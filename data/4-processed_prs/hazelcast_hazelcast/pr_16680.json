{"pr_number": 16680, "pr_title": "Handle network disconnections between slave nodes", "pr_createdAt": "2020-02-24T08:03:32Z", "pr_url": "https://github.com/hazelcast/hazelcast/pull/16680", "timeline": [{"oid": "59763510b62d43874e93e06c132ad1f5518ad502", "url": "https://github.com/hazelcast/hazelcast/commit/59763510b62d43874e93e06c132ad1f5518ad502", "message": "Cleanup the cluster service tests", "committedDate": "2020-02-17T09:32:22Z", "type": "commit"}, {"oid": "52e7a9692c465e0b72089fa7f9f0b08a0a8d654a", "url": "https://github.com/hazelcast/hazelcast/commit/52e7a9692c465e0b72089fa7f9f0b08a0a8d654a", "message": "Handle network disconnections between slave nodes\n\nIn Hazelcast IMDG 3.9, we improved the algorithms used in the cluster\nmanagement layer and resolved several problems. With that work, our member list\nmanagement logic procured a good set of consistency and safety guarantees.\nIn short, the master node manages the cluster member list and publishes member\nlist updates with version numbers. Other nodes apply these updates\nin the correct order by checking version numbers. In addition, each Hazelcast\nnode tracks the liveness of other nodes. The master node uses this mechanism to\ndetect failures of other nodes, and other nodes use this mechanism to detect\nfailure of the master node. This failure detection mechanism also works during\nnetwork partitions to help Hazelcast clusters split into multiple subclusters\nand remain available.\n\nHowever, there is a shortcoming in the current design. Even though each node\ntracks the liveliness of other nodes, they do not share their failure\ndetections with each other. Since the master node is the only authority to\nupdate the cluster member list, if there are network problems between slave\nnodes, the master node is not aware of these problems and does not update\nthe cluster member list. This situation can lead to data loss or availability\nproblems in the cluster.\n\nThe solution to this problem is two-fold. First, we make master nodes aware of\nnetwork problems that occur between slave nodes. It is sufficient for each\nslave node to propagate its failure detections to the master node because we\nalready have a good set of mechanisms and consistency guarantees built around\nthe decisions made by the master node. Second, the master node decides on\nan optimal cluster member list after it learns the network problems between\nother nodes.\n\nIn the first part of the solution, we make slave nodes propagate their\nsuspicions to the master node. We use the heartbeat mechanism for this purpose.\nSlave nodes piggyback their suspicions to the heartbeat messages sent to\nthe master node. The master node collects these suspicions and after some time\nit triggers the next step to decide on a new cluster member list.\n\nUsing this knowledge, the master node should decide on a new member list such\nthat all nodes in the new member list are connected to each other, i.e., there\nis no connection problem between the nodes in the new member list. This problem\nhas the same solution with the maximum clique problem in graph theory. A clique\nin an undirected graph is a subset of vertices which forms a complete graph,\ni.e, each vertex in a clique has an edge to every other vertex. A maximum\nclique is the largest clique that satisfies the given definition.\n\nWe use an implementation of the Bron\u2013Kerbosch algorithm to find the maximum\nclique of a Hazelcast cluster given a set of slave node suspicions. This\nalgorithm gives us the smallest set of Hazelcast nodes to kick so that\nthe remaining nodes in the cluster are fully connected to each other again.\nSo the master node kicks the nodes returned by the Bron-Kerbosch algorithm.", "committedDate": "2020-02-24T09:23:07Z", "type": "commit"}, {"oid": "52e7a9692c465e0b72089fa7f9f0b08a0a8d654a", "url": "https://github.com/hazelcast/hazelcast/commit/52e7a9692c465e0b72089fa7f9f0b08a0a8d654a", "message": "Handle network disconnections between slave nodes\n\nIn Hazelcast IMDG 3.9, we improved the algorithms used in the cluster\nmanagement layer and resolved several problems. With that work, our member list\nmanagement logic procured a good set of consistency and safety guarantees.\nIn short, the master node manages the cluster member list and publishes member\nlist updates with version numbers. Other nodes apply these updates\nin the correct order by checking version numbers. In addition, each Hazelcast\nnode tracks the liveness of other nodes. The master node uses this mechanism to\ndetect failures of other nodes, and other nodes use this mechanism to detect\nfailure of the master node. This failure detection mechanism also works during\nnetwork partitions to help Hazelcast clusters split into multiple subclusters\nand remain available.\n\nHowever, there is a shortcoming in the current design. Even though each node\ntracks the liveliness of other nodes, they do not share their failure\ndetections with each other. Since the master node is the only authority to\nupdate the cluster member list, if there are network problems between slave\nnodes, the master node is not aware of these problems and does not update\nthe cluster member list. This situation can lead to data loss or availability\nproblems in the cluster.\n\nThe solution to this problem is two-fold. First, we make master nodes aware of\nnetwork problems that occur between slave nodes. It is sufficient for each\nslave node to propagate its failure detections to the master node because we\nalready have a good set of mechanisms and consistency guarantees built around\nthe decisions made by the master node. Second, the master node decides on\nan optimal cluster member list after it learns the network problems between\nother nodes.\n\nIn the first part of the solution, we make slave nodes propagate their\nsuspicions to the master node. We use the heartbeat mechanism for this purpose.\nSlave nodes piggyback their suspicions to the heartbeat messages sent to\nthe master node. The master node collects these suspicions and after some time\nit triggers the next step to decide on a new cluster member list.\n\nUsing this knowledge, the master node should decide on a new member list such\nthat all nodes in the new member list are connected to each other, i.e., there\nis no connection problem between the nodes in the new member list. This problem\nhas the same solution with the maximum clique problem in graph theory. A clique\nin an undirected graph is a subset of vertices which forms a complete graph,\ni.e, each vertex in a clique has an edge to every other vertex. A maximum\nclique is the largest clique that satisfies the given definition.\n\nWe use an implementation of the Bron\u2013Kerbosch algorithm to find the maximum\nclique of a Hazelcast cluster given a set of slave node suspicions. This\nalgorithm gives us the smallest set of Hazelcast nodes to kick so that\nthe remaining nodes in the cluster are fully connected to each other again.\nSo the master node kicks the nodes returned by the Bron-Kerbosch algorithm.", "committedDate": "2020-02-24T09:23:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc4ODc0Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/16680#discussion_r383788747", "bodyText": "Leftover.", "author": "mdogan", "createdAt": "2020-02-25T10:25:35Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/util/graph/BronKerboschCliqueFinder.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+*  Original work Copyright (c) 2005-2020, by Ewgenij Proschak and Contributors.\n+ * Modified work Copyright (c) 2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.internal.util.graph;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+\n+public class BronKerboschCliqueFinder<V> {\n+\n+    private final Graph<V> graph;\n+    private final long nanos;\n+    private boolean timeLimitReached;\n+    private List<Set<V>> maximumCliques;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param graph   the input graph; must be simple\n+     * @param timeout the maximum time to wait, if zero no timeout\n+     * @param unit    the time unit of the timeout argument\n+     */\n+    public BronKerboschCliqueFinder(Graph<V> graph, long timeout, TimeUnit unit) {\n+        this.graph = Objects.requireNonNull(graph, \"Graph cannot be null\");\n+        if (timeout == 0L) {\n+            this.nanos = Long.MAX_VALUE;\n+        } else {\n+            this.nanos = unit.toNanos(timeout);\n+        }\n+        if (this.nanos < 1L) {\n+            throw new IllegalArgumentException(\"Invalid timeout, must be positive\");\n+        }\n+        this.timeLimitReached = false;\n+    }\n+\n+    /**\n+     * Constructs a new clique finder.\n+     *\n+     * @param graph the input graph; must be \"simple\".\n+     */\n+    public BronKerboschCliqueFinder(Graph<V> graph) {\n+        this(graph, 0L, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Computes and returns the maximum cliques of the given graph.\n+     *\n+     * @return the maximum cliques of the given graph.\n+     */\n+    public Collection<Set<V>> computeMaxCliques() {\n+        lazyRun();\n+        return maximumCliques;\n+    }\n+\n+    /**\n+     * Check the computation has stopped due to a time limit or due to computing all maximal\n+     * cliques.\n+     *\n+     * @return true if the computation has stopped due to a time limit, false otherwise\n+     */\n+    public boolean isTimeLimitReached() {\n+        return timeLimitReached;\n+    }\n+\n+    /**\n+     * Lazily execute the enumeration algorithm.\n+     */\n+    private void lazyRun() {\n+        if (maximumCliques != null) {\n+            return;\n+        }\n+\n+        maximumCliques = new ArrayList<>();\n+\n+        // [basri] Our Graph impl is already a simple graph.\n+        //            if (!GraphTests.isSimple(graph)) {\n+        //                throw new IllegalArgumentException(\"Graph must be simple\");\n+        //            }", "originalCommit": "52e7a9692c465e0b72089fa7f9f0b08a0a8d654a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc5MTI1Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/16680#discussion_r383791252", "bodyText": "Can you please add a few comments/javadoc on the class and update(), resolve() methods?", "author": "mdogan", "createdAt": "2020-02-25T10:29:48Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/cluster/impl/PartialDisconnectionHandler.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.internal.cluster.impl;\n+\n+import com.hazelcast.cluster.impl.MemberImpl;\n+import com.hazelcast.internal.util.graph.BronKerboschCliqueFinder;\n+import com.hazelcast.internal.util.graph.Graph;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static java.util.Collections.emptySet;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+\n+class PartialDisconnectionHandler {", "originalCommit": "52e7a9692c465e0b72089fa7f9f0b08a0a8d654a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc5MjEzOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16680#discussion_r383792139", "bodyText": "better to move lock() to outside of try { block...", "author": "mdogan", "createdAt": "2020-02-25T10:31:26Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/cluster/impl/MembershipManager.java", "diffHunk": "@@ -1200,12 +1242,87 @@ public boolean verifySplitBrainMergeMemberListVersion(SplitBrainJoinMessage join\n         }\n     }\n \n+    void handleReceivedSuspectedMembers(MemberImpl sender, long timestamp, Collection<MemberInfo> suspectedMemberInfos) {\n+        if (!validateReceivedSuspectedMembers(sender, suspectedMemberInfos)) {\n+            return;\n+        }\n+\n+        MemberMap memberMap = getMemberMap();\n+        List<MemberImpl> suspectedMembers = suspectedMemberInfos.stream()\n+                                                                .map(m -> memberMap.getMember(m.getAddress(), m.getUuid()))\n+                                                                .filter(Objects::nonNull)\n+                                                                .collect(toList());\n+\n+        if (partialDisconnectionHandler.update(sender, timestamp, suspectedMembers)) {\n+            logger.warning(\"Received suspected members: \" + suspectedMembers + \" from \" + sender);\n+            if (logger.isFineEnabled()) {\n+                for (Entry<MemberImpl, Set<MemberImpl>> e : partialDisconnectionHandler.getDisconnections().entrySet()) {\n+                    logger.fine(e.getKey() + \" is disconnected to: \" + e.getValue());\n+                }\n+            }\n+        }\n+    }\n+\n+    private boolean validateReceivedSuspectedMembers(MemberImpl sender, Collection<MemberInfo> suspectedMemberInfos) {\n+        if (!partialDisconnectionDetectionEnabled) {\n+            return false;\n+        } else if (!clusterService.isMaster()) {\n+            if (suspectedMemberInfos.size() > 0) {\n+                logger.severe(\"This not is not master but received suspected members: \" + suspectedMemberInfos + \" from \"\n+                        + sender);\n+            }\n+            return false;\n+        } else if (getLocalMember().equals(sender)) {\n+            logger.severe(\"Received suspected members: \" + suspectedMemberInfos + \" from itself.\");\n+            return false;\n+        } else if (suspectedMemberInfos.contains(new MemberInfo(getLocalMember()))) {\n+            logger.severe(\"Received suspected members: \" + suspectedMemberInfos + \" from \" + sender + \" contains this member!\");\n+            return false;\n+        } else if (clusterService.getClusterJoinManager().isMastershipClaimInProgress()) {\n+            if (suspectedMemberInfos.size() > 0 && logger.isFineEnabled()) {\n+                logger.warning(\"Ignoring received suspected members: \" + suspectedMemberInfos + \" from \" + sender\n+                        + \" because mastership claim is in progress...\");\n+            }\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    void checkPartialDisconnectivity(long timestamp) {\n+        if (!partialDisconnectionDetectionEnabled) {\n+            return;\n+        } else if (!clusterService.isMaster()) {\n+            logger.severe(\"Cannot check disconnected members since I am not the master.\");\n+            return;\n+        }\n+\n+        try {\n+            clusterServiceLock.lock();", "originalCommit": "52e7a9692c465e0b72089fa7f9f0b08a0a8d654a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc5Mjk0Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/16680#discussion_r383792942", "bodyText": "Are these really severe logs, or can we log them as warning?", "author": "mdogan", "createdAt": "2020-02-25T10:32:48Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/cluster/impl/MembershipManager.java", "diffHunk": "@@ -1200,12 +1242,87 @@ public boolean verifySplitBrainMergeMemberListVersion(SplitBrainJoinMessage join\n         }\n     }\n \n+    void handleReceivedSuspectedMembers(MemberImpl sender, long timestamp, Collection<MemberInfo> suspectedMemberInfos) {\n+        if (!validateReceivedSuspectedMembers(sender, suspectedMemberInfos)) {\n+            return;\n+        }\n+\n+        MemberMap memberMap = getMemberMap();\n+        List<MemberImpl> suspectedMembers = suspectedMemberInfos.stream()\n+                                                                .map(m -> memberMap.getMember(m.getAddress(), m.getUuid()))\n+                                                                .filter(Objects::nonNull)\n+                                                                .collect(toList());\n+\n+        if (partialDisconnectionHandler.update(sender, timestamp, suspectedMembers)) {\n+            logger.warning(\"Received suspected members: \" + suspectedMembers + \" from \" + sender);\n+            if (logger.isFineEnabled()) {\n+                for (Entry<MemberImpl, Set<MemberImpl>> e : partialDisconnectionHandler.getDisconnections().entrySet()) {\n+                    logger.fine(e.getKey() + \" is disconnected to: \" + e.getValue());\n+                }\n+            }\n+        }\n+    }\n+\n+    private boolean validateReceivedSuspectedMembers(MemberImpl sender, Collection<MemberInfo> suspectedMemberInfos) {\n+        if (!partialDisconnectionDetectionEnabled) {\n+            return false;\n+        } else if (!clusterService.isMaster()) {\n+            if (suspectedMemberInfos.size() > 0) {\n+                logger.severe(\"This not is not master but received suspected members: \" + suspectedMemberInfos + \" from \"", "originalCommit": "52e7a9692c465e0b72089fa7f9f0b08a0a8d654a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc5MzgwNA==", "url": "https://github.com/hazelcast/hazelcast/pull/16680#discussion_r383793804", "bodyText": "Can't we make just use Member as parameter, instead of Address and UUID pair?\nclearMemberSuspicion(MemberImpl member, String reason)", "author": "mdogan", "createdAt": "2020-02-25T10:34:23Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/cluster/impl/MembershipManager.java", "diffHunk": "@@ -456,27 +487,37 @@ void setMembers(MemberMap memberMap) {\n \n     // called under cluster service lock\n     private void retainSuspectedMembers(MemberMap memberMap) {\n-        Iterator<Address> it = suspectedMembers.iterator();\n+        Iterator<MemberImpl> it = suspectedMembers.iterator();\n         while (it.hasNext()) {\n-            Address suspectedAddress = it.next();\n-            if (!memberMap.contains(suspectedAddress)) {\n+            Member suspectedMember = it.next();\n+            if (memberMap.getMember(suspectedMember.getAddress(), suspectedMember.getUuid()) == null) {\n                 if (logger.isFineEnabled()) {\n-                    logger.fine(\"Removing suspected address \" + suspectedAddress + \", it's no longer a member.\");\n+                    logger.fine(\"Removing suspected address \" + suspectedMember.getAddress() + \", it's no longer a member.\");\n                 }\n \n                 it.remove();\n             }\n         }\n     }\n \n-    boolean isMemberSuspected(Address address) {\n-        return suspectedMembers.contains(address);\n+    Collection<MemberImpl> getSuspectedMembers() {\n+        return new HashSet<>(suspectedMembers);\n+    }\n+\n+    boolean isMemberSuspected(Address address, UUID uuid) {\n+        for (MemberImpl suspectedMember : suspectedMembers) {\n+            if (suspectedMember.getAddress().equals(address) && suspectedMember.getUuid().equals(uuid)) {\n+                return true;\n+            }\n+        }\n+\n+        return false;\n     }\n \n-    boolean clearMemberSuspicion(Address address, String reason) {\n+    boolean clearMemberSuspicion(Address address, UUID uuid, String reason) {", "originalCommit": "52e7a9692c465e0b72089fa7f9f0b08a0a8d654a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc5NDA4Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/16680#discussion_r383794082", "bodyText": "Can't we make just use Member as parameter, instead of Address and UUID pair?\nisMemberSuspected(MemberImpl member)", "author": "mdogan", "createdAt": "2020-02-25T10:34:54Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/cluster/impl/MembershipManager.java", "diffHunk": "@@ -456,27 +487,37 @@ void setMembers(MemberMap memberMap) {\n \n     // called under cluster service lock\n     private void retainSuspectedMembers(MemberMap memberMap) {\n-        Iterator<Address> it = suspectedMembers.iterator();\n+        Iterator<MemberImpl> it = suspectedMembers.iterator();\n         while (it.hasNext()) {\n-            Address suspectedAddress = it.next();\n-            if (!memberMap.contains(suspectedAddress)) {\n+            Member suspectedMember = it.next();\n+            if (memberMap.getMember(suspectedMember.getAddress(), suspectedMember.getUuid()) == null) {\n                 if (logger.isFineEnabled()) {\n-                    logger.fine(\"Removing suspected address \" + suspectedAddress + \", it's no longer a member.\");\n+                    logger.fine(\"Removing suspected address \" + suspectedMember.getAddress() + \", it's no longer a member.\");\n                 }\n \n                 it.remove();\n             }\n         }\n     }\n \n-    boolean isMemberSuspected(Address address) {\n-        return suspectedMembers.contains(address);\n+    Collection<MemberImpl> getSuspectedMembers() {\n+        return new HashSet<>(suspectedMembers);\n+    }\n+\n+    boolean isMemberSuspected(Address address, UUID uuid) {", "originalCommit": "52e7a9692c465e0b72089fa7f9f0b08a0a8d654a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc5NTEzMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16680#discussion_r383795131", "bodyText": "getMissingMembers() returns mutable collection now?", "author": "mdogan", "createdAt": "2020-02-25T10:36:45Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/cluster/impl/MembershipManager.java", "diffHunk": "@@ -986,7 +1029,7 @@ MemberImpl getMissingMember(Address address, UUID uuid) {\n      * Returns all missing members.\n      */\n     Collection<MemberImpl> getMissingMembers() {\n-        return Collections.unmodifiableCollection(missingMembersRef.get().values());\n+        return missingMembersRef.get().values();", "originalCommit": "52e7a9692c465e0b72089fa7f9f0b08a0a8d654a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMwMzgzOA==", "url": "https://github.com/hazelcast/hazelcast/pull/16680#discussion_r384303838", "bodyText": "we always set immutable map to it. So I removed the immutable decoration here.", "author": "metanet", "createdAt": "2020-02-26T06:59:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc5NTEzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMwOTAzNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16680#discussion_r384309035", "bodyText": "ah I got it... \ud83e\udd26\u200d\u2642", "author": "mdogan", "createdAt": "2020-02-26T07:16:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc5NTEzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc5NzUwOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16680#discussion_r383797509", "bodyText": "Is this really an illegal state: IllegalStateException ?  maybe something like TimeoutException would be better..", "author": "mdogan", "createdAt": "2020-02-25T10:41:06Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/cluster/impl/PartialDisconnectionHandler.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.internal.cluster.impl;\n+\n+import com.hazelcast.cluster.impl.MemberImpl;\n+import com.hazelcast.internal.util.graph.BronKerboschCliqueFinder;\n+import com.hazelcast.internal.util.graph.Graph;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static java.util.Collections.emptySet;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+\n+class PartialDisconnectionHandler {\n+    private final long detectionIntervalMs;\n+    private final long algorithmTimeoutMs;\n+    private Map<MemberImpl, Set<MemberImpl>> disconnections = new HashMap<>();\n+    private long lastUpdated;\n+\n+    PartialDisconnectionHandler(long detectionIntervalMs, long algorithmTimeoutMs) {\n+        this.detectionIntervalMs = detectionIntervalMs;\n+        this.algorithmTimeoutMs = algorithmTimeoutMs;\n+    }\n+\n+    boolean update(MemberImpl member, long timestamp, Collection<MemberImpl> disconnectedMembers) {\n+        if (timestamp < lastUpdated) {\n+            return false;\n+        }\n+\n+        Set<MemberImpl> currentDisconnectedMembers =  disconnections.get(member);\n+        if (currentDisconnectedMembers == null) {\n+            if (disconnectedMembers.isEmpty()) {\n+                return false;\n+            }\n+\n+            currentDisconnectedMembers = new HashSet<>();\n+            disconnections.put(member, currentDisconnectedMembers);\n+        }\n+\n+        boolean updated = false;\n+\n+        for (MemberImpl disconnectedMember : disconnectedMembers) {\n+            if (currentDisconnectedMembers.add(disconnectedMember)\n+                    && !disconnections.getOrDefault(disconnectedMember, emptySet()).contains(member)) {\n+                lastUpdated = timestamp;\n+                updated = true;\n+            }\n+        }\n+\n+        if (currentDisconnectedMembers.retainAll(disconnectedMembers)) {\n+            lastUpdated = timestamp;\n+            updated = true;\n+        }\n+\n+        if (currentDisconnectedMembers.isEmpty()) {\n+            disconnections.remove(member);\n+        }\n+\n+        return updated;\n+    }\n+\n+    boolean shouldResolvePartialDisconnections(long timestamp) {\n+        return !disconnections.isEmpty() && timestamp - lastUpdated >= detectionIntervalMs;\n+    }\n+\n+    Collection<MemberImpl> resolve(Map<MemberImpl, Set<MemberImpl>> disconnections) {\n+        Set<MemberImpl> members = new HashSet<>();\n+        disconnections.forEach((k, v) -> {\n+            members.add(k);\n+            members.addAll(v);\n+        });\n+\n+        Graph<MemberImpl> connectivityGraph = buildConnectionGraph(members, disconnections);\n+        BronKerboschCliqueFinder<MemberImpl> cliqueFinder = createCliqueFinder(connectivityGraph);\n+        Collection<Set<MemberImpl>> maxCliques = cliqueFinder.computeMaxCliques();\n+\n+        if (cliqueFinder.isTimeLimitReached()) {\n+            throw new IllegalStateException(\"Partial disconnection resolution algorithm timed out! disconnectivity map: \"", "originalCommit": "52e7a9692c465e0b72089fa7f9f0b08a0a8d654a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc5ODkzMg==", "url": "https://github.com/hazelcast/hazelcast/pull/16680#discussion_r383798932", "bodyText": "Shouldn't we filter out algorithm timeout? Due to my understanding, this is not always a severe failure...", "author": "mdogan", "createdAt": "2020-02-25T10:43:36Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/cluster/impl/MembershipManager.java", "diffHunk": "@@ -1268,5 +1385,48 @@ private void innerRun() {\n             }\n         }\n     }\n+\n+    private class ResolvePartialDisconnectionsTask\n+            implements Runnable {\n+\n+        final Map<MemberImpl, Set<MemberImpl>> disconnections;\n+\n+        ResolvePartialDisconnectionsTask(Map<MemberImpl, Set<MemberImpl>> disconnections) {\n+            this.disconnections = disconnections;\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                Collection<MemberImpl> membersToRemove = partialDisconnectionHandler.resolve(disconnections);\n+                clusterServiceLock.lock();\n+                try {\n+                    for (MemberImpl member : membersToRemove) {\n+                        if (getMember(member.getAddress(), member.getUuid()) == null) {\n+                            logger.warning(\"Won't remove partially disconnected members: \" + membersToRemove);\n+                            return;\n+                        }\n+                    }\n+\n+                    for (MemberImpl member : membersToRemove) {\n+                        String reason = format(\"Removing %s because it has disconnected from some of the members!\", member);\n+                        logger.warning(reason);\n+                        suspectMember(member, reason, true);\n+                    }\n+                } finally {\n+                    clusterServiceLock.unlock();\n+                }\n+            } catch (Exception e) {\n+                logger.severe(\"Partial disconnection resolution algorithm failed.\", e);", "originalCommit": "52e7a9692c465e0b72089fa7f9f0b08a0a8d654a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzgyOTk1Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/16680#discussion_r383829956", "bodyText": "Is it legitimate to see null master here? if yes, this change can lead NPE.", "author": "ahmetmircik", "createdAt": "2020-02-25T11:47:07Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/cluster/impl/ClusterHeartbeatManager.java", "diffHunk": "@@ -274,14 +282,14 @@ private void onInvalidHeartbeat(MembersViewMetadata senderMembersViewMetadata) {\n                 clusterService.sendExplicitSuspicion(senderMembersViewMetadata);\n             }\n         } else {\n-            Address masterAddress = clusterService.getMasterAddress();\n-            if (clusterService.getMembershipManager().isMemberSuspected(masterAddress)) {\n+            MemberImpl master = clusterService.getMember(clusterService.getMasterAddress());", "originalCommit": "52e7a9692c465e0b72089fa7f9f0b08a0a8d654a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMzMjEyOA==", "url": "https://github.com/hazelcast/hazelcast/pull/16680#discussion_r384332128", "bodyText": "this method is called under the cluster service lock when the member has joined to the cluster. Because if this, master cannot be null here I think.", "author": "metanet", "createdAt": "2020-02-26T08:20:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzgyOTk1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzgzMjM3NA==", "url": "https://github.com/hazelcast/hazelcast/pull/16680#discussion_r383832374", "bodyText": "minor:\ncan be rewritten without else:\nCollection<MemberInfo> suspectedMembers = Collections.emptySet();\nif (clusterService.getMembershipManager().isPartialDisconnectionDetectionEnabled()\n                    && !clusterService.isMaster() && target.getAddress().equals(clusterService.getMasterAddress())) {\n                suspectedMembers = clusterService.getMembershipManager()\n                        .getSuspectedMembers()\n                        .stream()\n                        .map(MemberInfo::new)\n                        .collect(toSet());\n}", "author": "ahmetmircik", "createdAt": "2020-02-25T11:52:42Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/cluster/impl/ClusterHeartbeatManager.java", "diffHunk": "@@ -610,7 +618,20 @@ private void sendHeartbeat(Member target) {\n         }\n         try {\n             MembersViewMetadata membersViewMetadata = clusterService.getMembershipManager().createLocalMembersViewMetadata();\n-            Operation op = new HeartbeatOp(membersViewMetadata, target.getUuid(), clusterClock.getClusterTime());\n+            Collection<MemberInfo> suspectedMembers;\n+            if (clusterService.getMembershipManager().isPartialDisconnectionDetectionEnabled()\n+                    && !clusterService.isMaster() && target.getAddress().equals(clusterService.getMasterAddress())) {\n+                suspectedMembers = clusterService.getMembershipManager()\n+                                                 .getSuspectedMembers()\n+                                                 .stream()\n+                                                 .map(MemberInfo::new)\n+                                                 .collect(toSet());\n+            } else {\n+                suspectedMembers = Collections.emptySet();\n+            }", "originalCommit": "52e7a9692c465e0b72089fa7f9f0b08a0a8d654a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzgzODcxNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16680#discussion_r383838715", "bodyText": "Type of currentDisconnectedMembers  is a Set, as i understand it is because same MemberImpl can be added multiple times?", "author": "ahmetmircik", "createdAt": "2020-02-25T12:06:53Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/cluster/impl/PartialDisconnectionHandler.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.internal.cluster.impl;\n+\n+import com.hazelcast.cluster.impl.MemberImpl;\n+import com.hazelcast.internal.util.graph.BronKerboschCliqueFinder;\n+import com.hazelcast.internal.util.graph.Graph;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static java.util.Collections.emptySet;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+\n+class PartialDisconnectionHandler {\n+    private final long detectionIntervalMs;\n+    private final long algorithmTimeoutMs;\n+    private Map<MemberImpl, Set<MemberImpl>> disconnections = new HashMap<>();\n+    private long lastUpdated;\n+\n+    PartialDisconnectionHandler(long detectionIntervalMs, long algorithmTimeoutMs) {\n+        this.detectionIntervalMs = detectionIntervalMs;\n+        this.algorithmTimeoutMs = algorithmTimeoutMs;\n+    }\n+\n+    boolean update(MemberImpl member, long timestamp, Collection<MemberImpl> disconnectedMembers) {\n+        if (timestamp < lastUpdated) {\n+            return false;\n+        }\n+\n+        Set<MemberImpl> currentDisconnectedMembers =  disconnections.get(member);\n+        if (currentDisconnectedMembers == null) {\n+            if (disconnectedMembers.isEmpty()) {\n+                return false;\n+            }\n+\n+            currentDisconnectedMembers = new HashSet<>();\n+            disconnections.put(member, currentDisconnectedMembers);\n+        }\n+\n+        boolean updated = false;\n+\n+        for (MemberImpl disconnectedMember : disconnectedMembers) {\n+            if (currentDisconnectedMembers.add(disconnectedMember)", "originalCommit": "52e7a9692c465e0b72089fa7f9f0b08a0a8d654a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzgzOTM3Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/16680#discussion_r383839377", "bodyText": "can you please add javaDoc for returned boolean?", "author": "ahmetmircik", "createdAt": "2020-02-25T12:08:22Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/cluster/impl/ClusterHeartbeatManager.java", "diffHunk": "@@ -371,9 +379,9 @@ public void handleHeartbeatComplaint(MembersViewMetadata receiverMVMetadata, Mem\n      * @param member    the member sending the heartbeat\n      * @param timestamp the timestamp when the heartbeat was created\n      */\n-    public void onHeartbeat(MemberImpl member, long timestamp) {\n+    public boolean onHeartbeat(MemberImpl member, long timestamp) {", "originalCommit": "52e7a9692c465e0b72089fa7f9f0b08a0a8d654a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg0Mzg2MA==", "url": "https://github.com/hazelcast/hazelcast/pull/16680#discussion_r383843860", "bodyText": "Can we encapsulate these prop readings into PartialDisconnectionHandler to increase isolation?", "author": "ahmetmircik", "createdAt": "2020-02-25T12:18:38Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/cluster/impl/MembershipManager.java", "diffHunk": "@@ -112,7 +125,25 @@\n         this.nodeEngine = node.getNodeEngine();\n         this.logger = node.getLogger(getClass());\n \n-        mastershipClaimTimeoutSeconds = node.getProperties().getInteger(MASTERSHIP_CLAIM_TIMEOUT_SECONDS);\n+        this.mastershipClaimTimeoutSeconds = node.getProperties().getInteger(MASTERSHIP_CLAIM_TIMEOUT_SECONDS);\n+\n+        int partialDisconnectionResolutionHeartbeatCount = node.getProperties().getInteger(\n+                PARTIAL_MEMBER_DISCONNECTION_RESOLUTION_HEARTBEAT_COUNT);\n+        this.partialDisconnectionDetectionEnabled = partialDisconnectionResolutionHeartbeatCount > 0;\n+        long heartbeatIntervalMs = SECONDS.toMillis(node.getProperties().getInteger(HEARTBEAT_INTERVAL_SECONDS));\n+        long partialDisconnectivityDetectionIntervalMs =\n+                partialDisconnectionResolutionHeartbeatCount * heartbeatIntervalMs;\n+        long heartbeatTimeoutMs = SECONDS.toMillis(node.getProperties().getInteger(MAX_NO_HEARTBEAT_SECONDS));\n+\n+        if (!partialDisconnectionDetectionEnabled) {\n+            partialDisconnectivityDetectionIntervalMs = Long.MAX_VALUE;\n+        } else if (heartbeatTimeoutMs < partialDisconnectivityDetectionIntervalMs) {\n+            partialDisconnectivityDetectionIntervalMs = heartbeatTimeoutMs;\n+        }\n+\n+        this.partialDisconnectionHandler = new PartialDisconnectionHandler(partialDisconnectivityDetectionIntervalMs,", "originalCommit": "52e7a9692c465e0b72089fa7f9f0b08a0a8d654a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg0NTM4MA==", "url": "https://github.com/hazelcast/hazelcast/pull/16680#discussion_r383845380", "bodyText": "timeout zero seems a special value for infinity, if it is possible to eliminate it, code may be clearer.", "author": "ahmetmircik", "createdAt": "2020-02-25T12:22:03Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/util/graph/BronKerboschCliqueFinder.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+*  Original work Copyright (c) 2005-2020, by Ewgenij Proschak and Contributors.\n+ * Modified work Copyright (c) 2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.internal.util.graph;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+\n+public class BronKerboschCliqueFinder<V> {\n+\n+    private final Graph<V> graph;\n+    private final long nanos;\n+    private boolean timeLimitReached;\n+    private List<Set<V>> maximumCliques;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param graph   the input graph; must be simple\n+     * @param timeout the maximum time to wait, if zero no timeout\n+     * @param unit    the time unit of the timeout argument\n+     */\n+    public BronKerboschCliqueFinder(Graph<V> graph, long timeout, TimeUnit unit) {\n+        this.graph = Objects.requireNonNull(graph, \"Graph cannot be null\");\n+        if (timeout == 0L) {", "originalCommit": "52e7a9692c465e0b72089fa7f9f0b08a0a8d654a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "dbe903d833070448deb4a93d34da6440fe37321a", "url": "https://github.com/hazelcast/hazelcast/commit/dbe903d833070448deb4a93d34da6440fe37321a", "message": "Address review comments", "committedDate": "2020-02-26T11:46:47Z", "type": "commit"}, {"oid": "dbe903d833070448deb4a93d34da6440fe37321a", "url": "https://github.com/hazelcast/hazelcast/commit/dbe903d833070448deb4a93d34da6440fe37321a", "message": "Address review comments", "committedDate": "2020-02-26T11:46:47Z", "type": "forcePushed"}]}