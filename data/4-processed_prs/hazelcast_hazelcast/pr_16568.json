{"pr_number": 16568, "pr_title": "Null support for InPredicate", "pr_createdAt": "2020-01-28T12:36:12Z", "pr_url": "https://github.com/hazelcast/hazelcast/pull/16568", "timeline": [{"oid": "d53b1c62f286585a67646e683c0cb01368964f53", "url": "https://github.com/hazelcast/hazelcast/commit/d53b1c62f286585a67646e683c0cb01368964f53", "message": "Support nulls for InPredicate\n\nFixes: https://github.com/hazelcast/hazelcast/issues/15100", "committedDate": "2020-01-29T10:48:44Z", "type": "commit"}, {"oid": "6357173cf8965dcb7bb9bb7a1b6232e974f2b365", "url": "https://github.com/hazelcast/hazelcast/commit/6357173cf8965dcb7bb9bb7a1b6232e974f2b365", "message": "make checkstyle happy", "committedDate": "2020-01-29T10:48:44Z", "type": "commit"}, {"oid": "6357173cf8965dcb7bb9bb7a1b6232e974f2b365", "url": "https://github.com/hazelcast/hazelcast/commit/6357173cf8965dcb7bb9bb7a1b6232e974f2b365", "message": "make checkstyle happy", "committedDate": "2020-01-29T10:48:44Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM0MDQ2Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/16568#discussion_r372340466", "bodyText": "What if an IN (null) predicate is applied to a sequences of attribute values, where the first one is non-null and the second is null? The first call will result in initialising set which will cause the second iteration to use set.contains() - shouldn't it use isNull() for null items in the set?", "author": "vojtechtoman", "createdAt": "2020-01-29T11:56:11Z", "path": "hazelcast/src/main/java/com/hazelcast/query/impl/predicates/InPredicate.java", "diffHunk": "@@ -68,11 +69,23 @@ public Predicate accept(Visitor visitor, Indexes indexes) {\n \n     @Override\n     protected boolean applyForSingleAttributeValue(Comparable attributeValue) {\n-        if (attributeValue == null) {\n+        Set<Comparable> set = convertedInValues;\n+\n+        if (attributeValue == null && set == null) {", "originalCommit": "d53b1c62f286585a67646e683c0cb01368964f53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM0NTM5Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/16568#discussion_r372345392", "bodyText": "Good point, fixing...", "author": "taburet", "createdAt": "2020-01-29T12:07:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM0MDQ2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4NjE0Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/16568#discussion_r372386147", "bodyText": "As it turned out, isNull is not really required here, == null is enough. AbstractIndex.NULL is produced while downgrading from index-based evaluation, see CompositeEqualPredicate.apply for instance, but there is no such downgrading for InPredicate. But still I decided to keep it for consistency with other predicates and added null normalization: 8c9f5a3", "author": "taburet", "createdAt": "2020-01-29T13:39:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM0MDQ2Ng=="}], "type": "inlineReview"}, {"oid": "8c9f5a38e71587f5dcf1d1bdd0779932da92e753", "url": "https://github.com/hazelcast/hazelcast/commit/8c9f5a38e71587f5dcf1d1bdd0779932da92e753", "message": "normalize nulls", "committedDate": "2020-01-29T13:33:53Z", "type": "commit"}, {"oid": "514360e39f2303f42b4e77928f9c738edf08b32b", "url": "https://github.com/hazelcast/hazelcast/commit/514360e39f2303f42b4e77928f9c738edf08b32b", "message": "remove unused import", "committedDate": "2020-01-29T13:44:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc3NTY1Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/16568#discussion_r372775653", "bodyText": "MInor comment: the presence of null values could be cached in a separate Boolean variable so that \"brute force\" is needed at most once.", "author": "devozerov", "createdAt": "2020-01-30T06:19:53Z", "path": "hazelcast/src/main/java/com/hazelcast/query/impl/predicates/InPredicate.java", "diffHunk": "@@ -68,15 +69,32 @@ public Predicate accept(Visitor visitor, Indexes indexes) {\n \n     @Override\n     protected boolean applyForSingleAttributeValue(Comparable attributeValue) {\n-        if (attributeValue == null) {\n+        Set<Comparable> set = convertedInValues;\n+\n+        if (attributeValue == null && set == null) {\n+            // Conversion of the values given to the predicate is possible only\n+            // if the passed attribute value is non-null, otherwise we are\n+            // unable to infer a proper converter. Postpone the conversion and\n+            // do a brute-force comparison.\n+\n+            for (Comparable value : values) {", "originalCommit": "514360e39f2303f42b4e77928f9c738edf08b32b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg1NDM0MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16568#discussion_r372854341", "bodyText": "Fixed in ba8d175", "author": "taburet", "createdAt": "2020-01-30T09:58:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc3NTY1Mw=="}], "type": "inlineReview"}, {"oid": "ba8d175a844082f6ca40c8c4391e8caf156bb54d", "url": "https://github.com/hazelcast/hazelcast/commit/ba8d175a844082f6ca40c8c4391e8caf156bb54d", "message": "optimize null comparison", "committedDate": "2020-01-30T09:53:25Z", "type": "commit"}]}