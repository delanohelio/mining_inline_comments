{"pr_number": 17640, "pr_title": "Add expressions design document", "pr_createdAt": "2020-09-29T10:55:49Z", "pr_url": "https://github.com/hazelcast/hazelcast/pull/17640", "timeline": [{"oid": "003bc188d2699b6b88a70768187e8e0ad56d0df2", "url": "https://github.com/hazelcast/hazelcast/commit/003bc188d2699b6b88a70768187e8e0ad56d0df2", "message": "Add expressions design document", "committedDate": "2020-09-29T10:47:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzMyMTY1Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17640#discussion_r497321652", "bodyText": "Expressions are", "author": "viliam-durina", "createdAt": "2020-09-30T08:10:20Z", "path": "docs/design/sql/08-expressions.md", "diffHunk": "@@ -0,0 +1,192 @@\n+# SQL Expressions\n+\n+## Overview\n+\n+Expressions is one of the core elements of every SQL implementation.", "originalCommit": "003bc188d2699b6b88a70768187e8e0ad56d0df2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODY0ODY5Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17640#discussion_r498648692", "bodyText": "fixed in d1d2929", "author": "taburet", "createdAt": "2020-10-02T07:08:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzMyMTY1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzMyMjU4Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17640#discussion_r497322586", "bodyText": "What are type expressions?", "author": "viliam-durina", "createdAt": "2020-09-30T08:11:52Z", "path": "docs/design/sql/08-expressions.md", "diffHunk": "@@ -0,0 +1,192 @@\n+# SQL Expressions\n+\n+## Overview\n+\n+Expressions is one of the core elements of every SQL implementation.\n+Expressions can participate in projections (`SELECT a + b FROM t`) and\n+filters (`SELECT * FROM t WHERE a + b < 10`). Expressions may be roughly\n+subdivided into 4 general categories:\n+\n+- Terminal expressions not referring to other expressions: column,\n+  literal, parameter and type expressions.", "originalCommit": "003bc188d2699b6b88a70768187e8e0ad56d0df2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODY0OTI0MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17640#discussion_r498649241", "bodyText": "CAST(1 AS INT), INT is referring to a type, clarified in d1d2929", "author": "taburet", "createdAt": "2020-10-02T07:09:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzMyMjU4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODY1NjE0Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17640#discussion_r498656142", "bodyText": "But these can refer to other expressions, cant' they? You can do CAST(1+column1+UPPER(col2)) as INT. So they don't belong to this category.", "author": "viliam-durina", "createdAt": "2020-10-02T07:27:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzMyMjU4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODY3NzAzMA==", "url": "https://github.com/hazelcast/hazelcast/pull/17640#discussion_r498677030", "bodyText": "I meant the INT part itself, it provides a reference to a type in expressions, in Calcite it's represented as SqlIdentifier which is a subclass of SqlNode, so it's a regular AST node.", "author": "taburet", "createdAt": "2020-10-02T08:13:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzMyMjU4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODY4OTkwNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17640#discussion_r498689906", "bodyText": "Makes sense this way, I never thought of the INT as of a type expression. I'll suggest an alternative text to current version though.", "author": "viliam-durina", "createdAt": "2020-10-02T08:39:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzMyMjU4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzMyNzQwMw==", "url": "https://github.com/hazelcast/hazelcast/pull/17640#discussion_r497327403", "bodyText": "Colon at the end?", "author": "viliam-durina", "createdAt": "2020-09-30T08:19:44Z", "path": "docs/design/sql/08-expressions.md", "diffHunk": "@@ -0,0 +1,192 @@\n+# SQL Expressions\n+\n+## Overview\n+\n+Expressions is one of the core elements of every SQL implementation.\n+Expressions can participate in projections (`SELECT a + b FROM t`) and\n+filters (`SELECT * FROM t WHERE a + b < 10`). Expressions may be roughly\n+subdivided into 4 general categories:\n+\n+- Terminal expressions not referring to other expressions: column,\n+  literal, parameter and type expressions.\n+- Operators, like numeric arithmetic operators: `+`, `-`, etc.\n+- Predicates, like comparison predicates: `<`, `>`, etc.\n+- Functions, like `ABS`, `SIN`, etc.\n+\n+## Implementation Details\n+\n+We use facilities provided by Calcite to support expression parsing and\n+validation. Every SQL expression goes through the following stages:\n+\n+- Parsing\n+- Validation\n+- Conversion\n+- Translation\n+- Evaluation\n+\n+### Parsing Stage\n+\n+The goal of the parsing stage is to obtain an AST expression\n+representation from the textual expression representation for\n+syntactically valid constructs and report errors for invalid ones. For\n+instance, `a + b` is syntactically valid and `a +` is invalid.\n+\n+In Calcite, AST nodes are represented as subclasses of `SqlNode`. Column\n+and type references are represented by `SqlIdentifier`. Literals are\n+represented by `SqlLiteral` and its subclasses. Parameters are\n+represented by `SqlDynamicParam`. Most other, if not all, expressions\n+are subclasses of `SqlCall`.\n+\n+### Validation Stage\n+\n+The goal of the validation stage is to make sure that the AST\n+expressions produced by the previous parsing stage are semantically\n+valid. For instance, `1 + 1` is semantically valid while `1 + true` is\n+not.\n+\n+In Calcite, the validation logic is encapsulated and orchestrated by\n+implementations of `SqlValidator`. Specifically, `SqlValidatorImpl`\n+extended by `HazelcastSqlValidator` is used to customize the validation\n+logic to align it with our requirements.\n+\n+As a first step of the validation process, `SqlValidatorImpl` may apply\n+some transformations to the passed AST which should not affect the\n+semantics of the AST. Such transformations are called \"unconditional\n+rewrites\" (see `SqlValidatorImpl.performUnconditionalRewrites`). Every\n+`SqlCall` node has an associated `SqlOperator` returned by its\n+`getOperator` method. `SqlOperator` implementations may customize\n+various aspects of a certain operator including the rewriting behavior\n+itself (see `SqlOperator.rewriteCall`).\n+\n+Normally, Calcite's parser inspects the hardcoded `SqlStdOperatorTable`\n+implementation of `SqlOperatorTable` to resolve a certain operator, so\n+it's hard to customize the pre-existing operators. To make the\n+customization possible, operators from `SqlStdOperatorTable` are patched\n+to the ones from `HazelcastSqlOperatorTable` during the AST rewriting\n+process (see `HazelcastSqlValidator.performUnconditionalRewrites` and\n+`HazelcastOperatorTableVisitor`).\n+\n+Usually, semantic validation requires assigning types to every\n+expression and its operand expressions, if any. In Calcite, that type\n+assignment behavior may be customized in several ways:\n+\n+- `SqlValidator.deriveType` may customize the behavior globally.\n+\n+- Each `SqlOperator` implementation may customize its operand type\n+  inference strategy (see `SqlOperandTypeInference` and\n+  `SqlOperator.getOperandTypeInference`) and its return type inference\n+  strategy (see `SqlReturnTypeInference`,\n+  `SqlOperator.getReturnTypeInference` and\n+  `SqlOperator.inferReturnType`). The first one is used only if some of\n+  the operand types are unknown. Also, operand type validation strategy\n+  can be customized using an associated `SqlOperandTypeChecker` (see\n+  `SqlOperator.getOperandTypeChecker`).\n+\n+- Additionally, some expressions require their operands to be coerced to\n+  a certain type. For instance, `=` operator requires both of its sides\n+  to be of the same type. In Calcite, such coercion services are\n+  provided by `TypeCoercion` implementations. Specifically,\n+  `TypeCoercionImpl` extended by `HazelcastTypeCoercion` is used to\n+  customize the coercion logic.\n+\n+The following general rules apply when assigning types:\n+\n+- Literals: `TRUE` and `FALSE` literals receive `BOOLEAN` type; numeric\n+  literals containing no decimal point (`1`, `42`, etc.) receive the\n+  smallest integer type possible (`TINYINT`, `SMALLINT`, `INTEGER` or\n+  `BIGINT`); numeric literals containing decimal point (`1.1`, `4.2`,\n+  etc.) receive `DECIMAL` type; scientific notation numeric literals\n+  (`1e1`, `4.2e2`, etc.) receive `DOUBLE` type; string literals\n+  (`'foo'`) receive `VARCHAR` type.\n+\n+- Parameters: parameter types are inferred from the context: `1.0 + ?`,\n+  the parameter would receive `DOUBLE` type.\n+\n+As an end result, for semantically valid ASTs, the validation process\n+produces a potentially transformed AST where every node has a known\n+type. For semantically invalid ASTs, an error is reported.\n+\n+### Conversion Stage\n+\n+The goal of the conversion stage it to convert the syntactically and\n+semantically valid AST (`SqlNode`) received from the previous stages to\n+a representation suitable for the relational optimization. In Calcite,\n+relational nodes are represented by subclasses of `RelNode` while\n+expression nodes referenced from relational ones are represented by\n+subclasses of `RexNode`.\n+\n+During conversion Calcite also applies various simplifications and\n+optimizations to expressions (see `SqlToRelConverter` and\n+`HazelcastSqlToRelConverter`). After the conversion all references to\n+the original textual SQL query representation are irreversibly lost. In\n+other words, it's impossible to recover a `SqlNode` from a certain\n+`RexNode` or `RelNode`.\n+\n+The resulting expressions may also undergo various transformations as\n+dictated by relational optimizations applied in other parts of the SQL\n+engine.\n+\n+### Translation Stage\n+\n+The goal of the translation phase is to translate the `RexNode`\n+representation received from the previous stage to a representation\n+suitable for the runtime evaluation of expressions.\n+\n+The translation is performed by `RexToExpressionVisitor` with the help\n+of `RexToExpression`. Every instance of `RexNode` is translated into a\n+corresponding `Expression` instance:", "originalCommit": "003bc188d2699b6b88a70768187e8e0ad56d0df2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODY0OTM3Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17640#discussion_r498649372", "bodyText": "fixed in d1d2929", "author": "taburet", "createdAt": "2020-10-02T07:09:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzMyNzQwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzMyNzYzOA==", "url": "https://github.com/hazelcast/hazelcast/pull/17640#discussion_r497327638", "bodyText": "No further changes are", "author": "viliam-durina", "createdAt": "2020-09-30T08:20:05Z", "path": "docs/design/sql/08-expressions.md", "diffHunk": "@@ -0,0 +1,192 @@\n+# SQL Expressions\n+\n+## Overview\n+\n+Expressions is one of the core elements of every SQL implementation.\n+Expressions can participate in projections (`SELECT a + b FROM t`) and\n+filters (`SELECT * FROM t WHERE a + b < 10`). Expressions may be roughly\n+subdivided into 4 general categories:\n+\n+- Terminal expressions not referring to other expressions: column,\n+  literal, parameter and type expressions.\n+- Operators, like numeric arithmetic operators: `+`, `-`, etc.\n+- Predicates, like comparison predicates: `<`, `>`, etc.\n+- Functions, like `ABS`, `SIN`, etc.\n+\n+## Implementation Details\n+\n+We use facilities provided by Calcite to support expression parsing and\n+validation. Every SQL expression goes through the following stages:\n+\n+- Parsing\n+- Validation\n+- Conversion\n+- Translation\n+- Evaluation\n+\n+### Parsing Stage\n+\n+The goal of the parsing stage is to obtain an AST expression\n+representation from the textual expression representation for\n+syntactically valid constructs and report errors for invalid ones. For\n+instance, `a + b` is syntactically valid and `a +` is invalid.\n+\n+In Calcite, AST nodes are represented as subclasses of `SqlNode`. Column\n+and type references are represented by `SqlIdentifier`. Literals are\n+represented by `SqlLiteral` and its subclasses. Parameters are\n+represented by `SqlDynamicParam`. Most other, if not all, expressions\n+are subclasses of `SqlCall`.\n+\n+### Validation Stage\n+\n+The goal of the validation stage is to make sure that the AST\n+expressions produced by the previous parsing stage are semantically\n+valid. For instance, `1 + 1` is semantically valid while `1 + true` is\n+not.\n+\n+In Calcite, the validation logic is encapsulated and orchestrated by\n+implementations of `SqlValidator`. Specifically, `SqlValidatorImpl`\n+extended by `HazelcastSqlValidator` is used to customize the validation\n+logic to align it with our requirements.\n+\n+As a first step of the validation process, `SqlValidatorImpl` may apply\n+some transformations to the passed AST which should not affect the\n+semantics of the AST. Such transformations are called \"unconditional\n+rewrites\" (see `SqlValidatorImpl.performUnconditionalRewrites`). Every\n+`SqlCall` node has an associated `SqlOperator` returned by its\n+`getOperator` method. `SqlOperator` implementations may customize\n+various aspects of a certain operator including the rewriting behavior\n+itself (see `SqlOperator.rewriteCall`).\n+\n+Normally, Calcite's parser inspects the hardcoded `SqlStdOperatorTable`\n+implementation of `SqlOperatorTable` to resolve a certain operator, so\n+it's hard to customize the pre-existing operators. To make the\n+customization possible, operators from `SqlStdOperatorTable` are patched\n+to the ones from `HazelcastSqlOperatorTable` during the AST rewriting\n+process (see `HazelcastSqlValidator.performUnconditionalRewrites` and\n+`HazelcastOperatorTableVisitor`).\n+\n+Usually, semantic validation requires assigning types to every\n+expression and its operand expressions, if any. In Calcite, that type\n+assignment behavior may be customized in several ways:\n+\n+- `SqlValidator.deriveType` may customize the behavior globally.\n+\n+- Each `SqlOperator` implementation may customize its operand type\n+  inference strategy (see `SqlOperandTypeInference` and\n+  `SqlOperator.getOperandTypeInference`) and its return type inference\n+  strategy (see `SqlReturnTypeInference`,\n+  `SqlOperator.getReturnTypeInference` and\n+  `SqlOperator.inferReturnType`). The first one is used only if some of\n+  the operand types are unknown. Also, operand type validation strategy\n+  can be customized using an associated `SqlOperandTypeChecker` (see\n+  `SqlOperator.getOperandTypeChecker`).\n+\n+- Additionally, some expressions require their operands to be coerced to\n+  a certain type. For instance, `=` operator requires both of its sides\n+  to be of the same type. In Calcite, such coercion services are\n+  provided by `TypeCoercion` implementations. Specifically,\n+  `TypeCoercionImpl` extended by `HazelcastTypeCoercion` is used to\n+  customize the coercion logic.\n+\n+The following general rules apply when assigning types:\n+\n+- Literals: `TRUE` and `FALSE` literals receive `BOOLEAN` type; numeric\n+  literals containing no decimal point (`1`, `42`, etc.) receive the\n+  smallest integer type possible (`TINYINT`, `SMALLINT`, `INTEGER` or\n+  `BIGINT`); numeric literals containing decimal point (`1.1`, `4.2`,\n+  etc.) receive `DECIMAL` type; scientific notation numeric literals\n+  (`1e1`, `4.2e2`, etc.) receive `DOUBLE` type; string literals\n+  (`'foo'`) receive `VARCHAR` type.\n+\n+- Parameters: parameter types are inferred from the context: `1.0 + ?`,\n+  the parameter would receive `DOUBLE` type.\n+\n+As an end result, for semantically valid ASTs, the validation process\n+produces a potentially transformed AST where every node has a known\n+type. For semantically invalid ASTs, an error is reported.\n+\n+### Conversion Stage\n+\n+The goal of the conversion stage it to convert the syntactically and\n+semantically valid AST (`SqlNode`) received from the previous stages to\n+a representation suitable for the relational optimization. In Calcite,\n+relational nodes are represented by subclasses of `RelNode` while\n+expression nodes referenced from relational ones are represented by\n+subclasses of `RexNode`.\n+\n+During conversion Calcite also applies various simplifications and\n+optimizations to expressions (see `SqlToRelConverter` and\n+`HazelcastSqlToRelConverter`). After the conversion all references to\n+the original textual SQL query representation are irreversibly lost. In\n+other words, it's impossible to recover a `SqlNode` from a certain\n+`RexNode` or `RelNode`.\n+\n+The resulting expressions may also undergo various transformations as\n+dictated by relational optimizations applied in other parts of the SQL\n+engine.\n+\n+### Translation Stage\n+\n+The goal of the translation phase is to translate the `RexNode`\n+representation received from the previous stage to a representation\n+suitable for the runtime evaluation of expressions.\n+\n+The translation is performed by `RexToExpressionVisitor` with the help\n+of `RexToExpression`. Every instance of `RexNode` is translated into a\n+corresponding `Expression` instance:\n+\n+The final result of the translation stage is an `Expression` tree ready\n+for runtime evaluation. No further changes expected to the tree after", "originalCommit": "003bc188d2699b6b88a70768187e8e0ad56d0df2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODY0OTM5Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17640#discussion_r498649396", "bodyText": "fixed in d1d2929", "author": "taburet", "createdAt": "2020-10-02T07:10:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzMyNzYzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzMyOTM2Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17640#discussion_r497329363", "bodyText": "We should mention the issue with SELECT ? here.", "author": "viliam-durina", "createdAt": "2020-09-30T08:22:54Z", "path": "docs/design/sql/08-expressions.md", "diffHunk": "@@ -0,0 +1,192 @@\n+# SQL Expressions\n+\n+## Overview\n+\n+Expressions is one of the core elements of every SQL implementation.\n+Expressions can participate in projections (`SELECT a + b FROM t`) and\n+filters (`SELECT * FROM t WHERE a + b < 10`). Expressions may be roughly\n+subdivided into 4 general categories:\n+\n+- Terminal expressions not referring to other expressions: column,\n+  literal, parameter and type expressions.\n+- Operators, like numeric arithmetic operators: `+`, `-`, etc.\n+- Predicates, like comparison predicates: `<`, `>`, etc.\n+- Functions, like `ABS`, `SIN`, etc.\n+\n+## Implementation Details\n+\n+We use facilities provided by Calcite to support expression parsing and\n+validation. Every SQL expression goes through the following stages:\n+\n+- Parsing\n+- Validation\n+- Conversion\n+- Translation\n+- Evaluation\n+\n+### Parsing Stage\n+\n+The goal of the parsing stage is to obtain an AST expression\n+representation from the textual expression representation for\n+syntactically valid constructs and report errors for invalid ones. For\n+instance, `a + b` is syntactically valid and `a +` is invalid.\n+\n+In Calcite, AST nodes are represented as subclasses of `SqlNode`. Column\n+and type references are represented by `SqlIdentifier`. Literals are\n+represented by `SqlLiteral` and its subclasses. Parameters are\n+represented by `SqlDynamicParam`. Most other, if not all, expressions\n+are subclasses of `SqlCall`.\n+\n+### Validation Stage\n+\n+The goal of the validation stage is to make sure that the AST\n+expressions produced by the previous parsing stage are semantically\n+valid. For instance, `1 + 1` is semantically valid while `1 + true` is\n+not.\n+\n+In Calcite, the validation logic is encapsulated and orchestrated by\n+implementations of `SqlValidator`. Specifically, `SqlValidatorImpl`\n+extended by `HazelcastSqlValidator` is used to customize the validation\n+logic to align it with our requirements.\n+\n+As a first step of the validation process, `SqlValidatorImpl` may apply\n+some transformations to the passed AST which should not affect the\n+semantics of the AST. Such transformations are called \"unconditional\n+rewrites\" (see `SqlValidatorImpl.performUnconditionalRewrites`). Every\n+`SqlCall` node has an associated `SqlOperator` returned by its\n+`getOperator` method. `SqlOperator` implementations may customize\n+various aspects of a certain operator including the rewriting behavior\n+itself (see `SqlOperator.rewriteCall`).\n+\n+Normally, Calcite's parser inspects the hardcoded `SqlStdOperatorTable`\n+implementation of `SqlOperatorTable` to resolve a certain operator, so\n+it's hard to customize the pre-existing operators. To make the\n+customization possible, operators from `SqlStdOperatorTable` are patched\n+to the ones from `HazelcastSqlOperatorTable` during the AST rewriting\n+process (see `HazelcastSqlValidator.performUnconditionalRewrites` and\n+`HazelcastOperatorTableVisitor`).\n+\n+Usually, semantic validation requires assigning types to every\n+expression and its operand expressions, if any. In Calcite, that type\n+assignment behavior may be customized in several ways:\n+\n+- `SqlValidator.deriveType` may customize the behavior globally.\n+\n+- Each `SqlOperator` implementation may customize its operand type\n+  inference strategy (see `SqlOperandTypeInference` and\n+  `SqlOperator.getOperandTypeInference`) and its return type inference\n+  strategy (see `SqlReturnTypeInference`,\n+  `SqlOperator.getReturnTypeInference` and\n+  `SqlOperator.inferReturnType`). The first one is used only if some of\n+  the operand types are unknown. Also, operand type validation strategy\n+  can be customized using an associated `SqlOperandTypeChecker` (see\n+  `SqlOperator.getOperandTypeChecker`).\n+\n+- Additionally, some expressions require their operands to be coerced to\n+  a certain type. For instance, `=` operator requires both of its sides\n+  to be of the same type. In Calcite, such coercion services are\n+  provided by `TypeCoercion` implementations. Specifically,\n+  `TypeCoercionImpl` extended by `HazelcastTypeCoercion` is used to\n+  customize the coercion logic.\n+\n+The following general rules apply when assigning types:\n+\n+- Literals: `TRUE` and `FALSE` literals receive `BOOLEAN` type; numeric\n+  literals containing no decimal point (`1`, `42`, etc.) receive the\n+  smallest integer type possible (`TINYINT`, `SMALLINT`, `INTEGER` or\n+  `BIGINT`); numeric literals containing decimal point (`1.1`, `4.2`,\n+  etc.) receive `DECIMAL` type; scientific notation numeric literals\n+  (`1e1`, `4.2e2`, etc.) receive `DOUBLE` type; string literals\n+  (`'foo'`) receive `VARCHAR` type.\n+\n+- Parameters: parameter types are inferred from the context: `1.0 + ?`,\n+  the parameter would receive `DOUBLE` type.", "originalCommit": "003bc188d2699b6b88a70768187e8e0ad56d0df2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODY0OTQ1OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17640#discussion_r498649458", "bodyText": "added in d1d2929", "author": "taburet", "createdAt": "2020-10-02T07:10:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzMyOTM2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODAyNzQ5Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17640#discussion_r498027492", "bodyText": "Can we have the list of these requirements?", "author": "devozerov", "createdAt": "2020-10-01T07:09:20Z", "path": "docs/design/sql/08-expressions.md", "diffHunk": "@@ -0,0 +1,192 @@\n+# SQL Expressions\n+\n+## Overview\n+\n+Expressions is one of the core elements of every SQL implementation.\n+Expressions can participate in projections (`SELECT a + b FROM t`) and\n+filters (`SELECT * FROM t WHERE a + b < 10`). Expressions may be roughly\n+subdivided into 4 general categories:\n+\n+- Terminal expressions not referring to other expressions: column,\n+  literal, parameter and type expressions.\n+- Operators, like numeric arithmetic operators: `+`, `-`, etc.\n+- Predicates, like comparison predicates: `<`, `>`, etc.\n+- Functions, like `ABS`, `SIN`, etc.\n+\n+## Implementation Details\n+\n+We use facilities provided by Calcite to support expression parsing and\n+validation. Every SQL expression goes through the following stages:\n+\n+- Parsing\n+- Validation\n+- Conversion\n+- Translation\n+- Evaluation\n+\n+### Parsing Stage\n+\n+The goal of the parsing stage is to obtain an AST expression\n+representation from the textual expression representation for\n+syntactically valid constructs and report errors for invalid ones. For\n+instance, `a + b` is syntactically valid and `a +` is invalid.\n+\n+In Calcite, AST nodes are represented as subclasses of `SqlNode`. Column\n+and type references are represented by `SqlIdentifier`. Literals are\n+represented by `SqlLiteral` and its subclasses. Parameters are\n+represented by `SqlDynamicParam`. Most other, if not all, expressions\n+are subclasses of `SqlCall`.\n+\n+### Validation Stage\n+\n+The goal of the validation stage is to make sure that the AST\n+expressions produced by the previous parsing stage are semantically\n+valid. For instance, `1 + 1` is semantically valid while `1 + true` is\n+not.\n+\n+In Calcite, the validation logic is encapsulated and orchestrated by\n+implementations of `SqlValidator`. Specifically, `SqlValidatorImpl`\n+extended by `HazelcastSqlValidator` is used to customize the validation\n+logic to align it with our requirements.", "originalCommit": "003bc188d2699b6b88a70768187e8e0ad56d0df2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODY0OTY5NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17640#discussion_r498649695", "bodyText": "clarified in d1d2929", "author": "taburet", "createdAt": "2020-10-02T07:10:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODAyNzQ5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODAzODc3MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17640#discussion_r498038771", "bodyText": "Can we have a paragraph that explains, how all these pieces interact with each other? Namely:\n\nSqlValidator.deriveType - when is it called and how does it relate to SqlOperator.deriveType?\nSqlOperandTypeInference - when does it come into play?\nSqlOperandTypeChecker - same as above, and how it relates to SqlOperator.checkOperandTypes and SqlOperator.getOperandCountRange methods that have overrides in out classes (e.g. why HazelcastSqlCastFunction overrides checkOperandTypes?)", "author": "devozerov", "createdAt": "2020-10-01T07:31:02Z", "path": "docs/design/sql/08-expressions.md", "diffHunk": "@@ -0,0 +1,192 @@\n+# SQL Expressions\n+\n+## Overview\n+\n+Expressions is one of the core elements of every SQL implementation.\n+Expressions can participate in projections (`SELECT a + b FROM t`) and\n+filters (`SELECT * FROM t WHERE a + b < 10`). Expressions may be roughly\n+subdivided into 4 general categories:\n+\n+- Terminal expressions not referring to other expressions: column,\n+  literal, parameter and type expressions.\n+- Operators, like numeric arithmetic operators: `+`, `-`, etc.\n+- Predicates, like comparison predicates: `<`, `>`, etc.\n+- Functions, like `ABS`, `SIN`, etc.\n+\n+## Implementation Details\n+\n+We use facilities provided by Calcite to support expression parsing and\n+validation. Every SQL expression goes through the following stages:\n+\n+- Parsing\n+- Validation\n+- Conversion\n+- Translation\n+- Evaluation\n+\n+### Parsing Stage\n+\n+The goal of the parsing stage is to obtain an AST expression\n+representation from the textual expression representation for\n+syntactically valid constructs and report errors for invalid ones. For\n+instance, `a + b` is syntactically valid and `a +` is invalid.\n+\n+In Calcite, AST nodes are represented as subclasses of `SqlNode`. Column\n+and type references are represented by `SqlIdentifier`. Literals are\n+represented by `SqlLiteral` and its subclasses. Parameters are\n+represented by `SqlDynamicParam`. Most other, if not all, expressions\n+are subclasses of `SqlCall`.\n+\n+### Validation Stage\n+\n+The goal of the validation stage is to make sure that the AST\n+expressions produced by the previous parsing stage are semantically\n+valid. For instance, `1 + 1` is semantically valid while `1 + true` is\n+not.\n+\n+In Calcite, the validation logic is encapsulated and orchestrated by\n+implementations of `SqlValidator`. Specifically, `SqlValidatorImpl`\n+extended by `HazelcastSqlValidator` is used to customize the validation\n+logic to align it with our requirements.\n+\n+As a first step of the validation process, `SqlValidatorImpl` may apply\n+some transformations to the passed AST which should not affect the\n+semantics of the AST. Such transformations are called \"unconditional\n+rewrites\" (see `SqlValidatorImpl.performUnconditionalRewrites`). Every\n+`SqlCall` node has an associated `SqlOperator` returned by its\n+`getOperator` method. `SqlOperator` implementations may customize\n+various aspects of a certain operator including the rewriting behavior\n+itself (see `SqlOperator.rewriteCall`).\n+\n+Normally, Calcite's parser inspects the hardcoded `SqlStdOperatorTable`\n+implementation of `SqlOperatorTable` to resolve a certain operator, so\n+it's hard to customize the pre-existing operators. To make the\n+customization possible, operators from `SqlStdOperatorTable` are patched\n+to the ones from `HazelcastSqlOperatorTable` during the AST rewriting\n+process (see `HazelcastSqlValidator.performUnconditionalRewrites` and\n+`HazelcastOperatorTableVisitor`).\n+\n+Usually, semantic validation requires assigning types to every\n+expression and its operand expressions, if any. In Calcite, that type\n+assignment behavior may be customized in several ways:\n+\n+- `SqlValidator.deriveType` may customize the behavior globally.", "originalCommit": "003bc188d2699b6b88a70768187e8e0ad56d0df2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODY0OTcxOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17640#discussion_r498649719", "bodyText": "clarified in d1d2929", "author": "taburet", "createdAt": "2020-10-02T07:10:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODAzODc3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODAzOTQ5NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17640#discussion_r498039495", "bodyText": "Can we have an extended description of how the coercion works (built-in and our own), how it relates to 01-type-system.md conversions, what are the current problems, and possibly - how we are going to deal with it in the future?", "author": "devozerov", "createdAt": "2020-10-01T07:32:27Z", "path": "docs/design/sql/08-expressions.md", "diffHunk": "@@ -0,0 +1,192 @@\n+# SQL Expressions\n+\n+## Overview\n+\n+Expressions is one of the core elements of every SQL implementation.\n+Expressions can participate in projections (`SELECT a + b FROM t`) and\n+filters (`SELECT * FROM t WHERE a + b < 10`). Expressions may be roughly\n+subdivided into 4 general categories:\n+\n+- Terminal expressions not referring to other expressions: column,\n+  literal, parameter and type expressions.\n+- Operators, like numeric arithmetic operators: `+`, `-`, etc.\n+- Predicates, like comparison predicates: `<`, `>`, etc.\n+- Functions, like `ABS`, `SIN`, etc.\n+\n+## Implementation Details\n+\n+We use facilities provided by Calcite to support expression parsing and\n+validation. Every SQL expression goes through the following stages:\n+\n+- Parsing\n+- Validation\n+- Conversion\n+- Translation\n+- Evaluation\n+\n+### Parsing Stage\n+\n+The goal of the parsing stage is to obtain an AST expression\n+representation from the textual expression representation for\n+syntactically valid constructs and report errors for invalid ones. For\n+instance, `a + b` is syntactically valid and `a +` is invalid.\n+\n+In Calcite, AST nodes are represented as subclasses of `SqlNode`. Column\n+and type references are represented by `SqlIdentifier`. Literals are\n+represented by `SqlLiteral` and its subclasses. Parameters are\n+represented by `SqlDynamicParam`. Most other, if not all, expressions\n+are subclasses of `SqlCall`.\n+\n+### Validation Stage\n+\n+The goal of the validation stage is to make sure that the AST\n+expressions produced by the previous parsing stage are semantically\n+valid. For instance, `1 + 1` is semantically valid while `1 + true` is\n+not.\n+\n+In Calcite, the validation logic is encapsulated and orchestrated by\n+implementations of `SqlValidator`. Specifically, `SqlValidatorImpl`\n+extended by `HazelcastSqlValidator` is used to customize the validation\n+logic to align it with our requirements.\n+\n+As a first step of the validation process, `SqlValidatorImpl` may apply\n+some transformations to the passed AST which should not affect the\n+semantics of the AST. Such transformations are called \"unconditional\n+rewrites\" (see `SqlValidatorImpl.performUnconditionalRewrites`). Every\n+`SqlCall` node has an associated `SqlOperator` returned by its\n+`getOperator` method. `SqlOperator` implementations may customize\n+various aspects of a certain operator including the rewriting behavior\n+itself (see `SqlOperator.rewriteCall`).\n+\n+Normally, Calcite's parser inspects the hardcoded `SqlStdOperatorTable`\n+implementation of `SqlOperatorTable` to resolve a certain operator, so\n+it's hard to customize the pre-existing operators. To make the\n+customization possible, operators from `SqlStdOperatorTable` are patched\n+to the ones from `HazelcastSqlOperatorTable` during the AST rewriting\n+process (see `HazelcastSqlValidator.performUnconditionalRewrites` and\n+`HazelcastOperatorTableVisitor`).\n+\n+Usually, semantic validation requires assigning types to every\n+expression and its operand expressions, if any. In Calcite, that type\n+assignment behavior may be customized in several ways:\n+\n+- `SqlValidator.deriveType` may customize the behavior globally.\n+\n+- Each `SqlOperator` implementation may customize its operand type\n+  inference strategy (see `SqlOperandTypeInference` and\n+  `SqlOperator.getOperandTypeInference`) and its return type inference\n+  strategy (see `SqlReturnTypeInference`,\n+  `SqlOperator.getReturnTypeInference` and\n+  `SqlOperator.inferReturnType`). The first one is used only if some of\n+  the operand types are unknown. Also, operand type validation strategy\n+  can be customized using an associated `SqlOperandTypeChecker` (see\n+  `SqlOperator.getOperandTypeChecker`).\n+\n+- Additionally, some expressions require their operands to be coerced to\n+  a certain type. For instance, `=` operator requires both of its sides\n+  to be of the same type. In Calcite, such coercion services are\n+  provided by `TypeCoercion` implementations. Specifically,\n+  `TypeCoercionImpl` extended by `HazelcastTypeCoercion` is used to", "originalCommit": "003bc188d2699b6b88a70768187e8e0ad56d0df2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA0MTk2OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17640#discussion_r498041968", "bodyText": "For example, we have HazelcastTypeCoercion that does some inference, and also SqlOperandTypeInference that passed to many operators, plus several custom implementations of this interface located in the HazelcastInferTypes.\nHow do they relate to each other?", "author": "devozerov", "createdAt": "2020-10-01T07:37:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODAzOTQ5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODY0OTc0Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17640#discussion_r498649747", "bodyText": "clarified in d1d2929", "author": "taburet", "createdAt": "2020-10-02T07:10:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODAzOTQ5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA0MTA1MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17640#discussion_r498041051", "bodyText": "Since the proper parameter inference is still an open question, can we have more examples of how it is actually performed in our product at the moment? For example, comparison and binary arithmetic functions have one inference strategy, while simple functions do it differently.", "author": "devozerov", "createdAt": "2020-10-01T07:35:32Z", "path": "docs/design/sql/08-expressions.md", "diffHunk": "@@ -0,0 +1,192 @@\n+# SQL Expressions\n+\n+## Overview\n+\n+Expressions is one of the core elements of every SQL implementation.\n+Expressions can participate in projections (`SELECT a + b FROM t`) and\n+filters (`SELECT * FROM t WHERE a + b < 10`). Expressions may be roughly\n+subdivided into 4 general categories:\n+\n+- Terminal expressions not referring to other expressions: column,\n+  literal, parameter and type expressions.\n+- Operators, like numeric arithmetic operators: `+`, `-`, etc.\n+- Predicates, like comparison predicates: `<`, `>`, etc.\n+- Functions, like `ABS`, `SIN`, etc.\n+\n+## Implementation Details\n+\n+We use facilities provided by Calcite to support expression parsing and\n+validation. Every SQL expression goes through the following stages:\n+\n+- Parsing\n+- Validation\n+- Conversion\n+- Translation\n+- Evaluation\n+\n+### Parsing Stage\n+\n+The goal of the parsing stage is to obtain an AST expression\n+representation from the textual expression representation for\n+syntactically valid constructs and report errors for invalid ones. For\n+instance, `a + b` is syntactically valid and `a +` is invalid.\n+\n+In Calcite, AST nodes are represented as subclasses of `SqlNode`. Column\n+and type references are represented by `SqlIdentifier`. Literals are\n+represented by `SqlLiteral` and its subclasses. Parameters are\n+represented by `SqlDynamicParam`. Most other, if not all, expressions\n+are subclasses of `SqlCall`.\n+\n+### Validation Stage\n+\n+The goal of the validation stage is to make sure that the AST\n+expressions produced by the previous parsing stage are semantically\n+valid. For instance, `1 + 1` is semantically valid while `1 + true` is\n+not.\n+\n+In Calcite, the validation logic is encapsulated and orchestrated by\n+implementations of `SqlValidator`. Specifically, `SqlValidatorImpl`\n+extended by `HazelcastSqlValidator` is used to customize the validation\n+logic to align it with our requirements.\n+\n+As a first step of the validation process, `SqlValidatorImpl` may apply\n+some transformations to the passed AST which should not affect the\n+semantics of the AST. Such transformations are called \"unconditional\n+rewrites\" (see `SqlValidatorImpl.performUnconditionalRewrites`). Every\n+`SqlCall` node has an associated `SqlOperator` returned by its\n+`getOperator` method. `SqlOperator` implementations may customize\n+various aspects of a certain operator including the rewriting behavior\n+itself (see `SqlOperator.rewriteCall`).\n+\n+Normally, Calcite's parser inspects the hardcoded `SqlStdOperatorTable`\n+implementation of `SqlOperatorTable` to resolve a certain operator, so\n+it's hard to customize the pre-existing operators. To make the\n+customization possible, operators from `SqlStdOperatorTable` are patched\n+to the ones from `HazelcastSqlOperatorTable` during the AST rewriting\n+process (see `HazelcastSqlValidator.performUnconditionalRewrites` and\n+`HazelcastOperatorTableVisitor`).\n+\n+Usually, semantic validation requires assigning types to every\n+expression and its operand expressions, if any. In Calcite, that type\n+assignment behavior may be customized in several ways:\n+\n+- `SqlValidator.deriveType` may customize the behavior globally.\n+\n+- Each `SqlOperator` implementation may customize its operand type\n+  inference strategy (see `SqlOperandTypeInference` and\n+  `SqlOperator.getOperandTypeInference`) and its return type inference\n+  strategy (see `SqlReturnTypeInference`,\n+  `SqlOperator.getReturnTypeInference` and\n+  `SqlOperator.inferReturnType`). The first one is used only if some of\n+  the operand types are unknown. Also, operand type validation strategy\n+  can be customized using an associated `SqlOperandTypeChecker` (see\n+  `SqlOperator.getOperandTypeChecker`).\n+\n+- Additionally, some expressions require their operands to be coerced to\n+  a certain type. For instance, `=` operator requires both of its sides\n+  to be of the same type. In Calcite, such coercion services are\n+  provided by `TypeCoercion` implementations. Specifically,\n+  `TypeCoercionImpl` extended by `HazelcastTypeCoercion` is used to\n+  customize the coercion logic.\n+\n+The following general rules apply when assigning types:\n+\n+- Literals: `TRUE` and `FALSE` literals receive `BOOLEAN` type; numeric\n+  literals containing no decimal point (`1`, `42`, etc.) receive the\n+  smallest integer type possible (`TINYINT`, `SMALLINT`, `INTEGER` or\n+  `BIGINT`); numeric literals containing decimal point (`1.1`, `4.2`,\n+  etc.) receive `DECIMAL` type; scientific notation numeric literals\n+  (`1e1`, `4.2e2`, etc.) receive `DOUBLE` type; string literals\n+  (`'foo'`) receive `VARCHAR` type.\n+\n+- Parameters: parameter types are inferred from the context: `1.0 + ?`,", "originalCommit": "003bc188d2699b6b88a70768187e8e0ad56d0df2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODY0OTc4NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17640#discussion_r498649785", "bodyText": "clarified in d1d2929", "author": "taburet", "createdAt": "2020-10-02T07:10:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA0MTA1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA0NDE3MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17640#discussion_r498044171", "bodyText": "Does it make sense to mention HazelcastOperandTypes.notAny/notAllNull methods? What is the main motivation to have them?\nFor example, why notAllNull is used in the UNARY_MINUS? Couldn't we convert -NULL to just NULL without throwing an error?", "author": "devozerov", "createdAt": "2020-10-01T07:41:27Z", "path": "docs/design/sql/08-expressions.md", "diffHunk": "@@ -0,0 +1,192 @@\n+# SQL Expressions", "originalCommit": "003bc188d2699b6b88a70768187e8e0ad56d0df2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODY0OTgxMg==", "url": "https://github.com/hazelcast/hazelcast/pull/17640#discussion_r498649812", "bodyText": "clarified in d1d2929", "author": "taburet", "createdAt": "2020-10-02T07:11:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA0NDE3MQ=="}], "type": "inlineReview"}, {"oid": "d1d2929413835f7a462bc88686630dd57203b27c", "url": "https://github.com/hazelcast/hazelcast/commit/d1d2929413835f7a462bc88686630dd57203b27c", "message": "address review comments", "committedDate": "2020-10-02T07:07:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODY4OTk0Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17640#discussion_r498689943", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            - Terminal expressions not referring to other expressions: column,\n          \n          \n            \n              literal, parameter and type (as seen in `CAST`) expressions.\n          \n          \n            \n            - Terminal expressions not referring to other expressions: column\n          \n          \n            \n              references, literals, dynamic parameters and type expressions (i.e.\n          \n          \n            \n              the type argument of the `CAST` expression).", "author": "viliam-durina", "createdAt": "2020-10-02T08:39:56Z", "path": "docs/design/sql/08-expressions.md", "diffHunk": "@@ -0,0 +1,261 @@\n+# SQL Expressions\n+\n+## Overview\n+\n+Expressions are one of the core elements of every SQL implementation.\n+Expressions can participate in projections (`SELECT a + b FROM t`) and\n+filters (`SELECT * FROM t WHERE a + b < 10`). Expressions may be roughly\n+subdivided into 4 general categories:\n+\n+- Terminal expressions not referring to other expressions: column,\n+  literal, parameter and type (as seen in `CAST`) expressions.", "originalCommit": "d1d2929413835f7a462bc88686630dd57203b27c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6f9f770951ae82a989f8f59474cfcac890f03956", "url": "https://github.com/hazelcast/hazelcast/commit/6f9f770951ae82a989f8f59474cfcac890f03956", "message": "Update docs/design/sql/08-expressions.md\n\nCo-authored-by: Viliam Durina <viliam-durina@users.noreply.github.com>", "committedDate": "2020-10-02T08:42:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODczMTUyMw==", "url": "https://github.com/hazelcast/hazelcast/pull/17640#discussion_r498731523", "bodyText": "AFAIK this is not the main problem. The bigger problem is that we allow implicit conversions for those pairs, that are defined as explicit in the 01-type-system.md. For example, LENGTH(intCol) will just work fine, while INT -> VARCHAR explicit conversion is prohibited.\nI would advise to mention it in the document explicitly:\n\nWe currently do incorrect implicit conversions that otherwise should be explicit only - these invalid conversions are performed by Calcite code, not ours, and this should be fixed somehow in the future\nWe currently do not understand whether we should have this implicit/explicit notion at all, or whether allowed conversions should be defined on the operator level. Or maybe we should have implicit/explicit conversions and per-operator overrides.", "author": "devozerov", "createdAt": "2020-10-02T10:05:50Z", "path": "docs/design/sql/08-expressions.md", "diffHunk": "@@ -0,0 +1,262 @@\n+# SQL Expressions\n+\n+## Overview\n+\n+Expressions are one of the core elements of every SQL implementation.\n+Expressions can participate in projections (`SELECT a + b FROM t`) and\n+filters (`SELECT * FROM t WHERE a + b < 10`). Expressions may be roughly\n+subdivided into 4 general categories:\n+\n+- Terminal expressions not referring to other expressions: column\n+  references, literals, dynamic parameters and type expressions (i.e.\n+  the type argument of the `CAST` expression).\n+- Operators, like numeric arithmetic operators: `+`, `-`, etc.\n+- Predicates, like comparison predicates: `<`, `>`, etc.\n+- Functions, like `ABS`, `SIN`, etc.\n+\n+## Implementation Details\n+\n+We use facilities provided by Calcite to support expression parsing and\n+validation. Every SQL expression goes through the following stages:\n+\n+- Parsing\n+- Validation\n+- Conversion\n+- Translation\n+- Evaluation\n+\n+### Parsing Stage\n+\n+The goal of the parsing stage is to obtain an AST expression\n+representation from the textual expression representation for\n+syntactically valid constructs and report errors for invalid ones. For\n+instance, `a + b` is syntactically valid and `a +` is invalid.\n+\n+In Calcite, AST nodes are represented as subclasses of `SqlNode`. Column\n+and type references are represented by `SqlIdentifier`. Literals are\n+represented by `SqlLiteral` and its subclasses. Parameters are\n+represented by `SqlDynamicParam`. Most other, if not all, expressions\n+are subclasses of `SqlCall`.\n+\n+### Validation Stage\n+\n+The goal of the validation stage is to make sure that the AST\n+expressions produced by the previous parsing stage are semantically\n+valid. For instance, `1 + 1` is semantically valid while `1 + true` is\n+not.\n+\n+In Calcite, the validation logic is encapsulated and orchestrated by\n+implementations of `SqlValidator`. Specifically, `SqlValidatorImpl`\n+extended by `HazelcastSqlValidator` is used to customize the validation\n+logic to align it with our requirements: the narrowest integer type is\n+assigned to integer literals and to `CAST` operators involving integer\n+types.\n+\n+As a first step of the validation process, `SqlValidatorImpl` may apply\n+some transformations to the passed AST which should not affect the\n+semantics of the AST. Such transformations are called \"unconditional\n+rewrites\" (see `SqlValidatorImpl.performUnconditionalRewrites`). Every\n+`SqlCall` node has an associated `SqlOperator` returned by its\n+`getOperator` method. `SqlOperator` implementations may customize\n+various aspects of a certain operator including the rewriting behavior\n+itself (see `SqlOperator.rewriteCall`).\n+\n+Normally, Calcite's parser inspects the hardcoded `SqlStdOperatorTable`\n+implementation of `SqlOperatorTable` to resolve a certain operator, so\n+it's hard to customize the pre-existing operators. To make the\n+customization possible, operators from `SqlStdOperatorTable` are patched\n+to the ones from `HazelcastSqlOperatorTable` during the AST rewriting\n+process (see `HazelcastSqlValidator.performUnconditionalRewrites` and\n+`HazelcastOperatorTableVisitor`).\n+\n+Usually, semantic validation requires assigning types to every\n+expression and its operand expressions, if any. In Calcite, that type\n+assignment behavior may be customized in several ways:\n+\n+- `SqlValidator.deriveType` may customize the behavior globally, it's\n+  the main source of truth for node types and invoked every time when a\n+  node type is needed. Derived types are cached by the validator to\n+  avoid constant re-derivation. Usually, if a node in question is an\n+  operator the validator just delegates the type derivation to it using\n+  `SqlOperator.deriveType`. Which in turn, usually, delegates back to\n+  the validator to derive the types of its operands and then calls\n+  `SqlOperator.inferReturnType`, which may delegate to\n+  `SqlReturnTypeInference` strategy associated with the operator.\n+\n+- Each `SqlOperator` implementation may customize its operand type\n+  inference strategy (see `SqlOperandTypeInference` and\n+  `SqlOperator.getOperandTypeInference`) and its return type inference\n+  strategy (see `SqlReturnTypeInference`,\n+  `SqlOperator.getReturnTypeInference` and\n+  `SqlOperator.inferReturnType`). Also, operand type validation strategy\n+  can be customized using an associated `SqlOperandTypeChecker` (see\n+  `SqlOperator.getOperandTypeChecker`).\n+\n+- Additionally, some expressions require their operands to be coerced to\n+  a certain type. For instance, `=` operator requires both of its sides\n+  to be of the same type. In Calcite, such coercion services are\n+  provided by `TypeCoercion` implementations. Specifically,\n+  `TypeCoercionImpl` extended by `HazelcastTypeCoercion` is used to\n+  customize the coercion logic.\n+\n+The following general rules apply when assigning types:\n+\n+- Literals: `TRUE` and `FALSE` literals receive `BOOLEAN` type; numeric\n+  literals containing no decimal point (`1`, `42`, etc.) receive the\n+  narrowest integer type possible (`TINYINT`, `SMALLINT`, `INTEGER` or\n+  `BIGINT`); numeric literals containing decimal point (`1.1`, `4.2`,\n+  etc.) receive `DECIMAL` type; scientific notation numeric literals\n+  (`1e1`, `4.2e2`, etc.) receive `DOUBLE` type; string literals\n+  (`'foo'`) receive `VARCHAR` type.\n+\n+- Parameters: parameter types are inferred from the context: `1.0 + ?`,\n+  the parameter would receive `DECIMAL` type since the type of the\n+  left-hand side literal is `DECIMAL`; `1 + ?`, despite the fact that\n+  the literal type is `TINYINT` the parameter would receive `BIGINT`\n+  type because `TINYINT` is too restrictive; `sin(?)`, the parameter\n+  would receive `DOUBLE` type since it's the only type accepted by `sin`\n+  function. In certain cases (`SELECT ?`, for instance) it's impossible\n+  to infer a concrete type, more on that below.\n+  \n+In general, the validation process begins with a call to\n+`SqlValidator.validate`, which starts a recursive validation of the\n+passed node and its children. Typically, during the validation, types\n+should be _derived_ for every node starting at the root, that usually\n+requires knowing types of all child nodes. Types of certain nodes\n+(dynamic parameters, for instance) might be unknown, so as a first step\n+every node tries to _infer_ types for its child nodes of unknown types.\n+For operators this process can be customized using\n+`SqlOperandTypeInference` strategy associated with an operator.\n+\n+If a node type can't be inferred, the validation fails. Currently, that\n+happens if an operator acts only on dynamic parameters and/or `NULL`s.\n+This might change in the future, for instance we may assign some default\n+type in such cases. Consider `? + ?`, `+` operator can be applied to\n+numeric and temporal types, we may choose to assign `DECIMAL` type for\n+the parameters in this specific case. Alternatively, we might take into\n+account the actual types of the passed parameter arguments and construct\n+separate query plans based on that information, that way we would not\n+need any one-size-fits-all defaults. `NULL` as a type is not a\n+first-class citizen in Calcite: basically, every `NULL` literal\n+participating in some operator or function must have a concrete type\n+assigned, therefore `NULL + NULL` is affected by the same type inference\n+problem, which might be solved by making `NULL` type a first-class\n+citizen or by choosing some defaults.\n+\n+After all unknown types are inferred and assigned to nodes, type for\n+every tree node can be derived from the node itself potentially\n+consulting its child nodes for their types. Most operators have an\n+additional round of type refinement called type coercion. For instance,\n+both sides of the binary comparison operators are coerced to the same\n+type respecting type precedence and conversion rules defined in [Type\n+System design document](01-type-system.md). Another example is the\n+binary arithmetic operators coercing their operands to a common type.\n+The coercion can be customized by providing a custom `TypeCoercion` (see", "originalCommit": "6f9f770951ae82a989f8f59474cfcac890f03956", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODgwMTQyMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17640#discussion_r498801421", "bodyText": "fixed in 2311497", "author": "taburet", "createdAt": "2020-10-02T12:51:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODczMTUyMw=="}], "type": "inlineReview"}, {"oid": "2311497e69a49d9d38938c7b67de723ef9cbceaf", "url": "https://github.com/hazelcast/hazelcast/commit/2311497e69a49d9d38938c7b67de723ef9cbceaf", "message": "address review comments", "committedDate": "2020-10-02T12:50:56Z", "type": "commit"}, {"oid": "70a7ddd2f431559ca57355b421199079c02ea5e3", "url": "https://github.com/hazelcast/hazelcast/commit/70a7ddd2f431559ca57355b421199079c02ea5e3", "message": "Merge branch 'master' into expressions-tdd", "committedDate": "2020-10-07T05:23:53Z", "type": "commit"}]}