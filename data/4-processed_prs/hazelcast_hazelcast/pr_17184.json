{"pr_number": 17184, "pr_title": "Tenant control moved to TenantControlService, fix cache replication with unavailable applications / classes", "pr_createdAt": "2020-07-07T00:46:29Z", "pr_url": "https://github.com/hazelcast/hazelcast/pull/17184", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjAxMjQwNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r452012405", "bodyText": "Calling allien code while holding a lock is a source or problems.", "author": "pveentjer", "createdAt": "2020-07-09T07:17:50Z", "path": "hazelcast/src/main/java/com/hazelcast/cache/impl/TenantContextual.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.cache.impl;\n+\n+import com.hazelcast.spi.tenantcontrol.TenantControl;\n+import com.hazelcast.spi.tenantcontrol.TenantControl.Closeable;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.function.Supplier;\n+\n+/**\n+ * Represents a value that requires tenant control context to be accessed\n+ *\n+ * @author lprimak\n+ * @param <T> object type\n+ */\n+public class TenantContextual<T> {\n+    private T contextual;\n+    private volatile boolean initialized;\n+    private final Supplier<T> initFunction;\n+    private final Supplier<Boolean> existsFunction;\n+    private final TenantControl tenantControl;\n+    private final Lock lock = new ReentrantLock();\n+\n+    public TenantContextual(Supplier<T> initFunction, Supplier<Boolean> existsFunction, TenantControl tenantControl) {\n+        this.initFunction = initFunction;\n+        this.existsFunction = existsFunction;\n+        this.tenantControl = tenantControl;\n+    }\n+\n+    /**\n+     *\n+     * @return underlying object, initialize within Tenant Control when necessary\n+     */\n+    public T get() {\n+        boolean localInitialized = this.initialized;\n+        if (!localInitialized) {\n+            try {\n+                lock.lock();", "originalCommit": "9262896bfe67873d293133e6630c6aaaeab8b1ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjI0NDA2MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r452244061", "bodyText": "I don't believe any alien code is called from here. This class is really private API (perhaps I should annotate it as such) but the way it's used only \"non-alien\" code is used here", "author": "lprimak", "createdAt": "2020-07-09T14:06:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjAxMjQwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYzNDcwMA==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r452634700", "bodyText": "Alien code -> Code that isn't owned by this class.  The problem with any interface injected into this class and called whole holding a lock, it is very easy to run into severe problems (contention, deadlocks etc). And perhaps it is fine now, but I have seen on quite a few occasions that eventually you end up with some nasty locking problem.", "author": "pveentjer", "createdAt": "2020-07-10T05:49:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjAxMjQwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg5MjA0Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r498892042", "bodyText": "This should be called once, before the tenant context is initialised. Probably isn't going to be a problem. @lprimak is it possible to initialise the tenant control eagerly while record store is being created and not later when it's accessed?", "author": "mmedenjak", "createdAt": "2020-10-02T15:26:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjAxMjQwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODkzNzgxNw==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r498937817", "bodyText": "no, as when Hazelcast migration happens, no user classes (factory classes here) are available so this will result in errors", "author": "lprimak", "createdAt": "2020-10-02T16:54:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjAxMjQwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYyNzIyMw==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r499627223", "bodyText": "Resolving as it should be lazy and it will be invoked only once.", "author": "mmedenjak", "createdAt": "2020-10-05T14:09:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjAxMjQwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjAxMjc4Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r452012786", "bodyText": "Every problem in software engineering can be solved by adding an extra layer of indirection; apart from having too many layers of indirection. I have the feeling that we are adding an unwanted layer of indirection here.", "author": "pveentjer", "createdAt": "2020-07-09T07:18:35Z", "path": "hazelcast/src/main/java/com/hazelcast/cache/impl/TenantContextual.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.cache.impl;\n+\n+import com.hazelcast.spi.tenantcontrol.TenantControl;\n+import com.hazelcast.spi.tenantcontrol.TenantControl.Closeable;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.function.Supplier;\n+\n+/**\n+ * Represents a value that requires tenant control context to be accessed\n+ *\n+ * @author lprimak\n+ * @param <T> object type\n+ */\n+public class TenantContextual<T> {", "originalCommit": "9262896bfe67873d293133e6630c6aaaeab8b1ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjI0NDI1NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r452244254", "bodyText": "I am not sure what is the alternative here is, do you have a suggestion?", "author": "lprimak", "createdAt": "2020-07-09T14:07:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjAxMjc4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg5Mjg2Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r498892863", "bodyText": "Resolving this comment as this class serves its' purpose and I asked if the tenant context can be resolved eagerly in other comment above.", "author": "mmedenjak", "createdAt": "2020-10-02T15:28:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjAxMjc4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjAxMzExNw==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r452013117", "bodyText": "A lock always needs to be acquired outside the try block.", "author": "pveentjer", "createdAt": "2020-07-09T07:19:16Z", "path": "hazelcast/src/main/java/com/hazelcast/cache/impl/TenantContextual.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.cache.impl;\n+\n+import com.hazelcast.spi.tenantcontrol.TenantControl;\n+import com.hazelcast.spi.tenantcontrol.TenantControl.Closeable;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.function.Supplier;\n+\n+/**\n+ * Represents a value that requires tenant control context to be accessed\n+ *\n+ * @author lprimak\n+ * @param <T> object type\n+ */\n+public class TenantContextual<T> {\n+    private T contextual;\n+    private volatile boolean initialized;\n+    private final Supplier<T> initFunction;\n+    private final Supplier<Boolean> existsFunction;\n+    private final TenantControl tenantControl;\n+    private final Lock lock = new ReentrantLock();\n+\n+    public TenantContextual(Supplier<T> initFunction, Supplier<Boolean> existsFunction, TenantControl tenantControl) {\n+        this.initFunction = initFunction;\n+        this.existsFunction = existsFunction;\n+        this.tenantControl = tenantControl;\n+    }\n+\n+    /**\n+     *\n+     * @return underlying object, initialize within Tenant Control when necessary\n+     */\n+    public T get() {\n+        boolean localInitialized = this.initialized;\n+        if (!localInitialized) {\n+            try {\n+                lock.lock();", "originalCommit": "9262896bfe67873d293133e6630c6aaaeab8b1ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjI0NDM1Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r452244353", "bodyText": "you are right. done.", "author": "lprimak", "createdAt": "2020-07-09T14:07:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjAxMzExNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjAxNTg2Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r452015862", "bodyText": "This will break any implementation of TenantControl. In theory it is allowed because it is @Beta, but something that needs to be considered since there is already a release with this interface.", "author": "pveentjer", "createdAt": "2020-07-09T07:24:44Z", "path": "hazelcast/src/main/java/com/hazelcast/spi/tenantcontrol/TenantControl.java", "diffHunk": "@@ -33,8 +31,7 @@\n  * @author lprimak\n  */\n @Beta\n-public interface TenantControl extends Serializable {\n-\n+public interface TenantControl extends DataSerializable {", "originalCommit": "9262896bfe67873d293133e6630c6aaaeab8b1ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjI0NDk1Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r452244956", "bodyText": "TenantControl was created by me for Payara. I doubt very much it'll break anyone else. Besides, many, many things were changed in more of an incompatible way from Hazelcast 3.x to 4.x anyway", "author": "lprimak", "createdAt": "2020-07-09T14:08:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjAxNTg2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYzNDkyMg==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r452634922", "bodyText": "Hazelcast 4.0 is a major release and hence allowed to break API.", "author": "pveentjer", "createdAt": "2020-07-10T05:50:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjAxNTg2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzE3NTY4Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r453175687", "bodyText": "Generally since it's beta and since it's a rather obscure feature, I'm ok with changing it in a minor release.", "author": "mmedenjak", "createdAt": "2020-07-11T09:16:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjAxNTg2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjAxNjA1NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r452016055", "bodyText": "Breaking beta interface..", "author": "pveentjer", "createdAt": "2020-07-09T07:25:04Z", "path": "hazelcast/src/main/java/com/hazelcast/spi/tenantcontrol/DestroyEventContext.java", "diffHunk": "@@ -16,27 +16,21 @@\n \n package com.hazelcast.spi.tenantcontrol;\n \n+import com.hazelcast.core.HazelcastInstance;\n import com.hazelcast.spi.annotation.Beta;\n \n /**\n  * Hook to decouple Hazelcast object from the tenant\n- * @param <T> context type\n  */\n @Beta\n-public interface DestroyEventContext<T> {\n+public interface DestroyEventContext {", "originalCommit": "9262896bfe67873d293133e6630c6aaaeab8b1ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjI0NTE3Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r452245173", "bodyText": "Same comment as above", "author": "lprimak", "createdAt": "2020-07-09T14:08:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjAxNjA1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ2MzUzOA==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r464463538", "bodyText": "minor: method instead of class", "author": "vbekiaris", "createdAt": "2020-08-03T14:49:45Z", "path": "hazelcast/src/main/java/com/hazelcast/spi/impl/operationservice/Operation.java", "diffHunk": "@@ -772,6 +785,48 @@ protected void writeInternal(ObjectDataOutput out) throws IOException {\n     protected void readInternal(ObjectDataInput in) throws IOException {\n     }\n \n+    public TenantControl getTenantControl() {\n+        return tenantControl;\n+    }\n+\n+    public void setTenantControlIfNotAlready() {\n+        if (tenantControl == TenantControl.NOOP_TENANT_CONTROL) {\n+            tenantControl = nodeEngine.getTenantControlFactory().saveCurrentTenant();\n+            if (tenantControl == null) {\n+                getLogger().warning(String.format(\"TenantControl factory return null: %s - %s)\",\n+                        this.toString(), nodeEngine.getTenantControlFactory().toString()));\n+                tenantControl = TenantControl.NOOP_TENANT_CONTROL;\n+            } else {\n+                setFlag(true, BITMASK_TENANT_CONTROL_SET);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * checks if operation is ready to execute,\n+     * if not, it will be pushed to the back of the queue\n+     * Tenant's isAvailable() class is responsible for waiting", "originalCommit": "9114bc47e3a6c8905aa9ab0257c8451f2183e064", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ2Njc2NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r464466765", "bodyText": "This method body should be only executed when cluster version is >= 4.1, otherwise it might introduce trouble with rolling upgrades. So something like:\nif (nodeEngine.getClusterService().getClusterVersion().isGreaterOrEqual(Versions.V4_1)) {\n  ... // do stuff\n}\n\nedit (note to self): reconsider, maybe old members just ignore the flag they don't know how to deal with", "author": "vbekiaris", "createdAt": "2020-08-03T14:54:58Z", "path": "hazelcast/src/main/java/com/hazelcast/spi/impl/operationservice/Operation.java", "diffHunk": "@@ -772,6 +785,48 @@ protected void writeInternal(ObjectDataOutput out) throws IOException {\n     protected void readInternal(ObjectDataInput in) throws IOException {\n     }\n \n+    public TenantControl getTenantControl() {\n+        return tenantControl;\n+    }\n+\n+    public void setTenantControlIfNotAlready() {\n+        if (tenantControl == TenantControl.NOOP_TENANT_CONTROL) {", "originalCommit": "9114bc47e3a6c8905aa9ab0257c8451f2183e064", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ4MDU5NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r464480594", "bodyText": "This method name might be confusing (eg it reminds me of BlockingOperation#shouldWait). Maybe rename to isTenantAvailable?", "author": "vbekiaris", "createdAt": "2020-08-03T15:16:26Z", "path": "hazelcast/src/main/java/com/hazelcast/spi/impl/operationservice/Operation.java", "diffHunk": "@@ -772,6 +785,48 @@ protected void writeInternal(ObjectDataOutput out) throws IOException {\n     protected void readInternal(ObjectDataInput in) throws IOException {\n     }\n \n+    public TenantControl getTenantControl() {\n+        return tenantControl;\n+    }\n+\n+    public void setTenantControlIfNotAlready() {\n+        if (tenantControl == TenantControl.NOOP_TENANT_CONTROL) {\n+            tenantControl = nodeEngine.getTenantControlFactory().saveCurrentTenant();\n+            if (tenantControl == null) {\n+                getLogger().warning(String.format(\"TenantControl factory return null: %s - %s)\",\n+                        this.toString(), nodeEngine.getTenantControlFactory().toString()));\n+                tenantControl = TenantControl.NOOP_TENANT_CONTROL;\n+            } else {\n+                setFlag(true, BITMASK_TENANT_CONTROL_SET);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * checks if operation is ready to execute,\n+     * if not, it will be pushed to the back of the queue\n+     * Tenant's isAvailable() class is responsible for waiting\n+     * so there is no tight loop\n+     *\n+     * @return true if ready\n+     */\n+    public boolean isOperationReady() {", "originalCommit": "9114bc47e3a6c8905aa9ab0257c8451f2183e064", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA2NjI2MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r467066261", "bodyText": "must be guarded for rolling upgrades:\nif (out.getVersion().isGreaterOrEqual(Versions.V4_1)) {\n  ... write\n}\n\nAlso, for this to work, this class must implement Versioned interface.", "author": "vbekiaris", "createdAt": "2020-08-07T14:12:28Z", "path": "hazelcast/src/main/java/com/hazelcast/spi/impl/proxyservice/impl/operations/PostJoinProxyOperation.java", "diffHunk": "@@ -86,6 +87,7 @@ protected void writeInternal(ObjectDataOutput out) throws IOException {\n                 out.writeUTF(proxy.getServiceName());\n                 out.writeUTF(proxy.getObjectName());\n                 UUIDSerializationUtil.writeUUID(out, proxy.getSource());\n+                out.writeObject(proxy.getTenantControl());", "originalCommit": "9114bc47e3a6c8905aa9ab0257c8451f2183e064", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA2NjM5Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r467066397", "bodyText": "Same as above for rolling upgrades", "author": "vbekiaris", "createdAt": "2020-08-07T14:12:41Z", "path": "hazelcast/src/main/java/com/hazelcast/spi/impl/proxyservice/impl/operations/PostJoinProxyOperation.java", "diffHunk": "@@ -97,7 +99,7 @@ protected void readInternal(ObjectDataInput in) throws IOException {\n         if (len > 0) {\n             proxies = new ArrayList<>(len);\n             for (int i = 0; i < len; i++) {\n-                ProxyInfo proxy = new ProxyInfo(in.readUTF(), in.readUTF(), UUIDSerializationUtil.readUUID(in));\n+                ProxyInfo proxy = new ProxyInfo(in.readUTF(), in.readUTF(), UUIDSerializationUtil.readUUID(in), in.readObject());", "originalCommit": "9114bc47e3a6c8905aa9ab0257c8451f2183e064", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA4NjI0NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r467086245", "bodyText": "The effects of this method's return value on ICache implementation should not be part of this javadoc. Instead we need something helpful for TenantControlFactory implementors (like you ;-)).", "author": "vbekiaris", "createdAt": "2020-08-07T14:44:38Z", "path": "hazelcast/src/main/java/com/hazelcast/spi/tenantcontrol/TenantControlFactory.java", "diffHunk": "@@ -47,11 +45,14 @@\n      * Further operations from other threads will use the returned context\n      * for this particular Hazelcast object to re-establish the invocation context\n      *\n-     * @param event hook to destroy any Hazelcast object when the tenant is destroyed,\n-     * This is used, for example, to delete all associated caches from the application when\n-     * it gets undeployed, so there are no ClassCastExceptions afterwards\n-     *\n      * @return new TenantControl instance with the saved state of the current tenant\n      */\n-    TenantControl saveCurrentTenant(DestroyEventContext event);\n+    TenantControl saveCurrentTenant();\n+\n+    /**\n+     * If not, CacheConfigs are always sent over the wire as PreJoin ops", "originalCommit": "9114bc47e3a6c8905aa9ab0257c8451f2183e064", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzEwNTg5Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r467105893", "bodyText": "rename method to distributedObjectCreated (to match the term \"distributed object\" for hazelcast-managed objects). Same for objectDestroyed below. (see also similar DistributedObjectListener interface)\nAdditionally, Optionals as wrappers create litter and my personal opinion is that they don't look great as method arguments. I think @Nullable DestroyEventContext destroyEventContext would be better here, but let's see what other reviewers think about this.", "author": "vbekiaris", "createdAt": "2020-08-07T15:18:14Z", "path": "hazelcast/src/main/java/com/hazelcast/spi/tenantcontrol/TenantControl.java", "diffHunk": "@@ -43,18 +42,18 @@\n     /**\n      * Establish this tenant's thread-local context\n      * Particular TenantControl implementation will control the details of how\n-     * createRequestScope parameter is handled, but in general,\n-     * if createRequestScope = false, only ClassLoader is set up,\n-     * if createRequestScope = true, in addition to ClassLoader,\n-     * other things like invocation, EJB/JPA/CDI context should be set up as well\n      *\n-     * In other words, if only app class needs to be resolved, set createRequestScope to false\n-     * If actually calling into user's code, set createRequestScope to true\n-     *\n-     * @param createRequestScope whether to create CDI request scope for this context\n      * @return handle to be able to close the tenant's scope.\n      */\n-    Closeable setTenant(boolean createRequestScope);\n+    Closeable setTenant();\n+\n+    /**\n+     * To be called when Hazelcast object is created\n+     * @param destroyEventContext hook to decouple any Hazelcast object when the tenant is destroyed,\n+     * This is used, for example, to delete all associated caches from the application when\n+     * it gets undeployed, so there are no ClassCastExceptions afterwards\n+     */\n+    void objectCreated(Optional<DestroyEventContext> destroyEventContext);", "originalCommit": "9114bc47e3a6c8905aa9ab0257c8451f2183e064", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAzMDUzNA==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r469030534", "bodyText": "As far as Optional, I like it but I really don't care either way. So if you want me to do @Nullable I will", "author": "lprimak", "createdAt": "2020-08-12T06:23:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzEwNTg5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTA0MzQxNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r469043415", "bodyText": "However, if you look at the implementation, the orElse thing works really well and really descriptive on optionals. I suppose another if() statement will work just as well however I think this looks eligant", "author": "lprimak", "createdAt": "2020-08-12T06:54:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzEwNTg5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk5ODc4MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r484998780", "bodyText": "I still think Optional will pollute the caller side. See also Brian Goetz's https://stackoverflow.com/questions/26327957/should-java-8-getters-return-optional-type/26328555#26328555 : \"You should almost never use it as a field of something or a method parameter.\"", "author": "vbekiaris", "createdAt": "2020-09-08T15:12:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzEwNTg5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTExMTQzNw==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r485111437", "bodyText": "done", "author": "lprimak", "createdAt": "2020-09-08T18:20:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzEwNTg5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzEwOTY3NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r467109674", "bodyText": "Optionals as method arguments? let's see what other reviewers think.", "author": "vbekiaris", "createdAt": "2020-08-07T15:24:54Z", "path": "hazelcast/src/main/java/com/hazelcast/spi/impl/proxyservice/impl/ProxyRegistry.java", "diffHunk": "@@ -194,9 +197,11 @@ public DistributedObjectFuture getOrCreateProxyFuture(String name, UUID source,\n      * @param local        {@code true} if the proxy should be only created on the local member,\n      *                     otherwise fires {@code DistributedObjectEvent} to trigger cluster-wide\n      *                     proxy creation.\n+     * @param tenantControl optional, if it was transferred via PostOp\n      * @return The DistributedObject instance if it is created by this method, null otherwise.\n      */\n-    public DistributedObjectFuture createProxy(String name, UUID source, boolean initialize, boolean local) {\n+    public DistributedObjectFuture createProxy(String name, UUID source, boolean initialize, boolean local,\n+            Optional<TenantControl> tenantControl) {", "originalCommit": "9114bc47e3a6c8905aa9ab0257c8451f2183e064", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTExMTU4Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r485111586", "bodyText": "done", "author": "lprimak", "createdAt": "2020-09-08T18:20:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzEwOTY3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzU1NTQ5OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r467555499", "bodyText": "in this section, the returned value from process conflates the counter to be incremented with the need to retry the task. This is confusing. Maybe keep the counter logic encapsulated in process methods and indicate need to retry with a boolean return type from process? Or someone else may have a better idea", "author": "vbekiaris", "createdAt": "2020-08-09T08:43:15Z", "path": "hazelcast/src/main/java/com/hazelcast/spi/impl/operationexecutor/impl/OperationThread.java", "diffHunk": "@@ -132,20 +132,27 @@ public final void executeRun() {\n \n     private void process(Object task) {\n         try {\n+            SwCounter counter;", "originalCommit": "9114bc47e3a6c8905aa9ab0257c8451f2183e064", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAzMTgxOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r469031819", "bodyText": "You are right that it conflates the return value. However your proposal will lead to a lot of code duplication and opportunity for errors. I think my solution is elegant, even though a bit confusing. I wish we had tuples :) however they do bring some issues as well", "author": "lprimak", "createdAt": "2020-08-12T06:26:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzU1NTQ5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAzMjAyNA==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r469032024", "bodyText": "I will put in a comment to un-confuse", "author": "lprimak", "createdAt": "2020-08-12T06:26:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzU1NTQ5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgxNzMzNA==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r495817334", "bodyText": "Is there an example how much code duplication it actually introduces? I don't think it'll be too much and I must agree this approach is suprising to say the least. It also requires you to do code like this, which might not be necessary if you were passing around boolean:\nreturn currentRunner.run(operation) ? null : completedOperationCount;", "author": "mmedenjak", "createdAt": "2020-09-28T09:46:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzU1NTQ5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTk5ODUwNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r495998505", "bodyText": "It saves at least 12 redundant lines of code in hazelcast/src/main/java/com/hazelcast/spi/impl/operationexecutor/impl/OperationThread.java, you can see the changes right in this PR.\nThe issue here isn't only the therwise-would-be 12 lines of code, the alternative would require creating an if() statement for every one of those counter instances to check if the operation is available, and only then increment the counter, leading to another 20+ line of code duplication, which is very error-prone and would require another 50+ lines of unit tests.\nIn reality it may not be that complex, but just thinking about it makes this solution much more elegant", "author": "lprimak", "createdAt": "2020-09-28T14:50:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzU1NTQ5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ4NDkzMA==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r497484930", "bodyText": "Can you point to the commit where the alternate solution is present? I tried going through the git history for this class but could not find it. The issue being that the current codebase definitely has issues with clarity and I'm unsure if I can assess how worse the alternate solution is.", "author": "mmedenjak", "createdAt": "2020-09-30T12:53:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzU1NTQ5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY1MDA2MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r497650060", "bodyText": "Unfortunately when I did the alternative solution it was pretty bad and I didn't even commit it.\nI think the comment makes the current solution pretty  clear on what it does.\nI can roll this whole thing back and put back the \"bad\" solution but I need some assurances that the work will not be in vain. I need this PR done in 4.1 and if that's what it'll take I can do that (reluctantly)", "author": "lprimak", "createdAt": "2020-09-30T16:37:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzU1NTQ5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY5OTY1MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r497699651", "bodyText": "Ok, this is taking too much time and energy.\nI'll jut revert this change, put in all the duplicate code that was here before\nso we can just move on from this.", "author": "lprimak", "createdAt": "2020-09-30T17:58:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzU1NTQ5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzU1NjQ4MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r467556480", "bodyText": "call may result in an Operation being offloaded for execution in another thread (see OFFLOAD_ORDINAL case below and Offload#start javadoc). Probably we need to just mention the TenantControl relationship in the javadoc of Offload#start, as it is the offloaded operation implementor's responsibility to offload to another thread.", "author": "vbekiaris", "createdAt": "2020-08-09T08:52:51Z", "path": "hazelcast/src/main/java/com/hazelcast/spi/impl/operationservice/impl/OperationRunnerImpl.java", "diffHunk": "@@ -204,23 +204,29 @@ public void run(Operation op) {\n             checkNodeState(op);\n \n             if (timeout(op)) {\n-                return;\n+                return false;\n             }\n \n             ensureNoPartitionProblems(op);\n \n             ensureNoSplitBrain(op);\n \n-            op.beforeRun();\n-\n-            call(op);\n+            if (op.isOperationReady()) {\n+                op.pushThreadContext();\n+                op.beforeRun();\n+                call(op);", "originalCommit": "9114bc47e3a6c8905aa9ab0257c8451f2183e064", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODg3NTAwMA==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r488875000", "bodyText": "done", "author": "lprimak", "createdAt": "2020-09-15T18:25:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzU1NjQ4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzU1ODU3Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r467558576", "bodyText": "rolling upgrades: make this class implement Versioned and guard for cluster version being greater or equal than current one\n(also in readData below)", "author": "vbekiaris", "createdAt": "2020-08-09T09:14:39Z", "path": "hazelcast/src/main/java/com/hazelcast/spi/impl/proxyservice/impl/DistributedObjectEventPacket.java", "diffHunk": "@@ -60,12 +64,17 @@ public UUID getSource() {\n         return source;\n     }\n \n+    public TenantControl getTenantControl() {\n+        return tenantControl;\n+    }\n+\n     @Override\n     public void writeData(ObjectDataOutput out) throws IOException {\n         out.writeBoolean(eventType == EventType.CREATED);\n         out.writeUTF(serviceName);\n         out.writeUTF(name);\n         UUIDSerializationUtil.writeUUID(out, source);\n+        out.writeObject(tenantControl);", "originalCommit": "9114bc47e3a6c8905aa9ab0257c8451f2183e064", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU0MDgyNA==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r485540824", "bodyText": "\"cannot be null\" is a new sentence I guess?", "author": "vbekiaris", "createdAt": "2020-09-09T11:34:29Z", "path": "hazelcast/src/main/java/com/hazelcast/spi/tenantcontrol/TenantControl.java", "diffHunk": "@@ -43,18 +41,19 @@\n     /**\n      * Establish this tenant's thread-local context\n      * Particular TenantControl implementation will control the details of how\n-     * createRequestScope parameter is handled, but in general,\n-     * if createRequestScope = false, only ClassLoader is set up,\n-     * if createRequestScope = true, in addition to ClassLoader,\n-     * other things like invocation, EJB/JPA/CDI context should be set up as well\n      *\n-     * In other words, if only app class needs to be resolved, set createRequestScope to false\n-     * If actually calling into user's code, set createRequestScope to true\n-     *\n-     * @param createRequestScope whether to create CDI request scope for this context\n      * @return handle to be able to close the tenant's scope.\n      */\n-    Closeable setTenant(boolean createRequestScope);\n+    Closeable setTenant();\n+\n+    /**\n+     * To be called when Hazelcast object is created\n+     * @param destroyEventContext hook to decouple any Hazelcast object when the tenant is destroyed,\n+     * This is used, for example, to delete all associated caches from the application when\n+     * it gets undeployed, so there are no ClassCastExceptions afterwards\n+     * cannot be null. This is a functional interface, no-op lambda can be used", "originalCommit": "164021d0811c0fa2115991237705d4f9d9ec7bf6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODgzNjMyNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r488836326", "bodyText": "fixed", "author": "lprimak", "createdAt": "2020-09-15T17:23:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU0MDgyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTY5MTE4NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r485691184", "bodyText": "Is the purpose of this interface to be implemented by user classes? Is it necessary to add this interface and introduce more complication in class loading? If so, then the interface should be placed in a public package.", "author": "vbekiaris", "createdAt": "2020-09-09T15:12:27Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/nio/ClassLoaderUtil.java", "diffHunk": "@@ -39,6 +39,13 @@\n  */\n @SuppressWarnings({\"checkstyle:magicnumber\", \"checkstyle:npathcomplexity\"})\n public final class ClassLoaderUtil {\n+    /**\n+     * Marker interface.\n+     * do not cache constructors if an instance of this interface,\n+     * Used by systems with complicated class loader schemes\n+     * that may interfere with caching\n+     */\n+    public interface BypassClassCaching { };", "originalCommit": "164021d0811c0fa2115991237705d4f9d9ec7bf6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODgzOTAxNA==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r488839014", "bodyText": "Yes, this is correct. I added this because Hazelcast's class caching was causing issues in Payara's class loading.\nI will move it into SPI", "author": "lprimak", "createdAt": "2020-09-15T17:27:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTY5MTE4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzY3MjY1OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r487672659", "bodyText": "since this field is not part of the serialized form of this operation, it should be transient", "author": "vbekiaris", "createdAt": "2020-09-14T06:14:17Z", "path": "hazelcast/src/main/java/com/hazelcast/cache/impl/operation/CacheReplicationOperation.java", "diffHunk": "@@ -64,6 +62,7 @@\n     private final List<CacheConfig> configs = new ArrayList<CacheConfig>();\n     private final Map<String, Map<Data, CacheRecord>> data = new HashMap<String, Map<Data, CacheRecord>>();\n     private CacheNearCacheStateHolder nearCacheStateHolder;\n+    private boolean classesAlwaysAvailable = true;", "originalCommit": "164021d0811c0fa2115991237705d4f9d9ec7bf6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODg0NzYzNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r488847636", "bodyText": "fixed", "author": "lprimak", "createdAt": "2020-09-15T17:36:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzY3MjY1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzY3MzcxNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r487673716", "bodyText": "This needs to be guarded for rolling upgrade (add implements Versioned to class and check out.getVersion() / in.getVersion() in the corresponding read implementation)", "author": "vbekiaris", "createdAt": "2020-09-14T06:17:23Z", "path": "hazelcast/src/main/java/com/hazelcast/cache/impl/operation/CacheReplicationOperation.java", "diffHunk": "@@ -157,7 +146,11 @@ protected void writeInternal(ObjectDataOutput out)\n         int confSize = configs.size();\n         out.writeInt(confSize);\n         for (CacheConfig config : configs) {\n-            out.writeObject(config);\n+            if (!classesAlwaysAvailable) {", "originalCommit": "164021d0811c0fa2115991237705d4f9d9ec7bf6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODg0OTgxMA==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r488849810", "bodyText": "fixed", "author": "lprimak", "createdAt": "2020-09-15T17:40:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzY3MzcxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzY3ODQ4OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r487678489", "bodyText": "This class is not specific to cache implementation, I would move it to com.hazelcast.spi.impl.tenantcontrol. Since it is in impl package, no reason to annotate with @PrivateApi. I see the usefulness of this class, assuming it is used for once-off configuration initialization and not in the hot path.", "author": "vbekiaris", "createdAt": "2020-09-14T06:29:57Z", "path": "hazelcast/src/main/java/com/hazelcast/cache/impl/TenantContextual.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.cache.impl;\n+\n+import com.hazelcast.spi.annotation.PrivateApi;\n+import com.hazelcast.spi.tenantcontrol.TenantControl;\n+import com.hazelcast.spi.tenantcontrol.TenantControl.Closeable;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.function.Supplier;\n+\n+/**\n+ * Represents a value that requires tenant control context to be accessed", "originalCommit": "164021d0811c0fa2115991237705d4f9d9ec7bf6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODg1NzUyMw==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r488857523", "bodyText": "fixed", "author": "lprimak", "createdAt": "2020-09-15T17:53:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzY3ODQ4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzgxNTQ0Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r487815446", "bodyText": "This breaks RU compatibility. CacheDestroyEventContext class and this line need to be restored", "author": "vbekiaris", "createdAt": "2020-09-14T10:38:36Z", "path": "hazelcast/src/main/java/com/hazelcast/cache/impl/CacheDataSerializerHook.java", "diffHunk": "@@ -236,7 +234,6 @@ public DataSerializableFactory createFactory() {\n         constructors[SET_EXPIRY_POLICY] = arg -> new CacheSetExpiryPolicyOperation();\n         constructors[SET_EXPIRY_POLICY_BACKUP] = arg -> new CacheSetExpiryPolicyBackupOperation();\n         constructors[EXPIRE_BATCH_BACKUP] = arg -> new CacheExpireBatchBackupOperation();\n-        constructors[CACHE_DESTROY_EVENT_CONTEXT] = arg -> new CacheDestroyEventContext();", "originalCommit": "164021d0811c0fa2115991237705d4f9d9ec7bf6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODg1NTEyMw==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r488855123", "bodyText": "fixed", "author": "lprimak", "createdAt": "2020-09-15T17:49:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzgxNTQ0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkxMzA1Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r487913057", "bodyText": "why is the second argument always false? It should match OperationThread#priority.", "author": "vbekiaris", "createdAt": "2020-09-14T13:29:51Z", "path": "hazelcast/src/main/java/com/hazelcast/spi/impl/operationexecutor/impl/OperationThread.java", "diffHunk": "@@ -132,20 +132,33 @@ public final void executeRun() {\n \n     private void process(Object task) {\n         try {\n+            SwCounter counter;\n+            // process() will return it's appropriate counter to be incremented\n+            // if process() returns null instead, which means that task's tenant\n+            // is not available, the task will be put in the back of the queue\n+            // this, however, conflates the meaning of SwCounter return value\n+            // design choice needed to be made, otherwise there would be a lot of\n+            // code duplication. Wishing Java had tuples (although they bring their own problems)\n             if (task.getClass() == Packet.class) {\n-                process((Packet) task);\n+                counter = process((Packet) task);\n             } else if (task instanceof Operation) {\n-                process((Operation) task);\n+                counter = process((Operation) task);\n             } else if (task instanceof PartitionSpecificRunnable) {\n-                process((PartitionSpecificRunnable) task);\n+                counter = process((PartitionSpecificRunnable) task);\n             } else if (task instanceof Runnable) {\n-                process((Runnable) task);\n+                counter = process((Runnable) task);\n             } else if (task instanceof TaskBatch) {\n-                process((TaskBatch) task);\n+                counter = process((TaskBatch) task);\n             } else {\n                 throw new IllegalStateException(\"Unhandled task:\" + task);\n             }\n-            completedTotalCount.inc();\n+            if (counter != null) {\n+                counter.inc();\n+                completedTotalCount.inc();\n+            } else {\n+                // retry later if not ready\n+                queue.add(task, false);", "originalCommit": "164021d0811c0fa2115991237705d4f9d9ec7bf6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODg1NjUwMA==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r488856500", "bodyText": "fixed", "author": "lprimak", "createdAt": "2020-09-15T17:51:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkxMzA1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk0MDcwMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r487940701", "bodyText": "add javadoc explaining possible return values", "author": "vbekiaris", "createdAt": "2020-09-14T13:56:11Z", "path": "hazelcast/src/main/java/com/hazelcast/spi/impl/operationexecutor/OperationRunner.java", "diffHunk": "@@ -49,11 +49,11 @@ public OperationRunner(int partitionId) {\n \n     public abstract long executedOperationsCount();\n \n-    public abstract void run(Packet packet) throws Exception;\n+    public abstract boolean run(Packet packet) throws Exception;", "originalCommit": "164021d0811c0fa2115991237705d4f9d9ec7bf6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODg2MjU3OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r488862578", "bodyText": "fixed", "author": "lprimak", "createdAt": "2020-09-15T18:02:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk0MDcwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk0MDk4Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r487940983", "bodyText": "javadoc: same as above", "author": "vbekiaris", "createdAt": "2020-09-14T13:56:28Z", "path": "hazelcast/src/main/java/com/hazelcast/spi/impl/operationexecutor/OperationRunner.java", "diffHunk": "@@ -49,11 +49,11 @@ public OperationRunner(int partitionId) {\n \n     public abstract long executedOperationsCount();\n \n-    public abstract void run(Packet packet) throws Exception;\n+    public abstract boolean run(Packet packet) throws Exception;\n \n     public abstract void run(Runnable task);\n \n-    public abstract void run(Operation task);\n+    public abstract boolean run(Operation task);", "originalCommit": "164021d0811c0fa2115991237705d4f9d9ec7bf6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODg2MjY5NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r488862695", "bodyText": "fixed", "author": "lprimak", "createdAt": "2020-09-15T18:02:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk0MDk4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc0MDg5Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r495740897", "bodyText": "I see you've basically removed all previous logic and switched to the new one. Now, what should happen if there's a cluster comprised out of 4.1 members (having the new logic) but operating at a cluster version of 4.0? Since the old logic was removed but the new logic isn't in effect till the cluster version is 4.1, neither will actually be used and in this case it seems like tenant control is completely ignored.\nPossibly, we need to keep the old logic running till the cluster version is 4.1.", "author": "mmedenjak", "createdAt": "2020-09-28T07:31:26Z", "path": "hazelcast/src/main/java/com/hazelcast/cache/impl/tenantcontrol/CacheDestroyEventContext.java", "diffHunk": "@@ -42,21 +42,6 @@ public CacheDestroyEventContext(String cacheName) {\n         this.cacheName = cacheName;\n     }\n \n-    @Override", "originalCommit": "19db19f642b571041435a8469f4d0a3e65f09d9d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjAwMTAyOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r496001029", "bodyText": "old logic didn't work correctly under any circumstances anyway, it actually created more problems, so it brings no value here, actually fixes a previous problem.", "author": "lprimak", "createdAt": "2020-09-28T14:52:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc0MDg5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ2NzAwMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r497467001", "bodyText": "Ok, if that's the case...", "author": "mmedenjak", "createdAt": "2020-09-30T12:25:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc0MDg5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc1Mzg1NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r495753855", "bodyText": "It's rather awkward that tenant control is scattered in different subsystems. Some of it is in distributed proxies, some of it is in the operation subsystem, some of it is in the record stores. Perhaps the most surprising part is that it is part of the proxies, which should be simple lightweight facades over the operations sent to members.\nAs far as I can see, it's mostly because you would like to hook into the lifecycle and destroy mechanism. I see two issues with this:\n\nfirst, the proxy lifecycle is not synchronized with the partition operations. That means, you might destroy a proxy on one thread while there's a partition operation currently running and using a tenant control\nsecondly, as initially mentioned, it's rather awkward to see tenant control in the proxy and the operation subsystem. Proxies are also part of hazelcast clients and as far as I could tell, it's not really needed for clients to interact with tenant control, as they might not have any cache classes in the classpath and basically the tenant control is part of the operation subsystem.\n\nAs such, I suggest that you keep the tenant control as part of the cache service or the cache record store and move the tenant control cleanup to com.hazelcast.cache.impl.AbstractCacheService#deleteCache, which is what a member will run once a cache (and proxy) is destroyed.", "author": "mmedenjak", "createdAt": "2020-09-28T07:56:41Z", "path": "hazelcast/src/main/java/com/hazelcast/cache/impl/AbstractCacheRecordStore.java", "diffHunk": "@@ -164,64 +162,72 @@ public AbstractCacheRecordStore(String cacheNameWithPrefix, int partitionId, Nod\n             throw new CacheNotExistsException(\"Cache \" + cacheNameWithPrefix + \" is already destroyed or not created yet, on \"\n                     + nodeEngine.getLocalMember());\n         }\n-        Closeable tenantContext = CacheConfigAccessor.getTenantControl(cacheConfig).setTenant(true);\n-        try {\n-            this.eventJournalConfig = cacheConfig.getEventJournalConfig();\n-            this.evictionConfig = cacheConfig.getEvictionConfig();\n-            if (evictionConfig == null) {\n-                throw new IllegalStateException(\"Eviction config cannot be null!\");\n-            }\n-            this.wanReplicationEnabled = cacheService.isWanReplicationEnabled(cacheNameWithPrefix);\n-            this.disablePerEntryInvalidationEvents = cacheConfig.isDisablePerEntryInvalidationEvents();\n-            initializeStatisticsAndFactories(cacheNameWithPrefix);\n-\n-            EvictionPolicyComparator evictionPolicyComparator = createEvictionPolicyComparator(evictionConfig);\n-            evictionPolicyComparator = injectDependencies(evictionPolicyComparator);\n-            this.evictionPolicyEvaluator = new EvictionPolicyEvaluator<>(evictionPolicyComparator);\n-            this.cacheContext = cacheService.getOrCreateCacheContext(cacheNameWithPrefix);\n-            this.records = createRecordCacheMap();\n-            this.evictionChecker = createCacheEvictionChecker(evictionConfig.getSize(), evictionConfig.getMaxSizePolicy());\n-            this.evictionStrategy = createEvictionStrategy(evictionConfig);\n-            this.objectNamespace = CacheService.getObjectNamespace(cacheNameWithPrefix);\n-            this.persistWanReplicatedData = canPersistWanReplicatedData(cacheConfig, nodeEngine);\n-            this.cacheRecordFactory = new CacheRecordFactory(cacheConfig.getInMemoryFormat(), ss);\n-            this.valueComparator = getValueComparatorOf(cacheConfig.getInMemoryFormat());\n-            this.clearExpiredRecordsTask = cacheService.getExpirationManager().getTask();\n-\n-            registerResourceIfItIsClosable(cacheWriter);\n-            registerResourceIfItIsClosable(cacheLoader);\n-            registerResourceIfItIsClosable(defaultExpiryPolicy);\n-            init();\n-        } finally {\n-            try {\n-                tenantContext.close();\n-            } catch (IOException ex) {\n-                ExceptionUtil.rethrow(ex);\n-            }\n-        }\n-    }\n+        this.eventJournalConfig = cacheConfig.getEventJournalConfig();\n+        this.evictionConfig = cacheConfig.getEvictionConfig();\n+        if (evictionConfig == null) {\n+            throw new IllegalStateException(\"Eviction config cannot be null!\");\n+        }\n+        this.wanReplicationEnabled = cacheService.isWanReplicationEnabled(cacheNameWithPrefix);\n+        this.disablePerEntryInvalidationEvents = cacheConfig.isDisablePerEntryInvalidationEvents();\n+\n+        EvictionPolicyComparator evictionPolicyComparator = createEvictionPolicyComparator(evictionConfig);\n+        evictionPolicyComparator = injectDependencies(evictionPolicyComparator);\n+        this.evictionPolicyEvaluator = new EvictionPolicyEvaluator<>(evictionPolicyComparator);\n+        this.cacheContext = cacheService.getOrCreateCacheContext(cacheNameWithPrefix);\n+        this.records = createRecordCacheMap();\n+        this.evictionChecker = createCacheEvictionChecker(evictionConfig.getSize(), evictionConfig.getMaxSizePolicy());\n+        this.evictionStrategy = createEvictionStrategy(evictionConfig);\n+        this.objectNamespace = CacheService.getObjectNamespace(cacheNameWithPrefix);\n+        this.persistWanReplicatedData = canPersistWanReplicatedData(cacheConfig, nodeEngine);\n+        this.cacheRecordFactory = new CacheRecordFactory(cacheConfig.getInMemoryFormat(), ss);\n+        this.valueComparator = getValueComparatorOf(cacheConfig.getInMemoryFormat());\n+        this.clearExpiredRecordsTask = cacheService.getExpirationManager().getTask();\n \n-    private void initializeStatisticsAndFactories(String cacheNameWithPrefix) {\n         if (cacheConfig.isStatisticsEnabled()) {\n             statistics = cacheService.createCacheStatIfAbsent(cacheNameWithPrefix);\n         }\n-        if (cacheConfig.getCacheLoaderFactory() != null) {\n-            Factory<CacheLoader> cacheLoaderFactory = cacheConfig.getCacheLoaderFactory();\n-            cacheLoaderFactory = injectDependencies(cacheLoaderFactory);\n-            cacheLoader = cacheLoaderFactory.create();\n-            cacheLoader = injectDependencies(cacheLoader);\n-        }\n-        if (cacheConfig.getCacheWriterFactory() != null) {\n-            Factory<CacheWriter> cacheWriterFactory = cacheConfig.getCacheWriterFactory();\n-            cacheWriterFactory = injectDependencies(cacheWriterFactory);\n-            cacheWriter = cacheWriterFactory.create();\n-            cacheWriter = injectDependencies(cacheWriter);\n-        }\n+        injectDependencies(evictionPolicyEvaluator.getEvictionPolicyComparator());\n+        TenantControl tenantControl = nodeEngine.getProxyService()", "originalCommit": "19db19f642b571041435a8469f4d0a3e65f09d9d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA1OTk2OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r496059968", "bodyText": "Doesn't this undo the part of the effort of moving out tenant control out of the cache service? I thought the idea was to make it generic and not linked to cache.\nI agree with you that it looks awkward however I don't know enough to see where it would be a better, generic place to put it that's accessible to all", "author": "lprimak", "createdAt": "2020-09-28T15:56:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc1Mzg1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA2NTI0NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r496065244", "bodyText": "I basically need something 'global' where I can retrieve tenant control by service and distributed object names. Is there any generic place like that?", "author": "lprimak", "createdAt": "2020-09-28T16:04:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc1Mzg1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ2OTg0MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r497469841", "bodyText": "It doesn't need to be just in the cache service, it can be part of any service that wishes to participate in tenant control. Some services may not need to participate in tenant control so hooking it into the proxy lifecycle might be unnecessary there (e.g. FlakeIdGenerator, PNCounter).\nAs for what would be the best \"global\" place, I guess it's just like any other helper subsystem (execution service, proxy service, ...) so to me NodeEngine.getTenantControl seems ok and generally NodeEngine is readily available almost everywhere.", "author": "mmedenjak", "createdAt": "2020-09-30T12:30:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc1Mzg1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY1MTAxMA==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r497651010", "bodyText": "Ok, I can move it out of proxy into NodeEngine", "author": "lprimak", "createdAt": "2020-09-30T16:39:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc1Mzg1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY3OTI1Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r497679257", "bodyText": "Let me correct that, I need to assess the feasibility of it first", "author": "lprimak", "createdAt": "2020-09-30T17:23:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc1Mzg1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY4MjQwMw==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r497682403", "bodyText": "Ok, the problem I am having is that tenant control needs to go over the wire when distributed object is created.\nThis is why I put it into proxy anyway. Do you have the alternative of how to get tenant control created correctly with the distributed object while not using the proxy as the vehicle for this?", "author": "lprimak", "createdAt": "2020-09-30T17:28:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc1Mzg1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY4NjkzOA==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r497686938", "bodyText": "Let me rephrase that. The 'specific' tenant control instance needs to be created when distributed object is created, and needs to go over the wire and be 'held' by the same distributed object everywhere in the cluster. This is why the code went into Proxy in the first place, because it is the 'mirror' of the distributed object on every node.\nNodeEngine doesn't seem to have enough state so I can generically, get correct tenant control that's attached to a particular object.\nSo the requirements are:\n\ntenant control holds state on a per-object basis, and needs to be distributed on the network\ntenant control needs to be kept with the object through all cluster nodes\nObjects, such as CacheRecordStore need object-specific tenantControl when created\n\nAgain, I saw the proxy as an appropriate method for this, as it's the node's view into a distributed object.\nAm I not seeing something obvious here? Is there another generic object that's attached to every\ndistributed object that could hold TenantControl that I am not seeing?", "author": "lprimak", "createdAt": "2020-09-30T17:36:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc1Mzg1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI0ODU1Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r498248553", "bodyText": "You're right, a proxy does seem like the perfect place for it then. Alternatively, it could be placed in a service, much like the proxy service, in NodeEngine, and share the same lifecycle, so that we could avoid mixing concerns in the proxy service and its' classes. Still, the proxy service and all of its' classes are private API, so we may simply ignore this complexity at this point, and merge it, only to consider moving it elsewhere in a subsequent PR.\nSummary - I'll think about it a bit more but we can say this is not a blocker for the merge.", "author": "mmedenjak", "createdAt": "2020-10-01T13:34:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc1Mzg1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc1NzY0NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r495757645", "bodyText": "Can you avoid creating TenantContextual wrappers in case there are no factories and no expiry policy? Thing is, we're targetting high partition counts (e.g. 50k) and with this code, every record store of every cache will have three TenantContextual objects wrapped in LatencyTrackingCacheLoader, wrapped in more TenantContextual.\nSo if I'm calculating this correct, each ICache with no cache loader, cache writer or expiry policy will have hundreds of thousands of objects instantiated. Instead, you can have NOOP implementations to avoid null checks.", "author": "mmedenjak", "createdAt": "2020-09-28T08:03:41Z", "path": "hazelcast/src/main/java/com/hazelcast/cache/impl/AbstractCacheRecordStore.java", "diffHunk": "@@ -164,64 +162,72 @@ public AbstractCacheRecordStore(String cacheNameWithPrefix, int partitionId, Nod\n             throw new CacheNotExistsException(\"Cache \" + cacheNameWithPrefix + \" is already destroyed or not created yet, on \"\n                     + nodeEngine.getLocalMember());\n         }\n-        Closeable tenantContext = CacheConfigAccessor.getTenantControl(cacheConfig).setTenant(true);\n-        try {\n-            this.eventJournalConfig = cacheConfig.getEventJournalConfig();\n-            this.evictionConfig = cacheConfig.getEvictionConfig();\n-            if (evictionConfig == null) {\n-                throw new IllegalStateException(\"Eviction config cannot be null!\");\n-            }\n-            this.wanReplicationEnabled = cacheService.isWanReplicationEnabled(cacheNameWithPrefix);\n-            this.disablePerEntryInvalidationEvents = cacheConfig.isDisablePerEntryInvalidationEvents();\n-            initializeStatisticsAndFactories(cacheNameWithPrefix);\n-\n-            EvictionPolicyComparator evictionPolicyComparator = createEvictionPolicyComparator(evictionConfig);\n-            evictionPolicyComparator = injectDependencies(evictionPolicyComparator);\n-            this.evictionPolicyEvaluator = new EvictionPolicyEvaluator<>(evictionPolicyComparator);\n-            this.cacheContext = cacheService.getOrCreateCacheContext(cacheNameWithPrefix);\n-            this.records = createRecordCacheMap();\n-            this.evictionChecker = createCacheEvictionChecker(evictionConfig.getSize(), evictionConfig.getMaxSizePolicy());\n-            this.evictionStrategy = createEvictionStrategy(evictionConfig);\n-            this.objectNamespace = CacheService.getObjectNamespace(cacheNameWithPrefix);\n-            this.persistWanReplicatedData = canPersistWanReplicatedData(cacheConfig, nodeEngine);\n-            this.cacheRecordFactory = new CacheRecordFactory(cacheConfig.getInMemoryFormat(), ss);\n-            this.valueComparator = getValueComparatorOf(cacheConfig.getInMemoryFormat());\n-            this.clearExpiredRecordsTask = cacheService.getExpirationManager().getTask();\n-\n-            registerResourceIfItIsClosable(cacheWriter);\n-            registerResourceIfItIsClosable(cacheLoader);\n-            registerResourceIfItIsClosable(defaultExpiryPolicy);\n-            init();\n-        } finally {\n-            try {\n-                tenantContext.close();\n-            } catch (IOException ex) {\n-                ExceptionUtil.rethrow(ex);\n-            }\n-        }\n-    }\n+        this.eventJournalConfig = cacheConfig.getEventJournalConfig();\n+        this.evictionConfig = cacheConfig.getEvictionConfig();\n+        if (evictionConfig == null) {\n+            throw new IllegalStateException(\"Eviction config cannot be null!\");\n+        }\n+        this.wanReplicationEnabled = cacheService.isWanReplicationEnabled(cacheNameWithPrefix);\n+        this.disablePerEntryInvalidationEvents = cacheConfig.isDisablePerEntryInvalidationEvents();\n+\n+        EvictionPolicyComparator evictionPolicyComparator = createEvictionPolicyComparator(evictionConfig);\n+        evictionPolicyComparator = injectDependencies(evictionPolicyComparator);\n+        this.evictionPolicyEvaluator = new EvictionPolicyEvaluator<>(evictionPolicyComparator);\n+        this.cacheContext = cacheService.getOrCreateCacheContext(cacheNameWithPrefix);\n+        this.records = createRecordCacheMap();\n+        this.evictionChecker = createCacheEvictionChecker(evictionConfig.getSize(), evictionConfig.getMaxSizePolicy());\n+        this.evictionStrategy = createEvictionStrategy(evictionConfig);\n+        this.objectNamespace = CacheService.getObjectNamespace(cacheNameWithPrefix);\n+        this.persistWanReplicatedData = canPersistWanReplicatedData(cacheConfig, nodeEngine);\n+        this.cacheRecordFactory = new CacheRecordFactory(cacheConfig.getInMemoryFormat(), ss);\n+        this.valueComparator = getValueComparatorOf(cacheConfig.getInMemoryFormat());\n+        this.clearExpiredRecordsTask = cacheService.getExpirationManager().getTask();\n \n-    private void initializeStatisticsAndFactories(String cacheNameWithPrefix) {\n         if (cacheConfig.isStatisticsEnabled()) {\n             statistics = cacheService.createCacheStatIfAbsent(cacheNameWithPrefix);\n         }\n-        if (cacheConfig.getCacheLoaderFactory() != null) {\n-            Factory<CacheLoader> cacheLoaderFactory = cacheConfig.getCacheLoaderFactory();\n-            cacheLoaderFactory = injectDependencies(cacheLoaderFactory);\n-            cacheLoader = cacheLoaderFactory.create();\n-            cacheLoader = injectDependencies(cacheLoader);\n-        }\n-        if (cacheConfig.getCacheWriterFactory() != null) {\n-            Factory<CacheWriter> cacheWriterFactory = cacheConfig.getCacheWriterFactory();\n-            cacheWriterFactory = injectDependencies(cacheWriterFactory);\n-            cacheWriter = cacheWriterFactory.create();\n-            cacheWriter = injectDependencies(cacheWriter);\n-        }\n+        injectDependencies(evictionPolicyEvaluator.getEvictionPolicyComparator());\n+        TenantControl tenantControl = nodeEngine.getProxyService()\n+                .getTenantControl(ICacheService.SERVICE_NAME, cacheNameWithPrefix);\n+        cacheLoader = new TenantContextual<>(this::initCacheLoader,", "originalCommit": "19db19f642b571041435a8469f4d0a3e65f09d9d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA4ODU3MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r496088570", "bodyText": "this turned out to be quite the task :)", "author": "lprimak", "createdAt": "2020-09-28T16:40:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc1NzY0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ3MTcxNA==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r497471714", "bodyText": "Looks good.", "author": "mmedenjak", "createdAt": "2020-09-30T12:33:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc1NzY0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc5NjAzMg==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r495796032", "bodyText": "You can also add Nonnull annotation here then, also add Nonnull or Nullable for other methods, parameters and return values.", "author": "mmedenjak", "createdAt": "2020-09-28T09:10:47Z", "path": "hazelcast/src/main/java/com/hazelcast/spi/tenantcontrol/TenantControl.java", "diffHunk": "@@ -43,18 +41,19 @@\n     /**\n      * Establish this tenant's thread-local context\n      * Particular TenantControl implementation will control the details of how\n-     * createRequestScope parameter is handled, but in general,\n-     * if createRequestScope = false, only ClassLoader is set up,\n-     * if createRequestScope = true, in addition to ClassLoader,\n-     * other things like invocation, EJB/JPA/CDI context should be set up as well\n      *\n-     * In other words, if only app class needs to be resolved, set createRequestScope to false\n-     * If actually calling into user's code, set createRequestScope to true\n-     *\n-     * @param createRequestScope whether to create CDI request scope for this context\n      * @return handle to be able to close the tenant's scope.\n      */\n-    Closeable setTenant(boolean createRequestScope);\n+    Closeable setTenant();\n+\n+    /**\n+     * To be called when Hazelcast object is created\n+     * @param destroyEventContext hook to decouple any Hazelcast object when the tenant is destroyed,\n+     * This is used, for example, to delete all associated caches from the application when\n+     * it gets undeployed, so there are no ClassCastExceptions afterwards.\n+     * Cannot be null. This is a functional interface, so no-op lambda can be used instead.\n+     */\n+    void distributedObjectCreated(DestroyEventContext destroyEventContext);", "originalCommit": "19db19f642b571041435a8469f4d0a3e65f09d9d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjExMDI5OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r496110299", "bodyText": "done", "author": "lprimak", "createdAt": "2020-09-28T17:16:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc5NjAzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc5NjM5NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r495796394", "bodyText": "Minor - \"Particular TenantControl implementation will control the details of how\" can probably be rephrased as it sounds strange.", "author": "mmedenjak", "createdAt": "2020-09-28T09:11:22Z", "path": "hazelcast/src/main/java/com/hazelcast/spi/tenantcontrol/TenantControl.java", "diffHunk": "@@ -43,18 +41,19 @@\n     /**\n      * Establish this tenant's thread-local context\n      * Particular TenantControl implementation will control the details of how", "originalCommit": "19db19f642b571041435a8469f4d0a3e65f09d9d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjExMTA0OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r496111049", "bodyText": "done", "author": "lprimak", "createdAt": "2020-09-28T17:17:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc5NjM5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc5OTE0Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r495799147", "bodyText": "Minor: {@code null} and {@link ClassCastException}", "author": "mmedenjak", "createdAt": "2020-09-28T09:16:02Z", "path": "hazelcast/src/main/java/com/hazelcast/spi/tenantcontrol/TenantControl.java", "diffHunk": "@@ -43,18 +41,19 @@\n     /**\n      * Establish this tenant's thread-local context\n      * Particular TenantControl implementation will control the details of how\n-     * createRequestScope parameter is handled, but in general,\n-     * if createRequestScope = false, only ClassLoader is set up,\n-     * if createRequestScope = true, in addition to ClassLoader,\n-     * other things like invocation, EJB/JPA/CDI context should be set up as well\n      *\n-     * In other words, if only app class needs to be resolved, set createRequestScope to false\n-     * If actually calling into user's code, set createRequestScope to true\n-     *\n-     * @param createRequestScope whether to create CDI request scope for this context\n      * @return handle to be able to close the tenant's scope.\n      */\n-    Closeable setTenant(boolean createRequestScope);\n+    Closeable setTenant();\n+\n+    /**\n+     * To be called when Hazelcast object is created\n+     * @param destroyEventContext hook to decouple any Hazelcast object when the tenant is destroyed,\n+     * This is used, for example, to delete all associated caches from the application when\n+     * it gets undeployed, so there are no ClassCastExceptions afterwards.", "originalCommit": "19db19f642b571041435a8469f4d0a3e65f09d9d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjExMTU5MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r496111590", "bodyText": "done", "author": "lprimak", "createdAt": "2020-09-28T17:18:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc5OTE0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgwMDc3NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r495800774", "bodyText": "Minor: maybe we can change the method names distributedObjectCreated and distributedObjectDestroyed. I understand they should be called when the object is created and destroyed but this tells more about when they will be called rather than what the implementation should do. In some other case, maybe we might call these methods when the object hasn't yet been created or destroyed.\nMaybe something like registerContext or unregisterContext is better?", "author": "mmedenjak", "createdAt": "2020-09-28T09:18:51Z", "path": "hazelcast/src/main/java/com/hazelcast/spi/tenantcontrol/TenantControl.java", "diffHunk": "@@ -65,5 +64,29 @@\n      * Hazelcast object from the tenant\n      * This is so the TenantControl itself can be garbage collected\n      */\n-    void unregister();\n+    void distributedObjectDestroyed();", "originalCommit": "19db19f642b571041435a8469f4d0a3e65f09d9d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyNDQ4NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r496124484", "bodyText": "renamed to registerObject / unregisterObject", "author": "lprimak", "createdAt": "2020-09-28T17:41:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgwMDc3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgwMjI2OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r495802269", "bodyText": "Umph. We are leaking private API here and this is a big problem in terms of compatibility. Operation is very private API and it's class name, package, methods and implementation may change heavily between releases or even get deleted completely. Can you provide less context here?", "author": "mmedenjak", "createdAt": "2020-09-28T09:21:19Z", "path": "hazelcast/src/main/java/com/hazelcast/spi/tenantcontrol/TenantControl.java", "diffHunk": "@@ -65,5 +64,29 @@\n      * Hazelcast object from the tenant\n      * This is so the TenantControl itself can be garbage collected\n      */\n-    void unregister();\n+    void distributedObjectDestroyed();\n+\n+    /**\n+     * Checks if tenant app is loaded at the current time and classes are available\n+     *\n+     * @param op passed so the tenant can filter on who is calling\n+     * @return true if tenant is loaded and classes are available\n+     */\n+    boolean isAvailable(Operation op);", "originalCommit": "19db19f642b571041435a8469f4d0a3e65f09d9d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjExNDU1OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r496114558", "bodyText": "All I could think of is class name (String) or actual class (Class) objects I'll change it to Class for now as it seems more type-safe", "author": "lprimak", "createdAt": "2020-09-28T17:23:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgwMjI2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ3MjQ3Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r497472472", "bodyText": "Again, operations might change class names and be deleted across minor releases so I'm not sure this will be good enough. Perhaps something even more lightweight like service name and distributed object name? Operations that aren't related to a distributed object (e.g. com.hazelcast.internal.cluster.impl.operations.HeartbeatOp, WhoisMasterOp, com.hazelcast.internal.management.operation.SetLicenseOperation) would then not participate in tenant control, which seems like a good thing.", "author": "mmedenjak", "createdAt": "2020-09-30T12:34:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgwMjI2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY3NzIyNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r497677226", "bodyText": "The point of this is to filter by operation. service or distributed object names are useless in this case.", "author": "lprimak", "createdAt": "2020-09-30T17:19:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgwMjI2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI1NTQxNA==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r498255414", "bodyText": "It is very inconvenient from the standpoint of the SPI implementations as users might depend on classes, or methods, or API, which is internal and subject to change. While on this subject, I'm thinking not only what can happen in terms of when we change a class name/package, or add/remove methods but what would happen for your SPI implementation if we added a new operation like com.hazelcast.cache.internal.SuperFastReadOperation. How would you make sure that operation is handled properly then?\nBut, in an effort to proceed further with this PR, here are some questions and ideas:\n\u2022 what is it that you actually use from an operation? What's important to your implementation of the SPI? The operation name? I'm thinking if we can introduce a new interface which will clearly describe the things that you require, and our private API can provide just this information.\n\u2022 we can keep providing the Operation, but add a big warning in javadoc, and elsewhere, that it's private API and subject to change. Far from elegant, but you'd get access to the Operation, and we distance ourselves from any SPI implementations that might break because of our changes.\n\u2022 alternatively, although unlikely, we can maybe think about making the tenant control part of the private API. That way, it has access to all other private API and we can change it any way we want in any release. Still, this option is rather \"dirty\"", "author": "mmedenjak", "createdAt": "2020-10-01T13:44:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgwMjI2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg5NzczMA==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r498897730", "bodyText": "We decided not to pursue moving this SPI into a private/internal package as it wouldn't really be owned by Hazelcast and we could not then move it, remove it, augment it when and how we would like to. Instead, it would effectively be owned by Payara.\nInstead, we have managed to agree on what is actually needed from the perspective of the operation. Resolving this comment as we will soon update this part of the code to avoid leaking private API.", "author": "mmedenjak", "createdAt": "2020-10-02T15:36:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgwMjI2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgwMzE2Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r495803166", "bodyText": "What's the difference between this method and close? I would expect close to clear the context.", "author": "mmedenjak", "createdAt": "2020-09-28T09:22:48Z", "path": "hazelcast/src/main/java/com/hazelcast/spi/tenantcontrol/TenantControl.java", "diffHunk": "@@ -65,5 +64,29 @@\n      * Hazelcast object from the tenant\n      * This is so the TenantControl itself can be garbage collected\n      */\n-    void unregister();\n+    void distributedObjectDestroyed();\n+\n+    /**\n+     * Checks if tenant app is loaded at the current time and classes are available\n+     *\n+     * @param op passed so the tenant can filter on who is calling\n+     * @return true if tenant is loaded and classes are available\n+     */\n+    boolean isAvailable(Operation op);\n+\n+    /**\n+     * clean up the thread to avoid potential class loader leaks\n+     */\n+    void clearThreadContext();", "originalCommit": "19db19f642b571041435a8469f4d0a3e65f09d9d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyNTkzNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r496125936", "bodyText": "added more comments. This is catch-all method that clears all of the potential context instead of just the one that was used in setTenant()", "author": "lprimak", "createdAt": "2020-09-28T17:43:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgwMzE2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgwODU1NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r495808554", "bodyText": "Why do we need to reserialise on cache destroy? Keep in mind this is concurrent with cache partition operations.", "author": "mmedenjak", "createdAt": "2020-09-28T09:31:55Z", "path": "hazelcast/src/main/java/com/hazelcast/cache/impl/AbstractCacheService.java", "diffHunk": "@@ -503,35 +489,18 @@ public CacheConfig findCacheConfig(String simpleName) {\n         try {\n             // Set name explicitly, because found config might have a wildcard name.\n             CacheConfig cacheConfig = new CacheConfig(cacheSimpleConfig).setName(simpleName);\n-            setTenantControl(cacheConfig);\n             return cacheConfig;\n         } catch (Exception e) {\n             throw new CacheException(e);\n         }\n     }\n \n-    @Override\n-    public void setTenantControl(CacheConfig cacheConfig) {\n-        if (!NOOP_TENANT_CONTROL.equals(getTenantControl(cacheConfig))) {\n-            // a tenant control has already been explicitly set for the cache config\n-            return;\n-        }\n-        // associate cache config with the current thread's tenant\n-        // and add hook so when the tenant is destroyed, so is the cache config\n-        TenantControlFactory tenantControlFactory = null;\n-        try {\n-            tenantControlFactory = ServiceLoader.load(TenantControlFactory.class,\n-                    TENANT_CONTROL_FACTORY, nodeEngine.getConfigClassLoader());\n-        } catch (Exception e) {\n-            if (logger.isFinestEnabled()) {\n-                logger.finest(\"Could not load service provider for TenantControl\", e);\n-            }\n-        }\n-        if (tenantControlFactory == null) {\n-            tenantControlFactory = NOOP_TENANT_CONTROL_FACTORY;\n-        }\n-        CacheConfigAccessor.setTenantControl(cacheConfig, tenantControlFactory.saveCurrentTenant(\n-                new CacheDestroyEventContext(cacheConfig.getName())));\n+    public void reSerializeCacheConfig(CacheConfig cacheConfig) {\n+        CompletableFuture<CacheConfig> future = new CompletableFuture<>();", "originalCommit": "19db19f642b571041435a8469f4d0a3e65f09d9d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyODY4Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r496128686", "bodyText": "All user classes have to be removed from the cache configuration, i.e. key types, value types, all factories, etc. when tenant is destroyed, otherwise there would be class loading issues.\nThis is called when tenant is undeployed so there would be no other cache operations with this configuration in this case.", "author": "lprimak", "createdAt": "2020-09-28T17:48:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgwODU1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ5NDY0OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r497494648", "bodyText": "As we don't have any synchronization between the proxy lifecycle and the operation lifecycle, it is still possible there are ongoing operations using tenant control, e.g. replication operations, cache read/write operations being retried because of some network issues... On the other hand, as this would be called from some unknown thread by the SPI implementation, there's not much we can do here but document that it must be invoked once there are no more ongoing operations.", "author": "mmedenjak", "createdAt": "2020-09-30T13:08:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgwODU1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY4MzYwNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r497683606", "bodyText": "in tenant control's case, this is only called when tenant is unavailable, and in such case all operations are not going to go through (would be put back in the queue) and will eventually time out. This is the correct behavior in this instance.", "author": "lprimak", "createdAt": "2020-09-30T17:30:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgwODU1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI1NzYxMw==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r498257613", "bodyText": "Ok, right, thanks.", "author": "mmedenjak", "createdAt": "2020-10-01T13:47:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgwODU1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgwOTMzMg==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r495809332", "bodyText": "Can you add javadoc explaining what resolved is about?", "author": "mmedenjak", "createdAt": "2020-09-28T09:33:16Z", "path": "hazelcast/src/main/java/com/hazelcast/cache/impl/DeferredValue.java", "diffHunk": "@@ -71,8 +71,12 @@ public Data getSerializedValue(SerializationService serializationService) {\n         return serializedValue;\n     }\n \n-    // returns a new DeferredValue representing the same value as this\n     public DeferredValue<V> shallowCopy() {\n+        return shallowCopy(true, null);\n+    }\n+\n+    // returns a new DeferredValue representing the same value as this\n+    public DeferredValue<V> shallowCopy(boolean resolved, SerializationService serializationService) {", "originalCommit": "19db19f642b571041435a8469f4d0a3e65f09d9d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEzNDI3Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r496134272", "bodyText": "done", "author": "lprimak", "createdAt": "2020-09-28T17:58:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgwOTMzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgxMDUyOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r495810529", "bodyText": "Can you initialise the serialisation service on the config before calling this method instead of providing it as an argument?", "author": "mmedenjak", "createdAt": "2020-09-28T09:35:25Z", "path": "hazelcast/src/main/java/com/hazelcast/config/CacheConfig.java", "diffHunk": "@@ -708,11 +688,11 @@ protected void readListenerConfigurations(ObjectDataInput in) throws IOException\n      *                 or will be resolved to loaded classes and the actual {@code keyType} and {@code valueType} will be copied.\n      *                 Otherwise, this configuration's {@code keyClassName} and {@code valueClassName} will be copied to the\n      *                 target config, to be resolved at a later time.\n+     * @param backupSerializationService in case serialization service isn't initialized", "originalCommit": "19db19f642b571041435a8469f4d0a3e65f09d9d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEzNDg0Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r496134843", "bodyText": "Here I was simply trying to resolve an NPE. I was not going to refactor this class without knowing the sideffects.\nPerhaps you can ask @vbekiaris as I believe he wrote that class", "author": "lprimak", "createdAt": "2020-09-28T17:59:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgxMDUyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI1ODg4MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r498258880", "bodyText": "It's not a blocker but I think it would be safe to set the serialisation service before calling this method. I'm more worried about the changes in the proxy and operation system than any issues that could come up as a side effect of setting the serialisation service on CacheConfig :)", "author": "mmedenjak", "createdAt": "2020-10-01T13:49:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgxMDUyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgxMzAzOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r495813039", "bodyText": "It's a bit hard reasoning about the states of DeferredValue. Isn't it the case that either serializedValueExists is true or valueExists is true and that we can simply use the previous code? Which scenario does this new case cover?", "author": "mmedenjak", "createdAt": "2020-09-28T09:39:41Z", "path": "hazelcast/src/main/java/com/hazelcast/cache/impl/DeferredValue.java", "diffHunk": "@@ -81,7 +85,12 @@ public Data getSerializedValue(SerializationService serializationService) {\n             copy.serializedValueExists = true;\n             copy.serializedValue = serializedValue;\n         }\n-        if (valueExists) {\n+        if (!resolved && serializationService != null) {", "originalCommit": "19db19f642b571041435a8469f4d0a3e65f09d9d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEzNTE1NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r496135155", "bodyText": "This is a simple fix for NPE.", "author": "lprimak", "createdAt": "2020-09-28T17:59:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgxMzAzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ3MTE2Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r497471163", "bodyText": "When does NPE occur?", "author": "mmedenjak", "createdAt": "2020-09-30T12:32:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgxMzAzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY1MjA3NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r497652075", "bodyText": "Oh I really don't remember the details. There is a whole bunch of \"other side\" here in Payara that you don't see and it was quite the effort to get all of this working. I just fixed the NPE when I saw it and I unfortunately don't remember where exactly it was.", "author": "lprimak", "createdAt": "2020-09-30T16:40:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgxMzAzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgxNDg2Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r495814863", "bodyText": "Can you revert this and ClassLoaderUtil?", "author": "mmedenjak", "createdAt": "2020-09-28T09:42:37Z", "path": "hazelcast/src/main/java/com/hazelcast/cp/internal/datastructures/atomiclong/proxy/AtomicLongProxy.java", "diffHunk": "@@ -251,5 +251,4 @@ public void destroy() {\n     public CPGroupId getGroupId() {\n         return groupId;\n     }\n-\n }", "originalCommit": "19db19f642b571041435a8469f4d0a3e65f09d9d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgyMTU3NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r495821575", "bodyText": "What if the proxies were propagated while the cluster version is 4.0 and then we switched to cluster version 4.1? Where do we react to this cluster version change to update the tenant control?", "author": "mmedenjak", "createdAt": "2020-09-28T09:53:49Z", "path": "hazelcast/src/main/java/com/hazelcast/spi/impl/proxyservice/impl/operations/PostJoinProxyOperation.java", "diffHunk": "@@ -125,7 +132,8 @@ public int getClassId() {\n         @Override\n         public void run() {\n             try {\n-                registry.createProxy(proxyInfo.getObjectName(), proxyInfo.getSource(), true, true);\n+                registry.createProxy(proxyInfo.getObjectName(), proxyInfo.getSource(), true, true,", "originalCommit": "19db19f642b571041435a8469f4d0a3e65f09d9d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEzOTMxNA==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r496139314", "bodyText": "Not sure this can be resolved, or should be, since 4.0 didn't work correctly anyway", "author": "lprimak", "createdAt": "2020-09-28T18:07:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgyMTU3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ4MDc5MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r497480791", "bodyText": "It might be the case, but here's what will happen on RU from 4.0 to 4.1. A user is running 4.0 cluster with some proxies. They start RU, shut down some 4.0 members, add some 4.1 members, and perhaps add some more proxies in the meantime. They complete RU and switch to cluster version 4.1. At this point, none of the proxies have tenant control since we had to avoid copying it because of serialization concerns.\nWhat I'm thinking is that we should either avoid sending tenant control over the wire and rely on some tenant control on each node locally based on the configuration and the node version, or implement ClusterVersionListener#onClusterVersionChange and react on the cluster version change to distribute the tenant control across the cluster once the cluster has been upgraded to 4.1, which seems prone to race conditions as it would be asynchronous.", "author": "mmedenjak", "createdAt": "2020-09-30T12:47:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgyMTU3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY1NTUwNw==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r497655507", "bodyText": "tenant control absolutely has to be sent over the wire. This is one of the basic requirements. Again, there is lots of things you don't see that are implemented in Payara and may not be obvious from just the Hazelcast part.\nAs discussed previously I will try to move it out of proxy and into node engine.\nAll of this is non-existent problem anyway because nobody is using tenant control in 4.0 because it doesn't work correctly anyway.", "author": "lprimak", "createdAt": "2020-09-30T16:46:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgyMTU3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY5NDA5NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r497694095", "bodyText": "To answer your question directly, if tenant control is not found (null) it won't be used in which case you will get classloader errors, which would happen in 4.0 anyway since tenant control isn't working correctly.\nSo, the situation is improved in all cases, and breaks in none.", "author": "lprimak", "createdAt": "2020-09-30T17:49:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgyMTU3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI2MjgxMg==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r498262812", "bodyText": "Ok, I'll reassess the code from the standpoint of having to migrate tenant control. I think it might be ok then, and we might further be comfortable with the incompatibility with RU, if we made this whole tenant control SPI internal. But I have to think some more about the consequences of something like that.", "author": "mmedenjak", "createdAt": "2020-10-01T13:54:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgyMTU3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM5MzAwNw==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r498393007", "bodyText": "Either way it's fine with me", "author": "lprimak", "createdAt": "2020-10-01T17:04:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgyMTU3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgyNDEwNw==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r495824107", "bodyText": "Leftover", "author": "mmedenjak", "createdAt": "2020-09-28T09:58:01Z", "path": "hazelcast/src/test/java/com/hazelcast/cache/CacheTenantControlTest.java", "diffHunk": "@@ -137,69 +167,120 @@ public void testTenantControl_executionBeforeAfterOps() {\n \n         cache.destroy();\n \n-        assertEquals(1, saveCurrentCount.get());\n+        assertNotNull(savedTenant.get());\n         // expecting tenant context is created & closed 5 times:\n         // 2 times on creation of record store (wrapping initialization of eviction policy)\n         // + 3 times on before/afterRun of put, get & getAndPut operations\n         assertEquals(5, setTenantCount.get());\n         assertEquals(5, closeTenantCount.get());\n+        assertEquals(1, registerTenantCount.get());\n         assertEquals(1, unregisterTenantCount.get());\n+        assertEquals(3, clearedThreadInfoCount.get());\n     }\n \n     @Test\n     public void testDestroyEventContext_destroyRemovesTenantControl() {\n         Assume.assumeTrue(\"Requires CountingTenantControl explicitly configured\", hasTenantControl);\n-        HazelcastInstance hz = createHazelcastInstance(config);\n+        HazelcastInstance hz = createHazelcastInstance(getNewConfig());\n         ICache<Integer, Integer> cache = hz.getCacheManager().getCache(cacheName);\n \n         cache.put(1, 1);\n         cache.get(1);\n         cache.getAndPut(1, 2);\n \n-        destroyEventContext.get().destroy(cache);\n+        destroyEventContext.get().tenantUnavailable();\n \n-        assertEquals(TenantControl.NOOP_TENANT_CONTROL,\n-                getTenantControl(getCacheService(hz).getCacheConfig(cache.getPrefixedName())));\n+        assertInstanceOf(CountingTenantControl.class, getTenantControl(hz, cache));\n+    }\n+\n+    @Test\n+    public void basicMapTest() {\n+        Assume.assumeTrue(\"Requires CountingTenantControl explicitly configured\", hasTenantControl);\n+        HazelcastInstance hz = createHazelcastInstance(getNewConfig().setProperty(ClusterProperty.PARTITION_COUNT.getName(), \"1\"));\n+        IMap<String, Integer> map = hz.getMap(\"MyMap\");\n+        map.addEntryListener((EntryAddedListener) (EntryEvent event) -> System.out.format(\"Added: %s\\n\", event.getValue()), true);\n+        map.put(\"oneKey\", 1);\n+        map.destroy();\n+        assertNotNull(savedTenant.get());\n+        assertEquals(3, setTenantCount.get());\n+        assertEquals(1, registerTenantCount.get());\n+        assertEquals(1, unregisterTenantCount.get());\n     }\n \n     private void assertTenantControlCreated(HazelcastInstance instance) {\n         ICacheService cacheService = getCacheService(instance);\n         CacheConfig cacheConfig = cacheService.getCacheConfig(CacheUtil.getDistributedObjectName(cacheName));\n-        assertNotNull(\"TenantControl should not be null\", getTenantControl(cacheConfig));\n+        assertNotNull(\"TenantControl should not be null\", getTenantControl(instance, cacheConfig));\n         if (hasTenantControl) {\n-            assertInstanceOf(CountingTenantControl.class, getTenantControl(cacheConfig));\n+            assertInstanceOf(CountingTenantControl.class, getTenantControl(instance, cacheConfig));\n         } else {\n-            assertEquals(TenantControl.NOOP_TENANT_CONTROL, getTenantControl(cacheConfig));\n+            assertEquals(TenantControl.NOOP_TENANT_CONTROL, getTenantControl(instance, cacheConfig));\n         }\n     }\n \n     public static class CountingTenantControl implements TenantControl {\n-\n         @Override\n-        public Closeable setTenant(boolean createRequestScope) {\n-            new Exception().printStackTrace();\n+        public Closeable setTenant() {\n+//            new Exception().printStackTrace();", "originalCommit": "19db19f642b571041435a8469f4d0a3e65f09d9d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE0MDEyNA==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r496140124", "bodyText": "removed", "author": "lprimak", "createdAt": "2020-09-28T18:08:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTgyNDEwNw=="}], "type": "inlineReview"}, {"oid": "00d88000801c254e6c2961085bf8ec595b6a3161", "url": "https://github.com/hazelcast/hazelcast/commit/00d88000801c254e6c2961085bf8ec595b6a3161", "message": "tenant control moved out of cache and operation delays - squashed commit", "committedDate": "2020-10-19T22:32:51Z", "type": "commit"}, {"oid": "94b69a7f68903b45dc89eacf12a544c6347b4b12", "url": "https://github.com/hazelcast/hazelcast/commit/94b69a7f68903b45dc89eacf12a544c6347b4b12", "message": "hopefully fixed the tenant control serialization compatibility", "committedDate": "2020-10-19T22:34:09Z", "type": "commit"}, {"oid": "94b69a7f68903b45dc89eacf12a544c6347b4b12", "url": "https://github.com/hazelcast/hazelcast/commit/94b69a7f68903b45dc89eacf12a544c6347b4b12", "message": "hopefully fixed the tenant control serialization compatibility", "committedDate": "2020-10-19T22:34:09Z", "type": "forcePushed"}, {"oid": "6625431b8f351c569a58e62da87b2dfa68ffb6aa", "url": "https://github.com/hazelcast/hazelcast/commit/6625431b8f351c569a58e62da87b2dfa68ffb6aa", "message": "Merge branch 'master' into TENANT-CONTROL-CACHE-REPLICATION", "committedDate": "2020-11-27T05:54:16Z", "type": "commit"}, {"oid": "9ac6d7267e7758d6b033c950d0dd146e813d5d0a", "url": "https://github.com/hazelcast/hazelcast/commit/9ac6d7267e7758d6b033c950d0dd146e813d5d0a", "message": "updated PR compatibility to version 4.2, fixed failing tests", "committedDate": "2020-11-29T18:35:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM0MzI4Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r535343287", "bodyText": "minor: this method override can be removed, returns same as overridden method Operation#requiresTenantContext", "author": "vbekiaris", "createdAt": "2020-12-03T15:39:41Z", "path": "hazelcast/src/main/java/com/hazelcast/cache/impl/operation/AddCacheConfigOperation.java", "diffHunk": "@@ -69,5 +68,8 @@ public int getClassId() {\n         return CacheDataSerializerHook.ADD_CACHE_CONFIG_OPERATION;\n     }\n \n-\n+    @Override\n+    public boolean requiresTenantContext() {", "originalCommit": "9ac6d7267e7758d6b033c950d0dd146e813d5d0a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjkzMzk0NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r536933944", "bodyText": "done", "author": "lprimak", "createdAt": "2020-12-06T02:03:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM0MzI4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE0MjE2Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r536142162", "bodyText": "Always returning true here will result in adding the batch back to the queue twice, since it is already added in the finally block above. In a sense it is harmless, because batch.next() will return null each additional time it is requeued, still it breaks the completed operation batches metric (without an associated test failing -- something to be fixed in a further PR probably). We should always return false from this method.", "author": "vbekiaris", "createdAt": "2020-12-04T14:34:28Z", "path": "hazelcast/src/main/java/com/hazelcast/spi/impl/operationexecutor/impl/OperationThread.java", "diffHunk": "@@ -196,6 +241,7 @@ private void process(TaskBatch batch) {\n         } finally {\n             queue.add(batch, false);\n         }\n+        return true;", "originalCommit": "9ac6d7267e7758d6b033c950d0dd146e813d5d0a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjk0MDEwMw==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r536940103", "bodyText": "fixed", "author": "lprimak", "createdAt": "2020-12-06T02:50:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE0MjE2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE3NDA5Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r536174097", "bodyText": "nit: update to 4.2", "author": "vbekiaris", "createdAt": "2020-12-04T15:19:28Z", "path": "hazelcast/src/main/java/com/hazelcast/spi/impl/tenantcontrol/impl/TenantControlReplicationOperation.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.spi.impl.tenantcontrol.impl;\n+\n+import com.hazelcast.internal.util.MapUtil;\n+import com.hazelcast.nio.ObjectDataInput;\n+import com.hazelcast.nio.ObjectDataOutput;\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.spi.impl.SpiDataSerializerHook;\n+import com.hazelcast.spi.impl.operationservice.Operation;\n+import com.hazelcast.spi.tenantcontrol.TenantControl;\n+\n+import javax.annotation.Nonnull;\n+import java.io.IOException;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentMap;\n+\n+/**\n+ * Operation which exchanges tenant control between members.\n+ * Can be used to exchange a single or multiple tenant controls each belonging\n+ * to a different distributed object.\n+ *\n+ * @since 4.1", "originalCommit": "9ac6d7267e7758d6b033c950d0dd146e813d5d0a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjkzMzk5NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r536933994", "bodyText": "done", "author": "lprimak", "createdAt": "2020-12-06T02:03:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE3NDA5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE5NDAyMA==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r536194020", "bodyText": "Why was this test changed? The second HazelcastInstance is anyway started with the filtering class loader and invoke will trigger the cache loader factory instantiation attempt. In the new version of the code, the following 2 lines will be anyway skipped because this line will throw the ClassNotFoundException.", "author": "vbekiaris", "createdAt": "2020-12-04T15:47:44Z", "path": "hazelcast/src/test/java/com/hazelcast/cache/CacheTypesConfigTest.java", "diffHunk": "@@ -152,10 +154,19 @@ public void cacheConfigShouldBeAddedOnJoiningMember_whenCacheLoaderFactoryNotRes\n         assertClusterSize(2, hz1, hz2);\n \n         ICache<String, Person> cache = hz2.getCacheManager().getCache(cacheName);\n-        String key = generateKeyOwnedBy(hz2);\n-        expect.expectCause(new RootCauseMatcher(ClassNotFoundException.class, \"classloading.domain.PersonCacheLoaderFactory - \"\n-                + \"Package excluded explicitly\"));\n-        cache.invoke(key, new PersonEntryProcessor());\n+        ClassLoader oldClassLoader = Thread.currentThread().getContextClassLoader();\n+        try {\n+            Thread.currentThread().setContextClassLoader(hz2.getConfig().getClassLoader());\n+            CacheProxy cacheProxy = (CacheProxy) cache;\n+            CacheService cacheService = (CacheService) cacheProxy.getService();\n+            expect.expectCause(new RootCauseMatcher(ClassNotFoundException.class, \"classloading.domain.PersonCacheLoaderFactory - \"\n+                    + \"Package excluded explicitly\"));\n+            cacheService.getCacheConfig(cache.getPrefixedName()).getCacheLoaderFactory();", "originalCommit": "9ac6d7267e7758d6b033c950d0dd146e813d5d0a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjkzNTc4Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r536935782", "bodyText": "Because this test always succeeded, when it should have failed. With this change, class loading is more realistic and it makes for a better test.\nI changed it because it was succeeding when I introduced it into app server (actual class loading environment) but it should have failed.", "author": "lprimak", "createdAt": "2020-12-06T02:17:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE5NDAyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQwOTk1OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r537409959", "bodyText": "Because this test always succeeded, when it should have failed. With this change, class loading is more realistic and it makes for a better test.\n\nThe original test expects the exception to be thrown from Hazelcast partition operation threads. These threads are the ones which execute the EntryProcessor from invoke and are responsible for instantiating and invoking the CacheLoader. They use the config classloader (that is the FilteringClassLoader setup in second instance's Config).\nThe updated code changes the test-executing thread's context classloader and forces initialization of the CacheLoader from the test thread, triggering the exception to be thrown earlier from getCacheLoaderFactory call and does not exercise the partition operation thread code that should trigger the CacheLoader execution at all.\nCan you elaborate on the setup that succeeded when it should have failed?", "author": "vbekiaris", "createdAt": "2020-12-07T10:51:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE5NDAyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY0NjYxMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r537646611", "bodyText": "Can you elaborate on the setup that succeeded when it should have failed?\n\nThis was 3 years ago, I don't remember. All I know this was failing in my tests an I fixed it.\nI reverted the changes and added another test, hope that resolves this (long) discussion", "author": "lprimak", "createdAt": "2020-12-07T16:31:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjE5NDAyMA=="}], "type": "inlineReview"}, {"oid": "2030b4a7363fc7b97e3d2ef7817902b2d34923af", "url": "https://github.com/hazelcast/hazelcast/commit/2030b4a7363fc7b97e3d2ef7817902b2d34923af", "message": "Merge branch 'master' into TENANT-CONTROL-CACHE-REPLICATION", "committedDate": "2020-12-06T01:57:08Z", "type": "commit"}, {"oid": "07ba61894c925b5855e5c2fc7521046490221c18", "url": "https://github.com/hazelcast/hazelcast/commit/07ba61894c925b5855e5c2fc7521046490221c18", "message": "minor fixes based on review Dec 4 2020", "committedDate": "2020-12-06T02:18:09Z", "type": "commit"}, {"oid": "ff1932eaaa6d0e4b1eb0049ea9a403feebfb4190", "url": "https://github.com/hazelcast/hazelcast/commit/ff1932eaaa6d0e4b1eb0049ea9a403feebfb4190", "message": "batch processing itself can never be deferred", "committedDate": "2020-12-06T02:49:43Z", "type": "commit"}, {"oid": "4014782a52c114d4fe2d200fd88f2008c458f5a5", "url": "https://github.com/hazelcast/hazelcast/commit/4014782a52c114d4fe2d200fd88f2008c458f5a5", "message": "Merge remote-tracking branch 'upstream/master' into TENANT-CONTROL-CACHE-REPLICATION", "committedDate": "2020-12-07T16:20:38Z", "type": "commit"}, {"oid": "d51643d53ebeec11456037c171193bb5c281cb16", "url": "https://github.com/hazelcast/hazelcast/commit/d51643d53ebeec11456037c171193bb5c281cb16", "message": "extracted changes for CacheTypesConfigTest into a separate test", "committedDate": "2020-12-07T16:27:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzYxMjM0MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r537612340", "bodyText": "How come this inject dependencies is here? The evaluator is initialised above.", "author": "mmedenjak", "createdAt": "2020-12-07T15:48:49Z", "path": "hazelcast/src/main/java/com/hazelcast/cache/impl/AbstractCacheRecordStore.java", "diffHunk": "@@ -164,64 +162,73 @@ public AbstractCacheRecordStore(String cacheNameWithPrefix, int partitionId, Nod\n             throw new CacheNotExistsException(\"Cache \" + cacheNameWithPrefix + \" is already destroyed or not created yet, on \"\n                     + nodeEngine.getLocalMember());\n         }\n-        Closeable tenantContext = CacheConfigAccessor.getTenantControl(cacheConfig).setTenant(true);\n-        try {\n-            this.eventJournalConfig = cacheConfig.getEventJournalConfig();\n-            this.evictionConfig = cacheConfig.getEvictionConfig();\n-            if (evictionConfig == null) {\n-                throw new IllegalStateException(\"Eviction config cannot be null!\");\n-            }\n-            this.wanReplicationEnabled = cacheService.isWanReplicationEnabled(cacheNameWithPrefix);\n-            this.disablePerEntryInvalidationEvents = cacheConfig.isDisablePerEntryInvalidationEvents();\n-            initializeStatisticsAndFactories(cacheNameWithPrefix);\n-\n-            EvictionPolicyComparator evictionPolicyComparator = createEvictionPolicyComparator(evictionConfig);\n-            evictionPolicyComparator = injectDependencies(evictionPolicyComparator);\n-            this.evictionPolicyEvaluator = new EvictionPolicyEvaluator<>(evictionPolicyComparator);\n-            this.cacheContext = cacheService.getOrCreateCacheContext(cacheNameWithPrefix);\n-            this.records = createRecordCacheMap();\n-            this.evictionChecker = createCacheEvictionChecker(evictionConfig.getSize(), evictionConfig.getMaxSizePolicy());\n-            this.evictionStrategy = createEvictionStrategy(evictionConfig);\n-            this.objectNamespace = CacheService.getObjectNamespace(cacheNameWithPrefix);\n-            this.persistWanReplicatedData = canPersistWanReplicatedData(cacheConfig, nodeEngine);\n-            this.cacheRecordFactory = new CacheRecordFactory(cacheConfig.getInMemoryFormat(), ss);\n-            this.valueComparator = getValueComparatorOf(cacheConfig.getInMemoryFormat());\n-            this.clearExpiredRecordsTask = cacheService.getExpirationManager().getTask();\n-\n-            registerResourceIfItIsClosable(cacheWriter);\n-            registerResourceIfItIsClosable(cacheLoader);\n-            registerResourceIfItIsClosable(defaultExpiryPolicy);\n-            init();\n-        } finally {\n-            try {\n-                tenantContext.close();\n-            } catch (IOException ex) {\n-                ExceptionUtil.rethrow(ex);\n-            }\n-        }\n-    }\n+        this.eventJournalConfig = cacheConfig.getEventJournalConfig();\n+        this.evictionConfig = cacheConfig.getEvictionConfig();\n+        if (evictionConfig == null) {\n+            throw new IllegalStateException(\"Eviction config cannot be null!\");\n+        }\n+        this.wanReplicationEnabled = cacheService.isWanReplicationEnabled(cacheNameWithPrefix);\n+        this.disablePerEntryInvalidationEvents = cacheConfig.isDisablePerEntryInvalidationEvents();\n+\n+        EvictionPolicyComparator evictionPolicyComparator = createEvictionPolicyComparator(evictionConfig);\n+        evictionPolicyComparator = injectDependencies(evictionPolicyComparator);\n+        this.evictionPolicyEvaluator = new EvictionPolicyEvaluator<>(evictionPolicyComparator);\n+        this.cacheContext = cacheService.getOrCreateCacheContext(cacheNameWithPrefix);\n+        this.records = createRecordCacheMap();\n+        this.evictionChecker = createCacheEvictionChecker(evictionConfig.getSize(), evictionConfig.getMaxSizePolicy());\n+        this.evictionStrategy = createEvictionStrategy(evictionConfig);\n+        this.objectNamespace = CacheService.getObjectNamespace(cacheNameWithPrefix);\n+        this.persistWanReplicatedData = canPersistWanReplicatedData(cacheConfig, nodeEngine);\n+        this.cacheRecordFactory = new CacheRecordFactory(cacheConfig.getInMemoryFormat(), ss);\n+        this.valueComparator = getValueComparatorOf(cacheConfig.getInMemoryFormat());\n+        this.clearExpiredRecordsTask = cacheService.getExpirationManager().getTask();\n \n-    private void initializeStatisticsAndFactories(String cacheNameWithPrefix) {\n         if (cacheConfig.isStatisticsEnabled()) {\n             statistics = cacheService.createCacheStatIfAbsent(cacheNameWithPrefix);\n         }\n-        if (cacheConfig.getCacheLoaderFactory() != null) {\n-            Factory<CacheLoader> cacheLoaderFactory = cacheConfig.getCacheLoaderFactory();\n-            cacheLoaderFactory = injectDependencies(cacheLoaderFactory);\n-            cacheLoader = cacheLoaderFactory.create();\n-            cacheLoader = injectDependencies(cacheLoader);\n-        }\n-        if (cacheConfig.getCacheWriterFactory() != null) {\n-            Factory<CacheWriter> cacheWriterFactory = cacheConfig.getCacheWriterFactory();\n-            cacheWriterFactory = injectDependencies(cacheWriterFactory);\n-            cacheWriter = cacheWriterFactory.create();\n-            cacheWriter = injectDependencies(cacheWriter);\n-        }\n+        injectDependencies(evictionPolicyEvaluator.getEvictionPolicyComparator());", "originalCommit": "ff1932eaaa6d0e4b1eb0049ea9a403feebfb4190", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc1MjUyNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r537752525", "bodyText": "probably a mistake. Can you fix it since you are already working on this?", "author": "lprimak", "createdAt": "2020-12-07T19:00:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzYxMjM0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc2Mjg5NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r537762895", "bodyText": "Ok, I will.", "author": "mmedenjak", "createdAt": "2020-12-07T19:17:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzYxMjM0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY5NTMxNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r537695315", "bodyText": "Is it no longer possible that this requires tenant control set?", "author": "mmedenjak", "createdAt": "2020-12-07T17:36:14Z", "path": "hazelcast/src/main/java/com/hazelcast/cache/impl/AbstractCacheRecordStore.java", "diffHunk": "@@ -353,12 +355,7 @@ protected EvictionChecker createCacheEvictionChecker(int size, MaxSizePolicy max\n     protected EvictionPolicyComparator createEvictionPolicyComparator(EvictionConfig evictionConfig) {\n         checkCacheEvictionConfig(evictionConfig);\n \n-        Closeable tenantContext = getTenantControl(cacheConfig).setTenant(false);", "originalCommit": "ff1932eaaa6d0e4b1eb0049ea9a403feebfb4190", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc0NTk2Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r537745966", "bodyText": "No it doesn't. At this point all data is serialized and user classes are not required", "author": "lprimak", "createdAt": "2020-12-07T18:51:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY5NTMxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcxODQ0MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r537718440", "bodyText": "From which threads can this reassignment be called now? As I don't see safe publication of new values.", "author": "mmedenjak", "createdAt": "2020-12-07T18:09:12Z", "path": "hazelcast/src/main/java/com/hazelcast/cache/impl/CacheProxySupport.java", "diffHunk": "@@ -92,7 +93,7 @@\n     private static final int TIMEOUT = 10;\n \n     protected final ILogger logger;\n-    protected final CacheConfig<K, V> cacheConfig;\n+    protected CacheConfig<K, V> cacheConfig;", "originalCommit": "ff1932eaaa6d0e4b1eb0049ea9a403feebfb4190", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc0NjM0Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r537746342", "bodyText": "I think you already changed this", "author": "lprimak", "createdAt": "2020-12-07T18:52:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcxODQ0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc1MTcwMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r537751701", "bodyText": "this is called when the tenant is undeployed and cache config is deserialized. It doesn't have to be propagated anywhere and cannot be inconsistent.", "author": "lprimak", "createdAt": "2020-12-07T18:59:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcxODQ0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc2MTUwMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r537761501", "bodyText": "The thread-safety semantics remain the same, I only removed duplication.\n\nIt doesn't have to be propagated anywhere and cannot be inconsistent.\n\nCan you elaborate? If that is so, why do we need to update it in the first place?", "author": "mmedenjak", "createdAt": "2020-12-07T19:14:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcxODQ0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc2MzE0Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r537763147", "bodyText": "To remove references to classes no longer available via class loader when application is Undeployed from Payara", "author": "lprimak", "createdAt": "2020-12-07T19:17:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcxODQ0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc3OTYzMw==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r537779633", "bodyText": "I don't know how else to reserialize cache config when tenant is undeployed, to remove all user classes that are no longer available on the current instance, thus the title of original issue for this PR.\n#10875", "author": "lprimak", "createdAt": "2020-12-07T19:40:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcxODQ0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc4MTQyOA==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r537781428", "bodyText": "Also I can't prove a negative", "author": "lprimak", "createdAt": "2020-12-07T19:42:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcxODQ0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk5MDk1NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r537990955", "bodyText": "The only other way I could see to do this is to recreate the whole proxy again with the new re-serialized cache config. I have no idea how to do that safely either.", "author": "lprimak", "createdAt": "2020-12-08T02:45:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzcxODQ0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzczMTU1Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r537731553", "bodyText": "I think we can remove this whole backupSerializationService. The case which you seem to be referring to is when the CacheConfig is constructed using public CacheConfig(CacheSimpleConfig simpleConfig). I believe that if we set the serialization service in that constructor, it will always be non-null. Do you have a test (either on our side or on your side) which tests for this NPE?", "author": "mmedenjak", "createdAt": "2020-12-07T18:29:06Z", "path": "hazelcast/src/main/java/com/hazelcast/cache/impl/PreJoinCacheConfig.java", "diffHunk": "@@ -56,7 +57,12 @@ public PreJoinCacheConfig(CacheConfig cacheConfig) {\n     }\n \n     public PreJoinCacheConfig(CacheConfig cacheConfig, boolean resolved) {\n-        cacheConfig.copy(this, resolved);\n+        this(cacheConfig, resolved, null);\n+    }\n+\n+    public PreJoinCacheConfig(CacheConfig cacheConfig, boolean resolved,\n+            SerializationService backupSerializationService) {", "originalCommit": "ff1932eaaa6d0e4b1eb0049ea9a403feebfb4190", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc0ODAxOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r537748019", "bodyText": "No, this was during reSerialize() which does a copy() of the cache config, not simpleConfig", "author": "lprimak", "createdAt": "2020-12-07T18:55:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzczMTU1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc1MzEyMg==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r537753122", "bodyText": "I am sure it can be removed provided serializationService is made sure never to be null", "author": "lprimak", "createdAt": "2020-12-07T19:01:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzczMTU1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc2MjQxOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r537762419", "bodyText": "Yes, reSerialize() was doing a copy of a CacheConfig which was most probably constructed using public CacheConfig(CacheSimpleConfig simpleConfig) as that constructor does not ensure the serialization service is set.\nDo you have a test (either on our side or on your side) which tests for this NPE?", "author": "mmedenjak", "createdAt": "2020-12-07T19:16:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzczMTU1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc3NTE1OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r537775159", "bodyText": "Maybe... this was so long ago I don't remember", "author": "lprimak", "createdAt": "2020-12-07T19:34:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzczMTU1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc3ODEwNA==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r537778104", "bodyText": "I'll remove it and we'll test then.", "author": "mmedenjak", "createdAt": "2020-12-07T19:37:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzczMTU1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk4ODI1Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r537988252", "bodyText": "Yes, reSerialize() was doing a copy of a CacheConfig which was most probably constructed using public CacheConfig(CacheSimpleConfig simpleConfig)\n\nI remember now. This is correct. If CacheConfig always have serializer non-null, the backup serialization code can be removed.", "author": "lprimak", "createdAt": "2020-12-08T02:37:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzczMTU1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODY1NjMzMg==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r538656332", "bodyText": "I started removing it which then turned out to either the serialization service needing to be added to public CacheConfig(CacheSimpleConfig simpleConfig) or a setter added to CacheConfig. @vbekiaris is that constructor public API?\nAlso, is CacheConfig#copy public API? Because we're changing the arguments to include SerializationService, which is private API.", "author": "mmedenjak", "createdAt": "2020-12-08T17:48:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzczMTU1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTEyMzE2Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r539123163", "bodyText": "Pragmatically, I don't expect any end users actually use CacheConfig(CacheSimpleConfig simpleConfig) or CacheConfig#copy, however both are exposed as public. A workaround could be to add a package-private setter for SerializationService and access it via CacheConfigAccessor which is already declared as @PrivateApi.", "author": "vbekiaris", "createdAt": "2020-12-09T08:58:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzczMTU1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTIzMjU5Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r539232596", "bodyText": "Changed it to your suggestion and removed backup serialization service. CacheConfig should now always have the serialization service set.", "author": "mmedenjak", "createdAt": "2020-12-09T11:35:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzczMTU1Mw=="}], "type": "inlineReview"}, {"oid": "bbe8cc1ac7ce8e10d4f86c6434f68f93a324528e", "url": "https://github.com/hazelcast/hazelcast/commit/bbe8cc1ac7ce8e10d4f86c6434f68f93a324528e", "message": "Cleanup", "committedDate": "2020-12-07T18:41:16Z", "type": "commit"}, {"oid": "4879f2594ff414018ec322debea65562054a41d6", "url": "https://github.com/hazelcast/hazelcast/commit/4879f2594ff414018ec322debea65562054a41d6", "message": "Cleanup", "committedDate": "2020-12-07T19:19:46Z", "type": "commit"}, {"oid": "ce857745ccf908bf5f67e514c8f296790b7589e1", "url": "https://github.com/hazelcast/hazelcast/commit/ce857745ccf908bf5f67e514c8f296790b7589e1", "message": "Add caveats", "committedDate": "2020-12-08T18:54:35Z", "type": "commit"}, {"oid": "c0857136f01eebadb1b9c738238f1dca5c89e21d", "url": "https://github.com/hazelcast/hazelcast/commit/c0857136f01eebadb1b9c738238f1dca5c89e21d", "message": "Cleanup and remove backup serialization service. It should now be set in all cases for CacheConfig.", "committedDate": "2020-12-09T11:33:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTI3MTM1Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r539271352", "bodyText": "This classloader is not used. Is there a test missing?", "author": "mmedenjak", "createdAt": "2020-12-09T12:37:21Z", "path": "hazelcast/src/test/java/com/hazelcast/cache/TenantUnavailableTest.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.cache;\n+\n+import com.hazelcast.cache.impl.CacheProxy;\n+import com.hazelcast.cache.impl.ICacheService;\n+import com.hazelcast.config.CacheConfig;\n+import com.hazelcast.core.HazelcastInstance;\n+import com.hazelcast.internal.util.ExceptionUtil;\n+import com.hazelcast.partition.MigrationListener;\n+import com.hazelcast.partition.MigrationState;\n+import com.hazelcast.partition.ReplicaMigrationEvent;\n+import com.hazelcast.test.HazelcastSerialClassRunner;\n+import com.hazelcast.test.HazelcastTestSupport;\n+import com.hazelcast.test.TestHazelcastInstanceFactory;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import javax.cache.Cache;\n+import javax.cache.CacheManager;\n+import java.io.Serializable;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+\n+import static com.hazelcast.cache.CachePartitionIteratorMigrationTest.putValuesToPartition;\n+import static com.hazelcast.cache.CacheTestSupport.createServerCachingProvider;\n+import static com.hazelcast.cache.CacheTestSupport.getCacheService;\n+import static com.hazelcast.cache.HazelcastCacheManager.CACHE_MANAGER_PREFIX;\n+import static com.hazelcast.cache.TenantControlTest.classesAlwaysAvailable;\n+import static com.hazelcast.cache.TenantControlTest.destroyEventContext;\n+import static com.hazelcast.cache.TenantControlTest.initState;\n+import static com.hazelcast.cache.TenantControlTest.newConfig;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * App Server reload / app not loaded tests\n+ *\n+ * @author lprimak\n+ */\n+@RunWith(HazelcastSerialClassRunner.class)\n+@Category(QuickTest.class)\n+public class TenantUnavailableTest extends HazelcastTestSupport {\n+    private String cacheName;\n+    private static final Set<String> disallowClassNames = new HashSet<>();\n+    private static final CountDownLatch latch = new CountDownLatch(1);\n+    private static boolean classLoadingFailed;\n+\n+    @Before\n+    public void setup() {\n+        cacheName = randomName();\n+        classLoadingFailed = false;\n+        initState();\n+        classesAlwaysAvailable = false;\n+    }\n+\n+    @Test\n+    public void testCacheWithTypesWithoutClassLoader() {\n+        TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(2);\n+        HazelcastInstance hz1 = factory.newHazelcastInstance(newConfig());\n+        CacheConfig<KeyType, ValueType> cacheConfig = new CacheConfig<>();\n+        cacheConfig.setTypes(KeyType.class, ValueType.class);\n+        Cache<KeyType, ValueType> cache1 = createServerCachingProvider(hz1)\n+                .getCacheManager()\n+                .createCache(cacheName, cacheConfig);\n+        cache1.put(new KeyType(), new ValueType());\n+        assertInstanceOf(ValueType.class, cache1.get(new KeyType()));\n+\n+        HazelcastInstance hz2 = factory.newHazelcastInstance(newConfig());\n+        ICacheService cacheService = getCacheService(hz2);\n+        disallowClassNames.add(KeyType.class.getName());\n+        hz1.shutdown(); // force migration\n+        CacheManager cacheManager = createServerCachingProvider(hz2).getCacheManager();\n+        Cache<KeyType, ValueType> cache2 = cacheManager.getCache(cacheName);\n+        disallowClassNames.clear();\n+        assertInstanceOf(ValueType.class, cache2.get(new KeyType()));\n+\n+        destroyEventContext.get().tenantUnavailable();\n+        disallowClassNames.add(KeyType.class.getName());\n+\n+        cacheConfig = cacheService.getCacheConfig(CACHE_MANAGER_PREFIX + cacheName);\n+        Cache<KeyType, ValueType> cache3 = cacheManager.getCache(cacheName);\n+        assertInstanceOf(ValueType.class, cache3.get(new KeyType()));\n+        Assert.assertFalse(\"Class Loading Failed\", classLoadingFailed);\n+    }\n+\n+    @Test\n+    public void testMigrationWithUnavailableClasses() throws InterruptedException {\n+        classesAlwaysAvailable = false;\n+        TestHazelcastInstanceFactory factory = createHazelcastInstanceFactory(2);\n+        HazelcastInstance hz1 = factory.newHazelcastInstance(newConfig());\n+        CacheConfig<String, ValueType> cacheConfig = new CacheConfig<>();\n+        cacheConfig.setTypes(String.class, ValueType.class);\n+\n+        @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+        CacheProxy<String, ValueType> cache1 = (CacheProxy) createServerCachingProvider(hz1)\n+                .getCacheManager().createCache(cacheName, cacheConfig);\n+        ValueType value = new ValueType();\n+        putValuesToPartition(hz1, cache1, value, 0, 1);\n+        putValuesToPartition(hz1, cache1, value, 1, 1);\n+\n+        disallowClassNames.add(ValueType.class.getName());\n+        HazelcastInstance hz2 = factory.newHazelcastInstance(newConfig().setLiteMember(true));\n+        hz1.getPartitionService().addMigrationListener(new MigrationListenerImpl());\n+        CacheManager cacheManager = createServerCachingProvider(hz2).getCacheManager();\n+        Cache<String, ValueType> cache2 = cacheManager.getCache(cacheName);\n+        // force migration\n+        hz2.getCluster().promoteLocalLiteMember();\n+        latch.await(); // await migration\n+        disallowClassNames.clear();\n+        Iterator<Cache.Entry<String, ValueType>> it2 = cache2.iterator();\n+\n+        assertTrue(\"Iterator should not be empty\", it2.hasNext());\n+        while (it2.hasNext()) {\n+            Cache.Entry<String, ValueType> entry = it2.next();\n+            assertInstanceOf(ValueType.class, entry.getValue());\n+        }\n+        Assert.assertFalse(\"Class Loading Failed\", classLoadingFailed);\n+    }\n+\n+    public static class SimulateNonExistantClassLoader extends URLClassLoader {", "originalCommit": "c0857136f01eebadb1b9c738238f1dca5c89e21d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ0MjEyNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r539442126", "bodyText": "yes, probably.\nneed to go through history to figure out what happened\nthe alternative is that there was one and it's no longer applicable, I will take a look", "author": "lprimak", "createdAt": "2020-12-09T16:14:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTI3MTM1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ0NDUwMw==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r539444503", "bodyText": "well, there is no history since commits were squashed :(", "author": "lprimak", "createdAt": "2020-12-09T16:16:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTI3MTM1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ5NTU1OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r539495559", "bodyText": "I think during the refactoring of tests somehow reference to SimulateNonExistantClassLoader  got lost", "author": "lprimak", "createdAt": "2020-12-09T17:19:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTI3MTM1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTUwNTA2Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r539505063", "bodyText": "yes, this test is completely broken, I am working on restoring it to functional state", "author": "lprimak", "createdAt": "2020-12-09T17:32:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTI3MTM1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTUxNDc1Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r539514753", "bodyText": "ok this is now fixed", "author": "lprimak", "createdAt": "2020-12-09T17:43:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTI3MTM1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTI3MjY3NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r539272674", "bodyText": "classesAlwaysAvailable is false in all tests. Is there a test where it is true? Should we have a test for that?", "author": "mmedenjak", "createdAt": "2020-12-09T12:39:26Z", "path": "hazelcast/src/test/java/com/hazelcast/cache/TenantUnavailableTest.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.cache;\n+\n+import com.hazelcast.cache.impl.CacheProxy;\n+import com.hazelcast.cache.impl.ICacheService;\n+import com.hazelcast.config.CacheConfig;\n+import com.hazelcast.core.HazelcastInstance;\n+import com.hazelcast.internal.util.ExceptionUtil;\n+import com.hazelcast.partition.MigrationListener;\n+import com.hazelcast.partition.MigrationState;\n+import com.hazelcast.partition.ReplicaMigrationEvent;\n+import com.hazelcast.test.HazelcastSerialClassRunner;\n+import com.hazelcast.test.HazelcastTestSupport;\n+import com.hazelcast.test.TestHazelcastInstanceFactory;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import javax.cache.Cache;\n+import javax.cache.CacheManager;\n+import java.io.Serializable;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+\n+import static com.hazelcast.cache.CachePartitionIteratorMigrationTest.putValuesToPartition;\n+import static com.hazelcast.cache.CacheTestSupport.createServerCachingProvider;\n+import static com.hazelcast.cache.CacheTestSupport.getCacheService;\n+import static com.hazelcast.cache.HazelcastCacheManager.CACHE_MANAGER_PREFIX;\n+import static com.hazelcast.cache.TenantControlTest.classesAlwaysAvailable;\n+import static com.hazelcast.cache.TenantControlTest.destroyEventContext;\n+import static com.hazelcast.cache.TenantControlTest.initState;\n+import static com.hazelcast.cache.TenantControlTest.newConfig;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * App Server reload / app not loaded tests\n+ *\n+ * @author lprimak\n+ */\n+@RunWith(HazelcastSerialClassRunner.class)\n+@Category(QuickTest.class)\n+public class TenantUnavailableTest extends HazelcastTestSupport {\n+    private String cacheName;\n+    private static final Set<String> disallowClassNames = new HashSet<>();\n+    private static final CountDownLatch latch = new CountDownLatch(1);\n+    private static boolean classLoadingFailed;\n+\n+    @Before\n+    public void setup() {\n+        cacheName = randomName();\n+        classLoadingFailed = false;\n+        initState();\n+        classesAlwaysAvailable = false;", "originalCommit": "c0857136f01eebadb1b9c738238f1dca5c89e21d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ0Mjc2OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r539442769", "bodyText": "there is nothing to test that isn't tested already if classesAlwaysAvailable is true", "author": "lprimak", "createdAt": "2020-12-09T16:14:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTI3MjY3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU2NTIxOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r539565219", "bodyText": "Then I'll remove this field as I don't see it's point.", "author": "mmedenjak", "createdAt": "2020-12-09T18:57:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTI3MjY3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU3ODAyOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17184#discussion_r539578029", "bodyText": "Ok, I think there was some use for this beforehand (it had to be set to true at one point) but with the current state it's no longer necessary", "author": "lprimak", "createdAt": "2020-12-09T19:17:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTI3MjY3NA=="}], "type": "inlineReview"}, {"oid": "2563d35b480fb0369dc6c77b8a072f709654a129", "url": "https://github.com/hazelcast/hazelcast/commit/2563d35b480fb0369dc6c77b8a072f709654a129", "message": "Cleanup tests", "committedDate": "2020-12-09T13:01:28Z", "type": "commit"}, {"oid": "e82b7a5a2d65c0b2dfc835ba70240ae1109b7a3a", "url": "https://github.com/hazelcast/hazelcast/commit/e82b7a5a2d65c0b2dfc835ba70240ae1109b7a3a", "message": "Fix tests", "committedDate": "2020-12-09T15:19:33Z", "type": "commit"}, {"oid": "8a588c26c99febc8fdc45977d5bc79ab7bfb581f", "url": "https://github.com/hazelcast/hazelcast/commit/8a588c26c99febc8fdc45977d5bc79ab7bfb581f", "message": "restore TenantUnavailableTest functionality", "committedDate": "2020-12-09T17:43:12Z", "type": "commit"}, {"oid": "2ee9e71fdc16113e551125e6865f0d53a15a582e", "url": "https://github.com/hazelcast/hazelcast/commit/2ee9e71fdc16113e551125e6865f0d53a15a582e", "message": "Add tests", "committedDate": "2020-12-10T14:25:09Z", "type": "commit"}]}