{"pr_number": 16869, "pr_title": "Allow longer metric words, fail-fast if exceeded", "pr_createdAt": "2020-04-09T10:13:01Z", "pr_url": "https://github.com/hazelcast/hazelcast/pull/16869", "timeline": [{"oid": "96ed70e17d6cb526d2aaf010a395ffb26f0d7371", "url": "https://github.com/hazelcast/hazelcast/commit/96ed70e17d6cb526d2aaf010a395ffb26f0d7371", "message": "Allow longer metric words, fail-fast if exceeded\n\nWhen metric dictionary word was longer than 127 characters, incorrect\ncompressed stream was produced. This PR pushes the limit to 255\ncharacters and fails fast if exceeded.\n\nAlso removes unnused `Strign[] dictionary` from `MetricsDictionary`.\n\nRelated to hazelcast/hazelcast-jet#2155", "committedDate": "2020-04-09T10:09:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAyMjA0Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/16869#discussion_r408022047", "bodyText": "I believe we should keep writing to tmpDos and copy its backing buffer to dictionaryDos at the end. The reason for introducing tmpDos was to avoid allocating many single-byte byte[] instances that DeflaterOutputStream does for writing (most of the) primitives. See DeflaterOutputStream#write(int).", "author": "blazember", "createdAt": "2020-04-14T10:10:44Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/metrics/impl/MetricsCompressor.java", "diffHunk": "@@ -257,29 +259,26 @@ private void writeDictionary() throws IOException {\n         dictionaryDos.writeInt(words.size());\n         String lastWord = \"\";\n         for (MetricsDictionary.Word word : words) {\n-\n             String wordText = word.word();\n-            int maxCommonLen = Math.min(lastWord.length(), wordText.length());\n+            if (wordText.length() > UNSIGNED_BYTE_MAX_VALUE) {\n+                // this should have been checked earlier, this is a safety check\n+                throw new RuntimeException(\"Dictionary element too long: \" + wordText);\n+            }\n+            int maxCommonLen = Math.min(lastWord.length(), wordText.length()) & UNSIGNED_BYTE_MAX_VALUE;\n             int commonLen = 0;\n-            boolean common = true;\n-            for (int i = 0; i < maxCommonLen && common; i++) {\n-                if (wordText.charAt(i) == lastWord.charAt(i)) {\n-                    commonLen++;\n-                } else {\n-                    common = false;\n-                }\n+            while (commonLen < maxCommonLen\n+                    && wordText.charAt(commonLen) == lastWord.charAt(commonLen)) {\n+                commonLen++;\n             }\n \n             int diffLen = wordText.length() - commonLen;\n-            tmpDos.writeInt(word.dictionaryId());\n-            tmpDos.writeByte(commonLen);\n-            tmpDos.writeByte(diffLen);\n+            dictionaryDos.writeInt(word.dictionaryId());", "originalCommit": "96ed70e17d6cb526d2aaf010a395ffb26f0d7371", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA4Nzk5Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/16869#discussion_r408087993", "bodyText": "That's nasty.. I'm reverting then and adding a comment. A code that takes a more complicated path for simple things for some side-effect should have a comment IMO.", "author": "viliam-durina", "createdAt": "2020-04-14T12:14:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAyMjA0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA5NTE2NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16869#discussion_r408095165", "bodyText": "A code that takes a more complicated path for simple things for some side-effect should have a comment IMO.\n\nThe comment is already there:\n\n  \n    \n      hazelcast/hazelcast/src/main/java/com/hazelcast/internal/metrics/impl/MetricsCompressor.java\n    \n    \n         Line 124\n      in\n      97ff57b\n    \n    \n    \n    \n\n        \n          \n           // temporary buffer to avoid DeflaterOutputStream's extra byte[] allocations", "author": "puzpuzpuz", "createdAt": "2020-04-14T12:27:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAyMjA0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODEyMDM2MA==", "url": "https://github.com/hazelcast/hazelcast/pull/16869#discussion_r408120360", "bodyText": "Renaming the field to allocFriendlyDos or something meaningful would also make sense. That should at least give a hint to future us. tmpDos is indeed a meaningless name and makes us thinking using this field is not necessary. I had to navigate to the field declaration as well to recall the reason for using it.", "author": "blazember", "createdAt": "2020-04-14T13:06:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAyMjA0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA0MzM2Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/16869#discussion_r408043362", "bodyText": "Created #16883 for this.", "author": "blazember", "createdAt": "2020-04-14T10:48:24Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/metrics/impl/MetricsCompressor.java", "diffHunk": "@@ -257,29 +259,26 @@ private void writeDictionary() throws IOException {\n         dictionaryDos.writeInt(words.size());\n         String lastWord = \"\";\n         for (MetricsDictionary.Word word : words) {\n-\n             String wordText = word.word();\n-            int maxCommonLen = Math.min(lastWord.length(), wordText.length());\n+            if (wordText.length() > UNSIGNED_BYTE_MAX_VALUE) {\n+                // this should have been checked earlier, this is a safety check\n+                throw new RuntimeException(\"Dictionary element too long: \" + wordText);\n+            }\n+            int maxCommonLen = Math.min(lastWord.length(), wordText.length()) & UNSIGNED_BYTE_MAX_VALUE;\n             int commonLen = 0;\n-            boolean common = true;\n-            for (int i = 0; i < maxCommonLen && common; i++) {\n-                if (wordText.charAt(i) == lastWord.charAt(i)) {\n-                    commonLen++;\n-                } else {\n-                    common = false;\n-                }\n+            while (commonLen < maxCommonLen\n+                    && wordText.charAt(commonLen) == lastWord.charAt(commonLen)) {\n+                commonLen++;\n             }\n \n             int diffLen = wordText.length() - commonLen;\n-            tmpDos.writeInt(word.dictionaryId());\n-            tmpDos.writeByte(commonLen);\n-            tmpDos.writeByte(diffLen);\n+            dictionaryDos.writeInt(word.dictionaryId());\n+            dictionaryDos.writeByte(commonLen);\n+            dictionaryDos.writeByte(diffLen);\n             for (int i = commonLen; i < wordText.length(); i++) {\n-                tmpDos.writeChar(wordText.charAt(i));\n+                dictionaryDos.writeChar(wordText.charAt(i));", "originalCommit": "96ed70e17d6cb526d2aaf010a395ffb26f0d7371", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA0MzYyMA==", "url": "https://github.com/hazelcast/hazelcast/pull/16869#discussion_r408043620", "bodyText": "\ud83d\udc4d", "author": "blazember", "createdAt": "2020-04-14T10:48:50Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/metrics/impl/MetricsCompressor.java", "diffHunk": "@@ -389,20 +388,16 @@ public static void extractMetrics(byte[] blob, MetricConsumer consumer, Supplier\n \n         for (int i = 0; i < dictionarySize; i++) {\n             int dictionaryId = dis.readInt();\n-            byte commonLen = dis.readByte();\n-            byte diffLen = dis.readByte();\n-\n-            for (int j = 0; j < commonLen; j++) {\n-                sb.append(lastWord.charAt(j));\n-            }\n-\n+            int commonLen = dis.readUnsignedByte();\n+            int diffLen = dis.readUnsignedByte();\n+            sb.append(lastWord, 0, commonLen);\n             for (int j = 0; j < diffLen; j++) {\n                 sb.append(dis.readChar());\n             }\n             String readWord = sb.toString();\n             lastWord = readWord;\n             dictionary[dictionaryId] = readWord;\n-            sb.delete(0, commonLen + diffLen);\n+            sb.setLength(0);", "originalCommit": "96ed70e17d6cb526d2aaf010a395ffb26f0d7371", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d0fbad130a199cceaccddaa45a268d35794cc88f", "url": "https://github.com/hazelcast/hazelcast/commit/d0fbad130a199cceaccddaa45a268d35794cc88f", "message": "Address the review comment", "committedDate": "2020-04-14T12:15:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYzOTIwMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16869#discussion_r408639201", "bodyText": "I wonder if that's a safe change from 4.0.z backport's perspective. Management Center is using MetricsCompressor to decompress metrics collection. And if this change is released in IMDG 4.0.2, MC 4.0 and 4.0.1 won't be able to decompress collections containing metrics with lengths in the [128, 255] range.\nSo, I think that this part of the PR (namely, byte -> unsigned byte change in the binary) shouldn't be backported to 4.0.z.\n@blazember WDYT?\nAdditional note (for the sake of completeness of this compatibility overview). Members decompress client metrics (see ClientEndpointImpl#provideDynamicMetrics()) before storing them in the collection (done by MC publisher). Thus, with this change a 4.0 or 4.0.1 member won't be able to decompress blob sent by a newer Java client. If we don't change the binary format and just make compressor to skip data points with lengthy metric names, that wouldn't be a concern.", "author": "puzpuzpuz", "createdAt": "2020-04-15T07:35:19Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/metrics/impl/MetricsCompressor.java", "diffHunk": "@@ -389,20 +391,16 @@ public static void extractMetrics(byte[] blob, MetricConsumer consumer, Supplier\n \n         for (int i = 0; i < dictionarySize; i++) {\n             int dictionaryId = dis.readInt();\n-            byte commonLen = dis.readByte();\n-            byte diffLen = dis.readByte();\n-\n-            for (int j = 0; j < commonLen; j++) {\n-                sb.append(lastWord.charAt(j));\n-            }\n-\n+            int commonLen = dis.readUnsignedByte();", "originalCommit": "d0fbad130a199cceaccddaa45a268d35794cc88f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc5Mjg2NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16869#discussion_r408792865", "bodyText": "Lengths under 255 are without any changes, regardless if member, client or both are fixed. Compressor never fails now or before. Client failed before, but doesn't now. For lengths above 256 the compression fails while previously the decompression failed.\nBut I think it's very important to ensure that the member doesn't crash for lengths above 255, we need a test for that, probably as a part of this PR.", "author": "viliam-durina", "createdAt": "2020-04-15T12:10:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYzOTIwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODgxNDE5MA==", "url": "https://github.com/hazelcast/hazelcast/pull/16869#discussion_r408814190", "bodyText": "Lengths under 255 are without any changes, regardless if member, client or both are fixed.\n\nMy bad. I've missed the fact that the write code stays the same, so changes are only in how written data (the byte) is interpreted.\n\nBut I think it's very important to ensure that the member doesn't crash for lengths above 255, we need a test for that, probably as a part of this PR.\n\nA huge +1 from me here.\nMarking this one as resolved.", "author": "puzpuzpuz", "createdAt": "2020-04-15T12:47:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYzOTIwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY0MDg2OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16869#discussion_r408640869", "bodyText": "nit: when_tooLongTagValue_then_fails sounds like a more sane method name.", "author": "puzpuzpuz", "createdAt": "2020-04-15T07:38:26Z", "path": "hazelcast/src/test/java/com/hazelcast/internal/metrics/impl/MetricsCompressorTest.java", "diffHunk": "@@ -307,4 +316,54 @@ public void consumeDouble(MetricDescriptor descriptor, double value) {\n \n         verify(metricConsumerSpy).consumeLong(sameMetric, 43L);\n     }\n+\n+    @Test\n+    public void testLongValue() {\n+        DefaultMetricDescriptorSupplier supplier = new DefaultMetricDescriptorSupplier();\n+        MetricsCompressor compressor = new MetricsCompressor();\n+\n+        String longPrefix = Stream.generate(() -> \"a\")\n+                                  .limit(MetricsDictionary.MAX_WORD_LENGTH - 1)\n+                                  .collect(Collectors.joining());\n+        MetricDescriptor metric1 = supplier.get()\n+                                           .withMetric(\"metricName\")\n+                                           .withTag(\"tag0\", longPrefix + \"0\")\n+                                           .withTag(\"tag1\", longPrefix + \"1\");\n+\n+        compressor.addLong(metric1, 42);\n+        byte[] blob = compressor.getBlobAndReset();\n+\n+        MetricConsumer metricConsumer = new MetricConsumer() {\n+            @Override\n+            public void consumeLong(MetricDescriptor descriptor, long value) {\n+                assertEquals(42, value);\n+                assertEquals(\"metricName\", descriptor.metric());\n+                assertEquals(longPrefix + \"0\", descriptor.tagValue(\"tag0\"));\n+                assertEquals(longPrefix + \"1\", descriptor.tagValue(\"tag1\"));\n+            }\n+\n+            @Override\n+            public void consumeDouble(MetricDescriptor descriptor, double value) {\n+                fail(\"Restored a double metric\");\n+            }\n+        };\n+\n+        MetricConsumer metricConsumerSpy = spy(metricConsumer);\n+        MetricsCompressor.extractMetrics(blob, metricConsumerSpy, supplierSpy);\n+    }\n+\n+    @Test\n+    public void when_tooLongValue_then_fails() {", "originalCommit": "d0fbad130a199cceaccddaa45a268d35794cc88f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY0MTA5OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16869#discussion_r408641099", "bodyText": "nit: testLongTagValue sounds like a more sane method name.", "author": "puzpuzpuz", "createdAt": "2020-04-15T07:38:51Z", "path": "hazelcast/src/test/java/com/hazelcast/internal/metrics/impl/MetricsCompressorTest.java", "diffHunk": "@@ -307,4 +316,54 @@ public void consumeDouble(MetricDescriptor descriptor, double value) {\n \n         verify(metricConsumerSpy).consumeLong(sameMetric, 43L);\n     }\n+\n+    @Test\n+    public void testLongValue() {", "originalCommit": "d0fbad130a199cceaccddaa45a268d35794cc88f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY0MTY2MA==", "url": "https://github.com/hazelcast/hazelcast/pull/16869#discussion_r408641660", "bodyText": "nit: when_tooLongWord_then_fails sounds like a more sane method name.", "author": "puzpuzpuz", "createdAt": "2020-04-15T07:39:50Z", "path": "hazelcast/src/test/java/com/hazelcast/internal/metrics/impl/MetricsDictionaryTest.java", "diffHunk": "@@ -69,4 +70,12 @@ public void testGetDictionaryIdReturnsSameIdForSameWord() {\n         assertEquals(word1Id, dictionary.getDictionaryId(\"word1\"));\n     }\n \n+    @Test\n+    public void when_tooLongValue_then_fails() {", "originalCommit": "d0fbad130a199cceaccddaa45a268d35794cc88f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "92ca18717f9556711fab5edd5b86f045f63e134b", "url": "https://github.com/hazelcast/hazelcast/commit/92ca18717f9556711fab5edd5b86f045f63e134b", "message": "Rename tests", "committedDate": "2020-04-15T12:28:00Z", "type": "commit"}, {"oid": "3ad6fbe2b72d10e3d960815958339b87898d5313", "url": "https://github.com/hazelcast/hazelcast/commit/3ad6fbe2b72d10e3d960815958339b87898d5313", "message": "Ignore metrics with too long words", "committedDate": "2020-04-15T13:29:18Z", "type": "commit"}, {"oid": "c56807dbbc2f05b7fae8b9d1486288f017cf5231", "url": "https://github.com/hazelcast/hazelcast/commit/c56807dbbc2f05b7fae8b9d1486288f017cf5231", "message": "Remove unnecessary operation", "committedDate": "2020-04-15T13:34:59Z", "type": "commit"}, {"oid": "07029fefc0c76f61ea2a86ccaf07955f5e5d6531", "url": "https://github.com/hazelcast/hazelcast/commit/07029fefc0c76f61ea2a86ccaf07955f5e5d6531", "message": "Add logging of ignored metrics with long words", "committedDate": "2020-04-15T13:57:15Z", "type": "commit"}, {"oid": "7c0aa5728febd9f6f80b86ea443f24de11363844", "url": "https://github.com/hazelcast/hazelcast/commit/7c0aa5728febd9f6f80b86ea443f24de11363844", "message": "Fix checkstyle", "committedDate": "2020-04-15T14:02:57Z", "type": "commit"}, {"oid": "3ac68a196ff3b270a43aad1a63a097a07d76cdee", "url": "https://github.com/hazelcast/hazelcast/commit/3ac68a196ff3b270a43aad1a63a097a07d76cdee", "message": "Make LongWordException non-checked", "committedDate": "2020-04-16T09:59:33Z", "type": "commit"}]}