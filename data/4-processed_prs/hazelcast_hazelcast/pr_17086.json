{"pr_number": 17086, "pr_title": "Initial support for Portable and INSERTs", "pr_createdAt": "2020-06-15T13:42:05Z", "pr_url": "https://github.com/hazelcast/hazelcast/pull/17086", "timeline": [{"oid": "e59b48d1e3920a63bee754cfe66683ebbaffd31a", "url": "https://github.com/hazelcast/hazelcast/commit/e59b48d1e3920a63bee754cfe66683ebbaffd31a", "message": "Initial support for Portable and INSERTs", "committedDate": "2020-06-15T13:16:48Z", "type": "commit"}, {"oid": "1ac3d3090f711bc7445ebec99f7702a3027a01f6", "url": "https://github.com/hazelcast/hazelcast/commit/1ac3d3090f711bc7445ebec99f7702a3027a01f6", "message": "Make checkstyle happy", "committedDate": "2020-06-15T13:55:53Z", "type": "commit"}, {"oid": "fed5f10f547dacc19f13c6cc4cb3282facfaada8", "url": "https://github.com/hazelcast/hazelcast/commit/fed5f10f547dacc19f13c6cc4cb3282facfaada8", "message": "Make checkstyle happy", "committedDate": "2020-06-15T14:02:47Z", "type": "commit"}, {"oid": "5870bbfe8500bc3d9fbbf91252df404a5faacd23", "url": "https://github.com/hazelcast/hazelcast/commit/5870bbfe8500bc3d9fbbf91252df404a5faacd23", "message": "Make checkstyle happy", "committedDate": "2020-06-15T14:14:31Z", "type": "commit"}, {"oid": "ee672ba8ace75fc08b00fb3286d34f2a3203a9fc", "url": "https://github.com/hazelcast/hazelcast/commit/ee672ba8ace75fc08b00fb3286d34f2a3203a9fc", "message": "Add support for POJO field injection", "committedDate": "2020-06-17T06:46:12Z", "type": "commit"}, {"oid": "196c567479d35777c994837342da6fc96f5594d7", "url": "https://github.com/hazelcast/hazelcast/commit/196c567479d35777c994837342da6fc96f5594d7", "message": "Proper declared table type resolution", "committedDate": "2020-06-17T07:20:36Z", "type": "commit"}, {"oid": "48001d80f5ada939bad083bdf29a6c8832eda971", "url": "https://github.com/hazelcast/hazelcast/commit/48001d80f5ada939bad083bdf29a6c8832eda971", "message": "Simplify resolvers", "committedDate": "2020-06-17T11:21:34Z", "type": "commit"}, {"oid": "d6b18861a8372be0883c2fd1aa0d500aaf72babb", "url": "https://github.com/hazelcast/hazelcast/commit/d6b18861a8372be0883c2fd1aa0d500aaf72babb", "message": "Add DML design doc.", "committedDate": "2020-06-17T12:36:48Z", "type": "commit"}, {"oid": "95c59e175fc26605e5596cb10bc113d995d0e83a", "url": "https://github.com/hazelcast/hazelcast/commit/95c59e175fc26605e5596cb10bc113d995d0e83a", "message": "Formatting", "committedDate": "2020-06-17T12:39:47Z", "type": "commit"}, {"oid": "3a4d9d0f7dc8a618d7a8cf43664da8392e3e06ec", "url": "https://github.com/hazelcast/hazelcast/commit/3a4d9d0f7dc8a618d7a8cf43664da8392e3e06ec", "message": "Wording", "committedDate": "2020-06-17T12:55:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTk4OTUwMw==", "url": "https://github.com/hazelcast/hazelcast/pull/17086#discussion_r441989503", "bodyText": "There is one problematic case that can be seen pretty frequently in IMDG with SQL - when the same field is present in both key and value. The common motivation for this is data co-location for joins. E.g.:\nPersonKey {\n    Long id;\n    Long deptId;\n}\nPersonValue {\n    ...\n    Long deptId;\n}\n\nIs there a way to write to both fields in our case?", "author": "devozerov", "createdAt": "2020-06-18T06:11:59Z", "path": "docs/design/sql/05-dml.md", "diffHunk": "@@ -0,0 +1,100 @@\n+# SQL DML\n+\n+## Overview\n+In SQL, the Data Manipulation Language comprises the SQL-data change statements which modify stored data.\n+Typically, we can distinguish three classes of commands:\n+- **CREATE** which creates new record(s) (`INSERT`)\n+- **UPDATE** which updates record(s) fields (`UPDATE`, `MERGE`)\n+- **DELETE** which deletes record(s) (`DELETE`)\n+\n+## 1. INSERT\n+To create new record(s) one of two variations of `INSERT` statement can be used:\n+- `INSERT INTO` - will append to the target table. If it\u2019s not possible due to unique constraint violation, it will\n+  fail. It\u2019s a safe choice if the target never overwrites (such as Kafka, JMS or a JDBC that use a sequence for the\n+  primary key or has no primary key)\n+- `INSERT OVERWRITE` - will allow overwrites. It will behave as a sequence of `DELETE` followed by an `INSERT`,\n+  performed atomically. Specifically, the fields not listed in the insert statement will not retain their values, but\n+  will be assigned `null` or default values. If `INSERT OVERWRITE` is used for a target that doesn\u2019t overwrite by\n+  design (like Kafka), it will behave exactly as `INSERT INTO`. No error will be thrown. The delete in the imaginary\n+  `DELETE` action will delete no rows.\n+\n+### 1.1 Serialization\n+In addition to primitive SQL types (which can be mapped to Java types and stored directly), two serialization formats\n+are supported:\n+- POJO (reflective access to public properties and fields) - requires Java class on the classpath and no-arg\n+  constructor\n+- Portable (supported just for IMDG data structures) - if `InMemoryFormat` is set to `BINARY` it requires just\n+  `ClassDefinition` to be registered upfront, if `InMemoryFormat` is set to `OBJECT` it requires also Portable factory\n+  and Portable class itself on the classpath\n+\n+Serialization formats have following precedence (the order in which we check whether given serialization can be\n+applied):\n+1. primitive SQL types\n+2. POJO\n+3. Portable\n+\n+Eventual errors from type mismatch between declared and actual types are deferred to statement execution.\n+\n+The way the data is serialized is expressed via DDL. Depending on the nature of stored objects that information can be\n+encoded either in column names or using `OPTIONS` clause.\n+\n+#### 1.1.1 Key-Value storage\n+The serialization formats of key and value are specified separately. To determine whether given field belongs to key or\n+value either Java class or Portable `ClassDefinition` is inspected. In case of a name clash between fields of key and\n+value composite objects, the ones from key take precedence and are actually written.", "originalCommit": "3a4d9d0f7dc8a618d7a8cf43664da8392e3e06ec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjAxMDI3Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17086#discussion_r442010276", "bodyText": "It can be done, of course. So there would be no shadowing for INSERTSs.", "author": "gierlachg", "createdAt": "2020-06-18T07:03:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTk4OTUwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjA0NDM5MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17086#discussion_r442044390", "bodyText": "How the DDL command to handle such use case would look like?", "author": "devozerov", "createdAt": "2020-06-18T08:07:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTk4OTUwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjA0NjUwMA==", "url": "https://github.com/hazelcast/hazelcast/pull/17086#discussion_r442046500", "bodyText": "Personally, I would not introduce any specific syntax for this. What about the simplest thing, while reading key shadows value but while writing both are written?", "author": "gierlachg", "createdAt": "2020-06-18T08:11:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTk4OTUwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjA1MTE3NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17086#discussion_r442051174", "bodyText": "This might be surprising to users because in some cases fields with the same name may actually be different.\nI think aliases could provide a way to solve this, where we define a field and a path to the value of the field.", "author": "devozerov", "createdAt": "2020-06-18T08:19:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTk4OTUwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY1NDkyMA==", "url": "https://github.com/hazelcast/hazelcast/pull/17086#discussion_r442654920", "bodyText": "Do you have any specific syntax in mind? Or something like @viliam-durina recently proposed:\nCREATE EXTERNAL TABLE t (\n  id_key BIGINT,\n  id_value BIGINT\n)\nTYPE ...\nOPTIONS (\n  \"fieldName.id_key\" '__key.id',\n  \"fieldName.id_value\" 'this.id'\n)\n\n?", "author": "gierlachg", "createdAt": "2020-06-19T06:28:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTk4OTUwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTk5MjcyMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17086#discussion_r441992721", "bodyText": "One thing that concerns me is the usage of CREATE EXTERNAL TABLE for internal cluster objects because the whole command context is misleading:\n\nNothing is really created because the map already exists. Likewise, when we call \"DROP\" the map is not destroyed\nThe map is internal to the system, not external\n\nWhat if rethink completely how treat maps? Consider that in future we may want to create and drop distributed objects declaratively, @cangencer has some ideas about it. In this case, we will do something like CREATE MAP myMap ... or DROP MAP myMap ....\nNow, what we may want to do with an existing IMap is to add some metadata, like these class names. This could be done with the ALTER statement. E.g.:\nALTER MAP myMap KEY_CLASS com.PersonKey VALUE_CLASS com.Person TABLE_NAME my_map_table\nWDYT?", "author": "devozerov", "createdAt": "2020-06-18T06:21:02Z", "path": "docs/design/sql/05-dml.md", "diffHunk": "@@ -0,0 +1,100 @@\n+# SQL DML\n+\n+## Overview\n+In SQL, the Data Manipulation Language comprises the SQL-data change statements which modify stored data.\n+Typically, we can distinguish three classes of commands:\n+- **CREATE** which creates new record(s) (`INSERT`)\n+- **UPDATE** which updates record(s) fields (`UPDATE`, `MERGE`)\n+- **DELETE** which deletes record(s) (`DELETE`)\n+\n+## 1. INSERT\n+To create new record(s) one of two variations of `INSERT` statement can be used:\n+- `INSERT INTO` - will append to the target table. If it\u2019s not possible due to unique constraint violation, it will\n+  fail. It\u2019s a safe choice if the target never overwrites (such as Kafka, JMS or a JDBC that use a sequence for the\n+  primary key or has no primary key)\n+- `INSERT OVERWRITE` - will allow overwrites. It will behave as a sequence of `DELETE` followed by an `INSERT`,\n+  performed atomically. Specifically, the fields not listed in the insert statement will not retain their values, but\n+  will be assigned `null` or default values. If `INSERT OVERWRITE` is used for a target that doesn\u2019t overwrite by\n+  design (like Kafka), it will behave exactly as `INSERT INTO`. No error will be thrown. The delete in the imaginary\n+  `DELETE` action will delete no rows.\n+\n+### 1.1 Serialization\n+In addition to primitive SQL types (which can be mapped to Java types and stored directly), two serialization formats\n+are supported:\n+- POJO (reflective access to public properties and fields) - requires Java class on the classpath and no-arg\n+  constructor\n+- Portable (supported just for IMDG data structures) - if `InMemoryFormat` is set to `BINARY` it requires just\n+  `ClassDefinition` to be registered upfront, if `InMemoryFormat` is set to `OBJECT` it requires also Portable factory\n+  and Portable class itself on the classpath\n+\n+Serialization formats have following precedence (the order in which we check whether given serialization can be\n+applied):\n+1. primitive SQL types\n+2. POJO\n+3. Portable\n+\n+Eventual errors from type mismatch between declared and actual types are deferred to statement execution.\n+\n+The way the data is serialized is expressed via DDL. Depending on the nature of stored objects that information can be\n+encoded either in column names or using `OPTIONS` clause.\n+\n+#### 1.1.1 Key-Value storage\n+The serialization formats of key and value are specified separately. To determine whether given field belongs to key or\n+value either Java class or Portable `ClassDefinition` is inspected. In case of a name clash between fields of key and\n+value composite objects, the ones from key take precedence and are actually written.\n+\n+To define a table where both key and value are of primitive SQL types, `__key` & `this` as column names should be used.\n+For example:\n+```\n+CREATE EXTERNAL TABLE name (\n+  __key INT,\n+  this VARCHAR\n+) TYPE \"com.hazelcast.LocalPartitionedMap\"", "originalCommit": "3a4d9d0f7dc8a618d7a8cf43664da8392e3e06ec", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTk5NDc5OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17086#discussion_r441994799", "bodyText": "Here we basically duplicate the definition of columns. First, they are defined explicitly. Second, they could be derived from the class. The idea with CREATE MAP / ALTER MAP addresses this - you just provide class definitions (in the form of a class name, or portable class IDs), and columns are extracted from there.\nIs there any important use cases for us where explicit column definition might be needed? E.g. to define an alias for the column, or to mark it non-nullable, etc?", "author": "devozerov", "createdAt": "2020-06-18T06:26:25Z", "path": "docs/design/sql/05-dml.md", "diffHunk": "@@ -0,0 +1,100 @@\n+# SQL DML\n+\n+## Overview\n+In SQL, the Data Manipulation Language comprises the SQL-data change statements which modify stored data.\n+Typically, we can distinguish three classes of commands:\n+- **CREATE** which creates new record(s) (`INSERT`)\n+- **UPDATE** which updates record(s) fields (`UPDATE`, `MERGE`)\n+- **DELETE** which deletes record(s) (`DELETE`)\n+\n+## 1. INSERT\n+To create new record(s) one of two variations of `INSERT` statement can be used:\n+- `INSERT INTO` - will append to the target table. If it\u2019s not possible due to unique constraint violation, it will\n+  fail. It\u2019s a safe choice if the target never overwrites (such as Kafka, JMS or a JDBC that use a sequence for the\n+  primary key or has no primary key)\n+- `INSERT OVERWRITE` - will allow overwrites. It will behave as a sequence of `DELETE` followed by an `INSERT`,\n+  performed atomically. Specifically, the fields not listed in the insert statement will not retain their values, but\n+  will be assigned `null` or default values. If `INSERT OVERWRITE` is used for a target that doesn\u2019t overwrite by\n+  design (like Kafka), it will behave exactly as `INSERT INTO`. No error will be thrown. The delete in the imaginary\n+  `DELETE` action will delete no rows.\n+\n+### 1.1 Serialization\n+In addition to primitive SQL types (which can be mapped to Java types and stored directly), two serialization formats\n+are supported:\n+- POJO (reflective access to public properties and fields) - requires Java class on the classpath and no-arg\n+  constructor\n+- Portable (supported just for IMDG data structures) - if `InMemoryFormat` is set to `BINARY` it requires just\n+  `ClassDefinition` to be registered upfront, if `InMemoryFormat` is set to `OBJECT` it requires also Portable factory\n+  and Portable class itself on the classpath\n+\n+Serialization formats have following precedence (the order in which we check whether given serialization can be\n+applied):\n+1. primitive SQL types\n+2. POJO\n+3. Portable\n+\n+Eventual errors from type mismatch between declared and actual types are deferred to statement execution.\n+\n+The way the data is serialized is expressed via DDL. Depending on the nature of stored objects that information can be\n+encoded either in column names or using `OPTIONS` clause.\n+\n+#### 1.1.1 Key-Value storage\n+The serialization formats of key and value are specified separately. To determine whether given field belongs to key or\n+value either Java class or Portable `ClassDefinition` is inspected. In case of a name clash between fields of key and\n+value composite objects, the ones from key take precedence and are actually written.\n+\n+To define a table where both key and value are of primitive SQL types, `__key` & `this` as column names should be used.\n+For example:\n+```\n+CREATE EXTERNAL TABLE name (\n+  __key INT,\n+  this VARCHAR\n+) TYPE \"com.hazelcast.LocalPartitionedMap\"\n+```\n+\n+Given:\n+```\n+class PersonId {\n+    public int id;\n+}\n+\n+class Person {\n+    public String name;\n+}\n+```\n+To define a table where both key and value are POJOs and respectively of `PersonId` & `Person` class, `keyClass` &\n+`valueClass` should be used. For example:\n+```\n+CREATE EXTERNAL TABLE name (", "originalCommit": "3a4d9d0f7dc8a618d7a8cf43664da8392e3e06ec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjAwODI3Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17086#discussion_r442008277", "bodyText": "There is one important use case where the map does not exist and user would like to start inserting records to it. In any other scenario, in theory, we don't need any CREATE/ALTER as we can derive the schema from existing entries. We could for instance allow CREATE MAP (however it's another customization to the syntax) only if map with given name does not exist - failing otherwise. Moreover, if we want to avoid duplication of defined columns we would need to take that customization a little bit further and disallow specifying table columns at all, something like CREATE MAP map_name OPTIONS (keyClass 'PersonId', valueClass 'Person').\nThe second use case I see, where specifying (and not deriving from existing entries) table columns might be useful is usage of polymorphic maps. Maybe, user would like to be specific (and sure) what classes are read and written - however I'm not sure how widespread such usage is.", "author": "gierlachg", "createdAt": "2020-06-18T06:59:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTk5NDc5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTk5NjUzOA==", "url": "https://github.com/hazelcast/hazelcast/pull/17086#discussion_r441996538", "bodyText": "Type specification in the form of fully-qualified class name is pretty verbose. Can it be reduced to a simple name? E.g. kafka, jms, etc.", "author": "devozerov", "createdAt": "2020-06-18T06:30:47Z", "path": "docs/design/sql/05-dml.md", "diffHunk": "@@ -0,0 +1,100 @@\n+# SQL DML\n+\n+## Overview\n+In SQL, the Data Manipulation Language comprises the SQL-data change statements which modify stored data.\n+Typically, we can distinguish three classes of commands:\n+- **CREATE** which creates new record(s) (`INSERT`)\n+- **UPDATE** which updates record(s) fields (`UPDATE`, `MERGE`)\n+- **DELETE** which deletes record(s) (`DELETE`)\n+\n+## 1. INSERT\n+To create new record(s) one of two variations of `INSERT` statement can be used:\n+- `INSERT INTO` - will append to the target table. If it\u2019s not possible due to unique constraint violation, it will\n+  fail. It\u2019s a safe choice if the target never overwrites (such as Kafka, JMS or a JDBC that use a sequence for the\n+  primary key or has no primary key)\n+- `INSERT OVERWRITE` - will allow overwrites. It will behave as a sequence of `DELETE` followed by an `INSERT`,\n+  performed atomically. Specifically, the fields not listed in the insert statement will not retain their values, but\n+  will be assigned `null` or default values. If `INSERT OVERWRITE` is used for a target that doesn\u2019t overwrite by\n+  design (like Kafka), it will behave exactly as `INSERT INTO`. No error will be thrown. The delete in the imaginary\n+  `DELETE` action will delete no rows.\n+\n+### 1.1 Serialization\n+In addition to primitive SQL types (which can be mapped to Java types and stored directly), two serialization formats\n+are supported:\n+- POJO (reflective access to public properties and fields) - requires Java class on the classpath and no-arg\n+  constructor\n+- Portable (supported just for IMDG data structures) - if `InMemoryFormat` is set to `BINARY` it requires just\n+  `ClassDefinition` to be registered upfront, if `InMemoryFormat` is set to `OBJECT` it requires also Portable factory\n+  and Portable class itself on the classpath\n+\n+Serialization formats have following precedence (the order in which we check whether given serialization can be\n+applied):\n+1. primitive SQL types\n+2. POJO\n+3. Portable\n+\n+Eventual errors from type mismatch between declared and actual types are deferred to statement execution.\n+\n+The way the data is serialized is expressed via DDL. Depending on the nature of stored objects that information can be\n+encoded either in column names or using `OPTIONS` clause.\n+\n+#### 1.1.1 Key-Value storage\n+The serialization formats of key and value are specified separately. To determine whether given field belongs to key or\n+value either Java class or Portable `ClassDefinition` is inspected. In case of a name clash between fields of key and\n+value composite objects, the ones from key take precedence and are actually written.\n+\n+To define a table where both key and value are of primitive SQL types, `__key` & `this` as column names should be used.\n+For example:\n+```\n+CREATE EXTERNAL TABLE name (\n+  __key INT,\n+  this VARCHAR\n+) TYPE \"com.hazelcast.LocalPartitionedMap\"\n+```\n+\n+Given:\n+```\n+class PersonId {\n+    public int id;\n+}\n+\n+class Person {\n+    public String name;\n+}\n+```\n+To define a table where both key and value are POJOs and respectively of `PersonId` & `Person` class, `keyClass` &\n+`valueClass` should be used. For example:\n+```\n+CREATE EXTERNAL TABLE name (\n+  id INT,\n+  name VARCHAR\n+) TYPE \"com.hazelcast.LocalPartitionedMap\"\n+OPTIONS (keyClass 'PersonId', valueClass 'Person')\n+```\n+\n+Given:\n+```\n+ClassDefinition keyClassDefinition = new ClassDefinitionBuilder(1, 2, 3)\n+    .addIntField(\"id\")\n+    .build();\n+\n+ClassDefinition valueClassDefinition = new ClassDefinitionBuilder(4, 5, 6)\n+    .addUTFField(\"name\")\n+    .build();\n+```\n+To define a table where both key and value are Portables and map to respective `ClassDefinition`s, `keyFactoryId` +\n+`keyClassId` + `KeyClassVersion` & `valueFactoryId` + `valueClassId` + `valueClassVersion` should be used. For example:\n+```\n+CREATE EXTERNAL TABLE name (\n+  id INT,\n+  name VARCHAR\n+) TYPE \"com.hazelcast.LocalPartitionedMap\"", "originalCommit": "3a4d9d0f7dc8a618d7a8cf43664da8392e3e06ec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjAwODkxMg==", "url": "https://github.com/hazelcast/hazelcast/pull/17086#discussion_r442008912", "bodyText": "I believe it was intentionally done like that by @viliam-durina to ease the creation of custom connectors.", "author": "gierlachg", "createdAt": "2020-06-18T07:00:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTk5NjUzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjA0NTUyMg==", "url": "https://github.com/hazelcast/hazelcast/pull/17086#discussion_r442045522", "bodyText": "Yes, the question is - does it really pays off? From the user perspective, he always needs to provide the fully-qualified name in quotes. But practically the chance of conflict is close to zero.", "author": "devozerov", "createdAt": "2020-06-18T08:09:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTk5NjUzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTk5NzAxMw==", "url": "https://github.com/hazelcast/hazelcast/pull/17086#discussion_r441997013", "bodyText": "Can we have an explicit list of commands that are going to be supported in 4.1?", "author": "devozerov", "createdAt": "2020-06-18T06:31:56Z", "path": "docs/design/sql/05-dml.md", "diffHunk": "@@ -0,0 +1,100 @@\n+# SQL DML\n+\n+## Overview\n+In SQL, the Data Manipulation Language comprises the SQL-data change statements which modify stored data.\n+Typically, we can distinguish three classes of commands:", "originalCommit": "3a4d9d0f7dc8a618d7a8cf43664da8392e3e06ec", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTk5NzI4Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17086#discussion_r441997287", "bodyText": "We should define in the document in which schema the object will be created.", "author": "devozerov", "createdAt": "2020-06-18T06:32:40Z", "path": "docs/design/sql/05-dml.md", "diffHunk": "@@ -0,0 +1,100 @@\n+# SQL DML\n+\n+## Overview\n+In SQL, the Data Manipulation Language comprises the SQL-data change statements which modify stored data.\n+Typically, we can distinguish three classes of commands:\n+- **CREATE** which creates new record(s) (`INSERT`)\n+- **UPDATE** which updates record(s) fields (`UPDATE`, `MERGE`)\n+- **DELETE** which deletes record(s) (`DELETE`)\n+\n+## 1. INSERT\n+To create new record(s) one of two variations of `INSERT` statement can be used:\n+- `INSERT INTO` - will append to the target table. If it\u2019s not possible due to unique constraint violation, it will\n+  fail. It\u2019s a safe choice if the target never overwrites (such as Kafka, JMS or a JDBC that use a sequence for the\n+  primary key or has no primary key)\n+- `INSERT OVERWRITE` - will allow overwrites. It will behave as a sequence of `DELETE` followed by an `INSERT`,\n+  performed atomically. Specifically, the fields not listed in the insert statement will not retain their values, but\n+  will be assigned `null` or default values. If `INSERT OVERWRITE` is used for a target that doesn\u2019t overwrite by\n+  design (like Kafka), it will behave exactly as `INSERT INTO`. No error will be thrown. The delete in the imaginary\n+  `DELETE` action will delete no rows.\n+\n+### 1.1 Serialization\n+In addition to primitive SQL types (which can be mapped to Java types and stored directly), two serialization formats\n+are supported:\n+- POJO (reflective access to public properties and fields) - requires Java class on the classpath and no-arg\n+  constructor\n+- Portable (supported just for IMDG data structures) - if `InMemoryFormat` is set to `BINARY` it requires just\n+  `ClassDefinition` to be registered upfront, if `InMemoryFormat` is set to `OBJECT` it requires also Portable factory\n+  and Portable class itself on the classpath\n+\n+Serialization formats have following precedence (the order in which we check whether given serialization can be\n+applied):\n+1. primitive SQL types\n+2. POJO\n+3. Portable\n+\n+Eventual errors from type mismatch between declared and actual types are deferred to statement execution.\n+\n+The way the data is serialized is expressed via DDL. Depending on the nature of stored objects that information can be\n+encoded either in column names or using `OPTIONS` clause.\n+\n+#### 1.1.1 Key-Value storage\n+The serialization formats of key and value are specified separately. To determine whether given field belongs to key or\n+value either Java class or Portable `ClassDefinition` is inspected. In case of a name clash between fields of key and\n+value composite objects, the ones from key take precedence and are actually written.\n+\n+To define a table where both key and value are of primitive SQL types, `__key` & `this` as column names should be used.\n+For example:\n+```\n+CREATE EXTERNAL TABLE name (\n+  __key INT,\n+  this VARCHAR\n+) TYPE \"com.hazelcast.LocalPartitionedMap\"\n+```\n+\n+Given:\n+```\n+class PersonId {\n+    public int id;\n+}\n+\n+class Person {\n+    public String name;\n+}\n+```\n+To define a table where both key and value are POJOs and respectively of `PersonId` & `Person` class, `keyClass` &\n+`valueClass` should be used. For example:\n+```\n+CREATE EXTERNAL TABLE name (\n+  id INT,\n+  name VARCHAR\n+) TYPE \"com.hazelcast.LocalPartitionedMap\"\n+OPTIONS (keyClass 'PersonId', valueClass 'Person')\n+```\n+\n+Given:\n+```\n+ClassDefinition keyClassDefinition = new ClassDefinitionBuilder(1, 2, 3)\n+    .addIntField(\"id\")\n+    .build();\n+\n+ClassDefinition valueClassDefinition = new ClassDefinitionBuilder(4, 5, 6)\n+    .addUTFField(\"name\")\n+    .build();\n+```\n+To define a table where both key and value are Portables and map to respective `ClassDefinition`s, `keyFactoryId` +\n+`keyClassId` + `KeyClassVersion` & `valueFactoryId` + `valueClassId` + `valueClassVersion` should be used. For example:\n+```\n+CREATE EXTERNAL TABLE name (", "originalCommit": "3a4d9d0f7dc8a618d7a8cf43664da8392e3e06ec", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b92ea7f9871eac2bb480e3ac4f169d0ba96f952e", "url": "https://github.com/hazelcast/hazelcast/commit/b92ea7f9871eac2bb480e3ac4f169d0ba96f952e", "message": "Improving DML design document", "committedDate": "2020-06-18T12:05:03Z", "type": "commit"}, {"oid": "3a2607eafff710ba28f7374889a1da75a39f99f0", "url": "https://github.com/hazelcast/hazelcast/commit/3a2607eafff710ba28f7374889a1da75a39f99f0", "message": "Merge branch 'sql' into portable_and_inserts\n\n# Conflicts:\n#\thazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/parse/UnsupportedOperationVisitor.java", "committedDate": "2020-06-18T12:40:03Z", "type": "commit"}, {"oid": "932ce39408273933944211cb2b1e1529cd1f63a5", "url": "https://github.com/hazelcast/hazelcast/commit/932ce39408273933944211cb2b1e1529cd1f63a5", "message": "Add TODOs", "committedDate": "2020-06-18T16:51:58Z", "type": "commit"}, {"oid": "0b3223730e8fca1f573760cfa2d334e616524ff5", "url": "https://github.com/hazelcast/hazelcast/commit/0b3223730e8fca1f573760cfa2d334e616524ff5", "message": "Merge branch 'sql' into portable_and_inserts", "committedDate": "2020-06-19T13:38:14Z", "type": "commit"}, {"oid": "caa372da9d589ba830dddd5565130d63cc9955ff", "url": "https://github.com/hazelcast/hazelcast/commit/caa372da9d589ba830dddd5565130d63cc9955ff", "message": "Merge branch 'sql' into portable_and_inserts", "committedDate": "2020-06-23T10:27:27Z", "type": "commit"}, {"oid": "09b6e82fb38eb211b983978f07473f2bb461ab2f", "url": "https://github.com/hazelcast/hazelcast/commit/09b6e82fb38eb211b983978f07473f2bb461ab2f", "message": "Add JSON support for SQL", "committedDate": "2020-06-23T14:51:40Z", "type": "commit"}, {"oid": "0cafa572f971848c0fd070baaa96bc506042a034", "url": "https://github.com/hazelcast/hazelcast/commit/0cafa572f971848c0fd070baaa96bc506042a034", "message": "Derive schema from POJO & Portable", "committedDate": "2020-06-24T09:46:09Z", "type": "commit"}, {"oid": "122a9dbded4a4849f265375ff2c616f387829ff6", "url": "https://github.com/hazelcast/hazelcast/commit/122a9dbded4a4849f265375ff2c616f387829ff6", "message": "Cleanup", "committedDate": "2020-06-24T10:12:18Z", "type": "commit"}, {"oid": "529b53dd729ba598853a45ce8a39c68a6e3a76a9", "url": "https://github.com/hazelcast/hazelcast/commit/529b53dd729ba598853a45ce8a39c68a6e3a76a9", "message": "Refactor", "committedDate": "2020-06-24T11:16:28Z", "type": "commit"}, {"oid": "60ced877dc12a4e04ffa129e38125474cec7120c", "url": "https://github.com/hazelcast/hazelcast/commit/60ced877dc12a4e04ffa129e38125474cec7120c", "message": "Refactor UpsertTargets", "committedDate": "2020-06-24T12:42:27Z", "type": "commit"}, {"oid": "78ec920259853fb7cab6fcfa88c1c5f581221318", "url": "https://github.com/hazelcast/hazelcast/commit/78ec920259853fb7cab6fcfa88c1c5f581221318", "message": "Refactor JsonUpsertTarget", "committedDate": "2020-06-24T13:06:51Z", "type": "commit"}, {"oid": "370e3c052a12a74edb522d1e7bf77cebf12e7057", "url": "https://github.com/hazelcast/hazelcast/commit/370e3c052a12a74edb522d1e7bf77cebf12e7057", "message": "Support sample json metadata resolution", "committedDate": "2020-06-25T06:47:11Z", "type": "commit"}, {"oid": "9692dbac6b5411acd86ab17926293d6c13a8ca30", "url": "https://github.com/hazelcast/hazelcast/commit/9692dbac6b5411acd86ab17926293d6c13a8ca30", "message": "Better error handling", "committedDate": "2020-06-25T07:15:17Z", "type": "commit"}, {"oid": "140f7a4a8604cf9e03de1531aaa884b8c22fdf1d", "url": "https://github.com/hazelcast/hazelcast/commit/140f7a4a8604cf9e03de1531aaa884b8c22fdf1d", "message": "Avoid json deserialization", "committedDate": "2020-06-25T08:55:02Z", "type": "commit"}, {"oid": "a6011802292d1b364528aae2dfadaa9619eaf4c6", "url": "https://github.com/hazelcast/hazelcast/commit/a6011802292d1b364528aae2dfadaa9619eaf4c6", "message": "Add table validation on creation", "committedDate": "2020-06-25T09:56:51Z", "type": "commit"}, {"oid": "a90e43ab4b61808e62150344081665b01d12d5f8", "url": "https://github.com/hazelcast/hazelcast/commit/a90e43ab4b61808e62150344081665b01d12d5f8", "message": "Naming", "committedDate": "2020-06-25T10:01:31Z", "type": "commit"}, {"oid": "119cb405c296bee799ffc499267375603da345c6", "url": "https://github.com/hazelcast/hazelcast/commit/119cb405c296bee799ffc499267375603da345c6", "message": "Make checkstyle happier", "committedDate": "2020-06-25T12:15:54Z", "type": "commit"}, {"oid": "76caa8316efde8fae9f9f15c6fdd57b0f58c13fb", "url": "https://github.com/hazelcast/hazelcast/commit/76caa8316efde8fae9f9f15c6fdd57b0f58c13fb", "message": "Merge branch 'sql' into portable_and_inserts\n\n# Conflicts:\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/extract/GenericQueryTarget.java\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/schema/map/ReplicatedMapTableResolver.java\n#\thazelcast/src/test/java/com/hazelcast/sql/impl/schema/map/sample/MapSampleMetadataResolverTest.java", "committedDate": "2020-06-25T12:39:37Z", "type": "commit"}, {"oid": "fc66420c1270b1a27496b712bd42a973f49c6ae4", "url": "https://github.com/hazelcast/hazelcast/commit/fc66420c1270b1a27496b712bd42a973f49c6ae4", "message": "Formatting", "committedDate": "2020-06-25T12:45:16Z", "type": "commit"}]}