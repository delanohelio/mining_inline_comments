{"pr_number": 17568, "pr_title": "Clean up ClusterProperty", "pr_createdAt": "2020-09-17T12:51:50Z", "pr_url": "https://github.com/hazelcast/hazelcast/pull/17568", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDkxNzY1MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17568#discussion_r490917650", "bodyText": "Could you also add the JavaDoc?", "author": "kwart", "createdAt": "2020-09-18T12:34:39Z", "path": "hazelcast/src/main/java/com/hazelcast/spi/properties/ClusterProperty.java", "diffHunk": "@@ -53,170 +53,177 @@\n  */\n @SuppressWarnings({\"checkstyle:javadocvariable\", \"checkstyle:magicnumber\"})\n public final class ClusterProperty {\n+    /*\n+     * NETWORKING / TCP PROPERTIES\n+     */\n+    /**\n+     * The interval at which network stats (bytes sent and received) are\n+     * re-calculated and published.\n+     * Used only when Advanced Networking is enabled.\n+     */\n+    public static final HazelcastProperty NETWORK_STATS_REFRESH_INTERVAL_SECONDS\n+            = new HazelcastProperty(\"hazelcast.network.stats.refresh.interval.seconds\", 3, SECONDS);\n+\n+    /**\n+     * Controls whether we apply more strict checks upon BIND requests towards\n+     * a cluster member.\n+     * The checks mainly validate the remote BIND request against the remote\n+     * address as found in the socket. By default they are disabled, to avoid\n+     * connectivity issues when deployed under NAT'ed infrastructure.\n+     */\n+    public static final HazelcastProperty BIND_SPOOFING_CHECKS =\n+            new HazelcastProperty(\"hazelcast.nio.tcp.spoofing.checks\", false);\n \n     /**\n      * Number of parallel connection between members.\n-     *\n+     * <p>\n      * There is no point in having more connections than IO threads.\n      */\n     public static final HazelcastProperty CHANNEL_COUNT\n             = new HazelcastProperty(\"tcp.channels.per.connection\", 1);\n \n     /**\n-     * Total number of partitions in the Hazelcast cluster.\n+     * The interval in seconds between\n+     * {@link com.hazelcast.internal.networking.nio.iobalancer.IOBalancer}\n+     * executions. The shorter intervals will catch I/O Imbalance faster, but\n+     * they will cause higher overhead.\n+     * <p>\n+     * Please see the documentation of\n+     * {@link com.hazelcast.internal.networking.nio.iobalancer.IOBalancer}\n+     * for a detailed explanation of the problem.\n+     * <p>\n+     * The default is 20 seconds. A value smaller than 1 disables the balancer.\n      */\n-    public static final HazelcastProperty PARTITION_COUNT\n-            = new HazelcastProperty(\"hazelcast.partition.count\", 271);\n+    public static final HazelcastProperty IO_BALANCER_INTERVAL_SECONDS\n+            = new HazelcastProperty(\"hazelcast.io.balancer.interval.seconds\", 20, SECONDS);\n \n     /**\n-     * The number of partition operation handler threads per member.\n-     * <p>\n-     * If this is less than the number of partitions on a member, partition operations\n-     * will queue behind other operations of different partitions.\n-     *\n+     * Prefer IPv4 network interface when picking a local address.\n      */\n-    public static final HazelcastProperty PARTITION_OPERATION_THREAD_COUNT\n-            = new HazelcastProperty(\"hazelcast.operation.thread.count\",\n-            (Function<HazelcastProperties, Integer>) properties -> max(2, RuntimeAvailableProcessors.get()));\n+    @SuppressWarnings(\"checkstyle:constantname\")\n+    public static final HazelcastProperty PREFER_IPv4_STACK\n+            = new HazelcastProperty(\"hazelcast.prefer.ipv4.stack\", true);\n \n     /**\n-     * The number of generic operation handler threads per member.\n-     * <p>\n-     * The default is max(2, processors/2);\n+     * Bind both server-socket and client-sockets to any local interface.\n      */\n-    public static final HazelcastProperty GENERIC_OPERATION_THREAD_COUNT\n-            = new HazelcastProperty(\"hazelcast.operation.generic.thread.count\",\n-            (Function<HazelcastProperties, Integer>) o -> {\n-                // default generic operation thread count\n-                int processors = RuntimeAvailableProcessors.get();\n-                return max(2, processors / 2);\n-            });\n+    public static final HazelcastProperty SOCKET_BIND_ANY\n+            = new HazelcastProperty(\"hazelcast.socket.bind.any\", true);\n \n     /**\n-     * The number of priority generic operation handler threads per member.\n-     * <p>\n-     * The default is 1.\n-     * <p>\n-     * Having at least 1 priority generic operation thread helps to improve cluster stability since a lot of cluster\n-     * operations are generic priority operations and they should get executed as soon as possible. If there is a dedicated\n-     * generic operation thread then these operations don't get delayed because the generic threads are busy executing regular\n-     * user operations. So unless memory consumption is an issue, make sure there is at least 1 thread.\n+     * Bind server-socket to any local interface. If not set,\n+     * {@link #SOCKET_BIND_ANY} is used as the default.\n      */\n-    public static final HazelcastProperty PRIORITY_GENERIC_OPERATION_THREAD_COUNT\n-            = new HazelcastProperty(\"hazelcast.operation.priority.generic.thread.count\", 1);\n+    public static final HazelcastProperty SOCKET_SERVER_BIND_ANY\n+            = new HazelcastProperty(\"hazelcast.socket.server.bind.any\", SOCKET_BIND_ANY);\n \n     /**\n-     * The number of threads that process responses.\n-     * <p>\n-     * By default there are 2 response threads; this gives stable and good performance.\n-     * <p>\n-     * If set to 0, the response threads are bypassed and the response handling is done\n-     * on the IO threads. Under certain conditions this can give a higher throughput, but\n-     * setting it to 0 should be regarded an experimental feature.\n+     * Bind client-sockets to any local interface. If not set,\n+     * {@link #SOCKET_BIND_ANY} is used as the default.\n      */\n-    public static final HazelcastProperty RESPONSE_THREAD_COUNT\n-            = new HazelcastProperty(\"hazelcast.operation.response.thread.count\", 2);\n+    public static final HazelcastProperty SOCKET_CLIENT_BIND_ANY\n+            = new HazelcastProperty(\"hazelcast.socket.client.bind.any\", SOCKET_BIND_ANY);\n \n     /**\n-     * The number of threads that the client engine has available for processing requests that are not partition specific.\n-     * Most of the requests, such as {@code map.put} and {@code map.get}, are partition specific and will use a\n-     * partition-specific operation thread, but there are also requests that can't be executed on a partition-specific operation\n-     * thread, such as {@code multimap.containsValue(value)}, because they need to access all partitions on a given\n-     * member.\n-     *\n-     * When not set it is set as core-size\n+     * Bind client socket to an interface when connecting to a remote server\n+     * socket. When set to false, client socket is not bound to any interface.\n      */\n-    public static final HazelcastProperty CLIENT_ENGINE_THREAD_COUNT\n-            = new HazelcastProperty(\"hazelcast.clientengine.thread.count\", -1);\n+    public static final HazelcastProperty SOCKET_CLIENT_BIND\n+            = new HazelcastProperty(\"hazelcast.socket.client.bind\", true);\n \n     /**\n-     * The number of threads that the client engine has available for processing requests that are related to transactions\n-     * When not set it is set as core-size.\n+     * Socket receive buffer (SO_RCVBUF) size in KB. If you have a very fast\n+     * network, e.g., 10gbit) and/or you have large entries, then you may benefit\n+     * from increasing sender/receiver buffer sizes. Use this property and the\n+     * next one below tune the size.\n      */\n-    public static final HazelcastProperty CLIENT_ENGINE_QUERY_THREAD_COUNT\n-            = new HazelcastProperty(\"hazelcast.clientengine.query.thread.count\", -1);\n+    public static final HazelcastProperty SOCKET_RECEIVE_BUFFER_SIZE\n+            = new HazelcastProperty(\"hazelcast.socket.receive.buffer.size\", 128);\n \n     /**\n-     * The number of threads that the client engine has available for processing requests that are blocking\n-     * (example: related to transactions)\n-     * When not set it is set as core-size * 20.\n+     * Socket send buffer (SO_SNDBUF) size in KB.\n      */\n-    public static final HazelcastProperty CLIENT_ENGINE_BLOCKING_THREAD_COUNT\n-            = new HazelcastProperty(\"hazelcast.clientengine.blocking.thread.count\", -1);\n+    public static final HazelcastProperty SOCKET_SEND_BUFFER_SIZE\n+            = new HazelcastProperty(\"hazelcast.socket.send.buffer.size\", 128);\n \n     /**\n-     * Time period to check if a client is still part of the cluster.\n+     * If the bytebuffers used in the socket should be a direct bytebuffer (true)\n+     * or a regular bytebuffer (false).\n      */\n-    public static final HazelcastProperty CLIENT_CLEANUP_PERIOD\n-            = new HazelcastProperty(\"hazelcast.client.cleanup.period.millis\", 10000, MILLISECONDS);\n+    public static final HazelcastProperty SOCKET_BUFFER_DIRECT\n+            = new HazelcastProperty(\"hazelcast.socket.buffer.direct\", false);\n \n     /**\n-     * Timeout duration to decide if a client is still part of the cluster.\n-     * If a member can not find any connection to a client in the cluster, it will clean up local resources that is\n-     * owned by that client.\n+     * Overrides receive buffer size for connections opened by clients.\n+     * <p>\n+     * Hazelcast creates all connections with receive buffer size set according\n+     * to {@link #SOCKET_RECEIVE_BUFFER_SIZE}.\n+     * When it detects a connection was opened by a client then it adjusts receive\n+     * buffer size according to this property.\n+     * <p>\n+     * Size is in kilobytes.\n+     * <p>\n+     * The default is -1 (same as receive buffer size for connections opened by members).\n      */\n-    public static final HazelcastProperty CLIENT_CLEANUP_TIMEOUT\n-            = new HazelcastProperty(\"hazelcast.client.cleanup.timeout.millis\", 120000, MILLISECONDS);\n+    public static final HazelcastProperty SOCKET_CLIENT_RECEIVE_BUFFER_SIZE\n+            = new HazelcastProperty(\"hazelcast.socket.client.receive.buffer.size\", -1);\n \n     /**\n-     * Number of threads for the {@link com.hazelcast.spi.impl.eventservice.impl.EventServiceImpl} executor.\n-     * The executor is responsible for executing the events. If you process a lot of events and have many cores, setting\n-     * a higher value is a good practice. This way, more events can be processed in parallel.\n+     * Overrides send buffer size for connections opened by clients.\n+     * <p>\n+     * Hazelcast creates all connections with send buffer size set according to\n+     * {@link #SOCKET_SEND_BUFFER_SIZE}.\n+     * When it detects a connection was opened by a client then it adjusts send\n+     * buffer size according to this property.\n+     * <p>\n+     * Size is in kilobytes.\n+     * <p>\n+     * The default is -1 (same as receive buffer size for connections opened by members).\n      */\n-    public static final HazelcastProperty EVENT_THREAD_COUNT\n-            = new HazelcastProperty(\"hazelcast.event.thread.count\", 5);\n+    public static final HazelcastProperty SOCKET_CLIENT_SEND_BUFFER_SIZE\n+            = new HazelcastProperty(\"hazelcast.socket.client.send.buffer.size\", -1);\n+\n+    public static final HazelcastProperty SOCKET_CLIENT_BUFFER_DIRECT", "originalCommit": "6ed8be72debd304dbc6408d4c04f2aeb7509caff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk1MjM4OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17568#discussion_r490952389", "bodyText": "Added.", "author": "mmedenjak", "createdAt": "2020-09-18T13:33:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDkxNzY1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDkxODQ5MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17568#discussion_r490918491", "bodyText": "Could you also add the JavaDoc?", "author": "kwart", "createdAt": "2020-09-18T12:36:16Z", "path": "hazelcast/src/main/java/com/hazelcast/spi/properties/ClusterProperty.java", "diffHunk": "@@ -483,417 +493,444 @@ private int getWhenNoSSLDetected() {\n             = new HazelcastProperty(\"hazelcast.heartbeat.interval.seconds\", 5, SECONDS);\n \n     /**\n-     * The timeout which defines when master candidate gives up waiting for response to its mastership claim.\n-     * After timeout happens, non-responding member will be removed from member list.\n+     * The timeout which defines when master candidate gives up waiting for\n+     * response to its mastership claim.\n+     * After timeout happens, non-responding member will be removed from member\n+     * list.\n      */\n     public static final HazelcastProperty MASTERSHIP_CLAIM_TIMEOUT_SECONDS\n             = new HazelcastProperty(\"hazelcast.mastership.claim.timeout.seconds\", 120, SECONDS);\n+\n     /**\n-     * The timeout which defines when a cluster member is removed because it has not sent any heartbeats.\n+     * The timeout which defines when a cluster member is removed because it has\n+     * not sent any heartbeats.\n      */\n     public static final HazelcastProperty MAX_NO_HEARTBEAT_SECONDS\n             = new HazelcastProperty(\"hazelcast.max.no.heartbeat.seconds\", 60, SECONDS);\n \n     /**\n-     * The master member, i.e, the first member in the cluster member list administrates the cluster\n-     * and kicks unreachable members with the heartbeat mechanism. It means that a non-master member (i.e,\n-     * any member other than the master) does not send heartbeats to the master for the \"heartbeat timeout\"\n-     * duration, it is kicked from the cluster. However, there can be heartbeat problems between non-master\n-     * members as well. Since the master member is the single authority to update the cluster member list,\n-     * non-master members report their heartbeat problems to the master so that the master can update\n+     * The master member, i.e, the first member in the cluster member list\n+     * administrates the cluster and kicks unreachable members with the heartbeat\n+     * mechanism. It means that a non-master member (i.e, any member other than\n+     * the master) does not send heartbeats to the master for the \"heartbeat timeout\"\n+     * duration, it is kicked from the cluster. However, there can be heartbeat\n+     * problems between non-master members as well. Since the master member is\n+     * the single authority to update the cluster member list, non-master members\n+     * report their heartbeat problems to the master so that the master can update\n      * the cluster member list.\n      * <p>\n-     * When the master receives a heartbeat problem report from another member, it first waits for a number\n-     * of heartbeat rounds to allow other members to report their problems if there is any. After that,\n-     * it takes all reports received so far and checks if it can update the cluster member in a way that\n-     * the minimum number of members will be kicked from the cluster and there won't be any heartbeat problem\n-     * between the remaining members.\n+     * When the master receives a heartbeat problem report from another member,\n+     * it first waits for a number of heartbeat rounds to allow other members to\n+     * report their problems if there is any. After that, it takes all reports\n+     * received so far and checks if it can update the cluster member in a way\n+     * that the minimum number of members will be kicked from the cluster and\n+     * there won't be any heartbeat problem between the remaining members.\n      * <p>\n-     * If this configuration option is set to 0, this functionality is disabled. It is recommended to be\n-     * set to at least 3 or 5 so that the master will wait long enough to collect heartbeat problem reports.\n-     * Otherwise, the master member can make sub-optimal decisions.\n+     * If this configuration option is set to 0, this functionality is disabled.\n+     * It is recommended to be set to at least 3 or 5 so that the master will\n+     * wait long enough to collect heartbeat problem reports. Otherwise, the\n+     * master member can make sub-optimal decisions.\n      */\n     public static final HazelcastProperty PARTIAL_MEMBER_DISCONNECTION_RESOLUTION_HEARTBEAT_COUNT\n             = new HazelcastProperty(\"hazelcast.partial.member.disconnection.resolution.heartbeat.count\", 0);\n \n     /**\n-     * The partial member disconnection resolution mechanism uses a graph algorithm that finds a max-clique\n-     * in non-polynomial time. Since it could take a lot of time to find a max-clique in a large graph, i.e,\n-     * in a large cluster with lots of random network disconnections, we use a timeout mechanism to stop\n-     * execution of the algorithm.\n+     * The partial member disconnection resolution mechanism uses a graph algorithm\n+     * that finds a max-clique in non-polynomial time. Since it could take a lot\n+     * of time to find a max-clique in a large graph, i.e, in a large cluster\n+     * with lots of random network disconnections, we use a timeout mechanism\n+     * to stop execution of the algorithm.\n      */\n     public static final HazelcastProperty PARTIAL_MEMBER_DISCONNECTION_RESOLUTION_ALGORITHM_TIMEOUT_SECONDS\n             = new HazelcastProperty(\"hazelcast.partial.member.disconnection.resolution.algorithm.timeout.seconds\", 5);\n \n     /**\n      * Heartbeat failure detector type. Available options are:\n      * <ul>\n-     * <li><code>deadline</code>:  A deadline based failure detector uses an absolute timeout\n+     * <li>{@code deadline}:  A deadline based failure detector uses an absolute timeout\n      * for missing/lost heartbeats. After timeout member is considered as dead/unavailable.\n      * </li>\n-     * <li><code>phi-accrual</code>: Implementation of 'The Phi Accrual Failure Detector' by Hayashibara et al.\n-     * as defined in their paper. Phi Accrual Failure Detector is adaptive to network/environment conditions,\n-     * that's why a lower {@link #MAX_NO_HEARTBEAT_SECONDS} (for example 10 or 15 seconds) can be used to provide\n-     * faster detection of unavailable members.\n+     * <li>{@code phi-accrual}: Implementation of 'The Phi Accrual Failure Detector'\n+     * by Hayashibara et al. as defined in their paper. Phi Accrual Failure Detector\n+     * is adaptive to network/environment conditions, that's why a lower\n+     * {@link #MAX_NO_HEARTBEAT_SECONDS} (for example 10 or 15 seconds) can be\n+     * used to provide faster detection of unavailable members.\n      * </li>\n      * </ul>\n-     *\n+     * <p>\n      * Default failure detector is <code>deadline</code>.\n      */\n     public static final HazelcastProperty HEARTBEAT_FAILURE_DETECTOR_TYPE\n             = new HazelcastProperty(\"hazelcast.heartbeat.failuredetector.type\", ClusterFailureDetectorType.DEADLINE.toString());\n \n     /**\n-     * The interval at which the master sends the member lists are sent to other non-master members\n+     * The interval at which the master sends the member lists are sent to other\n+     * non-master members.\n      */\n     public static final HazelcastProperty MEMBER_LIST_PUBLISH_INTERVAL_SECONDS\n             = new HazelcastProperty(\"hazelcast.member.list.publish.interval.seconds\", 60, SECONDS);\n \n+    /**\n+     * Time after which the member assumes the client is dead and closes its\n+     * connections to the client.\n+     */\n     public static final HazelcastProperty CLIENT_HEARTBEAT_TIMEOUT_SECONDS\n             = new HazelcastProperty(\"hazelcast.client.max.no.heartbeat.seconds\", 300, SECONDS);\n \n     public static final HazelcastProperty CLUSTER_SHUTDOWN_TIMEOUT_SECONDS", "originalCommit": "6ed8be72debd304dbc6408d4c04f2aeb7509caff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk1MjMyOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17568#discussion_r490952329", "bodyText": "Added. I used my power of reasoning and tried to write a nice, fresh javadoc :) Maybe I can add the same now to the reference manual \ud83e\udd14", "author": "mmedenjak", "createdAt": "2020-09-18T13:33:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDkxODQ5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDkxOTA4Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17568#discussion_r490919086", "bodyText": "Could you also add the JavaDoc?", "author": "kwart", "createdAt": "2020-09-18T12:37:25Z", "path": "hazelcast/src/main/java/com/hazelcast/spi/properties/ClusterProperty.java", "diffHunk": "@@ -483,417 +493,444 @@ private int getWhenNoSSLDetected() {\n             = new HazelcastProperty(\"hazelcast.heartbeat.interval.seconds\", 5, SECONDS);\n \n     /**\n-     * The timeout which defines when master candidate gives up waiting for response to its mastership claim.\n-     * After timeout happens, non-responding member will be removed from member list.\n+     * The timeout which defines when master candidate gives up waiting for\n+     * response to its mastership claim.\n+     * After timeout happens, non-responding member will be removed from member\n+     * list.\n      */\n     public static final HazelcastProperty MASTERSHIP_CLAIM_TIMEOUT_SECONDS\n             = new HazelcastProperty(\"hazelcast.mastership.claim.timeout.seconds\", 120, SECONDS);\n+\n     /**\n-     * The timeout which defines when a cluster member is removed because it has not sent any heartbeats.\n+     * The timeout which defines when a cluster member is removed because it has\n+     * not sent any heartbeats.\n      */\n     public static final HazelcastProperty MAX_NO_HEARTBEAT_SECONDS\n             = new HazelcastProperty(\"hazelcast.max.no.heartbeat.seconds\", 60, SECONDS);\n \n     /**\n-     * The master member, i.e, the first member in the cluster member list administrates the cluster\n-     * and kicks unreachable members with the heartbeat mechanism. It means that a non-master member (i.e,\n-     * any member other than the master) does not send heartbeats to the master for the \"heartbeat timeout\"\n-     * duration, it is kicked from the cluster. However, there can be heartbeat problems between non-master\n-     * members as well. Since the master member is the single authority to update the cluster member list,\n-     * non-master members report their heartbeat problems to the master so that the master can update\n+     * The master member, i.e, the first member in the cluster member list\n+     * administrates the cluster and kicks unreachable members with the heartbeat\n+     * mechanism. It means that a non-master member (i.e, any member other than\n+     * the master) does not send heartbeats to the master for the \"heartbeat timeout\"\n+     * duration, it is kicked from the cluster. However, there can be heartbeat\n+     * problems between non-master members as well. Since the master member is\n+     * the single authority to update the cluster member list, non-master members\n+     * report their heartbeat problems to the master so that the master can update\n      * the cluster member list.\n      * <p>\n-     * When the master receives a heartbeat problem report from another member, it first waits for a number\n-     * of heartbeat rounds to allow other members to report their problems if there is any. After that,\n-     * it takes all reports received so far and checks if it can update the cluster member in a way that\n-     * the minimum number of members will be kicked from the cluster and there won't be any heartbeat problem\n-     * between the remaining members.\n+     * When the master receives a heartbeat problem report from another member,\n+     * it first waits for a number of heartbeat rounds to allow other members to\n+     * report their problems if there is any. After that, it takes all reports\n+     * received so far and checks if it can update the cluster member in a way\n+     * that the minimum number of members will be kicked from the cluster and\n+     * there won't be any heartbeat problem between the remaining members.\n      * <p>\n-     * If this configuration option is set to 0, this functionality is disabled. It is recommended to be\n-     * set to at least 3 or 5 so that the master will wait long enough to collect heartbeat problem reports.\n-     * Otherwise, the master member can make sub-optimal decisions.\n+     * If this configuration option is set to 0, this functionality is disabled.\n+     * It is recommended to be set to at least 3 or 5 so that the master will\n+     * wait long enough to collect heartbeat problem reports. Otherwise, the\n+     * master member can make sub-optimal decisions.\n      */\n     public static final HazelcastProperty PARTIAL_MEMBER_DISCONNECTION_RESOLUTION_HEARTBEAT_COUNT\n             = new HazelcastProperty(\"hazelcast.partial.member.disconnection.resolution.heartbeat.count\", 0);\n \n     /**\n-     * The partial member disconnection resolution mechanism uses a graph algorithm that finds a max-clique\n-     * in non-polynomial time. Since it could take a lot of time to find a max-clique in a large graph, i.e,\n-     * in a large cluster with lots of random network disconnections, we use a timeout mechanism to stop\n-     * execution of the algorithm.\n+     * The partial member disconnection resolution mechanism uses a graph algorithm\n+     * that finds a max-clique in non-polynomial time. Since it could take a lot\n+     * of time to find a max-clique in a large graph, i.e, in a large cluster\n+     * with lots of random network disconnections, we use a timeout mechanism\n+     * to stop execution of the algorithm.\n      */\n     public static final HazelcastProperty PARTIAL_MEMBER_DISCONNECTION_RESOLUTION_ALGORITHM_TIMEOUT_SECONDS\n             = new HazelcastProperty(\"hazelcast.partial.member.disconnection.resolution.algorithm.timeout.seconds\", 5);\n \n     /**\n      * Heartbeat failure detector type. Available options are:\n      * <ul>\n-     * <li><code>deadline</code>:  A deadline based failure detector uses an absolute timeout\n+     * <li>{@code deadline}:  A deadline based failure detector uses an absolute timeout\n      * for missing/lost heartbeats. After timeout member is considered as dead/unavailable.\n      * </li>\n-     * <li><code>phi-accrual</code>: Implementation of 'The Phi Accrual Failure Detector' by Hayashibara et al.\n-     * as defined in their paper. Phi Accrual Failure Detector is adaptive to network/environment conditions,\n-     * that's why a lower {@link #MAX_NO_HEARTBEAT_SECONDS} (for example 10 or 15 seconds) can be used to provide\n-     * faster detection of unavailable members.\n+     * <li>{@code phi-accrual}: Implementation of 'The Phi Accrual Failure Detector'\n+     * by Hayashibara et al. as defined in their paper. Phi Accrual Failure Detector\n+     * is adaptive to network/environment conditions, that's why a lower\n+     * {@link #MAX_NO_HEARTBEAT_SECONDS} (for example 10 or 15 seconds) can be\n+     * used to provide faster detection of unavailable members.\n      * </li>\n      * </ul>\n-     *\n+     * <p>\n      * Default failure detector is <code>deadline</code>.\n      */\n     public static final HazelcastProperty HEARTBEAT_FAILURE_DETECTOR_TYPE\n             = new HazelcastProperty(\"hazelcast.heartbeat.failuredetector.type\", ClusterFailureDetectorType.DEADLINE.toString());\n \n     /**\n-     * The interval at which the master sends the member lists are sent to other non-master members\n+     * The interval at which the master sends the member lists are sent to other\n+     * non-master members.\n      */\n     public static final HazelcastProperty MEMBER_LIST_PUBLISH_INTERVAL_SECONDS\n             = new HazelcastProperty(\"hazelcast.member.list.publish.interval.seconds\", 60, SECONDS);\n \n+    /**\n+     * Time after which the member assumes the client is dead and closes its\n+     * connections to the client.\n+     */\n     public static final HazelcastProperty CLIENT_HEARTBEAT_TIMEOUT_SECONDS\n             = new HazelcastProperty(\"hazelcast.client.max.no.heartbeat.seconds\", 300, SECONDS);\n \n     public static final HazelcastProperty CLUSTER_SHUTDOWN_TIMEOUT_SECONDS\n             = new HazelcastProperty(\"hazelcast.cluster.shutdown.timeout.seconds\", 900, SECONDS);\n \n-    public static final HazelcastProperty INITIAL_MIN_CLUSTER_SIZE\n-            = new HazelcastProperty(\"hazelcast.initial.min.cluster.size\", 0);\n-    public static final HazelcastProperty INITIAL_WAIT_SECONDS\n-            = new HazelcastProperty(\"hazelcast.initial.wait.seconds\", 0, SECONDS);\n-\n-    /**\n-     * The number of incremental ports, starting with port number defined in network configuration,\n-     * that will be used to connect to a host which is defined without a port in the TCP-IP member list\n-     * while a node is searching for a cluster.\n-     */\n-    public static final HazelcastProperty TCP_JOIN_PORT_TRY_COUNT\n-            = new HazelcastProperty(\"hazelcast.tcp.join.port.try.count\", 3);\n-\n-    public static final HazelcastProperty MAP_REPLICA_SCHEDULED_TASK_DELAY_SECONDS\n-            = new HazelcastProperty(\"hazelcast.map.replica.scheduled.task.delay.seconds\", 10, SECONDS);\n-\n-    /**\n-     * You can use MAP_EXPIRY_DELAY_SECONDS to deal with some possible\n-     * edge cases, such as using EntryProcessor. Without this delay, you\n-     * may see that an EntryProcessor running on the owner partition\n-     * found a key, but entry backup processor did not find it on backup,\n-     * and as a result when backup promotes to owner you will end up\n-     * with an unprocessed key.\n-     */\n-    public static final HazelcastProperty MAP_EXPIRY_DELAY_SECONDS\n-            = new HazelcastProperty(\"hazelcast.map.expiry.delay.seconds\", 10, SECONDS);\n-\n-    /**\n-     * Maximum number of IMap entries Hazelcast will evict during a\n-     * single eviction cycle. Eviction cycle is triggered by a map\n-     * mutation. Typically it's OK to evict at most a single entry.\n-     * However imagine the scenario where you are inserting values in a\n-     * loop and in each iteration you double entry size. In this\n-     * situation Hazelcast has to evict more than just a single entry -\n-     * as all existing entries are smaller than the entry which is about\n-     * to be added and removing any old entry cannot make sufficient\n-     * room for the new entry.\n-     *\n-     * Default: 1\n-     */\n-    public static final HazelcastProperty MAP_EVICTION_BATCH_SIZE\n-            = new HazelcastProperty(\"hazelcast.map.eviction.batch.size\", 1);\n-\n-    /**\n-     * XML and system property for setting the hot restart required free space.\n-     * By default, hot restart requires at least 15% free HD space.\n-     */\n-    public static final HazelcastProperty HOT_RESTART_FREE_NATIVE_MEMORY_PERCENTAGE\n-            = new HazelcastProperty(\"hazelcast.hotrestart.free.native.memory.percentage\", 15);\n-\n-    public static final HazelcastProperty LOGGING_TYPE\n-            = new HazelcastProperty(\"hazelcast.logging.type\", \"jdk\");\n-\n     /**\n-     * Controls whether cluster name, ip and version should be included in all log messages\n+     * Maximum wait in seconds during graceful shutdown.\n      */\n-    public static final HazelcastProperty LOGGING_ENABLE_DETAILS\n-            = new HazelcastProperty(\"hazelcast.logging.details.enabled\", true);\n-\n-    public static final HazelcastProperty ENABLE_JMX\n-            = new HazelcastProperty(\"hazelcast.jmx\", false);\n-    public static final HazelcastProperty JMX_UPDATE_INTERVAL_SECONDS\n-            = new HazelcastProperty(\"hazelcast.jmx.update.interval.seconds\", 5, SECONDS);\n-\n-    public static final HazelcastProperty MC_MAX_VISIBLE_SLOW_OPERATION_COUNT\n-            = new HazelcastProperty(\"hazelcast.mc.max.visible.slow.operations.count\", 10);\n+    public static final HazelcastProperty GRACEFUL_SHUTDOWN_MAX_WAIT\n+            = new HazelcastProperty(\"hazelcast.graceful.shutdown.max.wait\", 600, SECONDS);\n \n     /**\n-     * The number of threads that the Management Center service has available for processing operations\n-     * sent from connected Management Center instance.\n+     * Interval for publishing partition table periodically to all cluster members\n+     * in seconds.\n      */\n-    public static final HazelcastProperty MC_EXECUTOR_THREAD_COUNT\n-            = new HazelcastProperty(\"hazelcast.mc.executor.thread.count\", 2);\n+    public static final HazelcastProperty PARTITION_TABLE_SEND_INTERVAL\n+            = new HazelcastProperty(\"hazelcast.partition.table.send.interval\", 15, SECONDS);\n \n-    public static final HazelcastProperty CONNECTION_MONITOR_INTERVAL\n-            = new HazelcastProperty(\"hazelcast.connection.monitor.interval\", 100, MILLISECONDS);\n-    public static final HazelcastProperty CONNECTION_MONITOR_MAX_FAULTS\n-            = new HazelcastProperty(\"hazelcast.connection.monitor.max.faults\", 3);\n     /**\n-     * Time in seconds to sleep after a migration task.\n-     */\n-    public static final HazelcastProperty PARTITION_MIGRATION_INTERVAL\n-            = new HazelcastProperty(\"hazelcast.partition.migration.interval\", 0, SECONDS);\n-    /**\n-     * Timeout in seconds for all migration operations.\n+     * Interval for syncing backup replicas in seconds.\n      */\n-    public static final HazelcastProperty PARTITION_MIGRATION_TIMEOUT\n-            = new HazelcastProperty(\"hazelcast.partition.migration.timeout\", 300, SECONDS);\n-    public static final HazelcastProperty PARTITION_FRAGMENTED_MIGRATION_ENABLED\n-            = new HazelcastProperty(\"hazelcast.partition.migration.fragments.enabled\", true);\n-    public static final HazelcastProperty DISABLE_STALE_READ_ON_PARTITION_MIGRATION\n-            = new HazelcastProperty(\"hazelcast.partition.migration.stale.read.disabled\", false);\n-\n-    public static final HazelcastProperty PARTITION_TABLE_SEND_INTERVAL\n-            = new HazelcastProperty(\"hazelcast.partition.table.send.interval\", 15, SECONDS);\n     public static final HazelcastProperty PARTITION_BACKUP_SYNC_INTERVAL\n             = new HazelcastProperty(\"hazelcast.partition.backup.sync.interval\", 30, SECONDS);\n+\n     /**\n      * Maximum number of partition migrations to be executed concurrently on a member.\n      * Member can be either source or target of the migration.\n      * <ul>\n      * <li>\n-     *  Having too much parallelization can increase the heap memory usage and overload the network during partition rebalance.\n+     *  Having too much parallelization can increase the heap memory usage and\n+     *  overload the network during partition rebalance.\n+     * </li>\n+     * <li>\n+     *  Having less parallelization can increase the total migration completion time.\n      * </li>\n-     * <li>Having less parallelization can increase the total migration completion time.</li>\n      * </ul>\n      */\n     public static final HazelcastProperty PARTITION_MAX_PARALLEL_MIGRATIONS\n             = new HazelcastProperty(\"hazelcast.partition.max.parallel.migrations\", 10);\n+\n     /**\n      * Maximum number of anti-entropy partition replications to be executed on a member.\n      * By default equals to {@link #PARTITION_MAX_PARALLEL_MIGRATIONS}.\n      */\n     public static final HazelcastProperty PARTITION_MAX_PARALLEL_REPLICATIONS\n             = new HazelcastProperty(\"hazelcast.partition.max.parallel.replications\", PARTITION_MAX_PARALLEL_MIGRATIONS);\n+\n+    /**\n+     * Class name implementing {@link com.hazelcast.partition.PartitioningStrategy}, which\n+     * defines key to partition mapping.\n+     */\n     public static final HazelcastProperty PARTITIONING_STRATEGY_CLASS\n             = new HazelcastProperty(\"hazelcast.partitioning.strategy.class\", \"\");\n \n-    public static final HazelcastProperty GRACEFUL_SHUTDOWN_MAX_WAIT\n-            = new HazelcastProperty(\"hazelcast.graceful.shutdown.max.wait\", 600, SECONDS);\n+    /**\n+     * Time period to check if a client is still part of the cluster.\n+     */\n+    public static final HazelcastProperty CLIENT_CLEANUP_PERIOD\n+            = new HazelcastProperty(\"hazelcast.client.cleanup.period.millis\", 10000, MILLISECONDS);\n \n     /**\n-     * Enables or disables the {@link com.hazelcast.spi.impl.operationexecutor.slowoperationdetector.SlowOperationDetector}.\n+     * Timeout duration to decide if a client is still part of the cluster.\n+     * If a member can not find any connection to a client in the cluster, it\n+     * will clean up local resources that is owned by that client.\n      */\n-    public static final HazelcastProperty SLOW_OPERATION_DETECTOR_ENABLED\n-            = new HazelcastProperty(\"hazelcast.slow.operation.detector.enabled\", true);\n+    public static final HazelcastProperty CLIENT_CLEANUP_TIMEOUT\n+            = new HazelcastProperty(\"hazelcast.client.cleanup.timeout.millis\", 120000, MILLISECONDS);\n \n     /**\n-     * Defines a threshold above which a running operation in {@link OperationService} is considered to be slow.\n-     * These operations will log a warning and will be shown in the Management Center with detailed information, e.g. stacktrace.\n+     * Override cluster version to use while node is not yet member of a cluster.\n+     * The cluster version assumed before joining a cluster may affect the serialization\n+     * format of cluster discovery &amp; join operations and its compatibility\n+     * with members of a cluster running on different Hazelcast codebase versions.\n+     * The default is to use the node's codebase version. You may need to override\n+     * it for your node to join a cluster running on a previous cluster version.\n      */\n-    public static final HazelcastProperty SLOW_OPERATION_DETECTOR_THRESHOLD_MILLIS\n-            = new HazelcastProperty(\"hazelcast.slow.operation.detector.threshold.millis\", 10000, MILLISECONDS);\n+    public static final HazelcastProperty INIT_CLUSTER_VERSION\n+            = new HazelcastProperty(\"hazelcast.init.cluster.version\");\n \n+\n+    /*\n+     * METRICS / MONITORING PROPERTIES\n+     */\n     /**\n-     * This value defines the retention time of invocations in slow operation logs.\n+     * Enables/disables metrics collection altogether. This is a master\n+     * switch for all metrics related functionality.\n      * <p>\n-     * If an invocation is older than this value, it will be purged from the log to prevent unlimited memory usage.\n-     * When all invocations are purged from a log, the log itself will be deleted.\n-     *\n-     * @see #SLOW_OPERATION_DETECTOR_LOG_PURGE_INTERVAL_SECONDS\n+     * NOTE: This property overrides {@link MetricsConfig#isEnabled()}.\n+     * <p>\n+     * Using {@link MetricsConfig#setEnabled(boolean)} and the declarative\n+     * counterparts are preferred over using this property. The main purpose\n+     * of making metrics collection configurable from properties too is\n+     * allowing operators to configure the metrics subsystem from the outside\n+     * during investigation without touching or copying the configuration\n+     * potentially embedded into a signed artifact.\n      */\n-    public static final HazelcastProperty SLOW_OPERATION_DETECTOR_LOG_RETENTION_SECONDS\n-            = new HazelcastProperty(\"hazelcast.slow.operation.detector.log.retention.seconds\", 3600, SECONDS);\n+    public static final HazelcastProperty METRICS_ENABLED\n+            = new HazelcastProperty(\"hazelcast.metrics.enabled\");\n \n     /**\n-     * Purge interval for slow operation logs.\n-     *\n-     * @see #SLOW_OPERATION_DETECTOR_LOG_RETENTION_SECONDS\n+     * Enables/disables collecting metrics for Management Center. If disabled,\n+     * Management Center can't consume the metrics from this member.\n+     * <p>\n+     * NOTE: This property overrides {@link MetricsManagementCenterConfig#isEnabled()}.\n+     * <p>\n+     * Using {@link MetricsManagementCenterConfig#setEnabled(boolean)} and the declarative\n+     * counterparts are preferred over using this property. The main purpose\n+     * of making metrics collection configurable from properties too is\n+     * allowing operators to configure the metrics subsystem from the outside\n+     * during investigation without touching or copying the configuration\n+     * potentially embedded into a signed artifact.\n      */\n-    public static final HazelcastProperty SLOW_OPERATION_DETECTOR_LOG_PURGE_INTERVAL_SECONDS\n-            = new HazelcastProperty(\"hazelcast.slow.operation.detector.log.purge.interval.seconds\", 300, SECONDS);\n+    public static final HazelcastProperty METRICS_MC_ENABLED\n+            = new HazelcastProperty(\"hazelcast.metrics.mc.enabled\");\n \n     /**\n-     * Defines if the stacktraces of slow operations are logged in the log file. Stacktraces will always be reported to the\n-     * Management Center, but by default they are not printed to keep the log size small.\n+     * Sets the duration in seconds for which the collected metrics are retained\n+     * and Management Center can consume them.\n+     * <p>\n+     * NOTE: This property overrides {@link MetricsManagementCenterConfig#getRetentionSeconds()}.\n+     * <p>\n+     * Using {@link MetricsManagementCenterConfig#setRetentionSeconds(int)} and the declarative\n+     * counterparts are preferred over using this property. The main purpose\n+     * of making metrics collection configurable from properties too is\n+     * allowing operators to configure the metrics subsystem from the outside\n+     * during investigation without touching or copying the configuration\n+     * potentially embedded into a signed artifact.\n      */\n-    public static final HazelcastProperty SLOW_OPERATION_DETECTOR_STACK_TRACE_LOGGING_ENABLED\n-            = new HazelcastProperty(\"hazelcast.slow.operation.detector.stacktrace.logging.enabled\", false);\n-\n-    public static final HazelcastProperty LOCK_MAX_LEASE_TIME_SECONDS\n-            = new HazelcastProperty(\"hazelcast.lock.max.lease.time.seconds\", Long.MAX_VALUE, SECONDS);\n-\n-    public static final HazelcastProperty ENTERPRISE_LICENSE_KEY\n-            = new HazelcastProperty(\"hazelcast.enterprise.license.key\");\n+    public static final HazelcastProperty METRICS_MC_RETENTION\n+            = new HazelcastProperty(\"hazelcast.metrics.mc.retention\");\n \n     /**\n-     * Setting this capacity is valid if you set {@code writeCoalescing} to {@code false}\n-     * (see {@link com.hazelcast.config.MapStoreConfig#setWriteCoalescing(boolean)}).\n-     * Otherwise its value will not be taken into account.\n+     * Enables/disables exposing metrics on JMX.\n      * <p>\n-     * The per node maximum write-behind queue capacity is the total of all write-behind queue sizes in a node, including backups.\n+     * NOTE: This property overrides {@link MetricsJmxConfig#isEnabled()}.\n      * <p>\n-     * The maximum value which can be set is {@link Integer#MAX_VALUE}\n+     * Using {@link MetricsJmxConfig#setEnabled(boolean)} and the declarative\n+     * counterparts are preferred over using this property. The main purpose\n+     * of making metrics collection configurable from properties too is\n+     * allowing operators to configure the metrics subsystem from the outside\n+     * during investigation without touching or copying the configuration\n+     * potentially embedded into a signed artifact.\n      */\n-    public static final HazelcastProperty MAP_WRITE_BEHIND_QUEUE_CAPACITY\n-            = new HazelcastProperty(\"hazelcast.map.write.behind.queue.capacity\", 50000);\n+    public static final HazelcastProperty METRICS_JMX_ENABLED\n+            = new HazelcastProperty(\"hazelcast.metrics.jmx.enabled\");\n \n     /**\n-     * Defines cache invalidation event batch sending is enabled or not.\n+     * Health monitoring log level. When SILENT, logs are printed only when values\n+     * exceed some predefined threshold. When NOISY, logs are always printed\n+     * periodically. Set OFF to turn off completely.\n      */\n-    public static final HazelcastProperty CACHE_INVALIDATION_MESSAGE_BATCH_ENABLED\n-            = new HazelcastProperty(\"hazelcast.cache.invalidation.batch.enabled\", true);\n+    public static final HazelcastProperty HEALTH_MONITORING_LEVEL\n+            = new HazelcastProperty(\"hazelcast.health.monitoring.level\", HealthMonitorLevel.SILENT.toString());\n \n     /**\n-     * Defines the maximum number of cache invalidation events to be drained and sent to the event listeners in a batch.\n+     * Health monitoring logging interval in seconds.\n      */\n-    public static final HazelcastProperty CACHE_INVALIDATION_MESSAGE_BATCH_SIZE\n-            = new HazelcastProperty(\"hazelcast.cache.invalidation.batch.size\", 100);\n+    public static final HazelcastProperty HEALTH_MONITORING_DELAY_SECONDS\n+            = new HazelcastProperty(\"hazelcast.health.monitoring.delay.seconds\", 20, SECONDS);\n \n     /**\n-     * Defines the cache invalidation event batch sending frequency in seconds.\n-     * <p>\n-     * When the number of events do not come up to {@link #CACHE_INVALIDATION_MESSAGE_BATCH_SIZE} in the given time period (which\n-     * is defined by this property); those events are gathered into a batch and sent to target.\n+     * When the health monitoring level is SILENT, logs are printed only when the\n+     * memory usage exceeds this threshold.\n      */\n-    public static final HazelcastProperty CACHE_INVALIDATION_MESSAGE_BATCH_FREQUENCY_SECONDS\n-            = new HazelcastProperty(\"hazelcast.cache.invalidation.batchfrequency.seconds\", 10, SECONDS);\n+    public static final HazelcastProperty HEALTH_MONITORING_THRESHOLD_MEMORY_PERCENTAGE\n+            = new HazelcastProperty(\"hazelcast.health.monitoring.threshold.memory.percentage\", 70);\n \n     /**\n-     * Defines Near Cache invalidation event batch sending is enabled or not.\n+     * When the health monitoring level is SILENT, logs are printed only when\n+     * the CPU usage exceeds this threshold.\n      */\n-    public static final HazelcastProperty MAP_INVALIDATION_MESSAGE_BATCH_ENABLED\n-            = new HazelcastProperty(\"hazelcast.map.invalidation.batch.enabled\", true);\n+    public static final HazelcastProperty HEALTH_MONITORING_THRESHOLD_CPU_PERCENTAGE\n+            = new HazelcastProperty(\"hazelcast.health.monitoring.threshold.cpu.percentage\", 70);\n \n     /**\n-     * Defines the maximum number of Near Cache invalidation events to be drained and sent to the event Near Cache in a batch.\n+     * Enable JMX agent.\n      */\n-    public static final HazelcastProperty MAP_INVALIDATION_MESSAGE_BATCH_SIZE\n-            = new HazelcastProperty(\"hazelcast.map.invalidation.batch.size\", 100);\n+    public static final HazelcastProperty ENABLE_JMX\n+            = new HazelcastProperty(\"hazelcast.jmx\", false);\n+\n+    public static final HazelcastProperty JMX_UPDATE_INTERVAL_SECONDS", "originalCommit": "6ed8be72debd304dbc6408d4c04f2aeb7509caff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk1MjQyMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17568#discussion_r490952421", "bodyText": "Added.", "author": "mmedenjak", "createdAt": "2020-09-18T13:33:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDkxOTA4Ng=="}], "type": "inlineReview"}, {"oid": "7641d12d49e9b85d17166154ab12967627cc1785", "url": "https://github.com/hazelcast/hazelcast/commit/7641d12d49e9b85d17166154ab12967627cc1785", "message": "Clean up ClusterProperty\n\n- arrange properties in groups\n- add javadoc from reference manual", "committedDate": "2020-09-18T13:15:17Z", "type": "commit"}, {"oid": "072a444e1a3a92777e33952d90d00e002533d638", "url": "https://github.com/hazelcast/hazelcast/commit/072a444e1a3a92777e33952d90d00e002533d638", "message": "Checkstyle", "committedDate": "2020-09-18T13:15:17Z", "type": "commit"}, {"oid": "ecbcdcdc8c1ea05a6ef531ef7a56ac55bdcbd452", "url": "https://github.com/hazelcast/hazelcast/commit/ecbcdcdc8c1ea05a6ef531ef7a56ac55bdcbd452", "message": "Checkstyle", "committedDate": "2020-09-18T13:15:17Z", "type": "commit"}, {"oid": "3f996a3a1daea14593d04e969367b6b9f490e891", "url": "https://github.com/hazelcast/hazelcast/commit/3f996a3a1daea14593d04e969367b6b9f490e891", "message": "Added javadoc for leftovers", "committedDate": "2020-09-18T13:32:44Z", "type": "commit"}, {"oid": "3f996a3a1daea14593d04e969367b6b9f490e891", "url": "https://github.com/hazelcast/hazelcast/commit/3f996a3a1daea14593d04e969367b6b9f490e891", "message": "Added javadoc for leftovers", "committedDate": "2020-09-18T13:32:44Z", "type": "forcePushed"}]}