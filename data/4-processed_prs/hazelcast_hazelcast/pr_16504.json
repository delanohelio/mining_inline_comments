{"pr_number": 16504, "pr_title": "Fix HD ICache iterator consistency issue", "pr_createdAt": "2020-01-20T14:50:07Z", "pr_url": "https://github.com/hazelcast/hazelcast/pull/16504", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODYxNDQ1Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/16504#discussion_r368614456", "bodyText": "previously we checked for iteratorResult == null but the check seems redundant?", "author": "vbekiaris", "createdAt": "2020-01-20T15:46:27Z", "path": "hazelcast/src/main/java/com/hazelcast/cache/impl/CachePartitionsIterator.java", "diffHunk": "@@ -70,27 +70,24 @@ protected List fetch() {\n         final OperationService operationService = cacheProxy.getNodeEngine().getOperationService();\n         if (prefetchValues) {\n             Operation operation = cacheProxy.operationProvider.createFetchEntriesOperation(pointers, fetchSize);\n-            InternalCompletableFuture<CacheEntriesWithCursor> f = operationService\n-                    .invokeOnPartition(CacheService.SERVICE_NAME, operation, partitionIndex);\n-            CacheEntriesWithCursor iteratorResult = f.joinInternal();\n-            if (iteratorResult != null) {\n-                setLastTableIndex(iteratorResult.getEntries(), iteratorResult.getPointers());\n-                return iteratorResult.getEntries();\n-            }\n+            CacheEntriesWithCursor iteratorResult = invoke(operationService, operation);\n+            setIterationPointers(iteratorResult.getEntries(), iteratorResult.getPointers());", "originalCommit": "a3bd6cbb36ee33fc3a63087c27f267f11a53cbcd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ2MTUwNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16504#discussion_r369461505", "bodyText": "@mmedenjak, it seems null is still possible?", "author": "petrpleshachkov", "createdAt": "2020-01-22T09:53:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODYxNDQ1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ3NDA3NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16504#discussion_r369474075", "bodyText": "Yes, seems so. We never return null from any operation.", "author": "mmedenjak", "createdAt": "2020-01-22T10:17:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODYxNDQ1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ3NTI0Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/16504#discussion_r369475246", "bodyText": "@petrpleshachkov checked both operations, I don't see it. Where specifically did you see null being returned?", "author": "mmedenjak", "createdAt": "2020-01-22T10:19:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODYxNDQ1Ng=="}], "type": "inlineReview"}, {"oid": "a6df55025d0d5023cfcfeea93181abc36300b102", "url": "https://github.com/hazelcast/hazelcast/commit/a6df55025d0d5023cfcfeea93181abc36300b102", "message": "Fix HD ICache iterator consistency issue\n\nThe hasNotBeenObserved method had an issue which might cause stable\nentries to be skipped.\n\nAlso:\n- added bouncing tests for on-heap and off-heap ICache\n- moved the hasNotBeenObserved method for a common parent class for both\noff-heap ICache and IMap\n- made it possible for ICache iterator to return an entry with a null\nvalue in case prefetchValues is false. This is the same way it is in the\n IMap iterator.\n- further aligned the ICache and IMap code", "committedDate": "2020-01-22T09:37:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ2MTg3Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/16504#discussion_r369461873", "bodyText": "The same here regarding null iteratorResult?", "author": "petrpleshachkov", "createdAt": "2020-01-22T09:54:22Z", "path": "hazelcast/src/main/java/com/hazelcast/cache/impl/CachePartitionsIterator.java", "diffHunk": "@@ -70,27 +70,24 @@ protected List fetch() {\n         final OperationService operationService = cacheProxy.getNodeEngine().getOperationService();\n         if (prefetchValues) {\n             Operation operation = cacheProxy.operationProvider.createFetchEntriesOperation(pointers, fetchSize);\n-            InternalCompletableFuture<CacheEntriesWithCursor> f = operationService\n-                    .invokeOnPartition(CacheService.SERVICE_NAME, operation, partitionIndex);\n-            CacheEntriesWithCursor iteratorResult = f.joinInternal();\n-            if (iteratorResult != null) {\n-                setLastTableIndex(iteratorResult.getEntries(), iteratorResult.getPointers());\n-                return iteratorResult.getEntries();\n-            }\n+            CacheEntriesWithCursor iteratorResult = invoke(operationService, operation);\n+            setIterationPointers(iteratorResult.getEntries(), iteratorResult.getPointers());\n+            return iteratorResult.getEntries();\n         } else {\n             Operation operation = cacheProxy.operationProvider.createFetchKeysOperation(pointers, fetchSize);\n-            InternalCompletableFuture<CacheKeysWithCursor> f = operationService\n-                    .invokeOnPartition(CacheService.SERVICE_NAME, operation, partitionIndex);\n-            CacheKeysWithCursor iteratorResult = f.joinInternal();\n-            if (iteratorResult != null) {\n-                setLastTableIndex(iteratorResult.getKeys(), iteratorResult.getPointers());\n-                return iteratorResult.getKeys();\n-            }\n+            CacheKeysWithCursor iteratorResult = invoke(operationService, operation);\n+            setIterationPointers(iteratorResult.getKeys(), iteratorResult.getPointers());", "originalCommit": "a3bd6cbb36ee33fc3a63087c27f267f11a53cbcd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ3NjY4NA==", "url": "https://github.com/hazelcast/hazelcast/pull/16504#discussion_r369476684", "bodyText": "The way I see it, it boils down to the return values from ICacheRecordStore#fetchKeys and ICacheRecordStore#fetchEntries and I don't see null being returned from either. Where did you see the null value?", "author": "mmedenjak", "createdAt": "2020-01-22T10:22:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ2MTg3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ4ODI3Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/16504#discussion_r369488277", "bodyText": "f.joinInternal() -> join() -> reportJoin(). The reportJoin() returns null in some cases\n    private static <T> T reportJoin(Object r) {\n        if (r instanceof AltResult) {\n            Throwable x;\n            if ((x = ((AltResult)r).ex) == null)\n                return null;\n            if (x instanceof CancellationException)\n                throw (CancellationException)x;\n            if (x instanceof CompletionException)\n                throw (CompletionException)x;\n            throw new CompletionException(x);\n        }\n        @SuppressWarnings(\"unchecked\") T t = (T) r;\n        return t;\n    }", "author": "petrpleshachkov", "createdAt": "2020-01-22T10:46:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ2MTg3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ5MzA2OA==", "url": "https://github.com/hazelcast/hazelcast/pull/16504#discussion_r369493068", "bodyText": "Hm, not sure in which case this might happens but we'll have to inspect all of the codebase then as I see we have 290 usages of InternalCompletableFuture#joinInternal and I haven't seen null checks anywhere.", "author": "mmedenjak", "createdAt": "2020-01-22T10:56:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ2MTg3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ5NDg4Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/16504#discussion_r369494887", "bodyText": "Apparently this is a very rare case. @vbekiaris, WDYT?", "author": "petrpleshachkov", "createdAt": "2020-01-22T11:00:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ2MTg3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ5NTg5MA==", "url": "https://github.com/hazelcast/hazelcast/pull/16504#discussion_r369495890", "bodyText": "I see one reason why AltResult.ex might be null is if the future is completed with null:\n    /** The encoding of the null value. */\n    static final AltResult NIL = new AltResult(null);", "author": "mmedenjak", "createdAt": "2020-01-22T11:02:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ2MTg3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ5NjI3Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/16504#discussion_r369496276", "bodyText": "AltResult(ex = null) is the JDK 's null outcome encoding:\nCompletableFuture cf = new CompletableFuture();\ncf.complete(null); // --> this is encoded internally as an AltResult with field ex == null\n\nThe CompletableFutures obtained from invoking fetchKeys/Entries will either complete normally (with the non-null value returned from the respective operation) or exceptionally (when there is an invocation issue) but null is not a possible outcome.", "author": "vbekiaris", "createdAt": "2020-01-22T11:03:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ2MTg3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ2NDM0NA==", "url": "https://github.com/hazelcast/hazelcast/pull/16504#discussion_r369464344", "bodyText": "Typo?  successfulterations -> successfullterations?", "author": "petrpleshachkov", "createdAt": "2020-01-22T09:58:54Z", "path": "hazelcast/src/test/java/com/hazelcast/cache/CachePartitionIteratorBouncingTest.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.cache;\n+\n+import com.hazelcast.cache.impl.CacheProxy;\n+import com.hazelcast.client.cache.impl.ClientCacheProxy;\n+import com.hazelcast.config.CacheSimpleConfig;\n+import com.hazelcast.config.Config;\n+import com.hazelcast.config.InMemoryFormat;\n+import com.hazelcast.config.MaxSizePolicy;\n+import com.hazelcast.core.HazelcastInstance;\n+import com.hazelcast.test.HazelcastSerialClassRunner;\n+import com.hazelcast.test.HazelcastTestSupport;\n+import com.hazelcast.test.annotation.SlowTest;\n+import com.hazelcast.test.bounce.BounceMemberRule;\n+import com.hazelcast.test.bounce.BounceTestConfiguration.DriverType;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import javax.cache.Cache;\n+import javax.cache.Cache.Entry;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.logging.Logger;\n+\n+import static com.hazelcast.config.EvictionConfig.DEFAULT_MAX_SIZE_POLICY;\n+import static com.hazelcast.config.MaxSizePolicy.USED_NATIVE_MEMORY_SIZE;\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(HazelcastSerialClassRunner.class)\n+@Category(SlowTest.class)\n+public class CachePartitionIteratorBouncingTest extends HazelcastTestSupport {\n+\n+    private final Logger logger = Logger.getLogger(getClass().getName());\n+    private static final String TEST_CACHE_NAME = \"testCache\";\n+    private static final int STABLE_ENTRY_COUNT = 10000;\n+    private static final int CONCURRENCY = 2;\n+    public static final int FETCH_SIZE = 100;\n+    public static final int MUTATION_ENTRY_FACTOR = 10;\n+    public AtomicInteger successfulIterations = new AtomicInteger();", "originalCommit": "a3bd6cbb36ee33fc3a63087c27f267f11a53cbcd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ3MDQzMg==", "url": "https://github.com/hazelcast/hazelcast/pull/16504#discussion_r369470432", "bodyText": "We call the method twice with runnableIndex = 0 in both cases? Is this an idea of the test?", "author": "petrpleshachkov", "createdAt": "2020-01-22T10:10:04Z", "path": "hazelcast/src/test/java/com/hazelcast/cache/CachePartitionIteratorBouncingTest.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.cache;\n+\n+import com.hazelcast.cache.impl.CacheProxy;\n+import com.hazelcast.client.cache.impl.ClientCacheProxy;\n+import com.hazelcast.config.CacheSimpleConfig;\n+import com.hazelcast.config.Config;\n+import com.hazelcast.config.InMemoryFormat;\n+import com.hazelcast.config.MaxSizePolicy;\n+import com.hazelcast.core.HazelcastInstance;\n+import com.hazelcast.test.HazelcastSerialClassRunner;\n+import com.hazelcast.test.HazelcastTestSupport;\n+import com.hazelcast.test.annotation.SlowTest;\n+import com.hazelcast.test.bounce.BounceMemberRule;\n+import com.hazelcast.test.bounce.BounceTestConfiguration.DriverType;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import javax.cache.Cache;\n+import javax.cache.Cache.Entry;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.logging.Logger;\n+\n+import static com.hazelcast.config.EvictionConfig.DEFAULT_MAX_SIZE_POLICY;\n+import static com.hazelcast.config.MaxSizePolicy.USED_NATIVE_MEMORY_SIZE;\n+import static java.util.concurrent.TimeUnit.MINUTES;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(HazelcastSerialClassRunner.class)\n+@Category(SlowTest.class)\n+public class CachePartitionIteratorBouncingTest extends HazelcastTestSupport {\n+\n+    private final Logger logger = Logger.getLogger(getClass().getName());\n+    private static final String TEST_CACHE_NAME = \"testCache\";\n+    private static final int STABLE_ENTRY_COUNT = 10000;\n+    private static final int CONCURRENCY = 2;\n+    public static final int FETCH_SIZE = 100;\n+    public static final int MUTATION_ENTRY_FACTOR = 10;\n+    public AtomicInteger successfulIterations = new AtomicInteger();\n+\n+    @Rule\n+    public BounceMemberRule bounceMemberRule =\n+            BounceMemberRule.with(getConfig())\n+                            .clusterSize(4)\n+                            .driverCount(4)\n+                            .driverType(isClientDriver() ? DriverType.CLIENT : DriverType.MEMBER)\n+                            .build();\n+\n+    @Override\n+    protected Config getConfig() {\n+        Config config = smallInstanceConfig();\n+        MaxSizePolicy maxSizePolicy = getInMemoryFormat() == InMemoryFormat.NATIVE\n+                ? USED_NATIVE_MEMORY_SIZE\n+                : DEFAULT_MAX_SIZE_POLICY;\n+        config.getCacheConfig(TEST_CACHE_NAME)\n+              .setInMemoryFormat(getInMemoryFormat())\n+              .getEvictionConfig()\n+              .setMaxSizePolicy(maxSizePolicy)\n+              .setSize(Integer.MAX_VALUE);\n+\n+        return config;\n+    }\n+\n+    @Test\n+    public void test() {\n+        ICache<Integer, Integer> cache = bounceMemberRule.getSteadyMember()\n+                                                         .getCacheManager()\n+                                                         .getCache(TEST_CACHE_NAME);\n+        populateCache(cache);\n+\n+        Runnable[] testTasks = new Runnable[CONCURRENCY];\n+        for (int i = 0; i < CONCURRENCY; ) {\n+            HazelcastInstance driver = bounceMemberRule.getNextTestDriver();\n+            testTasks[i++] = new IterationRunnable(driver);\n+            testTasks[i++] = new MutationRunnable(driver, i / 2);\n+        }\n+        bounceMemberRule.testRepeatedly(testTasks, MINUTES.toSeconds(3));\n+    }\n+\n+    private void populateCache(ICache<Integer, Integer> cache) {\n+        for (int i = 0; i < STABLE_ENTRY_COUNT; i++) {\n+            cache.put(i, i);\n+        }\n+    }\n+\n+    public class IterationRunnable implements Runnable {\n+\n+        private final HazelcastInstance hazelcastInstance;\n+        private ICache<Integer, Integer> cache;\n+\n+        public IterationRunnable(HazelcastInstance hazelcastInstance) {\n+            this.hazelcastInstance = hazelcastInstance;\n+        }\n+\n+        @Override\n+        public void run() {\n+            if (cache == null) {\n+                cache = hazelcastInstance.getCacheManager().getCache(TEST_CACHE_NAME);\n+            }\n+            HashSet<Integer> all = getAll();\n+            for (int i = 0; i < STABLE_ENTRY_COUNT; i++) {\n+                assertTrue(\"Missing stable entry \" + i + \" - \" + cache.get(i), all.contains(i));\n+            }\n+\n+            logger.info(\"Successfully finished iteration \" + successfulIterations.incrementAndGet());\n+        }\n+\n+        private HashSet<Integer> getAll() {\n+            HashSet<Integer> keys = new HashSet<>();\n+            int partitionCount = hazelcastInstance.getPartitionService().getPartitions().size();\n+            for (int partitionId = 0; partitionId < partitionCount; partitionId++) {\n+                Iterator<Cache.Entry<Integer, Integer>> iterator = createIterator(cache, FETCH_SIZE, partitionId, false);\n+                while (iterator.hasNext()) {\n+                    Entry<Integer, Integer> e = iterator.next();\n+                    assertTrue(\"Got the same key twice\", keys.add(e.getKey()));\n+                }\n+            }\n+            return keys;\n+        }\n+\n+    }\n+\n+    private Iterator<Cache.Entry<Integer, Integer>> createIterator(\n+            ICache<Integer, Integer> cache, int fetchSize, int partitionId, boolean prefetchValues) {\n+        return isClientDriver()\n+                ? ((ClientCacheProxy<Integer, Integer>) cache).iterator(fetchSize, partitionId, prefetchValues)\n+                : ((CacheProxy<Integer, Integer>) cache).iterator(fetchSize, partitionId, prefetchValues);\n+    }\n+\n+    protected boolean isClientDriver() {\n+        return false;\n+    }\n+\n+    protected InMemoryFormat getInMemoryFormat() {\n+        return CacheSimpleConfig.DEFAULT_IN_MEMORY_FORMAT;\n+    }\n+\n+    public static class MutationRunnable implements Runnable {\n+        private final HazelcastInstance hazelcastInstance;\n+        private final int startIndex;\n+        private final int endIndex;\n+        private ICache<Integer, Integer> cache;\n+\n+        public MutationRunnable(HazelcastInstance hazelcastInstance, int runnableIndex) {\n+            this.hazelcastInstance = hazelcastInstance;", "originalCommit": "a3bd6cbb36ee33fc3a63087c27f267f11a53cbcd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ3OTMwNw==", "url": "https://github.com/hazelcast/hazelcast/pull/16504#discussion_r369479307", "bodyText": "Which method and which cases? As the for-loop increases by two in each loop, the iteration index should be increasing by one.", "author": "mmedenjak", "createdAt": "2020-01-22T10:27:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ3MDQzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ4NDY5Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/16504#discussion_r369484693", "bodyText": "Didn't notice that it increases by 2.", "author": "petrpleshachkov", "createdAt": "2020-01-22T10:38:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ3MDQzMg=="}], "type": "inlineReview"}, {"oid": "5ab677bc77c66eb02f9e026b9faceb920fd93c9f", "url": "https://github.com/hazelcast/hazelcast/commit/5ab677bc77c66eb02f9e026b9faceb920fd93c9f", "message": "Fix tests", "committedDate": "2020-01-22T10:17:33Z", "type": "commit"}, {"oid": "1d2a1a27ae79b3f959b18250c1d5176bc62d0f58", "url": "https://github.com/hazelcast/hazelcast/commit/1d2a1a27ae79b3f959b18250c1d5176bc62d0f58", "message": "Address review comments", "committedDate": "2020-01-22T10:28:34Z", "type": "commit"}, {"oid": "1d2a1a27ae79b3f959b18250c1d5176bc62d0f58", "url": "https://github.com/hazelcast/hazelcast/commit/1d2a1a27ae79b3f959b18250c1d5176bc62d0f58", "message": "Address review comments", "committedDate": "2020-01-22T10:28:34Z", "type": "forcePushed"}]}