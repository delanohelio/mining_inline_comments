{"pr_number": 1495, "pr_title": "Improved ItemModule::take() behavior", "pr_createdAt": "2020-02-03T10:14:58Z", "pr_url": "https://github.com/Anuken/Mindustry/pull/1495", "timeline": [{"oid": "4d4a6d3d0c9a887dd1b3c6b1f4c3f20c31c962e7", "url": "https://github.com/Anuken/Mindustry/commit/4d4a6d3d0c9a887dd1b3c6b1f4c3f20c31c962e7", "message": "Improved ItemModule::take() behavior\n\nThe original take() behavior spams items in whatever order they appear in the items list until each index is depleted, which is problematic when non-specific unloaders are competing against dedicated unloaders for a low-index resources.\r\n\r\nMy modification makes the take() loop persistent so take() will do complete laps around the item list starting from wherever the previous call returned from, never repeating the same item twice in a row unless there is nothing else to return. A significant improvement IMO.\r\n\r\nHow is this an improvement? With the original behavior, if you converge a bunch of belts on a storage block or launcher, want to unload a few belts of specific resources (ex.: copper, lead, silicon and titanium for surge alloy) and pass everything else including overflows along using non-specific unloaders, you are out of luck when the resources you want are at the top of the list since most of those will get swept away by non-specific unloaders. With the rotating take(), non-specific unloaders are equal-opportunity across all available resources, which gives single-resource unloaders that many more chances to unload more of their resources before non-specific unloaders get to them. It also reduces the rate at which items further down the list that may hardly ever get touched by the existing implementation will race toward the storage block's cap. The even drain across all items will help prevent things like mass driver stalls due to receivers filling up with an excess resource that isn't getting cleared.\r\n\r\nIt would be even nicer if dedicated unloaders had priority over non-specific ones (non-specific unloaders don't touch resources with dedicated unloaders unless the dedicated unloaders are overflowing), though that would require a rework beyond my current \"getting the stupid IDE and tool chains to work\" level of familiarity with Java development.\r\n\r\nTo sum it up: trivial change, big impact for people who like mixing belts and sorting them out with unloaders.", "committedDate": "2020-02-03T10:10:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA0NTUyMw==", "url": "https://github.com/Anuken/Mindustry/pull/1495#discussion_r374045523", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                \t\t\t// save the next position so the next call to take() can resume from there.\n          \n          \n            \n                \t\t// save the next position so the next call to take() can resume from there.", "author": "Quezler", "createdAt": "2020-02-03T11:13:04Z", "path": "core/src/mindustry/world/modules/ItemModule.java", "diffHunk": "@@ -66,11 +66,28 @@ public int total(){\n         return total;\n     }\n \n+    // Making the take() loop persistent so it does not return the same item twice in a row unless there is nothing else to return.\n+    protected int takeRotation;\n+\n     public Item take(){\n-        for(int i = 0; i < items.length; i++){\n+    \t// 0-to-length loop broken in two parts. First resume the loop where it previously left off.\n+        for(int i = takeRotation; i < items.length; i++){\n+            if(items[i] > 0){\n+                items[i]--;\n+                total--;\n+    \t\t\t// save the next position so the next call to take() can resume from there.", "originalCommit": "4d4a6d3d0c9a887dd1b3c6b1f4c3f20c31c962e7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA0NTYyNQ==", "url": "https://github.com/Anuken/Mindustry/pull/1495#discussion_r374045625", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                \t\t\t// save the next position so the next call to take() can resume from there.\n          \n          \n            \n                \t\t// save the next position so the next call to take() can resume from there.", "author": "Quezler", "createdAt": "2020-02-03T11:13:18Z", "path": "core/src/mindustry/world/modules/ItemModule.java", "diffHunk": "@@ -66,11 +66,28 @@ public int total(){\n         return total;\n     }\n \n+    // Making the take() loop persistent so it does not return the same item twice in a row unless there is nothing else to return.\n+    protected int takeRotation;\n+\n     public Item take(){\n-        for(int i = 0; i < items.length; i++){\n+    \t// 0-to-length loop broken in two parts. First resume the loop where it previously left off.\n+        for(int i = takeRotation; i < items.length; i++){\n+            if(items[i] > 0){\n+                items[i]--;\n+                total--;\n+    \t\t\t// save the next position so the next call to take() can resume from there.\n+                takeRotation = (i + 1) % items.length;\n+                return content.item(i);\n+            }\n+        }\n+\n+        // Then start a new lap which ends where the call started from if empty.\n+        for(int i = 0; i < takeRotation; i++){\n             if(items[i] > 0){\n                 items[i]--;\n                 total--;\n+    \t\t\t// save the next position so the next call to take() can resume from there.", "originalCommit": "4d4a6d3d0c9a887dd1b3c6b1f4c3f20c31c962e7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "489bf304e44290fded1f81810846cabd5bb2ffb4", "url": "https://github.com/Anuken/Mindustry/commit/489bf304e44290fded1f81810846cabd5bb2ffb4", "message": "Update core/src/mindustry/world/modules/ItemModule.java\n\nCo-Authored-By: Patrick 'Quezler' Mounier <Quezler@me.com>", "committedDate": "2020-02-03T11:18:30Z", "type": "commit"}, {"oid": "5da52696d7e734ebb05fdc5d10470277d5d5e820", "url": "https://github.com/Anuken/Mindustry/commit/5da52696d7e734ebb05fdc5d10470277d5d5e820", "message": "Update core/src/mindustry/world/modules/ItemModule.java\n\nCo-Authored-By: Patrick 'Quezler' Mounier <Quezler@me.com>", "committedDate": "2020-02-03T11:18:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDE3MTE5Mw==", "url": "https://github.com/Anuken/Mindustry/pull/1495#discussion_r374171193", "bodyText": "This method can be written as a single loop.\nfor(int i = 0; i < items.length; i++){\n    int index = (i + takeRotation) % items.length;\n    if(items[index] > 0){\n        items[index] --;\n        total --;\n        takeRotation = (index + 1) % items.length;\n        return content.item(i);\n    }\n}", "author": "Anuken", "createdAt": "2020-02-03T15:34:38Z", "path": "core/src/mindustry/world/modules/ItemModule.java", "diffHunk": "@@ -66,11 +66,28 @@ public int total(){\n         return total;\n     }\n \n+    // Making the take() loop persistent so it does not return the same item twice in a row unless there is nothing else to return.\n+    protected int takeRotation;\n+\n     public Item take(){\n-        for(int i = 0; i < items.length; i++){\n+    \t// 0-to-length loop broken in two parts. First resume the loop where it previously left off.\n+        for(int i = takeRotation; i < items.length; i++){\n+            if(items[i] > 0){\n+                items[i]--;\n+                total--;\n+    \t\t// save the next position so the next call to take() can resume from there.\n+                takeRotation = (i + 1) % items.length;\n+                return content.item(i);\n+            }\n+        }", "originalCommit": "5da52696d7e734ebb05fdc5d10470277d5d5e820", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDMxNTI0Nw==", "url": "https://github.com/Anuken/Mindustry/pull/1495#discussion_r374315247", "bodyText": "Sure, it can, though modulo remains an extremely expensive instruction on modern hardware (from 15-25 cycles for IDIV/r8 to 50-70 cycles for /r64 vs less than one cycle effective cost for most other 1-5 cycles ALU instructions due to pipelined superscalar execution) and depending on how the java compiler re-factors this, you can conceivably spend more CPU time waiting for IDIV to produce the remainder the rest of the loop depends on than doing useful work in tight loops like that.\nAs a mostly low-level/bare-metal ASM/C/C++/VHDL programmer, putting an exceptionally expensive operation in an otherwise trivial loop's control path when it can so easily be avoided bothers me.\nHope you found this bit of low-level hardware perspective enlightening.", "author": "InvalidError404", "createdAt": "2020-02-03T20:10:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDE3MTE5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDM0OTg3Nw==", "url": "https://github.com/Anuken/Mindustry/pull/1495#discussion_r374349877", "bodyText": "I am aware that modulo is generally considered expensive, but in this case there isn't much of a benefit to splitting things up into two loops. Adding an extra loop adds more code and makes this method harder to read and modify.\nYou also have to consider the fact that this is extremely premature optimization. take() is a method that is called only once per frame for every input bridge and unloader. Considering that most active games have few amounts of these blocks being used, it really doesn't matter which implementation is slower, because the difference is only going to be on the order of a few nanoseconds. I would rather have more readable code than something that's ugly and imperceptibly faster.\nThat being said, I tried benchmarking both versions to see how significant the speed difference was, and the performance difference (with random items) for these two is about ~12 ns, with the non-modulo one taking 30 and the other taking 42. Rewriting the mod implementation to mostly use subtraction instead of modulo actually made it run faster than yours, with 21 ns taken per invocation. This benchmark probably isn't too accurate, but when dealing with nanoseconds, I don't think it'll matter too much.\nCode:\n            for(int i = 0; i < items.length; i++){\n                int index = (i + takeRotation);\n                if(index >= items.length) index -= items.length; //conditional instead of mod\n                if(items[index] > 0){\n                    items[index] --;\n                    total --;\n                    takeRotation = index + 1;\n                    return content.item(index % items.length); //called rarely so it doesn't really matter here, according to benchmarks\n                }\n            }\n\n            return null;", "author": "Anuken", "createdAt": "2020-02-03T21:26:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDE3MTE5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQyNjEyMQ==", "url": "https://github.com/Anuken/Mindustry/pull/1495#discussion_r374426121", "bodyText": "Guessing this is speculative execution at work: branch prediction may not like my front loop having a pseudo-random starting point so your more predictable loop ends up cheaper overall despite having an extra test.\nAs for being imperceptibly faster, imperceptibly faster bits of code add up over time.", "author": "InvalidError404", "createdAt": "2020-02-04T01:01:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDE3MTE5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDE3MTMzOA==", "url": "https://github.com/Anuken/Mindustry/pull/1495#discussion_r374171338", "bodyText": "Instance variables should always be declared at the top of a class.", "author": "Anuken", "createdAt": "2020-02-03T15:34:52Z", "path": "core/src/mindustry/world/modules/ItemModule.java", "diffHunk": "@@ -66,11 +66,28 @@ public int total(){\n         return total;\n     }\n \n+    // Making the take() loop persistent so it does not return the same item twice in a row unless there is nothing else to return.\n+    protected int takeRotation;", "originalCommit": "5da52696d7e734ebb05fdc5d10470277d5d5e820", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDMxODYzNw==", "url": "https://github.com/Anuken/Mindustry/pull/1495#discussion_r374318637", "bodyText": "Of course, sorry about that.\nJust wanted to put the tweak out for people to try and hopefully see the modified behavior or something resembling it make it into a future release.", "author": "InvalidError404", "createdAt": "2020-02-03T20:17:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDE3MTMzOA=="}], "type": "inlineReview"}, {"oid": "455ce98a869c36fc9e77c6cfadf343e5612e64d4", "url": "https://github.com/Anuken/Mindustry/commit/455ce98a869c36fc9e77c6cfadf343e5612e64d4", "message": "Formatting", "committedDate": "2020-02-03T20:26:49Z", "type": "commit"}, {"oid": "0b4bd2ddec4366b30981f91071f97bfe1cfa1787", "url": "https://github.com/Anuken/Mindustry/commit/0b4bd2ddec4366b30981f91071f97bfe1cfa1787", "message": "Anuken's take() rotator.", "committedDate": "2020-02-04T01:10:17Z", "type": "commit"}]}