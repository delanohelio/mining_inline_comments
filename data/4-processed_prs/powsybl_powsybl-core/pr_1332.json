{"pr_number": 1332, "pr_title": "Cgmes conversion join voltage levels connected by switches", "pr_createdAt": "2020-06-03T09:20:01Z", "pr_url": "https://github.com/powsybl/powsybl-core/pull/1332", "timeline": [{"oid": "f6dd672c747c027a7679aeeb1ef44da30ddae186", "url": "https://github.com/powsybl/powsybl-core/commit/f6dd672c747c027a7679aeeb1ef44da30ddae186", "message": "Merge branch 'master' into cgmes_conversion_joinVoltageLevels", "committedDate": "2020-04-24T07:22:56Z", "type": "commit"}, {"oid": "27b8920247beba85ac7aa6296d681ce81152023a", "url": "https://github.com/powsybl/powsybl-core/commit/27b8920247beba85ac7aa6296d681ce81152023a", "message": "Join voltageLevels by switches\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>", "committedDate": "2020-04-29T11:12:51Z", "type": "commit"}, {"oid": "ab6216c0f70cb713141035d5844e8196bf7d83f5", "url": "https://github.com/powsybl/powsybl-core/commit/ab6216c0f70cb713141035d5844e8196bf7d83f5", "message": "Merge branch 'master' into cgmes_conversion_joinVoltageLevels", "committedDate": "2020-05-08T07:32:01Z", "type": "commit"}, {"oid": "4eb43d7e017067ae541263d8811eb89f02b02498", "url": "https://github.com/powsybl/powsybl-core/commit/4eb43d7e017067ae541263d8811eb89f02b02498", "message": "Refact complex method\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>", "committedDate": "2020-05-14T07:40:17Z", "type": "commit"}, {"oid": "4ebd477c51ead613d7b9c548b171d7786622adbd", "url": "https://github.com/powsybl/powsybl-core/commit/4ebd477c51ead613d7b9c548b171d7786622adbd", "message": "Pretty code\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>", "committedDate": "2020-05-14T14:03:19Z", "type": "commit"}, {"oid": "d9c327a206fce12cd51f95f6a0a44cb90cefcd91", "url": "https://github.com/powsybl/powsybl-core/commit/d9c327a206fce12cd51f95f6a0a44cb90cefcd91", "message": "Add unitary tests\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>", "committedDate": "2020-05-14T23:09:13Z", "type": "commit"}, {"oid": "378b7ec04e4e7950931e014611797305be4278e9", "url": "https://github.com/powsybl/powsybl-core/commit/378b7ec04e4e7950931e014611797305be4278e9", "message": "Merge branch 'master' into cgmes_conversion_joinVoltageLevels", "committedDate": "2020-05-21T09:46:37Z", "type": "commit"}, {"oid": "fe37aecbce1da35802bc00ce2ccc2c4396077524", "url": "https://github.com/powsybl/powsybl-core/commit/fe37aecbce1da35802bc00ce2ccc2c4396077524", "message": "Merge branch 'master' into cgmes_conversion_joinVoltageLevels", "committedDate": "2020-05-28T12:49:37Z", "type": "commit"}, {"oid": "65301420202fff7f124d2936273fe72150fa02f5", "url": "https://github.com/powsybl/powsybl-core/commit/65301420202fff7f124d2936273fe72150fa02f5", "message": "Merge branch 'master' into cgmes_conversion_joinVoltageLevels", "committedDate": "2020-06-03T07:10:52Z", "type": "commit"}, {"oid": "13b23d017e21375bba807b7d52e89f527927a5bd", "url": "https://github.com/powsybl/powsybl-core/commit/13b23d017e21375bba807b7d52e89f527927a5bd", "message": "Fix static methods\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>", "committedDate": "2020-06-03T07:54:52Z", "type": "commit"}, {"oid": "928231c0d11ae29e9cebd023585e53a2f2754854", "url": "https://github.com/powsybl/powsybl-core/commit/928231c0d11ae29e9cebd023585e53a2f2754854", "message": "Merge branch 'master' into cgmes_conversion_joinVoltageLevels\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>\n\n# Conflicts:\n#\tcgmes/cgmes-conformity/src/test/java/com/powsybl/cgmes/conformity/test/CgmesConformity1ModifiedCatalog.java\n#\tcgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/SwitchConversion.java", "committedDate": "2020-07-02T14:13:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU5Mjg3MQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1332#discussion_r434592871", "bodyText": "typo substationIsMapped", "author": "MioRtia", "createdAt": "2020-06-03T14:04:59Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/SubstationIdMapping.java", "diffHunk": "@@ -31,49 +30,233 @@\n \n     public SubstationIdMapping(Context context) {\n         this.context = context;\n-        this.mapping = new HashMap<>();\n+        this.substationMapping = new HashMap<>();\n+        this.voltageLevelMapping = new HashMap<>();\n     }\n \n-    public boolean isMapped(String cgmesIdentifier) {\n+    public boolean subStationIsMapped(String cgmesIdentifier) {", "originalCommit": "13b23d017e21375bba807b7d52e89f527927a5bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEzNDQyMg==", "url": "https://github.com/powsybl/powsybl-core/pull/1332#discussion_r449134422", "bodyText": "Done", "author": "marqueslanauja", "createdAt": "2020-07-02T16:27:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU5Mjg3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk5NDQ1NQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1332#discussion_r448994455", "bodyText": "Maybe rename getVoltageLevelFromNode it is more understandable", "author": "MioRtia", "createdAt": "2020-07-02T13:17:27Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/SubstationIdMapping.java", "diffHunk": "@@ -31,49 +30,233 @@\n \n     public SubstationIdMapping(Context context) {\n         this.context = context;\n-        this.mapping = new HashMap<>();\n+        this.substationMapping = new HashMap<>();\n+        this.voltageLevelMapping = new HashMap<>();\n     }\n \n-    public boolean isMapped(String cgmesIdentifier) {\n+    public boolean subStationIsMapped(String cgmesIdentifier) {\n         String sid = context.namingStrategy().getId(CgmesNames.SUBSTATION, cgmesIdentifier);\n-        return mapping.containsKey(sid);\n+        return substationMapping.containsKey(sid);\n     }\n \n-    public String iidm(String cgmesIdentifier) {\n+    public String substationIidm(String cgmesIdentifier) {\n         String sid = context.namingStrategy().getId(CgmesNames.SUBSTATION, cgmesIdentifier);\n-        if (mapping.containsKey(sid)) {\n-            return mapping.get(sid);\n+        if (substationMapping.containsKey(sid)) {\n+            return substationMapping.get(sid);\n         }\n         return sid;\n     }\n \n+    public boolean voltageLevelIsMapped(String cgmesIdentifier) {\n+        String vlid = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, cgmesIdentifier);\n+        return voltageLevelMapping.containsKey(vlid);\n+    }\n+\n+    public String voltageLevelIidm(String cgmesIdentifier) {\n+        String vlid = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, cgmesIdentifier);\n+        if (voltageLevelMapping.containsKey(vlid)) {\n+            return voltageLevelMapping.get(vlid);\n+        }\n+        return vlid;\n+    }\n+\n+    // CGMES standard:\n+    // \"a PowerTransformer is contained in one Substation but it can connect a Terminal to\n+    // another Substation\"\n+    // Ends of transformers need to be in the same substation in the IIDM model.\n+    // We will map some CGMES substations to a single IIDM substation\n+    // when they are connected by transformers,\n+    // that is, when there are at least one power transformer that has terminals on both\n+    // substations\n+    // Ends of switches need to be in the same voltageLevel in the IIDM model.\n+    // We will map some CGMES voltageLevels to a single IIDM voltageLevel\n+    // when they are connected by switches\n+\n     public void build() {\n-        // CGMES standard:\n-        // \"a PowerTransformer is contained in one Substation but it can connect a Terminal to\n-        // another Substation\"\n-        // Ends of transformers need to be in the same substation in the IIDM model.\n-        // We will map some CGMES substations to a single IIDM substation\n-        // when they are connected by transformers,\n-        // that is, when there are at least one power transformer that has terminals on both\n-        // substations\n-\n-        UndirectedGraph<String, Object> g = graphSubstationsTransformers();\n-        new ConnectivityInspector<>(g).connectedSets().stream()\n-                .filter(substationIds -> substationIds.size() > 1)\n-                .forEach(substationIds -> {\n-                    String selectedSubstationId = representativeSubstationId(substationIds);\n-                    for (String substationId : substationIds) {\n-                        if (!substationId.equals(selectedSubstationId)) {\n-                            mapping.put(substationId, selectedSubstationId);\n-                        }\n+        Map<String, List<String>> voltageLevelAdjacency = new HashMap<>();\n+        Map<String, List<String>> substationAdjacency = new HashMap<>();\n+\n+        buildAdjacency(voltageLevelAdjacency, substationAdjacency);\n+        buildVoltageLevel(voltageLevelAdjacency);\n+        buildSubstation(substationAdjacency);\n+    }\n+\n+    private void buildAdjacency(Map<String, List<String>> voltageLevelAdjacency,\n+        Map<String, List<String>> substationAdjacency) {\n+        context.cgmes().voltageLevels().forEach(vl -> addVoltageLevel(voltageLevelAdjacency, vl));\n+        context.cgmes().substations().forEach(st -> addSubstation(substationAdjacency, st));\n+\n+        context.cgmes().switches().forEach(sw -> addSwitch(voltageLevelAdjacency, substationAdjacency, sw));\n+        context.cgmes().groupedTransformerEnds().forEach((t, tends) -> addEnds(substationAdjacency, tends));\n+    }\n+\n+    private void addVoltageLevel(Map<String, List<String>> voltageLevelAdjacency, PropertyBag vl) {\n+        String voltageLevelId = vl.getId(CgmesNames.VOLTAGE_LEVEL);\n+        String vId = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, voltageLevelId);\n+        voltageLevelAdjacency.computeIfAbsent(vId, k -> new ArrayList<>());\n+    }\n+\n+    private void addSubstation(Map<String, List<String>> substationAdjacency, PropertyBag sub) {\n+        String substationlId = sub.getId(CgmesNames.SUBSTATION);\n+        String subId = context.namingStrategy().getId(CgmesNames.SUBSTATION, substationlId);\n+        substationAdjacency.computeIfAbsent(subId, k -> new ArrayList<>());\n+    }\n+\n+    private void addSwitch(Map<String, List<String>> voltageLevelAdjacency,\n+        Map<String, List<String>> substationAdjacency, PropertyBag sw) {\n+        CgmesTerminal t1 = context.cgmes().terminal(sw.getId(CgmesNames.TERMINAL + 1));\n+        String node1 = context.nodeBreaker() ? t1.connectivityNode() : t1.topologicalNode();\n+\n+        String voltageLevelId1 = nodeGetVoltageLevel(node1, t1);\n+        if (voltageLevelId1 == null) {\n+            return;\n+        }\n+\n+        CgmesTerminal t2 = context.cgmes().terminal(sw.getId(CgmesNames.TERMINAL + 2));\n+        String node2 = context.nodeBreaker() ? t2.connectivityNode() : t2.topologicalNode();\n+        String voltageLevelId2 = nodeGetVoltageLevel(node2, t2);\n+        if (voltageLevelId2 == null) {\n+            return;\n+        }\n+\n+        addSwitchAdjacency(voltageLevelAdjacency, substationAdjacency, t1, t2, voltageLevelId1, voltageLevelId2);\n+    }\n+\n+    private String nodeGetVoltageLevel(String node, CgmesTerminal t) {", "originalCommit": "13b23d017e21375bba807b7d52e89f527927a5bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEzNDYwOA==", "url": "https://github.com/powsybl/powsybl-core/pull/1332#discussion_r449134608", "bodyText": "Done", "author": "marqueslanauja", "createdAt": "2020-07-02T16:27:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk5NDQ1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk5NDkyOA==", "url": "https://github.com/powsybl/powsybl-core/pull/1332#discussion_r448994928", "bodyText": "When does this case happen? In boundaries?", "author": "MioRtia", "createdAt": "2020-07-02T13:18:12Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/SubstationIdMapping.java", "diffHunk": "@@ -31,49 +30,233 @@\n \n     public SubstationIdMapping(Context context) {\n         this.context = context;\n-        this.mapping = new HashMap<>();\n+        this.substationMapping = new HashMap<>();\n+        this.voltageLevelMapping = new HashMap<>();\n     }\n \n-    public boolean isMapped(String cgmesIdentifier) {\n+    public boolean subStationIsMapped(String cgmesIdentifier) {\n         String sid = context.namingStrategy().getId(CgmesNames.SUBSTATION, cgmesIdentifier);\n-        return mapping.containsKey(sid);\n+        return substationMapping.containsKey(sid);\n     }\n \n-    public String iidm(String cgmesIdentifier) {\n+    public String substationIidm(String cgmesIdentifier) {\n         String sid = context.namingStrategy().getId(CgmesNames.SUBSTATION, cgmesIdentifier);\n-        if (mapping.containsKey(sid)) {\n-            return mapping.get(sid);\n+        if (substationMapping.containsKey(sid)) {\n+            return substationMapping.get(sid);\n         }\n         return sid;\n     }\n \n+    public boolean voltageLevelIsMapped(String cgmesIdentifier) {\n+        String vlid = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, cgmesIdentifier);\n+        return voltageLevelMapping.containsKey(vlid);\n+    }\n+\n+    public String voltageLevelIidm(String cgmesIdentifier) {\n+        String vlid = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, cgmesIdentifier);\n+        if (voltageLevelMapping.containsKey(vlid)) {\n+            return voltageLevelMapping.get(vlid);\n+        }\n+        return vlid;\n+    }\n+\n+    // CGMES standard:\n+    // \"a PowerTransformer is contained in one Substation but it can connect a Terminal to\n+    // another Substation\"\n+    // Ends of transformers need to be in the same substation in the IIDM model.\n+    // We will map some CGMES substations to a single IIDM substation\n+    // when they are connected by transformers,\n+    // that is, when there are at least one power transformer that has terminals on both\n+    // substations\n+    // Ends of switches need to be in the same voltageLevel in the IIDM model.\n+    // We will map some CGMES voltageLevels to a single IIDM voltageLevel\n+    // when they are connected by switches\n+\n     public void build() {\n-        // CGMES standard:\n-        // \"a PowerTransformer is contained in one Substation but it can connect a Terminal to\n-        // another Substation\"\n-        // Ends of transformers need to be in the same substation in the IIDM model.\n-        // We will map some CGMES substations to a single IIDM substation\n-        // when they are connected by transformers,\n-        // that is, when there are at least one power transformer that has terminals on both\n-        // substations\n-\n-        UndirectedGraph<String, Object> g = graphSubstationsTransformers();\n-        new ConnectivityInspector<>(g).connectedSets().stream()\n-                .filter(substationIds -> substationIds.size() > 1)\n-                .forEach(substationIds -> {\n-                    String selectedSubstationId = representativeSubstationId(substationIds);\n-                    for (String substationId : substationIds) {\n-                        if (!substationId.equals(selectedSubstationId)) {\n-                            mapping.put(substationId, selectedSubstationId);\n-                        }\n+        Map<String, List<String>> voltageLevelAdjacency = new HashMap<>();\n+        Map<String, List<String>> substationAdjacency = new HashMap<>();\n+\n+        buildAdjacency(voltageLevelAdjacency, substationAdjacency);\n+        buildVoltageLevel(voltageLevelAdjacency);\n+        buildSubstation(substationAdjacency);\n+    }\n+\n+    private void buildAdjacency(Map<String, List<String>> voltageLevelAdjacency,\n+        Map<String, List<String>> substationAdjacency) {\n+        context.cgmes().voltageLevels().forEach(vl -> addVoltageLevel(voltageLevelAdjacency, vl));\n+        context.cgmes().substations().forEach(st -> addSubstation(substationAdjacency, st));\n+\n+        context.cgmes().switches().forEach(sw -> addSwitch(voltageLevelAdjacency, substationAdjacency, sw));\n+        context.cgmes().groupedTransformerEnds().forEach((t, tends) -> addEnds(substationAdjacency, tends));\n+    }\n+\n+    private void addVoltageLevel(Map<String, List<String>> voltageLevelAdjacency, PropertyBag vl) {\n+        String voltageLevelId = vl.getId(CgmesNames.VOLTAGE_LEVEL);\n+        String vId = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, voltageLevelId);\n+        voltageLevelAdjacency.computeIfAbsent(vId, k -> new ArrayList<>());\n+    }\n+\n+    private void addSubstation(Map<String, List<String>> substationAdjacency, PropertyBag sub) {\n+        String substationlId = sub.getId(CgmesNames.SUBSTATION);\n+        String subId = context.namingStrategy().getId(CgmesNames.SUBSTATION, substationlId);\n+        substationAdjacency.computeIfAbsent(subId, k -> new ArrayList<>());\n+    }\n+\n+    private void addSwitch(Map<String, List<String>> voltageLevelAdjacency,\n+        Map<String, List<String>> substationAdjacency, PropertyBag sw) {\n+        CgmesTerminal t1 = context.cgmes().terminal(sw.getId(CgmesNames.TERMINAL + 1));\n+        String node1 = context.nodeBreaker() ? t1.connectivityNode() : t1.topologicalNode();\n+\n+        String voltageLevelId1 = nodeGetVoltageLevel(node1, t1);\n+        if (voltageLevelId1 == null) {", "originalCommit": "13b23d017e21375bba807b7d52e89f527927a5bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEzNTMyMg==", "url": "https://github.com/powsybl/powsybl-core/pull/1332#discussion_r449135322", "bodyText": "you are right, in boundaries.", "author": "marqueslanauja", "createdAt": "2020-07-02T16:28:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk5NDkyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2MDY0MA==", "url": "https://github.com/powsybl/powsybl-core/pull/1332#discussion_r492160640", "bodyText": "It could be nice to add a comment in the code to explain it. Because, it's not really explicit\nSame remark below", "author": "mathbagu", "createdAt": "2020-09-21T15:40:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk5NDkyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk5NTA5OA==", "url": "https://github.com/powsybl/powsybl-core/pull/1332#discussion_r448995098", "bodyText": "Same question", "author": "MioRtia", "createdAt": "2020-07-02T13:18:30Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/SubstationIdMapping.java", "diffHunk": "@@ -31,49 +30,233 @@\n \n     public SubstationIdMapping(Context context) {\n         this.context = context;\n-        this.mapping = new HashMap<>();\n+        this.substationMapping = new HashMap<>();\n+        this.voltageLevelMapping = new HashMap<>();\n     }\n \n-    public boolean isMapped(String cgmesIdentifier) {\n+    public boolean subStationIsMapped(String cgmesIdentifier) {\n         String sid = context.namingStrategy().getId(CgmesNames.SUBSTATION, cgmesIdentifier);\n-        return mapping.containsKey(sid);\n+        return substationMapping.containsKey(sid);\n     }\n \n-    public String iidm(String cgmesIdentifier) {\n+    public String substationIidm(String cgmesIdentifier) {\n         String sid = context.namingStrategy().getId(CgmesNames.SUBSTATION, cgmesIdentifier);\n-        if (mapping.containsKey(sid)) {\n-            return mapping.get(sid);\n+        if (substationMapping.containsKey(sid)) {\n+            return substationMapping.get(sid);\n         }\n         return sid;\n     }\n \n+    public boolean voltageLevelIsMapped(String cgmesIdentifier) {\n+        String vlid = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, cgmesIdentifier);\n+        return voltageLevelMapping.containsKey(vlid);\n+    }\n+\n+    public String voltageLevelIidm(String cgmesIdentifier) {\n+        String vlid = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, cgmesIdentifier);\n+        if (voltageLevelMapping.containsKey(vlid)) {\n+            return voltageLevelMapping.get(vlid);\n+        }\n+        return vlid;\n+    }\n+\n+    // CGMES standard:\n+    // \"a PowerTransformer is contained in one Substation but it can connect a Terminal to\n+    // another Substation\"\n+    // Ends of transformers need to be in the same substation in the IIDM model.\n+    // We will map some CGMES substations to a single IIDM substation\n+    // when they are connected by transformers,\n+    // that is, when there are at least one power transformer that has terminals on both\n+    // substations\n+    // Ends of switches need to be in the same voltageLevel in the IIDM model.\n+    // We will map some CGMES voltageLevels to a single IIDM voltageLevel\n+    // when they are connected by switches\n+\n     public void build() {\n-        // CGMES standard:\n-        // \"a PowerTransformer is contained in one Substation but it can connect a Terminal to\n-        // another Substation\"\n-        // Ends of transformers need to be in the same substation in the IIDM model.\n-        // We will map some CGMES substations to a single IIDM substation\n-        // when they are connected by transformers,\n-        // that is, when there are at least one power transformer that has terminals on both\n-        // substations\n-\n-        UndirectedGraph<String, Object> g = graphSubstationsTransformers();\n-        new ConnectivityInspector<>(g).connectedSets().stream()\n-                .filter(substationIds -> substationIds.size() > 1)\n-                .forEach(substationIds -> {\n-                    String selectedSubstationId = representativeSubstationId(substationIds);\n-                    for (String substationId : substationIds) {\n-                        if (!substationId.equals(selectedSubstationId)) {\n-                            mapping.put(substationId, selectedSubstationId);\n-                        }\n+        Map<String, List<String>> voltageLevelAdjacency = new HashMap<>();\n+        Map<String, List<String>> substationAdjacency = new HashMap<>();\n+\n+        buildAdjacency(voltageLevelAdjacency, substationAdjacency);\n+        buildVoltageLevel(voltageLevelAdjacency);\n+        buildSubstation(substationAdjacency);\n+    }\n+\n+    private void buildAdjacency(Map<String, List<String>> voltageLevelAdjacency,\n+        Map<String, List<String>> substationAdjacency) {\n+        context.cgmes().voltageLevels().forEach(vl -> addVoltageLevel(voltageLevelAdjacency, vl));\n+        context.cgmes().substations().forEach(st -> addSubstation(substationAdjacency, st));\n+\n+        context.cgmes().switches().forEach(sw -> addSwitch(voltageLevelAdjacency, substationAdjacency, sw));\n+        context.cgmes().groupedTransformerEnds().forEach((t, tends) -> addEnds(substationAdjacency, tends));\n+    }\n+\n+    private void addVoltageLevel(Map<String, List<String>> voltageLevelAdjacency, PropertyBag vl) {\n+        String voltageLevelId = vl.getId(CgmesNames.VOLTAGE_LEVEL);\n+        String vId = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, voltageLevelId);\n+        voltageLevelAdjacency.computeIfAbsent(vId, k -> new ArrayList<>());\n+    }\n+\n+    private void addSubstation(Map<String, List<String>> substationAdjacency, PropertyBag sub) {\n+        String substationlId = sub.getId(CgmesNames.SUBSTATION);\n+        String subId = context.namingStrategy().getId(CgmesNames.SUBSTATION, substationlId);\n+        substationAdjacency.computeIfAbsent(subId, k -> new ArrayList<>());\n+    }\n+\n+    private void addSwitch(Map<String, List<String>> voltageLevelAdjacency,\n+        Map<String, List<String>> substationAdjacency, PropertyBag sw) {\n+        CgmesTerminal t1 = context.cgmes().terminal(sw.getId(CgmesNames.TERMINAL + 1));\n+        String node1 = context.nodeBreaker() ? t1.connectivityNode() : t1.topologicalNode();\n+\n+        String voltageLevelId1 = nodeGetVoltageLevel(node1, t1);\n+        if (voltageLevelId1 == null) {\n+            return;\n+        }\n+\n+        CgmesTerminal t2 = context.cgmes().terminal(sw.getId(CgmesNames.TERMINAL + 2));\n+        String node2 = context.nodeBreaker() ? t2.connectivityNode() : t2.topologicalNode();\n+        String voltageLevelId2 = nodeGetVoltageLevel(node2, t2);\n+        if (voltageLevelId2 == null) {", "originalCommit": "13b23d017e21375bba807b7d52e89f527927a5bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEzNTYwMw==", "url": "https://github.com/powsybl/powsybl-core/pull/1332#discussion_r449135603", "bodyText": "you are right, in boundaries", "author": "marqueslanauja", "createdAt": "2020-07-02T16:29:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk5NTA5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAwMzYwNw==", "url": "https://github.com/powsybl/powsybl-core/pull/1332#discussion_r449003607", "bodyText": "Same question: in which case does it happen?", "author": "MioRtia", "createdAt": "2020-07-02T13:31:36Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/SubstationIdMapping.java", "diffHunk": "@@ -31,49 +30,233 @@\n \n     public SubstationIdMapping(Context context) {\n         this.context = context;\n-        this.mapping = new HashMap<>();\n+        this.substationMapping = new HashMap<>();\n+        this.voltageLevelMapping = new HashMap<>();\n     }\n \n-    public boolean isMapped(String cgmesIdentifier) {\n+    public boolean subStationIsMapped(String cgmesIdentifier) {\n         String sid = context.namingStrategy().getId(CgmesNames.SUBSTATION, cgmesIdentifier);\n-        return mapping.containsKey(sid);\n+        return substationMapping.containsKey(sid);\n     }\n \n-    public String iidm(String cgmesIdentifier) {\n+    public String substationIidm(String cgmesIdentifier) {\n         String sid = context.namingStrategy().getId(CgmesNames.SUBSTATION, cgmesIdentifier);\n-        if (mapping.containsKey(sid)) {\n-            return mapping.get(sid);\n+        if (substationMapping.containsKey(sid)) {\n+            return substationMapping.get(sid);\n         }\n         return sid;\n     }\n \n+    public boolean voltageLevelIsMapped(String cgmesIdentifier) {\n+        String vlid = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, cgmesIdentifier);\n+        return voltageLevelMapping.containsKey(vlid);\n+    }\n+\n+    public String voltageLevelIidm(String cgmesIdentifier) {\n+        String vlid = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, cgmesIdentifier);\n+        if (voltageLevelMapping.containsKey(vlid)) {\n+            return voltageLevelMapping.get(vlid);\n+        }\n+        return vlid;\n+    }\n+\n+    // CGMES standard:\n+    // \"a PowerTransformer is contained in one Substation but it can connect a Terminal to\n+    // another Substation\"\n+    // Ends of transformers need to be in the same substation in the IIDM model.\n+    // We will map some CGMES substations to a single IIDM substation\n+    // when they are connected by transformers,\n+    // that is, when there are at least one power transformer that has terminals on both\n+    // substations\n+    // Ends of switches need to be in the same voltageLevel in the IIDM model.\n+    // We will map some CGMES voltageLevels to a single IIDM voltageLevel\n+    // when they are connected by switches\n+\n     public void build() {\n-        // CGMES standard:\n-        // \"a PowerTransformer is contained in one Substation but it can connect a Terminal to\n-        // another Substation\"\n-        // Ends of transformers need to be in the same substation in the IIDM model.\n-        // We will map some CGMES substations to a single IIDM substation\n-        // when they are connected by transformers,\n-        // that is, when there are at least one power transformer that has terminals on both\n-        // substations\n-\n-        UndirectedGraph<String, Object> g = graphSubstationsTransformers();\n-        new ConnectivityInspector<>(g).connectedSets().stream()\n-                .filter(substationIds -> substationIds.size() > 1)\n-                .forEach(substationIds -> {\n-                    String selectedSubstationId = representativeSubstationId(substationIds);\n-                    for (String substationId : substationIds) {\n-                        if (!substationId.equals(selectedSubstationId)) {\n-                            mapping.put(substationId, selectedSubstationId);\n-                        }\n+        Map<String, List<String>> voltageLevelAdjacency = new HashMap<>();\n+        Map<String, List<String>> substationAdjacency = new HashMap<>();\n+\n+        buildAdjacency(voltageLevelAdjacency, substationAdjacency);\n+        buildVoltageLevel(voltageLevelAdjacency);\n+        buildSubstation(substationAdjacency);\n+    }\n+\n+    private void buildAdjacency(Map<String, List<String>> voltageLevelAdjacency,\n+        Map<String, List<String>> substationAdjacency) {\n+        context.cgmes().voltageLevels().forEach(vl -> addVoltageLevel(voltageLevelAdjacency, vl));\n+        context.cgmes().substations().forEach(st -> addSubstation(substationAdjacency, st));\n+\n+        context.cgmes().switches().forEach(sw -> addSwitch(voltageLevelAdjacency, substationAdjacency, sw));\n+        context.cgmes().groupedTransformerEnds().forEach((t, tends) -> addEnds(substationAdjacency, tends));\n+    }\n+\n+    private void addVoltageLevel(Map<String, List<String>> voltageLevelAdjacency, PropertyBag vl) {\n+        String voltageLevelId = vl.getId(CgmesNames.VOLTAGE_LEVEL);\n+        String vId = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, voltageLevelId);\n+        voltageLevelAdjacency.computeIfAbsent(vId, k -> new ArrayList<>());\n+    }\n+\n+    private void addSubstation(Map<String, List<String>> substationAdjacency, PropertyBag sub) {\n+        String substationlId = sub.getId(CgmesNames.SUBSTATION);\n+        String subId = context.namingStrategy().getId(CgmesNames.SUBSTATION, substationlId);\n+        substationAdjacency.computeIfAbsent(subId, k -> new ArrayList<>());\n+    }\n+\n+    private void addSwitch(Map<String, List<String>> voltageLevelAdjacency,\n+        Map<String, List<String>> substationAdjacency, PropertyBag sw) {\n+        CgmesTerminal t1 = context.cgmes().terminal(sw.getId(CgmesNames.TERMINAL + 1));\n+        String node1 = context.nodeBreaker() ? t1.connectivityNode() : t1.topologicalNode();\n+\n+        String voltageLevelId1 = nodeGetVoltageLevel(node1, t1);\n+        if (voltageLevelId1 == null) {\n+            return;\n+        }\n+\n+        CgmesTerminal t2 = context.cgmes().terminal(sw.getId(CgmesNames.TERMINAL + 2));\n+        String node2 = context.nodeBreaker() ? t2.connectivityNode() : t2.topologicalNode();\n+        String voltageLevelId2 = nodeGetVoltageLevel(node2, t2);\n+        if (voltageLevelId2 == null) {\n+            return;\n+        }\n+\n+        addSwitchAdjacency(voltageLevelAdjacency, substationAdjacency, t1, t2, voltageLevelId1, voltageLevelId2);\n+    }\n+\n+    private String nodeGetVoltageLevel(String node, CgmesTerminal t) {\n+        String voltageLevelId = null;\n+        if (node != null && !context.boundary().containsNode(node)) {\n+            voltageLevelId = context.cgmes().voltageLevel(t, context.nodeBreaker());\n+        }\n+        return voltageLevelId;\n+    }\n+\n+    private void addSwitchAdjacency(Map<String, List<String>> voltageLevelAdjacency,\n+        Map<String, List<String>> substationAdjacency, CgmesTerminal t1, CgmesTerminal t2, String voltageLevelId1,\n+        String voltageLevelId2) {\n+        if (voltageLevelId1.equals(voltageLevelId2)) {\n+            return;\n+        }\n+        List<String> ad1 = voltageLevelAdjacency.get(voltageLevelId1);\n+        if (ad1 != null) {\n+            ad1.add(voltageLevelId2);\n+        }\n+        List<String> ad2 = voltageLevelAdjacency.get(voltageLevelId2);\n+        if (ad2 != null) {\n+            ad2.add(voltageLevelId1);\n+        }\n+\n+        String substationId1 = context.cgmes().substation(t1, context.nodeBreaker());\n+        if (substationId1 == null) {", "originalCommit": "13b23d017e21375bba807b7d52e89f527927a5bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEzNTcwNA==", "url": "https://github.com/powsybl/powsybl-core/pull/1332#discussion_r449135704", "bodyText": "you are right, in boundaries", "author": "marqueslanauja", "createdAt": "2020-07-02T16:29:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAwMzYwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAwMzcwMA==", "url": "https://github.com/powsybl/powsybl-core/pull/1332#discussion_r449003700", "bodyText": "Same question", "author": "MioRtia", "createdAt": "2020-07-02T13:31:44Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/SubstationIdMapping.java", "diffHunk": "@@ -31,49 +30,233 @@\n \n     public SubstationIdMapping(Context context) {\n         this.context = context;\n-        this.mapping = new HashMap<>();\n+        this.substationMapping = new HashMap<>();\n+        this.voltageLevelMapping = new HashMap<>();\n     }\n \n-    public boolean isMapped(String cgmesIdentifier) {\n+    public boolean subStationIsMapped(String cgmesIdentifier) {\n         String sid = context.namingStrategy().getId(CgmesNames.SUBSTATION, cgmesIdentifier);\n-        return mapping.containsKey(sid);\n+        return substationMapping.containsKey(sid);\n     }\n \n-    public String iidm(String cgmesIdentifier) {\n+    public String substationIidm(String cgmesIdentifier) {\n         String sid = context.namingStrategy().getId(CgmesNames.SUBSTATION, cgmesIdentifier);\n-        if (mapping.containsKey(sid)) {\n-            return mapping.get(sid);\n+        if (substationMapping.containsKey(sid)) {\n+            return substationMapping.get(sid);\n         }\n         return sid;\n     }\n \n+    public boolean voltageLevelIsMapped(String cgmesIdentifier) {\n+        String vlid = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, cgmesIdentifier);\n+        return voltageLevelMapping.containsKey(vlid);\n+    }\n+\n+    public String voltageLevelIidm(String cgmesIdentifier) {\n+        String vlid = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, cgmesIdentifier);\n+        if (voltageLevelMapping.containsKey(vlid)) {\n+            return voltageLevelMapping.get(vlid);\n+        }\n+        return vlid;\n+    }\n+\n+    // CGMES standard:\n+    // \"a PowerTransformer is contained in one Substation but it can connect a Terminal to\n+    // another Substation\"\n+    // Ends of transformers need to be in the same substation in the IIDM model.\n+    // We will map some CGMES substations to a single IIDM substation\n+    // when they are connected by transformers,\n+    // that is, when there are at least one power transformer that has terminals on both\n+    // substations\n+    // Ends of switches need to be in the same voltageLevel in the IIDM model.\n+    // We will map some CGMES voltageLevels to a single IIDM voltageLevel\n+    // when they are connected by switches\n+\n     public void build() {\n-        // CGMES standard:\n-        // \"a PowerTransformer is contained in one Substation but it can connect a Terminal to\n-        // another Substation\"\n-        // Ends of transformers need to be in the same substation in the IIDM model.\n-        // We will map some CGMES substations to a single IIDM substation\n-        // when they are connected by transformers,\n-        // that is, when there are at least one power transformer that has terminals on both\n-        // substations\n-\n-        UndirectedGraph<String, Object> g = graphSubstationsTransformers();\n-        new ConnectivityInspector<>(g).connectedSets().stream()\n-                .filter(substationIds -> substationIds.size() > 1)\n-                .forEach(substationIds -> {\n-                    String selectedSubstationId = representativeSubstationId(substationIds);\n-                    for (String substationId : substationIds) {\n-                        if (!substationId.equals(selectedSubstationId)) {\n-                            mapping.put(substationId, selectedSubstationId);\n-                        }\n+        Map<String, List<String>> voltageLevelAdjacency = new HashMap<>();\n+        Map<String, List<String>> substationAdjacency = new HashMap<>();\n+\n+        buildAdjacency(voltageLevelAdjacency, substationAdjacency);\n+        buildVoltageLevel(voltageLevelAdjacency);\n+        buildSubstation(substationAdjacency);\n+    }\n+\n+    private void buildAdjacency(Map<String, List<String>> voltageLevelAdjacency,\n+        Map<String, List<String>> substationAdjacency) {\n+        context.cgmes().voltageLevels().forEach(vl -> addVoltageLevel(voltageLevelAdjacency, vl));\n+        context.cgmes().substations().forEach(st -> addSubstation(substationAdjacency, st));\n+\n+        context.cgmes().switches().forEach(sw -> addSwitch(voltageLevelAdjacency, substationAdjacency, sw));\n+        context.cgmes().groupedTransformerEnds().forEach((t, tends) -> addEnds(substationAdjacency, tends));\n+    }\n+\n+    private void addVoltageLevel(Map<String, List<String>> voltageLevelAdjacency, PropertyBag vl) {\n+        String voltageLevelId = vl.getId(CgmesNames.VOLTAGE_LEVEL);\n+        String vId = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, voltageLevelId);\n+        voltageLevelAdjacency.computeIfAbsent(vId, k -> new ArrayList<>());\n+    }\n+\n+    private void addSubstation(Map<String, List<String>> substationAdjacency, PropertyBag sub) {\n+        String substationlId = sub.getId(CgmesNames.SUBSTATION);\n+        String subId = context.namingStrategy().getId(CgmesNames.SUBSTATION, substationlId);\n+        substationAdjacency.computeIfAbsent(subId, k -> new ArrayList<>());\n+    }\n+\n+    private void addSwitch(Map<String, List<String>> voltageLevelAdjacency,\n+        Map<String, List<String>> substationAdjacency, PropertyBag sw) {\n+        CgmesTerminal t1 = context.cgmes().terminal(sw.getId(CgmesNames.TERMINAL + 1));\n+        String node1 = context.nodeBreaker() ? t1.connectivityNode() : t1.topologicalNode();\n+\n+        String voltageLevelId1 = nodeGetVoltageLevel(node1, t1);\n+        if (voltageLevelId1 == null) {\n+            return;\n+        }\n+\n+        CgmesTerminal t2 = context.cgmes().terminal(sw.getId(CgmesNames.TERMINAL + 2));\n+        String node2 = context.nodeBreaker() ? t2.connectivityNode() : t2.topologicalNode();\n+        String voltageLevelId2 = nodeGetVoltageLevel(node2, t2);\n+        if (voltageLevelId2 == null) {\n+            return;\n+        }\n+\n+        addSwitchAdjacency(voltageLevelAdjacency, substationAdjacency, t1, t2, voltageLevelId1, voltageLevelId2);\n+    }\n+\n+    private String nodeGetVoltageLevel(String node, CgmesTerminal t) {\n+        String voltageLevelId = null;\n+        if (node != null && !context.boundary().containsNode(node)) {\n+            voltageLevelId = context.cgmes().voltageLevel(t, context.nodeBreaker());\n+        }\n+        return voltageLevelId;\n+    }\n+\n+    private void addSwitchAdjacency(Map<String, List<String>> voltageLevelAdjacency,\n+        Map<String, List<String>> substationAdjacency, CgmesTerminal t1, CgmesTerminal t2, String voltageLevelId1,\n+        String voltageLevelId2) {\n+        if (voltageLevelId1.equals(voltageLevelId2)) {\n+            return;\n+        }\n+        List<String> ad1 = voltageLevelAdjacency.get(voltageLevelId1);\n+        if (ad1 != null) {\n+            ad1.add(voltageLevelId2);\n+        }\n+        List<String> ad2 = voltageLevelAdjacency.get(voltageLevelId2);\n+        if (ad2 != null) {\n+            ad2.add(voltageLevelId1);\n+        }\n+\n+        String substationId1 = context.cgmes().substation(t1, context.nodeBreaker());\n+        if (substationId1 == null) {\n+            return;\n+        }\n+        String substationId2 = context.cgmes().substation(t2, context.nodeBreaker());\n+        if (substationId2 == null) {", "originalCommit": "13b23d017e21375bba807b7d52e89f527927a5bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEzNTc5NQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1332#discussion_r449135795", "bodyText": "you are right, in boundaries", "author": "marqueslanauja", "createdAt": "2020-07-02T16:29:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAwMzcwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA0MDY4OQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1332#discussion_r449040689", "bodyText": "Is terminalData.voltageLevel still used? If not, you can delete the field in the TerminalData object.", "author": "MioRtia", "createdAt": "2020-07-02T14:25:16Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/AbstractConductingEquipmentConversion.java", "diffHunk": "@@ -202,16 +202,24 @@ String iidmVoltageLevelId(int n) {\n     }\n \n     protected VoltageLevel voltageLevel() {\n-        return terminals[0].voltageLevel;\n+        if (terminals[0].iidmVoltageLevelId != null) {", "originalCommit": "928231c0d11ae29e9cebd023585e53a2f2754854", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEzNjI3Nw==", "url": "https://github.com/powsybl/powsybl-core/pull/1332#discussion_r449136277", "bodyText": "It is used.", "author": "marqueslanauja", "createdAt": "2020-07-02T16:30:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA0MDY4OQ=="}], "type": "inlineReview"}, {"oid": "cc422f5e739617ac56b4f2d7cb9e51bba0b85bc0", "url": "https://github.com/powsybl/powsybl-core/commit/cc422f5e739617ac56b4f2d7cb9e51bba0b85bc0", "message": "Apply reviewer comments\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>", "committedDate": "2020-07-02T14:58:16Z", "type": "commit"}, {"oid": "6bdfe9074d997e3ea0b23a38188b59c0cc46a98e", "url": "https://github.com/powsybl/powsybl-core/commit/6bdfe9074d997e3ea0b23a38188b59c0cc46a98e", "message": "delete unnecessary method\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>", "committedDate": "2020-07-02T16:47:47Z", "type": "commit"}, {"oid": "7dedd452146a015d8b3a81e76d8ecae15c696a5b", "url": "https://github.com/powsybl/powsybl-core/commit/7dedd452146a015d8b3a81e76d8ecae15c696a5b", "message": "Merge branch 'master' into cgmes_conversion_joinVoltageLevels", "committedDate": "2020-08-28T09:44:40Z", "type": "commit"}, {"oid": "c1b0be51ccfcab55fa28279147b467f30e0b88b5", "url": "https://github.com/powsybl/powsybl-core/commit/c1b0be51ccfcab55fa28279147b467f30e0b88b5", "message": "Merge branch 'master' into cgmes_conversion_joinVoltageLevels\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>\n\n# Conflicts:\n#\tcgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/SubstationIdMapping.java\n#\tcgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/SwitchConversion.java", "committedDate": "2020-09-17T06:43:23Z", "type": "commit"}, {"oid": "90aa9a5823076c8b3664113c414da857c0457b0a", "url": "https://github.com/powsybl/powsybl-core/commit/90aa9a5823076c8b3664113c414da857c0457b0a", "message": "Add merged substations and voltage levels as alias\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>", "committedDate": "2020-09-17T12:21:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE1NzcyNg==", "url": "https://github.com/powsybl/powsybl-core/pull/1332#discussion_r492157726", "bodyText": "Honestly I don't understand what this code does, just because the name of the variables are not well chosen. Could you please rename substationMapping and voltageMapping to something more explicit or explain in comment what is the key, what is the value of these maps?\nIs it a BiMap, to associate a voltageLevel to a substation?", "author": "mathbagu", "createdAt": "2020-09-21T15:35:50Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/SubstationIdMapping.java", "diffHunk": "@@ -31,47 +31,243 @@\n \n     public SubstationIdMapping(Context context) {\n         this.context = context;\n-        this.mapping = new HashMap<>();\n+        this.substationMapping = new HashMap<>();\n+        this.voltageLevelMapping = new HashMap<>();\n     }\n \n-    public boolean isMapped(String cgmesIdentifier) {\n+    public boolean substationIsMapped(String cgmesIdentifier) {\n         String sid = context.namingStrategy().getId(CgmesNames.SUBSTATION, cgmesIdentifier);\n-        return mapping.containsKey(sid);\n+        return substationMapping.containsKey(sid);\n     }\n \n-    public String iidm(String cgmesIdentifier) {\n+    public String substationIidm(String cgmesIdentifier) {\n         String sid = context.namingStrategy().getId(CgmesNames.SUBSTATION, cgmesIdentifier);\n-        if (mapping.containsKey(sid)) {\n-            return mapping.get(sid);\n+        if (substationMapping.containsKey(sid)) {\n+            return substationMapping.get(sid);\n         }\n         return sid;\n     }\n \n+    public List<String> mergedSubstations(String cgmesIdentifier) {\n+        String sid = context.namingStrategy().getId(CgmesNames.SUBSTATION, cgmesIdentifier);\n+        return substationMapping.entrySet().stream().filter(record -> record.getValue().equals(sid))\n+            .map(Map.Entry::getKey).collect(Collectors.toList());\n+    }", "originalCommit": "90aa9a5823076c8b3664113c414da857c0457b0a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA2NDMzNA==", "url": "https://github.com/powsybl/powsybl-core/pull/1332#discussion_r493064334", "bodyText": "Can not be a BiMap as the values are not unique. The code has been commented and a small example has been added", "author": "marqueslanauja", "createdAt": "2020-09-22T22:16:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE1NzcyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA2NTYwOQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1332#discussion_r493065609", "bodyText": "Some code has been refact to improve readability", "author": "marqueslanauja", "createdAt": "2020-09-22T22:19:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE1NzcyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2MzEyMg==", "url": "https://github.com/powsybl/powsybl-core/pull/1332#discussion_r492163122", "bodyText": "Are you sure that all these test are necessary? You should explain in which case it happens, the code is really hard to maintain because there is a lot of things in your head :)", "author": "mathbagu", "createdAt": "2020-09-21T15:43:47Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/SubstationIdMapping.java", "diffHunk": "@@ -31,47 +31,243 @@\n \n     public SubstationIdMapping(Context context) {\n         this.context = context;\n-        this.mapping = new HashMap<>();\n+        this.substationMapping = new HashMap<>();\n+        this.voltageLevelMapping = new HashMap<>();\n     }\n \n-    public boolean isMapped(String cgmesIdentifier) {\n+    public boolean substationIsMapped(String cgmesIdentifier) {\n         String sid = context.namingStrategy().getId(CgmesNames.SUBSTATION, cgmesIdentifier);\n-        return mapping.containsKey(sid);\n+        return substationMapping.containsKey(sid);\n     }\n \n-    public String iidm(String cgmesIdentifier) {\n+    public String substationIidm(String cgmesIdentifier) {\n         String sid = context.namingStrategy().getId(CgmesNames.SUBSTATION, cgmesIdentifier);\n-        if (mapping.containsKey(sid)) {\n-            return mapping.get(sid);\n+        if (substationMapping.containsKey(sid)) {\n+            return substationMapping.get(sid);\n         }\n         return sid;\n     }\n \n+    public List<String> mergedSubstations(String cgmesIdentifier) {\n+        String sid = context.namingStrategy().getId(CgmesNames.SUBSTATION, cgmesIdentifier);\n+        return substationMapping.entrySet().stream().filter(record -> record.getValue().equals(sid))\n+            .map(Map.Entry::getKey).collect(Collectors.toList());\n+    }\n+\n+    public boolean voltageLevelIsMapped(String cgmesIdentifier) {\n+        String vlid = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, cgmesIdentifier);\n+        return voltageLevelMapping.containsKey(vlid);\n+    }\n+\n+    public String voltageLevelIidm(String cgmesIdentifier) {\n+        String vlid = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, cgmesIdentifier);\n+        if (voltageLevelMapping.containsKey(vlid)) {\n+            return voltageLevelMapping.get(vlid);\n+        }\n+        return vlid;\n+    }\n+\n+    public List<String> mergedVoltageLevels(String cgmesIdentifier) {\n+        String vlid = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, cgmesIdentifier);\n+        return voltageLevelMapping.entrySet().stream().filter(record -> record.getValue().equals(vlid))\n+            .map(Map.Entry::getKey).collect(Collectors.toList());\n+    }\n+\n+    // CGMES standard:\n+    // \"a PowerTransformer is contained in one Substation but it can connect a Terminal to\n+    // another Substation\"\n+    // Ends of transformers need to be in the same substation in the IIDM model.\n+    // We will map some CGMES substations to a single IIDM substation\n+    // when they are connected by transformers,\n+    // that is, when there are at least one power transformer that has terminals on both\n+    // substations\n+    // Ends of switches need to be in the same voltageLevel in the IIDM model.\n+    // We will map some CGMES voltageLevels to a single IIDM voltageLevel\n+    // when they are connected by switches\n+\n     public void build() {\n-        // CGMES standard:\n-        // \"a PowerTransformer is contained in one Substation but it can connect a Terminal to\n-        // another Substation\"\n-        // Ends of transformers need to be in the same substation in the IIDM model.\n-        // We will map some CGMES substations to a single IIDM substation\n-        // when they are connected by transformers,\n-        // that is, when there are at least one power transformer that has terminals on both\n-        // substations\n-\n-        Graph<String, Object> g = graphSubstationsTransformers();\n-        new ConnectivityInspector<>(g).connectedSets().stream()\n-                .filter(substationIds -> substationIds.size() > 1)\n-                .forEach(substationIds -> {\n-                    String selectedSubstationId = representativeSubstationId(substationIds);\n-                    for (String substationId : substationIds) {\n-                        if (!substationId.equals(selectedSubstationId)) {\n-                            mapping.put(substationId, selectedSubstationId);\n-                        }\n+        Map<String, List<String>> voltageLevelAdjacency = new HashMap<>();\n+        Map<String, List<String>> substationAdjacency = new HashMap<>();\n+\n+        buildAdjacency(voltageLevelAdjacency, substationAdjacency);\n+        buildVoltageLevel(voltageLevelAdjacency);\n+        buildSubstation(substationAdjacency);\n+    }\n+\n+    private void buildAdjacency(Map<String, List<String>> voltageLevelAdjacency,\n+        Map<String, List<String>> substationAdjacency) {\n+        context.cgmes().voltageLevels().forEach(vl -> addVoltageLevel(voltageLevelAdjacency, vl));\n+        context.cgmes().substations().forEach(st -> addSubstation(substationAdjacency, st));\n+\n+        context.cgmes().switches().forEach(sw -> addSwitch(voltageLevelAdjacency, substationAdjacency, sw));\n+        context.cgmes().groupedTransformerEnds().forEach((t, tends) -> addEnds(substationAdjacency, tends));\n+    }\n+\n+    private void addVoltageLevel(Map<String, List<String>> voltageLevelAdjacency, PropertyBag vl) {\n+        String voltageLevelId = vl.getId(CgmesNames.VOLTAGE_LEVEL);\n+        String vId = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, voltageLevelId);\n+        voltageLevelAdjacency.computeIfAbsent(vId, k -> new ArrayList<>());\n+    }\n+\n+    private void addSubstation(Map<String, List<String>> substationAdjacency, PropertyBag sub) {\n+        String substationlId = sub.getId(CgmesNames.SUBSTATION);\n+        String subId = context.namingStrategy().getId(CgmesNames.SUBSTATION, substationlId);\n+        substationAdjacency.computeIfAbsent(subId, k -> new ArrayList<>());\n+    }\n+\n+    private void addSwitch(Map<String, List<String>> voltageLevelAdjacency,\n+        Map<String, List<String>> substationAdjacency, PropertyBag sw) {\n+        CgmesTerminal t1 = context.cgmes().terminal(sw.getId(CgmesNames.TERMINAL + 1));\n+        String node1 = context.nodeBreaker() ? t1.connectivityNode() : t1.topologicalNode();\n+\n+        String voltageLevelId1 = getVoltageLevelFromNode(node1, t1);\n+        if (voltageLevelId1 == null) {\n+            return;\n+        }\n+\n+        CgmesTerminal t2 = context.cgmes().terminal(sw.getId(CgmesNames.TERMINAL + 2));\n+        String node2 = context.nodeBreaker() ? t2.connectivityNode() : t2.topologicalNode();\n+        String voltageLevelId2 = getVoltageLevelFromNode(node2, t2);\n+        if (voltageLevelId2 == null) {\n+            return;\n+        }\n+\n+        addSwitchAdjacency(voltageLevelAdjacency, substationAdjacency, t1, t2, voltageLevelId1, voltageLevelId2);\n+    }\n+\n+    private String getVoltageLevelFromNode(String node, CgmesTerminal t) {\n+        String voltageLevelId = null;\n+        if (node != null && !context.boundary().containsNode(node)) {\n+            voltageLevelId = context.cgmes().voltageLevel(t, context.nodeBreaker());\n+        }\n+        return voltageLevelId;\n+    }\n+\n+    private void addSwitchAdjacency(Map<String, List<String>> voltageLevelAdjacency,\n+        Map<String, List<String>> substationAdjacency, CgmesTerminal t1, CgmesTerminal t2, String voltageLevelId1,\n+        String voltageLevelId2) {\n+        if (voltageLevelId1.equals(voltageLevelId2)) {\n+            return;\n+        }\n+        List<String> ad1 = voltageLevelAdjacency.get(voltageLevelId1);\n+        if (ad1 != null) {\n+            ad1.add(voltageLevelId2);\n+        }\n+        List<String> ad2 = voltageLevelAdjacency.get(voltageLevelId2);\n+        if (ad2 != null) {\n+            ad2.add(voltageLevelId1);\n+        }\n+\n+        String substationId1 = context.cgmes().substation(t1, context.nodeBreaker());\n+        if (substationId1 == null) {\n+            return;\n+        }\n+        String substationId2 = context.cgmes().substation(t2, context.nodeBreaker());\n+        if (substationId2 == null) {\n+            return;\n+        }\n+        if (substationId1.equals(substationId2)) {\n+            return;\n+        }\n+\n+        ad1 = substationAdjacency.get(substationId1);\n+        if (ad1 != null) {\n+            ad1.add(substationId2);\n+        }\n+        ad2 = substationAdjacency.get(substationId2);\n+        if (ad2 != null) {\n+            ad2.add(substationId1);\n+        }\n+    }", "originalCommit": "90aa9a5823076c8b3664113c414da857c0457b0a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA2Mjg4MA==", "url": "https://github.com/powsybl/powsybl-core/pull/1332#discussion_r493062880", "bodyText": "Has been changed to Objects.requireNonNull(ad2)", "author": "marqueslanauja", "createdAt": "2020-09-22T22:12:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2MzEyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTU2ODM0Mg==", "url": "https://github.com/powsybl/powsybl-core/pull/1332#discussion_r501568342", "bodyText": "Even in this case, can you add a comment about in which case it can be null? If it never happens, it can not be checked (the method is private)", "author": "miovd", "createdAt": "2020-10-08T09:14:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2MzEyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzgxNjg3MA==", "url": "https://github.com/powsybl/powsybl-core/pull/1332#discussion_r503816870", "bodyText": "I throw an exception that gives more information and clarifies when this situation can happen.", "author": "marqueslanauja", "createdAt": "2020-10-13T09:47:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2MzEyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE3MjY3NA==", "url": "https://github.com/powsybl/powsybl-core/pull/1332#discussion_r492172674", "bodyText": "I think the else never happens. If the voltageLevelIds is empty, this will throw an error. Why don't throw it directly with an explicit message", "author": "mathbagu", "createdAt": "2020-09-21T15:57:37Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/SubstationIdMapping.java", "diffHunk": "@@ -31,47 +31,243 @@\n \n     public SubstationIdMapping(Context context) {\n         this.context = context;\n-        this.mapping = new HashMap<>();\n+        this.substationMapping = new HashMap<>();\n+        this.voltageLevelMapping = new HashMap<>();\n     }\n \n-    public boolean isMapped(String cgmesIdentifier) {\n+    public boolean substationIsMapped(String cgmesIdentifier) {\n         String sid = context.namingStrategy().getId(CgmesNames.SUBSTATION, cgmesIdentifier);\n-        return mapping.containsKey(sid);\n+        return substationMapping.containsKey(sid);\n     }\n \n-    public String iidm(String cgmesIdentifier) {\n+    public String substationIidm(String cgmesIdentifier) {\n         String sid = context.namingStrategy().getId(CgmesNames.SUBSTATION, cgmesIdentifier);\n-        if (mapping.containsKey(sid)) {\n-            return mapping.get(sid);\n+        if (substationMapping.containsKey(sid)) {\n+            return substationMapping.get(sid);\n         }\n         return sid;\n     }\n \n+    public List<String> mergedSubstations(String cgmesIdentifier) {\n+        String sid = context.namingStrategy().getId(CgmesNames.SUBSTATION, cgmesIdentifier);\n+        return substationMapping.entrySet().stream().filter(record -> record.getValue().equals(sid))\n+            .map(Map.Entry::getKey).collect(Collectors.toList());\n+    }\n+\n+    public boolean voltageLevelIsMapped(String cgmesIdentifier) {\n+        String vlid = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, cgmesIdentifier);\n+        return voltageLevelMapping.containsKey(vlid);\n+    }\n+\n+    public String voltageLevelIidm(String cgmesIdentifier) {\n+        String vlid = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, cgmesIdentifier);\n+        if (voltageLevelMapping.containsKey(vlid)) {\n+            return voltageLevelMapping.get(vlid);\n+        }\n+        return vlid;\n+    }\n+\n+    public List<String> mergedVoltageLevels(String cgmesIdentifier) {\n+        String vlid = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, cgmesIdentifier);\n+        return voltageLevelMapping.entrySet().stream().filter(record -> record.getValue().equals(vlid))\n+            .map(Map.Entry::getKey).collect(Collectors.toList());\n+    }\n+\n+    // CGMES standard:\n+    // \"a PowerTransformer is contained in one Substation but it can connect a Terminal to\n+    // another Substation\"\n+    // Ends of transformers need to be in the same substation in the IIDM model.\n+    // We will map some CGMES substations to a single IIDM substation\n+    // when they are connected by transformers,\n+    // that is, when there are at least one power transformer that has terminals on both\n+    // substations\n+    // Ends of switches need to be in the same voltageLevel in the IIDM model.\n+    // We will map some CGMES voltageLevels to a single IIDM voltageLevel\n+    // when they are connected by switches\n+\n     public void build() {\n-        // CGMES standard:\n-        // \"a PowerTransformer is contained in one Substation but it can connect a Terminal to\n-        // another Substation\"\n-        // Ends of transformers need to be in the same substation in the IIDM model.\n-        // We will map some CGMES substations to a single IIDM substation\n-        // when they are connected by transformers,\n-        // that is, when there are at least one power transformer that has terminals on both\n-        // substations\n-\n-        Graph<String, Object> g = graphSubstationsTransformers();\n-        new ConnectivityInspector<>(g).connectedSets().stream()\n-                .filter(substationIds -> substationIds.size() > 1)\n-                .forEach(substationIds -> {\n-                    String selectedSubstationId = representativeSubstationId(substationIds);\n-                    for (String substationId : substationIds) {\n-                        if (!substationId.equals(selectedSubstationId)) {\n-                            mapping.put(substationId, selectedSubstationId);\n-                        }\n+        Map<String, List<String>> voltageLevelAdjacency = new HashMap<>();\n+        Map<String, List<String>> substationAdjacency = new HashMap<>();\n+\n+        buildAdjacency(voltageLevelAdjacency, substationAdjacency);\n+        buildVoltageLevel(voltageLevelAdjacency);\n+        buildSubstation(substationAdjacency);\n+    }\n+\n+    private void buildAdjacency(Map<String, List<String>> voltageLevelAdjacency,\n+        Map<String, List<String>> substationAdjacency) {\n+        context.cgmes().voltageLevels().forEach(vl -> addVoltageLevel(voltageLevelAdjacency, vl));\n+        context.cgmes().substations().forEach(st -> addSubstation(substationAdjacency, st));\n+\n+        context.cgmes().switches().forEach(sw -> addSwitch(voltageLevelAdjacency, substationAdjacency, sw));\n+        context.cgmes().groupedTransformerEnds().forEach((t, tends) -> addEnds(substationAdjacency, tends));\n+    }\n+\n+    private void addVoltageLevel(Map<String, List<String>> voltageLevelAdjacency, PropertyBag vl) {\n+        String voltageLevelId = vl.getId(CgmesNames.VOLTAGE_LEVEL);\n+        String vId = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, voltageLevelId);\n+        voltageLevelAdjacency.computeIfAbsent(vId, k -> new ArrayList<>());\n+    }\n+\n+    private void addSubstation(Map<String, List<String>> substationAdjacency, PropertyBag sub) {\n+        String substationlId = sub.getId(CgmesNames.SUBSTATION);\n+        String subId = context.namingStrategy().getId(CgmesNames.SUBSTATION, substationlId);\n+        substationAdjacency.computeIfAbsent(subId, k -> new ArrayList<>());\n+    }\n+\n+    private void addSwitch(Map<String, List<String>> voltageLevelAdjacency,\n+        Map<String, List<String>> substationAdjacency, PropertyBag sw) {\n+        CgmesTerminal t1 = context.cgmes().terminal(sw.getId(CgmesNames.TERMINAL + 1));\n+        String node1 = context.nodeBreaker() ? t1.connectivityNode() : t1.topologicalNode();\n+\n+        String voltageLevelId1 = getVoltageLevelFromNode(node1, t1);\n+        if (voltageLevelId1 == null) {\n+            return;\n+        }\n+\n+        CgmesTerminal t2 = context.cgmes().terminal(sw.getId(CgmesNames.TERMINAL + 2));\n+        String node2 = context.nodeBreaker() ? t2.connectivityNode() : t2.topologicalNode();\n+        String voltageLevelId2 = getVoltageLevelFromNode(node2, t2);\n+        if (voltageLevelId2 == null) {\n+            return;\n+        }\n+\n+        addSwitchAdjacency(voltageLevelAdjacency, substationAdjacency, t1, t2, voltageLevelId1, voltageLevelId2);\n+    }\n+\n+    private String getVoltageLevelFromNode(String node, CgmesTerminal t) {\n+        String voltageLevelId = null;\n+        if (node != null && !context.boundary().containsNode(node)) {\n+            voltageLevelId = context.cgmes().voltageLevel(t, context.nodeBreaker());\n+        }\n+        return voltageLevelId;\n+    }\n+\n+    private void addSwitchAdjacency(Map<String, List<String>> voltageLevelAdjacency,\n+        Map<String, List<String>> substationAdjacency, CgmesTerminal t1, CgmesTerminal t2, String voltageLevelId1,\n+        String voltageLevelId2) {\n+        if (voltageLevelId1.equals(voltageLevelId2)) {\n+            return;\n+        }\n+        List<String> ad1 = voltageLevelAdjacency.get(voltageLevelId1);\n+        if (ad1 != null) {\n+            ad1.add(voltageLevelId2);\n+        }\n+        List<String> ad2 = voltageLevelAdjacency.get(voltageLevelId2);\n+        if (ad2 != null) {\n+            ad2.add(voltageLevelId1);\n+        }\n+\n+        String substationId1 = context.cgmes().substation(t1, context.nodeBreaker());\n+        if (substationId1 == null) {\n+            return;\n+        }\n+        String substationId2 = context.cgmes().substation(t2, context.nodeBreaker());\n+        if (substationId2 == null) {\n+            return;\n+        }\n+        if (substationId1.equals(substationId2)) {\n+            return;\n+        }\n+\n+        ad1 = substationAdjacency.get(substationId1);\n+        if (ad1 != null) {\n+            ad1.add(substationId2);\n+        }\n+        ad2 = substationAdjacency.get(substationId2);\n+        if (ad2 != null) {\n+            ad2.add(substationId1);\n+        }\n+    }\n+\n+    private void addEnds(Map<String, List<String>> substationAdjacency, PropertyBags tends) {\n+        List<String> substationsIds = substationsIds(tends);\n+        if (substationsIds.size() <= 1) {\n+            return;\n+        }\n+        String sub0 = substationsIds.get(0);\n+        for (int i = 1; i < substationsIds.size(); i++) {\n+            String subi = substationsIds.get(i);\n+            if (sub0.contentEquals(subi)) {\n+                continue;\n+            }\n+            List<String> ad0 = substationAdjacency.get(sub0);\n+            if (ad0 != null) {\n+                ad0.add(subi);\n+            }\n+            List<String> adi = substationAdjacency.get(subi);\n+            if (adi != null) {\n+                adi.add(sub0);\n+            }\n+        }\n+    }\n+\n+    private void buildVoltageLevel(Map<String, List<String>> voltageLevelAdjacency) {\n+        Set<String> visitedVoltageLevels = new HashSet<>();\n+        voltageLevelAdjacency.keySet().forEach(vl -> {\n+            if (!visitedVoltageLevels.contains(vl)) {\n+                ArrayList<String> vlAds = adjacents(voltageLevelAdjacency, visitedVoltageLevels, vl);\n+                String selectedVoltageLevelId = representativeVoltageLevelId(vlAds);\n+                for (String voltageLevelId : vlAds) {\n+                    if (!voltageLevelId.equals(selectedVoltageLevelId)) {\n+                        voltageLevelMapping.put(voltageLevelId, selectedVoltageLevelId);\n                     }\n-                });\n-        if (!mapping.isEmpty()) {\n+                }\n+            }\n+        });\n+        if (!voltageLevelMapping.isEmpty()) {\n+            LOG.warn(\"VoltageLevel id mapping needed for {} voltageLevels: {}\",\n+                voltageLevelMapping.size(), voltageLevelMapping);\n+        }\n+    }\n+\n+    private void buildSubstation(Map<String, List<String>> substationAdjacency) {\n+        Set<String> visitedSubstations = new HashSet<>();\n+        substationAdjacency.keySet().forEach(sub -> {\n+            if (!visitedSubstations.contains(sub)) {\n+                ArrayList<String> subAds = adjacents(substationAdjacency, visitedSubstations, sub);\n+\n+                String selectedSubstationId = representativeSubstationId(subAds);\n+                for (String substationId : subAds) {\n+                    if (!substationId.equals(selectedSubstationId)) {\n+                        substationMapping.put(substationId, selectedSubstationId);\n+                    }\n+                }\n+            }\n+        });\n+        if (!substationMapping.isEmpty()) {\n             LOG.warn(\"Substation id mapping needed for {} substations: {}\",\n-                    mapping.size(), mapping);\n+                    substationMapping.size(), substationMapping);\n+        }\n+    }\n+\n+    private static ArrayList<String> adjacents(Map<String, List<String>> adjacency, Set<String> visited, String id) {\n+        ArrayList<String> adjacent = new ArrayList<>();\n+        adjacent.add(id);\n+        visited.add(id);\n+\n+        int k = 0;\n+        while (k < adjacent.size()) {\n+            String vl0 = adjacent.get(k);\n+            if (adjacency.containsKey(vl0)) {\n+                adjacency.get(vl0).forEach(ad -> {\n+                    if (visited.contains(ad)) {\n+                        return;\n+                    }\n+                    adjacent.add(ad);\n+                    visited.add(ad);\n+                });\n+            }\n+            k++;\n         }\n+        return adjacent;\n+    }\n+\n+    private static String representativeVoltageLevelId(Collection<String> voltageLevelIds) {\n+        return voltageLevelIds.stream()\n+                .sorted()\n+                .findFirst()\n+                .orElse(voltageLevelIds.iterator().next());", "originalCommit": "90aa9a5823076c8b3664113c414da857c0457b0a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA2MTc0MA==", "url": "https://github.com/powsybl/powsybl-core/pull/1332#discussion_r493061740", "bodyText": "An error has been thrown. Done", "author": "marqueslanauja", "createdAt": "2020-09-22T22:09:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE3MjY3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE3NTYyNQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1332#discussion_r492175625", "bodyText": "Write this in a single line", "author": "mathbagu", "createdAt": "2020-09-21T16:01:59Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/SwitchConversion.java", "diffHunk": "@@ -74,29 +69,18 @@ private void convertSwitchAtBoundary(int boundarySide) {\n     private void convertToSwitch() {\n         boolean normalOpen = p.asBoolean(\"normalOpen\", false);\n         boolean open = p.asBoolean(\"open\", normalOpen);\n-        if (convertToLowImpedanceLine()) {\n-            warnLowImpedanceLineCreated();\n-            LineAdder adder = context.network().newLine().setR(context.config().lowImpedanceLineR())\n-                    .setX(context.config().lowImpedanceLineX()).setG1(0).setB1(0).setG2(0).setB2(0);\n+        if (context.nodeBreaker()) {\n+            VoltageLevel.NodeBreakerView.SwitchAdder adder;\n+            adder = voltageLevel().getNodeBreakerView().newSwitch().setKind(kind());", "originalCommit": "90aa9a5823076c8b3664113c414da857c0457b0a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA2MTA5MQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1332#discussion_r493061091", "bodyText": "Done", "author": "marqueslanauja", "createdAt": "2020-09-22T22:07:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE3NTYyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE3NTY4MA==", "url": "https://github.com/powsybl/powsybl-core/pull/1332#discussion_r492175680", "bodyText": "Write this in a single line", "author": "mathbagu", "createdAt": "2020-09-21T16:02:05Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/SwitchConversion.java", "diffHunk": "@@ -74,29 +69,18 @@ private void convertSwitchAtBoundary(int boundarySide) {\n     private void convertToSwitch() {\n         boolean normalOpen = p.asBoolean(\"normalOpen\", false);\n         boolean open = p.asBoolean(\"open\", normalOpen);\n-        if (convertToLowImpedanceLine()) {\n-            warnLowImpedanceLineCreated();\n-            LineAdder adder = context.network().newLine().setR(context.config().lowImpedanceLineR())\n-                    .setX(context.config().lowImpedanceLineX()).setG1(0).setB1(0).setG2(0).setB2(0);\n+        if (context.nodeBreaker()) {\n+            VoltageLevel.NodeBreakerView.SwitchAdder adder;\n+            adder = voltageLevel().getNodeBreakerView().newSwitch().setKind(kind());\n             identify(adder);\n-            boolean branchIsClosed = !open;\n-            connect(adder, terminalConnected(1), terminalConnected(2), branchIsClosed);\n-            Line line = adder.add();\n-            convertedTerminals(line.getTerminal1(), line.getTerminal2());\n+            connect(adder, open);\n+            adder.add();\n         } else {\n-            if (context.nodeBreaker()) {\n-                VoltageLevel.NodeBreakerView.SwitchAdder adder;\n-                adder = voltageLevel().getNodeBreakerView().newSwitch().setKind(kind());\n-                identify(adder);\n-                connect(adder, open);\n-                adder.add();\n-            } else {\n-                VoltageLevel.BusBreakerView.SwitchAdder adder;\n-                adder = voltageLevel().getBusBreakerView().newSwitch();\n-                identify(adder);\n-                connect(adder, open);\n-                adder.add();\n-            }\n+            VoltageLevel.BusBreakerView.SwitchAdder adder;\n+            adder = voltageLevel().getBusBreakerView().newSwitch();", "originalCommit": "90aa9a5823076c8b3664113c414da857c0457b0a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA2MDk3OA==", "url": "https://github.com/powsybl/powsybl-core/pull/1332#discussion_r493060978", "bodyText": "Done", "author": "marqueslanauja", "createdAt": "2020-09-22T22:07:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE3NTY4MA=="}], "type": "inlineReview"}, {"oid": "62e3f789a93054685bec1c23d768baef26aa770f", "url": "https://github.com/powsybl/powsybl-core/commit/62e3f789a93054685bec1c23d768baef26aa770f", "message": "Merge branch 'master' into cgmes_conversion_joinVoltageLevels\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>\n\n# Conflicts:\n#\tcgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/elements/SwitchConversion.java", "committedDate": "2020-09-22T09:42:35Z", "type": "commit"}, {"oid": "0a8c40c51c4cf57700c3118ea592b3a2f5b4bff4", "url": "https://github.com/powsybl/powsybl-core/commit/0a8c40c51c4cf57700c3118ea592b3a2f5b4bff4", "message": "Pretty and documented code\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>", "committedDate": "2020-09-22T22:04:36Z", "type": "commit"}, {"oid": "7f5b580e72ab691e62f9d88a547e36a58e42e766", "url": "https://github.com/powsybl/powsybl-core/commit/7f5b580e72ab691e62f9d88a547e36a58e42e766", "message": "Typo\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>", "committedDate": "2020-09-23T06:23:52Z", "type": "commit"}, {"oid": "75f7f5f9f99f35ef78022e4f31273957ea5de283", "url": "https://github.com/powsybl/powsybl-core/commit/75f7f5f9f99f35ef78022e4f31273957ea5de283", "message": "Merge branch 'master' into cgmes_conversion_joinVoltageLevels", "committedDate": "2020-09-25T05:42:56Z", "type": "commit"}, {"oid": "65eb129b6dbad460c7f2b51192315b88e0484db9", "url": "https://github.com/powsybl/powsybl-core/commit/65eb129b6dbad460c7f2b51192315b88e0484db9", "message": "Merge branch 'master' into cgmes_conversion_joinVoltageLevels", "committedDate": "2020-10-12T16:07:03Z", "type": "commit"}, {"oid": "28133d614d94ebd594e73426dc2e025da8e90670", "url": "https://github.com/powsybl/powsybl-core/commit/28133d614d94ebd594e73426dc2e025da8e90670", "message": "Apply reviewer comment\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>", "committedDate": "2020-10-13T09:42:10Z", "type": "commit"}, {"oid": "dcd8f2f57cc6d3552cad79800f38addb39c69bcb", "url": "https://github.com/powsybl/powsybl-core/commit/dcd8f2f57cc6d3552cad79800f38addb39c69bcb", "message": "Prettier message\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>", "committedDate": "2020-10-13T10:06:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgwNjAzNA==", "url": "https://github.com/powsybl/powsybl-core/pull/1332#discussion_r511806034", "bodyText": "I would collect into a set.", "author": "mathbagu", "createdAt": "2020-10-26T09:02:47Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/SubstationIdMapping.java", "diffHunk": "@@ -10,70 +10,302 @@\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.HashMap;\n+import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n \n-import org.jgrapht.Graph;\n-import org.jgrapht.alg.connectivity.ConnectivityInspector;\n-import org.jgrapht.graph.Pseudograph;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import com.powsybl.cgmes.model.CgmesNames;\n import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.commons.PowsyblException;\n import com.powsybl.triplestore.api.PropertyBag;\n import com.powsybl.triplestore.api.PropertyBags;\n \n /**\n+ * CGMES standard: <br>\n+ * A PowerTransformer is contained in one Substation, but it can connect a Terminal to another different Substation <br>\n+ * A Switch can connect to different voltageLevels\n+ * <p>\n+ * IIDM Model: <br>\n+ * Ends of transformers need to be in the same substation<br>\n+ * Ends of switches need to be in the same voltageLevel\n+ * <p>\n+ * Solution: <br>\n+ * CGMES substations that are connected by transformers will be mapped to a single IIDM substation <br>\n+ * CGMES voltageLevels that are connected by switches will be mapped to a single IIDM voltageLevel\n+ * <p>\n+ * Example: <br>\n+ * We suppose that VL1, VL2, VL3, VL4, VL5, VL6 and VL7 are CGMES voltageLevels, <br>\n+ * Sw23 is a switch connecting voltageLevels VL2 and VL3, <br>\n+ * Sw34 is a switch connecting voltageLevels VL3 and VL4 and <br>\n+ * Sw67 is a switch connecting voltageLevels VL6 and VL7\n+ * <p>\n+ * Steps: <br>\n+ * Fill voltageLevelAdjacency Map <br>\n+ * Two voltageLevels are adjacent if they are connected by a switch <br>\n+ * The voltageLevelAdjacency Map will include the following records <br>\n+ * (VL1, []) <br>\n+ * (VL2, [VL2, VL3]) <br>\n+ * (VL3, [VL2, VL3, VL4]) <br>\n+ * (VL4, [VL3, VL4]) <br>\n+ * (VL5, []) <br>\n+ * (VL6, [VL6, VL7]) <br>\n+ * (VL7, [VL6, VL7]) <br>\n+ * <p>\n+ * For each non-visited VoltageLevel-key of the voltageLevelAdjacency Map all connected voltageLevels will be calculated  <br>\n+ * Two voltageLevels are connected if they are adjacent <br>\n+ * (allConnected method) <br>\n+ * All connected VoltageLevels to VL1 will be [VL1] <br>\n+ * All connected VoltageLevels to VL2 will be [VL2, VL3, VL4] <br>\n+ * All connected VoltageLevels to VL5 will be [VL5] <br>\n+ * All connected VoltageLevels to VL6 will be [VL6, VL7]\n+ * <p>\n+ * So the following voltageLevels should be merged <br>\n+ * [VL2, VL3, VL4] and the representative (IIDM voltageLevel) will be VL2 <br>\n+ * [VL6, VL7] and the representative (IIDM voltageLevel) will be VL6\n+ * <p>\n+ * And finally previous data is recorded in the voltageLevelMapping Map as <br>\n+ * (For each merged voltageLevel a record (merged voltageLevel, representative voltageLevel) is added) <br>\n+ * (VL3, VL2) <br>\n+ * (VL4, VL2) <br>\n+ * (VL7, VL6) <br>\n+ * <p>\n+ * The voltageLevelMapping Map will be used to assign the IIDM voltageLevel during the conversion process\n+ * <p>\n+ * The same algorithm is used to identify the substations that should be merged but: <br>\n+ * Two substations are adjacent if there is a transformer between them. <br>\n+ * The two substations associated with two adjacent voltageLevels, are adjacent if they are different substations.\n+ * <p>\n  * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n  */\n+\n public class SubstationIdMapping {\n \n     public SubstationIdMapping(Context context) {\n         this.context = context;\n-        this.mapping = new HashMap<>();\n+        this.substationMapping = new HashMap<>();\n+        this.voltageLevelMapping = new HashMap<>();\n     }\n \n-    public boolean isMapped(String cgmesIdentifier) {\n+    public boolean substationIsMapped(String cgmesIdentifier) {\n         String sid = context.namingStrategy().getId(CgmesNames.SUBSTATION, cgmesIdentifier);\n-        return mapping.containsKey(sid);\n+        return substationMapping.containsKey(sid);\n     }\n \n-    public String iidm(String cgmesIdentifier) {\n+    public String substationIidm(String cgmesIdentifier) {\n         String sid = context.namingStrategy().getId(CgmesNames.SUBSTATION, cgmesIdentifier);\n-        if (mapping.containsKey(sid)) {\n-            return mapping.get(sid);\n+        if (substationMapping.containsKey(sid)) {\n+            return substationMapping.get(sid);\n         }\n         return sid;\n     }\n \n+    // All the keys for a given value, all the merged substations that have cgmesIdentifier as representative\n+    public List<String> mergedSubstations(String cgmesIdentifier) {\n+        String sid = context.namingStrategy().getId(CgmesNames.SUBSTATION, cgmesIdentifier);\n+        return substationMapping.entrySet().stream().filter(record -> record.getValue().equals(sid))\n+            .map(Map.Entry::getKey).collect(Collectors.toList());", "originalCommit": "dcd8f2f57cc6d3552cad79800f38addb39c69bcb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE2MjU1MQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1332#discussion_r512162551", "bodyText": "Done", "author": "marqueslanauja", "createdAt": "2020-10-26T18:00:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgwNjAzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgwNjE0Nw==", "url": "https://github.com/powsybl/powsybl-core/pull/1332#discussion_r511806147", "bodyText": "I would collect to a set.", "author": "mathbagu", "createdAt": "2020-10-26T09:03:00Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/SubstationIdMapping.java", "diffHunk": "@@ -10,70 +10,302 @@\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.HashMap;\n+import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n \n-import org.jgrapht.Graph;\n-import org.jgrapht.alg.connectivity.ConnectivityInspector;\n-import org.jgrapht.graph.Pseudograph;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import com.powsybl.cgmes.model.CgmesNames;\n import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.commons.PowsyblException;\n import com.powsybl.triplestore.api.PropertyBag;\n import com.powsybl.triplestore.api.PropertyBags;\n \n /**\n+ * CGMES standard: <br>\n+ * A PowerTransformer is contained in one Substation, but it can connect a Terminal to another different Substation <br>\n+ * A Switch can connect to different voltageLevels\n+ * <p>\n+ * IIDM Model: <br>\n+ * Ends of transformers need to be in the same substation<br>\n+ * Ends of switches need to be in the same voltageLevel\n+ * <p>\n+ * Solution: <br>\n+ * CGMES substations that are connected by transformers will be mapped to a single IIDM substation <br>\n+ * CGMES voltageLevels that are connected by switches will be mapped to a single IIDM voltageLevel\n+ * <p>\n+ * Example: <br>\n+ * We suppose that VL1, VL2, VL3, VL4, VL5, VL6 and VL7 are CGMES voltageLevels, <br>\n+ * Sw23 is a switch connecting voltageLevels VL2 and VL3, <br>\n+ * Sw34 is a switch connecting voltageLevels VL3 and VL4 and <br>\n+ * Sw67 is a switch connecting voltageLevels VL6 and VL7\n+ * <p>\n+ * Steps: <br>\n+ * Fill voltageLevelAdjacency Map <br>\n+ * Two voltageLevels are adjacent if they are connected by a switch <br>\n+ * The voltageLevelAdjacency Map will include the following records <br>\n+ * (VL1, []) <br>\n+ * (VL2, [VL2, VL3]) <br>\n+ * (VL3, [VL2, VL3, VL4]) <br>\n+ * (VL4, [VL3, VL4]) <br>\n+ * (VL5, []) <br>\n+ * (VL6, [VL6, VL7]) <br>\n+ * (VL7, [VL6, VL7]) <br>\n+ * <p>\n+ * For each non-visited VoltageLevel-key of the voltageLevelAdjacency Map all connected voltageLevels will be calculated  <br>\n+ * Two voltageLevels are connected if they are adjacent <br>\n+ * (allConnected method) <br>\n+ * All connected VoltageLevels to VL1 will be [VL1] <br>\n+ * All connected VoltageLevels to VL2 will be [VL2, VL3, VL4] <br>\n+ * All connected VoltageLevels to VL5 will be [VL5] <br>\n+ * All connected VoltageLevels to VL6 will be [VL6, VL7]\n+ * <p>\n+ * So the following voltageLevels should be merged <br>\n+ * [VL2, VL3, VL4] and the representative (IIDM voltageLevel) will be VL2 <br>\n+ * [VL6, VL7] and the representative (IIDM voltageLevel) will be VL6\n+ * <p>\n+ * And finally previous data is recorded in the voltageLevelMapping Map as <br>\n+ * (For each merged voltageLevel a record (merged voltageLevel, representative voltageLevel) is added) <br>\n+ * (VL3, VL2) <br>\n+ * (VL4, VL2) <br>\n+ * (VL7, VL6) <br>\n+ * <p>\n+ * The voltageLevelMapping Map will be used to assign the IIDM voltageLevel during the conversion process\n+ * <p>\n+ * The same algorithm is used to identify the substations that should be merged but: <br>\n+ * Two substations are adjacent if there is a transformer between them. <br>\n+ * The two substations associated with two adjacent voltageLevels, are adjacent if they are different substations.\n+ * <p>\n  * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n  */\n+\n public class SubstationIdMapping {\n \n     public SubstationIdMapping(Context context) {\n         this.context = context;\n-        this.mapping = new HashMap<>();\n+        this.substationMapping = new HashMap<>();\n+        this.voltageLevelMapping = new HashMap<>();\n     }\n \n-    public boolean isMapped(String cgmesIdentifier) {\n+    public boolean substationIsMapped(String cgmesIdentifier) {\n         String sid = context.namingStrategy().getId(CgmesNames.SUBSTATION, cgmesIdentifier);\n-        return mapping.containsKey(sid);\n+        return substationMapping.containsKey(sid);\n     }\n \n-    public String iidm(String cgmesIdentifier) {\n+    public String substationIidm(String cgmesIdentifier) {\n         String sid = context.namingStrategy().getId(CgmesNames.SUBSTATION, cgmesIdentifier);\n-        if (mapping.containsKey(sid)) {\n-            return mapping.get(sid);\n+        if (substationMapping.containsKey(sid)) {\n+            return substationMapping.get(sid);\n         }\n         return sid;\n     }\n \n+    // All the keys for a given value, all the merged substations that have cgmesIdentifier as representative\n+    public List<String> mergedSubstations(String cgmesIdentifier) {\n+        String sid = context.namingStrategy().getId(CgmesNames.SUBSTATION, cgmesIdentifier);\n+        return substationMapping.entrySet().stream().filter(record -> record.getValue().equals(sid))\n+            .map(Map.Entry::getKey).collect(Collectors.toList());\n+    }\n+\n+    public boolean voltageLevelIsMapped(String cgmesIdentifier) {\n+        String vlid = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, cgmesIdentifier);\n+        return voltageLevelMapping.containsKey(vlid);\n+    }\n+\n+    public String voltageLevelIidm(String cgmesIdentifier) {\n+        String vlid = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, cgmesIdentifier);\n+        if (voltageLevelMapping.containsKey(vlid)) {\n+            return voltageLevelMapping.get(vlid);\n+        }\n+        return vlid;\n+    }\n+\n+    // All the keys for a given value, all the merged voltageLevels that have cgmesIdentifier as representative\n+    public List<String> mergedVoltageLevels(String cgmesIdentifier) {\n+        String vlid = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, cgmesIdentifier);\n+        return voltageLevelMapping.entrySet().stream().filter(record -> record.getValue().equals(vlid))\n+            .map(Map.Entry::getKey).collect(Collectors.toList());", "originalCommit": "dcd8f2f57cc6d3552cad79800f38addb39c69bcb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE2Mjc0Mw==", "url": "https://github.com/powsybl/powsybl-core/pull/1332#discussion_r512162743", "bodyText": "Done", "author": "marqueslanauja", "createdAt": "2020-10-26T18:00:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgwNjE0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgwNzgzMQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1332#discussion_r511807831", "bodyText": "I would write voltageLevelAdjacency.put(vid, new ArrayList<>());\nHere, we are sure that the key is absent, so it's not necessary to check it", "author": "mathbagu", "createdAt": "2020-10-26T09:06:06Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/SubstationIdMapping.java", "diffHunk": "@@ -10,70 +10,302 @@\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.HashMap;\n+import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n \n-import org.jgrapht.Graph;\n-import org.jgrapht.alg.connectivity.ConnectivityInspector;\n-import org.jgrapht.graph.Pseudograph;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import com.powsybl.cgmes.model.CgmesNames;\n import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.commons.PowsyblException;\n import com.powsybl.triplestore.api.PropertyBag;\n import com.powsybl.triplestore.api.PropertyBags;\n \n /**\n+ * CGMES standard: <br>\n+ * A PowerTransformer is contained in one Substation, but it can connect a Terminal to another different Substation <br>\n+ * A Switch can connect to different voltageLevels\n+ * <p>\n+ * IIDM Model: <br>\n+ * Ends of transformers need to be in the same substation<br>\n+ * Ends of switches need to be in the same voltageLevel\n+ * <p>\n+ * Solution: <br>\n+ * CGMES substations that are connected by transformers will be mapped to a single IIDM substation <br>\n+ * CGMES voltageLevels that are connected by switches will be mapped to a single IIDM voltageLevel\n+ * <p>\n+ * Example: <br>\n+ * We suppose that VL1, VL2, VL3, VL4, VL5, VL6 and VL7 are CGMES voltageLevels, <br>\n+ * Sw23 is a switch connecting voltageLevels VL2 and VL3, <br>\n+ * Sw34 is a switch connecting voltageLevels VL3 and VL4 and <br>\n+ * Sw67 is a switch connecting voltageLevels VL6 and VL7\n+ * <p>\n+ * Steps: <br>\n+ * Fill voltageLevelAdjacency Map <br>\n+ * Two voltageLevels are adjacent if they are connected by a switch <br>\n+ * The voltageLevelAdjacency Map will include the following records <br>\n+ * (VL1, []) <br>\n+ * (VL2, [VL2, VL3]) <br>\n+ * (VL3, [VL2, VL3, VL4]) <br>\n+ * (VL4, [VL3, VL4]) <br>\n+ * (VL5, []) <br>\n+ * (VL6, [VL6, VL7]) <br>\n+ * (VL7, [VL6, VL7]) <br>\n+ * <p>\n+ * For each non-visited VoltageLevel-key of the voltageLevelAdjacency Map all connected voltageLevels will be calculated  <br>\n+ * Two voltageLevels are connected if they are adjacent <br>\n+ * (allConnected method) <br>\n+ * All connected VoltageLevels to VL1 will be [VL1] <br>\n+ * All connected VoltageLevels to VL2 will be [VL2, VL3, VL4] <br>\n+ * All connected VoltageLevels to VL5 will be [VL5] <br>\n+ * All connected VoltageLevels to VL6 will be [VL6, VL7]\n+ * <p>\n+ * So the following voltageLevels should be merged <br>\n+ * [VL2, VL3, VL4] and the representative (IIDM voltageLevel) will be VL2 <br>\n+ * [VL6, VL7] and the representative (IIDM voltageLevel) will be VL6\n+ * <p>\n+ * And finally previous data is recorded in the voltageLevelMapping Map as <br>\n+ * (For each merged voltageLevel a record (merged voltageLevel, representative voltageLevel) is added) <br>\n+ * (VL3, VL2) <br>\n+ * (VL4, VL2) <br>\n+ * (VL7, VL6) <br>\n+ * <p>\n+ * The voltageLevelMapping Map will be used to assign the IIDM voltageLevel during the conversion process\n+ * <p>\n+ * The same algorithm is used to identify the substations that should be merged but: <br>\n+ * Two substations are adjacent if there is a transformer between them. <br>\n+ * The two substations associated with two adjacent voltageLevels, are adjacent if they are different substations.\n+ * <p>\n  * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n  */\n+\n public class SubstationIdMapping {\n \n     public SubstationIdMapping(Context context) {\n         this.context = context;\n-        this.mapping = new HashMap<>();\n+        this.substationMapping = new HashMap<>();\n+        this.voltageLevelMapping = new HashMap<>();\n     }\n \n-    public boolean isMapped(String cgmesIdentifier) {\n+    public boolean substationIsMapped(String cgmesIdentifier) {\n         String sid = context.namingStrategy().getId(CgmesNames.SUBSTATION, cgmesIdentifier);\n-        return mapping.containsKey(sid);\n+        return substationMapping.containsKey(sid);\n     }\n \n-    public String iidm(String cgmesIdentifier) {\n+    public String substationIidm(String cgmesIdentifier) {\n         String sid = context.namingStrategy().getId(CgmesNames.SUBSTATION, cgmesIdentifier);\n-        if (mapping.containsKey(sid)) {\n-            return mapping.get(sid);\n+        if (substationMapping.containsKey(sid)) {\n+            return substationMapping.get(sid);\n         }\n         return sid;\n     }\n \n+    // All the keys for a given value, all the merged substations that have cgmesIdentifier as representative\n+    public List<String> mergedSubstations(String cgmesIdentifier) {\n+        String sid = context.namingStrategy().getId(CgmesNames.SUBSTATION, cgmesIdentifier);\n+        return substationMapping.entrySet().stream().filter(record -> record.getValue().equals(sid))\n+            .map(Map.Entry::getKey).collect(Collectors.toList());\n+    }\n+\n+    public boolean voltageLevelIsMapped(String cgmesIdentifier) {\n+        String vlid = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, cgmesIdentifier);\n+        return voltageLevelMapping.containsKey(vlid);\n+    }\n+\n+    public String voltageLevelIidm(String cgmesIdentifier) {\n+        String vlid = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, cgmesIdentifier);\n+        if (voltageLevelMapping.containsKey(vlid)) {\n+            return voltageLevelMapping.get(vlid);\n+        }\n+        return vlid;\n+    }\n+\n+    // All the keys for a given value, all the merged voltageLevels that have cgmesIdentifier as representative\n+    public List<String> mergedVoltageLevels(String cgmesIdentifier) {\n+        String vlid = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, cgmesIdentifier);\n+        return voltageLevelMapping.entrySet().stream().filter(record -> record.getValue().equals(vlid))\n+            .map(Map.Entry::getKey).collect(Collectors.toList());\n+    }\n+\n     public void build() {\n-        // CGMES standard:\n-        // \"a PowerTransformer is contained in one Substation but it can connect a Terminal to\n-        // another Substation\"\n-        // Ends of transformers need to be in the same substation in the IIDM model.\n-        // We will map some CGMES substations to a single IIDM substation\n-        // when they are connected by transformers,\n-        // that is, when there are at least one power transformer that has terminals on both\n-        // substations\n-\n-        Graph<String, Object> g = graphSubstationsTransformers();\n-        new ConnectivityInspector<>(g).connectedSets().stream()\n-                .filter(substationIds -> substationIds.size() > 1)\n-                .forEach(substationIds -> {\n-                    String selectedSubstationId = representativeSubstationId(substationIds);\n-                    for (String substationId : substationIds) {\n-                        if (!substationId.equals(selectedSubstationId)) {\n-                            mapping.put(substationId, selectedSubstationId);\n-                        }\n+        Map<String, List<String>> voltageLevelAdjacency = new HashMap<>();\n+        Map<String, List<String>> substationAdjacency = new HashMap<>();\n+\n+        buildAdjacency(voltageLevelAdjacency, substationAdjacency);\n+        buildVoltageLevel(voltageLevelAdjacency);\n+        buildSubstation(substationAdjacency);\n+    }\n+\n+    private void buildAdjacency(Map<String, List<String>> voltageLevelAdjacency,\n+        Map<String, List<String>> substationAdjacency) {\n+        context.cgmes().voltageLevels().forEach(vl -> addVoltageLevel(voltageLevelAdjacency, vl));\n+        context.cgmes().substations().forEach(st -> addSubstation(substationAdjacency, st));\n+\n+        context.cgmes().switches().forEach(sw -> addSwitch(voltageLevelAdjacency, substationAdjacency, sw));\n+        context.cgmes().groupedTransformerEnds().forEach((t, tends) -> addEnds(substationAdjacency, tends));\n+    }\n+\n+    private void addVoltageLevel(Map<String, List<String>> voltageLevelAdjacency, PropertyBag vl) {\n+        String voltageLevelId = vl.getId(CgmesNames.VOLTAGE_LEVEL);\n+        String vId = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, voltageLevelId);\n+        voltageLevelAdjacency.computeIfAbsent(vId, k -> new ArrayList<>());", "originalCommit": "dcd8f2f57cc6d3552cad79800f38addb39c69bcb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE2Mjg1Ng==", "url": "https://github.com/powsybl/powsybl-core/pull/1332#discussion_r512162856", "bodyText": "Done", "author": "marqueslanauja", "createdAt": "2020-10-26T18:00:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgwNzgzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgwNzkyMA==", "url": "https://github.com/powsybl/powsybl-core/pull/1332#discussion_r511807920", "bodyText": "I would write voltageLevelAdjacency.put(vid, new ArrayList<>());\nHere, we are sure that the key is absent, so it's not necessary to check it", "author": "mathbagu", "createdAt": "2020-10-26T09:06:14Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/SubstationIdMapping.java", "diffHunk": "@@ -10,70 +10,302 @@\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.HashMap;\n+import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n \n-import org.jgrapht.Graph;\n-import org.jgrapht.alg.connectivity.ConnectivityInspector;\n-import org.jgrapht.graph.Pseudograph;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import com.powsybl.cgmes.model.CgmesNames;\n import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.commons.PowsyblException;\n import com.powsybl.triplestore.api.PropertyBag;\n import com.powsybl.triplestore.api.PropertyBags;\n \n /**\n+ * CGMES standard: <br>\n+ * A PowerTransformer is contained in one Substation, but it can connect a Terminal to another different Substation <br>\n+ * A Switch can connect to different voltageLevels\n+ * <p>\n+ * IIDM Model: <br>\n+ * Ends of transformers need to be in the same substation<br>\n+ * Ends of switches need to be in the same voltageLevel\n+ * <p>\n+ * Solution: <br>\n+ * CGMES substations that are connected by transformers will be mapped to a single IIDM substation <br>\n+ * CGMES voltageLevels that are connected by switches will be mapped to a single IIDM voltageLevel\n+ * <p>\n+ * Example: <br>\n+ * We suppose that VL1, VL2, VL3, VL4, VL5, VL6 and VL7 are CGMES voltageLevels, <br>\n+ * Sw23 is a switch connecting voltageLevels VL2 and VL3, <br>\n+ * Sw34 is a switch connecting voltageLevels VL3 and VL4 and <br>\n+ * Sw67 is a switch connecting voltageLevels VL6 and VL7\n+ * <p>\n+ * Steps: <br>\n+ * Fill voltageLevelAdjacency Map <br>\n+ * Two voltageLevels are adjacent if they are connected by a switch <br>\n+ * The voltageLevelAdjacency Map will include the following records <br>\n+ * (VL1, []) <br>\n+ * (VL2, [VL2, VL3]) <br>\n+ * (VL3, [VL2, VL3, VL4]) <br>\n+ * (VL4, [VL3, VL4]) <br>\n+ * (VL5, []) <br>\n+ * (VL6, [VL6, VL7]) <br>\n+ * (VL7, [VL6, VL7]) <br>\n+ * <p>\n+ * For each non-visited VoltageLevel-key of the voltageLevelAdjacency Map all connected voltageLevels will be calculated  <br>\n+ * Two voltageLevels are connected if they are adjacent <br>\n+ * (allConnected method) <br>\n+ * All connected VoltageLevels to VL1 will be [VL1] <br>\n+ * All connected VoltageLevels to VL2 will be [VL2, VL3, VL4] <br>\n+ * All connected VoltageLevels to VL5 will be [VL5] <br>\n+ * All connected VoltageLevels to VL6 will be [VL6, VL7]\n+ * <p>\n+ * So the following voltageLevels should be merged <br>\n+ * [VL2, VL3, VL4] and the representative (IIDM voltageLevel) will be VL2 <br>\n+ * [VL6, VL7] and the representative (IIDM voltageLevel) will be VL6\n+ * <p>\n+ * And finally previous data is recorded in the voltageLevelMapping Map as <br>\n+ * (For each merged voltageLevel a record (merged voltageLevel, representative voltageLevel) is added) <br>\n+ * (VL3, VL2) <br>\n+ * (VL4, VL2) <br>\n+ * (VL7, VL6) <br>\n+ * <p>\n+ * The voltageLevelMapping Map will be used to assign the IIDM voltageLevel during the conversion process\n+ * <p>\n+ * The same algorithm is used to identify the substations that should be merged but: <br>\n+ * Two substations are adjacent if there is a transformer between them. <br>\n+ * The two substations associated with two adjacent voltageLevels, are adjacent if they are different substations.\n+ * <p>\n  * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n  */\n+\n public class SubstationIdMapping {\n \n     public SubstationIdMapping(Context context) {\n         this.context = context;\n-        this.mapping = new HashMap<>();\n+        this.substationMapping = new HashMap<>();\n+        this.voltageLevelMapping = new HashMap<>();\n     }\n \n-    public boolean isMapped(String cgmesIdentifier) {\n+    public boolean substationIsMapped(String cgmesIdentifier) {\n         String sid = context.namingStrategy().getId(CgmesNames.SUBSTATION, cgmesIdentifier);\n-        return mapping.containsKey(sid);\n+        return substationMapping.containsKey(sid);\n     }\n \n-    public String iidm(String cgmesIdentifier) {\n+    public String substationIidm(String cgmesIdentifier) {\n         String sid = context.namingStrategy().getId(CgmesNames.SUBSTATION, cgmesIdentifier);\n-        if (mapping.containsKey(sid)) {\n-            return mapping.get(sid);\n+        if (substationMapping.containsKey(sid)) {\n+            return substationMapping.get(sid);\n         }\n         return sid;\n     }\n \n+    // All the keys for a given value, all the merged substations that have cgmesIdentifier as representative\n+    public List<String> mergedSubstations(String cgmesIdentifier) {\n+        String sid = context.namingStrategy().getId(CgmesNames.SUBSTATION, cgmesIdentifier);\n+        return substationMapping.entrySet().stream().filter(record -> record.getValue().equals(sid))\n+            .map(Map.Entry::getKey).collect(Collectors.toList());\n+    }\n+\n+    public boolean voltageLevelIsMapped(String cgmesIdentifier) {\n+        String vlid = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, cgmesIdentifier);\n+        return voltageLevelMapping.containsKey(vlid);\n+    }\n+\n+    public String voltageLevelIidm(String cgmesIdentifier) {\n+        String vlid = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, cgmesIdentifier);\n+        if (voltageLevelMapping.containsKey(vlid)) {\n+            return voltageLevelMapping.get(vlid);\n+        }\n+        return vlid;\n+    }\n+\n+    // All the keys for a given value, all the merged voltageLevels that have cgmesIdentifier as representative\n+    public List<String> mergedVoltageLevels(String cgmesIdentifier) {\n+        String vlid = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, cgmesIdentifier);\n+        return voltageLevelMapping.entrySet().stream().filter(record -> record.getValue().equals(vlid))\n+            .map(Map.Entry::getKey).collect(Collectors.toList());\n+    }\n+\n     public void build() {\n-        // CGMES standard:\n-        // \"a PowerTransformer is contained in one Substation but it can connect a Terminal to\n-        // another Substation\"\n-        // Ends of transformers need to be in the same substation in the IIDM model.\n-        // We will map some CGMES substations to a single IIDM substation\n-        // when they are connected by transformers,\n-        // that is, when there are at least one power transformer that has terminals on both\n-        // substations\n-\n-        Graph<String, Object> g = graphSubstationsTransformers();\n-        new ConnectivityInspector<>(g).connectedSets().stream()\n-                .filter(substationIds -> substationIds.size() > 1)\n-                .forEach(substationIds -> {\n-                    String selectedSubstationId = representativeSubstationId(substationIds);\n-                    for (String substationId : substationIds) {\n-                        if (!substationId.equals(selectedSubstationId)) {\n-                            mapping.put(substationId, selectedSubstationId);\n-                        }\n+        Map<String, List<String>> voltageLevelAdjacency = new HashMap<>();\n+        Map<String, List<String>> substationAdjacency = new HashMap<>();\n+\n+        buildAdjacency(voltageLevelAdjacency, substationAdjacency);\n+        buildVoltageLevel(voltageLevelAdjacency);\n+        buildSubstation(substationAdjacency);\n+    }\n+\n+    private void buildAdjacency(Map<String, List<String>> voltageLevelAdjacency,\n+        Map<String, List<String>> substationAdjacency) {\n+        context.cgmes().voltageLevels().forEach(vl -> addVoltageLevel(voltageLevelAdjacency, vl));\n+        context.cgmes().substations().forEach(st -> addSubstation(substationAdjacency, st));\n+\n+        context.cgmes().switches().forEach(sw -> addSwitch(voltageLevelAdjacency, substationAdjacency, sw));\n+        context.cgmes().groupedTransformerEnds().forEach((t, tends) -> addEnds(substationAdjacency, tends));\n+    }\n+\n+    private void addVoltageLevel(Map<String, List<String>> voltageLevelAdjacency, PropertyBag vl) {\n+        String voltageLevelId = vl.getId(CgmesNames.VOLTAGE_LEVEL);\n+        String vId = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, voltageLevelId);\n+        voltageLevelAdjacency.computeIfAbsent(vId, k -> new ArrayList<>());\n+    }\n+\n+    private void addSubstation(Map<String, List<String>> substationAdjacency, PropertyBag sub) {\n+        String substationlId = sub.getId(CgmesNames.SUBSTATION);\n+        String subId = context.namingStrategy().getId(CgmesNames.SUBSTATION, substationlId);\n+        substationAdjacency.computeIfAbsent(subId, k -> new ArrayList<>());", "originalCommit": "dcd8f2f57cc6d3552cad79800f38addb39c69bcb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE2Mjk2Mw==", "url": "https://github.com/powsybl/powsybl-core/pull/1332#discussion_r512162963", "bodyText": "Done", "author": "marqueslanauja", "createdAt": "2020-10-26T18:00:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgwNzkyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgwOTI1Nw==", "url": "https://github.com/powsybl/powsybl-core/pull/1332#discussion_r511809257", "bodyText": "From my point of view, to avoid duplicates we should use Map<String, Set<String>>", "author": "mathbagu", "createdAt": "2020-10-26T09:08:30Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/SubstationIdMapping.java", "diffHunk": "@@ -10,70 +10,302 @@\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.HashMap;\n+import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n \n-import org.jgrapht.Graph;\n-import org.jgrapht.alg.connectivity.ConnectivityInspector;\n-import org.jgrapht.graph.Pseudograph;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import com.powsybl.cgmes.model.CgmesNames;\n import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.commons.PowsyblException;\n import com.powsybl.triplestore.api.PropertyBag;\n import com.powsybl.triplestore.api.PropertyBags;\n \n /**\n+ * CGMES standard: <br>\n+ * A PowerTransformer is contained in one Substation, but it can connect a Terminal to another different Substation <br>\n+ * A Switch can connect to different voltageLevels\n+ * <p>\n+ * IIDM Model: <br>\n+ * Ends of transformers need to be in the same substation<br>\n+ * Ends of switches need to be in the same voltageLevel\n+ * <p>\n+ * Solution: <br>\n+ * CGMES substations that are connected by transformers will be mapped to a single IIDM substation <br>\n+ * CGMES voltageLevels that are connected by switches will be mapped to a single IIDM voltageLevel\n+ * <p>\n+ * Example: <br>\n+ * We suppose that VL1, VL2, VL3, VL4, VL5, VL6 and VL7 are CGMES voltageLevels, <br>\n+ * Sw23 is a switch connecting voltageLevels VL2 and VL3, <br>\n+ * Sw34 is a switch connecting voltageLevels VL3 and VL4 and <br>\n+ * Sw67 is a switch connecting voltageLevels VL6 and VL7\n+ * <p>\n+ * Steps: <br>\n+ * Fill voltageLevelAdjacency Map <br>\n+ * Two voltageLevels are adjacent if they are connected by a switch <br>\n+ * The voltageLevelAdjacency Map will include the following records <br>\n+ * (VL1, []) <br>\n+ * (VL2, [VL2, VL3]) <br>\n+ * (VL3, [VL2, VL3, VL4]) <br>\n+ * (VL4, [VL3, VL4]) <br>\n+ * (VL5, []) <br>\n+ * (VL6, [VL6, VL7]) <br>\n+ * (VL7, [VL6, VL7]) <br>\n+ * <p>\n+ * For each non-visited VoltageLevel-key of the voltageLevelAdjacency Map all connected voltageLevels will be calculated  <br>\n+ * Two voltageLevels are connected if they are adjacent <br>\n+ * (allConnected method) <br>\n+ * All connected VoltageLevels to VL1 will be [VL1] <br>\n+ * All connected VoltageLevels to VL2 will be [VL2, VL3, VL4] <br>\n+ * All connected VoltageLevels to VL5 will be [VL5] <br>\n+ * All connected VoltageLevels to VL6 will be [VL6, VL7]\n+ * <p>\n+ * So the following voltageLevels should be merged <br>\n+ * [VL2, VL3, VL4] and the representative (IIDM voltageLevel) will be VL2 <br>\n+ * [VL6, VL7] and the representative (IIDM voltageLevel) will be VL6\n+ * <p>\n+ * And finally previous data is recorded in the voltageLevelMapping Map as <br>\n+ * (For each merged voltageLevel a record (merged voltageLevel, representative voltageLevel) is added) <br>\n+ * (VL3, VL2) <br>\n+ * (VL4, VL2) <br>\n+ * (VL7, VL6) <br>\n+ * <p>\n+ * The voltageLevelMapping Map will be used to assign the IIDM voltageLevel during the conversion process\n+ * <p>\n+ * The same algorithm is used to identify the substations that should be merged but: <br>\n+ * Two substations are adjacent if there is a transformer between them. <br>\n+ * The two substations associated with two adjacent voltageLevels, are adjacent if they are different substations.\n+ * <p>\n  * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n  */\n+\n public class SubstationIdMapping {\n \n     public SubstationIdMapping(Context context) {\n         this.context = context;\n-        this.mapping = new HashMap<>();\n+        this.substationMapping = new HashMap<>();\n+        this.voltageLevelMapping = new HashMap<>();\n     }\n \n-    public boolean isMapped(String cgmesIdentifier) {\n+    public boolean substationIsMapped(String cgmesIdentifier) {\n         String sid = context.namingStrategy().getId(CgmesNames.SUBSTATION, cgmesIdentifier);\n-        return mapping.containsKey(sid);\n+        return substationMapping.containsKey(sid);\n     }\n \n-    public String iidm(String cgmesIdentifier) {\n+    public String substationIidm(String cgmesIdentifier) {\n         String sid = context.namingStrategy().getId(CgmesNames.SUBSTATION, cgmesIdentifier);\n-        if (mapping.containsKey(sid)) {\n-            return mapping.get(sid);\n+        if (substationMapping.containsKey(sid)) {\n+            return substationMapping.get(sid);\n         }\n         return sid;\n     }\n \n+    // All the keys for a given value, all the merged substations that have cgmesIdentifier as representative\n+    public List<String> mergedSubstations(String cgmesIdentifier) {\n+        String sid = context.namingStrategy().getId(CgmesNames.SUBSTATION, cgmesIdentifier);\n+        return substationMapping.entrySet().stream().filter(record -> record.getValue().equals(sid))\n+            .map(Map.Entry::getKey).collect(Collectors.toList());\n+    }\n+\n+    public boolean voltageLevelIsMapped(String cgmesIdentifier) {\n+        String vlid = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, cgmesIdentifier);\n+        return voltageLevelMapping.containsKey(vlid);\n+    }\n+\n+    public String voltageLevelIidm(String cgmesIdentifier) {\n+        String vlid = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, cgmesIdentifier);\n+        if (voltageLevelMapping.containsKey(vlid)) {\n+            return voltageLevelMapping.get(vlid);\n+        }\n+        return vlid;\n+    }\n+\n+    // All the keys for a given value, all the merged voltageLevels that have cgmesIdentifier as representative\n+    public List<String> mergedVoltageLevels(String cgmesIdentifier) {\n+        String vlid = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, cgmesIdentifier);\n+        return voltageLevelMapping.entrySet().stream().filter(record -> record.getValue().equals(vlid))\n+            .map(Map.Entry::getKey).collect(Collectors.toList());\n+    }\n+\n     public void build() {\n-        // CGMES standard:\n-        // \"a PowerTransformer is contained in one Substation but it can connect a Terminal to\n-        // another Substation\"\n-        // Ends of transformers need to be in the same substation in the IIDM model.\n-        // We will map some CGMES substations to a single IIDM substation\n-        // when they are connected by transformers,\n-        // that is, when there are at least one power transformer that has terminals on both\n-        // substations\n-\n-        Graph<String, Object> g = graphSubstationsTransformers();\n-        new ConnectivityInspector<>(g).connectedSets().stream()\n-                .filter(substationIds -> substationIds.size() > 1)\n-                .forEach(substationIds -> {\n-                    String selectedSubstationId = representativeSubstationId(substationIds);\n-                    for (String substationId : substationIds) {\n-                        if (!substationId.equals(selectedSubstationId)) {\n-                            mapping.put(substationId, selectedSubstationId);\n-                        }\n+        Map<String, List<String>> voltageLevelAdjacency = new HashMap<>();\n+        Map<String, List<String>> substationAdjacency = new HashMap<>();", "originalCommit": "dcd8f2f57cc6d3552cad79800f38addb39c69bcb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE2MzA4MA==", "url": "https://github.com/powsybl/powsybl-core/pull/1332#discussion_r512163080", "bodyText": "Done", "author": "marqueslanauja", "createdAt": "2020-10-26T18:01:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgwOTI1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgwOTk3MQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1332#discussion_r511809971", "bodyText": "Maybe this utility function is used elsewhere (maybe it already exists). Could we move it outside this class?", "author": "mathbagu", "createdAt": "2020-10-26T09:09:44Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/SubstationIdMapping.java", "diffHunk": "@@ -10,70 +10,302 @@\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.HashMap;\n+import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n \n-import org.jgrapht.Graph;\n-import org.jgrapht.alg.connectivity.ConnectivityInspector;\n-import org.jgrapht.graph.Pseudograph;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import com.powsybl.cgmes.model.CgmesNames;\n import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.commons.PowsyblException;\n import com.powsybl.triplestore.api.PropertyBag;\n import com.powsybl.triplestore.api.PropertyBags;\n \n /**\n+ * CGMES standard: <br>\n+ * A PowerTransformer is contained in one Substation, but it can connect a Terminal to another different Substation <br>\n+ * A Switch can connect to different voltageLevels\n+ * <p>\n+ * IIDM Model: <br>\n+ * Ends of transformers need to be in the same substation<br>\n+ * Ends of switches need to be in the same voltageLevel\n+ * <p>\n+ * Solution: <br>\n+ * CGMES substations that are connected by transformers will be mapped to a single IIDM substation <br>\n+ * CGMES voltageLevels that are connected by switches will be mapped to a single IIDM voltageLevel\n+ * <p>\n+ * Example: <br>\n+ * We suppose that VL1, VL2, VL3, VL4, VL5, VL6 and VL7 are CGMES voltageLevels, <br>\n+ * Sw23 is a switch connecting voltageLevels VL2 and VL3, <br>\n+ * Sw34 is a switch connecting voltageLevels VL3 and VL4 and <br>\n+ * Sw67 is a switch connecting voltageLevels VL6 and VL7\n+ * <p>\n+ * Steps: <br>\n+ * Fill voltageLevelAdjacency Map <br>\n+ * Two voltageLevels are adjacent if they are connected by a switch <br>\n+ * The voltageLevelAdjacency Map will include the following records <br>\n+ * (VL1, []) <br>\n+ * (VL2, [VL2, VL3]) <br>\n+ * (VL3, [VL2, VL3, VL4]) <br>\n+ * (VL4, [VL3, VL4]) <br>\n+ * (VL5, []) <br>\n+ * (VL6, [VL6, VL7]) <br>\n+ * (VL7, [VL6, VL7]) <br>\n+ * <p>\n+ * For each non-visited VoltageLevel-key of the voltageLevelAdjacency Map all connected voltageLevels will be calculated  <br>\n+ * Two voltageLevels are connected if they are adjacent <br>\n+ * (allConnected method) <br>\n+ * All connected VoltageLevels to VL1 will be [VL1] <br>\n+ * All connected VoltageLevels to VL2 will be [VL2, VL3, VL4] <br>\n+ * All connected VoltageLevels to VL5 will be [VL5] <br>\n+ * All connected VoltageLevels to VL6 will be [VL6, VL7]\n+ * <p>\n+ * So the following voltageLevels should be merged <br>\n+ * [VL2, VL3, VL4] and the representative (IIDM voltageLevel) will be VL2 <br>\n+ * [VL6, VL7] and the representative (IIDM voltageLevel) will be VL6\n+ * <p>\n+ * And finally previous data is recorded in the voltageLevelMapping Map as <br>\n+ * (For each merged voltageLevel a record (merged voltageLevel, representative voltageLevel) is added) <br>\n+ * (VL3, VL2) <br>\n+ * (VL4, VL2) <br>\n+ * (VL7, VL6) <br>\n+ * <p>\n+ * The voltageLevelMapping Map will be used to assign the IIDM voltageLevel during the conversion process\n+ * <p>\n+ * The same algorithm is used to identify the substations that should be merged but: <br>\n+ * Two substations are adjacent if there is a transformer between them. <br>\n+ * The two substations associated with two adjacent voltageLevels, are adjacent if they are different substations.\n+ * <p>\n  * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n  */\n+\n public class SubstationIdMapping {\n \n     public SubstationIdMapping(Context context) {\n         this.context = context;\n-        this.mapping = new HashMap<>();\n+        this.substationMapping = new HashMap<>();\n+        this.voltageLevelMapping = new HashMap<>();\n     }\n \n-    public boolean isMapped(String cgmesIdentifier) {\n+    public boolean substationIsMapped(String cgmesIdentifier) {\n         String sid = context.namingStrategy().getId(CgmesNames.SUBSTATION, cgmesIdentifier);\n-        return mapping.containsKey(sid);\n+        return substationMapping.containsKey(sid);\n     }\n \n-    public String iidm(String cgmesIdentifier) {\n+    public String substationIidm(String cgmesIdentifier) {\n         String sid = context.namingStrategy().getId(CgmesNames.SUBSTATION, cgmesIdentifier);\n-        if (mapping.containsKey(sid)) {\n-            return mapping.get(sid);\n+        if (substationMapping.containsKey(sid)) {\n+            return substationMapping.get(sid);\n         }\n         return sid;\n     }\n \n+    // All the keys for a given value, all the merged substations that have cgmesIdentifier as representative\n+    public List<String> mergedSubstations(String cgmesIdentifier) {\n+        String sid = context.namingStrategy().getId(CgmesNames.SUBSTATION, cgmesIdentifier);\n+        return substationMapping.entrySet().stream().filter(record -> record.getValue().equals(sid))\n+            .map(Map.Entry::getKey).collect(Collectors.toList());\n+    }\n+\n+    public boolean voltageLevelIsMapped(String cgmesIdentifier) {\n+        String vlid = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, cgmesIdentifier);\n+        return voltageLevelMapping.containsKey(vlid);\n+    }\n+\n+    public String voltageLevelIidm(String cgmesIdentifier) {\n+        String vlid = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, cgmesIdentifier);\n+        if (voltageLevelMapping.containsKey(vlid)) {\n+            return voltageLevelMapping.get(vlid);\n+        }\n+        return vlid;\n+    }\n+\n+    // All the keys for a given value, all the merged voltageLevels that have cgmesIdentifier as representative\n+    public List<String> mergedVoltageLevels(String cgmesIdentifier) {\n+        String vlid = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, cgmesIdentifier);\n+        return voltageLevelMapping.entrySet().stream().filter(record -> record.getValue().equals(vlid))\n+            .map(Map.Entry::getKey).collect(Collectors.toList());\n+    }\n+\n     public void build() {\n-        // CGMES standard:\n-        // \"a PowerTransformer is contained in one Substation but it can connect a Terminal to\n-        // another Substation\"\n-        // Ends of transformers need to be in the same substation in the IIDM model.\n-        // We will map some CGMES substations to a single IIDM substation\n-        // when they are connected by transformers,\n-        // that is, when there are at least one power transformer that has terminals on both\n-        // substations\n-\n-        Graph<String, Object> g = graphSubstationsTransformers();\n-        new ConnectivityInspector<>(g).connectedSets().stream()\n-                .filter(substationIds -> substationIds.size() > 1)\n-                .forEach(substationIds -> {\n-                    String selectedSubstationId = representativeSubstationId(substationIds);\n-                    for (String substationId : substationIds) {\n-                        if (!substationId.equals(selectedSubstationId)) {\n-                            mapping.put(substationId, selectedSubstationId);\n-                        }\n+        Map<String, List<String>> voltageLevelAdjacency = new HashMap<>();\n+        Map<String, List<String>> substationAdjacency = new HashMap<>();\n+\n+        buildAdjacency(voltageLevelAdjacency, substationAdjacency);\n+        buildVoltageLevel(voltageLevelAdjacency);\n+        buildSubstation(substationAdjacency);\n+    }\n+\n+    private void buildAdjacency(Map<String, List<String>> voltageLevelAdjacency,\n+        Map<String, List<String>> substationAdjacency) {\n+        context.cgmes().voltageLevels().forEach(vl -> addVoltageLevel(voltageLevelAdjacency, vl));\n+        context.cgmes().substations().forEach(st -> addSubstation(substationAdjacency, st));\n+\n+        context.cgmes().switches().forEach(sw -> addSwitch(voltageLevelAdjacency, substationAdjacency, sw));\n+        context.cgmes().groupedTransformerEnds().forEach((t, tends) -> addEnds(substationAdjacency, tends));\n+    }\n+\n+    private void addVoltageLevel(Map<String, List<String>> voltageLevelAdjacency, PropertyBag vl) {\n+        String voltageLevelId = vl.getId(CgmesNames.VOLTAGE_LEVEL);\n+        String vId = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, voltageLevelId);\n+        voltageLevelAdjacency.computeIfAbsent(vId, k -> new ArrayList<>());\n+    }\n+\n+    private void addSubstation(Map<String, List<String>> substationAdjacency, PropertyBag sub) {\n+        String substationlId = sub.getId(CgmesNames.SUBSTATION);\n+        String subId = context.namingStrategy().getId(CgmesNames.SUBSTATION, substationlId);\n+        substationAdjacency.computeIfAbsent(subId, k -> new ArrayList<>());\n+    }\n+\n+    // Two different voltageLevels are adjacent if they are connected by a switch\n+    // If the corresponding substations are different they are also adjacent\n+    private void addSwitch(Map<String, List<String>> voltageLevelAdjacency,\n+        Map<String, List<String>> substationAdjacency, PropertyBag sw) {\n+\n+        CgmesTerminal t1 = context.cgmes().terminal(sw.getId(CgmesNames.TERMINAL + 1));\n+        String node1 = context.nodeBreaker() ? t1.connectivityNode() : t1.topologicalNode();\n+        String voltageLevelId1 = getVoltageLevelFromNode(node1, t1);\n+\n+        CgmesTerminal t2 = context.cgmes().terminal(sw.getId(CgmesNames.TERMINAL + 2));\n+        String node2 = context.nodeBreaker() ? t2.connectivityNode() : t2.topologicalNode();\n+        String voltageLevelId2 = getVoltageLevelFromNode(node2, t2);\n+\n+        // Null could be received as voltageLevel at the boundary\n+        if (voltageLevelId1 == null || voltageLevelId2 == null || voltageLevelId1.equals(voltageLevelId2)) {\n+            return;\n+        }\n+        addAdjacency(voltageLevelAdjacency, voltageLevelId1, voltageLevelId2);\n+\n+        String substationId1 = context.cgmes().substation(t1, context.nodeBreaker());\n+        String substationId2 = context.cgmes().substation(t2, context.nodeBreaker());\n+\n+        // Null could be received as substation at the boundary\n+        if (substationId1 == null || substationId2 == null || substationId1.equals(substationId2)) {\n+            return;\n+        }\n+        addAdjacency(substationAdjacency, substationId1, substationId2);\n+    }\n+\n+    private String getVoltageLevelFromNode(String node, CgmesTerminal t) {\n+        String voltageLevelId = null;\n+        if (node != null && !context.boundary().containsNode(node)) {\n+            voltageLevelId = context.cgmes().voltageLevel(t, context.nodeBreaker());\n+        }\n+        return voltageLevelId;\n+    }", "originalCommit": "dcd8f2f57cc6d3552cad79800f38addb39c69bcb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE2MzIzOQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1332#discussion_r512163239", "bodyText": "Done", "author": "marqueslanauja", "createdAt": "2020-10-26T18:01:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgwOTk3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgxOTAxOQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1332#discussion_r511819019", "bodyText": "If sub(0)'s content is equal to sub(i)'s content, that means the two substations are the same? Why isn't sufficient enough to put the substations IDs in a set and call addAdjacency for all couple?\nWhen substationsIds contains three different values (3WT), I'm not sure your proposal works well: it creates the following association (0,1), (1, 0), (0, 2) and (2, 0) but not (1, 2) and (2, 1). Is it correct?", "author": "mathbagu", "createdAt": "2020-10-26T09:24:39Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/SubstationIdMapping.java", "diffHunk": "@@ -10,70 +10,302 @@\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.HashMap;\n+import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n \n-import org.jgrapht.Graph;\n-import org.jgrapht.alg.connectivity.ConnectivityInspector;\n-import org.jgrapht.graph.Pseudograph;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import com.powsybl.cgmes.model.CgmesNames;\n import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.commons.PowsyblException;\n import com.powsybl.triplestore.api.PropertyBag;\n import com.powsybl.triplestore.api.PropertyBags;\n \n /**\n+ * CGMES standard: <br>\n+ * A PowerTransformer is contained in one Substation, but it can connect a Terminal to another different Substation <br>\n+ * A Switch can connect to different voltageLevels\n+ * <p>\n+ * IIDM Model: <br>\n+ * Ends of transformers need to be in the same substation<br>\n+ * Ends of switches need to be in the same voltageLevel\n+ * <p>\n+ * Solution: <br>\n+ * CGMES substations that are connected by transformers will be mapped to a single IIDM substation <br>\n+ * CGMES voltageLevels that are connected by switches will be mapped to a single IIDM voltageLevel\n+ * <p>\n+ * Example: <br>\n+ * We suppose that VL1, VL2, VL3, VL4, VL5, VL6 and VL7 are CGMES voltageLevels, <br>\n+ * Sw23 is a switch connecting voltageLevels VL2 and VL3, <br>\n+ * Sw34 is a switch connecting voltageLevels VL3 and VL4 and <br>\n+ * Sw67 is a switch connecting voltageLevels VL6 and VL7\n+ * <p>\n+ * Steps: <br>\n+ * Fill voltageLevelAdjacency Map <br>\n+ * Two voltageLevels are adjacent if they are connected by a switch <br>\n+ * The voltageLevelAdjacency Map will include the following records <br>\n+ * (VL1, []) <br>\n+ * (VL2, [VL2, VL3]) <br>\n+ * (VL3, [VL2, VL3, VL4]) <br>\n+ * (VL4, [VL3, VL4]) <br>\n+ * (VL5, []) <br>\n+ * (VL6, [VL6, VL7]) <br>\n+ * (VL7, [VL6, VL7]) <br>\n+ * <p>\n+ * For each non-visited VoltageLevel-key of the voltageLevelAdjacency Map all connected voltageLevels will be calculated  <br>\n+ * Two voltageLevels are connected if they are adjacent <br>\n+ * (allConnected method) <br>\n+ * All connected VoltageLevels to VL1 will be [VL1] <br>\n+ * All connected VoltageLevels to VL2 will be [VL2, VL3, VL4] <br>\n+ * All connected VoltageLevels to VL5 will be [VL5] <br>\n+ * All connected VoltageLevels to VL6 will be [VL6, VL7]\n+ * <p>\n+ * So the following voltageLevels should be merged <br>\n+ * [VL2, VL3, VL4] and the representative (IIDM voltageLevel) will be VL2 <br>\n+ * [VL6, VL7] and the representative (IIDM voltageLevel) will be VL6\n+ * <p>\n+ * And finally previous data is recorded in the voltageLevelMapping Map as <br>\n+ * (For each merged voltageLevel a record (merged voltageLevel, representative voltageLevel) is added) <br>\n+ * (VL3, VL2) <br>\n+ * (VL4, VL2) <br>\n+ * (VL7, VL6) <br>\n+ * <p>\n+ * The voltageLevelMapping Map will be used to assign the IIDM voltageLevel during the conversion process\n+ * <p>\n+ * The same algorithm is used to identify the substations that should be merged but: <br>\n+ * Two substations are adjacent if there is a transformer between them. <br>\n+ * The two substations associated with two adjacent voltageLevels, are adjacent if they are different substations.\n+ * <p>\n  * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n  */\n+\n public class SubstationIdMapping {\n \n     public SubstationIdMapping(Context context) {\n         this.context = context;\n-        this.mapping = new HashMap<>();\n+        this.substationMapping = new HashMap<>();\n+        this.voltageLevelMapping = new HashMap<>();\n     }\n \n-    public boolean isMapped(String cgmesIdentifier) {\n+    public boolean substationIsMapped(String cgmesIdentifier) {\n         String sid = context.namingStrategy().getId(CgmesNames.SUBSTATION, cgmesIdentifier);\n-        return mapping.containsKey(sid);\n+        return substationMapping.containsKey(sid);\n     }\n \n-    public String iidm(String cgmesIdentifier) {\n+    public String substationIidm(String cgmesIdentifier) {\n         String sid = context.namingStrategy().getId(CgmesNames.SUBSTATION, cgmesIdentifier);\n-        if (mapping.containsKey(sid)) {\n-            return mapping.get(sid);\n+        if (substationMapping.containsKey(sid)) {\n+            return substationMapping.get(sid);\n         }\n         return sid;\n     }\n \n+    // All the keys for a given value, all the merged substations that have cgmesIdentifier as representative\n+    public List<String> mergedSubstations(String cgmesIdentifier) {\n+        String sid = context.namingStrategy().getId(CgmesNames.SUBSTATION, cgmesIdentifier);\n+        return substationMapping.entrySet().stream().filter(record -> record.getValue().equals(sid))\n+            .map(Map.Entry::getKey).collect(Collectors.toList());\n+    }\n+\n+    public boolean voltageLevelIsMapped(String cgmesIdentifier) {\n+        String vlid = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, cgmesIdentifier);\n+        return voltageLevelMapping.containsKey(vlid);\n+    }\n+\n+    public String voltageLevelIidm(String cgmesIdentifier) {\n+        String vlid = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, cgmesIdentifier);\n+        if (voltageLevelMapping.containsKey(vlid)) {\n+            return voltageLevelMapping.get(vlid);\n+        }\n+        return vlid;\n+    }\n+\n+    // All the keys for a given value, all the merged voltageLevels that have cgmesIdentifier as representative\n+    public List<String> mergedVoltageLevels(String cgmesIdentifier) {\n+        String vlid = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, cgmesIdentifier);\n+        return voltageLevelMapping.entrySet().stream().filter(record -> record.getValue().equals(vlid))\n+            .map(Map.Entry::getKey).collect(Collectors.toList());\n+    }\n+\n     public void build() {\n-        // CGMES standard:\n-        // \"a PowerTransformer is contained in one Substation but it can connect a Terminal to\n-        // another Substation\"\n-        // Ends of transformers need to be in the same substation in the IIDM model.\n-        // We will map some CGMES substations to a single IIDM substation\n-        // when they are connected by transformers,\n-        // that is, when there are at least one power transformer that has terminals on both\n-        // substations\n-\n-        Graph<String, Object> g = graphSubstationsTransformers();\n-        new ConnectivityInspector<>(g).connectedSets().stream()\n-                .filter(substationIds -> substationIds.size() > 1)\n-                .forEach(substationIds -> {\n-                    String selectedSubstationId = representativeSubstationId(substationIds);\n-                    for (String substationId : substationIds) {\n-                        if (!substationId.equals(selectedSubstationId)) {\n-                            mapping.put(substationId, selectedSubstationId);\n-                        }\n+        Map<String, List<String>> voltageLevelAdjacency = new HashMap<>();\n+        Map<String, List<String>> substationAdjacency = new HashMap<>();\n+\n+        buildAdjacency(voltageLevelAdjacency, substationAdjacency);\n+        buildVoltageLevel(voltageLevelAdjacency);\n+        buildSubstation(substationAdjacency);\n+    }\n+\n+    private void buildAdjacency(Map<String, List<String>> voltageLevelAdjacency,\n+        Map<String, List<String>> substationAdjacency) {\n+        context.cgmes().voltageLevels().forEach(vl -> addVoltageLevel(voltageLevelAdjacency, vl));\n+        context.cgmes().substations().forEach(st -> addSubstation(substationAdjacency, st));\n+\n+        context.cgmes().switches().forEach(sw -> addSwitch(voltageLevelAdjacency, substationAdjacency, sw));\n+        context.cgmes().groupedTransformerEnds().forEach((t, tends) -> addEnds(substationAdjacency, tends));\n+    }\n+\n+    private void addVoltageLevel(Map<String, List<String>> voltageLevelAdjacency, PropertyBag vl) {\n+        String voltageLevelId = vl.getId(CgmesNames.VOLTAGE_LEVEL);\n+        String vId = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, voltageLevelId);\n+        voltageLevelAdjacency.computeIfAbsent(vId, k -> new ArrayList<>());\n+    }\n+\n+    private void addSubstation(Map<String, List<String>> substationAdjacency, PropertyBag sub) {\n+        String substationlId = sub.getId(CgmesNames.SUBSTATION);\n+        String subId = context.namingStrategy().getId(CgmesNames.SUBSTATION, substationlId);\n+        substationAdjacency.computeIfAbsent(subId, k -> new ArrayList<>());\n+    }\n+\n+    // Two different voltageLevels are adjacent if they are connected by a switch\n+    // If the corresponding substations are different they are also adjacent\n+    private void addSwitch(Map<String, List<String>> voltageLevelAdjacency,\n+        Map<String, List<String>> substationAdjacency, PropertyBag sw) {\n+\n+        CgmesTerminal t1 = context.cgmes().terminal(sw.getId(CgmesNames.TERMINAL + 1));\n+        String node1 = context.nodeBreaker() ? t1.connectivityNode() : t1.topologicalNode();\n+        String voltageLevelId1 = getVoltageLevelFromNode(node1, t1);\n+\n+        CgmesTerminal t2 = context.cgmes().terminal(sw.getId(CgmesNames.TERMINAL + 2));\n+        String node2 = context.nodeBreaker() ? t2.connectivityNode() : t2.topologicalNode();\n+        String voltageLevelId2 = getVoltageLevelFromNode(node2, t2);\n+\n+        // Null could be received as voltageLevel at the boundary\n+        if (voltageLevelId1 == null || voltageLevelId2 == null || voltageLevelId1.equals(voltageLevelId2)) {\n+            return;\n+        }\n+        addAdjacency(voltageLevelAdjacency, voltageLevelId1, voltageLevelId2);\n+\n+        String substationId1 = context.cgmes().substation(t1, context.nodeBreaker());\n+        String substationId2 = context.cgmes().substation(t2, context.nodeBreaker());\n+\n+        // Null could be received as substation at the boundary\n+        if (substationId1 == null || substationId2 == null || substationId1.equals(substationId2)) {\n+            return;\n+        }\n+        addAdjacency(substationAdjacency, substationId1, substationId2);\n+    }\n+\n+    private String getVoltageLevelFromNode(String node, CgmesTerminal t) {\n+        String voltageLevelId = null;\n+        if (node != null && !context.boundary().containsNode(node)) {\n+            voltageLevelId = context.cgmes().voltageLevel(t, context.nodeBreaker());\n+        }\n+        return voltageLevelId;\n+    }\n+\n+    // Two different substations are adjacent if they are connected by a transformer\n+    private void addEnds(Map<String, List<String>> substationAdjacency, PropertyBags tends) {\n+        List<String> substationsIds = substationsIds(tends);\n+        if (substationsIds.size() <= 1) {\n+            return;\n+        }\n+        String sub0 = substationsIds.get(0);\n+        for (int i = 1; i < substationsIds.size(); i++) {\n+            String subi = substationsIds.get(i);\n+\n+            if (sub0.contentEquals(subi)) {", "originalCommit": "dcd8f2f57cc6d3552cad79800f38addb39c69bcb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE2NTczNw==", "url": "https://github.com/powsybl/powsybl-core/pull/1332#discussion_r512165737", "bodyText": "The code is ok. We only need to connect the three substations (0, 1, and 2), so associating the substation 0 with the substations 1 and 2 is enough.", "author": "marqueslanauja", "createdAt": "2020-10-26T18:05:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgxOTAxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgxOTY5MA==", "url": "https://github.com/powsybl/powsybl-core/pull/1332#discussion_r511819690", "bodyText": "Using lambda is not necessary here. Replace the forEach by a classic for-loop to increase readability, or use functional code as much as you can.", "author": "mathbagu", "createdAt": "2020-10-26T09:25:43Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/SubstationIdMapping.java", "diffHunk": "@@ -10,70 +10,302 @@\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.HashMap;\n+import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n \n-import org.jgrapht.Graph;\n-import org.jgrapht.alg.connectivity.ConnectivityInspector;\n-import org.jgrapht.graph.Pseudograph;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import com.powsybl.cgmes.model.CgmesNames;\n import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.commons.PowsyblException;\n import com.powsybl.triplestore.api.PropertyBag;\n import com.powsybl.triplestore.api.PropertyBags;\n \n /**\n+ * CGMES standard: <br>\n+ * A PowerTransformer is contained in one Substation, but it can connect a Terminal to another different Substation <br>\n+ * A Switch can connect to different voltageLevels\n+ * <p>\n+ * IIDM Model: <br>\n+ * Ends of transformers need to be in the same substation<br>\n+ * Ends of switches need to be in the same voltageLevel\n+ * <p>\n+ * Solution: <br>\n+ * CGMES substations that are connected by transformers will be mapped to a single IIDM substation <br>\n+ * CGMES voltageLevels that are connected by switches will be mapped to a single IIDM voltageLevel\n+ * <p>\n+ * Example: <br>\n+ * We suppose that VL1, VL2, VL3, VL4, VL5, VL6 and VL7 are CGMES voltageLevels, <br>\n+ * Sw23 is a switch connecting voltageLevels VL2 and VL3, <br>\n+ * Sw34 is a switch connecting voltageLevels VL3 and VL4 and <br>\n+ * Sw67 is a switch connecting voltageLevels VL6 and VL7\n+ * <p>\n+ * Steps: <br>\n+ * Fill voltageLevelAdjacency Map <br>\n+ * Two voltageLevels are adjacent if they are connected by a switch <br>\n+ * The voltageLevelAdjacency Map will include the following records <br>\n+ * (VL1, []) <br>\n+ * (VL2, [VL2, VL3]) <br>\n+ * (VL3, [VL2, VL3, VL4]) <br>\n+ * (VL4, [VL3, VL4]) <br>\n+ * (VL5, []) <br>\n+ * (VL6, [VL6, VL7]) <br>\n+ * (VL7, [VL6, VL7]) <br>\n+ * <p>\n+ * For each non-visited VoltageLevel-key of the voltageLevelAdjacency Map all connected voltageLevels will be calculated  <br>\n+ * Two voltageLevels are connected if they are adjacent <br>\n+ * (allConnected method) <br>\n+ * All connected VoltageLevels to VL1 will be [VL1] <br>\n+ * All connected VoltageLevels to VL2 will be [VL2, VL3, VL4] <br>\n+ * All connected VoltageLevels to VL5 will be [VL5] <br>\n+ * All connected VoltageLevels to VL6 will be [VL6, VL7]\n+ * <p>\n+ * So the following voltageLevels should be merged <br>\n+ * [VL2, VL3, VL4] and the representative (IIDM voltageLevel) will be VL2 <br>\n+ * [VL6, VL7] and the representative (IIDM voltageLevel) will be VL6\n+ * <p>\n+ * And finally previous data is recorded in the voltageLevelMapping Map as <br>\n+ * (For each merged voltageLevel a record (merged voltageLevel, representative voltageLevel) is added) <br>\n+ * (VL3, VL2) <br>\n+ * (VL4, VL2) <br>\n+ * (VL7, VL6) <br>\n+ * <p>\n+ * The voltageLevelMapping Map will be used to assign the IIDM voltageLevel during the conversion process\n+ * <p>\n+ * The same algorithm is used to identify the substations that should be merged but: <br>\n+ * Two substations are adjacent if there is a transformer between them. <br>\n+ * The two substations associated with two adjacent voltageLevels, are adjacent if they are different substations.\n+ * <p>\n  * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n  */\n+\n public class SubstationIdMapping {\n \n     public SubstationIdMapping(Context context) {\n         this.context = context;\n-        this.mapping = new HashMap<>();\n+        this.substationMapping = new HashMap<>();\n+        this.voltageLevelMapping = new HashMap<>();\n     }\n \n-    public boolean isMapped(String cgmesIdentifier) {\n+    public boolean substationIsMapped(String cgmesIdentifier) {\n         String sid = context.namingStrategy().getId(CgmesNames.SUBSTATION, cgmesIdentifier);\n-        return mapping.containsKey(sid);\n+        return substationMapping.containsKey(sid);\n     }\n \n-    public String iidm(String cgmesIdentifier) {\n+    public String substationIidm(String cgmesIdentifier) {\n         String sid = context.namingStrategy().getId(CgmesNames.SUBSTATION, cgmesIdentifier);\n-        if (mapping.containsKey(sid)) {\n-            return mapping.get(sid);\n+        if (substationMapping.containsKey(sid)) {\n+            return substationMapping.get(sid);\n         }\n         return sid;\n     }\n \n+    // All the keys for a given value, all the merged substations that have cgmesIdentifier as representative\n+    public List<String> mergedSubstations(String cgmesIdentifier) {\n+        String sid = context.namingStrategy().getId(CgmesNames.SUBSTATION, cgmesIdentifier);\n+        return substationMapping.entrySet().stream().filter(record -> record.getValue().equals(sid))\n+            .map(Map.Entry::getKey).collect(Collectors.toList());\n+    }\n+\n+    public boolean voltageLevelIsMapped(String cgmesIdentifier) {\n+        String vlid = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, cgmesIdentifier);\n+        return voltageLevelMapping.containsKey(vlid);\n+    }\n+\n+    public String voltageLevelIidm(String cgmesIdentifier) {\n+        String vlid = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, cgmesIdentifier);\n+        if (voltageLevelMapping.containsKey(vlid)) {\n+            return voltageLevelMapping.get(vlid);\n+        }\n+        return vlid;\n+    }\n+\n+    // All the keys for a given value, all the merged voltageLevels that have cgmesIdentifier as representative\n+    public List<String> mergedVoltageLevels(String cgmesIdentifier) {\n+        String vlid = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, cgmesIdentifier);\n+        return voltageLevelMapping.entrySet().stream().filter(record -> record.getValue().equals(vlid))\n+            .map(Map.Entry::getKey).collect(Collectors.toList());\n+    }\n+\n     public void build() {\n-        // CGMES standard:\n-        // \"a PowerTransformer is contained in one Substation but it can connect a Terminal to\n-        // another Substation\"\n-        // Ends of transformers need to be in the same substation in the IIDM model.\n-        // We will map some CGMES substations to a single IIDM substation\n-        // when they are connected by transformers,\n-        // that is, when there are at least one power transformer that has terminals on both\n-        // substations\n-\n-        Graph<String, Object> g = graphSubstationsTransformers();\n-        new ConnectivityInspector<>(g).connectedSets().stream()\n-                .filter(substationIds -> substationIds.size() > 1)\n-                .forEach(substationIds -> {\n-                    String selectedSubstationId = representativeSubstationId(substationIds);\n-                    for (String substationId : substationIds) {\n-                        if (!substationId.equals(selectedSubstationId)) {\n-                            mapping.put(substationId, selectedSubstationId);\n-                        }\n+        Map<String, List<String>> voltageLevelAdjacency = new HashMap<>();\n+        Map<String, List<String>> substationAdjacency = new HashMap<>();\n+\n+        buildAdjacency(voltageLevelAdjacency, substationAdjacency);\n+        buildVoltageLevel(voltageLevelAdjacency);\n+        buildSubstation(substationAdjacency);\n+    }\n+\n+    private void buildAdjacency(Map<String, List<String>> voltageLevelAdjacency,\n+        Map<String, List<String>> substationAdjacency) {\n+        context.cgmes().voltageLevels().forEach(vl -> addVoltageLevel(voltageLevelAdjacency, vl));\n+        context.cgmes().substations().forEach(st -> addSubstation(substationAdjacency, st));\n+\n+        context.cgmes().switches().forEach(sw -> addSwitch(voltageLevelAdjacency, substationAdjacency, sw));\n+        context.cgmes().groupedTransformerEnds().forEach((t, tends) -> addEnds(substationAdjacency, tends));\n+    }\n+\n+    private void addVoltageLevel(Map<String, List<String>> voltageLevelAdjacency, PropertyBag vl) {\n+        String voltageLevelId = vl.getId(CgmesNames.VOLTAGE_LEVEL);\n+        String vId = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, voltageLevelId);\n+        voltageLevelAdjacency.computeIfAbsent(vId, k -> new ArrayList<>());\n+    }\n+\n+    private void addSubstation(Map<String, List<String>> substationAdjacency, PropertyBag sub) {\n+        String substationlId = sub.getId(CgmesNames.SUBSTATION);\n+        String subId = context.namingStrategy().getId(CgmesNames.SUBSTATION, substationlId);\n+        substationAdjacency.computeIfAbsent(subId, k -> new ArrayList<>());\n+    }\n+\n+    // Two different voltageLevels are adjacent if they are connected by a switch\n+    // If the corresponding substations are different they are also adjacent\n+    private void addSwitch(Map<String, List<String>> voltageLevelAdjacency,\n+        Map<String, List<String>> substationAdjacency, PropertyBag sw) {\n+\n+        CgmesTerminal t1 = context.cgmes().terminal(sw.getId(CgmesNames.TERMINAL + 1));\n+        String node1 = context.nodeBreaker() ? t1.connectivityNode() : t1.topologicalNode();\n+        String voltageLevelId1 = getVoltageLevelFromNode(node1, t1);\n+\n+        CgmesTerminal t2 = context.cgmes().terminal(sw.getId(CgmesNames.TERMINAL + 2));\n+        String node2 = context.nodeBreaker() ? t2.connectivityNode() : t2.topologicalNode();\n+        String voltageLevelId2 = getVoltageLevelFromNode(node2, t2);\n+\n+        // Null could be received as voltageLevel at the boundary\n+        if (voltageLevelId1 == null || voltageLevelId2 == null || voltageLevelId1.equals(voltageLevelId2)) {\n+            return;\n+        }\n+        addAdjacency(voltageLevelAdjacency, voltageLevelId1, voltageLevelId2);\n+\n+        String substationId1 = context.cgmes().substation(t1, context.nodeBreaker());\n+        String substationId2 = context.cgmes().substation(t2, context.nodeBreaker());\n+\n+        // Null could be received as substation at the boundary\n+        if (substationId1 == null || substationId2 == null || substationId1.equals(substationId2)) {\n+            return;\n+        }\n+        addAdjacency(substationAdjacency, substationId1, substationId2);\n+    }\n+\n+    private String getVoltageLevelFromNode(String node, CgmesTerminal t) {\n+        String voltageLevelId = null;\n+        if (node != null && !context.boundary().containsNode(node)) {\n+            voltageLevelId = context.cgmes().voltageLevel(t, context.nodeBreaker());\n+        }\n+        return voltageLevelId;\n+    }\n+\n+    // Two different substations are adjacent if they are connected by a transformer\n+    private void addEnds(Map<String, List<String>> substationAdjacency, PropertyBags tends) {\n+        List<String> substationsIds = substationsIds(tends);\n+        if (substationsIds.size() <= 1) {\n+            return;\n+        }\n+        String sub0 = substationsIds.get(0);\n+        for (int i = 1; i < substationsIds.size(); i++) {\n+            String subi = substationsIds.get(i);\n+\n+            if (sub0.contentEquals(subi)) {\n+                continue;\n+            }\n+            addAdjacency(substationAdjacency, sub0, subi);\n+        }\n+    }\n+\n+    // Record in the adjacency Map that \"id1 is adjacent to id2\" and \"id2 is adjacent to id1\"\n+    private static void addAdjacency(Map<String, List<String>> adjacency, String id1, String id2) {\n+        List<String> ad1 = adjacency.get(id1);\n+        if (ad1 == null) {\n+            throw new PowsyblException(\"Unexpected reference to Substation or voltageLevel \" + id1\n+                + \". It has not been defined in CGMES substations / voltageLevels.\");\n+        }\n+        List<String> ad2 = adjacency.get(id2);\n+        if (ad2 == null) {\n+            throw new PowsyblException(\"Unexpected reference to Substation or voltageLevel \" + id2\n+                + \". It has not been defined in CGMES substations / voltageLevels.\");\n+        }\n+\n+        ad1.add(id2);\n+        ad2.add(id1);\n+    }\n+\n+    private void buildVoltageLevel(Map<String, List<String>> voltageLevelAdjacency) {\n+        Set<String> visitedVoltageLevels = new HashSet<>();\n+        voltageLevelAdjacency.keySet().forEach(vl -> {\n+            if (!visitedVoltageLevels.contains(vl)) {\n+                ArrayList<String> vlAds = allConnected(voltageLevelAdjacency, visitedVoltageLevels, vl);\n+                String selectedVoltageLevelId = representativeVoltageLevelId(vlAds);\n+                for (String voltageLevelId : vlAds) {\n+                    if (!voltageLevelId.equals(selectedVoltageLevelId)) {\n+                        voltageLevelMapping.put(voltageLevelId, selectedVoltageLevelId);\n                     }\n-                });\n-        if (!mapping.isEmpty()) {\n+                }\n+            }\n+        });", "originalCommit": "dcd8f2f57cc6d3552cad79800f38addb39c69bcb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE2NTk2Mw==", "url": "https://github.com/powsybl/powsybl-core/pull/1332#discussion_r512165963", "bodyText": "Done", "author": "marqueslanauja", "createdAt": "2020-10-26T18:05:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgxOTY5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgyMDE4Mw==", "url": "https://github.com/powsybl/powsybl-core/pull/1332#discussion_r511820183", "bodyText": "Same remark here", "author": "mathbagu", "createdAt": "2020-10-26T09:26:34Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/SubstationIdMapping.java", "diffHunk": "@@ -10,70 +10,302 @@\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.HashMap;\n+import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n \n-import org.jgrapht.Graph;\n-import org.jgrapht.alg.connectivity.ConnectivityInspector;\n-import org.jgrapht.graph.Pseudograph;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import com.powsybl.cgmes.model.CgmesNames;\n import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.commons.PowsyblException;\n import com.powsybl.triplestore.api.PropertyBag;\n import com.powsybl.triplestore.api.PropertyBags;\n \n /**\n+ * CGMES standard: <br>\n+ * A PowerTransformer is contained in one Substation, but it can connect a Terminal to another different Substation <br>\n+ * A Switch can connect to different voltageLevels\n+ * <p>\n+ * IIDM Model: <br>\n+ * Ends of transformers need to be in the same substation<br>\n+ * Ends of switches need to be in the same voltageLevel\n+ * <p>\n+ * Solution: <br>\n+ * CGMES substations that are connected by transformers will be mapped to a single IIDM substation <br>\n+ * CGMES voltageLevels that are connected by switches will be mapped to a single IIDM voltageLevel\n+ * <p>\n+ * Example: <br>\n+ * We suppose that VL1, VL2, VL3, VL4, VL5, VL6 and VL7 are CGMES voltageLevels, <br>\n+ * Sw23 is a switch connecting voltageLevels VL2 and VL3, <br>\n+ * Sw34 is a switch connecting voltageLevels VL3 and VL4 and <br>\n+ * Sw67 is a switch connecting voltageLevels VL6 and VL7\n+ * <p>\n+ * Steps: <br>\n+ * Fill voltageLevelAdjacency Map <br>\n+ * Two voltageLevels are adjacent if they are connected by a switch <br>\n+ * The voltageLevelAdjacency Map will include the following records <br>\n+ * (VL1, []) <br>\n+ * (VL2, [VL2, VL3]) <br>\n+ * (VL3, [VL2, VL3, VL4]) <br>\n+ * (VL4, [VL3, VL4]) <br>\n+ * (VL5, []) <br>\n+ * (VL6, [VL6, VL7]) <br>\n+ * (VL7, [VL6, VL7]) <br>\n+ * <p>\n+ * For each non-visited VoltageLevel-key of the voltageLevelAdjacency Map all connected voltageLevels will be calculated  <br>\n+ * Two voltageLevels are connected if they are adjacent <br>\n+ * (allConnected method) <br>\n+ * All connected VoltageLevels to VL1 will be [VL1] <br>\n+ * All connected VoltageLevels to VL2 will be [VL2, VL3, VL4] <br>\n+ * All connected VoltageLevels to VL5 will be [VL5] <br>\n+ * All connected VoltageLevels to VL6 will be [VL6, VL7]\n+ * <p>\n+ * So the following voltageLevels should be merged <br>\n+ * [VL2, VL3, VL4] and the representative (IIDM voltageLevel) will be VL2 <br>\n+ * [VL6, VL7] and the representative (IIDM voltageLevel) will be VL6\n+ * <p>\n+ * And finally previous data is recorded in the voltageLevelMapping Map as <br>\n+ * (For each merged voltageLevel a record (merged voltageLevel, representative voltageLevel) is added) <br>\n+ * (VL3, VL2) <br>\n+ * (VL4, VL2) <br>\n+ * (VL7, VL6) <br>\n+ * <p>\n+ * The voltageLevelMapping Map will be used to assign the IIDM voltageLevel during the conversion process\n+ * <p>\n+ * The same algorithm is used to identify the substations that should be merged but: <br>\n+ * Two substations are adjacent if there is a transformer between them. <br>\n+ * The two substations associated with two adjacent voltageLevels, are adjacent if they are different substations.\n+ * <p>\n  * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n  */\n+\n public class SubstationIdMapping {\n \n     public SubstationIdMapping(Context context) {\n         this.context = context;\n-        this.mapping = new HashMap<>();\n+        this.substationMapping = new HashMap<>();\n+        this.voltageLevelMapping = new HashMap<>();\n     }\n \n-    public boolean isMapped(String cgmesIdentifier) {\n+    public boolean substationIsMapped(String cgmesIdentifier) {\n         String sid = context.namingStrategy().getId(CgmesNames.SUBSTATION, cgmesIdentifier);\n-        return mapping.containsKey(sid);\n+        return substationMapping.containsKey(sid);\n     }\n \n-    public String iidm(String cgmesIdentifier) {\n+    public String substationIidm(String cgmesIdentifier) {\n         String sid = context.namingStrategy().getId(CgmesNames.SUBSTATION, cgmesIdentifier);\n-        if (mapping.containsKey(sid)) {\n-            return mapping.get(sid);\n+        if (substationMapping.containsKey(sid)) {\n+            return substationMapping.get(sid);\n         }\n         return sid;\n     }\n \n+    // All the keys for a given value, all the merged substations that have cgmesIdentifier as representative\n+    public List<String> mergedSubstations(String cgmesIdentifier) {\n+        String sid = context.namingStrategy().getId(CgmesNames.SUBSTATION, cgmesIdentifier);\n+        return substationMapping.entrySet().stream().filter(record -> record.getValue().equals(sid))\n+            .map(Map.Entry::getKey).collect(Collectors.toList());\n+    }\n+\n+    public boolean voltageLevelIsMapped(String cgmesIdentifier) {\n+        String vlid = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, cgmesIdentifier);\n+        return voltageLevelMapping.containsKey(vlid);\n+    }\n+\n+    public String voltageLevelIidm(String cgmesIdentifier) {\n+        String vlid = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, cgmesIdentifier);\n+        if (voltageLevelMapping.containsKey(vlid)) {\n+            return voltageLevelMapping.get(vlid);\n+        }\n+        return vlid;\n+    }\n+\n+    // All the keys for a given value, all the merged voltageLevels that have cgmesIdentifier as representative\n+    public List<String> mergedVoltageLevels(String cgmesIdentifier) {\n+        String vlid = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, cgmesIdentifier);\n+        return voltageLevelMapping.entrySet().stream().filter(record -> record.getValue().equals(vlid))\n+            .map(Map.Entry::getKey).collect(Collectors.toList());\n+    }\n+\n     public void build() {\n-        // CGMES standard:\n-        // \"a PowerTransformer is contained in one Substation but it can connect a Terminal to\n-        // another Substation\"\n-        // Ends of transformers need to be in the same substation in the IIDM model.\n-        // We will map some CGMES substations to a single IIDM substation\n-        // when they are connected by transformers,\n-        // that is, when there are at least one power transformer that has terminals on both\n-        // substations\n-\n-        Graph<String, Object> g = graphSubstationsTransformers();\n-        new ConnectivityInspector<>(g).connectedSets().stream()\n-                .filter(substationIds -> substationIds.size() > 1)\n-                .forEach(substationIds -> {\n-                    String selectedSubstationId = representativeSubstationId(substationIds);\n-                    for (String substationId : substationIds) {\n-                        if (!substationId.equals(selectedSubstationId)) {\n-                            mapping.put(substationId, selectedSubstationId);\n-                        }\n+        Map<String, List<String>> voltageLevelAdjacency = new HashMap<>();\n+        Map<String, List<String>> substationAdjacency = new HashMap<>();\n+\n+        buildAdjacency(voltageLevelAdjacency, substationAdjacency);\n+        buildVoltageLevel(voltageLevelAdjacency);\n+        buildSubstation(substationAdjacency);\n+    }\n+\n+    private void buildAdjacency(Map<String, List<String>> voltageLevelAdjacency,\n+        Map<String, List<String>> substationAdjacency) {\n+        context.cgmes().voltageLevels().forEach(vl -> addVoltageLevel(voltageLevelAdjacency, vl));\n+        context.cgmes().substations().forEach(st -> addSubstation(substationAdjacency, st));\n+\n+        context.cgmes().switches().forEach(sw -> addSwitch(voltageLevelAdjacency, substationAdjacency, sw));\n+        context.cgmes().groupedTransformerEnds().forEach((t, tends) -> addEnds(substationAdjacency, tends));\n+    }\n+\n+    private void addVoltageLevel(Map<String, List<String>> voltageLevelAdjacency, PropertyBag vl) {\n+        String voltageLevelId = vl.getId(CgmesNames.VOLTAGE_LEVEL);\n+        String vId = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, voltageLevelId);\n+        voltageLevelAdjacency.computeIfAbsent(vId, k -> new ArrayList<>());\n+    }\n+\n+    private void addSubstation(Map<String, List<String>> substationAdjacency, PropertyBag sub) {\n+        String substationlId = sub.getId(CgmesNames.SUBSTATION);\n+        String subId = context.namingStrategy().getId(CgmesNames.SUBSTATION, substationlId);\n+        substationAdjacency.computeIfAbsent(subId, k -> new ArrayList<>());\n+    }\n+\n+    // Two different voltageLevels are adjacent if they are connected by a switch\n+    // If the corresponding substations are different they are also adjacent\n+    private void addSwitch(Map<String, List<String>> voltageLevelAdjacency,\n+        Map<String, List<String>> substationAdjacency, PropertyBag sw) {\n+\n+        CgmesTerminal t1 = context.cgmes().terminal(sw.getId(CgmesNames.TERMINAL + 1));\n+        String node1 = context.nodeBreaker() ? t1.connectivityNode() : t1.topologicalNode();\n+        String voltageLevelId1 = getVoltageLevelFromNode(node1, t1);\n+\n+        CgmesTerminal t2 = context.cgmes().terminal(sw.getId(CgmesNames.TERMINAL + 2));\n+        String node2 = context.nodeBreaker() ? t2.connectivityNode() : t2.topologicalNode();\n+        String voltageLevelId2 = getVoltageLevelFromNode(node2, t2);\n+\n+        // Null could be received as voltageLevel at the boundary\n+        if (voltageLevelId1 == null || voltageLevelId2 == null || voltageLevelId1.equals(voltageLevelId2)) {\n+            return;\n+        }\n+        addAdjacency(voltageLevelAdjacency, voltageLevelId1, voltageLevelId2);\n+\n+        String substationId1 = context.cgmes().substation(t1, context.nodeBreaker());\n+        String substationId2 = context.cgmes().substation(t2, context.nodeBreaker());\n+\n+        // Null could be received as substation at the boundary\n+        if (substationId1 == null || substationId2 == null || substationId1.equals(substationId2)) {\n+            return;\n+        }\n+        addAdjacency(substationAdjacency, substationId1, substationId2);\n+    }\n+\n+    private String getVoltageLevelFromNode(String node, CgmesTerminal t) {\n+        String voltageLevelId = null;\n+        if (node != null && !context.boundary().containsNode(node)) {\n+            voltageLevelId = context.cgmes().voltageLevel(t, context.nodeBreaker());\n+        }\n+        return voltageLevelId;\n+    }\n+\n+    // Two different substations are adjacent if they are connected by a transformer\n+    private void addEnds(Map<String, List<String>> substationAdjacency, PropertyBags tends) {\n+        List<String> substationsIds = substationsIds(tends);\n+        if (substationsIds.size() <= 1) {\n+            return;\n+        }\n+        String sub0 = substationsIds.get(0);\n+        for (int i = 1; i < substationsIds.size(); i++) {\n+            String subi = substationsIds.get(i);\n+\n+            if (sub0.contentEquals(subi)) {\n+                continue;\n+            }\n+            addAdjacency(substationAdjacency, sub0, subi);\n+        }\n+    }\n+\n+    // Record in the adjacency Map that \"id1 is adjacent to id2\" and \"id2 is adjacent to id1\"\n+    private static void addAdjacency(Map<String, List<String>> adjacency, String id1, String id2) {\n+        List<String> ad1 = adjacency.get(id1);\n+        if (ad1 == null) {\n+            throw new PowsyblException(\"Unexpected reference to Substation or voltageLevel \" + id1\n+                + \". It has not been defined in CGMES substations / voltageLevels.\");\n+        }\n+        List<String> ad2 = adjacency.get(id2);\n+        if (ad2 == null) {\n+            throw new PowsyblException(\"Unexpected reference to Substation or voltageLevel \" + id2\n+                + \". It has not been defined in CGMES substations / voltageLevels.\");\n+        }\n+\n+        ad1.add(id2);\n+        ad2.add(id1);\n+    }\n+\n+    private void buildVoltageLevel(Map<String, List<String>> voltageLevelAdjacency) {\n+        Set<String> visitedVoltageLevels = new HashSet<>();\n+        voltageLevelAdjacency.keySet().forEach(vl -> {\n+            if (!visitedVoltageLevels.contains(vl)) {\n+                ArrayList<String> vlAds = allConnected(voltageLevelAdjacency, visitedVoltageLevels, vl);\n+                String selectedVoltageLevelId = representativeVoltageLevelId(vlAds);\n+                for (String voltageLevelId : vlAds) {\n+                    if (!voltageLevelId.equals(selectedVoltageLevelId)) {\n+                        voltageLevelMapping.put(voltageLevelId, selectedVoltageLevelId);\n                     }\n-                });\n-        if (!mapping.isEmpty()) {\n+                }\n+            }\n+        });\n+        if (!voltageLevelMapping.isEmpty()) {\n+            LOG.warn(\"VoltageLevel id mapping needed for {} voltageLevels: {}\",\n+                voltageLevelMapping.size(), voltageLevelMapping);\n+        }\n+    }\n+\n+    private void buildSubstation(Map<String, List<String>> substationAdjacency) {\n+        Set<String> visitedSubstations = new HashSet<>();\n+        substationAdjacency.keySet().forEach(sub -> {\n+            if (!visitedSubstations.contains(sub)) {\n+                ArrayList<String> subAds = allConnected(substationAdjacency, visitedSubstations, sub);\n+\n+                String selectedSubstationId = representativeSubstationId(subAds);\n+                for (String substationId : subAds) {\n+                    if (!substationId.equals(selectedSubstationId)) {\n+                        substationMapping.put(substationId, selectedSubstationId);\n+                    }\n+                }\n+            }\n+        });", "originalCommit": "dcd8f2f57cc6d3552cad79800f38addb39c69bcb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE2NjA4MQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1332#discussion_r512166081", "bodyText": "Done", "author": "marqueslanauja", "createdAt": "2020-10-26T18:06:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgyMDE4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgyMDcyNQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1332#discussion_r511820725", "bodyText": "See my previous comment: using a set instead of a list will make this algorithm more efficient", "author": "mathbagu", "createdAt": "2020-10-26T09:27:27Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/SubstationIdMapping.java", "diffHunk": "@@ -10,70 +10,302 @@\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.HashMap;\n+import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n \n-import org.jgrapht.Graph;\n-import org.jgrapht.alg.connectivity.ConnectivityInspector;\n-import org.jgrapht.graph.Pseudograph;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import com.powsybl.cgmes.model.CgmesNames;\n import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.commons.PowsyblException;\n import com.powsybl.triplestore.api.PropertyBag;\n import com.powsybl.triplestore.api.PropertyBags;\n \n /**\n+ * CGMES standard: <br>\n+ * A PowerTransformer is contained in one Substation, but it can connect a Terminal to another different Substation <br>\n+ * A Switch can connect to different voltageLevels\n+ * <p>\n+ * IIDM Model: <br>\n+ * Ends of transformers need to be in the same substation<br>\n+ * Ends of switches need to be in the same voltageLevel\n+ * <p>\n+ * Solution: <br>\n+ * CGMES substations that are connected by transformers will be mapped to a single IIDM substation <br>\n+ * CGMES voltageLevels that are connected by switches will be mapped to a single IIDM voltageLevel\n+ * <p>\n+ * Example: <br>\n+ * We suppose that VL1, VL2, VL3, VL4, VL5, VL6 and VL7 are CGMES voltageLevels, <br>\n+ * Sw23 is a switch connecting voltageLevels VL2 and VL3, <br>\n+ * Sw34 is a switch connecting voltageLevels VL3 and VL4 and <br>\n+ * Sw67 is a switch connecting voltageLevels VL6 and VL7\n+ * <p>\n+ * Steps: <br>\n+ * Fill voltageLevelAdjacency Map <br>\n+ * Two voltageLevels are adjacent if they are connected by a switch <br>\n+ * The voltageLevelAdjacency Map will include the following records <br>\n+ * (VL1, []) <br>\n+ * (VL2, [VL2, VL3]) <br>\n+ * (VL3, [VL2, VL3, VL4]) <br>\n+ * (VL4, [VL3, VL4]) <br>\n+ * (VL5, []) <br>\n+ * (VL6, [VL6, VL7]) <br>\n+ * (VL7, [VL6, VL7]) <br>\n+ * <p>\n+ * For each non-visited VoltageLevel-key of the voltageLevelAdjacency Map all connected voltageLevels will be calculated  <br>\n+ * Two voltageLevels are connected if they are adjacent <br>\n+ * (allConnected method) <br>\n+ * All connected VoltageLevels to VL1 will be [VL1] <br>\n+ * All connected VoltageLevels to VL2 will be [VL2, VL3, VL4] <br>\n+ * All connected VoltageLevels to VL5 will be [VL5] <br>\n+ * All connected VoltageLevels to VL6 will be [VL6, VL7]\n+ * <p>\n+ * So the following voltageLevels should be merged <br>\n+ * [VL2, VL3, VL4] and the representative (IIDM voltageLevel) will be VL2 <br>\n+ * [VL6, VL7] and the representative (IIDM voltageLevel) will be VL6\n+ * <p>\n+ * And finally previous data is recorded in the voltageLevelMapping Map as <br>\n+ * (For each merged voltageLevel a record (merged voltageLevel, representative voltageLevel) is added) <br>\n+ * (VL3, VL2) <br>\n+ * (VL4, VL2) <br>\n+ * (VL7, VL6) <br>\n+ * <p>\n+ * The voltageLevelMapping Map will be used to assign the IIDM voltageLevel during the conversion process\n+ * <p>\n+ * The same algorithm is used to identify the substations that should be merged but: <br>\n+ * Two substations are adjacent if there is a transformer between them. <br>\n+ * The two substations associated with two adjacent voltageLevels, are adjacent if they are different substations.\n+ * <p>\n  * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n  */\n+\n public class SubstationIdMapping {\n \n     public SubstationIdMapping(Context context) {\n         this.context = context;\n-        this.mapping = new HashMap<>();\n+        this.substationMapping = new HashMap<>();\n+        this.voltageLevelMapping = new HashMap<>();\n     }\n \n-    public boolean isMapped(String cgmesIdentifier) {\n+    public boolean substationIsMapped(String cgmesIdentifier) {\n         String sid = context.namingStrategy().getId(CgmesNames.SUBSTATION, cgmesIdentifier);\n-        return mapping.containsKey(sid);\n+        return substationMapping.containsKey(sid);\n     }\n \n-    public String iidm(String cgmesIdentifier) {\n+    public String substationIidm(String cgmesIdentifier) {\n         String sid = context.namingStrategy().getId(CgmesNames.SUBSTATION, cgmesIdentifier);\n-        if (mapping.containsKey(sid)) {\n-            return mapping.get(sid);\n+        if (substationMapping.containsKey(sid)) {\n+            return substationMapping.get(sid);\n         }\n         return sid;\n     }\n \n+    // All the keys for a given value, all the merged substations that have cgmesIdentifier as representative\n+    public List<String> mergedSubstations(String cgmesIdentifier) {\n+        String sid = context.namingStrategy().getId(CgmesNames.SUBSTATION, cgmesIdentifier);\n+        return substationMapping.entrySet().stream().filter(record -> record.getValue().equals(sid))\n+            .map(Map.Entry::getKey).collect(Collectors.toList());\n+    }\n+\n+    public boolean voltageLevelIsMapped(String cgmesIdentifier) {\n+        String vlid = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, cgmesIdentifier);\n+        return voltageLevelMapping.containsKey(vlid);\n+    }\n+\n+    public String voltageLevelIidm(String cgmesIdentifier) {\n+        String vlid = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, cgmesIdentifier);\n+        if (voltageLevelMapping.containsKey(vlid)) {\n+            return voltageLevelMapping.get(vlid);\n+        }\n+        return vlid;\n+    }\n+\n+    // All the keys for a given value, all the merged voltageLevels that have cgmesIdentifier as representative\n+    public List<String> mergedVoltageLevels(String cgmesIdentifier) {\n+        String vlid = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, cgmesIdentifier);\n+        return voltageLevelMapping.entrySet().stream().filter(record -> record.getValue().equals(vlid))\n+            .map(Map.Entry::getKey).collect(Collectors.toList());\n+    }\n+\n     public void build() {\n-        // CGMES standard:\n-        // \"a PowerTransformer is contained in one Substation but it can connect a Terminal to\n-        // another Substation\"\n-        // Ends of transformers need to be in the same substation in the IIDM model.\n-        // We will map some CGMES substations to a single IIDM substation\n-        // when they are connected by transformers,\n-        // that is, when there are at least one power transformer that has terminals on both\n-        // substations\n-\n-        Graph<String, Object> g = graphSubstationsTransformers();\n-        new ConnectivityInspector<>(g).connectedSets().stream()\n-                .filter(substationIds -> substationIds.size() > 1)\n-                .forEach(substationIds -> {\n-                    String selectedSubstationId = representativeSubstationId(substationIds);\n-                    for (String substationId : substationIds) {\n-                        if (!substationId.equals(selectedSubstationId)) {\n-                            mapping.put(substationId, selectedSubstationId);\n-                        }\n+        Map<String, List<String>> voltageLevelAdjacency = new HashMap<>();\n+        Map<String, List<String>> substationAdjacency = new HashMap<>();\n+\n+        buildAdjacency(voltageLevelAdjacency, substationAdjacency);\n+        buildVoltageLevel(voltageLevelAdjacency);\n+        buildSubstation(substationAdjacency);\n+    }\n+\n+    private void buildAdjacency(Map<String, List<String>> voltageLevelAdjacency,\n+        Map<String, List<String>> substationAdjacency) {\n+        context.cgmes().voltageLevels().forEach(vl -> addVoltageLevel(voltageLevelAdjacency, vl));\n+        context.cgmes().substations().forEach(st -> addSubstation(substationAdjacency, st));\n+\n+        context.cgmes().switches().forEach(sw -> addSwitch(voltageLevelAdjacency, substationAdjacency, sw));\n+        context.cgmes().groupedTransformerEnds().forEach((t, tends) -> addEnds(substationAdjacency, tends));\n+    }\n+\n+    private void addVoltageLevel(Map<String, List<String>> voltageLevelAdjacency, PropertyBag vl) {\n+        String voltageLevelId = vl.getId(CgmesNames.VOLTAGE_LEVEL);\n+        String vId = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, voltageLevelId);\n+        voltageLevelAdjacency.computeIfAbsent(vId, k -> new ArrayList<>());\n+    }\n+\n+    private void addSubstation(Map<String, List<String>> substationAdjacency, PropertyBag sub) {\n+        String substationlId = sub.getId(CgmesNames.SUBSTATION);\n+        String subId = context.namingStrategy().getId(CgmesNames.SUBSTATION, substationlId);\n+        substationAdjacency.computeIfAbsent(subId, k -> new ArrayList<>());\n+    }\n+\n+    // Two different voltageLevels are adjacent if they are connected by a switch\n+    // If the corresponding substations are different they are also adjacent\n+    private void addSwitch(Map<String, List<String>> voltageLevelAdjacency,\n+        Map<String, List<String>> substationAdjacency, PropertyBag sw) {\n+\n+        CgmesTerminal t1 = context.cgmes().terminal(sw.getId(CgmesNames.TERMINAL + 1));\n+        String node1 = context.nodeBreaker() ? t1.connectivityNode() : t1.topologicalNode();\n+        String voltageLevelId1 = getVoltageLevelFromNode(node1, t1);\n+\n+        CgmesTerminal t2 = context.cgmes().terminal(sw.getId(CgmesNames.TERMINAL + 2));\n+        String node2 = context.nodeBreaker() ? t2.connectivityNode() : t2.topologicalNode();\n+        String voltageLevelId2 = getVoltageLevelFromNode(node2, t2);\n+\n+        // Null could be received as voltageLevel at the boundary\n+        if (voltageLevelId1 == null || voltageLevelId2 == null || voltageLevelId1.equals(voltageLevelId2)) {\n+            return;\n+        }\n+        addAdjacency(voltageLevelAdjacency, voltageLevelId1, voltageLevelId2);\n+\n+        String substationId1 = context.cgmes().substation(t1, context.nodeBreaker());\n+        String substationId2 = context.cgmes().substation(t2, context.nodeBreaker());\n+\n+        // Null could be received as substation at the boundary\n+        if (substationId1 == null || substationId2 == null || substationId1.equals(substationId2)) {\n+            return;\n+        }\n+        addAdjacency(substationAdjacency, substationId1, substationId2);\n+    }\n+\n+    private String getVoltageLevelFromNode(String node, CgmesTerminal t) {\n+        String voltageLevelId = null;\n+        if (node != null && !context.boundary().containsNode(node)) {\n+            voltageLevelId = context.cgmes().voltageLevel(t, context.nodeBreaker());\n+        }\n+        return voltageLevelId;\n+    }\n+\n+    // Two different substations are adjacent if they are connected by a transformer\n+    private void addEnds(Map<String, List<String>> substationAdjacency, PropertyBags tends) {\n+        List<String> substationsIds = substationsIds(tends);\n+        if (substationsIds.size() <= 1) {\n+            return;\n+        }\n+        String sub0 = substationsIds.get(0);\n+        for (int i = 1; i < substationsIds.size(); i++) {\n+            String subi = substationsIds.get(i);\n+\n+            if (sub0.contentEquals(subi)) {\n+                continue;\n+            }\n+            addAdjacency(substationAdjacency, sub0, subi);\n+        }\n+    }\n+\n+    // Record in the adjacency Map that \"id1 is adjacent to id2\" and \"id2 is adjacent to id1\"\n+    private static void addAdjacency(Map<String, List<String>> adjacency, String id1, String id2) {\n+        List<String> ad1 = adjacency.get(id1);\n+        if (ad1 == null) {\n+            throw new PowsyblException(\"Unexpected reference to Substation or voltageLevel \" + id1\n+                + \". It has not been defined in CGMES substations / voltageLevels.\");\n+        }\n+        List<String> ad2 = adjacency.get(id2);\n+        if (ad2 == null) {\n+            throw new PowsyblException(\"Unexpected reference to Substation or voltageLevel \" + id2\n+                + \". It has not been defined in CGMES substations / voltageLevels.\");\n+        }\n+\n+        ad1.add(id2);\n+        ad2.add(id1);\n+    }\n+\n+    private void buildVoltageLevel(Map<String, List<String>> voltageLevelAdjacency) {\n+        Set<String> visitedVoltageLevels = new HashSet<>();\n+        voltageLevelAdjacency.keySet().forEach(vl -> {\n+            if (!visitedVoltageLevels.contains(vl)) {\n+                ArrayList<String> vlAds = allConnected(voltageLevelAdjacency, visitedVoltageLevels, vl);\n+                String selectedVoltageLevelId = representativeVoltageLevelId(vlAds);\n+                for (String voltageLevelId : vlAds) {\n+                    if (!voltageLevelId.equals(selectedVoltageLevelId)) {\n+                        voltageLevelMapping.put(voltageLevelId, selectedVoltageLevelId);\n                     }\n-                });\n-        if (!mapping.isEmpty()) {\n+                }\n+            }\n+        });\n+        if (!voltageLevelMapping.isEmpty()) {\n+            LOG.warn(\"VoltageLevel id mapping needed for {} voltageLevels: {}\",\n+                voltageLevelMapping.size(), voltageLevelMapping);\n+        }\n+    }\n+\n+    private void buildSubstation(Map<String, List<String>> substationAdjacency) {\n+        Set<String> visitedSubstations = new HashSet<>();\n+        substationAdjacency.keySet().forEach(sub -> {\n+            if (!visitedSubstations.contains(sub)) {\n+                ArrayList<String> subAds = allConnected(substationAdjacency, visitedSubstations, sub);\n+\n+                String selectedSubstationId = representativeSubstationId(subAds);\n+                for (String substationId : subAds) {\n+                    if (!substationId.equals(selectedSubstationId)) {\n+                        substationMapping.put(substationId, selectedSubstationId);\n+                    }\n+                }\n+            }\n+        });\n+        if (!substationMapping.isEmpty()) {\n             LOG.warn(\"Substation id mapping needed for {} substations: {}\",\n-                    mapping.size(), mapping);\n+                    substationMapping.size(), substationMapping);\n         }\n     }\n \n+    // Given an id (substation / voltageLevel) returns all connected ids (substations / voltageLevels)\n+    // Two ids are connected if they are adjacent in the adjacency Map\n+    private static ArrayList<String> allConnected(Map<String, List<String>> adjacency, Set<String> visited, String id) {\n+        ArrayList<String> allConnected = new ArrayList<>();\n+\n+        // Insert id in the allConnected list and record it as visited\n+        allConnected.add(id);\n+        visited.add(id);\n+\n+        // Expand, adding in each step all non-visited adjacent ids\"\n+        int k = 0;\n+        while (k < allConnected.size()) {\n+            String vl0 = allConnected.get(k);\n+            if (adjacency.containsKey(vl0)) {", "originalCommit": "dcd8f2f57cc6d3552cad79800f38addb39c69bcb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE2OTI3MQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1332#discussion_r512169271", "bodyText": "To expand, we need to process the List by index as we are increasing it, so we prefer a List rather than a Set.", "author": "marqueslanauja", "createdAt": "2020-10-26T18:11:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgyMDcyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgyMDk4Mw==", "url": "https://github.com/powsybl/powsybl-core/pull/1332#discussion_r511820983", "bodyText": "This is probably a Set too", "author": "mathbagu", "createdAt": "2020-10-26T09:27:52Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/SubstationIdMapping.java", "diffHunk": "@@ -10,70 +10,302 @@\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.HashMap;\n+import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n \n-import org.jgrapht.Graph;\n-import org.jgrapht.alg.connectivity.ConnectivityInspector;\n-import org.jgrapht.graph.Pseudograph;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import com.powsybl.cgmes.model.CgmesNames;\n import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.commons.PowsyblException;\n import com.powsybl.triplestore.api.PropertyBag;\n import com.powsybl.triplestore.api.PropertyBags;\n \n /**\n+ * CGMES standard: <br>\n+ * A PowerTransformer is contained in one Substation, but it can connect a Terminal to another different Substation <br>\n+ * A Switch can connect to different voltageLevels\n+ * <p>\n+ * IIDM Model: <br>\n+ * Ends of transformers need to be in the same substation<br>\n+ * Ends of switches need to be in the same voltageLevel\n+ * <p>\n+ * Solution: <br>\n+ * CGMES substations that are connected by transformers will be mapped to a single IIDM substation <br>\n+ * CGMES voltageLevels that are connected by switches will be mapped to a single IIDM voltageLevel\n+ * <p>\n+ * Example: <br>\n+ * We suppose that VL1, VL2, VL3, VL4, VL5, VL6 and VL7 are CGMES voltageLevels, <br>\n+ * Sw23 is a switch connecting voltageLevels VL2 and VL3, <br>\n+ * Sw34 is a switch connecting voltageLevels VL3 and VL4 and <br>\n+ * Sw67 is a switch connecting voltageLevels VL6 and VL7\n+ * <p>\n+ * Steps: <br>\n+ * Fill voltageLevelAdjacency Map <br>\n+ * Two voltageLevels are adjacent if they are connected by a switch <br>\n+ * The voltageLevelAdjacency Map will include the following records <br>\n+ * (VL1, []) <br>\n+ * (VL2, [VL2, VL3]) <br>\n+ * (VL3, [VL2, VL3, VL4]) <br>\n+ * (VL4, [VL3, VL4]) <br>\n+ * (VL5, []) <br>\n+ * (VL6, [VL6, VL7]) <br>\n+ * (VL7, [VL6, VL7]) <br>\n+ * <p>\n+ * For each non-visited VoltageLevel-key of the voltageLevelAdjacency Map all connected voltageLevels will be calculated  <br>\n+ * Two voltageLevels are connected if they are adjacent <br>\n+ * (allConnected method) <br>\n+ * All connected VoltageLevels to VL1 will be [VL1] <br>\n+ * All connected VoltageLevels to VL2 will be [VL2, VL3, VL4] <br>\n+ * All connected VoltageLevels to VL5 will be [VL5] <br>\n+ * All connected VoltageLevels to VL6 will be [VL6, VL7]\n+ * <p>\n+ * So the following voltageLevels should be merged <br>\n+ * [VL2, VL3, VL4] and the representative (IIDM voltageLevel) will be VL2 <br>\n+ * [VL6, VL7] and the representative (IIDM voltageLevel) will be VL6\n+ * <p>\n+ * And finally previous data is recorded in the voltageLevelMapping Map as <br>\n+ * (For each merged voltageLevel a record (merged voltageLevel, representative voltageLevel) is added) <br>\n+ * (VL3, VL2) <br>\n+ * (VL4, VL2) <br>\n+ * (VL7, VL6) <br>\n+ * <p>\n+ * The voltageLevelMapping Map will be used to assign the IIDM voltageLevel during the conversion process\n+ * <p>\n+ * The same algorithm is used to identify the substations that should be merged but: <br>\n+ * Two substations are adjacent if there is a transformer between them. <br>\n+ * The two substations associated with two adjacent voltageLevels, are adjacent if they are different substations.\n+ * <p>\n  * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n  */\n+\n public class SubstationIdMapping {\n \n     public SubstationIdMapping(Context context) {\n         this.context = context;\n-        this.mapping = new HashMap<>();\n+        this.substationMapping = new HashMap<>();\n+        this.voltageLevelMapping = new HashMap<>();\n     }\n \n-    public boolean isMapped(String cgmesIdentifier) {\n+    public boolean substationIsMapped(String cgmesIdentifier) {\n         String sid = context.namingStrategy().getId(CgmesNames.SUBSTATION, cgmesIdentifier);\n-        return mapping.containsKey(sid);\n+        return substationMapping.containsKey(sid);\n     }\n \n-    public String iidm(String cgmesIdentifier) {\n+    public String substationIidm(String cgmesIdentifier) {\n         String sid = context.namingStrategy().getId(CgmesNames.SUBSTATION, cgmesIdentifier);\n-        if (mapping.containsKey(sid)) {\n-            return mapping.get(sid);\n+        if (substationMapping.containsKey(sid)) {\n+            return substationMapping.get(sid);\n         }\n         return sid;\n     }\n \n+    // All the keys for a given value, all the merged substations that have cgmesIdentifier as representative\n+    public List<String> mergedSubstations(String cgmesIdentifier) {\n+        String sid = context.namingStrategy().getId(CgmesNames.SUBSTATION, cgmesIdentifier);\n+        return substationMapping.entrySet().stream().filter(record -> record.getValue().equals(sid))\n+            .map(Map.Entry::getKey).collect(Collectors.toList());\n+    }\n+\n+    public boolean voltageLevelIsMapped(String cgmesIdentifier) {\n+        String vlid = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, cgmesIdentifier);\n+        return voltageLevelMapping.containsKey(vlid);\n+    }\n+\n+    public String voltageLevelIidm(String cgmesIdentifier) {\n+        String vlid = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, cgmesIdentifier);\n+        if (voltageLevelMapping.containsKey(vlid)) {\n+            return voltageLevelMapping.get(vlid);\n+        }\n+        return vlid;\n+    }\n+\n+    // All the keys for a given value, all the merged voltageLevels that have cgmesIdentifier as representative\n+    public List<String> mergedVoltageLevels(String cgmesIdentifier) {\n+        String vlid = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, cgmesIdentifier);\n+        return voltageLevelMapping.entrySet().stream().filter(record -> record.getValue().equals(vlid))\n+            .map(Map.Entry::getKey).collect(Collectors.toList());\n+    }\n+\n     public void build() {\n-        // CGMES standard:\n-        // \"a PowerTransformer is contained in one Substation but it can connect a Terminal to\n-        // another Substation\"\n-        // Ends of transformers need to be in the same substation in the IIDM model.\n-        // We will map some CGMES substations to a single IIDM substation\n-        // when they are connected by transformers,\n-        // that is, when there are at least one power transformer that has terminals on both\n-        // substations\n-\n-        Graph<String, Object> g = graphSubstationsTransformers();\n-        new ConnectivityInspector<>(g).connectedSets().stream()\n-                .filter(substationIds -> substationIds.size() > 1)\n-                .forEach(substationIds -> {\n-                    String selectedSubstationId = representativeSubstationId(substationIds);\n-                    for (String substationId : substationIds) {\n-                        if (!substationId.equals(selectedSubstationId)) {\n-                            mapping.put(substationId, selectedSubstationId);\n-                        }\n+        Map<String, List<String>> voltageLevelAdjacency = new HashMap<>();\n+        Map<String, List<String>> substationAdjacency = new HashMap<>();\n+\n+        buildAdjacency(voltageLevelAdjacency, substationAdjacency);\n+        buildVoltageLevel(voltageLevelAdjacency);\n+        buildSubstation(substationAdjacency);\n+    }\n+\n+    private void buildAdjacency(Map<String, List<String>> voltageLevelAdjacency,\n+        Map<String, List<String>> substationAdjacency) {\n+        context.cgmes().voltageLevels().forEach(vl -> addVoltageLevel(voltageLevelAdjacency, vl));\n+        context.cgmes().substations().forEach(st -> addSubstation(substationAdjacency, st));\n+\n+        context.cgmes().switches().forEach(sw -> addSwitch(voltageLevelAdjacency, substationAdjacency, sw));\n+        context.cgmes().groupedTransformerEnds().forEach((t, tends) -> addEnds(substationAdjacency, tends));\n+    }\n+\n+    private void addVoltageLevel(Map<String, List<String>> voltageLevelAdjacency, PropertyBag vl) {\n+        String voltageLevelId = vl.getId(CgmesNames.VOLTAGE_LEVEL);\n+        String vId = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, voltageLevelId);\n+        voltageLevelAdjacency.computeIfAbsent(vId, k -> new ArrayList<>());\n+    }\n+\n+    private void addSubstation(Map<String, List<String>> substationAdjacency, PropertyBag sub) {\n+        String substationlId = sub.getId(CgmesNames.SUBSTATION);\n+        String subId = context.namingStrategy().getId(CgmesNames.SUBSTATION, substationlId);\n+        substationAdjacency.computeIfAbsent(subId, k -> new ArrayList<>());\n+    }\n+\n+    // Two different voltageLevels are adjacent if they are connected by a switch\n+    // If the corresponding substations are different they are also adjacent\n+    private void addSwitch(Map<String, List<String>> voltageLevelAdjacency,\n+        Map<String, List<String>> substationAdjacency, PropertyBag sw) {\n+\n+        CgmesTerminal t1 = context.cgmes().terminal(sw.getId(CgmesNames.TERMINAL + 1));\n+        String node1 = context.nodeBreaker() ? t1.connectivityNode() : t1.topologicalNode();\n+        String voltageLevelId1 = getVoltageLevelFromNode(node1, t1);\n+\n+        CgmesTerminal t2 = context.cgmes().terminal(sw.getId(CgmesNames.TERMINAL + 2));\n+        String node2 = context.nodeBreaker() ? t2.connectivityNode() : t2.topologicalNode();\n+        String voltageLevelId2 = getVoltageLevelFromNode(node2, t2);\n+\n+        // Null could be received as voltageLevel at the boundary\n+        if (voltageLevelId1 == null || voltageLevelId2 == null || voltageLevelId1.equals(voltageLevelId2)) {\n+            return;\n+        }\n+        addAdjacency(voltageLevelAdjacency, voltageLevelId1, voltageLevelId2);\n+\n+        String substationId1 = context.cgmes().substation(t1, context.nodeBreaker());\n+        String substationId2 = context.cgmes().substation(t2, context.nodeBreaker());\n+\n+        // Null could be received as substation at the boundary\n+        if (substationId1 == null || substationId2 == null || substationId1.equals(substationId2)) {\n+            return;\n+        }\n+        addAdjacency(substationAdjacency, substationId1, substationId2);\n+    }\n+\n+    private String getVoltageLevelFromNode(String node, CgmesTerminal t) {\n+        String voltageLevelId = null;\n+        if (node != null && !context.boundary().containsNode(node)) {\n+            voltageLevelId = context.cgmes().voltageLevel(t, context.nodeBreaker());\n+        }\n+        return voltageLevelId;\n+    }\n+\n+    // Two different substations are adjacent if they are connected by a transformer\n+    private void addEnds(Map<String, List<String>> substationAdjacency, PropertyBags tends) {\n+        List<String> substationsIds = substationsIds(tends);\n+        if (substationsIds.size() <= 1) {\n+            return;\n+        }\n+        String sub0 = substationsIds.get(0);\n+        for (int i = 1; i < substationsIds.size(); i++) {\n+            String subi = substationsIds.get(i);\n+\n+            if (sub0.contentEquals(subi)) {\n+                continue;\n+            }\n+            addAdjacency(substationAdjacency, sub0, subi);\n+        }\n+    }\n+\n+    // Record in the adjacency Map that \"id1 is adjacent to id2\" and \"id2 is adjacent to id1\"\n+    private static void addAdjacency(Map<String, List<String>> adjacency, String id1, String id2) {\n+        List<String> ad1 = adjacency.get(id1);\n+        if (ad1 == null) {\n+            throw new PowsyblException(\"Unexpected reference to Substation or voltageLevel \" + id1\n+                + \". It has not been defined in CGMES substations / voltageLevels.\");\n+        }\n+        List<String> ad2 = adjacency.get(id2);\n+        if (ad2 == null) {\n+            throw new PowsyblException(\"Unexpected reference to Substation or voltageLevel \" + id2\n+                + \". It has not been defined in CGMES substations / voltageLevels.\");\n+        }\n+\n+        ad1.add(id2);\n+        ad2.add(id1);\n+    }\n+\n+    private void buildVoltageLevel(Map<String, List<String>> voltageLevelAdjacency) {\n+        Set<String> visitedVoltageLevels = new HashSet<>();\n+        voltageLevelAdjacency.keySet().forEach(vl -> {\n+            if (!visitedVoltageLevels.contains(vl)) {\n+                ArrayList<String> vlAds = allConnected(voltageLevelAdjacency, visitedVoltageLevels, vl);\n+                String selectedVoltageLevelId = representativeVoltageLevelId(vlAds);\n+                for (String voltageLevelId : vlAds) {\n+                    if (!voltageLevelId.equals(selectedVoltageLevelId)) {\n+                        voltageLevelMapping.put(voltageLevelId, selectedVoltageLevelId);\n                     }\n-                });\n-        if (!mapping.isEmpty()) {\n+                }\n+            }\n+        });\n+        if (!voltageLevelMapping.isEmpty()) {\n+            LOG.warn(\"VoltageLevel id mapping needed for {} voltageLevels: {}\",\n+                voltageLevelMapping.size(), voltageLevelMapping);\n+        }\n+    }\n+\n+    private void buildSubstation(Map<String, List<String>> substationAdjacency) {\n+        Set<String> visitedSubstations = new HashSet<>();\n+        substationAdjacency.keySet().forEach(sub -> {\n+            if (!visitedSubstations.contains(sub)) {\n+                ArrayList<String> subAds = allConnected(substationAdjacency, visitedSubstations, sub);\n+\n+                String selectedSubstationId = representativeSubstationId(subAds);\n+                for (String substationId : subAds) {\n+                    if (!substationId.equals(selectedSubstationId)) {\n+                        substationMapping.put(substationId, selectedSubstationId);\n+                    }\n+                }\n+            }\n+        });\n+        if (!substationMapping.isEmpty()) {\n             LOG.warn(\"Substation id mapping needed for {} substations: {}\",\n-                    mapping.size(), mapping);\n+                    substationMapping.size(), substationMapping);\n         }\n     }\n \n+    // Given an id (substation / voltageLevel) returns all connected ids (substations / voltageLevels)\n+    // Two ids are connected if they are adjacent in the adjacency Map\n+    private static ArrayList<String> allConnected(Map<String, List<String>> adjacency, Set<String> visited, String id) {\n+        ArrayList<String> allConnected = new ArrayList<>();", "originalCommit": "dcd8f2f57cc6d3552cad79800f38addb39c69bcb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE2NjQ1OA==", "url": "https://github.com/powsybl/powsybl-core/pull/1332#discussion_r512166458", "bodyText": "Done", "author": "marqueslanauja", "createdAt": "2020-10-26T18:06:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgyMDk4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgyMTY2MA==", "url": "https://github.com/powsybl/powsybl-core/pull/1332#discussion_r511821660", "bodyText": "You should throw an AssertionError if this list is expected to never be empty", "author": "mathbagu", "createdAt": "2020-10-26T09:28:49Z", "path": "cgmes/cgmes-conversion/src/main/java/com/powsybl/cgmes/conversion/SubstationIdMapping.java", "diffHunk": "@@ -10,70 +10,302 @@\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.HashMap;\n+import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n \n-import org.jgrapht.Graph;\n-import org.jgrapht.alg.connectivity.ConnectivityInspector;\n-import org.jgrapht.graph.Pseudograph;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import com.powsybl.cgmes.model.CgmesNames;\n import com.powsybl.cgmes.model.CgmesTerminal;\n+import com.powsybl.commons.PowsyblException;\n import com.powsybl.triplestore.api.PropertyBag;\n import com.powsybl.triplestore.api.PropertyBags;\n \n /**\n+ * CGMES standard: <br>\n+ * A PowerTransformer is contained in one Substation, but it can connect a Terminal to another different Substation <br>\n+ * A Switch can connect to different voltageLevels\n+ * <p>\n+ * IIDM Model: <br>\n+ * Ends of transformers need to be in the same substation<br>\n+ * Ends of switches need to be in the same voltageLevel\n+ * <p>\n+ * Solution: <br>\n+ * CGMES substations that are connected by transformers will be mapped to a single IIDM substation <br>\n+ * CGMES voltageLevels that are connected by switches will be mapped to a single IIDM voltageLevel\n+ * <p>\n+ * Example: <br>\n+ * We suppose that VL1, VL2, VL3, VL4, VL5, VL6 and VL7 are CGMES voltageLevels, <br>\n+ * Sw23 is a switch connecting voltageLevels VL2 and VL3, <br>\n+ * Sw34 is a switch connecting voltageLevels VL3 and VL4 and <br>\n+ * Sw67 is a switch connecting voltageLevels VL6 and VL7\n+ * <p>\n+ * Steps: <br>\n+ * Fill voltageLevelAdjacency Map <br>\n+ * Two voltageLevels are adjacent if they are connected by a switch <br>\n+ * The voltageLevelAdjacency Map will include the following records <br>\n+ * (VL1, []) <br>\n+ * (VL2, [VL2, VL3]) <br>\n+ * (VL3, [VL2, VL3, VL4]) <br>\n+ * (VL4, [VL3, VL4]) <br>\n+ * (VL5, []) <br>\n+ * (VL6, [VL6, VL7]) <br>\n+ * (VL7, [VL6, VL7]) <br>\n+ * <p>\n+ * For each non-visited VoltageLevel-key of the voltageLevelAdjacency Map all connected voltageLevels will be calculated  <br>\n+ * Two voltageLevels are connected if they are adjacent <br>\n+ * (allConnected method) <br>\n+ * All connected VoltageLevels to VL1 will be [VL1] <br>\n+ * All connected VoltageLevels to VL2 will be [VL2, VL3, VL4] <br>\n+ * All connected VoltageLevels to VL5 will be [VL5] <br>\n+ * All connected VoltageLevels to VL6 will be [VL6, VL7]\n+ * <p>\n+ * So the following voltageLevels should be merged <br>\n+ * [VL2, VL3, VL4] and the representative (IIDM voltageLevel) will be VL2 <br>\n+ * [VL6, VL7] and the representative (IIDM voltageLevel) will be VL6\n+ * <p>\n+ * And finally previous data is recorded in the voltageLevelMapping Map as <br>\n+ * (For each merged voltageLevel a record (merged voltageLevel, representative voltageLevel) is added) <br>\n+ * (VL3, VL2) <br>\n+ * (VL4, VL2) <br>\n+ * (VL7, VL6) <br>\n+ * <p>\n+ * The voltageLevelMapping Map will be used to assign the IIDM voltageLevel during the conversion process\n+ * <p>\n+ * The same algorithm is used to identify the substations that should be merged but: <br>\n+ * Two substations are adjacent if there is a transformer between them. <br>\n+ * The two substations associated with two adjacent voltageLevels, are adjacent if they are different substations.\n+ * <p>\n  * @author Luma Zamarre\u00f1o <zamarrenolm at aia.es>\n+ * @author Jos\u00e9 Antonio Marqu\u00e9s <marquesja at aia.es>\n  */\n+\n public class SubstationIdMapping {\n \n     public SubstationIdMapping(Context context) {\n         this.context = context;\n-        this.mapping = new HashMap<>();\n+        this.substationMapping = new HashMap<>();\n+        this.voltageLevelMapping = new HashMap<>();\n     }\n \n-    public boolean isMapped(String cgmesIdentifier) {\n+    public boolean substationIsMapped(String cgmesIdentifier) {\n         String sid = context.namingStrategy().getId(CgmesNames.SUBSTATION, cgmesIdentifier);\n-        return mapping.containsKey(sid);\n+        return substationMapping.containsKey(sid);\n     }\n \n-    public String iidm(String cgmesIdentifier) {\n+    public String substationIidm(String cgmesIdentifier) {\n         String sid = context.namingStrategy().getId(CgmesNames.SUBSTATION, cgmesIdentifier);\n-        if (mapping.containsKey(sid)) {\n-            return mapping.get(sid);\n+        if (substationMapping.containsKey(sid)) {\n+            return substationMapping.get(sid);\n         }\n         return sid;\n     }\n \n+    // All the keys for a given value, all the merged substations that have cgmesIdentifier as representative\n+    public List<String> mergedSubstations(String cgmesIdentifier) {\n+        String sid = context.namingStrategy().getId(CgmesNames.SUBSTATION, cgmesIdentifier);\n+        return substationMapping.entrySet().stream().filter(record -> record.getValue().equals(sid))\n+            .map(Map.Entry::getKey).collect(Collectors.toList());\n+    }\n+\n+    public boolean voltageLevelIsMapped(String cgmesIdentifier) {\n+        String vlid = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, cgmesIdentifier);\n+        return voltageLevelMapping.containsKey(vlid);\n+    }\n+\n+    public String voltageLevelIidm(String cgmesIdentifier) {\n+        String vlid = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, cgmesIdentifier);\n+        if (voltageLevelMapping.containsKey(vlid)) {\n+            return voltageLevelMapping.get(vlid);\n+        }\n+        return vlid;\n+    }\n+\n+    // All the keys for a given value, all the merged voltageLevels that have cgmesIdentifier as representative\n+    public List<String> mergedVoltageLevels(String cgmesIdentifier) {\n+        String vlid = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, cgmesIdentifier);\n+        return voltageLevelMapping.entrySet().stream().filter(record -> record.getValue().equals(vlid))\n+            .map(Map.Entry::getKey).collect(Collectors.toList());\n+    }\n+\n     public void build() {\n-        // CGMES standard:\n-        // \"a PowerTransformer is contained in one Substation but it can connect a Terminal to\n-        // another Substation\"\n-        // Ends of transformers need to be in the same substation in the IIDM model.\n-        // We will map some CGMES substations to a single IIDM substation\n-        // when they are connected by transformers,\n-        // that is, when there are at least one power transformer that has terminals on both\n-        // substations\n-\n-        Graph<String, Object> g = graphSubstationsTransformers();\n-        new ConnectivityInspector<>(g).connectedSets().stream()\n-                .filter(substationIds -> substationIds.size() > 1)\n-                .forEach(substationIds -> {\n-                    String selectedSubstationId = representativeSubstationId(substationIds);\n-                    for (String substationId : substationIds) {\n-                        if (!substationId.equals(selectedSubstationId)) {\n-                            mapping.put(substationId, selectedSubstationId);\n-                        }\n+        Map<String, List<String>> voltageLevelAdjacency = new HashMap<>();\n+        Map<String, List<String>> substationAdjacency = new HashMap<>();\n+\n+        buildAdjacency(voltageLevelAdjacency, substationAdjacency);\n+        buildVoltageLevel(voltageLevelAdjacency);\n+        buildSubstation(substationAdjacency);\n+    }\n+\n+    private void buildAdjacency(Map<String, List<String>> voltageLevelAdjacency,\n+        Map<String, List<String>> substationAdjacency) {\n+        context.cgmes().voltageLevels().forEach(vl -> addVoltageLevel(voltageLevelAdjacency, vl));\n+        context.cgmes().substations().forEach(st -> addSubstation(substationAdjacency, st));\n+\n+        context.cgmes().switches().forEach(sw -> addSwitch(voltageLevelAdjacency, substationAdjacency, sw));\n+        context.cgmes().groupedTransformerEnds().forEach((t, tends) -> addEnds(substationAdjacency, tends));\n+    }\n+\n+    private void addVoltageLevel(Map<String, List<String>> voltageLevelAdjacency, PropertyBag vl) {\n+        String voltageLevelId = vl.getId(CgmesNames.VOLTAGE_LEVEL);\n+        String vId = context.namingStrategy().getId(CgmesNames.VOLTAGE_LEVEL, voltageLevelId);\n+        voltageLevelAdjacency.computeIfAbsent(vId, k -> new ArrayList<>());\n+    }\n+\n+    private void addSubstation(Map<String, List<String>> substationAdjacency, PropertyBag sub) {\n+        String substationlId = sub.getId(CgmesNames.SUBSTATION);\n+        String subId = context.namingStrategy().getId(CgmesNames.SUBSTATION, substationlId);\n+        substationAdjacency.computeIfAbsent(subId, k -> new ArrayList<>());\n+    }\n+\n+    // Two different voltageLevels are adjacent if they are connected by a switch\n+    // If the corresponding substations are different they are also adjacent\n+    private void addSwitch(Map<String, List<String>> voltageLevelAdjacency,\n+        Map<String, List<String>> substationAdjacency, PropertyBag sw) {\n+\n+        CgmesTerminal t1 = context.cgmes().terminal(sw.getId(CgmesNames.TERMINAL + 1));\n+        String node1 = context.nodeBreaker() ? t1.connectivityNode() : t1.topologicalNode();\n+        String voltageLevelId1 = getVoltageLevelFromNode(node1, t1);\n+\n+        CgmesTerminal t2 = context.cgmes().terminal(sw.getId(CgmesNames.TERMINAL + 2));\n+        String node2 = context.nodeBreaker() ? t2.connectivityNode() : t2.topologicalNode();\n+        String voltageLevelId2 = getVoltageLevelFromNode(node2, t2);\n+\n+        // Null could be received as voltageLevel at the boundary\n+        if (voltageLevelId1 == null || voltageLevelId2 == null || voltageLevelId1.equals(voltageLevelId2)) {\n+            return;\n+        }\n+        addAdjacency(voltageLevelAdjacency, voltageLevelId1, voltageLevelId2);\n+\n+        String substationId1 = context.cgmes().substation(t1, context.nodeBreaker());\n+        String substationId2 = context.cgmes().substation(t2, context.nodeBreaker());\n+\n+        // Null could be received as substation at the boundary\n+        if (substationId1 == null || substationId2 == null || substationId1.equals(substationId2)) {\n+            return;\n+        }\n+        addAdjacency(substationAdjacency, substationId1, substationId2);\n+    }\n+\n+    private String getVoltageLevelFromNode(String node, CgmesTerminal t) {\n+        String voltageLevelId = null;\n+        if (node != null && !context.boundary().containsNode(node)) {\n+            voltageLevelId = context.cgmes().voltageLevel(t, context.nodeBreaker());\n+        }\n+        return voltageLevelId;\n+    }\n+\n+    // Two different substations are adjacent if they are connected by a transformer\n+    private void addEnds(Map<String, List<String>> substationAdjacency, PropertyBags tends) {\n+        List<String> substationsIds = substationsIds(tends);\n+        if (substationsIds.size() <= 1) {\n+            return;\n+        }\n+        String sub0 = substationsIds.get(0);\n+        for (int i = 1; i < substationsIds.size(); i++) {\n+            String subi = substationsIds.get(i);\n+\n+            if (sub0.contentEquals(subi)) {\n+                continue;\n+            }\n+            addAdjacency(substationAdjacency, sub0, subi);\n+        }\n+    }\n+\n+    // Record in the adjacency Map that \"id1 is adjacent to id2\" and \"id2 is adjacent to id1\"\n+    private static void addAdjacency(Map<String, List<String>> adjacency, String id1, String id2) {\n+        List<String> ad1 = adjacency.get(id1);\n+        if (ad1 == null) {\n+            throw new PowsyblException(\"Unexpected reference to Substation or voltageLevel \" + id1\n+                + \". It has not been defined in CGMES substations / voltageLevels.\");\n+        }\n+        List<String> ad2 = adjacency.get(id2);\n+        if (ad2 == null) {\n+            throw new PowsyblException(\"Unexpected reference to Substation or voltageLevel \" + id2\n+                + \". It has not been defined in CGMES substations / voltageLevels.\");\n+        }\n+\n+        ad1.add(id2);\n+        ad2.add(id1);\n+    }\n+\n+    private void buildVoltageLevel(Map<String, List<String>> voltageLevelAdjacency) {\n+        Set<String> visitedVoltageLevels = new HashSet<>();\n+        voltageLevelAdjacency.keySet().forEach(vl -> {\n+            if (!visitedVoltageLevels.contains(vl)) {\n+                ArrayList<String> vlAds = allConnected(voltageLevelAdjacency, visitedVoltageLevels, vl);\n+                String selectedVoltageLevelId = representativeVoltageLevelId(vlAds);\n+                for (String voltageLevelId : vlAds) {\n+                    if (!voltageLevelId.equals(selectedVoltageLevelId)) {\n+                        voltageLevelMapping.put(voltageLevelId, selectedVoltageLevelId);\n                     }\n-                });\n-        if (!mapping.isEmpty()) {\n+                }\n+            }\n+        });\n+        if (!voltageLevelMapping.isEmpty()) {\n+            LOG.warn(\"VoltageLevel id mapping needed for {} voltageLevels: {}\",\n+                voltageLevelMapping.size(), voltageLevelMapping);\n+        }\n+    }\n+\n+    private void buildSubstation(Map<String, List<String>> substationAdjacency) {\n+        Set<String> visitedSubstations = new HashSet<>();\n+        substationAdjacency.keySet().forEach(sub -> {\n+            if (!visitedSubstations.contains(sub)) {\n+                ArrayList<String> subAds = allConnected(substationAdjacency, visitedSubstations, sub);\n+\n+                String selectedSubstationId = representativeSubstationId(subAds);\n+                for (String substationId : subAds) {\n+                    if (!substationId.equals(selectedSubstationId)) {\n+                        substationMapping.put(substationId, selectedSubstationId);\n+                    }\n+                }\n+            }\n+        });\n+        if (!substationMapping.isEmpty()) {\n             LOG.warn(\"Substation id mapping needed for {} substations: {}\",\n-                    mapping.size(), mapping);\n+                    substationMapping.size(), substationMapping);\n         }\n     }\n \n+    // Given an id (substation / voltageLevel) returns all connected ids (substations / voltageLevels)\n+    // Two ids are connected if they are adjacent in the adjacency Map\n+    private static ArrayList<String> allConnected(Map<String, List<String>> adjacency, Set<String> visited, String id) {\n+        ArrayList<String> allConnected = new ArrayList<>();\n+\n+        // Insert id in the allConnected list and record it as visited\n+        allConnected.add(id);\n+        visited.add(id);\n+\n+        // Expand, adding in each step all non-visited adjacent ids\"\n+        int k = 0;\n+        while (k < allConnected.size()) {\n+            String vl0 = allConnected.get(k);\n+            if (adjacency.containsKey(vl0)) {\n+                adjacency.get(vl0).forEach(ad -> {\n+                    if (visited.contains(ad)) {\n+                        return;\n+                    }\n+                    allConnected.add(ad);\n+                    visited.add(ad);\n+                });\n+            }\n+            k++;\n+        }\n+        return allConnected;\n+    }\n+\n+    private static String representativeVoltageLevelId(Collection<String> voltageLevelIds) {\n+        return voltageLevelIds.stream()\n+                .sorted()\n+                .findFirst()\n+                .orElseThrow(() -> new PowsyblException(\"Unexpected: voltageLevelIds list is empty\"));", "originalCommit": "dcd8f2f57cc6d3552cad79800f38addb39c69bcb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE2NjYxOQ==", "url": "https://github.com/powsybl/powsybl-core/pull/1332#discussion_r512166619", "bodyText": "Done", "author": "marqueslanauja", "createdAt": "2020-10-26T18:06:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgyMTY2MA=="}], "type": "inlineReview"}, {"oid": "43ff59c18f99df5c82b8f65e67e45f51463c4ddd", "url": "https://github.com/powsybl/powsybl-core/commit/43ff59c18f99df5c82b8f65e67e45f51463c4ddd", "message": "Merge branch 'master' into cgmes_conversion_joinVoltageLevels\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>\n\n# Conflicts:\n#\tcgmes/cgmes-conversion/src/test/java/com/powsybl/cgmes/conversion/test/conformity/modified/CgmesConformity1ModifiedConversionTest.java", "committedDate": "2020-10-26T12:07:50Z", "type": "commit"}, {"oid": "0c3dd838957b79175716d600fc17fd6baa4489e8", "url": "https://github.com/powsybl/powsybl-core/commit/0c3dd838957b79175716d600fc17fd6baa4489e8", "message": "Apply reviewer comments\n\nSigned-off-by: Jos\u00e9 Antonio Marqu\u00e9s <marquesja@aia.es>", "committedDate": "2020-10-26T16:50:03Z", "type": "commit"}, {"oid": "aca6f57b04795f33ad298d467f00a207a1b89768", "url": "https://github.com/powsybl/powsybl-core/commit/aca6f57b04795f33ad298d467f00a207a1b89768", "message": "simplify access to voltage level from terminal\n\nSigned-off-by: Luma <zamarrenolm@aia.es>", "committedDate": "2020-10-26T17:03:57Z", "type": "commit"}, {"oid": "c612b38c73c927f94b05e49b29da052d85917f4b", "url": "https://github.com/powsybl/powsybl-core/commit/c612b38c73c927f94b05e49b29da052d85917f4b", "message": "Merge branch 'master' into cgmes_conversion_joinVoltageLevels", "committedDate": "2020-10-26T17:50:00Z", "type": "commit"}, {"oid": "43d9289eeeea35fda948111c63883568a2b37a60", "url": "https://github.com/powsybl/powsybl-core/commit/43d9289eeeea35fda948111c63883568a2b37a60", "message": "Merge branch 'master' into cgmes_conversion_joinVoltageLevels", "committedDate": "2020-10-27T09:23:36Z", "type": "commit"}, {"oid": "c615a26dfa5b29e22bfc9cded8c3a3e99d888a55", "url": "https://github.com/powsybl/powsybl-core/commit/c615a26dfa5b29e22bfc9cded8c3a3e99d888a55", "message": "fix style\n\nSigned-off-by: Luma <zamarrenolm@aia.es>", "committedDate": "2020-10-27T09:50:15Z", "type": "commit"}, {"oid": "3eacf3fd21eaeed5aa579de1d34b52189d03e07f", "url": "https://github.com/powsybl/powsybl-core/commit/3eacf3fd21eaeed5aa579de1d34b52189d03e07f", "message": "Merge branch 'master' into cgmes_conversion_joinVoltageLevels", "committedDate": "2020-11-05T08:42:38Z", "type": "commit"}]}