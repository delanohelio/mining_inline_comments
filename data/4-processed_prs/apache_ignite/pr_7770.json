{"pr_number": 7770, "pr_title": "IGNITE-12981: Fix pme-free snapshot exchange if coordinator left the cluster", "pr_createdAt": "2020-05-04T13:30:01Z", "pr_url": "https://github.com/apache/ignite/pull/7770", "timeline": [{"oid": "ff4f6133c01bfed161a516dac9de5156dfcc21b2", "url": "https://github.com/apache/ignite/commit/ff4f6133c01bfed161a516dac9de5156dfcc21b2", "message": "IGNITE-12981: wip", "committedDate": "2020-05-04T13:28:54Z", "type": "commit"}, {"oid": "de45132e35086972d02b3d070c46f0962defadd5", "url": "https://github.com/apache/ignite/commit/de45132e35086972d02b3d070c46f0962defadd5", "message": "IGNITE-12981: wip", "committedDate": "2020-05-04T14:32:41Z", "type": "commit"}, {"oid": "958e33e9d5114ec23dc74fc6e77322929242cef2", "url": "https://github.com/apache/ignite/commit/958e33e9d5114ec23dc74fc6e77322929242cef2", "message": "IGNITE-12981: fix was rebalanced flag causes partition resend", "committedDate": "2020-05-04T18:52:26Z", "type": "commit"}, {"oid": "765ca0cfa3b02cd97a91ae99396f91b5bb8c052a", "url": "https://github.com/apache/ignite/commit/765ca0cfa3b02cd97a91ae99396f91b5bb8c052a", "message": "IGNITE-12981: extend test coverage for snapshot", "committedDate": "2020-05-05T16:57:32Z", "type": "commit"}, {"oid": "ba88f3f4c411225178a25af3cb8c1dd3df2d8420", "url": "https://github.com/apache/ignite/commit/ba88f3f4c411225178a25af3cb8c1dd3df2d8420", "message": "IGNITE-12981: remove unnecessary comment", "committedDate": "2020-05-05T18:40:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDY0NDk1MQ==", "url": "https://github.com/apache/ignite/pull/7770#discussion_r420644951", "bodyText": "Unnecessary line brake", "author": "NSAmelchev", "createdAt": "2020-05-06T09:05:04Z", "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/persistence/snapshot/IgniteClusterSnapshotSelfTest.java", "diffHunk": "@@ -854,6 +863,190 @@ public void testClusterSnapshotWithSharedCacheGroup() throws Exception {\n         assertSnapshotCacheKeys(snp.cache(ccfg2.getName()));\n     }\n \n+    /** @throws Exception If fails. */\n+    @Test\n+    public void testClusterSnapshotCoordinatorStopped() throws Exception {\n+        CountDownLatch block = new CountDownLatch(1);\n+        startGridsWithCache(3, dfltCacheCfg, CACHE_KEYS_RANGE);\n+        startClientGrid(3);\n+\n+        awaitPartitionMapExchange();\n+\n+        for (Ignite grid : Arrays.asList(grid(1), grid(2))) {\n+            ((IgniteEx)grid).context().cache().context().exchange()\n+                .registerExchangeAwareComponent(new PartitionsExchangeAware() {\n+                    /** {@inheritDoc} */\n+                    @Override public void onInitBeforeTopologyLock(GridDhtPartitionsExchangeFuture fut) {\n+                        try {\n+                            block.await();\n+                        }\n+                        catch (InterruptedException e) {\n+                            fail(\"Must not catch exception here: \" + e.getMessage());\n+                        }\n+                    }\n+                });\n+        }\n+\n+        for (Ignite grid : G.allGrids()) {\n+            TestRecordingCommunicationSpi.spi(grid)\n+                .blockMessages((node, msg) -> msg instanceof GridDhtPartitionsSingleMessage);\n+        }\n+\n+        IgniteFuture<Void> fut = grid(1).snapshot().createSnapshot(SNAPSHOT_NAME);\n+\n+        stopGrid(0);\n+\n+        block.countDown();\n+\n+        // There are two exchanges happen: snapshot, node left (with pme-free).\n+        // Both of them are not require for sending messages.\n+        assertFalse(\"Pme-free switch doesn't expect messaging exchanging between nodes\",\n+            GridTestUtils.waitForCondition(() -> {\n+                boolean hasMsgs = false;\n+\n+                for (Ignite g : G.allGrids())\n+                    hasMsgs |= TestRecordingCommunicationSpi.spi(g).hasBlockedMessages();\n+\n+                return hasMsgs;\n+            }, 5_000));\n+\n+        assertThrowsWithCause((Callable<Object>)fut::get, IgniteException.class);\n+\n+        List<GridDhtPartitionsExchangeFuture> exchFuts =\n+            grid(1).context().cache().context().exchange().exchangeFutures();\n+\n+        assertFalse(\"Exchanges cannot be empty due to snapshot and node left happened\",\n+            exchFuts.isEmpty());\n+\n+        for (GridDhtPartitionsExchangeFuture exch : exchFuts) {\n+            assertTrue(\"Snapshot and node left events must keep `rebalanced` state\" + exch,\n+                exch.rebalanced());\n+        }\n+    }\n+\n+    /** @throws Exception If fails. */\n+    @Test\n+    public void testClusterSnapshotOnMovingPartitionsCoordinatorLeft() throws Exception {\n+        startGridsWithCache(2, dfltCacheCfg, CACHE_KEYS_RANGE);\n+\n+        for (Ignite grid : G.allGrids()) {\n+            TestRecordingCommunicationSpi.spi(grid)\n+                .blockMessages((node, msg) -> msg instanceof GridDhtPartitionSupplyMessage);\n+        }\n+\n+        Ignite ignite = startGrid(2);\n+\n+        ignite.cluster().setBaselineTopology(ignite.cluster().topologyVersion());\n+\n+        TestRecordingCommunicationSpi.spi(grid(0))\n+            .waitForBlocked();\n+\n+        CountDownLatch latch = new CountDownLatch(G.allGrids().size());\n+        IgniteInternalFuture<?> stopFut = GridTestUtils.runAsync(() -> {\n+            try {\n+                U.await(latch);\n+\n+                stopGrid(0);\n+            }\n+            catch (IgniteInterruptedCheckedException e) {\n+                fail(\"Must not fail here: \" + e.getMessage());\n+            }\n+        });\n+\n+        Queue<T2<GridDhtPartitionExchangeId, Boolean>> exchFuts = new ConcurrentLinkedQueue<>();\n+\n+        for (Ignite ig : G.allGrids()) {\n+            ((IgniteEx)ig).context().cache().context().exchange()\n+                .registerExchangeAwareComponent(new PartitionsExchangeAware() {\n+                    /** {@inheritDoc} */\n+                    @Override public void onInitBeforeTopologyLock(GridDhtPartitionsExchangeFuture fut) {\n+                        try {\n+                            exchFuts.add(new T2<>(fut.exchangeId(), fut.rebalanced()));\n+                            latch.countDown();\n+\n+                            stopFut.get();\n+                        }\n+                        catch (IgniteCheckedException e) {\n+                            U.log(log, \"Interrupted on coordinator: \" + e.getMessage());\n+                        }\n+                    }\n+                });\n+        }\n+\n+        IgniteFuture<Void> fut = ignite.snapshot().createSnapshot(SNAPSHOT_NAME);\n+\n+        stopFut.get();\n+\n+        assertThrowsAnyCause(log,\n+            fut::get,\n+            IgniteException.class,\n+            \"Snapshot creation has been finished with an error\");\n+\n+        assertEquals(\"Snapshot futures expected: \" + exchFuts, 3, exchFuts.size());\n+\n+        for (T2<GridDhtPartitionExchangeId, Boolean> exch : exchFuts)\n+            assertFalse(\"Snapshot `rebalanced` must be false with moving partitions: \" + exch.get1(), exch.get2());\n+", "originalCommit": "ba88f3f4c411225178a25af3cb8c1dd3df2d8420", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcyOTk2Mg==", "url": "https://github.com/apache/ignite/pull/7770#discussion_r420729962", "bodyText": "fixed.", "author": "Mmuzaf", "createdAt": "2020-05-06T11:50:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDY0NDk1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDY0NTA5Mw==", "url": "https://github.com/apache/ignite/pull/7770#discussion_r420645093", "bodyText": "Can be one line", "author": "NSAmelchev", "createdAt": "2020-05-06T09:05:22Z", "path": "modules/core/src/test/java/org/apache/ignite/internal/processors/cache/persistence/snapshot/IgniteClusterSnapshotSelfTest.java", "diffHunk": "@@ -854,6 +863,190 @@ public void testClusterSnapshotWithSharedCacheGroup() throws Exception {\n         assertSnapshotCacheKeys(snp.cache(ccfg2.getName()));\n     }\n \n+    /** @throws Exception If fails. */\n+    @Test\n+    public void testClusterSnapshotCoordinatorStopped() throws Exception {\n+        CountDownLatch block = new CountDownLatch(1);\n+        startGridsWithCache(3, dfltCacheCfg, CACHE_KEYS_RANGE);\n+        startClientGrid(3);\n+\n+        awaitPartitionMapExchange();\n+\n+        for (Ignite grid : Arrays.asList(grid(1), grid(2))) {\n+            ((IgniteEx)grid).context().cache().context().exchange()\n+                .registerExchangeAwareComponent(new PartitionsExchangeAware() {\n+                    /** {@inheritDoc} */\n+                    @Override public void onInitBeforeTopologyLock(GridDhtPartitionsExchangeFuture fut) {\n+                        try {\n+                            block.await();\n+                        }\n+                        catch (InterruptedException e) {\n+                            fail(\"Must not catch exception here: \" + e.getMessage());\n+                        }\n+                    }\n+                });\n+        }\n+\n+        for (Ignite grid : G.allGrids()) {\n+            TestRecordingCommunicationSpi.spi(grid)\n+                .blockMessages((node, msg) -> msg instanceof GridDhtPartitionsSingleMessage);\n+        }\n+\n+        IgniteFuture<Void> fut = grid(1).snapshot().createSnapshot(SNAPSHOT_NAME);\n+\n+        stopGrid(0);\n+\n+        block.countDown();\n+\n+        // There are two exchanges happen: snapshot, node left (with pme-free).\n+        // Both of them are not require for sending messages.\n+        assertFalse(\"Pme-free switch doesn't expect messaging exchanging between nodes\",\n+            GridTestUtils.waitForCondition(() -> {\n+                boolean hasMsgs = false;\n+\n+                for (Ignite g : G.allGrids())\n+                    hasMsgs |= TestRecordingCommunicationSpi.spi(g).hasBlockedMessages();\n+\n+                return hasMsgs;\n+            }, 5_000));\n+\n+        assertThrowsWithCause((Callable<Object>)fut::get, IgniteException.class);\n+\n+        List<GridDhtPartitionsExchangeFuture> exchFuts =\n+            grid(1).context().cache().context().exchange().exchangeFutures();\n+\n+        assertFalse(\"Exchanges cannot be empty due to snapshot and node left happened\",\n+            exchFuts.isEmpty());\n+\n+        for (GridDhtPartitionsExchangeFuture exch : exchFuts) {\n+            assertTrue(\"Snapshot and node left events must keep `rebalanced` state\" + exch,\n+                exch.rebalanced());\n+        }\n+    }\n+\n+    /** @throws Exception If fails. */\n+    @Test\n+    public void testClusterSnapshotOnMovingPartitionsCoordinatorLeft() throws Exception {\n+        startGridsWithCache(2, dfltCacheCfg, CACHE_KEYS_RANGE);\n+\n+        for (Ignite grid : G.allGrids()) {\n+            TestRecordingCommunicationSpi.spi(grid)\n+                .blockMessages((node, msg) -> msg instanceof GridDhtPartitionSupplyMessage);\n+        }\n+\n+        Ignite ignite = startGrid(2);\n+\n+        ignite.cluster().setBaselineTopology(ignite.cluster().topologyVersion());\n+\n+        TestRecordingCommunicationSpi.spi(grid(0))\n+            .waitForBlocked();\n+\n+        CountDownLatch latch = new CountDownLatch(G.allGrids().size());\n+        IgniteInternalFuture<?> stopFut = GridTestUtils.runAsync(() -> {\n+            try {\n+                U.await(latch);\n+\n+                stopGrid(0);\n+            }\n+            catch (IgniteInterruptedCheckedException e) {\n+                fail(\"Must not fail here: \" + e.getMessage());\n+            }\n+        });\n+\n+        Queue<T2<GridDhtPartitionExchangeId, Boolean>> exchFuts = new ConcurrentLinkedQueue<>();\n+\n+        for (Ignite ig : G.allGrids()) {\n+            ((IgniteEx)ig).context().cache().context().exchange()\n+                .registerExchangeAwareComponent(new PartitionsExchangeAware() {\n+                    /** {@inheritDoc} */\n+                    @Override public void onInitBeforeTopologyLock(GridDhtPartitionsExchangeFuture fut) {\n+                        try {\n+                            exchFuts.add(new T2<>(fut.exchangeId(), fut.rebalanced()));\n+                            latch.countDown();\n+\n+                            stopFut.get();\n+                        }\n+                        catch (IgniteCheckedException e) {\n+                            U.log(log, \"Interrupted on coordinator: \" + e.getMessage());\n+                        }\n+                    }\n+                });\n+        }\n+\n+        IgniteFuture<Void> fut = ignite.snapshot().createSnapshot(SNAPSHOT_NAME);\n+\n+        stopFut.get();\n+\n+        assertThrowsAnyCause(log,\n+            fut::get,\n+            IgniteException.class,\n+            \"Snapshot creation has been finished with an error\");\n+\n+        assertEquals(\"Snapshot futures expected: \" + exchFuts, 3, exchFuts.size());\n+\n+        for (T2<GridDhtPartitionExchangeId, Boolean> exch : exchFuts)\n+            assertFalse(\"Snapshot `rebalanced` must be false with moving partitions: \" + exch.get1(), exch.get2());\n+\n+    }\n+\n+    /** @throws Exception If fails. */\n+    @Test\n+    public void testSnapshotPartitionExchangeAwareOrder() throws Exception {\n+        IgniteEx ignite = startGridsWithCache(3, dfltCacheCfg, CACHE_KEYS_RANGE);\n+\n+        Map<UUID, PartitionsExchangeAware> comps = new HashMap<>();\n+\n+        for (Ignite ig : G.allGrids()) {\n+            PartitionsExchangeAware comp;\n+\n+            ((IgniteEx)ig).context().cache().context().exchange()\n+                .registerExchangeAwareComponent(comp = new PartitionsExchangeAware() {\n+                    /** Order of exchange calls. */\n+                    private final AtomicInteger order = new AtomicInteger();\n+\n+                    /** {@inheritDoc} */\n+                    @Override public void onInitBeforeTopologyLock(GridDhtPartitionsExchangeFuture fut) {\n+                        assertEquals(\"Exchange order violated: \" + fut.firstEvent(), 0, order.getAndIncrement());\n+                    }\n+\n+                    /** {@inheritDoc} */\n+                    @Override public void onInitAfterTopologyLock(GridDhtPartitionsExchangeFuture fut) {\n+                        assertEquals(\"Exchange order violated: \" + fut.firstEvent(), 1, order.getAndIncrement());\n+                    }\n+\n+                    /** {@inheritDoc} */\n+                    @Override public void onDoneBeforeTopologyUnlock(GridDhtPartitionsExchangeFuture fut) {\n+                        assertEquals(\"Exchange order violated: \" + fut.firstEvent(), 2, order.getAndIncrement());\n+                    }\n+\n+                    /** {@inheritDoc} */\n+                    @Override public void onDoneAfterTopologyUnlock(GridDhtPartitionsExchangeFuture fut) {\n+                        assertEquals(\"Exchange order violated: \" + fut.firstEvent(), 3, order.getAndSet(0));\n+                    }\n+                });\n+\n+            comps.put(((IgniteEx)ig).localNode().id(), comp);\n+        }\n+\n+        ignite.snapshot().createSnapshot(SNAPSHOT_NAME)", "originalCommit": "ba88f3f4c411225178a25af3cb8c1dd3df2d8420", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDczMDAxMw==", "url": "https://github.com/apache/ignite/pull/7770#discussion_r420730013", "bodyText": "fixed.", "author": "Mmuzaf", "createdAt": "2020-05-06T11:50:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDY0NTA5Mw=="}], "type": "inlineReview"}, {"oid": "526b16c58792beb7ec4992df3c210f76b537d8e0", "url": "https://github.com/apache/ignite/commit/526b16c58792beb7ec4992df3c210f76b537d8e0", "message": "IGNITE-12981: fix review comments", "committedDate": "2020-05-06T11:50:04Z", "type": "commit"}]}