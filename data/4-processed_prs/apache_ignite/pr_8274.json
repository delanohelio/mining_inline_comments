{"pr_number": 8274, "pr_title": "IGNITE-13481 Fix decorators @ignite_versions and @version_if. Introdu\u2026", "pr_createdAt": "2020-09-24T10:25:15Z", "pr_url": "https://github.com/apache/ignite/pull/8274", "timeline": [{"oid": "9a4135cd2d5a5aad83d834a6e981e8bc21b9aa02", "url": "https://github.com/apache/ignite/commit/9a4135cd2d5a5aad83d834a6e981e8bc21b9aa02", "message": "IGNITE-13481 Fix decorators @ignite_versions and @version_if. Introduce unit tests.", "committedDate": "2020-09-24T10:24:19Z", "type": "commit"}, {"oid": "d6ed1cb7736d037270bac40e75f4d10f194f3b42", "url": "https://github.com/apache/ignite/commit/d6ed1cb7736d037270bac40e75f4d10f194f3b42", "message": "IGNITE-13481 Fix travis.yml", "committedDate": "2020-09-24T12:54:22Z", "type": "commit"}, {"oid": "2b8c098a0321e761550228e3298c250665c34fa6", "url": "https://github.com/apache/ignite/commit/2b8c098a0321e761550228e3298c250665c34fa6", "message": "IGNITE-13481 Fix buggy travis-tox and matrix.", "committedDate": "2020-09-24T14:17:41Z", "type": "commit"}, {"oid": "45ff77aa1cc900ff5e5a569006ab3c315eee8ffe", "url": "https://github.com/apache/ignite/commit/45ff77aa1cc900ff5e5a569006ab3c315eee8ffe", "message": "IGNITE-13481 Fixes.", "committedDate": "2020-09-24T14:57:33Z", "type": "commit"}, {"oid": "6754f7d44e8bcc6ddb4efe3d5679fb9947d16297", "url": "https://github.com/apache/ignite/commit/6754f7d44e8bcc6ddb4efe3d5679fb9947d16297", "message": "IGNITE-13481 Hope that final fixes", "committedDate": "2020-09-24T15:41:34Z", "type": "commit"}, {"oid": "94016342209cbe5afbc3401f3c0eede3841e8c05", "url": "https://github.com/apache/ignite/commit/94016342209cbe5afbc3401f3c0eede3841e8c05", "message": "IGNITE-13481 Additional asserts in unit test.", "committedDate": "2020-09-24T16:57:51Z", "type": "commit"}, {"oid": "291357f3ef66b2e79471304a47f332d6f8c88c4b", "url": "https://github.com/apache/ignite/commit/291357f3ef66b2e79471304a47f332d6f8c88c4b", "message": "IGNITE-13481 Add some help.", "committedDate": "2020-09-25T08:21:35Z", "type": "commit"}, {"oid": "2a7773a30b0569b62600a225015e101804bcd0b1", "url": "https://github.com/apache/ignite/commit/2a7773a30b0569b62600a225015e101804bcd0b1", "message": "IGNITE-13481 Fix markdown.", "committedDate": "2020-09-25T08:24:02Z", "type": "commit"}, {"oid": "ffb49b04dd77b15f64084e586e5fae3be82ea109", "url": "https://github.com/apache/ignite/commit/ffb49b04dd77b15f64084e586e5fae3be82ea109", "message": "IGNITE-13481 Add some more.", "committedDate": "2020-09-25T08:31:37Z", "type": "commit"}, {"oid": "151af7412f7615814ca566b8d1704b0ed110e83e", "url": "https://github.com/apache/ignite/commit/151af7412f7615814ca566b8d1704b0ed110e83e", "message": "IGNITE-13481 Add some more.", "committedDate": "2020-09-25T08:31:59Z", "type": "commit"}, {"oid": "534c69b2f63cde1a0b19c381ea80e4af9a4c1ccd", "url": "https://github.com/apache/ignite/commit/534c69b2f63cde1a0b19c381ea80e4af9a4c1ccd", "message": "IGNITE-13481 Add some more.", "committedDate": "2020-09-25T08:33:05Z", "type": "commit"}, {"oid": "4dd82fc70ddba7a1442b1852b228befa9138de97", "url": "https://github.com/apache/ignite/commit/4dd82fc70ddba7a1442b1852b228befa9138de97", "message": "IGNITE-13481 Fix skipping codestyle check", "committedDate": "2020-09-25T09:41:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk4NzAwMA==", "url": "https://github.com/apache/ignite/pull/8274#discussion_r494987000", "bodyText": "What is a purpose to install ignitetest?", "author": "timoninmaxim", "createdAt": "2020-09-25T13:28:07Z", "path": "modules/ducktests/tests/README.md", "diffHunk": "@@ -2,21 +2,59 @@\n The `ignitetest` framework provides basic functionality and services\n to write integration tests for Apache Ignite. This framework bases on \n the `ducktape` test framework, for information about it check the links:\n-- https://github.com/confluentinc/ducktape - source code of the `ducktape`;\n+- https://github.com/confluentinc/ducktape - source code of the `ducktape`.\n - http://ducktape-docs.readthedocs.io - documentation to the `ducktape`.\n \n-Structure of the `ignitetest` directory is:\n-- `./ignitetest/services` contains basic services functionality;\n-- `./ignitetest/utils` contains utils for testing;\n+Structure of the `tests` directory is:\n+- `./ignitetest/services` contains basic services functionality.\n+- `./ignitetest/utils` contains utils for testing.\n - `./ignitetest/tests` contains tests.\n+- `./checks` contains unit tests of utils, tests' decorators etc. \n \n Docker is used to emulate distributed environment. Single container represents \n a running node.\n \n ## Requirements\n To just start tests locally the only requirement is preinstalled `docker`. \n+For development process requirements are `python` >= 3.6.\n \n-For development process requirements are:\n-1. `python` >= 3.6;\n-2. `tox` (check python codestyle);\n-3. `docker`.\n+## Run tests locally\n+- Change a current directory to`${IGNITE_HOME}`\n+- Build Apache IGNITE invoking `${IGNITE_HOME}/scripts/build.sh`\n+- Change a current directory to `${IGNITE_HOME}/modules/ducktests/tests`\n+- Run tests in docker containers using a following command:\n+```\n+./docker/run_tests.sh\n+```\n+- For detailed help and instructions, use a following command:\n+```\n+./docker/run_tests.sh --help\n+```\n+\n+## Preparing development environment\n+- Create a virtual environment and activate it using following commands:\n+```\n+python3 -m venv ~/.virtualenvs/ignite-ducktests-dev\n+source ~/.virtualenvs/ignite-ducktests-dev/bin/activate\n+```\n+- Change a current directory to `${IGNITE_HOME}/modules/ducktests/tests`. We refer to it as `${DUCKTESTS_DIR}`.\n+- Install requirements and `ignitetests` as editable using following commands:\n+```\n+pip install -r docker/requirements-dev.txt\n+pip install -e .", "originalCommit": "4dd82fc70ddba7a1442b1852b228befa9138de97", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA0NDA0MA==", "url": "https://github.com/apache/ignite/pull/8274#discussion_r495044040", "bodyText": "This is required for pytest. Usual thing", "author": "ivandasch", "createdAt": "2020-09-25T14:54:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk4NzAwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTAxOTE1MQ==", "url": "https://github.com/apache/ignite/pull/8274#discussion_r495019151", "bodyText": "Why do you check only 'ver' and not others (ver_1, ver_2, ignit_verson)?", "author": "timoninmaxim", "createdAt": "2020-09-25T14:16:41Z", "path": "modules/ducktests/tests/checks/utils/check_marks.py", "diffHunk": "@@ -0,0 +1,240 @@\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+\"\"\"\n+Checks custom parametrizers.\n+\"\"\"\n+\n+import itertools\n+from unittest.mock import Mock\n+\n+import pytest\n+from ducktape.mark import parametrized, parametrize, matrix, ignore\n+from ducktape.mark.mark_expander import MarkedFunctionExpander\n+\n+from ignitetest.utils._mark import IgniteVersionParametrize, ignite_versions, version_if\n+from ignitetest.utils.version import IgniteVersion, V_2_8_0, V_2_8_1, V_2_7_6, DEV_BRANCH\n+\n+\n+def expand_function(*, func, sess_ctx):\n+    \"\"\"\n+    Inject parameters into function and generate context list.\n+    \"\"\"\n+    assert parametrized(func)\n+    assert next(filter(lambda x: isinstance(x, IgniteVersionParametrize), func.marks), None)\n+\n+    return MarkedFunctionExpander(session_context=sess_ctx, function=func).expand()\n+\n+\n+def mock_session_ctx(*, global_args=None):\n+    \"\"\"\n+    Create mock of session context.\n+    \"\"\"\n+    sess_ctx = Mock()\n+    sess_ctx.globals = global_args if global_args else {}\n+\n+    return sess_ctx\n+\n+\n+class CheckIgniteVersions:\n+    \"\"\"\n+    Checks @ignite_version parametrization.\n+    \"\"\"\n+    single_params = itertools.product(\n+        [[str(V_2_8_1)], [str(V_2_8_1), str(DEV_BRANCH)]],\n+        [{}, {'ignite_versions': 'dev'}, {'ignite_versions': ['2.8.1', 'dev']}]\n+    )\n+\n+    @pytest.mark.parametrize(\n+        ['versions', 'global_args'],\n+        list(map(lambda x: pytest.param(x[0], x[1]), single_params))\n+    )\n+    def check_injection(self, versions, global_args):\n+        \"\"\"\n+        Checks parametrization with single version.\n+        \"\"\"\n+        @ignite_versions(*versions, version_prefix='ver')\n+        def function(ver):\n+            return IgniteVersion(ver)\n+\n+        context_list = expand_function(func=function, sess_ctx=mock_session_ctx(global_args=global_args))\n+\n+        self._check_injection(context_list, versions=versions, global_args=global_args)\n+\n+    pair_params = itertools.product(\n+        [[(str(DEV_BRANCH), str(V_2_8_1))], [(str(DEV_BRANCH), str(V_2_8_0)), (str(DEV_BRANCH), str(V_2_8_1))]],\n+        [{}, {'ignite_versions': [['2.8.1', '2.7.6'], ['2.8.1', '2.8.0']]}, {'ignite_versions': [['dev', '2.8.1']]}]\n+    )\n+\n+    @pytest.mark.parametrize(\n+        ['versions', 'global_args'],\n+        list(map(lambda x: pytest.param(x[0], x[1]), pair_params))\n+    )\n+    def check_injection_pairs(self, versions, global_args):\n+        \"\"\"\n+        Checks parametrization with pair of versions.\n+        \"\"\"\n+        @ignite_versions(*versions, version_prefix='pair')\n+        def function(pair_1, pair_2):\n+            return IgniteVersion(pair_1), IgniteVersion(pair_2)\n+\n+        context_list = expand_function(func=function, sess_ctx=mock_session_ctx(global_args=global_args))\n+\n+        self._check_injection(context_list, versions=versions, global_args=global_args, pairs=True)\n+\n+    @pytest.mark.parametrize(\n+        ['versions', 'version_prefix', 'global_args'],\n+        [\n+            pytest.param([(DEV_BRANCH, V_2_8_1)], 'ver', {}),\n+            pytest.param([DEV_BRANCH], 'ver', {'ignite_versions': [['dev', '2.8.1']]}),\n+            pytest.param([DEV_BRANCH], 'invalid_prefix', {})\n+        ]\n+    )\n+    def check_injection_fail(self, versions, version_prefix, global_args):\n+        \"\"\"\n+        Check incorrect injecting variables with single parameter.\n+        \"\"\"\n+        @ignite_versions(*versions, version_prefix=version_prefix)\n+        def function(ver):\n+            return IgniteVersion(ver)\n+\n+        with pytest.raises(Exception):\n+            context_list = expand_function(func=function, sess_ctx=mock_session_ctx(global_args=global_args))\n+\n+            self._check_injection(context_list, versions=versions, global_args=global_args)\n+\n+    @pytest.mark.parametrize(\n+        ['versions', 'version_prefix', 'global_args'],\n+        [\n+            pytest.param([DEV_BRANCH, V_2_8_1], 'pair', {}),\n+            pytest.param([(DEV_BRANCH, V_2_8_1)], 'pair', {'ignite_versions': 'dev'}),\n+            pytest.param([(DEV_BRANCH, V_2_8_1)], 'pair', {'ignite_versions': ['dev', '2.8.1']}),\n+            pytest.param([(DEV_BRANCH, V_2_8_1)], 'invalid_prefix', {})\n+        ]\n+    )\n+    def check_injection_pairs_fail(self, versions, version_prefix, global_args):\n+        \"\"\"\n+        Check incorrect injecting with pairs of versions.\n+        \"\"\"\n+        @ignite_versions(*versions, version_prefix=version_prefix)\n+        def function(pair_1, pair_2):\n+            return IgniteVersion(pair_1), IgniteVersion(pair_2)\n+\n+        with pytest.raises(Exception):\n+            context_list = expand_function(func=function, sess_ctx=mock_session_ctx(global_args=global_args))\n+\n+            self._check_injection(context_list, versions=versions, global_args=global_args, pairs=True)\n+\n+    def check_with_others_marks(self):  # pylint: disable=R0201\n+        \"\"\"\n+        Checks that ignite version parametrization works with others correctly.\n+        \"\"\"\n+        @ignite_versions(str(DEV_BRANCH), str(V_2_8_1), version_prefix='ver')\n+        @parametrize(x=10, y=20)\n+        @parametrize(x=30, y=40)\n+        def function_parametrize(ver, x, y):\n+            return ver, x, y\n+\n+        @ignite_versions((str(DEV_BRANCH), str(V_2_8_1)), (str(V_2_8_1), str(V_2_7_6)), version_prefix='pair')\n+        @matrix(i=[10, 20], j=[30, 40])\n+        def function_matrix(pair_1, pair_2, i, j):\n+            return pair_1, pair_2, i, j\n+\n+        @ignore(ver=str(DEV_BRANCH))\n+        @ignite_versions(str(DEV_BRANCH), str(V_2_8_1), version_prefix='ver')\n+        def function_ignore(ver):\n+            return ver\n+\n+        context_list = expand_function(func=function_parametrize, sess_ctx=mock_session_ctx())\n+        context_list += expand_function(func=function_matrix, sess_ctx=mock_session_ctx())\n+        context_list += expand_function(func=function_ignore, sess_ctx=mock_session_ctx())\n+\n+        assert len(context_list) == 14\n+\n+        parametrized_context = list(filter(lambda x: x.function_name == function_parametrize.__name__, context_list))\n+        assert len(parametrized_context) == 4\n+        for ctx in parametrized_context:\n+            args = ctx.injected_args\n+            assert len(args) == 3\n+            assert ctx.function() == (args['ver'], args['x'], args['y'])\n+\n+        matrix_context = list(filter(lambda x: x.function_name == function_matrix.__name__, context_list))\n+        assert len(matrix_context) == 8\n+        for ctx in matrix_context:\n+            args = ctx.injected_args\n+            assert len(args) == 4\n+            assert ctx.function() == (args['pair_1'], args['pair_2'], args['i'], args['j'])\n+\n+        assert len(list(filter(lambda x: x.function_name == function_ignore.__name__, context_list))) == 2\n+        assert len(list(filter(lambda x: x.ignore, context_list))) == 1\n+\n+    @staticmethod\n+    def _check_injection(context_list, *, versions, global_args=None, pairs=False):\n+        if global_args:\n+            global_versions = global_args['ignite_versions']\n+\n+            if isinstance(global_versions, str):\n+                assert not pairs\n+\n+                check_versions = [IgniteVersion(global_versions)]\n+            elif isinstance(global_args['ignite_versions'], tuple):\n+                assert pairs\n+\n+                check_versions = [tuple(map(IgniteVersion, global_versions))]\n+            elif pairs:\n+                check_versions = list(map(lambda x: (IgniteVersion(x[0]), IgniteVersion(x[1])), global_versions))\n+            else:\n+                check_versions = list(map(IgniteVersion, global_versions))\n+        else:\n+            check_versions = list(map(IgniteVersion, versions)) if not pairs else \\\n+                list(map(lambda x: (IgniteVersion(x[0]), IgniteVersion(x[1])), versions))\n+\n+        assert len(context_list) == len(check_versions)\n+\n+        for i, ctx in enumerate(sorted(context_list, key=lambda x: x.function())):\n+            assert ctx.function() == check_versions[i]\n+\n+\n+class CheckVersionIf:\n+    \"\"\"\n+    Checks @version_if parametrization.\n+    \"\"\"\n+    def check_common(self):  # pylint: disable=R0201\n+        \"\"\"\n+        Check common scenarios with @ignite_versions parametrization.\n+        \"\"\"\n+        @version_if(lambda ver: ver != V_2_8_0, variable_name='ver')\n+        @ignite_versions(str(DEV_BRANCH), str(V_2_8_0), version_prefix='ver')\n+        def function_1(ver):\n+            return IgniteVersion(ver)\n+\n+        @version_if(lambda ver: ver > V_2_7_6, variable_name='ver_1')\n+        @version_if(lambda ver: ver < V_2_8_0, variable_name='ver_2')\n+        @ignite_versions((str(V_2_8_1), str(V_2_8_0)), (str(V_2_8_0), str(V_2_7_6)), version_prefix='ver')\n+        def function_2(ver_1, ver_2):\n+            return IgniteVersion(ver_1), IgniteVersion(ver_2)\n+\n+        @ignite_versions(str(DEV_BRANCH), str(V_2_8_0))\n+        def function_3(ignite_version):\n+            return IgniteVersion(ignite_version)\n+\n+        context_list = expand_function(func=function_1, sess_ctx=mock_session_ctx())\n+        context_list += expand_function(func=function_2, sess_ctx=mock_session_ctx())\n+        context_list += expand_function(func=function_3, sess_ctx=mock_session_ctx())\n+\n+        assert len(context_list) == 6\n+\n+        assert next(filter(lambda x: x.injected_args['ver'] == str(V_2_8_0), context_list)).ignore\n+        assert not next(filter(lambda x: x.injected_args['ver'] == str(DEV_BRANCH), context_list)).ignore", "originalCommit": "4dd82fc70ddba7a1442b1852b228befa9138de97", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA0NjQzNQ==", "url": "https://github.com/apache/ignite/pull/8274#discussion_r495046435", "bodyText": "Different options are tested in other checks, see below", "author": "ivandasch", "createdAt": "2020-09-25T14:58:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTAxOTE1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTAyODYwMg==", "url": "https://github.com/apache/ignite/pull/8274#discussion_r495028602", "bodyText": "Here and below, list is non-required for parameterize as it works well with generators. Additional converting to list increase code mess. Let's avoid it as much as possible.", "author": "timoninmaxim", "createdAt": "2020-09-25T14:30:38Z", "path": "modules/ducktests/tests/checks/utils/check_marks.py", "diffHunk": "@@ -0,0 +1,240 @@\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+\"\"\"\n+Checks custom parametrizers.\n+\"\"\"\n+\n+import itertools\n+from unittest.mock import Mock\n+\n+import pytest\n+from ducktape.mark import parametrized, parametrize, matrix, ignore\n+from ducktape.mark.mark_expander import MarkedFunctionExpander\n+\n+from ignitetest.utils._mark import IgniteVersionParametrize, ignite_versions, version_if\n+from ignitetest.utils.version import IgniteVersion, V_2_8_0, V_2_8_1, V_2_7_6, DEV_BRANCH\n+\n+\n+def expand_function(*, func, sess_ctx):\n+    \"\"\"\n+    Inject parameters into function and generate context list.\n+    \"\"\"\n+    assert parametrized(func)\n+    assert next(filter(lambda x: isinstance(x, IgniteVersionParametrize), func.marks), None)\n+\n+    return MarkedFunctionExpander(session_context=sess_ctx, function=func).expand()\n+\n+\n+def mock_session_ctx(*, global_args=None):\n+    \"\"\"\n+    Create mock of session context.\n+    \"\"\"\n+    sess_ctx = Mock()\n+    sess_ctx.globals = global_args if global_args else {}\n+\n+    return sess_ctx\n+\n+\n+class CheckIgniteVersions:\n+    \"\"\"\n+    Checks @ignite_version parametrization.\n+    \"\"\"\n+    single_params = itertools.product(\n+        [[str(V_2_8_1)], [str(V_2_8_1), str(DEV_BRANCH)]],\n+        [{}, {'ignite_versions': 'dev'}, {'ignite_versions': ['2.8.1', 'dev']}]\n+    )\n+\n+    @pytest.mark.parametrize(\n+        ['versions', 'global_args'],\n+        list(map(lambda x: pytest.param(x[0], x[1]), single_params))", "originalCommit": "4dd82fc70ddba7a1442b1852b228befa9138de97", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA0Njc5Ng==", "url": "https://github.com/apache/ignite/pull/8274#discussion_r495046796", "bodyText": "Ok", "author": "ivandasch", "createdAt": "2020-09-25T14:58:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTAyODYwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTAzNzY0MQ==", "url": "https://github.com/apache/ignite/pull/8274#discussion_r495037641", "bodyText": "As I understand it checks that test parameters are correct, but do not test decorator itself. So exception in this line can hide error in decorator implementation. For example, test expect exception but test parameters are wrong -> it leads to exception but do not test decorator. Am I correct?", "author": "timoninmaxim", "createdAt": "2020-09-25T14:44:34Z", "path": "modules/ducktests/tests/checks/utils/check_marks.py", "diffHunk": "@@ -0,0 +1,240 @@\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+\"\"\"\n+Checks custom parametrizers.\n+\"\"\"\n+\n+import itertools\n+from unittest.mock import Mock\n+\n+import pytest\n+from ducktape.mark import parametrized, parametrize, matrix, ignore\n+from ducktape.mark.mark_expander import MarkedFunctionExpander\n+\n+from ignitetest.utils._mark import IgniteVersionParametrize, ignite_versions, version_if\n+from ignitetest.utils.version import IgniteVersion, V_2_8_0, V_2_8_1, V_2_7_6, DEV_BRANCH\n+\n+\n+def expand_function(*, func, sess_ctx):\n+    \"\"\"\n+    Inject parameters into function and generate context list.\n+    \"\"\"\n+    assert parametrized(func)\n+    assert next(filter(lambda x: isinstance(x, IgniteVersionParametrize), func.marks), None)\n+\n+    return MarkedFunctionExpander(session_context=sess_ctx, function=func).expand()\n+\n+\n+def mock_session_ctx(*, global_args=None):\n+    \"\"\"\n+    Create mock of session context.\n+    \"\"\"\n+    sess_ctx = Mock()\n+    sess_ctx.globals = global_args if global_args else {}\n+\n+    return sess_ctx\n+\n+\n+class CheckIgniteVersions:\n+    \"\"\"\n+    Checks @ignite_version parametrization.\n+    \"\"\"\n+    single_params = itertools.product(\n+        [[str(V_2_8_1)], [str(V_2_8_1), str(DEV_BRANCH)]],\n+        [{}, {'ignite_versions': 'dev'}, {'ignite_versions': ['2.8.1', 'dev']}]\n+    )\n+\n+    @pytest.mark.parametrize(\n+        ['versions', 'global_args'],\n+        list(map(lambda x: pytest.param(x[0], x[1]), single_params))\n+    )\n+    def check_injection(self, versions, global_args):\n+        \"\"\"\n+        Checks parametrization with single version.\n+        \"\"\"\n+        @ignite_versions(*versions, version_prefix='ver')\n+        def function(ver):\n+            return IgniteVersion(ver)\n+\n+        context_list = expand_function(func=function, sess_ctx=mock_session_ctx(global_args=global_args))\n+\n+        self._check_injection(context_list, versions=versions, global_args=global_args)\n+\n+    pair_params = itertools.product(\n+        [[(str(DEV_BRANCH), str(V_2_8_1))], [(str(DEV_BRANCH), str(V_2_8_0)), (str(DEV_BRANCH), str(V_2_8_1))]],\n+        [{}, {'ignite_versions': [['2.8.1', '2.7.6'], ['2.8.1', '2.8.0']]}, {'ignite_versions': [['dev', '2.8.1']]}]\n+    )\n+\n+    @pytest.mark.parametrize(\n+        ['versions', 'global_args'],\n+        list(map(lambda x: pytest.param(x[0], x[1]), pair_params))\n+    )\n+    def check_injection_pairs(self, versions, global_args):\n+        \"\"\"\n+        Checks parametrization with pair of versions.\n+        \"\"\"\n+        @ignite_versions(*versions, version_prefix='pair')\n+        def function(pair_1, pair_2):\n+            return IgniteVersion(pair_1), IgniteVersion(pair_2)\n+\n+        context_list = expand_function(func=function, sess_ctx=mock_session_ctx(global_args=global_args))\n+\n+        self._check_injection(context_list, versions=versions, global_args=global_args, pairs=True)\n+\n+    @pytest.mark.parametrize(\n+        ['versions', 'version_prefix', 'global_args'],\n+        [\n+            pytest.param([(DEV_BRANCH, V_2_8_1)], 'ver', {}),\n+            pytest.param([DEV_BRANCH], 'ver', {'ignite_versions': [['dev', '2.8.1']]}),\n+            pytest.param([DEV_BRANCH], 'invalid_prefix', {})\n+        ]\n+    )\n+    def check_injection_fail(self, versions, version_prefix, global_args):\n+        \"\"\"\n+        Check incorrect injecting variables with single parameter.\n+        \"\"\"\n+        @ignite_versions(*versions, version_prefix=version_prefix)\n+        def function(ver):\n+            return IgniteVersion(ver)\n+\n+        with pytest.raises(Exception):\n+            context_list = expand_function(func=function, sess_ctx=mock_session_ctx(global_args=global_args))\n+\n+            self._check_injection(context_list, versions=versions, global_args=global_args)\n+\n+    @pytest.mark.parametrize(\n+        ['versions', 'version_prefix', 'global_args'],\n+        [\n+            pytest.param([DEV_BRANCH, V_2_8_1], 'pair', {}),\n+            pytest.param([(DEV_BRANCH, V_2_8_1)], 'pair', {'ignite_versions': 'dev'}),\n+            pytest.param([(DEV_BRANCH, V_2_8_1)], 'pair', {'ignite_versions': ['dev', '2.8.1']}),\n+            pytest.param([(DEV_BRANCH, V_2_8_1)], 'invalid_prefix', {})\n+        ]\n+    )\n+    def check_injection_pairs_fail(self, versions, version_prefix, global_args):\n+        \"\"\"\n+        Check incorrect injecting with pairs of versions.\n+        \"\"\"\n+        @ignite_versions(*versions, version_prefix=version_prefix)\n+        def function(pair_1, pair_2):\n+            return IgniteVersion(pair_1), IgniteVersion(pair_2)\n+\n+        with pytest.raises(Exception):\n+            context_list = expand_function(func=function, sess_ctx=mock_session_ctx(global_args=global_args))\n+\n+            self._check_injection(context_list, versions=versions, global_args=global_args, pairs=True)\n+\n+    def check_with_others_marks(self):  # pylint: disable=R0201\n+        \"\"\"\n+        Checks that ignite version parametrization works with others correctly.\n+        \"\"\"\n+        @ignite_versions(str(DEV_BRANCH), str(V_2_8_1), version_prefix='ver')\n+        @parametrize(x=10, y=20)\n+        @parametrize(x=30, y=40)\n+        def function_parametrize(ver, x, y):\n+            return ver, x, y\n+\n+        @ignite_versions((str(DEV_BRANCH), str(V_2_8_1)), (str(V_2_8_1), str(V_2_7_6)), version_prefix='pair')\n+        @matrix(i=[10, 20], j=[30, 40])\n+        def function_matrix(pair_1, pair_2, i, j):\n+            return pair_1, pair_2, i, j\n+\n+        @ignore(ver=str(DEV_BRANCH))\n+        @ignite_versions(str(DEV_BRANCH), str(V_2_8_1), version_prefix='ver')\n+        def function_ignore(ver):\n+            return ver\n+\n+        context_list = expand_function(func=function_parametrize, sess_ctx=mock_session_ctx())\n+        context_list += expand_function(func=function_matrix, sess_ctx=mock_session_ctx())\n+        context_list += expand_function(func=function_ignore, sess_ctx=mock_session_ctx())\n+\n+        assert len(context_list) == 14\n+\n+        parametrized_context = list(filter(lambda x: x.function_name == function_parametrize.__name__, context_list))\n+        assert len(parametrized_context) == 4\n+        for ctx in parametrized_context:\n+            args = ctx.injected_args\n+            assert len(args) == 3\n+            assert ctx.function() == (args['ver'], args['x'], args['y'])\n+\n+        matrix_context = list(filter(lambda x: x.function_name == function_matrix.__name__, context_list))\n+        assert len(matrix_context) == 8\n+        for ctx in matrix_context:\n+            args = ctx.injected_args\n+            assert len(args) == 4\n+            assert ctx.function() == (args['pair_1'], args['pair_2'], args['i'], args['j'])\n+\n+        assert len(list(filter(lambda x: x.function_name == function_ignore.__name__, context_list))) == 2\n+        assert len(list(filter(lambda x: x.ignore, context_list))) == 1\n+\n+    @staticmethod\n+    def _check_injection(context_list, *, versions, global_args=None, pairs=False):\n+        if global_args:\n+            global_versions = global_args['ignite_versions']\n+\n+            if isinstance(global_versions, str):\n+                assert not pairs", "originalCommit": "4dd82fc70ddba7a1442b1852b228befa9138de97", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA0NTIxNw==", "url": "https://github.com/apache/ignite/pull/8274#discussion_r495045217", "bodyText": "I don't understand you, I tried but no clue what are you talking about", "author": "ivandasch", "createdAt": "2020-09-25T14:56:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTAzNzY0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA1MzE1MA==", "url": "https://github.com/apache/ignite/pull/8274#discussion_r495053150", "bodyText": "removed", "author": "ivandasch", "createdAt": "2020-09-25T15:08:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTAzNzY0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTAzOTE2Mw==", "url": "https://github.com/apache/ignite/pull/8274#discussion_r495039163", "bodyText": "What do you think if split the ternary operation on explicit if-else blocks, so every assignment of check_version is explicitly visible? IMHO, it will make code a bit clearer.", "author": "timoninmaxim", "createdAt": "2020-09-25T14:46:57Z", "path": "modules/ducktests/tests/checks/utils/check_marks.py", "diffHunk": "@@ -0,0 +1,240 @@\n+# Licensed to the Apache Software Foundation (ASF) under one or more\n+# contributor license agreements.  See the NOTICE file distributed with\n+# this work for additional information regarding copyright ownership.\n+# The ASF licenses this file to You under the Apache License, Version 2.0\n+# (the \"License\"); you may not use this file except in compliance with\n+# the License.  You may obtain a copy of the License at\n+#\n+#    http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+\"\"\"\n+Checks custom parametrizers.\n+\"\"\"\n+\n+import itertools\n+from unittest.mock import Mock\n+\n+import pytest\n+from ducktape.mark import parametrized, parametrize, matrix, ignore\n+from ducktape.mark.mark_expander import MarkedFunctionExpander\n+\n+from ignitetest.utils._mark import IgniteVersionParametrize, ignite_versions, version_if\n+from ignitetest.utils.version import IgniteVersion, V_2_8_0, V_2_8_1, V_2_7_6, DEV_BRANCH\n+\n+\n+def expand_function(*, func, sess_ctx):\n+    \"\"\"\n+    Inject parameters into function and generate context list.\n+    \"\"\"\n+    assert parametrized(func)\n+    assert next(filter(lambda x: isinstance(x, IgniteVersionParametrize), func.marks), None)\n+\n+    return MarkedFunctionExpander(session_context=sess_ctx, function=func).expand()\n+\n+\n+def mock_session_ctx(*, global_args=None):\n+    \"\"\"\n+    Create mock of session context.\n+    \"\"\"\n+    sess_ctx = Mock()\n+    sess_ctx.globals = global_args if global_args else {}\n+\n+    return sess_ctx\n+\n+\n+class CheckIgniteVersions:\n+    \"\"\"\n+    Checks @ignite_version parametrization.\n+    \"\"\"\n+    single_params = itertools.product(\n+        [[str(V_2_8_1)], [str(V_2_8_1), str(DEV_BRANCH)]],\n+        [{}, {'ignite_versions': 'dev'}, {'ignite_versions': ['2.8.1', 'dev']}]\n+    )\n+\n+    @pytest.mark.parametrize(\n+        ['versions', 'global_args'],\n+        list(map(lambda x: pytest.param(x[0], x[1]), single_params))\n+    )\n+    def check_injection(self, versions, global_args):\n+        \"\"\"\n+        Checks parametrization with single version.\n+        \"\"\"\n+        @ignite_versions(*versions, version_prefix='ver')\n+        def function(ver):\n+            return IgniteVersion(ver)\n+\n+        context_list = expand_function(func=function, sess_ctx=mock_session_ctx(global_args=global_args))\n+\n+        self._check_injection(context_list, versions=versions, global_args=global_args)\n+\n+    pair_params = itertools.product(\n+        [[(str(DEV_BRANCH), str(V_2_8_1))], [(str(DEV_BRANCH), str(V_2_8_0)), (str(DEV_BRANCH), str(V_2_8_1))]],\n+        [{}, {'ignite_versions': [['2.8.1', '2.7.6'], ['2.8.1', '2.8.0']]}, {'ignite_versions': [['dev', '2.8.1']]}]\n+    )\n+\n+    @pytest.mark.parametrize(\n+        ['versions', 'global_args'],\n+        list(map(lambda x: pytest.param(x[0], x[1]), pair_params))\n+    )\n+    def check_injection_pairs(self, versions, global_args):\n+        \"\"\"\n+        Checks parametrization with pair of versions.\n+        \"\"\"\n+        @ignite_versions(*versions, version_prefix='pair')\n+        def function(pair_1, pair_2):\n+            return IgniteVersion(pair_1), IgniteVersion(pair_2)\n+\n+        context_list = expand_function(func=function, sess_ctx=mock_session_ctx(global_args=global_args))\n+\n+        self._check_injection(context_list, versions=versions, global_args=global_args, pairs=True)\n+\n+    @pytest.mark.parametrize(\n+        ['versions', 'version_prefix', 'global_args'],\n+        [\n+            pytest.param([(DEV_BRANCH, V_2_8_1)], 'ver', {}),\n+            pytest.param([DEV_BRANCH], 'ver', {'ignite_versions': [['dev', '2.8.1']]}),\n+            pytest.param([DEV_BRANCH], 'invalid_prefix', {})\n+        ]\n+    )\n+    def check_injection_fail(self, versions, version_prefix, global_args):\n+        \"\"\"\n+        Check incorrect injecting variables with single parameter.\n+        \"\"\"\n+        @ignite_versions(*versions, version_prefix=version_prefix)\n+        def function(ver):\n+            return IgniteVersion(ver)\n+\n+        with pytest.raises(Exception):\n+            context_list = expand_function(func=function, sess_ctx=mock_session_ctx(global_args=global_args))\n+\n+            self._check_injection(context_list, versions=versions, global_args=global_args)\n+\n+    @pytest.mark.parametrize(\n+        ['versions', 'version_prefix', 'global_args'],\n+        [\n+            pytest.param([DEV_BRANCH, V_2_8_1], 'pair', {}),\n+            pytest.param([(DEV_BRANCH, V_2_8_1)], 'pair', {'ignite_versions': 'dev'}),\n+            pytest.param([(DEV_BRANCH, V_2_8_1)], 'pair', {'ignite_versions': ['dev', '2.8.1']}),\n+            pytest.param([(DEV_BRANCH, V_2_8_1)], 'invalid_prefix', {})\n+        ]\n+    )\n+    def check_injection_pairs_fail(self, versions, version_prefix, global_args):\n+        \"\"\"\n+        Check incorrect injecting with pairs of versions.\n+        \"\"\"\n+        @ignite_versions(*versions, version_prefix=version_prefix)\n+        def function(pair_1, pair_2):\n+            return IgniteVersion(pair_1), IgniteVersion(pair_2)\n+\n+        with pytest.raises(Exception):\n+            context_list = expand_function(func=function, sess_ctx=mock_session_ctx(global_args=global_args))\n+\n+            self._check_injection(context_list, versions=versions, global_args=global_args, pairs=True)\n+\n+    def check_with_others_marks(self):  # pylint: disable=R0201\n+        \"\"\"\n+        Checks that ignite version parametrization works with others correctly.\n+        \"\"\"\n+        @ignite_versions(str(DEV_BRANCH), str(V_2_8_1), version_prefix='ver')\n+        @parametrize(x=10, y=20)\n+        @parametrize(x=30, y=40)\n+        def function_parametrize(ver, x, y):\n+            return ver, x, y\n+\n+        @ignite_versions((str(DEV_BRANCH), str(V_2_8_1)), (str(V_2_8_1), str(V_2_7_6)), version_prefix='pair')\n+        @matrix(i=[10, 20], j=[30, 40])\n+        def function_matrix(pair_1, pair_2, i, j):\n+            return pair_1, pair_2, i, j\n+\n+        @ignore(ver=str(DEV_BRANCH))\n+        @ignite_versions(str(DEV_BRANCH), str(V_2_8_1), version_prefix='ver')\n+        def function_ignore(ver):\n+            return ver\n+\n+        context_list = expand_function(func=function_parametrize, sess_ctx=mock_session_ctx())\n+        context_list += expand_function(func=function_matrix, sess_ctx=mock_session_ctx())\n+        context_list += expand_function(func=function_ignore, sess_ctx=mock_session_ctx())\n+\n+        assert len(context_list) == 14\n+\n+        parametrized_context = list(filter(lambda x: x.function_name == function_parametrize.__name__, context_list))\n+        assert len(parametrized_context) == 4\n+        for ctx in parametrized_context:\n+            args = ctx.injected_args\n+            assert len(args) == 3\n+            assert ctx.function() == (args['ver'], args['x'], args['y'])\n+\n+        matrix_context = list(filter(lambda x: x.function_name == function_matrix.__name__, context_list))\n+        assert len(matrix_context) == 8\n+        for ctx in matrix_context:\n+            args = ctx.injected_args\n+            assert len(args) == 4\n+            assert ctx.function() == (args['pair_1'], args['pair_2'], args['i'], args['j'])\n+\n+        assert len(list(filter(lambda x: x.function_name == function_ignore.__name__, context_list))) == 2\n+        assert len(list(filter(lambda x: x.ignore, context_list))) == 1\n+\n+    @staticmethod\n+    def _check_injection(context_list, *, versions, global_args=None, pairs=False):\n+        if global_args:\n+            global_versions = global_args['ignite_versions']\n+\n+            if isinstance(global_versions, str):\n+                assert not pairs\n+\n+                check_versions = [IgniteVersion(global_versions)]\n+            elif isinstance(global_args['ignite_versions'], tuple):\n+                assert pairs\n+\n+                check_versions = [tuple(map(IgniteVersion, global_versions))]\n+            elif pairs:\n+                check_versions = list(map(lambda x: (IgniteVersion(x[0]), IgniteVersion(x[1])), global_versions))\n+            else:\n+                check_versions = list(map(IgniteVersion, global_versions))\n+        else:\n+            check_versions = list(map(IgniteVersion, versions)) if not pairs else \\", "originalCommit": "4dd82fc70ddba7a1442b1852b228befa9138de97", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA0NjY4NA==", "url": "https://github.com/apache/ignite/pull/8274#discussion_r495046684", "bodyText": "I disagree.", "author": "ivandasch", "createdAt": "2020-09-25T14:58:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTAzOTE2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA1MzI3Ng==", "url": "https://github.com/apache/ignite/pull/8274#discussion_r495053276", "bodyText": "Changed", "author": "ivandasch", "createdAt": "2020-09-25T15:09:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTAzOTE2Mw=="}], "type": "inlineReview"}, {"oid": "b1b33f83d58cc3fdd1b68f8308d2f16fdc27bf6b", "url": "https://github.com/apache/ignite/commit/b1b33f83d58cc3fdd1b68f8308d2f16fdc27bf6b", "message": "IGNITE-13481 wip.", "committedDate": "2020-09-25T15:06:41Z", "type": "commit"}]}