{"pr_number": 7915, "pr_title": "IGNITE-12868 Calcite integration. LEFT, RIGHT join support", "pr_createdAt": "2020-06-09T08:53:38Z", "pr_url": "https://github.com/apache/ignite/pull/7915", "timeline": [{"oid": "26c07cd91f2a9c308009d3c5eaa1df996ca2750d", "url": "https://github.com/apache/ignite/commit/26c07cd91f2a9c308009d3c5eaa1df996ca2750d", "message": "IGNITE-12868 Calcite integration. LEFT, RIGHT join support", "committedDate": "2020-06-09T08:51:41Z", "type": "commit"}, {"oid": "0dd284865e36a8ba7118c9df4f4f5454712e9f2e", "url": "https://github.com/apache/ignite/commit/0dd284865e36a8ba7118c9df4f4f5454712e9f2e", "message": "move common logic to the abstract class", "committedDate": "2020-06-09T12:01:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzMzNTY0Ng==", "url": "https://github.com/apache/ignite/pull/7915#discussion_r437335646", "bodyText": "Can we add new Object[]{3, \"QA\"} here to ensure it will not be a part of the output?", "author": "rkondakov", "createdAt": "2020-06-09T11:26:30Z", "path": "modules/calcite/src/test/java/org/apache/ignite/internal/processors/query/calcite/exec/rel/ExecutionTest.java", "diffHunk": "@@ -151,6 +152,285 @@ public void testUnionAll() {\n         assertEquals(12, res.size());\n     }\n \n+    /** */\n+    @Test\n+    public void testLeftJoin() {\n+        //    select e.id, e.name, d.name as dep_name\n+        //      from emp e\n+        // left join dep d\n+        //        on e.depno = d.depno\n+\n+        ExecutionContext<Object[]> ctx = executionContext(F.first(nodes()), UUID.randomUUID(), 0);\n+\n+        ScanNode<Object[]> persons = new ScanNode<>(ctx, Arrays.asList(\n+            new Object[]{0, \"Igor\", 1},\n+            new Object[]{1, \"Roman\", 2},\n+            new Object[]{2, \"Ivan\", null},\n+            new Object[]{3, \"Alexey\", 1}\n+        ));\n+\n+        ScanNode<Object[]> deps = new ScanNode<>(ctx, Arrays.asList(\n+            new Object[]{1, \"Core\"},\n+            new Object[]{2, \"SQL\"}\n+        ));\n+\n+        LeftJoinNode<Object[]> join = new LeftJoinNode<>(\n+            ctx,\n+            r -> r[2] == r[3],\n+            new RowHandler.RowFactory<Object[]>() {\n+                @Override public Object[] create() {\n+                    return new Object[2];\n+                }\n+\n+                @Override public Object[] create(Object... fields) {\n+                    return create();\n+                }\n+            }\n+        );\n+        join.register(F.asList(persons, deps));\n+\n+        ProjectNode<Object[]> project = new ProjectNode<>(ctx, r -> new Object[]{r[0], r[1], r[4]});\n+        project.register(join);\n+\n+        RootNode<Object[]> node = new RootNode<>(ctx, r -> {});\n+        node.register(project);\n+\n+        assert node.hasNext();\n+\n+        ArrayList<Object[]> rows = new ArrayList<>();\n+\n+        while (node.hasNext())\n+            rows.add(node.next());\n+\n+        assertEquals(4, rows.size());\n+\n+        Assert.assertArrayEquals(new Object[]{0, \"Igor\", \"Core\"}, rows.get(0));\n+        Assert.assertArrayEquals(new Object[]{1, \"Roman\", \"SQL\"}, rows.get(1));\n+        Assert.assertArrayEquals(new Object[]{2, \"Ivan\", null}, rows.get(2));\n+        Assert.assertArrayEquals(new Object[]{3, \"Alexey\", \"Core\"}, rows.get(3));\n+    }\n+\n+    /** */\n+    @Test\n+    public void testRightJoin() {\n+        //     select e.id, e.name, d.name as dep_name\n+        //       from dep d\n+        // right join emp e\n+        //         on e.depno = d.depno\n+\n+        ExecutionContext<Object[]> ctx = executionContext(F.first(nodes()), UUID.randomUUID(), 0);\n+\n+        ScanNode<Object[]> persons = new ScanNode<>(ctx, Arrays.asList(\n+            new Object[]{0, \"Igor\", 1},\n+            new Object[]{1, \"Roman\", 2},\n+            new Object[]{2, \"Ivan\", null},\n+            new Object[]{3, \"Alexey\", 1}\n+        ));\n+\n+        ScanNode<Object[]> deps = new ScanNode<>(ctx, Arrays.asList(\n+            new Object[]{1, \"Core\"},\n+            new Object[]{2, \"SQL\"}\n+        ));\n+\n+        RightJoinNode<Object[]> join = new RightJoinNode<>(\n+            ctx,\n+            r -> r[0] == r[4],\n+            new RowHandler.RowFactory<Object[]>() {\n+                @Override public Object[] create() {\n+                    return new Object[2];\n+                }\n+\n+                @Override public Object[] create(Object... fields) {\n+                    return create();\n+                }\n+            }\n+        );\n+        join.register(F.asList(deps, persons));\n+\n+        ProjectNode<Object[]> project = new ProjectNode<>(ctx, r -> new Object[]{r[2], r[3], r[1]});\n+        project.register(join);\n+\n+        RootNode<Object[]> node = new RootNode<>(ctx, r -> {});\n+        node.register(project);\n+\n+        assert node.hasNext();\n+\n+        ArrayList<Object[]> rows = new ArrayList<>();\n+\n+        while (node.hasNext())\n+            rows.add(node.next());\n+\n+        assertEquals(4, rows.size());\n+\n+        Assert.assertArrayEquals(new Object[]{0, \"Igor\", \"Core\"}, rows.get(0));\n+        Assert.assertArrayEquals(new Object[]{1, \"Roman\", \"SQL\"}, rows.get(1));\n+        Assert.assertArrayEquals(new Object[]{2, \"Ivan\", null}, rows.get(2));\n+        Assert.assertArrayEquals(new Object[]{3, \"Alexey\", \"Core\"}, rows.get(3));\n+    }\n+\n+    /** */\n+    @Test\n+    public void testFullOuterJoin() {\n+        //          select e.id, e.name, d.name as dep_name\n+        //            from emp e\n+        // full outer join dep d\n+        //              on e.depno = d.depno\n+\n+        ExecutionContext<Object[]> ctx = executionContext(F.first(nodes()), UUID.randomUUID(), 0);\n+\n+        ScanNode<Object[]> persons = new ScanNode<>(ctx, Arrays.asList(\n+            new Object[]{0, \"Igor\", 1},\n+            new Object[]{1, \"Roman\", 2},\n+            new Object[]{2, \"Ivan\", null},\n+            new Object[]{3, \"Alexey\", 1}\n+        ));\n+\n+        ScanNode<Object[]> deps = new ScanNode<>(ctx, Arrays.asList(\n+            new Object[]{1, \"Core\"},\n+            new Object[]{2, \"SQL\"},\n+            new Object[]{3, \"QA\"}\n+        ));\n+\n+        FullOuterJoinNode<Object[]> join = new FullOuterJoinNode<>(\n+            ctx,\n+            r -> r[2] == r[3],\n+            new RowHandler.RowFactory<Object[]>() {\n+                @Override public Object[] create() {\n+                    return new Object[3];\n+                }\n+\n+                @Override public Object[] create(Object... fields) {\n+                    return create();\n+                }\n+            },\n+            new RowHandler.RowFactory<Object[]>() {\n+                @Override public Object[] create() {\n+                    return new Object[2];\n+                }\n+\n+                @Override public Object[] create(Object... fields) {\n+                    return create();\n+                }\n+            }\n+        );\n+        join.register(F.asList(persons, deps));\n+\n+        ProjectNode<Object[]> project = new ProjectNode<>(ctx, r -> new Object[]{r[0], r[1], r[4]});\n+        project.register(join);\n+\n+        RootNode<Object[]> node = new RootNode<>(ctx, r -> {});\n+        node.register(project);\n+\n+        assert node.hasNext();\n+\n+        ArrayList<Object[]> rows = new ArrayList<>();\n+\n+        while (node.hasNext())\n+            rows.add(node.next());\n+\n+        assertEquals(5, rows.size());\n+\n+        Assert.assertArrayEquals(new Object[]{0, \"Igor\", \"Core\"}, rows.get(0));\n+        Assert.assertArrayEquals(new Object[]{1, \"Roman\", \"SQL\"}, rows.get(1));\n+        Assert.assertArrayEquals(new Object[]{2, \"Ivan\", null}, rows.get(2));\n+        Assert.assertArrayEquals(new Object[]{3, \"Alexey\", \"Core\"}, rows.get(3));\n+        Assert.assertArrayEquals(new Object[]{null, null, \"QA\"}, rows.get(4));\n+    }\n+\n+    /** */\n+    @Test\n+    public void testSemiJoin() {\n+        //    select d.name as dep_name\n+        //      from dep d\n+        // semi join emp e\n+        //        on e.depno = d.depno\n+\n+        ExecutionContext<Object[]> ctx = executionContext(F.first(nodes()), UUID.randomUUID(), 0);\n+\n+        ScanNode<Object[]> persons = new ScanNode<>(ctx, Arrays.asList(\n+            new Object[]{0, \"Igor\", 1},\n+            new Object[]{1, \"Roman\", 2},\n+            new Object[]{2, \"Ivan\", null},\n+            new Object[]{3, \"Alexey\", 1}\n+        ));\n+\n+        ScanNode<Object[]> deps = new ScanNode<>(ctx, Arrays.asList(\n+            new Object[]{1, \"Core\"},\n+            new Object[]{2, \"SQL\"}", "originalCommit": "26c07cd91f2a9c308009d3c5eaa1df996ca2750d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQzNDY4OA==", "url": "https://github.com/apache/ignite/pull/7915#discussion_r437434688", "bodyText": "Yep, sure. Fixed.", "author": "korlov42", "createdAt": "2020-06-09T13:49:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzMzNTY0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzMzODUyMQ==", "url": "https://github.com/apache/ignite/pull/7915#discussion_r437338521", "bodyText": "What does waitingRight == -1 mean? It is not clear. If it is a special value, we can put it into a static constant with a meaningful name. It would improve readability.", "author": "rkondakov", "createdAt": "2020-06-09T11:32:26Z", "path": "modules/calcite/src/main/java/org/apache/ignite/internal/processors/query/calcite/exec/rel/AntiJoinNode.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.query.calcite.exec.rel;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.List;\n+import java.util.function.Predicate;\n+import org.apache.ignite.internal.processors.query.calcite.exec.ExecutionContext;\n+import org.apache.ignite.internal.processors.query.calcite.exec.RowHandler;\n+import org.apache.ignite.internal.util.typedef.F;\n+\n+/** */\n+public class AntiJoinNode<Row> extends AbstractNode<Row> {\n+    /** */\n+    private final Predicate<Row> cond;\n+\n+    /** */\n+    private final RowHandler<Row> handler;\n+\n+    /** */\n+    private int requested;\n+\n+    /** */\n+    private int waitingLeft;\n+\n+    /** */\n+    private int waitingRight;\n+\n+    /** */\n+    private final List<Row> rightMaterialized = new ArrayList<>(IN_BUFFER_SIZE);\n+\n+    /** */\n+    private final Deque<Row> leftInBuf = new ArrayDeque<>(IN_BUFFER_SIZE);\n+\n+    /** */\n+    private boolean inLoop;\n+\n+    /** */\n+    private Row left;\n+\n+    /** */\n+    private int rightIdx;\n+\n+    /**\n+     * @param ctx Execution context.\n+     * @param cond Join expression.\n+     */\n+    public AntiJoinNode(ExecutionContext<Row> ctx, Predicate<Row> cond) {\n+        super(ctx);\n+\n+        this.cond = cond;\n+        handler = ctx.rowHandler();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void request(int rowsCnt) {\n+        checkThread();\n+\n+        assert !F.isEmpty(sources) && sources.size() == 2;\n+        assert rowsCnt > 0 && requested == 0;\n+\n+        requested = rowsCnt;\n+\n+        if (!inLoop)\n+            context().execute(this::flushFromBuffer);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected Downstream<Row> requestDownstream(int idx) {\n+        if (idx == 0)\n+            return new Downstream<Row>() {\n+                /** {@inheritDoc} */\n+                @Override public void push(Row row) {\n+                    pushLeft(row);\n+                }\n+\n+                /** {@inheritDoc} */\n+                @Override public void end() {\n+                    endLeft();\n+                }\n+\n+                /** {@inheritDoc} */\n+                @Override public void onError(Throwable e) {\n+                    AntiJoinNode.this.onError(e);\n+                }\n+            };\n+        else if (idx == 1)\n+            return new Downstream<Row>() {\n+                /** {@inheritDoc} */\n+                @Override public void push(Row row) {\n+                    pushRight(row);\n+                }\n+\n+                /** {@inheritDoc} */\n+                @Override public void end() {\n+                    endRight();\n+                }\n+\n+                /** {@inheritDoc} */\n+                @Override public void onError(Throwable e) {\n+                    AntiJoinNode.this.onError(e);\n+                }\n+            };\n+\n+        throw new IndexOutOfBoundsException();\n+    }\n+\n+    /** */\n+    private void pushLeft(Row row) {\n+        checkThread();\n+\n+        assert downstream != null;\n+        assert waitingLeft > 0;\n+\n+        waitingLeft--;\n+\n+        leftInBuf.add(row);\n+\n+        flushFromBuffer();\n+    }\n+\n+    /** */\n+    private void pushRight(Row row) {\n+        checkThread();\n+\n+        assert downstream != null;\n+        assert waitingRight > 0;\n+\n+        waitingRight--;\n+\n+        rightMaterialized.add(row);\n+\n+        if (waitingRight == 0)\n+            sources.get(1).request(waitingRight = IN_BUFFER_SIZE);\n+    }\n+\n+    /** */\n+    private void endLeft() {\n+        checkThread();\n+\n+        assert downstream != null;\n+        assert waitingLeft > 0;\n+\n+        waitingLeft = -1;\n+\n+        flushFromBuffer();\n+    }\n+\n+    /** */\n+    private void endRight() {\n+        checkThread();\n+\n+        assert downstream != null;\n+        assert waitingRight > 0;\n+\n+        waitingRight = -1;\n+\n+        flushFromBuffer();\n+    }\n+\n+    /** */\n+    private void onError(Throwable e) {\n+        checkThread();\n+\n+        assert downstream != null;\n+\n+        downstream.onError(e);\n+    }\n+\n+    /** */\n+    private void flushFromBuffer() {\n+        inLoop = true;\n+        try {\n+            if (waitingRight == -1) {", "originalCommit": "26c07cd91f2a9c308009d3c5eaa1df996ca2750d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQzNDk2Mg==", "url": "https://github.com/apache/ignite/pull/7915#discussion_r437434962", "bodyText": "Good point. Fixed.", "author": "korlov42", "createdAt": "2020-06-09T13:49:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzMzODUyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM1MzA3OQ==", "url": "https://github.com/apache/ignite/pull/7915#discussion_r437353079", "bodyText": "Using HashSet here looks like not a good idea because in general Row has not overridden hc/e methods. Especially current row implementation is a simple Object[]. I agree that we need a semantics of set here, but we need to think of its implementation more thoroughly.", "author": "rkondakov", "createdAt": "2020-06-09T12:00:25Z", "path": "modules/calcite/src/main/java/org/apache/ignite/internal/processors/query/calcite/exec/rel/FullOuterJoinNode.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.query.calcite.exec.rel;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import org.apache.ignite.internal.processors.query.calcite.exec.ExecutionContext;\n+import org.apache.ignite.internal.processors.query.calcite.exec.RowHandler;\n+import org.apache.ignite.internal.util.typedef.F;\n+\n+/** */\n+public class FullOuterJoinNode<Row> extends AbstractNode<Row> {\n+    /** Left row factory. */\n+    private final RowHandler.RowFactory<Row> leftRowFactory;\n+\n+    /** Right row factory. */\n+    private final RowHandler.RowFactory<Row> rightRowFactory;\n+\n+    /** Whether current left row was matched or not. */\n+    private boolean leftMatched;\n+\n+    /** */\n+    private final Set<Row> rightNotMatched = new HashSet<>();", "originalCommit": "26c07cd91f2a9c308009d3c5eaa1df996ca2750d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ0MDg3OA==", "url": "https://github.com/apache/ignite/pull/7915#discussion_r437440878", "bodyText": "Actually it was what I relied on. Identity hash code and reference equality should be used here. Anyway I just rewrote this part with BitSet, so fixed", "author": "korlov42", "createdAt": "2020-06-09T13:55:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM1MzA3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM1NjAyMA==", "url": "https://github.com/apache/ignite/pull/7915#discussion_r437356020", "bodyText": "If I understand the semantics of semi-join right, it should emit only one row for each match. For example here I see:\n\nA semi join returns a row from one join input (A) if there is at least one matching row on the other join input (B).\nThe essential differences between a semi join and a regular join are:\n\nSemi join either returns each row from input A, or it does not. No row duplication can occur.\nRegular join duplicates rows if there are multiple matches on the join predicate.\nSemi join is defined to only return columns from input A.\nRegular join may return columns from either (or both) join inputs.\n\n\nSo rightMaterialized can be a sort of set here.", "author": "rkondakov", "createdAt": "2020-06-09T12:05:59Z", "path": "modules/calcite/src/main/java/org/apache/ignite/internal/processors/query/calcite/exec/rel/SemiJoinNode.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.internal.processors.query.calcite.exec.rel;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.List;\n+import java.util.function.Predicate;\n+import org.apache.ignite.internal.processors.query.calcite.exec.ExecutionContext;\n+import org.apache.ignite.internal.processors.query.calcite.exec.RowHandler;\n+import org.apache.ignite.internal.util.typedef.F;\n+\n+/** */\n+public class SemiJoinNode<Row> extends AbstractNode<Row> {\n+    /** */\n+    private final Predicate<Row> cond;\n+\n+    /** */\n+    private final RowHandler<Row> handler;\n+\n+    /** */\n+    private int requested;\n+\n+    /** */\n+    private int waitingLeft;\n+\n+    /** */\n+    private int waitingRight;\n+\n+    /** */\n+    private final List<Row> rightMaterialized = new ArrayList<>(IN_BUFFER_SIZE);\n+\n+    /** */\n+    private final Deque<Row> leftInBuf = new ArrayDeque<>(IN_BUFFER_SIZE);\n+\n+    /** */\n+    private boolean inLoop;\n+\n+    /** */\n+    private Row left;\n+\n+    /** */\n+    private int rightIdx;\n+\n+    /**\n+     * @param ctx Execution context.\n+     * @param cond Join expression.\n+     */\n+    public SemiJoinNode(ExecutionContext<Row> ctx, Predicate<Row> cond) {\n+        super(ctx);\n+\n+        this.cond = cond;\n+        handler = ctx.rowHandler();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override public void request(int rowsCnt) {\n+        checkThread();\n+\n+        assert !F.isEmpty(sources) && sources.size() == 2;\n+        assert rowsCnt > 0 && requested == 0;\n+\n+        requested = rowsCnt;\n+\n+        if (!inLoop)\n+            context().execute(this::flushFromBuffer);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override protected Downstream<Row> requestDownstream(int idx) {\n+        if (idx == 0)\n+            return new Downstream<Row>() {\n+                /** {@inheritDoc} */\n+                @Override public void push(Row row) {\n+                    pushLeft(row);\n+                }\n+\n+                /** {@inheritDoc} */\n+                @Override public void end() {\n+                    endLeft();\n+                }\n+\n+                /** {@inheritDoc} */\n+                @Override public void onError(Throwable e) {\n+                    SemiJoinNode.this.onError(e);\n+                }\n+            };\n+        else if (idx == 1)\n+            return new Downstream<Row>() {\n+                /** {@inheritDoc} */\n+                @Override public void push(Row row) {\n+                    pushRight(row);\n+                }\n+\n+                /** {@inheritDoc} */\n+                @Override public void end() {\n+                    endRight();\n+                }\n+\n+                /** {@inheritDoc} */\n+                @Override public void onError(Throwable e) {\n+                    SemiJoinNode.this.onError(e);\n+                }\n+            };\n+\n+        throw new IndexOutOfBoundsException();\n+    }\n+\n+    /** */\n+    private void pushLeft(Row row) {\n+        checkThread();\n+\n+        assert downstream != null;\n+        assert waitingLeft > 0;\n+\n+        waitingLeft--;\n+\n+        leftInBuf.add(row);\n+\n+        flushFromBuffer();\n+    }\n+\n+    /** */\n+    private void pushRight(Row row) {\n+        checkThread();\n+\n+        assert downstream != null;\n+        assert waitingRight > 0;\n+\n+        waitingRight--;\n+\n+        rightMaterialized.add(row);\n+\n+        if (waitingRight == 0)\n+            sources.get(1).request(waitingRight = IN_BUFFER_SIZE);\n+    }\n+\n+    /** */\n+    private void endLeft() {\n+        checkThread();\n+\n+        assert downstream != null;\n+        assert waitingLeft > 0;\n+\n+        waitingLeft = -1;\n+\n+        flushFromBuffer();\n+    }\n+\n+    /** */\n+    private void endRight() {\n+        checkThread();\n+\n+        assert downstream != null;\n+        assert waitingRight > 0;\n+\n+        waitingRight = -1;\n+\n+        flushFromBuffer();\n+    }\n+\n+    /** */\n+    private void onError(Throwable e) {\n+        checkThread();\n+\n+        assert downstream != null;\n+\n+        downstream.onError(e);\n+    }\n+\n+    /** */\n+    private void flushFromBuffer() {\n+        inLoop = true;\n+        try {\n+            if (waitingRight == -1) {\n+                while (requested > 0 && (left != null || !leftInBuf.isEmpty())) {\n+                    if (left == null)\n+                        left = leftInBuf.remove();\n+\n+                    boolean matched = false;\n+\n+                    while (!matched && requested > 0 && rightIdx < rightMaterialized.size()) {\n+                        Row row = handler.concat(left, rightMaterialized.get(rightIdx++));\n+\n+                        if (!cond.test(row))\n+                            continue;\n+\n+                        requested--;\n+                        matched = true;\n+                        downstream.push(left);", "originalCommit": "26c07cd91f2a9c308009d3c5eaa1df996ca2750d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkyNDA2NQ==", "url": "https://github.com/apache/ignite/pull/7915#discussion_r437924065", "bodyText": "it should emit only one row for each match\n\nAnd it does so. Please see test https://github.com/apache/ignite/pull/7915/files#diff-57b3dae5cc807015f62943792c5c70ebR343", "author": "korlov42", "createdAt": "2020-06-10T07:42:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM1NjAyMA=="}], "type": "inlineReview"}, {"oid": "55189baf9fc26373b557b68d01cdcad17434d76e", "url": "https://github.com/apache/ignite/commit/55189baf9fc26373b557b68d01cdcad17434d76e", "message": "changed HashSet to BitSet for right joins", "committedDate": "2020-06-09T13:48:30Z", "type": "commit"}]}