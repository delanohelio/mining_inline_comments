{"pr_number": 1702, "pr_title": "Issue #1688: Rewrite HierarchicalEntityManager tests", "pr_createdAt": "2020-12-29T11:19:27Z", "pr_url": "https://github.com/epam/cloud-pipeline/pull/1702", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTQ3MDMwMA==", "url": "https://github.com/epam/cloud-pipeline/pull/1702#discussion_r559470300", "bodyText": "Why this bean shall be spy?", "author": "ekazachkova", "createdAt": "2021-01-18T10:39:57Z", "path": "api/src/test/java/com/epam/pipeline/test/acl/AclTestBeans.java", "diffHunk": "@@ -484,6 +479,14 @@ protected FolderCrudManager mockFolderCrudManager() {\n         return Mockito.mock(FolderCrudManager.class);\n     }\n \n+    @Bean\n+    protected HierarchicalEntityManager spyHierarchicalEntityManager() {\n+        return spy(HierarchicalEntityManager.class);\n+    }\n+\n+    @SpyBean\n+    protected RoleManager spyRoleManager;", "originalCommit": "304b258c60aa8aa560e6e270a53a77e5b99e31d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTQ5MTc5MQ==", "url": "https://github.com/epam/cloud-pipeline/pull/1702#discussion_r559491791", "bodyText": "Let's keep one style:\n@SpyBean\nprotected HierarchicalEntityManager spyHierarchicalEntityManager;", "author": "ekazachkova", "createdAt": "2021-01-18T11:14:48Z", "path": "api/src/test/java/com/epam/pipeline/test/acl/AclTestBeans.java", "diffHunk": "@@ -484,6 +479,14 @@ protected FolderCrudManager mockFolderCrudManager() {\n         return Mockito.mock(FolderCrudManager.class);\n     }\n \n+    @Bean", "originalCommit": "304b258c60aa8aa560e6e270a53a77e5b99e31d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTQ5OTc3OA==", "url": "https://github.com/epam/cloud-pipeline/pull/1702#discussion_r559499778", "bodyText": "Why old test assertion is different from new?", "author": "ekazachkova", "createdAt": "2021-01-18T11:28:37Z", "path": "api/src/test/java/com/epam/pipeline/manager/HierarchicalEntityManagerTest.java", "diffHunk": "@@ -16,348 +16,315 @@\n \n package com.epam.pipeline.manager;\n \n-import com.epam.pipeline.app.TestApplicationWithAclSecurity;\n-import com.epam.pipeline.controller.vo.PermissionGrantVO;\n-import com.epam.pipeline.controller.vo.PipelineUserVO;\n-import com.epam.pipeline.controller.vo.configuration.RunConfigurationVO;\n import com.epam.pipeline.entity.AbstractSecuredEntity;\n-import com.epam.pipeline.entity.configuration.PipelineConfiguration;\n import com.epam.pipeline.entity.configuration.RunConfiguration;\n-import com.epam.pipeline.entity.configuration.RunConfigurationEntry;\n+import com.epam.pipeline.entity.docker.DockerRegistryList;\n import com.epam.pipeline.entity.pipeline.DockerRegistry;\n import com.epam.pipeline.entity.pipeline.Folder;\n+import com.epam.pipeline.entity.pipeline.Pipeline;\n import com.epam.pipeline.entity.pipeline.Tool;\n import com.epam.pipeline.entity.pipeline.ToolGroup;\n import com.epam.pipeline.entity.security.acl.AclClass;\n import com.epam.pipeline.entity.security.acl.AclSid;\n import com.epam.pipeline.entity.user.DefaultRoles;\n import com.epam.pipeline.entity.user.Role;\n-import com.epam.pipeline.manager.cluster.KubernetesManager;\n-import com.epam.pipeline.manager.configuration.RunConfigurationManager;\n-import com.epam.pipeline.manager.docker.DockerClient;\n-import com.epam.pipeline.manager.docker.DockerClientFactory;\n import com.epam.pipeline.manager.docker.DockerRegistryManager;\n-import com.epam.pipeline.manager.pipeline.FolderCrudManager;\n-import com.epam.pipeline.manager.pipeline.ToolGroupManager;\n-import com.epam.pipeline.manager.pipeline.ToolManager;\n+import com.epam.pipeline.manager.pipeline.FolderManager;\n import com.epam.pipeline.manager.security.GrantPermissionManager;\n import com.epam.pipeline.manager.user.RoleManager;\n import com.epam.pipeline.manager.user.UserManager;\n+import com.epam.pipeline.security.UserContext;\n import com.epam.pipeline.security.acl.AclPermission;\n-import org.junit.Assert;\n-import org.junit.Before;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.user.UserCreatorUtils;\n import org.junit.Test;\n-import org.mockito.Mockito;\n import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.boot.test.mock.mockito.MockBean;\n-import org.springframework.security.test.context.support.WithMockUser;\n-import org.springframework.test.annotation.DirtiesContext;\n-import org.springframework.test.context.ContextConfiguration;\n-import org.springframework.transaction.annotation.Transactional;\n \n import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n \n-\n-@DirtiesContext\n-@Transactional\n-@ContextConfiguration(classes = TestApplicationWithAclSecurity.class)\n-public class HierarchicalEntityManagerTest extends AbstractManagerTest {\n-\n-    private static final String USER = \"OWNER\";\n-    private static final String USER2 = \"VIEWER\";\n-\n-    private static final String TEST_NAME = \"name\";\n-    private static final int ALL_PERMISSIONS = AclPermission.READ.getMask()\n-                                                | AclPermission.WRITE.getMask()\n-                                                | AclPermission.EXECUTE.getMask();\n-    private static final int ALL_PERMISSIONS_SIMPLE = AclPermission.getBasicPermissions().stream()\n-            .map(AclPermission::getSimpleMask).reduce((m, m2) -> m | m2).get();\n-    private static final String TEST_ROLE = \"TEST_ROLE\";\n-\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ALL_PERMISSIONS;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_2;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.READ_PERMISSION;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.WRITE_PERMISSION;\n+import static com.epam.pipeline.test.creator.configuration.ConfigurationCreatorUtils.getRunConfiguration;\n+import static com.epam.pipeline.test.creator.docker.DockerCreatorUtils.getDockerRegistry;\n+import static com.epam.pipeline.test.creator.docker.DockerCreatorUtils.getDockerRegistryList;\n+import static com.epam.pipeline.test.creator.docker.DockerCreatorUtils.getTool;\n+import static com.epam.pipeline.test.creator.docker.DockerCreatorUtils.getToolGroup;\n+import static com.epam.pipeline.test.creator.folder.FolderCreatorUtils.getFolder;\n+import static com.epam.pipeline.test.creator.pipeline.PipelineCreatorUtils.getPipeline;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyBoolean;\n+import static org.mockito.Matchers.anyLong;\n+import static org.mockito.Mockito.doReturn;\n+\n+public class HierarchicalEntityManagerTest extends AbstractAclTest {\n+\n+    private final Tool tool = getTool(ID, ANOTHER_SIMPLE_USER);\n+    private final ToolGroup toolGroup = getToolGroup(ID, ANOTHER_SIMPLE_USER, Collections.singletonList(tool));\n+    private final RunConfiguration runConfiguration = getRunConfiguration(ID, ANOTHER_SIMPLE_USER);\n+    private final Pipeline pipeline = getPipeline(ID, ANOTHER_SIMPLE_USER);\n+    private final UserContext userContext = new UserContext(ID, SIMPLE_USER);\n+    private final DockerRegistry registry =\n+            getDockerRegistry(ID, ANOTHER_SIMPLE_USER, Collections.singletonList(toolGroup));\n+    private final DockerRegistryList dockerRegistryList = getDockerRegistryList(ID, ANOTHER_SIMPLE_USER, registry);\n+    private final Folder folder = getFolder(ID, ANOTHER_SIMPLE_USER);\n+    private final Role role = UserCreatorUtils.getRole();\n \n     @Autowired\n     private HierarchicalEntityManager hierarchicalEntityManager;\n \n     @Autowired\n-    private RunConfigurationManager configurationManager;\n-\n-    @Autowired\n-    private DockerRegistryManager registryManager;\n+    private DockerRegistryManager mockRegistryManager;\n \n     @Autowired\n-    private ToolGroupManager toolGroupManager;\n+    private UserManager mockUserManager;\n \n     @Autowired\n-    private ToolManager toolManager;\n+    private GrantPermissionManager spyPermissionManager;\n \n     @Autowired\n-    private UserManager userManager;\n+    private FolderManager mockFolderManager;\n \n     @Autowired\n-    private RoleManager roleManager;\n-\n-    @Autowired\n-    private GrantPermissionManager permissionManager;\n-\n-    @Autowired\n-    private FolderCrudManager folderCrudManager;\n-\n-    @MockBean\n-    private DockerClientFactory dockerClientFactory;\n-\n-    @MockBean\n-    private KubernetesManager kubernetesManager;\n-\n-    private DockerClient client = Mockito.mock(DockerClient.class);\n-\n-    @Before\n-    public void setUp() {\n-        PipelineUserVO userVO = new PipelineUserVO();\n-        userVO.setRoleIds(Collections.singletonList(DefaultRoles.ROLE_USER.getId()));\n-        userVO.setUserName(USER);\n-        userManager.createUser(userVO);\n-\n-        userVO.setUserName(USER2);\n-        userManager.createUser(userVO);\n-        Mockito.when(kubernetesManager.createDockerRegistrySecret(Mockito.any())).thenReturn(\"\");\n-        Mockito.when(dockerClientFactory.getDockerClient(Mockito.any(), Mockito.any())).thenReturn(client);\n-    }\n+    private RoleManager spyRoleManager;\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testToolInheritPermissionsFromRegistry() {\n-        DockerRegistry registry = registryManager.create(\n-                ObjectCreatorUtils.createDockerRegistryVO(TEST_NAME, USER, USER));\n-        ToolGroup toolGroup = toolGroupManager.create(\n-                ObjectCreatorUtils.createToolGroup(TEST_NAME, registry.getId()));\n-        toolManager.create(ObjectCreatorUtils.createTool(TEST_NAME, toolGroup.getId()), false);\n-        grantPermission(registry.getId(), AclClass.DOCKER_REGISTRY, USER2, true, AclPermission.READ.getMask());\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n-                .loadAvailable(new AclSid(USER2, true), null);\n-        Assert.assertEquals(3, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.TOOL).get(0).getMask(), AclPermission.READ.getMask());\n+    public void shouldInheritPermissionsFromRegistry() {\n+        doReturn(dockerRegistryList).when(mockRegistryManager).loadAllRegistriesContent();\n+        doReturn(folder).when(mockFolderManager).loadTree();\n+        mockUserContext();\n+        mockSid();\n+        initAclEntity(dockerRegistryList);\n+        initAclEntity(registry, AclPermission.READ);\n+        initAclEntity(toolGroup);\n+        initAclEntity(tool);\n+\n+        final Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n+                .loadAvailable(new AclSid(SIMPLE_USER, true), null);\n+\n+        assertThat(available.size()).isEqualTo(3);\n+        assertThat(available.get(AclClass.TOOL).get(0).getMask()).isEqualTo(READ_PERMISSION);\n     }\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testIfOnlyToolAllowedGroupAndRegistryDontPresetInResult() {\n-        DockerRegistry registry = registryManager.create(\n-                ObjectCreatorUtils.createDockerRegistryVO(TEST_NAME, USER, USER));\n-        ToolGroup toolGroup = toolGroupManager.create(\n-                ObjectCreatorUtils.createToolGroup(TEST_NAME, registry.getId()));\n-        Tool tool = toolManager.create(\n-                ObjectCreatorUtils.createTool(TEST_NAME, toolGroup.getId()), false);\n-        grantPermission(tool.getId(), AclClass.TOOL, USER2, true, AclPermission.READ.getMask());\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n-                .loadAvailable(new AclSid(USER2, true), null);\n-        Assert.assertEquals(1, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.TOOL).get(0).getMask(), AclPermission.READ.getMask());\n+    public void shouldLoadOnlyEntityWithPermission() {\n+        doReturn(dockerRegistryList).when(mockRegistryManager).loadAllRegistriesContent();\n+        doReturn(folder).when(mockFolderManager).loadTree();\n+        mockUserContext();\n+        mockSid();\n+        initAclEntity(dockerRegistryList);\n+        initAclEntity(registry);\n+        initAclEntity(toolGroup);\n+        initAclEntity(tool, AclPermission.READ);\n+\n+        final Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n+                .loadAvailable(new AclSid(SIMPLE_USER, true), null);\n+\n+        assertThat(available.size()).isEqualTo(1);\n+        assertThat(available.get(AclClass.TOOL).get(0).getMask()).isEqualTo(READ_PERMISSION);\n     }\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testLoadingByRoleSidWorks() {\n-        DockerRegistry registry = registryManager.create(\n-                ObjectCreatorUtils.createDockerRegistryVO(TEST_NAME, USER, USER));\n-        ToolGroup toolGroup = toolGroupManager.create(\n-                ObjectCreatorUtils.createToolGroup(TEST_NAME, registry.getId()));\n-        Tool tool = toolManager.create(\n-                ObjectCreatorUtils.createTool(TEST_NAME, toolGroup.getId()), false);\n-        grantPermission(tool.getId(), AclClass.TOOL, DefaultRoles.ROLE_USER.getName(),\n-                false, AclPermission.READ.getMask());\n-\n-        Folder folder = createFolder(TEST_NAME, null);\n-        RunConfiguration runConfiguration = createRunConfiguration(TEST_NAME, folder.getId());\n-        grantPermission(runConfiguration.getId(), AclClass.CONFIGURATION, DefaultRoles.ROLE_USER.getName(),\n-                false, AclPermission.READ.getMask());\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager.loadAvailable(\n-                new AclSid(DefaultRoles.ROLE_USER.getName(), false), null);\n-        Assert.assertEquals(2, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.TOOL).get(0).getMask(), AclPermission.READ.getMask());\n+    public void shouldLoadByRoleSid() {\n+        folder.setConfigurations(Collections.singletonList(runConfiguration));\n+        doReturn(dockerRegistryList).when(mockRegistryManager).loadAllRegistriesContent();\n+        doReturn(folder).when(mockFolderManager).loadTree();\n+        mockUserContext();\n+        mockSid();\n+        initAclEntity(dockerRegistryList);\n+        initAclEntity(folder);\n+        initAclEntity(registry);\n+        initAclEntity(toolGroup);\n+        initAclEntity(tool,\n+                Collections.singletonList(new UserPermission(DefaultRoles.ROLE_USER.getName(), READ_PERMISSION)));\n+        initAclEntity(runConfiguration,\n+                Collections.singletonList(new UserPermission(DefaultRoles.ROLE_USER.getName(), READ_PERMISSION)));\n+\n+        final Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager.loadAvailable(\n+                new AclSid(DefaultRoles.ROLE_USER.getName(), true), null);\n+\n+        assertThat(available.size()).isEqualTo(2);\n+        assertThat(available.get(AclClass.TOOL).get(0).getMask()).isEqualTo(READ_PERMISSION);\n     }\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testLoadingByRoleSidWorksWhenLoadForUser() {\n-        DockerRegistry registry = registryManager.create(\n-                ObjectCreatorUtils.createDockerRegistryVO(TEST_NAME, USER, USER));\n-        ToolGroup toolGroup = toolGroupManager.create(\n-                ObjectCreatorUtils.createToolGroup(TEST_NAME, registry.getId()));\n-        Tool tool = toolManager.create(\n-                ObjectCreatorUtils.createTool(TEST_NAME, toolGroup.getId()), false);\n-        grantPermission(tool.getId(), AclClass.TOOL, DefaultRoles.ROLE_USER.getName(),\n-                false, AclPermission.READ.getMask());\n-\n-        Folder folder = createFolder(TEST_NAME, null);\n-        RunConfiguration runConfiguration = createRunConfiguration(TEST_NAME, folder.getId());\n-        grantPermission(runConfiguration.getId(), AclClass.CONFIGURATION, DefaultRoles.ROLE_USER.getName(),\n-                false, AclPermission.READ.getMask());\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n-                .loadAvailable(new AclSid(USER2, true), null);\n-        Assert.assertEquals(2, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.TOOL).get(0).getMask(), AclPermission.READ.getMask());\n+    public void shouldLoadByRoleSidWhenLoadForUser() {\n+        folder.setConfigurations(Collections.singletonList(runConfiguration));\n+        doReturn(dockerRegistryList).when(mockRegistryManager).loadAllRegistriesContent();\n+        doReturn(folder).when(mockFolderManager).loadTree();\n+        mockUserContext();\n+        mockSid();\n+        initAclEntity(dockerRegistryList);\n+        initAclEntity(folder);\n+        initAclEntity(registry);\n+        initAclEntity(toolGroup);\n+        initAclEntity(tool, AclPermission.READ);\n+        initAclEntity(runConfiguration, AclPermission.READ);\n+\n+        final Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager.loadAvailable(\n+                new AclSid(SIMPLE_USER, true), null);\n+\n+        assertThat(available.size()).isEqualTo(2);\n+        assertThat(available.get(AclClass.TOOL).get(0).getMask()).isEqualTo(READ_PERMISSION);\n     }\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testLoadingByGroupSidWorksWhenLoadForUser() {\n-        DockerRegistry registry = registryManager.create(\n-                ObjectCreatorUtils.createDockerRegistryVO(TEST_NAME, USER, USER));\n-        ToolGroup toolGroup = toolGroupManager.create(\n-                ObjectCreatorUtils.createToolGroup(TEST_NAME, registry.getId()));\n-        Tool tool = toolManager.create(\n-                ObjectCreatorUtils.createTool(TEST_NAME, toolGroup.getId()), false);\n-        Role role = roleManager.createRole(TEST_ROLE, false, false, null);\n-        grantPermission(tool.getId(), AclClass.TOOL, role.getName(),\n-                false, AclPermission.READ.getMask());\n-        roleManager.assignRole(role.getId(), Collections.singletonList(userManager.loadUserByName(USER2).getId()));\n-\n-        Folder folder = createFolder(TEST_NAME, null);\n-        RunConfiguration runConfiguration = createRunConfiguration(TEST_NAME, folder.getId());\n-        grantPermission(runConfiguration.getId(), AclClass.CONFIGURATION, DefaultRoles.ROLE_USER.getName(),\n-                false, AclPermission.READ.getMask());\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n-                .loadAvailable(new AclSid(USER2, true), null);\n-        Assert.assertEquals(2, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.TOOL).get(0).getMask(), AclPermission.READ.getMask());\n+    public void shouldLoadByGroupSidWhenLoadForUser() {\n+        folder.setConfigurations(Collections.singletonList(runConfiguration));\n+        doReturn(dockerRegistryList).when(mockRegistryManager).loadAllRegistriesContent();\n+        doReturn(folder).when(mockFolderManager).loadTree();\n+        doReturn(role).when(spyRoleManager).loadRole(anyLong());\n+        spyRoleManager.assignRole(role.getId(), Collections.singletonList(ID));\n+        mockUserContext();\n+        mockSid();\n+        initAclEntity(dockerRegistryList);\n+        initAclEntity(folder);\n+        initAclEntity(registry);\n+        initAclEntity(toolGroup);\n+        initAclEntity(tool, AclPermission.READ);\n+        initAclEntity(runConfiguration, AclPermission.READ);\n+\n+        final Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager.loadAvailable(\n+                new AclSid(SIMPLE_USER, true), null);\n+\n+        assertThat(available.size()).isEqualTo(2);\n+        assertThat(available.get(AclClass.TOOL).get(0).getMask()).isEqualTo(READ_PERMISSION);\n     }\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testInheritPermissions() {\n-        Folder folder = createFolder(TEST_NAME, null);\n-        createRunConfiguration(TEST_NAME, folder.getId());\n-\n-        grantPermission(folder.getId(), AclClass.FOLDER, USER2, true, AclPermission.READ.getMask());\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n-                .loadAvailable(new AclSid(USER2, true), null);\n-        Assert.assertEquals(2, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.CONFIGURATION).get(0).getMask(), AclPermission.READ.getMask());\n+    public void shouldInheritPermissions() {\n+        folder.setConfigurations(Collections.singletonList(runConfiguration));\n+        doReturn(folder).when(mockFolderManager).loadTree();\n+        mockDockerRegistryList();\n+        mockUserContext();\n+        mockSid();\n+        initAclEntity(folder, AclPermission.READ);\n+        initAclEntity(runConfiguration);\n+\n+        final Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n+                .loadAvailable(new AclSid(SIMPLE_USER, true), null);\n+\n+        assertThat(available.size()).isEqualTo(1);", "originalCommit": "304b258c60aa8aa560e6e270a53a77e5b99e31d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTUxNTUyMA==", "url": "https://github.com/epam/cloud-pipeline/pull/1702#discussion_r559515520", "bodyText": "Why we should test pipeline here?", "author": "ekazachkova", "createdAt": "2021-01-18T11:56:53Z", "path": "api/src/test/java/com/epam/pipeline/manager/HierarchicalEntityManagerTest.java", "diffHunk": "@@ -16,348 +16,315 @@\n \n package com.epam.pipeline.manager;\n \n-import com.epam.pipeline.app.TestApplicationWithAclSecurity;\n-import com.epam.pipeline.controller.vo.PermissionGrantVO;\n-import com.epam.pipeline.controller.vo.PipelineUserVO;\n-import com.epam.pipeline.controller.vo.configuration.RunConfigurationVO;\n import com.epam.pipeline.entity.AbstractSecuredEntity;\n-import com.epam.pipeline.entity.configuration.PipelineConfiguration;\n import com.epam.pipeline.entity.configuration.RunConfiguration;\n-import com.epam.pipeline.entity.configuration.RunConfigurationEntry;\n+import com.epam.pipeline.entity.docker.DockerRegistryList;\n import com.epam.pipeline.entity.pipeline.DockerRegistry;\n import com.epam.pipeline.entity.pipeline.Folder;\n+import com.epam.pipeline.entity.pipeline.Pipeline;\n import com.epam.pipeline.entity.pipeline.Tool;\n import com.epam.pipeline.entity.pipeline.ToolGroup;\n import com.epam.pipeline.entity.security.acl.AclClass;\n import com.epam.pipeline.entity.security.acl.AclSid;\n import com.epam.pipeline.entity.user.DefaultRoles;\n import com.epam.pipeline.entity.user.Role;\n-import com.epam.pipeline.manager.cluster.KubernetesManager;\n-import com.epam.pipeline.manager.configuration.RunConfigurationManager;\n-import com.epam.pipeline.manager.docker.DockerClient;\n-import com.epam.pipeline.manager.docker.DockerClientFactory;\n import com.epam.pipeline.manager.docker.DockerRegistryManager;\n-import com.epam.pipeline.manager.pipeline.FolderCrudManager;\n-import com.epam.pipeline.manager.pipeline.ToolGroupManager;\n-import com.epam.pipeline.manager.pipeline.ToolManager;\n+import com.epam.pipeline.manager.pipeline.FolderManager;\n import com.epam.pipeline.manager.security.GrantPermissionManager;\n import com.epam.pipeline.manager.user.RoleManager;\n import com.epam.pipeline.manager.user.UserManager;\n+import com.epam.pipeline.security.UserContext;\n import com.epam.pipeline.security.acl.AclPermission;\n-import org.junit.Assert;\n-import org.junit.Before;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.user.UserCreatorUtils;\n import org.junit.Test;\n-import org.mockito.Mockito;\n import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.boot.test.mock.mockito.MockBean;\n-import org.springframework.security.test.context.support.WithMockUser;\n-import org.springframework.test.annotation.DirtiesContext;\n-import org.springframework.test.context.ContextConfiguration;\n-import org.springframework.transaction.annotation.Transactional;\n \n import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n \n-\n-@DirtiesContext\n-@Transactional\n-@ContextConfiguration(classes = TestApplicationWithAclSecurity.class)\n-public class HierarchicalEntityManagerTest extends AbstractManagerTest {\n-\n-    private static final String USER = \"OWNER\";\n-    private static final String USER2 = \"VIEWER\";\n-\n-    private static final String TEST_NAME = \"name\";\n-    private static final int ALL_PERMISSIONS = AclPermission.READ.getMask()\n-                                                | AclPermission.WRITE.getMask()\n-                                                | AclPermission.EXECUTE.getMask();\n-    private static final int ALL_PERMISSIONS_SIMPLE = AclPermission.getBasicPermissions().stream()\n-            .map(AclPermission::getSimpleMask).reduce((m, m2) -> m | m2).get();\n-    private static final String TEST_ROLE = \"TEST_ROLE\";\n-\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ALL_PERMISSIONS;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_2;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.READ_PERMISSION;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.WRITE_PERMISSION;\n+import static com.epam.pipeline.test.creator.configuration.ConfigurationCreatorUtils.getRunConfiguration;\n+import static com.epam.pipeline.test.creator.docker.DockerCreatorUtils.getDockerRegistry;\n+import static com.epam.pipeline.test.creator.docker.DockerCreatorUtils.getDockerRegistryList;\n+import static com.epam.pipeline.test.creator.docker.DockerCreatorUtils.getTool;\n+import static com.epam.pipeline.test.creator.docker.DockerCreatorUtils.getToolGroup;\n+import static com.epam.pipeline.test.creator.folder.FolderCreatorUtils.getFolder;\n+import static com.epam.pipeline.test.creator.pipeline.PipelineCreatorUtils.getPipeline;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyBoolean;\n+import static org.mockito.Matchers.anyLong;\n+import static org.mockito.Mockito.doReturn;\n+\n+public class HierarchicalEntityManagerTest extends AbstractAclTest {\n+\n+    private final Tool tool = getTool(ID, ANOTHER_SIMPLE_USER);\n+    private final ToolGroup toolGroup = getToolGroup(ID, ANOTHER_SIMPLE_USER, Collections.singletonList(tool));\n+    private final RunConfiguration runConfiguration = getRunConfiguration(ID, ANOTHER_SIMPLE_USER);\n+    private final Pipeline pipeline = getPipeline(ID, ANOTHER_SIMPLE_USER);\n+    private final UserContext userContext = new UserContext(ID, SIMPLE_USER);\n+    private final DockerRegistry registry =\n+            getDockerRegistry(ID, ANOTHER_SIMPLE_USER, Collections.singletonList(toolGroup));\n+    private final DockerRegistryList dockerRegistryList = getDockerRegistryList(ID, ANOTHER_SIMPLE_USER, registry);\n+    private final Folder folder = getFolder(ID, ANOTHER_SIMPLE_USER);\n+    private final Role role = UserCreatorUtils.getRole();\n \n     @Autowired\n     private HierarchicalEntityManager hierarchicalEntityManager;\n \n     @Autowired\n-    private RunConfigurationManager configurationManager;\n-\n-    @Autowired\n-    private DockerRegistryManager registryManager;\n+    private DockerRegistryManager mockRegistryManager;\n \n     @Autowired\n-    private ToolGroupManager toolGroupManager;\n+    private UserManager mockUserManager;\n \n     @Autowired\n-    private ToolManager toolManager;\n+    private GrantPermissionManager spyPermissionManager;\n \n     @Autowired\n-    private UserManager userManager;\n+    private FolderManager mockFolderManager;\n \n     @Autowired\n-    private RoleManager roleManager;\n-\n-    @Autowired\n-    private GrantPermissionManager permissionManager;\n-\n-    @Autowired\n-    private FolderCrudManager folderCrudManager;\n-\n-    @MockBean\n-    private DockerClientFactory dockerClientFactory;\n-\n-    @MockBean\n-    private KubernetesManager kubernetesManager;\n-\n-    private DockerClient client = Mockito.mock(DockerClient.class);\n-\n-    @Before\n-    public void setUp() {\n-        PipelineUserVO userVO = new PipelineUserVO();\n-        userVO.setRoleIds(Collections.singletonList(DefaultRoles.ROLE_USER.getId()));\n-        userVO.setUserName(USER);\n-        userManager.createUser(userVO);\n-\n-        userVO.setUserName(USER2);\n-        userManager.createUser(userVO);\n-        Mockito.when(kubernetesManager.createDockerRegistrySecret(Mockito.any())).thenReturn(\"\");\n-        Mockito.when(dockerClientFactory.getDockerClient(Mockito.any(), Mockito.any())).thenReturn(client);\n-    }\n+    private RoleManager spyRoleManager;\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testToolInheritPermissionsFromRegistry() {\n-        DockerRegistry registry = registryManager.create(\n-                ObjectCreatorUtils.createDockerRegistryVO(TEST_NAME, USER, USER));\n-        ToolGroup toolGroup = toolGroupManager.create(\n-                ObjectCreatorUtils.createToolGroup(TEST_NAME, registry.getId()));\n-        toolManager.create(ObjectCreatorUtils.createTool(TEST_NAME, toolGroup.getId()), false);\n-        grantPermission(registry.getId(), AclClass.DOCKER_REGISTRY, USER2, true, AclPermission.READ.getMask());\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n-                .loadAvailable(new AclSid(USER2, true), null);\n-        Assert.assertEquals(3, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.TOOL).get(0).getMask(), AclPermission.READ.getMask());\n+    public void shouldInheritPermissionsFromRegistry() {\n+        doReturn(dockerRegistryList).when(mockRegistryManager).loadAllRegistriesContent();\n+        doReturn(folder).when(mockFolderManager).loadTree();\n+        mockUserContext();\n+        mockSid();\n+        initAclEntity(dockerRegistryList);\n+        initAclEntity(registry, AclPermission.READ);\n+        initAclEntity(toolGroup);\n+        initAclEntity(tool);\n+\n+        final Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n+                .loadAvailable(new AclSid(SIMPLE_USER, true), null);\n+\n+        assertThat(available.size()).isEqualTo(3);\n+        assertThat(available.get(AclClass.TOOL).get(0).getMask()).isEqualTo(READ_PERMISSION);\n     }\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testIfOnlyToolAllowedGroupAndRegistryDontPresetInResult() {\n-        DockerRegistry registry = registryManager.create(\n-                ObjectCreatorUtils.createDockerRegistryVO(TEST_NAME, USER, USER));\n-        ToolGroup toolGroup = toolGroupManager.create(\n-                ObjectCreatorUtils.createToolGroup(TEST_NAME, registry.getId()));\n-        Tool tool = toolManager.create(\n-                ObjectCreatorUtils.createTool(TEST_NAME, toolGroup.getId()), false);\n-        grantPermission(tool.getId(), AclClass.TOOL, USER2, true, AclPermission.READ.getMask());\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n-                .loadAvailable(new AclSid(USER2, true), null);\n-        Assert.assertEquals(1, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.TOOL).get(0).getMask(), AclPermission.READ.getMask());\n+    public void shouldLoadOnlyEntityWithPermission() {\n+        doReturn(dockerRegistryList).when(mockRegistryManager).loadAllRegistriesContent();\n+        doReturn(folder).when(mockFolderManager).loadTree();\n+        mockUserContext();\n+        mockSid();\n+        initAclEntity(dockerRegistryList);\n+        initAclEntity(registry);\n+        initAclEntity(toolGroup);\n+        initAclEntity(tool, AclPermission.READ);\n+\n+        final Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n+                .loadAvailable(new AclSid(SIMPLE_USER, true), null);\n+\n+        assertThat(available.size()).isEqualTo(1);\n+        assertThat(available.get(AclClass.TOOL).get(0).getMask()).isEqualTo(READ_PERMISSION);\n     }\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testLoadingByRoleSidWorks() {\n-        DockerRegistry registry = registryManager.create(\n-                ObjectCreatorUtils.createDockerRegistryVO(TEST_NAME, USER, USER));\n-        ToolGroup toolGroup = toolGroupManager.create(\n-                ObjectCreatorUtils.createToolGroup(TEST_NAME, registry.getId()));\n-        Tool tool = toolManager.create(\n-                ObjectCreatorUtils.createTool(TEST_NAME, toolGroup.getId()), false);\n-        grantPermission(tool.getId(), AclClass.TOOL, DefaultRoles.ROLE_USER.getName(),\n-                false, AclPermission.READ.getMask());\n-\n-        Folder folder = createFolder(TEST_NAME, null);\n-        RunConfiguration runConfiguration = createRunConfiguration(TEST_NAME, folder.getId());\n-        grantPermission(runConfiguration.getId(), AclClass.CONFIGURATION, DefaultRoles.ROLE_USER.getName(),\n-                false, AclPermission.READ.getMask());\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager.loadAvailable(\n-                new AclSid(DefaultRoles.ROLE_USER.getName(), false), null);\n-        Assert.assertEquals(2, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.TOOL).get(0).getMask(), AclPermission.READ.getMask());\n+    public void shouldLoadByRoleSid() {\n+        folder.setConfigurations(Collections.singletonList(runConfiguration));\n+        doReturn(dockerRegistryList).when(mockRegistryManager).loadAllRegistriesContent();\n+        doReturn(folder).when(mockFolderManager).loadTree();\n+        mockUserContext();\n+        mockSid();\n+        initAclEntity(dockerRegistryList);\n+        initAclEntity(folder);\n+        initAclEntity(registry);\n+        initAclEntity(toolGroup);\n+        initAclEntity(tool,\n+                Collections.singletonList(new UserPermission(DefaultRoles.ROLE_USER.getName(), READ_PERMISSION)));\n+        initAclEntity(runConfiguration,\n+                Collections.singletonList(new UserPermission(DefaultRoles.ROLE_USER.getName(), READ_PERMISSION)));\n+\n+        final Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager.loadAvailable(\n+                new AclSid(DefaultRoles.ROLE_USER.getName(), true), null);\n+\n+        assertThat(available.size()).isEqualTo(2);\n+        assertThat(available.get(AclClass.TOOL).get(0).getMask()).isEqualTo(READ_PERMISSION);\n     }\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testLoadingByRoleSidWorksWhenLoadForUser() {\n-        DockerRegistry registry = registryManager.create(\n-                ObjectCreatorUtils.createDockerRegistryVO(TEST_NAME, USER, USER));\n-        ToolGroup toolGroup = toolGroupManager.create(\n-                ObjectCreatorUtils.createToolGroup(TEST_NAME, registry.getId()));\n-        Tool tool = toolManager.create(\n-                ObjectCreatorUtils.createTool(TEST_NAME, toolGroup.getId()), false);\n-        grantPermission(tool.getId(), AclClass.TOOL, DefaultRoles.ROLE_USER.getName(),\n-                false, AclPermission.READ.getMask());\n-\n-        Folder folder = createFolder(TEST_NAME, null);\n-        RunConfiguration runConfiguration = createRunConfiguration(TEST_NAME, folder.getId());\n-        grantPermission(runConfiguration.getId(), AclClass.CONFIGURATION, DefaultRoles.ROLE_USER.getName(),\n-                false, AclPermission.READ.getMask());\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n-                .loadAvailable(new AclSid(USER2, true), null);\n-        Assert.assertEquals(2, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.TOOL).get(0).getMask(), AclPermission.READ.getMask());\n+    public void shouldLoadByRoleSidWhenLoadForUser() {\n+        folder.setConfigurations(Collections.singletonList(runConfiguration));\n+        doReturn(dockerRegistryList).when(mockRegistryManager).loadAllRegistriesContent();\n+        doReturn(folder).when(mockFolderManager).loadTree();\n+        mockUserContext();\n+        mockSid();\n+        initAclEntity(dockerRegistryList);\n+        initAclEntity(folder);\n+        initAclEntity(registry);\n+        initAclEntity(toolGroup);\n+        initAclEntity(tool, AclPermission.READ);\n+        initAclEntity(runConfiguration, AclPermission.READ);\n+\n+        final Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager.loadAvailable(\n+                new AclSid(SIMPLE_USER, true), null);\n+\n+        assertThat(available.size()).isEqualTo(2);\n+        assertThat(available.get(AclClass.TOOL).get(0).getMask()).isEqualTo(READ_PERMISSION);\n     }\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testLoadingByGroupSidWorksWhenLoadForUser() {\n-        DockerRegistry registry = registryManager.create(\n-                ObjectCreatorUtils.createDockerRegistryVO(TEST_NAME, USER, USER));\n-        ToolGroup toolGroup = toolGroupManager.create(\n-                ObjectCreatorUtils.createToolGroup(TEST_NAME, registry.getId()));\n-        Tool tool = toolManager.create(\n-                ObjectCreatorUtils.createTool(TEST_NAME, toolGroup.getId()), false);\n-        Role role = roleManager.createRole(TEST_ROLE, false, false, null);\n-        grantPermission(tool.getId(), AclClass.TOOL, role.getName(),\n-                false, AclPermission.READ.getMask());\n-        roleManager.assignRole(role.getId(), Collections.singletonList(userManager.loadUserByName(USER2).getId()));\n-\n-        Folder folder = createFolder(TEST_NAME, null);\n-        RunConfiguration runConfiguration = createRunConfiguration(TEST_NAME, folder.getId());\n-        grantPermission(runConfiguration.getId(), AclClass.CONFIGURATION, DefaultRoles.ROLE_USER.getName(),\n-                false, AclPermission.READ.getMask());\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n-                .loadAvailable(new AclSid(USER2, true), null);\n-        Assert.assertEquals(2, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.TOOL).get(0).getMask(), AclPermission.READ.getMask());\n+    public void shouldLoadByGroupSidWhenLoadForUser() {\n+        folder.setConfigurations(Collections.singletonList(runConfiguration));\n+        doReturn(dockerRegistryList).when(mockRegistryManager).loadAllRegistriesContent();\n+        doReturn(folder).when(mockFolderManager).loadTree();\n+        doReturn(role).when(spyRoleManager).loadRole(anyLong());\n+        spyRoleManager.assignRole(role.getId(), Collections.singletonList(ID));\n+        mockUserContext();\n+        mockSid();\n+        initAclEntity(dockerRegistryList);\n+        initAclEntity(folder);\n+        initAclEntity(registry);\n+        initAclEntity(toolGroup);\n+        initAclEntity(tool, AclPermission.READ);\n+        initAclEntity(runConfiguration, AclPermission.READ);\n+\n+        final Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager.loadAvailable(\n+                new AclSid(SIMPLE_USER, true), null);\n+\n+        assertThat(available.size()).isEqualTo(2);\n+        assertThat(available.get(AclClass.TOOL).get(0).getMask()).isEqualTo(READ_PERMISSION);\n     }\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testInheritPermissions() {\n-        Folder folder = createFolder(TEST_NAME, null);\n-        createRunConfiguration(TEST_NAME, folder.getId());\n-\n-        grantPermission(folder.getId(), AclClass.FOLDER, USER2, true, AclPermission.READ.getMask());\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n-                .loadAvailable(new AclSid(USER2, true), null);\n-        Assert.assertEquals(2, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.CONFIGURATION).get(0).getMask(), AclPermission.READ.getMask());\n+    public void shouldInheritPermissions() {\n+        folder.setConfigurations(Collections.singletonList(runConfiguration));\n+        doReturn(folder).when(mockFolderManager).loadTree();\n+        mockDockerRegistryList();\n+        mockUserContext();\n+        mockSid();\n+        initAclEntity(folder, AclPermission.READ);\n+        initAclEntity(runConfiguration);\n+\n+        final Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n+                .loadAvailable(new AclSid(SIMPLE_USER, true), null);\n+\n+        assertThat(available.size()).isEqualTo(1);\n+        assertThat(available.get(AclClass.CONFIGURATION).get(0).getMask()).isEqualTo(READ_PERMISSION);\n     }\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testUseItsOwnPermissions() {\n-        Folder folder = createFolder(TEST_NAME, null);\n-        RunConfiguration runConfiguration = createRunConfiguration(TEST_NAME, folder.getId());\n-\n-        grantPermission(folder.getId(), AclClass.FOLDER, USER2, true, AclPermission.READ.getMask());\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n-                .loadAvailable(new AclSid(USER2, true), null);\n-        Assert.assertEquals(2, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.CONFIGURATION).get(0).getMask(), AclPermission.READ.getMask());\n-\n-\n-        grantPermission(runConfiguration.getId(), AclClass.CONFIGURATION, USER2, true,\n-                ALL_PERMISSIONS);\n-\n-        available = hierarchicalEntityManager.loadAvailable(new AclSid(USER2, true), null);\n-        Assert.assertEquals(2, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.CONFIGURATION).get(0).getMask(), ALL_PERMISSIONS_SIMPLE);\n+    public void shouldUseItsOwnPermissions() {\n+        folder.setConfigurations(Collections.singletonList(runConfiguration));\n+        folder.setPipelines(Collections.singletonList(pipeline));", "originalCommit": "304b258c60aa8aa560e6e270a53a77e5b99e31d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTUyNDY2OA==", "url": "https://github.com/epam/cloud-pipeline/pull/1702#discussion_r559524668", "bodyText": "It seems that some permissions shall be present here.", "author": "ekazachkova", "createdAt": "2021-01-18T12:14:01Z", "path": "api/src/test/java/com/epam/pipeline/manager/HierarchicalEntityManagerTest.java", "diffHunk": "@@ -16,348 +16,315 @@\n \n package com.epam.pipeline.manager;\n \n-import com.epam.pipeline.app.TestApplicationWithAclSecurity;\n-import com.epam.pipeline.controller.vo.PermissionGrantVO;\n-import com.epam.pipeline.controller.vo.PipelineUserVO;\n-import com.epam.pipeline.controller.vo.configuration.RunConfigurationVO;\n import com.epam.pipeline.entity.AbstractSecuredEntity;\n-import com.epam.pipeline.entity.configuration.PipelineConfiguration;\n import com.epam.pipeline.entity.configuration.RunConfiguration;\n-import com.epam.pipeline.entity.configuration.RunConfigurationEntry;\n+import com.epam.pipeline.entity.docker.DockerRegistryList;\n import com.epam.pipeline.entity.pipeline.DockerRegistry;\n import com.epam.pipeline.entity.pipeline.Folder;\n+import com.epam.pipeline.entity.pipeline.Pipeline;\n import com.epam.pipeline.entity.pipeline.Tool;\n import com.epam.pipeline.entity.pipeline.ToolGroup;\n import com.epam.pipeline.entity.security.acl.AclClass;\n import com.epam.pipeline.entity.security.acl.AclSid;\n import com.epam.pipeline.entity.user.DefaultRoles;\n import com.epam.pipeline.entity.user.Role;\n-import com.epam.pipeline.manager.cluster.KubernetesManager;\n-import com.epam.pipeline.manager.configuration.RunConfigurationManager;\n-import com.epam.pipeline.manager.docker.DockerClient;\n-import com.epam.pipeline.manager.docker.DockerClientFactory;\n import com.epam.pipeline.manager.docker.DockerRegistryManager;\n-import com.epam.pipeline.manager.pipeline.FolderCrudManager;\n-import com.epam.pipeline.manager.pipeline.ToolGroupManager;\n-import com.epam.pipeline.manager.pipeline.ToolManager;\n+import com.epam.pipeline.manager.pipeline.FolderManager;\n import com.epam.pipeline.manager.security.GrantPermissionManager;\n import com.epam.pipeline.manager.user.RoleManager;\n import com.epam.pipeline.manager.user.UserManager;\n+import com.epam.pipeline.security.UserContext;\n import com.epam.pipeline.security.acl.AclPermission;\n-import org.junit.Assert;\n-import org.junit.Before;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.user.UserCreatorUtils;\n import org.junit.Test;\n-import org.mockito.Mockito;\n import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.boot.test.mock.mockito.MockBean;\n-import org.springframework.security.test.context.support.WithMockUser;\n-import org.springframework.test.annotation.DirtiesContext;\n-import org.springframework.test.context.ContextConfiguration;\n-import org.springframework.transaction.annotation.Transactional;\n \n import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n \n-\n-@DirtiesContext\n-@Transactional\n-@ContextConfiguration(classes = TestApplicationWithAclSecurity.class)\n-public class HierarchicalEntityManagerTest extends AbstractManagerTest {\n-\n-    private static final String USER = \"OWNER\";\n-    private static final String USER2 = \"VIEWER\";\n-\n-    private static final String TEST_NAME = \"name\";\n-    private static final int ALL_PERMISSIONS = AclPermission.READ.getMask()\n-                                                | AclPermission.WRITE.getMask()\n-                                                | AclPermission.EXECUTE.getMask();\n-    private static final int ALL_PERMISSIONS_SIMPLE = AclPermission.getBasicPermissions().stream()\n-            .map(AclPermission::getSimpleMask).reduce((m, m2) -> m | m2).get();\n-    private static final String TEST_ROLE = \"TEST_ROLE\";\n-\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ALL_PERMISSIONS;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_2;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.READ_PERMISSION;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.WRITE_PERMISSION;\n+import static com.epam.pipeline.test.creator.configuration.ConfigurationCreatorUtils.getRunConfiguration;\n+import static com.epam.pipeline.test.creator.docker.DockerCreatorUtils.getDockerRegistry;\n+import static com.epam.pipeline.test.creator.docker.DockerCreatorUtils.getDockerRegistryList;\n+import static com.epam.pipeline.test.creator.docker.DockerCreatorUtils.getTool;\n+import static com.epam.pipeline.test.creator.docker.DockerCreatorUtils.getToolGroup;\n+import static com.epam.pipeline.test.creator.folder.FolderCreatorUtils.getFolder;\n+import static com.epam.pipeline.test.creator.pipeline.PipelineCreatorUtils.getPipeline;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyBoolean;\n+import static org.mockito.Matchers.anyLong;\n+import static org.mockito.Mockito.doReturn;\n+\n+public class HierarchicalEntityManagerTest extends AbstractAclTest {\n+\n+    private final Tool tool = getTool(ID, ANOTHER_SIMPLE_USER);\n+    private final ToolGroup toolGroup = getToolGroup(ID, ANOTHER_SIMPLE_USER, Collections.singletonList(tool));\n+    private final RunConfiguration runConfiguration = getRunConfiguration(ID, ANOTHER_SIMPLE_USER);\n+    private final Pipeline pipeline = getPipeline(ID, ANOTHER_SIMPLE_USER);\n+    private final UserContext userContext = new UserContext(ID, SIMPLE_USER);\n+    private final DockerRegistry registry =\n+            getDockerRegistry(ID, ANOTHER_SIMPLE_USER, Collections.singletonList(toolGroup));\n+    private final DockerRegistryList dockerRegistryList = getDockerRegistryList(ID, ANOTHER_SIMPLE_USER, registry);\n+    private final Folder folder = getFolder(ID, ANOTHER_SIMPLE_USER);\n+    private final Role role = UserCreatorUtils.getRole();\n \n     @Autowired\n     private HierarchicalEntityManager hierarchicalEntityManager;\n \n     @Autowired\n-    private RunConfigurationManager configurationManager;\n-\n-    @Autowired\n-    private DockerRegistryManager registryManager;\n+    private DockerRegistryManager mockRegistryManager;\n \n     @Autowired\n-    private ToolGroupManager toolGroupManager;\n+    private UserManager mockUserManager;\n \n     @Autowired\n-    private ToolManager toolManager;\n+    private GrantPermissionManager spyPermissionManager;\n \n     @Autowired\n-    private UserManager userManager;\n+    private FolderManager mockFolderManager;\n \n     @Autowired\n-    private RoleManager roleManager;\n-\n-    @Autowired\n-    private GrantPermissionManager permissionManager;\n-\n-    @Autowired\n-    private FolderCrudManager folderCrudManager;\n-\n-    @MockBean\n-    private DockerClientFactory dockerClientFactory;\n-\n-    @MockBean\n-    private KubernetesManager kubernetesManager;\n-\n-    private DockerClient client = Mockito.mock(DockerClient.class);\n-\n-    @Before\n-    public void setUp() {\n-        PipelineUserVO userVO = new PipelineUserVO();\n-        userVO.setRoleIds(Collections.singletonList(DefaultRoles.ROLE_USER.getId()));\n-        userVO.setUserName(USER);\n-        userManager.createUser(userVO);\n-\n-        userVO.setUserName(USER2);\n-        userManager.createUser(userVO);\n-        Mockito.when(kubernetesManager.createDockerRegistrySecret(Mockito.any())).thenReturn(\"\");\n-        Mockito.when(dockerClientFactory.getDockerClient(Mockito.any(), Mockito.any())).thenReturn(client);\n-    }\n+    private RoleManager spyRoleManager;\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testToolInheritPermissionsFromRegistry() {\n-        DockerRegistry registry = registryManager.create(\n-                ObjectCreatorUtils.createDockerRegistryVO(TEST_NAME, USER, USER));\n-        ToolGroup toolGroup = toolGroupManager.create(\n-                ObjectCreatorUtils.createToolGroup(TEST_NAME, registry.getId()));\n-        toolManager.create(ObjectCreatorUtils.createTool(TEST_NAME, toolGroup.getId()), false);\n-        grantPermission(registry.getId(), AclClass.DOCKER_REGISTRY, USER2, true, AclPermission.READ.getMask());\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n-                .loadAvailable(new AclSid(USER2, true), null);\n-        Assert.assertEquals(3, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.TOOL).get(0).getMask(), AclPermission.READ.getMask());\n+    public void shouldInheritPermissionsFromRegistry() {\n+        doReturn(dockerRegistryList).when(mockRegistryManager).loadAllRegistriesContent();\n+        doReturn(folder).when(mockFolderManager).loadTree();\n+        mockUserContext();\n+        mockSid();\n+        initAclEntity(dockerRegistryList);\n+        initAclEntity(registry, AclPermission.READ);\n+        initAclEntity(toolGroup);\n+        initAclEntity(tool);\n+\n+        final Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n+                .loadAvailable(new AclSid(SIMPLE_USER, true), null);\n+\n+        assertThat(available.size()).isEqualTo(3);\n+        assertThat(available.get(AclClass.TOOL).get(0).getMask()).isEqualTo(READ_PERMISSION);\n     }\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testIfOnlyToolAllowedGroupAndRegistryDontPresetInResult() {\n-        DockerRegistry registry = registryManager.create(\n-                ObjectCreatorUtils.createDockerRegistryVO(TEST_NAME, USER, USER));\n-        ToolGroup toolGroup = toolGroupManager.create(\n-                ObjectCreatorUtils.createToolGroup(TEST_NAME, registry.getId()));\n-        Tool tool = toolManager.create(\n-                ObjectCreatorUtils.createTool(TEST_NAME, toolGroup.getId()), false);\n-        grantPermission(tool.getId(), AclClass.TOOL, USER2, true, AclPermission.READ.getMask());\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n-                .loadAvailable(new AclSid(USER2, true), null);\n-        Assert.assertEquals(1, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.TOOL).get(0).getMask(), AclPermission.READ.getMask());\n+    public void shouldLoadOnlyEntityWithPermission() {\n+        doReturn(dockerRegistryList).when(mockRegistryManager).loadAllRegistriesContent();\n+        doReturn(folder).when(mockFolderManager).loadTree();\n+        mockUserContext();\n+        mockSid();\n+        initAclEntity(dockerRegistryList);\n+        initAclEntity(registry);\n+        initAclEntity(toolGroup);\n+        initAclEntity(tool, AclPermission.READ);\n+\n+        final Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n+                .loadAvailable(new AclSid(SIMPLE_USER, true), null);\n+\n+        assertThat(available.size()).isEqualTo(1);\n+        assertThat(available.get(AclClass.TOOL).get(0).getMask()).isEqualTo(READ_PERMISSION);\n     }\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testLoadingByRoleSidWorks() {\n-        DockerRegistry registry = registryManager.create(\n-                ObjectCreatorUtils.createDockerRegistryVO(TEST_NAME, USER, USER));\n-        ToolGroup toolGroup = toolGroupManager.create(\n-                ObjectCreatorUtils.createToolGroup(TEST_NAME, registry.getId()));\n-        Tool tool = toolManager.create(\n-                ObjectCreatorUtils.createTool(TEST_NAME, toolGroup.getId()), false);\n-        grantPermission(tool.getId(), AclClass.TOOL, DefaultRoles.ROLE_USER.getName(),\n-                false, AclPermission.READ.getMask());\n-\n-        Folder folder = createFolder(TEST_NAME, null);\n-        RunConfiguration runConfiguration = createRunConfiguration(TEST_NAME, folder.getId());\n-        grantPermission(runConfiguration.getId(), AclClass.CONFIGURATION, DefaultRoles.ROLE_USER.getName(),\n-                false, AclPermission.READ.getMask());\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager.loadAvailable(\n-                new AclSid(DefaultRoles.ROLE_USER.getName(), false), null);\n-        Assert.assertEquals(2, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.TOOL).get(0).getMask(), AclPermission.READ.getMask());\n+    public void shouldLoadByRoleSid() {\n+        folder.setConfigurations(Collections.singletonList(runConfiguration));\n+        doReturn(dockerRegistryList).when(mockRegistryManager).loadAllRegistriesContent();\n+        doReturn(folder).when(mockFolderManager).loadTree();\n+        mockUserContext();\n+        mockSid();\n+        initAclEntity(dockerRegistryList);\n+        initAclEntity(folder);\n+        initAclEntity(registry);\n+        initAclEntity(toolGroup);\n+        initAclEntity(tool,\n+                Collections.singletonList(new UserPermission(DefaultRoles.ROLE_USER.getName(), READ_PERMISSION)));\n+        initAclEntity(runConfiguration,\n+                Collections.singletonList(new UserPermission(DefaultRoles.ROLE_USER.getName(), READ_PERMISSION)));\n+\n+        final Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager.loadAvailable(\n+                new AclSid(DefaultRoles.ROLE_USER.getName(), true), null);\n+\n+        assertThat(available.size()).isEqualTo(2);\n+        assertThat(available.get(AclClass.TOOL).get(0).getMask()).isEqualTo(READ_PERMISSION);\n     }\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testLoadingByRoleSidWorksWhenLoadForUser() {\n-        DockerRegistry registry = registryManager.create(\n-                ObjectCreatorUtils.createDockerRegistryVO(TEST_NAME, USER, USER));\n-        ToolGroup toolGroup = toolGroupManager.create(\n-                ObjectCreatorUtils.createToolGroup(TEST_NAME, registry.getId()));\n-        Tool tool = toolManager.create(\n-                ObjectCreatorUtils.createTool(TEST_NAME, toolGroup.getId()), false);\n-        grantPermission(tool.getId(), AclClass.TOOL, DefaultRoles.ROLE_USER.getName(),\n-                false, AclPermission.READ.getMask());\n-\n-        Folder folder = createFolder(TEST_NAME, null);\n-        RunConfiguration runConfiguration = createRunConfiguration(TEST_NAME, folder.getId());\n-        grantPermission(runConfiguration.getId(), AclClass.CONFIGURATION, DefaultRoles.ROLE_USER.getName(),\n-                false, AclPermission.READ.getMask());\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n-                .loadAvailable(new AclSid(USER2, true), null);\n-        Assert.assertEquals(2, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.TOOL).get(0).getMask(), AclPermission.READ.getMask());\n+    public void shouldLoadByRoleSidWhenLoadForUser() {\n+        folder.setConfigurations(Collections.singletonList(runConfiguration));\n+        doReturn(dockerRegistryList).when(mockRegistryManager).loadAllRegistriesContent();\n+        doReturn(folder).when(mockFolderManager).loadTree();\n+        mockUserContext();\n+        mockSid();\n+        initAclEntity(dockerRegistryList);\n+        initAclEntity(folder);\n+        initAclEntity(registry);\n+        initAclEntity(toolGroup);\n+        initAclEntity(tool, AclPermission.READ);\n+        initAclEntity(runConfiguration, AclPermission.READ);\n+\n+        final Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager.loadAvailable(\n+                new AclSid(SIMPLE_USER, true), null);\n+\n+        assertThat(available.size()).isEqualTo(2);\n+        assertThat(available.get(AclClass.TOOL).get(0).getMask()).isEqualTo(READ_PERMISSION);\n     }\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testLoadingByGroupSidWorksWhenLoadForUser() {\n-        DockerRegistry registry = registryManager.create(\n-                ObjectCreatorUtils.createDockerRegistryVO(TEST_NAME, USER, USER));\n-        ToolGroup toolGroup = toolGroupManager.create(\n-                ObjectCreatorUtils.createToolGroup(TEST_NAME, registry.getId()));\n-        Tool tool = toolManager.create(\n-                ObjectCreatorUtils.createTool(TEST_NAME, toolGroup.getId()), false);\n-        Role role = roleManager.createRole(TEST_ROLE, false, false, null);\n-        grantPermission(tool.getId(), AclClass.TOOL, role.getName(),\n-                false, AclPermission.READ.getMask());\n-        roleManager.assignRole(role.getId(), Collections.singletonList(userManager.loadUserByName(USER2).getId()));\n-\n-        Folder folder = createFolder(TEST_NAME, null);\n-        RunConfiguration runConfiguration = createRunConfiguration(TEST_NAME, folder.getId());\n-        grantPermission(runConfiguration.getId(), AclClass.CONFIGURATION, DefaultRoles.ROLE_USER.getName(),\n-                false, AclPermission.READ.getMask());\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n-                .loadAvailable(new AclSid(USER2, true), null);\n-        Assert.assertEquals(2, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.TOOL).get(0).getMask(), AclPermission.READ.getMask());\n+    public void shouldLoadByGroupSidWhenLoadForUser() {\n+        folder.setConfigurations(Collections.singletonList(runConfiguration));\n+        doReturn(dockerRegistryList).when(mockRegistryManager).loadAllRegistriesContent();\n+        doReturn(folder).when(mockFolderManager).loadTree();\n+        doReturn(role).when(spyRoleManager).loadRole(anyLong());\n+        spyRoleManager.assignRole(role.getId(), Collections.singletonList(ID));\n+        mockUserContext();\n+        mockSid();\n+        initAclEntity(dockerRegistryList);\n+        initAclEntity(folder);\n+        initAclEntity(registry);\n+        initAclEntity(toolGroup);\n+        initAclEntity(tool, AclPermission.READ);\n+        initAclEntity(runConfiguration, AclPermission.READ);\n+\n+        final Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager.loadAvailable(\n+                new AclSid(SIMPLE_USER, true), null);\n+\n+        assertThat(available.size()).isEqualTo(2);\n+        assertThat(available.get(AclClass.TOOL).get(0).getMask()).isEqualTo(READ_PERMISSION);\n     }\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testInheritPermissions() {\n-        Folder folder = createFolder(TEST_NAME, null);\n-        createRunConfiguration(TEST_NAME, folder.getId());\n-\n-        grantPermission(folder.getId(), AclClass.FOLDER, USER2, true, AclPermission.READ.getMask());\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n-                .loadAvailable(new AclSid(USER2, true), null);\n-        Assert.assertEquals(2, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.CONFIGURATION).get(0).getMask(), AclPermission.READ.getMask());\n+    public void shouldInheritPermissions() {\n+        folder.setConfigurations(Collections.singletonList(runConfiguration));\n+        doReturn(folder).when(mockFolderManager).loadTree();\n+        mockDockerRegistryList();\n+        mockUserContext();\n+        mockSid();\n+        initAclEntity(folder, AclPermission.READ);\n+        initAclEntity(runConfiguration);\n+\n+        final Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n+                .loadAvailable(new AclSid(SIMPLE_USER, true), null);\n+\n+        assertThat(available.size()).isEqualTo(1);\n+        assertThat(available.get(AclClass.CONFIGURATION).get(0).getMask()).isEqualTo(READ_PERMISSION);\n     }\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testUseItsOwnPermissions() {\n-        Folder folder = createFolder(TEST_NAME, null);\n-        RunConfiguration runConfiguration = createRunConfiguration(TEST_NAME, folder.getId());\n-\n-        grantPermission(folder.getId(), AclClass.FOLDER, USER2, true, AclPermission.READ.getMask());\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n-                .loadAvailable(new AclSid(USER2, true), null);\n-        Assert.assertEquals(2, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.CONFIGURATION).get(0).getMask(), AclPermission.READ.getMask());\n-\n-\n-        grantPermission(runConfiguration.getId(), AclClass.CONFIGURATION, USER2, true,\n-                ALL_PERMISSIONS);\n-\n-        available = hierarchicalEntityManager.loadAvailable(new AclSid(USER2, true), null);\n-        Assert.assertEquals(2, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.CONFIGURATION).get(0).getMask(), ALL_PERMISSIONS_SIMPLE);\n+    public void shouldUseItsOwnPermissions() {\n+        folder.setConfigurations(Collections.singletonList(runConfiguration));\n+        folder.setPipelines(Collections.singletonList(pipeline));\n+        doReturn(folder).when(mockFolderManager).loadTree();\n+        mockDockerRegistryList();\n+        mockUserContext();\n+        mockSid();\n+        initAclEntity(folder, AclPermission.READ);\n+        initAclEntity(pipeline);\n+        initAclEntity(runConfiguration, AclPermission.WRITE);\n+\n+        final Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n+                .loadAvailable(new AclSid(SIMPLE_USER, true), null);\n+\n+        assertThat(available.size()).isEqualTo(2);\n+        assertThat(available.get(AclClass.PIPELINE).get(0).getMask()).isEqualTo(READ_PERMISSION);\n+        assertThat(available.get(AclClass.CONFIGURATION).get(0).getMask())\n+                .isEqualTo(READ_PERMISSION + WRITE_PERMISSION);\n     }\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testUseItOwnPermissionsIfParentRestricted() {\n-        Folder folder = createFolder(TEST_NAME, null);\n-        RunConfiguration runConfiguration = createRunConfiguration(TEST_NAME, folder.getId());\n-\n-        grantPermission(folder.getId(), AclClass.FOLDER, USER2, true, AclPermission.NO_READ.getMask());\n-        grantPermission(runConfiguration.getId(), AclClass.CONFIGURATION, USER2, true,\n-                ALL_PERMISSIONS);\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n-                .loadAvailable(new AclSid(USER2, true), null);\n-        //folder should be filtered because it forbidden\n-        Assert.assertEquals(1, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.CONFIGURATION).get(0).getMask(), ALL_PERMISSIONS_SIMPLE);\n+    public void shouldUseItOwnPermissionsIfParentRestricted() {\n+        final RunConfiguration runConfiguration = getRunConfiguration(ID, SIMPLE_USER);\n+        folder.setConfigurations(Collections.singletonList(runConfiguration));\n+        doReturn(folder).when(mockFolderManager).loadTree();\n+        mockDockerRegistryList();\n+        mockUserContext();\n+        mockSid();\n+        initAclEntity(folder, AclPermission.NO_READ);\n+        initAclEntity(runConfiguration);", "originalCommit": "304b258c60aa8aa560e6e270a53a77e5b99e31d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTUzNzg5Mg==", "url": "https://github.com/epam/cloud-pipeline/pull/1702#discussion_r559537892", "bodyText": "Why should we use additional child hierarchy? \u0421an we continue to follow the approach like the tests above?", "author": "ekazachkova", "createdAt": "2021-01-18T12:38:17Z", "path": "api/src/test/java/com/epam/pipeline/manager/HierarchicalEntityManagerTest.java", "diffHunk": "@@ -16,348 +16,315 @@\n \n package com.epam.pipeline.manager;\n \n-import com.epam.pipeline.app.TestApplicationWithAclSecurity;\n-import com.epam.pipeline.controller.vo.PermissionGrantVO;\n-import com.epam.pipeline.controller.vo.PipelineUserVO;\n-import com.epam.pipeline.controller.vo.configuration.RunConfigurationVO;\n import com.epam.pipeline.entity.AbstractSecuredEntity;\n-import com.epam.pipeline.entity.configuration.PipelineConfiguration;\n import com.epam.pipeline.entity.configuration.RunConfiguration;\n-import com.epam.pipeline.entity.configuration.RunConfigurationEntry;\n+import com.epam.pipeline.entity.docker.DockerRegistryList;\n import com.epam.pipeline.entity.pipeline.DockerRegistry;\n import com.epam.pipeline.entity.pipeline.Folder;\n+import com.epam.pipeline.entity.pipeline.Pipeline;\n import com.epam.pipeline.entity.pipeline.Tool;\n import com.epam.pipeline.entity.pipeline.ToolGroup;\n import com.epam.pipeline.entity.security.acl.AclClass;\n import com.epam.pipeline.entity.security.acl.AclSid;\n import com.epam.pipeline.entity.user.DefaultRoles;\n import com.epam.pipeline.entity.user.Role;\n-import com.epam.pipeline.manager.cluster.KubernetesManager;\n-import com.epam.pipeline.manager.configuration.RunConfigurationManager;\n-import com.epam.pipeline.manager.docker.DockerClient;\n-import com.epam.pipeline.manager.docker.DockerClientFactory;\n import com.epam.pipeline.manager.docker.DockerRegistryManager;\n-import com.epam.pipeline.manager.pipeline.FolderCrudManager;\n-import com.epam.pipeline.manager.pipeline.ToolGroupManager;\n-import com.epam.pipeline.manager.pipeline.ToolManager;\n+import com.epam.pipeline.manager.pipeline.FolderManager;\n import com.epam.pipeline.manager.security.GrantPermissionManager;\n import com.epam.pipeline.manager.user.RoleManager;\n import com.epam.pipeline.manager.user.UserManager;\n+import com.epam.pipeline.security.UserContext;\n import com.epam.pipeline.security.acl.AclPermission;\n-import org.junit.Assert;\n-import org.junit.Before;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.user.UserCreatorUtils;\n import org.junit.Test;\n-import org.mockito.Mockito;\n import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.boot.test.mock.mockito.MockBean;\n-import org.springframework.security.test.context.support.WithMockUser;\n-import org.springframework.test.annotation.DirtiesContext;\n-import org.springframework.test.context.ContextConfiguration;\n-import org.springframework.transaction.annotation.Transactional;\n \n import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n \n-\n-@DirtiesContext\n-@Transactional\n-@ContextConfiguration(classes = TestApplicationWithAclSecurity.class)\n-public class HierarchicalEntityManagerTest extends AbstractManagerTest {\n-\n-    private static final String USER = \"OWNER\";\n-    private static final String USER2 = \"VIEWER\";\n-\n-    private static final String TEST_NAME = \"name\";\n-    private static final int ALL_PERMISSIONS = AclPermission.READ.getMask()\n-                                                | AclPermission.WRITE.getMask()\n-                                                | AclPermission.EXECUTE.getMask();\n-    private static final int ALL_PERMISSIONS_SIMPLE = AclPermission.getBasicPermissions().stream()\n-            .map(AclPermission::getSimpleMask).reduce((m, m2) -> m | m2).get();\n-    private static final String TEST_ROLE = \"TEST_ROLE\";\n-\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ALL_PERMISSIONS;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_2;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.READ_PERMISSION;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.WRITE_PERMISSION;\n+import static com.epam.pipeline.test.creator.configuration.ConfigurationCreatorUtils.getRunConfiguration;\n+import static com.epam.pipeline.test.creator.docker.DockerCreatorUtils.getDockerRegistry;\n+import static com.epam.pipeline.test.creator.docker.DockerCreatorUtils.getDockerRegistryList;\n+import static com.epam.pipeline.test.creator.docker.DockerCreatorUtils.getTool;\n+import static com.epam.pipeline.test.creator.docker.DockerCreatorUtils.getToolGroup;\n+import static com.epam.pipeline.test.creator.folder.FolderCreatorUtils.getFolder;\n+import static com.epam.pipeline.test.creator.pipeline.PipelineCreatorUtils.getPipeline;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyBoolean;\n+import static org.mockito.Matchers.anyLong;\n+import static org.mockito.Mockito.doReturn;\n+\n+public class HierarchicalEntityManagerTest extends AbstractAclTest {\n+\n+    private final Tool tool = getTool(ID, ANOTHER_SIMPLE_USER);\n+    private final ToolGroup toolGroup = getToolGroup(ID, ANOTHER_SIMPLE_USER, Collections.singletonList(tool));\n+    private final RunConfiguration runConfiguration = getRunConfiguration(ID, ANOTHER_SIMPLE_USER);\n+    private final Pipeline pipeline = getPipeline(ID, ANOTHER_SIMPLE_USER);\n+    private final UserContext userContext = new UserContext(ID, SIMPLE_USER);\n+    private final DockerRegistry registry =\n+            getDockerRegistry(ID, ANOTHER_SIMPLE_USER, Collections.singletonList(toolGroup));\n+    private final DockerRegistryList dockerRegistryList = getDockerRegistryList(ID, ANOTHER_SIMPLE_USER, registry);\n+    private final Folder folder = getFolder(ID, ANOTHER_SIMPLE_USER);\n+    private final Role role = UserCreatorUtils.getRole();\n \n     @Autowired\n     private HierarchicalEntityManager hierarchicalEntityManager;\n \n     @Autowired\n-    private RunConfigurationManager configurationManager;\n-\n-    @Autowired\n-    private DockerRegistryManager registryManager;\n+    private DockerRegistryManager mockRegistryManager;\n \n     @Autowired\n-    private ToolGroupManager toolGroupManager;\n+    private UserManager mockUserManager;\n \n     @Autowired\n-    private ToolManager toolManager;\n+    private GrantPermissionManager spyPermissionManager;\n \n     @Autowired\n-    private UserManager userManager;\n+    private FolderManager mockFolderManager;\n \n     @Autowired\n-    private RoleManager roleManager;\n-\n-    @Autowired\n-    private GrantPermissionManager permissionManager;\n-\n-    @Autowired\n-    private FolderCrudManager folderCrudManager;\n-\n-    @MockBean\n-    private DockerClientFactory dockerClientFactory;\n-\n-    @MockBean\n-    private KubernetesManager kubernetesManager;\n-\n-    private DockerClient client = Mockito.mock(DockerClient.class);\n-\n-    @Before\n-    public void setUp() {\n-        PipelineUserVO userVO = new PipelineUserVO();\n-        userVO.setRoleIds(Collections.singletonList(DefaultRoles.ROLE_USER.getId()));\n-        userVO.setUserName(USER);\n-        userManager.createUser(userVO);\n-\n-        userVO.setUserName(USER2);\n-        userManager.createUser(userVO);\n-        Mockito.when(kubernetesManager.createDockerRegistrySecret(Mockito.any())).thenReturn(\"\");\n-        Mockito.when(dockerClientFactory.getDockerClient(Mockito.any(), Mockito.any())).thenReturn(client);\n-    }\n+    private RoleManager spyRoleManager;\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testToolInheritPermissionsFromRegistry() {\n-        DockerRegistry registry = registryManager.create(\n-                ObjectCreatorUtils.createDockerRegistryVO(TEST_NAME, USER, USER));\n-        ToolGroup toolGroup = toolGroupManager.create(\n-                ObjectCreatorUtils.createToolGroup(TEST_NAME, registry.getId()));\n-        toolManager.create(ObjectCreatorUtils.createTool(TEST_NAME, toolGroup.getId()), false);\n-        grantPermission(registry.getId(), AclClass.DOCKER_REGISTRY, USER2, true, AclPermission.READ.getMask());\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n-                .loadAvailable(new AclSid(USER2, true), null);\n-        Assert.assertEquals(3, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.TOOL).get(0).getMask(), AclPermission.READ.getMask());\n+    public void shouldInheritPermissionsFromRegistry() {\n+        doReturn(dockerRegistryList).when(mockRegistryManager).loadAllRegistriesContent();\n+        doReturn(folder).when(mockFolderManager).loadTree();\n+        mockUserContext();\n+        mockSid();\n+        initAclEntity(dockerRegistryList);\n+        initAclEntity(registry, AclPermission.READ);\n+        initAclEntity(toolGroup);\n+        initAclEntity(tool);\n+\n+        final Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n+                .loadAvailable(new AclSid(SIMPLE_USER, true), null);\n+\n+        assertThat(available.size()).isEqualTo(3);\n+        assertThat(available.get(AclClass.TOOL).get(0).getMask()).isEqualTo(READ_PERMISSION);\n     }\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testIfOnlyToolAllowedGroupAndRegistryDontPresetInResult() {\n-        DockerRegistry registry = registryManager.create(\n-                ObjectCreatorUtils.createDockerRegistryVO(TEST_NAME, USER, USER));\n-        ToolGroup toolGroup = toolGroupManager.create(\n-                ObjectCreatorUtils.createToolGroup(TEST_NAME, registry.getId()));\n-        Tool tool = toolManager.create(\n-                ObjectCreatorUtils.createTool(TEST_NAME, toolGroup.getId()), false);\n-        grantPermission(tool.getId(), AclClass.TOOL, USER2, true, AclPermission.READ.getMask());\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n-                .loadAvailable(new AclSid(USER2, true), null);\n-        Assert.assertEquals(1, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.TOOL).get(0).getMask(), AclPermission.READ.getMask());\n+    public void shouldLoadOnlyEntityWithPermission() {\n+        doReturn(dockerRegistryList).when(mockRegistryManager).loadAllRegistriesContent();\n+        doReturn(folder).when(mockFolderManager).loadTree();\n+        mockUserContext();\n+        mockSid();\n+        initAclEntity(dockerRegistryList);\n+        initAclEntity(registry);\n+        initAclEntity(toolGroup);\n+        initAclEntity(tool, AclPermission.READ);\n+\n+        final Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n+                .loadAvailable(new AclSid(SIMPLE_USER, true), null);\n+\n+        assertThat(available.size()).isEqualTo(1);\n+        assertThat(available.get(AclClass.TOOL).get(0).getMask()).isEqualTo(READ_PERMISSION);\n     }\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testLoadingByRoleSidWorks() {\n-        DockerRegistry registry = registryManager.create(\n-                ObjectCreatorUtils.createDockerRegistryVO(TEST_NAME, USER, USER));\n-        ToolGroup toolGroup = toolGroupManager.create(\n-                ObjectCreatorUtils.createToolGroup(TEST_NAME, registry.getId()));\n-        Tool tool = toolManager.create(\n-                ObjectCreatorUtils.createTool(TEST_NAME, toolGroup.getId()), false);\n-        grantPermission(tool.getId(), AclClass.TOOL, DefaultRoles.ROLE_USER.getName(),\n-                false, AclPermission.READ.getMask());\n-\n-        Folder folder = createFolder(TEST_NAME, null);\n-        RunConfiguration runConfiguration = createRunConfiguration(TEST_NAME, folder.getId());\n-        grantPermission(runConfiguration.getId(), AclClass.CONFIGURATION, DefaultRoles.ROLE_USER.getName(),\n-                false, AclPermission.READ.getMask());\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager.loadAvailable(\n-                new AclSid(DefaultRoles.ROLE_USER.getName(), false), null);\n-        Assert.assertEquals(2, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.TOOL).get(0).getMask(), AclPermission.READ.getMask());\n+    public void shouldLoadByRoleSid() {\n+        folder.setConfigurations(Collections.singletonList(runConfiguration));\n+        doReturn(dockerRegistryList).when(mockRegistryManager).loadAllRegistriesContent();\n+        doReturn(folder).when(mockFolderManager).loadTree();\n+        mockUserContext();\n+        mockSid();\n+        initAclEntity(dockerRegistryList);\n+        initAclEntity(folder);\n+        initAclEntity(registry);\n+        initAclEntity(toolGroup);\n+        initAclEntity(tool,\n+                Collections.singletonList(new UserPermission(DefaultRoles.ROLE_USER.getName(), READ_PERMISSION)));\n+        initAclEntity(runConfiguration,\n+                Collections.singletonList(new UserPermission(DefaultRoles.ROLE_USER.getName(), READ_PERMISSION)));\n+\n+        final Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager.loadAvailable(\n+                new AclSid(DefaultRoles.ROLE_USER.getName(), true), null);\n+\n+        assertThat(available.size()).isEqualTo(2);\n+        assertThat(available.get(AclClass.TOOL).get(0).getMask()).isEqualTo(READ_PERMISSION);\n     }\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testLoadingByRoleSidWorksWhenLoadForUser() {\n-        DockerRegistry registry = registryManager.create(\n-                ObjectCreatorUtils.createDockerRegistryVO(TEST_NAME, USER, USER));\n-        ToolGroup toolGroup = toolGroupManager.create(\n-                ObjectCreatorUtils.createToolGroup(TEST_NAME, registry.getId()));\n-        Tool tool = toolManager.create(\n-                ObjectCreatorUtils.createTool(TEST_NAME, toolGroup.getId()), false);\n-        grantPermission(tool.getId(), AclClass.TOOL, DefaultRoles.ROLE_USER.getName(),\n-                false, AclPermission.READ.getMask());\n-\n-        Folder folder = createFolder(TEST_NAME, null);\n-        RunConfiguration runConfiguration = createRunConfiguration(TEST_NAME, folder.getId());\n-        grantPermission(runConfiguration.getId(), AclClass.CONFIGURATION, DefaultRoles.ROLE_USER.getName(),\n-                false, AclPermission.READ.getMask());\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n-                .loadAvailable(new AclSid(USER2, true), null);\n-        Assert.assertEquals(2, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.TOOL).get(0).getMask(), AclPermission.READ.getMask());\n+    public void shouldLoadByRoleSidWhenLoadForUser() {\n+        folder.setConfigurations(Collections.singletonList(runConfiguration));\n+        doReturn(dockerRegistryList).when(mockRegistryManager).loadAllRegistriesContent();\n+        doReturn(folder).when(mockFolderManager).loadTree();\n+        mockUserContext();\n+        mockSid();\n+        initAclEntity(dockerRegistryList);\n+        initAclEntity(folder);\n+        initAclEntity(registry);\n+        initAclEntity(toolGroup);\n+        initAclEntity(tool, AclPermission.READ);\n+        initAclEntity(runConfiguration, AclPermission.READ);\n+\n+        final Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager.loadAvailable(\n+                new AclSid(SIMPLE_USER, true), null);\n+\n+        assertThat(available.size()).isEqualTo(2);\n+        assertThat(available.get(AclClass.TOOL).get(0).getMask()).isEqualTo(READ_PERMISSION);\n     }\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testLoadingByGroupSidWorksWhenLoadForUser() {\n-        DockerRegistry registry = registryManager.create(\n-                ObjectCreatorUtils.createDockerRegistryVO(TEST_NAME, USER, USER));\n-        ToolGroup toolGroup = toolGroupManager.create(\n-                ObjectCreatorUtils.createToolGroup(TEST_NAME, registry.getId()));\n-        Tool tool = toolManager.create(\n-                ObjectCreatorUtils.createTool(TEST_NAME, toolGroup.getId()), false);\n-        Role role = roleManager.createRole(TEST_ROLE, false, false, null);\n-        grantPermission(tool.getId(), AclClass.TOOL, role.getName(),\n-                false, AclPermission.READ.getMask());\n-        roleManager.assignRole(role.getId(), Collections.singletonList(userManager.loadUserByName(USER2).getId()));\n-\n-        Folder folder = createFolder(TEST_NAME, null);\n-        RunConfiguration runConfiguration = createRunConfiguration(TEST_NAME, folder.getId());\n-        grantPermission(runConfiguration.getId(), AclClass.CONFIGURATION, DefaultRoles.ROLE_USER.getName(),\n-                false, AclPermission.READ.getMask());\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n-                .loadAvailable(new AclSid(USER2, true), null);\n-        Assert.assertEquals(2, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.TOOL).get(0).getMask(), AclPermission.READ.getMask());\n+    public void shouldLoadByGroupSidWhenLoadForUser() {\n+        folder.setConfigurations(Collections.singletonList(runConfiguration));\n+        doReturn(dockerRegistryList).when(mockRegistryManager).loadAllRegistriesContent();\n+        doReturn(folder).when(mockFolderManager).loadTree();\n+        doReturn(role).when(spyRoleManager).loadRole(anyLong());\n+        spyRoleManager.assignRole(role.getId(), Collections.singletonList(ID));\n+        mockUserContext();\n+        mockSid();\n+        initAclEntity(dockerRegistryList);\n+        initAclEntity(folder);\n+        initAclEntity(registry);\n+        initAclEntity(toolGroup);\n+        initAclEntity(tool, AclPermission.READ);\n+        initAclEntity(runConfiguration, AclPermission.READ);\n+\n+        final Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager.loadAvailable(\n+                new AclSid(SIMPLE_USER, true), null);\n+\n+        assertThat(available.size()).isEqualTo(2);\n+        assertThat(available.get(AclClass.TOOL).get(0).getMask()).isEqualTo(READ_PERMISSION);\n     }\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testInheritPermissions() {\n-        Folder folder = createFolder(TEST_NAME, null);\n-        createRunConfiguration(TEST_NAME, folder.getId());\n-\n-        grantPermission(folder.getId(), AclClass.FOLDER, USER2, true, AclPermission.READ.getMask());\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n-                .loadAvailable(new AclSid(USER2, true), null);\n-        Assert.assertEquals(2, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.CONFIGURATION).get(0).getMask(), AclPermission.READ.getMask());\n+    public void shouldInheritPermissions() {\n+        folder.setConfigurations(Collections.singletonList(runConfiguration));\n+        doReturn(folder).when(mockFolderManager).loadTree();\n+        mockDockerRegistryList();\n+        mockUserContext();\n+        mockSid();\n+        initAclEntity(folder, AclPermission.READ);\n+        initAclEntity(runConfiguration);\n+\n+        final Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n+                .loadAvailable(new AclSid(SIMPLE_USER, true), null);\n+\n+        assertThat(available.size()).isEqualTo(1);\n+        assertThat(available.get(AclClass.CONFIGURATION).get(0).getMask()).isEqualTo(READ_PERMISSION);\n     }\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testUseItsOwnPermissions() {\n-        Folder folder = createFolder(TEST_NAME, null);\n-        RunConfiguration runConfiguration = createRunConfiguration(TEST_NAME, folder.getId());\n-\n-        grantPermission(folder.getId(), AclClass.FOLDER, USER2, true, AclPermission.READ.getMask());\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n-                .loadAvailable(new AclSid(USER2, true), null);\n-        Assert.assertEquals(2, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.CONFIGURATION).get(0).getMask(), AclPermission.READ.getMask());\n-\n-\n-        grantPermission(runConfiguration.getId(), AclClass.CONFIGURATION, USER2, true,\n-                ALL_PERMISSIONS);\n-\n-        available = hierarchicalEntityManager.loadAvailable(new AclSid(USER2, true), null);\n-        Assert.assertEquals(2, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.CONFIGURATION).get(0).getMask(), ALL_PERMISSIONS_SIMPLE);\n+    public void shouldUseItsOwnPermissions() {\n+        folder.setConfigurations(Collections.singletonList(runConfiguration));\n+        folder.setPipelines(Collections.singletonList(pipeline));\n+        doReturn(folder).when(mockFolderManager).loadTree();\n+        mockDockerRegistryList();\n+        mockUserContext();\n+        mockSid();\n+        initAclEntity(folder, AclPermission.READ);\n+        initAclEntity(pipeline);\n+        initAclEntity(runConfiguration, AclPermission.WRITE);\n+\n+        final Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n+                .loadAvailable(new AclSid(SIMPLE_USER, true), null);\n+\n+        assertThat(available.size()).isEqualTo(2);\n+        assertThat(available.get(AclClass.PIPELINE).get(0).getMask()).isEqualTo(READ_PERMISSION);\n+        assertThat(available.get(AclClass.CONFIGURATION).get(0).getMask())\n+                .isEqualTo(READ_PERMISSION + WRITE_PERMISSION);\n     }\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testUseItOwnPermissionsIfParentRestricted() {\n-        Folder folder = createFolder(TEST_NAME, null);\n-        RunConfiguration runConfiguration = createRunConfiguration(TEST_NAME, folder.getId());\n-\n-        grantPermission(folder.getId(), AclClass.FOLDER, USER2, true, AclPermission.NO_READ.getMask());\n-        grantPermission(runConfiguration.getId(), AclClass.CONFIGURATION, USER2, true,\n-                ALL_PERMISSIONS);\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n-                .loadAvailable(new AclSid(USER2, true), null);\n-        //folder should be filtered because it forbidden\n-        Assert.assertEquals(1, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.CONFIGURATION).get(0).getMask(), ALL_PERMISSIONS_SIMPLE);\n+    public void shouldUseItOwnPermissionsIfParentRestricted() {\n+        final RunConfiguration runConfiguration = getRunConfiguration(ID, SIMPLE_USER);\n+        folder.setConfigurations(Collections.singletonList(runConfiguration));\n+        doReturn(folder).when(mockFolderManager).loadTree();\n+        mockDockerRegistryList();\n+        mockUserContext();\n+        mockSid();\n+        initAclEntity(folder, AclPermission.NO_READ);\n+        initAclEntity(runConfiguration);\n+\n+        final Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n+                .loadAvailable(new AclSid(SIMPLE_USER, true), null);\n+\n+        assertThat(available.size()).isEqualTo(1);\n+        assertThat(available.get(AclClass.CONFIGURATION).get(0).getMask()).isEqualTo(ALL_PERMISSIONS);\n     }\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testUseItOwnRestrictedPermissionsIfParentAllowed() {\n-        Folder folder = createFolder(TEST_NAME, null);\n-        RunConfiguration runConfiguration = createRunConfiguration(TEST_NAME, folder.getId());\n-\n-        grantPermission(folder.getId(), AclClass.FOLDER, USER2, true, ALL_PERMISSIONS);\n-        grantPermission(runConfiguration.getId(), AclClass.CONFIGURATION, USER2, true,\n-                AclPermission.NO_READ.getMask());\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n-                .loadAvailable(new AclSid(USER2, true), null);\n-        //folder should be filtered because it forbidden\n-        Assert.assertEquals(1, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.FOLDER).get(0).getMask(), ALL_PERMISSIONS_SIMPLE);\n+    public void shouldUseItOwnRestrictedPermissionsIfParentAllowed() {\n+        final Folder childFolder = getFolder(ID_2, ANOTHER_SIMPLE_USER);", "originalCommit": "304b258c60aa8aa560e6e270a53a77e5b99e31d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTU5ODQ4Ng==", "url": "https://github.com/epam/cloud-pipeline/pull/1702#discussion_r559598486", "bodyText": "It seems that the new test logic is not repeat the old one: permissions shall be granted to group", "author": "ekazachkova", "createdAt": "2021-01-18T14:19:59Z", "path": "api/src/test/java/com/epam/pipeline/manager/HierarchicalEntityManagerTest.java", "diffHunk": "@@ -16,348 +16,315 @@\n \n package com.epam.pipeline.manager;\n \n-import com.epam.pipeline.app.TestApplicationWithAclSecurity;\n-import com.epam.pipeline.controller.vo.PermissionGrantVO;\n-import com.epam.pipeline.controller.vo.PipelineUserVO;\n-import com.epam.pipeline.controller.vo.configuration.RunConfigurationVO;\n import com.epam.pipeline.entity.AbstractSecuredEntity;\n-import com.epam.pipeline.entity.configuration.PipelineConfiguration;\n import com.epam.pipeline.entity.configuration.RunConfiguration;\n-import com.epam.pipeline.entity.configuration.RunConfigurationEntry;\n+import com.epam.pipeline.entity.docker.DockerRegistryList;\n import com.epam.pipeline.entity.pipeline.DockerRegistry;\n import com.epam.pipeline.entity.pipeline.Folder;\n+import com.epam.pipeline.entity.pipeline.Pipeline;\n import com.epam.pipeline.entity.pipeline.Tool;\n import com.epam.pipeline.entity.pipeline.ToolGroup;\n import com.epam.pipeline.entity.security.acl.AclClass;\n import com.epam.pipeline.entity.security.acl.AclSid;\n import com.epam.pipeline.entity.user.DefaultRoles;\n import com.epam.pipeline.entity.user.Role;\n-import com.epam.pipeline.manager.cluster.KubernetesManager;\n-import com.epam.pipeline.manager.configuration.RunConfigurationManager;\n-import com.epam.pipeline.manager.docker.DockerClient;\n-import com.epam.pipeline.manager.docker.DockerClientFactory;\n import com.epam.pipeline.manager.docker.DockerRegistryManager;\n-import com.epam.pipeline.manager.pipeline.FolderCrudManager;\n-import com.epam.pipeline.manager.pipeline.ToolGroupManager;\n-import com.epam.pipeline.manager.pipeline.ToolManager;\n+import com.epam.pipeline.manager.pipeline.FolderManager;\n import com.epam.pipeline.manager.security.GrantPermissionManager;\n import com.epam.pipeline.manager.user.RoleManager;\n import com.epam.pipeline.manager.user.UserManager;\n+import com.epam.pipeline.security.UserContext;\n import com.epam.pipeline.security.acl.AclPermission;\n-import org.junit.Assert;\n-import org.junit.Before;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.user.UserCreatorUtils;\n import org.junit.Test;\n-import org.mockito.Mockito;\n import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.boot.test.mock.mockito.MockBean;\n-import org.springframework.security.test.context.support.WithMockUser;\n-import org.springframework.test.annotation.DirtiesContext;\n-import org.springframework.test.context.ContextConfiguration;\n-import org.springframework.transaction.annotation.Transactional;\n \n import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n \n-\n-@DirtiesContext\n-@Transactional\n-@ContextConfiguration(classes = TestApplicationWithAclSecurity.class)\n-public class HierarchicalEntityManagerTest extends AbstractManagerTest {\n-\n-    private static final String USER = \"OWNER\";\n-    private static final String USER2 = \"VIEWER\";\n-\n-    private static final String TEST_NAME = \"name\";\n-    private static final int ALL_PERMISSIONS = AclPermission.READ.getMask()\n-                                                | AclPermission.WRITE.getMask()\n-                                                | AclPermission.EXECUTE.getMask();\n-    private static final int ALL_PERMISSIONS_SIMPLE = AclPermission.getBasicPermissions().stream()\n-            .map(AclPermission::getSimpleMask).reduce((m, m2) -> m | m2).get();\n-    private static final String TEST_ROLE = \"TEST_ROLE\";\n-\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ALL_PERMISSIONS;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_2;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.READ_PERMISSION;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.WRITE_PERMISSION;\n+import static com.epam.pipeline.test.creator.configuration.ConfigurationCreatorUtils.getRunConfiguration;\n+import static com.epam.pipeline.test.creator.docker.DockerCreatorUtils.getDockerRegistry;\n+import static com.epam.pipeline.test.creator.docker.DockerCreatorUtils.getDockerRegistryList;\n+import static com.epam.pipeline.test.creator.docker.DockerCreatorUtils.getTool;\n+import static com.epam.pipeline.test.creator.docker.DockerCreatorUtils.getToolGroup;\n+import static com.epam.pipeline.test.creator.folder.FolderCreatorUtils.getFolder;\n+import static com.epam.pipeline.test.creator.pipeline.PipelineCreatorUtils.getPipeline;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyBoolean;\n+import static org.mockito.Matchers.anyLong;\n+import static org.mockito.Mockito.doReturn;\n+\n+public class HierarchicalEntityManagerTest extends AbstractAclTest {\n+\n+    private final Tool tool = getTool(ID, ANOTHER_SIMPLE_USER);\n+    private final ToolGroup toolGroup = getToolGroup(ID, ANOTHER_SIMPLE_USER, Collections.singletonList(tool));\n+    private final RunConfiguration runConfiguration = getRunConfiguration(ID, ANOTHER_SIMPLE_USER);\n+    private final Pipeline pipeline = getPipeline(ID, ANOTHER_SIMPLE_USER);\n+    private final UserContext userContext = new UserContext(ID, SIMPLE_USER);\n+    private final DockerRegistry registry =\n+            getDockerRegistry(ID, ANOTHER_SIMPLE_USER, Collections.singletonList(toolGroup));\n+    private final DockerRegistryList dockerRegistryList = getDockerRegistryList(ID, ANOTHER_SIMPLE_USER, registry);\n+    private final Folder folder = getFolder(ID, ANOTHER_SIMPLE_USER);\n+    private final Role role = UserCreatorUtils.getRole();\n \n     @Autowired\n     private HierarchicalEntityManager hierarchicalEntityManager;\n \n     @Autowired\n-    private RunConfigurationManager configurationManager;\n-\n-    @Autowired\n-    private DockerRegistryManager registryManager;\n+    private DockerRegistryManager mockRegistryManager;\n \n     @Autowired\n-    private ToolGroupManager toolGroupManager;\n+    private UserManager mockUserManager;\n \n     @Autowired\n-    private ToolManager toolManager;\n+    private GrantPermissionManager spyPermissionManager;\n \n     @Autowired\n-    private UserManager userManager;\n+    private FolderManager mockFolderManager;\n \n     @Autowired\n-    private RoleManager roleManager;\n-\n-    @Autowired\n-    private GrantPermissionManager permissionManager;\n-\n-    @Autowired\n-    private FolderCrudManager folderCrudManager;\n-\n-    @MockBean\n-    private DockerClientFactory dockerClientFactory;\n-\n-    @MockBean\n-    private KubernetesManager kubernetesManager;\n-\n-    private DockerClient client = Mockito.mock(DockerClient.class);\n-\n-    @Before\n-    public void setUp() {\n-        PipelineUserVO userVO = new PipelineUserVO();\n-        userVO.setRoleIds(Collections.singletonList(DefaultRoles.ROLE_USER.getId()));\n-        userVO.setUserName(USER);\n-        userManager.createUser(userVO);\n-\n-        userVO.setUserName(USER2);\n-        userManager.createUser(userVO);\n-        Mockito.when(kubernetesManager.createDockerRegistrySecret(Mockito.any())).thenReturn(\"\");\n-        Mockito.when(dockerClientFactory.getDockerClient(Mockito.any(), Mockito.any())).thenReturn(client);\n-    }\n+    private RoleManager spyRoleManager;\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testToolInheritPermissionsFromRegistry() {\n-        DockerRegistry registry = registryManager.create(\n-                ObjectCreatorUtils.createDockerRegistryVO(TEST_NAME, USER, USER));\n-        ToolGroup toolGroup = toolGroupManager.create(\n-                ObjectCreatorUtils.createToolGroup(TEST_NAME, registry.getId()));\n-        toolManager.create(ObjectCreatorUtils.createTool(TEST_NAME, toolGroup.getId()), false);\n-        grantPermission(registry.getId(), AclClass.DOCKER_REGISTRY, USER2, true, AclPermission.READ.getMask());\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n-                .loadAvailable(new AclSid(USER2, true), null);\n-        Assert.assertEquals(3, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.TOOL).get(0).getMask(), AclPermission.READ.getMask());\n+    public void shouldInheritPermissionsFromRegistry() {\n+        doReturn(dockerRegistryList).when(mockRegistryManager).loadAllRegistriesContent();\n+        doReturn(folder).when(mockFolderManager).loadTree();\n+        mockUserContext();\n+        mockSid();\n+        initAclEntity(dockerRegistryList);\n+        initAclEntity(registry, AclPermission.READ);\n+        initAclEntity(toolGroup);\n+        initAclEntity(tool);\n+\n+        final Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n+                .loadAvailable(new AclSid(SIMPLE_USER, true), null);\n+\n+        assertThat(available.size()).isEqualTo(3);\n+        assertThat(available.get(AclClass.TOOL).get(0).getMask()).isEqualTo(READ_PERMISSION);\n     }\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testIfOnlyToolAllowedGroupAndRegistryDontPresetInResult() {\n-        DockerRegistry registry = registryManager.create(\n-                ObjectCreatorUtils.createDockerRegistryVO(TEST_NAME, USER, USER));\n-        ToolGroup toolGroup = toolGroupManager.create(\n-                ObjectCreatorUtils.createToolGroup(TEST_NAME, registry.getId()));\n-        Tool tool = toolManager.create(\n-                ObjectCreatorUtils.createTool(TEST_NAME, toolGroup.getId()), false);\n-        grantPermission(tool.getId(), AclClass.TOOL, USER2, true, AclPermission.READ.getMask());\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n-                .loadAvailable(new AclSid(USER2, true), null);\n-        Assert.assertEquals(1, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.TOOL).get(0).getMask(), AclPermission.READ.getMask());\n+    public void shouldLoadOnlyEntityWithPermission() {\n+        doReturn(dockerRegistryList).when(mockRegistryManager).loadAllRegistriesContent();\n+        doReturn(folder).when(mockFolderManager).loadTree();\n+        mockUserContext();\n+        mockSid();\n+        initAclEntity(dockerRegistryList);\n+        initAclEntity(registry);\n+        initAclEntity(toolGroup);\n+        initAclEntity(tool, AclPermission.READ);\n+\n+        final Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n+                .loadAvailable(new AclSid(SIMPLE_USER, true), null);\n+\n+        assertThat(available.size()).isEqualTo(1);\n+        assertThat(available.get(AclClass.TOOL).get(0).getMask()).isEqualTo(READ_PERMISSION);\n     }\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testLoadingByRoleSidWorks() {\n-        DockerRegistry registry = registryManager.create(\n-                ObjectCreatorUtils.createDockerRegistryVO(TEST_NAME, USER, USER));\n-        ToolGroup toolGroup = toolGroupManager.create(\n-                ObjectCreatorUtils.createToolGroup(TEST_NAME, registry.getId()));\n-        Tool tool = toolManager.create(\n-                ObjectCreatorUtils.createTool(TEST_NAME, toolGroup.getId()), false);\n-        grantPermission(tool.getId(), AclClass.TOOL, DefaultRoles.ROLE_USER.getName(),\n-                false, AclPermission.READ.getMask());\n-\n-        Folder folder = createFolder(TEST_NAME, null);\n-        RunConfiguration runConfiguration = createRunConfiguration(TEST_NAME, folder.getId());\n-        grantPermission(runConfiguration.getId(), AclClass.CONFIGURATION, DefaultRoles.ROLE_USER.getName(),\n-                false, AclPermission.READ.getMask());\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager.loadAvailable(\n-                new AclSid(DefaultRoles.ROLE_USER.getName(), false), null);\n-        Assert.assertEquals(2, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.TOOL).get(0).getMask(), AclPermission.READ.getMask());\n+    public void shouldLoadByRoleSid() {\n+        folder.setConfigurations(Collections.singletonList(runConfiguration));\n+        doReturn(dockerRegistryList).when(mockRegistryManager).loadAllRegistriesContent();\n+        doReturn(folder).when(mockFolderManager).loadTree();\n+        mockUserContext();\n+        mockSid();\n+        initAclEntity(dockerRegistryList);\n+        initAclEntity(folder);\n+        initAclEntity(registry);\n+        initAclEntity(toolGroup);\n+        initAclEntity(tool,\n+                Collections.singletonList(new UserPermission(DefaultRoles.ROLE_USER.getName(), READ_PERMISSION)));\n+        initAclEntity(runConfiguration,\n+                Collections.singletonList(new UserPermission(DefaultRoles.ROLE_USER.getName(), READ_PERMISSION)));\n+\n+        final Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager.loadAvailable(\n+                new AclSid(DefaultRoles.ROLE_USER.getName(), true), null);\n+\n+        assertThat(available.size()).isEqualTo(2);\n+        assertThat(available.get(AclClass.TOOL).get(0).getMask()).isEqualTo(READ_PERMISSION);\n     }\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testLoadingByRoleSidWorksWhenLoadForUser() {\n-        DockerRegistry registry = registryManager.create(\n-                ObjectCreatorUtils.createDockerRegistryVO(TEST_NAME, USER, USER));\n-        ToolGroup toolGroup = toolGroupManager.create(\n-                ObjectCreatorUtils.createToolGroup(TEST_NAME, registry.getId()));\n-        Tool tool = toolManager.create(\n-                ObjectCreatorUtils.createTool(TEST_NAME, toolGroup.getId()), false);\n-        grantPermission(tool.getId(), AclClass.TOOL, DefaultRoles.ROLE_USER.getName(),\n-                false, AclPermission.READ.getMask());\n-\n-        Folder folder = createFolder(TEST_NAME, null);\n-        RunConfiguration runConfiguration = createRunConfiguration(TEST_NAME, folder.getId());\n-        grantPermission(runConfiguration.getId(), AclClass.CONFIGURATION, DefaultRoles.ROLE_USER.getName(),\n-                false, AclPermission.READ.getMask());\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n-                .loadAvailable(new AclSid(USER2, true), null);\n-        Assert.assertEquals(2, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.TOOL).get(0).getMask(), AclPermission.READ.getMask());\n+    public void shouldLoadByRoleSidWhenLoadForUser() {\n+        folder.setConfigurations(Collections.singletonList(runConfiguration));", "originalCommit": "304b258c60aa8aa560e6e270a53a77e5b99e31d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTYwMTc4OA==", "url": "https://github.com/epam/cloud-pipeline/pull/1702#discussion_r559601788", "bodyText": "Also, could I ask you to add not issue related changes to this class?\nIf you don't mind, let's refactor beans above JsonService, DataStorageManager and FolderCrudManager to make them @MockBean. Moreover, let's remove TemplatesScanner since it is not a bean.", "author": "ekazachkova", "createdAt": "2021-01-18T14:25:15Z", "path": "api/src/test/java/com/epam/pipeline/test/acl/AclTestBeans.java", "diffHunk": "@@ -484,6 +479,14 @@ protected FolderCrudManager mockFolderCrudManager() {\n         return Mockito.mock(FolderCrudManager.class);\n     }\n \n+    @Bean", "originalCommit": "304b258c60aa8aa560e6e270a53a77e5b99e31d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Njc1MjA0NA==", "url": "https://github.com/epam/cloud-pipeline/pull/1702#discussion_r566752044", "bodyText": "According to the documentation for AclImpl this sid shall be owner sid. So I would prefer leave new PrincipalSid(entity.getOwner())", "author": "ekazachkova", "createdAt": "2021-01-29T11:19:16Z", "path": "api/src/test/java/com/epam/pipeline/test/acl/AbstractAclTest.java", "diffHunk": "@@ -83,17 +84,37 @@\n \n     protected void initAclEntity(AbstractSecuredEntity entity, Permission permission) {\n         initAclEntity(entity,\n-                Collections.singletonList(new UserPermission(SIMPLE_USER, permission.getMask())));\n+                Collections.singletonList(new UserPermission(SIMPLE_USER, permission.getMask())), null);\n     }\n \n     protected void initAclEntity(AbstractSecuredEntity entity) {\n-        initAclEntity(entity, Collections.emptyList());\n+        initAclEntity(entity, Collections.emptyList(), null);\n     }\n \n     protected void initAclEntity(AbstractSecuredEntity entity, List<AbstractGrantPermission> permissions) {\n+        initAclEntity(entity, permissions, null);\n+    }\n+\n+    protected void initAclEntity(AbstractSecuredEntity entity, String role, Permission permission) {\n+        initAclEntity(entity,\n+                Collections.singletonList(new AuthorityPermission(permission.getMask(), role)), role);\n+    }\n+\n+    protected void initAclEntity(AbstractSecuredEntity entity, String role) {\n+        initAclEntity(entity, Collections.emptyList(), role);\n+    }\n+\n+    protected void initAclEntity(AbstractSecuredEntity entity, List<AbstractGrantPermission> permissions, String role) {\n+        Sid sid;\n+        if (role == null) {\n+            sid = new PrincipalSid(entity.getOwner());\n+        } else {\n+            sid = new GrantedAuthoritySid(DefaultRoles.ROLE_ANONYMOUS_USER.getName());\n+        }\n+\n         ObjectIdentityImpl objectIdentity = new ObjectIdentityImpl(entity);\n         AclImpl acl = new AclImpl(objectIdentity, entity.getId(), aclAuthorizationStrategy,\n-                grantingStrategy, null, null, true, new PrincipalSid(entity.getOwner()));\n+                grantingStrategy, null, null, true, sid);", "originalCommit": "7b73b61dd208cacb29faf849397e075cf12de8b7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Njc1MzkxNg==", "url": "https://github.com/epam/cloud-pipeline/pull/1702#discussion_r566753916", "bodyText": "Let's create a separate method  mockUserContextWithRole", "author": "ekazachkova", "createdAt": "2021-01-29T11:23:00Z", "path": "api/src/test/java/com/epam/pipeline/manager/HierarchicalEntityManagerTest.java", "diffHunk": "@@ -16,348 +16,353 @@\n \n package com.epam.pipeline.manager;\n \n-import com.epam.pipeline.app.TestApplicationWithAclSecurity;\n-import com.epam.pipeline.controller.vo.PermissionGrantVO;\n-import com.epam.pipeline.controller.vo.PipelineUserVO;\n-import com.epam.pipeline.controller.vo.configuration.RunConfigurationVO;\n import com.epam.pipeline.entity.AbstractSecuredEntity;\n-import com.epam.pipeline.entity.configuration.PipelineConfiguration;\n import com.epam.pipeline.entity.configuration.RunConfiguration;\n-import com.epam.pipeline.entity.configuration.RunConfigurationEntry;\n+import com.epam.pipeline.entity.docker.DockerRegistryList;\n import com.epam.pipeline.entity.pipeline.DockerRegistry;\n import com.epam.pipeline.entity.pipeline.Folder;\n import com.epam.pipeline.entity.pipeline.Tool;\n import com.epam.pipeline.entity.pipeline.ToolGroup;\n import com.epam.pipeline.entity.security.acl.AclClass;\n import com.epam.pipeline.entity.security.acl.AclSid;\n import com.epam.pipeline.entity.user.DefaultRoles;\n-import com.epam.pipeline.entity.user.Role;\n-import com.epam.pipeline.manager.cluster.KubernetesManager;\n-import com.epam.pipeline.manager.configuration.RunConfigurationManager;\n-import com.epam.pipeline.manager.docker.DockerClient;\n-import com.epam.pipeline.manager.docker.DockerClientFactory;\n+import com.epam.pipeline.entity.user.ExtendedRole;\n+import com.epam.pipeline.entity.user.PipelineUser;\n import com.epam.pipeline.manager.docker.DockerRegistryManager;\n-import com.epam.pipeline.manager.pipeline.FolderCrudManager;\n-import com.epam.pipeline.manager.pipeline.ToolGroupManager;\n-import com.epam.pipeline.manager.pipeline.ToolManager;\n+import com.epam.pipeline.manager.pipeline.FolderManager;\n import com.epam.pipeline.manager.security.GrantPermissionManager;\n import com.epam.pipeline.manager.user.RoleManager;\n import com.epam.pipeline.manager.user.UserManager;\n+import com.epam.pipeline.security.UserContext;\n import com.epam.pipeline.security.acl.AclPermission;\n-import org.junit.Assert;\n-import org.junit.Before;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.user.UserCreatorUtils;\n import org.junit.Test;\n-import org.mockito.Mockito;\n import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.boot.test.mock.mockito.MockBean;\n-import org.springframework.security.test.context.support.WithMockUser;\n-import org.springframework.test.annotation.DirtiesContext;\n-import org.springframework.test.context.ContextConfiguration;\n-import org.springframework.transaction.annotation.Transactional;\n \n import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n \n-\n-@DirtiesContext\n-@Transactional\n-@ContextConfiguration(classes = TestApplicationWithAclSecurity.class)\n-public class HierarchicalEntityManagerTest extends AbstractManagerTest {\n-\n-    private static final String USER = \"OWNER\";\n-    private static final String USER2 = \"VIEWER\";\n-\n-    private static final String TEST_NAME = \"name\";\n-    private static final int ALL_PERMISSIONS = AclPermission.READ.getMask()\n-                                                | AclPermission.WRITE.getMask()\n-                                                | AclPermission.EXECUTE.getMask();\n-    private static final int ALL_PERMISSIONS_SIMPLE = AclPermission.getBasicPermissions().stream()\n-            .map(AclPermission::getSimpleMask).reduce((m, m2) -> m | m2).get();\n-    private static final String TEST_ROLE = \"TEST_ROLE\";\n-\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ALL_PERMISSIONS;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.READ_PERMISSION;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.WRITE_PERMISSION;\n+import static com.epam.pipeline.test.creator.configuration.ConfigurationCreatorUtils.getRunConfiguration;\n+import static com.epam.pipeline.test.creator.docker.DockerCreatorUtils.getDockerRegistry;\n+import static com.epam.pipeline.test.creator.docker.DockerCreatorUtils.getDockerRegistryList;\n+import static com.epam.pipeline.test.creator.docker.DockerCreatorUtils.getTool;\n+import static com.epam.pipeline.test.creator.docker.DockerCreatorUtils.getToolGroup;\n+import static com.epam.pipeline.test.creator.folder.FolderCreatorUtils.getFolder;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyBoolean;\n+import static org.mockito.Mockito.doReturn;\n+\n+public class HierarchicalEntityManagerTest extends AbstractAclTest {\n+\n+    private final DockerRegistryList dockerRegistryList = getDockerRegistryList();\n+    private final UserContext userContext = new UserContext(ID, SIMPLE_USER);\n \n     @Autowired\n     private HierarchicalEntityManager hierarchicalEntityManager;\n \n     @Autowired\n-    private RunConfigurationManager configurationManager;\n-\n-    @Autowired\n-    private DockerRegistryManager registryManager;\n+    private DockerRegistryManager mockRegistryManager;\n \n     @Autowired\n-    private ToolGroupManager toolGroupManager;\n+    private UserManager mockUserManager;\n \n     @Autowired\n-    private ToolManager toolManager;\n+    private FolderManager mockFolderManager;\n \n     @Autowired\n-    private UserManager userManager;\n+    private RoleManager mockRoleManager;\n \n     @Autowired\n-    private RoleManager roleManager;\n-\n-    @Autowired\n-    private GrantPermissionManager permissionManager;\n-\n-    @Autowired\n-    private FolderCrudManager folderCrudManager;\n-\n-    @MockBean\n-    private DockerClientFactory dockerClientFactory;\n-\n-    @MockBean\n-    private KubernetesManager kubernetesManager;\n-\n-    private DockerClient client = Mockito.mock(DockerClient.class);\n-\n-    @Before\n-    public void setUp() {\n-        PipelineUserVO userVO = new PipelineUserVO();\n-        userVO.setRoleIds(Collections.singletonList(DefaultRoles.ROLE_USER.getId()));\n-        userVO.setUserName(USER);\n-        userManager.createUser(userVO);\n-\n-        userVO.setUserName(USER2);\n-        userManager.createUser(userVO);\n-        Mockito.when(kubernetesManager.createDockerRegistrySecret(Mockito.any())).thenReturn(\"\");\n-        Mockito.when(dockerClientFactory.getDockerClient(Mockito.any(), Mockito.any())).thenReturn(client);\n-    }\n+    private GrantPermissionManager spyPermissionManager;\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testToolInheritPermissionsFromRegistry() {\n-        DockerRegistry registry = registryManager.create(\n-                ObjectCreatorUtils.createDockerRegistryVO(TEST_NAME, USER, USER));\n-        ToolGroup toolGroup = toolGroupManager.create(\n-                ObjectCreatorUtils.createToolGroup(TEST_NAME, registry.getId()));\n-        toolManager.create(ObjectCreatorUtils.createTool(TEST_NAME, toolGroup.getId()), false);\n-        grantPermission(registry.getId(), AclClass.DOCKER_REGISTRY, USER2, true, AclPermission.READ.getMask());\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n-                .loadAvailable(new AclSid(USER2, true), null);\n-        Assert.assertEquals(3, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.TOOL).get(0).getMask(), AclPermission.READ.getMask());\n+    public void shouldInheritPermissionsFromRegistry() {\n+        final DockerRegistry registry = getDockerRegistry(ID, ANOTHER_SIMPLE_USER);\n+        final Tool tool = getTool(ID, ANOTHER_SIMPLE_USER);\n+        final ToolGroup toolGroup = getToolGroup(ID, ANOTHER_SIMPLE_USER);\n+        final DockerRegistryList dockerRegistryList = getDockerRegistryList(ID, ANOTHER_SIMPLE_USER, registry);\n+        final Folder folder = getFolder(ANOTHER_SIMPLE_USER);\n+        toolGroup.setTools(Collections.singletonList(tool));\n+        registry.setGroups(Collections.singletonList(toolGroup));\n+        doReturn(dockerRegistryList).when(mockRegistryManager).loadAllRegistriesContent();\n+        doReturn(folder).when(mockFolderManager).loadTree();\n+        mockUserContext();\n+        mockSid();\n+        initAclEntity(dockerRegistryList);\n+        initAclEntity(registry, AclPermission.READ);\n+        initAclEntity(toolGroup);\n+        initAclEntity(tool);\n+\n+        final Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n+                .loadAvailable(new AclSid(SIMPLE_USER, true), null);\n+\n+        assertThat(available.size()).isEqualTo(3);\n+        assertThat(available.get(AclClass.TOOL).get(0).getMask()).isEqualTo(READ_PERMISSION);\n     }\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testIfOnlyToolAllowedGroupAndRegistryDontPresetInResult() {\n-        DockerRegistry registry = registryManager.create(\n-                ObjectCreatorUtils.createDockerRegistryVO(TEST_NAME, USER, USER));\n-        ToolGroup toolGroup = toolGroupManager.create(\n-                ObjectCreatorUtils.createToolGroup(TEST_NAME, registry.getId()));\n-        Tool tool = toolManager.create(\n-                ObjectCreatorUtils.createTool(TEST_NAME, toolGroup.getId()), false);\n-        grantPermission(tool.getId(), AclClass.TOOL, USER2, true, AclPermission.READ.getMask());\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n-                .loadAvailable(new AclSid(USER2, true), null);\n-        Assert.assertEquals(1, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.TOOL).get(0).getMask(), AclPermission.READ.getMask());\n+    public void shouldLoadOnlyEntityWithPermission() {\n+        final DockerRegistry registry = getDockerRegistry(ID, ANOTHER_SIMPLE_USER);\n+        final Tool tool = getTool(ID, ANOTHER_SIMPLE_USER);\n+        final ToolGroup toolGroup = getToolGroup(ID, ANOTHER_SIMPLE_USER);\n+        final DockerRegistryList dockerRegistryList = getDockerRegistryList(ID, ANOTHER_SIMPLE_USER, registry);\n+        final Folder folder = getFolder(ANOTHER_SIMPLE_USER);\n+        toolGroup.setTools(Collections.singletonList(tool));\n+        registry.setGroups(Collections.singletonList(toolGroup));\n+        doReturn(dockerRegistryList).when(mockRegistryManager).loadAllRegistriesContent();\n+        doReturn(folder).when(mockFolderManager).loadTree();\n+        mockUserContext();\n+        mockSid();\n+        initAclEntity(dockerRegistryList);\n+        initAclEntity(registry);\n+        initAclEntity(toolGroup);\n+        initAclEntity(tool, AclPermission.READ);\n+\n+        final Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n+                .loadAvailable(new AclSid(SIMPLE_USER, true), null);\n+\n+        assertThat(available.size()).isEqualTo(1);\n+        assertThat(available.get(AclClass.TOOL).get(0).getMask()).isEqualTo(READ_PERMISSION);\n     }\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testLoadingByRoleSidWorks() {\n-        DockerRegistry registry = registryManager.create(\n-                ObjectCreatorUtils.createDockerRegistryVO(TEST_NAME, USER, USER));\n-        ToolGroup toolGroup = toolGroupManager.create(\n-                ObjectCreatorUtils.createToolGroup(TEST_NAME, registry.getId()));\n-        Tool tool = toolManager.create(\n-                ObjectCreatorUtils.createTool(TEST_NAME, toolGroup.getId()), false);\n-        grantPermission(tool.getId(), AclClass.TOOL, DefaultRoles.ROLE_USER.getName(),\n-                false, AclPermission.READ.getMask());\n-\n-        Folder folder = createFolder(TEST_NAME, null);\n-        RunConfiguration runConfiguration = createRunConfiguration(TEST_NAME, folder.getId());\n-        grantPermission(runConfiguration.getId(), AclClass.CONFIGURATION, DefaultRoles.ROLE_USER.getName(),\n-                false, AclPermission.READ.getMask());\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager.loadAvailable(\n-                new AclSid(DefaultRoles.ROLE_USER.getName(), false), null);\n-        Assert.assertEquals(2, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.TOOL).get(0).getMask(), AclPermission.READ.getMask());\n+    public void shouldLoadByRoleSid() {\n+        final DockerRegistry registry = getDockerRegistry(ID, ANOTHER_SIMPLE_USER);\n+        final Tool tool = getTool(ID, ANOTHER_SIMPLE_USER);\n+        final ToolGroup toolGroup = getToolGroup(ID, ANOTHER_SIMPLE_USER);\n+        final DockerRegistryList dockerRegistryList = getDockerRegistryList(ID, ANOTHER_SIMPLE_USER, registry);\n+        final Folder folder = getFolder(ANOTHER_SIMPLE_USER);\n+        final RunConfiguration runConfiguration = getRunConfiguration(ID, ANOTHER_SIMPLE_USER);\n+        toolGroup.setTools(Collections.singletonList(tool));\n+        registry.setGroups(Collections.singletonList(toolGroup));\n+        folder.setConfigurations(Collections.singletonList(runConfiguration));\n+        doReturn(dockerRegistryList).when(mockRegistryManager).loadAllRegistriesContent();\n+        doReturn(folder).when(mockFolderManager).loadTree();\n+        mockUserContext();\n+        mockSid();\n+        initAclEntity(dockerRegistryList);\n+        initAclEntity(folder);\n+        initAclEntity(registry);\n+        initAclEntity(toolGroup);\n+        initAclEntity(tool,\n+                Collections.singletonList(new UserPermission(DefaultRoles.ROLE_USER.getName(), READ_PERMISSION)));\n+        initAclEntity(runConfiguration,\n+                Collections.singletonList(new UserPermission(DefaultRoles.ROLE_USER.getName(), READ_PERMISSION)));\n+\n+        final Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager.loadAvailable(\n+                new AclSid(DefaultRoles.ROLE_USER.getName(), true), null);\n+\n+        assertThat(available.size()).isEqualTo(2);\n+        assertThat(available.get(AclClass.TOOL).get(0).getMask()).isEqualTo(READ_PERMISSION);\n     }\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testLoadingByRoleSidWorksWhenLoadForUser() {\n-        DockerRegistry registry = registryManager.create(\n-                ObjectCreatorUtils.createDockerRegistryVO(TEST_NAME, USER, USER));\n-        ToolGroup toolGroup = toolGroupManager.create(\n-                ObjectCreatorUtils.createToolGroup(TEST_NAME, registry.getId()));\n-        Tool tool = toolManager.create(\n-                ObjectCreatorUtils.createTool(TEST_NAME, toolGroup.getId()), false);\n-        grantPermission(tool.getId(), AclClass.TOOL, DefaultRoles.ROLE_USER.getName(),\n-                false, AclPermission.READ.getMask());\n-\n-        Folder folder = createFolder(TEST_NAME, null);\n-        RunConfiguration runConfiguration = createRunConfiguration(TEST_NAME, folder.getId());\n-        grantPermission(runConfiguration.getId(), AclClass.CONFIGURATION, DefaultRoles.ROLE_USER.getName(),\n-                false, AclPermission.READ.getMask());\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n-                .loadAvailable(new AclSid(USER2, true), null);\n-        Assert.assertEquals(2, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.TOOL).get(0).getMask(), AclPermission.READ.getMask());\n+    public void shouldLoadByRoleSidWhenLoadForUser() {\n+        final DockerRegistry registry = getDockerRegistry(ID, ANOTHER_SIMPLE_USER);\n+        final ToolGroup toolGroup = getToolGroup(ID, ANOTHER_SIMPLE_USER);\n+        final DockerRegistryList dockerRegistryList = getDockerRegistryList(ID, ANOTHER_SIMPLE_USER, registry);\n+        final Folder folder = getFolder(ANOTHER_SIMPLE_USER);\n+        final UserContext userContext = new UserContext(ID, ANOTHER_SIMPLE_USER);", "originalCommit": "7b73b61dd208cacb29faf849397e075cf12de8b7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NjgxNjI1Ng==", "url": "https://github.com/epam/cloud-pipeline/pull/1702#discussion_r566816256", "bodyText": "Could you please fix this test: the new test is not repeat the old test logic?", "author": "ekazachkova", "createdAt": "2021-01-29T13:21:39Z", "path": "api/src/test/java/com/epam/pipeline/manager/HierarchicalEntityManagerTest.java", "diffHunk": "@@ -16,348 +16,353 @@\n \n package com.epam.pipeline.manager;\n \n-import com.epam.pipeline.app.TestApplicationWithAclSecurity;\n-import com.epam.pipeline.controller.vo.PermissionGrantVO;\n-import com.epam.pipeline.controller.vo.PipelineUserVO;\n-import com.epam.pipeline.controller.vo.configuration.RunConfigurationVO;\n import com.epam.pipeline.entity.AbstractSecuredEntity;\n-import com.epam.pipeline.entity.configuration.PipelineConfiguration;\n import com.epam.pipeline.entity.configuration.RunConfiguration;\n-import com.epam.pipeline.entity.configuration.RunConfigurationEntry;\n+import com.epam.pipeline.entity.docker.DockerRegistryList;\n import com.epam.pipeline.entity.pipeline.DockerRegistry;\n import com.epam.pipeline.entity.pipeline.Folder;\n import com.epam.pipeline.entity.pipeline.Tool;\n import com.epam.pipeline.entity.pipeline.ToolGroup;\n import com.epam.pipeline.entity.security.acl.AclClass;\n import com.epam.pipeline.entity.security.acl.AclSid;\n import com.epam.pipeline.entity.user.DefaultRoles;\n-import com.epam.pipeline.entity.user.Role;\n-import com.epam.pipeline.manager.cluster.KubernetesManager;\n-import com.epam.pipeline.manager.configuration.RunConfigurationManager;\n-import com.epam.pipeline.manager.docker.DockerClient;\n-import com.epam.pipeline.manager.docker.DockerClientFactory;\n+import com.epam.pipeline.entity.user.ExtendedRole;\n+import com.epam.pipeline.entity.user.PipelineUser;\n import com.epam.pipeline.manager.docker.DockerRegistryManager;\n-import com.epam.pipeline.manager.pipeline.FolderCrudManager;\n-import com.epam.pipeline.manager.pipeline.ToolGroupManager;\n-import com.epam.pipeline.manager.pipeline.ToolManager;\n+import com.epam.pipeline.manager.pipeline.FolderManager;\n import com.epam.pipeline.manager.security.GrantPermissionManager;\n import com.epam.pipeline.manager.user.RoleManager;\n import com.epam.pipeline.manager.user.UserManager;\n+import com.epam.pipeline.security.UserContext;\n import com.epam.pipeline.security.acl.AclPermission;\n-import org.junit.Assert;\n-import org.junit.Before;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.user.UserCreatorUtils;\n import org.junit.Test;\n-import org.mockito.Mockito;\n import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.boot.test.mock.mockito.MockBean;\n-import org.springframework.security.test.context.support.WithMockUser;\n-import org.springframework.test.annotation.DirtiesContext;\n-import org.springframework.test.context.ContextConfiguration;\n-import org.springframework.transaction.annotation.Transactional;\n \n import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n \n-\n-@DirtiesContext\n-@Transactional\n-@ContextConfiguration(classes = TestApplicationWithAclSecurity.class)\n-public class HierarchicalEntityManagerTest extends AbstractManagerTest {\n-\n-    private static final String USER = \"OWNER\";\n-    private static final String USER2 = \"VIEWER\";\n-\n-    private static final String TEST_NAME = \"name\";\n-    private static final int ALL_PERMISSIONS = AclPermission.READ.getMask()\n-                                                | AclPermission.WRITE.getMask()\n-                                                | AclPermission.EXECUTE.getMask();\n-    private static final int ALL_PERMISSIONS_SIMPLE = AclPermission.getBasicPermissions().stream()\n-            .map(AclPermission::getSimpleMask).reduce((m, m2) -> m | m2).get();\n-    private static final String TEST_ROLE = \"TEST_ROLE\";\n-\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ALL_PERMISSIONS;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.READ_PERMISSION;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.WRITE_PERMISSION;\n+import static com.epam.pipeline.test.creator.configuration.ConfigurationCreatorUtils.getRunConfiguration;\n+import static com.epam.pipeline.test.creator.docker.DockerCreatorUtils.getDockerRegistry;\n+import static com.epam.pipeline.test.creator.docker.DockerCreatorUtils.getDockerRegistryList;\n+import static com.epam.pipeline.test.creator.docker.DockerCreatorUtils.getTool;\n+import static com.epam.pipeline.test.creator.docker.DockerCreatorUtils.getToolGroup;\n+import static com.epam.pipeline.test.creator.folder.FolderCreatorUtils.getFolder;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyBoolean;\n+import static org.mockito.Mockito.doReturn;\n+\n+public class HierarchicalEntityManagerTest extends AbstractAclTest {\n+\n+    private final DockerRegistryList dockerRegistryList = getDockerRegistryList();\n+    private final UserContext userContext = new UserContext(ID, SIMPLE_USER);\n \n     @Autowired\n     private HierarchicalEntityManager hierarchicalEntityManager;\n \n     @Autowired\n-    private RunConfigurationManager configurationManager;\n-\n-    @Autowired\n-    private DockerRegistryManager registryManager;\n+    private DockerRegistryManager mockRegistryManager;\n \n     @Autowired\n-    private ToolGroupManager toolGroupManager;\n+    private UserManager mockUserManager;\n \n     @Autowired\n-    private ToolManager toolManager;\n+    private FolderManager mockFolderManager;\n \n     @Autowired\n-    private UserManager userManager;\n+    private RoleManager mockRoleManager;\n \n     @Autowired\n-    private RoleManager roleManager;\n-\n-    @Autowired\n-    private GrantPermissionManager permissionManager;\n-\n-    @Autowired\n-    private FolderCrudManager folderCrudManager;\n-\n-    @MockBean\n-    private DockerClientFactory dockerClientFactory;\n-\n-    @MockBean\n-    private KubernetesManager kubernetesManager;\n-\n-    private DockerClient client = Mockito.mock(DockerClient.class);\n-\n-    @Before\n-    public void setUp() {\n-        PipelineUserVO userVO = new PipelineUserVO();\n-        userVO.setRoleIds(Collections.singletonList(DefaultRoles.ROLE_USER.getId()));\n-        userVO.setUserName(USER);\n-        userManager.createUser(userVO);\n-\n-        userVO.setUserName(USER2);\n-        userManager.createUser(userVO);\n-        Mockito.when(kubernetesManager.createDockerRegistrySecret(Mockito.any())).thenReturn(\"\");\n-        Mockito.when(dockerClientFactory.getDockerClient(Mockito.any(), Mockito.any())).thenReturn(client);\n-    }\n+    private GrantPermissionManager spyPermissionManager;\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testToolInheritPermissionsFromRegistry() {\n-        DockerRegistry registry = registryManager.create(\n-                ObjectCreatorUtils.createDockerRegistryVO(TEST_NAME, USER, USER));\n-        ToolGroup toolGroup = toolGroupManager.create(\n-                ObjectCreatorUtils.createToolGroup(TEST_NAME, registry.getId()));\n-        toolManager.create(ObjectCreatorUtils.createTool(TEST_NAME, toolGroup.getId()), false);\n-        grantPermission(registry.getId(), AclClass.DOCKER_REGISTRY, USER2, true, AclPermission.READ.getMask());\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n-                .loadAvailable(new AclSid(USER2, true), null);\n-        Assert.assertEquals(3, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.TOOL).get(0).getMask(), AclPermission.READ.getMask());\n+    public void shouldInheritPermissionsFromRegistry() {\n+        final DockerRegistry registry = getDockerRegistry(ID, ANOTHER_SIMPLE_USER);\n+        final Tool tool = getTool(ID, ANOTHER_SIMPLE_USER);\n+        final ToolGroup toolGroup = getToolGroup(ID, ANOTHER_SIMPLE_USER);\n+        final DockerRegistryList dockerRegistryList = getDockerRegistryList(ID, ANOTHER_SIMPLE_USER, registry);\n+        final Folder folder = getFolder(ANOTHER_SIMPLE_USER);\n+        toolGroup.setTools(Collections.singletonList(tool));\n+        registry.setGroups(Collections.singletonList(toolGroup));\n+        doReturn(dockerRegistryList).when(mockRegistryManager).loadAllRegistriesContent();\n+        doReturn(folder).when(mockFolderManager).loadTree();\n+        mockUserContext();\n+        mockSid();\n+        initAclEntity(dockerRegistryList);\n+        initAclEntity(registry, AclPermission.READ);\n+        initAclEntity(toolGroup);\n+        initAclEntity(tool);\n+\n+        final Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n+                .loadAvailable(new AclSid(SIMPLE_USER, true), null);\n+\n+        assertThat(available.size()).isEqualTo(3);\n+        assertThat(available.get(AclClass.TOOL).get(0).getMask()).isEqualTo(READ_PERMISSION);\n     }\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testIfOnlyToolAllowedGroupAndRegistryDontPresetInResult() {\n-        DockerRegistry registry = registryManager.create(\n-                ObjectCreatorUtils.createDockerRegistryVO(TEST_NAME, USER, USER));\n-        ToolGroup toolGroup = toolGroupManager.create(\n-                ObjectCreatorUtils.createToolGroup(TEST_NAME, registry.getId()));\n-        Tool tool = toolManager.create(\n-                ObjectCreatorUtils.createTool(TEST_NAME, toolGroup.getId()), false);\n-        grantPermission(tool.getId(), AclClass.TOOL, USER2, true, AclPermission.READ.getMask());\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n-                .loadAvailable(new AclSid(USER2, true), null);\n-        Assert.assertEquals(1, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.TOOL).get(0).getMask(), AclPermission.READ.getMask());\n+    public void shouldLoadOnlyEntityWithPermission() {\n+        final DockerRegistry registry = getDockerRegistry(ID, ANOTHER_SIMPLE_USER);\n+        final Tool tool = getTool(ID, ANOTHER_SIMPLE_USER);\n+        final ToolGroup toolGroup = getToolGroup(ID, ANOTHER_SIMPLE_USER);\n+        final DockerRegistryList dockerRegistryList = getDockerRegistryList(ID, ANOTHER_SIMPLE_USER, registry);\n+        final Folder folder = getFolder(ANOTHER_SIMPLE_USER);\n+        toolGroup.setTools(Collections.singletonList(tool));\n+        registry.setGroups(Collections.singletonList(toolGroup));\n+        doReturn(dockerRegistryList).when(mockRegistryManager).loadAllRegistriesContent();\n+        doReturn(folder).when(mockFolderManager).loadTree();\n+        mockUserContext();\n+        mockSid();\n+        initAclEntity(dockerRegistryList);\n+        initAclEntity(registry);\n+        initAclEntity(toolGroup);\n+        initAclEntity(tool, AclPermission.READ);\n+\n+        final Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n+                .loadAvailable(new AclSid(SIMPLE_USER, true), null);\n+\n+        assertThat(available.size()).isEqualTo(1);\n+        assertThat(available.get(AclClass.TOOL).get(0).getMask()).isEqualTo(READ_PERMISSION);\n     }\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testLoadingByRoleSidWorks() {\n-        DockerRegistry registry = registryManager.create(\n-                ObjectCreatorUtils.createDockerRegistryVO(TEST_NAME, USER, USER));\n-        ToolGroup toolGroup = toolGroupManager.create(\n-                ObjectCreatorUtils.createToolGroup(TEST_NAME, registry.getId()));\n-        Tool tool = toolManager.create(\n-                ObjectCreatorUtils.createTool(TEST_NAME, toolGroup.getId()), false);\n-        grantPermission(tool.getId(), AclClass.TOOL, DefaultRoles.ROLE_USER.getName(),\n-                false, AclPermission.READ.getMask());\n-\n-        Folder folder = createFolder(TEST_NAME, null);\n-        RunConfiguration runConfiguration = createRunConfiguration(TEST_NAME, folder.getId());\n-        grantPermission(runConfiguration.getId(), AclClass.CONFIGURATION, DefaultRoles.ROLE_USER.getName(),\n-                false, AclPermission.READ.getMask());\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager.loadAvailable(\n-                new AclSid(DefaultRoles.ROLE_USER.getName(), false), null);\n-        Assert.assertEquals(2, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.TOOL).get(0).getMask(), AclPermission.READ.getMask());\n+    public void shouldLoadByRoleSid() {\n+        final DockerRegistry registry = getDockerRegistry(ID, ANOTHER_SIMPLE_USER);\n+        final Tool tool = getTool(ID, ANOTHER_SIMPLE_USER);\n+        final ToolGroup toolGroup = getToolGroup(ID, ANOTHER_SIMPLE_USER);\n+        final DockerRegistryList dockerRegistryList = getDockerRegistryList(ID, ANOTHER_SIMPLE_USER, registry);\n+        final Folder folder = getFolder(ANOTHER_SIMPLE_USER);\n+        final RunConfiguration runConfiguration = getRunConfiguration(ID, ANOTHER_SIMPLE_USER);\n+        toolGroup.setTools(Collections.singletonList(tool));\n+        registry.setGroups(Collections.singletonList(toolGroup));\n+        folder.setConfigurations(Collections.singletonList(runConfiguration));\n+        doReturn(dockerRegistryList).when(mockRegistryManager).loadAllRegistriesContent();\n+        doReturn(folder).when(mockFolderManager).loadTree();\n+        mockUserContext();\n+        mockSid();\n+        initAclEntity(dockerRegistryList);\n+        initAclEntity(folder);\n+        initAclEntity(registry);\n+        initAclEntity(toolGroup);\n+        initAclEntity(tool,\n+                Collections.singletonList(new UserPermission(DefaultRoles.ROLE_USER.getName(), READ_PERMISSION)));\n+        initAclEntity(runConfiguration,\n+                Collections.singletonList(new UserPermission(DefaultRoles.ROLE_USER.getName(), READ_PERMISSION)));\n+\n+        final Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager.loadAvailable(\n+                new AclSid(DefaultRoles.ROLE_USER.getName(), true), null);\n+\n+        assertThat(available.size()).isEqualTo(2);\n+        assertThat(available.get(AclClass.TOOL).get(0).getMask()).isEqualTo(READ_PERMISSION);\n     }\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testLoadingByRoleSidWorksWhenLoadForUser() {\n-        DockerRegistry registry = registryManager.create(\n-                ObjectCreatorUtils.createDockerRegistryVO(TEST_NAME, USER, USER));\n-        ToolGroup toolGroup = toolGroupManager.create(\n-                ObjectCreatorUtils.createToolGroup(TEST_NAME, registry.getId()));\n-        Tool tool = toolManager.create(\n-                ObjectCreatorUtils.createTool(TEST_NAME, toolGroup.getId()), false);\n-        grantPermission(tool.getId(), AclClass.TOOL, DefaultRoles.ROLE_USER.getName(),\n-                false, AclPermission.READ.getMask());\n-\n-        Folder folder = createFolder(TEST_NAME, null);\n-        RunConfiguration runConfiguration = createRunConfiguration(TEST_NAME, folder.getId());\n-        grantPermission(runConfiguration.getId(), AclClass.CONFIGURATION, DefaultRoles.ROLE_USER.getName(),\n-                false, AclPermission.READ.getMask());\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n-                .loadAvailable(new AclSid(USER2, true), null);\n-        Assert.assertEquals(2, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.TOOL).get(0).getMask(), AclPermission.READ.getMask());\n+    public void shouldLoadByRoleSidWhenLoadForUser() {\n+        final DockerRegistry registry = getDockerRegistry(ID, ANOTHER_SIMPLE_USER);\n+        final ToolGroup toolGroup = getToolGroup(ID, ANOTHER_SIMPLE_USER);\n+        final DockerRegistryList dockerRegistryList = getDockerRegistryList(ID, ANOTHER_SIMPLE_USER, registry);\n+        final Folder folder = getFolder(ANOTHER_SIMPLE_USER);\n+        final UserContext userContext = new UserContext(ID, ANOTHER_SIMPLE_USER);\n+        userContext.setGroups(Collections.singletonList(DefaultRoles.ROLE_USER.getName()));\n+        final Tool tool = getTool(ID, ANOTHER_SIMPLE_USER);\n+        final RunConfiguration runConfiguration = getRunConfiguration(ID, ANOTHER_SIMPLE_USER);\n+        toolGroup.setTools(Collections.singletonList(tool));\n+        registry.setGroups(Collections.singletonList(toolGroup));\n+        folder.setConfigurations(Collections.singletonList(runConfiguration));\n+        doReturn(dockerRegistryList).when(mockRegistryManager).loadAllRegistriesContent();\n+        doReturn(folder).when(mockFolderManager).loadTree();\n+        doReturn(userContext).when(mockUserManager).loadUserContext(any());\n+        mockSid();\n+        initAclEntity(dockerRegistryList, DefaultRoles.ROLE_ANONYMOUS_USER.getName());\n+        initAclEntity(folder, DefaultRoles.ROLE_ANONYMOUS_USER.getName());\n+        initAclEntity(registry, DefaultRoles.ROLE_ANONYMOUS_USER.getName());\n+        initAclEntity(toolGroup, DefaultRoles.ROLE_ANONYMOUS_USER.getName());\n+        initAclEntity(tool, DefaultRoles.ROLE_USER.getName(), AclPermission.READ);\n+        initAclEntity(runConfiguration, DefaultRoles.ROLE_USER.getName(), AclPermission.READ);\n+\n+        final Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager.loadAvailable(\n+                new AclSid(SIMPLE_USER, true), null);\n+\n+        assertThat(available.size()).isEqualTo(2);\n+        assertThat(available.get(AclClass.TOOL).get(0).getMask()).isEqualTo(READ_PERMISSION);\n     }\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testLoadingByGroupSidWorksWhenLoadForUser() {\n-        DockerRegistry registry = registryManager.create(\n-                ObjectCreatorUtils.createDockerRegistryVO(TEST_NAME, USER, USER));\n-        ToolGroup toolGroup = toolGroupManager.create(\n-                ObjectCreatorUtils.createToolGroup(TEST_NAME, registry.getId()));\n-        Tool tool = toolManager.create(\n-                ObjectCreatorUtils.createTool(TEST_NAME, toolGroup.getId()), false);\n-        Role role = roleManager.createRole(TEST_ROLE, false, false, null);\n-        grantPermission(tool.getId(), AclClass.TOOL, role.getName(),\n-                false, AclPermission.READ.getMask());\n-        roleManager.assignRole(role.getId(), Collections.singletonList(userManager.loadUserByName(USER2).getId()));\n-\n-        Folder folder = createFolder(TEST_NAME, null);\n-        RunConfiguration runConfiguration = createRunConfiguration(TEST_NAME, folder.getId());\n-        grantPermission(runConfiguration.getId(), AclClass.CONFIGURATION, DefaultRoles.ROLE_USER.getName(),\n-                false, AclPermission.READ.getMask());\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n-                .loadAvailable(new AclSid(USER2, true), null);\n-        Assert.assertEquals(2, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.TOOL).get(0).getMask(), AclPermission.READ.getMask());\n+    public void shouldLoadByGroupSidWhenLoadForUser() {\n+        final DockerRegistry registry = getDockerRegistry(ID, ANOTHER_SIMPLE_USER);\n+        final ToolGroup toolGroup = getToolGroup(ID, ANOTHER_SIMPLE_USER);\n+        final DockerRegistryList dockerRegistryList = getDockerRegistryList(ID, ANOTHER_SIMPLE_USER, registry);\n+        final Folder folder = getFolder(ANOTHER_SIMPLE_USER);\n+        final Tool tool = getTool(ID, ANOTHER_SIMPLE_USER);\n+        final RunConfiguration runConfiguration = getRunConfiguration(ID, ANOTHER_SIMPLE_USER);\n+        final PipelineUser pipelineUser = UserCreatorUtils.getPipelineUser();\n+        final ExtendedRole extendedRole = UserCreatorUtils.getExtendedRole();\n+        extendedRole.setUsers(Collections.singletonList(pipelineUser));\n+        toolGroup.setTools(Collections.singletonList(tool));\n+        registry.setGroups(Collections.singletonList(toolGroup));\n+        folder.setConfigurations(Collections.singletonList(runConfiguration));\n+        doReturn(dockerRegistryList).when(mockRegistryManager).loadAllRegistriesContent();\n+        doReturn(folder).when(mockFolderManager).loadTree();\n+        doReturn(extendedRole).when(mockRoleManager).assignRole(any(), any());\n+        mockUserContext();\n+        mockSid();\n+        initAclEntity(dockerRegistryList);\n+        initAclEntity(folder);\n+        initAclEntity(registry);\n+        initAclEntity(toolGroup);\n+        initAclEntity(tool, AclPermission.READ);\n+        initAclEntity(runConfiguration, AclPermission.READ);\n+\n+        final Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager.loadAvailable(\n+                new AclSid(SIMPLE_USER, true), null);\n+\n+        assertThat(available.size()).isEqualTo(2);\n+        assertThat(available.get(AclClass.TOOL).get(0).getMask()).isEqualTo(READ_PERMISSION);\n     }\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testInheritPermissions() {\n-        Folder folder = createFolder(TEST_NAME, null);\n-        createRunConfiguration(TEST_NAME, folder.getId());\n-\n-        grantPermission(folder.getId(), AclClass.FOLDER, USER2, true, AclPermission.READ.getMask());\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n-                .loadAvailable(new AclSid(USER2, true), null);\n-        Assert.assertEquals(2, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.CONFIGURATION).get(0).getMask(), AclPermission.READ.getMask());\n+    public void shouldInheritPermissions() {\n+        final Folder root = new Folder();\n+        final Folder folder = getFolder(ANOTHER_SIMPLE_USER);\n+        final RunConfiguration runConfiguration = getRunConfiguration(ID, ANOTHER_SIMPLE_USER);\n+        folder.setConfigurations(Collections.singletonList(runConfiguration));\n+        root.setChildFolders(Collections.singletonList(folder));\n+        doReturn(root).when(mockFolderManager).loadTree();\n+        mockDockerRegistryList();\n+        mockUserContext();\n+        mockSid();\n+        initAclEntity(folder, AclPermission.READ);\n+        initAclEntity(runConfiguration);\n+\n+        final Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n+                .loadAvailable(new AclSid(SIMPLE_USER, true), null);\n+\n+        assertThat(available.size()).isEqualTo(2);\n+        assertThat(available.get(AclClass.CONFIGURATION).get(0).getMask()).isEqualTo(READ_PERMISSION);\n     }\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testUseItsOwnPermissions() {\n-        Folder folder = createFolder(TEST_NAME, null);\n-        RunConfiguration runConfiguration = createRunConfiguration(TEST_NAME, folder.getId());\n-\n-        grantPermission(folder.getId(), AclClass.FOLDER, USER2, true, AclPermission.READ.getMask());\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n-                .loadAvailable(new AclSid(USER2, true), null);\n-        Assert.assertEquals(2, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.CONFIGURATION).get(0).getMask(), AclPermission.READ.getMask());\n-\n-\n-        grantPermission(runConfiguration.getId(), AclClass.CONFIGURATION, USER2, true,\n-                ALL_PERMISSIONS);\n-\n-        available = hierarchicalEntityManager.loadAvailable(new AclSid(USER2, true), null);\n-        Assert.assertEquals(2, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.CONFIGURATION).get(0).getMask(), ALL_PERMISSIONS_SIMPLE);\n+    public void shouldUseItsOwnPermissions() {\n+        final Folder root = new Folder();\n+        final Folder folder = getFolder(ANOTHER_SIMPLE_USER);\n+        final RunConfiguration runConfiguration = getRunConfiguration(ID, ANOTHER_SIMPLE_USER);\n+        folder.setConfigurations(Collections.singletonList(runConfiguration));\n+        root.setChildFolders(Collections.singletonList(folder));\n+        doReturn(root).when(mockFolderManager).loadTree();\n+        mockDockerRegistryList();\n+        mockUserContext();\n+        mockSid();\n+        initAclEntity(folder, AclPermission.READ);\n+        initAclEntity(runConfiguration, AclPermission.WRITE);\n+\n+        final Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n+                .loadAvailable(new AclSid(SIMPLE_USER, true), null);\n+\n+        assertThat(available.size()).isEqualTo(2);\n+        assertThat(available.get(AclClass.CONFIGURATION).get(0).getMask())\n+                .isEqualTo(READ_PERMISSION + WRITE_PERMISSION);\n     }\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testUseItOwnPermissionsIfParentRestricted() {\n-        Folder folder = createFolder(TEST_NAME, null);\n-        RunConfiguration runConfiguration = createRunConfiguration(TEST_NAME, folder.getId());\n-\n-        grantPermission(folder.getId(), AclClass.FOLDER, USER2, true, AclPermission.NO_READ.getMask());\n-        grantPermission(runConfiguration.getId(), AclClass.CONFIGURATION, USER2, true,\n-                ALL_PERMISSIONS);\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n-                .loadAvailable(new AclSid(USER2, true), null);\n-        //folder should be filtered because it forbidden\n-        Assert.assertEquals(1, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.CONFIGURATION).get(0).getMask(), ALL_PERMISSIONS_SIMPLE);\n+    public void shouldUseItOwnPermissionsIfParentRestricted() {\n+        final Folder root = new Folder();\n+        final Folder folder = getFolder(ANOTHER_SIMPLE_USER);\n+        final RunConfiguration runConfiguration = getRunConfiguration(ID, ANOTHER_SIMPLE_USER);\n+        folder.setConfigurations(Collections.singletonList(runConfiguration));\n+        root.setChildFolders(Collections.singletonList(folder));\n+        doReturn(root).when(mockFolderManager).loadTree();\n+        mockDockerRegistryList();\n+        mockUserContext();\n+        mockSid();\n+        initAclEntity(folder);\n+        initAclEntity(runConfiguration, AclPermission.READ);\n+\n+        final Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n+                .loadAvailable(new AclSid(SIMPLE_USER, true), null);\n+\n+        assertThat(available.size()).isEqualTo(1);\n+        assertThat(available.get(AclClass.CONFIGURATION).get(0).getMask()).isEqualTo(READ_PERMISSION);\n     }\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testUseItOwnRestrictedPermissionsIfParentAllowed() {\n-        Folder folder = createFolder(TEST_NAME, null);\n-        RunConfiguration runConfiguration = createRunConfiguration(TEST_NAME, folder.getId());\n-\n-        grantPermission(folder.getId(), AclClass.FOLDER, USER2, true, ALL_PERMISSIONS);\n-        grantPermission(runConfiguration.getId(), AclClass.CONFIGURATION, USER2, true,\n-                AclPermission.NO_READ.getMask());\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n-                .loadAvailable(new AclSid(USER2, true), null);\n-        //folder should be filtered because it forbidden\n-        Assert.assertEquals(1, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.FOLDER).get(0).getMask(), ALL_PERMISSIONS_SIMPLE);\n+    public void shouldUseItOwnRestrictedPermissionsIfParentAllowed() {\n+        final Folder root = new Folder();\n+        final Folder folder = getFolder(ANOTHER_SIMPLE_USER);\n+        final RunConfiguration runConfiguration = getRunConfiguration(ID, ANOTHER_SIMPLE_USER);\n+        folder.setConfigurations(Collections.singletonList(runConfiguration));\n+        root.setChildFolders(Collections.singletonList(folder));\n+        doReturn(root).when(mockFolderManager).loadTree();\n+        mockDockerRegistryList();\n+        mockUserContext();\n+        mockSid();\n+        initAclEntity(folder, AclPermission.READ);\n+        initAclEntity(runConfiguration, AclPermission.NO_READ);\n+\n+        final Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n+                .loadAvailable(new AclSid(SIMPLE_USER, true), null);\n+\n+        assertThat(available.size()).isEqualTo(1);\n+        assertThat(available.get(AclClass.FOLDER).get(0).getMask()).isEqualTo(READ_PERMISSION);\n     }\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testUseItOwnPermissionsIfParentRestrictedByInheritance() {\n-        Folder folder = createFolder(TEST_NAME, null);\n-        Folder subFolder = createFolder(TEST_NAME, folder.getId());\n-        RunConfiguration runConfiguration = createRunConfiguration(TEST_NAME, subFolder.getId());\n-\n-        grantPermission(folder.getId(), AclClass.FOLDER, USER2, true, AclPermission.NO_READ.getMask());\n-        grantPermission(runConfiguration.getId(), AclClass.CONFIGURATION, USER2, true,\n-                ALL_PERMISSIONS);\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n-                .loadAvailable(new AclSid(USER2, true), null);\n-        //folder should be filtered because it forbidden\n-        Assert.assertEquals(1, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.CONFIGURATION).get(0).getMask(), ALL_PERMISSIONS_SIMPLE);\n+    public void shouldUseItOwnPermissionsIfParentRestrictedByInheritance() {", "originalCommit": "7b73b61dd208cacb29faf849397e075cf12de8b7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTA3MzQzNw==", "url": "https://github.com/epam/cloud-pipeline/pull/1702#discussion_r571073437", "bodyText": "Let's grant permissions for role ROLE_USER (as it done in shouldLoadByRoleSidWhenLoadForUser test)", "author": "ekazachkova", "createdAt": "2021-02-05T16:02:12Z", "path": "api/src/test/java/com/epam/pipeline/manager/HierarchicalEntityManagerTest.java", "diffHunk": "@@ -16,348 +16,312 @@\n \n package com.epam.pipeline.manager;\n \n-import com.epam.pipeline.app.TestApplicationWithAclSecurity;\n-import com.epam.pipeline.controller.vo.PermissionGrantVO;\n-import com.epam.pipeline.controller.vo.PipelineUserVO;\n-import com.epam.pipeline.controller.vo.configuration.RunConfigurationVO;\n import com.epam.pipeline.entity.AbstractSecuredEntity;\n-import com.epam.pipeline.entity.configuration.PipelineConfiguration;\n import com.epam.pipeline.entity.configuration.RunConfiguration;\n-import com.epam.pipeline.entity.configuration.RunConfigurationEntry;\n+import com.epam.pipeline.entity.docker.DockerRegistryList;\n import com.epam.pipeline.entity.pipeline.DockerRegistry;\n import com.epam.pipeline.entity.pipeline.Folder;\n import com.epam.pipeline.entity.pipeline.Tool;\n import com.epam.pipeline.entity.pipeline.ToolGroup;\n import com.epam.pipeline.entity.security.acl.AclClass;\n import com.epam.pipeline.entity.security.acl.AclSid;\n import com.epam.pipeline.entity.user.DefaultRoles;\n-import com.epam.pipeline.entity.user.Role;\n-import com.epam.pipeline.manager.cluster.KubernetesManager;\n-import com.epam.pipeline.manager.configuration.RunConfigurationManager;\n-import com.epam.pipeline.manager.docker.DockerClient;\n-import com.epam.pipeline.manager.docker.DockerClientFactory;\n import com.epam.pipeline.manager.docker.DockerRegistryManager;\n-import com.epam.pipeline.manager.pipeline.FolderCrudManager;\n-import com.epam.pipeline.manager.pipeline.ToolGroupManager;\n-import com.epam.pipeline.manager.pipeline.ToolManager;\n-import com.epam.pipeline.manager.security.GrantPermissionManager;\n-import com.epam.pipeline.manager.user.RoleManager;\n+import com.epam.pipeline.manager.pipeline.FolderManager;\n import com.epam.pipeline.manager.user.UserManager;\n+import com.epam.pipeline.security.UserContext;\n import com.epam.pipeline.security.acl.AclPermission;\n-import org.junit.Assert;\n-import org.junit.Before;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n import org.junit.Test;\n-import org.mockito.Mockito;\n import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.boot.test.mock.mockito.MockBean;\n import org.springframework.security.test.context.support.WithMockUser;\n-import org.springframework.test.annotation.DirtiesContext;\n-import org.springframework.test.context.ContextConfiguration;\n-import org.springframework.transaction.annotation.Transactional;\n \n import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n \n-\n-@DirtiesContext\n-@Transactional\n-@ContextConfiguration(classes = TestApplicationWithAclSecurity.class)\n-public class HierarchicalEntityManagerTest extends AbstractManagerTest {\n-\n-    private static final String USER = \"OWNER\";\n-    private static final String USER2 = \"VIEWER\";\n-\n-    private static final String TEST_NAME = \"name\";\n-    private static final int ALL_PERMISSIONS = AclPermission.READ.getMask()\n-                                                | AclPermission.WRITE.getMask()\n-                                                | AclPermission.EXECUTE.getMask();\n-    private static final int ALL_PERMISSIONS_SIMPLE = AclPermission.getBasicPermissions().stream()\n-            .map(AclPermission::getSimpleMask).reduce((m, m2) -> m | m2).get();\n-    private static final String TEST_ROLE = \"TEST_ROLE\";\n-\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_2;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.READ_PERMISSION;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.WRITE_PERMISSION;\n+import static com.epam.pipeline.test.creator.configuration.ConfigurationCreatorUtils.getRunConfiguration;\n+import static com.epam.pipeline.test.creator.docker.DockerCreatorUtils.getDockerRegistry;\n+import static com.epam.pipeline.test.creator.docker.DockerCreatorUtils.getDockerRegistryList;\n+import static com.epam.pipeline.test.creator.docker.DockerCreatorUtils.getTool;\n+import static com.epam.pipeline.test.creator.docker.DockerCreatorUtils.getToolGroup;\n+import static com.epam.pipeline.test.creator.folder.FolderCreatorUtils.getFolder;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Mockito.doReturn;\n+\n+public class HierarchicalEntityManagerTest extends AbstractAclTest {\n+\n+    private final DockerRegistryList dockerRegistryList = getDockerRegistryList();\n+    private final UserContext userContext = new UserContext(ID, SIMPLE_USER);\n \n     @Autowired\n     private HierarchicalEntityManager hierarchicalEntityManager;\n \n     @Autowired\n-    private RunConfigurationManager configurationManager;\n-\n-    @Autowired\n-    private DockerRegistryManager registryManager;\n-\n-    @Autowired\n-    private ToolGroupManager toolGroupManager;\n+    private DockerRegistryManager mockRegistryManager;\n \n     @Autowired\n-    private ToolManager toolManager;\n+    private UserManager mockUserManager;\n \n     @Autowired\n-    private UserManager userManager;\n-\n-    @Autowired\n-    private RoleManager roleManager;\n-\n-    @Autowired\n-    private GrantPermissionManager permissionManager;\n-\n-    @Autowired\n-    private FolderCrudManager folderCrudManager;\n-\n-    @MockBean\n-    private DockerClientFactory dockerClientFactory;\n-\n-    @MockBean\n-    private KubernetesManager kubernetesManager;\n-\n-    private DockerClient client = Mockito.mock(DockerClient.class);\n-\n-    @Before\n-    public void setUp() {\n-        PipelineUserVO userVO = new PipelineUserVO();\n-        userVO.setRoleIds(Collections.singletonList(DefaultRoles.ROLE_USER.getId()));\n-        userVO.setUserName(USER);\n-        userManager.createUser(userVO);\n-\n-        userVO.setUserName(USER2);\n-        userManager.createUser(userVO);\n-        Mockito.when(kubernetesManager.createDockerRegistrySecret(Mockito.any())).thenReturn(\"\");\n-        Mockito.when(dockerClientFactory.getDockerClient(Mockito.any(), Mockito.any())).thenReturn(client);\n-    }\n+    private FolderManager mockFolderManager;\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testToolInheritPermissionsFromRegistry() {\n-        DockerRegistry registry = registryManager.create(\n-                ObjectCreatorUtils.createDockerRegistryVO(TEST_NAME, USER, USER));\n-        ToolGroup toolGroup = toolGroupManager.create(\n-                ObjectCreatorUtils.createToolGroup(TEST_NAME, registry.getId()));\n-        toolManager.create(ObjectCreatorUtils.createTool(TEST_NAME, toolGroup.getId()), false);\n-        grantPermission(registry.getId(), AclClass.DOCKER_REGISTRY, USER2, true, AclPermission.READ.getMask());\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n-                .loadAvailable(new AclSid(USER2, true), null);\n-        Assert.assertEquals(3, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.TOOL).get(0).getMask(), AclPermission.READ.getMask());\n+    @WithMockUser\n+    public void shouldInheritPermissionsFromRegistry() {\n+        final DockerRegistry registry = getDockerRegistry(ID, ANOTHER_SIMPLE_USER);\n+        final Tool tool = getTool(ID, ANOTHER_SIMPLE_USER);\n+        final ToolGroup toolGroup = getToolGroup(ID, ANOTHER_SIMPLE_USER);\n+        final DockerRegistryList dockerRegistryList = getDockerRegistryList(ID, ANOTHER_SIMPLE_USER, registry);\n+        final Folder folder = getFolder(ANOTHER_SIMPLE_USER);\n+        toolGroup.setTools(Collections.singletonList(tool));\n+        registry.setGroups(Collections.singletonList(toolGroup));\n+        doReturn(dockerRegistryList).when(mockRegistryManager).loadAllRegistriesContent();\n+        doReturn(folder).when(mockFolderManager).loadTree();\n+        mockUserContext();\n+        initAclEntity(dockerRegistryList);\n+        initAclEntity(registry, AclPermission.READ);\n+        initAclEntity(toolGroup);\n+        initAclEntity(tool);\n+\n+        final Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n+                .loadAvailable(new AclSid(SIMPLE_USER, true), null);\n+\n+        assertThat(available.size()).isEqualTo(3);\n+        assertThat(available.get(AclClass.TOOL).get(0).getMask()).isEqualTo(READ_PERMISSION);\n     }\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testIfOnlyToolAllowedGroupAndRegistryDontPresetInResult() {\n-        DockerRegistry registry = registryManager.create(\n-                ObjectCreatorUtils.createDockerRegistryVO(TEST_NAME, USER, USER));\n-        ToolGroup toolGroup = toolGroupManager.create(\n-                ObjectCreatorUtils.createToolGroup(TEST_NAME, registry.getId()));\n-        Tool tool = toolManager.create(\n-                ObjectCreatorUtils.createTool(TEST_NAME, toolGroup.getId()), false);\n-        grantPermission(tool.getId(), AclClass.TOOL, USER2, true, AclPermission.READ.getMask());\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n-                .loadAvailable(new AclSid(USER2, true), null);\n-        Assert.assertEquals(1, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.TOOL).get(0).getMask(), AclPermission.READ.getMask());\n+    @WithMockUser\n+    public void shouldLoadOnlyEntityWithPermission() {\n+        final DockerRegistry registry = getDockerRegistry(ID, ANOTHER_SIMPLE_USER);\n+        final Tool tool = getTool(ID, ANOTHER_SIMPLE_USER);\n+        final ToolGroup toolGroup = getToolGroup(ID, ANOTHER_SIMPLE_USER);\n+        final DockerRegistryList dockerRegistryList = getDockerRegistryList(ID, ANOTHER_SIMPLE_USER, registry);\n+        final Folder folder = getFolder(ANOTHER_SIMPLE_USER);\n+        toolGroup.setTools(Collections.singletonList(tool));\n+        registry.setGroups(Collections.singletonList(toolGroup));\n+        doReturn(dockerRegistryList).when(mockRegistryManager).loadAllRegistriesContent();\n+        doReturn(folder).when(mockFolderManager).loadTree();\n+        mockUserContext();\n+        initAclEntity(dockerRegistryList);\n+        initAclEntity(registry);\n+        initAclEntity(toolGroup);\n+        initAclEntity(tool, AclPermission.READ);\n+\n+        final Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n+                .loadAvailable(new AclSid(SIMPLE_USER, true), null);\n+\n+        assertThat(available.size()).isEqualTo(1);\n+        assertThat(available.get(AclClass.TOOL).get(0).getMask()).isEqualTo(READ_PERMISSION);\n     }\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testLoadingByRoleSidWorks() {\n-        DockerRegistry registry = registryManager.create(\n-                ObjectCreatorUtils.createDockerRegistryVO(TEST_NAME, USER, USER));\n-        ToolGroup toolGroup = toolGroupManager.create(\n-                ObjectCreatorUtils.createToolGroup(TEST_NAME, registry.getId()));\n-        Tool tool = toolManager.create(\n-                ObjectCreatorUtils.createTool(TEST_NAME, toolGroup.getId()), false);\n-        grantPermission(tool.getId(), AclClass.TOOL, DefaultRoles.ROLE_USER.getName(),\n-                false, AclPermission.READ.getMask());\n-\n-        Folder folder = createFolder(TEST_NAME, null);\n-        RunConfiguration runConfiguration = createRunConfiguration(TEST_NAME, folder.getId());\n-        grantPermission(runConfiguration.getId(), AclClass.CONFIGURATION, DefaultRoles.ROLE_USER.getName(),\n-                false, AclPermission.READ.getMask());\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager.loadAvailable(\n-                new AclSid(DefaultRoles.ROLE_USER.getName(), false), null);\n-        Assert.assertEquals(2, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.TOOL).get(0).getMask(), AclPermission.READ.getMask());\n+    @WithMockUser\n+    public void shouldLoadByRoleSid() {\n+        final DockerRegistry registry = getDockerRegistry(ID, ANOTHER_SIMPLE_USER);\n+        final Tool tool = getTool(ID, ANOTHER_SIMPLE_USER);\n+        final ToolGroup toolGroup = getToolGroup(ID, ANOTHER_SIMPLE_USER);\n+        final DockerRegistryList dockerRegistryList = getDockerRegistryList(ID, ANOTHER_SIMPLE_USER, registry);\n+        final Folder folder = getFolder(ANOTHER_SIMPLE_USER);\n+        final RunConfiguration runConfiguration = getRunConfiguration(ID, ANOTHER_SIMPLE_USER);\n+        toolGroup.setTools(Collections.singletonList(tool));\n+        registry.setGroups(Collections.singletonList(toolGroup));\n+        folder.setConfigurations(Collections.singletonList(runConfiguration));\n+        doReturn(dockerRegistryList).when(mockRegistryManager).loadAllRegistriesContent();\n+        doReturn(folder).when(mockFolderManager).loadTree();\n+        mockUserContext();\n+        initAclEntity(dockerRegistryList);\n+        initAclEntity(folder);\n+        initAclEntity(registry);\n+        initAclEntity(toolGroup);\n+        initAclEntity(tool,", "originalCommit": "9bd514ff5153f2e8e46cbfbcefe959dc8c9ec773", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTA3Mzk4MQ==", "url": "https://github.com/epam/cloud-pipeline/pull/1702#discussion_r571073981", "bodyText": "Could you please fix principal?", "author": "ekazachkova", "createdAt": "2021-02-05T16:03:01Z", "path": "api/src/test/java/com/epam/pipeline/manager/HierarchicalEntityManagerTest.java", "diffHunk": "@@ -16,348 +16,312 @@\n \n package com.epam.pipeline.manager;\n \n-import com.epam.pipeline.app.TestApplicationWithAclSecurity;\n-import com.epam.pipeline.controller.vo.PermissionGrantVO;\n-import com.epam.pipeline.controller.vo.PipelineUserVO;\n-import com.epam.pipeline.controller.vo.configuration.RunConfigurationVO;\n import com.epam.pipeline.entity.AbstractSecuredEntity;\n-import com.epam.pipeline.entity.configuration.PipelineConfiguration;\n import com.epam.pipeline.entity.configuration.RunConfiguration;\n-import com.epam.pipeline.entity.configuration.RunConfigurationEntry;\n+import com.epam.pipeline.entity.docker.DockerRegistryList;\n import com.epam.pipeline.entity.pipeline.DockerRegistry;\n import com.epam.pipeline.entity.pipeline.Folder;\n import com.epam.pipeline.entity.pipeline.Tool;\n import com.epam.pipeline.entity.pipeline.ToolGroup;\n import com.epam.pipeline.entity.security.acl.AclClass;\n import com.epam.pipeline.entity.security.acl.AclSid;\n import com.epam.pipeline.entity.user.DefaultRoles;\n-import com.epam.pipeline.entity.user.Role;\n-import com.epam.pipeline.manager.cluster.KubernetesManager;\n-import com.epam.pipeline.manager.configuration.RunConfigurationManager;\n-import com.epam.pipeline.manager.docker.DockerClient;\n-import com.epam.pipeline.manager.docker.DockerClientFactory;\n import com.epam.pipeline.manager.docker.DockerRegistryManager;\n-import com.epam.pipeline.manager.pipeline.FolderCrudManager;\n-import com.epam.pipeline.manager.pipeline.ToolGroupManager;\n-import com.epam.pipeline.manager.pipeline.ToolManager;\n-import com.epam.pipeline.manager.security.GrantPermissionManager;\n-import com.epam.pipeline.manager.user.RoleManager;\n+import com.epam.pipeline.manager.pipeline.FolderManager;\n import com.epam.pipeline.manager.user.UserManager;\n+import com.epam.pipeline.security.UserContext;\n import com.epam.pipeline.security.acl.AclPermission;\n-import org.junit.Assert;\n-import org.junit.Before;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n import org.junit.Test;\n-import org.mockito.Mockito;\n import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.boot.test.mock.mockito.MockBean;\n import org.springframework.security.test.context.support.WithMockUser;\n-import org.springframework.test.annotation.DirtiesContext;\n-import org.springframework.test.context.ContextConfiguration;\n-import org.springframework.transaction.annotation.Transactional;\n \n import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n \n-\n-@DirtiesContext\n-@Transactional\n-@ContextConfiguration(classes = TestApplicationWithAclSecurity.class)\n-public class HierarchicalEntityManagerTest extends AbstractManagerTest {\n-\n-    private static final String USER = \"OWNER\";\n-    private static final String USER2 = \"VIEWER\";\n-\n-    private static final String TEST_NAME = \"name\";\n-    private static final int ALL_PERMISSIONS = AclPermission.READ.getMask()\n-                                                | AclPermission.WRITE.getMask()\n-                                                | AclPermission.EXECUTE.getMask();\n-    private static final int ALL_PERMISSIONS_SIMPLE = AclPermission.getBasicPermissions().stream()\n-            .map(AclPermission::getSimpleMask).reduce((m, m2) -> m | m2).get();\n-    private static final String TEST_ROLE = \"TEST_ROLE\";\n-\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_2;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.READ_PERMISSION;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.WRITE_PERMISSION;\n+import static com.epam.pipeline.test.creator.configuration.ConfigurationCreatorUtils.getRunConfiguration;\n+import static com.epam.pipeline.test.creator.docker.DockerCreatorUtils.getDockerRegistry;\n+import static com.epam.pipeline.test.creator.docker.DockerCreatorUtils.getDockerRegistryList;\n+import static com.epam.pipeline.test.creator.docker.DockerCreatorUtils.getTool;\n+import static com.epam.pipeline.test.creator.docker.DockerCreatorUtils.getToolGroup;\n+import static com.epam.pipeline.test.creator.folder.FolderCreatorUtils.getFolder;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Mockito.doReturn;\n+\n+public class HierarchicalEntityManagerTest extends AbstractAclTest {\n+\n+    private final DockerRegistryList dockerRegistryList = getDockerRegistryList();\n+    private final UserContext userContext = new UserContext(ID, SIMPLE_USER);\n \n     @Autowired\n     private HierarchicalEntityManager hierarchicalEntityManager;\n \n     @Autowired\n-    private RunConfigurationManager configurationManager;\n-\n-    @Autowired\n-    private DockerRegistryManager registryManager;\n-\n-    @Autowired\n-    private ToolGroupManager toolGroupManager;\n+    private DockerRegistryManager mockRegistryManager;\n \n     @Autowired\n-    private ToolManager toolManager;\n+    private UserManager mockUserManager;\n \n     @Autowired\n-    private UserManager userManager;\n-\n-    @Autowired\n-    private RoleManager roleManager;\n-\n-    @Autowired\n-    private GrantPermissionManager permissionManager;\n-\n-    @Autowired\n-    private FolderCrudManager folderCrudManager;\n-\n-    @MockBean\n-    private DockerClientFactory dockerClientFactory;\n-\n-    @MockBean\n-    private KubernetesManager kubernetesManager;\n-\n-    private DockerClient client = Mockito.mock(DockerClient.class);\n-\n-    @Before\n-    public void setUp() {\n-        PipelineUserVO userVO = new PipelineUserVO();\n-        userVO.setRoleIds(Collections.singletonList(DefaultRoles.ROLE_USER.getId()));\n-        userVO.setUserName(USER);\n-        userManager.createUser(userVO);\n-\n-        userVO.setUserName(USER2);\n-        userManager.createUser(userVO);\n-        Mockito.when(kubernetesManager.createDockerRegistrySecret(Mockito.any())).thenReturn(\"\");\n-        Mockito.when(dockerClientFactory.getDockerClient(Mockito.any(), Mockito.any())).thenReturn(client);\n-    }\n+    private FolderManager mockFolderManager;\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testToolInheritPermissionsFromRegistry() {\n-        DockerRegistry registry = registryManager.create(\n-                ObjectCreatorUtils.createDockerRegistryVO(TEST_NAME, USER, USER));\n-        ToolGroup toolGroup = toolGroupManager.create(\n-                ObjectCreatorUtils.createToolGroup(TEST_NAME, registry.getId()));\n-        toolManager.create(ObjectCreatorUtils.createTool(TEST_NAME, toolGroup.getId()), false);\n-        grantPermission(registry.getId(), AclClass.DOCKER_REGISTRY, USER2, true, AclPermission.READ.getMask());\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n-                .loadAvailable(new AclSid(USER2, true), null);\n-        Assert.assertEquals(3, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.TOOL).get(0).getMask(), AclPermission.READ.getMask());\n+    @WithMockUser\n+    public void shouldInheritPermissionsFromRegistry() {\n+        final DockerRegistry registry = getDockerRegistry(ID, ANOTHER_SIMPLE_USER);\n+        final Tool tool = getTool(ID, ANOTHER_SIMPLE_USER);\n+        final ToolGroup toolGroup = getToolGroup(ID, ANOTHER_SIMPLE_USER);\n+        final DockerRegistryList dockerRegistryList = getDockerRegistryList(ID, ANOTHER_SIMPLE_USER, registry);\n+        final Folder folder = getFolder(ANOTHER_SIMPLE_USER);\n+        toolGroup.setTools(Collections.singletonList(tool));\n+        registry.setGroups(Collections.singletonList(toolGroup));\n+        doReturn(dockerRegistryList).when(mockRegistryManager).loadAllRegistriesContent();\n+        doReturn(folder).when(mockFolderManager).loadTree();\n+        mockUserContext();\n+        initAclEntity(dockerRegistryList);\n+        initAclEntity(registry, AclPermission.READ);\n+        initAclEntity(toolGroup);\n+        initAclEntity(tool);\n+\n+        final Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n+                .loadAvailable(new AclSid(SIMPLE_USER, true), null);\n+\n+        assertThat(available.size()).isEqualTo(3);\n+        assertThat(available.get(AclClass.TOOL).get(0).getMask()).isEqualTo(READ_PERMISSION);\n     }\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testIfOnlyToolAllowedGroupAndRegistryDontPresetInResult() {\n-        DockerRegistry registry = registryManager.create(\n-                ObjectCreatorUtils.createDockerRegistryVO(TEST_NAME, USER, USER));\n-        ToolGroup toolGroup = toolGroupManager.create(\n-                ObjectCreatorUtils.createToolGroup(TEST_NAME, registry.getId()));\n-        Tool tool = toolManager.create(\n-                ObjectCreatorUtils.createTool(TEST_NAME, toolGroup.getId()), false);\n-        grantPermission(tool.getId(), AclClass.TOOL, USER2, true, AclPermission.READ.getMask());\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n-                .loadAvailable(new AclSid(USER2, true), null);\n-        Assert.assertEquals(1, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.TOOL).get(0).getMask(), AclPermission.READ.getMask());\n+    @WithMockUser\n+    public void shouldLoadOnlyEntityWithPermission() {\n+        final DockerRegistry registry = getDockerRegistry(ID, ANOTHER_SIMPLE_USER);\n+        final Tool tool = getTool(ID, ANOTHER_SIMPLE_USER);\n+        final ToolGroup toolGroup = getToolGroup(ID, ANOTHER_SIMPLE_USER);\n+        final DockerRegistryList dockerRegistryList = getDockerRegistryList(ID, ANOTHER_SIMPLE_USER, registry);\n+        final Folder folder = getFolder(ANOTHER_SIMPLE_USER);\n+        toolGroup.setTools(Collections.singletonList(tool));\n+        registry.setGroups(Collections.singletonList(toolGroup));\n+        doReturn(dockerRegistryList).when(mockRegistryManager).loadAllRegistriesContent();\n+        doReturn(folder).when(mockFolderManager).loadTree();\n+        mockUserContext();\n+        initAclEntity(dockerRegistryList);\n+        initAclEntity(registry);\n+        initAclEntity(toolGroup);\n+        initAclEntity(tool, AclPermission.READ);\n+\n+        final Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n+                .loadAvailable(new AclSid(SIMPLE_USER, true), null);\n+\n+        assertThat(available.size()).isEqualTo(1);\n+        assertThat(available.get(AclClass.TOOL).get(0).getMask()).isEqualTo(READ_PERMISSION);\n     }\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testLoadingByRoleSidWorks() {\n-        DockerRegistry registry = registryManager.create(\n-                ObjectCreatorUtils.createDockerRegistryVO(TEST_NAME, USER, USER));\n-        ToolGroup toolGroup = toolGroupManager.create(\n-                ObjectCreatorUtils.createToolGroup(TEST_NAME, registry.getId()));\n-        Tool tool = toolManager.create(\n-                ObjectCreatorUtils.createTool(TEST_NAME, toolGroup.getId()), false);\n-        grantPermission(tool.getId(), AclClass.TOOL, DefaultRoles.ROLE_USER.getName(),\n-                false, AclPermission.READ.getMask());\n-\n-        Folder folder = createFolder(TEST_NAME, null);\n-        RunConfiguration runConfiguration = createRunConfiguration(TEST_NAME, folder.getId());\n-        grantPermission(runConfiguration.getId(), AclClass.CONFIGURATION, DefaultRoles.ROLE_USER.getName(),\n-                false, AclPermission.READ.getMask());\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager.loadAvailable(\n-                new AclSid(DefaultRoles.ROLE_USER.getName(), false), null);\n-        Assert.assertEquals(2, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.TOOL).get(0).getMask(), AclPermission.READ.getMask());\n+    @WithMockUser\n+    public void shouldLoadByRoleSid() {\n+        final DockerRegistry registry = getDockerRegistry(ID, ANOTHER_SIMPLE_USER);\n+        final Tool tool = getTool(ID, ANOTHER_SIMPLE_USER);\n+        final ToolGroup toolGroup = getToolGroup(ID, ANOTHER_SIMPLE_USER);\n+        final DockerRegistryList dockerRegistryList = getDockerRegistryList(ID, ANOTHER_SIMPLE_USER, registry);\n+        final Folder folder = getFolder(ANOTHER_SIMPLE_USER);\n+        final RunConfiguration runConfiguration = getRunConfiguration(ID, ANOTHER_SIMPLE_USER);\n+        toolGroup.setTools(Collections.singletonList(tool));\n+        registry.setGroups(Collections.singletonList(toolGroup));\n+        folder.setConfigurations(Collections.singletonList(runConfiguration));\n+        doReturn(dockerRegistryList).when(mockRegistryManager).loadAllRegistriesContent();\n+        doReturn(folder).when(mockFolderManager).loadTree();\n+        mockUserContext();\n+        initAclEntity(dockerRegistryList);\n+        initAclEntity(folder);\n+        initAclEntity(registry);\n+        initAclEntity(toolGroup);\n+        initAclEntity(tool,\n+                Collections.singletonList(new UserPermission(DefaultRoles.ROLE_USER.getName(), READ_PERMISSION)));\n+        initAclEntity(runConfiguration,\n+                Collections.singletonList(new UserPermission(DefaultRoles.ROLE_USER.getName(), READ_PERMISSION)));\n+\n+        final Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager.loadAvailable(\n+                new AclSid(DefaultRoles.ROLE_USER.getName(), true), null);", "originalCommit": "9bd514ff5153f2e8e46cbfbcefe959dc8c9ec773", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTA5MDMwOA==", "url": "https://github.com/epam/cloud-pipeline/pull/1702#discussion_r571090308", "bodyText": "Maybe it would be cleaner to move new AclSid(SIMPLE_USER, true) to test class constants:\nprivate static final AclSid USER_SID = new AclSid(SIMPLE_USER, true);\n\n?", "author": "ekazachkova", "createdAt": "2021-02-05T16:27:11Z", "path": "api/src/test/java/com/epam/pipeline/manager/HierarchicalEntityManagerTest.java", "diffHunk": "@@ -16,348 +16,312 @@\n \n package com.epam.pipeline.manager;\n \n-import com.epam.pipeline.app.TestApplicationWithAclSecurity;\n-import com.epam.pipeline.controller.vo.PermissionGrantVO;\n-import com.epam.pipeline.controller.vo.PipelineUserVO;\n-import com.epam.pipeline.controller.vo.configuration.RunConfigurationVO;\n import com.epam.pipeline.entity.AbstractSecuredEntity;\n-import com.epam.pipeline.entity.configuration.PipelineConfiguration;\n import com.epam.pipeline.entity.configuration.RunConfiguration;\n-import com.epam.pipeline.entity.configuration.RunConfigurationEntry;\n+import com.epam.pipeline.entity.docker.DockerRegistryList;\n import com.epam.pipeline.entity.pipeline.DockerRegistry;\n import com.epam.pipeline.entity.pipeline.Folder;\n import com.epam.pipeline.entity.pipeline.Tool;\n import com.epam.pipeline.entity.pipeline.ToolGroup;\n import com.epam.pipeline.entity.security.acl.AclClass;\n import com.epam.pipeline.entity.security.acl.AclSid;\n import com.epam.pipeline.entity.user.DefaultRoles;\n-import com.epam.pipeline.entity.user.Role;\n-import com.epam.pipeline.manager.cluster.KubernetesManager;\n-import com.epam.pipeline.manager.configuration.RunConfigurationManager;\n-import com.epam.pipeline.manager.docker.DockerClient;\n-import com.epam.pipeline.manager.docker.DockerClientFactory;\n import com.epam.pipeline.manager.docker.DockerRegistryManager;\n-import com.epam.pipeline.manager.pipeline.FolderCrudManager;\n-import com.epam.pipeline.manager.pipeline.ToolGroupManager;\n-import com.epam.pipeline.manager.pipeline.ToolManager;\n-import com.epam.pipeline.manager.security.GrantPermissionManager;\n-import com.epam.pipeline.manager.user.RoleManager;\n+import com.epam.pipeline.manager.pipeline.FolderManager;\n import com.epam.pipeline.manager.user.UserManager;\n+import com.epam.pipeline.security.UserContext;\n import com.epam.pipeline.security.acl.AclPermission;\n-import org.junit.Assert;\n-import org.junit.Before;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n import org.junit.Test;\n-import org.mockito.Mockito;\n import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.boot.test.mock.mockito.MockBean;\n import org.springframework.security.test.context.support.WithMockUser;\n-import org.springframework.test.annotation.DirtiesContext;\n-import org.springframework.test.context.ContextConfiguration;\n-import org.springframework.transaction.annotation.Transactional;\n \n import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n \n-\n-@DirtiesContext\n-@Transactional\n-@ContextConfiguration(classes = TestApplicationWithAclSecurity.class)\n-public class HierarchicalEntityManagerTest extends AbstractManagerTest {\n-\n-    private static final String USER = \"OWNER\";\n-    private static final String USER2 = \"VIEWER\";\n-\n-    private static final String TEST_NAME = \"name\";\n-    private static final int ALL_PERMISSIONS = AclPermission.READ.getMask()\n-                                                | AclPermission.WRITE.getMask()\n-                                                | AclPermission.EXECUTE.getMask();\n-    private static final int ALL_PERMISSIONS_SIMPLE = AclPermission.getBasicPermissions().stream()\n-            .map(AclPermission::getSimpleMask).reduce((m, m2) -> m | m2).get();\n-    private static final String TEST_ROLE = \"TEST_ROLE\";\n-\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_2;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.READ_PERMISSION;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.WRITE_PERMISSION;\n+import static com.epam.pipeline.test.creator.configuration.ConfigurationCreatorUtils.getRunConfiguration;\n+import static com.epam.pipeline.test.creator.docker.DockerCreatorUtils.getDockerRegistry;\n+import static com.epam.pipeline.test.creator.docker.DockerCreatorUtils.getDockerRegistryList;\n+import static com.epam.pipeline.test.creator.docker.DockerCreatorUtils.getTool;\n+import static com.epam.pipeline.test.creator.docker.DockerCreatorUtils.getToolGroup;\n+import static com.epam.pipeline.test.creator.folder.FolderCreatorUtils.getFolder;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Mockito.doReturn;\n+\n+public class HierarchicalEntityManagerTest extends AbstractAclTest {\n+\n+    private final DockerRegistryList dockerRegistryList = getDockerRegistryList();\n+    private final UserContext userContext = new UserContext(ID, SIMPLE_USER);\n \n     @Autowired\n     private HierarchicalEntityManager hierarchicalEntityManager;\n \n     @Autowired\n-    private RunConfigurationManager configurationManager;\n-\n-    @Autowired\n-    private DockerRegistryManager registryManager;\n-\n-    @Autowired\n-    private ToolGroupManager toolGroupManager;\n+    private DockerRegistryManager mockRegistryManager;\n \n     @Autowired\n-    private ToolManager toolManager;\n+    private UserManager mockUserManager;\n \n     @Autowired\n-    private UserManager userManager;\n-\n-    @Autowired\n-    private RoleManager roleManager;\n-\n-    @Autowired\n-    private GrantPermissionManager permissionManager;\n-\n-    @Autowired\n-    private FolderCrudManager folderCrudManager;\n-\n-    @MockBean\n-    private DockerClientFactory dockerClientFactory;\n-\n-    @MockBean\n-    private KubernetesManager kubernetesManager;\n-\n-    private DockerClient client = Mockito.mock(DockerClient.class);\n-\n-    @Before\n-    public void setUp() {\n-        PipelineUserVO userVO = new PipelineUserVO();\n-        userVO.setRoleIds(Collections.singletonList(DefaultRoles.ROLE_USER.getId()));\n-        userVO.setUserName(USER);\n-        userManager.createUser(userVO);\n-\n-        userVO.setUserName(USER2);\n-        userManager.createUser(userVO);\n-        Mockito.when(kubernetesManager.createDockerRegistrySecret(Mockito.any())).thenReturn(\"\");\n-        Mockito.when(dockerClientFactory.getDockerClient(Mockito.any(), Mockito.any())).thenReturn(client);\n-    }\n+    private FolderManager mockFolderManager;\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testToolInheritPermissionsFromRegistry() {\n-        DockerRegistry registry = registryManager.create(\n-                ObjectCreatorUtils.createDockerRegistryVO(TEST_NAME, USER, USER));\n-        ToolGroup toolGroup = toolGroupManager.create(\n-                ObjectCreatorUtils.createToolGroup(TEST_NAME, registry.getId()));\n-        toolManager.create(ObjectCreatorUtils.createTool(TEST_NAME, toolGroup.getId()), false);\n-        grantPermission(registry.getId(), AclClass.DOCKER_REGISTRY, USER2, true, AclPermission.READ.getMask());\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n-                .loadAvailable(new AclSid(USER2, true), null);\n-        Assert.assertEquals(3, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.TOOL).get(0).getMask(), AclPermission.READ.getMask());\n+    @WithMockUser\n+    public void shouldInheritPermissionsFromRegistry() {\n+        final DockerRegistry registry = getDockerRegistry(ID, ANOTHER_SIMPLE_USER);\n+        final Tool tool = getTool(ID, ANOTHER_SIMPLE_USER);\n+        final ToolGroup toolGroup = getToolGroup(ID, ANOTHER_SIMPLE_USER);\n+        final DockerRegistryList dockerRegistryList = getDockerRegistryList(ID, ANOTHER_SIMPLE_USER, registry);\n+        final Folder folder = getFolder(ANOTHER_SIMPLE_USER);\n+        toolGroup.setTools(Collections.singletonList(tool));\n+        registry.setGroups(Collections.singletonList(toolGroup));\n+        doReturn(dockerRegistryList).when(mockRegistryManager).loadAllRegistriesContent();\n+        doReturn(folder).when(mockFolderManager).loadTree();\n+        mockUserContext();\n+        initAclEntity(dockerRegistryList);\n+        initAclEntity(registry, AclPermission.READ);\n+        initAclEntity(toolGroup);\n+        initAclEntity(tool);\n+\n+        final Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n+                .loadAvailable(new AclSid(SIMPLE_USER, true), null);\n+\n+        assertThat(available.size()).isEqualTo(3);\n+        assertThat(available.get(AclClass.TOOL).get(0).getMask()).isEqualTo(READ_PERMISSION);\n     }\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testIfOnlyToolAllowedGroupAndRegistryDontPresetInResult() {\n-        DockerRegistry registry = registryManager.create(\n-                ObjectCreatorUtils.createDockerRegistryVO(TEST_NAME, USER, USER));\n-        ToolGroup toolGroup = toolGroupManager.create(\n-                ObjectCreatorUtils.createToolGroup(TEST_NAME, registry.getId()));\n-        Tool tool = toolManager.create(\n-                ObjectCreatorUtils.createTool(TEST_NAME, toolGroup.getId()), false);\n-        grantPermission(tool.getId(), AclClass.TOOL, USER2, true, AclPermission.READ.getMask());\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n-                .loadAvailable(new AclSid(USER2, true), null);\n-        Assert.assertEquals(1, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.TOOL).get(0).getMask(), AclPermission.READ.getMask());\n+    @WithMockUser\n+    public void shouldLoadOnlyEntityWithPermission() {\n+        final DockerRegistry registry = getDockerRegistry(ID, ANOTHER_SIMPLE_USER);\n+        final Tool tool = getTool(ID, ANOTHER_SIMPLE_USER);\n+        final ToolGroup toolGroup = getToolGroup(ID, ANOTHER_SIMPLE_USER);\n+        final DockerRegistryList dockerRegistryList = getDockerRegistryList(ID, ANOTHER_SIMPLE_USER, registry);\n+        final Folder folder = getFolder(ANOTHER_SIMPLE_USER);\n+        toolGroup.setTools(Collections.singletonList(tool));\n+        registry.setGroups(Collections.singletonList(toolGroup));\n+        doReturn(dockerRegistryList).when(mockRegistryManager).loadAllRegistriesContent();\n+        doReturn(folder).when(mockFolderManager).loadTree();\n+        mockUserContext();\n+        initAclEntity(dockerRegistryList);\n+        initAclEntity(registry);\n+        initAclEntity(toolGroup);\n+        initAclEntity(tool, AclPermission.READ);\n+\n+        final Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n+                .loadAvailable(new AclSid(SIMPLE_USER, true), null);\n+\n+        assertThat(available.size()).isEqualTo(1);\n+        assertThat(available.get(AclClass.TOOL).get(0).getMask()).isEqualTo(READ_PERMISSION);\n     }\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testLoadingByRoleSidWorks() {\n-        DockerRegistry registry = registryManager.create(\n-                ObjectCreatorUtils.createDockerRegistryVO(TEST_NAME, USER, USER));\n-        ToolGroup toolGroup = toolGroupManager.create(\n-                ObjectCreatorUtils.createToolGroup(TEST_NAME, registry.getId()));\n-        Tool tool = toolManager.create(\n-                ObjectCreatorUtils.createTool(TEST_NAME, toolGroup.getId()), false);\n-        grantPermission(tool.getId(), AclClass.TOOL, DefaultRoles.ROLE_USER.getName(),\n-                false, AclPermission.READ.getMask());\n-\n-        Folder folder = createFolder(TEST_NAME, null);\n-        RunConfiguration runConfiguration = createRunConfiguration(TEST_NAME, folder.getId());\n-        grantPermission(runConfiguration.getId(), AclClass.CONFIGURATION, DefaultRoles.ROLE_USER.getName(),\n-                false, AclPermission.READ.getMask());\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager.loadAvailable(\n-                new AclSid(DefaultRoles.ROLE_USER.getName(), false), null);\n-        Assert.assertEquals(2, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.TOOL).get(0).getMask(), AclPermission.READ.getMask());\n+    @WithMockUser\n+    public void shouldLoadByRoleSid() {\n+        final DockerRegistry registry = getDockerRegistry(ID, ANOTHER_SIMPLE_USER);\n+        final Tool tool = getTool(ID, ANOTHER_SIMPLE_USER);\n+        final ToolGroup toolGroup = getToolGroup(ID, ANOTHER_SIMPLE_USER);\n+        final DockerRegistryList dockerRegistryList = getDockerRegistryList(ID, ANOTHER_SIMPLE_USER, registry);\n+        final Folder folder = getFolder(ANOTHER_SIMPLE_USER);\n+        final RunConfiguration runConfiguration = getRunConfiguration(ID, ANOTHER_SIMPLE_USER);\n+        toolGroup.setTools(Collections.singletonList(tool));\n+        registry.setGroups(Collections.singletonList(toolGroup));\n+        folder.setConfigurations(Collections.singletonList(runConfiguration));\n+        doReturn(dockerRegistryList).when(mockRegistryManager).loadAllRegistriesContent();\n+        doReturn(folder).when(mockFolderManager).loadTree();\n+        mockUserContext();\n+        initAclEntity(dockerRegistryList);\n+        initAclEntity(folder);\n+        initAclEntity(registry);\n+        initAclEntity(toolGroup);\n+        initAclEntity(tool,\n+                Collections.singletonList(new UserPermission(DefaultRoles.ROLE_USER.getName(), READ_PERMISSION)));\n+        initAclEntity(runConfiguration,\n+                Collections.singletonList(new UserPermission(DefaultRoles.ROLE_USER.getName(), READ_PERMISSION)));\n+\n+        final Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager.loadAvailable(\n+                new AclSid(DefaultRoles.ROLE_USER.getName(), true), null);\n+\n+        assertThat(available.size()).isEqualTo(2);\n+        assertThat(available.get(AclClass.TOOL).get(0).getMask()).isEqualTo(READ_PERMISSION);\n     }\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testLoadingByRoleSidWorksWhenLoadForUser() {\n-        DockerRegistry registry = registryManager.create(\n-                ObjectCreatorUtils.createDockerRegistryVO(TEST_NAME, USER, USER));\n-        ToolGroup toolGroup = toolGroupManager.create(\n-                ObjectCreatorUtils.createToolGroup(TEST_NAME, registry.getId()));\n-        Tool tool = toolManager.create(\n-                ObjectCreatorUtils.createTool(TEST_NAME, toolGroup.getId()), false);\n-        grantPermission(tool.getId(), AclClass.TOOL, DefaultRoles.ROLE_USER.getName(),\n-                false, AclPermission.READ.getMask());\n-\n-        Folder folder = createFolder(TEST_NAME, null);\n-        RunConfiguration runConfiguration = createRunConfiguration(TEST_NAME, folder.getId());\n-        grantPermission(runConfiguration.getId(), AclClass.CONFIGURATION, DefaultRoles.ROLE_USER.getName(),\n-                false, AclPermission.READ.getMask());\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n-                .loadAvailable(new AclSid(USER2, true), null);\n-        Assert.assertEquals(2, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.TOOL).get(0).getMask(), AclPermission.READ.getMask());\n+    @WithMockUser\n+    public void shouldLoadByRoleSidWhenLoadForUser() {\n+        final DockerRegistry registry = getDockerRegistry(ID, ANOTHER_SIMPLE_USER);\n+        final ToolGroup toolGroup = getToolGroup(ID, ANOTHER_SIMPLE_USER);\n+        final DockerRegistryList dockerRegistryList = getDockerRegistryList(ID, ANOTHER_SIMPLE_USER, registry);\n+        final Folder folder = getFolder(ANOTHER_SIMPLE_USER);\n+        final Tool tool = getTool(ID, ANOTHER_SIMPLE_USER);\n+        final RunConfiguration runConfiguration = getRunConfiguration(ID, ANOTHER_SIMPLE_USER);\n+        toolGroup.setTools(Collections.singletonList(tool));\n+        registry.setGroups(Collections.singletonList(toolGroup));\n+        folder.setConfigurations(Collections.singletonList(runConfiguration));\n+        doReturn(dockerRegistryList).when(mockRegistryManager).loadAllRegistriesContent();\n+        doReturn(folder).when(mockFolderManager).loadTree();\n+        mockUserContextWithRole();\n+        initAclEntity(dockerRegistryList);\n+        initAclEntity(folder);\n+        initAclEntity(registry);\n+        initAclEntity(toolGroup);\n+        initAclEntity(tool, DefaultRoles.ROLE_USER.getName(), AclPermission.READ);\n+        initAclEntity(runConfiguration, DefaultRoles.ROLE_USER.getName(), AclPermission.READ);\n+\n+        final Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager.loadAvailable(\n+                new AclSid(SIMPLE_USER, true), null);\n+\n+        assertThat(available.size()).isEqualTo(2);\n+        assertThat(available.get(AclClass.TOOL).get(0).getMask()).isEqualTo(READ_PERMISSION);\n     }\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testLoadingByGroupSidWorksWhenLoadForUser() {\n-        DockerRegistry registry = registryManager.create(\n-                ObjectCreatorUtils.createDockerRegistryVO(TEST_NAME, USER, USER));\n-        ToolGroup toolGroup = toolGroupManager.create(\n-                ObjectCreatorUtils.createToolGroup(TEST_NAME, registry.getId()));\n-        Tool tool = toolManager.create(\n-                ObjectCreatorUtils.createTool(TEST_NAME, toolGroup.getId()), false);\n-        Role role = roleManager.createRole(TEST_ROLE, false, false, null);\n-        grantPermission(tool.getId(), AclClass.TOOL, role.getName(),\n-                false, AclPermission.READ.getMask());\n-        roleManager.assignRole(role.getId(), Collections.singletonList(userManager.loadUserByName(USER2).getId()));\n-\n-        Folder folder = createFolder(TEST_NAME, null);\n-        RunConfiguration runConfiguration = createRunConfiguration(TEST_NAME, folder.getId());\n-        grantPermission(runConfiguration.getId(), AclClass.CONFIGURATION, DefaultRoles.ROLE_USER.getName(),\n-                false, AclPermission.READ.getMask());\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n-                .loadAvailable(new AclSid(USER2, true), null);\n-        Assert.assertEquals(2, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.TOOL).get(0).getMask(), AclPermission.READ.getMask());\n+    @WithMockUser\n+    public void shouldInheritPermissions() {\n+        final Folder root = new Folder();\n+        final Folder folder = getFolder(ANOTHER_SIMPLE_USER);\n+        final RunConfiguration runConfiguration = getRunConfiguration(ID, ANOTHER_SIMPLE_USER);\n+        folder.setConfigurations(Collections.singletonList(runConfiguration));\n+        root.setChildFolders(Collections.singletonList(folder));\n+        doReturn(root).when(mockFolderManager).loadTree();\n+        mockDockerRegistryList();\n+        mockUserContext();\n+        initAclEntity(folder, AclPermission.READ);\n+        initAclEntity(runConfiguration);\n+\n+        final Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n+                .loadAvailable(new AclSid(SIMPLE_USER, true), null);\n+\n+        assertThat(available.size()).isEqualTo(2);\n+        assertThat(available.get(AclClass.CONFIGURATION).get(0).getMask()).isEqualTo(READ_PERMISSION);\n     }\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testInheritPermissions() {\n-        Folder folder = createFolder(TEST_NAME, null);\n-        createRunConfiguration(TEST_NAME, folder.getId());\n-\n-        grantPermission(folder.getId(), AclClass.FOLDER, USER2, true, AclPermission.READ.getMask());\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n-                .loadAvailable(new AclSid(USER2, true), null);\n-        Assert.assertEquals(2, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.CONFIGURATION).get(0).getMask(), AclPermission.READ.getMask());\n+    @WithMockUser\n+    public void shouldUseItsOwnPermissions() {\n+        final Folder root = new Folder();\n+        final Folder folder = getFolder(ANOTHER_SIMPLE_USER);\n+        final RunConfiguration runConfiguration = getRunConfiguration(ID, ANOTHER_SIMPLE_USER);\n+        folder.setConfigurations(Collections.singletonList(runConfiguration));\n+        root.setChildFolders(Collections.singletonList(folder));\n+        doReturn(root).when(mockFolderManager).loadTree();\n+        mockDockerRegistryList();\n+        mockUserContext();\n+        initAclEntity(folder, AclPermission.READ);\n+        initAclEntity(runConfiguration, AclPermission.WRITE);\n+\n+        final Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n+                .loadAvailable(new AclSid(SIMPLE_USER, true), null);\n+\n+        assertThat(available.size()).isEqualTo(2);\n+        assertThat(available.get(AclClass.CONFIGURATION).get(0).getMask())\n+                .isEqualTo(READ_PERMISSION + WRITE_PERMISSION);\n     }\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testUseItsOwnPermissions() {\n-        Folder folder = createFolder(TEST_NAME, null);\n-        RunConfiguration runConfiguration = createRunConfiguration(TEST_NAME, folder.getId());\n-\n-        grantPermission(folder.getId(), AclClass.FOLDER, USER2, true, AclPermission.READ.getMask());\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n-                .loadAvailable(new AclSid(USER2, true), null);\n-        Assert.assertEquals(2, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.CONFIGURATION).get(0).getMask(), AclPermission.READ.getMask());\n-\n-\n-        grantPermission(runConfiguration.getId(), AclClass.CONFIGURATION, USER2, true,\n-                ALL_PERMISSIONS);\n-\n-        available = hierarchicalEntityManager.loadAvailable(new AclSid(USER2, true), null);\n-        Assert.assertEquals(2, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.CONFIGURATION).get(0).getMask(), ALL_PERMISSIONS_SIMPLE);\n+    @WithMockUser\n+    public void shouldUseItOwnPermissionsIfParentRestricted() {\n+        final Folder root = new Folder();\n+        final Folder folder = getFolder(ANOTHER_SIMPLE_USER);\n+        final RunConfiguration runConfiguration = getRunConfiguration(ID, ANOTHER_SIMPLE_USER);\n+        folder.setConfigurations(Collections.singletonList(runConfiguration));\n+        root.setChildFolders(Collections.singletonList(folder));\n+        doReturn(root).when(mockFolderManager).loadTree();\n+        mockDockerRegistryList();\n+        mockUserContext();\n+        initAclEntity(folder);\n+        initAclEntity(runConfiguration, AclPermission.READ);\n+\n+        final Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n+                .loadAvailable(new AclSid(SIMPLE_USER, true), null);\n+\n+        assertThat(available.size()).isEqualTo(1);\n+        assertThat(available.get(AclClass.CONFIGURATION).get(0).getMask()).isEqualTo(READ_PERMISSION);\n     }\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testUseItOwnPermissionsIfParentRestricted() {\n-        Folder folder = createFolder(TEST_NAME, null);\n-        RunConfiguration runConfiguration = createRunConfiguration(TEST_NAME, folder.getId());\n-\n-        grantPermission(folder.getId(), AclClass.FOLDER, USER2, true, AclPermission.NO_READ.getMask());\n-        grantPermission(runConfiguration.getId(), AclClass.CONFIGURATION, USER2, true,\n-                ALL_PERMISSIONS);\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n-                .loadAvailable(new AclSid(USER2, true), null);\n-        //folder should be filtered because it forbidden\n-        Assert.assertEquals(1, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.CONFIGURATION).get(0).getMask(), ALL_PERMISSIONS_SIMPLE);\n+    @WithMockUser\n+    public void shouldUseItOwnRestrictedPermissionsIfParentAllowed() {\n+        final Folder root = new Folder();\n+        final Folder folder = getFolder(ANOTHER_SIMPLE_USER);\n+        final RunConfiguration runConfiguration = getRunConfiguration(ID, ANOTHER_SIMPLE_USER);\n+        folder.setConfigurations(Collections.singletonList(runConfiguration));\n+        root.setChildFolders(Collections.singletonList(folder));\n+        doReturn(root).when(mockFolderManager).loadTree();\n+        mockDockerRegistryList();\n+        mockUserContext();\n+        initAclEntity(folder, AclPermission.READ);\n+        initAclEntity(runConfiguration, AclPermission.NO_READ);\n+\n+        final Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n+                .loadAvailable(new AclSid(SIMPLE_USER, true), null);\n+\n+        assertThat(available.size()).isEqualTo(1);\n+        assertThat(available.get(AclClass.FOLDER).get(0).getMask()).isEqualTo(READ_PERMISSION);\n     }\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testUseItOwnRestrictedPermissionsIfParentAllowed() {\n-        Folder folder = createFolder(TEST_NAME, null);\n-        RunConfiguration runConfiguration = createRunConfiguration(TEST_NAME, folder.getId());\n-\n-        grantPermission(folder.getId(), AclClass.FOLDER, USER2, true, ALL_PERMISSIONS);\n-        grantPermission(runConfiguration.getId(), AclClass.CONFIGURATION, USER2, true,\n-                AclPermission.NO_READ.getMask());\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n-                .loadAvailable(new AclSid(USER2, true), null);\n-        //folder should be filtered because it forbidden\n-        Assert.assertEquals(1, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.FOLDER).get(0).getMask(), ALL_PERMISSIONS_SIMPLE);\n+    @WithMockUser\n+    public void shouldUseItOwnPermissionsIfParentRestrictedByInheritance() {\n+        final Folder root = new Folder();\n+        final Folder folder = getFolder(ANOTHER_SIMPLE_USER);\n+        final Folder childFolder = getFolder(ID_2, folder.getId(), ANOTHER_SIMPLE_USER);\n+        final RunConfiguration runConfiguration = getRunConfiguration(ID_2, ANOTHER_SIMPLE_USER);\n+        childFolder.setConfigurations(Collections.singletonList(runConfiguration));\n+        root.setChildFolders(Collections.singletonList(folder));\n+        folder.setChildFolders(Collections.singletonList(childFolder));\n+        doReturn(root).when(mockFolderManager).loadTree();\n+        mockDockerRegistryList();\n+        mockUserContext();\n+        initAclEntity(folder);\n+        initAclEntity(runConfiguration, AclPermission.READ);\n+\n+        final Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n+                .loadAvailable(new AclSid(SIMPLE_USER, true), null);\n+\n+        assertThat(available.size()).isEqualTo(1);\n+        assertThat(available.get(AclClass.CONFIGURATION).get(0).getMask()).isEqualTo(READ_PERMISSION);\n     }\n \n     @Test\n-    @WithMockUser(username = USER)\n-    public void testUseItOwnPermissionsIfParentRestrictedByInheritance() {\n-        Folder folder = createFolder(TEST_NAME, null);\n-        Folder subFolder = createFolder(TEST_NAME, folder.getId());\n-        RunConfiguration runConfiguration = createRunConfiguration(TEST_NAME, subFolder.getId());\n-\n-        grantPermission(folder.getId(), AclClass.FOLDER, USER2, true, AclPermission.NO_READ.getMask());\n-        grantPermission(runConfiguration.getId(), AclClass.CONFIGURATION, USER2, true,\n-                ALL_PERMISSIONS);\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n-                .loadAvailable(new AclSid(USER2, true), null);\n-        //folder should be filtered because it forbidden\n-        Assert.assertEquals(1, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.CONFIGURATION).get(0).getMask(), ALL_PERMISSIONS_SIMPLE);\n-    }\n-\n-    @Test\n-    @WithMockUser(username = USER)\n+    @WithMockUser\n     public void shouldReturnOneAclClassOnly() {\n-        Folder folder = createFolder(TEST_NAME, null);\n-        Folder subFolder = createFolder(TEST_NAME, folder.getId());\n-        RunConfiguration runConfiguration = createRunConfiguration(TEST_NAME, subFolder.getId());\n-\n-        grantPermission(folder.getId(), AclClass.FOLDER, USER2, true, ALL_PERMISSIONS);\n-        grantPermission(runConfiguration.getId(), AclClass.CONFIGURATION, USER2, true,\n-                ALL_PERMISSIONS);\n-\n-        Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n-                .loadAvailable(new AclSid(USER2, true), AclClass.CONFIGURATION);\n-        Assert.assertEquals(1, available.size());\n-        Assert.assertEquals((int) available.get(AclClass.CONFIGURATION).get(0).getMask(), ALL_PERMISSIONS_SIMPLE);\n+        final Folder root = new Folder();\n+        final Folder folder = getFolder(ANOTHER_SIMPLE_USER);\n+        final Folder childFolder = getFolder(ID_2, folder.getId(), ANOTHER_SIMPLE_USER);\n+        final RunConfiguration runConfiguration = getRunConfiguration(ID_2, ANOTHER_SIMPLE_USER);\n+        childFolder.setConfigurations(Collections.singletonList(runConfiguration));\n+        root.setChildFolders(Collections.singletonList(folder));\n+        folder.setChildFolders(Collections.singletonList(childFolder));\n+        doReturn(root).when(mockFolderManager).loadTree();\n+        mockDockerRegistryList();\n+        mockUserContext();\n+        initAclEntity(folder, AclPermission.READ);\n+        initAclEntity(runConfiguration, AclPermission.READ);\n+\n+        final Map<AclClass, List<AbstractSecuredEntity>> available = hierarchicalEntityManager\n+                .loadAvailable(new AclSid(SIMPLE_USER, true), AclClass.CONFIGURATION);", "originalCommit": "9bd514ff5153f2e8e46cbfbcefe959dc8c9ec773", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "eaf1040180df5ceb6e0d44aa878ffbe1316da88d", "url": "https://github.com/epam/cloud-pipeline/commit/eaf1040180df5ceb6e0d44aa878ffbe1316da88d", "message": "Issue #1688: Rewritten HierarchicalEntityManagerTest", "committedDate": "2021-02-08T10:49:19Z", "type": "commit"}, {"oid": "1023e1915418e20daa35f916b3b67e77bd57c2d4", "url": "https://github.com/epam/cloud-pipeline/commit/1023e1915418e20daa35f916b3b67e77bd57c2d4", "message": "Issue #1688: one test added, test class refactored", "committedDate": "2021-02-08T10:49:35Z", "type": "commit"}, {"oid": "2b0fa3b6b71f9908c8e7bfafeb0a797887eb8bf5", "url": "https://github.com/epam/cloud-pipeline/commit/2b0fa3b6b71f9908c8e7bfafeb0a797887eb8bf5", "message": "Issue #1688: improvements and refactoring in accordance with comments", "committedDate": "2021-02-08T10:52:20Z", "type": "commit"}, {"oid": "fba3b76c890d6a52d8465b800067c3072ba02e66", "url": "https://github.com/epam/cloud-pipeline/commit/fba3b76c890d6a52d8465b800067c3072ba02e66", "message": "Issue #1688: added permissions for groups in the shouldLoadByRoleSidWhenLoadForUser test", "committedDate": "2021-02-08T10:52:22Z", "type": "commit"}, {"oid": "7b2703f134d2c0c6d0fdf22747cb5a7c17f98ca0", "url": "https://github.com/epam/cloud-pipeline/commit/7b2703f134d2c0c6d0fdf22747cb5a7c17f98ca0", "message": "Issue #1688: assertion added", "committedDate": "2021-02-08T10:52:23Z", "type": "commit"}, {"oid": "fcad1cd553a722dbd1cf683e9c1d33861fbf1ee5", "url": "https://github.com/epam/cloud-pipeline/commit/fcad1cd553a722dbd1cf683e9c1d33861fbf1ee5", "message": "Issue #1688: init Acl strategy changed in the shouldLoadByRoleSidWhenLoadForUser test", "committedDate": "2021-02-08T10:52:23Z", "type": "commit"}, {"oid": "36a3bb025f99f6d26eaf09920303498b28b388ba", "url": "https://github.com/epam/cloud-pipeline/commit/36a3bb025f99f6d26eaf09920303498b28b388ba", "message": "Issue #1688: bringing the tests in line with the previous ones", "committedDate": "2021-02-08T10:52:23Z", "type": "commit"}, {"oid": "e26f55bc6a10abf7a96feba6dcbd6ea242f872e1", "url": "https://github.com/epam/cloud-pipeline/commit/e26f55bc6a10abf7a96feba6dcbd6ea242f872e1", "message": "Issue #1688: redundant test has been removed", "committedDate": "2021-02-08T10:52:24Z", "type": "commit"}, {"oid": "4609a3318293169d0bba02ad39cd100cf33d32a9", "url": "https://github.com/epam/cloud-pipeline/commit/4609a3318293169d0bba02ad39cd100cf33d32a9", "message": "Issue #1688: added WithMockUser annotation + removed mock method", "committedDate": "2021-02-08T10:52:24Z", "type": "commit"}, {"oid": "1a69b2e5b4b8d26cdda2bf5fe8c3375c868ed2d6", "url": "https://github.com/epam/cloud-pipeline/commit/1a69b2e5b4b8d26cdda2bf5fe8c3375c868ed2d6", "message": "Issue #1688: style refactoring + minor fix in shouldLoadByRoleSid test", "committedDate": "2021-02-08T10:52:25Z", "type": "commit"}, {"oid": "cfe299097f568242e07f8c4117fc2176cbcb5136", "url": "https://github.com/epam/cloud-pipeline/commit/cfe299097f568242e07f8c4117fc2176cbcb5136", "message": "Issue #1688: develop branch rebased", "committedDate": "2021-02-08T11:05:52Z", "type": "commit"}, {"oid": "cfe299097f568242e07f8c4117fc2176cbcb5136", "url": "https://github.com/epam/cloud-pipeline/commit/cfe299097f568242e07f8c4117fc2176cbcb5136", "message": "Issue #1688: develop branch rebased", "committedDate": "2021-02-08T11:05:52Z", "type": "forcePushed"}]}