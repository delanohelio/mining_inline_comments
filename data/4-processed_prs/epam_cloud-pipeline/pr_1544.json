{"pr_number": 1544, "pr_title": "Issue #1404: Implemented tests for DockerRegistryApiService", "pr_createdAt": "2020-11-05T13:41:13Z", "pr_url": "https://github.com/epam/cloud-pipeline/pull/1544", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDYwOTI4Nw==", "url": "https://github.com/epam/cloud-pipeline/pull/1544#discussion_r520609287", "bodyText": "Apparently, we should use the dockerRegistryApiService here, not the mockDockerRegistryManager. And also in the test below.", "author": "YouKofan", "createdAt": "2020-11-10T14:35:40Z", "path": "api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.acl.docker;\n+\n+import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n+import com.epam.pipeline.entity.docker.DockerRegistryList;\n+import com.epam.pipeline.entity.pipeline.DockerRegistry;\n+import com.epam.pipeline.entity.pipeline.DockerRegistryEventEnvelope;\n+import com.epam.pipeline.entity.pipeline.Tool;\n+import com.epam.pipeline.entity.security.JwtRawToken;\n+import com.epam.pipeline.manager.docker.DockerRegistryManager;\n+import com.epam.pipeline.manager.security.AuthManager;\n+import com.epam.pipeline.security.acl.AclPermission;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.docker.DockerCreatorUtils;\n+import com.epam.pipeline.test.creator.docker.ToolCreatorUtils;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.test.context.support.WithMockUser;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.doReturn;\n+\n+public class DockerRegistryApiServiceTest extends AbstractAclTest {\n+\n+    private static final byte[] BYTE_RESULT = TEST_STRING.getBytes();\n+    private final DockerRegistry dockerRegistry = DockerCreatorUtils.getDockerRegistry();\n+    private final DockerRegistry dockerRegistryWithOwner = DockerCreatorUtils.getDockerRegistry(SIMPLE_USER);\n+    private final DockerRegistryVO dockerRegistryVO = DockerCreatorUtils.getDockerRegistryVO();\n+    private final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList();\n+    private final Tool tool = ToolCreatorUtils.getTool();\n+    private final List<Tool> tools = Collections.singletonList(tool);\n+    private final DockerRegistryEventEnvelope eventEnvelope = DockerCreatorUtils.getDockerRegistryEventEnvelope();\n+\n+    @Autowired\n+    private DockerRegistryApiService dockerRegistryApiService;\n+\n+    @Autowired\n+    private DockerRegistryManager mockDockerRegistryManager;\n+\n+    @Autowired\n+    private AuthManager mockAuthManager;\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldCreateDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).create(dockerRegistryVO);\n+\n+        assertThat(dockerRegistryApiService.create(dockerRegistryVO)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyCreateDockerRegistryForNonAdminUser() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).create(dockerRegistryVO);\n+\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.create(dockerRegistryVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateDockerRegistryWhenPermissionIsGranted() {\n+        initAclEntity(dockerRegistryWithOwner, AclPermission.WRITE);\n+        doReturn(SIMPLE_USER).when(mockAuthManager).getAuthorizedUser();\n+        doReturn(dockerRegistryWithOwner).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n+\n+        final DockerRegistry resultRegistry = dockerRegistryApiService.updateDockerRegistry(dockerRegistry);\n+\n+        assertThat(resultRegistry).isEqualTo(dockerRegistryWithOwner);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyUpdateDockerRegistryWhenPermissionIsNotGranted() {\n+        doReturn(dockerRegistryWithOwner).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n+        initAclEntity(dockerRegistryWithOwner);\n+        doReturn(SIMPLE_USER).when(mockAuthManager).getAuthorizedUser();\n+\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.updateDockerRegistry(dockerRegistryWithOwner));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateDockerRegistryCredentialsForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO))\n+                .isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyUpdateDockerRegistryCredentialsForNonAdminUser() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldListDockerRegistriesWithCerts() {\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n+\n+        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts()).isEqualTo(dockerRegistryList);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadAllRegistriesContent() {\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n+\n+        assertThat(dockerRegistryApiService.loadAllRegistriesContent()).isEqualTo(dockerRegistryList);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadDockerRegistry() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).load(ID);\n+\n+        assertThat(dockerRegistryApiService.load(ID)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldDeleteDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).delete(ID, true);\n+\n+        assertThat(mockDockerRegistryManager.delete(ID, true)).isEqualTo(dockerRegistry);", "originalCommit": "663ad3a99f2552639481f236603945c5730c7195", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI0NDIwMA==", "url": "https://github.com/epam/cloud-pipeline/pull/1544#discussion_r521244200", "bodyText": "To my mind it would be better to overload the method\nCould we add final to method argument?", "author": "ekazachkova", "createdAt": "2020-11-11T09:58:27Z", "path": "api/src/test/java/com/epam/pipeline/test/creator/docker/ToolCreatorUtils.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.test.creator.docker;\n+\n+import com.epam.pipeline.entity.pipeline.Tool;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+\n+public final class ToolCreatorUtils {\n+\n+    private ToolCreatorUtils() {\n+\n+    }\n+\n+    public static Tool getTool() {\n+        final Tool tool = new Tool();\n+        tool.setId(ID);\n+        tool.setName(TEST_STRING);\n+        tool.setCpu(TEST_STRING);\n+        tool.setDefaultCommand(TEST_STRING);\n+        tool.setToolGroupId(ID);\n+        tool.setRegistry(TEST_STRING);\n+        tool.setRegistryId(ID);\n+        return tool;\n+    }\n+\n+    public static Tool getTool(String owner) {", "originalCommit": "663ad3a99f2552639481f236603945c5730c7195", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI0NDY4MQ==", "url": "https://github.com/epam/cloud-pipeline/pull/1544#discussion_r521244681", "bodyText": "To my mind it would be better to overload the method\nCould we add final to method argument?", "author": "ekazachkova", "createdAt": "2020-11-11T09:59:17Z", "path": "api/src/test/java/com/epam/pipeline/test/creator/docker/DockerCreatorUtils.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.test.creator.docker;\n+\n+import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n+import com.epam.pipeline.entity.docker.DockerRegistryList;\n+import com.epam.pipeline.entity.pipeline.DockerRegistry;\n+import com.epam.pipeline.entity.pipeline.DockerRegistryEventEnvelope;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+\n+public final class DockerCreatorUtils {\n+\n+    private DockerCreatorUtils() {\n+\n+    }\n+\n+    public static DockerRegistry getDockerRegistry() {\n+        final DockerRegistry dockerRegistry = new DockerRegistry();\n+        dockerRegistry.setCaCert(TEST_STRING);\n+        dockerRegistry.setId(ID);\n+        dockerRegistry.setDescription(TEST_STRING);\n+        dockerRegistry.setExternalUrl(TEST_STRING);\n+        dockerRegistry.setHasMetadata(true);\n+        dockerRegistry.setPassword(TEST_STRING);\n+        return dockerRegistry;\n+    }\n+\n+    public static DockerRegistry getDockerRegistry(String owner) {", "originalCommit": "663ad3a99f2552639481f236603945c5730c7195", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI0NjM1NA==", "url": "https://github.com/epam/cloud-pipeline/pull/1544#discussion_r521246354", "bodyText": "Do not forget to add final\nDo we really need this method?", "author": "ekazachkova", "createdAt": "2020-11-11T10:02:08Z", "path": "api/src/test/java/com/epam/pipeline/test/creator/docker/DockerCreatorUtils.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.test.creator.docker;\n+\n+import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n+import com.epam.pipeline.entity.docker.DockerRegistryList;\n+import com.epam.pipeline.entity.pipeline.DockerRegistry;\n+import com.epam.pipeline.entity.pipeline.DockerRegistryEventEnvelope;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+\n+public final class DockerCreatorUtils {\n+\n+    private DockerCreatorUtils() {\n+\n+    }\n+\n+    public static DockerRegistry getDockerRegistry() {\n+        final DockerRegistry dockerRegistry = new DockerRegistry();\n+        dockerRegistry.setCaCert(TEST_STRING);\n+        dockerRegistry.setId(ID);\n+        dockerRegistry.setDescription(TEST_STRING);\n+        dockerRegistry.setExternalUrl(TEST_STRING);\n+        dockerRegistry.setHasMetadata(true);\n+        dockerRegistry.setPassword(TEST_STRING);\n+        return dockerRegistry;\n+    }\n+\n+    public static DockerRegistry getDockerRegistry(String owner) {\n+        final DockerRegistry dockerRegistry = new DockerRegistry();\n+        dockerRegistry.setOwner(owner);\n+        dockerRegistry.setCaCert(TEST_STRING);\n+        dockerRegistry.setId(ID);\n+        dockerRegistry.setDescription(TEST_STRING);\n+        dockerRegistry.setExternalUrl(TEST_STRING);\n+        dockerRegistry.setHasMetadata(true);\n+        dockerRegistry.setPassword(TEST_STRING);\n+        return dockerRegistry;\n+    }\n+\n+    public static DockerRegistryVO getDockerRegistryVO() {\n+        final DockerRegistryVO dockerRegistryVO = new DockerRegistryVO();\n+        dockerRegistryVO.setCaCert(TEST_STRING);\n+        dockerRegistryVO.setId(ID);\n+        dockerRegistryVO.setDescription(TEST_STRING);\n+        dockerRegistryVO.setExternalUrl(TEST_STRING);\n+        dockerRegistryVO.setPassword(TEST_STRING);\n+        return dockerRegistryVO;\n+    }\n+\n+    public static DockerRegistryList getDockerRegistryList() {\n+        final List<DockerRegistry> dockerRegistries = Collections.singletonList(getDockerRegistry());\n+        return new DockerRegistryList(dockerRegistries);\n+    }\n+\n+    public static DockerRegistryList getDockerRegistryList(String owner) {", "originalCommit": "663ad3a99f2552639481f236603945c5730c7195", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTI2OTAyOQ==", "url": "https://github.com/epam/cloud-pipeline/pull/1544#discussion_r521269029", "bodyText": "Could you add a simple tests for methods with AclTree annotation?", "author": "ekazachkova", "createdAt": "2020-11-11T10:42:02Z", "path": "api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.acl.docker;\n+\n+import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n+import com.epam.pipeline.entity.docker.DockerRegistryList;\n+import com.epam.pipeline.entity.pipeline.DockerRegistry;\n+import com.epam.pipeline.entity.pipeline.DockerRegistryEventEnvelope;\n+import com.epam.pipeline.entity.pipeline.Tool;\n+import com.epam.pipeline.entity.security.JwtRawToken;\n+import com.epam.pipeline.manager.docker.DockerRegistryManager;\n+import com.epam.pipeline.manager.security.AuthManager;\n+import com.epam.pipeline.security.acl.AclPermission;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.docker.DockerCreatorUtils;\n+import com.epam.pipeline.test.creator.docker.ToolCreatorUtils;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.test.context.support.WithMockUser;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.doReturn;\n+\n+public class DockerRegistryApiServiceTest extends AbstractAclTest {", "originalCommit": "663ad3a99f2552639481f236603945c5730c7195", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c3103f3f4623dae614b7ca813920a21f643d8c0a", "url": "https://github.com/epam/cloud-pipeline/commit/c3103f3f4623dae614b7ca813920a21f643d8c0a", "message": "Issue #1404: Added tests for AclTree annotation", "committedDate": "2020-11-18T07:46:58Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTkzNjk4NQ==", "url": "https://github.com/epam/cloud-pipeline/pull/1544#discussion_r525936985", "bodyText": "Could it be realized like:\nreturn getTool(null, null)\n\n?", "author": "ekazachkova", "createdAt": "2020-11-18T09:30:03Z", "path": "api/src/test/java/com/epam/pipeline/test/creator/docker/DockerCreatorUtils.java", "diffHunk": "@@ -165,10 +166,56 @@ public static DockerRegistryVO getDockerRegistryVO() {\n     }\n \n     public static DockerRegistryList getDockerRegistryList() {\n-        return new DockerRegistryList(Collections.singletonList(getDockerRegistry()));\n+        final List<DockerRegistry> dockerRegistries = Collections.singletonList(getDockerRegistry());\n+        return new DockerRegistryList(dockerRegistries);\n+    }\n+\n+    public static DockerRegistryList getDockerRegistryList(final DockerRegistry dockerRegistry) {\n+        return new DockerRegistryList(Collections.singletonList(dockerRegistry));\n     }\n \n     public static DockerRegistryEventEnvelope getDockerRegistryEventEnvelope() {\n         return new DockerRegistryEventEnvelope();\n     }\n+\n+    public static Tool getTool(final Long id, final String owner) {\n+        final Tool tool = new Tool();\n+        tool.setOwner(owner);\n+        tool.setId(id);\n+        tool.setCpu(TEST_STRING);\n+        tool.setDefaultCommand(TEST_STRING);\n+        tool.setToolGroupId(ID);\n+        tool.setRegistry(TEST_STRING);\n+        return tool;\n+    }\n+\n+    public static Tool getTool(final String owner) {\n+        return getTool(ID, owner);\n+    }\n+\n+    public static Tool getTool() {\n+        final Tool tool = new Tool();", "originalCommit": "c3103f3f4623dae614b7ca813920a21f643d8c0a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTkzOTY4MA==", "url": "https://github.com/epam/cloud-pipeline/pull/1544#discussion_r525939680", "bodyText": "Could you please remove empty line?", "author": "ekazachkova", "createdAt": "2020-11-18T09:34:03Z", "path": "api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java", "diffHunk": "@@ -0,0 +1,363 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.acl.docker;\n+\n+import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n+import com.epam.pipeline.entity.AbstractHierarchicalEntity;\n+import com.epam.pipeline.entity.AbstractSecuredEntity;\n+import com.epam.pipeline.entity.docker.DockerRegistryList;\n+import com.epam.pipeline.entity.pipeline.DockerRegistry;\n+import com.epam.pipeline.entity.pipeline.DockerRegistryEventEnvelope;\n+import com.epam.pipeline.entity.pipeline.Tool;\n+import com.epam.pipeline.entity.pipeline.ToolGroup;\n+import com.epam.pipeline.entity.security.JwtRawToken;\n+import com.epam.pipeline.manager.docker.DockerRegistryManager;\n+import com.epam.pipeline.security.acl.AclPermission;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.docker.DockerCreatorUtils;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.test.context.support.WithMockUser;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_2;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_3;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.doReturn;\n+\n+public class DockerRegistryApiServiceTest extends AbstractAclTest {\n+\n+    private static final byte[] BYTE_RESULT = TEST_STRING.getBytes();\n+    private final DockerRegistry dockerRegistry = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n+    private final DockerRegistryVO dockerRegistryVO = DockerCreatorUtils.getDockerRegistryVO();\n+    private final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+    private final Tool tool = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n+    private final List<Tool> tools = Collections.singletonList(tool);\n+    private final DockerRegistryEventEnvelope eventEnvelope = DockerCreatorUtils.getDockerRegistryEventEnvelope();\n+    private final JwtRawToken jwtRawToken = new JwtRawToken(TEST_STRING);\n+    private final DockerRegistry dockerRegistryWithTools = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n+    private final ToolGroup toolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ANOTHER_SIMPLE_USER);\n+    private final ToolGroup toolGroup = DockerCreatorUtils.getToolGroup(ID_2, ANOTHER_SIMPLE_USER);\n+    private final ToolGroup emptyToolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ID_3, ANOTHER_SIMPLE_USER);\n+    private final Tool toolRead = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n+    private final Tool toolWithoutPermission = DockerCreatorUtils.getTool(ID_2, ANOTHER_SIMPLE_USER);\n+    private final List<Tool> toolList = Arrays.asList(toolRead, toolWithoutPermission);\n+    private final List<ToolGroup> toolGroups =\n+            Arrays.asList(toolGroup, toolGroupWithoutPermission, emptyToolGroupWithoutPermission);\n+", "originalCommit": "c3103f3f4623dae614b7ca813920a21f643d8c0a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk2ODQ2Mg==", "url": "https://github.com/epam/cloud-pipeline/pull/1544#discussion_r525968462", "bodyText": "It looks a bit confusing: you are granting permission to object with name *WithoutPermission", "author": "ekazachkova", "createdAt": "2020-11-18T10:16:25Z", "path": "api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java", "diffHunk": "@@ -0,0 +1,363 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.acl.docker;\n+\n+import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n+import com.epam.pipeline.entity.AbstractHierarchicalEntity;\n+import com.epam.pipeline.entity.AbstractSecuredEntity;\n+import com.epam.pipeline.entity.docker.DockerRegistryList;\n+import com.epam.pipeline.entity.pipeline.DockerRegistry;\n+import com.epam.pipeline.entity.pipeline.DockerRegistryEventEnvelope;\n+import com.epam.pipeline.entity.pipeline.Tool;\n+import com.epam.pipeline.entity.pipeline.ToolGroup;\n+import com.epam.pipeline.entity.security.JwtRawToken;\n+import com.epam.pipeline.manager.docker.DockerRegistryManager;\n+import com.epam.pipeline.security.acl.AclPermission;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.docker.DockerCreatorUtils;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.test.context.support.WithMockUser;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_2;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_3;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.doReturn;\n+\n+public class DockerRegistryApiServiceTest extends AbstractAclTest {\n+\n+    private static final byte[] BYTE_RESULT = TEST_STRING.getBytes();\n+    private final DockerRegistry dockerRegistry = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n+    private final DockerRegistryVO dockerRegistryVO = DockerCreatorUtils.getDockerRegistryVO();\n+    private final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+    private final Tool tool = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n+    private final List<Tool> tools = Collections.singletonList(tool);\n+    private final DockerRegistryEventEnvelope eventEnvelope = DockerCreatorUtils.getDockerRegistryEventEnvelope();\n+    private final JwtRawToken jwtRawToken = new JwtRawToken(TEST_STRING);\n+    private final DockerRegistry dockerRegistryWithTools = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n+    private final ToolGroup toolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ANOTHER_SIMPLE_USER);\n+    private final ToolGroup toolGroup = DockerCreatorUtils.getToolGroup(ID_2, ANOTHER_SIMPLE_USER);\n+    private final ToolGroup emptyToolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ID_3, ANOTHER_SIMPLE_USER);\n+    private final Tool toolRead = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n+    private final Tool toolWithoutPermission = DockerCreatorUtils.getTool(ID_2, ANOTHER_SIMPLE_USER);\n+    private final List<Tool> toolList = Arrays.asList(toolRead, toolWithoutPermission);\n+    private final List<ToolGroup> toolGroups =\n+            Arrays.asList(toolGroup, toolGroupWithoutPermission, emptyToolGroupWithoutPermission);\n+\n+\n+    @Autowired\n+    private DockerRegistryApiService dockerRegistryApiService;\n+\n+    @Autowired\n+    private DockerRegistryManager mockDockerRegistryManager;\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldCreateDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).create(dockerRegistryVO);\n+\n+        assertThat(dockerRegistryApiService.create(dockerRegistryVO)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyCreateDockerRegistryForNonAdminUser() {\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.create(dockerRegistryVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateDockerRegistryWhenPermissionIsGranted() {\n+        initAclEntity(dockerRegistry, AclPermission.WRITE);\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateDockerRegistryHierarchyWhenPermissionIsGranted() {\n+        initDockerRegistryAclTree();\n+        initAclEntity(dockerRegistryWithTools, AclPermission.WRITE);\n+        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistryWithTools);\n+\n+        final DockerRegistry returnedDr = dockerRegistryApiService.updateDockerRegistry(dockerRegistryWithTools);\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyUpdateDockerRegistryWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.updateDockerRegistry(dockerRegistry));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateDockerRegistryCredentialsForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO))\n+                .isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyUpdateDockerRegistryCredentialsForNonAdminUser() {\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateWholeDockerRegistryHierarchyCredentialsForAdmin() {\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager)\n+                .updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        final DockerRegistry returnedDr = dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        assertWholeDockerRegistryAclTree(returnedDr);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldListDockerRegistriesWithCerts() {\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n+\n+        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts()).isEqualTo(dockerRegistryList);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldListDockerRegistryHierarchyWithCerts() {\n+        final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+        final DockerRegistry anotherRegistry = DockerCreatorUtils.getDockerRegistry(ID_3, ANOTHER_SIMPLE_USER);\n+        dockerRegistryList.setRegistries(Arrays.asList(dockerRegistryWithTools, anotherRegistry));\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n+\n+        final DockerRegistry returnedDr = (DockerRegistry) dockerRegistryApiService\n+                .listDockerRegistriesWithCerts().getChildren().get(0);\n+\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts().getChildren().size()).isEqualTo(1);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadAllRegistriesContent() {\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n+\n+        assertThat(dockerRegistryApiService.loadAllRegistriesContent()).isEqualTo(dockerRegistryList);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldLoadAllRegistriesHierarchyContent() {\n+        final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+        final DockerRegistry anotherRegistry = DockerCreatorUtils.getDockerRegistry(ID_3, ANOTHER_SIMPLE_USER);\n+        dockerRegistryList.setRegistries(Arrays.asList(dockerRegistryWithTools, anotherRegistry));\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n+\n+        final DockerRegistry returnedDr = (DockerRegistry) dockerRegistryApiService\n+                .loadAllRegistriesContent().getChildren().get(0);\n+\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+        assertThat(dockerRegistryApiService.loadAllRegistriesContent().getChildren().size()).isEqualTo(1);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadDockerRegistry() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).load(ID);\n+\n+        assertThat(dockerRegistryApiService.load(ID)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldLoadDockerRegistryHierarchy() {\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager).load(ID);\n+\n+        final DockerRegistry returnedDr = dockerRegistryApiService.load(ID);\n+\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldDeleteDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).delete(ID, true);\n+\n+        assertThat(dockerRegistryApiService.delete(ID, true)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDeleteDockerRegistryWhenPermissionIsGranted() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).delete(ID, true);\n+        initAclEntity(dockerRegistry, AclPermission.WRITE);\n+\n+        assertThat(dockerRegistryApiService.delete(ID, true)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyDeleteDockerRegistryWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.delete(ID, true));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldNotifyDockerRegistryEventsForAdmin() {\n+        doReturn(tools).when(mockDockerRegistryManager).notifyDockerRegistryEvents(TEST_STRING, eventEnvelope);\n+\n+        assertThat(dockerRegistryApiService.notifyDockerRegistryEvents(TEST_STRING, eventEnvelope)).isEqualTo(tools);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyNotifyDockerRegistryEventsForNotAdmin() {\n+        doReturn(tools).when(mockDockerRegistryManager).notifyDockerRegistryEvents(TEST_STRING, eventEnvelope);\n+\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.notifyDockerRegistryEvents(TEST_STRING, eventEnvelope));\n+    }\n+\n+    @Test\n+    public void shouldIssueTokenForDockerRegistry() {\n+        doReturn(jwtRawToken).when(mockDockerRegistryManager)\n+                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING);\n+\n+        assertThat(dockerRegistryApiService\n+                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING))\n+                .isEqualTo(jwtRawToken);\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldGetCertificateContentForAdmin() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getCertificateContent(ID);\n+\n+        assertThat(dockerRegistryApiService.getCertificateContent(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldGetCertificateContentWhenPermissionIsGranted() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getCertificateContent(ID);\n+        initAclEntity(dockerRegistry, AclPermission.READ);\n+\n+        assertThat(dockerRegistryApiService.getCertificateContent(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyGetCertificateContentWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.getCertificateContent(ID));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldGetConfigScript() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getConfigScript(ID);\n+\n+        assertThat(dockerRegistryApiService.getConfigScript(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldGetConfigScriptWhenPermissionIsGranted() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getConfigScript(ID);\n+        initAclEntity(dockerRegistry, AclPermission.READ);\n+\n+        assertThat(dockerRegistryApiService.getConfigScript(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyGetConfigScriptWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.getConfigScript(ID));\n+    }\n+\n+    private void initDockerRegistryAclTree() {\n+        toolGroup.setTools(toolList);\n+        toolGroupWithoutPermission.setTools(toolList);\n+        dockerRegistryWithTools.setGroups(toolGroups);\n+        initAclEntity(toolRead, AclPermission.READ);\n+        initAclEntity(toolWithoutPermission);\n+        initAclEntity(toolGroup, AclPermission.READ);\n+        initAclEntity(toolGroupWithoutPermission);\n+        initAclEntity(emptyToolGroupWithoutPermission, AclPermission.READ);", "originalCommit": "c3103f3f4623dae614b7ca813920a21f643d8c0a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk4NzQ0NQ==", "url": "https://github.com/epam/cloud-pipeline/pull/1544#discussion_r525987445", "bodyText": "Class fields mutation makes code confusing. To my mind it would more clearly to refactor this lines:\ntoolGroup.setTools(toolList);\ntoolGroupWithoutPermission.setTools(toolList);\ndockerRegistryWithTools.setGroups(toolGroups);\n\nI would suggest two options:\n\ncreate a new objects into the test\ninitialize this fields at the tests class beginning", "author": "ekazachkova", "createdAt": "2020-11-18T10:45:19Z", "path": "api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java", "diffHunk": "@@ -0,0 +1,363 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.acl.docker;\n+\n+import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n+import com.epam.pipeline.entity.AbstractHierarchicalEntity;\n+import com.epam.pipeline.entity.AbstractSecuredEntity;\n+import com.epam.pipeline.entity.docker.DockerRegistryList;\n+import com.epam.pipeline.entity.pipeline.DockerRegistry;\n+import com.epam.pipeline.entity.pipeline.DockerRegistryEventEnvelope;\n+import com.epam.pipeline.entity.pipeline.Tool;\n+import com.epam.pipeline.entity.pipeline.ToolGroup;\n+import com.epam.pipeline.entity.security.JwtRawToken;\n+import com.epam.pipeline.manager.docker.DockerRegistryManager;\n+import com.epam.pipeline.security.acl.AclPermission;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.docker.DockerCreatorUtils;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.test.context.support.WithMockUser;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_2;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_3;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.doReturn;\n+\n+public class DockerRegistryApiServiceTest extends AbstractAclTest {\n+\n+    private static final byte[] BYTE_RESULT = TEST_STRING.getBytes();\n+    private final DockerRegistry dockerRegistry = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n+    private final DockerRegistryVO dockerRegistryVO = DockerCreatorUtils.getDockerRegistryVO();\n+    private final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+    private final Tool tool = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n+    private final List<Tool> tools = Collections.singletonList(tool);\n+    private final DockerRegistryEventEnvelope eventEnvelope = DockerCreatorUtils.getDockerRegistryEventEnvelope();\n+    private final JwtRawToken jwtRawToken = new JwtRawToken(TEST_STRING);\n+    private final DockerRegistry dockerRegistryWithTools = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n+    private final ToolGroup toolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ANOTHER_SIMPLE_USER);\n+    private final ToolGroup toolGroup = DockerCreatorUtils.getToolGroup(ID_2, ANOTHER_SIMPLE_USER);\n+    private final ToolGroup emptyToolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ID_3, ANOTHER_SIMPLE_USER);\n+    private final Tool toolRead = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n+    private final Tool toolWithoutPermission = DockerCreatorUtils.getTool(ID_2, ANOTHER_SIMPLE_USER);\n+    private final List<Tool> toolList = Arrays.asList(toolRead, toolWithoutPermission);\n+    private final List<ToolGroup> toolGroups =\n+            Arrays.asList(toolGroup, toolGroupWithoutPermission, emptyToolGroupWithoutPermission);\n+\n+\n+    @Autowired\n+    private DockerRegistryApiService dockerRegistryApiService;\n+\n+    @Autowired\n+    private DockerRegistryManager mockDockerRegistryManager;\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldCreateDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).create(dockerRegistryVO);\n+\n+        assertThat(dockerRegistryApiService.create(dockerRegistryVO)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyCreateDockerRegistryForNonAdminUser() {\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.create(dockerRegistryVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateDockerRegistryWhenPermissionIsGranted() {\n+        initAclEntity(dockerRegistry, AclPermission.WRITE);\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateDockerRegistryHierarchyWhenPermissionIsGranted() {\n+        initDockerRegistryAclTree();\n+        initAclEntity(dockerRegistryWithTools, AclPermission.WRITE);\n+        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistryWithTools);\n+\n+        final DockerRegistry returnedDr = dockerRegistryApiService.updateDockerRegistry(dockerRegistryWithTools);\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyUpdateDockerRegistryWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.updateDockerRegistry(dockerRegistry));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateDockerRegistryCredentialsForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO))\n+                .isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyUpdateDockerRegistryCredentialsForNonAdminUser() {\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateWholeDockerRegistryHierarchyCredentialsForAdmin() {\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager)\n+                .updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        final DockerRegistry returnedDr = dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        assertWholeDockerRegistryAclTree(returnedDr);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldListDockerRegistriesWithCerts() {\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n+\n+        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts()).isEqualTo(dockerRegistryList);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldListDockerRegistryHierarchyWithCerts() {\n+        final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+        final DockerRegistry anotherRegistry = DockerCreatorUtils.getDockerRegistry(ID_3, ANOTHER_SIMPLE_USER);\n+        dockerRegistryList.setRegistries(Arrays.asList(dockerRegistryWithTools, anotherRegistry));\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n+\n+        final DockerRegistry returnedDr = (DockerRegistry) dockerRegistryApiService\n+                .listDockerRegistriesWithCerts().getChildren().get(0);\n+\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts().getChildren().size()).isEqualTo(1);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadAllRegistriesContent() {\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n+\n+        assertThat(dockerRegistryApiService.loadAllRegistriesContent()).isEqualTo(dockerRegistryList);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldLoadAllRegistriesHierarchyContent() {\n+        final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+        final DockerRegistry anotherRegistry = DockerCreatorUtils.getDockerRegistry(ID_3, ANOTHER_SIMPLE_USER);\n+        dockerRegistryList.setRegistries(Arrays.asList(dockerRegistryWithTools, anotherRegistry));\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n+\n+        final DockerRegistry returnedDr = (DockerRegistry) dockerRegistryApiService\n+                .loadAllRegistriesContent().getChildren().get(0);\n+\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+        assertThat(dockerRegistryApiService.loadAllRegistriesContent().getChildren().size()).isEqualTo(1);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadDockerRegistry() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).load(ID);\n+\n+        assertThat(dockerRegistryApiService.load(ID)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldLoadDockerRegistryHierarchy() {\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager).load(ID);\n+\n+        final DockerRegistry returnedDr = dockerRegistryApiService.load(ID);\n+\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldDeleteDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).delete(ID, true);\n+\n+        assertThat(dockerRegistryApiService.delete(ID, true)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDeleteDockerRegistryWhenPermissionIsGranted() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).delete(ID, true);\n+        initAclEntity(dockerRegistry, AclPermission.WRITE);\n+\n+        assertThat(dockerRegistryApiService.delete(ID, true)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyDeleteDockerRegistryWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.delete(ID, true));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldNotifyDockerRegistryEventsForAdmin() {\n+        doReturn(tools).when(mockDockerRegistryManager).notifyDockerRegistryEvents(TEST_STRING, eventEnvelope);\n+\n+        assertThat(dockerRegistryApiService.notifyDockerRegistryEvents(TEST_STRING, eventEnvelope)).isEqualTo(tools);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyNotifyDockerRegistryEventsForNotAdmin() {\n+        doReturn(tools).when(mockDockerRegistryManager).notifyDockerRegistryEvents(TEST_STRING, eventEnvelope);\n+\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.notifyDockerRegistryEvents(TEST_STRING, eventEnvelope));\n+    }\n+\n+    @Test\n+    public void shouldIssueTokenForDockerRegistry() {\n+        doReturn(jwtRawToken).when(mockDockerRegistryManager)\n+                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING);\n+\n+        assertThat(dockerRegistryApiService\n+                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING))\n+                .isEqualTo(jwtRawToken);\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldGetCertificateContentForAdmin() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getCertificateContent(ID);\n+\n+        assertThat(dockerRegistryApiService.getCertificateContent(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldGetCertificateContentWhenPermissionIsGranted() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getCertificateContent(ID);\n+        initAclEntity(dockerRegistry, AclPermission.READ);\n+\n+        assertThat(dockerRegistryApiService.getCertificateContent(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyGetCertificateContentWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.getCertificateContent(ID));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldGetConfigScript() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getConfigScript(ID);\n+\n+        assertThat(dockerRegistryApiService.getConfigScript(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldGetConfigScriptWhenPermissionIsGranted() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getConfigScript(ID);\n+        initAclEntity(dockerRegistry, AclPermission.READ);\n+\n+        assertThat(dockerRegistryApiService.getConfigScript(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyGetConfigScriptWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.getConfigScript(ID));\n+    }\n+\n+    private void initDockerRegistryAclTree() {\n+        toolGroup.setTools(toolList);\n+        toolGroupWithoutPermission.setTools(toolList);\n+        dockerRegistryWithTools.setGroups(toolGroups);", "originalCommit": "c3103f3f4623dae614b7ca813920a21f643d8c0a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk5NjE5OA==", "url": "https://github.com/epam/cloud-pipeline/pull/1544#discussion_r525996198", "bodyText": "Maybe assertThat(dockerRegistryChildren).containsAll(toolGroups); would be enough?", "author": "ekazachkova", "createdAt": "2020-11-18T10:59:03Z", "path": "api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java", "diffHunk": "@@ -0,0 +1,363 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.acl.docker;\n+\n+import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n+import com.epam.pipeline.entity.AbstractHierarchicalEntity;\n+import com.epam.pipeline.entity.AbstractSecuredEntity;\n+import com.epam.pipeline.entity.docker.DockerRegistryList;\n+import com.epam.pipeline.entity.pipeline.DockerRegistry;\n+import com.epam.pipeline.entity.pipeline.DockerRegistryEventEnvelope;\n+import com.epam.pipeline.entity.pipeline.Tool;\n+import com.epam.pipeline.entity.pipeline.ToolGroup;\n+import com.epam.pipeline.entity.security.JwtRawToken;\n+import com.epam.pipeline.manager.docker.DockerRegistryManager;\n+import com.epam.pipeline.security.acl.AclPermission;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.docker.DockerCreatorUtils;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.test.context.support.WithMockUser;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_2;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_3;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.doReturn;\n+\n+public class DockerRegistryApiServiceTest extends AbstractAclTest {\n+\n+    private static final byte[] BYTE_RESULT = TEST_STRING.getBytes();\n+    private final DockerRegistry dockerRegistry = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n+    private final DockerRegistryVO dockerRegistryVO = DockerCreatorUtils.getDockerRegistryVO();\n+    private final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+    private final Tool tool = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n+    private final List<Tool> tools = Collections.singletonList(tool);\n+    private final DockerRegistryEventEnvelope eventEnvelope = DockerCreatorUtils.getDockerRegistryEventEnvelope();\n+    private final JwtRawToken jwtRawToken = new JwtRawToken(TEST_STRING);\n+    private final DockerRegistry dockerRegistryWithTools = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n+    private final ToolGroup toolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ANOTHER_SIMPLE_USER);\n+    private final ToolGroup toolGroup = DockerCreatorUtils.getToolGroup(ID_2, ANOTHER_SIMPLE_USER);\n+    private final ToolGroup emptyToolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ID_3, ANOTHER_SIMPLE_USER);\n+    private final Tool toolRead = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n+    private final Tool toolWithoutPermission = DockerCreatorUtils.getTool(ID_2, ANOTHER_SIMPLE_USER);\n+    private final List<Tool> toolList = Arrays.asList(toolRead, toolWithoutPermission);\n+    private final List<ToolGroup> toolGroups =\n+            Arrays.asList(toolGroup, toolGroupWithoutPermission, emptyToolGroupWithoutPermission);\n+\n+\n+    @Autowired\n+    private DockerRegistryApiService dockerRegistryApiService;\n+\n+    @Autowired\n+    private DockerRegistryManager mockDockerRegistryManager;\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldCreateDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).create(dockerRegistryVO);\n+\n+        assertThat(dockerRegistryApiService.create(dockerRegistryVO)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyCreateDockerRegistryForNonAdminUser() {\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.create(dockerRegistryVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateDockerRegistryWhenPermissionIsGranted() {\n+        initAclEntity(dockerRegistry, AclPermission.WRITE);\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateDockerRegistryHierarchyWhenPermissionIsGranted() {\n+        initDockerRegistryAclTree();\n+        initAclEntity(dockerRegistryWithTools, AclPermission.WRITE);\n+        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistryWithTools);\n+\n+        final DockerRegistry returnedDr = dockerRegistryApiService.updateDockerRegistry(dockerRegistryWithTools);\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyUpdateDockerRegistryWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.updateDockerRegistry(dockerRegistry));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateDockerRegistryCredentialsForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO))\n+                .isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyUpdateDockerRegistryCredentialsForNonAdminUser() {\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateWholeDockerRegistryHierarchyCredentialsForAdmin() {\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager)\n+                .updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        final DockerRegistry returnedDr = dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        assertWholeDockerRegistryAclTree(returnedDr);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldListDockerRegistriesWithCerts() {\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n+\n+        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts()).isEqualTo(dockerRegistryList);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldListDockerRegistryHierarchyWithCerts() {\n+        final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+        final DockerRegistry anotherRegistry = DockerCreatorUtils.getDockerRegistry(ID_3, ANOTHER_SIMPLE_USER);\n+        dockerRegistryList.setRegistries(Arrays.asList(dockerRegistryWithTools, anotherRegistry));\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n+\n+        final DockerRegistry returnedDr = (DockerRegistry) dockerRegistryApiService\n+                .listDockerRegistriesWithCerts().getChildren().get(0);\n+\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts().getChildren().size()).isEqualTo(1);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadAllRegistriesContent() {\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n+\n+        assertThat(dockerRegistryApiService.loadAllRegistriesContent()).isEqualTo(dockerRegistryList);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldLoadAllRegistriesHierarchyContent() {\n+        final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+        final DockerRegistry anotherRegistry = DockerCreatorUtils.getDockerRegistry(ID_3, ANOTHER_SIMPLE_USER);\n+        dockerRegistryList.setRegistries(Arrays.asList(dockerRegistryWithTools, anotherRegistry));\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n+\n+        final DockerRegistry returnedDr = (DockerRegistry) dockerRegistryApiService\n+                .loadAllRegistriesContent().getChildren().get(0);\n+\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+        assertThat(dockerRegistryApiService.loadAllRegistriesContent().getChildren().size()).isEqualTo(1);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadDockerRegistry() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).load(ID);\n+\n+        assertThat(dockerRegistryApiService.load(ID)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldLoadDockerRegistryHierarchy() {\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager).load(ID);\n+\n+        final DockerRegistry returnedDr = dockerRegistryApiService.load(ID);\n+\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldDeleteDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).delete(ID, true);\n+\n+        assertThat(dockerRegistryApiService.delete(ID, true)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDeleteDockerRegistryWhenPermissionIsGranted() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).delete(ID, true);\n+        initAclEntity(dockerRegistry, AclPermission.WRITE);\n+\n+        assertThat(dockerRegistryApiService.delete(ID, true)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyDeleteDockerRegistryWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.delete(ID, true));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldNotifyDockerRegistryEventsForAdmin() {\n+        doReturn(tools).when(mockDockerRegistryManager).notifyDockerRegistryEvents(TEST_STRING, eventEnvelope);\n+\n+        assertThat(dockerRegistryApiService.notifyDockerRegistryEvents(TEST_STRING, eventEnvelope)).isEqualTo(tools);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyNotifyDockerRegistryEventsForNotAdmin() {\n+        doReturn(tools).when(mockDockerRegistryManager).notifyDockerRegistryEvents(TEST_STRING, eventEnvelope);\n+\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.notifyDockerRegistryEvents(TEST_STRING, eventEnvelope));\n+    }\n+\n+    @Test\n+    public void shouldIssueTokenForDockerRegistry() {\n+        doReturn(jwtRawToken).when(mockDockerRegistryManager)\n+                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING);\n+\n+        assertThat(dockerRegistryApiService\n+                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING))\n+                .isEqualTo(jwtRawToken);\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldGetCertificateContentForAdmin() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getCertificateContent(ID);\n+\n+        assertThat(dockerRegistryApiService.getCertificateContent(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldGetCertificateContentWhenPermissionIsGranted() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getCertificateContent(ID);\n+        initAclEntity(dockerRegistry, AclPermission.READ);\n+\n+        assertThat(dockerRegistryApiService.getCertificateContent(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyGetCertificateContentWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.getCertificateContent(ID));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldGetConfigScript() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getConfigScript(ID);\n+\n+        assertThat(dockerRegistryApiService.getConfigScript(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldGetConfigScriptWhenPermissionIsGranted() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getConfigScript(ID);\n+        initAclEntity(dockerRegistry, AclPermission.READ);\n+\n+        assertThat(dockerRegistryApiService.getConfigScript(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyGetConfigScriptWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.getConfigScript(ID));\n+    }\n+\n+    private void initDockerRegistryAclTree() {\n+        toolGroup.setTools(toolList);\n+        toolGroupWithoutPermission.setTools(toolList);\n+        dockerRegistryWithTools.setGroups(toolGroups);\n+        initAclEntity(toolRead, AclPermission.READ);\n+        initAclEntity(toolWithoutPermission);\n+        initAclEntity(toolGroup, AclPermission.READ);\n+        initAclEntity(toolGroupWithoutPermission);\n+        initAclEntity(emptyToolGroupWithoutPermission, AclPermission.READ);\n+    }\n+\n+    private void assertPartialDockerRegistryAclTree(final DockerRegistry registry) {\n+        assertDockerRegistryAclHierarchy(registry);\n+        final List<? extends AbstractSecuredEntity> toolGroupWithoutPermissionLeaves =\n+                registry.getChildren().get(1).getLeaves();\n+        assertThat(toolGroupWithoutPermissionLeaves.size()).isEqualTo(1);\n+        assertThat(toolGroupWithoutPermissionLeaves.get(0)).isEqualTo(toolRead);\n+    }\n+\n+    private void assertWholeDockerRegistryAclTree(final DockerRegistry registry) {\n+        assertDockerRegistryAclHierarchy(registry);\n+        final List<? extends AbstractSecuredEntity> toolGroupWithoutPermissionLeaves =\n+                registry.getChildren().get(1).getLeaves();\n+\n+        assertThat(toolGroupWithoutPermissionLeaves.size()).isEqualTo(toolList.size());\n+        assertThat(toolGroupWithoutPermissionLeaves).isEqualTo(toolList);\n+    }\n+\n+    private void assertDockerRegistryAclHierarchy(final DockerRegistry registry) {\n+        final List<AbstractHierarchicalEntity> dockerRegistryChildren = registry.getChildren();\n+        final List<? extends AbstractSecuredEntity> toolGroupLeaves = registry.getChildren().get(0).getLeaves();\n+        final List<? extends AbstractSecuredEntity> emptyToolGroupLeaves = registry.getChildren().get(2).getLeaves();\n+\n+        assertThat(dockerRegistryChildren.size()).isEqualTo(toolGroups.size());", "originalCommit": "c3103f3f4623dae614b7ca813920a21f643d8c0a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjAwMDIxNQ==", "url": "https://github.com/epam/cloud-pipeline/pull/1544#discussion_r526000215", "bodyText": "If so, could you please check it for other places? (and think about common method)", "author": "ekazachkova", "createdAt": "2020-11-18T11:05:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk5NjE5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjAwMDUxMQ==", "url": "https://github.com/epam/cloud-pipeline/pull/1544#discussion_r526000511", "bodyText": "Could we use hasSize here?", "author": "ekazachkova", "createdAt": "2020-11-18T11:05:47Z", "path": "api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java", "diffHunk": "@@ -0,0 +1,363 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.acl.docker;\n+\n+import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n+import com.epam.pipeline.entity.AbstractHierarchicalEntity;\n+import com.epam.pipeline.entity.AbstractSecuredEntity;\n+import com.epam.pipeline.entity.docker.DockerRegistryList;\n+import com.epam.pipeline.entity.pipeline.DockerRegistry;\n+import com.epam.pipeline.entity.pipeline.DockerRegistryEventEnvelope;\n+import com.epam.pipeline.entity.pipeline.Tool;\n+import com.epam.pipeline.entity.pipeline.ToolGroup;\n+import com.epam.pipeline.entity.security.JwtRawToken;\n+import com.epam.pipeline.manager.docker.DockerRegistryManager;\n+import com.epam.pipeline.security.acl.AclPermission;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.docker.DockerCreatorUtils;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.test.context.support.WithMockUser;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_2;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_3;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.doReturn;\n+\n+public class DockerRegistryApiServiceTest extends AbstractAclTest {\n+\n+    private static final byte[] BYTE_RESULT = TEST_STRING.getBytes();\n+    private final DockerRegistry dockerRegistry = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n+    private final DockerRegistryVO dockerRegistryVO = DockerCreatorUtils.getDockerRegistryVO();\n+    private final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+    private final Tool tool = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n+    private final List<Tool> tools = Collections.singletonList(tool);\n+    private final DockerRegistryEventEnvelope eventEnvelope = DockerCreatorUtils.getDockerRegistryEventEnvelope();\n+    private final JwtRawToken jwtRawToken = new JwtRawToken(TEST_STRING);\n+    private final DockerRegistry dockerRegistryWithTools = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n+    private final ToolGroup toolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ANOTHER_SIMPLE_USER);\n+    private final ToolGroup toolGroup = DockerCreatorUtils.getToolGroup(ID_2, ANOTHER_SIMPLE_USER);\n+    private final ToolGroup emptyToolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ID_3, ANOTHER_SIMPLE_USER);\n+    private final Tool toolRead = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n+    private final Tool toolWithoutPermission = DockerCreatorUtils.getTool(ID_2, ANOTHER_SIMPLE_USER);\n+    private final List<Tool> toolList = Arrays.asList(toolRead, toolWithoutPermission);\n+    private final List<ToolGroup> toolGroups =\n+            Arrays.asList(toolGroup, toolGroupWithoutPermission, emptyToolGroupWithoutPermission);\n+\n+\n+    @Autowired\n+    private DockerRegistryApiService dockerRegistryApiService;\n+\n+    @Autowired\n+    private DockerRegistryManager mockDockerRegistryManager;\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldCreateDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).create(dockerRegistryVO);\n+\n+        assertThat(dockerRegistryApiService.create(dockerRegistryVO)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyCreateDockerRegistryForNonAdminUser() {\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.create(dockerRegistryVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateDockerRegistryWhenPermissionIsGranted() {\n+        initAclEntity(dockerRegistry, AclPermission.WRITE);\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateDockerRegistryHierarchyWhenPermissionIsGranted() {\n+        initDockerRegistryAclTree();\n+        initAclEntity(dockerRegistryWithTools, AclPermission.WRITE);\n+        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistryWithTools);\n+\n+        final DockerRegistry returnedDr = dockerRegistryApiService.updateDockerRegistry(dockerRegistryWithTools);\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyUpdateDockerRegistryWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.updateDockerRegistry(dockerRegistry));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateDockerRegistryCredentialsForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO))\n+                .isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyUpdateDockerRegistryCredentialsForNonAdminUser() {\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateWholeDockerRegistryHierarchyCredentialsForAdmin() {\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager)\n+                .updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        final DockerRegistry returnedDr = dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        assertWholeDockerRegistryAclTree(returnedDr);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldListDockerRegistriesWithCerts() {\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n+\n+        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts()).isEqualTo(dockerRegistryList);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldListDockerRegistryHierarchyWithCerts() {\n+        final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+        final DockerRegistry anotherRegistry = DockerCreatorUtils.getDockerRegistry(ID_3, ANOTHER_SIMPLE_USER);\n+        dockerRegistryList.setRegistries(Arrays.asList(dockerRegistryWithTools, anotherRegistry));\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n+\n+        final DockerRegistry returnedDr = (DockerRegistry) dockerRegistryApiService\n+                .listDockerRegistriesWithCerts().getChildren().get(0);\n+\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts().getChildren().size()).isEqualTo(1);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadAllRegistriesContent() {\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n+\n+        assertThat(dockerRegistryApiService.loadAllRegistriesContent()).isEqualTo(dockerRegistryList);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldLoadAllRegistriesHierarchyContent() {\n+        final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+        final DockerRegistry anotherRegistry = DockerCreatorUtils.getDockerRegistry(ID_3, ANOTHER_SIMPLE_USER);\n+        dockerRegistryList.setRegistries(Arrays.asList(dockerRegistryWithTools, anotherRegistry));\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n+\n+        final DockerRegistry returnedDr = (DockerRegistry) dockerRegistryApiService\n+                .loadAllRegistriesContent().getChildren().get(0);\n+\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+        assertThat(dockerRegistryApiService.loadAllRegistriesContent().getChildren().size()).isEqualTo(1);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadDockerRegistry() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).load(ID);\n+\n+        assertThat(dockerRegistryApiService.load(ID)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldLoadDockerRegistryHierarchy() {\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager).load(ID);\n+\n+        final DockerRegistry returnedDr = dockerRegistryApiService.load(ID);\n+\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldDeleteDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).delete(ID, true);\n+\n+        assertThat(dockerRegistryApiService.delete(ID, true)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDeleteDockerRegistryWhenPermissionIsGranted() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).delete(ID, true);\n+        initAclEntity(dockerRegistry, AclPermission.WRITE);\n+\n+        assertThat(dockerRegistryApiService.delete(ID, true)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyDeleteDockerRegistryWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.delete(ID, true));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldNotifyDockerRegistryEventsForAdmin() {\n+        doReturn(tools).when(mockDockerRegistryManager).notifyDockerRegistryEvents(TEST_STRING, eventEnvelope);\n+\n+        assertThat(dockerRegistryApiService.notifyDockerRegistryEvents(TEST_STRING, eventEnvelope)).isEqualTo(tools);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyNotifyDockerRegistryEventsForNotAdmin() {\n+        doReturn(tools).when(mockDockerRegistryManager).notifyDockerRegistryEvents(TEST_STRING, eventEnvelope);\n+\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.notifyDockerRegistryEvents(TEST_STRING, eventEnvelope));\n+    }\n+\n+    @Test\n+    public void shouldIssueTokenForDockerRegistry() {\n+        doReturn(jwtRawToken).when(mockDockerRegistryManager)\n+                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING);\n+\n+        assertThat(dockerRegistryApiService\n+                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING))\n+                .isEqualTo(jwtRawToken);\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldGetCertificateContentForAdmin() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getCertificateContent(ID);\n+\n+        assertThat(dockerRegistryApiService.getCertificateContent(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldGetCertificateContentWhenPermissionIsGranted() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getCertificateContent(ID);\n+        initAclEntity(dockerRegistry, AclPermission.READ);\n+\n+        assertThat(dockerRegistryApiService.getCertificateContent(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyGetCertificateContentWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.getCertificateContent(ID));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldGetConfigScript() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getConfigScript(ID);\n+\n+        assertThat(dockerRegistryApiService.getConfigScript(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldGetConfigScriptWhenPermissionIsGranted() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getConfigScript(ID);\n+        initAclEntity(dockerRegistry, AclPermission.READ);\n+\n+        assertThat(dockerRegistryApiService.getConfigScript(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyGetConfigScriptWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.getConfigScript(ID));\n+    }\n+\n+    private void initDockerRegistryAclTree() {\n+        toolGroup.setTools(toolList);\n+        toolGroupWithoutPermission.setTools(toolList);\n+        dockerRegistryWithTools.setGroups(toolGroups);\n+        initAclEntity(toolRead, AclPermission.READ);\n+        initAclEntity(toolWithoutPermission);\n+        initAclEntity(toolGroup, AclPermission.READ);\n+        initAclEntity(toolGroupWithoutPermission);\n+        initAclEntity(emptyToolGroupWithoutPermission, AclPermission.READ);\n+    }\n+\n+    private void assertPartialDockerRegistryAclTree(final DockerRegistry registry) {\n+        assertDockerRegistryAclHierarchy(registry);\n+        final List<? extends AbstractSecuredEntity> toolGroupWithoutPermissionLeaves =\n+                registry.getChildren().get(1).getLeaves();\n+        assertThat(toolGroupWithoutPermissionLeaves.size()).isEqualTo(1);", "originalCommit": "c3103f3f4623dae614b7ca813920a21f643d8c0a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjAwMzM5NQ==", "url": "https://github.com/epam/cloud-pipeline/pull/1544#discussion_r526003395", "bodyText": "If so, could you please fix it for other methods?", "author": "ekazachkova", "createdAt": "2020-11-18T11:10:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjAwMDUxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjAwNzM1MA==", "url": "https://github.com/epam/cloud-pipeline/pull/1544#discussion_r526007350", "bodyText": "Could we store dockerRegistryApiService.loadAllRegistriesContent().getChildren() into the local field?", "author": "ekazachkova", "createdAt": "2020-11-18T11:17:01Z", "path": "api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java", "diffHunk": "@@ -0,0 +1,363 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.acl.docker;\n+\n+import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n+import com.epam.pipeline.entity.AbstractHierarchicalEntity;\n+import com.epam.pipeline.entity.AbstractSecuredEntity;\n+import com.epam.pipeline.entity.docker.DockerRegistryList;\n+import com.epam.pipeline.entity.pipeline.DockerRegistry;\n+import com.epam.pipeline.entity.pipeline.DockerRegistryEventEnvelope;\n+import com.epam.pipeline.entity.pipeline.Tool;\n+import com.epam.pipeline.entity.pipeline.ToolGroup;\n+import com.epam.pipeline.entity.security.JwtRawToken;\n+import com.epam.pipeline.manager.docker.DockerRegistryManager;\n+import com.epam.pipeline.security.acl.AclPermission;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.docker.DockerCreatorUtils;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.test.context.support.WithMockUser;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_2;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_3;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.doReturn;\n+\n+public class DockerRegistryApiServiceTest extends AbstractAclTest {\n+\n+    private static final byte[] BYTE_RESULT = TEST_STRING.getBytes();\n+    private final DockerRegistry dockerRegistry = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n+    private final DockerRegistryVO dockerRegistryVO = DockerCreatorUtils.getDockerRegistryVO();\n+    private final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+    private final Tool tool = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n+    private final List<Tool> tools = Collections.singletonList(tool);\n+    private final DockerRegistryEventEnvelope eventEnvelope = DockerCreatorUtils.getDockerRegistryEventEnvelope();\n+    private final JwtRawToken jwtRawToken = new JwtRawToken(TEST_STRING);\n+    private final DockerRegistry dockerRegistryWithTools = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n+    private final ToolGroup toolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ANOTHER_SIMPLE_USER);\n+    private final ToolGroup toolGroup = DockerCreatorUtils.getToolGroup(ID_2, ANOTHER_SIMPLE_USER);\n+    private final ToolGroup emptyToolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ID_3, ANOTHER_SIMPLE_USER);\n+    private final Tool toolRead = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n+    private final Tool toolWithoutPermission = DockerCreatorUtils.getTool(ID_2, ANOTHER_SIMPLE_USER);\n+    private final List<Tool> toolList = Arrays.asList(toolRead, toolWithoutPermission);\n+    private final List<ToolGroup> toolGroups =\n+            Arrays.asList(toolGroup, toolGroupWithoutPermission, emptyToolGroupWithoutPermission);\n+\n+\n+    @Autowired\n+    private DockerRegistryApiService dockerRegistryApiService;\n+\n+    @Autowired\n+    private DockerRegistryManager mockDockerRegistryManager;\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldCreateDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).create(dockerRegistryVO);\n+\n+        assertThat(dockerRegistryApiService.create(dockerRegistryVO)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyCreateDockerRegistryForNonAdminUser() {\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.create(dockerRegistryVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateDockerRegistryWhenPermissionIsGranted() {\n+        initAclEntity(dockerRegistry, AclPermission.WRITE);\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateDockerRegistryHierarchyWhenPermissionIsGranted() {\n+        initDockerRegistryAclTree();\n+        initAclEntity(dockerRegistryWithTools, AclPermission.WRITE);\n+        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistryWithTools);\n+\n+        final DockerRegistry returnedDr = dockerRegistryApiService.updateDockerRegistry(dockerRegistryWithTools);\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyUpdateDockerRegistryWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.updateDockerRegistry(dockerRegistry));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateDockerRegistryCredentialsForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO))\n+                .isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyUpdateDockerRegistryCredentialsForNonAdminUser() {\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateWholeDockerRegistryHierarchyCredentialsForAdmin() {\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager)\n+                .updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        final DockerRegistry returnedDr = dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        assertWholeDockerRegistryAclTree(returnedDr);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldListDockerRegistriesWithCerts() {\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n+\n+        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts()).isEqualTo(dockerRegistryList);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldListDockerRegistryHierarchyWithCerts() {\n+        final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+        final DockerRegistry anotherRegistry = DockerCreatorUtils.getDockerRegistry(ID_3, ANOTHER_SIMPLE_USER);\n+        dockerRegistryList.setRegistries(Arrays.asList(dockerRegistryWithTools, anotherRegistry));\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n+\n+        final DockerRegistry returnedDr = (DockerRegistry) dockerRegistryApiService\n+                .listDockerRegistriesWithCerts().getChildren().get(0);\n+\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts().getChildren().size()).isEqualTo(1);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadAllRegistriesContent() {\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n+\n+        assertThat(dockerRegistryApiService.loadAllRegistriesContent()).isEqualTo(dockerRegistryList);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldLoadAllRegistriesHierarchyContent() {\n+        final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+        final DockerRegistry anotherRegistry = DockerCreatorUtils.getDockerRegistry(ID_3, ANOTHER_SIMPLE_USER);\n+        dockerRegistryList.setRegistries(Arrays.asList(dockerRegistryWithTools, anotherRegistry));\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n+\n+        final DockerRegistry returnedDr = (DockerRegistry) dockerRegistryApiService", "originalCommit": "c3103f3f4623dae614b7ca813920a21f643d8c0a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjAxMDM2NA==", "url": "https://github.com/epam/cloud-pipeline/pull/1544#discussion_r526010364", "bodyText": "Is it possible to rename this method to more clear?", "author": "ekazachkova", "createdAt": "2020-11-18T11:21:59Z", "path": "api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java", "diffHunk": "@@ -0,0 +1,363 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.acl.docker;\n+\n+import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n+import com.epam.pipeline.entity.AbstractHierarchicalEntity;\n+import com.epam.pipeline.entity.AbstractSecuredEntity;\n+import com.epam.pipeline.entity.docker.DockerRegistryList;\n+import com.epam.pipeline.entity.pipeline.DockerRegistry;\n+import com.epam.pipeline.entity.pipeline.DockerRegistryEventEnvelope;\n+import com.epam.pipeline.entity.pipeline.Tool;\n+import com.epam.pipeline.entity.pipeline.ToolGroup;\n+import com.epam.pipeline.entity.security.JwtRawToken;\n+import com.epam.pipeline.manager.docker.DockerRegistryManager;\n+import com.epam.pipeline.security.acl.AclPermission;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.docker.DockerCreatorUtils;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.test.context.support.WithMockUser;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_2;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_3;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.doReturn;\n+\n+public class DockerRegistryApiServiceTest extends AbstractAclTest {\n+\n+    private static final byte[] BYTE_RESULT = TEST_STRING.getBytes();\n+    private final DockerRegistry dockerRegistry = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n+    private final DockerRegistryVO dockerRegistryVO = DockerCreatorUtils.getDockerRegistryVO();\n+    private final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+    private final Tool tool = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n+    private final List<Tool> tools = Collections.singletonList(tool);\n+    private final DockerRegistryEventEnvelope eventEnvelope = DockerCreatorUtils.getDockerRegistryEventEnvelope();\n+    private final JwtRawToken jwtRawToken = new JwtRawToken(TEST_STRING);\n+    private final DockerRegistry dockerRegistryWithTools = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n+    private final ToolGroup toolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ANOTHER_SIMPLE_USER);\n+    private final ToolGroup toolGroup = DockerCreatorUtils.getToolGroup(ID_2, ANOTHER_SIMPLE_USER);\n+    private final ToolGroup emptyToolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ID_3, ANOTHER_SIMPLE_USER);\n+    private final Tool toolRead = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n+    private final Tool toolWithoutPermission = DockerCreatorUtils.getTool(ID_2, ANOTHER_SIMPLE_USER);\n+    private final List<Tool> toolList = Arrays.asList(toolRead, toolWithoutPermission);\n+    private final List<ToolGroup> toolGroups =\n+            Arrays.asList(toolGroup, toolGroupWithoutPermission, emptyToolGroupWithoutPermission);\n+\n+\n+    @Autowired\n+    private DockerRegistryApiService dockerRegistryApiService;\n+\n+    @Autowired\n+    private DockerRegistryManager mockDockerRegistryManager;\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldCreateDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).create(dockerRegistryVO);\n+\n+        assertThat(dockerRegistryApiService.create(dockerRegistryVO)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyCreateDockerRegistryForNonAdminUser() {\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.create(dockerRegistryVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateDockerRegistryWhenPermissionIsGranted() {\n+        initAclEntity(dockerRegistry, AclPermission.WRITE);\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateDockerRegistryHierarchyWhenPermissionIsGranted() {\n+        initDockerRegistryAclTree();\n+        initAclEntity(dockerRegistryWithTools, AclPermission.WRITE);\n+        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistryWithTools);\n+\n+        final DockerRegistry returnedDr = dockerRegistryApiService.updateDockerRegistry(dockerRegistryWithTools);\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyUpdateDockerRegistryWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.updateDockerRegistry(dockerRegistry));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateDockerRegistryCredentialsForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO))\n+                .isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyUpdateDockerRegistryCredentialsForNonAdminUser() {\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateWholeDockerRegistryHierarchyCredentialsForAdmin() {\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager)\n+                .updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        final DockerRegistry returnedDr = dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        assertWholeDockerRegistryAclTree(returnedDr);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldListDockerRegistriesWithCerts() {\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n+\n+        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts()).isEqualTo(dockerRegistryList);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldListDockerRegistryHierarchyWithCerts() {\n+        final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+        final DockerRegistry anotherRegistry = DockerCreatorUtils.getDockerRegistry(ID_3, ANOTHER_SIMPLE_USER);\n+        dockerRegistryList.setRegistries(Arrays.asList(dockerRegistryWithTools, anotherRegistry));\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n+\n+        final DockerRegistry returnedDr = (DockerRegistry) dockerRegistryApiService\n+                .listDockerRegistriesWithCerts().getChildren().get(0);\n+\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts().getChildren().size()).isEqualTo(1);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadAllRegistriesContent() {\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n+\n+        assertThat(dockerRegistryApiService.loadAllRegistriesContent()).isEqualTo(dockerRegistryList);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldLoadAllRegistriesHierarchyContent() {\n+        final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+        final DockerRegistry anotherRegistry = DockerCreatorUtils.getDockerRegistry(ID_3, ANOTHER_SIMPLE_USER);\n+        dockerRegistryList.setRegistries(Arrays.asList(dockerRegistryWithTools, anotherRegistry));\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n+\n+        final DockerRegistry returnedDr = (DockerRegistry) dockerRegistryApiService\n+                .loadAllRegistriesContent().getChildren().get(0);\n+\n+        assertPartialDockerRegistryAclTree(returnedDr);", "originalCommit": "c3103f3f4623dae614b7ca813920a21f643d8c0a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjAxNzAxMQ==", "url": "https://github.com/epam/cloud-pipeline/pull/1544#discussion_r526017011", "bodyText": "Could we refactor this logic somehow: list.get(index) is not clear? (Maybe pick methods for each requested entity? by Id?)", "author": "ekazachkova", "createdAt": "2020-11-18T11:33:15Z", "path": "api/src/test/java/com/epam/pipeline/acl/docker/DockerRegistryApiServiceTest.java", "diffHunk": "@@ -0,0 +1,363 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.acl.docker;\n+\n+import com.epam.pipeline.controller.vo.docker.DockerRegistryVO;\n+import com.epam.pipeline.entity.AbstractHierarchicalEntity;\n+import com.epam.pipeline.entity.AbstractSecuredEntity;\n+import com.epam.pipeline.entity.docker.DockerRegistryList;\n+import com.epam.pipeline.entity.pipeline.DockerRegistry;\n+import com.epam.pipeline.entity.pipeline.DockerRegistryEventEnvelope;\n+import com.epam.pipeline.entity.pipeline.Tool;\n+import com.epam.pipeline.entity.pipeline.ToolGroup;\n+import com.epam.pipeline.entity.security.JwtRawToken;\n+import com.epam.pipeline.manager.docker.DockerRegistryManager;\n+import com.epam.pipeline.security.acl.AclPermission;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.docker.DockerCreatorUtils;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.test.context.support.WithMockUser;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_2;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_3;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.doReturn;\n+\n+public class DockerRegistryApiServiceTest extends AbstractAclTest {\n+\n+    private static final byte[] BYTE_RESULT = TEST_STRING.getBytes();\n+    private final DockerRegistry dockerRegistry = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n+    private final DockerRegistryVO dockerRegistryVO = DockerCreatorUtils.getDockerRegistryVO();\n+    private final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+    private final Tool tool = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n+    private final List<Tool> tools = Collections.singletonList(tool);\n+    private final DockerRegistryEventEnvelope eventEnvelope = DockerCreatorUtils.getDockerRegistryEventEnvelope();\n+    private final JwtRawToken jwtRawToken = new JwtRawToken(TEST_STRING);\n+    private final DockerRegistry dockerRegistryWithTools = DockerCreatorUtils.getDockerRegistry(ANOTHER_SIMPLE_USER);\n+    private final ToolGroup toolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ANOTHER_SIMPLE_USER);\n+    private final ToolGroup toolGroup = DockerCreatorUtils.getToolGroup(ID_2, ANOTHER_SIMPLE_USER);\n+    private final ToolGroup emptyToolGroupWithoutPermission = DockerCreatorUtils.getToolGroup(ID_3, ANOTHER_SIMPLE_USER);\n+    private final Tool toolRead = DockerCreatorUtils.getTool(ANOTHER_SIMPLE_USER);\n+    private final Tool toolWithoutPermission = DockerCreatorUtils.getTool(ID_2, ANOTHER_SIMPLE_USER);\n+    private final List<Tool> toolList = Arrays.asList(toolRead, toolWithoutPermission);\n+    private final List<ToolGroup> toolGroups =\n+            Arrays.asList(toolGroup, toolGroupWithoutPermission, emptyToolGroupWithoutPermission);\n+\n+\n+    @Autowired\n+    private DockerRegistryApiService dockerRegistryApiService;\n+\n+    @Autowired\n+    private DockerRegistryManager mockDockerRegistryManager;\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldCreateDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).create(dockerRegistryVO);\n+\n+        assertThat(dockerRegistryApiService.create(dockerRegistryVO)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyCreateDockerRegistryForNonAdminUser() {\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.create(dockerRegistryVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateDockerRegistryWhenPermissionIsGranted() {\n+        initAclEntity(dockerRegistry, AclPermission.WRITE);\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistry);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistry(dockerRegistry)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateDockerRegistryHierarchyWhenPermissionIsGranted() {\n+        initDockerRegistryAclTree();\n+        initAclEntity(dockerRegistryWithTools, AclPermission.WRITE);\n+        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager).updateDockerRegistry(dockerRegistryWithTools);\n+\n+        final DockerRegistry returnedDr = dockerRegistryApiService.updateDockerRegistry(dockerRegistryWithTools);\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyUpdateDockerRegistryWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.updateDockerRegistry(dockerRegistry));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateDockerRegistryCredentialsForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        assertThat(dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO))\n+                .isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyUpdateDockerRegistryCredentialsForNonAdminUser() {\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateWholeDockerRegistryHierarchyCredentialsForAdmin() {\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager)\n+                .updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        final DockerRegistry returnedDr = dockerRegistryApiService.updateDockerRegistryCredentials(dockerRegistryVO);\n+\n+        assertWholeDockerRegistryAclTree(returnedDr);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldListDockerRegistriesWithCerts() {\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n+\n+        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts()).isEqualTo(dockerRegistryList);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldListDockerRegistryHierarchyWithCerts() {\n+        final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+        final DockerRegistry anotherRegistry = DockerCreatorUtils.getDockerRegistry(ID_3, ANOTHER_SIMPLE_USER);\n+        dockerRegistryList.setRegistries(Arrays.asList(dockerRegistryWithTools, anotherRegistry));\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).listAllDockerRegistriesWithCerts();\n+\n+        final DockerRegistry returnedDr = (DockerRegistry) dockerRegistryApiService\n+                .listDockerRegistriesWithCerts().getChildren().get(0);\n+\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+        assertThat(dockerRegistryApiService.listDockerRegistriesWithCerts().getChildren().size()).isEqualTo(1);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadAllRegistriesContent() {\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n+\n+        assertThat(dockerRegistryApiService.loadAllRegistriesContent()).isEqualTo(dockerRegistryList);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldLoadAllRegistriesHierarchyContent() {\n+        final DockerRegistryList dockerRegistryList = DockerCreatorUtils.getDockerRegistryList(dockerRegistry);\n+        final DockerRegistry anotherRegistry = DockerCreatorUtils.getDockerRegistry(ID_3, ANOTHER_SIMPLE_USER);\n+        dockerRegistryList.setRegistries(Arrays.asList(dockerRegistryWithTools, anotherRegistry));\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryList).when(mockDockerRegistryManager).loadAllRegistriesContent();\n+\n+        final DockerRegistry returnedDr = (DockerRegistry) dockerRegistryApiService\n+                .loadAllRegistriesContent().getChildren().get(0);\n+\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+        assertThat(dockerRegistryApiService.loadAllRegistriesContent().getChildren().size()).isEqualTo(1);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadDockerRegistry() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).load(ID);\n+\n+        assertThat(dockerRegistryApiService.load(ID)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldLoadDockerRegistryHierarchy() {\n+        initDockerRegistryAclTree();\n+        doReturn(dockerRegistryWithTools).when(mockDockerRegistryManager).load(ID);\n+\n+        final DockerRegistry returnedDr = dockerRegistryApiService.load(ID);\n+\n+        assertPartialDockerRegistryAclTree(returnedDr);\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldDeleteDockerRegistryForAdmin() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).delete(ID, true);\n+\n+        assertThat(dockerRegistryApiService.delete(ID, true)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDeleteDockerRegistryWhenPermissionIsGranted() {\n+        doReturn(dockerRegistry).when(mockDockerRegistryManager).delete(ID, true);\n+        initAclEntity(dockerRegistry, AclPermission.WRITE);\n+\n+        assertThat(dockerRegistryApiService.delete(ID, true)).isEqualTo(dockerRegistry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyDeleteDockerRegistryWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.delete(ID, true));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldNotifyDockerRegistryEventsForAdmin() {\n+        doReturn(tools).when(mockDockerRegistryManager).notifyDockerRegistryEvents(TEST_STRING, eventEnvelope);\n+\n+        assertThat(dockerRegistryApiService.notifyDockerRegistryEvents(TEST_STRING, eventEnvelope)).isEqualTo(tools);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDenyNotifyDockerRegistryEventsForNotAdmin() {\n+        doReturn(tools).when(mockDockerRegistryManager).notifyDockerRegistryEvents(TEST_STRING, eventEnvelope);\n+\n+        assertThrows(AccessDeniedException.class,\n+            () -> dockerRegistryApiService.notifyDockerRegistryEvents(TEST_STRING, eventEnvelope));\n+    }\n+\n+    @Test\n+    public void shouldIssueTokenForDockerRegistry() {\n+        doReturn(jwtRawToken).when(mockDockerRegistryManager)\n+                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING);\n+\n+        assertThat(dockerRegistryApiService\n+                .issueTokenForDockerRegistry(TEST_STRING, TEST_STRING, TEST_STRING, TEST_STRING))\n+                .isEqualTo(jwtRawToken);\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldGetCertificateContentForAdmin() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getCertificateContent(ID);\n+\n+        assertThat(dockerRegistryApiService.getCertificateContent(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldGetCertificateContentWhenPermissionIsGranted() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getCertificateContent(ID);\n+        initAclEntity(dockerRegistry, AclPermission.READ);\n+\n+        assertThat(dockerRegistryApiService.getCertificateContent(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyGetCertificateContentWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.getCertificateContent(ID));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldGetConfigScript() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getConfigScript(ID);\n+\n+        assertThat(dockerRegistryApiService.getConfigScript(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(SIMPLE_USER)\n+    public void shouldGetConfigScriptWhenPermissionIsGranted() {\n+        doReturn(BYTE_RESULT).when(mockDockerRegistryManager).getConfigScript(ID);\n+        initAclEntity(dockerRegistry, AclPermission.READ);\n+\n+        assertThat(dockerRegistryApiService.getConfigScript(ID)).isEqualTo(BYTE_RESULT);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyGetConfigScriptWhenPermissionIsNotGranted() {\n+        initAclEntity(dockerRegistry);\n+\n+        assertThrows(AccessDeniedException.class, () -> dockerRegistryApiService.getConfigScript(ID));\n+    }\n+\n+    private void initDockerRegistryAclTree() {\n+        toolGroup.setTools(toolList);\n+        toolGroupWithoutPermission.setTools(toolList);\n+        dockerRegistryWithTools.setGroups(toolGroups);\n+        initAclEntity(toolRead, AclPermission.READ);\n+        initAclEntity(toolWithoutPermission);\n+        initAclEntity(toolGroup, AclPermission.READ);\n+        initAclEntity(toolGroupWithoutPermission);\n+        initAclEntity(emptyToolGroupWithoutPermission, AclPermission.READ);\n+    }\n+\n+    private void assertPartialDockerRegistryAclTree(final DockerRegistry registry) {\n+        assertDockerRegistryAclHierarchy(registry);\n+        final List<? extends AbstractSecuredEntity> toolGroupWithoutPermissionLeaves =\n+                registry.getChildren().get(1).getLeaves();\n+        assertThat(toolGroupWithoutPermissionLeaves.size()).isEqualTo(1);\n+        assertThat(toolGroupWithoutPermissionLeaves.get(0)).isEqualTo(toolRead);\n+    }\n+\n+    private void assertWholeDockerRegistryAclTree(final DockerRegistry registry) {\n+        assertDockerRegistryAclHierarchy(registry);\n+        final List<? extends AbstractSecuredEntity> toolGroupWithoutPermissionLeaves =\n+                registry.getChildren().get(1).getLeaves();\n+\n+        assertThat(toolGroupWithoutPermissionLeaves.size()).isEqualTo(toolList.size());\n+        assertThat(toolGroupWithoutPermissionLeaves).isEqualTo(toolList);\n+    }\n+\n+    private void assertDockerRegistryAclHierarchy(final DockerRegistry registry) {\n+        final List<AbstractHierarchicalEntity> dockerRegistryChildren = registry.getChildren();\n+        final List<? extends AbstractSecuredEntity> toolGroupLeaves = registry.getChildren().get(0).getLeaves();", "originalCommit": "c3103f3f4623dae614b7ca813920a21f643d8c0a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0827d96f72a94d9c78b9c6ea29339eba98ff906d", "url": "https://github.com/epam/cloud-pipeline/commit/0827d96f72a94d9c78b9c6ea29339eba98ff906d", "message": "Issue #1404: Classes moved to acl package", "committedDate": "2020-11-18T14:07:30Z", "type": "commit"}, {"oid": "fe94dc764f316c003773190714b9c9e35b32ee9f", "url": "https://github.com/epam/cloud-pipeline/commit/fe94dc764f316c003773190714b9c9e35b32ee9f", "message": "Issue #1404: Implemented tests for DockerRegistryApiService", "committedDate": "2020-11-18T14:07:31Z", "type": "commit"}, {"oid": "841645292a31b3af2e2ceca233256cfbcd95d8d1", "url": "https://github.com/epam/cloud-pipeline/commit/841645292a31b3af2e2ceca233256cfbcd95d8d1", "message": "Issue #1404: Added tests for AclTree annotation", "committedDate": "2020-11-18T14:33:10Z", "type": "commit"}, {"oid": "efb35955d01c6b006d93061421daa1529e6f228a", "url": "https://github.com/epam/cloud-pipeline/commit/efb35955d01c6b006d93061421daa1529e6f228a", "message": "Issue #1404: AclTree tests refactoring", "committedDate": "2020-11-19T12:45:38Z", "type": "commit"}, {"oid": "efb35955d01c6b006d93061421daa1529e6f228a", "url": "https://github.com/epam/cloud-pipeline/commit/efb35955d01c6b006d93061421daa1529e6f228a", "message": "Issue #1404: AclTree tests refactoring", "committedDate": "2020-11-19T12:45:38Z", "type": "forcePushed"}, {"oid": "d980bcdc57c70e9904ba8bd347fffb67c97b57ad", "url": "https://github.com/epam/cloud-pipeline/commit/d980bcdc57c70e9904ba8bd347fffb67c97b57ad", "message": "Issue #1404: added childrenById map for AclTree assertions", "committedDate": "2020-11-20T08:50:45Z", "type": "commit"}, {"oid": "1e455fcf504bd2da113b5a72e09f95fad57e7343", "url": "https://github.com/epam/cloud-pipeline/commit/1e455fcf504bd2da113b5a72e09f95fad57e7343", "message": "Issue #1404: Applied proposed refactoring to AclTree tests", "committedDate": "2020-11-27T15:27:20Z", "type": "commit"}, {"oid": "cd73dceefe7eb11454c128d83cf46ed8488dd779", "url": "https://github.com/epam/cloud-pipeline/commit/cd73dceefe7eb11454c128d83cf46ed8488dd779", "message": "Issue #1404: Added more test object to fix permission merging, improved the way returned data accessed from collections", "committedDate": "2020-11-30T15:05:51Z", "type": "commit"}]}