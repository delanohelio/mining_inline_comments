{"pr_number": 1459, "pr_title": "Issue #1405: Implemented tests for ClusterController", "pr_createdAt": "2020-10-02T15:51:20Z", "pr_url": "https://github.com/epam/cloud-pipeline/pull/1459", "timeline": [{"oid": "a01c624290f51635a39f62e3dcad5c9e7613247b", "url": "https://github.com/epam/cloud-pipeline/commit/a01c624290f51635a39f62e3dcad5c9e7613247b", "message": "Issue #1405: Removed redundant ArgumentCaptor assertions", "committedDate": "2020-10-09T10:30:48Z", "type": "forcePushed"}, {"oid": "e8158ea3cb417ee85d4f27ef2c728cda7bc7794f", "url": "https://github.com/epam/cloud-pipeline/commit/e8158ea3cb417ee85d4f27ef2c728cda7bc7794f", "message": "Issue #1405: Implemented tests for ClusterController", "committedDate": "2020-10-16T13:34:16Z", "type": "commit"}, {"oid": "c0f02978b0fc1b5ceeb9787d9df86b883d924577", "url": "https://github.com/epam/cloud-pipeline/commit/c0f02978b0fc1b5ceeb9787d9df86b883d924577", "message": "Issue #1405: Changed ClusterControllerTest to use NodeCreatorUtils", "committedDate": "2020-10-16T13:34:22Z", "type": "commit"}, {"oid": "7fac8fa3a614f506da6d6afcaa43a1ea641af7ed", "url": "https://github.com/epam/cloud-pipeline/commit/7fac8fa3a614f506da6d6afcaa43a1ea641af7ed", "message": "Issue #1405: Removed redundant ArgumentCaptor assertions", "committedDate": "2020-10-16T13:34:22Z", "type": "commit"}, {"oid": "0212398bc26b845c5c3f97fbc5e2ebfa5c54839b", "url": "https://github.com/epam/cloud-pipeline/commit/0212398bc26b845c5c3f97fbc5e2ebfa5c54839b", "message": "Issue #1405: Expanded test data, lombok constructor removed from PipelineRun", "committedDate": "2020-10-16T13:34:23Z", "type": "commit"}, {"oid": "e5eccbb00218bff66b550b3819db9adb8df916a7", "url": "https://github.com/epam/cloud-pipeline/commit/e5eccbb00218bff66b550b3819db9adb8df916a7", "message": "Issue #1405: TypeReference creation moved to CreatorUtils", "committedDate": "2020-10-16T13:34:23Z", "type": "commit"}, {"oid": "6f0fffa670d840604a5d1f4fd69a805252203561", "url": "https://github.com/epam/cloud-pipeline/commit/6f0fffa670d840604a5d1f4fd69a805252203561", "message": "Issue #1405: ClusterControllerTest refactoring", "committedDate": "2020-10-16T13:58:47Z", "type": "commit"}, {"oid": "6f0fffa670d840604a5d1f4fd69a805252203561", "url": "https://github.com/epam/cloud-pipeline/commit/6f0fffa670d840604a5d1f4fd69a805252203561", "message": "Issue #1405: ClusterControllerTest refactoring", "committedDate": "2020-10-16T13:58:47Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU4NzAxNA==", "url": "https://github.com/epam/cloud-pipeline/pull/1459#discussion_r506587014", "bodyText": "Let's create a new method that will overload performRequest method with new argument String contentType. The current performRequest will call this method with default EXPECTED_CONTENT_TYPE.", "author": "ekazachkova", "createdAt": "2020-10-16T16:27:41Z", "path": "api/src/test/java/com/epam/pipeline/controller/cluster/ClusterControllerTest.java", "diffHunk": "@@ -0,0 +1,334 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.controller.cluster;\n+\n+import com.epam.pipeline.controller.vo.FilterNodesVO;\n+import com.epam.pipeline.entity.cluster.AllowedInstanceAndPriceTypes;\n+import com.epam.pipeline.entity.cluster.FilterPodsRequest;\n+import com.epam.pipeline.entity.cluster.InstanceType;\n+import com.epam.pipeline.entity.cluster.MasterNode;\n+import com.epam.pipeline.entity.cluster.NodeDisk;\n+import com.epam.pipeline.entity.cluster.NodeInstance;\n+import com.epam.pipeline.entity.cluster.monitoring.MonitoringStats;\n+import com.epam.pipeline.manager.cluster.ClusterApiService;\n+import com.epam.pipeline.test.creator.cluster.NodeCreatorUtils;\n+import com.epam.pipeline.test.web.AbstractControllerTest;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;\n+import org.springframework.security.test.context.support.WithMockUser;\n+import org.springframework.test.web.servlet.MvcResult;\n+import org.springframework.util.LinkedMultiValueMap;\n+import org.springframework.util.MultiValueMap;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.InputStream;\n+import java.time.Duration;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.delete;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+@WebMvcTest(controllers = ClusterController.class)\n+public class ClusterControllerTest extends AbstractControllerTest {\n+\n+    private static final long ID = 1L;\n+    private static final String CLUSTER_URL = SERVLET_PATH + \"/cluster\";\n+    private static final String MASTER_NODES_URL = CLUSTER_URL + \"/master\";\n+    private static final String NODE_URL = CLUSTER_URL + \"/node\";\n+    private static final String INSTANCE_URL = CLUSTER_URL + \"/instance\";\n+    private static final String LOAD_NODES_URL = NODE_URL + \"/loadAll\";\n+    private static final String FILTER_NODES_URL = NODE_URL +\"/filter\";\n+    private static final String LOAD_NODE_URL = NODE_URL + \"/%s/load\";\n+    private static final String NODE_NAME_URL = NODE_URL + \"/%s\";\n+    private static final String LOAD_INSTANCE_TYPES_URL = INSTANCE_URL + \"/loadAll\";\n+    private static final String LOAD_ALLOWED_INSTANCE_TYPES_URL = INSTANCE_URL + \"/allowed\";\n+    private static final String NODE_USAGE_URL = NODE_NAME_URL + \"/usage\";\n+    private static final String NODE_DISKS_URL = NODE_NAME_URL + \"/disks\";\n+    private static final String NODE_STATISTICS_URL = NODE_USAGE_URL + \"/report\";\n+    private static final String PORT = \"7367\";\n+    private static final String NAME = \"testName\";\n+    private static final String TEST_DATA = \"test_data\";\n+    private static final String FROM_STRING = \"2019-04-01T09:08:07\";\n+    private static final String TO_STRING = \"2020-05-02T12:11:10\";\n+    private final NodeInstance nodeInstance = NodeCreatorUtils.getDefaultNodeInstance();\n+    private final List<NodeInstance> nodeInstances = Collections.singletonList(nodeInstance);\n+    private final List<InstanceType>\n+            instanceTypes = Collections.singletonList(NodeCreatorUtils.getDefaultInstanceType());\n+    private final LocalDateTime from = LocalDateTime.parse(FROM_STRING, DateTimeFormatter.ISO_LOCAL_DATE_TIME);\n+    private final LocalDateTime to = LocalDateTime.parse(TO_STRING, DateTimeFormatter.ISO_LOCAL_DATE_TIME);\n+\n+    @Autowired\n+    private ClusterApiService mockClusterApiService;\n+\n+    @Test\n+    public void shouldFailLoadMasterNodesForUnauthorizedUser() throws Exception {\n+        performUnauthorizedRequest(get(MASTER_NODES_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadMasterNodes() throws Exception {\n+        final List<MasterNode> masterNodes = Collections.singletonList(MasterNode.fromNode(\n+                NodeCreatorUtils.getDefaultNode(), PORT));\n+\n+        Mockito.doReturn(masterNodes).when(mockClusterApiService).getMasterNodes();\n+\n+        final MvcResult mvcResult = performRequest(get(MASTER_NODES_URL));\n+\n+        Mockito.verify(mockClusterApiService).getMasterNodes();\n+\n+        assertResponse(mvcResult, masterNodes, NodeCreatorUtils.MASTER_NODE_LIST_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailLoadNodesForUnauthorizedUser() throws Exception {\n+        performUnauthorizedRequest(get(LOAD_NODES_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadNodes() throws Exception {\n+        Mockito.doReturn(nodeInstances).when(mockClusterApiService).getNodes();\n+\n+        final MvcResult mvcResult = performRequest(get(LOAD_NODES_URL));\n+\n+        Mockito.verify(mockClusterApiService).getNodes();\n+\n+        assertResponse(mvcResult, nodeInstances, NodeCreatorUtils.NODE_INSTANCE_LIST_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailFilterNodesForUnauthorizedUser() throws Exception {\n+        performUnauthorizedRequest(post(FILTER_NODES_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldFilterNodes() throws Exception {\n+        final FilterNodesVO filterNodesVO = NodeCreatorUtils.getDefaultFilterNodesVO();\n+        final String content = getObjectMapper().writeValueAsString(filterNodesVO);\n+\n+        Mockito.doReturn(nodeInstances).when(mockClusterApiService).filterNodes(Mockito.refEq(filterNodesVO));\n+\n+        final MvcResult mvcResult = performRequest(post(FILTER_NODES_URL).content(content));\n+\n+        Mockito.verify(mockClusterApiService).filterNodes(Mockito.refEq(filterNodesVO));\n+\n+        assertResponse(mvcResult, nodeInstances, NodeCreatorUtils.NODE_INSTANCE_LIST_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailLoadNodeForUnauthorizedUser() throws Exception {\n+        performUnauthorizedRequest(get(String.format(LOAD_NODE_URL, NAME)));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadNode() throws Exception {\n+        Mockito.doReturn(nodeInstance).when(mockClusterApiService).getNode(NAME);\n+\n+        final MvcResult mvcResult = performRequest(get(String.format(LOAD_NODE_URL, NAME)));\n+\n+        Mockito.verify(mockClusterApiService).getNode(NAME);\n+\n+        assertResponse(mvcResult, nodeInstance, NodeCreatorUtils.NODE_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailLoadNodeFilteredForUnauthorizedUser() throws Exception {\n+        performUnauthorizedRequest(post(LOAD_NODES_URL, NAME));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadNodeFiltered() throws Exception {\n+        final FilterPodsRequest filterPodsRequest = NodeCreatorUtils.getDefaultFilterPodsRequest();\n+        final String content = getObjectMapper().writeValueAsString(filterPodsRequest);\n+\n+        Mockito.doReturn(nodeInstance).when(mockClusterApiService)\n+                .getNode(Mockito.eq(NAME), Mockito.refEq(filterPodsRequest));\n+\n+        final MvcResult mvcResult = performRequest(post(String.format(LOAD_NODE_URL, NAME)).content(content));\n+\n+        Mockito.verify(mockClusterApiService)\n+                .getNode(Mockito.eq(NAME), Mockito.refEq(filterPodsRequest));\n+\n+        assertResponse(mvcResult, nodeInstance, NodeCreatorUtils.NODE_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailTerminateNodeForUnauthorizedUser() throws Exception {\n+        performUnauthorizedRequest(delete(NODE_NAME_URL, NAME));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldTerminateNode() throws Exception {\n+        Mockito.doReturn(nodeInstance).when(mockClusterApiService).terminateNode(NAME);\n+\n+        final MvcResult mvcResult = performRequest(delete(String.format(NODE_NAME_URL, NAME)));\n+\n+        Mockito.verify(mockClusterApiService).terminateNode(NAME);\n+\n+        assertResponse(mvcResult, nodeInstance, NodeCreatorUtils.NODE_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailLoadAllInstanceTypesForUnauthorizedUser() throws Exception {\n+        performUnauthorizedRequest(get(LOAD_INSTANCE_TYPES_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadAllowedInstanceTypes() throws Exception {\n+        final MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n+        params.add(\"regionId\", \"1\");\n+        params.add(\"toolInstances\", \"false\");\n+        params.add(\"spot\", \"true\");\n+\n+        Mockito.doReturn(instanceTypes).when(mockClusterApiService).getAllowedInstanceTypes(ID, true);\n+\n+        final MvcResult mvcResult = performRequest(get(LOAD_INSTANCE_TYPES_URL).params(params));\n+\n+        Mockito.verify(mockClusterApiService).getAllowedInstanceTypes(ID, true);\n+\n+        assertResponse(mvcResult, instanceTypes, NodeCreatorUtils.INSTANCE_TYPE_LIST_TYPE);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadAllowedToolInstanceTypes() throws Exception {\n+        final MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n+        params.add(\"regionId\", \"1\");\n+        params.add(\"toolInstances\", \"true\");\n+        params.add(\"spot\", \"false\");\n+\n+        Mockito.doReturn(instanceTypes).when(mockClusterApiService).getAllowedToolInstanceTypes(ID, false);\n+\n+        final MvcResult mvcResult = performRequest(get(LOAD_INSTANCE_TYPES_URL).params(params));\n+\n+        Mockito.verify(mockClusterApiService).getAllowedToolInstanceTypes(ID, false);\n+\n+        assertResponse(mvcResult, instanceTypes, NodeCreatorUtils.INSTANCE_TYPE_LIST_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailLoadAllowedInstanceAndPriceTypesForUnauthorizedUser() throws Exception {\n+        performUnauthorizedRequest(get(LOAD_ALLOWED_INSTANCE_TYPES_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadAllowedInstanceAndPriceTypes() throws Exception {\n+        final MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n+        params.add(\"toolId\", \"1\");\n+        params.add(\"regionId\", \"1\");\n+        params.add(\"spot\", \"false\");\n+\n+        final AllowedInstanceAndPriceTypes allowedInstanceAndPriceTypes =\n+                NodeCreatorUtils.getDefaultAllowedInstanceAndPriceTypes();\n+\n+        Mockito.doReturn(allowedInstanceAndPriceTypes).when(mockClusterApiService)\n+                .getAllowedInstanceAndPriceTypes(ID, ID, false);\n+\n+        final MvcResult mvcResult = performRequest(get(LOAD_ALLOWED_INSTANCE_TYPES_URL).params(params));\n+\n+        Mockito.verify(mockClusterApiService).getAllowedInstanceAndPriceTypes(ID, ID, false);\n+\n+        assertResponse(mvcResult, allowedInstanceAndPriceTypes, NodeCreatorUtils.ALLOWED_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailGetNodeUsageStatisticsForUnauthorizedUser() throws Exception {\n+        performUnauthorizedRequest(get(String.format(NODE_USAGE_URL, NAME)));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldGetNodeUsageStatistics() throws Exception {\n+        final List<MonitoringStats> monitoringStats = Collections.singletonList(new MonitoringStats());\n+        final MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n+        params.add(\"from\", FROM_STRING.replace('T', ' '));\n+        params.add(\"to\", TO_STRING.replace('T', ' '));\n+\n+        Mockito.doReturn(monitoringStats).when(mockClusterApiService)\n+                .getStatsForNode(NAME, from, to);\n+\n+        final MvcResult mvcResult = performRequest(get(String.format(NODE_USAGE_URL, NAME)).params(params));\n+\n+        Mockito.verify(mockClusterApiService).getStatsForNode(NAME, from, to);\n+\n+        assertResponse(mvcResult, monitoringStats, NodeCreatorUtils.MONITORING_STATS_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailDownloadNodeUsageStatisticsReportForUnauthorizedUser() throws Exception {\n+        performUnauthorizedRequest(get(String.format(NODE_STATISTICS_URL, NAME)));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDownloadNodeUsageStatisticsReport() throws Exception {\n+        final InputStream inputStream = new ByteArrayInputStream(TEST_DATA.getBytes());\n+\n+        Mockito.doReturn(inputStream).when(mockClusterApiService)\n+                .getUsageStatisticsFile(NAME, from, to, Duration.ofHours(1));\n+\n+        final MvcResult mvcResult = mvc().perform(get(String.format(NODE_STATISTICS_URL, NAME))", "originalCommit": "6f0fffa670d840604a5d1f4fd69a805252203561", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjU4OTIwMA==", "url": "https://github.com/epam/cloud-pipeline/pull/1459#discussion_r506589200", "bodyText": "Could you please make this field final or call it directly in Assert.assertEquals?", "author": "ekazachkova", "createdAt": "2020-10-16T16:31:33Z", "path": "api/src/test/java/com/epam/pipeline/controller/cluster/ClusterControllerTest.java", "diffHunk": "@@ -0,0 +1,334 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.controller.cluster;\n+\n+import com.epam.pipeline.controller.vo.FilterNodesVO;\n+import com.epam.pipeline.entity.cluster.AllowedInstanceAndPriceTypes;\n+import com.epam.pipeline.entity.cluster.FilterPodsRequest;\n+import com.epam.pipeline.entity.cluster.InstanceType;\n+import com.epam.pipeline.entity.cluster.MasterNode;\n+import com.epam.pipeline.entity.cluster.NodeDisk;\n+import com.epam.pipeline.entity.cluster.NodeInstance;\n+import com.epam.pipeline.entity.cluster.monitoring.MonitoringStats;\n+import com.epam.pipeline.manager.cluster.ClusterApiService;\n+import com.epam.pipeline.test.creator.cluster.NodeCreatorUtils;\n+import com.epam.pipeline.test.web.AbstractControllerTest;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;\n+import org.springframework.security.test.context.support.WithMockUser;\n+import org.springframework.test.web.servlet.MvcResult;\n+import org.springframework.util.LinkedMultiValueMap;\n+import org.springframework.util.MultiValueMap;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.InputStream;\n+import java.time.Duration;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.delete;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+@WebMvcTest(controllers = ClusterController.class)\n+public class ClusterControllerTest extends AbstractControllerTest {\n+\n+    private static final long ID = 1L;\n+    private static final String CLUSTER_URL = SERVLET_PATH + \"/cluster\";\n+    private static final String MASTER_NODES_URL = CLUSTER_URL + \"/master\";\n+    private static final String NODE_URL = CLUSTER_URL + \"/node\";\n+    private static final String INSTANCE_URL = CLUSTER_URL + \"/instance\";\n+    private static final String LOAD_NODES_URL = NODE_URL + \"/loadAll\";\n+    private static final String FILTER_NODES_URL = NODE_URL +\"/filter\";\n+    private static final String LOAD_NODE_URL = NODE_URL + \"/%s/load\";\n+    private static final String NODE_NAME_URL = NODE_URL + \"/%s\";\n+    private static final String LOAD_INSTANCE_TYPES_URL = INSTANCE_URL + \"/loadAll\";\n+    private static final String LOAD_ALLOWED_INSTANCE_TYPES_URL = INSTANCE_URL + \"/allowed\";\n+    private static final String NODE_USAGE_URL = NODE_NAME_URL + \"/usage\";\n+    private static final String NODE_DISKS_URL = NODE_NAME_URL + \"/disks\";\n+    private static final String NODE_STATISTICS_URL = NODE_USAGE_URL + \"/report\";\n+    private static final String PORT = \"7367\";\n+    private static final String NAME = \"testName\";\n+    private static final String TEST_DATA = \"test_data\";\n+    private static final String FROM_STRING = \"2019-04-01T09:08:07\";\n+    private static final String TO_STRING = \"2020-05-02T12:11:10\";\n+    private final NodeInstance nodeInstance = NodeCreatorUtils.getDefaultNodeInstance();\n+    private final List<NodeInstance> nodeInstances = Collections.singletonList(nodeInstance);\n+    private final List<InstanceType>\n+            instanceTypes = Collections.singletonList(NodeCreatorUtils.getDefaultInstanceType());\n+    private final LocalDateTime from = LocalDateTime.parse(FROM_STRING, DateTimeFormatter.ISO_LOCAL_DATE_TIME);\n+    private final LocalDateTime to = LocalDateTime.parse(TO_STRING, DateTimeFormatter.ISO_LOCAL_DATE_TIME);\n+\n+    @Autowired\n+    private ClusterApiService mockClusterApiService;\n+\n+    @Test\n+    public void shouldFailLoadMasterNodesForUnauthorizedUser() throws Exception {\n+        performUnauthorizedRequest(get(MASTER_NODES_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadMasterNodes() throws Exception {\n+        final List<MasterNode> masterNodes = Collections.singletonList(MasterNode.fromNode(\n+                NodeCreatorUtils.getDefaultNode(), PORT));\n+\n+        Mockito.doReturn(masterNodes).when(mockClusterApiService).getMasterNodes();\n+\n+        final MvcResult mvcResult = performRequest(get(MASTER_NODES_URL));\n+\n+        Mockito.verify(mockClusterApiService).getMasterNodes();\n+\n+        assertResponse(mvcResult, masterNodes, NodeCreatorUtils.MASTER_NODE_LIST_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailLoadNodesForUnauthorizedUser() throws Exception {\n+        performUnauthorizedRequest(get(LOAD_NODES_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadNodes() throws Exception {\n+        Mockito.doReturn(nodeInstances).when(mockClusterApiService).getNodes();\n+\n+        final MvcResult mvcResult = performRequest(get(LOAD_NODES_URL));\n+\n+        Mockito.verify(mockClusterApiService).getNodes();\n+\n+        assertResponse(mvcResult, nodeInstances, NodeCreatorUtils.NODE_INSTANCE_LIST_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailFilterNodesForUnauthorizedUser() throws Exception {\n+        performUnauthorizedRequest(post(FILTER_NODES_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldFilterNodes() throws Exception {\n+        final FilterNodesVO filterNodesVO = NodeCreatorUtils.getDefaultFilterNodesVO();\n+        final String content = getObjectMapper().writeValueAsString(filterNodesVO);\n+\n+        Mockito.doReturn(nodeInstances).when(mockClusterApiService).filterNodes(Mockito.refEq(filterNodesVO));\n+\n+        final MvcResult mvcResult = performRequest(post(FILTER_NODES_URL).content(content));\n+\n+        Mockito.verify(mockClusterApiService).filterNodes(Mockito.refEq(filterNodesVO));\n+\n+        assertResponse(mvcResult, nodeInstances, NodeCreatorUtils.NODE_INSTANCE_LIST_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailLoadNodeForUnauthorizedUser() throws Exception {\n+        performUnauthorizedRequest(get(String.format(LOAD_NODE_URL, NAME)));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadNode() throws Exception {\n+        Mockito.doReturn(nodeInstance).when(mockClusterApiService).getNode(NAME);\n+\n+        final MvcResult mvcResult = performRequest(get(String.format(LOAD_NODE_URL, NAME)));\n+\n+        Mockito.verify(mockClusterApiService).getNode(NAME);\n+\n+        assertResponse(mvcResult, nodeInstance, NodeCreatorUtils.NODE_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailLoadNodeFilteredForUnauthorizedUser() throws Exception {\n+        performUnauthorizedRequest(post(LOAD_NODES_URL, NAME));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadNodeFiltered() throws Exception {\n+        final FilterPodsRequest filterPodsRequest = NodeCreatorUtils.getDefaultFilterPodsRequest();\n+        final String content = getObjectMapper().writeValueAsString(filterPodsRequest);\n+\n+        Mockito.doReturn(nodeInstance).when(mockClusterApiService)\n+                .getNode(Mockito.eq(NAME), Mockito.refEq(filterPodsRequest));\n+\n+        final MvcResult mvcResult = performRequest(post(String.format(LOAD_NODE_URL, NAME)).content(content));\n+\n+        Mockito.verify(mockClusterApiService)\n+                .getNode(Mockito.eq(NAME), Mockito.refEq(filterPodsRequest));\n+\n+        assertResponse(mvcResult, nodeInstance, NodeCreatorUtils.NODE_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailTerminateNodeForUnauthorizedUser() throws Exception {\n+        performUnauthorizedRequest(delete(NODE_NAME_URL, NAME));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldTerminateNode() throws Exception {\n+        Mockito.doReturn(nodeInstance).when(mockClusterApiService).terminateNode(NAME);\n+\n+        final MvcResult mvcResult = performRequest(delete(String.format(NODE_NAME_URL, NAME)));\n+\n+        Mockito.verify(mockClusterApiService).terminateNode(NAME);\n+\n+        assertResponse(mvcResult, nodeInstance, NodeCreatorUtils.NODE_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailLoadAllInstanceTypesForUnauthorizedUser() throws Exception {\n+        performUnauthorizedRequest(get(LOAD_INSTANCE_TYPES_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadAllowedInstanceTypes() throws Exception {\n+        final MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n+        params.add(\"regionId\", \"1\");\n+        params.add(\"toolInstances\", \"false\");\n+        params.add(\"spot\", \"true\");\n+\n+        Mockito.doReturn(instanceTypes).when(mockClusterApiService).getAllowedInstanceTypes(ID, true);\n+\n+        final MvcResult mvcResult = performRequest(get(LOAD_INSTANCE_TYPES_URL).params(params));\n+\n+        Mockito.verify(mockClusterApiService).getAllowedInstanceTypes(ID, true);\n+\n+        assertResponse(mvcResult, instanceTypes, NodeCreatorUtils.INSTANCE_TYPE_LIST_TYPE);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadAllowedToolInstanceTypes() throws Exception {\n+        final MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n+        params.add(\"regionId\", \"1\");\n+        params.add(\"toolInstances\", \"true\");\n+        params.add(\"spot\", \"false\");\n+\n+        Mockito.doReturn(instanceTypes).when(mockClusterApiService).getAllowedToolInstanceTypes(ID, false);\n+\n+        final MvcResult mvcResult = performRequest(get(LOAD_INSTANCE_TYPES_URL).params(params));\n+\n+        Mockito.verify(mockClusterApiService).getAllowedToolInstanceTypes(ID, false);\n+\n+        assertResponse(mvcResult, instanceTypes, NodeCreatorUtils.INSTANCE_TYPE_LIST_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailLoadAllowedInstanceAndPriceTypesForUnauthorizedUser() throws Exception {\n+        performUnauthorizedRequest(get(LOAD_ALLOWED_INSTANCE_TYPES_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadAllowedInstanceAndPriceTypes() throws Exception {\n+        final MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n+        params.add(\"toolId\", \"1\");\n+        params.add(\"regionId\", \"1\");\n+        params.add(\"spot\", \"false\");\n+\n+        final AllowedInstanceAndPriceTypes allowedInstanceAndPriceTypes =\n+                NodeCreatorUtils.getDefaultAllowedInstanceAndPriceTypes();\n+\n+        Mockito.doReturn(allowedInstanceAndPriceTypes).when(mockClusterApiService)\n+                .getAllowedInstanceAndPriceTypes(ID, ID, false);\n+\n+        final MvcResult mvcResult = performRequest(get(LOAD_ALLOWED_INSTANCE_TYPES_URL).params(params));\n+\n+        Mockito.verify(mockClusterApiService).getAllowedInstanceAndPriceTypes(ID, ID, false);\n+\n+        assertResponse(mvcResult, allowedInstanceAndPriceTypes, NodeCreatorUtils.ALLOWED_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailGetNodeUsageStatisticsForUnauthorizedUser() throws Exception {\n+        performUnauthorizedRequest(get(String.format(NODE_USAGE_URL, NAME)));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldGetNodeUsageStatistics() throws Exception {\n+        final List<MonitoringStats> monitoringStats = Collections.singletonList(new MonitoringStats());\n+        final MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n+        params.add(\"from\", FROM_STRING.replace('T', ' '));\n+        params.add(\"to\", TO_STRING.replace('T', ' '));\n+\n+        Mockito.doReturn(monitoringStats).when(mockClusterApiService)\n+                .getStatsForNode(NAME, from, to);\n+\n+        final MvcResult mvcResult = performRequest(get(String.format(NODE_USAGE_URL, NAME)).params(params));\n+\n+        Mockito.verify(mockClusterApiService).getStatsForNode(NAME, from, to);\n+\n+        assertResponse(mvcResult, monitoringStats, NodeCreatorUtils.MONITORING_STATS_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailDownloadNodeUsageStatisticsReportForUnauthorizedUser() throws Exception {\n+        performUnauthorizedRequest(get(String.format(NODE_STATISTICS_URL, NAME)));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDownloadNodeUsageStatisticsReport() throws Exception {\n+        final InputStream inputStream = new ByteArrayInputStream(TEST_DATA.getBytes());\n+\n+        Mockito.doReturn(inputStream).when(mockClusterApiService)\n+                .getUsageStatisticsFile(NAME, from, to, Duration.ofHours(1));\n+\n+        final MvcResult mvcResult = mvc().perform(get(String.format(NODE_STATISTICS_URL, NAME))\n+                .servletPath(SERVLET_PATH)\n+                .contentType(\"application/octet-stream\")\n+                .param(\"from\", FROM_STRING.replace('T', ' '))\n+                .param(\"to\", TO_STRING.replace('T', ' '))\n+                .param(\"interval\", \"PT1H\"))\n+                .andExpect(status().isOk())\n+                .andExpect(content().contentType(\"application/octet-stream\"))\n+                .andReturn();\n+\n+        Mockito.verify(mockClusterApiService).getUsageStatisticsFile(NAME, from, to, Duration.ofHours(1));\n+\n+        String actualResponseData = mvcResult.getResponse().getContentAsString();", "originalCommit": "6f0fffa670d840604a5d1f4fd69a805252203561", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "94d0bbe6e68e9b79f50625ae0cca616a139ccfab", "url": "https://github.com/epam/cloud-pipeline/commit/94d0bbe6e68e9b79f50625ae0cca616a139ccfab", "message": "Issue #1405: Added overloaded performRequest method, removed extra line breaks", "committedDate": "2020-10-19T11:08:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODMzNzY3MA==", "url": "https://github.com/epam/cloud-pipeline/pull/1459#discussion_r508337670", "bodyText": "Let's use the same naming approach here. It has to be NODE_DISK_LIST_TYPE or NODE_DISKS_TYPE.", "author": "tcibinan", "createdAt": "2020-10-20T09:11:14Z", "path": "api/src/test/java/com/epam/pipeline/test/creator/cluster/NodeCreatorUtils.java", "diffHunk": "@@ -32,14 +36,30 @@\n import java.time.format.DateTimeFormatter;\n import java.util.Collections;\n import java.util.List;\n+import java.util.Map;\n \n import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING_LIST;\n \n public final class NodeCreatorUtils {\n \n+    public static final TypeReference<Result<List<MasterNode>>> MASTER_NODE_LIST_TYPE =\n+            new TypeReference<Result<List<MasterNode>>>() { };\n+    public static final TypeReference<Result<List<NodeInstance>>> NODE_INSTANCE_LIST_TYPE =\n+            new TypeReference<Result<List<NodeInstance>>>() { };\n+    public static final TypeReference<Result<NodeInstance>> NODE_INSTANCE_TYPE =\n+            new TypeReference<Result<NodeInstance>>() { };\n+    public static final TypeReference<Result<List<InstanceType>>> INSTANCE_TYPE_LIST_TYPE =\n+            new TypeReference<Result<List<InstanceType>>>() { };\n+    public static final TypeReference<Result<AllowedInstanceAndPriceTypes>> ALLOWED_INSTANCE_TYPE =\n+            new TypeReference<Result<AllowedInstanceAndPriceTypes>>() { };\n+    public static final TypeReference<Result<List<MonitoringStats>>> MONITORING_STATS_TYPE =\n+            new TypeReference<Result<List<MonitoringStats>>>() { };\n+    public static final TypeReference<Result<List<NodeDisk>>> NODE_DISK_TYPE =", "originalCommit": "94d0bbe6e68e9b79f50625ae0cca616a139ccfab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODMzOTIwMA==", "url": "https://github.com/epam/cloud-pipeline/pull/1459#discussion_r508339200", "bodyText": "Probably we can use TEST_INT here similarly to TEST_STRING.", "author": "tcibinan", "createdAt": "2020-10-20T09:13:26Z", "path": "api/src/test/java/com/epam/pipeline/test/creator/cluster/NodeCreatorUtils.java", "diffHunk": "@@ -48,15 +68,39 @@ private NodeCreatorUtils() {\n     }\n \n     public static NodeInstance getDefaultNodeInstance() {\n-        return new NodeInstance();\n+        final List<NodeInstanceAddress> nodeInstanceAddresses = Collections.singletonList(new NodeInstanceAddress());\n+        final Map<String, String> testMap = Collections.singletonMap(TEST_STRING, TEST_STRING);\n+        NodeInstance nodeInstance = new NodeInstance();\n+        nodeInstance.setClusterName(TEST_STRING);\n+        nodeInstance.setName(TEST_STRING);\n+        nodeInstance.setCreationTimestamp(TEST_STRING);\n+        nodeInstance.setRegion(TEST_STRING);\n+        nodeInstance.setRunId(TEST_STRING);\n+        nodeInstance.setAddresses(nodeInstanceAddresses);\n+        nodeInstance.setAllocatable(testMap);\n+        nodeInstance.setCapacity(testMap);\n+        nodeInstance.setLabels(testMap);\n+        return nodeInstance;\n     }\n \n     public static InstanceType getDefaultInstanceType() {\n-        return InstanceType.builder().name(TEST_STRING).build();\n+        return InstanceType.builder()\n+                .name(TEST_STRING)\n+                .gpu(4)", "originalCommit": "94d0bbe6e68e9b79f50625ae0cca616a139ccfab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM1OTM2NQ==", "url": "https://github.com/epam/cloud-pipeline/pull/1459#discussion_r508359365", "bodyText": "Could you please also check that the response file name is that we expects it to be. It is pretty important because it will be visible by the end user when he/she downloads the node usage report.", "author": "tcibinan", "createdAt": "2020-10-20T09:43:19Z", "path": "api/src/test/java/com/epam/pipeline/controller/cluster/ClusterControllerTest.java", "diffHunk": "@@ -0,0 +1,309 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.controller.cluster;\n+\n+import com.epam.pipeline.controller.vo.FilterNodesVO;\n+import com.epam.pipeline.entity.cluster.AllowedInstanceAndPriceTypes;\n+import com.epam.pipeline.entity.cluster.FilterPodsRequest;\n+import com.epam.pipeline.entity.cluster.InstanceType;\n+import com.epam.pipeline.entity.cluster.MasterNode;\n+import com.epam.pipeline.entity.cluster.NodeDisk;\n+import com.epam.pipeline.entity.cluster.NodeInstance;\n+import com.epam.pipeline.entity.cluster.monitoring.MonitoringStats;\n+import com.epam.pipeline.manager.cluster.ClusterApiService;\n+import com.epam.pipeline.test.creator.cluster.NodeCreatorUtils;\n+import com.epam.pipeline.test.web.AbstractControllerTest;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;\n+import org.springframework.security.test.context.support.WithMockUser;\n+import org.springframework.test.web.servlet.MvcResult;\n+import org.springframework.util.LinkedMultiValueMap;\n+import org.springframework.util.MultiValueMap;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.InputStream;\n+import java.time.Duration;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.delete;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+\n+@WebMvcTest(controllers = ClusterController.class)\n+public class ClusterControllerTest extends AbstractControllerTest {\n+\n+    private static final long ID = 1L;\n+    private static final String CLUSTER_URL = SERVLET_PATH + \"/cluster\";\n+    private static final String MASTER_NODES_URL = CLUSTER_URL + \"/master\";\n+    private static final String NODE_URL = CLUSTER_URL + \"/node\";\n+    private static final String INSTANCE_URL = CLUSTER_URL + \"/instance\";\n+    private static final String LOAD_NODES_URL = NODE_URL + \"/loadAll\";\n+    private static final String FILTER_NODES_URL = NODE_URL +\"/filter\";\n+    private static final String LOAD_NODE_URL = NODE_URL + \"/%s/load\";\n+    private static final String NODE_NAME_URL = NODE_URL + \"/%s\";\n+    private static final String LOAD_INSTANCE_TYPES_URL = INSTANCE_URL + \"/loadAll\";\n+    private static final String LOAD_ALLOWED_INSTANCE_TYPES_URL = INSTANCE_URL + \"/allowed\";\n+    private static final String NODE_USAGE_URL = NODE_NAME_URL + \"/usage\";\n+    private static final String NODE_DISKS_URL = NODE_NAME_URL + \"/disks\";\n+    private static final String NODE_STATISTICS_URL = NODE_USAGE_URL + \"/report\";\n+    private static final String PORT = \"7367\";\n+    private static final String NAME = \"testName\";\n+    private static final String TEST_DATA = \"test_data\";\n+    private static final String FROM_STRING = \"2019-04-01T09:08:07\";\n+    private static final String TO_STRING = \"2020-05-02T12:11:10\";\n+    private static final String OCTET_STREAM_CONTENT_TYPE = \"application/octet-stream\";\n+    private final NodeInstance nodeInstance = NodeCreatorUtils.getDefaultNodeInstance();\n+    private final List<NodeInstance> nodeInstances = Collections.singletonList(nodeInstance);\n+    private final List<InstanceType>\n+            instanceTypes = Collections.singletonList(NodeCreatorUtils.getDefaultInstanceType());\n+    private final LocalDateTime from = LocalDateTime.parse(FROM_STRING, DateTimeFormatter.ISO_LOCAL_DATE_TIME);\n+    private final LocalDateTime to = LocalDateTime.parse(TO_STRING, DateTimeFormatter.ISO_LOCAL_DATE_TIME);\n+\n+    @Autowired\n+    private ClusterApiService mockClusterApiService;\n+\n+    @Test\n+    public void shouldFailLoadMasterNodesForUnauthorizedUser() throws Exception {\n+        performUnauthorizedRequest(get(MASTER_NODES_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadMasterNodes() throws Exception {\n+        final List<MasterNode> masterNodes = Collections.singletonList(MasterNode.fromNode(\n+                NodeCreatorUtils.getDefaultNode(), PORT));\n+        Mockito.doReturn(masterNodes).when(mockClusterApiService).getMasterNodes();\n+\n+        final MvcResult mvcResult = performRequest(get(MASTER_NODES_URL));\n+\n+        Mockito.verify(mockClusterApiService).getMasterNodes();\n+        assertResponse(mvcResult, masterNodes, NodeCreatorUtils.MASTER_NODE_LIST_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailLoadNodesForUnauthorizedUser() throws Exception {\n+        performUnauthorizedRequest(get(LOAD_NODES_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadNodes() throws Exception {\n+        Mockito.doReturn(nodeInstances).when(mockClusterApiService).getNodes();\n+\n+        final MvcResult mvcResult = performRequest(get(LOAD_NODES_URL));\n+\n+        Mockito.verify(mockClusterApiService).getNodes();\n+        assertResponse(mvcResult, nodeInstances, NodeCreatorUtils.NODE_INSTANCE_LIST_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailFilterNodesForUnauthorizedUser() throws Exception {\n+        performUnauthorizedRequest(post(FILTER_NODES_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldFilterNodes() throws Exception {\n+        final FilterNodesVO filterNodesVO = NodeCreatorUtils.getDefaultFilterNodesVO();\n+        final String content = getObjectMapper().writeValueAsString(filterNodesVO);\n+        Mockito.doReturn(nodeInstances).when(mockClusterApiService).filterNodes(Mockito.refEq(filterNodesVO));\n+\n+        final MvcResult mvcResult = performRequest(post(FILTER_NODES_URL).content(content));\n+\n+        Mockito.verify(mockClusterApiService).filterNodes(Mockito.refEq(filterNodesVO));\n+        assertResponse(mvcResult, nodeInstances, NodeCreatorUtils.NODE_INSTANCE_LIST_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailLoadNodeForUnauthorizedUser() throws Exception {\n+        performUnauthorizedRequest(get(String.format(LOAD_NODE_URL, NAME)));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadNode() throws Exception {\n+        Mockito.doReturn(nodeInstance).when(mockClusterApiService).getNode(NAME);\n+\n+        final MvcResult mvcResult = performRequest(get(String.format(LOAD_NODE_URL, NAME)));\n+\n+        Mockito.verify(mockClusterApiService).getNode(NAME);\n+        assertResponse(mvcResult, nodeInstance, NodeCreatorUtils.NODE_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailLoadNodeFilteredForUnauthorizedUser() throws Exception {\n+        performUnauthorizedRequest(post(LOAD_NODES_URL, NAME));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadNodeFiltered() throws Exception {\n+        final FilterPodsRequest filterPodsRequest = NodeCreatorUtils.getDefaultFilterPodsRequest();\n+        final String content = getObjectMapper().writeValueAsString(filterPodsRequest);\n+        Mockito.doReturn(nodeInstance).when(mockClusterApiService)\n+                .getNode(Mockito.eq(NAME), Mockito.refEq(filterPodsRequest));\n+\n+        final MvcResult mvcResult = performRequest(post(String.format(LOAD_NODE_URL, NAME)).content(content));\n+\n+        Mockito.verify(mockClusterApiService)\n+                .getNode(Mockito.eq(NAME), Mockito.refEq(filterPodsRequest));\n+        assertResponse(mvcResult, nodeInstance, NodeCreatorUtils.NODE_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailTerminateNodeForUnauthorizedUser() throws Exception {\n+        performUnauthorizedRequest(delete(NODE_NAME_URL, NAME));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldTerminateNode() throws Exception {\n+        Mockito.doReturn(nodeInstance).when(mockClusterApiService).terminateNode(NAME);\n+\n+        final MvcResult mvcResult = performRequest(delete(String.format(NODE_NAME_URL, NAME)));\n+\n+        Mockito.verify(mockClusterApiService).terminateNode(NAME);\n+        assertResponse(mvcResult, nodeInstance, NodeCreatorUtils.NODE_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailLoadAllInstanceTypesForUnauthorizedUser() throws Exception {\n+        performUnauthorizedRequest(get(LOAD_INSTANCE_TYPES_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadAllowedInstanceTypes() throws Exception {\n+        final MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n+        params.add(\"regionId\", \"1\");\n+        params.add(\"toolInstances\", \"false\");\n+        params.add(\"spot\", \"true\");\n+        Mockito.doReturn(instanceTypes).when(mockClusterApiService).getAllowedInstanceTypes(ID, true);\n+\n+        final MvcResult mvcResult = performRequest(get(LOAD_INSTANCE_TYPES_URL).params(params));\n+\n+        Mockito.verify(mockClusterApiService).getAllowedInstanceTypes(ID, true);\n+        assertResponse(mvcResult, instanceTypes, NodeCreatorUtils.INSTANCE_TYPE_LIST_TYPE);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadAllowedToolInstanceTypes() throws Exception {\n+        final MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n+        params.add(\"regionId\", \"1\");\n+        params.add(\"toolInstances\", \"true\");\n+        params.add(\"spot\", \"false\");\n+        Mockito.doReturn(instanceTypes).when(mockClusterApiService).getAllowedToolInstanceTypes(ID, false);\n+\n+        final MvcResult mvcResult = performRequest(get(LOAD_INSTANCE_TYPES_URL).params(params));\n+\n+        Mockito.verify(mockClusterApiService).getAllowedToolInstanceTypes(ID, false);\n+        assertResponse(mvcResult, instanceTypes, NodeCreatorUtils.INSTANCE_TYPE_LIST_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailLoadAllowedInstanceAndPriceTypesForUnauthorizedUser() throws Exception {\n+        performUnauthorizedRequest(get(LOAD_ALLOWED_INSTANCE_TYPES_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadAllowedInstanceAndPriceTypes() throws Exception {\n+        final MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n+        params.add(\"toolId\", \"1\");\n+        params.add(\"regionId\", \"1\");\n+        params.add(\"spot\", \"false\");\n+        final AllowedInstanceAndPriceTypes allowedInstanceAndPriceTypes =\n+                NodeCreatorUtils.getDefaultAllowedInstanceAndPriceTypes();\n+        Mockito.doReturn(allowedInstanceAndPriceTypes).when(mockClusterApiService)\n+                .getAllowedInstanceAndPriceTypes(ID, ID, false);\n+\n+        final MvcResult mvcResult = performRequest(get(LOAD_ALLOWED_INSTANCE_TYPES_URL).params(params));\n+\n+        Mockito.verify(mockClusterApiService).getAllowedInstanceAndPriceTypes(ID, ID, false);\n+        assertResponse(mvcResult, allowedInstanceAndPriceTypes, NodeCreatorUtils.ALLOWED_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailGetNodeUsageStatisticsForUnauthorizedUser() throws Exception {\n+        performUnauthorizedRequest(get(String.format(NODE_USAGE_URL, NAME)));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldGetNodeUsageStatistics() throws Exception {\n+        final List<MonitoringStats> monitoringStats = Collections.singletonList(new MonitoringStats());\n+        final MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n+        params.add(\"from\", FROM_STRING.replace('T', ' '));\n+        params.add(\"to\", TO_STRING.replace('T', ' '));\n+        Mockito.doReturn(monitoringStats).when(mockClusterApiService)\n+                .getStatsForNode(NAME, from, to);\n+\n+        final MvcResult mvcResult = performRequest(get(String.format(NODE_USAGE_URL, NAME)).params(params));\n+\n+        Mockito.verify(mockClusterApiService).getStatsForNode(NAME, from, to);\n+        assertResponse(mvcResult, monitoringStats, NodeCreatorUtils.MONITORING_STATS_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailDownloadNodeUsageStatisticsReportForUnauthorizedUser() throws Exception {\n+        performUnauthorizedRequest(get(String.format(NODE_STATISTICS_URL, NAME)));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldDownloadNodeUsageStatisticsReport() throws Exception {\n+        final InputStream inputStream = new ByteArrayInputStream(TEST_DATA.getBytes());\n+        final MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n+        params.add(\"from\", FROM_STRING.replace('T', ' '));\n+        params.add(\"to\", TO_STRING.replace('T', ' '));\n+        params.add(\"interval\", \"PT1H\");\n+        Mockito.doReturn(inputStream).when(mockClusterApiService)\n+                .getUsageStatisticsFile(NAME, from, to, Duration.ofHours(1));\n+\n+        final MvcResult mvcResult = performRequest(\n+                get(String.format(NODE_STATISTICS_URL, NAME)).params(params), OCTET_STREAM_CONTENT_TYPE\n+        );\n+\n+        Mockito.verify(mockClusterApiService).getUsageStatisticsFile(NAME, from, to, Duration.ofHours(1));\n+        final String actualResponseData = mvcResult.getResponse().getContentAsString();\n+        Assert.assertEquals(TEST_DATA, actualResponseData);", "originalCommit": "94d0bbe6e68e9b79f50625ae0cca616a139ccfab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM2MDExMQ==", "url": "https://github.com/epam/cloud-pipeline/pull/1459#discussion_r508360111", "bodyText": "Could you please also add the similar test case which covers \"toolInstances\": false?", "author": "tcibinan", "createdAt": "2020-10-20T09:44:29Z", "path": "api/src/test/java/com/epam/pipeline/controller/cluster/ClusterControllerTest.java", "diffHunk": "@@ -0,0 +1,309 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.controller.cluster;\n+\n+import com.epam.pipeline.controller.vo.FilterNodesVO;\n+import com.epam.pipeline.entity.cluster.AllowedInstanceAndPriceTypes;\n+import com.epam.pipeline.entity.cluster.FilterPodsRequest;\n+import com.epam.pipeline.entity.cluster.InstanceType;\n+import com.epam.pipeline.entity.cluster.MasterNode;\n+import com.epam.pipeline.entity.cluster.NodeDisk;\n+import com.epam.pipeline.entity.cluster.NodeInstance;\n+import com.epam.pipeline.entity.cluster.monitoring.MonitoringStats;\n+import com.epam.pipeline.manager.cluster.ClusterApiService;\n+import com.epam.pipeline.test.creator.cluster.NodeCreatorUtils;\n+import com.epam.pipeline.test.web.AbstractControllerTest;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;\n+import org.springframework.security.test.context.support.WithMockUser;\n+import org.springframework.test.web.servlet.MvcResult;\n+import org.springframework.util.LinkedMultiValueMap;\n+import org.springframework.util.MultiValueMap;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.InputStream;\n+import java.time.Duration;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.delete;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+\n+@WebMvcTest(controllers = ClusterController.class)\n+public class ClusterControllerTest extends AbstractControllerTest {\n+\n+    private static final long ID = 1L;\n+    private static final String CLUSTER_URL = SERVLET_PATH + \"/cluster\";\n+    private static final String MASTER_NODES_URL = CLUSTER_URL + \"/master\";\n+    private static final String NODE_URL = CLUSTER_URL + \"/node\";\n+    private static final String INSTANCE_URL = CLUSTER_URL + \"/instance\";\n+    private static final String LOAD_NODES_URL = NODE_URL + \"/loadAll\";\n+    private static final String FILTER_NODES_URL = NODE_URL +\"/filter\";\n+    private static final String LOAD_NODE_URL = NODE_URL + \"/%s/load\";\n+    private static final String NODE_NAME_URL = NODE_URL + \"/%s\";\n+    private static final String LOAD_INSTANCE_TYPES_URL = INSTANCE_URL + \"/loadAll\";\n+    private static final String LOAD_ALLOWED_INSTANCE_TYPES_URL = INSTANCE_URL + \"/allowed\";\n+    private static final String NODE_USAGE_URL = NODE_NAME_URL + \"/usage\";\n+    private static final String NODE_DISKS_URL = NODE_NAME_URL + \"/disks\";\n+    private static final String NODE_STATISTICS_URL = NODE_USAGE_URL + \"/report\";\n+    private static final String PORT = \"7367\";\n+    private static final String NAME = \"testName\";\n+    private static final String TEST_DATA = \"test_data\";\n+    private static final String FROM_STRING = \"2019-04-01T09:08:07\";\n+    private static final String TO_STRING = \"2020-05-02T12:11:10\";\n+    private static final String OCTET_STREAM_CONTENT_TYPE = \"application/octet-stream\";\n+    private final NodeInstance nodeInstance = NodeCreatorUtils.getDefaultNodeInstance();\n+    private final List<NodeInstance> nodeInstances = Collections.singletonList(nodeInstance);\n+    private final List<InstanceType>\n+            instanceTypes = Collections.singletonList(NodeCreatorUtils.getDefaultInstanceType());\n+    private final LocalDateTime from = LocalDateTime.parse(FROM_STRING, DateTimeFormatter.ISO_LOCAL_DATE_TIME);\n+    private final LocalDateTime to = LocalDateTime.parse(TO_STRING, DateTimeFormatter.ISO_LOCAL_DATE_TIME);\n+\n+    @Autowired\n+    private ClusterApiService mockClusterApiService;\n+\n+    @Test\n+    public void shouldFailLoadMasterNodesForUnauthorizedUser() throws Exception {\n+        performUnauthorizedRequest(get(MASTER_NODES_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadMasterNodes() throws Exception {\n+        final List<MasterNode> masterNodes = Collections.singletonList(MasterNode.fromNode(\n+                NodeCreatorUtils.getDefaultNode(), PORT));\n+        Mockito.doReturn(masterNodes).when(mockClusterApiService).getMasterNodes();\n+\n+        final MvcResult mvcResult = performRequest(get(MASTER_NODES_URL));\n+\n+        Mockito.verify(mockClusterApiService).getMasterNodes();\n+        assertResponse(mvcResult, masterNodes, NodeCreatorUtils.MASTER_NODE_LIST_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailLoadNodesForUnauthorizedUser() throws Exception {\n+        performUnauthorizedRequest(get(LOAD_NODES_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadNodes() throws Exception {\n+        Mockito.doReturn(nodeInstances).when(mockClusterApiService).getNodes();\n+\n+        final MvcResult mvcResult = performRequest(get(LOAD_NODES_URL));\n+\n+        Mockito.verify(mockClusterApiService).getNodes();\n+        assertResponse(mvcResult, nodeInstances, NodeCreatorUtils.NODE_INSTANCE_LIST_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailFilterNodesForUnauthorizedUser() throws Exception {\n+        performUnauthorizedRequest(post(FILTER_NODES_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldFilterNodes() throws Exception {\n+        final FilterNodesVO filterNodesVO = NodeCreatorUtils.getDefaultFilterNodesVO();\n+        final String content = getObjectMapper().writeValueAsString(filterNodesVO);\n+        Mockito.doReturn(nodeInstances).when(mockClusterApiService).filterNodes(Mockito.refEq(filterNodesVO));\n+\n+        final MvcResult mvcResult = performRequest(post(FILTER_NODES_URL).content(content));\n+\n+        Mockito.verify(mockClusterApiService).filterNodes(Mockito.refEq(filterNodesVO));\n+        assertResponse(mvcResult, nodeInstances, NodeCreatorUtils.NODE_INSTANCE_LIST_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailLoadNodeForUnauthorizedUser() throws Exception {\n+        performUnauthorizedRequest(get(String.format(LOAD_NODE_URL, NAME)));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadNode() throws Exception {\n+        Mockito.doReturn(nodeInstance).when(mockClusterApiService).getNode(NAME);\n+\n+        final MvcResult mvcResult = performRequest(get(String.format(LOAD_NODE_URL, NAME)));\n+\n+        Mockito.verify(mockClusterApiService).getNode(NAME);\n+        assertResponse(mvcResult, nodeInstance, NodeCreatorUtils.NODE_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailLoadNodeFilteredForUnauthorizedUser() throws Exception {\n+        performUnauthorizedRequest(post(LOAD_NODES_URL, NAME));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadNodeFiltered() throws Exception {\n+        final FilterPodsRequest filterPodsRequest = NodeCreatorUtils.getDefaultFilterPodsRequest();\n+        final String content = getObjectMapper().writeValueAsString(filterPodsRequest);\n+        Mockito.doReturn(nodeInstance).when(mockClusterApiService)\n+                .getNode(Mockito.eq(NAME), Mockito.refEq(filterPodsRequest));\n+\n+        final MvcResult mvcResult = performRequest(post(String.format(LOAD_NODE_URL, NAME)).content(content));\n+\n+        Mockito.verify(mockClusterApiService)\n+                .getNode(Mockito.eq(NAME), Mockito.refEq(filterPodsRequest));\n+        assertResponse(mvcResult, nodeInstance, NodeCreatorUtils.NODE_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailTerminateNodeForUnauthorizedUser() throws Exception {\n+        performUnauthorizedRequest(delete(NODE_NAME_URL, NAME));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldTerminateNode() throws Exception {\n+        Mockito.doReturn(nodeInstance).when(mockClusterApiService).terminateNode(NAME);\n+\n+        final MvcResult mvcResult = performRequest(delete(String.format(NODE_NAME_URL, NAME)));\n+\n+        Mockito.verify(mockClusterApiService).terminateNode(NAME);\n+        assertResponse(mvcResult, nodeInstance, NodeCreatorUtils.NODE_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailLoadAllInstanceTypesForUnauthorizedUser() throws Exception {\n+        performUnauthorizedRequest(get(LOAD_INSTANCE_TYPES_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadAllowedInstanceTypes() throws Exception {\n+        final MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n+        params.add(\"regionId\", \"1\");\n+        params.add(\"toolInstances\", \"false\");\n+        params.add(\"spot\", \"true\");\n+        Mockito.doReturn(instanceTypes).when(mockClusterApiService).getAllowedInstanceTypes(ID, true);\n+\n+        final MvcResult mvcResult = performRequest(get(LOAD_INSTANCE_TYPES_URL).params(params));\n+\n+        Mockito.verify(mockClusterApiService).getAllowedInstanceTypes(ID, true);\n+        assertResponse(mvcResult, instanceTypes, NodeCreatorUtils.INSTANCE_TYPE_LIST_TYPE);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadAllowedToolInstanceTypes() throws Exception {\n+        final MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n+        params.add(\"regionId\", \"1\");\n+        params.add(\"toolInstances\", \"true\");", "originalCommit": "94d0bbe6e68e9b79f50625ae0cca616a139ccfab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM2ODEwOQ==", "url": "https://github.com/epam/cloud-pipeline/pull/1459#discussion_r508368109", "bodyText": "It would be nice to avoid such date time conversions.\nWe can explicitly specify request formatter and use it here to build inputs.\nclass ClusterControllerTest {\n\n    ...\n\n    private final DateTimeFormatter REQUEST_FORMATTER = DateTimeFormatter.ofPattern(\"iso pattern without T\");\n    private final DateTimeFormatter DEFAULT_FORMATTER = DateTimeFormatter.ISO_LOCAL_DATE_TIME;\n    private final LocalDateTime from = LocalDateTime.parse(\"...\", DEFAULT_FORMATTER);\n    private final LocalDateTime to = LocalDateTime.parse(\"...\", DEFAULT_FORMATTER);\n\n    @Test\n    @WithMockUser\n    public void shouldGetNodeUsageStatistics() throws Exception {\n        final List<MonitoringStats> monitoringStats = Collections.singletonList(new MonitoringStats());\n        final MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n        params.add(\"from\", from.format(REQUEST_FORMATTER));\n\n    ...", "author": "tcibinan", "createdAt": "2020-10-20T09:56:31Z", "path": "api/src/test/java/com/epam/pipeline/controller/cluster/ClusterControllerTest.java", "diffHunk": "@@ -0,0 +1,309 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.controller.cluster;\n+\n+import com.epam.pipeline.controller.vo.FilterNodesVO;\n+import com.epam.pipeline.entity.cluster.AllowedInstanceAndPriceTypes;\n+import com.epam.pipeline.entity.cluster.FilterPodsRequest;\n+import com.epam.pipeline.entity.cluster.InstanceType;\n+import com.epam.pipeline.entity.cluster.MasterNode;\n+import com.epam.pipeline.entity.cluster.NodeDisk;\n+import com.epam.pipeline.entity.cluster.NodeInstance;\n+import com.epam.pipeline.entity.cluster.monitoring.MonitoringStats;\n+import com.epam.pipeline.manager.cluster.ClusterApiService;\n+import com.epam.pipeline.test.creator.cluster.NodeCreatorUtils;\n+import com.epam.pipeline.test.web.AbstractControllerTest;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;\n+import org.springframework.security.test.context.support.WithMockUser;\n+import org.springframework.test.web.servlet.MvcResult;\n+import org.springframework.util.LinkedMultiValueMap;\n+import org.springframework.util.MultiValueMap;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.InputStream;\n+import java.time.Duration;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.delete;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+\n+@WebMvcTest(controllers = ClusterController.class)\n+public class ClusterControllerTest extends AbstractControllerTest {\n+\n+    private static final long ID = 1L;\n+    private static final String CLUSTER_URL = SERVLET_PATH + \"/cluster\";\n+    private static final String MASTER_NODES_URL = CLUSTER_URL + \"/master\";\n+    private static final String NODE_URL = CLUSTER_URL + \"/node\";\n+    private static final String INSTANCE_URL = CLUSTER_URL + \"/instance\";\n+    private static final String LOAD_NODES_URL = NODE_URL + \"/loadAll\";\n+    private static final String FILTER_NODES_URL = NODE_URL +\"/filter\";\n+    private static final String LOAD_NODE_URL = NODE_URL + \"/%s/load\";\n+    private static final String NODE_NAME_URL = NODE_URL + \"/%s\";\n+    private static final String LOAD_INSTANCE_TYPES_URL = INSTANCE_URL + \"/loadAll\";\n+    private static final String LOAD_ALLOWED_INSTANCE_TYPES_URL = INSTANCE_URL + \"/allowed\";\n+    private static final String NODE_USAGE_URL = NODE_NAME_URL + \"/usage\";\n+    private static final String NODE_DISKS_URL = NODE_NAME_URL + \"/disks\";\n+    private static final String NODE_STATISTICS_URL = NODE_USAGE_URL + \"/report\";\n+    private static final String PORT = \"7367\";\n+    private static final String NAME = \"testName\";\n+    private static final String TEST_DATA = \"test_data\";\n+    private static final String FROM_STRING = \"2019-04-01T09:08:07\";\n+    private static final String TO_STRING = \"2020-05-02T12:11:10\";\n+    private static final String OCTET_STREAM_CONTENT_TYPE = \"application/octet-stream\";\n+    private final NodeInstance nodeInstance = NodeCreatorUtils.getDefaultNodeInstance();\n+    private final List<NodeInstance> nodeInstances = Collections.singletonList(nodeInstance);\n+    private final List<InstanceType>\n+            instanceTypes = Collections.singletonList(NodeCreatorUtils.getDefaultInstanceType());\n+    private final LocalDateTime from = LocalDateTime.parse(FROM_STRING, DateTimeFormatter.ISO_LOCAL_DATE_TIME);\n+    private final LocalDateTime to = LocalDateTime.parse(TO_STRING, DateTimeFormatter.ISO_LOCAL_DATE_TIME);\n+\n+    @Autowired\n+    private ClusterApiService mockClusterApiService;\n+\n+    @Test\n+    public void shouldFailLoadMasterNodesForUnauthorizedUser() throws Exception {\n+        performUnauthorizedRequest(get(MASTER_NODES_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadMasterNodes() throws Exception {\n+        final List<MasterNode> masterNodes = Collections.singletonList(MasterNode.fromNode(\n+                NodeCreatorUtils.getDefaultNode(), PORT));\n+        Mockito.doReturn(masterNodes).when(mockClusterApiService).getMasterNodes();\n+\n+        final MvcResult mvcResult = performRequest(get(MASTER_NODES_URL));\n+\n+        Mockito.verify(mockClusterApiService).getMasterNodes();\n+        assertResponse(mvcResult, masterNodes, NodeCreatorUtils.MASTER_NODE_LIST_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailLoadNodesForUnauthorizedUser() throws Exception {\n+        performUnauthorizedRequest(get(LOAD_NODES_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadNodes() throws Exception {\n+        Mockito.doReturn(nodeInstances).when(mockClusterApiService).getNodes();\n+\n+        final MvcResult mvcResult = performRequest(get(LOAD_NODES_URL));\n+\n+        Mockito.verify(mockClusterApiService).getNodes();\n+        assertResponse(mvcResult, nodeInstances, NodeCreatorUtils.NODE_INSTANCE_LIST_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailFilterNodesForUnauthorizedUser() throws Exception {\n+        performUnauthorizedRequest(post(FILTER_NODES_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldFilterNodes() throws Exception {\n+        final FilterNodesVO filterNodesVO = NodeCreatorUtils.getDefaultFilterNodesVO();\n+        final String content = getObjectMapper().writeValueAsString(filterNodesVO);\n+        Mockito.doReturn(nodeInstances).when(mockClusterApiService).filterNodes(Mockito.refEq(filterNodesVO));\n+\n+        final MvcResult mvcResult = performRequest(post(FILTER_NODES_URL).content(content));\n+\n+        Mockito.verify(mockClusterApiService).filterNodes(Mockito.refEq(filterNodesVO));\n+        assertResponse(mvcResult, nodeInstances, NodeCreatorUtils.NODE_INSTANCE_LIST_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailLoadNodeForUnauthorizedUser() throws Exception {\n+        performUnauthorizedRequest(get(String.format(LOAD_NODE_URL, NAME)));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadNode() throws Exception {\n+        Mockito.doReturn(nodeInstance).when(mockClusterApiService).getNode(NAME);\n+\n+        final MvcResult mvcResult = performRequest(get(String.format(LOAD_NODE_URL, NAME)));\n+\n+        Mockito.verify(mockClusterApiService).getNode(NAME);\n+        assertResponse(mvcResult, nodeInstance, NodeCreatorUtils.NODE_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailLoadNodeFilteredForUnauthorizedUser() throws Exception {\n+        performUnauthorizedRequest(post(LOAD_NODES_URL, NAME));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadNodeFiltered() throws Exception {\n+        final FilterPodsRequest filterPodsRequest = NodeCreatorUtils.getDefaultFilterPodsRequest();\n+        final String content = getObjectMapper().writeValueAsString(filterPodsRequest);\n+        Mockito.doReturn(nodeInstance).when(mockClusterApiService)\n+                .getNode(Mockito.eq(NAME), Mockito.refEq(filterPodsRequest));\n+\n+        final MvcResult mvcResult = performRequest(post(String.format(LOAD_NODE_URL, NAME)).content(content));\n+\n+        Mockito.verify(mockClusterApiService)\n+                .getNode(Mockito.eq(NAME), Mockito.refEq(filterPodsRequest));\n+        assertResponse(mvcResult, nodeInstance, NodeCreatorUtils.NODE_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailTerminateNodeForUnauthorizedUser() throws Exception {\n+        performUnauthorizedRequest(delete(NODE_NAME_URL, NAME));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldTerminateNode() throws Exception {\n+        Mockito.doReturn(nodeInstance).when(mockClusterApiService).terminateNode(NAME);\n+\n+        final MvcResult mvcResult = performRequest(delete(String.format(NODE_NAME_URL, NAME)));\n+\n+        Mockito.verify(mockClusterApiService).terminateNode(NAME);\n+        assertResponse(mvcResult, nodeInstance, NodeCreatorUtils.NODE_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailLoadAllInstanceTypesForUnauthorizedUser() throws Exception {\n+        performUnauthorizedRequest(get(LOAD_INSTANCE_TYPES_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadAllowedInstanceTypes() throws Exception {\n+        final MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n+        params.add(\"regionId\", \"1\");\n+        params.add(\"toolInstances\", \"false\");\n+        params.add(\"spot\", \"true\");\n+        Mockito.doReturn(instanceTypes).when(mockClusterApiService).getAllowedInstanceTypes(ID, true);\n+\n+        final MvcResult mvcResult = performRequest(get(LOAD_INSTANCE_TYPES_URL).params(params));\n+\n+        Mockito.verify(mockClusterApiService).getAllowedInstanceTypes(ID, true);\n+        assertResponse(mvcResult, instanceTypes, NodeCreatorUtils.INSTANCE_TYPE_LIST_TYPE);\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadAllowedToolInstanceTypes() throws Exception {\n+        final MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n+        params.add(\"regionId\", \"1\");\n+        params.add(\"toolInstances\", \"true\");\n+        params.add(\"spot\", \"false\");\n+        Mockito.doReturn(instanceTypes).when(mockClusterApiService).getAllowedToolInstanceTypes(ID, false);\n+\n+        final MvcResult mvcResult = performRequest(get(LOAD_INSTANCE_TYPES_URL).params(params));\n+\n+        Mockito.verify(mockClusterApiService).getAllowedToolInstanceTypes(ID, false);\n+        assertResponse(mvcResult, instanceTypes, NodeCreatorUtils.INSTANCE_TYPE_LIST_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailLoadAllowedInstanceAndPriceTypesForUnauthorizedUser() throws Exception {\n+        performUnauthorizedRequest(get(LOAD_ALLOWED_INSTANCE_TYPES_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadAllowedInstanceAndPriceTypes() throws Exception {\n+        final MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n+        params.add(\"toolId\", \"1\");\n+        params.add(\"regionId\", \"1\");\n+        params.add(\"spot\", \"false\");\n+        final AllowedInstanceAndPriceTypes allowedInstanceAndPriceTypes =\n+                NodeCreatorUtils.getDefaultAllowedInstanceAndPriceTypes();\n+        Mockito.doReturn(allowedInstanceAndPriceTypes).when(mockClusterApiService)\n+                .getAllowedInstanceAndPriceTypes(ID, ID, false);\n+\n+        final MvcResult mvcResult = performRequest(get(LOAD_ALLOWED_INSTANCE_TYPES_URL).params(params));\n+\n+        Mockito.verify(mockClusterApiService).getAllowedInstanceAndPriceTypes(ID, ID, false);\n+        assertResponse(mvcResult, allowedInstanceAndPriceTypes, NodeCreatorUtils.ALLOWED_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailGetNodeUsageStatisticsForUnauthorizedUser() throws Exception {\n+        performUnauthorizedRequest(get(String.format(NODE_USAGE_URL, NAME)));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldGetNodeUsageStatistics() throws Exception {\n+        final List<MonitoringStats> monitoringStats = Collections.singletonList(new MonitoringStats());\n+        final MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n+        params.add(\"from\", FROM_STRING.replace('T', ' '));", "originalCommit": "94d0bbe6e68e9b79f50625ae0cca616a139ccfab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM2OTM2NA==", "url": "https://github.com/epam/cloud-pipeline/pull/1459#discussion_r508369364", "bodyText": "PMD expects us to get rid of all string literals duplications. So could you please extract variables for regionId, toolInstances and etc.", "author": "tcibinan", "createdAt": "2020-10-20T09:58:21Z", "path": "api/src/test/java/com/epam/pipeline/controller/cluster/ClusterControllerTest.java", "diffHunk": "@@ -0,0 +1,309 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.controller.cluster;\n+\n+import com.epam.pipeline.controller.vo.FilterNodesVO;\n+import com.epam.pipeline.entity.cluster.AllowedInstanceAndPriceTypes;\n+import com.epam.pipeline.entity.cluster.FilterPodsRequest;\n+import com.epam.pipeline.entity.cluster.InstanceType;\n+import com.epam.pipeline.entity.cluster.MasterNode;\n+import com.epam.pipeline.entity.cluster.NodeDisk;\n+import com.epam.pipeline.entity.cluster.NodeInstance;\n+import com.epam.pipeline.entity.cluster.monitoring.MonitoringStats;\n+import com.epam.pipeline.manager.cluster.ClusterApiService;\n+import com.epam.pipeline.test.creator.cluster.NodeCreatorUtils;\n+import com.epam.pipeline.test.web.AbstractControllerTest;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;\n+import org.springframework.security.test.context.support.WithMockUser;\n+import org.springframework.test.web.servlet.MvcResult;\n+import org.springframework.util.LinkedMultiValueMap;\n+import org.springframework.util.MultiValueMap;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.InputStream;\n+import java.time.Duration;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.delete;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+\n+@WebMvcTest(controllers = ClusterController.class)\n+public class ClusterControllerTest extends AbstractControllerTest {\n+\n+    private static final long ID = 1L;\n+    private static final String CLUSTER_URL = SERVLET_PATH + \"/cluster\";\n+    private static final String MASTER_NODES_URL = CLUSTER_URL + \"/master\";\n+    private static final String NODE_URL = CLUSTER_URL + \"/node\";\n+    private static final String INSTANCE_URL = CLUSTER_URL + \"/instance\";\n+    private static final String LOAD_NODES_URL = NODE_URL + \"/loadAll\";\n+    private static final String FILTER_NODES_URL = NODE_URL +\"/filter\";\n+    private static final String LOAD_NODE_URL = NODE_URL + \"/%s/load\";\n+    private static final String NODE_NAME_URL = NODE_URL + \"/%s\";\n+    private static final String LOAD_INSTANCE_TYPES_URL = INSTANCE_URL + \"/loadAll\";\n+    private static final String LOAD_ALLOWED_INSTANCE_TYPES_URL = INSTANCE_URL + \"/allowed\";\n+    private static final String NODE_USAGE_URL = NODE_NAME_URL + \"/usage\";\n+    private static final String NODE_DISKS_URL = NODE_NAME_URL + \"/disks\";\n+    private static final String NODE_STATISTICS_URL = NODE_USAGE_URL + \"/report\";\n+    private static final String PORT = \"7367\";\n+    private static final String NAME = \"testName\";\n+    private static final String TEST_DATA = \"test_data\";\n+    private static final String FROM_STRING = \"2019-04-01T09:08:07\";\n+    private static final String TO_STRING = \"2020-05-02T12:11:10\";\n+    private static final String OCTET_STREAM_CONTENT_TYPE = \"application/octet-stream\";\n+    private final NodeInstance nodeInstance = NodeCreatorUtils.getDefaultNodeInstance();\n+    private final List<NodeInstance> nodeInstances = Collections.singletonList(nodeInstance);\n+    private final List<InstanceType>\n+            instanceTypes = Collections.singletonList(NodeCreatorUtils.getDefaultInstanceType());\n+    private final LocalDateTime from = LocalDateTime.parse(FROM_STRING, DateTimeFormatter.ISO_LOCAL_DATE_TIME);\n+    private final LocalDateTime to = LocalDateTime.parse(TO_STRING, DateTimeFormatter.ISO_LOCAL_DATE_TIME);\n+\n+    @Autowired\n+    private ClusterApiService mockClusterApiService;\n+\n+    @Test\n+    public void shouldFailLoadMasterNodesForUnauthorizedUser() throws Exception {\n+        performUnauthorizedRequest(get(MASTER_NODES_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadMasterNodes() throws Exception {\n+        final List<MasterNode> masterNodes = Collections.singletonList(MasterNode.fromNode(\n+                NodeCreatorUtils.getDefaultNode(), PORT));\n+        Mockito.doReturn(masterNodes).when(mockClusterApiService).getMasterNodes();\n+\n+        final MvcResult mvcResult = performRequest(get(MASTER_NODES_URL));\n+\n+        Mockito.verify(mockClusterApiService).getMasterNodes();\n+        assertResponse(mvcResult, masterNodes, NodeCreatorUtils.MASTER_NODE_LIST_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailLoadNodesForUnauthorizedUser() throws Exception {\n+        performUnauthorizedRequest(get(LOAD_NODES_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadNodes() throws Exception {\n+        Mockito.doReturn(nodeInstances).when(mockClusterApiService).getNodes();\n+\n+        final MvcResult mvcResult = performRequest(get(LOAD_NODES_URL));\n+\n+        Mockito.verify(mockClusterApiService).getNodes();\n+        assertResponse(mvcResult, nodeInstances, NodeCreatorUtils.NODE_INSTANCE_LIST_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailFilterNodesForUnauthorizedUser() throws Exception {\n+        performUnauthorizedRequest(post(FILTER_NODES_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldFilterNodes() throws Exception {\n+        final FilterNodesVO filterNodesVO = NodeCreatorUtils.getDefaultFilterNodesVO();\n+        final String content = getObjectMapper().writeValueAsString(filterNodesVO);\n+        Mockito.doReturn(nodeInstances).when(mockClusterApiService).filterNodes(Mockito.refEq(filterNodesVO));\n+\n+        final MvcResult mvcResult = performRequest(post(FILTER_NODES_URL).content(content));\n+\n+        Mockito.verify(mockClusterApiService).filterNodes(Mockito.refEq(filterNodesVO));\n+        assertResponse(mvcResult, nodeInstances, NodeCreatorUtils.NODE_INSTANCE_LIST_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailLoadNodeForUnauthorizedUser() throws Exception {\n+        performUnauthorizedRequest(get(String.format(LOAD_NODE_URL, NAME)));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadNode() throws Exception {\n+        Mockito.doReturn(nodeInstance).when(mockClusterApiService).getNode(NAME);\n+\n+        final MvcResult mvcResult = performRequest(get(String.format(LOAD_NODE_URL, NAME)));\n+\n+        Mockito.verify(mockClusterApiService).getNode(NAME);\n+        assertResponse(mvcResult, nodeInstance, NodeCreatorUtils.NODE_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailLoadNodeFilteredForUnauthorizedUser() throws Exception {\n+        performUnauthorizedRequest(post(LOAD_NODES_URL, NAME));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadNodeFiltered() throws Exception {\n+        final FilterPodsRequest filterPodsRequest = NodeCreatorUtils.getDefaultFilterPodsRequest();\n+        final String content = getObjectMapper().writeValueAsString(filterPodsRequest);\n+        Mockito.doReturn(nodeInstance).when(mockClusterApiService)\n+                .getNode(Mockito.eq(NAME), Mockito.refEq(filterPodsRequest));\n+\n+        final MvcResult mvcResult = performRequest(post(String.format(LOAD_NODE_URL, NAME)).content(content));\n+\n+        Mockito.verify(mockClusterApiService)\n+                .getNode(Mockito.eq(NAME), Mockito.refEq(filterPodsRequest));\n+        assertResponse(mvcResult, nodeInstance, NodeCreatorUtils.NODE_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailTerminateNodeForUnauthorizedUser() throws Exception {\n+        performUnauthorizedRequest(delete(NODE_NAME_URL, NAME));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldTerminateNode() throws Exception {\n+        Mockito.doReturn(nodeInstance).when(mockClusterApiService).terminateNode(NAME);\n+\n+        final MvcResult mvcResult = performRequest(delete(String.format(NODE_NAME_URL, NAME)));\n+\n+        Mockito.verify(mockClusterApiService).terminateNode(NAME);\n+        assertResponse(mvcResult, nodeInstance, NodeCreatorUtils.NODE_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailLoadAllInstanceTypesForUnauthorizedUser() throws Exception {\n+        performUnauthorizedRequest(get(LOAD_INSTANCE_TYPES_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadAllowedInstanceTypes() throws Exception {\n+        final MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n+        params.add(\"regionId\", \"1\");", "originalCommit": "94d0bbe6e68e9b79f50625ae0cca616a139ccfab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0a18547f5d5352b29cc251532f3a94e17b746c44", "url": "https://github.com/epam/cloud-pipeline/commit/0a18547f5d5352b29cc251532f3a94e17b746c44", "message": "Issue #1405: More constants created, assertion for filename added", "committedDate": "2020-10-20T11:14:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTE1MTY1MA==", "url": "https://github.com/epam/cloud-pipeline/pull/1459#discussion_r509151650", "bodyText": "Please extract String.valueOf calls to fields as well.", "author": "tcibinan", "createdAt": "2020-10-21T10:02:47Z", "path": "api/src/test/java/com/epam/pipeline/controller/cluster/ClusterControllerTest.java", "diffHunk": "@@ -0,0 +1,321 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.controller.cluster;\n+\n+import com.epam.pipeline.controller.vo.FilterNodesVO;\n+import com.epam.pipeline.entity.cluster.AllowedInstanceAndPriceTypes;\n+import com.epam.pipeline.entity.cluster.FilterPodsRequest;\n+import com.epam.pipeline.entity.cluster.InstanceType;\n+import com.epam.pipeline.entity.cluster.MasterNode;\n+import com.epam.pipeline.entity.cluster.NodeDisk;\n+import com.epam.pipeline.entity.cluster.NodeInstance;\n+import com.epam.pipeline.entity.cluster.monitoring.MonitoringStats;\n+import com.epam.pipeline.manager.cluster.ClusterApiService;\n+import com.epam.pipeline.test.creator.cluster.NodeCreatorUtils;\n+import com.epam.pipeline.test.web.AbstractControllerTest;\n+import org.assertj.core.api.Assertions;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;\n+import org.springframework.security.test.context.support.WithMockUser;\n+import org.springframework.test.web.servlet.MvcResult;\n+import org.springframework.util.LinkedMultiValueMap;\n+import org.springframework.util.MultiValueMap;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.InputStream;\n+import java.time.Duration;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.delete;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+\n+@WebMvcTest(controllers = ClusterController.class)\n+public class ClusterControllerTest extends AbstractControllerTest {\n+\n+    private static final long ID = 1L;\n+    private static final String CLUSTER_URL = SERVLET_PATH + \"/cluster\";\n+    private static final String MASTER_NODES_URL = CLUSTER_URL + \"/master\";\n+    private static final String NODE_URL = CLUSTER_URL + \"/node\";\n+    private static final String INSTANCE_URL = CLUSTER_URL + \"/instance\";\n+    private static final String LOAD_NODES_URL = NODE_URL + \"/loadAll\";\n+    private static final String FILTER_NODES_URL = NODE_URL +\"/filter\";\n+    private static final String LOAD_NODE_URL = NODE_URL + \"/%s/load\";\n+    private static final String NODE_NAME_URL = NODE_URL + \"/%s\";\n+    private static final String LOAD_INSTANCE_TYPES_URL = INSTANCE_URL + \"/loadAll\";\n+    private static final String LOAD_ALLOWED_INSTANCE_TYPES_URL = INSTANCE_URL + \"/allowed\";\n+    private static final String NODE_USAGE_URL = NODE_NAME_URL + \"/usage\";\n+    private static final String NODE_DISKS_URL = NODE_NAME_URL + \"/disks\";\n+    private static final String NODE_STATISTICS_URL = NODE_USAGE_URL + \"/report\";\n+    private static final String PORT = \"7367\";\n+    private static final String NAME = \"testName\";\n+    private static final String TEST_DATA = \"test_data\";\n+    private static final String OCTET_STREAM_CONTENT_TYPE = \"application/octet-stream\";\n+    private static final String TOOL_INSTANCES = \"toolInstances\";\n+    private static final String REGION_ID = \"regionId\";\n+    private static final String SPOT = \"spot\";\n+    private static final String TOOL_ID = \"toolId\";\n+    private static final String FROM = \"from\";\n+    private static final String TO = \"to\";\n+    private static final String FROM_STRING = \"2019-04-01T09:08:07\";\n+    private static final String TO_STRING = \"2020-05-02T12:11:10\";\n+    private static final DateTimeFormatter REQUEST_FORMATTER = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\");\n+    private static final DateTimeFormatter DEFAULT_FORMATTER = DateTimeFormatter.ISO_LOCAL_DATE_TIME;\n+    private final LocalDateTime from = LocalDateTime.parse(FROM_STRING, DEFAULT_FORMATTER);\n+    private final LocalDateTime to = LocalDateTime.parse(TO_STRING, DEFAULT_FORMATTER);\n+    private final NodeInstance nodeInstance = NodeCreatorUtils.getDefaultNodeInstance();\n+    private final List<NodeInstance> nodeInstances = Collections.singletonList(nodeInstance);\n+    private final List<InstanceType>\n+            instanceTypes = Collections.singletonList(NodeCreatorUtils.getDefaultInstanceType());\n+\n+    @Autowired\n+    private ClusterApiService mockClusterApiService;\n+\n+    @Test\n+    public void shouldFailLoadMasterNodesForUnauthorizedUser() throws Exception {\n+        performUnauthorizedRequest(get(MASTER_NODES_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadMasterNodes() throws Exception {\n+        final List<MasterNode> masterNodes = Collections.singletonList(MasterNode.fromNode(\n+                NodeCreatorUtils.getDefaultNode(), PORT));\n+        Mockito.doReturn(masterNodes).when(mockClusterApiService).getMasterNodes();\n+\n+        final MvcResult mvcResult = performRequest(get(MASTER_NODES_URL));\n+\n+        Mockito.verify(mockClusterApiService).getMasterNodes();\n+        assertResponse(mvcResult, masterNodes, NodeCreatorUtils.MASTER_NODE_LIST_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailLoadNodesForUnauthorizedUser() throws Exception {\n+        performUnauthorizedRequest(get(LOAD_NODES_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadNodes() throws Exception {\n+        Mockito.doReturn(nodeInstances).when(mockClusterApiService).getNodes();\n+\n+        final MvcResult mvcResult = performRequest(get(LOAD_NODES_URL));\n+\n+        Mockito.verify(mockClusterApiService).getNodes();\n+        assertResponse(mvcResult, nodeInstances, NodeCreatorUtils.NODE_INSTANCE_LIST_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailFilterNodesForUnauthorizedUser() throws Exception {\n+        performUnauthorizedRequest(post(FILTER_NODES_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldFilterNodes() throws Exception {\n+        final FilterNodesVO filterNodesVO = NodeCreatorUtils.getDefaultFilterNodesVO();\n+        final String content = getObjectMapper().writeValueAsString(filterNodesVO);\n+        Mockito.doReturn(nodeInstances).when(mockClusterApiService).filterNodes(Mockito.refEq(filterNodesVO));\n+\n+        final MvcResult mvcResult = performRequest(post(FILTER_NODES_URL).content(content));\n+\n+        Mockito.verify(mockClusterApiService).filterNodes(Mockito.refEq(filterNodesVO));\n+        assertResponse(mvcResult, nodeInstances, NodeCreatorUtils.NODE_INSTANCE_LIST_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailLoadNodeForUnauthorizedUser() throws Exception {\n+        performUnauthorizedRequest(get(String.format(LOAD_NODE_URL, NAME)));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadNode() throws Exception {\n+        Mockito.doReturn(nodeInstance).when(mockClusterApiService).getNode(NAME);\n+\n+        final MvcResult mvcResult = performRequest(get(String.format(LOAD_NODE_URL, NAME)));\n+\n+        Mockito.verify(mockClusterApiService).getNode(NAME);\n+        assertResponse(mvcResult, nodeInstance, NodeCreatorUtils.NODE_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailLoadNodeFilteredForUnauthorizedUser() throws Exception {\n+        performUnauthorizedRequest(post(LOAD_NODES_URL, NAME));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadNodeFiltered() throws Exception {\n+        final FilterPodsRequest filterPodsRequest = NodeCreatorUtils.getDefaultFilterPodsRequest();\n+        final String content = getObjectMapper().writeValueAsString(filterPodsRequest);\n+        Mockito.doReturn(nodeInstance).when(mockClusterApiService)\n+                .getNode(Mockito.eq(NAME), Mockito.refEq(filterPodsRequest));\n+\n+        final MvcResult mvcResult = performRequest(post(String.format(LOAD_NODE_URL, NAME)).content(content));\n+\n+        Mockito.verify(mockClusterApiService)\n+                .getNode(Mockito.eq(NAME), Mockito.refEq(filterPodsRequest));\n+        assertResponse(mvcResult, nodeInstance, NodeCreatorUtils.NODE_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailTerminateNodeForUnauthorizedUser() throws Exception {\n+        performUnauthorizedRequest(delete(NODE_NAME_URL, NAME));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldTerminateNode() throws Exception {\n+        Mockito.doReturn(nodeInstance).when(mockClusterApiService).terminateNode(NAME);\n+\n+        final MvcResult mvcResult = performRequest(delete(String.format(NODE_NAME_URL, NAME)));\n+\n+        Mockito.verify(mockClusterApiService).terminateNode(NAME);\n+        assertResponse(mvcResult, nodeInstance, NodeCreatorUtils.NODE_INSTANCE_TYPE);\n+    }\n+\n+    @Test\n+    public void shouldFailLoadAllInstanceTypesForUnauthorizedUser() throws Exception {\n+        performUnauthorizedRequest(get(LOAD_INSTANCE_TYPES_URL));\n+    }\n+\n+    @Test\n+    @WithMockUser\n+    public void shouldLoadAllowedInstanceTypes() throws Exception {\n+        final MultiValueMap<String, String> params = new LinkedMultiValueMap<>();\n+        params.add(REGION_ID, String.valueOf(ID));\n+        params.add(TOOL_INSTANCES, String.valueOf(false));\n+        params.add(SPOT, String.valueOf(true));", "originalCommit": "0a18547f5d5352b29cc251532f3a94e17b746c44", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "eb073d4da6de6a9faa5709bef867ab74a2ad33ea", "url": "https://github.com/epam/cloud-pipeline/commit/eb073d4da6de6a9faa5709bef867ab74a2ad33ea", "message": "Issue #1405: Extracted String.valueOf() values to constant fields", "committedDate": "2020-10-21T11:03:45Z", "type": "commit"}, {"oid": "0177a3a226ad10c07e73f73c7bab6616054b3eed", "url": "https://github.com/epam/cloud-pipeline/commit/0177a3a226ad10c07e73f73c7bab6616054b3eed", "message": "Issue #1405: Unused import removed", "committedDate": "2020-10-23T10:10:34Z", "type": "commit"}]}