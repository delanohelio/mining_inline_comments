{"pr_number": 944, "pr_title": "Issue 938 Start run configuration by schedule", "pr_createdAt": "2020-02-06T11:09:54Z", "pr_url": "https://github.com/epam/cloud-pipeline/pull/944", "timeline": [{"oid": "055d7ced5b554ee73e8e59d9ba1a41c8d53f9cf6", "url": "https://github.com/epam/cloud-pipeline/commit/055d7ced5b554ee73e8e59d9ba1a41c8d53f9cf6", "message": "(issue #938) expand Run Schedule Api to be able to schedule to run Detached Configurations", "committedDate": "2020-02-05T11:40:45Z", "type": "commit"}, {"oid": "d66ee01ff4cde1d55f17a40b751d13ad5e3e5246", "url": "https://github.com/epam/cloud-pipeline/commit/d66ee01ff4cde1d55f17a40b751d13ad5e3e5246", "message": "(issue #938) refactor code to unify work with pipelineRun and RunConfiguration in PipelineRunScheduleManager and etc", "committedDate": "2020-02-05T11:40:45Z", "type": "commit"}, {"oid": "7d01c4f7f7dd46cf9a48c4612ecb978844911bc2", "url": "https://github.com/epam/cloud-pipeline/commit/7d01c4f7f7dd46cf9a48c4612ecb978844911bc2", "message": "(issue #938)tests WIP", "committedDate": "2020-02-05T11:40:46Z", "type": "commit"}, {"oid": "176b312bfebad79e88f9bfef86e8a520337df42c", "url": "https://github.com/epam/cloud-pipeline/commit/176b312bfebad79e88f9bfef86e8a520337df42c", "message": "(issue #938) tests WIP", "committedDate": "2020-02-05T14:17:04Z", "type": "commit"}, {"oid": "c660d6525be608d43739975a8ea040532092b48d", "url": "https://github.com/epam/cloud-pipeline/commit/c660d6525be608d43739975a8ea040532092b48d", "message": "(issue #938) tests WIP", "committedDate": "2020-02-05T15:15:17Z", "type": "commit"}, {"oid": "0f5f84ae62ac6a0867e2098da549c8e114d8a844", "url": "https://github.com/epam/cloud-pipeline/commit/0f5f84ae62ac6a0867e2098da549c8e114d8a844", "message": "(issue #938) save user name to restore auth context", "committedDate": "2020-02-05T16:28:08Z", "type": "commit"}, {"oid": "92beb2ff14c1c50cc43b86b0ebfda5f9eeeb47fc", "url": "https://github.com/epam/cloud-pipeline/commit/92beb2ff14c1c50cc43b86b0ebfda5f9eeeb47fc", "message": "(issue #938) tests", "committedDate": "2020-02-06T09:27:35Z", "type": "commit"}, {"oid": "a40fa26daa4a52496b7a1b128eb43b9b71865738", "url": "https://github.com/epam/cloud-pipeline/commit/a40fa26daa4a52496b7a1b128eb43b9b71865738", "message": "(issue #938) cleanup", "committedDate": "2020-02-06T11:20:35Z", "type": "commit"}, {"oid": "3cb78fc3ce09edb0b6da59f84da046ecd97422e5", "url": "https://github.com/epam/cloud-pipeline/commit/3cb78fc3ce09edb0b6da59f84da046ecd97422e5", "message": "(issue #938) licenses", "committedDate": "2020-02-06T11:30:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTgyNzQxOQ==", "url": "https://github.com/epam/cloud-pipeline/pull/944#discussion_r375827419", "bodyText": "I'd suggest replacing switch with interface call where implementation is selected depending on type, similar to storage handling approach.", "author": "mzueva", "createdAt": "2020-02-06T13:18:28Z", "path": "api/src/main/java/com/epam/pipeline/manager/pipeline/RunScheduleManager.java", "diffHunk": "@@ -135,73 +148,115 @@ public void init() {\n     }\n \n     @Transactional(propagation = Propagation.REQUIRED)\n-    public List<RunSchedule> deleteRunSchedules(final Long runId, final List<Long> scheduleIds) {\n+    public List<RunSchedule> deleteSchedules(final Long schedulableId, final ScheduleType scheduleType,\n+                                             final List<Long> scheduleIds) {\n         final List<RunSchedule> schedules = scheduleIds.stream()\n-            .map(this::loadRunSchedule)\n-            .peek(schedule -> Assert.isTrue(runId.equals(schedule.getRunId()),\n-                                        messageHelper.getMessage(MessageConstants.ERROR_RUN_ID_NOT_CORRESPONDING)))\n+            .map(this::loadSchedule)\n+            .peek(schedule -> Assert.isTrue(\n+                    schedulableId.equals(schedule.getSchedulableId()) && schedule.getType() == scheduleType,\n+                    messageHelper.getMessage(MessageConstants.ERROR_RUN_ID_NOT_CORRESPONDING))\n+            )\n             .peek(scheduler::unscheduleRunSchedule)\n             .collect(Collectors.toList());\n         runScheduleDao.deleteRunSchedules(scheduleIds);\n         return schedules;\n     }\n \n     @Transactional(propagation = Propagation.REQUIRED)\n-    public void deleteRunSchedulesForRun(final Long runId) {\n-        runScheduleDao.deleteRunSchedulesForRun(runId);\n+    public void deleteSchedules(final Long schedulableId, final ScheduleType scheduleType) {\n+        runScheduleDao.deleteRunSchedules(schedulableId, scheduleType);\n     }\n \n-    public RunSchedule loadRunSchedule(final Long id) {\n+    public RunSchedule loadSchedule(final Long id) {\n         return runScheduleDao.loadRunSchedule(id).orElseThrow(() -> new IllegalArgumentException(\n             messageHelper.getMessage(MessageConstants.ERROR_RUN_SCHEDULE_NOT_FOUND, id)));\n     }\n \n-    private void checkNewScheduleRequirements(final Long runId, final PipelineRun pipelineRun,\n-                                              final PipelineRunScheduleVO runScheduleVO) {\n-        checkIdenticalCronExpressionForRun(runId, runScheduleVO);\n-        verifyRunSchedule(runId, pipelineRun, runScheduleVO);\n+    @Transactional(propagation = Propagation.REQUIRED)\n+    public void deleteSchedulesForRunByPipeline(final Long pipelineId) {\n+        runScheduleDao.deleteRunSchedulesForRunByPipeline(pipelineId);\n+    }\n+\n+    private void checkNewRunScheduleRequirements(final Long schedulableId, final PipelineRunScheduleVO runScheduleVO,\n+                                                 final ScheduleType scheduleType) {\n+        checkIdenticalCronExpression(schedulableId, scheduleType, runScheduleVO);\n+        verifyRunSchedule(schedulableId, runScheduleVO, scheduleType);\n     }\n \n-    private void verifyRunSchedule(final Long runId, final PipelineRun pipelineRun,\n-                                   final PipelineRunScheduleVO runScheduleVO) {\n+    private void verifyRunSchedule(final Long runId, final PipelineRunScheduleVO runScheduleVO,\n+                                   final ScheduleType type) {\n         verifyCronExpression(runId, runScheduleVO);\n         Assert.notNull(runScheduleVO.getAction(),\n                        messageHelper.getMessage(MessageConstants.SCHEDULE_ACTION_IS_NOT_PROVIDED, runId));\n-        Assert.notNull(pipelineRun,\n-                       messageHelper.getMessage(MessageConstants.ERROR_RUN_PIPELINES_NOT_FOUND, pipelineRun.getName()));\n-        Assert.isTrue(!pipelineRun.getInstance().getSpot(), messageHelper.getMessage(\n-            MessageConstants.ERROR_ON_DEMAND_REQUIRED));\n-        Assert.isTrue(!pipelineRun.getStatus().isFinal(), messageHelper.getMessage(\n-            MessageConstants.ERROR_PIPELINE_RUN_FINISHED, runId));\n         Assert.isTrue(StringUtils.hasText(runScheduleVO.getTimeZone()),\n                       messageHelper.getMessage(MessageConstants.ERROR_TIME_ZONE_IS_NOT_PROVIDED, runId));\n-        Assert.isTrue(!(runScheduleVO.getAction().equals(RunScheduledAction.PAUSE)\n-                        && isNonPauseOrClusterRun(pipelineRun)),\n-                      messageHelper.getMessage(MessageConstants.DEBUG_RUN_IDLE_SKIP_CHECK));\n+        switch (type) {\n+            case PIPELINE_RUN:", "originalCommit": "3cb78fc3ce09edb0b6da59f84da046ecd97422e5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTgyNzcwMA==", "url": "https://github.com/epam/cloud-pipeline/pull/944#discussion_r375827700", "bodyText": "missing final", "author": "mzueva", "createdAt": "2020-02-06T13:19:08Z", "path": "api/src/main/java/com/epam/pipeline/manager/pipeline/RunScheduleManager.java", "diffHunk": "@@ -135,73 +148,115 @@ public void init() {\n     }\n \n     @Transactional(propagation = Propagation.REQUIRED)\n-    public List<RunSchedule> deleteRunSchedules(final Long runId, final List<Long> scheduleIds) {\n+    public List<RunSchedule> deleteSchedules(final Long schedulableId, final ScheduleType scheduleType,\n+                                             final List<Long> scheduleIds) {\n         final List<RunSchedule> schedules = scheduleIds.stream()\n-            .map(this::loadRunSchedule)\n-            .peek(schedule -> Assert.isTrue(runId.equals(schedule.getRunId()),\n-                                        messageHelper.getMessage(MessageConstants.ERROR_RUN_ID_NOT_CORRESPONDING)))\n+            .map(this::loadSchedule)\n+            .peek(schedule -> Assert.isTrue(\n+                    schedulableId.equals(schedule.getSchedulableId()) && schedule.getType() == scheduleType,\n+                    messageHelper.getMessage(MessageConstants.ERROR_RUN_ID_NOT_CORRESPONDING))\n+            )\n             .peek(scheduler::unscheduleRunSchedule)\n             .collect(Collectors.toList());\n         runScheduleDao.deleteRunSchedules(scheduleIds);\n         return schedules;\n     }\n \n     @Transactional(propagation = Propagation.REQUIRED)\n-    public void deleteRunSchedulesForRun(final Long runId) {\n-        runScheduleDao.deleteRunSchedulesForRun(runId);\n+    public void deleteSchedules(final Long schedulableId, final ScheduleType scheduleType) {\n+        runScheduleDao.deleteRunSchedules(schedulableId, scheduleType);\n     }\n \n-    public RunSchedule loadRunSchedule(final Long id) {\n+    public RunSchedule loadSchedule(final Long id) {\n         return runScheduleDao.loadRunSchedule(id).orElseThrow(() -> new IllegalArgumentException(\n             messageHelper.getMessage(MessageConstants.ERROR_RUN_SCHEDULE_NOT_FOUND, id)));\n     }\n \n-    private void checkNewScheduleRequirements(final Long runId, final PipelineRun pipelineRun,\n-                                              final PipelineRunScheduleVO runScheduleVO) {\n-        checkIdenticalCronExpressionForRun(runId, runScheduleVO);\n-        verifyRunSchedule(runId, pipelineRun, runScheduleVO);\n+    @Transactional(propagation = Propagation.REQUIRED)\n+    public void deleteSchedulesForRunByPipeline(final Long pipelineId) {\n+        runScheduleDao.deleteRunSchedulesForRunByPipeline(pipelineId);\n+    }\n+\n+    private void checkNewRunScheduleRequirements(final Long schedulableId, final PipelineRunScheduleVO runScheduleVO,\n+                                                 final ScheduleType scheduleType) {\n+        checkIdenticalCronExpression(schedulableId, scheduleType, runScheduleVO);\n+        verifyRunSchedule(schedulableId, runScheduleVO, scheduleType);\n     }\n \n-    private void verifyRunSchedule(final Long runId, final PipelineRun pipelineRun,\n-                                   final PipelineRunScheduleVO runScheduleVO) {\n+    private void verifyRunSchedule(final Long runId, final PipelineRunScheduleVO runScheduleVO,\n+                                   final ScheduleType type) {\n         verifyCronExpression(runId, runScheduleVO);\n         Assert.notNull(runScheduleVO.getAction(),\n                        messageHelper.getMessage(MessageConstants.SCHEDULE_ACTION_IS_NOT_PROVIDED, runId));\n-        Assert.notNull(pipelineRun,\n-                       messageHelper.getMessage(MessageConstants.ERROR_RUN_PIPELINES_NOT_FOUND, pipelineRun.getName()));\n-        Assert.isTrue(!pipelineRun.getInstance().getSpot(), messageHelper.getMessage(\n-            MessageConstants.ERROR_ON_DEMAND_REQUIRED));\n-        Assert.isTrue(!pipelineRun.getStatus().isFinal(), messageHelper.getMessage(\n-            MessageConstants.ERROR_PIPELINE_RUN_FINISHED, runId));\n         Assert.isTrue(StringUtils.hasText(runScheduleVO.getTimeZone()),\n                       messageHelper.getMessage(MessageConstants.ERROR_TIME_ZONE_IS_NOT_PROVIDED, runId));\n-        Assert.isTrue(!(runScheduleVO.getAction().equals(RunScheduledAction.PAUSE)\n-                        && isNonPauseOrClusterRun(pipelineRun)),\n-                      messageHelper.getMessage(MessageConstants.DEBUG_RUN_IDLE_SKIP_CHECK));\n+        switch (type) {\n+            case PIPELINE_RUN:\n+                Assert.isTrue(runScheduleVO.getAction() == RunScheduledAction.PAUSE\n+                        || runScheduleVO.getAction() == RunScheduledAction.RESUME,\n+                        messageHelper.getMessage(MessageConstants.SCHEDULE_ACTION_IS_NOT_ALLOWED,\n+                                RunScheduledAction.RESUME.name() + \", \" + RunScheduledAction.PAUSE.name(),\n+                                runScheduleVO.getAction()));\n+                break;\n+            case RUN_CONFIGURATION:\n+                Assert.isTrue(runScheduleVO.getAction() == RunScheduledAction.RUN,\n+                        messageHelper.getMessage(MessageConstants.SCHEDULE_ACTION_IS_NOT_ALLOWED,\n+                                RunScheduledAction.RUN.name(), runScheduleVO.getAction()));\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+\n+    private void verifySchedulable(final Long schedulableId, final ScheduleType scheduleType) {\n+        switch (scheduleType) {\n+            case PIPELINE_RUN:\n+                PipelineRun pipelineRun = pipelineRunManager.loadPipelineRun(schedulableId);", "originalCommit": "3cb78fc3ce09edb0b6da59f84da046ecd97422e5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTgyNzg5NA==", "url": "https://github.com/epam/cloud-pipeline/pull/944#discussion_r375827894", "bodyText": "Not sure: shouldn't we throw an exception here?", "author": "mzueva", "createdAt": "2020-02-06T13:19:37Z", "path": "api/src/main/java/com/epam/pipeline/manager/pipeline/RunScheduleManager.java", "diffHunk": "@@ -135,73 +148,115 @@ public void init() {\n     }\n \n     @Transactional(propagation = Propagation.REQUIRED)\n-    public List<RunSchedule> deleteRunSchedules(final Long runId, final List<Long> scheduleIds) {\n+    public List<RunSchedule> deleteSchedules(final Long schedulableId, final ScheduleType scheduleType,\n+                                             final List<Long> scheduleIds) {\n         final List<RunSchedule> schedules = scheduleIds.stream()\n-            .map(this::loadRunSchedule)\n-            .peek(schedule -> Assert.isTrue(runId.equals(schedule.getRunId()),\n-                                        messageHelper.getMessage(MessageConstants.ERROR_RUN_ID_NOT_CORRESPONDING)))\n+            .map(this::loadSchedule)\n+            .peek(schedule -> Assert.isTrue(\n+                    schedulableId.equals(schedule.getSchedulableId()) && schedule.getType() == scheduleType,\n+                    messageHelper.getMessage(MessageConstants.ERROR_RUN_ID_NOT_CORRESPONDING))\n+            )\n             .peek(scheduler::unscheduleRunSchedule)\n             .collect(Collectors.toList());\n         runScheduleDao.deleteRunSchedules(scheduleIds);\n         return schedules;\n     }\n \n     @Transactional(propagation = Propagation.REQUIRED)\n-    public void deleteRunSchedulesForRun(final Long runId) {\n-        runScheduleDao.deleteRunSchedulesForRun(runId);\n+    public void deleteSchedules(final Long schedulableId, final ScheduleType scheduleType) {\n+        runScheduleDao.deleteRunSchedules(schedulableId, scheduleType);\n     }\n \n-    public RunSchedule loadRunSchedule(final Long id) {\n+    public RunSchedule loadSchedule(final Long id) {\n         return runScheduleDao.loadRunSchedule(id).orElseThrow(() -> new IllegalArgumentException(\n             messageHelper.getMessage(MessageConstants.ERROR_RUN_SCHEDULE_NOT_FOUND, id)));\n     }\n \n-    private void checkNewScheduleRequirements(final Long runId, final PipelineRun pipelineRun,\n-                                              final PipelineRunScheduleVO runScheduleVO) {\n-        checkIdenticalCronExpressionForRun(runId, runScheduleVO);\n-        verifyRunSchedule(runId, pipelineRun, runScheduleVO);\n+    @Transactional(propagation = Propagation.REQUIRED)\n+    public void deleteSchedulesForRunByPipeline(final Long pipelineId) {\n+        runScheduleDao.deleteRunSchedulesForRunByPipeline(pipelineId);\n+    }\n+\n+    private void checkNewRunScheduleRequirements(final Long schedulableId, final PipelineRunScheduleVO runScheduleVO,\n+                                                 final ScheduleType scheduleType) {\n+        checkIdenticalCronExpression(schedulableId, scheduleType, runScheduleVO);\n+        verifyRunSchedule(schedulableId, runScheduleVO, scheduleType);\n     }\n \n-    private void verifyRunSchedule(final Long runId, final PipelineRun pipelineRun,\n-                                   final PipelineRunScheduleVO runScheduleVO) {\n+    private void verifyRunSchedule(final Long runId, final PipelineRunScheduleVO runScheduleVO,\n+                                   final ScheduleType type) {\n         verifyCronExpression(runId, runScheduleVO);\n         Assert.notNull(runScheduleVO.getAction(),\n                        messageHelper.getMessage(MessageConstants.SCHEDULE_ACTION_IS_NOT_PROVIDED, runId));\n-        Assert.notNull(pipelineRun,\n-                       messageHelper.getMessage(MessageConstants.ERROR_RUN_PIPELINES_NOT_FOUND, pipelineRun.getName()));\n-        Assert.isTrue(!pipelineRun.getInstance().getSpot(), messageHelper.getMessage(\n-            MessageConstants.ERROR_ON_DEMAND_REQUIRED));\n-        Assert.isTrue(!pipelineRun.getStatus().isFinal(), messageHelper.getMessage(\n-            MessageConstants.ERROR_PIPELINE_RUN_FINISHED, runId));\n         Assert.isTrue(StringUtils.hasText(runScheduleVO.getTimeZone()),\n                       messageHelper.getMessage(MessageConstants.ERROR_TIME_ZONE_IS_NOT_PROVIDED, runId));\n-        Assert.isTrue(!(runScheduleVO.getAction().equals(RunScheduledAction.PAUSE)\n-                        && isNonPauseOrClusterRun(pipelineRun)),\n-                      messageHelper.getMessage(MessageConstants.DEBUG_RUN_IDLE_SKIP_CHECK));\n+        switch (type) {\n+            case PIPELINE_RUN:\n+                Assert.isTrue(runScheduleVO.getAction() == RunScheduledAction.PAUSE\n+                        || runScheduleVO.getAction() == RunScheduledAction.RESUME,\n+                        messageHelper.getMessage(MessageConstants.SCHEDULE_ACTION_IS_NOT_ALLOWED,\n+                                RunScheduledAction.RESUME.name() + \", \" + RunScheduledAction.PAUSE.name(),\n+                                runScheduleVO.getAction()));\n+                break;\n+            case RUN_CONFIGURATION:\n+                Assert.isTrue(runScheduleVO.getAction() == RunScheduledAction.RUN,\n+                        messageHelper.getMessage(MessageConstants.SCHEDULE_ACTION_IS_NOT_ALLOWED,\n+                                RunScheduledAction.RUN.name(), runScheduleVO.getAction()));\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+\n+    private void verifySchedulable(final Long schedulableId, final ScheduleType scheduleType) {\n+        switch (scheduleType) {\n+            case PIPELINE_RUN:\n+                PipelineRun pipelineRun = pipelineRunManager.loadPipelineRun(schedulableId);\n+                Assert.notNull(pipelineRun, messageHelper\n+                        .getMessage(MessageConstants.ERROR_RUN_PIPELINES_NOT_FOUND, pipelineRun.getName()));\n+                Assert.isTrue(!pipelineRun.getInstance().getSpot(), messageHelper.getMessage(\n+                        MessageConstants.ERROR_ON_DEMAND_REQUIRED));\n+                Assert.isTrue(!pipelineRun.getStatus().isFinal(), messageHelper.getMessage(\n+                        MessageConstants.ERROR_PIPELINE_RUN_FINISHED, schedulableId));\n+                Assert.isTrue(!isNonPauseOrClusterRun(pipelineRun),\n+                        messageHelper.getMessage(MessageConstants.DEBUG_RUN_IDLE_SKIP_CHECK));\n+                break;\n+            case RUN_CONFIGURATION:\n+                RunConfiguration configuration = configurationManager.load(schedulableId);\n+                Assert.notNull(configuration,\n+                        messageHelper.getMessage(MessageConstants.ERROR_RUN_CONFIG_NOT_FOUND, schedulableId));\n+                break;\n+            default:\n+                log.error(messageHelper.getMessage(MessageConstants.CRON_EXPRESSION_IDENTICAL));", "originalCommit": "3cb78fc3ce09edb0b6da59f84da046ecd97422e5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTgyOTA4Ng==", "url": "https://github.com/epam/cloud-pipeline/pull/944#discussion_r375829086", "bodyText": "One more place to use some polymorphic interface for handling different ScheduleTypes", "author": "mzueva", "createdAt": "2020-02-06T13:22:19Z", "path": "api/src/main/java/com/epam/pipeline/manager/scheduling/RunScheduler.java", "diffHunk": "@@ -68,42 +78,50 @@ public void init() {\n \n     public void scheduleRunSchedule(final RunSchedule schedule) {\n         try {\n-            log.debug(\"Request received to schedule run \");\n+            log.debug(\"Request received to schedule action: \" + schedule.getAction() + \" for \"\n+                    + schedule.getType() + ID + schedule.getSchedulableId());\n             final JobDetail jobDetail = jobDetail(schedule);\n \n             log.debug(\"Creating trigger for key \" + jobDetail.getKey().getName() + \" at date: \" + DateUtils.now());\n             final Trigger cronTrigger = createCronTrigger(schedule);\n \n             final Date scheduledDate = quartzScheduler.scheduleJob(jobDetail, cronTrigger);\n-            log.debug(\"Job for run: \" + schedule.getRunId() + \" scheduled successfully for date: \" + scheduledDate);\n+            log.debug(\"Job for: \" + schedule.getType() + ID\n+                    + schedule.getSchedulableId() + \" scheduled successfully for date: \" + scheduledDate);\n         } catch (SchedulerException | ParseException e) {\n-            log.error(\"SchedulerException while scheduling job for run \" + schedule.getRunId() + \" : \" +\n+            log.error(\"SchedulerException while scheduling job for run \" + schedule.getSchedulableId() + \" : \" +\n                       e.getMessage());\n         }\n     }\n \n     public void unscheduleRunSchedule(final RunSchedule schedule) {\n         try {\n-            log.debug(\"Request received to unscheduling trigger for run \" + schedule.getRunId());\n+            log.debug(\"Request received to unscheduling trigger for: \" + schedule.getType()\n+                    + ID + schedule.getSchedulableId());\n \n             final JobKey key = jobDetail(schedule).getKey();\n \n             quartzScheduler.deleteJob(key);\n \n-            log.debug(\"Schedule \" + schedule.getCronExpression() + \" for run \" + schedule.getRunId() +\n-                      \" was revoked successfully.\");\n+            log.debug(\"Schedule \" + schedule.getCronExpression() + \" for \"  + schedule.getType()\n+                    + ID + schedule.getSchedulableId() + \" was revoked successfully.\");\n         } catch (SchedulerException e) {\n-            log.error(\"SchedulerException while unscheduling trigger for run \" + schedule.getRunId() + \" : \" +\n-                      e.getMessage());\n+            log.error(\"SchedulerException while unscheduling trigger for \"  + schedule.getType()\n+                    + ID + schedule.getSchedulableId() + \" : \" + e.getMessage());\n         }\n     }\n \n     private JobDetail jobDetail(final RunSchedule runSchedule) {\n         JobDetailFactoryBean jobDetailFactory = new JobDetailFactoryBean();\n-        jobDetailFactory.setJobClass(RunScheduleJob.class);\n-        jobDetailFactory.getJobDataMap().put(\"RunId\", runSchedule.getRunId());\n+        jobDetailFactory.setJobClass(runSchedule.getType() == ScheduleType.PIPELINE_RUN", "originalCommit": "3cb78fc3ce09edb0b6da59f84da046ecd97422e5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTgzMTU2Nw==", "url": "https://github.com/epam/cloud-pipeline/pull/944#discussion_r375831567", "bodyText": "Method authManager.issueToken with null expiration will issue a token with default expiration (1 month by default). We need to specify expiration manually, if we need a long-term token", "author": "mzueva", "createdAt": "2020-02-06T13:27:29Z", "path": "api/src/main/java/com/epam/pipeline/manager/scheduling/RunScheduler.java", "diffHunk": "@@ -68,42 +78,50 @@ public void init() {\n \n     public void scheduleRunSchedule(final RunSchedule schedule) {\n         try {\n-            log.debug(\"Request received to schedule run \");\n+            log.debug(\"Request received to schedule action: \" + schedule.getAction() + \" for \"\n+                    + schedule.getType() + ID + schedule.getSchedulableId());\n             final JobDetail jobDetail = jobDetail(schedule);\n \n             log.debug(\"Creating trigger for key \" + jobDetail.getKey().getName() + \" at date: \" + DateUtils.now());\n             final Trigger cronTrigger = createCronTrigger(schedule);\n \n             final Date scheduledDate = quartzScheduler.scheduleJob(jobDetail, cronTrigger);\n-            log.debug(\"Job for run: \" + schedule.getRunId() + \" scheduled successfully for date: \" + scheduledDate);\n+            log.debug(\"Job for: \" + schedule.getType() + ID\n+                    + schedule.getSchedulableId() + \" scheduled successfully for date: \" + scheduledDate);\n         } catch (SchedulerException | ParseException e) {\n-            log.error(\"SchedulerException while scheduling job for run \" + schedule.getRunId() + \" : \" +\n+            log.error(\"SchedulerException while scheduling job for run \" + schedule.getSchedulableId() + \" : \" +\n                       e.getMessage());\n         }\n     }\n \n     public void unscheduleRunSchedule(final RunSchedule schedule) {\n         try {\n-            log.debug(\"Request received to unscheduling trigger for run \" + schedule.getRunId());\n+            log.debug(\"Request received to unscheduling trigger for: \" + schedule.getType()\n+                    + ID + schedule.getSchedulableId());\n \n             final JobKey key = jobDetail(schedule).getKey();\n \n             quartzScheduler.deleteJob(key);\n \n-            log.debug(\"Schedule \" + schedule.getCronExpression() + \" for run \" + schedule.getRunId() +\n-                      \" was revoked successfully.\");\n+            log.debug(\"Schedule \" + schedule.getCronExpression() + \" for \"  + schedule.getType()\n+                    + ID + schedule.getSchedulableId() + \" was revoked successfully.\");\n         } catch (SchedulerException e) {\n-            log.error(\"SchedulerException while unscheduling trigger for run \" + schedule.getRunId() + \" : \" +\n-                      e.getMessage());\n+            log.error(\"SchedulerException while unscheduling trigger for \"  + schedule.getType()\n+                    + ID + schedule.getSchedulableId() + \" : \" + e.getMessage());\n         }\n     }\n \n     private JobDetail jobDetail(final RunSchedule runSchedule) {\n         JobDetailFactoryBean jobDetailFactory = new JobDetailFactoryBean();\n-        jobDetailFactory.setJobClass(RunScheduleJob.class);\n-        jobDetailFactory.getJobDataMap().put(\"RunId\", runSchedule.getRunId());\n+        jobDetailFactory.setJobClass(runSchedule.getType() == ScheduleType.PIPELINE_RUN\n+                ? RunScheduleJob.class\n+                : ConfigurationScheduleJob.class);\n+        jobDetailFactory.getJobDataMap().put(\"SchedulableId\", runSchedule.getSchedulableId());\n+        jobDetailFactory.getJobDataMap().put(\n+                \"UserToken\", authManager.issueToken(userManager.loadUserContext(runSchedule.getUser()), null).getToken()", "originalCommit": "3cb78fc3ce09edb0b6da59f84da046ecd97422e5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1a043ea59f27ddb84aca9ada6e9d2cad8e9276c4", "url": "https://github.com/epam/cloud-pipeline/commit/1a043ea59f27ddb84aca9ada6e9d2cad8e9276c4", "message": "(issue #938) correction on review", "committedDate": "2020-02-06T15:39:26Z", "type": "commit"}, {"oid": "9633ca5bdc0345fef6229a6d0c3a78051bb610dd", "url": "https://github.com/epam/cloud-pipeline/commit/9633ca5bdc0345fef6229a6d0c3a78051bb610dd", "message": "(issue #938) controller description fix", "committedDate": "2020-02-06T15:42:11Z", "type": "commit"}, {"oid": "0fe6e64e2f8f66d51b498ba9c625a873720e00cc", "url": "https://github.com/epam/cloud-pipeline/commit/0fe6e64e2f8f66d51b498ba9c625a873720e00cc", "message": "(issue #938) restore Security Context by loading PipelineUser instead of using jwt token", "committedDate": "2020-02-06T16:29:29Z", "type": "commit"}, {"oid": "0fe6e64e2f8f66d51b498ba9c625a873720e00cc", "url": "https://github.com/epam/cloud-pipeline/commit/0fe6e64e2f8f66d51b498ba9c625a873720e00cc", "message": "(issue #938) restore Security Context by loading PipelineUser instead of using jwt token", "committedDate": "2020-02-06T16:29:29Z", "type": "forcePushed"}, {"oid": "c270e932d4981b67339467e3a34dc9907c308e7a", "url": "https://github.com/epam/cloud-pipeline/commit/c270e932d4981b67339467e3a34dc9907c308e7a", "message": "(issue #938) test fix", "committedDate": "2020-02-07T10:59:50Z", "type": "commit"}]}