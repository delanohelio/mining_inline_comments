{"pr_number": 1642, "pr_title": "Issue #1404: Implemented tests for acl layer PipelineApiService", "pr_createdAt": "2020-12-09T15:57:43Z", "pr_url": "https://github.com/epam/cloud-pipeline/pull/1642", "timeline": [{"oid": "301990a43df88288d2ee689542dc9cc085faf318", "url": "https://github.com/epam/cloud-pipeline/commit/301990a43df88288d2ee689542dc9cc085faf318", "message": "Issue #1404: Implemented tests for acl layer PipelineApiService\n\nSigned-off-by: Iurii_Kofanov <youkofan@gmail.com>", "committedDate": "2020-12-09T15:56:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI0NTU1MA==", "url": "https://github.com/epam/cloud-pipeline/pull/1642#discussion_r540245550", "bodyText": "I hope we can get rid of checked exceptions one day but for now we can at least improve the call site. It seams reasonable to create CustomAssertions.assertThrowsChecked method which accepts checked lambdas.\nTo manage checked lambdas you can define a special functional interface CheckedRunnable with a single checked method. This functional interface can be used as a lambda parameter type for the new method.\nIt allows to simplify the call up to the following state:\nassertThrowsChecked(AccessDeniedException.class, () -> pipelineApiService.loadRevision(ID, TEST_STRING));", "author": "tcibinan", "createdAt": "2020-12-10T15:09:38Z", "path": "api/src/test/java/com/epam/pipeline/acl/pipeline/PipelineApiServiceGitTest.java", "diffHunk": "@@ -0,0 +1,546 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.acl.pipeline;\n+\n+import com.epam.pipeline.controller.vo.PipelineSourceItemVO;\n+import com.epam.pipeline.controller.vo.PipelineSourceItemsVO;\n+import com.epam.pipeline.controller.vo.UploadFileMetadata;\n+import com.epam.pipeline.entity.git.GitCommitEntry;\n+import com.epam.pipeline.entity.git.GitCredentials;\n+import com.epam.pipeline.entity.git.GitRepositoryEntry;\n+import com.epam.pipeline.entity.git.GitTagEntry;\n+import com.epam.pipeline.entity.pipeline.Pipeline;\n+import com.epam.pipeline.exception.git.GitClientException;\n+import com.epam.pipeline.manager.git.GitManager;\n+import com.epam.pipeline.manager.pipeline.PipelineManager;\n+import com.epam.pipeline.security.acl.AclPermission;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.git.GitCreatorUtils;\n+import com.epam.pipeline.test.creator.pipeline.PipelineCreatorUtils;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.test.context.support.WithMockUser;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_ARRAY;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_INT;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.doReturn;\n+\n+public class PipelineApiServiceGitTest extends AbstractAclTest {\n+\n+    protected final Pipeline pipeline = PipelineCreatorUtils.getPipeline(ANOTHER_SIMPLE_USER);\n+    private final GitTagEntry gitTagEntry = GitCreatorUtils.getGitTagEntry();\n+    private final GitCommitEntry gitCommitEntry = GitCreatorUtils.getGitCommitEntry();\n+    private final PipelineSourceItemVO sourceItemVO = PipelineCreatorUtils.getPipelineSourceItemVO();\n+    private final PipelineSourceItemsVO sourceItemsVO = PipelineCreatorUtils.getPipelineSourceItemsVO();\n+    private final GitCredentials gitCredentials = GitCreatorUtils.getGitCredentials();\n+    private final GitRepositoryEntry gitRepositoryEntry = GitCreatorUtils.getGitRepositoryEntry();\n+    private final UploadFileMetadata fileMetadata = PipelineCreatorUtils.getUploadFileMetadata();\n+    private final List<GitRepositoryEntry> gitRepositoryEntries = Collections.singletonList(gitRepositoryEntry);\n+    private final List<UploadFileMetadata> files = Collections.singletonList(fileMetadata);\n+\n+    @Autowired\n+    private PipelineApiService pipelineApiService;\n+    @Autowired\n+    private PipelineManager mockPipelineManager;\n+    @Autowired\n+    private GitManager mockGitManager;\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldLoadRevisionForAdmin() throws GitClientException {\n+        doReturn(pipeline).when(mockPipelineManager).load(ID);\n+        doReturn(gitTagEntry).when(mockGitManager).loadRevision(pipeline, TEST_STRING);\n+\n+        assertThat(pipelineApiService.loadRevision(ID, TEST_STRING)).isEqualTo(gitTagEntry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldLoadRevisionWhenPermissionIsGranted() throws GitClientException {\n+        initAclEntity(pipeline, AclPermission.READ);\n+        doReturn(pipeline).when(mockPipelineManager).load(ID);\n+        doReturn(gitTagEntry).when(mockGitManager).loadRevision(pipeline, TEST_STRING);\n+\n+        assertThat(pipelineApiService.loadRevision(ID, TEST_STRING)).isEqualTo(gitTagEntry);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyLoadRevisionWhenPermissionIsNotGranted() throws GitClientException {\n+        initAclEntity(pipeline);\n+        doReturn(pipeline).when(mockPipelineManager).load(ID);\n+        doReturn(gitTagEntry).when(mockGitManager).loadRevision(pipeline, TEST_STRING);\n+\n+        assertThrows(AccessDeniedException.class, () -> {\n+            try {\n+                pipelineApiService.loadRevision(ID, TEST_STRING);\n+            } catch (GitClientException e) {\n+                e.printStackTrace();\n+            }\n+        });", "originalCommit": "301990a43df88288d2ee689542dc9cc085faf318", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI2MTYyNg==", "url": "https://github.com/epam/cloud-pipeline/pull/1642#discussion_r540261626", "bodyText": "As long as we share spring context between tests we should be extremely careful with what we do with spy objects. The most safe approach would be to reset spy objects after all tests in a class.\nWhat do you think? Is there any real risk about non resetting the spy?", "author": "tcibinan", "createdAt": "2020-12-10T15:28:42Z", "path": "api/src/test/java/com/epam/pipeline/acl/pipeline/PipelineApiServiceTest.java", "diffHunk": "@@ -0,0 +1,831 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.acl.pipeline;\n+\n+import com.epam.pipeline.controller.vo.CheckRepositoryVO;\n+import com.epam.pipeline.controller.vo.GenerateFileVO;\n+import com.epam.pipeline.controller.vo.PipelineVO;\n+import com.epam.pipeline.controller.vo.PipelinesWithPermissionsVO;\n+import com.epam.pipeline.controller.vo.RegisterPipelineVersionVO;\n+import com.epam.pipeline.controller.vo.TaskGraphVO;\n+import com.epam.pipeline.entity.cluster.InstancePrice;\n+import com.epam.pipeline.entity.pipeline.DocumentGenerationProperty;\n+import com.epam.pipeline.entity.pipeline.Folder;\n+import com.epam.pipeline.entity.pipeline.Pipeline;\n+import com.epam.pipeline.entity.pipeline.PipelineRun;\n+import com.epam.pipeline.entity.pipeline.Revision;\n+import com.epam.pipeline.exception.git.GitClientException;\n+import com.epam.pipeline.manager.cluster.InstanceOfferManager;\n+import com.epam.pipeline.manager.pipeline.DocumentGenerationPropertyManager;\n+import com.epam.pipeline.manager.pipeline.PipelineFileGenerationManager;\n+import com.epam.pipeline.manager.pipeline.PipelineManager;\n+import com.epam.pipeline.manager.pipeline.PipelineRunManager;\n+import com.epam.pipeline.manager.pipeline.PipelineVersionManager;\n+import com.epam.pipeline.manager.security.GrantPermissionManager;\n+import com.epam.pipeline.security.acl.AclPermission;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.folder.FolderCreatorUtils;\n+import com.epam.pipeline.test.creator.pipeline.PipelineCreatorUtils;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.test.context.support.WithMockUser;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_2;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.READ_PERMISSION;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_ARRAY;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_INT;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.WRITE_PERMISSION;\n+import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.doReturn;\n+\n+public class PipelineApiServiceTest extends AbstractAclTest {\n+\n+    protected final Pipeline pipeline = PipelineCreatorUtils.getPipeline(ANOTHER_SIMPLE_USER);\n+    private final Pipeline anotherPipeline = PipelineCreatorUtils.getPipeline(ID_2, ANOTHER_SIMPLE_USER, ID_2);\n+    private final PipelineVO pipelineVO = PipelineCreatorUtils.getPipelineVO(ID);\n+    private final Folder folder = FolderCreatorUtils.getFolder(ID, ANOTHER_SIMPLE_USER);\n+    private final CheckRepositoryVO checkRepositoryVO = PipelineCreatorUtils.getCheckRepositoryVO();\n+    private final PipelinesWithPermissionsVO pipelinesWithPermissions =\n+            PipelineCreatorUtils.getPipelinesWithPermissionsVO();\n+    private final PipelineRun pipelineRun = PipelineCreatorUtils.getPipelineRun(ID, ANOTHER_SIMPLE_USER);\n+    private final Revision revision = PipelineCreatorUtils.getRevision();\n+    private final InstancePrice instancePrice = PipelineCreatorUtils.getInstancePrice();\n+    private final TaskGraphVO taskGraphVO = PipelineCreatorUtils.getTaskGraphVO();\n+    private final GenerateFileVO fileVO = PipelineCreatorUtils.getGenerateFileVO();\n+    private final RegisterPipelineVersionVO pipelineVersionVO = PipelineCreatorUtils.getRegisterPipelineVersionVO();\n+    private final DocumentGenerationProperty property = PipelineCreatorUtils.getDocumentGenerationProperty();\n+    private final List<PipelineRun> pipelineRunList = Collections.singletonList(pipelineRun);\n+    private final List<Revision> revisionList = Collections.singletonList(revision);\n+    private final List<DocumentGenerationProperty> propertyList = Collections.singletonList(property);\n+\n+    @Autowired\n+    private PipelineApiService pipelineApiService;\n+    @Autowired\n+    private PipelineManager mockPipelineManager;\n+    @Autowired\n+    private PipelineRunManager mockPipelineRunManager;\n+    @Autowired\n+    private PipelineVersionManager mockVersionManager;\n+    @Autowired\n+    private InstanceOfferManager mockInstanceOfferManager;\n+    @Autowired\n+    private PipelineFileGenerationManager mockFileGenerationManager;\n+    @Autowired\n+    private DocumentGenerationPropertyManager mockPropertyManager;\n+    @Autowired\n+    private GrantPermissionManager spyGrantPermissionManager;", "originalCommit": "301990a43df88288d2ee689542dc9cc085faf318", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDc1NTk5MQ==", "url": "https://github.com/epam/cloud-pipeline/pull/1642#discussion_r540755991", "bodyText": "Seems better to call it shouldDenyCreatePipelineWithoutPipelineManagerRole.", "author": "tcibinan", "createdAt": "2020-12-11T07:57:34Z", "path": "api/src/test/java/com/epam/pipeline/acl/pipeline/PipelineApiServiceTest.java", "diffHunk": "@@ -0,0 +1,831 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.acl.pipeline;\n+\n+import com.epam.pipeline.controller.vo.CheckRepositoryVO;\n+import com.epam.pipeline.controller.vo.GenerateFileVO;\n+import com.epam.pipeline.controller.vo.PipelineVO;\n+import com.epam.pipeline.controller.vo.PipelinesWithPermissionsVO;\n+import com.epam.pipeline.controller.vo.RegisterPipelineVersionVO;\n+import com.epam.pipeline.controller.vo.TaskGraphVO;\n+import com.epam.pipeline.entity.cluster.InstancePrice;\n+import com.epam.pipeline.entity.pipeline.DocumentGenerationProperty;\n+import com.epam.pipeline.entity.pipeline.Folder;\n+import com.epam.pipeline.entity.pipeline.Pipeline;\n+import com.epam.pipeline.entity.pipeline.PipelineRun;\n+import com.epam.pipeline.entity.pipeline.Revision;\n+import com.epam.pipeline.exception.git.GitClientException;\n+import com.epam.pipeline.manager.cluster.InstanceOfferManager;\n+import com.epam.pipeline.manager.pipeline.DocumentGenerationPropertyManager;\n+import com.epam.pipeline.manager.pipeline.PipelineFileGenerationManager;\n+import com.epam.pipeline.manager.pipeline.PipelineManager;\n+import com.epam.pipeline.manager.pipeline.PipelineRunManager;\n+import com.epam.pipeline.manager.pipeline.PipelineVersionManager;\n+import com.epam.pipeline.manager.security.GrantPermissionManager;\n+import com.epam.pipeline.security.acl.AclPermission;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.folder.FolderCreatorUtils;\n+import com.epam.pipeline.test.creator.pipeline.PipelineCreatorUtils;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.test.context.support.WithMockUser;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_2;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.READ_PERMISSION;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_ARRAY;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_INT;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.WRITE_PERMISSION;\n+import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.doReturn;\n+\n+public class PipelineApiServiceTest extends AbstractAclTest {\n+\n+    protected final Pipeline pipeline = PipelineCreatorUtils.getPipeline(ANOTHER_SIMPLE_USER);\n+    private final Pipeline anotherPipeline = PipelineCreatorUtils.getPipeline(ID_2, ANOTHER_SIMPLE_USER, ID_2);\n+    private final PipelineVO pipelineVO = PipelineCreatorUtils.getPipelineVO(ID);\n+    private final Folder folder = FolderCreatorUtils.getFolder(ID, ANOTHER_SIMPLE_USER);\n+    private final CheckRepositoryVO checkRepositoryVO = PipelineCreatorUtils.getCheckRepositoryVO();\n+    private final PipelinesWithPermissionsVO pipelinesWithPermissions =\n+            PipelineCreatorUtils.getPipelinesWithPermissionsVO();\n+    private final PipelineRun pipelineRun = PipelineCreatorUtils.getPipelineRun(ID, ANOTHER_SIMPLE_USER);\n+    private final Revision revision = PipelineCreatorUtils.getRevision();\n+    private final InstancePrice instancePrice = PipelineCreatorUtils.getInstancePrice();\n+    private final TaskGraphVO taskGraphVO = PipelineCreatorUtils.getTaskGraphVO();\n+    private final GenerateFileVO fileVO = PipelineCreatorUtils.getGenerateFileVO();\n+    private final RegisterPipelineVersionVO pipelineVersionVO = PipelineCreatorUtils.getRegisterPipelineVersionVO();\n+    private final DocumentGenerationProperty property = PipelineCreatorUtils.getDocumentGenerationProperty();\n+    private final List<PipelineRun> pipelineRunList = Collections.singletonList(pipelineRun);\n+    private final List<Revision> revisionList = Collections.singletonList(revision);\n+    private final List<DocumentGenerationProperty> propertyList = Collections.singletonList(property);\n+\n+    @Autowired\n+    private PipelineApiService pipelineApiService;\n+    @Autowired\n+    private PipelineManager mockPipelineManager;\n+    @Autowired\n+    private PipelineRunManager mockPipelineRunManager;\n+    @Autowired\n+    private PipelineVersionManager mockVersionManager;\n+    @Autowired\n+    private InstanceOfferManager mockInstanceOfferManager;\n+    @Autowired\n+    private PipelineFileGenerationManager mockFileGenerationManager;\n+    @Autowired\n+    private DocumentGenerationPropertyManager mockPropertyManager;\n+    @Autowired\n+    private GrantPermissionManager spyGrantPermissionManager;\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldCreatePipelineForAdmin() throws GitClientException {\n+        doReturn(pipeline).when(mockPipelineManager).create(pipelineVO);\n+\n+        assertThat(pipelineApiService.create(pipelineVO)).isEqualTo(pipeline);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER, roles = PIPELINE_MANAGER_ROLE)\n+    public void shouldCreatePipelineWhenPermissionIsGranted() throws GitClientException {\n+        initAclEntity(folder, AclPermission.WRITE);\n+        doReturn(pipeline).when(mockPipelineManager).create(pipelineVO);\n+\n+        assertThat(pipelineApiService.create(pipelineVO)).isEqualTo(pipeline);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER, roles = PIPELINE_MANAGER_ROLE)\n+    public void shouldDenyCreatePipelineWhenParentIdIsNull() throws GitClientException {\n+        initAclEntity(folder, AclPermission.WRITE);\n+        final PipelineVO pipelineVO = PipelineCreatorUtils.getPipelineVO(null);\n+        doReturn(pipeline).when(mockPipelineManager).create(pipelineVO);\n+\n+        assertThrows(AccessDeniedException.class, () -> {\n+            try {\n+                pipelineApiService.create(pipelineVO);\n+            } catch (GitClientException e) {\n+                e.printStackTrace();\n+            }\n+        });\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyCreatePipelineForUserRole() throws GitClientException {", "originalCommit": "301990a43df88288d2ee689542dc9cc085faf318", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDc1NjkzMw==", "url": "https://github.com/epam/cloud-pipeline/pull/1642#discussion_r540756933", "bodyText": "Let's be more explicit: shouldDenyCreatePipelineWhenPermissionForParentFolderIsNotGranted.", "author": "tcibinan", "createdAt": "2020-12-11T07:59:32Z", "path": "api/src/test/java/com/epam/pipeline/acl/pipeline/PipelineApiServiceTest.java", "diffHunk": "@@ -0,0 +1,831 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.acl.pipeline;\n+\n+import com.epam.pipeline.controller.vo.CheckRepositoryVO;\n+import com.epam.pipeline.controller.vo.GenerateFileVO;\n+import com.epam.pipeline.controller.vo.PipelineVO;\n+import com.epam.pipeline.controller.vo.PipelinesWithPermissionsVO;\n+import com.epam.pipeline.controller.vo.RegisterPipelineVersionVO;\n+import com.epam.pipeline.controller.vo.TaskGraphVO;\n+import com.epam.pipeline.entity.cluster.InstancePrice;\n+import com.epam.pipeline.entity.pipeline.DocumentGenerationProperty;\n+import com.epam.pipeline.entity.pipeline.Folder;\n+import com.epam.pipeline.entity.pipeline.Pipeline;\n+import com.epam.pipeline.entity.pipeline.PipelineRun;\n+import com.epam.pipeline.entity.pipeline.Revision;\n+import com.epam.pipeline.exception.git.GitClientException;\n+import com.epam.pipeline.manager.cluster.InstanceOfferManager;\n+import com.epam.pipeline.manager.pipeline.DocumentGenerationPropertyManager;\n+import com.epam.pipeline.manager.pipeline.PipelineFileGenerationManager;\n+import com.epam.pipeline.manager.pipeline.PipelineManager;\n+import com.epam.pipeline.manager.pipeline.PipelineRunManager;\n+import com.epam.pipeline.manager.pipeline.PipelineVersionManager;\n+import com.epam.pipeline.manager.security.GrantPermissionManager;\n+import com.epam.pipeline.security.acl.AclPermission;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.folder.FolderCreatorUtils;\n+import com.epam.pipeline.test.creator.pipeline.PipelineCreatorUtils;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.test.context.support.WithMockUser;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_2;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.READ_PERMISSION;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_ARRAY;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_INT;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.WRITE_PERMISSION;\n+import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.doReturn;\n+\n+public class PipelineApiServiceTest extends AbstractAclTest {\n+\n+    protected final Pipeline pipeline = PipelineCreatorUtils.getPipeline(ANOTHER_SIMPLE_USER);\n+    private final Pipeline anotherPipeline = PipelineCreatorUtils.getPipeline(ID_2, ANOTHER_SIMPLE_USER, ID_2);\n+    private final PipelineVO pipelineVO = PipelineCreatorUtils.getPipelineVO(ID);\n+    private final Folder folder = FolderCreatorUtils.getFolder(ID, ANOTHER_SIMPLE_USER);\n+    private final CheckRepositoryVO checkRepositoryVO = PipelineCreatorUtils.getCheckRepositoryVO();\n+    private final PipelinesWithPermissionsVO pipelinesWithPermissions =\n+            PipelineCreatorUtils.getPipelinesWithPermissionsVO();\n+    private final PipelineRun pipelineRun = PipelineCreatorUtils.getPipelineRun(ID, ANOTHER_SIMPLE_USER);\n+    private final Revision revision = PipelineCreatorUtils.getRevision();\n+    private final InstancePrice instancePrice = PipelineCreatorUtils.getInstancePrice();\n+    private final TaskGraphVO taskGraphVO = PipelineCreatorUtils.getTaskGraphVO();\n+    private final GenerateFileVO fileVO = PipelineCreatorUtils.getGenerateFileVO();\n+    private final RegisterPipelineVersionVO pipelineVersionVO = PipelineCreatorUtils.getRegisterPipelineVersionVO();\n+    private final DocumentGenerationProperty property = PipelineCreatorUtils.getDocumentGenerationProperty();\n+    private final List<PipelineRun> pipelineRunList = Collections.singletonList(pipelineRun);\n+    private final List<Revision> revisionList = Collections.singletonList(revision);\n+    private final List<DocumentGenerationProperty> propertyList = Collections.singletonList(property);\n+\n+    @Autowired\n+    private PipelineApiService pipelineApiService;\n+    @Autowired\n+    private PipelineManager mockPipelineManager;\n+    @Autowired\n+    private PipelineRunManager mockPipelineRunManager;\n+    @Autowired\n+    private PipelineVersionManager mockVersionManager;\n+    @Autowired\n+    private InstanceOfferManager mockInstanceOfferManager;\n+    @Autowired\n+    private PipelineFileGenerationManager mockFileGenerationManager;\n+    @Autowired\n+    private DocumentGenerationPropertyManager mockPropertyManager;\n+    @Autowired\n+    private GrantPermissionManager spyGrantPermissionManager;\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldCreatePipelineForAdmin() throws GitClientException {\n+        doReturn(pipeline).when(mockPipelineManager).create(pipelineVO);\n+\n+        assertThat(pipelineApiService.create(pipelineVO)).isEqualTo(pipeline);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER, roles = PIPELINE_MANAGER_ROLE)\n+    public void shouldCreatePipelineWhenPermissionIsGranted() throws GitClientException {\n+        initAclEntity(folder, AclPermission.WRITE);\n+        doReturn(pipeline).when(mockPipelineManager).create(pipelineVO);\n+\n+        assertThat(pipelineApiService.create(pipelineVO)).isEqualTo(pipeline);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER, roles = PIPELINE_MANAGER_ROLE)\n+    public void shouldDenyCreatePipelineWhenParentIdIsNull() throws GitClientException {\n+        initAclEntity(folder, AclPermission.WRITE);\n+        final PipelineVO pipelineVO = PipelineCreatorUtils.getPipelineVO(null);\n+        doReturn(pipeline).when(mockPipelineManager).create(pipelineVO);\n+\n+        assertThrows(AccessDeniedException.class, () -> {\n+            try {\n+                pipelineApiService.create(pipelineVO);\n+            } catch (GitClientException e) {\n+                e.printStackTrace();\n+            }\n+        });\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyCreatePipelineForUserRole() throws GitClientException {\n+        initAclEntity(folder, AclPermission.WRITE);\n+        doReturn(pipeline).when(mockPipelineManager).create(pipelineVO);\n+\n+        assertThrows(AccessDeniedException.class, () -> {\n+            try {\n+                pipelineApiService.create(pipelineVO);\n+            } catch (GitClientException e) {\n+                e.printStackTrace();\n+            }\n+        });\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER, roles = PIPELINE_MANAGER_ROLE)\n+    public void shouldDenyCreatePipelineWhenPermissionIsNotGranted() throws GitClientException {", "originalCommit": "301990a43df88288d2ee689542dc9cc085faf318", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDc2NTQ0Nw==", "url": "https://github.com/epam/cloud-pipeline/pull/1642#discussion_r540765447", "bodyText": "It looks like PipelineApiService.loadAllRunsByPipeline method may return runs for which a user doesn't have sufficient permissions.\nCould you please check if this is really what's happening. If it is then we should add a test for it and create an issue asking for a fix.", "author": "tcibinan", "createdAt": "2020-12-11T08:16:05Z", "path": "api/src/test/java/com/epam/pipeline/acl/pipeline/PipelineApiServiceTest.java", "diffHunk": "@@ -0,0 +1,831 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.acl.pipeline;\n+\n+import com.epam.pipeline.controller.vo.CheckRepositoryVO;\n+import com.epam.pipeline.controller.vo.GenerateFileVO;\n+import com.epam.pipeline.controller.vo.PipelineVO;\n+import com.epam.pipeline.controller.vo.PipelinesWithPermissionsVO;\n+import com.epam.pipeline.controller.vo.RegisterPipelineVersionVO;\n+import com.epam.pipeline.controller.vo.TaskGraphVO;\n+import com.epam.pipeline.entity.cluster.InstancePrice;\n+import com.epam.pipeline.entity.pipeline.DocumentGenerationProperty;\n+import com.epam.pipeline.entity.pipeline.Folder;\n+import com.epam.pipeline.entity.pipeline.Pipeline;\n+import com.epam.pipeline.entity.pipeline.PipelineRun;\n+import com.epam.pipeline.entity.pipeline.Revision;\n+import com.epam.pipeline.exception.git.GitClientException;\n+import com.epam.pipeline.manager.cluster.InstanceOfferManager;\n+import com.epam.pipeline.manager.pipeline.DocumentGenerationPropertyManager;\n+import com.epam.pipeline.manager.pipeline.PipelineFileGenerationManager;\n+import com.epam.pipeline.manager.pipeline.PipelineManager;\n+import com.epam.pipeline.manager.pipeline.PipelineRunManager;\n+import com.epam.pipeline.manager.pipeline.PipelineVersionManager;\n+import com.epam.pipeline.manager.security.GrantPermissionManager;\n+import com.epam.pipeline.security.acl.AclPermission;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.folder.FolderCreatorUtils;\n+import com.epam.pipeline.test.creator.pipeline.PipelineCreatorUtils;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.test.context.support.WithMockUser;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_2;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.READ_PERMISSION;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_ARRAY;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_INT;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.WRITE_PERMISSION;\n+import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.doReturn;\n+\n+public class PipelineApiServiceTest extends AbstractAclTest {\n+\n+    protected final Pipeline pipeline = PipelineCreatorUtils.getPipeline(ANOTHER_SIMPLE_USER);\n+    private final Pipeline anotherPipeline = PipelineCreatorUtils.getPipeline(ID_2, ANOTHER_SIMPLE_USER, ID_2);\n+    private final PipelineVO pipelineVO = PipelineCreatorUtils.getPipelineVO(ID);\n+    private final Folder folder = FolderCreatorUtils.getFolder(ID, ANOTHER_SIMPLE_USER);\n+    private final CheckRepositoryVO checkRepositoryVO = PipelineCreatorUtils.getCheckRepositoryVO();\n+    private final PipelinesWithPermissionsVO pipelinesWithPermissions =\n+            PipelineCreatorUtils.getPipelinesWithPermissionsVO();\n+    private final PipelineRun pipelineRun = PipelineCreatorUtils.getPipelineRun(ID, ANOTHER_SIMPLE_USER);\n+    private final Revision revision = PipelineCreatorUtils.getRevision();\n+    private final InstancePrice instancePrice = PipelineCreatorUtils.getInstancePrice();\n+    private final TaskGraphVO taskGraphVO = PipelineCreatorUtils.getTaskGraphVO();\n+    private final GenerateFileVO fileVO = PipelineCreatorUtils.getGenerateFileVO();\n+    private final RegisterPipelineVersionVO pipelineVersionVO = PipelineCreatorUtils.getRegisterPipelineVersionVO();\n+    private final DocumentGenerationProperty property = PipelineCreatorUtils.getDocumentGenerationProperty();\n+    private final List<PipelineRun> pipelineRunList = Collections.singletonList(pipelineRun);\n+    private final List<Revision> revisionList = Collections.singletonList(revision);\n+    private final List<DocumentGenerationProperty> propertyList = Collections.singletonList(property);\n+\n+    @Autowired\n+    private PipelineApiService pipelineApiService;\n+    @Autowired\n+    private PipelineManager mockPipelineManager;\n+    @Autowired\n+    private PipelineRunManager mockPipelineRunManager;\n+    @Autowired\n+    private PipelineVersionManager mockVersionManager;\n+    @Autowired\n+    private InstanceOfferManager mockInstanceOfferManager;\n+    @Autowired\n+    private PipelineFileGenerationManager mockFileGenerationManager;\n+    @Autowired\n+    private DocumentGenerationPropertyManager mockPropertyManager;\n+    @Autowired\n+    private GrantPermissionManager spyGrantPermissionManager;\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldCreatePipelineForAdmin() throws GitClientException {\n+        doReturn(pipeline).when(mockPipelineManager).create(pipelineVO);\n+\n+        assertThat(pipelineApiService.create(pipelineVO)).isEqualTo(pipeline);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER, roles = PIPELINE_MANAGER_ROLE)\n+    public void shouldCreatePipelineWhenPermissionIsGranted() throws GitClientException {\n+        initAclEntity(folder, AclPermission.WRITE);\n+        doReturn(pipeline).when(mockPipelineManager).create(pipelineVO);\n+\n+        assertThat(pipelineApiService.create(pipelineVO)).isEqualTo(pipeline);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER, roles = PIPELINE_MANAGER_ROLE)\n+    public void shouldDenyCreatePipelineWhenParentIdIsNull() throws GitClientException {\n+        initAclEntity(folder, AclPermission.WRITE);\n+        final PipelineVO pipelineVO = PipelineCreatorUtils.getPipelineVO(null);\n+        doReturn(pipeline).when(mockPipelineManager).create(pipelineVO);\n+\n+        assertThrows(AccessDeniedException.class, () -> {\n+            try {\n+                pipelineApiService.create(pipelineVO);\n+            } catch (GitClientException e) {\n+                e.printStackTrace();\n+            }\n+        });\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyCreatePipelineForUserRole() throws GitClientException {\n+        initAclEntity(folder, AclPermission.WRITE);\n+        doReturn(pipeline).when(mockPipelineManager).create(pipelineVO);\n+\n+        assertThrows(AccessDeniedException.class, () -> {\n+            try {\n+                pipelineApiService.create(pipelineVO);\n+            } catch (GitClientException e) {\n+                e.printStackTrace();\n+            }\n+        });\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER, roles = PIPELINE_MANAGER_ROLE)\n+    public void shouldDenyCreatePipelineWhenPermissionIsNotGranted() throws GitClientException {\n+        initAclEntity(folder);\n+        doReturn(pipeline).when(mockPipelineManager).create(pipelineVO);\n+\n+        assertThrows(AccessDeniedException.class, () -> {\n+            try {\n+                pipelineApiService.create(pipelineVO);\n+            } catch (GitClientException e) {\n+                e.printStackTrace();\n+            }\n+        });\n+    }\n+\n+    @Test\n+    public void setCheckRepositoryVO() throws GitClientException {\n+        doReturn(checkRepositoryVO).when(mockPipelineManager).check(checkRepositoryVO);\n+\n+        assertThat(pipelineApiService.check(checkRepositoryVO)).isEqualTo(checkRepositoryVO);\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdatePipelineForAdmin() {\n+        doReturn(pipeline).when(mockPipelineManager).update(pipelineVO);\n+\n+        assertThat(pipelineApiService.update(pipelineVO)).isEqualTo(pipeline);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdatePipelineWhenPermissionIsGranted() {\n+        initAclEntity(pipeline, AclPermission.WRITE);\n+        doReturn(pipeline).when(mockPipelineManager).update(pipelineVO);\n+\n+        final Pipeline returnedPipeline = pipelineApiService.update(pipelineVO);\n+\n+        assertThat(returnedPipeline).isEqualTo(pipeline);\n+        assertThat(returnedPipeline.getMask()).isEqualTo(WRITE_PERMISSION);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyUpdatePipelineWhenPermissionIsNotGranted() {\n+        initAclEntity(pipeline);\n+        doReturn(pipeline).when(mockPipelineManager).update(pipelineVO);\n+\n+        assertThrows(AccessDeniedException.class, () -> pipelineApiService.update(pipelineVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateTokenForAdmin() {\n+        doReturn(pipeline).when(mockPipelineManager).updateToken(pipelineVO);\n+\n+        assertThat(pipelineApiService.updateToken(pipelineVO)).isEqualTo(pipeline);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateTokenWhenPermissionIsGranted() {\n+        initAclEntity(pipeline, AclPermission.WRITE);\n+        doReturn(pipeline).when(mockPipelineManager).updateToken(pipelineVO);\n+\n+        final Pipeline returnedPipeline = pipelineApiService.updateToken(pipelineVO);\n+\n+        assertThat(returnedPipeline).isEqualTo(pipeline);\n+        assertThat(returnedPipeline.getMask()).isEqualTo(WRITE_PERMISSION);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyUpdateTokenWhenPermissionIsNotGranted() {\n+        initAclEntity(pipeline);\n+        doReturn(pipeline).when(mockPipelineManager).updateToken(pipelineVO);\n+\n+        assertThrows(AccessDeniedException.class, () -> pipelineApiService.updateToken(pipelineVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldLoadAllPipelinesForAdmin() {\n+        doReturn(mutableListOf(pipeline)).when(mockPipelineManager).loadAllPipelines(true);\n+\n+        assertThat(pipelineApiService.loadAllPipelines(true)).hasSize(1).contains(pipeline);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldLoadAllPipelinesWhenPermissionIsGranted() {\n+        initAclEntity(pipeline, AclPermission.READ);\n+        doReturn(mutableListOf(pipeline)).when(mockPipelineManager).loadAllPipelines(true);\n+\n+        final List<Pipeline> returnedPipelines = pipelineApiService.loadAllPipelines(true);\n+\n+        assertThat(returnedPipelines).hasSize(1).contains(pipeline);\n+        assertThat(returnedPipelines.get(0).getMask()).isEqualTo(READ_PERMISSION);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldLoadPipelinesWhichPermissionIsGranted() {\n+        initAclEntity(pipeline, AclPermission.READ);\n+        initAclEntity(anotherPipeline);\n+        doReturn(mutableListOf(pipeline, anotherPipeline)).when(mockPipelineManager).loadAllPipelines(true);\n+\n+        final List<Pipeline> returnedPipelines = pipelineApiService.loadAllPipelines(true);\n+\n+        assertThat(returnedPipelines).hasSize(1).contains(pipeline);\n+        assertThat(returnedPipelines.get(0).getMask()).isEqualTo(READ_PERMISSION);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldNotLoadAllPipelinesWhenPermissionIsNotGranted() {\n+        initAclEntity(pipeline);\n+        doReturn(mutableListOf(pipeline)).when(mockPipelineManager).loadAllPipelines(true);\n+\n+        assertThat(pipelineApiService.loadAllPipelines(true)).isEmpty();\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldLoadAllPipelinesWithPermissionsForAdmin() {\n+        doReturn(pipelinesWithPermissions).when(spyGrantPermissionManager)\n+                .loadAllPipelinesWithPermissions(TEST_INT, TEST_INT);\n+\n+        assertThat(pipelineApiService.loadAllPipelinesWithPermissions(TEST_INT, TEST_INT))\n+                .isEqualTo(pipelinesWithPermissions);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyLoadAllPipelinesWithPermissionsForNotAdmin() {\n+        doReturn(pipelinesWithPermissions).when(spyGrantPermissionManager)\n+                .loadAllPipelinesWithPermissions(TEST_INT, TEST_INT);\n+\n+        assertThrows(AccessDeniedException.class, () ->\n+                pipelineApiService.loadAllPipelinesWithPermissions(TEST_INT, TEST_INT));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldLoadPipelineForAdmin() {\n+        doReturn(pipeline).when(mockPipelineManager).load(ID, true);\n+\n+        assertThat(pipelineApiService.load(ID)).isEqualTo(pipeline);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldLoadPipelineWhenPermissionIsGranted() {\n+        initAclEntity(pipeline, AclPermission.READ);\n+        doReturn(pipeline).when(mockPipelineManager).load(ID, true);\n+\n+        final Pipeline returnedPipeline = pipelineApiService.load(ID);\n+\n+        assertThat(returnedPipeline).isEqualTo(pipeline);\n+        assertThat(returnedPipeline.getMask()).isEqualTo(READ_PERMISSION);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyLoadPipelineWhenPermissionIsNotGranted() {\n+        initAclEntity(pipeline);\n+        doReturn(pipeline).when(mockPipelineManager).load(ID, true);\n+\n+        assertThrows(AccessDeniedException.class, () -> pipelineApiService.load(ID));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldLoadPipelineByIdOrNameForAdmin() {\n+        doReturn(pipeline).when(mockPipelineManager).loadByNameOrId(TEST_STRING);\n+\n+        assertThat(pipelineApiService.loadPipelineByIdOrName(TEST_STRING)).isEqualTo(pipeline);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldLoadPipelineByIdOrNameWhenPermissionIsGranted() {\n+        initAclEntity(pipeline, AclPermission.READ);\n+        doReturn(pipeline).when(mockPipelineManager).loadByNameOrId(TEST_STRING);\n+\n+        final Pipeline returnedPipeline = pipelineApiService.loadPipelineByIdOrName(TEST_STRING);\n+\n+        assertThat(returnedPipeline).isEqualTo(pipeline);\n+        assertThat(returnedPipeline.getMask()).isEqualTo(READ_PERMISSION);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyLoadPipelineByIdOrNameWhenPermissionIsNotGranted() {\n+        initAclEntity(pipeline);\n+        doReturn(pipeline).when(mockPipelineManager).loadByNameOrId(TEST_STRING);\n+\n+        assertThrows(AccessDeniedException.class, () -> pipelineApiService.loadPipelineByIdOrName(TEST_STRING));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldLoadAllPipelinesWithoutVersionForAdmin() {\n+        doReturn(mutableListOf(pipeline)).when(mockPipelineManager).loadAllPipelines(false);\n+\n+        assertThat(pipelineApiService.loadAllPipelinesWithoutVersion()).hasSize(1).contains(pipeline);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldLoadAllPipelinesWithoutVersionWhenPermissionIsGranted() {\n+        initAclEntity(pipeline, AclPermission.READ);\n+        doReturn(mutableListOf(pipeline)).when(mockPipelineManager).loadAllPipelines(false);\n+\n+        final List<Pipeline> returnedPipelines = pipelineApiService.loadAllPipelinesWithoutVersion();\n+\n+        assertThat(returnedPipelines).hasSize(1).contains(pipeline);\n+        assertThat(returnedPipelines.get(0).getMask()).isEqualTo(READ_PERMISSION);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldLoadPipelinesWithoutVersionWhichPermissionIsGranted() {\n+        initAclEntity(pipeline, AclPermission.READ);\n+        initAclEntity(anotherPipeline);\n+        doReturn(mutableListOf(pipeline, anotherPipeline)).when(mockPipelineManager).loadAllPipelines(false);\n+\n+        final List<Pipeline> returnedPipelines = pipelineApiService.loadAllPipelinesWithoutVersion();\n+\n+        assertThat(returnedPipelines).hasSize(1).contains(pipeline);\n+        assertThat(returnedPipelines.get(0).getMask()).isEqualTo(READ_PERMISSION);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldNotLoadAllPipelinesWithoutVersionWhenPermissionIsNotGranted() {\n+        initAclEntity(pipeline);\n+        doReturn(mutableListOf(pipeline)).when(mockPipelineManager).loadAllPipelines(false);\n+\n+        assertThat(pipelineApiService.loadAllPipelinesWithoutVersion()).isEmpty();\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldDeletePipelineForAdmin() {\n+        doReturn(pipeline).when(mockPipelineManager).delete(ID, true);\n+\n+        assertThat(pipelineApiService.delete(ID, true)).isEqualTo(pipeline);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER, roles = PIPELINE_MANAGER_ROLE)\n+    public void shouldDeletePipelineWhenPermissionIsGranted() {\n+        initAclEntity(pipeline, AclPermission.WRITE);\n+        doReturn(pipeline).when(mockPipelineManager).delete(ID, true);\n+\n+        assertThat(pipelineApiService.delete(ID, true)).isEqualTo(pipeline);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER, roles = PIPELINE_MANAGER_ROLE)\n+    public void shouldDenyDeletePipelineWhenPermissionIsNotGranted() {\n+        initAclEntity(pipeline);\n+        doReturn(pipeline).when(mockPipelineManager).delete(ID, true);\n+\n+        assertThrows(AccessDeniedException.class, () -> pipelineApiService.delete(ID, true));\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyDeletePipelineForUserRole() {\n+        initAclEntity(pipeline, AclPermission.WRITE);\n+        doReturn(pipeline).when(mockPipelineManager).delete(ID, true);\n+\n+        assertThrows(AccessDeniedException.class, () -> pipelineApiService.delete(ID, true));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldLoadAllRunsByPipelineForAdmin() {\n+        doReturn(pipelineRunList).when(mockPipelineRunManager).loadAllRunsByPipeline(ID);\n+\n+        assertThat(pipelineApiService.loadAllRunsByPipeline(ID)).isEqualTo(pipelineRunList);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldLoadAllRunsByPipelineWhenPermissionIsGranted() {\n+        initAclEntity(pipeline, AclPermission.READ);\n+        initAclEntity(pipelineRun, AclPermission.READ);\n+        doReturn(pipelineRunList).when(mockPipelineRunManager).loadAllRunsByPipeline(ID);\n+\n+        final List<PipelineRun> returnedPipelineRunList = pipelineApiService.loadAllRunsByPipeline(ID);\n+\n+        assertThat(returnedPipelineRunList).hasSize(1).contains(pipelineRun);\n+        assertThat(returnedPipelineRunList.get(0).getMask()).isEqualTo(READ_PERMISSION);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyLoadAllRunsByPipelineWhenPermissionIsNotGranted() {\n+        initAclEntity(pipeline);\n+        doReturn(pipelineRunList).when(mockPipelineRunManager).loadAllRunsByPipeline(ID);\n+\n+        assertThrows(AccessDeniedException.class, () -> pipelineApiService.loadAllRunsByPipeline(ID));\n+    }\n+", "originalCommit": "301990a43df88288d2ee689542dc9cc085faf318", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDc2NTg3Mw==", "url": "https://github.com/epam/cloud-pipeline/pull/1642#discussion_r540765873", "bodyText": "The problem appears when a user has permissions for a pipeline but doesn't have permissions for a run of that pipeline.", "author": "tcibinan", "createdAt": "2020-12-11T08:16:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDc2NTQ0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjE4OTk5OA==", "url": "https://github.com/epam/cloud-pipeline/pull/1642#discussion_r542189998", "bodyText": "It turned out to be a problem for a separate issue. Closing for now.", "author": "tcibinan", "createdAt": "2020-12-14T08:20:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDc2NTQ0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDc3MTEwMg==", "url": "https://github.com/epam/cloud-pipeline/pull/1642#discussion_r540771102", "bodyText": "Probably these tests as well as all others depending on PipelineVersionManager can be moved to PipelineApiServiceGitTest.", "author": "tcibinan", "createdAt": "2020-12-11T08:26:27Z", "path": "api/src/test/java/com/epam/pipeline/acl/pipeline/PipelineApiServiceTest.java", "diffHunk": "@@ -0,0 +1,831 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.acl.pipeline;\n+\n+import com.epam.pipeline.controller.vo.CheckRepositoryVO;\n+import com.epam.pipeline.controller.vo.GenerateFileVO;\n+import com.epam.pipeline.controller.vo.PipelineVO;\n+import com.epam.pipeline.controller.vo.PipelinesWithPermissionsVO;\n+import com.epam.pipeline.controller.vo.RegisterPipelineVersionVO;\n+import com.epam.pipeline.controller.vo.TaskGraphVO;\n+import com.epam.pipeline.entity.cluster.InstancePrice;\n+import com.epam.pipeline.entity.pipeline.DocumentGenerationProperty;\n+import com.epam.pipeline.entity.pipeline.Folder;\n+import com.epam.pipeline.entity.pipeline.Pipeline;\n+import com.epam.pipeline.entity.pipeline.PipelineRun;\n+import com.epam.pipeline.entity.pipeline.Revision;\n+import com.epam.pipeline.exception.git.GitClientException;\n+import com.epam.pipeline.manager.cluster.InstanceOfferManager;\n+import com.epam.pipeline.manager.pipeline.DocumentGenerationPropertyManager;\n+import com.epam.pipeline.manager.pipeline.PipelineFileGenerationManager;\n+import com.epam.pipeline.manager.pipeline.PipelineManager;\n+import com.epam.pipeline.manager.pipeline.PipelineRunManager;\n+import com.epam.pipeline.manager.pipeline.PipelineVersionManager;\n+import com.epam.pipeline.manager.security.GrantPermissionManager;\n+import com.epam.pipeline.security.acl.AclPermission;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.folder.FolderCreatorUtils;\n+import com.epam.pipeline.test.creator.pipeline.PipelineCreatorUtils;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.test.context.support.WithMockUser;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_2;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.READ_PERMISSION;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_ARRAY;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_INT;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.WRITE_PERMISSION;\n+import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.doReturn;\n+\n+public class PipelineApiServiceTest extends AbstractAclTest {\n+\n+    protected final Pipeline pipeline = PipelineCreatorUtils.getPipeline(ANOTHER_SIMPLE_USER);\n+    private final Pipeline anotherPipeline = PipelineCreatorUtils.getPipeline(ID_2, ANOTHER_SIMPLE_USER, ID_2);\n+    private final PipelineVO pipelineVO = PipelineCreatorUtils.getPipelineVO(ID);\n+    private final Folder folder = FolderCreatorUtils.getFolder(ID, ANOTHER_SIMPLE_USER);\n+    private final CheckRepositoryVO checkRepositoryVO = PipelineCreatorUtils.getCheckRepositoryVO();\n+    private final PipelinesWithPermissionsVO pipelinesWithPermissions =\n+            PipelineCreatorUtils.getPipelinesWithPermissionsVO();\n+    private final PipelineRun pipelineRun = PipelineCreatorUtils.getPipelineRun(ID, ANOTHER_SIMPLE_USER);\n+    private final Revision revision = PipelineCreatorUtils.getRevision();\n+    private final InstancePrice instancePrice = PipelineCreatorUtils.getInstancePrice();\n+    private final TaskGraphVO taskGraphVO = PipelineCreatorUtils.getTaskGraphVO();\n+    private final GenerateFileVO fileVO = PipelineCreatorUtils.getGenerateFileVO();\n+    private final RegisterPipelineVersionVO pipelineVersionVO = PipelineCreatorUtils.getRegisterPipelineVersionVO();\n+    private final DocumentGenerationProperty property = PipelineCreatorUtils.getDocumentGenerationProperty();\n+    private final List<PipelineRun> pipelineRunList = Collections.singletonList(pipelineRun);\n+    private final List<Revision> revisionList = Collections.singletonList(revision);\n+    private final List<DocumentGenerationProperty> propertyList = Collections.singletonList(property);\n+\n+    @Autowired\n+    private PipelineApiService pipelineApiService;\n+    @Autowired\n+    private PipelineManager mockPipelineManager;\n+    @Autowired\n+    private PipelineRunManager mockPipelineRunManager;\n+    @Autowired\n+    private PipelineVersionManager mockVersionManager;\n+    @Autowired\n+    private InstanceOfferManager mockInstanceOfferManager;\n+    @Autowired\n+    private PipelineFileGenerationManager mockFileGenerationManager;\n+    @Autowired\n+    private DocumentGenerationPropertyManager mockPropertyManager;\n+    @Autowired\n+    private GrantPermissionManager spyGrantPermissionManager;\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldCreatePipelineForAdmin() throws GitClientException {\n+        doReturn(pipeline).when(mockPipelineManager).create(pipelineVO);\n+\n+        assertThat(pipelineApiService.create(pipelineVO)).isEqualTo(pipeline);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER, roles = PIPELINE_MANAGER_ROLE)\n+    public void shouldCreatePipelineWhenPermissionIsGranted() throws GitClientException {\n+        initAclEntity(folder, AclPermission.WRITE);\n+        doReturn(pipeline).when(mockPipelineManager).create(pipelineVO);\n+\n+        assertThat(pipelineApiService.create(pipelineVO)).isEqualTo(pipeline);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER, roles = PIPELINE_MANAGER_ROLE)\n+    public void shouldDenyCreatePipelineWhenParentIdIsNull() throws GitClientException {\n+        initAclEntity(folder, AclPermission.WRITE);\n+        final PipelineVO pipelineVO = PipelineCreatorUtils.getPipelineVO(null);\n+        doReturn(pipeline).when(mockPipelineManager).create(pipelineVO);\n+\n+        assertThrows(AccessDeniedException.class, () -> {\n+            try {\n+                pipelineApiService.create(pipelineVO);\n+            } catch (GitClientException e) {\n+                e.printStackTrace();\n+            }\n+        });\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyCreatePipelineForUserRole() throws GitClientException {\n+        initAclEntity(folder, AclPermission.WRITE);\n+        doReturn(pipeline).when(mockPipelineManager).create(pipelineVO);\n+\n+        assertThrows(AccessDeniedException.class, () -> {\n+            try {\n+                pipelineApiService.create(pipelineVO);\n+            } catch (GitClientException e) {\n+                e.printStackTrace();\n+            }\n+        });\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER, roles = PIPELINE_MANAGER_ROLE)\n+    public void shouldDenyCreatePipelineWhenPermissionIsNotGranted() throws GitClientException {\n+        initAclEntity(folder);\n+        doReturn(pipeline).when(mockPipelineManager).create(pipelineVO);\n+\n+        assertThrows(AccessDeniedException.class, () -> {\n+            try {\n+                pipelineApiService.create(pipelineVO);\n+            } catch (GitClientException e) {\n+                e.printStackTrace();\n+            }\n+        });\n+    }\n+\n+    @Test\n+    public void setCheckRepositoryVO() throws GitClientException {\n+        doReturn(checkRepositoryVO).when(mockPipelineManager).check(checkRepositoryVO);\n+\n+        assertThat(pipelineApiService.check(checkRepositoryVO)).isEqualTo(checkRepositoryVO);\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdatePipelineForAdmin() {\n+        doReturn(pipeline).when(mockPipelineManager).update(pipelineVO);\n+\n+        assertThat(pipelineApiService.update(pipelineVO)).isEqualTo(pipeline);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdatePipelineWhenPermissionIsGranted() {\n+        initAclEntity(pipeline, AclPermission.WRITE);\n+        doReturn(pipeline).when(mockPipelineManager).update(pipelineVO);\n+\n+        final Pipeline returnedPipeline = pipelineApiService.update(pipelineVO);\n+\n+        assertThat(returnedPipeline).isEqualTo(pipeline);\n+        assertThat(returnedPipeline.getMask()).isEqualTo(WRITE_PERMISSION);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyUpdatePipelineWhenPermissionIsNotGranted() {\n+        initAclEntity(pipeline);\n+        doReturn(pipeline).when(mockPipelineManager).update(pipelineVO);\n+\n+        assertThrows(AccessDeniedException.class, () -> pipelineApiService.update(pipelineVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateTokenForAdmin() {\n+        doReturn(pipeline).when(mockPipelineManager).updateToken(pipelineVO);\n+\n+        assertThat(pipelineApiService.updateToken(pipelineVO)).isEqualTo(pipeline);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateTokenWhenPermissionIsGranted() {\n+        initAclEntity(pipeline, AclPermission.WRITE);\n+        doReturn(pipeline).when(mockPipelineManager).updateToken(pipelineVO);\n+\n+        final Pipeline returnedPipeline = pipelineApiService.updateToken(pipelineVO);\n+\n+        assertThat(returnedPipeline).isEqualTo(pipeline);\n+        assertThat(returnedPipeline.getMask()).isEqualTo(WRITE_PERMISSION);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyUpdateTokenWhenPermissionIsNotGranted() {\n+        initAclEntity(pipeline);\n+        doReturn(pipeline).when(mockPipelineManager).updateToken(pipelineVO);\n+\n+        assertThrows(AccessDeniedException.class, () -> pipelineApiService.updateToken(pipelineVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldLoadAllPipelinesForAdmin() {\n+        doReturn(mutableListOf(pipeline)).when(mockPipelineManager).loadAllPipelines(true);\n+\n+        assertThat(pipelineApiService.loadAllPipelines(true)).hasSize(1).contains(pipeline);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldLoadAllPipelinesWhenPermissionIsGranted() {\n+        initAclEntity(pipeline, AclPermission.READ);\n+        doReturn(mutableListOf(pipeline)).when(mockPipelineManager).loadAllPipelines(true);\n+\n+        final List<Pipeline> returnedPipelines = pipelineApiService.loadAllPipelines(true);\n+\n+        assertThat(returnedPipelines).hasSize(1).contains(pipeline);\n+        assertThat(returnedPipelines.get(0).getMask()).isEqualTo(READ_PERMISSION);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldLoadPipelinesWhichPermissionIsGranted() {\n+        initAclEntity(pipeline, AclPermission.READ);\n+        initAclEntity(anotherPipeline);\n+        doReturn(mutableListOf(pipeline, anotherPipeline)).when(mockPipelineManager).loadAllPipelines(true);\n+\n+        final List<Pipeline> returnedPipelines = pipelineApiService.loadAllPipelines(true);\n+\n+        assertThat(returnedPipelines).hasSize(1).contains(pipeline);\n+        assertThat(returnedPipelines.get(0).getMask()).isEqualTo(READ_PERMISSION);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldNotLoadAllPipelinesWhenPermissionIsNotGranted() {\n+        initAclEntity(pipeline);\n+        doReturn(mutableListOf(pipeline)).when(mockPipelineManager).loadAllPipelines(true);\n+\n+        assertThat(pipelineApiService.loadAllPipelines(true)).isEmpty();\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldLoadAllPipelinesWithPermissionsForAdmin() {\n+        doReturn(pipelinesWithPermissions).when(spyGrantPermissionManager)\n+                .loadAllPipelinesWithPermissions(TEST_INT, TEST_INT);\n+\n+        assertThat(pipelineApiService.loadAllPipelinesWithPermissions(TEST_INT, TEST_INT))\n+                .isEqualTo(pipelinesWithPermissions);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyLoadAllPipelinesWithPermissionsForNotAdmin() {\n+        doReturn(pipelinesWithPermissions).when(spyGrantPermissionManager)\n+                .loadAllPipelinesWithPermissions(TEST_INT, TEST_INT);\n+\n+        assertThrows(AccessDeniedException.class, () ->\n+                pipelineApiService.loadAllPipelinesWithPermissions(TEST_INT, TEST_INT));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldLoadPipelineForAdmin() {\n+        doReturn(pipeline).when(mockPipelineManager).load(ID, true);\n+\n+        assertThat(pipelineApiService.load(ID)).isEqualTo(pipeline);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldLoadPipelineWhenPermissionIsGranted() {\n+        initAclEntity(pipeline, AclPermission.READ);\n+        doReturn(pipeline).when(mockPipelineManager).load(ID, true);\n+\n+        final Pipeline returnedPipeline = pipelineApiService.load(ID);\n+\n+        assertThat(returnedPipeline).isEqualTo(pipeline);\n+        assertThat(returnedPipeline.getMask()).isEqualTo(READ_PERMISSION);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyLoadPipelineWhenPermissionIsNotGranted() {\n+        initAclEntity(pipeline);\n+        doReturn(pipeline).when(mockPipelineManager).load(ID, true);\n+\n+        assertThrows(AccessDeniedException.class, () -> pipelineApiService.load(ID));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldLoadPipelineByIdOrNameForAdmin() {\n+        doReturn(pipeline).when(mockPipelineManager).loadByNameOrId(TEST_STRING);\n+\n+        assertThat(pipelineApiService.loadPipelineByIdOrName(TEST_STRING)).isEqualTo(pipeline);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldLoadPipelineByIdOrNameWhenPermissionIsGranted() {\n+        initAclEntity(pipeline, AclPermission.READ);\n+        doReturn(pipeline).when(mockPipelineManager).loadByNameOrId(TEST_STRING);\n+\n+        final Pipeline returnedPipeline = pipelineApiService.loadPipelineByIdOrName(TEST_STRING);\n+\n+        assertThat(returnedPipeline).isEqualTo(pipeline);\n+        assertThat(returnedPipeline.getMask()).isEqualTo(READ_PERMISSION);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyLoadPipelineByIdOrNameWhenPermissionIsNotGranted() {\n+        initAclEntity(pipeline);\n+        doReturn(pipeline).when(mockPipelineManager).loadByNameOrId(TEST_STRING);\n+\n+        assertThrows(AccessDeniedException.class, () -> pipelineApiService.loadPipelineByIdOrName(TEST_STRING));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldLoadAllPipelinesWithoutVersionForAdmin() {\n+        doReturn(mutableListOf(pipeline)).when(mockPipelineManager).loadAllPipelines(false);\n+\n+        assertThat(pipelineApiService.loadAllPipelinesWithoutVersion()).hasSize(1).contains(pipeline);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldLoadAllPipelinesWithoutVersionWhenPermissionIsGranted() {\n+        initAclEntity(pipeline, AclPermission.READ);\n+        doReturn(mutableListOf(pipeline)).when(mockPipelineManager).loadAllPipelines(false);\n+\n+        final List<Pipeline> returnedPipelines = pipelineApiService.loadAllPipelinesWithoutVersion();\n+\n+        assertThat(returnedPipelines).hasSize(1).contains(pipeline);\n+        assertThat(returnedPipelines.get(0).getMask()).isEqualTo(READ_PERMISSION);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldLoadPipelinesWithoutVersionWhichPermissionIsGranted() {\n+        initAclEntity(pipeline, AclPermission.READ);\n+        initAclEntity(anotherPipeline);\n+        doReturn(mutableListOf(pipeline, anotherPipeline)).when(mockPipelineManager).loadAllPipelines(false);\n+\n+        final List<Pipeline> returnedPipelines = pipelineApiService.loadAllPipelinesWithoutVersion();\n+\n+        assertThat(returnedPipelines).hasSize(1).contains(pipeline);\n+        assertThat(returnedPipelines.get(0).getMask()).isEqualTo(READ_PERMISSION);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldNotLoadAllPipelinesWithoutVersionWhenPermissionIsNotGranted() {\n+        initAclEntity(pipeline);\n+        doReturn(mutableListOf(pipeline)).when(mockPipelineManager).loadAllPipelines(false);\n+\n+        assertThat(pipelineApiService.loadAllPipelinesWithoutVersion()).isEmpty();\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldDeletePipelineForAdmin() {\n+        doReturn(pipeline).when(mockPipelineManager).delete(ID, true);\n+\n+        assertThat(pipelineApiService.delete(ID, true)).isEqualTo(pipeline);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER, roles = PIPELINE_MANAGER_ROLE)\n+    public void shouldDeletePipelineWhenPermissionIsGranted() {\n+        initAclEntity(pipeline, AclPermission.WRITE);\n+        doReturn(pipeline).when(mockPipelineManager).delete(ID, true);\n+\n+        assertThat(pipelineApiService.delete(ID, true)).isEqualTo(pipeline);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER, roles = PIPELINE_MANAGER_ROLE)\n+    public void shouldDenyDeletePipelineWhenPermissionIsNotGranted() {\n+        initAclEntity(pipeline);\n+        doReturn(pipeline).when(mockPipelineManager).delete(ID, true);\n+\n+        assertThrows(AccessDeniedException.class, () -> pipelineApiService.delete(ID, true));\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyDeletePipelineForUserRole() {\n+        initAclEntity(pipeline, AclPermission.WRITE);\n+        doReturn(pipeline).when(mockPipelineManager).delete(ID, true);\n+\n+        assertThrows(AccessDeniedException.class, () -> pipelineApiService.delete(ID, true));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldLoadAllRunsByPipelineForAdmin() {\n+        doReturn(pipelineRunList).when(mockPipelineRunManager).loadAllRunsByPipeline(ID);\n+\n+        assertThat(pipelineApiService.loadAllRunsByPipeline(ID)).isEqualTo(pipelineRunList);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldLoadAllRunsByPipelineWhenPermissionIsGranted() {\n+        initAclEntity(pipeline, AclPermission.READ);\n+        initAclEntity(pipelineRun, AclPermission.READ);\n+        doReturn(pipelineRunList).when(mockPipelineRunManager).loadAllRunsByPipeline(ID);\n+\n+        final List<PipelineRun> returnedPipelineRunList = pipelineApiService.loadAllRunsByPipeline(ID);\n+\n+        assertThat(returnedPipelineRunList).hasSize(1).contains(pipelineRun);\n+        assertThat(returnedPipelineRunList.get(0).getMask()).isEqualTo(READ_PERMISSION);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyLoadAllRunsByPipelineWhenPermissionIsNotGranted() {\n+        initAclEntity(pipeline);\n+        doReturn(pipelineRunList).when(mockPipelineRunManager).loadAllRunsByPipeline(ID);\n+\n+        assertThrows(AccessDeniedException.class, () -> pipelineApiService.loadAllRunsByPipeline(ID));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldLoadVersionFromGitForAdmin() throws GitClientException {\n+        doReturn(revisionList).when(mockVersionManager).loadAllVersionFromGit(ID);\n+\n+        assertThat(pipelineApiService.loadAllVersionFromGit(ID)).isEqualTo(revisionList);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldLoadAllVersionFromGitWhenPermissionIsGranted() throws GitClientException {\n+        initAclEntity(pipeline, AclPermission.READ);\n+        doReturn(revisionList).when(mockVersionManager).loadAllVersionFromGit(ID);\n+\n+        assertThat(pipelineApiService.loadAllVersionFromGit(ID)).isEqualTo(revisionList);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyLoadAllVersionFromGitWhenPermissionIsNotGranted() throws GitClientException {\n+        initAclEntity(pipeline);\n+        doReturn(revisionList).when(mockVersionManager).loadAllVersionFromGit(ID);\n+\n+        assertThrows(AccessDeniedException.class, () -> {\n+            try {\n+                pipelineApiService.loadAllVersionFromGit(ID);\n+            } catch (GitClientException e) {\n+                e.printStackTrace();\n+            }\n+        });\n+    }", "originalCommit": "301990a43df88288d2ee689542dc9cc085faf318", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDc3NjQ2Ng==", "url": "https://github.com/epam/cloud-pipeline/pull/1642#discussion_r540776466", "bodyText": "Replace protected with private.", "author": "tcibinan", "createdAt": "2020-12-11T08:35:51Z", "path": "api/src/test/java/com/epam/pipeline/acl/pipeline/PipelineApiServiceTest.java", "diffHunk": "@@ -0,0 +1,831 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.acl.pipeline;\n+\n+import com.epam.pipeline.controller.vo.CheckRepositoryVO;\n+import com.epam.pipeline.controller.vo.GenerateFileVO;\n+import com.epam.pipeline.controller.vo.PipelineVO;\n+import com.epam.pipeline.controller.vo.PipelinesWithPermissionsVO;\n+import com.epam.pipeline.controller.vo.RegisterPipelineVersionVO;\n+import com.epam.pipeline.controller.vo.TaskGraphVO;\n+import com.epam.pipeline.entity.cluster.InstancePrice;\n+import com.epam.pipeline.entity.pipeline.DocumentGenerationProperty;\n+import com.epam.pipeline.entity.pipeline.Folder;\n+import com.epam.pipeline.entity.pipeline.Pipeline;\n+import com.epam.pipeline.entity.pipeline.PipelineRun;\n+import com.epam.pipeline.entity.pipeline.Revision;\n+import com.epam.pipeline.exception.git.GitClientException;\n+import com.epam.pipeline.manager.cluster.InstanceOfferManager;\n+import com.epam.pipeline.manager.pipeline.DocumentGenerationPropertyManager;\n+import com.epam.pipeline.manager.pipeline.PipelineFileGenerationManager;\n+import com.epam.pipeline.manager.pipeline.PipelineManager;\n+import com.epam.pipeline.manager.pipeline.PipelineRunManager;\n+import com.epam.pipeline.manager.pipeline.PipelineVersionManager;\n+import com.epam.pipeline.manager.security.GrantPermissionManager;\n+import com.epam.pipeline.security.acl.AclPermission;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.folder.FolderCreatorUtils;\n+import com.epam.pipeline.test.creator.pipeline.PipelineCreatorUtils;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.test.context.support.WithMockUser;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_2;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.READ_PERMISSION;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_ARRAY;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_INT;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.WRITE_PERMISSION;\n+import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.doReturn;\n+\n+public class PipelineApiServiceTest extends AbstractAclTest {\n+\n+    protected final Pipeline pipeline = PipelineCreatorUtils.getPipeline(ANOTHER_SIMPLE_USER);", "originalCommit": "301990a43df88288d2ee689542dc9cc085faf318", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDc3ODc5OA==", "url": "https://github.com/epam/cloud-pipeline/pull/1642#discussion_r540778798", "bodyText": "It's a good practice to call overloaded methods from each other.\nIn this case it is possible to have something like the following with some modifications applied:\n    public static Pipeline getPipeline(final String owner) {\n        return getPipeline(ID, owner, ID);\n    }", "author": "tcibinan", "createdAt": "2020-12-11T08:39:55Z", "path": "api/src/test/java/com/epam/pipeline/test/creator/pipeline/PipelineCreatorUtils.java", "diffHunk": "@@ -30,9 +42,18 @@ private PipelineCreatorUtils() {\n     }\n \n     public static Pipeline getPipeline(final String owner) {\n-        Pipeline pipeline = new Pipeline();\n+        final Pipeline pipeline = new Pipeline();\n         pipeline.setId(ID);\n         pipeline.setOwner(owner);\n+        pipeline.setCurrentVersion(getRevision());\n+        return pipeline;\n+    }\n+\n+    public static Pipeline getPipeline(final Long id, final String owner, final Long parentId) {\n+        final Pipeline pipeline = new Pipeline();\n+        pipeline.setId(id);\n+        pipeline.setOwner(owner);\n+        pipeline.setParentFolderId(parentId);\n         return pipeline;\n     }", "originalCommit": "301990a43df88288d2ee689542dc9cc085faf318", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "97bddc15a405d0e20dd41ebcc36dc427324fd3e0", "url": "https://github.com/epam/cloud-pipeline/commit/97bddc15a405d0e20dd41ebcc36dc427324fd3e0", "message": "Issue #1404: Fixed and improvements in accordance with comments\n\nSigned-off-by: Iurii_Kofanov <youkofan@gmail.com>", "committedDate": "2020-12-14T08:37:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjIzNDM0Ng==", "url": "https://github.com/epam/cloud-pipeline/pull/1642#discussion_r542234346", "bodyText": "There is no need for an additional variable.", "author": "tcibinan", "createdAt": "2020-12-14T09:29:47Z", "path": "api/src/test/java/com/epam/pipeline/test/creator/pipeline/PipelineCreatorUtils.java", "diffHunk": "@@ -41,19 +41,17 @@ private PipelineCreatorUtils() {\n \n     }\n \n-    public static Pipeline getPipeline(final String owner) {\n+    public static Pipeline getPipeline(final Long id, final String owner, final Long parentId) {\n         final Pipeline pipeline = new Pipeline();\n-        pipeline.setId(ID);\n+        pipeline.setId(id);\n         pipeline.setOwner(owner);\n+        pipeline.setParentFolderId(parentId);\n         pipeline.setCurrentVersion(getRevision());\n         return pipeline;\n     }\n \n-    public static Pipeline getPipeline(final Long id, final String owner, final Long parentId) {\n-        final Pipeline pipeline = new Pipeline();\n-        pipeline.setId(id);\n-        pipeline.setOwner(owner);\n-        pipeline.setParentFolderId(parentId);\n+    public static Pipeline getPipeline(final String owner) {\n+        final Pipeline pipeline = getPipeline(ID, owner, ID);\n         return pipeline;", "originalCommit": "97bddc15a405d0e20dd41ebcc36dc427324fd3e0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjIzNjcyNQ==", "url": "https://github.com/epam/cloud-pipeline/pull/1642#discussion_r542236725", "bodyText": "I imagine if we can reuse assertThrows method here using @SneakyThrows annotation. The call site will look like this:\nassertThrows(expectedExceptionClass, () -> sneakyThrowing(runnable));", "author": "tcibinan", "createdAt": "2020-12-14T09:33:15Z", "path": "api/src/test/java/com/epam/pipeline/util/CustomAssertions.java", "diffHunk": "@@ -61,4 +61,20 @@ public static void assertThrows(final Runnable runnable) {\n         }\n         fail(\"Exception was expected but nothing was thrown.\");\n     }\n+\n+    public static void assertThrowsChecked(final Class<? extends Throwable> expectedExceptionClass,\n+                                           final CheckedRunnable runnable) {\n+        try {\n+            runnable.run();\n+        } catch (Exception e) {\n+            if (expectedExceptionClass.isInstance(e)) {\n+                return;\n+            } else {\n+                throw new AssertionError(\n+                        String.format(\"Expected exception %s was not thrown, but another exception was: %s.\",\n+                                expectedExceptionClass.getSimpleName(), e.getClass().getSimpleName()), e);\n+            }\n+        }\n+        fail(String.format(\"Expected exception %s was not thrown.\", expectedExceptionClass.getSimpleName()));\n+    }", "originalCommit": "97bddc15a405d0e20dd41ebcc36dc427324fd3e0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM2NjY4OA==", "url": "https://github.com/epam/cloud-pipeline/pull/1642#discussion_r542366688", "bodyText": "I support that something like this should work:\n    @SneakyThrows\n    public static void sneakyThrowing(final CheckedRunnable runnable) {\n        return runnable.run()\n    }\n\n    public static void assertThrowsChecked(final Class<? extends Throwable> expectedExceptionClass,\n                                           final CheckedRunnable runnable) {\n        assertThrows(expectedExceptionClass, () -> sneakyThrowing(runnable));\n    }", "author": "tcibinan", "createdAt": "2020-12-14T13:04:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjIzNjcyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjIzODEzNQ==", "url": "https://github.com/epam/cloud-pipeline/pull/1642#discussion_r542238135", "bodyText": "I think these methods should be moved to the git test class.", "author": "tcibinan", "createdAt": "2020-12-14T09:35:14Z", "path": "api/src/test/java/com/epam/pipeline/acl/pipeline/PipelineApiServiceTest.java", "diffHunk": "@@ -0,0 +1,774 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.acl.pipeline;\n+\n+import com.epam.pipeline.controller.vo.CheckRepositoryVO;\n+import com.epam.pipeline.controller.vo.GenerateFileVO;\n+import com.epam.pipeline.controller.vo.PipelineVO;\n+import com.epam.pipeline.controller.vo.PipelinesWithPermissionsVO;\n+import com.epam.pipeline.controller.vo.RegisterPipelineVersionVO;\n+import com.epam.pipeline.controller.vo.TaskGraphVO;\n+import com.epam.pipeline.entity.cluster.InstancePrice;\n+import com.epam.pipeline.entity.pipeline.DocumentGenerationProperty;\n+import com.epam.pipeline.entity.pipeline.Folder;\n+import com.epam.pipeline.entity.pipeline.Pipeline;\n+import com.epam.pipeline.entity.pipeline.PipelineRun;\n+import com.epam.pipeline.entity.pipeline.Revision;\n+import com.epam.pipeline.exception.git.GitClientException;\n+import com.epam.pipeline.manager.cluster.InstanceOfferManager;\n+import com.epam.pipeline.manager.pipeline.DocumentGenerationPropertyManager;\n+import com.epam.pipeline.manager.pipeline.PipelineFileGenerationManager;\n+import com.epam.pipeline.manager.pipeline.PipelineManager;\n+import com.epam.pipeline.manager.pipeline.PipelineRunManager;\n+import com.epam.pipeline.manager.pipeline.PipelineVersionManager;\n+import com.epam.pipeline.manager.security.GrantPermissionManager;\n+import com.epam.pipeline.security.acl.AclPermission;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.folder.FolderCreatorUtils;\n+import com.epam.pipeline.test.creator.pipeline.PipelineCreatorUtils;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.test.context.support.WithMockUser;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_2;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.READ_PERMISSION;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_ARRAY;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_INT;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.WRITE_PERMISSION;\n+import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n+import static com.epam.pipeline.util.CustomAssertions.assertThrowsChecked;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.reset;\n+\n+public class PipelineApiServiceTest extends AbstractAclTest {\n+\n+    private final Pipeline pipeline = PipelineCreatorUtils.getPipeline(ANOTHER_SIMPLE_USER);\n+    private final Pipeline anotherPipeline = PipelineCreatorUtils.getPipeline(ID_2, ANOTHER_SIMPLE_USER, ID_2);\n+    private final PipelineVO pipelineVO = PipelineCreatorUtils.getPipelineVO(ID);\n+    private final Folder folder = FolderCreatorUtils.getFolder(ID, ANOTHER_SIMPLE_USER);\n+    private final CheckRepositoryVO checkRepositoryVO = PipelineCreatorUtils.getCheckRepositoryVO();\n+    private final PipelinesWithPermissionsVO pipelinesWithPermissions =\n+            PipelineCreatorUtils.getPipelinesWithPermissionsVO();\n+    private final PipelineRun pipelineRun = PipelineCreatorUtils.getPipelineRun(ID, ANOTHER_SIMPLE_USER);\n+    private final Revision revision = PipelineCreatorUtils.getRevision();\n+    private final InstancePrice instancePrice = PipelineCreatorUtils.getInstancePrice();\n+    private final TaskGraphVO taskGraphVO = PipelineCreatorUtils.getTaskGraphVO();\n+    private final GenerateFileVO fileVO = PipelineCreatorUtils.getGenerateFileVO();\n+    private final RegisterPipelineVersionVO pipelineVersionVO = PipelineCreatorUtils.getRegisterPipelineVersionVO();\n+    private final DocumentGenerationProperty property = PipelineCreatorUtils.getDocumentGenerationProperty();\n+    private final List<PipelineRun> pipelineRunList = Collections.singletonList(pipelineRun);\n+    private final List<DocumentGenerationProperty> propertyList = Collections.singletonList(property);\n+\n+    @Autowired\n+    private PipelineApiService pipelineApiService;\n+    @Autowired\n+    private PipelineManager mockPipelineManager;\n+    @Autowired\n+    private PipelineRunManager mockPipelineRunManager;\n+    @Autowired\n+    private PipelineVersionManager mockVersionManager;\n+    @Autowired\n+    private InstanceOfferManager mockInstanceOfferManager;\n+    @Autowired\n+    private PipelineFileGenerationManager mockFileGenerationManager;\n+    @Autowired\n+    private DocumentGenerationPropertyManager mockPropertyManager;\n+    @Autowired\n+    private GrantPermissionManager spyGrantPermissionManager;\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldCreatePipelineForAdmin() throws GitClientException {\n+        doReturn(pipeline).when(mockPipelineManager).create(pipelineVO);\n+\n+        assertThat(pipelineApiService.create(pipelineVO)).isEqualTo(pipeline);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER, roles = PIPELINE_MANAGER_ROLE)\n+    public void shouldCreatePipelineWhenPermissionIsGranted() throws GitClientException {\n+        initAclEntity(folder, AclPermission.WRITE);\n+        doReturn(pipeline).when(mockPipelineManager).create(pipelineVO);\n+\n+        assertThat(pipelineApiService.create(pipelineVO)).isEqualTo(pipeline);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER, roles = PIPELINE_MANAGER_ROLE)\n+    public void shouldDenyCreatePipelineWhenParentIdIsNull() throws GitClientException {\n+        initAclEntity(folder, AclPermission.WRITE);\n+        final PipelineVO pipelineVO = PipelineCreatorUtils.getPipelineVO(null);\n+        doReturn(pipeline).when(mockPipelineManager).create(pipelineVO);\n+\n+        assertThrowsChecked(AccessDeniedException.class, () -> pipelineApiService.create(pipelineVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyCreatePipelineWithoutPipelineManagerRole() throws GitClientException {\n+        initAclEntity(folder, AclPermission.WRITE);\n+        doReturn(pipeline).when(mockPipelineManager).create(pipelineVO);\n+\n+        assertThrowsChecked(AccessDeniedException.class, () -> pipelineApiService.create(pipelineVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER, roles = PIPELINE_MANAGER_ROLE)\n+    public void shouldDenyCreatePipelineWhenPermissionForParentFolderIsNotGranted() throws GitClientException {\n+        initAclEntity(folder);\n+        doReturn(pipeline).when(mockPipelineManager).create(pipelineVO);\n+\n+        assertThrowsChecked(AccessDeniedException.class, () -> pipelineApiService.create(pipelineVO));\n+    }\n+\n+    @Test\n+    public void setCheckRepositoryVO() throws GitClientException {\n+        doReturn(checkRepositoryVO).when(mockPipelineManager).check(checkRepositoryVO);\n+\n+        assertThat(pipelineApiService.check(checkRepositoryVO)).isEqualTo(checkRepositoryVO);\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdatePipelineForAdmin() {\n+        doReturn(pipeline).when(mockPipelineManager).update(pipelineVO);\n+\n+        assertThat(pipelineApiService.update(pipelineVO)).isEqualTo(pipeline);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdatePipelineWhenPermissionIsGranted() {\n+        initAclEntity(pipeline, AclPermission.WRITE);\n+        doReturn(pipeline).when(mockPipelineManager).update(pipelineVO);\n+\n+        final Pipeline returnedPipeline = pipelineApiService.update(pipelineVO);\n+\n+        assertThat(returnedPipeline).isEqualTo(pipeline);\n+        assertThat(returnedPipeline.getMask()).isEqualTo(WRITE_PERMISSION);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyUpdatePipelineWhenPermissionIsNotGranted() {\n+        initAclEntity(pipeline);\n+        doReturn(pipeline).when(mockPipelineManager).update(pipelineVO);\n+\n+        assertThrows(AccessDeniedException.class, () -> pipelineApiService.update(pipelineVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateTokenForAdmin() {\n+        doReturn(pipeline).when(mockPipelineManager).updateToken(pipelineVO);\n+\n+        assertThat(pipelineApiService.updateToken(pipelineVO)).isEqualTo(pipeline);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateTokenWhenPermissionIsGranted() {\n+        initAclEntity(pipeline, AclPermission.WRITE);\n+        doReturn(pipeline).when(mockPipelineManager).updateToken(pipelineVO);\n+\n+        final Pipeline returnedPipeline = pipelineApiService.updateToken(pipelineVO);\n+\n+        assertThat(returnedPipeline).isEqualTo(pipeline);\n+        assertThat(returnedPipeline.getMask()).isEqualTo(WRITE_PERMISSION);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyUpdateTokenWhenPermissionIsNotGranted() {\n+        initAclEntity(pipeline);\n+        doReturn(pipeline).when(mockPipelineManager).updateToken(pipelineVO);\n+\n+        assertThrows(AccessDeniedException.class, () -> pipelineApiService.updateToken(pipelineVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldLoadAllPipelinesForAdmin() {\n+        doReturn(mutableListOf(pipeline)).when(mockPipelineManager).loadAllPipelines(true);\n+\n+        assertThat(pipelineApiService.loadAllPipelines(true)).hasSize(1).contains(pipeline);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldLoadAllPipelinesWhenPermissionIsGranted() {\n+        initAclEntity(pipeline, AclPermission.READ);\n+        doReturn(mutableListOf(pipeline)).when(mockPipelineManager).loadAllPipelines(true);\n+\n+        final List<Pipeline> returnedPipelines = pipelineApiService.loadAllPipelines(true);\n+\n+        assertThat(returnedPipelines).hasSize(1).contains(pipeline);\n+        assertThat(returnedPipelines.get(0).getMask()).isEqualTo(READ_PERMISSION);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldLoadPipelinesWhichPermissionIsGranted() {\n+        initAclEntity(pipeline, AclPermission.READ);\n+        initAclEntity(anotherPipeline);\n+        doReturn(mutableListOf(pipeline, anotherPipeline)).when(mockPipelineManager).loadAllPipelines(true);\n+\n+        final List<Pipeline> returnedPipelines = pipelineApiService.loadAllPipelines(true);\n+\n+        assertThat(returnedPipelines).hasSize(1).contains(pipeline);\n+        assertThat(returnedPipelines.get(0).getMask()).isEqualTo(READ_PERMISSION);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldNotLoadAllPipelinesWhenPermissionIsNotGranted() {\n+        initAclEntity(pipeline);\n+        doReturn(mutableListOf(pipeline)).when(mockPipelineManager).loadAllPipelines(true);\n+\n+        assertThat(pipelineApiService.loadAllPipelines(true)).isEmpty();\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldLoadAllPipelinesWithPermissionsForAdmin() {\n+        doReturn(pipelinesWithPermissions).when(spyGrantPermissionManager)\n+                .loadAllPipelinesWithPermissions(TEST_INT, TEST_INT);\n+\n+        assertThat(pipelineApiService.loadAllPipelinesWithPermissions(TEST_INT, TEST_INT))\n+                .isEqualTo(pipelinesWithPermissions);\n+        reset(spyGrantPermissionManager);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyLoadAllPipelinesWithPermissionsForNotAdmin() {\n+        doReturn(pipelinesWithPermissions).when(spyGrantPermissionManager)\n+                .loadAllPipelinesWithPermissions(TEST_INT, TEST_INT);\n+\n+        assertThrows(AccessDeniedException.class, () ->\n+                pipelineApiService.loadAllPipelinesWithPermissions(TEST_INT, TEST_INT));\n+        reset(spyGrantPermissionManager);\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldLoadPipelineForAdmin() {\n+        doReturn(pipeline).when(mockPipelineManager).load(ID, true);\n+\n+        assertThat(pipelineApiService.load(ID)).isEqualTo(pipeline);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldLoadPipelineWhenPermissionIsGranted() {\n+        initAclEntity(pipeline, AclPermission.READ);\n+        doReturn(pipeline).when(mockPipelineManager).load(ID, true);\n+\n+        final Pipeline returnedPipeline = pipelineApiService.load(ID);\n+\n+        assertThat(returnedPipeline).isEqualTo(pipeline);\n+        assertThat(returnedPipeline.getMask()).isEqualTo(READ_PERMISSION);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyLoadPipelineWhenPermissionIsNotGranted() {\n+        initAclEntity(pipeline);\n+        doReturn(pipeline).when(mockPipelineManager).load(ID, true);\n+\n+        assertThrows(AccessDeniedException.class, () -> pipelineApiService.load(ID));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldLoadPipelineByIdOrNameForAdmin() {\n+        doReturn(pipeline).when(mockPipelineManager).loadByNameOrId(TEST_STRING);\n+\n+        assertThat(pipelineApiService.loadPipelineByIdOrName(TEST_STRING)).isEqualTo(pipeline);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldLoadPipelineByIdOrNameWhenPermissionIsGranted() {\n+        initAclEntity(pipeline, AclPermission.READ);\n+        doReturn(pipeline).when(mockPipelineManager).loadByNameOrId(TEST_STRING);\n+\n+        final Pipeline returnedPipeline = pipelineApiService.loadPipelineByIdOrName(TEST_STRING);\n+\n+        assertThat(returnedPipeline).isEqualTo(pipeline);\n+        assertThat(returnedPipeline.getMask()).isEqualTo(READ_PERMISSION);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyLoadPipelineByIdOrNameWhenPermissionIsNotGranted() {\n+        initAclEntity(pipeline);\n+        doReturn(pipeline).when(mockPipelineManager).loadByNameOrId(TEST_STRING);\n+\n+        assertThrows(AccessDeniedException.class, () -> pipelineApiService.loadPipelineByIdOrName(TEST_STRING));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldLoadAllPipelinesWithoutVersionForAdmin() {\n+        doReturn(mutableListOf(pipeline)).when(mockPipelineManager).loadAllPipelines(false);\n+\n+        assertThat(pipelineApiService.loadAllPipelinesWithoutVersion()).hasSize(1).contains(pipeline);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldLoadAllPipelinesWithoutVersionWhenPermissionIsGranted() {\n+        initAclEntity(pipeline, AclPermission.READ);\n+        doReturn(mutableListOf(pipeline)).when(mockPipelineManager).loadAllPipelines(false);\n+\n+        final List<Pipeline> returnedPipelines = pipelineApiService.loadAllPipelinesWithoutVersion();\n+\n+        assertThat(returnedPipelines).hasSize(1).contains(pipeline);\n+        assertThat(returnedPipelines.get(0).getMask()).isEqualTo(READ_PERMISSION);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldLoadPipelinesWithoutVersionWhichPermissionIsGranted() {\n+        initAclEntity(pipeline, AclPermission.READ);\n+        initAclEntity(anotherPipeline);\n+        doReturn(mutableListOf(pipeline, anotherPipeline)).when(mockPipelineManager).loadAllPipelines(false);\n+\n+        final List<Pipeline> returnedPipelines = pipelineApiService.loadAllPipelinesWithoutVersion();\n+\n+        assertThat(returnedPipelines).hasSize(1).contains(pipeline);\n+        assertThat(returnedPipelines.get(0).getMask()).isEqualTo(READ_PERMISSION);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldNotLoadAllPipelinesWithoutVersionWhenPermissionIsNotGranted() {\n+        initAclEntity(pipeline);\n+        doReturn(mutableListOf(pipeline)).when(mockPipelineManager).loadAllPipelines(false);\n+\n+        assertThat(pipelineApiService.loadAllPipelinesWithoutVersion()).isEmpty();\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldDeletePipelineForAdmin() {\n+        doReturn(pipeline).when(mockPipelineManager).delete(ID, true);\n+\n+        assertThat(pipelineApiService.delete(ID, true)).isEqualTo(pipeline);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER, roles = PIPELINE_MANAGER_ROLE)\n+    public void shouldDeletePipelineWhenPermissionIsGranted() {\n+        initAclEntity(pipeline, AclPermission.WRITE);\n+        doReturn(pipeline).when(mockPipelineManager).delete(ID, true);\n+\n+        assertThat(pipelineApiService.delete(ID, true)).isEqualTo(pipeline);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER, roles = PIPELINE_MANAGER_ROLE)\n+    public void shouldDenyDeletePipelineWhenPermissionIsNotGranted() {\n+        initAclEntity(pipeline);\n+        doReturn(pipeline).when(mockPipelineManager).delete(ID, true);\n+\n+        assertThrows(AccessDeniedException.class, () -> pipelineApiService.delete(ID, true));\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyDeletePipelineWithoutPipelineManagerRole() {\n+        initAclEntity(pipeline, AclPermission.WRITE);\n+        doReturn(pipeline).when(mockPipelineManager).delete(ID, true);\n+\n+        assertThrows(AccessDeniedException.class, () -> pipelineApiService.delete(ID, true));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldLoadAllRunsByPipelineForAdmin() {\n+        doReturn(pipelineRunList).when(mockPipelineRunManager).loadAllRunsByPipeline(ID);\n+\n+        assertThat(pipelineApiService.loadAllRunsByPipeline(ID)).isEqualTo(pipelineRunList);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldLoadAllRunsByPipelineWhenPermissionIsGranted() {\n+        initAclEntity(pipeline, AclPermission.READ);\n+        initAclEntity(pipelineRun, AclPermission.READ);\n+        doReturn(pipelineRunList).when(mockPipelineRunManager).loadAllRunsByPipeline(ID);\n+\n+        final List<PipelineRun> returnedPipelineRunList = pipelineApiService.loadAllRunsByPipeline(ID);\n+\n+        assertThat(returnedPipelineRunList).hasSize(1).contains(pipelineRun);\n+        assertThat(returnedPipelineRunList.get(0).getMask()).isEqualTo(READ_PERMISSION);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyLoadAllRunsByPipelineWhenPermissionIsNotGranted() {\n+        initAclEntity(pipeline);\n+        doReturn(pipelineRunList).when(mockPipelineRunManager).loadAllRunsByPipeline(ID);\n+\n+        assertThrows(AccessDeniedException.class, () -> pipelineApiService.loadAllRunsByPipeline(ID));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldGetInstanceEstimatedPriceForAdmin() throws GitClientException {\n+        doReturn(instancePrice).when(mockInstanceOfferManager)\n+                .getInstanceEstimatedPrice(ID, TEST_STRING, TEST_STRING, TEST_STRING, TEST_INT, true, ID);\n+\n+        assertThat(pipelineApiService.\n+                getInstanceEstimatedPrice(ID, TEST_STRING, TEST_STRING, TEST_STRING, TEST_INT, true, ID))\n+                .isEqualTo(instancePrice);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldGetInstanceEstimatedPriceWhenPermissionIsGranted() throws GitClientException {\n+        initAclEntity(pipeline, AclPermission.READ);\n+        doReturn(instancePrice).when(mockInstanceOfferManager)\n+                .getInstanceEstimatedPrice(ID, TEST_STRING, TEST_STRING, TEST_STRING, TEST_INT, true, ID);\n+\n+        assertThat(pipelineApiService.\n+                getInstanceEstimatedPrice(ID, TEST_STRING, TEST_STRING, TEST_STRING, TEST_INT, true, ID))\n+                .isEqualTo(instancePrice);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyGetInstanceEstimatedPriceWhenPermissionIsNotGranted() throws GitClientException {\n+        initAclEntity(pipeline);\n+        doReturn(instancePrice).when(mockInstanceOfferManager)\n+                .getInstanceEstimatedPrice(ID, TEST_STRING, TEST_STRING, TEST_STRING, TEST_INT, true, ID);\n+\n+        assertThrowsChecked(AccessDeniedException.class, () ->\n+                pipelineApiService.getInstanceEstimatedPrice(ID, TEST_STRING, TEST_STRING,\n+                        TEST_STRING, TEST_INT, true, ID));\n+    }\n+\n+    @Test\n+    public void shouldGetInstanceEstimatedPrice() {\n+        doReturn(instancePrice).when(mockInstanceOfferManager)\n+                .getInstanceEstimatedPrice(TEST_STRING, TEST_INT, true, ID);\n+\n+        assertThat(pipelineApiService.getInstanceEstimatedPrice(TEST_STRING, TEST_INT, true, ID))\n+                .isEqualTo(instancePrice);\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldGetWorkflowGraphForAdmin() {\n+        doReturn(taskGraphVO).when(mockVersionManager).getWorkflowGraph(ID, TEST_STRING);\n+\n+        assertThat(pipelineApiService.getWorkflowGraph(ID, TEST_STRING)).isEqualTo(taskGraphVO);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldGetWorkflowGraphWhenPermissionIsGranted() {\n+        initAclEntity(pipeline, AclPermission.READ);\n+        doReturn(taskGraphVO).when(mockVersionManager).getWorkflowGraph(ID, TEST_STRING);\n+\n+        assertThat(pipelineApiService.getWorkflowGraph(ID, TEST_STRING)).isEqualTo(taskGraphVO);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyGetWorkflowGraphWhenPermissionIsNotGranted() {\n+        initAclEntity(pipeline);\n+        doReturn(taskGraphVO).when(mockVersionManager).getWorkflowGraph(ID, TEST_STRING);\n+\n+        assertThrows(AccessDeniedException.class, () -> pipelineApiService.getWorkflowGraph(ID, TEST_STRING));\n+    }", "originalCommit": "97bddc15a405d0e20dd41ebcc36dc427324fd3e0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjIzODI1Mg==", "url": "https://github.com/epam/cloud-pipeline/pull/1642#discussion_r542238252", "bodyText": "These too.", "author": "tcibinan", "createdAt": "2020-12-14T09:35:23Z", "path": "api/src/test/java/com/epam/pipeline/acl/pipeline/PipelineApiServiceTest.java", "diffHunk": "@@ -0,0 +1,774 @@\n+/*\n+ * Copyright 2017-2020 EPAM Systems, Inc. (https://www.epam.com/)\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.epam.pipeline.acl.pipeline;\n+\n+import com.epam.pipeline.controller.vo.CheckRepositoryVO;\n+import com.epam.pipeline.controller.vo.GenerateFileVO;\n+import com.epam.pipeline.controller.vo.PipelineVO;\n+import com.epam.pipeline.controller.vo.PipelinesWithPermissionsVO;\n+import com.epam.pipeline.controller.vo.RegisterPipelineVersionVO;\n+import com.epam.pipeline.controller.vo.TaskGraphVO;\n+import com.epam.pipeline.entity.cluster.InstancePrice;\n+import com.epam.pipeline.entity.pipeline.DocumentGenerationProperty;\n+import com.epam.pipeline.entity.pipeline.Folder;\n+import com.epam.pipeline.entity.pipeline.Pipeline;\n+import com.epam.pipeline.entity.pipeline.PipelineRun;\n+import com.epam.pipeline.entity.pipeline.Revision;\n+import com.epam.pipeline.exception.git.GitClientException;\n+import com.epam.pipeline.manager.cluster.InstanceOfferManager;\n+import com.epam.pipeline.manager.pipeline.DocumentGenerationPropertyManager;\n+import com.epam.pipeline.manager.pipeline.PipelineFileGenerationManager;\n+import com.epam.pipeline.manager.pipeline.PipelineManager;\n+import com.epam.pipeline.manager.pipeline.PipelineRunManager;\n+import com.epam.pipeline.manager.pipeline.PipelineVersionManager;\n+import com.epam.pipeline.manager.security.GrantPermissionManager;\n+import com.epam.pipeline.security.acl.AclPermission;\n+import com.epam.pipeline.test.acl.AbstractAclTest;\n+import com.epam.pipeline.test.creator.folder.FolderCreatorUtils;\n+import com.epam.pipeline.test.creator.pipeline.PipelineCreatorUtils;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.security.access.AccessDeniedException;\n+import org.springframework.security.test.context.support.WithMockUser;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.ID_2;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.READ_PERMISSION;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_ARRAY;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_INT;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.TEST_STRING;\n+import static com.epam.pipeline.test.creator.CommonCreatorConstants.WRITE_PERMISSION;\n+import static com.epam.pipeline.util.CustomAssertions.assertThrows;\n+import static com.epam.pipeline.util.CustomAssertions.assertThrowsChecked;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.reset;\n+\n+public class PipelineApiServiceTest extends AbstractAclTest {\n+\n+    private final Pipeline pipeline = PipelineCreatorUtils.getPipeline(ANOTHER_SIMPLE_USER);\n+    private final Pipeline anotherPipeline = PipelineCreatorUtils.getPipeline(ID_2, ANOTHER_SIMPLE_USER, ID_2);\n+    private final PipelineVO pipelineVO = PipelineCreatorUtils.getPipelineVO(ID);\n+    private final Folder folder = FolderCreatorUtils.getFolder(ID, ANOTHER_SIMPLE_USER);\n+    private final CheckRepositoryVO checkRepositoryVO = PipelineCreatorUtils.getCheckRepositoryVO();\n+    private final PipelinesWithPermissionsVO pipelinesWithPermissions =\n+            PipelineCreatorUtils.getPipelinesWithPermissionsVO();\n+    private final PipelineRun pipelineRun = PipelineCreatorUtils.getPipelineRun(ID, ANOTHER_SIMPLE_USER);\n+    private final Revision revision = PipelineCreatorUtils.getRevision();\n+    private final InstancePrice instancePrice = PipelineCreatorUtils.getInstancePrice();\n+    private final TaskGraphVO taskGraphVO = PipelineCreatorUtils.getTaskGraphVO();\n+    private final GenerateFileVO fileVO = PipelineCreatorUtils.getGenerateFileVO();\n+    private final RegisterPipelineVersionVO pipelineVersionVO = PipelineCreatorUtils.getRegisterPipelineVersionVO();\n+    private final DocumentGenerationProperty property = PipelineCreatorUtils.getDocumentGenerationProperty();\n+    private final List<PipelineRun> pipelineRunList = Collections.singletonList(pipelineRun);\n+    private final List<DocumentGenerationProperty> propertyList = Collections.singletonList(property);\n+\n+    @Autowired\n+    private PipelineApiService pipelineApiService;\n+    @Autowired\n+    private PipelineManager mockPipelineManager;\n+    @Autowired\n+    private PipelineRunManager mockPipelineRunManager;\n+    @Autowired\n+    private PipelineVersionManager mockVersionManager;\n+    @Autowired\n+    private InstanceOfferManager mockInstanceOfferManager;\n+    @Autowired\n+    private PipelineFileGenerationManager mockFileGenerationManager;\n+    @Autowired\n+    private DocumentGenerationPropertyManager mockPropertyManager;\n+    @Autowired\n+    private GrantPermissionManager spyGrantPermissionManager;\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldCreatePipelineForAdmin() throws GitClientException {\n+        doReturn(pipeline).when(mockPipelineManager).create(pipelineVO);\n+\n+        assertThat(pipelineApiService.create(pipelineVO)).isEqualTo(pipeline);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER, roles = PIPELINE_MANAGER_ROLE)\n+    public void shouldCreatePipelineWhenPermissionIsGranted() throws GitClientException {\n+        initAclEntity(folder, AclPermission.WRITE);\n+        doReturn(pipeline).when(mockPipelineManager).create(pipelineVO);\n+\n+        assertThat(pipelineApiService.create(pipelineVO)).isEqualTo(pipeline);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER, roles = PIPELINE_MANAGER_ROLE)\n+    public void shouldDenyCreatePipelineWhenParentIdIsNull() throws GitClientException {\n+        initAclEntity(folder, AclPermission.WRITE);\n+        final PipelineVO pipelineVO = PipelineCreatorUtils.getPipelineVO(null);\n+        doReturn(pipeline).when(mockPipelineManager).create(pipelineVO);\n+\n+        assertThrowsChecked(AccessDeniedException.class, () -> pipelineApiService.create(pipelineVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyCreatePipelineWithoutPipelineManagerRole() throws GitClientException {\n+        initAclEntity(folder, AclPermission.WRITE);\n+        doReturn(pipeline).when(mockPipelineManager).create(pipelineVO);\n+\n+        assertThrowsChecked(AccessDeniedException.class, () -> pipelineApiService.create(pipelineVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER, roles = PIPELINE_MANAGER_ROLE)\n+    public void shouldDenyCreatePipelineWhenPermissionForParentFolderIsNotGranted() throws GitClientException {\n+        initAclEntity(folder);\n+        doReturn(pipeline).when(mockPipelineManager).create(pipelineVO);\n+\n+        assertThrowsChecked(AccessDeniedException.class, () -> pipelineApiService.create(pipelineVO));\n+    }\n+\n+    @Test\n+    public void setCheckRepositoryVO() throws GitClientException {\n+        doReturn(checkRepositoryVO).when(mockPipelineManager).check(checkRepositoryVO);\n+\n+        assertThat(pipelineApiService.check(checkRepositoryVO)).isEqualTo(checkRepositoryVO);\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdatePipelineForAdmin() {\n+        doReturn(pipeline).when(mockPipelineManager).update(pipelineVO);\n+\n+        assertThat(pipelineApiService.update(pipelineVO)).isEqualTo(pipeline);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdatePipelineWhenPermissionIsGranted() {\n+        initAclEntity(pipeline, AclPermission.WRITE);\n+        doReturn(pipeline).when(mockPipelineManager).update(pipelineVO);\n+\n+        final Pipeline returnedPipeline = pipelineApiService.update(pipelineVO);\n+\n+        assertThat(returnedPipeline).isEqualTo(pipeline);\n+        assertThat(returnedPipeline.getMask()).isEqualTo(WRITE_PERMISSION);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyUpdatePipelineWhenPermissionIsNotGranted() {\n+        initAclEntity(pipeline);\n+        doReturn(pipeline).when(mockPipelineManager).update(pipelineVO);\n+\n+        assertThrows(AccessDeniedException.class, () -> pipelineApiService.update(pipelineVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldUpdateTokenForAdmin() {\n+        doReturn(pipeline).when(mockPipelineManager).updateToken(pipelineVO);\n+\n+        assertThat(pipelineApiService.updateToken(pipelineVO)).isEqualTo(pipeline);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldUpdateTokenWhenPermissionIsGranted() {\n+        initAclEntity(pipeline, AclPermission.WRITE);\n+        doReturn(pipeline).when(mockPipelineManager).updateToken(pipelineVO);\n+\n+        final Pipeline returnedPipeline = pipelineApiService.updateToken(pipelineVO);\n+\n+        assertThat(returnedPipeline).isEqualTo(pipeline);\n+        assertThat(returnedPipeline.getMask()).isEqualTo(WRITE_PERMISSION);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyUpdateTokenWhenPermissionIsNotGranted() {\n+        initAclEntity(pipeline);\n+        doReturn(pipeline).when(mockPipelineManager).updateToken(pipelineVO);\n+\n+        assertThrows(AccessDeniedException.class, () -> pipelineApiService.updateToken(pipelineVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldLoadAllPipelinesForAdmin() {\n+        doReturn(mutableListOf(pipeline)).when(mockPipelineManager).loadAllPipelines(true);\n+\n+        assertThat(pipelineApiService.loadAllPipelines(true)).hasSize(1).contains(pipeline);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldLoadAllPipelinesWhenPermissionIsGranted() {\n+        initAclEntity(pipeline, AclPermission.READ);\n+        doReturn(mutableListOf(pipeline)).when(mockPipelineManager).loadAllPipelines(true);\n+\n+        final List<Pipeline> returnedPipelines = pipelineApiService.loadAllPipelines(true);\n+\n+        assertThat(returnedPipelines).hasSize(1).contains(pipeline);\n+        assertThat(returnedPipelines.get(0).getMask()).isEqualTo(READ_PERMISSION);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldLoadPipelinesWhichPermissionIsGranted() {\n+        initAclEntity(pipeline, AclPermission.READ);\n+        initAclEntity(anotherPipeline);\n+        doReturn(mutableListOf(pipeline, anotherPipeline)).when(mockPipelineManager).loadAllPipelines(true);\n+\n+        final List<Pipeline> returnedPipelines = pipelineApiService.loadAllPipelines(true);\n+\n+        assertThat(returnedPipelines).hasSize(1).contains(pipeline);\n+        assertThat(returnedPipelines.get(0).getMask()).isEqualTo(READ_PERMISSION);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldNotLoadAllPipelinesWhenPermissionIsNotGranted() {\n+        initAclEntity(pipeline);\n+        doReturn(mutableListOf(pipeline)).when(mockPipelineManager).loadAllPipelines(true);\n+\n+        assertThat(pipelineApiService.loadAllPipelines(true)).isEmpty();\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldLoadAllPipelinesWithPermissionsForAdmin() {\n+        doReturn(pipelinesWithPermissions).when(spyGrantPermissionManager)\n+                .loadAllPipelinesWithPermissions(TEST_INT, TEST_INT);\n+\n+        assertThat(pipelineApiService.loadAllPipelinesWithPermissions(TEST_INT, TEST_INT))\n+                .isEqualTo(pipelinesWithPermissions);\n+        reset(spyGrantPermissionManager);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyLoadAllPipelinesWithPermissionsForNotAdmin() {\n+        doReturn(pipelinesWithPermissions).when(spyGrantPermissionManager)\n+                .loadAllPipelinesWithPermissions(TEST_INT, TEST_INT);\n+\n+        assertThrows(AccessDeniedException.class, () ->\n+                pipelineApiService.loadAllPipelinesWithPermissions(TEST_INT, TEST_INT));\n+        reset(spyGrantPermissionManager);\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldLoadPipelineForAdmin() {\n+        doReturn(pipeline).when(mockPipelineManager).load(ID, true);\n+\n+        assertThat(pipelineApiService.load(ID)).isEqualTo(pipeline);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldLoadPipelineWhenPermissionIsGranted() {\n+        initAclEntity(pipeline, AclPermission.READ);\n+        doReturn(pipeline).when(mockPipelineManager).load(ID, true);\n+\n+        final Pipeline returnedPipeline = pipelineApiService.load(ID);\n+\n+        assertThat(returnedPipeline).isEqualTo(pipeline);\n+        assertThat(returnedPipeline.getMask()).isEqualTo(READ_PERMISSION);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyLoadPipelineWhenPermissionIsNotGranted() {\n+        initAclEntity(pipeline);\n+        doReturn(pipeline).when(mockPipelineManager).load(ID, true);\n+\n+        assertThrows(AccessDeniedException.class, () -> pipelineApiService.load(ID));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldLoadPipelineByIdOrNameForAdmin() {\n+        doReturn(pipeline).when(mockPipelineManager).loadByNameOrId(TEST_STRING);\n+\n+        assertThat(pipelineApiService.loadPipelineByIdOrName(TEST_STRING)).isEqualTo(pipeline);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldLoadPipelineByIdOrNameWhenPermissionIsGranted() {\n+        initAclEntity(pipeline, AclPermission.READ);\n+        doReturn(pipeline).when(mockPipelineManager).loadByNameOrId(TEST_STRING);\n+\n+        final Pipeline returnedPipeline = pipelineApiService.loadPipelineByIdOrName(TEST_STRING);\n+\n+        assertThat(returnedPipeline).isEqualTo(pipeline);\n+        assertThat(returnedPipeline.getMask()).isEqualTo(READ_PERMISSION);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyLoadPipelineByIdOrNameWhenPermissionIsNotGranted() {\n+        initAclEntity(pipeline);\n+        doReturn(pipeline).when(mockPipelineManager).loadByNameOrId(TEST_STRING);\n+\n+        assertThrows(AccessDeniedException.class, () -> pipelineApiService.loadPipelineByIdOrName(TEST_STRING));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldLoadAllPipelinesWithoutVersionForAdmin() {\n+        doReturn(mutableListOf(pipeline)).when(mockPipelineManager).loadAllPipelines(false);\n+\n+        assertThat(pipelineApiService.loadAllPipelinesWithoutVersion()).hasSize(1).contains(pipeline);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldLoadAllPipelinesWithoutVersionWhenPermissionIsGranted() {\n+        initAclEntity(pipeline, AclPermission.READ);\n+        doReturn(mutableListOf(pipeline)).when(mockPipelineManager).loadAllPipelines(false);\n+\n+        final List<Pipeline> returnedPipelines = pipelineApiService.loadAllPipelinesWithoutVersion();\n+\n+        assertThat(returnedPipelines).hasSize(1).contains(pipeline);\n+        assertThat(returnedPipelines.get(0).getMask()).isEqualTo(READ_PERMISSION);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldLoadPipelinesWithoutVersionWhichPermissionIsGranted() {\n+        initAclEntity(pipeline, AclPermission.READ);\n+        initAclEntity(anotherPipeline);\n+        doReturn(mutableListOf(pipeline, anotherPipeline)).when(mockPipelineManager).loadAllPipelines(false);\n+\n+        final List<Pipeline> returnedPipelines = pipelineApiService.loadAllPipelinesWithoutVersion();\n+\n+        assertThat(returnedPipelines).hasSize(1).contains(pipeline);\n+        assertThat(returnedPipelines.get(0).getMask()).isEqualTo(READ_PERMISSION);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldNotLoadAllPipelinesWithoutVersionWhenPermissionIsNotGranted() {\n+        initAclEntity(pipeline);\n+        doReturn(mutableListOf(pipeline)).when(mockPipelineManager).loadAllPipelines(false);\n+\n+        assertThat(pipelineApiService.loadAllPipelinesWithoutVersion()).isEmpty();\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldDeletePipelineForAdmin() {\n+        doReturn(pipeline).when(mockPipelineManager).delete(ID, true);\n+\n+        assertThat(pipelineApiService.delete(ID, true)).isEqualTo(pipeline);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER, roles = PIPELINE_MANAGER_ROLE)\n+    public void shouldDeletePipelineWhenPermissionIsGranted() {\n+        initAclEntity(pipeline, AclPermission.WRITE);\n+        doReturn(pipeline).when(mockPipelineManager).delete(ID, true);\n+\n+        assertThat(pipelineApiService.delete(ID, true)).isEqualTo(pipeline);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER, roles = PIPELINE_MANAGER_ROLE)\n+    public void shouldDenyDeletePipelineWhenPermissionIsNotGranted() {\n+        initAclEntity(pipeline);\n+        doReturn(pipeline).when(mockPipelineManager).delete(ID, true);\n+\n+        assertThrows(AccessDeniedException.class, () -> pipelineApiService.delete(ID, true));\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyDeletePipelineWithoutPipelineManagerRole() {\n+        initAclEntity(pipeline, AclPermission.WRITE);\n+        doReturn(pipeline).when(mockPipelineManager).delete(ID, true);\n+\n+        assertThrows(AccessDeniedException.class, () -> pipelineApiService.delete(ID, true));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldLoadAllRunsByPipelineForAdmin() {\n+        doReturn(pipelineRunList).when(mockPipelineRunManager).loadAllRunsByPipeline(ID);\n+\n+        assertThat(pipelineApiService.loadAllRunsByPipeline(ID)).isEqualTo(pipelineRunList);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldLoadAllRunsByPipelineWhenPermissionIsGranted() {\n+        initAclEntity(pipeline, AclPermission.READ);\n+        initAclEntity(pipelineRun, AclPermission.READ);\n+        doReturn(pipelineRunList).when(mockPipelineRunManager).loadAllRunsByPipeline(ID);\n+\n+        final List<PipelineRun> returnedPipelineRunList = pipelineApiService.loadAllRunsByPipeline(ID);\n+\n+        assertThat(returnedPipelineRunList).hasSize(1).contains(pipelineRun);\n+        assertThat(returnedPipelineRunList.get(0).getMask()).isEqualTo(READ_PERMISSION);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyLoadAllRunsByPipelineWhenPermissionIsNotGranted() {\n+        initAclEntity(pipeline);\n+        doReturn(pipelineRunList).when(mockPipelineRunManager).loadAllRunsByPipeline(ID);\n+\n+        assertThrows(AccessDeniedException.class, () -> pipelineApiService.loadAllRunsByPipeline(ID));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldGetInstanceEstimatedPriceForAdmin() throws GitClientException {\n+        doReturn(instancePrice).when(mockInstanceOfferManager)\n+                .getInstanceEstimatedPrice(ID, TEST_STRING, TEST_STRING, TEST_STRING, TEST_INT, true, ID);\n+\n+        assertThat(pipelineApiService.\n+                getInstanceEstimatedPrice(ID, TEST_STRING, TEST_STRING, TEST_STRING, TEST_INT, true, ID))\n+                .isEqualTo(instancePrice);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldGetInstanceEstimatedPriceWhenPermissionIsGranted() throws GitClientException {\n+        initAclEntity(pipeline, AclPermission.READ);\n+        doReturn(instancePrice).when(mockInstanceOfferManager)\n+                .getInstanceEstimatedPrice(ID, TEST_STRING, TEST_STRING, TEST_STRING, TEST_INT, true, ID);\n+\n+        assertThat(pipelineApiService.\n+                getInstanceEstimatedPrice(ID, TEST_STRING, TEST_STRING, TEST_STRING, TEST_INT, true, ID))\n+                .isEqualTo(instancePrice);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyGetInstanceEstimatedPriceWhenPermissionIsNotGranted() throws GitClientException {\n+        initAclEntity(pipeline);\n+        doReturn(instancePrice).when(mockInstanceOfferManager)\n+                .getInstanceEstimatedPrice(ID, TEST_STRING, TEST_STRING, TEST_STRING, TEST_INT, true, ID);\n+\n+        assertThrowsChecked(AccessDeniedException.class, () ->\n+                pipelineApiService.getInstanceEstimatedPrice(ID, TEST_STRING, TEST_STRING,\n+                        TEST_STRING, TEST_INT, true, ID));\n+    }\n+\n+    @Test\n+    public void shouldGetInstanceEstimatedPrice() {\n+        doReturn(instancePrice).when(mockInstanceOfferManager)\n+                .getInstanceEstimatedPrice(TEST_STRING, TEST_INT, true, ID);\n+\n+        assertThat(pipelineApiService.getInstanceEstimatedPrice(TEST_STRING, TEST_INT, true, ID))\n+                .isEqualTo(instancePrice);\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldGetWorkflowGraphForAdmin() {\n+        doReturn(taskGraphVO).when(mockVersionManager).getWorkflowGraph(ID, TEST_STRING);\n+\n+        assertThat(pipelineApiService.getWorkflowGraph(ID, TEST_STRING)).isEqualTo(taskGraphVO);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldGetWorkflowGraphWhenPermissionIsGranted() {\n+        initAclEntity(pipeline, AclPermission.READ);\n+        doReturn(taskGraphVO).when(mockVersionManager).getWorkflowGraph(ID, TEST_STRING);\n+\n+        assertThat(pipelineApiService.getWorkflowGraph(ID, TEST_STRING)).isEqualTo(taskGraphVO);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyGetWorkflowGraphWhenPermissionIsNotGranted() {\n+        initAclEntity(pipeline);\n+        doReturn(taskGraphVO).when(mockVersionManager).getWorkflowGraph(ID, TEST_STRING);\n+\n+        assertThrows(AccessDeniedException.class, () -> pipelineApiService.getWorkflowGraph(ID, TEST_STRING));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldFillTemplateForPipelineVersionForAdmin() {\n+        doReturn(TEST_ARRAY).when(mockFileGenerationManager)\n+                .fillTemplateForPipelineVersion(ID, TEST_STRING, TEST_STRING, fileVO);\n+\n+        assertThat(pipelineApiService.fillTemplateForPipelineVersion(ID, TEST_STRING, TEST_STRING, fileVO))\n+                .isEqualTo(TEST_ARRAY);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldFillTemplateForPipelineVersionWhenPermissionIsGranted() {\n+        initAclEntity(pipeline, AclPermission.READ);\n+        doReturn(TEST_ARRAY).when(mockFileGenerationManager)\n+                .fillTemplateForPipelineVersion(ID, TEST_STRING, TEST_STRING, fileVO);\n+\n+        assertThat(pipelineApiService.fillTemplateForPipelineVersion(ID, TEST_STRING, TEST_STRING, fileVO))\n+                .isEqualTo(TEST_ARRAY);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyFillTemplateForPipelineVersionWhenPermissionIsNotGranted() {\n+        initAclEntity(pipeline);\n+        doReturn(TEST_ARRAY).when(mockFileGenerationManager)\n+                .fillTemplateForPipelineVersion(ID, TEST_STRING, TEST_STRING, fileVO);\n+\n+        assertThrows(AccessDeniedException.class, () ->\n+                pipelineApiService.fillTemplateForPipelineVersion(ID, TEST_STRING, TEST_STRING, fileVO));\n+    }\n+\n+    @Test\n+    @WithMockUser(roles = ADMIN_ROLE)\n+    public void shouldRegisterPipelineVersionForAdmin() throws GitClientException {\n+        doReturn(revision).when(mockVersionManager).registerPipelineVersion(pipelineVersionVO);\n+\n+        assertThat(pipelineApiService.registerPipelineVersion(pipelineVersionVO)).isEqualTo(revision);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldRegisterPipelineVersionWhenPermissionIsGranted() throws GitClientException {\n+        initAclEntity(pipeline, AclPermission.WRITE);\n+        doReturn(revision).when(mockVersionManager).registerPipelineVersion(pipelineVersionVO);\n+\n+        assertThat(pipelineApiService.registerPipelineVersion(pipelineVersionVO)).isEqualTo(revision);\n+    }\n+\n+    @Test\n+    @WithMockUser(username = SIMPLE_USER)\n+    public void shouldDenyRegisterPipelineVersionWhenPermissionIsNotGranted() throws GitClientException {\n+        initAclEntity(pipeline);\n+        doReturn(revision).when(mockVersionManager).registerPipelineVersion(pipelineVersionVO);\n+\n+        assertThrowsChecked(AccessDeniedException.class, () ->\n+                pipelineApiService.registerPipelineVersion(pipelineVersionVO));\n+    }", "originalCommit": "97bddc15a405d0e20dd41ebcc36dc427324fd3e0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f2e50340fb8f30f7dc13c509bb732a5e591d6007", "url": "https://github.com/epam/cloud-pipeline/commit/f2e50340fb8f30f7dc13c509bb732a5e591d6007", "message": "Issue #1404: moving some tests, improvement of assertion method\n\nSigned-off-by: Iurii_Kofanov <youkofan@gmail.com>", "committedDate": "2020-12-14T14:29:10Z", "type": "commit"}]}