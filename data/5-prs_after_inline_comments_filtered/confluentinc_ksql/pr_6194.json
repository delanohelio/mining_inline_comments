{"pr_number": 6194, "pr_title": "feat: add `KEY_FORMAT` and `FORMAT` WITH clause properties", "pr_createdAt": "2020-09-13T20:35:29Z", "pr_url": "https://github.com/confluentinc/ksql/pull/6194", "timeline": [{"oid": "f4caed33e7229964c79b96e779541d1cf807ab24", "url": "https://github.com/confluentinc/ksql/commit/f4caed33e7229964c79b96e779541d1cf807ab24", "message": "feat: add KEY_FORMAT and FORMAT WITH clause properties", "committedDate": "2020-09-13T20:26:52Z", "type": "commit"}, {"oid": "c7fa102fcd062f84cba757fdff27ca0c257153cb", "url": "https://github.com/confluentinc/ksql/commit/c7fa102fcd062f84cba757fdff27ca0c257153cb", "message": "test: fix DefaultFormatInjectorTest", "committedDate": "2020-09-13T21:06:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU3NzU0MA==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487577540", "bodyText": "PlannedTestsUpToDateTest currently fails because of two changes:\n\nthe removal of the create or replace feature flag from this properties blacklist, as this adds a field into the plan\nthe additional of the DefaultFormatInjector in this PR, which injects KEY_FORMAT into CS/CT statements where only VALUE_FORMAT has been explicitly provided, which is currently all tests.\n\nI think these two changes are acceptable, and therefore the way to fix the test is to regenerate test plans, but I'm curious to hear what others think, especially regarding whether it makes sense to inject key/value formats into CS/CT statements that don't explicitly provide them. Note that this behavior is inline with the DefaultSchemaInjector injecting schemas into statements for which schema inference is performed.", "author": "vcrfxia", "createdAt": "2020-09-13T21:07:19Z", "path": "ksqldb-functional-tests/src/test/java/io/confluent/ksql/test/planned/PlannedTestUtils.java", "diffHunk": "@@ -50,7 +50,7 @@ public static boolean isNotExcluded(final TestCase testCase) {\n     // Place temporary logic here to exclude test cases based on feature flags, etc.\n     return !(boolean) testCase\n         .properties()\n-        .getOrDefault(KsqlConfig.KSQL_CREATE_OR_REPLACE_ENABLED, false);\n+        .getOrDefault(KsqlConfig.KSQL_KEY_FORMAT_ENABLED, false);", "originalCommit": "c7fa102fcd062f84cba757fdff27ca0c257153cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkxMDM4OA==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487910388", "bodyText": "I've leave the removal of the KSQL_CREATE_OR_REPLACE_ENABLED to another PR. It's not related to this PR.  You could just ping Almog to have him remove it.\nDefaultFormatInjector should, (as I've noted above), do nothing if the feature flag is not set.  Hence no plans should need to change.  In general, if you find you need to generate a new set of plans before the feature flag is removed... something is wrong! ;)", "author": "big-andy-coates", "createdAt": "2020-09-14T13:26:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU3NzU0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTkyNTM5MQ==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r489925391", "bodyText": "I've leave the removal of the KSQL_CREATE_OR_REPLACE_ENABLED to another PR. It's not related to this PR.\n\nTurns out the removal of this feature flag does not affect whether the existing historic plans are up to date or not, as the newly added orReplace flag is optional and inferred to be false if not present.\n\nDefaultFormatInjector should, (as I've noted above), do nothing if the feature flag is not set. Hence no plans should need to change. In general, if you find you need to generate a new set of plans before the feature flag is removed... something is wrong! ;)\n\nSee #6194 (comment) for why the injector is still adding KEY_FORMAT even if the feature flag is not set.\nIn light of this, I've gone with the approach we discussed offline of updating KsqlPlanV1 to not include the statementText in comparisons, as we decided this was the lesser evil compared to either generating new plans or rewriting the existing ones.", "author": "vcrfxia", "createdAt": "2020-09-17T03:20:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU3NzU0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU3NzY0OQ==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487577649", "bodyText": "This is needed or else tests that don't explicitly specify KEY_FORMAT in CS/CT statements fail. Feels hacky to add the injector here but I can't think of a better solution (besides requiring explicit KEY_FORMAT in all tests, which doesn't seem right).", "author": "vcrfxia", "createdAt": "2020-09-13T21:08:41Z", "path": "ksqldb-functional-tests/src/main/java/io/confluent/ksql/test/tools/TestCaseBuilderUtil.java", "diffHunk": "@@ -197,7 +200,11 @@ private static Topic createTopicFromStatement(\n \n         if (isCsOrCT(stmt)) {\n           final PreparedStatement<?> prepare = parser.prepare(stmt, metaStore);\n-          topics.add(extractTopic.apply(prepare));\n+          final ConfiguredStatement<?> configured =\n+              ConfiguredStatement.of(prepare, Collections.emptyMap(), ksqlConfig);\n+          // TODO: cleaner way to handle this?\n+          final ConfiguredStatement<?> withFormats = new DefaultFormatInjector().inject(configured);", "originalCommit": "c7fa102fcd062f84cba757fdff27ca0c257153cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk0NTM0NQ==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487945345", "bodyText": "Welcome to the mess of the testing tool!\nYou're approach is generally correct - we need your injector in QTT to do its thing, so unfortunately, this means adding it to QTT, given QTT doesn't currently just use the default Injectors class, (not sure it actually can... not something I'm that familiar with - @agavra  may have more context).\nFor background: this bit of code is attempting to extract the topic info from the statement.  Later in TestExecutorUtil we run the statement for real.  Ideally, we don't want to have to add your injector to both places.  That's just making the code worse.\nMaybe an OK approach would be to have a common method (probably in TestExecutorUtil), that knows how to prepare the statement, with the correct injectors.  You add your injector there, and have both places call that method.\nNot ideal, but....", "author": "big-andy-coates", "createdAt": "2020-09-14T14:00:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU3NzY0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU3NzcyNw==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487577727", "bodyText": "Same as above: this is needed or else tests that don't explicitly specify KEY_FORMAT in CS/CT statements fail. Feels hacky to add the injector here but I can't think of a better solution (besides requiring explicit KEY_FORMAT in all tests, which doesn't seem right).", "author": "vcrfxia", "createdAt": "2020-09-13T21:09:25Z", "path": "ksqldb-functional-tests/src/main/java/io/confluent/ksql/test/tools/TestExecutorUtil.java", "diffHunk": "@@ -438,10 +439,13 @@ public ConfiguredKsqlPlan next() {\n         return Optional.empty();\n       }\n \n+      // TODO: cleaner way to handle this?\n+      final ConfiguredStatement<?> withFormats =", "originalCommit": "c7fa102fcd062f84cba757fdff27ca0c257153cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk0NTY4Ng==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487945686", "bodyText": "See aboive.", "author": "big-andy-coates", "createdAt": "2020-09-14T14:00:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU3NzcyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU3Nzg2OQ==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487577869", "bodyText": "Same problem as with the QTT framework above: this is needed or else tests that don't explicitly specify KEY_FORMAT in CS/CT statements fail. Feels hacky to add the injector here but I can't think of a better solution (besides requiring explicit KEY_FORMAT in all tests, which doesn't seem right).", "author": "vcrfxia", "createdAt": "2020-09-13T21:10:41Z", "path": "ksqldb-functional-tests/src/test/java/io/confluent/ksql/test/driver/KsqlTesterTest.java", "diffHunk": "@@ -210,9 +211,11 @@ private void execute(final ParsedStatement parsedStatement) {\n       return;\n     }\n \n+    // TODO: what's a cleaner way around this failure?\n+    final ConfiguredStatement<?> injected = new DefaultFormatInjector().inject(configured);", "originalCommit": "c7fa102fcd062f84cba757fdff27ca0c257153cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk0NjY0OQ==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487946649", "bodyText": "@agavra is probably the best person to comment here...", "author": "big-andy-coates", "createdAt": "2020-09-14T14:01:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU3Nzg2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU3ODA0MA==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487578040", "bodyText": "Is the RequestValidator the right place to perform this validation? This felt more correct to me than either the executor or the DefaultFormatInjector, but given that neither QTT nor YATT calls the RequestValidator, I'm no longer sure.", "author": "vcrfxia", "createdAt": "2020-09-13T21:12:31Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/validation/RequestValidator.java", "diffHunk": "@@ -142,6 +145,7 @@ public int validate(\n     } else if (KsqlEngine.isExecutableStatement(configured.getStatement())\n         || configured.getStatement() instanceof TerminateQuery) {\n       final ConfiguredStatement<?> statementInjected = injector.inject(configured);\n+      validateSupportedKeyFormat(statementInjected);", "originalCommit": "c7fa102fcd062f84cba757fdff27ca0c257153cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg5NzY4MQ==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487897681", "bodyText": "This doesn't look like the right place to me.  RequestValidator doesn't look to be called in headless mode.\nHow about putting a check at the top of EngineExecutor.plan(ConfiguredStatement<?> statement)?", "author": "big-andy-coates", "createdAt": "2020-09-14T13:08:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU3ODA0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTEzMTEzMg==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r489131132", "bodyText": "Ah, good call on the RequestValidator not being called in headless mode! Moved to the check into EngineExecutor (as you've suggested) instead.", "author": "vcrfxia", "createdAt": "2020-09-16T02:55:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU3ODA0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg3NjUzNQ==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487876535", "bodyText": "nit: lets get these moved up a line so they're next to VALUE_FORMAT_PROPERTY.", "author": "big-andy-coates", "createdAt": "2020-09-14T12:35:18Z", "path": "ksqldb-common/src/main/java/io/confluent/ksql/properties/with/CommonCreateConfigs.java", "diffHunk": "@@ -39,13 +39,14 @@\n   public static final String VALUE_AVRO_SCHEMA_FULL_NAME = \"VALUE_AVRO_SCHEMA_FULL_NAME\";\n   public static final String VALUE_FORMAT_PROPERTY = \"VALUE_FORMAT\";\n   public static final String WRAP_SINGLE_VALUE = \"WRAP_SINGLE_VALUE\";\n+  public static final String KEY_FORMAT_PROPERTY = \"KEY_FORMAT\";\n+  public static final String FORMAT_PROPERTY = \"FORMAT\";", "originalCommit": "c7fa102fcd062f84cba757fdff27ca0c257153cb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg4MzA1OA==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487883058", "bodyText": "FORMAT and KEY_FORMAT are equally valid in CREATE AS statements, so this check is also needed in CreateSourceAsProperties class.", "author": "big-andy-coates", "createdAt": "2020-09-14T12:45:55Z", "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/properties/with/CreateSourceProperties.java", "diffHunk": "@@ -74,12 +75,29 @@ public static CreateSourceProperties from(final Map<String, Literal> literals) {\n     this.props = new PropertiesConfig(CreateConfigs.CONFIG_METADATA, originals);\n     this.durationParser = Objects.requireNonNull(durationParser, \"durationParser\");\n \n+    props.validateKeyValueFormats(", "originalCommit": "c7fa102fcd062f84cba757fdff27ca0c257153cb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg4NDY2Mw==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487884663", "bodyText": "Having these throw if the property is not set smells to me.  Better to have them return an Optional, meaning the optionality of the property is baked into the type system.\nThis would also decouple this class from DefaultFormatInjector, meaning you could remove all the comments about DefaultFormatInjector.", "author": "big-andy-coates", "createdAt": "2020-09-14T12:48:21Z", "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/properties/with/CreateSourceProperties.java", "diffHunk": "@@ -131,13 +149,51 @@ public String getKafkaTopic() {\n     return Optional.ofNullable(props.getInt(CreateConfigs.SCHEMA_ID));\n   }\n \n-  public FormatInfo getFormatInfo() {\n-    return FormatInfo.of(\n-        props.getString(CommonCreateConfigs.VALUE_FORMAT_PROPERTY),\n-        getFormatProperties());\n+  /**\n+   * This method should only be called after the DefaultFormatInjector has run, in order to\n+   * guarantee a key format is present.\n+   */\n+  public FormatInfo getKeyFormatInfo() {\n+    final String keyFormat = getKeyFormatName().orElseThrow(\n+        () -> new IllegalStateException(\"Key format not present\")\n+    );\n+    return FormatInfo.of(keyFormat, ImmutableMap.of());\n+  }\n+\n+  /**\n+   * This method should only be called after the DefaultFormatInjector has run, in order to\n+   * guarantee a value format is present.\n+   */\n+  public FormatInfo getValueFormatInfo() {\n+    final String valueFormat = getValueFormatName().orElseThrow(\n+        () -> new IllegalStateException(\"Value format not present\")\n+    );\n+    return FormatInfo.of(valueFormat, getValueFormatProperties());", "originalCommit": "c7fa102fcd062f84cba757fdff27ca0c257153cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTkxMzI1Nw==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r489913257", "bodyText": "Done.", "author": "vcrfxia", "createdAt": "2020-09-17T03:00:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg4NDY2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg4ODQ4Mw==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487888483", "bodyText": "Nothing wrong with the code above, but how about the following to remove some duplicate calls and code:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              /**\n          \n          \n            \n               * This method may be called before the DefaultFormatInjector has run, in which case a\n          \n          \n            \n               * key format may not be present.\n          \n          \n            \n               */\n          \n          \n            \n              public Optional<String> getKeyFormatName() {\n          \n          \n            \n                final String keyFormat = props.getString(CommonCreateConfigs.FORMAT_PROPERTY) != null\n          \n          \n            \n                    ? props.getString(CommonCreateConfigs.FORMAT_PROPERTY)\n          \n          \n            \n                    : props.getString(CommonCreateConfigs.KEY_FORMAT_PROPERTY);\n          \n          \n            \n                return Optional.ofNullable(keyFormat);\n          \n          \n            \n              }\n          \n          \n            \n            \n          \n          \n            \n              /**\n          \n          \n            \n               * This method may be called before the DefaultFormatInjector has run, in which case a\n          \n          \n            \n               * value format may not be present.\n          \n          \n            \n               */\n          \n          \n            \n              public Optional<String> getValueFormatName() {\n          \n          \n            \n                final String valueFormat = props.getString(CommonCreateConfigs.FORMAT_PROPERTY) != null\n          \n          \n            \n                    ? props.getString(CommonCreateConfigs.FORMAT_PROPERTY)\n          \n          \n            \n                    : props.getString(CommonCreateConfigs.VALUE_FORMAT_PROPERTY);\n          \n          \n            \n                return Optional.ofNullable(valueFormat);\n          \n          \n            \n              }\n          \n          \n            \n              /**\n          \n          \n            \n               * The key format name, if supplied explicitly.\n          \n          \n            \n               */\n          \n          \n            \n              public Optional<String> getKeyFormatName() {\n          \n          \n            \n                final String keyFormat = getFormatName()\n          \n          \n            \n                   .orElse(props.getString(CommonCreateConfigs.KEY_FORMAT_PROPERTY));\n          \n          \n            \n                return Optional.ofNullable(keyFormat);\n          \n          \n            \n              }\n          \n          \n            \n            \n          \n          \n            \n              /**\n          \n          \n            \n               * The value format name, if supplied explicitly.\n          \n          \n            \n               */\n          \n          \n            \n              public Optional<String> getValueFormatName() {\n          \n          \n            \n                final String valueFormat = getFormatName()\n          \n          \n            \n                  .orElse(props.getString(CommonCreateConfigs.VALUE_FORMAT_PROPERTY));\n          \n          \n            \n                return Optional.ofNullable(valueFormat);\n          \n          \n            \n              }\n          \n          \n            \n              \n          \n          \n            \n              private Optional<String> getFormatName() {\n          \n          \n            \n                 return Optional.ofNullable(props.getString(CommonCreateConfigs.FORMAT_PROPERTY));\n          \n          \n            \n              }", "author": "big-andy-coates", "createdAt": "2020-09-14T12:54:13Z", "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/properties/with/CreateSourceProperties.java", "diffHunk": "@@ -131,13 +149,51 @@ public String getKafkaTopic() {\n     return Optional.ofNullable(props.getInt(CreateConfigs.SCHEMA_ID));\n   }\n \n-  public FormatInfo getFormatInfo() {\n-    return FormatInfo.of(\n-        props.getString(CommonCreateConfigs.VALUE_FORMAT_PROPERTY),\n-        getFormatProperties());\n+  /**\n+   * This method should only be called after the DefaultFormatInjector has run, in order to\n+   * guarantee a key format is present.\n+   */\n+  public FormatInfo getKeyFormatInfo() {\n+    final String keyFormat = getKeyFormatName().orElseThrow(\n+        () -> new IllegalStateException(\"Key format not present\")\n+    );\n+    return FormatInfo.of(keyFormat, ImmutableMap.of());\n+  }\n+\n+  /**\n+   * This method should only be called after the DefaultFormatInjector has run, in order to\n+   * guarantee a value format is present.\n+   */\n+  public FormatInfo getValueFormatInfo() {\n+    final String valueFormat = getValueFormatName().orElseThrow(\n+        () -> new IllegalStateException(\"Value format not present\")\n+    );\n+    return FormatInfo.of(valueFormat, getValueFormatProperties());\n   }\n \n-  private Map<String, String> getFormatProperties() {\n+  /**\n+   * This method may be called before the DefaultFormatInjector has run, in which case a\n+   * key format may not be present.\n+   */\n+  public Optional<String> getKeyFormatName() {\n+    final String keyFormat = props.getString(CommonCreateConfigs.FORMAT_PROPERTY) != null\n+        ? props.getString(CommonCreateConfigs.FORMAT_PROPERTY)\n+        : props.getString(CommonCreateConfigs.KEY_FORMAT_PROPERTY);\n+    return Optional.ofNullable(keyFormat);\n+  }\n+\n+  /**\n+   * This method may be called before the DefaultFormatInjector has run, in which case a\n+   * value format may not be present.\n+   */\n+  public Optional<String> getValueFormatName() {\n+    final String valueFormat = props.getString(CommonCreateConfigs.FORMAT_PROPERTY) != null\n+        ? props.getString(CommonCreateConfigs.FORMAT_PROPERTY)\n+        : props.getString(CommonCreateConfigs.VALUE_FORMAT_PROPERTY);\n+    return Optional.ofNullable(valueFormat);\n+  }", "originalCommit": "c7fa102fcd062f84cba757fdff27ca0c257153cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTExOTExNQ==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r489119115", "bodyText": "Much nicer! Thanks for the tip.", "author": "vcrfxia", "createdAt": "2020-09-16T02:10:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg4ODQ4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg4OTUwOQ==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487889509", "bodyText": "Add unit test / QTT test to cover the situation where FORMAT is supplied.  (Looks like this code would fail as its setting KEY_FORMAT and VALUE_FORMAT, but not clearing FORMAT if its provided.", "author": "big-andy-coates", "createdAt": "2020-09-14T12:55:37Z", "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/properties/with/CreateSourceProperties.java", "diffHunk": "@@ -182,6 +238,14 @@ public CreateSourceProperties withPartitionsAndReplicas(\n     return new CreateSourceProperties(originals, durationParser);\n   }\n \n+  public CreateSourceProperties withFormats(final String keyFormat, final String valueFormat) {\n+    final Map<String, Literal> originals = props.copyOfOriginalLiterals();\n+    originals.put(CommonCreateConfigs.KEY_FORMAT_PROPERTY, new StringLiteral(keyFormat));\n+    originals.put(CommonCreateConfigs.VALUE_FORMAT_PROPERTY, new StringLiteral(valueFormat));\n+\n+    return new CreateSourceProperties(originals, durationParser);\n+  }", "originalCommit": "c7fa102fcd062f84cba757fdff27ca0c257153cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDY2OTQzNA==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r490669434", "bodyText": "There are already QTTs for this. Are there specific cases you'd additionally like to see?\nThe injector is a no-op if FORMAT is supplied, since the injector returns if both a key and value format are present. As a consequence, this method is never called if FORMAT is supplied. If it feels more \"correct\" to clear FORMAT in this method I can do that but it's not necessary the way the code is set up today.", "author": "vcrfxia", "createdAt": "2020-09-18T02:48:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg4OTUwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg4OTgzNw==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487889837", "bodyText": "PropertiesConfig is meant to be a general purpose class, not specific to CreateSourceAsProperties and CreateSourceProperties. So while it makes sense to have general purpose code in there to handle timestamps, (validateDateTimeFormat), it probably doesn't make sense to have code in their for handle key & value formats.  That's probably best defined somewhere else. Maybe CommonCreateConfigs could have a utility method?", "author": "big-andy-coates", "createdAt": "2020-09-14T12:56:04Z", "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/properties/with/PropertiesConfig.java", "diffHunk": "@@ -69,6 +69,28 @@ public String toString() {\n     return new HashMap<>(originalLiterals);\n   }\n \n+  void validateKeyValueFormats(\n+      final String keyFormatConfig,\n+      final String valueFormatConfig,\n+      final String formatConfig\n+  ) {\n+    final Object value = originals().get(formatConfig);\n+    if (value == null) {\n+      return;\n+    }\n+\n+    if (originals().get(keyFormatConfig) != null) {\n+      throw new KsqlException(\"Cannot supply both '\" + keyFormatConfig + \"' and '\"\n+          + formatConfig + \"' properties. Did you mean to use '\" + valueFormatConfig\n+          + \"' instead of '\" + formatConfig + \"'?\");\n+    }\n+    if (originals().get(valueFormatConfig) != null) {\n+      throw new KsqlException(\"Cannot supply both '\" + valueFormatConfig + \"' and '\"\n+          + formatConfig + \"' properties. Did you mean to use '\" + keyFormatConfig\n+          + \"' instead of '\" + formatConfig + \"'?\");\n+    }\n+  }", "originalCommit": "c7fa102fcd062f84cba757fdff27ca0c257153cb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg5MDQ0Mg==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487890442", "bodyText": "This test class needs shouldThrowIfKeyFormatAndFormatProvided and shouldThrowIfValueFormatAndFormatProvided tests as well.", "author": "big-andy-coates", "createdAt": "2020-09-14T12:56:59Z", "path": "ksqldb-parser/src/test/java/io/confluent/ksql/parser/properties/with/CreateSourcePropertiesTest.java", "diffHunk": "@@ -391,22 +391,6 @@ public void shouldFailIfNoKafkaTopicName() {\n     assertThat(e.getMessage(), containsString(\"Missing required property \\\"KAFKA_TOPIC\\\" which has no default value.\"));\n   }\n \n-  @Test\n-  public void shouldFailIfNoValueFormat() {", "originalCommit": "c7fa102fcd062f84cba757fdff27ca0c257153cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTEyNDI3NQ==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r489124275", "bodyText": "Not sure what this comment is getting at. shouldThrowIfKeyFormatAndFormatProvided and shouldThrowIfValueFormatAndFormatProvided were already added to this file (with those exact names). Did you mean that CreateSourceAsPropertiesTest would need these tests as well, once the analogous validation was added to CreateAsSelectProperties? If so, this is done.", "author": "vcrfxia", "createdAt": "2020-09-16T02:29:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg5MDQ0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM2MDEwMg==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r489360102", "bodyText": "Yeah, that's what I meant :D", "author": "big-andy-coates", "createdAt": "2020-09-16T11:20:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg5MDQ0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg5MTY0Mw==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487891643", "bodyText": "nice catch!", "author": "big-andy-coates", "createdAt": "2020-09-14T12:58:45Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/logging/processing/ProcessingLogServerUtils.java", "diffHunk": "@@ -78,20 +78,24 @@ public static String processingLogStreamCreateStatement(\n   ) {\n     return processingLogStreamCreateStatement(\n         config.getString(ProcessingLogConfig.STREAM_NAME),\n-        getTopicName(config, ksqlConfig)\n+        getTopicName(config, ksqlConfig),\n+        ksqlConfig.getBoolean(KsqlConfig.KSQL_KEY_FORMAT_ENABLED)", "originalCommit": "c7fa102fcd062f84cba757fdff27ca0c257153cb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg5MTgxOQ==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487891819", "bodyText": "Likewise, nice catch!", "author": "big-andy-coates", "createdAt": "2020-09-14T12:59:03Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/KsqlRestApplication.java", "diffHunk": "@@ -881,7 +881,11 @@ private void registerCommandTopic() {\n \n     final String createCmd = \"CREATE STREAM \" + COMMANDS_STREAM_NAME\n         + \" (STATEMENT STRING)\"\n-        + \" WITH(VALUE_FORMAT='JSON', KAFKA_TOPIC='\" + commandTopic + \"');\";\n+        + \" WITH(\"\n+        + (ksqlConfigNoPort.getBoolean(KsqlConfig.KSQL_KEY_FORMAT_ENABLED)\n+            ? \"KEY_FORMAT='KAFKA' \"\n+            : \"\")\n+        + \"VALUE_FORMAT='JSON', KAFKA_TOPIC='\" + commandTopic + \"');\";", "originalCommit": "c7fa102fcd062f84cba757fdff27ca0c257153cb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg5ODk4MQ==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487898981", "bodyText": "Personally, I'd remove this bit from the JavaDocs (avoids the chance of it getting missed when the feature flag is removed).  And anyway, I don't think the injector needs to validate and throw the format properties. That only needs doing in one place.", "author": "big-andy-coates", "createdAt": "2020-09-14T13:09:57Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.format;\n+\n+import io.confluent.ksql.parser.KsqlParser.PreparedStatement;\n+import io.confluent.ksql.parser.SqlFormatter;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.confluent.ksql.parser.properties.with.CreateSourceProperties;\n+import io.confluent.ksql.parser.tree.CreateAsSelect;\n+import io.confluent.ksql.parser.tree.CreateSource;\n+import io.confluent.ksql.parser.tree.Statement;\n+import io.confluent.ksql.properties.with.CommonCreateConfigs;\n+import io.confluent.ksql.statement.ConfiguredStatement;\n+import io.confluent.ksql.statement.Injector;\n+import io.confluent.ksql.util.ErrorMessageUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+import java.util.Optional;\n+\n+/**\n+ * An injector which injects the key and value formats into the supplied {@code statement}.\n+ *\n+ * <p>The key format is only injected if:\n+ * <ul>\n+ * <li>The statement is a CT/CS.</li>\n+ * <li>The statement does not specify the FORMAT property in its WITH clause.</li>\n+ * <li>The statement does not specify the KEY_FORMAT property in its WITH clause.</li>\n+ * </ul>\n+ *\n+ * <p>Similarly, the value format is only injected if the above conditions are met,\n+ * where the KEY_FORMAT property is replaced with the VALUE_FORMAT property accordingly.\n+ *\n+ * <p>If any of the above are not true then the {@code statement} is returned unchanged.\n+ *\n+ * <p>This injector also validates that the KEY_FORMAT property is only supplied if the\n+ * relevant feature flag is enabled.", "originalCommit": "c7fa102fcd062f84cba757fdff27ca0c257153cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTEzNDAxNw==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r489134017", "bodyText": "Removed the Javadoc. See #6194 (comment) for discussion on why I still think it makes sense for this validation to be in the injector.", "author": "vcrfxia", "createdAt": "2020-09-16T03:06:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg5ODk4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwMTExNw==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487901117", "bodyText": "generally better to move code into functions to make the code much easier to read at a higher level, making this:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              @SuppressWarnings(\"unchecked\")\n          \n          \n            \n              @Override\n          \n          \n            \n              public <T extends Statement> ConfiguredStatement<T> inject(\n          \n          \n            \n                  final ConfiguredStatement<T> statement\n          \n          \n            \n              ) {\n          \n          \n            \n                if (statement.getStatement() instanceof CreateSource) {\n          \n          \n            \n                  final ConfiguredStatement<CreateSource> createStatement =\n          \n          \n            \n                      (ConfiguredStatement<CreateSource>) statement;\n          \n          \n            \n            \n          \n          \n            \n                  if (createStatement.getStatement().getProperties().getKeyFormatName().isPresent()) {\n          \n          \n            \n                    throwIfKeyFormatDisabled(createStatement);\n          \n          \n            \n                  }\n          \n          \n            \n            \n          \n          \n            \n                  try {\n          \n          \n            \n                    return (ConfiguredStatement<T>) forCreateStatement(createStatement).orElse(createStatement);\n          \n          \n            \n                  } catch (final KsqlStatementException e) {\n          \n          \n            \n                    throw e;\n          \n          \n            \n                  } catch (final KsqlException e) {\n          \n          \n            \n                    throw new KsqlStatementException(\n          \n          \n            \n                        ErrorMessageUtil.buildErrorMessage(e),\n          \n          \n            \n                        statement.getStatementText(),\n          \n          \n            \n                        e.getCause());\n          \n          \n            \n                  }\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                if (statement.getStatement() instanceof CreateAsSelect) {\n          \n          \n            \n                  final ConfiguredStatement<CreateAsSelect> createAsSelect =\n          \n          \n            \n                      (ConfiguredStatement<CreateAsSelect>) statement;\n          \n          \n            \n            \n          \n          \n            \n                  if (createAsSelect.getStatement().getProperties().getKeyFormatInfo().isPresent()) {\n          \n          \n            \n                    throwIfKeyFormatDisabled(createAsSelect);\n          \n          \n            \n                  }\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                return statement;\n          \n          \n            \n              }\n          \n          \n            \n              @SuppressWarnings(\"unchecked\")\n          \n          \n            \n              @Override\n          \n          \n            \n              public <T extends Statement> ConfiguredStatement<T> inject(\n          \n          \n            \n                  final ConfiguredStatement<T> statement\n          \n          \n            \n              ) {\n          \n          \n            \n                if (featureFlagNotEnabled(statement)) {\n          \n          \n            \n                   return statement;\n          \n          \n            \n                }\n          \n          \n            \n                \n          \n          \n            \n                if (statement.getStatement() instanceof CreateSource) {\n          \n          \n            \n                  return handleCreateSource((ConfiguredStatement<CreateSource>)statement);\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                if (statement.getStatement() instanceof CreateAsSelect) {\n          \n          \n            \n                   return handleCreateSourceAs((ConfiguredStatement<CreateAsSelect>)statement);\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                return statement;\n          \n          \n            \n              }\n          \n      \n    \n    \n  \n\nThis also limits the scope of the disabling of the unchecked warnings to only the bits of code that do this and it's clear that code is first checking the type.", "author": "big-andy-coates", "createdAt": "2020-09-14T13:13:07Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.format;\n+\n+import io.confluent.ksql.parser.KsqlParser.PreparedStatement;\n+import io.confluent.ksql.parser.SqlFormatter;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.confluent.ksql.parser.properties.with.CreateSourceProperties;\n+import io.confluent.ksql.parser.tree.CreateAsSelect;\n+import io.confluent.ksql.parser.tree.CreateSource;\n+import io.confluent.ksql.parser.tree.Statement;\n+import io.confluent.ksql.properties.with.CommonCreateConfigs;\n+import io.confluent.ksql.statement.ConfiguredStatement;\n+import io.confluent.ksql.statement.Injector;\n+import io.confluent.ksql.util.ErrorMessageUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+import java.util.Optional;\n+\n+/**\n+ * An injector which injects the key and value formats into the supplied {@code statement}.\n+ *\n+ * <p>The key format is only injected if:\n+ * <ul>\n+ * <li>The statement is a CT/CS.</li>\n+ * <li>The statement does not specify the FORMAT property in its WITH clause.</li>\n+ * <li>The statement does not specify the KEY_FORMAT property in its WITH clause.</li>\n+ * </ul>\n+ *\n+ * <p>Similarly, the value format is only injected if the above conditions are met,\n+ * where the KEY_FORMAT property is replaced with the VALUE_FORMAT property accordingly.\n+ *\n+ * <p>If any of the above are not true then the {@code statement} is returned unchanged.\n+ *\n+ * <p>This injector also validates that the KEY_FORMAT property is only supplied if the\n+ * relevant feature flag is enabled.\n+ */\n+public class DefaultFormatInjector implements Injector {\n+\n+  public DefaultFormatInjector() {\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public <T extends Statement> ConfiguredStatement<T> inject(\n+      final ConfiguredStatement<T> statement\n+  ) {\n+    if (statement.getStatement() instanceof CreateSource) {\n+      final ConfiguredStatement<CreateSource> createStatement =\n+          (ConfiguredStatement<CreateSource>) statement;\n+\n+      if (createStatement.getStatement().getProperties().getKeyFormatName().isPresent()) {\n+        throwIfKeyFormatDisabled(createStatement);\n+      }\n+\n+      try {\n+        return (ConfiguredStatement<T>) forCreateStatement(createStatement).orElse(createStatement);\n+      } catch (final KsqlStatementException e) {\n+        throw e;\n+      } catch (final KsqlException e) {\n+        throw new KsqlStatementException(\n+            ErrorMessageUtil.buildErrorMessage(e),\n+            statement.getStatementText(),\n+            e.getCause());\n+      }\n+    }\n+\n+    if (statement.getStatement() instanceof CreateAsSelect) {\n+      final ConfiguredStatement<CreateAsSelect> createAsSelect =\n+          (ConfiguredStatement<CreateAsSelect>) statement;\n+\n+      if (createAsSelect.getStatement().getProperties().getKeyFormatInfo().isPresent()) {\n+        throwIfKeyFormatDisabled(createAsSelect);\n+      }\n+    }\n+\n+    return statement;\n+  }", "originalCommit": "c7fa102fcd062f84cba757fdff27ca0c257153cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTEyMjgwNw==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r489122807", "bodyText": "I've incorporated the meta-point in this comment as best I could but the result isn't as clean as in your example since I can't figure out what the method signature of handleCreateSource() in this example would be. In order to return the result directly the return type would need to be ConfiguredStatement<T> but the helper method wouldn't know what T is if the input param has type ConfiguredStatement<CreateSource>. As a result, I wasn't able to isolate the unchecked warning beyond where it's at currently.", "author": "vcrfxia", "createdAt": "2020-09-16T02:23:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwMTExNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM2MjA1Mw==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r489362053", "bodyText": "something like:\n@SupressWarning({\"unchecked\", \"rawType\"})\nprivate <T extends Statement> ConfiguredStatement<T> handleCreateSource(\n    final ConfiguredStatement<CreateSource> statement\n  ) {\n\n  ...\n\n  // Safe to cast as we _know_ `T` is `CreateSource`.\n  return (ConfiguredStatement)result;\n}\nBut it's not a biggie.", "author": "big-andy-coates", "createdAt": "2020-09-16T11:24:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwMTExNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDY2OTk5NA==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r490669994", "bodyText": "Done, except there's still an unchecked cast warning on the main inject() method since checking that statement.getStatement() instanceof CreateSource isn't enough to guarantee a clean cast for (ConfiguredStatement<CreateSource>) statement. Am I missing something?", "author": "vcrfxia", "createdAt": "2020-09-18T02:50:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwMTExNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjAxMTg0OQ==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492011849", "bodyText": "I guess you could do:\n@SupressWarning({\"unchecked\", \"rawType\"})\nprivate <T extends Statement> ConfiguredStatement<T> handleCreateSource(\n    final ConfiguredStatement<T> statement\n  ) {\n  if (!statement.getStatement() instance of CreateSource) {\n     throw new IllegalArgumentException(something);\n  }\n  ...\n\n  return (ConfiguredStatement)result;\n}", "author": "big-andy-coates", "createdAt": "2020-09-21T12:41:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwMTExNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwMjcwNA==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487902704", "bodyText": "I think these can be removed. EngineExecutor.plan should be the only place you need to throw if key format is provided (or set to something other than KAFKA).\nI think all that is needed here is for inject to do nothing if the feature flag is not set.", "author": "big-andy-coates", "createdAt": "2020-09-14T13:15:28Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.format;\n+\n+import io.confluent.ksql.parser.KsqlParser.PreparedStatement;\n+import io.confluent.ksql.parser.SqlFormatter;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.confluent.ksql.parser.properties.with.CreateSourceProperties;\n+import io.confluent.ksql.parser.tree.CreateAsSelect;\n+import io.confluent.ksql.parser.tree.CreateSource;\n+import io.confluent.ksql.parser.tree.Statement;\n+import io.confluent.ksql.properties.with.CommonCreateConfigs;\n+import io.confluent.ksql.statement.ConfiguredStatement;\n+import io.confluent.ksql.statement.Injector;\n+import io.confluent.ksql.util.ErrorMessageUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+import java.util.Optional;\n+\n+/**\n+ * An injector which injects the key and value formats into the supplied {@code statement}.\n+ *\n+ * <p>The key format is only injected if:\n+ * <ul>\n+ * <li>The statement is a CT/CS.</li>\n+ * <li>The statement does not specify the FORMAT property in its WITH clause.</li>\n+ * <li>The statement does not specify the KEY_FORMAT property in its WITH clause.</li>\n+ * </ul>\n+ *\n+ * <p>Similarly, the value format is only injected if the above conditions are met,\n+ * where the KEY_FORMAT property is replaced with the VALUE_FORMAT property accordingly.\n+ *\n+ * <p>If any of the above are not true then the {@code statement} is returned unchanged.\n+ *\n+ * <p>This injector also validates that the KEY_FORMAT property is only supplied if the\n+ * relevant feature flag is enabled.\n+ */\n+public class DefaultFormatInjector implements Injector {\n+\n+  public DefaultFormatInjector() {\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public <T extends Statement> ConfiguredStatement<T> inject(\n+      final ConfiguredStatement<T> statement\n+  ) {\n+    if (statement.getStatement() instanceof CreateSource) {\n+      final ConfiguredStatement<CreateSource> createStatement =\n+          (ConfiguredStatement<CreateSource>) statement;\n+\n+      if (createStatement.getStatement().getProperties().getKeyFormatName().isPresent()) {\n+        throwIfKeyFormatDisabled(createStatement);\n+      }", "originalCommit": "c7fa102fcd062f84cba757fdff27ca0c257153cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTEyOTgyMg==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r489129822", "bodyText": "As discussed offline, this injector can't be a direct pass-through if the feature flag is not enabled because we still need to validate that VALUE_FORMAT is explicitly provided in this case, and I think it also makes sense to throw if KEY_FORMAT is supplied here rather than forcing downstream code to handle that. As discussed, I've cleaned up the feature flag handling logic in this class to only check the flag in one place so it's much more readable now.", "author": "vcrfxia", "createdAt": "2020-09-16T02:51:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwMjcwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM2MzgxOQ==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r489363819", "bodyText": "As discussed offline, this injector can't be a direct pass-through if the feature flag is not enabled because we still need to validate that VALUE_FORMAT is explicitly provided in this case\n\nAgreed.\n\nand I think it also makes sense to throw if KEY_FORMAT is supplied here rather than forcing downstream code to handle that.\n\nI don't think we gain anything from checking here, if we're already checking in EngineExecutor.plan.  It feels like an unnecessary check.\nBut it's no biggie, and having not played with the code, I may just be wrong ;)", "author": "big-andy-coates", "createdAt": "2020-09-16T11:28:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwMjcwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTkyMTc5NQ==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r489921795", "bodyText": "Ah, just remembered (rediscovered) the problem I ran into when I originally wanted the injector to be a pass-through if the feature flag isn't enabled: if the downstream (engine) code is updated to expect the statement contains a key format, and the injector doesn't add a key format because the feature flag is not enabled, then we fail downstream.\nOther options include:\n\nhave the downstream code check the feature flag and default to KAFKA if the key format isn't present. This is undesirable because we'll be checking the feature flag in a bunch of different places. Even if we create a util method for it, we'll be adding a bunch of code for passing KsqlConfig into the util method which will be removed once the feature flag is removed, and doesn't seem worth the effort as a result.\nhave CreateSourceProperties consume the feature flag and default to KAFKA if not set. This faces the same problem of CreateSourceProperties needing access to KsqlConfig which feels wrong.\n\nThe downside of having the injector always inject key format if not present, regardless of feature flag, is that when the feature flag is not set, users will still start seeing KEY_FORMAT appear in their statements which may be confusing. IMO this still seems less bad than the other options. WDYT?\n\nI don't think we gain anything from checking here, if we're already checking in EngineExecutor.plan. It feels like an unnecessary check.\n\nThe engine checks whether the key format is supported. This check is for whether the key format is supplied at all, and throws even if a valid (supported) key format is supplied, since users shouldn't be trying to supply key formats if the feature flag is not enabled. If we'd rather we can remove this check and allow users to supply KEY_FORMAT='KAFKA' even if the feature flag is not enabled. (My original reason for disallowing this was in an attempt to preserve the pre-feature flag behavior, but that's now been broken by the required change above.)", "author": "vcrfxia", "createdAt": "2020-09-17T03:14:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwMjcwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjAxNDQ3MA==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492014470", "bodyText": "IMO this still seems less bad than the other options. WDYT?\n\nSounds good.\n\nIf we'd rather we can remove this check and allow users to supply KEY_FORMAT='KAFKA' even if the feature flag is not enabled.\n\nI think it makes total sense. If we allow KEY_FORMAT='KAFKA' then its no longer a big weird that users will see KEY_FORMAT in their statements when ksqlDB displays them back to them.", "author": "big-andy-coates", "createdAt": "2020-09-21T12:44:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwMjcwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMwMDc3OA==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492300778", "bodyText": "Cool. I've updated the PR to allow the use of KEY_FORMAT and FORMAT even when the feature flag is not enabled.", "author": "vcrfxia", "createdAt": "2020-09-21T19:37:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwMjcwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwMjg4Ng==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487902886", "bodyText": "I think these can be removed. EngineExecutor.plan should be the only place you need to throw if key format is provided (or set to something other than KAFKA).\nI think all that is needed here is for inject to do nothing if the feature flag is not set.", "author": "big-andy-coates", "createdAt": "2020-09-14T13:15:43Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.format;\n+\n+import io.confluent.ksql.parser.KsqlParser.PreparedStatement;\n+import io.confluent.ksql.parser.SqlFormatter;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.confluent.ksql.parser.properties.with.CreateSourceProperties;\n+import io.confluent.ksql.parser.tree.CreateAsSelect;\n+import io.confluent.ksql.parser.tree.CreateSource;\n+import io.confluent.ksql.parser.tree.Statement;\n+import io.confluent.ksql.properties.with.CommonCreateConfigs;\n+import io.confluent.ksql.statement.ConfiguredStatement;\n+import io.confluent.ksql.statement.Injector;\n+import io.confluent.ksql.util.ErrorMessageUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+import java.util.Optional;\n+\n+/**\n+ * An injector which injects the key and value formats into the supplied {@code statement}.\n+ *\n+ * <p>The key format is only injected if:\n+ * <ul>\n+ * <li>The statement is a CT/CS.</li>\n+ * <li>The statement does not specify the FORMAT property in its WITH clause.</li>\n+ * <li>The statement does not specify the KEY_FORMAT property in its WITH clause.</li>\n+ * </ul>\n+ *\n+ * <p>Similarly, the value format is only injected if the above conditions are met,\n+ * where the KEY_FORMAT property is replaced with the VALUE_FORMAT property accordingly.\n+ *\n+ * <p>If any of the above are not true then the {@code statement} is returned unchanged.\n+ *\n+ * <p>This injector also validates that the KEY_FORMAT property is only supplied if the\n+ * relevant feature flag is enabled.\n+ */\n+public class DefaultFormatInjector implements Injector {\n+\n+  public DefaultFormatInjector() {\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public <T extends Statement> ConfiguredStatement<T> inject(\n+      final ConfiguredStatement<T> statement\n+  ) {\n+    if (statement.getStatement() instanceof CreateSource) {\n+      final ConfiguredStatement<CreateSource> createStatement =\n+          (ConfiguredStatement<CreateSource>) statement;\n+\n+      if (createStatement.getStatement().getProperties().getKeyFormatName().isPresent()) {\n+        throwIfKeyFormatDisabled(createStatement);\n+      }\n+\n+      try {\n+        return (ConfiguredStatement<T>) forCreateStatement(createStatement).orElse(createStatement);\n+      } catch (final KsqlStatementException e) {\n+        throw e;\n+      } catch (final KsqlException e) {\n+        throw new KsqlStatementException(\n+            ErrorMessageUtil.buildErrorMessage(e),\n+            statement.getStatementText(),\n+            e.getCause());\n+      }\n+    }\n+\n+    if (statement.getStatement() instanceof CreateAsSelect) {\n+      final ConfiguredStatement<CreateAsSelect> createAsSelect =\n+          (ConfiguredStatement<CreateAsSelect>) statement;\n+\n+      if (createAsSelect.getStatement().getProperties().getKeyFormatInfo().isPresent()) {\n+        throwIfKeyFormatDisabled(createAsSelect);\n+      }", "originalCommit": "c7fa102fcd062f84cba757fdff27ca0c257153cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTEyOTg0Mw==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r489129843", "bodyText": "As above.", "author": "vcrfxia", "createdAt": "2020-09-16T02:51:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwMjg4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwNTY3NQ==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487905675", "bodyText": "This can go if you just early out of the inject method whenever the feature flag is not set.", "author": "big-andy-coates", "createdAt": "2020-09-14T13:19:54Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.format;\n+\n+import io.confluent.ksql.parser.KsqlParser.PreparedStatement;\n+import io.confluent.ksql.parser.SqlFormatter;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.confluent.ksql.parser.properties.with.CreateSourceProperties;\n+import io.confluent.ksql.parser.tree.CreateAsSelect;\n+import io.confluent.ksql.parser.tree.CreateSource;\n+import io.confluent.ksql.parser.tree.Statement;\n+import io.confluent.ksql.properties.with.CommonCreateConfigs;\n+import io.confluent.ksql.statement.ConfiguredStatement;\n+import io.confluent.ksql.statement.Injector;\n+import io.confluent.ksql.util.ErrorMessageUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+import java.util.Optional;\n+\n+/**\n+ * An injector which injects the key and value formats into the supplied {@code statement}.\n+ *\n+ * <p>The key format is only injected if:\n+ * <ul>\n+ * <li>The statement is a CT/CS.</li>\n+ * <li>The statement does not specify the FORMAT property in its WITH clause.</li>\n+ * <li>The statement does not specify the KEY_FORMAT property in its WITH clause.</li>\n+ * </ul>\n+ *\n+ * <p>Similarly, the value format is only injected if the above conditions are met,\n+ * where the KEY_FORMAT property is replaced with the VALUE_FORMAT property accordingly.\n+ *\n+ * <p>If any of the above are not true then the {@code statement} is returned unchanged.\n+ *\n+ * <p>This injector also validates that the KEY_FORMAT property is only supplied if the\n+ * relevant feature flag is enabled.\n+ */\n+public class DefaultFormatInjector implements Injector {\n+\n+  public DefaultFormatInjector() {\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public <T extends Statement> ConfiguredStatement<T> inject(\n+      final ConfiguredStatement<T> statement\n+  ) {\n+    if (statement.getStatement() instanceof CreateSource) {\n+      final ConfiguredStatement<CreateSource> createStatement =\n+          (ConfiguredStatement<CreateSource>) statement;\n+\n+      if (createStatement.getStatement().getProperties().getKeyFormatName().isPresent()) {\n+        throwIfKeyFormatDisabled(createStatement);\n+      }\n+\n+      try {\n+        return (ConfiguredStatement<T>) forCreateStatement(createStatement).orElse(createStatement);\n+      } catch (final KsqlStatementException e) {\n+        throw e;\n+      } catch (final KsqlException e) {\n+        throw new KsqlStatementException(\n+            ErrorMessageUtil.buildErrorMessage(e),\n+            statement.getStatementText(),\n+            e.getCause());\n+      }\n+    }\n+\n+    if (statement.getStatement() instanceof CreateAsSelect) {\n+      final ConfiguredStatement<CreateAsSelect> createAsSelect =\n+          (ConfiguredStatement<CreateAsSelect>) statement;\n+\n+      if (createAsSelect.getStatement().getProperties().getKeyFormatInfo().isPresent()) {\n+        throwIfKeyFormatDisabled(createAsSelect);\n+      }\n+    }\n+\n+    return statement;\n+  }\n+\n+  private Optional<ConfiguredStatement<CreateSource>> forCreateStatement(\n+      final ConfiguredStatement<CreateSource> original\n+  ) {\n+\n+    final CreateSource statement = original.getStatement();\n+    final CreateSourceProperties properties = statement.getProperties();\n+\n+    final Optional<String> keyFormat = properties.getKeyFormatName();\n+    final Optional<String> valueFormat = properties.getValueFormatName();\n+\n+    final KsqlConfig config = getConfig(original);\n+    if (!config.getBoolean(KsqlConfig.KSQL_KEY_FORMAT_ENABLED)\n+        && !valueFormat.isPresent()) {\n+      throw new ParseFailedException(\"Failed to prepare statement: Missing required property \"\n+          + \"\\\"VALUE_FORMAT\\\" which has no default value.\");\n+    }", "originalCommit": "c7fa102fcd062f84cba757fdff27ca0c257153cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTEyOTkzNg==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r489129936", "bodyText": "As above.", "author": "vcrfxia", "createdAt": "2020-09-16T02:51:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwNTY3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwNjM1OA==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487906358", "bodyText": "nit: unnecessary brackets:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    && (config.getString(KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG) == null)) {\n          \n          \n            \n                    && config.getString(KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG) == null) {", "author": "big-andy-coates", "createdAt": "2020-09-14T13:20:50Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.format;\n+\n+import io.confluent.ksql.parser.KsqlParser.PreparedStatement;\n+import io.confluent.ksql.parser.SqlFormatter;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.confluent.ksql.parser.properties.with.CreateSourceProperties;\n+import io.confluent.ksql.parser.tree.CreateAsSelect;\n+import io.confluent.ksql.parser.tree.CreateSource;\n+import io.confluent.ksql.parser.tree.Statement;\n+import io.confluent.ksql.properties.with.CommonCreateConfigs;\n+import io.confluent.ksql.statement.ConfiguredStatement;\n+import io.confluent.ksql.statement.Injector;\n+import io.confluent.ksql.util.ErrorMessageUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+import java.util.Optional;\n+\n+/**\n+ * An injector which injects the key and value formats into the supplied {@code statement}.\n+ *\n+ * <p>The key format is only injected if:\n+ * <ul>\n+ * <li>The statement is a CT/CS.</li>\n+ * <li>The statement does not specify the FORMAT property in its WITH clause.</li>\n+ * <li>The statement does not specify the KEY_FORMAT property in its WITH clause.</li>\n+ * </ul>\n+ *\n+ * <p>Similarly, the value format is only injected if the above conditions are met,\n+ * where the KEY_FORMAT property is replaced with the VALUE_FORMAT property accordingly.\n+ *\n+ * <p>If any of the above are not true then the {@code statement} is returned unchanged.\n+ *\n+ * <p>This injector also validates that the KEY_FORMAT property is only supplied if the\n+ * relevant feature flag is enabled.\n+ */\n+public class DefaultFormatInjector implements Injector {\n+\n+  public DefaultFormatInjector() {\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public <T extends Statement> ConfiguredStatement<T> inject(\n+      final ConfiguredStatement<T> statement\n+  ) {\n+    if (statement.getStatement() instanceof CreateSource) {\n+      final ConfiguredStatement<CreateSource> createStatement =\n+          (ConfiguredStatement<CreateSource>) statement;\n+\n+      if (createStatement.getStatement().getProperties().getKeyFormatName().isPresent()) {\n+        throwIfKeyFormatDisabled(createStatement);\n+      }\n+\n+      try {\n+        return (ConfiguredStatement<T>) forCreateStatement(createStatement).orElse(createStatement);\n+      } catch (final KsqlStatementException e) {\n+        throw e;\n+      } catch (final KsqlException e) {\n+        throw new KsqlStatementException(\n+            ErrorMessageUtil.buildErrorMessage(e),\n+            statement.getStatementText(),\n+            e.getCause());\n+      }\n+    }\n+\n+    if (statement.getStatement() instanceof CreateAsSelect) {\n+      final ConfiguredStatement<CreateAsSelect> createAsSelect =\n+          (ConfiguredStatement<CreateAsSelect>) statement;\n+\n+      if (createAsSelect.getStatement().getProperties().getKeyFormatInfo().isPresent()) {\n+        throwIfKeyFormatDisabled(createAsSelect);\n+      }\n+    }\n+\n+    return statement;\n+  }\n+\n+  private Optional<ConfiguredStatement<CreateSource>> forCreateStatement(\n+      final ConfiguredStatement<CreateSource> original\n+  ) {\n+\n+    final CreateSource statement = original.getStatement();\n+    final CreateSourceProperties properties = statement.getProperties();\n+\n+    final Optional<String> keyFormat = properties.getKeyFormatName();\n+    final Optional<String> valueFormat = properties.getValueFormatName();\n+\n+    final KsqlConfig config = getConfig(original);\n+    if (!config.getBoolean(KsqlConfig.KSQL_KEY_FORMAT_ENABLED)\n+        && !valueFormat.isPresent()) {\n+      throw new ParseFailedException(\"Failed to prepare statement: Missing required property \"\n+          + \"\\\"VALUE_FORMAT\\\" which has no default value.\");\n+    }\n+\n+    if (keyFormat.isPresent() && valueFormat.isPresent()) {\n+      return Optional.empty();\n+    }\n+\n+    validateConfig(config, keyFormat, valueFormat);\n+\n+    final CreateSourceProperties injectedProps = properties.withFormats(\n+        keyFormat.orElse(config.getString(KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG)),\n+        valueFormat.orElse(config.getString(KsqlConfig.KSQL_DEFAULT_VALUE_FORMAT_CONFIG))\n+    );\n+    final CreateSource withFormats = statement.copyWith(\n+        original.getStatement().getElements(),\n+        injectedProps\n+    );\n+\n+    final PreparedStatement<CreateSource> prepared = buildPreparedStatement(withFormats);\n+    final ConfiguredStatement<CreateSource> configured = ConfiguredStatement\n+        .of(prepared, original.getConfigOverrides(), original.getConfig());\n+\n+    return Optional.of(configured);\n+  }\n+\n+  private static void validateConfig(\n+      final KsqlConfig config,\n+      final Optional<String> keyFormat,\n+      final Optional<String> valueFormat\n+  ) {\n+    if (!keyFormat.isPresent()\n+        && (config.getString(KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG) == null)) {", "originalCommit": "c7fa102fcd062f84cba757fdff27ca0c257153cb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwNzA1OQ==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487907059", "bodyText": "You don't need T, so this can just become:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private static <T extends Statement> KsqlConfig getConfig(\n          \n          \n            \n                  final ConfiguredStatement<T> statement\n          \n          \n            \n              ) {\n          \n          \n            \n                return statement.getConfig().cloneWithPropertyOverwrite(statement.getConfigOverrides());\n          \n          \n            \n              }\n          \n          \n            \n              private static KsqlConfig getConfig(final ConfiguredStatement<?> statement) {\n          \n          \n            \n                return statement.getConfig().cloneWithPropertyOverwrite(statement.getConfigOverrides());\n          \n          \n            \n              }", "author": "big-andy-coates", "createdAt": "2020-09-14T13:21:50Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.format;\n+\n+import io.confluent.ksql.parser.KsqlParser.PreparedStatement;\n+import io.confluent.ksql.parser.SqlFormatter;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.confluent.ksql.parser.properties.with.CreateSourceProperties;\n+import io.confluent.ksql.parser.tree.CreateAsSelect;\n+import io.confluent.ksql.parser.tree.CreateSource;\n+import io.confluent.ksql.parser.tree.Statement;\n+import io.confluent.ksql.properties.with.CommonCreateConfigs;\n+import io.confluent.ksql.statement.ConfiguredStatement;\n+import io.confluent.ksql.statement.Injector;\n+import io.confluent.ksql.util.ErrorMessageUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+import java.util.Optional;\n+\n+/**\n+ * An injector which injects the key and value formats into the supplied {@code statement}.\n+ *\n+ * <p>The key format is only injected if:\n+ * <ul>\n+ * <li>The statement is a CT/CS.</li>\n+ * <li>The statement does not specify the FORMAT property in its WITH clause.</li>\n+ * <li>The statement does not specify the KEY_FORMAT property in its WITH clause.</li>\n+ * </ul>\n+ *\n+ * <p>Similarly, the value format is only injected if the above conditions are met,\n+ * where the KEY_FORMAT property is replaced with the VALUE_FORMAT property accordingly.\n+ *\n+ * <p>If any of the above are not true then the {@code statement} is returned unchanged.\n+ *\n+ * <p>This injector also validates that the KEY_FORMAT property is only supplied if the\n+ * relevant feature flag is enabled.\n+ */\n+public class DefaultFormatInjector implements Injector {\n+\n+  public DefaultFormatInjector() {\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public <T extends Statement> ConfiguredStatement<T> inject(\n+      final ConfiguredStatement<T> statement\n+  ) {\n+    if (statement.getStatement() instanceof CreateSource) {\n+      final ConfiguredStatement<CreateSource> createStatement =\n+          (ConfiguredStatement<CreateSource>) statement;\n+\n+      if (createStatement.getStatement().getProperties().getKeyFormatName().isPresent()) {\n+        throwIfKeyFormatDisabled(createStatement);\n+      }\n+\n+      try {\n+        return (ConfiguredStatement<T>) forCreateStatement(createStatement).orElse(createStatement);\n+      } catch (final KsqlStatementException e) {\n+        throw e;\n+      } catch (final KsqlException e) {\n+        throw new KsqlStatementException(\n+            ErrorMessageUtil.buildErrorMessage(e),\n+            statement.getStatementText(),\n+            e.getCause());\n+      }\n+    }\n+\n+    if (statement.getStatement() instanceof CreateAsSelect) {\n+      final ConfiguredStatement<CreateAsSelect> createAsSelect =\n+          (ConfiguredStatement<CreateAsSelect>) statement;\n+\n+      if (createAsSelect.getStatement().getProperties().getKeyFormatInfo().isPresent()) {\n+        throwIfKeyFormatDisabled(createAsSelect);\n+      }\n+    }\n+\n+    return statement;\n+  }\n+\n+  private Optional<ConfiguredStatement<CreateSource>> forCreateStatement(\n+      final ConfiguredStatement<CreateSource> original\n+  ) {\n+\n+    final CreateSource statement = original.getStatement();\n+    final CreateSourceProperties properties = statement.getProperties();\n+\n+    final Optional<String> keyFormat = properties.getKeyFormatName();\n+    final Optional<String> valueFormat = properties.getValueFormatName();\n+\n+    final KsqlConfig config = getConfig(original);\n+    if (!config.getBoolean(KsqlConfig.KSQL_KEY_FORMAT_ENABLED)\n+        && !valueFormat.isPresent()) {\n+      throw new ParseFailedException(\"Failed to prepare statement: Missing required property \"\n+          + \"\\\"VALUE_FORMAT\\\" which has no default value.\");\n+    }\n+\n+    if (keyFormat.isPresent() && valueFormat.isPresent()) {\n+      return Optional.empty();\n+    }\n+\n+    validateConfig(config, keyFormat, valueFormat);\n+\n+    final CreateSourceProperties injectedProps = properties.withFormats(\n+        keyFormat.orElse(config.getString(KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG)),\n+        valueFormat.orElse(config.getString(KsqlConfig.KSQL_DEFAULT_VALUE_FORMAT_CONFIG))\n+    );\n+    final CreateSource withFormats = statement.copyWith(\n+        original.getStatement().getElements(),\n+        injectedProps\n+    );\n+\n+    final PreparedStatement<CreateSource> prepared = buildPreparedStatement(withFormats);\n+    final ConfiguredStatement<CreateSource> configured = ConfiguredStatement\n+        .of(prepared, original.getConfigOverrides(), original.getConfig());\n+\n+    return Optional.of(configured);\n+  }\n+\n+  private static void validateConfig(\n+      final KsqlConfig config,\n+      final Optional<String> keyFormat,\n+      final Optional<String> valueFormat\n+  ) {\n+    if (!keyFormat.isPresent()\n+        && (config.getString(KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG) == null)) {\n+      throw new KsqlException(\"Statement is missing the '\"\n+          + CommonCreateConfigs.KEY_FORMAT_PROPERTY + \"' property from the WITH clause. \"\n+          + \"Either provide one or set a default via the '\"\n+          + KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG + \"' config.\");\n+    }\n+    if (!valueFormat.isPresent()\n+        && (config.getString(KsqlConfig.KSQL_DEFAULT_VALUE_FORMAT_CONFIG) == null)) {\n+      throw new KsqlException(\"Statement is missing the '\"\n+          + CommonCreateConfigs.VALUE_FORMAT_PROPERTY + \"' property from the WITH clause. \"\n+          + \"Either provide one or set a default via the '\"\n+          + KsqlConfig.KSQL_DEFAULT_VALUE_FORMAT_CONFIG + \"' config.\");\n+    }\n+  }\n+\n+  private static <T extends Statement> KsqlConfig getConfig(\n+      final ConfiguredStatement<T> statement\n+  ) {\n+    return statement.getConfig().cloneWithPropertyOverwrite(statement.getConfigOverrides());\n+  }", "originalCommit": "c7fa102fcd062f84cba757fdff27ca0c257153cb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkwNzM0OQ==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487907349", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private static <T extends Statement> void throwIfKeyFormatDisabled(\n          \n          \n            \n                  final ConfiguredStatement<T> statement\n          \n          \n            \n              private static void throwIfKeyFormatDisabled(final ConfiguredStatement<?> statement", "author": "big-andy-coates", "createdAt": "2020-09-14T13:22:14Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.format;\n+\n+import io.confluent.ksql.parser.KsqlParser.PreparedStatement;\n+import io.confluent.ksql.parser.SqlFormatter;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.confluent.ksql.parser.properties.with.CreateSourceProperties;\n+import io.confluent.ksql.parser.tree.CreateAsSelect;\n+import io.confluent.ksql.parser.tree.CreateSource;\n+import io.confluent.ksql.parser.tree.Statement;\n+import io.confluent.ksql.properties.with.CommonCreateConfigs;\n+import io.confluent.ksql.statement.ConfiguredStatement;\n+import io.confluent.ksql.statement.Injector;\n+import io.confluent.ksql.util.ErrorMessageUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+import java.util.Optional;\n+\n+/**\n+ * An injector which injects the key and value formats into the supplied {@code statement}.\n+ *\n+ * <p>The key format is only injected if:\n+ * <ul>\n+ * <li>The statement is a CT/CS.</li>\n+ * <li>The statement does not specify the FORMAT property in its WITH clause.</li>\n+ * <li>The statement does not specify the KEY_FORMAT property in its WITH clause.</li>\n+ * </ul>\n+ *\n+ * <p>Similarly, the value format is only injected if the above conditions are met,\n+ * where the KEY_FORMAT property is replaced with the VALUE_FORMAT property accordingly.\n+ *\n+ * <p>If any of the above are not true then the {@code statement} is returned unchanged.\n+ *\n+ * <p>This injector also validates that the KEY_FORMAT property is only supplied if the\n+ * relevant feature flag is enabled.\n+ */\n+public class DefaultFormatInjector implements Injector {\n+\n+  public DefaultFormatInjector() {\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public <T extends Statement> ConfiguredStatement<T> inject(\n+      final ConfiguredStatement<T> statement\n+  ) {\n+    if (statement.getStatement() instanceof CreateSource) {\n+      final ConfiguredStatement<CreateSource> createStatement =\n+          (ConfiguredStatement<CreateSource>) statement;\n+\n+      if (createStatement.getStatement().getProperties().getKeyFormatName().isPresent()) {\n+        throwIfKeyFormatDisabled(createStatement);\n+      }\n+\n+      try {\n+        return (ConfiguredStatement<T>) forCreateStatement(createStatement).orElse(createStatement);\n+      } catch (final KsqlStatementException e) {\n+        throw e;\n+      } catch (final KsqlException e) {\n+        throw new KsqlStatementException(\n+            ErrorMessageUtil.buildErrorMessage(e),\n+            statement.getStatementText(),\n+            e.getCause());\n+      }\n+    }\n+\n+    if (statement.getStatement() instanceof CreateAsSelect) {\n+      final ConfiguredStatement<CreateAsSelect> createAsSelect =\n+          (ConfiguredStatement<CreateAsSelect>) statement;\n+\n+      if (createAsSelect.getStatement().getProperties().getKeyFormatInfo().isPresent()) {\n+        throwIfKeyFormatDisabled(createAsSelect);\n+      }\n+    }\n+\n+    return statement;\n+  }\n+\n+  private Optional<ConfiguredStatement<CreateSource>> forCreateStatement(\n+      final ConfiguredStatement<CreateSource> original\n+  ) {\n+\n+    final CreateSource statement = original.getStatement();\n+    final CreateSourceProperties properties = statement.getProperties();\n+\n+    final Optional<String> keyFormat = properties.getKeyFormatName();\n+    final Optional<String> valueFormat = properties.getValueFormatName();\n+\n+    final KsqlConfig config = getConfig(original);\n+    if (!config.getBoolean(KsqlConfig.KSQL_KEY_FORMAT_ENABLED)\n+        && !valueFormat.isPresent()) {\n+      throw new ParseFailedException(\"Failed to prepare statement: Missing required property \"\n+          + \"\\\"VALUE_FORMAT\\\" which has no default value.\");\n+    }\n+\n+    if (keyFormat.isPresent() && valueFormat.isPresent()) {\n+      return Optional.empty();\n+    }\n+\n+    validateConfig(config, keyFormat, valueFormat);\n+\n+    final CreateSourceProperties injectedProps = properties.withFormats(\n+        keyFormat.orElse(config.getString(KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG)),\n+        valueFormat.orElse(config.getString(KsqlConfig.KSQL_DEFAULT_VALUE_FORMAT_CONFIG))\n+    );\n+    final CreateSource withFormats = statement.copyWith(\n+        original.getStatement().getElements(),\n+        injectedProps\n+    );\n+\n+    final PreparedStatement<CreateSource> prepared = buildPreparedStatement(withFormats);\n+    final ConfiguredStatement<CreateSource> configured = ConfiguredStatement\n+        .of(prepared, original.getConfigOverrides(), original.getConfig());\n+\n+    return Optional.of(configured);\n+  }\n+\n+  private static void validateConfig(\n+      final KsqlConfig config,\n+      final Optional<String> keyFormat,\n+      final Optional<String> valueFormat\n+  ) {\n+    if (!keyFormat.isPresent()\n+        && (config.getString(KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG) == null)) {\n+      throw new KsqlException(\"Statement is missing the '\"\n+          + CommonCreateConfigs.KEY_FORMAT_PROPERTY + \"' property from the WITH clause. \"\n+          + \"Either provide one or set a default via the '\"\n+          + KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG + \"' config.\");\n+    }\n+    if (!valueFormat.isPresent()\n+        && (config.getString(KsqlConfig.KSQL_DEFAULT_VALUE_FORMAT_CONFIG) == null)) {\n+      throw new KsqlException(\"Statement is missing the '\"\n+          + CommonCreateConfigs.VALUE_FORMAT_PROPERTY + \"' property from the WITH clause. \"\n+          + \"Either provide one or set a default via the '\"\n+          + KsqlConfig.KSQL_DEFAULT_VALUE_FORMAT_CONFIG + \"' config.\");\n+    }\n+  }\n+\n+  private static <T extends Statement> KsqlConfig getConfig(\n+      final ConfiguredStatement<T> statement\n+  ) {\n+    return statement.getConfig().cloneWithPropertyOverwrite(statement.getConfigOverrides());\n+  }\n+\n+  private static <T extends Statement> void throwIfKeyFormatDisabled(\n+      final ConfiguredStatement<T> statement", "originalCommit": "c7fa102fcd062f84cba757fdff27ca0c257153cb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkyNDIwMw==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487924203", "bodyText": "I actually think having the getValueFormat is too tightly coupling this properties class to FormatFactory.  It would be better if these weren't coupled IMHO.\nI'm happy for you to leave this for another day. But if you have the time, rather than adding a new getKeyFormat method, maybe you could just remove the getValueFormat method and move the FormatFactory call inline.  Then rename getValueFormatInfo to just getValueFormat.\nAlso, getValueFormatProperties shouldn't be public.  It's just API bloat. Better callers just call getValueFormat().getProperties().", "author": "big-andy-coates", "createdAt": "2020-09-14T13:40:27Z", "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/properties/with/CreateSourceAsProperties.java", "diffHunk": "@@ -69,8 +69,12 @@ private CreateSourceAsProperties(final Map<String, Literal> originals) {\n     props.validateDateTimeFormat(CommonCreateConfigs.TIMESTAMP_FORMAT_PROPERTY);\n   }\n \n+  public Optional<Format> getKeyFormat() {\n+    return getKeyFormatInfo().map(FormatFactory::of);\n+  }", "originalCommit": "c7fa102fcd062f84cba757fdff27ca0c257153cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTkyOTg2MQ==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r489929861", "bodyText": "I'm happy for you to leave this for another day. But if you have the time, rather than adding a new getKeyFormat method, maybe you could just remove the getValueFormat method and move the FormatFactory call inline. Then rename getValueFormatInfo to just getValueFormat.\n\nDone.\n\nAlso, getValueFormatProperties shouldn't be public. It's just API bloat. Better callers just call getValueFormat().getProperties().\n\ngetValueFormat() returns an Optional which may be empty, whereas there are uses of getValueFormatProperties() even if getValueFormat() is empty, for example: \n  \n    \n      ksql/ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/Analyzer.java\n    \n    \n        Lines 177 to 179\n      in\n      0f04061\n    \n    \n    \n    \n\n        \n          \n           // overwrite any inheritable properties if they were explicitly \n        \n\n        \n          \n           // specified in the statement \n        \n\n        \n          \n           sourceProperties.putAll(sink.getProperties().getFormatProperties());", "author": "vcrfxia", "createdAt": "2020-09-17T03:27:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkyNDIwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjAyNjY3MQ==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492026671", "bodyText": "Agree that getValueFormatProperties should be public.  We'll have to ensure you can, for example, set the delimiter char even when the value/key format is not declared, but coming from system properties.  I wouldn't be surprised if there are already bugs in this area.", "author": "big-andy-coates", "createdAt": "2020-09-21T13:01:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkyNDIwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkyNjUyNA==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487926524", "bodyText": "As for the other properties class - can we inline these please and rename getKeyFormatInfo -> getKeyFormat etc?", "author": "big-andy-coates", "createdAt": "2020-09-14T13:42:41Z", "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/properties/with/CreateSourceProperties.java", "diffHunk": "@@ -74,12 +75,29 @@ public static CreateSourceProperties from(final Map<String, Literal> literals) {\n     this.props = new PropertiesConfig(CreateConfigs.CONFIG_METADATA, originals);\n     this.durationParser = Objects.requireNonNull(durationParser, \"durationParser\");\n \n+    props.validateKeyValueFormats(\n+        CommonCreateConfigs.KEY_FORMAT_PROPERTY,\n+        CommonCreateConfigs.VALUE_FORMAT_PROPERTY,\n+        CommonCreateConfigs.FORMAT_PROPERTY\n+    );\n     props.validateDateTimeFormat(CommonCreateConfigs.TIMESTAMP_FORMAT_PROPERTY);\n     validateWindowInfo();\n   }\n \n+  /**\n+   * This method should only be called after the DefaultFormatInjector has run, in order to\n+   * guarantee a key format is present.\n+   */\n+  public Format getKeyFormat() {\n+    return FormatFactory.of(getKeyFormatInfo());\n+  }", "originalCommit": "c7fa102fcd062f84cba757fdff27ca0c257153cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTkzMDE4Ng==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r489930186", "bodyText": "Done.", "author": "vcrfxia", "createdAt": "2020-09-17T03:28:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkyNjUyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkyNzIwNg==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487927206", "bodyText": "These feel like API bloat to me. Calls can just call getKeyFormat().getName() or similar.", "author": "big-andy-coates", "createdAt": "2020-09-14T13:43:19Z", "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/properties/with/CreateSourceProperties.java", "diffHunk": "@@ -131,13 +149,51 @@ public String getKafkaTopic() {\n     return Optional.ofNullable(props.getInt(CreateConfigs.SCHEMA_ID));\n   }\n \n-  public FormatInfo getFormatInfo() {\n-    return FormatInfo.of(\n-        props.getString(CommonCreateConfigs.VALUE_FORMAT_PROPERTY),\n-        getFormatProperties());\n+  /**\n+   * This method should only be called after the DefaultFormatInjector has run, in order to\n+   * guarantee a key format is present.\n+   */\n+  public FormatInfo getKeyFormatInfo() {\n+    final String keyFormat = getKeyFormatName().orElseThrow(\n+        () -> new IllegalStateException(\"Key format not present\")\n+    );\n+    return FormatInfo.of(keyFormat, ImmutableMap.of());\n+  }\n+\n+  /**\n+   * This method should only be called after the DefaultFormatInjector has run, in order to\n+   * guarantee a value format is present.\n+   */\n+  public FormatInfo getValueFormatInfo() {\n+    final String valueFormat = getValueFormatName().orElseThrow(\n+        () -> new IllegalStateException(\"Value format not present\")\n+    );\n+    return FormatInfo.of(valueFormat, getValueFormatProperties());\n   }\n \n-  private Map<String, String> getFormatProperties() {\n+  /**\n+   * This method may be called before the DefaultFormatInjector has run, in which case a\n+   * key format may not be present.\n+   */\n+  public Optional<String> getKeyFormatName() {\n+    final String keyFormat = props.getString(CommonCreateConfigs.FORMAT_PROPERTY) != null\n+        ? props.getString(CommonCreateConfigs.FORMAT_PROPERTY)\n+        : props.getString(CommonCreateConfigs.KEY_FORMAT_PROPERTY);\n+    return Optional.ofNullable(keyFormat);\n+  }\n+\n+  /**\n+   * This method may be called before the DefaultFormatInjector has run, in which case a\n+   * value format may not be present.\n+   */\n+  public Optional<String> getValueFormatName() {\n+    final String valueFormat = props.getString(CommonCreateConfigs.FORMAT_PROPERTY) != null\n+        ? props.getString(CommonCreateConfigs.FORMAT_PROPERTY)\n+        : props.getString(CommonCreateConfigs.VALUE_FORMAT_PROPERTY);\n+    return Optional.ofNullable(valueFormat);\n+  }", "originalCommit": "c7fa102fcd062f84cba757fdff27ca0c257153cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTkzNTIzMw==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r489935233", "bodyText": "This didn't work previously when one of the methods returned an Optional while the other didn't, but it's now possible and I've removed this method accordingly.", "author": "vcrfxia", "createdAt": "2020-09-17T03:37:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkyNzIwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkzMTUwMw==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487931503", "bodyText": "I wouldn't worry about having this on the interface. In time, all key formats will be supported.  It's ok to just hard code the check in one place, rejecting any key formats we don't support yet.  Then once we're done, all will be supported and that bit of code can be removed.", "author": "big-andy-coates", "createdAt": "2020-09-14T13:47:33Z", "path": "ksqldb-serde/src/main/java/io/confluent/ksql/serde/Format.java", "diffHunk": "@@ -165,4 +165,14 @@ default void validateProperties(Map<String, String> properties) {\n    * @return a {@code KsqlSerdeFactory} that generates serdes for the given format\n    */\n   KsqlSerdeFactory getSerdeFactory(FormatInfo info);\n+\n+  /**\n+   * All formats are supported as value formats. Until the primitive key work is complete,\n+   * not all formats are supported as key formats. Once complete, this method may be removed.\n+   *\n+   * @return whether or not this format is supported for keys\n+   */\n+  default boolean isSupportedKeyFormat() {\n+    return false;\n+  }", "originalCommit": "c7fa102fcd062f84cba757fdff27ca0c257153cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjAzNDAyMg==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492034022", "bodyText": "As above, remove this from the interface.  A format shouldn't know if its supported by the engine as a value or key format, it should know about itself.  It's the engine that knows what it does and does not support as a key format.  (Think about this interface soon being a 'user defined format' interface... we wouldn't expect implementers to say if its supported as a key format or not.)", "author": "big-andy-coates", "createdAt": "2020-09-21T13:13:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkzMTUwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA2MjI1OA==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492062258", "bodyText": "Just replace it with a Util class method.", "author": "big-andy-coates", "createdAt": "2020-09-21T13:52:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkzMTUwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5Nzc3Mg==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492297772", "bodyText": "Makes sense -- done.", "author": "vcrfxia", "createdAt": "2020-09-21T19:31:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkzMTUwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkzMzExNQ==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r487933115", "bodyText": "Hummm.... lot of changes in this class, but no test changes to match!  If it possible to extend some of the YATT tests themselves to set the feature flag and defaults configs and/or set KEY_FORMAT?", "author": "big-andy-coates", "createdAt": "2020-09-14T13:49:07Z", "path": "ksqldb-functional-tests/src/main/java/io/confluent/ksql/test/driver/AssertExecutor.java", "diffHunk": "@@ -60,41 +61,50 @@\n   static final List<SourceProperty> MUST_MATCH = ImmutableList.<SourceProperty>builder()\n       .add(new SourceProperty(\n           DataSource::getSchema,\n-          cs -> cs.getElements().toLogicalSchema(),\n+          (cs, cfg) -> cs.getElements().toLogicalSchema(),", "originalCommit": "c7fa102fcd062f84cba757fdff27ca0c257153cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTkzMzYwMw==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r489933603", "bodyText": "Added tests to ensure that YATT is properly verifying KEY_FORMAT of sources, and that FORMAT behaves as expected too. Didn't add tests to check that default format values are picked up from the config since there are already QTT tests for that, and I don't see the value of duplication here.", "author": "vcrfxia", "createdAt": "2020-09-17T03:34:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkzMzExNQ=="}], "type": "inlineReview"}, {"oid": "85ea098d1f6ac63e41238470c8508370285a2f77", "url": "https://github.com/confluentinc/ksql/commit/85ea098d1f6ac63e41238470c8508370285a2f77", "message": "Merge branch 'master' into key-format", "committedDate": "2020-09-15T21:53:50Z", "type": "commit"}, {"oid": "9614f7baca9c228120e4b4de239c6733cda8955d", "url": "https://github.com/confluentinc/ksql/commit/9614f7baca9c228120e4b4de239c6733cda8955d", "message": "chore: move supported key format validation into engine", "committedDate": "2020-09-16T01:34:40Z", "type": "commit"}, {"oid": "7ffb7d294743e7c94848eba80f19a2e661dc4577", "url": "https://github.com/confluentinc/ksql/commit/7ffb7d294743e7c94848eba80f19a2e661dc4577", "message": "chore: clean up use of feature flag in injector", "committedDate": "2020-09-16T01:55:56Z", "type": "commit"}, {"oid": "9fc1ae7dd034eb1777e70446b13603017b9cdbc0", "url": "https://github.com/confluentinc/ksql/commit/9fc1ae7dd034eb1777e70446b13603017b9cdbc0", "message": "chore: feedback", "committedDate": "2020-09-16T02:45:58Z", "type": "commit"}, {"oid": "9e963da8ce78801f76e45f0fafe8cf663bc28e4f", "url": "https://github.com/confluentinc/ksql/commit/9e963da8ce78801f76e45f0fafe8cf663bc28e4f", "message": "test: fix test", "committedDate": "2020-09-16T18:29:45Z", "type": "commit"}, {"oid": "7428c71c734b450589947e7052a73b3bd17ff173", "url": "https://github.com/confluentinc/ksql/commit/7428c71c734b450589947e7052a73b3bd17ff173", "message": "chore: inline getKeyFormat and getValueFormat", "committedDate": "2020-09-16T18:40:05Z", "type": "commit"}, {"oid": "aeb706ba3f5fb2117cd94af0f65260d840d51800", "url": "https://github.com/confluentinc/ksql/commit/aeb706ba3f5fb2117cd94af0f65260d840d51800", "message": "chore: rename getXXXFormatInfo to getXXXFormat", "committedDate": "2020-09-16T18:41:05Z", "type": "commit"}, {"oid": "915fe50c4a72b75ff761ebfb2a33e3238c77edb1", "url": "https://github.com/confluentinc/ksql/commit/915fe50c4a72b75ff761ebfb2a33e3238c77edb1", "message": "chore: getXXXFormat in CS props now return optional", "committedDate": "2020-09-16T18:56:36Z", "type": "commit"}, {"oid": "048fa84e68b5024c62fa7b740410cb95ebbc032e", "url": "https://github.com/confluentinc/ksql/commit/048fa84e68b5024c62fa7b740410cb95ebbc032e", "message": "chore: remove getXXXFormatName", "committedDate": "2020-09-16T19:04:47Z", "type": "commit"}, {"oid": "7ffc8e08f5f54c3fd6b14de335507ac15d0019b9", "url": "https://github.com/confluentinc/ksql/commit/7ffc8e08f5f54c3fd6b14de335507ac15d0019b9", "message": "chore: fix PlannedTestsUpToDateTest by removing statement text from comparison", "committedDate": "2020-09-17T03:35:10Z", "type": "commit"}, {"oid": "8863eb45fcd26e30164384bf4f27d0eb0dd1f7a1", "url": "https://github.com/confluentinc/ksql/commit/8863eb45fcd26e30164384bf4f27d0eb0dd1f7a1", "message": "chore: update error message", "committedDate": "2020-09-17T03:35:10Z", "type": "commit"}, {"oid": "ee96cd76dc6046c4c5e7fc79ce1987fc4e08e315", "url": "https://github.com/confluentinc/ksql/commit/ee96cd76dc6046c4c5e7fc79ce1987fc4e08e315", "message": "test: add YATT tests", "committedDate": "2020-09-17T03:35:10Z", "type": "commit"}, {"oid": "d580e4fd38d12fbbbd62b25365701b8c1ed83721", "url": "https://github.com/confluentinc/ksql/commit/d580e4fd38d12fbbbd62b25365701b8c1ed83721", "message": "chore: refactor injector", "committedDate": "2020-09-17T20:42:02Z", "type": "commit"}, {"oid": "d374c6bcd6493fceac0a32354efb0ab85bb4edd9", "url": "https://github.com/confluentinc/ksql/commit/d374c6bcd6493fceac0a32354efb0ab85bb4edd9", "message": "chore: test injector cleanup", "committedDate": "2020-09-17T20:50:07Z", "type": "commit"}, {"oid": "f5d9b5bbc3ed8748cb559b3ce090d5ab23223d83", "url": "https://github.com/confluentinc/ksql/commit/f5d9b5bbc3ed8748cb559b3ce090d5ab23223d83", "message": "test: fix tests", "committedDate": "2020-09-18T02:37:55Z", "type": "commit"}, {"oid": "20d64a782e94d628e6a4bf4025f5f012bf3a4d77", "url": "https://github.com/confluentinc/ksql/commit/20d64a782e94d628e6a4bf4025f5f012bf3a4d77", "message": "fix: fix execution of pre-plan statements", "committedDate": "2020-09-18T02:37:55Z", "type": "commit"}, {"oid": "efae981d3defa43ee390e65bd43e9685377dfc54", "url": "https://github.com/confluentinc/ksql/commit/efae981d3defa43ee390e65bd43e9685377dfc54", "message": "chore: checkstyle", "committedDate": "2020-09-18T02:50:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDY3MTk4OA==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r490671988", "bodyText": "Yuck :[\nThis is needed because statements read from the command topic aren't passed through injectors, yet the engine expects key formats to be present which is not the case for pre-execution-plan statements.\nRather than using the injector here, we could create the KsqlConfig and fill in the default, or we could hard-code the Kafka format, all of which are effectively equivalent.\nIs this sufficient reason to not use an injector in order to populate the default from the config? I don't think so but this is really gross.", "author": "vcrfxia", "createdAt": "2020-09-18T02:58:36Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/computation/InteractiveStatementExecutor.java", "diffHunk": "@@ -310,8 +311,9 @@ private String executeDdlStatement(final PreparedStatement<?> statement, final C\n     final KsqlConfig mergedConfig = buildMergedConfig(command);\n     final ConfiguredStatement<?> configured =\n         ConfiguredStatement.of(statement, command.getOverwriteProperties(), mergedConfig);\n+    final ConfiguredStatement<?> injected = new DefaultFormatInjector().inject(configured);", "originalCommit": "efae981d3defa43ee390e65bd43e9685377dfc54", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDg0Nzg5OA==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r490847898", "bodyText": "I'm confused.... while the SQL text in the plan in the command topic might not have the key format set, historical plans will have the key format set in both any ddlCommand and any queryPlan. As the idea is that the SQL text in the plan is just to display back to the user, and it's ok for the SQL we should back to not include the change, I don't think we need this injector here.\nSnippet of example serializer plan, show ddl and dml key formats of KAFKA:\n{\n    \"@type\" : \"ksqlPlanV1\",\n    \"statementText\" : \"CREATE STREAM OUTPUT AS SELECT\\n  INPUT.ID ID,\\n  ARRAY_MAX(INPUT.BOOL_ARRAY) BOOL_MAX,\\n  ARRAY_MAX(INPUT.INT_ARRAY) INT_MAX,\\n  ARRAY_MAX(INPUT.BIGINT_ARRAY) BIGINT_MAX,\\n  ARRAY_MAX(INPUT.DOUBLE_ARRAY) DOUBLE_MAX,\\n  ARRAY_MAX(INPUT.STRING_ARRAY) STRING_MAX,\\n  ARRAY_MAX(INPUT.DECIMAL_ARRAY) DECIMAL_MAX\\nFROM INPUT INPUT\\nEMIT CHANGES\",\n    \"ddlCommand\" : {\n      \"@type\" : \"createStreamV1\",\n      \"sourceName\" : \"OUTPUT\",\n      \"schema\" : \"`ID` STRING KEY, `BOOL_MAX` BOOLEAN, `INT_MAX` INTEGER, `BIGINT_MAX` BIGINT, `DOUBLE_MAX` DOUBLE, `STRING_MAX` STRING, `DECIMAL_MAX` DECIMAL(2, 1)\",\n      \"topicName\" : \"OUTPUT\",\n      \"formats\" : {\n        \"keyFormat\" : {\n          \"format\" : \"KAFKA\"\n        },\n        \"valueFormat\" : {\n          \"format\" : \"JSON\"\n        }\n      }\n    },\n    \"queryPlan\" : {\n      \"sources\" : [ \"INPUT\" ],\n      \"sink\" : \"OUTPUT\",\n      \"physicalPlan\" : {\n        \"@type\" : \"streamSinkV1\",\n        \"properties\" : {\n          \"queryContext\" : \"OUTPUT\"\n        },\n        \"source\" : {\n          \"@type\" : \"streamSelectV1\",\n          \"properties\" : {\n            \"queryContext\" : \"Project\"\n          },\n          \"source\" : {\n            \"@type\" : \"streamSourceV1\",\n            \"properties\" : {\n              \"queryContext\" : \"KsqlTopic/Source\"\n            },\n            \"topicName\" : \"test_topic\",\n            \"formats\" : {\n              \"keyFormat\" : {\n                \"format\" : \"KAFKA\"\n              },\n              \"valueFormat\" : {\n                \"format\" : \"JSON\"\n              }\n            },\n            \"sourceSchema\" : \"`ID` STRING KEY, `BOOL_ARRAY` ARRAY<BOOLEAN>, `INT_ARRAY` ARRAY<INTEGER>, `BIGINT_ARRAY` ARRAY<BIGINT>, `DOUBLE_ARRAY` ARRAY<DOUBLE>, `STRING_ARRAY` ARRAY<STRING>, `DECIMAL_ARRAY` ARRAY<DECIMAL(2, 1)>\"\n          },\n          \"keyColumnNames\" : [ \"ID\" ],\n          \"selectExpressions\" : [ \"ARRAY_MAX(BOOL_ARRAY) AS BOOL_MAX\", \"ARRAY_MAX(INT_ARRAY) AS INT_MAX\", \"ARRAY_MAX(BIGINT_ARRAY) AS BIGINT_MAX\", \"ARRAY_MAX(DOUBLE_ARRAY) AS DOUBLE_MAX\", \"ARRAY_MAX(STRING_ARRAY) AS STRING_MAX\", \"ARRAY_MAX(DECIMAL_ARRAY) AS DECIMAL_MAX\" ]\n        },\n        \"formats\" : {\n          \"keyFormat\" : {\n            \"format\" : \"KAFKA\"\n          },\n          \"valueFormat\" : {\n            \"format\" : \"JSON\"\n          }\n        },\n        \"topicName\" : \"OUTPUT\"\n      },\n      \"queryId\" : \"CSAS_OUTPUT_0\"\n    }\n  }\n}", "author": "big-andy-coates", "createdAt": "2020-09-18T10:17:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDY3MTk4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk4MTUxOA==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r490981518", "bodyText": "This code path is only hit for statements read from the command topic that do not contain query plans (i.e., those that were written to the command topic before query plans were introduced). These statements also do not contain KEY_FORMAT in their statement text, also by virtue of being old.", "author": "vcrfxia", "createdAt": "2020-09-18T14:18:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDY3MTk4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTczMjUwNA==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r491732504", "bodyText": "Removed this code path in #6257, so this is no longer a concern.", "author": "vcrfxia", "createdAt": "2020-09-20T20:45:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDY3MTk4OA=="}], "type": "inlineReview"}, {"oid": "596a9723ff909250b169db50666a473da1fd1436", "url": "https://github.com/confluentinc/ksql/commit/596a9723ff909250b169db50666a473da1fd1436", "message": "Merge branch 'master' into key-format", "committedDate": "2020-09-18T03:12:59Z", "type": "commit"}, {"oid": "f24796946c7f7cfd88b1a503d1822b42ba8e67bf", "url": "https://github.com/confluentinc/ksql/commit/f24796946c7f7cfd88b1a503d1822b42ba8e67bf", "message": "test: more test fixes", "committedDate": "2020-09-18T03:57:20Z", "type": "commit"}, {"oid": "aa32869968114bf36934e1a41224c4751fbe7def", "url": "https://github.com/confluentinc/ksql/commit/aa32869968114bf36934e1a41224c4751fbe7def", "message": "Merge branch 'master' into key-format", "committedDate": "2020-09-20T15:03:06Z", "type": "commit"}, {"oid": "ebe62a5b48a29f72484ecb7b7c82699321b45e3f", "url": "https://github.com/confluentinc/ksql/commit/ebe62a5b48a29f72484ecb7b7c82699321b45e3f", "message": "test: more test fixes", "committedDate": "2020-09-20T15:14:43Z", "type": "commit"}, {"oid": "46bdd57357e639400c1ffdca8f66c31687501cef", "url": "https://github.com/confluentinc/ksql/commit/46bdd57357e639400c1ffdca8f66c31687501cef", "message": "chore: checkstyle", "committedDate": "2020-09-20T15:17:50Z", "type": "commit"}, {"oid": "4f9cb6596c2b43a8c28a01e468de7b7081b7f4e9", "url": "https://github.com/confluentinc/ksql/commit/4f9cb6596c2b43a8c28a01e468de7b7081b7f4e9", "message": "test: more test fixes", "committedDate": "2020-09-20T20:50:58Z", "type": "commit"}, {"oid": "62951e00ffbc4878e214a458d03c1e837758a790", "url": "https://github.com/confluentinc/ksql/commit/62951e00ffbc4878e214a458d03c1e837758a790", "message": "chore: validate default formats up front", "committedDate": "2020-09-20T22:04:00Z", "type": "commit"}, {"oid": "fe945d192db52623a1c747af7a16bd9cbb34ad76", "url": "https://github.com/confluentinc/ksql/commit/fe945d192db52623a1c747af7a16bd9cbb34ad76", "message": "chore: enable json as key format", "committedDate": "2020-09-20T22:09:22Z", "type": "commit"}, {"oid": "3e938c9d66dec2669d1f5f0dc2d53bdbe33c28dd", "url": "https://github.com/confluentinc/ksql/commit/3e938c9d66dec2669d1f5f0dc2d53bdbe33c28dd", "message": "test: another test fix", "committedDate": "2020-09-21T00:14:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjAyOTg5MQ==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492029891", "bodyText": "You're calling throwOnUnsupportedKeyFormat from within the plan method's try/catch block already, so I don't think you need this try/catch, just let the exception bubble up.", "author": "big-andy-coates", "createdAt": "2020-09-21T13:07:27Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/EngineExecutor.java", "diffHunk": "@@ -342,6 +349,36 @@ private static void throwOnNonExecutableStatement(final ConfiguredStatement<?> s\n     }\n   }\n \n+  private static void throwOnUnsupportedKeyFormat(final ConfiguredStatement<?> statement) {\n+    try {\n+      if (statement.getStatement() instanceof CreateSource) {\n+        final CreateSource createSource = (CreateSource) statement.getStatement();\n+        throwOnUnsupportedKeyFormat(\n+            SourcePropertiesUtil.getKeyFormat(createSource.getProperties()));\n+      }\n+\n+      if (statement.getStatement() instanceof CreateAsSelect) {\n+        final CreateAsSelect createAsSelect = (CreateAsSelect) statement.getStatement();\n+        createAsSelect.getProperties().getKeyFormat()\n+            .ifPresent(EngineExecutor::throwOnUnsupportedKeyFormat);\n+      }\n+    } catch (KsqlStatementException e) {\n+      throw e;\n+    } catch (KsqlException e) {\n+      throw new KsqlStatementException(\n+          ErrorMessageUtil.buildErrorMessage(e),\n+          statement.getStatementText(),\n+          e.getCause());\n+    }", "originalCommit": "3e938c9d66dec2669d1f5f0dc2d53bdbe33c28dd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjAzMTMzNA==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492031334", "bodyText": "And for the record... ErrorMessageUtil... yuck!!!! I'd avoid using this class. It's one that should be shot in the head at some point.", "author": "big-andy-coates", "createdAt": "2020-09-21T13:09:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjAyOTg5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5ODY1Nw==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492298657", "bodyText": "You're calling throwOnUnsupportedKeyFormat from within the plan method's try/catch block already, so I don't think you need this try/catch, just let the exception bubble up.\n\nGood call. Made the change.\n\nAnd for the record... ErrorMessageUtil... yuck!!!! I'd avoid using this class. It's one that should be shot in the head at some point.\n\nMy use of ErrorMessageUtil was just copy-pasta from other parts of the code but I'm curious what your gripe with it is. Is it not useful to reveal the chain of causation to the user?", "author": "vcrfxia", "createdAt": "2020-09-21T19:33:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjAyOTg5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjAzMjg3Ng==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492032876", "bodyText": "I'd suggest putting some java docs on here explaining that the DefaultFormatInjector ensures that the formats are always present, i.e. tie up the code that avoids the Illegal state exception from being thrown with this code.", "author": "big-andy-coates", "createdAt": "2020-09-21T13:12:05Z", "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/properties/with/SourcePropertiesUtil.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.parser.properties.with;\n+\n+import io.confluent.ksql.serde.FormatInfo;\n+\n+public final class SourcePropertiesUtil {\n+\n+  private SourcePropertiesUtil() {\n+  }\n+\n+  public static FormatInfo getKeyFormat(final CreateSourceProperties properties) {\n+    return properties.getKeyFormat()\n+        .orElseThrow(() -> new IllegalStateException(\"Key format not present\"));\n+  }\n+\n+  public static FormatInfo getValueFormat(final CreateSourceProperties properties) {\n+    return properties.getValueFormat()\n+        .orElseThrow(() -> new IllegalStateException(\"Value format not present\"));\n+  }", "originalCommit": "3e938c9d66dec2669d1f5f0dc2d53bdbe33c28dd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjAzNTA2MA==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492035060", "bodyText": "As discussed above, let's only throw if non KAFKA.", "author": "big-andy-coates", "createdAt": "2020-09-21T13:15:25Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.format;\n+\n+import io.confluent.ksql.parser.KsqlParser.PreparedStatement;\n+import io.confluent.ksql.parser.SqlFormatter;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.confluent.ksql.parser.properties.with.CreateSourceProperties;\n+import io.confluent.ksql.parser.tree.CreateAsSelect;\n+import io.confluent.ksql.parser.tree.CreateSource;\n+import io.confluent.ksql.parser.tree.Statement;\n+import io.confluent.ksql.properties.with.CommonCreateConfigs;\n+import io.confluent.ksql.serde.FormatInfo;\n+import io.confluent.ksql.statement.ConfiguredStatement;\n+import io.confluent.ksql.statement.Injector;\n+import io.confluent.ksql.util.ErrorMessageUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+import java.util.Optional;\n+\n+/**\n+ * An injector which injects the key and value formats into the supplied {@code statement}.\n+ *\n+ * <p>The key format is only injected if:\n+ * <ul>\n+ * <li>The statement is a CT/CS.</li>\n+ * <li>The statement does not specify the FORMAT property in its WITH clause.</li>\n+ * <li>The statement does not specify the KEY_FORMAT property in its WITH clause.</li>\n+ * </ul>\n+ *\n+ * <p>Similarly, the value format is only injected if the above conditions are met,\n+ * where the KEY_FORMAT property is replaced with the VALUE_FORMAT property accordingly.\n+ *\n+ * <p>If any of the above are not true then the {@code statement} is returned unchanged.\n+ */\n+public class DefaultFormatInjector implements Injector {\n+\n+  public DefaultFormatInjector() {\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public <T extends Statement> ConfiguredStatement<T> inject(\n+      final ConfiguredStatement<T> statement\n+  ) {\n+    if (featureFlagNotEnabled(statement)) {\n+      validateLegacyFormatProperties(statement);\n+    }\n+\n+    if (statement.getStatement() instanceof CreateSource) {\n+      return handleCreateSource((ConfiguredStatement<CreateSource>) statement);\n+    }\n+\n+    return statement;\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private <T extends Statement> ConfiguredStatement<T> handleCreateSource(\n+      final ConfiguredStatement<CreateSource> statement\n+  ) {\n+    try {\n+      // Safe to cast as we know `T` is `CreateSource`\n+      return (ConfiguredStatement<T>)\n+          injectForCreateStatement(statement).orElse(statement);\n+    } catch (final KsqlStatementException e) {\n+      throw e;\n+    } catch (final KsqlException e) {\n+      throw new KsqlStatementException(\n+          ErrorMessageUtil.buildErrorMessage(e),\n+          statement.getStatementText(),\n+          e.getCause());\n+    }\n+  }\n+\n+  private Optional<ConfiguredStatement<CreateSource>> injectForCreateStatement(\n+      final ConfiguredStatement<CreateSource> original\n+  ) {\n+\n+    final CreateSource statement = original.getStatement();\n+    final CreateSourceProperties properties = statement.getProperties();\n+\n+    final Optional<FormatInfo> keyFormat = properties.getKeyFormat();\n+    final Optional<FormatInfo> valueFormat = properties.getValueFormat();\n+\n+    if (keyFormat.isPresent() && valueFormat.isPresent()) {\n+      return Optional.empty();\n+    }\n+\n+    final KsqlConfig config = getConfig(original);\n+    validateConfig(config, keyFormat, valueFormat);\n+\n+    final CreateSourceProperties injectedProps = properties.withFormats(\n+        keyFormat.map(FormatInfo::getFormat)\n+            .orElse(config.getString(KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG)),\n+        valueFormat.map(FormatInfo::getFormat)\n+            .orElse(config.getString(KsqlConfig.KSQL_DEFAULT_VALUE_FORMAT_CONFIG))\n+    );\n+    final CreateSource withFormats = statement.copyWith(\n+        original.getStatement().getElements(),\n+        injectedProps\n+    );\n+\n+    final PreparedStatement<CreateSource> prepared = buildPreparedStatement(withFormats);\n+    final ConfiguredStatement<CreateSource> configured = ConfiguredStatement\n+        .of(prepared, original.getConfigOverrides(), original.getConfig());\n+\n+    return Optional.of(configured);\n+  }\n+\n+  private static void validateConfig(\n+      final KsqlConfig config,\n+      final Optional<FormatInfo> keyFormat,\n+      final Optional<FormatInfo> valueFormat\n+  ) {\n+    if (!keyFormat.isPresent()\n+        && config.getString(KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG) == null) {\n+      throw new KsqlException(\"Statement is missing the '\"\n+          + CommonCreateConfigs.KEY_FORMAT_PROPERTY + \"' property from the WITH clause. \"\n+          + \"Either provide one or set a default via the '\"\n+          + KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG + \"' config.\");\n+    }\n+    if (!valueFormat.isPresent()\n+        && config.getString(KsqlConfig.KSQL_DEFAULT_VALUE_FORMAT_CONFIG) == null) {\n+      throw new KsqlException(\"Statement is missing the '\"\n+          + CommonCreateConfigs.VALUE_FORMAT_PROPERTY + \"' property from the WITH clause. \"\n+          + \"Either provide one or set a default via the '\"\n+          + KsqlConfig.KSQL_DEFAULT_VALUE_FORMAT_CONFIG + \"' config.\");\n+    }\n+  }\n+\n+  private static KsqlConfig getConfig(final ConfiguredStatement<?> statement) {\n+    return statement.getConfig().cloneWithPropertyOverwrite(statement.getConfigOverrides());\n+  }\n+\n+  private static void validateLegacyFormatProperties(final ConfiguredStatement<?> statement) {\n+    if (statement.getStatement() instanceof CreateSource) {\n+      final CreateSource createStatement = (CreateSource) statement.getStatement();\n+\n+      if (createStatement.getProperties().getKeyFormat().isPresent()) {\n+        throwKeyFormatDisabled(statement.getStatementText());\n+      }", "originalCommit": "3e938c9d66dec2669d1f5f0dc2d53bdbe33c28dd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5NzU2Ng==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492297566", "bodyText": "As discussed offline, this check to throw if KEY_FORMAT or FORMAT was provided without the feature flag enabled has been removed entirely. The engine is responsible for validating the provided format, in the context of the feature flag.", "author": "vcrfxia", "createdAt": "2020-09-21T19:31:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjAzNTA2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjAzNzM3Mg==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492037372", "bodyText": "nit:\nRather than having a method throwKeyFormatDisabled  that always throws an exception, I'd suggest having a keyFormatDisabledException method that creates the exception:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (createStatement.getProperties().getKeyFormat().isPresent()) {\n          \n          \n            \n                    throwKeyFormatDisabled(statement.getStatementText());\n          \n          \n            \n                  }\n          \n          \n            \n                  if (createStatement.getProperties().getKeyFormat().isPresent()) {\n          \n          \n            \n                    throw keyFormatDisabledException(statement.getStatementText());\n          \n          \n            \n                  }\n          \n      \n    \n    \n  \n\nThe benefit, is that it's easier to grok as you know by looking at the code that an exception is always thrown, without having to go check another function. This pattern can also avoid compiler issues, e.g. warnings and errors about code paths not initializing variables.", "author": "big-andy-coates", "createdAt": "2020-09-21T13:18:56Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.format;\n+\n+import io.confluent.ksql.parser.KsqlParser.PreparedStatement;\n+import io.confluent.ksql.parser.SqlFormatter;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.confluent.ksql.parser.properties.with.CreateSourceProperties;\n+import io.confluent.ksql.parser.tree.CreateAsSelect;\n+import io.confluent.ksql.parser.tree.CreateSource;\n+import io.confluent.ksql.parser.tree.Statement;\n+import io.confluent.ksql.properties.with.CommonCreateConfigs;\n+import io.confluent.ksql.serde.FormatInfo;\n+import io.confluent.ksql.statement.ConfiguredStatement;\n+import io.confluent.ksql.statement.Injector;\n+import io.confluent.ksql.util.ErrorMessageUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+import java.util.Optional;\n+\n+/**\n+ * An injector which injects the key and value formats into the supplied {@code statement}.\n+ *\n+ * <p>The key format is only injected if:\n+ * <ul>\n+ * <li>The statement is a CT/CS.</li>\n+ * <li>The statement does not specify the FORMAT property in its WITH clause.</li>\n+ * <li>The statement does not specify the KEY_FORMAT property in its WITH clause.</li>\n+ * </ul>\n+ *\n+ * <p>Similarly, the value format is only injected if the above conditions are met,\n+ * where the KEY_FORMAT property is replaced with the VALUE_FORMAT property accordingly.\n+ *\n+ * <p>If any of the above are not true then the {@code statement} is returned unchanged.\n+ */\n+public class DefaultFormatInjector implements Injector {\n+\n+  public DefaultFormatInjector() {\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public <T extends Statement> ConfiguredStatement<T> inject(\n+      final ConfiguredStatement<T> statement\n+  ) {\n+    if (featureFlagNotEnabled(statement)) {\n+      validateLegacyFormatProperties(statement);\n+    }\n+\n+    if (statement.getStatement() instanceof CreateSource) {\n+      return handleCreateSource((ConfiguredStatement<CreateSource>) statement);\n+    }\n+\n+    return statement;\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private <T extends Statement> ConfiguredStatement<T> handleCreateSource(\n+      final ConfiguredStatement<CreateSource> statement\n+  ) {\n+    try {\n+      // Safe to cast as we know `T` is `CreateSource`\n+      return (ConfiguredStatement<T>)\n+          injectForCreateStatement(statement).orElse(statement);\n+    } catch (final KsqlStatementException e) {\n+      throw e;\n+    } catch (final KsqlException e) {\n+      throw new KsqlStatementException(\n+          ErrorMessageUtil.buildErrorMessage(e),\n+          statement.getStatementText(),\n+          e.getCause());\n+    }\n+  }\n+\n+  private Optional<ConfiguredStatement<CreateSource>> injectForCreateStatement(\n+      final ConfiguredStatement<CreateSource> original\n+  ) {\n+\n+    final CreateSource statement = original.getStatement();\n+    final CreateSourceProperties properties = statement.getProperties();\n+\n+    final Optional<FormatInfo> keyFormat = properties.getKeyFormat();\n+    final Optional<FormatInfo> valueFormat = properties.getValueFormat();\n+\n+    if (keyFormat.isPresent() && valueFormat.isPresent()) {\n+      return Optional.empty();\n+    }\n+\n+    final KsqlConfig config = getConfig(original);\n+    validateConfig(config, keyFormat, valueFormat);\n+\n+    final CreateSourceProperties injectedProps = properties.withFormats(\n+        keyFormat.map(FormatInfo::getFormat)\n+            .orElse(config.getString(KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG)),\n+        valueFormat.map(FormatInfo::getFormat)\n+            .orElse(config.getString(KsqlConfig.KSQL_DEFAULT_VALUE_FORMAT_CONFIG))\n+    );\n+    final CreateSource withFormats = statement.copyWith(\n+        original.getStatement().getElements(),\n+        injectedProps\n+    );\n+\n+    final PreparedStatement<CreateSource> prepared = buildPreparedStatement(withFormats);\n+    final ConfiguredStatement<CreateSource> configured = ConfiguredStatement\n+        .of(prepared, original.getConfigOverrides(), original.getConfig());\n+\n+    return Optional.of(configured);\n+  }\n+\n+  private static void validateConfig(\n+      final KsqlConfig config,\n+      final Optional<FormatInfo> keyFormat,\n+      final Optional<FormatInfo> valueFormat\n+  ) {\n+    if (!keyFormat.isPresent()\n+        && config.getString(KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG) == null) {\n+      throw new KsqlException(\"Statement is missing the '\"\n+          + CommonCreateConfigs.KEY_FORMAT_PROPERTY + \"' property from the WITH clause. \"\n+          + \"Either provide one or set a default via the '\"\n+          + KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG + \"' config.\");\n+    }\n+    if (!valueFormat.isPresent()\n+        && config.getString(KsqlConfig.KSQL_DEFAULT_VALUE_FORMAT_CONFIG) == null) {\n+      throw new KsqlException(\"Statement is missing the '\"\n+          + CommonCreateConfigs.VALUE_FORMAT_PROPERTY + \"' property from the WITH clause. \"\n+          + \"Either provide one or set a default via the '\"\n+          + KsqlConfig.KSQL_DEFAULT_VALUE_FORMAT_CONFIG + \"' config.\");\n+    }\n+  }\n+\n+  private static KsqlConfig getConfig(final ConfiguredStatement<?> statement) {\n+    return statement.getConfig().cloneWithPropertyOverwrite(statement.getConfigOverrides());\n+  }\n+\n+  private static void validateLegacyFormatProperties(final ConfiguredStatement<?> statement) {\n+    if (statement.getStatement() instanceof CreateSource) {\n+      final CreateSource createStatement = (CreateSource) statement.getStatement();\n+\n+      if (createStatement.getProperties().getKeyFormat().isPresent()) {\n+        throwKeyFormatDisabled(statement.getStatementText());\n+      }", "originalCommit": "3e938c9d66dec2669d1f5f0dc2d53bdbe33c28dd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5Njg2MA==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492296860", "bodyText": "Cool tip! I'm sold.\nUnfortunately these methods were removed as part of the change to allow the use of KEY_FORMAT and FORMAT even if the feature flag is disabled so we won't be able to realize the shinier v2 of this code ;o", "author": "vcrfxia", "createdAt": "2020-09-21T19:29:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjAzNzM3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjAzOTkwMg==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492039902", "bodyText": "As discussed above, the following avoids the need for casting and suppressing warnings in the calling function:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              @SuppressWarnings(\"unchecked\")\n          \n          \n            \n              private <T extends Statement> ConfiguredStatement<T> handleCreateSource(\n          \n          \n            \n                  final ConfiguredStatement<CreateSource> statement\n          \n          \n            \n              ) {\n          \n          \n            \n                try {\n          \n          \n            \n                  // Safe to cast as we know `T` is `CreateSource`\n          \n          \n            \n                  return (ConfiguredStatement<T>)\n          \n          \n            \n                      injectForCreateStatement(statement).orElse(statement);\n          \n          \n            \n                } catch (final KsqlStatementException e) {\n          \n          \n            \n                  throw e;\n          \n          \n            \n                } catch (final KsqlException e) {\n          \n          \n            \n                  throw new KsqlStatementException(\n          \n          \n            \n                      ErrorMessageUtil.buildErrorMessage(e),\n          \n          \n            \n                      statement.getStatementText(),\n          \n          \n            \n                      e.getCause());\n          \n          \n            \n                }\n          \n          \n            \n              }\n          \n          \n            \n              @SuppressWarnings(\"unchecked\")\n          \n          \n            \n              private <T extends Statement> ConfiguredStatement<T> handleCreateSource(\n          \n          \n            \n                  final ConfiguredStatement<T> statement\n          \n          \n            \n              ) {\n          \n          \n            \n                if (!(statement.getStatement() instanceOf CreateSource) {\n          \n          \n            \n                   throw new IllegalArgumentException(\"blah\");\n          \n          \n            \n                }\n          \n          \n            \n                try {\n          \n          \n            \n                  // Safe to cast as we know `T` is `CreateSource`\n          \n          \n            \n                  return (ConfiguredStatement<T>)\n          \n          \n            \n                      injectForCreateStatement(statement).orElse(statement);\n          \n          \n            \n                } catch (final KsqlStatementException e) {\n          \n          \n            \n                  throw e;\n          \n          \n            \n                } catch (final KsqlException e) {\n          \n          \n            \n                  throw new KsqlStatementException(\n          \n          \n            \n                      ErrorMessageUtil.buildErrorMessage(e),\n          \n          \n            \n                      statement.getStatementText(),\n          \n          \n            \n                      e.getCause());\n          \n          \n            \n                }\n          \n          \n            \n              }\n          \n      \n    \n    \n  \n\nIf you don't link the double checking of types and loss of type safety, then stick with what you have. No biggie.", "author": "big-andy-coates", "createdAt": "2020-09-21T13:22:41Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.format;\n+\n+import io.confluent.ksql.parser.KsqlParser.PreparedStatement;\n+import io.confluent.ksql.parser.SqlFormatter;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.confluent.ksql.parser.properties.with.CreateSourceProperties;\n+import io.confluent.ksql.parser.tree.CreateAsSelect;\n+import io.confluent.ksql.parser.tree.CreateSource;\n+import io.confluent.ksql.parser.tree.Statement;\n+import io.confluent.ksql.properties.with.CommonCreateConfigs;\n+import io.confluent.ksql.serde.FormatInfo;\n+import io.confluent.ksql.statement.ConfiguredStatement;\n+import io.confluent.ksql.statement.Injector;\n+import io.confluent.ksql.util.ErrorMessageUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+import java.util.Optional;\n+\n+/**\n+ * An injector which injects the key and value formats into the supplied {@code statement}.\n+ *\n+ * <p>The key format is only injected if:\n+ * <ul>\n+ * <li>The statement is a CT/CS.</li>\n+ * <li>The statement does not specify the FORMAT property in its WITH clause.</li>\n+ * <li>The statement does not specify the KEY_FORMAT property in its WITH clause.</li>\n+ * </ul>\n+ *\n+ * <p>Similarly, the value format is only injected if the above conditions are met,\n+ * where the KEY_FORMAT property is replaced with the VALUE_FORMAT property accordingly.\n+ *\n+ * <p>If any of the above are not true then the {@code statement} is returned unchanged.\n+ */\n+public class DefaultFormatInjector implements Injector {\n+\n+  public DefaultFormatInjector() {\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public <T extends Statement> ConfiguredStatement<T> inject(\n+      final ConfiguredStatement<T> statement\n+  ) {\n+    if (featureFlagNotEnabled(statement)) {\n+      validateLegacyFormatProperties(statement);\n+    }\n+\n+    if (statement.getStatement() instanceof CreateSource) {\n+      return handleCreateSource((ConfiguredStatement<CreateSource>) statement);\n+    }\n+\n+    return statement;\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private <T extends Statement> ConfiguredStatement<T> handleCreateSource(\n+      final ConfiguredStatement<CreateSource> statement\n+  ) {\n+    try {\n+      // Safe to cast as we know `T` is `CreateSource`\n+      return (ConfiguredStatement<T>)\n+          injectForCreateStatement(statement).orElse(statement);\n+    } catch (final KsqlStatementException e) {\n+      throw e;\n+    } catch (final KsqlException e) {\n+      throw new KsqlStatementException(\n+          ErrorMessageUtil.buildErrorMessage(e),\n+          statement.getStatementText(),\n+          e.getCause());\n+    }\n+  }", "originalCommit": "3e938c9d66dec2669d1f5f0dc2d53bdbe33c28dd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5NTg5MA==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492295890", "bodyText": "Not convinced this is noticeably better. Will leave it as is.", "author": "vcrfxia", "createdAt": "2020-09-21T19:28:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjAzOTkwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA0NzExNg==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492047116", "bodyText": "nit:  this code is correct and works.  However, just a suggestion in terms of the pattern...\nThis code separates the validation from the access.  You first validate the state is what you need, then you access the state.  This works well until someone comes along and changes one side without realizing they should update the other.\nI'd suggest a better pattern is to access the state and validate what you extract. This makes it much harder for someone to come along and miss something, e.g.\nprivate Optional<ConfiguredStatement<CreateSource>> injectForCreateStatement(\n      final ConfiguredStatement<CreateSource> original\n  ) {\n   ....\n \n   final KsqlConfig config = getConfig(original);\n\n    final CreateSourceProperties injectedProps = properties.withFormats(\n        keyFormat.map(FormatInfo::getFormat).orElseGet(() -> getDefaultKeyFormat(config)),\n        valueFormat.map(FormatInfo::getFormat).orElseGet(() -> getDefaultValueFormat(config))\n    );\n\n    ...\n }\n\n private String getDefaultKeyFormat(final KsqlConfig config) {\n     final String format = config.getString(KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG);\n    if (format == null) {\n        throw new KsqlException(\"Statement is missing the '\"\n          + CommonCreateConfigs.KEY_FORMAT_PROPERTY + \"' property from the WITH clause. \"\n          + \"Either provide one or set a default via the '\"\n          + KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG + \"' config.\");\n    }\n\n    return format;\n }\n\n // Same pattern for getDefaultValueFormat\nHere, both the accessing and validating of the default key format is done in one place: the getDefaultKeyFormat method.", "author": "big-andy-coates", "createdAt": "2020-09-21T13:32:42Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.format;\n+\n+import io.confluent.ksql.parser.KsqlParser.PreparedStatement;\n+import io.confluent.ksql.parser.SqlFormatter;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.confluent.ksql.parser.properties.with.CreateSourceProperties;\n+import io.confluent.ksql.parser.tree.CreateAsSelect;\n+import io.confluent.ksql.parser.tree.CreateSource;\n+import io.confluent.ksql.parser.tree.Statement;\n+import io.confluent.ksql.properties.with.CommonCreateConfigs;\n+import io.confluent.ksql.serde.FormatInfo;\n+import io.confluent.ksql.statement.ConfiguredStatement;\n+import io.confluent.ksql.statement.Injector;\n+import io.confluent.ksql.util.ErrorMessageUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+import java.util.Optional;\n+\n+/**\n+ * An injector which injects the key and value formats into the supplied {@code statement}.\n+ *\n+ * <p>The key format is only injected if:\n+ * <ul>\n+ * <li>The statement is a CT/CS.</li>\n+ * <li>The statement does not specify the FORMAT property in its WITH clause.</li>\n+ * <li>The statement does not specify the KEY_FORMAT property in its WITH clause.</li>\n+ * </ul>\n+ *\n+ * <p>Similarly, the value format is only injected if the above conditions are met,\n+ * where the KEY_FORMAT property is replaced with the VALUE_FORMAT property accordingly.\n+ *\n+ * <p>If any of the above are not true then the {@code statement} is returned unchanged.\n+ */\n+public class DefaultFormatInjector implements Injector {\n+\n+  public DefaultFormatInjector() {\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public <T extends Statement> ConfiguredStatement<T> inject(\n+      final ConfiguredStatement<T> statement\n+  ) {\n+    if (featureFlagNotEnabled(statement)) {\n+      validateLegacyFormatProperties(statement);\n+    }\n+\n+    if (statement.getStatement() instanceof CreateSource) {\n+      return handleCreateSource((ConfiguredStatement<CreateSource>) statement);\n+    }\n+\n+    return statement;\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private <T extends Statement> ConfiguredStatement<T> handleCreateSource(\n+      final ConfiguredStatement<CreateSource> statement\n+  ) {\n+    try {\n+      // Safe to cast as we know `T` is `CreateSource`\n+      return (ConfiguredStatement<T>)\n+          injectForCreateStatement(statement).orElse(statement);\n+    } catch (final KsqlStatementException e) {\n+      throw e;\n+    } catch (final KsqlException e) {\n+      throw new KsqlStatementException(\n+          ErrorMessageUtil.buildErrorMessage(e),\n+          statement.getStatementText(),\n+          e.getCause());\n+    }\n+  }\n+\n+  private Optional<ConfiguredStatement<CreateSource>> injectForCreateStatement(\n+      final ConfiguredStatement<CreateSource> original\n+  ) {\n+\n+    final CreateSource statement = original.getStatement();\n+    final CreateSourceProperties properties = statement.getProperties();\n+\n+    final Optional<FormatInfo> keyFormat = properties.getKeyFormat();\n+    final Optional<FormatInfo> valueFormat = properties.getValueFormat();\n+\n+    if (keyFormat.isPresent() && valueFormat.isPresent()) {\n+      return Optional.empty();\n+    }\n+\n+    final KsqlConfig config = getConfig(original);\n+    validateConfig(config, keyFormat, valueFormat);\n+\n+    final CreateSourceProperties injectedProps = properties.withFormats(\n+        keyFormat.map(FormatInfo::getFormat)\n+            .orElse(config.getString(KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG)),\n+        valueFormat.map(FormatInfo::getFormat)\n+            .orElse(config.getString(KsqlConfig.KSQL_DEFAULT_VALUE_FORMAT_CONFIG))\n+    );", "originalCommit": "3e938c9d66dec2669d1f5f0dc2d53bdbe33c28dd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5NTYwMQ==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492295601", "bodyText": "Great tip! Made the change, will also keep this in mind for the future.", "author": "vcrfxia", "createdAt": "2020-09-21T19:27:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA0NzExNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA1MTM1Mw==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492051353", "bodyText": "Avoid use of ErrorMessageUtil... it's nasty.  How about just:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  throw new KsqlStatementException(\n          \n          \n            \n                      ErrorMessageUtil.buildErrorMessage(e),\n          \n          \n            \n                      statement.getStatementText(),\n          \n          \n            \n                      e.getCause());\n          \n          \n            \n                  throw new KsqlStatementException(e.getMessage(), statement.getStatementText(), e);", "author": "big-andy-coates", "createdAt": "2020-09-21T13:38:20Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/format/DefaultFormatInjector.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.format;\n+\n+import io.confluent.ksql.parser.KsqlParser.PreparedStatement;\n+import io.confluent.ksql.parser.SqlFormatter;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.confluent.ksql.parser.properties.with.CreateSourceProperties;\n+import io.confluent.ksql.parser.tree.CreateAsSelect;\n+import io.confluent.ksql.parser.tree.CreateSource;\n+import io.confluent.ksql.parser.tree.Statement;\n+import io.confluent.ksql.properties.with.CommonCreateConfigs;\n+import io.confluent.ksql.serde.FormatInfo;\n+import io.confluent.ksql.statement.ConfiguredStatement;\n+import io.confluent.ksql.statement.Injector;\n+import io.confluent.ksql.util.ErrorMessageUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+import java.util.Optional;\n+\n+/**\n+ * An injector which injects the key and value formats into the supplied {@code statement}.\n+ *\n+ * <p>The key format is only injected if:\n+ * <ul>\n+ * <li>The statement is a CT/CS.</li>\n+ * <li>The statement does not specify the FORMAT property in its WITH clause.</li>\n+ * <li>The statement does not specify the KEY_FORMAT property in its WITH clause.</li>\n+ * </ul>\n+ *\n+ * <p>Similarly, the value format is only injected if the above conditions are met,\n+ * where the KEY_FORMAT property is replaced with the VALUE_FORMAT property accordingly.\n+ *\n+ * <p>If any of the above are not true then the {@code statement} is returned unchanged.\n+ */\n+public class DefaultFormatInjector implements Injector {\n+\n+  public DefaultFormatInjector() {\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public <T extends Statement> ConfiguredStatement<T> inject(\n+      final ConfiguredStatement<T> statement\n+  ) {\n+    if (featureFlagNotEnabled(statement)) {\n+      validateLegacyFormatProperties(statement);\n+    }\n+\n+    if (statement.getStatement() instanceof CreateSource) {\n+      return handleCreateSource((ConfiguredStatement<CreateSource>) statement);\n+    }\n+\n+    return statement;\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private <T extends Statement> ConfiguredStatement<T> handleCreateSource(\n+      final ConfiguredStatement<CreateSource> statement\n+  ) {\n+    try {\n+      // Safe to cast as we know `T` is `CreateSource`\n+      return (ConfiguredStatement<T>)\n+          injectForCreateStatement(statement).orElse(statement);\n+    } catch (final KsqlStatementException e) {\n+      throw e;\n+    } catch (final KsqlException e) {\n+      throw new KsqlStatementException(\n+          ErrorMessageUtil.buildErrorMessage(e),\n+          statement.getStatementText(),\n+          e.getCause());", "originalCommit": "3e938c9d66dec2669d1f5f0dc2d53bdbe33c28dd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA1MzAxNw==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492053017", "bodyText": "nit: Pull SourcePropertiesUtil.getKeyFormat(properties) out in to a variable?", "author": "big-andy-coates", "createdAt": "2020-09-21T13:40:32Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/topic/TopicFactory.java", "diffHunk": "@@ -37,13 +36,16 @@ public static KsqlTopic create(final CreateSourceProperties properties) {\n     final Optional<WindowType> windowType = properties.getWindowType();\n     final Optional<Duration> windowSize = properties.getWindowSize();\n \n+\n     final KeyFormat keyFormat = windowType\n         .map(type -> KeyFormat\n-            .windowed(FormatInfo.of(FormatFactory.KAFKA.name()), WindowInfo.of(type, windowSize)))\n+            .windowed(\n+                SourcePropertiesUtil.getKeyFormat(properties),\n+                WindowInfo.of(type, windowSize)))\n         .orElseGet(() -> KeyFormat\n-            .nonWindowed(FormatInfo.of(FormatFactory.KAFKA.name())));\n+            .nonWindowed(SourcePropertiesUtil.getKeyFormat(properties)));\n \n-    final ValueFormat valueFormat = ValueFormat.of(properties.getFormatInfo());\n+    final ValueFormat valueFormat = ValueFormat.of(SourcePropertiesUtil.getValueFormat(properties));", "originalCommit": "3e938c9d66dec2669d1f5f0dc2d53bdbe33c28dd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA1NTY3Mw==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492055673", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private Injector statementInjector;\n          \n          \n            \n              private Injector formatInjector;", "author": "big-andy-coates", "createdAt": "2020-09-21T13:44:05Z", "path": "ksqldb-functional-tests/src/test/java/io/confluent/ksql/test/driver/KsqlTesterTest.java", "diffHunk": "@@ -108,6 +110,7 @@\n   private ServiceContext serviceContext;\n   private KsqlEngine engine;\n   private KsqlConfig config;\n+  private Injector statementInjector;", "originalCommit": "3e938c9d66dec2669d1f5f0dc2d53bdbe33c28dd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA2MTc4MQ==", "url": "https://github.com/confluentinc/ksql/pull/6194#discussion_r492061781", "bodyText": "You upper-case here, but not elsewhere in the code when accessing the property.  Maybe just move the uppercasing into fromName?", "author": "big-andy-coates", "createdAt": "2020-09-21T13:52:06Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/KsqlServerMain.java", "diffHunk": "@@ -101,6 +102,47 @@ void tryStartApp() throws Exception {\n     }\n   }\n \n+  private static void validateConfig(final KsqlConfig config) {\n+    validateStateDir(config);\n+    validateDefaultTopicFormats(config);\n+  }\n+\n+  private static void validateStateDir(final KsqlConfig config) {\n+    final String streamsStateDirPath = config.getKsqlStreamConfigProps().getOrDefault(\n+        StreamsConfig.STATE_DIR_CONFIG,\n+        StreamsConfig.configDef().defaultValues().get(StreamsConfig.STATE_DIR_CONFIG)).toString();\n+    enforceStreamStateDirAvailability(new File(streamsStateDirPath));\n+  }\n+\n+  @VisibleForTesting\n+  static void validateDefaultTopicFormats(final KsqlConfig config) {\n+    validateTopicFormat(config, KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG, \"key\");\n+    validateTopicFormat(config, KsqlConfig.KSQL_DEFAULT_VALUE_FORMAT_CONFIG, \"value\");\n+  }\n+\n+  private static void validateTopicFormat(\n+      final KsqlConfig config,\n+      final String configName,\n+      final String type\n+  ) {\n+    final String formatName = config.getString(configName);\n+    if (formatName == null) {\n+      return;\n+    }\n+\n+    final Format format;\n+    try {\n+      format = FormatFactory.fromName(formatName.toUpperCase());", "originalCommit": "3e938c9d66dec2669d1f5f0dc2d53bdbe33c28dd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e61bb75bb491acf207f108cc56856b4e1f66d766", "url": "https://github.com/confluentinc/ksql/commit/e61bb75bb491acf207f108cc56856b4e1f66d766", "message": "chore: remove isSupportedKeyFormat from interface", "committedDate": "2020-09-21T17:45:44Z", "type": "commit"}, {"oid": "066a4f411e4af366fb1e863ffee82fd40ece4eaa", "url": "https://github.com/confluentinc/ksql/commit/066a4f411e4af366fb1e863ffee82fd40ece4eaa", "message": "chore: feedback", "committedDate": "2020-09-21T18:19:05Z", "type": "commit"}, {"oid": "0592fe03aab5062130c9dd22334685a0840cb02e", "url": "https://github.com/confluentinc/ksql/commit/0592fe03aab5062130c9dd22334685a0840cb02e", "message": "chore: allow use of key_format and format without feature flag", "committedDate": "2020-09-21T18:30:06Z", "type": "commit"}, {"oid": "429740a32867b66ced69d94a39e95190d3192be4", "url": "https://github.com/confluentinc/ksql/commit/429740a32867b66ced69d94a39e95190d3192be4", "message": "fix: use of FORMAT in C*AS", "committedDate": "2020-09-21T18:48:43Z", "type": "commit"}, {"oid": "0fe947af3c52632ca866155610bc23cad70df66e", "url": "https://github.com/confluentinc/ksql/commit/0fe947af3c52632ca866155610bc23cad70df66e", "message": "test: qtt for key_format without feature flag", "committedDate": "2020-09-21T18:53:51Z", "type": "commit"}, {"oid": "49460ae9a3b7fbecce19c035936e3d4ba4ab49fb", "url": "https://github.com/confluentinc/ksql/commit/49460ae9a3b7fbecce19c035936e3d4ba4ab49fb", "message": "chore: historic plans for qtt without feature flag", "committedDate": "2020-09-21T18:56:51Z", "type": "commit"}, {"oid": "f1f0ca19302bc44a11269e355f9d8345b1d14668", "url": "https://github.com/confluentinc/ksql/commit/f1f0ca19302bc44a11269e355f9d8345b1d14668", "message": "Merge branch 'master' into key-format", "committedDate": "2020-09-21T21:27:12Z", "type": "commit"}, {"oid": "719bc434a9391ed5f559da2f336a4243249a9b51", "url": "https://github.com/confluentinc/ksql/commit/719bc434a9391ed5f559da2f336a4243249a9b51", "message": "chore: another merge conflict", "committedDate": "2020-09-21T21:35:05Z", "type": "commit"}]}