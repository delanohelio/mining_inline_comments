{"pr_number": 6770, "pr_title": "chore: support multi-column keys in GROUP BY", "pr_createdAt": "2020-12-15T06:14:40Z", "pr_url": "https://github.com/confluentinc/ksql/pull/6770", "timeline": [{"oid": "06113036776b299813fbfe8d22c38cf63da4caa9", "url": "https://github.com/confluentinc/ksql/commit/06113036776b299813fbfe8d22c38cf63da4caa9", "message": "feat: support multi-column keys in GROUP BY", "committedDate": "2020-12-15T06:17:34Z", "type": "commit"}, {"oid": "06113036776b299813fbfe8d22c38cf63da4caa9", "url": "https://github.com/confluentinc/ksql/commit/06113036776b299813fbfe8d22c38cf63da4caa9", "message": "feat: support multi-column keys in GROUP BY", "committedDate": "2020-12-15T06:17:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzA3NjExNA==", "url": "https://github.com/confluentinc/ksql/pull/6770#discussion_r543076114", "bodyText": "Is there a reason we weren't applying config overrides here? Seems like a bug. This fix is needed in order to pass the feature flag into the GroupByParamsFactory.", "author": "vcrfxia", "createdAt": "2020-12-15T06:19:09Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/EngineExecutor.java", "diffHunk": "@@ -478,7 +478,7 @@ private PersistentQueryMetadata executePersistentQuery(\n   }\n \n   private String buildPlanSummary(final QueryId queryId, final ExecutionStep<?> plan) {\n-    return new PlanSummary(queryId, config.getConfig(false), engineContext.getMetaStore())\n+    return new PlanSummary(queryId, config.getConfig(true), engineContext.getMetaStore())", "originalCommit": "06113036776b299813fbfe8d22c38cf63da4caa9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY0Nzk4Mg==", "url": "https://github.com/confluentinc/ksql/pull/6770#discussion_r543647982", "bodyText": "off the top of my head, I don't think there's any good reason. We should make sure that it's not being used in the pull query path as this (calling getConfig(true)) is shockingly expensive at high throughput.", "author": "agavra", "createdAt": "2020-12-15T20:01:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzA3NjExNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzcwNjIxMA==", "url": "https://github.com/confluentinc/ksql/pull/6770#discussion_r543706210", "bodyText": "This helper method is only called for persistent and push queries, not pull queries, so we should be in the clear. Good call on checking!", "author": "vcrfxia", "createdAt": "2020-12-15T21:40:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzA3NjExNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzA3NjYzNA==", "url": "https://github.com/confluentinc/ksql/pull/6770#discussion_r543076634", "bodyText": "This fix is needed, else sanitizeKeyFormat() adds in key wrapping after groupBy() removes it in the case of multi-column keys.", "author": "vcrfxia", "createdAt": "2020-12-15T06:20:22Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/structured/SchemaKGroupedStream.java", "diffHunk": "@@ -85,7 +85,7 @@\n     } else {\n       keyFormat = SerdeFeaturesFactory.sanitizeKeyFormat(\n           this.keyFormat,\n-          true\n+          schema.key().size() == 1", "originalCommit": "06113036776b299813fbfe8d22c38cf63da4caa9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzA3NzMzMg==", "url": "https://github.com/confluentinc/ksql/pull/6770#discussion_r543077332", "bodyText": "This test is identical to the existing shouldReturnNullIfAnyMultiExpressionResolvesToNull() and is therefore redundant.", "author": "vcrfxia", "createdAt": "2020-12-15T06:22:09Z", "path": "ksqldb-streams/src/test/java/io/confluent/ksql/execution/streams/GroupByParamsFactoryTest.java", "diffHunk": "@@ -238,37 +341,84 @@ public void shouldLogProcessingErrorIfAnyMultiExpressionResolvesToNull() {\n   }\n \n   @Test\n-  public void shouldUseNullInGroupByIfOneExpressionFailsOrReturnsNullInMulti() {", "originalCommit": "06113036776b299813fbfe8d22c38cf63da4caa9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "095cbed3fe3501a8491bb78f2e6bd352511fec43", "url": "https://github.com/confluentinc/ksql/commit/095cbed3fe3501a8491bb78f2e6bd352511fec43", "message": "chore: fix qtt formatting", "committedDate": "2020-12-15T17:56:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY1OTMxMw==", "url": "https://github.com/confluentinc/ksql/pull/6770#discussion_r543659313", "bodyText": "not your original code, but I'm wondering why we can't leverage the schema that we built in LogicalPlanner. It seems like these two schemas have to align perfectly or else this won't work (and the code is quite similar, this just handles ExpressionMetadata instead of Expression directly). Am I right? I haven't actually dug into it that much.", "author": "agavra", "createdAt": "2020-12-15T20:20:35Z", "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/GroupByParamsFactory.java", "diffHunk": "@@ -219,4 +229,69 @@ private static LogicalSchema multiExpressionSchema(\n     final ColumnName keyName = ColumnNames.nextKsqlColAlias(sourceSchema);\n     return buildSchemaWithKeyType(sourceSchema, keyName, SqlTypes.STRING);\n   }\n+\n+  private static final class ExpressionGrouper implements Grouper {\n+\n+    private final LogicalSchema schema;\n+    private final ImmutableList<ExpressionMetadata> groupBys;\n+    private final ProcessingLogger logger;\n+\n+    ExpressionGrouper(\n+        final LogicalSchema sourceSchema,\n+        final List<ExpressionMetadata> groupBys,\n+        final ProcessingLogger logger\n+    ) {\n+      this.schema = expressionSchema(sourceSchema, groupBys);\n+      this.groupBys = ImmutableList.copyOf(requireNonNull(groupBys, \"groupBys\"));\n+      this.logger = Objects.requireNonNull(logger, \"logger\");\n+\n+      if (this.groupBys.isEmpty()) {\n+        throw new IllegalArgumentException(\"Empty group by\");\n+      }\n+    }\n+\n+    @Override\n+    public LogicalSchema getSchema() {\n+      return schema;\n+    }\n+\n+    @Override\n+    public GenericKey apply(final GenericRow row) {\n+      final GenericKey.Builder builder = GenericKey.builder(groupBys.size());\n+\n+      for (int i = 0; i < groupBys.size(); i++) {\n+        final Object result = processColumn(i, groupBys.get(i), row, logger);\n+        if (result == null) {\n+          return null;\n+        }\n+\n+        builder.append(result);\n+      }\n+\n+      return builder.build();\n+    }\n+  }\n+\n+  private static LogicalSchema expressionSchema(", "originalCommit": "06113036776b299813fbfe8d22c38cf63da4caa9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzcxMDc4Mg==", "url": "https://github.com/confluentinc/ksql/pull/6770#discussion_r543710782", "bodyText": "Are you suggesting that the code for how we build the schema in the two places should be shared, or that the actual schema that gets built should be passed from LogicalPlanner to GroupByParamsFactory? I haven't looked too closely at the details of how the schema is built in LogicalPlanner but the latter doesn't make conceptual sense as the two are separated by the execution plan that gets serialized into the command topic.", "author": "vcrfxia", "createdAt": "2020-12-15T21:48:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY1OTMxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzcxMjQwMg==", "url": "https://github.com/confluentinc/ksql/pull/6770#discussion_r543712402", "bodyText": "I did mean the latter. Doesn't the serialized execution plan contain the schema (that was generated by the logical planner) too, though?", "author": "agavra", "createdAt": "2020-12-15T21:51:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY1OTMxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzcxODY4Mw==", "url": "https://github.com/confluentinc/ksql/pull/6770#discussion_r543718683", "bodyText": "We don't write the full schema in, no. Here's an example historic plan: \n  \n    \n      ksql/ksqldb-functional-tests/src/test/resources/historical_plans/group-by_-_AVRO_primitive_key/6.2.0_1607109704822/plan.json\n    \n    \n         Line 109\n      in\n      db2d019\n    \n    \n    \n    \n\n        \n          \n           \"groupByExpressions\" : [ \"VAL\" ] \n        \n    \n  \n\n For the group by step we only write the group by columns, which is why we have to reconstruct the rest of the schema.", "author": "vcrfxia", "createdAt": "2020-12-15T22:01:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY1OTMxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc0MDMyNQ==", "url": "https://github.com/confluentinc/ksql/pull/6770#discussion_r543740325", "bodyText": "ack, out of scope then but seems like something that might be worth looking into some day", "author": "agavra", "createdAt": "2020-12-15T22:41:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY1OTMxMw=="}], "type": "inlineReview"}]}