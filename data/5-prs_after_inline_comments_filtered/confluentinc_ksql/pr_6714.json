{"pr_number": 6714, "pr_title": "fix: Removes orphaned topics from transient queries", "pr_createdAt": "2020-12-02T23:17:03Z", "pr_url": "https://github.com/confluentinc/ksql/pull/6714", "timeline": [{"oid": "a4c72e59e826e3fbe3803361ac96f0777a492e70", "url": "https://github.com/confluentinc/ksql/commit/a4c72e59e826e3fbe3803361ac96f0777a492e70", "message": "fix: Removes orphaned topics from transient queries", "committedDate": "2020-12-08T18:28:05Z", "type": "commit"}, {"oid": "ac7fa9ea8bf96bf5e205580c64808365bfad49e1", "url": "https://github.com/confluentinc/ksql/commit/ac7fa9ea8bf96bf5e205580c64808365bfad49e1", "message": "Catch exception while listing topic names", "committedDate": "2020-12-08T18:28:05Z", "type": "commit"}, {"oid": "00285af9ecaa61e241f95d272d0b057cf265a9b5", "url": "https://github.com/confluentinc/ksql/commit/00285af9ecaa61e241f95d272d0b057cf265a9b5", "message": "Writes transient queries to disk so they can be cleaned up", "committedDate": "2020-12-08T19:11:50Z", "type": "commit"}, {"oid": "0c572b5ae2feb8f9c344158fd373d1c4ff339e2b", "url": "https://github.com/confluentinc/ksql/commit/0c572b5ae2feb8f9c344158fd373d1c4ff339e2b", "message": "Lint", "committedDate": "2020-12-08T19:14:02Z", "type": "commit"}, {"oid": "c4598b9f390b8f2ff2c282d793f2d4248e2e51d7", "url": "https://github.com/confluentinc/ksql/commit/c4598b9f390b8f2ff2c282d793f2d4248e2e51d7", "message": "Lint again", "committedDate": "2020-12-08T19:17:56Z", "type": "commit"}, {"oid": "c4598b9f390b8f2ff2c282d793f2d4248e2e51d7", "url": "https://github.com/confluentinc/ksql/commit/c4598b9f390b8f2ff2c282d793f2d4248e2e51d7", "message": "Lint again", "committedDate": "2020-12-08T19:17:56Z", "type": "forcePushed"}, {"oid": "a9a671b9a2201de213f794a849c71be56a3a4140", "url": "https://github.com/confluentinc/ksql/commit/a9a671b9a2201de213f794a849c71be56a3a4140", "message": "Fix test", "committedDate": "2020-12-08T20:21:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcxNzcwNA==", "url": "https://github.com/confluentinc/ksql/pull/6714#discussion_r538717704", "bodyText": "should we be using startsWith? I thought that in cloud we prefix all the topics with things other than just the transient application id. contains might be a safer bet either way", "author": "agavra", "createdAt": "2020-12-08T18:50:47Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/OrphanedTransientQueryCleaner.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.engine;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import io.confluent.ksql.exception.KafkaResponseGetFailedException;\n+import io.confluent.ksql.services.KafkaTopicClient;\n+import io.confluent.ksql.services.ServiceContext;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class OrphanedTransientQueryCleaner {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(OrphanedTransientQueryCleaner.class);\n+\n+  private final QueryCleanupService cleanupService;\n+\n+  public OrphanedTransientQueryCleaner(final QueryCleanupService cleanupService) {\n+    this.cleanupService = requireNonNull(cleanupService);\n+  }\n+\n+  public void cleanupOrphanedInternalTopics(\n+      final ServiceContext serviceContext,\n+      final Set<String> queryApplicationIds\n+  ) {\n+    final KafkaTopicClient topicClient = serviceContext.getTopicClient();\n+    final Set<String> topicNames;\n+    try {\n+      topicNames = topicClient.listTopicNames();\n+    } catch (KafkaResponseGetFailedException e) {\n+      LOG.error(\"Couldn't fetch topic names\", e);\n+      return;\n+    }\n+    // Find any transient query topics\n+    final Set<String> orphanedQueryApplicationIds = topicNames.stream()\n+        .map(topicName -> queryApplicationIds.stream().filter(topicName::startsWith).findFirst())", "originalCommit": "5d6f964fbe25c1a86258c0fe21deca16cff45a12", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg4NzE2MQ==", "url": "https://github.com/confluentinc/ksql/pull/6714#discussion_r538887161", "bodyText": "So far as I can tell, nothing is very different in the cloud beyond setting some configs differently for making the query application id.  After all, so far as I can tell it's streams that is creating these topics and they just append to the query application id.\nI verified this manually with the transient topic names, so I'm pretty confident startsWith should work.", "author": "AlanConfluent", "createdAt": "2020-12-08T23:27:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcxNzcwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg4ODg5MQ==", "url": "https://github.com/confluentinc/ksql/pull/6714#discussion_r538888891", "bodyText": "ack", "author": "agavra", "createdAt": "2020-12-08T23:31:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcxNzcwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcxOTU5Mg==", "url": "https://github.com/confluentinc/ksql/pull/6714#discussion_r538719592", "bodyText": "if I recall, this is actually a somewhat expensive metadata operation (though we may want to confirm with Kafka experts) if we'll be calling it regularly. Should we flip the semantics (i.e. check whether a topic corresponding to an orphaned query exists) instead of the other way around?", "author": "agavra", "createdAt": "2020-12-08T18:53:24Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/OrphanedTransientQueryCleaner.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.engine;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import io.confluent.ksql.exception.KafkaResponseGetFailedException;\n+import io.confluent.ksql.services.KafkaTopicClient;\n+import io.confluent.ksql.services.ServiceContext;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class OrphanedTransientQueryCleaner {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(OrphanedTransientQueryCleaner.class);\n+\n+  private final QueryCleanupService cleanupService;\n+\n+  public OrphanedTransientQueryCleaner(final QueryCleanupService cleanupService) {\n+    this.cleanupService = requireNonNull(cleanupService);\n+  }\n+\n+  public void cleanupOrphanedInternalTopics(\n+      final ServiceContext serviceContext,\n+      final Set<String> queryApplicationIds\n+  ) {\n+    final KafkaTopicClient topicClient = serviceContext.getTopicClient();\n+    final Set<String> topicNames;\n+    try {\n+      topicNames = topicClient.listTopicNames();", "originalCommit": "5d6f964fbe25c1a86258c0fe21deca16cff45a12", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg5MTE5Mg==", "url": "https://github.com/confluentinc/ksql/pull/6714#discussion_r538891192", "bodyText": "In theory, it should process just one set of commands at a time during startup (it shouldn't be possible for there to be more than one unprocessed file).  When it does that, it should call this just once.  So it does this list call on node startup and uses that list of topics to compare with all of the application query ids in the commands file.  It would seem to be more expensive to say for every queryApplicationId, check the existence of a given topic.  Not only is that more rpcs, it also might check plenty of completed transient queries the cleaned up with no issue.  I considered adding a \"done cleaning\" entry to the commands so I could find the set of only orphaned queries, but that seems potentially error prone as well and requires writing another entry.  This seemed a little simpler.\nTell me if you'd prefer the \"done cleaning\" approach.", "author": "AlanConfluent", "createdAt": "2020-12-08T23:36:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcxOTU5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg5OTk2OQ==", "url": "https://github.com/confluentinc/ksql/pull/6714#discussion_r538899969", "bodyText": "Yeah I agree the existing PR approach is better. At first, I didn't realize it happens just once on startup but since that's the case this is easier and less error-prone.", "author": "agavra", "createdAt": "2020-12-08T23:57:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcxOTU5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODgyNTMwMA==", "url": "https://github.com/confluentinc/ksql/pull/6714#discussion_r538825300", "bodyText": "Maybe I'm missing something, but shouldn't this filter out any that are currently running? otherwise won't we delete topics for queries that are running?\nEDIT: I noticed that what's passed in is only ever the orphaned queryIDs. Can we javadoc this method to explain that?", "author": "agavra", "createdAt": "2020-12-08T21:36:25Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/OrphanedTransientQueryCleaner.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.engine;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import io.confluent.ksql.exception.KafkaResponseGetFailedException;\n+import io.confluent.ksql.services.KafkaTopicClient;\n+import io.confluent.ksql.services.ServiceContext;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class OrphanedTransientQueryCleaner {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(OrphanedTransientQueryCleaner.class);\n+\n+  private final QueryCleanupService cleanupService;\n+\n+  public OrphanedTransientQueryCleaner(final QueryCleanupService cleanupService) {\n+    this.cleanupService = requireNonNull(cleanupService);\n+  }\n+\n+  public void cleanupOrphanedInternalTopics(\n+      final ServiceContext serviceContext,\n+      final Set<String> queryApplicationIds\n+  ) {\n+    final KafkaTopicClient topicClient = serviceContext.getTopicClient();\n+    final Set<String> topicNames;\n+    try {\n+      topicNames = topicClient.listTopicNames();\n+    } catch (KafkaResponseGetFailedException e) {\n+      LOG.error(\"Couldn't fetch topic names\", e);\n+      return;\n+    }\n+    // Find any transient query topics\n+    final Set<String> orphanedQueryApplicationIds = topicNames.stream()", "originalCommit": "a9a671b9a2201de213f794a849c71be56a3a4140", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg5MjM5MA==", "url": "https://github.com/confluentinc/ksql/pull/6714#discussion_r538892390", "bodyText": "Yeah, I think we're on the same page now.  This is only ever run on startup and so by definition, the query application ids, if found as topic prefixes, would be orphaned.  Of course, that list is all transient queries run, not technically just the orphaned ones.\nI'll improve the documentation.", "author": "AlanConfluent", "createdAt": "2020-12-08T23:39:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODgyNTMwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODgyNjY3Nw==", "url": "https://github.com/confluentinc/ksql/pull/6714#discussion_r538826677", "bodyText": "nit: can we follow given/when/then convention? (it's basically already there but without the comments)", "author": "agavra", "createdAt": "2020-12-08T21:38:53Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/engine/OrphanedTransientQueryCleanerTest.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.engine;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.common.collect.ImmutableSet;\n+import io.confluent.ksql.engine.QueryCleanupService.QueryCleanupTask;\n+import io.confluent.ksql.exception.KafkaResponseGetFailedException;\n+import io.confluent.ksql.services.KafkaTopicClient;\n+import io.confluent.ksql.services.ServiceContext;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class OrphanedTransientQueryCleanerTest {\n+  private static final String TOPIC1\n+      = \"_confluent-ksql-default_transient_932097300573686369_1606940079718\"\n+      + \"-Aggregate-GroupBy-repartition\";\n+  private static final String TOPIC2\n+      = \"_confluent-ksql-default_transient_932097300573686369_1606940079718\"\n+      + \"-Aggregate-Aggregate-Materialize-changelog\";\n+  private static final String TOPIC3\n+      = \"_confluent-ksql-default_transient_123497300573686369_1606940012345\"\n+      + \"-Aggregate-Aggregate-Materialize-changelog\";\n+\n+  private static final String BAD_TOPIC_NAME\n+      = \"_confluent-ksql-default_node0_transient_bad\";\n+\n+  private static final String APP_ID_1\n+      = \"_confluent-ksql-default_transient_932097300573686369_1606940079718\";\n+  private static final String APP_ID_2\n+      = \"_confluent-ksql-default_transient_123497300573686369_1606940012345\";\n+\n+  @Mock\n+  private QueryCleanupService queryCleanupService;\n+  @Mock\n+  private ServiceContext serviceContext;\n+  @Mock\n+  private KafkaTopicClient topicClient;\n+  @Captor\n+  private ArgumentCaptor<QueryCleanupTask> taskCaptor;\n+\n+  private OrphanedTransientQueryCleaner cleaner;\n+\n+  @Before\n+  public void setUp() {\n+    when(serviceContext.getTopicClient()).thenReturn(topicClient);\n+    cleaner = new OrphanedTransientQueryCleaner(queryCleanupService);\n+  }\n+\n+  @Test\n+  public void shouldCleanup_allApplicationIds() {\n+    when(topicClient.listTopicNames()).thenReturn(ImmutableSet.of(TOPIC1, TOPIC2, TOPIC3));", "originalCommit": "a9a671b9a2201de213f794a849c71be56a3a4140", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg5MzcwMQ==", "url": "https://github.com/confluentinc/ksql/pull/6714#discussion_r538893701", "bodyText": "Done", "author": "AlanConfluent", "createdAt": "2020-12-08T23:42:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODgyNjY3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODgzODM1Mw==", "url": "https://github.com/confluentinc/ksql/pull/6714#discussion_r538838353", "bodyText": "do you think it makes sense to make this an interface with JsonSubTypes so that we can handle a union of lots of different types of LocalCommands (see ExecutionStep for example) or is that overkill?", "author": "agavra", "createdAt": "2020-12-08T21:58:35Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/LocalCommand.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.server;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+\n+/**\n+ * A command which is executed locally and possibly requiring cleanup next time the server is\n+ * restarted.\n+ */\n+public class LocalCommand {", "originalCommit": "a9a671b9a2201de213f794a849c71be56a3a4140", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg5ODI0Mg==", "url": "https://github.com/confluentinc/ksql/pull/6714#discussion_r538898242", "bodyText": "Yeah, that's probably a little nicer.  I'll introduce that.  I was debating how general to make this since I don't know how many things will take advantage of it.", "author": "AlanConfluent", "createdAt": "2020-12-08T23:53:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODgzODM1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODgzOTMyNQ==", "url": "https://github.com/confluentinc/ksql/pull/6714#discussion_r538839325", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  throw new KsqlServerException(\"Bad directory \" + directory.getAbsolutePath());\n          \n          \n            \n                  throw new KsqlServerException(\"Bad local commands directory \" + directory.getAbsolutePath() + \". Please check your configuration for \" + KsqlConfig.KSQL_LOCAL_COMMANDS_LOCATION_CONFIG);", "author": "agavra", "createdAt": "2020-12-08T22:00:13Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/LocalCommands.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.server;\n+\n+import io.confluent.ksql.engine.KsqlEngine;\n+import io.confluent.ksql.rest.server.LocalCommand.Type;\n+import io.confluent.ksql.services.ServiceContext;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlServerException;\n+import io.confluent.ksql.util.TransientQueryMetadata;\n+import java.io.Closeable;\n+import java.io.File;\n+import java.io.FilenameFilter;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Represents commands that are issued to this node only (therefore not written to the command\n+ * topic), and might require additional cleanup later.  An example is a transient query.\n+ * These commands are stored locally on disk so that we can do any cleanup required, next time\n+ * the server restarts. This is only appropriate for best effort tasks since the data isn't durable\n+ * (since a node might leave and never rejoin the cluster).\n+ */\n+public class LocalCommands implements Closeable {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(LocalCommands.class);\n+\n+  static final String LOCAL_COMMANDS_FILE_SUFFIX = \".cmds\";\n+  static final String LOCAL_COMMANDS_PROCESSED_SUFFIX = \".processed\";\n+  private static final Random RANDOM = new Random();\n+\n+  private final File directory;\n+  private final KsqlEngine ksqlEngine;\n+  private final LocalCommandsFile currentLocalCommands;\n+\n+  LocalCommands(\n+      final File directory,\n+      final KsqlEngine ksqlEngine,\n+      final LocalCommandsFile currentLocalCommands\n+  ) {\n+    this.directory = directory;\n+    this.ksqlEngine = ksqlEngine;\n+    this.currentLocalCommands = currentLocalCommands;\n+  }\n+\n+  public File getCurrentLocalCommandsFile() {\n+    return currentLocalCommands.getFile();\n+  }\n+\n+  public void processLocalCommandFiles(\n+      final ServiceContext serviceContext\n+  ) {\n+    final FilenameFilter filter = (dir, fileName) -> fileName.endsWith(LOCAL_COMMANDS_FILE_SUFFIX);\n+    final File[] files = directory.listFiles(filter);\n+    if (files == null) {\n+      throw new KsqlServerException(\"Bad directory \" + directory.getAbsolutePath());", "originalCommit": "a9a671b9a2201de213f794a849c71be56a3a4140", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg0MDk3NA==", "url": "https://github.com/confluentinc/ksql/pull/6714#discussion_r538840974", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  LOG.error(\"Failed to write local command\", e);\n          \n          \n            \n                  LOG.error(\"Failed to write local command for transient query:\" + queryMetadata.getQueryApplicationId(), e);", "author": "agavra", "createdAt": "2020-12-08T22:03:00Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/LocalCommands.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.server;\n+\n+import io.confluent.ksql.engine.KsqlEngine;\n+import io.confluent.ksql.rest.server.LocalCommand.Type;\n+import io.confluent.ksql.services.ServiceContext;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlServerException;\n+import io.confluent.ksql.util.TransientQueryMetadata;\n+import java.io.Closeable;\n+import java.io.File;\n+import java.io.FilenameFilter;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Represents commands that are issued to this node only (therefore not written to the command\n+ * topic), and might require additional cleanup later.  An example is a transient query.\n+ * These commands are stored locally on disk so that we can do any cleanup required, next time\n+ * the server restarts. This is only appropriate for best effort tasks since the data isn't durable\n+ * (since a node might leave and never rejoin the cluster).\n+ */\n+public class LocalCommands implements Closeable {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(LocalCommands.class);\n+\n+  static final String LOCAL_COMMANDS_FILE_SUFFIX = \".cmds\";\n+  static final String LOCAL_COMMANDS_PROCESSED_SUFFIX = \".processed\";\n+  private static final Random RANDOM = new Random();\n+\n+  private final File directory;\n+  private final KsqlEngine ksqlEngine;\n+  private final LocalCommandsFile currentLocalCommands;\n+\n+  LocalCommands(\n+      final File directory,\n+      final KsqlEngine ksqlEngine,\n+      final LocalCommandsFile currentLocalCommands\n+  ) {\n+    this.directory = directory;\n+    this.ksqlEngine = ksqlEngine;\n+    this.currentLocalCommands = currentLocalCommands;\n+  }\n+\n+  public File getCurrentLocalCommandsFile() {\n+    return currentLocalCommands.getFile();\n+  }\n+\n+  public void processLocalCommandFiles(\n+      final ServiceContext serviceContext\n+  ) {\n+    final FilenameFilter filter = (dir, fileName) -> fileName.endsWith(LOCAL_COMMANDS_FILE_SUFFIX);\n+    final File[] files = directory.listFiles(filter);\n+    if (files == null) {\n+      throw new KsqlServerException(\"Bad directory \" + directory.getAbsolutePath());\n+    }\n+    for (final File file : files) {\n+      if (file.equals(currentLocalCommands.getFile())) {\n+        continue;\n+      }\n+      try (LocalCommandsFile localCommandsFile = LocalCommandsFile.createReadonly(file)) {\n+        final List<LocalCommand> localCommands = localCommandsFile.readRecords();\n+        cleanUpTransientQueryState(localCommands, serviceContext);\n+\n+        markFileAsProcessed(file);\n+      } catch (Exception e) {\n+        LOG.error(\"Error processing local commands \" + file.getAbsolutePath(), e);\n+        throw new KsqlServerException(\"Error processing local commands\", e);\n+      }\n+    }\n+  }\n+\n+  public void write(final TransientQueryMetadata queryMetadata) {\n+    try {\n+      currentLocalCommands.write(\n+          new LocalCommand(Type.TRANSIENT_QUERY, queryMetadata.getQueryApplicationId()));\n+    } catch (IOException e) {\n+      // Just log an error since not catching it would likely cause more cleanup work than this\n+      // aims to fix.\n+      LOG.error(\"Failed to write local command\", e);", "originalCommit": "a9a671b9a2201de213f794a849c71be56a3a4140", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg0MTU2OA==", "url": "https://github.com/confluentinc/ksql/pull/6714#discussion_r538841568", "bodyText": "why not just delete the file? Do we every use these?", "author": "agavra", "createdAt": "2020-12-08T22:04:11Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/LocalCommands.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.server;\n+\n+import io.confluent.ksql.engine.KsqlEngine;\n+import io.confluent.ksql.rest.server.LocalCommand.Type;\n+import io.confluent.ksql.services.ServiceContext;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlServerException;\n+import io.confluent.ksql.util.TransientQueryMetadata;\n+import java.io.Closeable;\n+import java.io.File;\n+import java.io.FilenameFilter;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Represents commands that are issued to this node only (therefore not written to the command\n+ * topic), and might require additional cleanup later.  An example is a transient query.\n+ * These commands are stored locally on disk so that we can do any cleanup required, next time\n+ * the server restarts. This is only appropriate for best effort tasks since the data isn't durable\n+ * (since a node might leave and never rejoin the cluster).\n+ */\n+public class LocalCommands implements Closeable {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(LocalCommands.class);\n+\n+  static final String LOCAL_COMMANDS_FILE_SUFFIX = \".cmds\";\n+  static final String LOCAL_COMMANDS_PROCESSED_SUFFIX = \".processed\";\n+  private static final Random RANDOM = new Random();\n+\n+  private final File directory;\n+  private final KsqlEngine ksqlEngine;\n+  private final LocalCommandsFile currentLocalCommands;\n+\n+  LocalCommands(\n+      final File directory,\n+      final KsqlEngine ksqlEngine,\n+      final LocalCommandsFile currentLocalCommands\n+  ) {\n+    this.directory = directory;\n+    this.ksqlEngine = ksqlEngine;\n+    this.currentLocalCommands = currentLocalCommands;\n+  }\n+\n+  public File getCurrentLocalCommandsFile() {\n+    return currentLocalCommands.getFile();\n+  }\n+\n+  public void processLocalCommandFiles(\n+      final ServiceContext serviceContext\n+  ) {\n+    final FilenameFilter filter = (dir, fileName) -> fileName.endsWith(LOCAL_COMMANDS_FILE_SUFFIX);\n+    final File[] files = directory.listFiles(filter);\n+    if (files == null) {\n+      throw new KsqlServerException(\"Bad directory \" + directory.getAbsolutePath());\n+    }\n+    for (final File file : files) {\n+      if (file.equals(currentLocalCommands.getFile())) {\n+        continue;\n+      }\n+      try (LocalCommandsFile localCommandsFile = LocalCommandsFile.createReadonly(file)) {\n+        final List<LocalCommand> localCommands = localCommandsFile.readRecords();\n+        cleanUpTransientQueryState(localCommands, serviceContext);\n+\n+        markFileAsProcessed(file);\n+      } catch (Exception e) {\n+        LOG.error(\"Error processing local commands \" + file.getAbsolutePath(), e);\n+        throw new KsqlServerException(\"Error processing local commands\", e);\n+      }\n+    }\n+  }\n+\n+  public void write(final TransientQueryMetadata queryMetadata) {\n+    try {\n+      currentLocalCommands.write(\n+          new LocalCommand(Type.TRANSIENT_QUERY, queryMetadata.getQueryApplicationId()));\n+    } catch (IOException e) {\n+      // Just log an error since not catching it would likely cause more cleanup work than this\n+      // aims to fix.\n+      LOG.error(\"Failed to write local command\", e);\n+    }\n+  }\n+\n+  public static LocalCommands open(\n+      final KsqlEngine ksqlEngine,\n+      final File directory\n+  ) {\n+    if (!directory.exists()) {\n+      if (!directory.mkdirs()) {\n+        throw new KsqlServerException(\"Couldn't create the local commands directory: \"\n+            + directory.getPath()\n+            + \"\\n Make sure the directory exists and is readable/writable for KSQL server \"\n+            + \"\\n or its parent directory is readable/writable by KSQL server\"\n+            + \"\\n or change it to a readable/writable directory by setting '\"\n+            + KsqlRestConfig.KSQL_LOCAL_COMMANDS_LOCATION_CONFIG\n+            + \"' config in the properties file.\"\n+        );\n+      }\n+\n+      try {\n+        Files.setPosixFilePermissions(directory.toPath(),\n+            PosixFilePermissions.fromString(\"rwx------\"));\n+      } catch (final IOException e) {\n+        throw new KsqlServerException(String.format(\n+            \"Couldn't set POSIX permissions on the backups directory: %s. Error = %s\",\n+            directory.getPath(), e.getMessage()));\n+      }\n+    }\n+\n+    if (!directory.isDirectory()) {\n+      throw new KsqlServerException(directory.getPath()\n+          + \" is not a directory.\"\n+          + \"\\n Make sure the directory exists and is readable/writable for KSQL server \"\n+          + \"\\n or its parent directory is readable/writable by KSQL server\"\n+          + \"\\n or change it to a readable/writable directory by setting '\"\n+          + KsqlRestConfig.KSQL_LOCAL_COMMANDS_LOCATION_CONFIG\n+          + \"' config in the properties file.\"\n+      );\n+    }\n+\n+    if (!directory.canWrite() || !directory.canRead() || !directory.canExecute()) {\n+      throw new KsqlServerException(\"The local commands directory is not readable/writable \"\n+          + \"for KSQL server: \"\n+          + directory.getPath()\n+          + \"\\n Make sure the directory exists and is readable/writable for KSQL server \"\n+          + \"\\n or change it to a readable/writable directory by setting '\"\n+          + KsqlRestConfig.KSQL_LOCAL_COMMANDS_LOCATION_CONFIG\n+          + \"' config in the properties file.\"\n+      );\n+    }\n+    final File file = new File(directory, String.format(\"local_commands_%d_%s%s\",\n+        System.currentTimeMillis(), Integer.toHexString(RANDOM.nextInt()),\n+        LOCAL_COMMANDS_FILE_SUFFIX));\n+    return new LocalCommands(directory, ksqlEngine, LocalCommandsFile.createWriteable(file));\n+  }\n+\n+  private void markFileAsProcessed(final File file) {", "originalCommit": "a9a671b9a2201de213f794a849c71be56a3a4140", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg0MzQyNQ==", "url": "https://github.com/confluentinc/ksql/pull/6714#discussion_r538843425", "bodyText": "just making sure, this writes it in UTF8 so it's human readable json, right? I think it would be nice to make these files human readble", "author": "agavra", "createdAt": "2020-12-08T22:07:06Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/LocalCommandsFile.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.server;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.confluent.ksql.util.KsqlException;\n+import java.io.Closeable;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * Represents a single file of commands issued to this node.\n+ */\n+public final class LocalCommandsFile  implements Closeable {\n+\n+  private static final ObjectMapper MAPPER = new ObjectMapper();\n+  private static final byte[] NEW_LINE_SEPARATOR_BYTES =\n+      \"\\n\".getBytes(StandardCharsets.UTF_8);\n+\n+\n+  private final File file;\n+  private final FileOutputStream writer;\n+\n+  private LocalCommandsFile(final File file, final boolean write) {\n+    this.file = Objects.requireNonNull(file, \"file\");\n+\n+    if (write) {\n+      this.writer = createWriter(file);\n+    } else {\n+      this.writer = null;\n+    }\n+  }\n+\n+  public static LocalCommandsFile createReadonly(final File file) {\n+    return new LocalCommandsFile(file, false);\n+  }\n+\n+  public static LocalCommandsFile createWriteable(final File file) {\n+    return new LocalCommandsFile(file, true);\n+  }\n+\n+  public void write(final LocalCommand localCommand) throws IOException {\n+    if (writer == null) {\n+      throw new IOException(\"Write permission denied.\");\n+    }\n+\n+    final byte[] bytes = MAPPER.writeValueAsBytes(localCommand);", "originalCommit": "a9a671b9a2201de213f794a849c71be56a3a4140", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkyMTQ5OQ==", "url": "https://github.com/confluentinc/ksql/pull/6714#discussion_r538921499", "bodyText": "Yep, it's UTF8: https://fasterxml.github.io/jackson-databind/javadoc/2.7/com/fasterxml/jackson/databind/ObjectMapper.html#writeValueAsBytes(java.lang.Object)", "author": "AlanConfluent", "createdAt": "2020-12-09T00:53:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg0MzQyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg0NjU4MA==", "url": "https://github.com/confluentinc/ksql/pull/6714#discussion_r538846580", "bodyText": "since the file is only relevant on a new startup, does it need to be added to the cleanup service or can we just have it do this cleanup on startup?", "author": "agavra", "createdAt": "2020-12-08T22:12:45Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/OrphanedTransientQueryCleaner.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.engine;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import io.confluent.ksql.exception.KafkaResponseGetFailedException;\n+import io.confluent.ksql.services.KafkaTopicClient;\n+import io.confluent.ksql.services.ServiceContext;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class OrphanedTransientQueryCleaner {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(OrphanedTransientQueryCleaner.class);\n+\n+  private final QueryCleanupService cleanupService;\n+\n+  public OrphanedTransientQueryCleaner(final QueryCleanupService cleanupService) {\n+    this.cleanupService = requireNonNull(cleanupService);\n+  }\n+\n+  public void cleanupOrphanedInternalTopics(\n+      final ServiceContext serviceContext,\n+      final Set<String> queryApplicationIds\n+  ) {\n+    final KafkaTopicClient topicClient = serviceContext.getTopicClient();\n+    final Set<String> topicNames;\n+    try {\n+      topicNames = topicClient.listTopicNames();\n+    } catch (KafkaResponseGetFailedException e) {\n+      LOG.error(\"Couldn't fetch topic names\", e);\n+      return;\n+    }\n+    // Find any transient query topics\n+    final Set<String> orphanedQueryApplicationIds = topicNames.stream()\n+        .map(topicName -> queryApplicationIds.stream().filter(topicName::startsWith).findFirst())\n+        .filter(Optional::isPresent)\n+        .map(Optional::get)\n+        .collect(Collectors.toSet());\n+    for (final String queryApplicationId : orphanedQueryApplicationIds) {\n+      cleanupService.addCleanupTask(", "originalCommit": "a9a671b9a2201de213f794a849c71be56a3a4140", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODkyMjI0NQ==", "url": "https://github.com/confluentinc/ksql/pull/6714#discussion_r538922245", "bodyText": "We chatted about this offline.  This takes advantage of the other cleanup routines done by QueryCleanupService, so needs access to it.  It does this cleanup once on startup", "author": "AlanConfluent", "createdAt": "2020-12-09T00:55:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODg0NjU4MA=="}], "type": "inlineReview"}, {"oid": "92cb46260af8aa1c717991f2eb9bdef3a2263250", "url": "https://github.com/confluentinc/ksql/commit/92cb46260af8aa1c717991f2eb9bdef3a2263250", "message": "Apply suggestions from code review\n\nCo-authored-by: Almog Gavra <almog@confluent.io>", "committedDate": "2020-12-09T00:41:29Z", "type": "commit"}, {"oid": "4c89d54c78e11a59a640dd7dbb29de933102bba9", "url": "https://github.com/confluentinc/ksql/commit/4c89d54c78e11a59a640dd7dbb29de933102bba9", "message": "Apply suggestions from code review\n\nCo-authored-by: Almog Gavra <almog@confluent.io>", "committedDate": "2020-12-09T00:56:42Z", "type": "commit"}, {"oid": "1f73ce512c63df7f61c8d7941014a9c40b23a158", "url": "https://github.com/confluentinc/ksql/commit/1f73ce512c63df7f61c8d7941014a9c40b23a158", "message": "Feedback", "committedDate": "2020-12-09T01:09:56Z", "type": "commit"}, {"oid": "484484a4a0246e9570697b74b0b6319649f848c7", "url": "https://github.com/confluentinc/ksql/commit/484484a4a0246e9570697b74b0b6319649f848c7", "message": "Removes redundant type field", "committedDate": "2020-12-10T22:24:05Z", "type": "commit"}]}