{"pr_number": 6462, "pr_title": "feat: cli to show tombstones in transient query output", "pr_createdAt": "2020-10-19T16:13:31Z", "pr_url": "https://github.com/confluentinc/ksql/pull/6462", "timeline": [{"oid": "4462a6dc52b120b88da2fd5e59a05e9caa2b664f", "url": "https://github.com/confluentinc/ksql/commit/4462a6dc52b120b88da2fd5e59a05e9caa2b664f", "message": "feat: cli to show tombstones in transient query output\n\nfixes: https://github.com/confluentinc/ksql/issues/3616\n\nThe output from transient queries that return tables will now include tombstones when run in the CLI or using the REST API directly.\n\nTombstones indicate an existing row has been deleted.\n\nCLI output now looks like:\n\n```\nksql> SELECT * FROM SOME_TABLE EMIT CHANGES;\n\n|  ID   |   COL0      |   COL1      |\n+-------+-------------+-------------+\n| 10    | A           | B           |\n| 20    | E           | F           |\n| 10    | <TOMBSTONE> | <TOMBSTONE> | <-- previous row '10' has been deleted.\n| 11    | X           | Y           |\n```\n\nTo facilitate this, the response from the rest api needed to change.  The query response includes a single `header`, followed by `row`'s of data. Previously, this looked like:\n\n```\n{\"header\":{\"queryId\":\"X\",\"schema\":\"`ID` BIGINT, `COL0` STRING, `COL1` STRING\"}},\n{\"row\":{\"columns\":[10,A,B]}},\n{\"row\":{\"columns\":[20,E,F]}},\n{\"row\":{\"columns\":[11,X,Y]}},\n```\n\nFor queries returning table rows, the result now looks like:\n\n```\n{\"header\":{\"queryId\":\"X\",\"key\":\"`ID` BIGINT\",\"schema\":\"`ID` BIGINT, `COL0` STRING, `COL1` STRING\"}},\n{\"row\":{\"key\":[10],\"columns\":[10,A,B]}},\n{\"row\":{\"key\":[20],\"columns\":[20,E,F]}},\n{\"row\":{\"key\":[10],\"tombstone\":true}},\n{\"row\":{\"key\":[11],\"columns\":[11,X,Y]}}\n```\n\nNote the addition of:\n* the `key` field in the `header`: this provides the schema of the primary key of the table,\n* the `key` field in each `row`: this provides the primary key of the row\n* the `tombstone` field of `row`. This is only set when the row is a tombstone.\n\nNote, it is possible that the query itself does not return the columns that make up the primary key of the table:\n\n```\nksql> SELECT COL0, COL1 FROM SOME_TABLE EMIT CHANGES;\n\n|   COL0      |   COL1      |\n+-------------+-------------+\n| A           | B           |\n| E           | F           |\n| <TOMBSTONE> | <TOMBSTONE> | <-- previous row deleted\n| X           | Y           |\n```\n\nThough of course, without including the key columns in the projection, its hard to tell which row has been deleted.\n\nThe API response would look like:\n\n```\n{\"header\":{\"queryId\":\"X\",\"key\":\"`ID` BIGINT\",\"schema\":\"`COL0` STRING, `COL1` STRING\"}},\n{\"row\":{\"key\":[10],\"columns\":[A,B]}},\n{\"row\":{\"key\":[20],\"columns\":[E,F]}},\n{\"row\":{\"key\":[10],\"tombstone\":true}},\n{\"row\":{\"key\":[11],\"columns\":[X,Y]}}\n```\n\nAs the change may break users of the API, the media type version has been bumped:\n\n* `application/vnd.ksql.v1+json`: works as before. No `key` or `tombstone` fields. Tombstones filters from output.\n* `application/vnd.ksql.v2+json`: new, and the new default, contains new fields and includes tombstones.\n\nUsers are recommended to use the version specific media types. Anyone using `application/json` will see a change in the response content.", "committedDate": "2020-10-19T16:12:51Z", "type": "commit"}, {"oid": "0bb5d6a63c0252afa5ef03f17f14c479d11138a8", "url": "https://github.com/confluentinc/ksql/commit/0bb5d6a63c0252afa5ef03f17f14c479d11138a8", "message": "chore: merge from master\n\nConflicting files\nksqldb-engine/src/main/java/io/confluent/ksql/query/QueryExecutor.java", "committedDate": "2020-10-19T16:19:53Z", "type": "commit"}, {"oid": "608e3b754ad2978d9e28dd15411412c0ab990425", "url": "https://github.com/confluentinc/ksql/commit/608e3b754ad2978d9e28dd15411412c0ab990425", "message": "test: include missing test update", "committedDate": "2020-10-19T16:29:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI0NTExMw==", "url": "https://github.com/confluentinc/ksql/pull/6462#discussion_r508245113", "bodyText": "Why not directly return boolean?", "author": "vcrfxia", "createdAt": "2020-10-20T06:41:43Z", "path": "ksqldb-rest-model/src/main/java/io/confluent/ksql/rest/entity/StreamedRow.java", "diffHunk": "@@ -218,21 +368,80 @@ public boolean equals(final Object o) {\n       }\n       final Header header = (Header) o;\n       return Objects.equals(queryId, header.queryId)\n-          && Objects.equals(schema, header.schema);\n+          && Objects.equals(keySchema, header.keySchema)\n+          && Objects.equals(columnsSchema, header.columnsSchema);\n     }\n \n     @Override\n     public int hashCode() {\n-      return Objects.hash(queryId, schema);\n+      return Objects.hash(queryId, keySchema, columnsSchema);\n+    }\n+  }\n+\n+  @JsonInclude(Include.NON_EMPTY)\n+  @JsonIgnoreProperties(ignoreUnknown = true)\n+  public static final class DataRow extends BaseRow {\n+\n+    @EffectivelyImmutable\n+    private final Optional<List<?>> key;\n+    @EffectivelyImmutable\n+    private final Optional<List<?>> columns;\n+\n+    public static DataRow row(\n+        final Optional<List<?>> key,\n+        final List<?> columns\n+    ) {\n+      return new DataRow(key, Optional.of(columns));\n+    }\n+\n+    public static DataRow tombstone(\n+        final List<?> key\n+    ) {\n+      return new DataRow(Optional.of(key), Optional.empty());\n+    }\n+\n+\n+    public Optional<List<?>> getKey() {\n+      return key;\n+    }\n+\n+    public Optional<List<?>> getColumns() {\n+      return columns;\n+    }\n+\n+    public Optional<Boolean> getTombstone() {", "originalCommit": "0bb5d6a63c0252afa5ef03f17f14c479d11138a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc1NjcyOA==", "url": "https://github.com/confluentinc/ksql/pull/6462#discussion_r508756728", "bodyText": "This is about getting the JSON right. In this case we only want the tombstone in the JSON if its a tombstone row.  Returning Optional.empty means its excluded from the JSON.", "author": "big-andy-coates", "createdAt": "2020-10-20T18:41:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI0NTExMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAwOTM5Mg==", "url": "https://github.com/confluentinc/ksql/pull/6462#discussion_r511009392", "bodyText": "I think there are better ways of achieving this than using optionals, which seems a little error prone and confusing. For example JsonInclude.Include.NON_DEFAULT can be used to omit the serialization of false.", "author": "agavra", "createdAt": "2020-10-23T16:43:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI0NTExMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI0NTQ4NA==", "url": "https://github.com/confluentinc/ksql/pull/6462#discussion_r508245484", "bodyText": "Looks like something was meant to be here but was forgotten. Perhaps check that <TOMBSTONE> is present?", "author": "vcrfxia", "createdAt": "2020-10-20T06:42:31Z", "path": "ksqldb-cli/src/test/java/io/confluent/ksql/cli/console/ConsoleTest.java", "diffHunk": "@@ -187,24 +187,58 @@ public void after() {\n   }\n \n   @Test\n-  public void testPrintGenericStreamedRow() {\n+  public void testPrintStreamRow() {\n     // Given:\n-    final StreamedRow row = StreamedRow.row(genericRow(\"col_1\", \"col_2\"));\n+    final StreamedRow row = StreamedRow.streamRow(genericRow(\"col_1\", \"col_2\"));\n \n     // When:\n     console.printStreamedRow(row);\n \n     // Then:\n+    assertThat(terminal.getOutputString(), containsString(\"col_1\"));\n+    assertThat(terminal.getOutputString(), containsString(\"col_2\"));\n+  }\n+\n+  @Test\n+  public void testPrintTableRow() {\n+    // Given:\n+    final StreamedRow row = StreamedRow.tableRow(ImmutableList.of(\"k_0\"), genericRow(\"col_1\", \"col_2\"));\n+\n+    // When:\n+    console.printStreamedRow(row);\n+\n+    // Then:\n+    if (console.getOutputFormat() != OutputFormat.TABULAR) {\n+      assertThat(terminal.getOutputString(), containsString(\"k_0\"));\n+    }\n+    assertThat(terminal.getOutputString(), containsString(\"col_1\"));\n+    assertThat(terminal.getOutputString(), containsString(\"col_2\"));\n+  }\n+\n+  @Test\n+  public void testPrintTableTombstone() {\n+    // Given:\n+    console.printStreamedRow(StreamedRow.pushHeader(new QueryId(\"id\"), SCHEMA.key(), SCHEMA.value()));\n+\n+    final StreamedRow row = StreamedRow.tombstone(ImmutableList.of(\"k_0\"));\n+\n+    // When:\n+    console.printStreamedRow(row);\n+\n+    // Then:\n+    assertThat(terminal.getOutputString(), containsString(\"k_0\"));\n+\n     if (console.getOutputFormat() == OutputFormat.TABULAR) {\n-      assertThat(terminal.getOutputString(), containsString(\"col_1\"));\n-      assertThat(terminal.getOutputString(), containsString(\"col_2\"));\n+", "originalCommit": "0bb5d6a63c0252afa5ef03f17f14c479d11138a8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI0NTg2NA==", "url": "https://github.com/confluentinc/ksql/pull/6462#discussion_r508245864", "bodyText": "To check my understanding: the reason this PR adds window info into the output node is so the window info can be printed as part of the key?", "author": "vcrfxia", "createdAt": "2020-10-20T06:43:23Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/KsqlBareOutputNode.java", "diffHunk": "@@ -15,25 +15,32 @@\n \n package io.confluent.ksql.planner.plan;\n \n+import static java.util.Objects.requireNonNull;\n+\n import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n import io.confluent.ksql.execution.timestamp.TimestampColumn;\n import io.confluent.ksql.name.SourceName;\n import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.serde.WindowInfo;\n import io.confluent.ksql.structured.SchemaKStream;\n import java.util.Optional;\n import java.util.OptionalInt;\n \n @SuppressWarnings(\"OptionalUsedAsFieldOrParameterType\")\n public class KsqlBareOutputNode extends OutputNode {\n \n+  private final Optional<WindowInfo> windowInfo;\n+\n   public KsqlBareOutputNode(\n       final PlanNodeId id,\n       final PlanNode source,\n       final LogicalSchema schema,\n       final OptionalInt limit,\n-      final Optional<TimestampColumn> timestampColumn\n+      final Optional<TimestampColumn> timestampColumn,\n+      final Optional<WindowInfo> windowInfo", "originalCommit": "0bb5d6a63c0252afa5ef03f17f14c479d11138a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc1NzY5NQ==", "url": "https://github.com/confluentinc/ksql/pull/6462#discussion_r508757695", "bodyText": "It's needed so that the key schema, returned at the start of a push query, can include the window bounds columns for windowed results.", "author": "big-andy-coates", "createdAt": "2020-10-20T18:42:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI0NTg2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI0NTk3MQ==", "url": "https://github.com/confluentinc/ksql/pull/6462#discussion_r508245971", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  throw new IllegalArgumentException(\"None struct key: \" + key);\n          \n          \n            \n                  throw new IllegalArgumentException(\"Non struct key: \" + key);", "author": "vcrfxia", "createdAt": "2020-10-20T06:43:37Z", "path": "ksqldb-execution/src/main/java/io/confluent/ksql/execution/util/StructKeyUtil.java", "diffHunk": "@@ -55,6 +58,40 @@ public static KeyBuilder keyBuilder(final ColumnName name, final SqlType type) {\n     );\n   }\n \n+  @SuppressWarnings(\"unchecked\")\n+  public static List<?> asList(final Object key) {\n+    final Optional<Windowed<Object>> windowed = key instanceof Windowed\n+        ? Optional.of((Windowed<Object>) key)\n+        : Optional.empty();\n+\n+    final Object naturalKey = windowed\n+        .map(Windowed::key)\n+        .orElse(key);\n+\n+    if (naturalKey != null && !(naturalKey instanceof Struct)) {\n+      throw new IllegalArgumentException(\"None struct key: \" + key);", "originalCommit": "0bb5d6a63c0252afa5ef03f17f14c479d11138a8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI0NjgwMw==", "url": "https://github.com/confluentinc/ksql/pull/6462#discussion_r508246803", "bodyText": "How come we use List<?> for the key type and GenericRow for the value type throughout this PR? Isn't GenericRow essentially just a wrapper around List<?>? Wondering what motivates the inconsistency here.", "author": "vcrfxia", "createdAt": "2020-10-20T06:45:15Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/api/spi/QueryPublisher.java", "diffHunk": "@@ -24,7 +25,7 @@\n  * query that is executed. A subscriber from the API implementation then subscribes to it, then a\n  * stream of query results flows from back-end to front-end where they are written to the wire.\n  */\n-public interface QueryPublisher extends Publisher<GenericRow> {\n+public interface QueryPublisher extends Publisher<KeyValue<List<?>, GenericRow>> {", "originalCommit": "0bb5d6a63c0252afa5ef03f17f14c479d11138a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc2MTMwMw==", "url": "https://github.com/confluentinc/ksql/pull/6462#discussion_r508761303", "bodyText": "Not sure I follow...\nI you suggesting we should have KeyValue<GenericRow, GenericRow>?  That would obviously be wrong, as the key shouldn't be represented by GenericRow.\nOr maybe KeyValue<List<?>, List<?>>?  We could do this, but that's changing more code.  The PR just adds the key, (which is just a list of values), and leaves the value as it was.   We could switch the GenericRow to List<?>, but... out of scope...", "author": "big-andy-coates", "createdAt": "2020-10-20T18:46:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI0NjgwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc3MjU2OA==", "url": "https://github.com/confluentinc/ksql/pull/6462#discussion_r508772568", "bodyText": "I think I see the difference now... while it's true that GenericRow essentially just wraps List<?>, the interpretation of the list elements in GenericRow is that each element represents a column, which is a dubious interpretation for the key since today the key is either a single column or three columns (single, primary column plus window start and end). Is that the reason you say KeyValue<GenericRow, GenericRow> would be incorrect?", "author": "vcrfxia", "createdAt": "2020-10-20T19:06:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI0NjgwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI0NjkzNw==", "url": "https://github.com/confluentinc/ksql/pull/6462#discussion_r508246937", "bodyText": "nit: can we rename this to something more meaningful?", "author": "vcrfxia", "createdAt": "2020-10-20T06:45:32Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/QueryStreamWriter.java", "diffHunk": "@@ -54,11 +61,13 @@\n       final TransientQueryMetadata queryMetadata,\n       final long disconnectCheckInterval,\n       final ObjectMapper objectMapper,\n-      final CompletableFuture<Void> connectionClosedFuture\n+      final CompletableFuture<Void> connectionClosedFuture,\n+      final boolean oldFormat", "originalCommit": "0bb5d6a63c0252afa5ef03f17f14c479d11138a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc2MTQ1MA==", "url": "https://github.com/confluentinc/ksql/pull/6462#discussion_r508761450", "bodyText": "suggestions?", "author": "big-andy-coates", "createdAt": "2020-10-20T18:47:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI0NjkzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc2NzAyNw==", "url": "https://github.com/confluentinc/ksql/pull/6462#discussion_r508767027", "bodyText": "Gone with v1Format. Not sure it's any better.", "author": "big-andy-coates", "createdAt": "2020-10-20T18:57:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI0NjkzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc3MzU5NQ==", "url": "https://github.com/confluentinc/ksql/pull/6462#discussion_r508773595", "bodyText": "Definitely better. Thanks!", "author": "vcrfxia", "createdAt": "2020-10-20T19:08:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI0NjkzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI0NzQ5NQ==", "url": "https://github.com/confluentinc/ksql/pull/6462#discussion_r508247495", "bodyText": "I'm a bit confused about what media types are accepted for the websocket endpoint. Is only v1 accepted, or is v2 also accepted but v2 functions the same as v1? I thought the former but I don't see any check here to fail on v2.", "author": "vcrfxia", "createdAt": "2020-10-20T06:46:46Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/WSQueryEndpoint.java", "diffHunk": "@@ -217,16 +217,16 @@ public void executeStreamQuery(final ServerWebSocket webSocket, final MultiMap r\n     }\n   }\n \n-  private void validateVersion(final MultiMap requestParams) {\n-\n-    final String version = requestParams.get(Versions.KSQL_V1_WS_PARAM);\n-\n+  private static void validateVersion(final MultiMap requestParams) {\n+    final String version = requestParams.get(\"version\");\n     if (version == null) {\n       return;\n     }\n \n-    if (!Versions.KSQL_V1_WS.equals(version)) {\n-      throw new IllegalArgumentException(\"Received invalid api version: \" + version);\n+    try {\n+      KsqlMediaType.valueOf(\"JSON\", Integer.parseInt(version));", "originalCommit": "0bb5d6a63c0252afa5ef03f17f14c479d11138a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc2MjM0Ng==", "url": "https://github.com/confluentinc/ksql/pull/6462#discussion_r508762346", "bodyText": "I'm a bit confused about what media types are accepted for the websocket endpoint.\n\nThis is defined in ServerVerticle: currently only V1.   #6439 will add V2.\n\nalso accepted but v2 functions the same as v1?\n\nYou've lost me...", "author": "big-andy-coates", "createdAt": "2020-10-20T18:48:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI0NzQ5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI0NzkwOA==", "url": "https://github.com/confluentinc/ksql/pull/6462#discussion_r508247908", "bodyText": "Read this a few times but I'm still not understanding this comment. (The two lines below make sense but I can't parse Type used Logical Schema to serialize key columns. in a meaningful way.)", "author": "vcrfxia", "createdAt": "2020-10-20T06:47:43Z", "path": "ksqldb-rest-model/src/main/java/io/confluent/ksql/rest/entity/StreamedRow.java", "diffHunk": "@@ -181,31 +269,93 @@ private static void checkUnion(final Optional<?>... fs) {\n   }\n \n   @Immutable\n+  public abstract static class BaseRow {\n+\n+    @Override\n+    public String toString() {\n+      try {\n+        return OBJECT_MAPPER.writeValueAsString(this);\n+      } catch (final JsonProcessingException e) {\n+        return super.toString();\n+      }\n+    }\n+  }\n+\n+  // Note: Type used `LogicalSchema` as a cheeky way of (de)serializing lists of columns.\n+  @JsonInclude(Include.NON_EMPTY)\n   @JsonIgnoreProperties(ignoreUnknown = true)\n-  public static final class Header {\n+  public static final class Header extends BaseRow {\n \n     private final QueryId queryId;\n-    private final LogicalSchema schema;\n+    private final Optional<ImmutableList<SimpleColumn>> keySchema;\n+    private final LogicalSchema columnsSchema;\n \n-    @JsonCreator\n     public static Header of(\n-        @JsonProperty(value = \"queryId\", required = true) final QueryId queryId,\n-        @JsonProperty(value = \"schema\", required = true) final LogicalSchema schema\n+        final QueryId queryId,\n+        final Optional<List<? extends SimpleColumn>> key,\n+        final LogicalSchema columnsSchema\n     ) {\n-      return new Header(queryId, schema);\n+      final Optional<List<? extends SimpleColumn>> keySchema = key\n+          .map(k -> LogicalSchema.builder().valueColumns(k).build())\n+          .map(LogicalSchema::columns);\n+\n+      return new Header(queryId, keySchema, columnsSchema);\n     }\n \n     public QueryId getQueryId() {\n       return queryId;\n     }\n \n-    public LogicalSchema getSchema() {\n-      return schema;\n+    /**\n+     * Used for push queries to return the schema of the key columns.\n+     *\n+     * <p>Note: The columns that make up the key may or may not be present in the projection, i.e.\n+     * in the {@link #getColumnsSchema()}.\n+     *\n+     * @return the columns that make up the key.\n+     */\n+    @JsonIgnore\n+    public Optional<List<SimpleColumn>> getKeySchema() {\n+      return keySchema.map(v -> v);\n     }\n \n-    private Header(final QueryId queryId, final LogicalSchema schema) {\n+    /**\n+     * @return The schema of the columns being returned by the query.\n+     */\n+    @JsonProperty(\"schema\")\n+    public LogicalSchema getColumnsSchema() {\n+      return columnsSchema;\n+    }\n+\n+    @JsonProperty(\"key\")\n+    @SuppressWarnings(\"unused\") // Invoked by reflection by Jackson.\n+    private Optional<LogicalSchema> getSerializedKeySchema() {\n+      // Type used Logical Schema to serialize key columns.", "originalCommit": "0bb5d6a63c0252afa5ef03f17f14c479d11138a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc2MjU0Mg==", "url": "https://github.com/confluentinc/ksql/pull/6462#discussion_r508762542", "bodyText": "I'll update.", "author": "big-andy-coates", "createdAt": "2020-10-20T18:49:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI0NzkwOA=="}], "type": "inlineReview"}, {"oid": "24c4ece73fe53957ef2dc5e7d596e7c252fdbe83", "url": "https://github.com/confluentinc/ksql/commit/24c4ece73fe53957ef2dc5e7d596e7c252fdbe83", "message": "Update docs/developer-guide/ksqldb-rest-api/query-endpoint.md\n\nCo-authored-by: Jim Galasyn <jim.galasyn@confluent.io>", "committedDate": "2020-10-20T18:50:27Z", "type": "commit"}, {"oid": "f24146939275086b2f78b5c6231bdf382017fcea", "url": "https://github.com/confluentinc/ksql/commit/f24146939275086b2f78b5c6231bdf382017fcea", "message": "Update docs/developer-guide/ksqldb-rest-api/query-endpoint.md\n\nCo-authored-by: Jim Galasyn <jim.galasyn@confluent.io>", "committedDate": "2020-10-20T18:50:35Z", "type": "commit"}, {"oid": "3742c2208f8d3f965c7edbe4e3af25f76267feed", "url": "https://github.com/confluentinc/ksql/commit/3742c2208f8d3f965c7edbe4e3af25f76267feed", "message": "Update docs/developer-guide/ksqldb-rest-api/query-endpoint.md\n\nCo-authored-by: Jim Galasyn <jim.galasyn@confluent.io>", "committedDate": "2020-10-20T18:50:42Z", "type": "commit"}, {"oid": "3736e68120032abedcc2dac49fd2488e7da658f7", "url": "https://github.com/confluentinc/ksql/commit/3736e68120032abedcc2dac49fd2488e7da658f7", "message": "Update docs/developer-guide/ksqldb-rest-api/query-endpoint.md\n\nCo-authored-by: Jim Galasyn <jim.galasyn@confluent.io>", "committedDate": "2020-10-20T18:50:49Z", "type": "commit"}, {"oid": "1fc7b6426546f6a9e52976679eab86987f0ec0fc", "url": "https://github.com/confluentinc/ksql/commit/1fc7b6426546f6a9e52976679eab86987f0ec0fc", "message": "Update docs/developer-guide/ksqldb-rest-api/query-endpoint.md\n\nCo-authored-by: Jim Galasyn <jim.galasyn@confluent.io>", "committedDate": "2020-10-20T18:50:56Z", "type": "commit"}, {"oid": "cb7bd501431930bfc429fbee0702b931edeb9ee1", "url": "https://github.com/confluentinc/ksql/commit/cb7bd501431930bfc429fbee0702b931edeb9ee1", "message": "Merge branch 'cli_tombstones' of github.com:big-andy-coates/ksql into cli_tombstones", "committedDate": "2020-10-20T18:51:59Z", "type": "commit"}, {"oid": "0d8600b05bb8016992104ded0a17f9d53925a36c", "url": "https://github.com/confluentinc/ksql/commit/0d8600b05bb8016992104ded0a17f9d53925a36c", "message": "chore: merge from master\n\nConflicting files\nksqldb-engine/src/test/java/io/confluent/ksql/util/TestDataProvider.java\nksqldb-rest-app/src/test/java/io/confluent/ksql/rest/integration/RestIntegrationTestUtil.java", "committedDate": "2020-10-20T18:59:32Z", "type": "commit"}, {"oid": "fcd2eeb76427d8de6015e6953b334106519af02a", "url": "https://github.com/confluentinc/ksql/commit/fcd2eeb76427d8de6015e6953b334106519af02a", "message": "chore: switch approach", "committedDate": "2020-10-23T14:20:03Z", "type": "commit"}, {"oid": "5f83e2d6985c9e0bc6f7a2d76d3fd29c59fdf063", "url": "https://github.com/confluentinc/ksql/commit/5f83e2d6985c9e0bc6f7a2d76d3fd29c59fdf063", "message": "chore: merge from master\n\nConflicting files\nksqldb-rest-app/src/main/java/io/confluent/ksql/api/server/ServerVerticle.java\nksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/PullQueryPublisher.java\nksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/StreamedQueryResource.java\nksqldb-rest-app/src/test/java/io/confluent/ksql/rest/integration/RestApiTest.java", "committedDate": "2020-10-23T14:30:06Z", "type": "commit"}, {"oid": "02e253da6cf96f749f948c48660dad99994eb315", "url": "https://github.com/confluentinc/ksql/commit/02e253da6cf96f749f948c48660dad99994eb315", "message": "chore: revert some noise and fix some things", "committedDate": "2020-10-23T14:58:48Z", "type": "commit"}, {"oid": "a2579a03f81538e327e2763bd62910359ee73965", "url": "https://github.com/confluentinc/ksql/commit/a2579a03f81538e327e2763bd62910359ee73965", "message": "chore: fix some tests", "committedDate": "2020-10-23T15:52:45Z", "type": "commit"}, {"oid": "df87e14ffdf1ad9055afe403ae5bb1a48e78d6a7", "url": "https://github.com/confluentinc/ksql/commit/df87e14ffdf1ad9055afe403ae5bb1a48e78d6a7", "message": "chore: fix some tests", "committedDate": "2020-10-23T16:46:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTcyMTMwNQ==", "url": "https://github.com/confluentinc/ksql/pull/6462#discussion_r511721305", "bodyText": "This comment is out of date.", "author": "vcrfxia", "createdAt": "2020-10-26T05:04:36Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/api/server/ServerVerticle.java", "diffHunk": "@@ -147,62 +148,63 @@ private Router setupRouter() {\n     // ----------------------------------------------\n \n     router.route(HttpMethod.GET, \"/\")\n-        .handler(this::handleInfoRedirect);\n+        .handler(ServerVerticle::handleInfoRedirect);\n     router.route(HttpMethod.POST, \"/ksql\")\n         .handler(BodyHandler.create())\n-        .produces(Versions.KSQL_V1_JSON)\n+        .produces(KsqlMediaType.KSQL_V1_JSON.mediaType())\n         .produces(JSON_CONTENT_TYPE)\n         .handler(this::handleKsqlRequest);\n     router.route(HttpMethod.POST, \"/ksql/terminate\")\n         .handler(BodyHandler.create())\n-        .produces(Versions.KSQL_V1_JSON)\n+        .produces(KsqlMediaType.KSQL_V1_JSON.mediaType())\n         .produces(JSON_CONTENT_TYPE)\n         .handler(this::handleTerminateRequest);\n     router.route(HttpMethod.POST, \"/query\")\n         .handler(BodyHandler.create())\n-        .produces(Versions.KSQL_V1_JSON)\n+        .produces(KsqlMediaType.KSQL_V1_JSON.mediaType())\n         .produces(JSON_CONTENT_TYPE)\n         .handler(this::handleQueryRequest);\n     router.route(HttpMethod.GET, \"/info\")\n-        .produces(Versions.KSQL_V1_JSON)\n+        .produces(KsqlMediaType.KSQL_V1_JSON.mediaType())\n         .produces(JSON_CONTENT_TYPE)\n         .handler(this::handleInfoRequest);\n     router.route(HttpMethod.POST, \"/heartbeat\")\n         .handler(BodyHandler.create())\n-        .produces(Versions.KSQL_V1_JSON)\n+        .produces(KsqlMediaType.KSQL_V1_JSON.mediaType())\n         .produces(JSON_CONTENT_TYPE)\n         .handler(this::handleHeartbeatRequest);\n     router.route(HttpMethod.GET, \"/clusterStatus\")\n-        .produces(Versions.KSQL_V1_JSON)\n+        .produces(KsqlMediaType.KSQL_V1_JSON.mediaType())\n         .produces(JSON_CONTENT_TYPE)\n         .handler(this::handleClusterStatusRequest);\n     router.route(HttpMethod.GET, \"/status/:type/:entity/:action\")\n-        .produces(Versions.KSQL_V1_JSON)\n+        .produces(KsqlMediaType.KSQL_V1_JSON.mediaType())\n         .produces(JSON_CONTENT_TYPE)\n         .handler(this::handleStatusRequest);\n     router.route(HttpMethod.GET, \"/status\")\n-        .produces(Versions.KSQL_V1_JSON)\n+        .produces(KsqlMediaType.KSQL_V1_JSON.mediaType())\n         .produces(JSON_CONTENT_TYPE)\n         .handler(this::handleAllStatusesRequest);\n     router.route(HttpMethod.POST, \"/lag\")\n         .handler(BodyHandler.create())\n-        .produces(Versions.KSQL_V1_JSON)\n+        .produces(KsqlMediaType.KSQL_V1_JSON.mediaType())\n         .produces(JSON_CONTENT_TYPE)\n         .handler(this::handleLagReportRequest);\n     router.route(HttpMethod.GET, \"/healthcheck\")\n-        .produces(Versions.KSQL_V1_JSON)\n+        .produces(KsqlMediaType.KSQL_V1_JSON.mediaType())\n         .produces(JSON_CONTENT_TYPE)\n         .handler(this::handleHealthcheckRequest);\n     router.route(HttpMethod.GET, \"/v1/metadata\")\n-        .produces(Versions.KSQL_V1_JSON)\n+        .produces(KsqlMediaType.KSQL_V1_JSON.mediaType())\n         .produces(JSON_CONTENT_TYPE)\n         .handler(this::handleServerMetadataRequest);\n     router.route(HttpMethod.GET, \"/v1/metadata/id\")\n-        .produces(Versions.KSQL_V1_JSON)\n+        .produces(KsqlMediaType.KSQL_V1_JSON.mediaType())\n         .produces(JSON_CONTENT_TYPE)\n         .handler(this::handleServerMetadataClusterIdRequest);\n     router.route(HttpMethod.GET, \"/ws/query\")\n-        .produces(Versions.KSQL_V1_JSON)\n+        .produces(KsqlMediaType.KSQL_V1_JSON.mediaType())\n+        // No support yet for V2. See https://github.com/confluentinc/ksql/issues/6439.", "originalCommit": "df87e14ffdf1ad9055afe403ae5bb1a48e78d6a7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTcyMjYyNg==", "url": "https://github.com/confluentinc/ksql/pull/6462#discussion_r511722626", "bodyText": "Now that we're no longer returning the key as part of the API, is there any point in continuing to pipe it in? I'm wondering if these changes can be removed, along with KeyValue and StructKeyUtil#asList.", "author": "vcrfxia", "createdAt": "2020-10-26T05:11:24Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/QueryStreamWriter.java", "diffHunk": "@@ -124,14 +126,22 @@ public synchronized void close() {\n   }\n \n   private StreamedRow buildHeader() {\n+    final QueryId queryId = queryMetadata.getQueryId();\n+\n     // Push queries only return value columns, but query metadata schema includes key and meta:\n     final LogicalSchema storedSchema = queryMetadata.getLogicalSchema();\n \n-    final Builder actualSchemaBuilder = LogicalSchema.builder();\n+    final Builder projectionSchema = LogicalSchema.builder();\n+\n+    storedSchema.value().forEach(projectionSchema::valueColumn);\n \n-    storedSchema.value().forEach(actualSchemaBuilder::valueColumn);\n+    return StreamedRow.header(queryId, projectionSchema.build());\n+  }\n \n-    return StreamedRow.header(NO_QUERY_ID, actualSchemaBuilder.build());\n+  private StreamedRow buildRow(final KeyValue<List<?>, GenericRow> row) {", "originalCommit": "df87e14ffdf1ad9055afe403ae5bb1a48e78d6a7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA5OTMzNg==", "url": "https://github.com/confluentinc/ksql/pull/6462#discussion_r516099336", "bodyText": "We still need the key.\nDeletes will come through with row.value as null.   The code then needs to build a new GenericRow to send to the client using row.key.  For example, consider these two key-values, where the second represents a deletion of the first:\n-- Given query, where ID is the primary key:\nSELECT ID, COL0 FROM FOO EMIT CHANGES;\n\n\n\nkey\nvalue\n\n\n\n\n10\n[10, 1]\n\n\n10\nnull\n\n\n\nThe code needs to translate the above two key-values posted to the blocking queue into a GenericRow that can be sent to the client.  When the value is not null we can just send the value. However, when value is null we must build a new GenericRow with any primary key columns set, which in this case would be [10, null].\nOnce all three APIs are handling tombstones we should be able to move this logic to the producing side of the queue and just queue the StreamedRow, e.g. we'd just queue:\n\n\n\nvalue\n\n\n\n\n{\"columns\": [10,1]\"}\n\n\n{\"columns\": [10,null]\", \"tombstone\": true}", "author": "big-andy-coates", "createdAt": "2020-11-02T16:35:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTcyMjYyNg=="}], "type": "inlineReview"}, {"oid": "ea2a0b01b584d76d83c3254ccea37fb9306eb808", "url": "https://github.com/confluentinc/ksql/commit/ea2a0b01b584d76d83c3254ccea37fb9306eb808", "message": "chore: requested changes", "committedDate": "2020-11-02T16:25:12Z", "type": "commit"}, {"oid": "2e00a57d04c73591db12aae2f480a54805c5f1ee", "url": "https://github.com/confluentinc/ksql/commit/2e00a57d04c73591db12aae2f480a54805c5f1ee", "message": "Merge branch 'master' into cli_tombstones", "committedDate": "2020-11-02T16:37:52Z", "type": "commit"}]}