{"pr_number": 4809, "pr_title": "fix: Removes unnecessary error logging for heartbeat since this is ex\u2026", "pr_createdAt": "2020-03-17T23:15:33Z", "pr_url": "https://github.com/confluentinc/ksql/pull/4809", "timeline": [{"oid": "499275066520770c98e25551edfc033227d2caed", "url": "https://github.com/confluentinc/ksql/commit/499275066520770c98e25551edfc033227d2caed", "message": "fix: Removes unnecessary error logging for heartbeat since this is expected", "committedDate": "2020-03-17T23:07:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDAyNzA4Mg==", "url": "https://github.com/confluentinc/ksql/pull/4809#discussion_r394027082", "bodyText": "This precedes even this change, but I feel we should throw an exception instead of returning null? and let the caller decide whether to log or not.. I am wondering if we should pass a flag down into a common class like KsqlTarget", "author": "vinothchandar", "createdAt": "2020-03-17T23:25:27Z", "path": "ksqldb-rest-client/src/main/java/io/confluent/ksql/rest/client/KsqlTarget.java", "diffHunk": "@@ -195,11 +199,16 @@ private KsqlRequest createKsqlRequest(\n \n   private void executeRequestAsync(\n       final String path,\n-      final Object jsonEntity\n+      final Object jsonEntity,\n+      final boolean expectFailures\n   ) {\n     execute(HttpMethod.POST, path, jsonEntity, (resp, vcf) -> {\n     }).exceptionally(t -> {\n-      log.error(\"Unexpected exception in async request\", t);\n+      if (expectFailures) {", "originalCommit": "499275066520770c98e25551edfc033227d2caed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDAyNzcwOA==", "url": "https://github.com/confluentinc/ksql/pull/4809#discussion_r394027708", "bodyText": "On second thought, guess the class itself is aware of different endpoints.. more about this method.. can it throw the exception and let the caller decide", "author": "vinothchandar", "createdAt": "2020-03-17T23:27:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDAyNzA4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ2NDQ5NQ==", "url": "https://github.com/confluentinc/ksql/pull/4809#discussion_r394464495", "bodyText": "I'd agree with Vinoth here - methods like postAsyncHeartbeatRequest and postAsyncLagReportingRequest should return a CompletableFuture, which allows the caller to decide if the care about the response and if they do, what to do with it.", "author": "big-andy-coates", "createdAt": "2020-03-18T16:06:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDAyNzA4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU4MTg2MA==", "url": "https://github.com/confluentinc/ksql/pull/4809#discussion_r394581860", "bodyText": "I was originally just keeping with an internal implementation that might be reusable for \"fire and forget\" type methods, but I'm also fine with making this a bit more general and letting callers handle the response/exception.\nChanged to return CompletableFuture<RestResponse<HeartbeatResponse>> which can now be handled by the caller, including handling the exceptional case.", "author": "AlanConfluent", "createdAt": "2020-03-18T19:14:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDAyNzA4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDAyNzQ1Ng==", "url": "https://github.com/confluentinc/ksql/pull/4809#discussion_r394027456", "bodyText": "We can rely on the IDE to annotate the argument instead of comment? :)", "author": "vinothchandar", "createdAt": "2020-03-17T23:26:47Z", "path": "ksqldb-rest-client/src/main/java/io/confluent/ksql/rest/client/KsqlTarget.java", "diffHunk": "@@ -118,7 +121,8 @@ public void postAsyncLagReportingRequest(\n   ) {\n     executeRequestAsync(\n         LAG_REPORT_PATH,\n-        lagReportingMessage\n+        lagReportingMessage,\n+        false /* expectFailures */", "originalCommit": "499275066520770c98e25551edfc033227d2caed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU4MTkzNQ==", "url": "https://github.com/confluentinc/ksql/pull/4809#discussion_r394581935", "bodyText": "Removed.", "author": "AlanConfluent", "createdAt": "2020-03-18T19:15:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDAyNzQ1Ng=="}], "type": "inlineReview"}, {"oid": "ef6fd65934a3559e71dfed35955f11a2dc97a403", "url": "https://github.com/confluentinc/ksql/commit/ef6fd65934a3559e71dfed35955f11a2dc97a403", "message": "Feedback", "committedDate": "2020-03-18T19:16:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDYwMTM2OA==", "url": "https://github.com/confluentinc/ksql/pull/4809#discussion_r394601368", "bodyText": "Is thenApply asynchronous? We don't want to block for the response. In fact, HeartbeatAgent doesn't even care about the response.", "author": "vpapavas", "createdAt": "2020-03-18T19:52:18Z", "path": "ksqldb-rest-client/src/main/java/io/confluent/ksql/rest/client/KsqlTarget.java", "diffHunk": "@@ -255,6 +261,18 @@ private void executeRequestAsync(\n     return KsqlClientUtil.toRestResponse(response, path, mapper);\n   }\n \n+  private <T> CompletableFuture<RestResponse<T>> executeAsync(\n+      final HttpMethod httpMethod,\n+      final String path,\n+      final Object requestBody,\n+      final Function<ResponseWithBody, T> mapper,\n+      final BiConsumer<HttpClientResponse, CompletableFuture<ResponseWithBody>> responseHandler\n+  ) {\n+    final CompletableFuture<ResponseWithBody> vcf =\n+        execute(httpMethod, path, requestBody, responseHandler);\n+    return vcf.thenApply(response -> KsqlClientUtil.toRestResponse(response, path, mapper));", "originalCommit": "ef6fd65934a3559e71dfed35955f11a2dc97a403", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDYxNDA1Nw==", "url": "https://github.com/confluentinc/ksql/pull/4809#discussion_r394614057", "bodyText": "Discussed offline, as long as we don't call get on the future , all other callbacks are non-blocking so we are good", "author": "vpapavas", "createdAt": "2020-03-18T20:17:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDYwMTM2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDYwMzUzNw==", "url": "https://github.com/confluentinc/ksql/pull/4809#discussion_r394603537", "bodyText": "nit: async heartbeat request?", "author": "vinothchandar", "createdAt": "2020-03-18T19:56:32Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/services/DefaultKsqlClient.java", "diffHunk": "@@ -103,7 +107,13 @@ public void makeAsyncHeartbeatRequest(\n         .target(serverEndPoint);\n \n     getTarget(target, authHeader)\n-        .postAsyncHeartbeatRequest(new KsqlHostInfoEntity(host.host(), host.port()), timestamp);\n+        .postAsyncHeartbeatRequest(new KsqlHostInfoEntity(host.host(), host.port()), timestamp)\n+        .exceptionally(t -> {\n+          // We send heartbeat requests quite frequently and to nodes that might be down.  We don't\n+          // want to fill the logs with spam, so we debug log exceptions.\n+          LOG.debug(\"Exception in async request\", t);", "originalCommit": "ef6fd65934a3559e71dfed35955f11a2dc97a403", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY2MjkyMA==", "url": "https://github.com/confluentinc/ksql/pull/4809#discussion_r394662920", "bodyText": "Done", "author": "AlanConfluent", "createdAt": "2020-03-18T21:57:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDYwMzUzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDYxMzQyOA==", "url": "https://github.com/confluentinc/ksql/pull/4809#discussion_r394613428", "bodyText": "Don't we want to debug log this as well?", "author": "vpapavas", "createdAt": "2020-03-18T20:16:04Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/services/DefaultKsqlClient.java", "diffHunk": "@@ -122,7 +132,11 @@ public void makeAsyncLagReportRequest(\n     final KsqlTarget target = sharedClient\n         .target(serverEndPoint);\n \n-    getTarget(target, authHeader).postAsyncLagReportingRequest(lagReportingMessage);\n+    getTarget(target, authHeader).postAsyncLagReportingRequest(lagReportingMessage)\n+        .exceptionally(t -> {\n+          LOG.error(\"Unexpected exception in async request\", t);", "originalCommit": "ef6fd65934a3559e71dfed35955f11a2dc97a403", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDYyNzY5NA==", "url": "https://github.com/confluentinc/ksql/pull/4809#discussion_r394627694", "bodyText": "Looking at the code, it seems like all of the hosts start off in a non-alive state and if the hoststatus callback happens at the wrong time, I think lag reporting could hit the same issue as well.\nMaking it debug logging as well.", "author": "AlanConfluent", "createdAt": "2020-03-18T20:43:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDYxMzQyOA=="}], "type": "inlineReview"}, {"oid": "60271594ec0876a46dbc972e7fa49e080471fb1e", "url": "https://github.com/confluentinc/ksql/commit/60271594ec0876a46dbc972e7fa49e080471fb1e", "message": "More Feedback", "committedDate": "2020-03-18T20:43:55Z", "type": "commit"}]}