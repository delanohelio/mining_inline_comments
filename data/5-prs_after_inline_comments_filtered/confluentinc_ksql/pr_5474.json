{"pr_number": 5474, "pr_title": "feat: implements ARRAY_JOIN as requested in (#5028)", "pr_createdAt": "2020-05-24T12:34:21Z", "pr_url": "https://github.com/confluentinc/ksql/pull/5474", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDUyOTkwMA==", "url": "https://github.com/confluentinc/ksql/pull/5474#discussion_r430529900", "bodyText": "nit: let's use ImmutableSet.of", "author": "agavra", "createdAt": "2020-05-26T16:04:40Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/udf/array/ArrayJoin.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.function.udf.array;\n+\n+import io.confluent.ksql.function.KsqlFunctionException;\n+import io.confluent.ksql.function.udf.Udf;\n+import io.confluent.ksql.function.udf.UdfDescription;\n+import io.confluent.ksql.function.udf.UdfParameter;\n+import io.confluent.ksql.util.KsqlConstants;\n+import java.math.BigInteger;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.StringJoiner;\n+import org.apache.kafka.connect.data.Struct;\n+\n+@SuppressWarnings(\"MethodMayBeStatic\") // UDF methods can not be static.\n+@UdfDescription(\n+    name = \"ARRAY_JOIN\",\n+    description = \"joins the array elements into a flat string representation\",\n+    author = KsqlConstants.CONFLUENT_AUTHOR\n+)\n+public class ArrayJoin {\n+\n+  private static final String DEFAULT_DELIMITER = \",\";\n+  private static final Set<Class> KSQL_PRIMITIVES = new HashSet<>(\n+      Arrays.asList(Boolean.class,Integer.class,BigInteger.class,Double.class,String.class)\n+  );", "originalCommit": "a71c4d63726c45759e637906b05220fead58998f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU0NjYwMA==", "url": "https://github.com/confluentinc/ksql/pull/5474#discussion_r430546600", "bodyText": "ok. will do.", "author": "hpgrahsl", "createdAt": "2020-05-26T16:28:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDUyOTkwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQwNDE0NQ==", "url": "https://github.com/confluentinc/ksql/pull/5474#discussion_r439404145", "bodyText": "done!", "author": "hpgrahsl", "createdAt": "2020-06-12T13:01:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDUyOTkwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDUzMTIxOQ==", "url": "https://github.com/confluentinc/ksql/pull/5474#discussion_r430531219", "bodyText": "why BigInteger? I think ksqlDB only uses BigDecimal internally - there is also Long.class if you are referring to the sql BIGINT type", "author": "agavra", "createdAt": "2020-05-26T16:06:27Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/udf/array/ArrayJoin.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.function.udf.array;\n+\n+import io.confluent.ksql.function.KsqlFunctionException;\n+import io.confluent.ksql.function.udf.Udf;\n+import io.confluent.ksql.function.udf.UdfDescription;\n+import io.confluent.ksql.function.udf.UdfParameter;\n+import io.confluent.ksql.util.KsqlConstants;\n+import java.math.BigInteger;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.StringJoiner;\n+import org.apache.kafka.connect.data.Struct;\n+\n+@SuppressWarnings(\"MethodMayBeStatic\") // UDF methods can not be static.\n+@UdfDescription(\n+    name = \"ARRAY_JOIN\",\n+    description = \"joins the array elements into a flat string representation\",\n+    author = KsqlConstants.CONFLUENT_AUTHOR\n+)\n+public class ArrayJoin {\n+\n+  private static final String DEFAULT_DELIMITER = \",\";\n+  private static final Set<Class> KSQL_PRIMITIVES = new HashSet<>(\n+      Arrays.asList(Boolean.class,Integer.class,BigInteger.class,Double.class,String.class)", "originalCommit": "a71c4d63726c45759e637906b05220fead58998f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU0ODg3OA==", "url": "https://github.com/confluentinc/ksql/pull/5474#discussion_r430548878", "bodyText": "fair point. I guess I mistakenly assumed that sql BIGINT would map to BigInteger which obviously is not the case? Should I switch to Long cause BigDecimal seems even weirder to me than BigInteger when thinking about it.", "author": "hpgrahsl", "createdAt": "2020-05-26T16:32:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDUzMTIxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU1MzgzMA==", "url": "https://github.com/confluentinc/ksql/pull/5474#discussion_r430553830", "bodyText": "I was a little unclear; we should remove BigInteger and add both Long and BigDecimal. BigDecimal is the java class that we use to represent the sql DECIMAL type, which should be supported in this method", "author": "agavra", "createdAt": "2020-05-26T16:39:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDUzMTIxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU1Nzc0NQ==", "url": "https://github.com/confluentinc/ksql/pull/5474#discussion_r430557745", "bodyText": "Thx for clarifying. The reason I didn't consider DECIMAL is because it simply didn't work for me. Maybe I'm too stupid but trying to use the ksql CLI and create an ARRAY of DECIMALs   never worked for me thus I thought it's currently not supported :)", "author": "hpgrahsl", "createdAt": "2020-05-26T16:43:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDUzMTIxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU2MzU4MQ==", "url": "https://github.com/confluentinc/ksql/pull/5474#discussion_r430563581", "bodyText": "Not stupid, haha - our UX isn't great with decimals, but the below should work:\nksql> CREATE STREAM dec_array (val ARRAY<DECIMAL(2,1)>) WITH (kafka_topic='foo', value_format='json', partitions=1);\n\n Message\n----------------\n Stream created\n----------------\nksql> INSERT INTO dec_array (val) VALUES (ARRAY[2.1]);\nksql> SELECT * FROM dec_array EMIT CHANGES;\n+----------------------------------------------+----------------------------------------------+\n|ROWKEY                                        |VAL                                           |\n+----------------------------------------------+----------------------------------------------+\n|null                                          |[2.1]                                         |", "author": "agavra", "createdAt": "2020-05-26T16:53:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDUzMTIxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQwNDIwNw==", "url": "https://github.com/confluentinc/ksql/pull/5474#discussion_r439404207", "bodyText": "done!", "author": "hpgrahsl", "createdAt": "2020-06-12T13:01:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDUzMTIxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDUzMTczOA==", "url": "https://github.com/confluentinc/ksql/pull/5474#discussion_r430531738", "bodyText": "what should the behavior be on a null delimiter? should we default to empty string delimiter or just return null? cc @derekjn", "author": "agavra", "createdAt": "2020-05-26T16:07:11Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/udf/array/ArrayJoin.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.function.udf.array;\n+\n+import io.confluent.ksql.function.KsqlFunctionException;\n+import io.confluent.ksql.function.udf.Udf;\n+import io.confluent.ksql.function.udf.UdfDescription;\n+import io.confluent.ksql.function.udf.UdfParameter;\n+import io.confluent.ksql.util.KsqlConstants;\n+import java.math.BigInteger;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.StringJoiner;\n+import org.apache.kafka.connect.data.Struct;\n+\n+@SuppressWarnings(\"MethodMayBeStatic\") // UDF methods can not be static.\n+@UdfDescription(\n+    name = \"ARRAY_JOIN\",\n+    description = \"joins the array elements into a flat string representation\",\n+    author = KsqlConstants.CONFLUENT_AUTHOR\n+)\n+public class ArrayJoin {\n+\n+  private static final String DEFAULT_DELIMITER = \",\";\n+  private static final Set<Class> KSQL_PRIMITIVES = new HashSet<>(\n+      Arrays.asList(Boolean.class,Integer.class,BigInteger.class,Double.class,String.class)\n+  );\n+\n+  @Udf\n+  public <T> String join(\n+      @UdfParameter(description = \"the array to join using the default delimiter '\"\n+          + DEFAULT_DELIMITER + \"'\") final List<T> array\n+  ) {\n+    return join(array, DEFAULT_DELIMITER);\n+  }\n+\n+  @Udf\n+  public <T> String join(\n+      @UdfParameter(description = \"the array to join using the specified delimiter\")\n+      final List<T> array,\n+      @UdfParameter(description = \"the string to be used as element delimiter\")\n+      final String delimiter\n+  ) {\n+\n+    if (array == null) {", "originalCommit": "a71c4d63726c45759e637906b05220fead58998f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU0OTE4NA==", "url": "https://github.com/confluentinc/ksql/pull/5474#discussion_r430549184", "bodyText": "I have no preference but you are right that it has to be specified by someone ;-)", "author": "hpgrahsl", "createdAt": "2020-05-26T16:32:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDUzMTczOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDczOTg4NQ==", "url": "https://github.com/confluentinc/ksql/pull/5474#discussion_r430739885", "bodyText": "I think that interpreting a null delimiter as the empty string makes sense here.", "author": "derekjn", "createdAt": "2020-05-26T22:21:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDUzMTczOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQwNDU0OQ==", "url": "https://github.com/confluentinc/ksql/pull/5474#discussion_r439404549", "bodyText": "done!", "author": "hpgrahsl", "createdAt": "2020-06-12T13:02:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDUzMTczOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDUzNjI0NA==", "url": "https://github.com/confluentinc/ksql/pull/5474#discussion_r430536244", "bodyText": "if we have a list of list, should it flatten the nested types or just return a string representation of the element? it seems odd to me that ARRAY[ARRAY[1, 2], ARRAY[3]] would flatten to the same result as ARRAY[1, 2, 3]\nsame concern for map and struct - I think my preference would be to support only primitives in the first implementation. Other languages have similar restrictions, e.g. python (which is even more restrictive):\n>>> '.'.join([['1', '2']])\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: sequence item 0: expected string, list found", "author": "agavra", "createdAt": "2020-05-26T16:13:40Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/udf/array/ArrayJoin.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.function.udf.array;\n+\n+import io.confluent.ksql.function.KsqlFunctionException;\n+import io.confluent.ksql.function.udf.Udf;\n+import io.confluent.ksql.function.udf.UdfDescription;\n+import io.confluent.ksql.function.udf.UdfParameter;\n+import io.confluent.ksql.util.KsqlConstants;\n+import java.math.BigInteger;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.StringJoiner;\n+import org.apache.kafka.connect.data.Struct;\n+\n+@SuppressWarnings(\"MethodMayBeStatic\") // UDF methods can not be static.\n+@UdfDescription(\n+    name = \"ARRAY_JOIN\",\n+    description = \"joins the array elements into a flat string representation\",\n+    author = KsqlConstants.CONFLUENT_AUTHOR\n+)\n+public class ArrayJoin {\n+\n+  private static final String DEFAULT_DELIMITER = \",\";\n+  private static final Set<Class> KSQL_PRIMITIVES = new HashSet<>(\n+      Arrays.asList(Boolean.class,Integer.class,BigInteger.class,Double.class,String.class)\n+  );\n+\n+  @Udf\n+  public <T> String join(\n+      @UdfParameter(description = \"the array to join using the default delimiter '\"\n+          + DEFAULT_DELIMITER + \"'\") final List<T> array\n+  ) {\n+    return join(array, DEFAULT_DELIMITER);\n+  }\n+\n+  @Udf\n+  public <T> String join(\n+      @UdfParameter(description = \"the array to join using the specified delimiter\")\n+      final List<T> array,\n+      @UdfParameter(description = \"the string to be used as element delimiter\")\n+      final String delimiter\n+  ) {\n+\n+    if (array == null) {\n+      return null;\n+    }\n+\n+    final StringJoiner sj = new StringJoiner(delimiter);\n+    array.forEach(e -> processElement(e, sj));\n+    return sj.toString();\n+\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private static <T> void processElement(final T element, final StringJoiner joiner) {\n+\n+    if (element == null || KSQL_PRIMITIVES.contains(element.getClass())) {\n+      handlePrimitiveType(element, joiner);\n+    } else if (element instanceof List) {\n+      handleListType((List)element,joiner);\n+    } else if (element instanceof Map) {\n+      handleMapType((Map) element, joiner);\n+    } else if (element instanceof Struct) {\n+      handleStructType((Struct)element, joiner);\n+    } else {\n+      throw new KsqlFunctionException(\"error: hit element of type \"\n+          + element.getClass().getTypeName() + \" which is currently not supported\");\n+    }\n+\n+  }\n+\n+  private static void handlePrimitiveType(final Object element, final StringJoiner joiner) {\n+    joiner.add(element != null ? element.toString() : null);\n+  }\n+\n+  private static void handleListType(final List<?> element, final StringJoiner joiner) {\n+    element.forEach(e -> processElement(e, joiner));", "originalCommit": "a71c4d63726c45759e637906b05220fead58998f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU1MzAzNA==", "url": "https://github.com/confluentinc/ksql/pull/5474#discussion_r430553034", "bodyText": "There were no clear indications about this in the issue discussion which is why I implemented it in this way, which is IMHO a \"natural\" choice. Remember that the original idea was that the result is just a flat string. If you want to see a different string result for the example you are referring to it essentially means to introduce further delimiters which can capture the semantics of nesting which might be out of scope for such a function. If someone really wants to have that I think it's better to decide for other forms of encoding e.g. a fully-fledged JSON-string representation, but I guess that's a different story.", "author": "hpgrahsl", "createdAt": "2020-05-26T16:38:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDUzNjI0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU1NTEwNw==", "url": "https://github.com/confluentinc/ksql/pull/5474#discussion_r430555107", "bodyText": "cc @derekjn @rmoff to chime in here, I'm happy with whatever we settle on", "author": "agavra", "createdAt": "2020-05-26T16:41:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDUzNjI0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDczOTA3NA==", "url": "https://github.com/confluentinc/ksql/pull/5474#discussion_r430739074", "bodyText": "I don't think we should implicitly flatten anything here. If I passed an array of arrays, I'd expect the result to be the string representation of each array, joined together by the delimiter. If that adds too much complexity to the implementation then I agree with @agavra that it would be reasonable to require primitive types, at least for the initial implementation. The semantics around concatenating string representations of structured types (especially if they have nondeterministic string reps) can start to get pretty messy.", "author": "derekjn", "createdAt": "2020-05-26T22:19:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDUzNjI0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTI5MTEzMA==", "url": "https://github.com/confluentinc/ksql/pull/5474#discussion_r431291130", "bodyText": "hi @derekjn so do I get you right that you want to capture the nesting semantics somehow in the resulting string representation? if so how exactly should this look like? it would be helpful if you can provide some examples at least one for each of the following: arrays of arrays, maps of maps or nested structs. THX in advance.\nbased on that we can then decide if the implementation should be done or we simply drop support for anything but flat arrays containing primitives. what I still quite don't get is why you have your issues with the current way it's implemented. think about a simple CSV-like string - in a basic CSV encoding you would end up with delimiting elements as is currently done since you don't capture complex structure in a simple CSV-style string.", "author": "hpgrahsl", "createdAt": "2020-05-27T16:47:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDUzNjI0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE3NDg5Ng==", "url": "https://github.com/confluentinc/ksql/pull/5474#discussion_r432174896", "bodyText": "For all of those examples I think we'd just want to use whatever CAST(value AS STRING) would return for the array element. That being said, I'm fine with only supporting primitive types for the initial implementation as @agavra suggested. Let's just go with that.", "author": "derekjn", "createdAt": "2020-05-28T23:17:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDUzNjI0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQwNDc5Mg==", "url": "https://github.com/confluentinc/ksql/pull/5474#discussion_r439404792", "bodyText": "dropped support for complex nested types for this initial version of ARRAY_JOIN", "author": "hpgrahsl", "createdAt": "2020-06-12T13:02:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDUzNjI0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDUzNzQxMw==", "url": "https://github.com/confluentinc/ksql/pull/5474#discussion_r430537413", "bodyText": "nit: we prefer hamcrest asserts in our tests, you can look at other tests for examples of assertThat(value, matches(matcher))", "author": "agavra", "createdAt": "2020-05-26T16:15:22Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/function/udf/array/ArrayJoinTest.java", "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.function.udf.array;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertThrows;\n+import static org.junit.Assert.assertTrue;", "originalCommit": "a71c4d63726c45759e637906b05220fead58998f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU1NTM1OA==", "url": "https://github.com/confluentinc/ksql/pull/5474#discussion_r430555358", "bodyText": "sure I can do that.\nre-nit from my side: however, when it comes to consistency of the way things are done in existing UDFs we could discuss days if not weeks ;-)", "author": "hpgrahsl", "createdAt": "2020-05-26T16:41:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDUzNzQxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQwNTA1NQ==", "url": "https://github.com/confluentinc/ksql/pull/5474#discussion_r439405055", "bodyText": "switched to hamcrest matchers", "author": "hpgrahsl", "createdAt": "2020-06-12T13:03:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDUzNzQxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDUzODgzMA==", "url": "https://github.com/confluentinc/ksql/pull/5474#discussion_r430538830", "bodyText": "can you add decimal and long types into this? (see not above that BigInteger and Long are not the same in java)", "author": "agavra", "createdAt": "2020-05-26T16:17:28Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/function/udf/array/ArrayJoinTest.java", "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.function.udf.array;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertThrows;\n+import static org.junit.Assert.assertTrue;\n+\n+import io.confluent.ksql.function.KsqlFunctionException;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.kafka.connect.data.Schema;\n+import org.apache.kafka.connect.data.SchemaBuilder;\n+import org.apache.kafka.connect.data.Struct;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+public class ArrayJoinTest {\n+\n+  private static final String CUSTOM_DELIMITER = \"|\";\n+  private static Struct STRUCT_DATA;\n+\n+  private final ArrayJoin arrayJoinUDF = new ArrayJoin();\n+\n+  @BeforeClass\n+  public static void initializeComplexStructTypeSampleData() {\n+\n+    Schema structSchema = SchemaBuilder.struct()\n+        .field(\"f1\", Schema.STRING_SCHEMA)\n+        .field(\"f2\", Schema.INT32_SCHEMA)\n+        .field(\"f3\", Schema.BOOLEAN_SCHEMA)\n+        .field(\"f4\", SchemaBuilder.struct()\n+            .field(\"f4-1\", Schema.STRING_SCHEMA)\n+            .build()\n+        )\n+        .field(\"f5\", SchemaBuilder.array(Schema.STRING_SCHEMA).build())\n+        .field(\"f6\", SchemaBuilder.array(SchemaBuilder.struct()\n+            .field(\"k\", Schema.STRING_SCHEMA)\n+            .field(\"v\", Schema.INT32_SCHEMA)\n+            .build())\n+        )\n+        .field(\"f7\",\n+            SchemaBuilder.array(SchemaBuilder.array(SchemaBuilder.array(Schema.INT32_SCHEMA))))\n+        .field(\"f8\", SchemaBuilder.map(Schema.STRING_SCHEMA, Schema.INT32_SCHEMA).build())\n+        .field(\"f9\", SchemaBuilder\n+            .map(Schema.STRING_SCHEMA, SchemaBuilder.array(Schema.STRING_SCHEMA).build()).build())\n+        .field(\"f10\", SchemaBuilder\n+            .map(Schema.STRING_SCHEMA, SchemaBuilder.array(Schema.INT32_SCHEMA).build()).build())\n+        .build();\n+\n+    STRUCT_DATA = new Struct(structSchema)\n+        .put(\"f1\", \"ksqldb UDF sample data\")\n+        .put(\"f2\", 42)\n+        .put(\"f3\", true)\n+        .put(\"f4\", new Struct(structSchema.field(\"f4\").schema())\n+            .put(\"f4-1\", \"hello ksqldb\")\n+        )\n+        .put(\"f5\", Arrays.asList(\"str_1\", \"str_2\", \"...\", \"str_N\"))\n+        .put(\"f6\", Arrays.asList(\n+            new Struct(structSchema.field(\"f6\").schema().valueSchema())\n+                .put(\"k\", \"a\").put(\"v\", 1),\n+            new Struct(structSchema.field(\"f6\").schema().valueSchema())\n+                .put(\"k\", \"b\").put(\"v\", 2),\n+            new Struct(structSchema.field(\"f6\").schema().valueSchema())\n+                .put(\"k\", \"c\").put(\"v\", 3)\n+            )\n+        )\n+        .put(\"f7\", Arrays.asList(\n+            Arrays.asList(Arrays.asList(0,1), Arrays.asList(2,3,4), Arrays.asList(5, 6),\n+                Arrays.asList(7,8,9)),\n+            Arrays.asList(Arrays.asList(9,8,7),Arrays.asList(6,5), Arrays.asList(4,3,2),\n+                Arrays.asList(1,0)\n+            )\n+        ))\n+        .put(\"f8\", new LinkedHashMap<String, Integer>() {{\n+          put(\"k1\", 6);\n+          put(\"k2\", 5);\n+          put(\"k3\", 4);\n+        }})\n+        .put(\"f9\", new LinkedHashMap<String, List<String>>() {{\n+          put(\"k1\", Arrays.asList(\"v1-a\", \"v1-b\"));\n+          put(\"k2\", Arrays.asList(\"v2-a\",\"v2-b\", \"v2-c\", \"v2-d\"));\n+          put(\"k3\", Arrays.asList(\"v3-a\",\"v3-b\",\"v3-c\"));\n+        }})\n+        .put(\"f10\", new LinkedHashMap<String, List<Integer>>() {{\n+          put(\"k1\", Arrays.asList(12, 21));\n+          put(\"k2\", Arrays.asList(23, 32));\n+          put(\"k3\", Arrays.asList(24, 42));\n+        }});\n+  }\n+\n+  @Test\n+  public void shouldReturnNullForNullInput() {\n+    assertNull(arrayJoinUDF.join(null));\n+    assertNull(arrayJoinUDF.join(null,CUSTOM_DELIMITER));\n+  }\n+\n+  @Test\n+  public void shouldReturnEmptyStringForEmptyArrays() {\n+    assertTrue(arrayJoinUDF.join(Collections.emptyList()).isEmpty());\n+    assertTrue(arrayJoinUDF.join(Collections.emptyList(),CUSTOM_DELIMITER).isEmpty());\n+  }\n+\n+  @Test\n+  public void shouldReturnCorrectStringForFlatArraysWithPrimitiveTypes() {", "originalCommit": "a71c4d63726c45759e637906b05220fead58998f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU1NDA0NA==", "url": "https://github.com/confluentinc/ksql/pull/5474#discussion_r430554044", "bodyText": "sure. but both or either of them? see my question above at the BigInteger comment.", "author": "hpgrahsl", "createdAt": "2020-05-26T16:39:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDUzODgzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQwNTQ5Mg==", "url": "https://github.com/confluentinc/ksql/pull/5474#discussion_r439405492", "bodyText": "done!", "author": "hpgrahsl", "createdAt": "2020-06-12T13:04:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDUzODgzMA=="}], "type": "inlineReview"}, {"oid": "86542b0022d43863d633638c7d5c9f8e9a4325c4", "url": "https://github.com/confluentinc/ksql/commit/86542b0022d43863d633638c7d5c9f8e9a4325c4", "message": "feat: implements ARRAY_JOIN as requested in (#5028)", "committedDate": "2020-06-12T12:59:13Z", "type": "commit"}, {"oid": "2bb913680388971b9bc90fc07ce69fc3b76f5221", "url": "https://github.com/confluentinc/ksql/commit/2bb913680388971b9bc90fc07ce69fc3b76f5221", "message": "feat: modifications for ARRAY_JOIN as discussed in #5474\n\nas requested by reviewers:\n\n- removed BigInteger from primitive types\n- added Long and BigDecimal to supported primitive types\n- dropped support for complex nested types\n- switched to hamcrest matchers in unit tests\n- added QueryTranslationTest for via PlannedTestGeneratorTest\n- adapted docs accordingly", "committedDate": "2020-06-12T12:59:13Z", "type": "commit"}, {"oid": "2bb913680388971b9bc90fc07ce69fc3b76f5221", "url": "https://github.com/confluentinc/ksql/commit/2bb913680388971b9bc90fc07ce69fc3b76f5221", "message": "feat: modifications for ARRAY_JOIN as discussed in #5474\n\nas requested by reviewers:\n\n- removed BigInteger from primitive types\n- added Long and BigDecimal to supported primitive types\n- dropped support for complex nested types\n- switched to hamcrest matchers in unit tests\n- added QueryTranslationTest for via PlannedTestGeneratorTest\n- adapted docs accordingly", "committedDate": "2020-06-12T12:59:13Z", "type": "forcePushed"}]}