{"pr_number": 5775, "pr_title": "feat(client): support DDL/DML statements in Java client", "pr_createdAt": "2020-07-07T19:08:30Z", "pr_url": "https://github.com/confluentinc/ksql/pull/5775", "timeline": [{"oid": "8e8650d96e760e91a7e2b51c10502b0351b3b24d", "url": "https://github.com/confluentinc/ksql/commit/8e8650d96e760e91a7e2b51c10502b0351b3b24d", "message": "feat(client): support DDL/DML statements in Java client", "committedDate": "2020-07-07T17:45:05Z", "type": "commit"}, {"oid": "361d5df9e2a33f6b4f8cc49d1390f604d3ed0eef", "url": "https://github.com/confluentinc/ksql/commit/361d5df9e2a33f6b4f8cc49d1390f604d3ed0eef", "message": "chore: validate number of statements upfront", "committedDate": "2020-07-07T18:41:48Z", "type": "commit"}, {"oid": "1d5177914a837ad3f7251052e25aad2516337cf1", "url": "https://github.com/confluentinc/ksql/commit/1d5177914a837ad3f7251052e25aad2516337cf1", "message": "docs: javadocs", "committedDate": "2020-07-07T18:53:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA4MzE3MQ==", "url": "https://github.com/confluentinc/ksql/pull/5775#discussion_r451083171", "bodyText": "I considered having a return type to contain the command sequence number here, rather than returning void. The command seqeunce number could be useful in the future, since it could be used to ensure that subsequent requests (transient queries, admin operations, etc.) are not executed until the necessary streams/tables have been created, but this is advanced usage that is not currently supported by the client, so exposing the command sequence number right now is not useful. Is it worth introducing an empty return type, e.g., ExecuteStatementResult as a placeholder, in case we want to expose the command sequence number in the future? Not sure how confusion from having an empty return type now trades off against potentially updating the API in a backwards-incompatible way in the future.", "author": "vcrfxia", "createdAt": "2020-07-07T19:08:57Z", "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/Client.java", "diffHunk": "@@ -112,6 +112,48 @@\n    */\n   CompletableFuture<Void> terminatePushQuery(String queryId);\n \n+  /**\n+   * Sends a SQL request to the ksqlDB server. This method supports 'CREATE', 'CREATE ... AS\n+   * SELECT', 'DROP', 'TERMINATE', and 'INSERT INTO ... AS SELECT' statements.\n+   *\n+   * <p>Each request should contain exactly one statement. Requests that contain multiple statements\n+   * will be rejected by the client, in the form of failing the {@code CompletableFuture}, and the\n+   * request will not be sent to the server.\n+   *\n+   * <p>The {@code CompletableFuture} is completed once a response is received from the server.\n+   * Note that the actual execution of the submitted statement is asynchronous, so the statement\n+   * may not have been executed by the time the {@code CompletableFuture} is completed.\n+   *\n+   * <p>If a non-200 response is received from the server, the {@code CompletableFuture} will be\n+   * failed.\n+   *\n+   * @param sql the request to be executed\n+   * @return a future that completes once the server response is received\n+   */\n+  CompletableFuture<Void> executeStatement(String sql);", "originalCommit": "1d5177914a837ad3f7251052e25aad2516337cf1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzI0NjU1OQ==", "url": "https://github.com/confluentinc/ksql/pull/5775#discussion_r453246559", "bodyText": "Update: once #5814 is merged, I'm going to update this return type to contain an Optional<String> containing the query ID, in the case of statements that start persistent queries. This is useful so client apps can easily terminate persistent queries.", "author": "vcrfxia", "createdAt": "2020-07-11T23:44:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA4MzE3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcyODE3OA==", "url": "https://github.com/confluentinc/ksql/pull/5775#discussion_r453728178", "bodyText": "If we don't complete the future until the command has been executed then I don't think we need a command sequence number. It seems perhaps that the command sequence number on the REST API is a workaround as there's no way to get a callback on completion with REST. But with a proper future I think we can implement it in a nicer way :)", "author": "purplefox", "createdAt": "2020-07-13T15:19:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA4MzE3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc5MDI0MQ==", "url": "https://github.com/confluentinc/ksql/pull/5775#discussion_r453790241", "bodyText": "If we don't complete the future until the command has been executed then I don't think we need a command sequence number. It seems perhaps that the command sequence number on the REST API is a workaround as there's no way to get a callback on completion with REST. But with a proper future I think we can implement it in a nicer way :)\n\nYeah, this is a good point. As mentioned above, though, we unfortunately don't have a good way to tell when the statement has been executed, and it's also unclear exactly what that means since some servers may have executed the statement while others haven't. Maybe we could add a server endpoint to expose the command sequence number of the most recent command executed by the server? Though that still wouldn't address the issue of different servers having executed up through different statements.", "author": "vcrfxia", "createdAt": "2020-07-13T16:52:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA4MzE3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDMwNjc2MA==", "url": "https://github.com/confluentinc/ksql/pull/5775#discussion_r454306760", "bodyText": "Yeah, sounds a bit complex and out of scope for now :)", "author": "purplefox", "createdAt": "2020-07-14T12:05:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA4MzE3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA4MzI2Mg==", "url": "https://github.com/confluentinc/ksql/pull/5775#discussion_r451083262", "bodyText": "As explained in the javadocs, the CompletableFuture is completed once the server accepts the statement. The actual statement execution is async, so the statement likely will not have been executed by the time the future is complete. Hopefully this is not too confusing to users.", "author": "vcrfxia", "createdAt": "2020-07-07T19:09:06Z", "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/Client.java", "diffHunk": "@@ -112,6 +112,48 @@\n    */\n   CompletableFuture<Void> terminatePushQuery(String queryId);\n \n+  /**\n+   * Sends a SQL request to the ksqlDB server. This method supports 'CREATE', 'CREATE ... AS\n+   * SELECT', 'DROP', 'TERMINATE', and 'INSERT INTO ... AS SELECT' statements.\n+   *\n+   * <p>Each request should contain exactly one statement. Requests that contain multiple statements\n+   * will be rejected by the client, in the form of failing the {@code CompletableFuture}, and the\n+   * request will not be sent to the server.\n+   *\n+   * <p>The {@code CompletableFuture} is completed once a response is received from the server.\n+   * Note that the actual execution of the submitted statement is asynchronous, so the statement", "originalCommit": "1d5177914a837ad3f7251052e25aad2516337cf1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcyNjI0OQ==", "url": "https://github.com/confluentinc/ksql/pull/5775#discussion_r453726249", "bodyText": "I'm curious why we don't complete the CompletableFuture when the statement has been executed? I think that would be more intuitive for the user.\nIs there any other way for the user to know when the statements has been executed? I'm thinking of use cases where they want to create a stream then start sending messages to it. Before sending the messages they need to know it's been created.", "author": "purplefox", "createdAt": "2020-07-13T15:17:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA4MzI2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc4NDYzMg==", "url": "https://github.com/confluentinc/ksql/pull/5775#discussion_r453784632", "bodyText": "Statement execution is async (command runner thread needs to be read the statement from the command topic, then execute), and there's no good way to know when the command has been executed. If we know the type of statement being executed, we could try to list streams/tables/queries and check the result contains the expected stream/table/query, but this feels rather hacky. It also doesn't address the problem that there may be multiple ksqlDB servers in the cluster, and the statement having been executed on one server does not guarantee that the other servers have executed the statement.", "author": "vcrfxia", "createdAt": "2020-07-13T16:42:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA4MzI2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc4NzEyOA==", "url": "https://github.com/confluentinc/ksql/pull/5775#discussion_r453787128", "bodyText": "In terms of how the user can know if the statement has been executed, besides listing streams/tables/queries as mentioned above, they can also try opening the connection to stream rows or insert new rows. That request will fail if the statement hasn't been executed yet, so they could retry the statement until it succeeds? Definitely not great but I'm not sure what better options we have.", "author": "vcrfxia", "createdAt": "2020-07-13T16:46:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA4MzI2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc4NzgxNg==", "url": "https://github.com/confluentinc/ksql/pull/5775#discussion_r453787816", "bodyText": "One correction to my earlier statement which mitigates some of the async execution pain: After reading the code more carefully, I found out that\n\nThe actual statement execution is async, so the statement likely will not have been executed by the time the future is complete.\n\nis not true. Under normal circumstances, the statement typically has executed by the time the future is complete. It only wouldn't if (1) the command runner thread was stuck for some reason, or (2) the config value for how long the server waits for the command to execute before returning a response from the /ksql endpoint was tuned to be too low.", "author": "vcrfxia", "createdAt": "2020-07-13T16:48:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA4MzI2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA4MzQ1Mw==", "url": "https://github.com/confluentinc/ksql/pull/5775#discussion_r451083453", "bodyText": "I considered introducing separate methods specific for terminating persistent queries and dropping streams/tables, but decided the additional complexity wasn't worth the minor benefit. Happy to hear other opinions on this, though.", "author": "vcrfxia", "createdAt": "2020-07-07T19:09:28Z", "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/Client.java", "diffHunk": "@@ -112,6 +112,48 @@\n    */\n   CompletableFuture<Void> terminatePushQuery(String queryId);\n \n+  /**\n+   * Sends a SQL request to the ksqlDB server. This method supports 'CREATE', 'CREATE ... AS\n+   * SELECT', 'DROP', 'TERMINATE', and 'INSERT INTO ... AS SELECT' statements.", "originalCommit": "1d5177914a837ad3f7251052e25aad2516337cf1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzczMjMwMg==", "url": "https://github.com/confluentinc/ksql/pull/5775#discussion_r453732302", "bodyText": "Just a sanity check probably best to check if the optional value is present before calling get(). (Same with below too)", "author": "purplefox", "createdAt": "2020-07-13T15:25:28Z", "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/impl/AdminResponseHandlers.java", "diffHunk": "@@ -35,10 +35,119 @@ private AdminResponseHandlers() {\n   static void handleListStreamsResponse(\n       final JsonObject streamsListEntity,\n       final CompletableFuture<List<StreamInfo>> cf\n+  ) {\n+    try {\n+      cf.complete(getListStreamsResponse(streamsListEntity).get());", "originalCommit": "1d5177914a837ad3f7251052e25aad2516337cf1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc5OTA0NA==", "url": "https://github.com/confluentinc/ksql/pull/5775#discussion_r453799044", "bodyText": "Do you mean switching the try-catch to an if-present-else-throw check? That makes sense to me. I'll make the change.", "author": "vcrfxia", "createdAt": "2020-07-13T17:07:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzczMjMwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzczNTMzNw==", "url": "https://github.com/confluentinc/ksql/pull/5775#discussion_r453735337", "bodyText": "Do we really want to swallow the exception here? It might make sense to propagate the exception to the completable future in the calling method.", "author": "purplefox", "createdAt": "2020-07-13T15:29:53Z", "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/impl/AdminResponseHandlers.java", "diffHunk": "@@ -47,18 +156,22 @@ static void handleListStreamsResponse(\n           .collect(Collectors.toList())\n       );\n     } catch (Exception e) {\n-      cf.completeExceptionally(new IllegalStateException(\n-          \"Unexpected server response format. Response: \" + streamsListEntity));\n+      return Optional.empty();", "originalCommit": "1d5177914a837ad3f7251052e25aad2516337cf1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzgwMTMwMQ==", "url": "https://github.com/confluentinc/ksql/pull/5775#discussion_r453801301", "bodyText": "Do you mean the specific exception e or the newly created IllegalStateException? The illegal state exception is still being sent to the CompletableFuture, it just happens in handleListStreamsResponse() now rather than here. As for the specific exception e, I guess there could be value in seeing the error message. What's your recommendation for exposing the error message from this method? Should we create a composite return type to contain either a List<StreamInfo> or an error message / exception? Feels rather heavy-weight though I can't think of anything better.", "author": "vcrfxia", "createdAt": "2020-07-13T17:10:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzczNTMzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcyOTE5OA==", "url": "https://github.com/confluentinc/ksql/pull/5775#discussion_r454729198", "bodyText": "Merging this PR for now to unblock the PRs behind it. Can add this in as a follow-on.\n@purplefox do you have recommendations for how to propagate any errors encountered from these methods to the calling methods? I can only think of either creating a composite return type (to contain either the successful response or an error / error message) or having the calling method optionally pass in a consumer to receive an error message, but both feel like overkill for getting an error message back from a method. There has to be a simpler way...?", "author": "vcrfxia", "createdAt": "2020-07-15T01:02:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzczNTMzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzczODYyNA==", "url": "https://github.com/confluentinc/ksql/pull/5775#discussion_r453738624", "bodyText": "Not a big deal but is it really worth putting this method in its own class? Might be simpler to just have the method in the class where it's used.", "author": "purplefox", "createdAt": "2020-07-13T15:34:36Z", "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/impl/DdlDmlRequestValidators.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client.impl;\n+\n+import io.confluent.ksql.api.client.exception.KsqlClientException;\n+import java.util.concurrent.CompletableFuture;\n+\n+final class DdlDmlRequestValidators {", "originalCommit": "1d5177914a837ad3f7251052e25aad2516337cf1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcyOTQwNg==", "url": "https://github.com/confluentinc/ksql/pull/5775#discussion_r454729406", "bodyText": "Agreed this is a bit overkill but I think it's better than having the logic in ClientImpl (where the method is needed) as ClientImpl is already pretty massive. Will leave this for now.", "author": "vcrfxia", "createdAt": "2020-07-15T01:03:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzczODYyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc0NjU2OA==", "url": "https://github.com/confluentinc/ksql/pull/5775#discussion_r453746568", "bodyText": "This seems fair enough, but another way of doing this would be to check the sql the user passes to executeStatement, if it's not one of the allowed commands we can reject it before sending to the server. Would just need to trim and lower case the string, then check for string prefix.", "author": "purplefox", "createdAt": "2020-07-13T15:43:47Z", "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/impl/DdlDmlResponseHandlers.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client.impl;\n+\n+import io.confluent.ksql.api.client.exception.KsqlClientException;\n+import io.vertx.core.json.JsonObject;\n+import java.util.concurrent.CompletableFuture;\n+\n+final class DdlDmlResponseHandlers {\n+\n+  public static final String EXECUTE_STATEMENT_REQUEST_ACCEPTED_DOC =\n+      \"The ksqlDB server accepted the statement issued via executeStatement(), but the response \"\n+      + \"received is of an unexpected format. \";\n+  public static final String EXECUTE_STATEMENT_USAGE_DOC = \"The executeStatement() method is only \"\n+      + \"for 'CREATE', 'CREATE ... AS SELECT', 'DROP', 'TERMINATE', and 'INSERT INTO ... AS \"\n+      + \"SELECT' statements. \";\n+\n+  private DdlDmlResponseHandlers() {\n+  }\n+\n+  static void handleExecuteStatementResponse(\n+      final JsonObject ksqlEntity,\n+      final CompletableFuture<Void> cf\n+  ) {\n+    if (!isCommandStatusEntity(ksqlEntity)) {\n+      handleUnexpectedEntity(ksqlEntity, cf);\n+      return;\n+    }\n+\n+    cf.complete(null);\n+  }\n+\n+  static RuntimeException handleUnexpectedNumResponseEntities(final int numEntities) {\n+    if (numEntities == 0) {\n+      return new KsqlClientException(EXECUTE_STATEMENT_REQUEST_ACCEPTED_DOC\n+          + EXECUTE_STATEMENT_USAGE_DOC);\n+    }\n+\n+    throw new IllegalStateException(\n+        \"Unexpected number of entities in server response: \" + numEntities);\n+  }\n+\n+  private static boolean isCommandStatusEntity(final JsonObject ksqlEntity) {\n+    return ksqlEntity.getString(\"commandId\") != null\n+        && ksqlEntity.getJsonObject(\"commandStatus\") != null;\n+  }\n+\n+  // CHECKSTYLE_RULES.OFF: CyclomaticComplexity\n+  private static void handleUnexpectedEntity(", "originalCommit": "1d5177914a837ad3f7251052e25aad2516337cf1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc5ODM5Ng==", "url": "https://github.com/confluentinc/ksql/pull/5775#discussion_r453798396", "bodyText": "I agree the approach implemented here and the alternative approach of checking for statement prefixes are about equally brittle. The reason I prefer the implemented approach is because if we reject statements outright (before sending them to the server), then we should reject all non-DDL/DML statements outright, which requires a more complicated check than just a simple prefix check. The check would have to be:\n\nstarts with CREATE STREAM or CREATE TABLE, or\nstarts with DROP and does not contain CONNECTOR (and special casing in case connector is in quotes), or\nstarts with TERMINATE, or\nstarts with INSERT INTO and contains AS SELECT (in order to distinguish from INSERT INTO ... VALUES statements)\n\nThis logic is complicated enough that I think we'd be entering fuzzy territory on whether the client or the server should perform parsing/validation.\nHowever, there's definitely a case to be made that we should perform this more complicated check on the client, in order to prevent users from using executeStatement() to insert rows or create/drop connectors. I just don't think it makes sense to have a partially-fledged prefix check on the statement -- we should either go all in or not bother, haha.", "author": "vcrfxia", "createdAt": "2020-07-13T17:05:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc0NjU2OA=="}], "type": "inlineReview"}, {"oid": "0c5a87fa66c02bcc3148049299042887fb22cb75", "url": "https://github.com/confluentinc/ksql/commit/0c5a87fa66c02bcc3148049299042887fb22cb75", "message": "chore: switch try-catch to if-else", "committedDate": "2020-07-14T04:08:52Z", "type": "commit"}]}