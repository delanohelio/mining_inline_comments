{"pr_number": 4232, "pr_title": "feat: native map/array constructors", "pr_createdAt": "2020-01-07T00:19:13Z", "pr_url": "https://github.com/confluentinc/ksql/pull/4232", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzY4ODUwMw==", "url": "https://github.com/confluentinc/ksql/pull/4232#discussion_r363688503", "bodyText": "If this is a customer facing error message, then I think it could be better worded and I don't think we need exclamation marks ;) . Maybe something like:\n\nArray constructor can not be empty. Please supply at least one element.\n\nYou could even link to the github issue that will add support for empty/all-null arrays so that people can upvote it.", "author": "big-andy-coates", "createdAt": "2020-01-07T10:39:57Z", "path": "ksql-execution/src/main/java/io/confluent/ksql/execution/util/ExpressionTypeManager.java", "diffHunk": "@@ -331,6 +333,83 @@ public Void visitSubscriptExpression(\n       return null;\n     }\n \n+    @Override\n+    public Void visitCreateArrayExpression(\n+        final CreateArrayExpression exp,\n+        final ExpressionTypeContext context\n+    ) {\n+      if (exp.getValues().isEmpty()) {\n+        throw new KsqlException(\"Cannot extract type from empty array!\");", "originalCommit": "fc6cff1f3b319a603999c9e2b0ed591d12b1b22b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzkwMzc5Ng==", "url": "https://github.com/confluentinc/ksql/pull/4232#discussion_r363903796", "bodyText": "#4239 will link to that issue", "author": "agavra", "createdAt": "2020-01-07T19:09:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzY4ODUwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzY4ODYwMA==", "url": "https://github.com/confluentinc/ksql/pull/4232#discussion_r363688600", "bodyText": "Again with the exclamation marks ;)\nIf this is customer facing, which as a KsqlException I'm assuming it is, then maybe something like:\n\nCan not construct array with all NULL elements.\n\nYou could even link to the github issue that will add support for empty/all-null arrays so that people can upvote it.\nCan the user work around this by casting one of the NULLs to a type?  Maybe include this in the error message and add a QTT test case.\nWhat about for INSERT VALUES where the required array type is known.... can we support all nulls then?  How about empty arrays?", "author": "big-andy-coates", "createdAt": "2020-01-07T10:40:14Z", "path": "ksql-execution/src/main/java/io/confluent/ksql/execution/util/ExpressionTypeManager.java", "diffHunk": "@@ -331,6 +333,83 @@ public Void visitSubscriptExpression(\n       return null;\n     }\n \n+    @Override\n+    public Void visitCreateArrayExpression(\n+        final CreateArrayExpression exp,\n+        final ExpressionTypeContext context\n+    ) {\n+      if (exp.getValues().isEmpty()) {\n+        throw new KsqlException(\"Cannot extract type from empty array!\");\n+      }\n+\n+      final List<SqlType> sqlTypes = exp\n+          .getValues()\n+          .stream()\n+          .map(val -> {\n+            process(val, context);\n+            return context.getSqlType();\n+          })\n+          .filter(Objects::nonNull)\n+          .distinct()\n+          .collect(Collectors.toList());\n+\n+      if (sqlTypes.size() == 0) {\n+        throw new KsqlException(\"Cannot extract type from array of nulls!\");", "originalCommit": "fc6cff1f3b319a603999c9e2b0ed591d12b1b22b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzkxMDU4Ng==", "url": "https://github.com/confluentinc/ksql/pull/4232#discussion_r363910586", "bodyText": "Can the user work around this by casting one of the NULLs to a type? Maybe include this in the error message and add a QTT test case.\n\nYes and done.\n\nWhat about for INSERT VALUES where the required array type is known.... can we support all nulls then? How about empty arrays?\n\nThis is not a trivial change. I've thought about this in the context of various things (i.e. struct type inference) and it's out of scope for this PR, though technically possible.", "author": "agavra", "createdAt": "2020-01-07T19:25:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzY4ODYwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM5MTc1Ng==", "url": "https://github.com/confluentinc/ksql/pull/4232#discussion_r367391756", "bodyText": "Can we link in a github issue to track this second part please?", "author": "big-andy-coates", "createdAt": "2020-01-16T12:30:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzY4ODYwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzYzNDE0Ng==", "url": "https://github.com/confluentinc/ksql/pull/4232#discussion_r367634146", "bodyText": "#4334", "author": "agavra", "createdAt": "2020-01-16T20:30:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzY4ODYwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzY4OTE1OQ==", "url": "https://github.com/confluentinc/ksql/pull/4232#discussion_r363689159", "bodyText": "It would be useful if this message called out what the type of each element was, as it may not be clear to the user which element has a different type.\nIf/when we support casting of array elements, (see other comments), then we may want to also call this out as an option in the error message.", "author": "big-andy-coates", "createdAt": "2020-01-07T10:41:43Z", "path": "ksql-execution/src/main/java/io/confluent/ksql/execution/util/ExpressionTypeManager.java", "diffHunk": "@@ -331,6 +333,83 @@ public Void visitSubscriptExpression(\n       return null;\n     }\n \n+    @Override\n+    public Void visitCreateArrayExpression(\n+        final CreateArrayExpression exp,\n+        final ExpressionTypeContext context\n+    ) {\n+      if (exp.getValues().isEmpty()) {\n+        throw new KsqlException(\"Cannot extract type from empty array!\");\n+      }\n+\n+      final List<SqlType> sqlTypes = exp\n+          .getValues()\n+          .stream()\n+          .map(val -> {\n+            process(val, context);\n+            return context.getSqlType();\n+          })\n+          .filter(Objects::nonNull)\n+          .distinct()\n+          .collect(Collectors.toList());\n+\n+      if (sqlTypes.size() == 0) {\n+        throw new KsqlException(\"Cannot extract type from array of nulls!\");\n+      }\n+\n+      if (sqlTypes.size() != 1) {\n+        throw new KsqlException(\n+            \"Invalid array expression! All values must be of the same type.\" + exp);", "originalCommit": "fc6cff1f3b319a603999c9e2b0ed591d12b1b22b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzY4OTIzNQ==", "url": "https://github.com/confluentinc/ksql/pull/4232#discussion_r363689235", "bodyText": "If this is a customer facing error message, then I think it could be better worded and I don't think we need exclamation marks ;) . Maybe something like:\n\nMap constructor can not be empty. Please supply at least key-value pair.\n\nYou could even link to the github issue that will add support for empty/all-null maps so that people can upvote it.", "author": "big-andy-coates", "createdAt": "2020-01-07T10:41:55Z", "path": "ksql-execution/src/main/java/io/confluent/ksql/execution/util/ExpressionTypeManager.java", "diffHunk": "@@ -331,6 +333,83 @@ public Void visitSubscriptExpression(\n       return null;\n     }\n \n+    @Override\n+    public Void visitCreateArrayExpression(\n+        final CreateArrayExpression exp,\n+        final ExpressionTypeContext context\n+    ) {\n+      if (exp.getValues().isEmpty()) {\n+        throw new KsqlException(\"Cannot extract type from empty array!\");\n+      }\n+\n+      final List<SqlType> sqlTypes = exp\n+          .getValues()\n+          .stream()\n+          .map(val -> {\n+            process(val, context);\n+            return context.getSqlType();\n+          })\n+          .filter(Objects::nonNull)\n+          .distinct()\n+          .collect(Collectors.toList());\n+\n+      if (sqlTypes.size() == 0) {\n+        throw new KsqlException(\"Cannot extract type from array of nulls!\");\n+      }\n+\n+      if (sqlTypes.size() != 1) {\n+        throw new KsqlException(\n+            \"Invalid array expression! All values must be of the same type.\" + exp);\n+      }\n+\n+      context.setSqlType(SqlArray.of(sqlTypes.get(0)));\n+      return null;\n+    }\n+\n+    @Override\n+    public Void visitCreateMapExpression(\n+        final CreateMapExpression exp,\n+        final ExpressionTypeContext context\n+    ) {\n+      if (exp.getMap().isEmpty()) {\n+        throw new KsqlException(\"Cannot extract type from empty map!\");", "originalCommit": "fc6cff1f3b319a603999c9e2b0ed591d12b1b22b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzkxNDMzMw==", "url": "https://github.com/confluentinc/ksql/pull/4232#discussion_r363914333", "bodyText": "BUT eRRoRS Are SO ExCITING!!11!11!11", "author": "agavra", "createdAt": "2020-01-07T19:34:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzY4OTIzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzY4OTY1Ng==", "url": "https://github.com/confluentinc/ksql/pull/4232#discussion_r363689656", "bodyText": "Wording of error is a little strange. Maybe something like \"Only STRING keys are supported in maps\"?  Might also be useful to call out which keys are not strings and what there type is, as this may not be obvious.", "author": "big-andy-coates", "createdAt": "2020-01-07T10:43:05Z", "path": "ksql-execution/src/main/java/io/confluent/ksql/execution/util/ExpressionTypeManager.java", "diffHunk": "@@ -331,6 +333,83 @@ public Void visitSubscriptExpression(\n       return null;\n     }\n \n+    @Override\n+    public Void visitCreateArrayExpression(\n+        final CreateArrayExpression exp,\n+        final ExpressionTypeContext context\n+    ) {\n+      if (exp.getValues().isEmpty()) {\n+        throw new KsqlException(\"Cannot extract type from empty array!\");\n+      }\n+\n+      final List<SqlType> sqlTypes = exp\n+          .getValues()\n+          .stream()\n+          .map(val -> {\n+            process(val, context);\n+            return context.getSqlType();\n+          })\n+          .filter(Objects::nonNull)\n+          .distinct()\n+          .collect(Collectors.toList());\n+\n+      if (sqlTypes.size() == 0) {\n+        throw new KsqlException(\"Cannot extract type from array of nulls!\");\n+      }\n+\n+      if (sqlTypes.size() != 1) {\n+        throw new KsqlException(\n+            \"Invalid array expression! All values must be of the same type.\" + exp);\n+      }\n+\n+      context.setSqlType(SqlArray.of(sqlTypes.get(0)));\n+      return null;\n+    }\n+\n+    @Override\n+    public Void visitCreateMapExpression(\n+        final CreateMapExpression exp,\n+        final ExpressionTypeContext context\n+    ) {\n+      if (exp.getMap().isEmpty()) {\n+        throw new KsqlException(\"Cannot extract type from empty map!\");\n+      }\n+\n+      final boolean anyNonStringKeys = exp.getMap()\n+          .keySet()\n+          .stream()\n+          .map(key -> {\n+            process(key, context);\n+            return context.getSqlType();\n+          })\n+          .anyMatch(type -> !SqlTypes.STRING.equals(type));\n+      if (anyNonStringKeys) {\n+        throw new KsqlException(\"Cannot support non-string keys on maps:\" + exp);", "originalCommit": "fc6cff1f3b319a603999c9e2b0ed591d12b1b22b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzY5MDA1NQ==", "url": "https://github.com/confluentinc/ksql/pull/4232#discussion_r363690055", "bodyText": "As with ARRAYs, it might help the user if the error included the types of the values, so that they could more easily see where the issue is., e.g. a UDF that returns a type different to what they thought.\nMaybe add details of how the user could use CAST to fix the issue?", "author": "big-andy-coates", "createdAt": "2020-01-07T10:44:06Z", "path": "ksql-execution/src/main/java/io/confluent/ksql/execution/util/ExpressionTypeManager.java", "diffHunk": "@@ -331,6 +333,83 @@ public Void visitSubscriptExpression(\n       return null;\n     }\n \n+    @Override\n+    public Void visitCreateArrayExpression(\n+        final CreateArrayExpression exp,\n+        final ExpressionTypeContext context\n+    ) {\n+      if (exp.getValues().isEmpty()) {\n+        throw new KsqlException(\"Cannot extract type from empty array!\");\n+      }\n+\n+      final List<SqlType> sqlTypes = exp\n+          .getValues()\n+          .stream()\n+          .map(val -> {\n+            process(val, context);\n+            return context.getSqlType();\n+          })\n+          .filter(Objects::nonNull)\n+          .distinct()\n+          .collect(Collectors.toList());\n+\n+      if (sqlTypes.size() == 0) {\n+        throw new KsqlException(\"Cannot extract type from array of nulls!\");\n+      }\n+\n+      if (sqlTypes.size() != 1) {\n+        throw new KsqlException(\n+            \"Invalid array expression! All values must be of the same type.\" + exp);\n+      }\n+\n+      context.setSqlType(SqlArray.of(sqlTypes.get(0)));\n+      return null;\n+    }\n+\n+    @Override\n+    public Void visitCreateMapExpression(\n+        final CreateMapExpression exp,\n+        final ExpressionTypeContext context\n+    ) {\n+      if (exp.getMap().isEmpty()) {\n+        throw new KsqlException(\"Cannot extract type from empty map!\");\n+      }\n+\n+      final boolean anyNonStringKeys = exp.getMap()\n+          .keySet()\n+          .stream()\n+          .map(key -> {\n+            process(key, context);\n+            return context.getSqlType();\n+          })\n+          .anyMatch(type -> !SqlTypes.STRING.equals(type));\n+      if (anyNonStringKeys) {\n+        throw new KsqlException(\"Cannot support non-string keys on maps:\" + exp);\n+      }\n+\n+      final List<SqlType> sqlTypes = exp.getMap()\n+          .values()\n+          .stream()\n+          .map(val -> {\n+            process(val, context);\n+            return context.getSqlType();\n+          })\n+          .distinct()\n+          .collect(Collectors.toList());\n+\n+      if (sqlTypes.size() != 1) {\n+        throw new KsqlException(\n+            \"Invalid map expression! All values must be of the same type. \" + exp);", "originalCommit": "fc6cff1f3b319a603999c9e2b0ed591d12b1b22b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk0ODMzNg==", "url": "https://github.com/confluentinc/ksql/pull/4232#discussion_r363948336", "bodyText": "Added a better error message, but I don't think we need to tell the user to CAST as that may not be the right solution for them.", "author": "agavra", "createdAt": "2020-01-07T20:59:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzY5MDA1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM5MzA0Ng==", "url": "https://github.com/confluentinc/ksql/pull/4232#discussion_r367393046", "bodyText": "What's the issue with suggesting CAST as a possible solution? We're not forcing them to use it...", "author": "big-andy-coates", "createdAt": "2020-01-16T12:34:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzY5MDA1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzYzNDc4Nw==", "url": "https://github.com/confluentinc/ksql/pull/4232#discussion_r367634787", "bodyText": "Fair enough", "author": "agavra", "createdAt": "2020-01-16T20:32:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzY5MDA1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzY5MDE1OA==", "url": "https://github.com/confluentinc/ksql/pull/4232#discussion_r363690158", "bodyText": "Maybe something like:\n\nCan not construct MAP with all NULL values.\n\nYou could even link to the github issue that will add support for empty/all-null arrays so that people can upvote it.\nCan the user work around this by casting one of the NULLs to a type?  Maybe include this in the error message and add a QTT test case.\nWhat about for INSERT VALUES where the required map type is known.... can we support all nulls then?  How about empty maps?", "author": "big-andy-coates", "createdAt": "2020-01-07T10:44:23Z", "path": "ksql-execution/src/main/java/io/confluent/ksql/execution/util/ExpressionTypeManager.java", "diffHunk": "@@ -331,6 +333,83 @@ public Void visitSubscriptExpression(\n       return null;\n     }\n \n+    @Override\n+    public Void visitCreateArrayExpression(\n+        final CreateArrayExpression exp,\n+        final ExpressionTypeContext context\n+    ) {\n+      if (exp.getValues().isEmpty()) {\n+        throw new KsqlException(\"Cannot extract type from empty array!\");\n+      }\n+\n+      final List<SqlType> sqlTypes = exp\n+          .getValues()\n+          .stream()\n+          .map(val -> {\n+            process(val, context);\n+            return context.getSqlType();\n+          })\n+          .filter(Objects::nonNull)\n+          .distinct()\n+          .collect(Collectors.toList());\n+\n+      if (sqlTypes.size() == 0) {\n+        throw new KsqlException(\"Cannot extract type from array of nulls!\");\n+      }\n+\n+      if (sqlTypes.size() != 1) {\n+        throw new KsqlException(\n+            \"Invalid array expression! All values must be of the same type.\" + exp);\n+      }\n+\n+      context.setSqlType(SqlArray.of(sqlTypes.get(0)));\n+      return null;\n+    }\n+\n+    @Override\n+    public Void visitCreateMapExpression(\n+        final CreateMapExpression exp,\n+        final ExpressionTypeContext context\n+    ) {\n+      if (exp.getMap().isEmpty()) {\n+        throw new KsqlException(\"Cannot extract type from empty map!\");\n+      }\n+\n+      final boolean anyNonStringKeys = exp.getMap()\n+          .keySet()\n+          .stream()\n+          .map(key -> {\n+            process(key, context);\n+            return context.getSqlType();\n+          })\n+          .anyMatch(type -> !SqlTypes.STRING.equals(type));\n+      if (anyNonStringKeys) {\n+        throw new KsqlException(\"Cannot support non-string keys on maps:\" + exp);\n+      }\n+\n+      final List<SqlType> sqlTypes = exp.getMap()\n+          .values()\n+          .stream()\n+          .map(val -> {\n+            process(val, context);\n+            return context.getSqlType();\n+          })\n+          .distinct()\n+          .collect(Collectors.toList());\n+\n+      if (sqlTypes.size() != 1) {\n+        throw new KsqlException(\n+            \"Invalid map expression! All values must be of the same type. \" + exp);\n+      }\n+\n+      if (sqlTypes.get(0) == null) {\n+        throw new KsqlException(\"Maps do not accept null values!\");", "originalCommit": "fc6cff1f3b319a603999c9e2b0ed591d12b1b22b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk0ODU3OQ==", "url": "https://github.com/confluentinc/ksql/pull/4232#discussion_r363948579", "bodyText": "See above", "author": "agavra", "createdAt": "2020-01-07T21:00:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzY5MDE1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM5NDMzMQ==", "url": "https://github.com/confluentinc/ksql/pull/4232#discussion_r367394331", "bodyText": "Second part you've covered above. Lets just make sure its captured in an issue, maybe linking to it from the error.\nStill think the error message could be improve to:\n| Can not construct MAP with all NULL values.\nAnd add the trick of using CAST.", "author": "big-andy-coates", "createdAt": "2020-01-16T12:37:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzY5MDE1OA=="}], "type": "inlineReview"}, {"oid": "a22eff5a55d3979b44882c71cd532be9ddd31327", "url": "https://github.com/confluentinc/ksql/commit/a22eff5a55d3979b44882c71cd532be9ddd31327", "message": "feat: improve error messages", "committedDate": "2020-01-07T21:21:08Z", "type": "forcePushed"}, {"oid": "841a14d02977d865beef46137eaab0a21d6fe055", "url": "https://github.com/confluentinc/ksql/commit/841a14d02977d865beef46137eaab0a21d6fe055", "message": "feat: improve error messages", "committedDate": "2020-01-13T18:58:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM5MTU4NQ==", "url": "https://github.com/confluentinc/ksql/pull/4232#discussion_r367391585", "bodyText": "nit: consider changing 'the NULL' to 'a NULL'.  There could be multiple nulls and only one needs to be none-null", "author": "big-andy-coates", "createdAt": "2020-01-16T12:30:00Z", "path": "ksql-execution/src/main/java/io/confluent/ksql/execution/util/ExpressionTypeManager.java", "diffHunk": "@@ -331,6 +334,94 @@ public Void visitSubscriptExpression(\n       return null;\n     }\n \n+    @Override\n+    public Void visitCreateArrayExpression(\n+        final CreateArrayExpression exp,\n+        final ExpressionTypeContext context\n+    ) {\n+      if (exp.getValues().isEmpty()) {\n+        throw new KsqlException(\n+            \"Array constructor cannot be empty. Please supply at least one element \"\n+                + \"(see https://github.com/confluentinc/ksql/issues/4239).\");\n+      }\n+\n+      final List<SqlType> sqlTypes = exp\n+          .getValues()\n+          .stream()\n+          .map(val -> {\n+            process(val, context);\n+            return context.getSqlType();\n+          })\n+          .filter(Objects::nonNull)\n+          .collect(Collectors.toList());\n+\n+      if (sqlTypes.size() == 0) {\n+        throw new KsqlException(\"Cannot construct an array with all NULL elements \"\n+            + \"(see https://github.com/confluentinc/ksql/issues/4239). As a workaround, you may \"\n+            + \"cast the NULL value to a desired type.\");", "originalCommit": "841a14d02977d865beef46137eaab0a21d6fe055", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzM5MzgzNw==", "url": "https://github.com/confluentinc/ksql/pull/4232#discussion_r367393837", "bodyText": "super nit: can we call this valueTypes and the other keyTypes to make it clear?", "author": "big-andy-coates", "createdAt": "2020-01-16T12:35:53Z", "path": "ksql-execution/src/main/java/io/confluent/ksql/execution/util/ExpressionTypeManager.java", "diffHunk": "@@ -331,6 +334,94 @@ public Void visitSubscriptExpression(\n       return null;\n     }\n \n+    @Override\n+    public Void visitCreateArrayExpression(\n+        final CreateArrayExpression exp,\n+        final ExpressionTypeContext context\n+    ) {\n+      if (exp.getValues().isEmpty()) {\n+        throw new KsqlException(\n+            \"Array constructor cannot be empty. Please supply at least one element \"\n+                + \"(see https://github.com/confluentinc/ksql/issues/4239).\");\n+      }\n+\n+      final List<SqlType> sqlTypes = exp\n+          .getValues()\n+          .stream()\n+          .map(val -> {\n+            process(val, context);\n+            return context.getSqlType();\n+          })\n+          .filter(Objects::nonNull)\n+          .collect(Collectors.toList());\n+\n+      if (sqlTypes.size() == 0) {\n+        throw new KsqlException(\"Cannot construct an array with all NULL elements \"\n+            + \"(see https://github.com/confluentinc/ksql/issues/4239). As a workaround, you may \"\n+            + \"cast the NULL value to a desired type.\");\n+      }\n+\n+      if (new HashSet<>(sqlTypes).size() != 1) {\n+        throw new KsqlException(\n+            String.format(\n+                \"Cannot construct an array with mismatching types (%s) from expression %s.\",\n+                sqlTypes,\n+                exp));\n+      }\n+\n+      context.setSqlType(SqlArray.of(sqlTypes.get(0)));\n+      return null;\n+    }\n+\n+    @Override\n+    public Void visitCreateMapExpression(\n+        final CreateMapExpression exp,\n+        final ExpressionTypeContext context\n+    ) {\n+      if (exp.getMap().isEmpty()) {\n+        throw new KsqlException(\"Map constructor cannot be empty. Please supply at least one key \"\n+            + \"value pair (see https://github.com/confluentinc/ksql/issues/4239).\");\n+      }\n+\n+      final List<SqlType> gkeyTypes = exp.getMap()\n+          .keySet()\n+          .stream()\n+          .map(key -> {\n+            process(key, context);\n+            return context.getSqlType();\n+          })\n+          .collect(Collectors.toList());\n+\n+      if (gkeyTypes.stream().anyMatch(type -> !SqlTypes.STRING.equals(type))) {\n+        throw new KsqlException(\"Only STRING keys are supported in maps but got: \" + gkeyTypes);\n+      }\n+\n+      final List<SqlType> sqlTypes = exp.getMap()", "originalCommit": "841a14d02977d865beef46137eaab0a21d6fe055", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "74d5d9436b449194b36d00f8fa969892b0df269e", "url": "https://github.com/confluentinc/ksql/commit/74d5d9436b449194b36d00f8fa969892b0df269e", "message": "feat: native map/array constructors\n\nBREAKING CHANGE: the old syntax for creating arrays using the builtin\nAS_ARRAY function will no longer work", "committedDate": "2020-01-17T17:36:20Z", "type": "commit"}, {"oid": "911761ae0337c61aa0ffb3fd95ae61a0bc4f0ac1", "url": "https://github.com/confluentinc/ksql/commit/911761ae0337c61aa0ffb3fd95ae61a0bc4f0ac1", "message": "feat: improve error messages", "committedDate": "2020-01-17T17:36:20Z", "type": "commit"}, {"oid": "79dff2ffe287a7fff2893d6e584652a3baeec219", "url": "https://github.com/confluentinc/ksql/commit/79dff2ffe287a7fff2893d6e584652a3baeec219", "message": "fix: andys comments", "committedDate": "2020-01-17T18:09:13Z", "type": "commit"}, {"oid": "79dff2ffe287a7fff2893d6e584652a3baeec219", "url": "https://github.com/confluentinc/ksql/commit/79dff2ffe287a7fff2893d6e584652a3baeec219", "message": "fix: andys comments", "committedDate": "2020-01-17T18:09:13Z", "type": "forcePushed"}]}