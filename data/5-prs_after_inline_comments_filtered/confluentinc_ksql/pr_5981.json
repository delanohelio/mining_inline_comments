{"pr_number": 5981, "pr_title": "test: parsing for SQL-driven testing tool", "pr_createdAt": "2020-08-11T18:25:39Z", "pr_url": "https://github.com/confluentinc/ksql/pull/5981", "timeline": [{"oid": "0e6bcd9f59bffcb44ce475fe463b872103d0cc82", "url": "https://github.com/confluentinc/ksql/commit/0e6bcd9f59bffcb44ce475fe463b872103d0cc82", "message": "test: parsing for SQL-driven testing tool", "committedDate": "2020-08-11T21:33:50Z", "type": "forcePushed"}, {"oid": "ff8e7bf7be7af09cda63b5b0c0edba47499d0132", "url": "https://github.com/confluentinc/ksql/commit/ff8e7bf7be7af09cda63b5b0c0edba47499d0132", "message": "test: parsing for SQL-driven testing tool", "committedDate": "2020-08-11T23:35:58Z", "type": "forcePushed"}, {"oid": "463abffeff43db1f28da8ceeb221bd471286d811", "url": "https://github.com/confluentinc/ksql/commit/463abffeff43db1f28da8ceeb221bd471286d811", "message": "test: parsing for SQL-driven testing tool", "committedDate": "2020-08-11T23:57:46Z", "type": "forcePushed"}, {"oid": "2158240b495cae179d19b19b3a0188cad0e9327e", "url": "https://github.com/confluentinc/ksql/commit/2158240b495cae179d19b19b3a0188cad0e9327e", "message": "test: parsing for SQL-driven testing tool", "committedDate": "2020-08-12T15:43:16Z", "type": "commit"}, {"oid": "2158240b495cae179d19b19b3a0188cad0e9327e", "url": "https://github.com/confluentinc/ksql/commit/2158240b495cae179d19b19b3a0188cad0e9327e", "message": "test: parsing for SQL-driven testing tool", "committedDate": "2020-08-12T15:43:16Z", "type": "forcePushed"}, {"oid": "01586b3fe84521018575fccbed9533265c7a9230", "url": "https://github.com/confluentinc/ksql/commit/01586b3fe84521018575fccbed9533265c7a9230", "message": "chore: change sql reader to not depend on engine", "committedDate": "2020-08-18T00:05:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3MDExNw==", "url": "https://github.com/confluentinc/ksql/pull/5981#discussion_r472070117", "bodyText": "I don't understand this comment...", "author": "big-andy-coates", "createdAt": "2020-08-18T10:14:18Z", "path": "ksqldb-functional-tests/src/main/java/io/confluent/ksql/test/parser/SqlTestReader.java", "diffHunk": "@@ -0,0 +1,162 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.test.parser;\n+\n+import io.confluent.ksql.KsqlExecutionContext;\n+import io.confluent.ksql.metastore.TypeRegistry;\n+import io.confluent.ksql.parser.AstBuilder;\n+import io.confluent.ksql.parser.CaseInsensitiveStream;\n+import io.confluent.ksql.parser.DefaultKsqlParser;\n+import io.confluent.ksql.parser.ParsingException;\n+import io.confluent.ksql.parser.SqlBaseLexer;\n+import io.confluent.ksql.parser.SqlBaseParser;\n+import io.confluent.ksql.parser.SqlBaseParser.TestStatementContext;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.Iterator;\n+import java.util.Objects;\n+import java.util.regex.Pattern;\n+import org.antlr.v4.runtime.BaseErrorListener;\n+import org.antlr.v4.runtime.CharStream;\n+import org.antlr.v4.runtime.CharStreams;\n+import org.antlr.v4.runtime.CommonTokenStream;\n+import org.antlr.v4.runtime.RecognitionException;\n+import org.antlr.v4.runtime.Recognizer;\n+import org.antlr.v4.runtime.Token;\n+\n+/**\n+ * The {@code SqlTestReader} is an iterator over a test case that will return\n+ * one test statement to execute at a time.\n+ *\n+ * <p>Since some test directives are not part of the ksqlDB grammar and are\n+ * handled via non-default ANTLR channels, this parser has a more complex\n+ * iteration. Specifically, the reader uses the {@code SqlBaseParser} to read\n+ * statements, but checks to see if any directives were skipped in the underlying\n+ * hidden channels.</p>\n+ */\n+public class SqlTestReader implements Iterator<TestStatement> {\n+\n+  private static final BaseErrorListener ERROR_LISTENER = new BaseErrorListener() {\n+    @Override\n+    public void syntaxError(\n+        final Recognizer<?, ?> recognizer,\n+        final Object offendingSymbol,\n+        final int line,\n+        final int charPositionInLine,\n+        final String message,\n+        final RecognitionException e\n+    ) {\n+      throw new ParsingException(message, e, line, charPositionInLine);\n+    }\n+  };\n+\n+  private static final Pattern TEST_DIRECTIVE_REGEX =\n+      Pattern.compile(\"(?m)^--@test:\\\\s*(?<name>.*)$\");\n+\n+  private final SqlBaseParser parser;\n+  private final CommonTokenStream tks;\n+\n+  /* indicates the latest index in tks that has been scanned for directives */\n+  private int directiveIdx = 0;\n+\n+  /* whether or not a statement has been read, but not yet returned */\n+  private boolean cachedStatement = false;\n+  private TestStatementContext testStatement;\n+\n+  public static SqlTestReader of(\n+      final String test\n+  ) {\n+    return new SqlTestReader(CharStreams.fromString(test));\n+  }\n+\n+  /**\n+   * @param file     the test file\n+   */\n+  public static SqlTestReader of(\n+      final Path file\n+  ) throws IOException {\n+    final CharStream chars = CharStreams.fromPath(file);\n+    return new SqlTestReader(chars);\n+  }\n+\n+  private SqlTestReader(final CharStream chars) {\n+    Objects.requireNonNull(chars, \"chars\");\n+\n+    final SqlBaseLexer lexer = new SqlBaseLexer(new CaseInsensitiveStream(chars));\n+    lexer.removeErrorListeners();\n+    lexer.addErrorListener(ERROR_LISTENER);\n+\n+    tks = new CommonTokenStream(lexer);\n+\n+    parser = new SqlBaseParser(tks);\n+    parser.removeErrorListeners();\n+    parser.addErrorListener(ERROR_LISTENER);\n+  }\n+\n+  @Override\n+  public boolean hasNext() {\n+    return cachedStatement\n+        || !parser.isMatchedEOF()\n+        || hasMoreDirectives();\n+  }\n+\n+  private boolean hasMoreDirectives() {\n+    for (int i = 0; directiveIdx + i < tks.size(); i++) {\n+      if (tks.get(directiveIdx + i).getChannel() == SqlBaseLexer.DIRECTIVES) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  @Override\n+  public TestStatement next() {\n+    // because the parser skips over non-default (SqlBaseLexer.DIRECTIVES) channels,\n+    // we need to first get the next test statement and then check if we \"skipped\"\n+    // over any comments that contain directives. if we find any directives, we\n+    // cache the statement that the parser read and hold off on returning it\n+    if (!cachedStatement && !parser.isMatchedEOF()) {\n+      testStatement = parser.testStatement(); // advances the token stream\n+      cachedStatement = true;\n+    }\n+\n+    // if there's no cachedStatement at this point, we've hit EOF", "originalCommit": "01586b3fe84521018575fccbed9533265c7a9230", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI4Njg4Nw==", "url": "https://github.com/confluentinc/ksql/pull/5981#discussion_r472286887", "bodyText": "I will clarify the comment :)", "author": "agavra", "createdAt": "2020-08-18T15:31:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3MDExNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3MjE4NQ==", "url": "https://github.com/confluentinc/ksql/pull/5981#discussion_r472072185", "bodyText": "Is it worth thinking about using Antlr for parsing the directive content? e.g. another syntax file that defines the format of directives?\nMay make it easier to extend in the future, without having to write complex regex and parsing code.", "author": "big-andy-coates", "createdAt": "2020-08-18T10:18:01Z", "path": "ksqldb-functional-tests/src/main/java/io/confluent/ksql/test/parser/TestDirective.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.test.parser;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Functions;\n+import io.confluent.ksql.parser.ParsingException;\n+import io.confluent.ksql.parser.SqlBaseLexer;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import org.antlr.v4.runtime.Token;\n+\n+/**\n+ * A test directive indicates special handling of test-only metadata. The\n+ * directive is specified in the test sql file as a single-line comment that\n+ * begins with * {@code --@} and the directive type and contents are separated\n+ * by a colon. The type must contain only letters and \".\" characters.\n+ *\n+ * <p>For example, tests are delimited using the {@code TEST} directive, which\n+ * would be specified in a file using {@code --@test: name}. The directive types\n+ * are case-insensitive.</p>\n+ *\n+ * <p>The ANTLR grammar that parses comments will handle directives differently\n+ * from normal comments, and will send them to the {@link SqlBaseLexer#DIRECTIVES}\n+ * channel. See {@link SqlTestReader} for more handling of directives.</p>\n+ */\n+public class TestDirective {", "originalCommit": "01586b3fe84521018575fccbed9533265c7a9230", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI4NzY5Nw==", "url": "https://github.com/confluentinc/ksql/pull/5981#discussion_r472287697", "bodyText": "this could definitely be worth it so we can specify different types of directives, for now I think it's a little overkill - I'll explore this in a future PR", "author": "agavra", "createdAt": "2020-08-18T15:32:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3MjE4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3Mjk0Nw==", "url": "https://github.com/confluentinc/ksql/pull/5981#discussion_r472072947", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                ;\n          \n          \n            \n                ENABLED(\"enabled\");", "author": "big-andy-coates", "createdAt": "2020-08-18T10:19:36Z", "path": "ksqldb-functional-tests/src/main/java/io/confluent/ksql/test/parser/TestDirective.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.test.parser;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Functions;\n+import io.confluent.ksql.parser.ParsingException;\n+import io.confluent.ksql.parser.SqlBaseLexer;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import org.antlr.v4.runtime.Token;\n+\n+/**\n+ * A test directive indicates special handling of test-only metadata. The\n+ * directive is specified in the test sql file as a single-line comment that\n+ * begins with * {@code --@} and the directive type and contents are separated\n+ * by a colon. The type must contain only letters and \".\" characters.\n+ *\n+ * <p>For example, tests are delimited using the {@code TEST} directive, which\n+ * would be specified in a file using {@code --@test: name}. The directive types\n+ * are case-insensitive.</p>\n+ *\n+ * <p>The ANTLR grammar that parses comments will handle directives differently\n+ * from normal comments, and will send them to the {@link SqlBaseLexer#DIRECTIVES}\n+ * channel. See {@link SqlTestReader} for more handling of directives.</p>\n+ */\n+public class TestDirective {\n+\n+  static final Pattern DIRECTIVE_REGEX = Pattern.compile(\n+      \"--@(?<type>[a-zA-Z.]+):\\\\s*(?<contents>.*)\"\n+  );\n+\n+  private final Type type;\n+  private final String contents;\n+\n+  public static TestDirective parse(final Token comment) {\n+    final Matcher matcher = DIRECTIVE_REGEX.matcher(comment.getText().trim());\n+    if (!matcher.find()) {\n+      throw new ParsingException(\n+          \"Expected directive matching pattern \" + DIRECTIVE_REGEX + \" but got \" + comment,\n+          null,\n+          comment.getLine(),\n+          comment.getCharPositionInLine()\n+      );\n+    }\n+\n+    final Type type = Type.from(matcher.group(\"type\").toLowerCase());\n+    final String contents = matcher.group(\"contents\");\n+\n+    return new TestDirective(type, contents);\n+  }\n+\n+  @VisibleForTesting\n+  TestDirective(final Type type, final String contents) {\n+    this.type = Objects.requireNonNull(type, \"type\");\n+    this.contents = Objects.requireNonNull(contents, \"contents\");\n+  }\n+\n+  public Type getType() {\n+    return type;\n+  }\n+\n+  public String getContents() {\n+    return contents;\n+  }\n+\n+  @Override\n+  public boolean equals(final Object o) {\n+    if (this == o) {\n+      return true;\n+    }\n+\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+\n+    final TestDirective that = (TestDirective) o;\n+    return type == that.type\n+        && Objects.equals(contents, that.contents);\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return Objects.hash(type, contents);\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return \"TestDirective{\"\n+        + \"type=\" + type\n+        + \", contents='\" + contents + '\\''\n+        + '}';\n+  }\n+\n+  public enum Type {\n+    TEST(\"test\"),\n+    EXPECTED_ERROR(\"expected.error\"),\n+    EXPECTED_MESSAGE(\"expected.message\"),\n+    UNKNOWN(\"UNKNOWN\")\n+    ;", "originalCommit": "01586b3fe84521018575fccbed9533265c7a9230", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3MzU1NQ==", "url": "https://github.com/confluentinc/ksql/pull/5981#discussion_r472073555", "bodyText": "What's this for?\nIf this is just so that from can return something, why not make from return Optional<Type>?\nMay be worth adding Java docs to each of these types with an explanation of what they do and how they should be used... or better yet... start compiling .md files for format of tests.  We have this for QTT. Need it for YATT too.", "author": "big-andy-coates", "createdAt": "2020-08-18T10:20:45Z", "path": "ksqldb-functional-tests/src/main/java/io/confluent/ksql/test/parser/TestDirective.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.test.parser;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Functions;\n+import io.confluent.ksql.parser.ParsingException;\n+import io.confluent.ksql.parser.SqlBaseLexer;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import org.antlr.v4.runtime.Token;\n+\n+/**\n+ * A test directive indicates special handling of test-only metadata. The\n+ * directive is specified in the test sql file as a single-line comment that\n+ * begins with * {@code --@} and the directive type and contents are separated\n+ * by a colon. The type must contain only letters and \".\" characters.\n+ *\n+ * <p>For example, tests are delimited using the {@code TEST} directive, which\n+ * would be specified in a file using {@code --@test: name}. The directive types\n+ * are case-insensitive.</p>\n+ *\n+ * <p>The ANTLR grammar that parses comments will handle directives differently\n+ * from normal comments, and will send them to the {@link SqlBaseLexer#DIRECTIVES}\n+ * channel. See {@link SqlTestReader} for more handling of directives.</p>\n+ */\n+public class TestDirective {\n+\n+  static final Pattern DIRECTIVE_REGEX = Pattern.compile(\n+      \"--@(?<type>[a-zA-Z.]+):\\\\s*(?<contents>.*)\"\n+  );\n+\n+  private final Type type;\n+  private final String contents;\n+\n+  public static TestDirective parse(final Token comment) {\n+    final Matcher matcher = DIRECTIVE_REGEX.matcher(comment.getText().trim());\n+    if (!matcher.find()) {\n+      throw new ParsingException(\n+          \"Expected directive matching pattern \" + DIRECTIVE_REGEX + \" but got \" + comment,\n+          null,\n+          comment.getLine(),\n+          comment.getCharPositionInLine()\n+      );\n+    }\n+\n+    final Type type = Type.from(matcher.group(\"type\").toLowerCase());\n+    final String contents = matcher.group(\"contents\");\n+\n+    return new TestDirective(type, contents);\n+  }\n+\n+  @VisibleForTesting\n+  TestDirective(final Type type, final String contents) {\n+    this.type = Objects.requireNonNull(type, \"type\");\n+    this.contents = Objects.requireNonNull(contents, \"contents\");\n+  }\n+\n+  public Type getType() {\n+    return type;\n+  }\n+\n+  public String getContents() {\n+    return contents;\n+  }\n+\n+  @Override\n+  public boolean equals(final Object o) {\n+    if (this == o) {\n+      return true;\n+    }\n+\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+\n+    final TestDirective that = (TestDirective) o;\n+    return type == that.type\n+        && Objects.equals(contents, that.contents);\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return Objects.hash(type, contents);\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return \"TestDirective{\"\n+        + \"type=\" + type\n+        + \", contents='\" + contents + '\\''\n+        + '}';\n+  }\n+\n+  public enum Type {\n+    TEST(\"test\"),\n+    EXPECTED_ERROR(\"expected.error\"),\n+    EXPECTED_MESSAGE(\"expected.message\"),\n+    UNKNOWN(\"UNKNOWN\")", "originalCommit": "01586b3fe84521018575fccbed9533265c7a9230", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI4OTQxNA==", "url": "https://github.com/confluentinc/ksql/pull/5981#discussion_r472289414", "bodyText": "I prefer having an UNKNOWN over an optional so that we don't always have to check if present and then just have a switch statement on the enum anyway.\nI'll add javadoc, and then when the code is somewhat ready for public consumption I'll add all the formal docs. This push was really to get it in a state where I can use it for query upgrades (and after that this will likely be a main project for me anyway, so I'll have dedicated time on it)", "author": "agavra", "createdAt": "2020-08-18T15:34:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3MzU1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM3MDc3Nw==", "url": "https://github.com/confluentinc/ksql/pull/5981#discussion_r472370777", "bodyText": "Sure, no worries if you feel strongly about it.\nI only raise it as I've seen such patterns before, where the enum includes an 'UNKNOWN' or 'error' value. It can result in the code becoming littered with switch statements that contain the UNKNOWN case, which then throw an exception, even though it can never be hit, because some earlier check has already handled it.\nIs there any reason why you can't just throw an exception with the location saying 'unknown directive'?", "author": "big-andy-coates", "createdAt": "2020-08-18T17:40:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3MzU1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM3NTgzNQ==", "url": "https://github.com/confluentinc/ksql/pull/5981#discussion_r472375835", "bodyText": "My instinct was to have it just ignore unknown directives and move on (as if it were another comment) so that tests can be parsed in previous versions where the directives may not exist. I'm happy also throwing the exception here in parse-time if we don't want that behavior", "author": "agavra", "createdAt": "2020-08-18T17:49:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3MzU1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3NTMxMw==", "url": "https://github.com/confluentinc/ksql/pull/5981#discussion_r472075313", "bodyText": "A cleaner API might be to store and return Optionals, e.g.\npublic Optional<ParsedStatement> getEngineStatement() {...}\nThis does away with the need for the has family of methods, and means the compiler/IDE can check for access to the optional without a matching isPresent etc, which you don't get by cutting your own version.\nAlso, consider adding a more functional  method that can take Consumers for each type in the union, simplifying code needing to handle this tri-state type.\n   void accept(\n     final Consumer<ParsedStatement> sqlConsumer, \n     final Consumer<AssertStatement<?> assertConsumer,\n     final Consumer<TestDirective> directiveConsumer\n  );", "author": "big-andy-coates", "createdAt": "2020-08-18T10:24:22Z", "path": "ksqldb-functional-tests/src/main/java/io/confluent/ksql/test/parser/TestStatement.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.test.parser;\n+\n+import io.confluent.ksql.parser.KsqlParser.ParsedStatement;\n+import io.confluent.ksql.parser.tree.AssertStatement;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.stream.Stream;\n+\n+/**\n+ * A single line of a test execution. A {@code TestStatement} can consist of\n+ * either:\n+ * <ul>\n+ *   <li> a {@link ParsedStatement}, which will issue an update to the ksqlDB, or </li>\n+ *   <li> an {@link AssertStatement}, which will ensure data is accurate, or </li>\n+ *   <li> a {@link TestDirective}, which will ensure some metadata on the test </li>\n+ * </ul>\n+ */\n+public final class TestStatement {", "originalCommit": "01586b3fe84521018575fccbed9533265c7a9230", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI5NDc2NA==", "url": "https://github.com/confluentinc/ksql/pull/5981#discussion_r472294764", "bodyText": "I had thought about this, but I think in practice this makes the code harder to read and understand. This is not a class with three optional fields, this is a \"OneOf\" class - if there were only three get statements, then the API suggests that any combination of them can be present.\nI do like your accept suggestion, though, in which case I just won't expose the fields at all and the discussion becomes moot \ud83d\ude02\nEDIT: since I have a stacked PR ready to go though I'll remove the existing methods in the next PR", "author": "agavra", "createdAt": "2020-08-18T15:42:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3NTMxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM3MjQyNw==", "url": "https://github.com/confluentinc/ksql/pull/5981#discussion_r472372427", "bodyText": "Not sure I follow why you think hasXXX methods better impart that it's a  \"OneOf\" class that using Optional.  But if its moot, then let's move on.\nhummm... I guess you could call them hasOnlyXXXX to make the union clear. :p", "author": "big-andy-coates", "createdAt": "2020-08-18T17:43:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA3NTMxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA4NDg2NQ==", "url": "https://github.com/confluentinc/ksql/pull/5981#discussion_r472084865", "bodyText": "If SqlTestReader was an Iterable rather than an Iterator then you're tests could be simple:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                assertThat(reader.hasNext(), is(true));\n          \n          \n            \n                assertThat(reader.next(), is(TestStatement.of(new TestDirective(Type.TEST, \"test1\"))));\n          \n          \n            \n                assertThat(reader.hasNext(), is(true));\n          \n          \n            \n                assertThat(reader.next().getEngineStatement().getStatementText(), containsString(\"CREATE STREAM foo\"));\n          \n          \n            \n                assertThat(reader.hasNext(), is(true));\n          \n          \n            \n                assertThat(reader.next().getEngineStatement().getStatementText(), containsString(\"CREATE STREAM bar\"));\n          \n          \n            \n                assertThat(reader.hasNext(), is(true));\n          \n          \n            \n                assertThat(reader.next().getEngineStatement().getStatementText(), containsString(\"INSERT INTO\"));\n          \n          \n            \n                assertThat(reader.hasNext(), is(true));\n          \n          \n            \n                assertThat(reader.next().getAssertStatement(), instanceOf(AssertValues.class));\n          \n          \n            \n                assertThat(reader.hasNext(), is(false));\n          \n          \n            \n                assertThat(reader, contains(\n          \n          \n            \n                   is(TestStatement.of(new TestDirective(Type.TEST, \"test1\"))),\n          \n          \n            \n                   is(engineStatement(\"CREATE STREAM foo (id INT KEY, col1 INT) WITH (kafka_topic='a', value_format='json');\")),\n          \n          \n            \n                   is(engineStatement(\"CREATE STREAM bar AS SELECT * FROM foo;\")),\n          \n          \n            \n                   ... etc.\n          \n          \n            \n                ));\n          \n      \n    \n    \n  \n\nJust a thought... not a biggie.", "author": "big-andy-coates", "createdAt": "2020-08-18T10:43:05Z", "path": "ksqldb-functional-tests/src/test/java/io/confluent/ksql/test/parser/SqlTestReaderTest.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.test.parser;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertThrows;\n+\n+import io.confluent.ksql.parser.ParsingException;\n+import io.confluent.ksql.parser.tree.AssertValues;\n+import io.confluent.ksql.test.parser.TestDirective.Type;\n+import org.junit.Test;\n+\n+@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+public class SqlTestReaderTest {\n+\n+  @Test\n+  public void shouldParseBasicTest() {\n+    // Given:\n+    final String contents = \"\"\n+        + \"--@test: test1\\n\"\n+        + \"CREATE STREAM foo (id INT KEY, col1 INT) WITH (kafka_topic='a', value_format='json');\\n\"\n+        + \"CREATE STREAM bar AS SELECT * FROM foo;\\n\"\n+        + \"INSERT INTO foo (id, col1) VALUES (1, 1);\\n\"\n+        + \"ASSERT VALUES bar (id, col1) VALUES (1, 1);\\n\"\n+        ;\n+\n+    // When:\n+    final SqlTestReader reader = SqlTestReader.of(contents);\n+\n+    // Then:\n+    assertThat(reader.hasNext(), is(true));\n+    assertThat(reader.next(), is(TestStatement.of(new TestDirective(Type.TEST, \"test1\"))));\n+    assertThat(reader.hasNext(), is(true));\n+    assertThat(reader.next().getEngineStatement().getStatementText(), containsString(\"CREATE STREAM foo\"));\n+    assertThat(reader.hasNext(), is(true));\n+    assertThat(reader.next().getEngineStatement().getStatementText(), containsString(\"CREATE STREAM bar\"));\n+    assertThat(reader.hasNext(), is(true));\n+    assertThat(reader.next().getEngineStatement().getStatementText(), containsString(\"INSERT INTO\"));\n+    assertThat(reader.hasNext(), is(true));\n+    assertThat(reader.next().getAssertStatement(), instanceOf(AssertValues.class));\n+    assertThat(reader.hasNext(), is(false));", "originalCommit": "01586b3fe84521018575fccbed9533265c7a9230", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI5NTgxOQ==", "url": "https://github.com/confluentinc/ksql/pull/5981#discussion_r472295819", "bodyText": "not easy to implement it as an Iterable given the nature of TokenStreams and Lexers", "author": "agavra", "createdAt": "2020-08-18T15:43:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA4NDg2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM3Mzk0MQ==", "url": "https://github.com/confluentinc/ksql/pull/5981#discussion_r472373941", "bodyText": "Sure is easy. Just move all that into the iterator!  the Iterable then just storers the data to be parsed, and the iterator does the parsing and iterating.\nThough I agree it would be weird to have it as Iterable.\nBTW, why not just have it parse every line and return it as a List, then iterate through the list?   What's the benefit of it parsing as you go?", "author": "big-andy-coates", "createdAt": "2020-08-18T17:46:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA4NDg2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM3ODQ4Nw==", "url": "https://github.com/confluentinc/ksql/pull/5981#discussion_r472378487", "bodyText": "Sure is easy. Just move all that into the iterator! the Iterable then just storers the data to be parsed, and the iterator does the parsing and iterating.\n\nFair enough! Though that does feel weird :P\n\nBTW, why not just have it parse every line and return it as a List, then iterate through the list? What's the benefit of it parsing as you go?\n\nIn my next PR I actually convert it to a list elsewhere. The reason I do it this way is so that I iterate until I find a --@test directive and then I start a new list. It just felt more natural to me than building a list then iterating the list to split it into tests. I could also build the list of lists here, but it turned out nicely with an iterator.\nI don't really feel too strongly, so I'll keep this like this for now and if it causes headaches i'll make it return a list.", "author": "agavra", "createdAt": "2020-08-18T17:54:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA4NDg2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA4NTc2Nw==", "url": "https://github.com/confluentinc/ksql/pull/5981#discussion_r472085767", "bodyText": "What happens if statements aren't separated by new lines?  Either directives or SQL statements?\nI'm guessing for directives the second directive would just be in the text of the first, which is probably fine.  But can/does it support multiple SQL statements on a line, or indeed one statement spread across lines.  Tests needed :D", "author": "big-andy-coates", "createdAt": "2020-08-18T10:44:59Z", "path": "ksqldb-functional-tests/src/test/java/io/confluent/ksql/test/parser/SqlTestReaderTest.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.test.parser;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertThrows;\n+\n+import io.confluent.ksql.parser.ParsingException;\n+import io.confluent.ksql.parser.tree.AssertValues;\n+import io.confluent.ksql.test.parser.TestDirective.Type;\n+import org.junit.Test;\n+\n+@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+public class SqlTestReaderTest {", "originalCommit": "01586b3fe84521018575fccbed9533265c7a9230", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI5NjU0MA==", "url": "https://github.com/confluentinc/ksql/pull/5981#discussion_r472296540", "bodyText": "I'm guessing for directives the second directive would just be in the text of the first, which is probably fine.\n\nyes\n\nBut can/does it support multiple SQL statements on a line, or indeed one statement spread across lines.\n\nIt does support this, it uses our standard parser \ud83d\ude02\n\nTests needed :D\n\nIncoming", "author": "agavra", "createdAt": "2020-08-18T15:44:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA4NTc2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA4NzEyNQ==", "url": "https://github.com/confluentinc/ksql/pull/5981#discussion_r472087125", "bodyText": "I'd move parsing out into own Parser class and leave TestDirective as a POJO.", "author": "big-andy-coates", "createdAt": "2020-08-18T10:47:43Z", "path": "ksqldb-functional-tests/src/main/java/io/confluent/ksql/test/parser/TestDirective.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.test.parser;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Functions;\n+import io.confluent.ksql.parser.ParsingException;\n+import io.confluent.ksql.parser.SqlBaseLexer;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import org.antlr.v4.runtime.Token;\n+\n+/**\n+ * A test directive indicates special handling of test-only metadata. The\n+ * directive is specified in the test sql file as a single-line comment that\n+ * begins with * {@code --@} and the directive type and contents are separated\n+ * by a colon. The type must contain only letters and \".\" characters.\n+ *\n+ * <p>For example, tests are delimited using the {@code TEST} directive, which\n+ * would be specified in a file using {@code --@test: name}. The directive types\n+ * are case-insensitive.</p>\n+ *\n+ * <p>The ANTLR grammar that parses comments will handle directives differently\n+ * from normal comments, and will send them to the {@link SqlBaseLexer#DIRECTIVES}\n+ * channel. See {@link SqlTestReader} for more handling of directives.</p>\n+ */\n+public class TestDirective {\n+\n+  static final Pattern DIRECTIVE_REGEX = Pattern.compile(\n+      \"--@(?<type>[a-zA-Z.]+):\\\\s*(?<contents>.*)\"\n+  );\n+\n+  private final Type type;\n+  private final String contents;\n+\n+  public static TestDirective parse(final Token comment) {\n+    final Matcher matcher = DIRECTIVE_REGEX.matcher(comment.getText().trim());\n+    if (!matcher.find()) {\n+      throw new ParsingException(\n+          \"Expected directive matching pattern \" + DIRECTIVE_REGEX + \" but got \" + comment,\n+          null,\n+          comment.getLine(),\n+          comment.getCharPositionInLine()\n+      );\n+    }\n+\n+    final Type type = Type.from(matcher.group(\"type\").toLowerCase());\n+    final String contents = matcher.group(\"contents\");\n+\n+    return new TestDirective(type, contents);\n+  }", "originalCommit": "01586b3fe84521018575fccbed9533265c7a9230", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA4ODUyMw==", "url": "https://github.com/confluentinc/ksql/pull/5981#discussion_r472088523", "bodyText": "it seems strange to me that AssertStatement is template on a Statement type.  There doesn't currently seem to be any logic that calls getStatement at present, (though I'm sure you've got some planned).  I don't see why this is necessary. Can not each assert standalone and know what it needs to check? What does the generic template arg give us?\nWhy not just:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public abstract class AssertStatement<T extends Statement> extends Node  {\n          \n          \n            \n            \n          \n          \n            \n              private final T statement;\n          \n          \n            \n            \n          \n          \n            \n              protected AssertStatement(\n          \n          \n            \n                  final Optional<NodeLocation> location,\n          \n          \n            \n                  final T statement\n          \n          \n            \n              ) {\n          \n          \n            \n                super(location);\n          \n          \n            \n                this.statement = Objects.requireNonNull(statement, \"statement\");\n          \n          \n            \n              }\n          \n          \n            \n            \n          \n          \n            \n              public T getStatement() {\n          \n          \n            \n                return statement;\n          \n          \n            \n              }\n          \n          \n            \n            }\n          \n          \n            \n            public abstract class AssertStatement extends Node  {\n          \n          \n            \n            \n          \n          \n            \n              protected AssertStatement(\n          \n          \n            \n                  final Optional<NodeLocation> location\n          \n          \n            \n              ) {\n          \n          \n            \n                super(location);\n          \n          \n            \n              }\n          \n          \n            \n            }", "author": "big-andy-coates", "createdAt": "2020-08-18T10:50:36Z", "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/tree/AssertStatement.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.parser.tree;\n+\n+import io.confluent.ksql.parser.Node;\n+import io.confluent.ksql.parser.NodeLocation;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+/**\n+ * Indicates that the given {@link io.confluent.ksql.parser.Node} is used\n+ * for testing purposes.\n+ */\n+public abstract class AssertStatement<T extends Statement> extends Node  {\n+\n+  private final T statement;\n+\n+  protected AssertStatement(\n+      final Optional<NodeLocation> location,\n+      final T statement\n+  ) {\n+    super(location);\n+    this.statement = Objects.requireNonNull(statement, \"statement\");\n+  }\n+\n+  public T getStatement() {\n+    return statement;\n+  }\n+}", "originalCommit": "01586b3fe84521018575fccbed9533265c7a9230", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c0a59ee484b5babeba1c54e3d01714644b4da2d1", "url": "https://github.com/confluentinc/ksql/commit/c0a59ee484b5babeba1c54e3d01714644b4da2d1", "message": "chore: address andys comments", "committedDate": "2020-08-18T16:30:11Z", "type": "commit"}, {"oid": "c71fb7242644d60bec279de297e8177e0f6cb4ed", "url": "https://github.com/confluentinc/ksql/commit/c71fb7242644d60bec279de297e8177e0f6cb4ed", "message": "fix: minor fixes", "committedDate": "2020-08-18T17:06:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM3NTI2MA==", "url": "https://github.com/confluentinc/ksql/pull/5981#discussion_r472375260", "bodyText": "What happens ASSERT is used in production ksqlDB?  Worth adding a QTT test case?", "author": "big-andy-coates", "createdAt": "2020-08-18T17:48:30Z", "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/tree/AstVisitor.java", "diffHunk": "@@ -180,4 +181,16 @@ public R visitRegisterType(final RegisterType node, final C context) {\n   public R visitDropType(final DropType node, final C context) {\n     return visitStatement(node, context);\n   }\n+\n+  public R visitAssertValues(final AssertValues node, final C context) {\n+    return visitStatement(node.getStatement(), context);\n+  }\n+\n+  public R visitAssertStream(final AssertStream node, final C context) {\n+    return visitStatement(node.getStatement(), context);\n+  }\n+\n+  public R visitAssertTable(final AssertTable node, final C context) {\n+    return visitStatement(node.getStatement(), context);\n+  }", "originalCommit": "c0a59ee484b5babeba1c54e3d01714644b4da2d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM3OTM0Mg==", "url": "https://github.com/confluentinc/ksql/pull/5981#discussion_r472379342", "bodyText": "yeah, production code doesn't use the testStatement parser rule so it shouldn't find it. I'll add a test in the follow-up PR (or if the build isn't green, don't want to wait another 45min jenkins cycle \ud83d\ude04 )", "author": "agavra", "createdAt": "2020-08-18T17:55:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM3NTI2MA=="}], "type": "inlineReview"}]}