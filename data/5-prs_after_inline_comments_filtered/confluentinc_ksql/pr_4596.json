{"pr_number": 4596, "pr_title": "feat: introduce JSON_SR format", "pr_createdAt": "2020-02-20T00:59:35Z", "pr_url": "https://github.com/confluentinc/ksql/pull/4596", "timeline": [{"oid": "70c401d2744b837ee78bf69713f1312f09ef21ae", "url": "https://github.com/confluentinc/ksql/commit/70c401d2744b837ee78bf69713f1312f09ef21ae", "message": "feat: introduce JSON_SR format", "committedDate": "2020-02-20T21:19:22Z", "type": "forcePushed"}, {"oid": "479c78603a5a71a36f7703353ed7258c25b823ab", "url": "https://github.com/confluentinc/ksql/commit/479c78603a5a71a36f7703353ed7258c25b823ab", "message": "feat: introduce JSON_SR format", "committedDate": "2020-02-20T21:24:25Z", "type": "forcePushed"}, {"oid": "1a8cc2911ca05e881a84c617021bc505d1d3f8a8", "url": "https://github.com/confluentinc/ksql/commit/1a8cc2911ca05e881a84c617021bc505d1d3f8a8", "message": "feat: introduce JSON_SR format", "committedDate": "2020-02-20T22:30:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzgwNTk2OQ==", "url": "https://github.com/confluentinc/ksql/pull/4596#discussion_r383805969", "bodyText": "Why does this need to return an InputStream? It seems that all the callers really just want the bytes.\nWould it be simpler (and more efficient) just to slice the byte[] and return another one with the prefix removed?\nAlso.. I know this InputStream won't block, but as we move to a more reactive / non blocking model in the server we should avoid using blocking constructs such as input and output streams and favour buffers.", "author": "purplefox", "createdAt": "2020-02-25T10:56:03Z", "path": "ksql-serde/src/main/java/io/confluent/ksql/serde/json/JsonSerdeUtils.java", "diffHunk": "@@ -23,14 +23,59 @@\n import io.confluent.ksql.schema.connect.SchemaWalker.Visitor;\n import io.confluent.ksql.schema.ksql.PersistenceSchema;\n import io.confluent.ksql.schema.ksql.SqlBaseType;\n+import io.confluent.ksql.util.KsqlException;\n+import java.io.ByteArrayInputStream;\n+import java.io.InputStream;\n+import javax.annotation.Nonnull;\n import org.apache.kafka.connect.data.Schema;\n import org.apache.kafka.connect.data.Schema.Type;\n \n-final class JsonSerdeUtils {\n+public final class JsonSerdeUtils {\n+\n+  // the JsonSchemaConverter adds a magic NULL byte and 4 bytes for the\n+  // schema ID at the start of the message\n+  private static final int SIZE_OF_SR_PREFIX = Byte.BYTES + Integer.BYTES;\n \n   private JsonSerdeUtils() {\n   }\n \n+  /**\n+   * Converts {@code jsonWithMagic} into an {@link InputStream} that represents\n+   * standard JSON encoding.\n+   *\n+   * @param jsonWithMagic the serialized JSON\n+   * @return the corresponding input stream\n+   * @throws io.confluent.ksql.util.KsqlException If the input is not encoded\n+   *         using the schema registry format (first byte magic byte, then\n+   *         four bytes for the schemaID).\n+   */\n+  public static InputStream asStandardJson(@Nonnull final byte[] jsonWithMagic) {", "originalCommit": "1a8cc2911ca05e881a84c617021bc505d1d3f8a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzk1MDMwOA==", "url": "https://github.com/confluentinc/ksql/pull/4596#discussion_r383950308", "bodyText": "I think Almog is trying to avoid the array copy for every message when deserializing. This could be premature optimisation, but I'm guessing it will hurt performance as we already know serialization is a large cost to us.\nAn alternative to copying the data into a new buffer would be to build a parser with the original buffer and with the suitable offset:, i.e. change a line like:\n// Original code that deserialized the whole byte array:\nMAPPER.readTree(bytes);\nto\n// Build a parser with the whole array and appropriate offset into that array:\n// This avoids the array copy at the cost of slightly more complex code.\nfinal int offset = isJsonSchema ? JsonSerdeUtils.SIZE_OF_SR_PREFIX : 0;\nMAPPER.readTree(MAPPER.getFactory().createParser(bytes, offset, bytes.length - offset));", "author": "big-andy-coates", "createdAt": "2020-02-25T15:26:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzgwNTk2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzk4Mzc4Mg==", "url": "https://github.com/confluentinc/ksql/pull/4596#discussion_r383983782", "bodyText": "Copying small arrays is super fast in Java. I would bet that it would be a lot faster than constructing an InputStream around it and reading bytes one by one.", "author": "purplefox", "createdAt": "2020-02-25T16:15:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzgwNTk2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzk4NTM5NQ==", "url": "https://github.com/confluentinc/ksql/pull/4596#discussion_r383985395", "bodyText": "Also if you use ByteBuffer or Vert.x Buffers you can avoid the copy altogether as slice just references the original array with different offset and length.", "author": "purplefox", "createdAt": "2020-02-25T16:17:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzgwNTk2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA1MTkxOQ==", "url": "https://github.com/confluentinc/ksql/pull/4596#discussion_r384051919", "bodyText": "replaced with:\n    return mapper.readValue(\n        jsonWithMagic,\n        SIZE_OF_SR_PREFIX,\n        jsonWithMagic.length - SIZE_OF_SR_PREFIX,\n        clazz\n    );\nInside the method. I believe this should work.", "author": "agavra", "createdAt": "2020-02-25T18:42:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzgwNTk2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkyODgwNg==", "url": "https://github.com/confluentinc/ksql/pull/4596#discussion_r383928806", "bodyText": "Can we rename this to make the code where its use read more intuitively?  Maybe:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public static InputStream asStandardJson(@Nonnull final byte[] jsonWithMagic) {\n          \n          \n            \n              public static InputStream stripSchemaId(@Nonnull final byte[] jsonWithMagic) {", "author": "big-andy-coates", "createdAt": "2020-02-25T14:54:23Z", "path": "ksql-serde/src/main/java/io/confluent/ksql/serde/json/JsonSerdeUtils.java", "diffHunk": "@@ -23,14 +23,59 @@\n import io.confluent.ksql.schema.connect.SchemaWalker.Visitor;\n import io.confluent.ksql.schema.ksql.PersistenceSchema;\n import io.confluent.ksql.schema.ksql.SqlBaseType;\n+import io.confluent.ksql.util.KsqlException;\n+import java.io.ByteArrayInputStream;\n+import java.io.InputStream;\n+import javax.annotation.Nonnull;\n import org.apache.kafka.connect.data.Schema;\n import org.apache.kafka.connect.data.Schema.Type;\n \n-final class JsonSerdeUtils {\n+public final class JsonSerdeUtils {\n+\n+  // the JsonSchemaConverter adds a magic NULL byte and 4 bytes for the\n+  // schema ID at the start of the message\n+  private static final int SIZE_OF_SR_PREFIX = Byte.BYTES + Integer.BYTES;\n \n   private JsonSerdeUtils() {\n   }\n \n+  /**\n+   * Converts {@code jsonWithMagic} into an {@link InputStream} that represents\n+   * standard JSON encoding.\n+   *\n+   * @param jsonWithMagic the serialized JSON\n+   * @return the corresponding input stream\n+   * @throws io.confluent.ksql.util.KsqlException If the input is not encoded\n+   *         using the schema registry format (first byte magic byte, then\n+   *         four bytes for the schemaID).\n+   */\n+  public static InputStream asStandardJson(@Nonnull final byte[] jsonWithMagic) {", "originalCommit": "1a8cc2911ca05e881a84c617021bc505d1d3f8a8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkyOTM1Mw==", "url": "https://github.com/confluentinc/ksql/pull/4596#discussion_r383929353", "bodyText": "Are we sure this error message is the right way around?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                          + \"the stream is declared with JSON_SR format (not JSON).\");\n          \n          \n            \n                          + \"the stream is declared with JSON format (not JSON_SR).\");\n          \n      \n    \n    \n  \n\nAlso, not sure users will know what JsonSchemaConverter is.  Can we explain this in a more simple manner? e.g. maybe talking about \"serialized by a SchemaRegistry aware serializer\"?", "author": "big-andy-coates", "createdAt": "2020-02-25T14:55:11Z", "path": "ksql-serde/src/main/java/io/confluent/ksql/serde/json/JsonSerdeUtils.java", "diffHunk": "@@ -23,14 +23,59 @@\n import io.confluent.ksql.schema.connect.SchemaWalker.Visitor;\n import io.confluent.ksql.schema.ksql.PersistenceSchema;\n import io.confluent.ksql.schema.ksql.SqlBaseType;\n+import io.confluent.ksql.util.KsqlException;\n+import java.io.ByteArrayInputStream;\n+import java.io.InputStream;\n+import javax.annotation.Nonnull;\n import org.apache.kafka.connect.data.Schema;\n import org.apache.kafka.connect.data.Schema.Type;\n \n-final class JsonSerdeUtils {\n+public final class JsonSerdeUtils {\n+\n+  // the JsonSchemaConverter adds a magic NULL byte and 4 bytes for the\n+  // schema ID at the start of the message\n+  private static final int SIZE_OF_SR_PREFIX = Byte.BYTES + Integer.BYTES;\n \n   private JsonSerdeUtils() {\n   }\n \n+  /**\n+   * Converts {@code jsonWithMagic} into an {@link InputStream} that represents\n+   * standard JSON encoding.\n+   *\n+   * @param jsonWithMagic the serialized JSON\n+   * @return the corresponding input stream\n+   * @throws io.confluent.ksql.util.KsqlException If the input is not encoded\n+   *         using the schema registry format (first byte magic byte, then\n+   *         four bytes for the schemaID).\n+   */\n+  public static InputStream asStandardJson(@Nonnull final byte[] jsonWithMagic) {\n+    if (!hasMagicByte(jsonWithMagic)) {\n+      // don't log contents of jsonWithMagic to avoid leaking data into the logs\n+      throw new KsqlException(\n+          \"Got unexpected JSON serialization format that did not start with the magic byte. If \"\n+              + \"this stream was not serialized using the JsonSchemaConverter, then make sure \"\n+              + \"the stream is declared with JSON_SR format (not JSON).\");", "originalCommit": "1a8cc2911ca05e881a84c617021bc505d1d3f8a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA1NDIyOQ==", "url": "https://github.com/confluentinc/ksql/pull/4596#discussion_r384054229", "bodyText": "good catch", "author": "agavra", "createdAt": "2020-02-25T18:46:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkyOTM1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzk0MTQ2OQ==", "url": "https://github.com/confluentinc/ksql/pull/4596#discussion_r383941469", "bodyText": "nit: The naming JsonSchemaFormat doesn't make it immediately obvious how this is different to JsonFormat. Maybe SchemaRegistryJsonFormat?", "author": "big-andy-coates", "createdAt": "2020-02-25T15:13:16Z", "path": "ksql-serde/src/main/java/io/confluent/ksql/serde/FormatFactory.java", "diffHunk": "@@ -52,6 +54,7 @@ public static Format fromName(final String name) {\n     switch (name) {\n       case AvroFormat.NAME:       return AVRO;\n       case JsonFormat.NAME:       return JSON;\n+      case JsonSchemaFormat.NAME: return JSON_SR;", "originalCommit": "1a8cc2911ca05e881a84c617021bc505d1d3f8a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA1MjU5OQ==", "url": "https://github.com/confluentinc/ksql/pull/4596#discussion_r384052599", "bodyText": "i'm following convention in the Converters (JsonConverter vs JsonSchemaConverter)", "author": "agavra", "createdAt": "2020-02-25T18:43:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzk0MTQ2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzk0MjM4NQ==", "url": "https://github.com/confluentinc/ksql/pull/4596#discussion_r383942385", "bodyText": "nit: final", "author": "big-andy-coates", "createdAt": "2020-02-25T15:14:41Z", "path": "ksql-serde/src/main/java/io/confluent/ksql/serde/json/JsonSchemaFormat.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.serde.json;\n+\n+import io.confluent.connect.json.JsonSchemaData;\n+import io.confluent.kafka.schemaregistry.ParsedSchema;\n+import io.confluent.kafka.schemaregistry.json.JsonSchema;\n+import io.confluent.ksql.serde.Format;\n+import io.confluent.ksql.serde.FormatInfo;\n+import io.confluent.ksql.serde.KsqlSerdeFactory;\n+import org.apache.kafka.connect.data.Schema;\n+\n+public class JsonSchemaFormat implements Format {\n+\n+  public static final String NAME = \"JSON_SR\";\n+\n+  private JsonSchemaData jsonData;", "originalCommit": "1a8cc2911ca05e881a84c617021bc505d1d3f8a8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzk0MzY2OQ==", "url": "https://github.com/confluentinc/ksql/pull/4596#discussion_r383943669", "bodyText": "Now both JsonSchemaformat and JsonFormat say they support schema inference from the Schema Registry.\nIs this still correct, or should JsonFormat no longer be saying it supports schema inference?  If it is still the case, isn't this going to be confusing for users?", "author": "big-andy-coates", "createdAt": "2020-02-25T15:16:38Z", "path": "ksql-serde/src/main/java/io/confluent/ksql/serde/json/JsonSchemaFormat.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.serde.json;\n+\n+import io.confluent.connect.json.JsonSchemaData;\n+import io.confluent.kafka.schemaregistry.ParsedSchema;\n+import io.confluent.kafka.schemaregistry.json.JsonSchema;\n+import io.confluent.ksql.serde.Format;\n+import io.confluent.ksql.serde.FormatInfo;\n+import io.confluent.ksql.serde.KsqlSerdeFactory;\n+import org.apache.kafka.connect.data.Schema;\n+\n+public class JsonSchemaFormat implements Format {\n+\n+  public static final String NAME = \"JSON_SR\";\n+\n+  private JsonSchemaData jsonData;\n+\n+  public JsonSchemaFormat() {\n+    this.jsonData = new JsonSchemaData();\n+  }\n+\n+  @Override\n+  public String name() {\n+    return NAME;\n+  }\n+\n+  @Override\n+  public boolean supportsSchemaInference() {\n+    return true;\n+  }\n+", "originalCommit": "1a8cc2911ca05e881a84c617021bc505d1d3f8a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA1MzEwNQ==", "url": "https://github.com/confluentinc/ksql/pull/4596#discussion_r384053105", "bodyText": "This is correct and it's the intended behavior. They can both support schema inference from schema registry, the difference is how you want to serialize/deserialize the data. I will write docs to explain this in a follow-up PR.", "author": "agavra", "createdAt": "2020-02-25T18:44:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzk0MzY2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA5NjUyMA==", "url": "https://github.com/confluentinc/ksql/pull/4596#discussion_r384096520", "bodyText": "naming request: can we please call this something other than \"schema inference\" ? I suggest \"schema lookup\" or \"schema reference\" or similar. Reason: \"schema inference\" in this kind of system usually means \"guessing at or figuring out the schema from just the data itself\" (a bit like what was recently added to print topic) - and as such this is actually a separate feature from anything to do with the SR.\nThanks for listening, mini-rant over \ud83d\ude01", "author": "blueedgenick", "createdAt": "2020-02-25T20:04:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzk0MzY2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY4Mzk0NA==", "url": "https://github.com/confluentinc/ksql/pull/4596#discussion_r384683944", "bodyText": "@blueedgenick - I'll update this in a future PR to avoid code jitter", "author": "agavra", "createdAt": "2020-02-26T18:34:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzk0MzY2OQ=="}], "type": "inlineReview"}, {"oid": "68e092e7a781ec7b9c146aa92cb659f15e5d530a", "url": "https://github.com/confluentinc/ksql/commit/68e092e7a781ec7b9c146aa92cb659f15e5d530a", "message": "feat: introduce JSON_SR format", "committedDate": "2020-02-26T18:22:27Z", "type": "commit"}, {"oid": "149c74a588a71e9ae8c4d77de6ab09f9fcb85897", "url": "https://github.com/confluentinc/ksql/commit/149c74a588a71e9ae8c4d77de6ab09f9fcb85897", "message": "fix: address andy/tims comments", "committedDate": "2020-02-26T18:22:28Z", "type": "commit"}, {"oid": "536fac33ed5587b43188818a032baad34015972a", "url": "https://github.com/confluentinc/ksql/commit/536fac33ed5587b43188818a032baad34015972a", "message": "test: more tests", "committedDate": "2020-02-26T18:30:49Z", "type": "commit"}, {"oid": "536fac33ed5587b43188818a032baad34015972a", "url": "https://github.com/confluentinc/ksql/commit/536fac33ed5587b43188818a032baad34015972a", "message": "test: more tests", "committedDate": "2020-02-26T18:30:49Z", "type": "forcePushed"}, {"oid": "1e8a2960d37d51697842a9d756f0aa0c72053af4", "url": "https://github.com/confluentinc/ksql/commit/1e8a2960d37d51697842a9d756f0aa0c72053af4", "message": "test: add generated plan", "committedDate": "2020-02-26T19:52:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc0NjM3MQ==", "url": "https://github.com/confluentinc/ksql/pull/4596#discussion_r384746371", "bodyText": "Null check here?", "author": "vpapavas", "createdAt": "2020-02-26T20:29:09Z", "path": "ksql-serde/src/main/java/io/confluent/ksql/serde/json/KsqlJsonDeserializer.java", "diffHunk": "@@ -75,12 +75,15 @@\n       .build();\n \n   private final PersistenceSchema physicalSchema;\n+  private final boolean isJsonSchema;\n   private String target = \"?\";\n \n   public KsqlJsonDeserializer(\n-      final PersistenceSchema physicalSchema\n+      final PersistenceSchema physicalSchema,\n+      final boolean isJsonSchema\n   ) {\n     this.physicalSchema = JsonSerdeUtils.validateSchema(physicalSchema);", "originalCommit": "1e8a2960d37d51697842a9d756f0aa0c72053af4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc1ODc1OA==", "url": "https://github.com/confluentinc/ksql/pull/4596#discussion_r384758758", "bodyText": "I've got another PR following up this one to fix loose ends and will make sure to add it there! (I want to get this in since the build is green)\nThanks for the review @vpapavas!", "author": "agavra", "createdAt": "2020-02-26T20:53:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc0NjM3MQ=="}], "type": "inlineReview"}]}