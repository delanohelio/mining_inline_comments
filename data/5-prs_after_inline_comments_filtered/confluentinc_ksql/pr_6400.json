{"pr_number": 6400, "pr_title": "feat: Add support for ALTER STREAM|TABLE", "pr_createdAt": "2020-10-10T00:42:26Z", "pr_url": "https://github.com/confluentinc/ksql/pull/6400", "timeline": [{"oid": "6cd74f5419660b0709fd3e0d85d83a254b73e2b6", "url": "https://github.com/confluentinc/ksql/commit/6cd74f5419660b0709fd3e0d85d83a254b73e2b6", "message": "feat: Add support for ALTER STREAM|TABLE", "committedDate": "2020-10-09T20:48:14Z", "type": "commit"}, {"oid": "2b0d339a4d66d16bb2f17ebef36818ffb05613fc", "url": "https://github.com/confluentinc/ksql/commit/2b0d339a4d66d16bb2f17ebef36818ffb05613fc", "message": "Merge with master", "committedDate": "2020-10-09T21:01:29Z", "type": "commit"}, {"oid": "d9d0168276473c284215bf40e01cf1e6b7ae6eb8", "url": "https://github.com/confluentinc/ksql/commit/d9d0168276473c284215bf40e01cf1e6b7ae6eb8", "message": "Merge branch 'master' of github.com:confluentinc/ksql into alter", "committedDate": "2020-10-10T00:25:09Z", "type": "commit"}, {"oid": "11b0dee0c661de4b80c209f95644af84d9dcd9e1", "url": "https://github.com/confluentinc/ksql/commit/11b0dee0c661de4b80c209f95644af84d9dcd9e1", "message": "Remove SerdeOptions", "committedDate": "2020-10-10T00:42:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUyNjA5NQ==", "url": "https://github.com/confluentinc/ksql/pull/6400#discussion_r503526095", "bodyText": "the error message in putSource needs to be updated:\n      existing.source.canUpgradeTo(dataSource).ifPresent(msg -> {\n        throw new KsqlException(\"Cannot REPLACE data source: \" + msg);\n      });\nWe could either make it more generic, or pass in more details in the putSource method to correctly display ALTER or REPLACE", "author": "agavra", "createdAt": "2020-10-12T20:52:07Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java", "diffHunk": "@@ -127,6 +131,81 @@ public DdlCommandResult executeDropType(final DropTypeCommand dropType) {\n           ? new DdlCommandResult(true, \"Dropped type '\" + typeName + \"'\")\n           : new DdlCommandResult(true, \"Type '\" + typeName + \"' does not exist\");\n     }\n+\n+    @Override\n+    public DdlCommandResult executeAlterSource(final AlterSourceCommand alterSource) {\n+      final DataSource dataSource = metaStore.getSource(alterSource.getSourceName());\n+\n+      if (dataSource == null) {\n+        throw new KsqlException(\n+            \"Source \" + alterSource.getSourceName().text()\n+                + \" does not exist.\"\n+        );\n+      }\n+\n+      if (!dataSource.getDataSourceType().getKsqlType().equals(alterSource.getKsqlType())) {\n+        throw new KsqlException(String.format(\n+            \"Incompatible data source type is %s, but statement was ALTER %s\",\n+            dataSource.getDataSourceType().getKsqlType(),\n+            alterSource.getKsqlType()\n+        ));\n+      }\n+\n+      if (dataSource.isCasTarget()) {\n+        throw new KsqlException(String.format(\n+            \"ALTER command is not supported for CREATE ... AS statements.\"\n+        ));\n+      }\n+\n+      final LogicalSchema newSchema = dataSource.getSchema()\n+          .asBuilder()\n+          .valueColumns(alterSource.getNewColumns().columns())\n+          .build();\n+\n+      if (alterSource.getKsqlType().equals(DataSourceType.KSTREAM.getKsqlType())) {\n+        return alterStream(dataSource, newSchema);\n+      } else {\n+        return alterTable(dataSource, newSchema);\n+      }\n+    }\n+\n+    private DdlCommandResult alterStream(\n+        final DataSource dataSource,\n+        final LogicalSchema newSchema\n+    ) {\n+      final KsqlStream<?> ksqlStream = new KsqlStream<>(\n+          dataSource.getSqlExpression().concat(sql),\n+          dataSource.getName(),\n+          newSchema,\n+          dataSource.getTimestampColumn(),\n+          dataSource.isCasTarget(),\n+          dataSource.getKsqlTopic()\n+      );\n+      metaStore.putSource(ksqlStream, true);", "originalCommit": "11b0dee0c661de4b80c209f95644af84d9dcd9e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUyNzEzNA==", "url": "https://github.com/confluentinc/ksql/pull/6400#discussion_r503527134", "bodyText": "what happens if there is a persistent INSERT INTO writing into this?", "author": "agavra", "createdAt": "2020-10-12T20:54:18Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java", "diffHunk": "@@ -127,6 +131,81 @@ public DdlCommandResult executeDropType(final DropTypeCommand dropType) {\n           ? new DdlCommandResult(true, \"Dropped type '\" + typeName + \"'\")\n           : new DdlCommandResult(true, \"Type '\" + typeName + \"' does not exist\");\n     }\n+\n+    @Override\n+    public DdlCommandResult executeAlterSource(final AlterSourceCommand alterSource) {\n+      final DataSource dataSource = metaStore.getSource(alterSource.getSourceName());\n+\n+      if (dataSource == null) {\n+        throw new KsqlException(\n+            \"Source \" + alterSource.getSourceName().text()\n+                + \" does not exist.\"\n+        );\n+      }\n+\n+      if (!dataSource.getDataSourceType().getKsqlType().equals(alterSource.getKsqlType())) {\n+        throw new KsqlException(String.format(\n+            \"Incompatible data source type is %s, but statement was ALTER %s\",\n+            dataSource.getDataSourceType().getKsqlType(),\n+            alterSource.getKsqlType()\n+        ));\n+      }\n+\n+      if (dataSource.isCasTarget()) {", "originalCommit": "11b0dee0c661de4b80c209f95644af84d9dcd9e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkwNjU0NQ==", "url": "https://github.com/confluentinc/ksql/pull/6400#discussion_r505906545", "bodyText": "Same thing as CREATE OR REPLACE - the new rows are populated with NULL.", "author": "jzaralim", "createdAt": "2020-10-15T22:47:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUyNzEzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUzNTAyMw==", "url": "https://github.com/confluentinc/ksql/pull/6400#discussion_r503535023", "bodyText": "instead of constructing this here, we should add a method to KsqlStream labeled withSchema. This ensures that if anyone ever modifies KsqlStream and adds new arguments it won't accidentally be missed when we copy it here (same for KsqlTable).\nalso, it could make it cleaner if you just added it to DataSource API, then you don't even need to check which type it is :)", "author": "agavra", "createdAt": "2020-10-12T21:13:29Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java", "diffHunk": "@@ -127,6 +131,81 @@ public DdlCommandResult executeDropType(final DropTypeCommand dropType) {\n           ? new DdlCommandResult(true, \"Dropped type '\" + typeName + \"'\")\n           : new DdlCommandResult(true, \"Type '\" + typeName + \"' does not exist\");\n     }\n+\n+    @Override\n+    public DdlCommandResult executeAlterSource(final AlterSourceCommand alterSource) {\n+      final DataSource dataSource = metaStore.getSource(alterSource.getSourceName());\n+\n+      if (dataSource == null) {\n+        throw new KsqlException(\n+            \"Source \" + alterSource.getSourceName().text()\n+                + \" does not exist.\"\n+        );\n+      }\n+\n+      if (!dataSource.getDataSourceType().getKsqlType().equals(alterSource.getKsqlType())) {\n+        throw new KsqlException(String.format(\n+            \"Incompatible data source type is %s, but statement was ALTER %s\",\n+            dataSource.getDataSourceType().getKsqlType(),\n+            alterSource.getKsqlType()\n+        ));\n+      }\n+\n+      if (dataSource.isCasTarget()) {\n+        throw new KsqlException(String.format(\n+            \"ALTER command is not supported for CREATE ... AS statements.\"\n+        ));\n+      }\n+\n+      final LogicalSchema newSchema = dataSource.getSchema()\n+          .asBuilder()\n+          .valueColumns(alterSource.getNewColumns().columns())\n+          .build();\n+\n+      if (alterSource.getKsqlType().equals(DataSourceType.KSTREAM.getKsqlType())) {\n+        return alterStream(dataSource, newSchema);\n+      } else {\n+        return alterTable(dataSource, newSchema);\n+      }\n+    }\n+\n+    private DdlCommandResult alterStream(\n+        final DataSource dataSource,\n+        final LogicalSchema newSchema\n+    ) {\n+      final KsqlStream<?> ksqlStream = new KsqlStream<>(", "originalCommit": "11b0dee0c661de4b80c209f95644af84d9dcd9e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUzNTM1Mg==", "url": "https://github.com/confluentinc/ksql/pull/6400#discussion_r503535352", "bodyText": "how does this end up looking like to the user when you describe a source? is this the UX we want? (make sure to add test coverage for this in ConsoleTest", "author": "agavra", "createdAt": "2020-10-12T21:14:23Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java", "diffHunk": "@@ -127,6 +131,81 @@ public DdlCommandResult executeDropType(final DropTypeCommand dropType) {\n           ? new DdlCommandResult(true, \"Dropped type '\" + typeName + \"'\")\n           : new DdlCommandResult(true, \"Type '\" + typeName + \"' does not exist\");\n     }\n+\n+    @Override\n+    public DdlCommandResult executeAlterSource(final AlterSourceCommand alterSource) {\n+      final DataSource dataSource = metaStore.getSource(alterSource.getSourceName());\n+\n+      if (dataSource == null) {\n+        throw new KsqlException(\n+            \"Source \" + alterSource.getSourceName().text()\n+                + \" does not exist.\"\n+        );\n+      }\n+\n+      if (!dataSource.getDataSourceType().getKsqlType().equals(alterSource.getKsqlType())) {\n+        throw new KsqlException(String.format(\n+            \"Incompatible data source type is %s, but statement was ALTER %s\",\n+            dataSource.getDataSourceType().getKsqlType(),\n+            alterSource.getKsqlType()\n+        ));\n+      }\n+\n+      if (dataSource.isCasTarget()) {\n+        throw new KsqlException(String.format(\n+            \"ALTER command is not supported for CREATE ... AS statements.\"\n+        ));\n+      }\n+\n+      final LogicalSchema newSchema = dataSource.getSchema()\n+          .asBuilder()\n+          .valueColumns(alterSource.getNewColumns().columns())\n+          .build();\n+\n+      if (alterSource.getKsqlType().equals(DataSourceType.KSTREAM.getKsqlType())) {\n+        return alterStream(dataSource, newSchema);\n+      } else {\n+        return alterTable(dataSource, newSchema);\n+      }\n+    }\n+\n+    private DdlCommandResult alterStream(\n+        final DataSource dataSource,\n+        final LogicalSchema newSchema\n+    ) {\n+      final KsqlStream<?> ksqlStream = new KsqlStream<>(\n+          dataSource.getSqlExpression().concat(sql),", "originalCommit": "11b0dee0c661de4b80c209f95644af84d9dcd9e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUzNjM4MQ==", "url": "https://github.com/confluentinc/ksql/pull/6400#discussion_r503536381", "bodyText": "passing in a LogicalSchema to represent the new columns seems... odd? we should probably be passing down just the new columns - users shouldn't be, for example, creating new KEY columns (at the moment at least), and the new columns shouldn't include any of the psuedocolumns.\nwe can see this in the way that you use it (you only get the columns):\nalterSource.getNewColumns().columns()", "author": "agavra", "createdAt": "2020-10-12T21:17:00Z", "path": "ksqldb-execution/src/main/java/io/confluent/ksql/execution/ddl/commands/AlterSourceCommand.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.execution.ddl.commands;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import io.confluent.ksql.name.SourceName;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+\n+public class AlterSourceCommand implements DdlCommand {\n+  private final SourceName sourceName;\n+  private final String ksqlType;\n+  private final LogicalSchema newColumns;\n+\n+\n+  public AlterSourceCommand(\n+      @JsonProperty(value = \"sourceName\", required = true) final SourceName sourceName,\n+      @JsonProperty(value = \"ksqlType\", required = true) final String ksqlType,\n+      @JsonProperty(value = \"newColumns\", required = true) final LogicalSchema newColumns", "originalCommit": "11b0dee0c661de4b80c209f95644af84d9dcd9e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU1OTA5NQ==", "url": "https://github.com/confluentinc/ksql/pull/6400#discussion_r503559095", "bodyText": "This was done because the Column class could not be deserialized:\nERROR Did not write the command to the command topic as it could not be deserialized. This is a bug! Please raise a Github issue containing the series of commands you ran to get to this point.\nCannot construct instance of `io.confluent.ksql.schema.ksql.Column` (no Creators, like default construct, exist): cannot deserialize from Object value (no delegate- or property-based Creator)\n\nBut yeah, using LogicalSchema here is pretty odd. Perhaps creating a new class for this purpose would make more sense.", "author": "jzaralim", "createdAt": "2020-10-12T22:09:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUzNjM4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDA3MjExMg==", "url": "https://github.com/confluentinc/ksql/pull/6400#discussion_r504072112", "bodyText": "That makes sense, I think all you'd need to do is add a serde module. You can see LogicalSchemaDeserializer and LogicalSchemaSerializer (and they're hooked up in KsqlTypesDeserializationModule)", "author": "agavra", "createdAt": "2020-10-13T16:00:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUzNjM4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUzODI0MQ==", "url": "https://github.com/confluentinc/ksql/pull/6400#discussion_r503538241", "bodyText": "I think we're missing test coverage for this in SqlFormatterTest", "author": "agavra", "createdAt": "2020-10-12T21:21:49Z", "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/SqlFormatter.java", "diffHunk": "@@ -493,6 +495,22 @@ protected Void visitGroupBy(final GroupBy node, final Integer indent) {\n       return null;\n     }\n \n+    @Override\n+    public Void visitAlterSource(final AlterSource node, final Integer indent) {", "originalCommit": "11b0dee0c661de4b80c209f95644af84d9dcd9e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUzOTY2NA==", "url": "https://github.com/confluentinc/ksql/pull/6400#discussion_r503539664", "bodyText": "hmm, I'm wondering what this means for compatibility - I'm not sure what adding a value to an enum will do to the JSON serde. I think it works but we should test issuing some commands on an earlier version of ksqlDB then upgrading to a version that has this patch and seeing that it works. Similarly, we should test what happens if we downgrade (submit something with ALTER in it, and then roll back). We should make sure we gracefully handle the failure and enter DEGRADED state)\nFYI @stevenpyzhang", "author": "agavra", "createdAt": "2020-10-12T21:25:31Z", "path": "ksqldb-rest-model/src/main/java/io/confluent/ksql/rest/entity/CommandId.java", "diffHunk": "@@ -42,7 +42,8 @@\n     CREATE,\n     DROP,\n     EXECUTE,\n-    TERMINATE\n+    TERMINATE,\n+    ALTER", "originalCommit": "11b0dee0c661de4b80c209f95644af84d9dcd9e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc2MjcyMw==", "url": "https://github.com/confluentinc/ksql/pull/6400#discussion_r505762723", "bodyText": "I don't think there's any good way to gracefully handle the failure without changing the earlier versions, which kinda goes against the point. And on top of that, the ddl command subtype alterSourceV1 also causes backwards compatibility issues. So given that this is supposed to just be an alternative to CREATE OR REPLACE, I'll go ahead and  reuse the commands for createStream/createTable for this instead.", "author": "jzaralim", "createdAt": "2020-10-15T18:42:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUzOTY2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkwNjU3Mw==", "url": "https://github.com/confluentinc/ksql/pull/6400#discussion_r505906573", "bodyText": "Sorry, ignore what I said - I tested this on a really old version that does not have the degraded state change. This actually does enter DEGRADED state, and switching between versions works.", "author": "jzaralim", "createdAt": "2020-10-15T22:47:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUzOTY2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU0NTY1Nw==", "url": "https://github.com/confluentinc/ksql/pull/6400#discussion_r503545657", "bodyText": "nit - please use the string concatenation method for toString (that's what the rest of the code base uses)", "author": "agavra", "createdAt": "2020-10-12T21:35:32Z", "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/tree/AlterSource.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.parser.tree;\n+\n+import static com.google.common.base.MoreObjects.toStringHelper;\n+\n+import com.google.errorprone.annotations.Immutable;\n+import io.confluent.ksql.metastore.model.DataSource.DataSourceType;\n+import io.confluent.ksql.name.SourceName;\n+import io.confluent.ksql.parser.NodeLocation;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+@Immutable\n+public class AlterSource extends Statement implements ExecutableDdlStatement {\n+  private final SourceName name;\n+  private final DataSourceType dataSourceType;\n+  private final List<AlterOption> alterOptions;\n+\n+  public AlterSource(\n+      final SourceName name,\n+      final DataSourceType dataSourceType,\n+      final List<AlterOption> alterOptions\n+  ) {\n+    this(Optional.empty(), name, dataSourceType, alterOptions);\n+  }\n+\n+  public AlterSource(\n+      final Optional<NodeLocation> location,\n+      final SourceName name,\n+      final DataSourceType dataSourceType,\n+      final List<AlterOption> alterOptions\n+  ) {\n+    super(location);\n+    this.name = name;\n+    this.dataSourceType = dataSourceType;\n+    this.alterOptions = alterOptions;\n+  }\n+\n+  public SourceName getName() {\n+    return name;\n+  }\n+\n+  public DataSourceType getDataSourceType() {\n+    return dataSourceType;\n+  }\n+\n+  public List<AlterOption> getAlterOptions() {\n+    return alterOptions;\n+  }\n+\n+  @Override\n+  public  <R, C> R accept(final AstVisitor<R, C> visitor, final C context) {\n+    return visitor.visitAlterSource(this, context);\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return Objects.hash(name, dataSourceType, alterOptions);\n+  }\n+\n+  @Override\n+  public boolean equals(final Object o) {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+    final AlterSource that = (AlterSource) o;\n+    return Objects.equals(name, that.name)\n+        && Objects.equals(dataSourceType, that.dataSourceType)\n+        && Objects.equals(alterOptions, that.alterOptions);\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return toStringHelper(this)", "originalCommit": "11b0dee0c661de4b80c209f95644af84d9dcd9e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "75b61b09946e72b15894177a66234c13ee757429", "url": "https://github.com/confluentinc/ksql/commit/75b61b09946e72b15894177a66234c13ee757429", "message": "Merge branch 'master' of github.com:confluentinc/ksql into alter", "committedDate": "2020-10-12T21:41:56Z", "type": "commit"}, {"oid": "63eb35935af6f2a01c889070b590cbac5e1c3776", "url": "https://github.com/confluentinc/ksql/commit/63eb35935af6f2a01c889070b590cbac5e1c3776", "message": "Address review comments", "committedDate": "2020-10-15T22:43:15Z", "type": "commit"}, {"oid": "2fc75071f54b2d1763155b1f0d891d69142b5cc5", "url": "https://github.com/confluentinc/ksql/commit/2fc75071f54b2d1763155b1f0d891d69142b5cc5", "message": "Rename Column Serde files", "committedDate": "2020-10-15T23:38:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg2NTI4Mg==", "url": "https://github.com/confluentinc/ksql/pull/6400#discussion_r507865282", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    throw new KsqlException(\"Cannot add existing column to schema: \" + e.getColumn());\n          \n          \n            \n                    throw new KsqlException(\"Cannot add column '\" + e.getColumn() + \"' to schema. A column with the same name already exists.\");", "author": "agavra", "createdAt": "2020-10-19T15:53:37Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/ddl/commands/DdlCommandExec.java", "diffHunk": "@@ -127,6 +132,54 @@ public DdlCommandResult executeDropType(final DropTypeCommand dropType) {\n           ? new DdlCommandResult(true, \"Dropped type '\" + typeName + \"'\")\n           : new DdlCommandResult(true, \"Type '\" + typeName + \"' does not exist\");\n     }\n+\n+    @Override\n+    public DdlCommandResult executeAlterSource(final AlterSourceCommand alterSource) {\n+      final DataSource dataSource = metaStore.getSource(alterSource.getSourceName());\n+\n+      if (dataSource == null) {\n+        throw new KsqlException(\n+            \"Source \" + alterSource.getSourceName().text()\n+                + \" does not exist.\"\n+        );\n+      }\n+\n+      if (!dataSource.getDataSourceType().getKsqlType().equals(alterSource.getKsqlType())) {\n+        throw new KsqlException(String.format(\n+            \"Incompatible data source type is %s, but statement was ALTER %s\",\n+            dataSource.getDataSourceType().getKsqlType(),\n+            alterSource.getKsqlType()\n+        ));\n+      }\n+\n+      if (dataSource.isCasTarget()) {\n+        throw new KsqlException(String.format(\n+            \"ALTER command is not supported for CREATE ... AS statements.\"\n+        ));\n+      }\n+\n+      final LogicalSchema newSchema;\n+\n+      try {\n+        newSchema = dataSource.getSchema()\n+            .asBuilder()\n+            .valueColumns(alterSource.getNewColumns())\n+            .build();\n+      } catch (DuplicateColumnException e) {\n+        throw new KsqlException(\"Cannot add existing column to schema: \" + e.getColumn());", "originalCommit": "2fc75071f54b2d1763155b1f0d891d69142b5cc5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg2Njk2Ng==", "url": "https://github.com/confluentinc/ksql/pull/6400#discussion_r507866966", "bodyText": "nit: let's java doc what sql is as well", "author": "agavra", "createdAt": "2020-10-19T15:55:51Z", "path": "ksqldb-metastore/src/main/java/io/confluent/ksql/metastore/model/DataSource.java", "diffHunk": "@@ -97,4 +97,9 @@ public String getKsqlType() {\n    */\n   Optional<String> canUpgradeTo(DataSource other);\n \n+  /**\n+   * @param schema a schema", "originalCommit": "2fc75071f54b2d1763155b1f0d891d69142b5cc5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg2OTQwMQ==", "url": "https://github.com/confluentinc/ksql/pull/6400#discussion_r507869401", "bodyText": "I think we need to follow the pattern of SchemaParser and do the proper error handling (see usages of error listeners) otherwise it only gets logged to stdout", "author": "agavra", "createdAt": "2020-10-19T15:59:12Z", "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/json/ColumnDeserializor.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.parser.json;\n+\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+import io.confluent.ksql.metastore.TypeRegistry;\n+import io.confluent.ksql.name.ColumnName;\n+import io.confluent.ksql.parser.CaseInsensitiveStream;\n+import io.confluent.ksql.parser.SqlBaseLexer;\n+import io.confluent.ksql.parser.SqlBaseParser;\n+import io.confluent.ksql.parser.SqlBaseParser.TableElementContext;\n+import io.confluent.ksql.schema.ksql.Column;\n+import io.confluent.ksql.schema.ksql.Column.Namespace;\n+import io.confluent.ksql.schema.ksql.SqlTypeParser;\n+import io.confluent.ksql.util.ParserUtil;\n+import java.io.IOException;\n+import org.antlr.v4.runtime.CharStreams;\n+import org.antlr.v4.runtime.CommonTokenStream;\n+\n+public class ColumnDeserializor extends JsonDeserializer<Column> {\n+\n+  public ColumnDeserializor() {\n+  }\n+\n+  @Override\n+  public Column deserialize(\n+      final JsonParser p,\n+      final DeserializationContext ctxt\n+  ) throws IOException {\n+    final String text = p.readValueAs(String.class);\n+    final SqlBaseLexer lexer = new SqlBaseLexer(\n+        new CaseInsensitiveStream(CharStreams.fromString(text))\n+    );\n+    final CommonTokenStream tokStream = new CommonTokenStream(lexer);\n+    final SqlBaseParser parser = new SqlBaseParser(tokStream);\n+    final TableElementContext context = parser.tableElement();", "originalCommit": "2fc75071f54b2d1763155b1f0d891d69142b5cc5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODAyNTk0NA==", "url": "https://github.com/confluentinc/ksql/pull/6400#discussion_r508025944", "bodyText": "Ended up using SchemaParser to parse the string instead", "author": "jzaralim", "createdAt": "2020-10-19T19:58:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzg2OTQwMQ=="}], "type": "inlineReview"}, {"oid": "055a8dfd7b0f902d4578c11274a15692b3085cfb", "url": "https://github.com/confluentinc/ksql/commit/055a8dfd7b0f902d4578c11274a15692b3085cfb", "message": "A couple of small changes", "committedDate": "2020-10-19T18:56:21Z", "type": "commit"}]}