{"pr_number": 6635, "pr_title": "chore: force repartition on joins with SR-enabled key formats", "pr_createdAt": "2020-11-17T20:23:11Z", "pr_url": "https://github.com/confluentinc/ksql/pull/6635", "timeline": [{"oid": "aed78b12f891db91306a98063c2de6105dbb8fd5", "url": "https://github.com/confluentinc/ksql/commit/aed78b12f891db91306a98063c2de6105dbb8fd5", "message": "chore: force repartition on joins with SR-enabled key formats", "committedDate": "2020-11-17T20:11:36Z", "type": "commit"}, {"oid": "cb94de41dea36011e32c043df8776fcc096bf681", "url": "https://github.com/confluentinc/ksql/commit/cb94de41dea36011e32c043df8776fcc096bf681", "message": "refactor: move common methods to new util", "committedDate": "2020-11-17T20:12:05Z", "type": "commit"}, {"oid": "c0d83466c7b0beb4fe259c933f43698516f37baf", "url": "https://github.com/confluentinc/ksql/commit/c0d83466c7b0beb4fe259c933f43698516f37baf", "message": "chore: historic plans", "committedDate": "2020-11-17T20:12:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ5NTYwOA==", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r525495608", "bodyText": "If we want to fix the first inefficiency mentioned in the PR description (that we currently force repartitions even if not strictly necessary), this is the bit of logic that would be updated.", "author": "vcrfxia", "createdAt": "2020-11-17T20:25:15Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PreJoinRepartitionNode.java", "diffHunk": "@@ -92,6 +101,11 @@ public LogicalSchema getSchema() {\n \n   @Override\n   public void setKeyFormat(final FormatInfo format) {\n+    // Force repartition in case of schema inference, to avoid misses due to key schema ID mismatch\n+    if (FormatFactory.of(format).supportsFeature(SerdeFeature.SCHEMA_INFERENCE)) {", "originalCommit": "c0d83466c7b0beb4fe259c933f43698516f37baf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUwODkyMg==", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r525508922", "bodyText": "might be good to link this to a GH issue and place the issue inline", "author": "agavra", "createdAt": "2020-11-17T20:38:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ5NTYwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ5NjQ1Nw==", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r525496457", "bodyText": "This PR does not add support for joining on windowed sources with SR-enableld key formats. This will be a follow-up PR.", "author": "vcrfxia", "createdAt": "2020-11-17T20:25:57Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/structured/SchemaKStream.java", "diffHunk": "@@ -306,20 +306,31 @@ static Expression rewriteTimeComparisonForFilter(final Expression expression) {\n \n   @SuppressWarnings(\"unchecked\")\n   public SchemaKStream<Struct> selectKey(\n+      final FormatInfo valueFormat,\n       final Expression keyExpression,\n       final Optional<FormatInfo> forceInternalKeyFormat,\n-      final Stacker contextStacker\n+      final Stacker contextStacker,\n+      final boolean forceRepartition\n   ) {\n     final boolean keyFormatChange = forceInternalKeyFormat.isPresent()\n         && !forceInternalKeyFormat.get().equals(keyFormat.getFormatInfo());\n \n-    if (!keyFormatChange && repartitionNotNeeded(ImmutableList.of(keyExpression))) {\n+    if (!keyFormatChange\n+        && repartitionNotNeeded(ImmutableList.of(keyExpression))\n+        && !forceRepartition\n+    ) {\n       return (SchemaKStream<Struct>) this;\n     }\n \n     if (keyFormat.isWindowed()) {\n-      throw new KsqlException(\"Implicit repartitioning of windowed sources is not supported. \"\n-          + \"See https://github.com/confluentinc/ksql/issues/4385.\");\n+      final String errorMsg = \"Implicit repartitioning of windowed sources is not supported. \"\n+          + \"See https://github.com/confluentinc/ksql/issues/4385.\";\n+      final String additionalMsg = forceRepartition\n+          ? \" As a result, ksqlDB does not support joins on Schema-Registry-enabled key formats \"", "originalCommit": "c0d83466c7b0beb4fe259c933f43698516f37baf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTQ5NzQyOQ==", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r525497429", "bodyText": "This test is identical to shouldNotRepartitionIfSameKeyField above, so the duplicate has been removed.", "author": "vcrfxia", "createdAt": "2020-11-17T20:26:40Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/structured/SchemaKStreamTest.java", "diffHunk": "@@ -146,31 +143,39 @@ public void shouldBuildSchemaForSelect() {\n   @Test\n   public void shouldNotRepartitionIfSameKeyField() {\n     // Given:\n-    final PlanNode logicalPlan = givenInitialKStreamOf(\n+    givenInitialKStreamOf(\n         \"SELECT col0, col2, col3 FROM test1 PARTITION BY col0 EMIT CHANGES;\");\n-    final UserRepartitionNode repartitionNode = (UserRepartitionNode) logicalPlan.getSources().get(0).getSources().get(0);\n \n     // When:\n     final SchemaKStream<?> result = initialSchemaKStream\n-        .selectKey(repartitionNode.getPartitionBy(), Optional.empty(), childContextStacker);\n+        .selectKey(valueFormat.getFormatInfo(), new UnqualifiedColumnReferenceExp(ColumnName.of(\"COL0\")), Optional.empty(), childContextStacker, false);\n \n     // Then:\n     assertThat(result, is(initialSchemaKStream));\n   }\n \n   @Test\n-  public void shouldNotRepartitionIfRowkey() {", "originalCommit": "c0d83466c7b0beb4fe259c933f43698516f37baf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUwNDU2Ng==", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r525504566", "bodyText": "I've tried to implement this new plan step in a generic way so that it can also support user table repartitions in the future, rather than baking in assumptions such as the fact that today the logical schema (and key format) never change when this step is called, as the step is only used to enable a specific join use case. However, there's no testing for the more general table rekey functionality, so maybe it's more misleading to have the step appear general, and we should be failing if any of these assumptions are violated instead?", "author": "vcrfxia", "createdAt": "2020-11-17T20:32:37Z", "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/TableSelectKeyBuilder.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Copyright 2019 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.execution.streams;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.confluent.ksql.GenericRow;\n+import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n+import io.confluent.ksql.execution.context.QueryContext;\n+import io.confluent.ksql.execution.expression.tree.Expression;\n+import io.confluent.ksql.execution.materialization.MaterializationInfo;\n+import io.confluent.ksql.execution.plan.KTableHolder;\n+import io.confluent.ksql.execution.plan.KeySerdeFactory;\n+import io.confluent.ksql.execution.plan.TableSelectKey;\n+import io.confluent.ksql.function.FunctionRegistry;\n+import io.confluent.ksql.logging.processing.ProcessingLogger;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.util.KsqlConfig;\n+import java.util.function.BiFunction;\n+import org.apache.kafka.common.utils.Bytes;\n+import org.apache.kafka.connect.data.Struct;\n+import org.apache.kafka.streams.KeyValue;\n+import org.apache.kafka.streams.kstream.KTable;\n+import org.apache.kafka.streams.kstream.Materialized;\n+import org.apache.kafka.streams.kstream.Named;\n+import org.apache.kafka.streams.state.KeyValueStore;\n+\n+public final class TableSelectKeyBuilder {\n+\n+  private TableSelectKeyBuilder() {\n+  }\n+\n+  public static KTableHolder<Struct> build(\n+      final KTableHolder<?> table,\n+      final TableSelectKey selectKey,\n+      final KsqlQueryBuilder queryBuilder,\n+      final MaterializedFactory materializedFactory\n+  ) {\n+    return build(\n+        table,\n+        selectKey,\n+        queryBuilder,\n+        materializedFactory,\n+        PartitionByParamsFactory::build\n+    );\n+  }\n+\n+  @VisibleForTesting\n+  static KTableHolder<Struct> build(\n+      final KTableHolder<?> table,\n+      final TableSelectKey selectKey,\n+      final KsqlQueryBuilder queryBuilder,\n+      final MaterializedFactory materializedFactory,\n+      final PartitionByParamsBuilder paramsBuilder\n+  ) {\n+    final LogicalSchema sourceSchema = table.getSchema();", "originalCommit": "c0d83466c7b0beb4fe259c933f43698516f37baf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUyMTk0NA==", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r525521944", "bodyText": "I think it's fine to implement it generically, we should have tests that fail if a user tries to repartition a table so I think that covers that this isn't being used for evil", "author": "agavra", "createdAt": "2020-11-17T21:01:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUwNDU2Ng=="}], "type": "inlineReview"}, {"oid": "8638a61007a3707f297f8ae428b9cf16216df202", "url": "https://github.com/confluentinc/ksql/commit/8638a61007a3707f297f8ae428b9cf16216df202", "message": "chore: findbugs", "committedDate": "2020-11-17T20:46:22Z", "type": "commit"}, {"oid": "ad4ed3bc52af2183627a784c9feb24543245f24e", "url": "https://github.com/confluentinc/ksql/commit/ad4ed3bc52af2183627a784c9feb24543245f24e", "message": "chore: fix test", "committedDate": "2020-11-17T21:37:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUxMDk0MA==", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r525510940", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      ? \" As a result, ksqlDB does not support joins on Schema-Registry-enabled key formats \"\n          \n          \n            \n                      ? \" As a result, ksqlDB does not support joins on windowed Schema-Registry-enabled key formats \"", "author": "agavra", "createdAt": "2020-11-17T20:41:16Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/structured/SchemaKStream.java", "diffHunk": "@@ -306,20 +306,31 @@ static Expression rewriteTimeComparisonForFilter(final Expression expression) {\n \n   @SuppressWarnings(\"unchecked\")\n   public SchemaKStream<Struct> selectKey(\n+      final FormatInfo valueFormat,\n       final Expression keyExpression,\n       final Optional<FormatInfo> forceInternalKeyFormat,\n-      final Stacker contextStacker\n+      final Stacker contextStacker,\n+      final boolean forceRepartition\n   ) {\n     final boolean keyFormatChange = forceInternalKeyFormat.isPresent()\n         && !forceInternalKeyFormat.get().equals(keyFormat.getFormatInfo());\n \n-    if (!keyFormatChange && repartitionNotNeeded(ImmutableList.of(keyExpression))) {\n+    if (!keyFormatChange\n+        && repartitionNotNeeded(ImmutableList.of(keyExpression))\n+        && !forceRepartition\n+    ) {\n       return (SchemaKStream<Struct>) this;\n     }\n \n     if (keyFormat.isWindowed()) {\n-      throw new KsqlException(\"Implicit repartitioning of windowed sources is not supported. \"\n-          + \"See https://github.com/confluentinc/ksql/issues/4385.\");\n+      final String errorMsg = \"Implicit repartitioning of windowed sources is not supported. \"\n+          + \"See https://github.com/confluentinc/ksql/issues/4385.\";\n+      final String additionalMsg = forceRepartition\n+          ? \" As a result, ksqlDB does not support joins on Schema-Registry-enabled key formats \"", "originalCommit": "c0d83466c7b0beb4fe259c933f43698516f37baf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTYzMTY3NQ==", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r525631675", "bodyText": "Whoops -- nice catch.", "author": "vcrfxia", "createdAt": "2020-11-18T01:17:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUxMDk0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUxMTk5NA==", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r525511994", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      ? \" As a result, ksqlDB does not support joins on Schema-Registry-enabled key formats \"\n          \n          \n            \n                      ? \" As a result, ksqlDB does not support joins on windowed Schema-Registry-enabled key formats \"", "author": "agavra", "createdAt": "2020-11-17T20:43:30Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/structured/SchemaKTable.java", "diffHunk": "@@ -157,10 +162,46 @@ public SchemaKTable(\n           + \"a join, joins on tables with multiple columns is not yet supported.\");\n     }\n \n-    throw new UnsupportedOperationException(\"Cannot repartition a TABLE source. \"\n-        + \"If this is a join, make sure that the criteria uses the TABLE's key column \"\n-        + Iterables.getOnlyElement(schema.key()).name().text() + \" instead of \"\n-        + keyExpression);\n+    // Table repartitioning is only supported for internal use in enabling joins\n+    if (!forceRepartition) {\n+      throw new UnsupportedOperationException(\"Cannot repartition a TABLE source. \"\n+          + \"If this is a join, make sure that the criteria uses the TABLE's key column \"\n+          + Iterables.getOnlyElement(schema.key()).name().text() + \" instead of \"\n+          + keyExpression);\n+    }\n+\n+    if (keyFormat.isWindowed()) {\n+      final String errorMsg = \"Implicit repartitioning of windowed sources is not supported. \"\n+          + \"See https://github.com/confluentinc/ksql/issues/4385.\";\n+      final String additionalMsg = forceRepartition\n+          ? \" As a result, ksqlDB does not support joins on Schema-Registry-enabled key formats \"", "originalCommit": "c0d83466c7b0beb4fe259c933f43698516f37baf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUyMTE4Mw==", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r525521183", "bodyText": "+1 nice refactor, can you add short javadoc? otherwise \"utils\" can be dumping ground for misc things", "author": "agavra", "createdAt": "2020-11-17T21:00:23Z", "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/MaterializationUtil.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.execution.streams;\n+\n+import io.confluent.ksql.GenericRow;\n+import io.confluent.ksql.SchemaNotSupportedException;\n+import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n+import io.confluent.ksql.execution.context.QueryContext;\n+import io.confluent.ksql.execution.plan.ExecutionStep;\n+import io.confluent.ksql.execution.plan.Formats;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.PhysicalSchema;\n+import org.apache.kafka.common.serialization.Serde;\n+import org.apache.kafka.common.utils.Bytes;\n+import org.apache.kafka.connect.data.Struct;\n+import org.apache.kafka.streams.kstream.Materialized;\n+import org.apache.kafka.streams.state.KeyValueStore;\n+\n+final class MaterializationUtil {", "originalCommit": "8638a61007a3707f297f8ae428b9cf16216df202", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzgyNjEyNw==", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r527826127", "bodyText": "Added a short javadoc but I'm not sure how much it adds beyond the name of the class. LMK if you had something else in mind.", "author": "vcrfxia", "createdAt": "2020-11-20T16:55:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUyMTE4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUyNjM4Nw==", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r525526387", "bodyText": "we might want to move this into JoiningNode so that we can leverage it both here and in JoinNode#getValueFormatForSource (that way, we can ensure that they line up - if for some reason we decide to switch JoinNode to use the right most value format, we won't have to make that change here too)", "author": "agavra", "createdAt": "2020-11-17T21:10:15Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PreJoinRepartitionNode.java", "diffHunk": "@@ -54,6 +59,10 @@ public PreJoinRepartitionNode(\n     this.joiningNode = source instanceof JoiningNode\n         ? Optional.of((JoiningNode) source)\n         : Optional.empty();\n+    this.valueFormat = getLeftmostSourceNode()", "originalCommit": "8638a61007a3707f297f8ae428b9cf16216df202", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzgyNjMyNA==", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r527826324", "bodyText": "Done -- good call!", "author": "vcrfxia", "createdAt": "2020-11-20T16:55:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUyNjM4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU0OTIwOA==", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r525549208", "bodyText": "I'm not sure, but should we make this requiresRepartition() || forceRepartition? If not, we should add a comment about why forced repartitions don't move in here (instead of // Node is repartitioning already)", "author": "agavra", "createdAt": "2020-11-17T21:52:51Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PreJoinRepartitionNode.java", "diffHunk": "@@ -92,6 +101,11 @@ public LogicalSchema getSchema() {\n \n   @Override\n   public void setKeyFormat(final FormatInfo format) {\n+    // Force repartition in case of schema inference, to avoid misses due to key schema ID mismatch\n+    if (FormatFactory.of(format).supportsFeature(SerdeFeature.SCHEMA_INFERENCE)) {\n+      forceRepartition = true;\n+    }\n+\n     if (requiresRepartition()) {", "originalCommit": "8638a61007a3707f297f8ae428b9cf16216df202", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzgyNzYzMg==", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r527827632", "bodyText": "Addressed this as part of revamping the logic (see #6635 (comment)).", "author": "vcrfxia", "createdAt": "2020-11-20T16:56:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU0OTIwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU1MDA1NQ==", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r525550055", "bodyText": "I know that none of this class is javadoc'd \ud83d\ude22 but I think it makes sense to tackle it a little bit at a time. Can we add some here explaining what forceRepartition does and why we might want to use it?", "author": "agavra", "createdAt": "2020-11-17T21:54:28Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/structured/SchemaKStream.java", "diffHunk": "@@ -306,20 +306,31 @@ static Expression rewriteTimeComparisonForFilter(final Expression expression) {\n \n   @SuppressWarnings(\"unchecked\")\n   public SchemaKStream<Struct> selectKey(\n+      final FormatInfo valueFormat,\n       final Expression keyExpression,\n       final Optional<FormatInfo> forceInternalKeyFormat,\n-      final Stacker contextStacker\n+      final Stacker contextStacker,\n+      final boolean forceRepartition", "originalCommit": "8638a61007a3707f297f8ae428b9cf16216df202", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU1MTQxOA==", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r525551418", "bodyText": "not your code: it bothers me a little that there's nothing \"requiring\" that this is called. can we have buildStream() throw an exception if setKeyFormat was never set? this will make sure that we don't refactor the code and lose this call somewhere in the refactor", "author": "agavra", "createdAt": "2020-11-17T21:57:02Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PreJoinRepartitionNode.java", "diffHunk": "@@ -92,6 +101,11 @@ public LogicalSchema getSchema() {\n \n   @Override\n   public void setKeyFormat(final FormatInfo format) {\n+    // Force repartition in case of schema inference, to avoid misses due to key schema ID mismatch", "originalCommit": "ad4ed3bc52af2183627a784c9feb24543245f24e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzgyNzMyMQ==", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r527827321", "bodyText": "That's because it wasn't required that this method be called previously :) I've revamped the logic here so it's now required, as that was the major point of confusion when reading this code as well. Also added the check you suggested.", "author": "vcrfxia", "createdAt": "2020-11-20T16:56:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU1MTQxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzgyODQyMA==", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r527828420", "bodyText": "Good call on challenging this, BTW. There was a bug where we weren't always forcing repartitions for upstream joins with SR-enableld key formats in multi-joins. I've fixed the bug and also added multi-join QTTs to cover this.", "author": "vcrfxia", "createdAt": "2020-11-20T16:57:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU1MTQxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU1MjI1NA==", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r525552254", "bodyText": "super nit: (usually better to have the easy things first in chained ands)\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    && repartitionNotNeeded(ImmutableList.of(keyExpression))\n          \n          \n            \n                    && !forceRepartition\n          \n          \n            \n                    && !forceRepartition\n          \n          \n            \n                    && repartitionNotNeeded(ImmutableList.of(keyExpression))", "author": "agavra", "createdAt": "2020-11-17T21:58:39Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/structured/SchemaKStream.java", "diffHunk": "@@ -306,20 +306,31 @@ static Expression rewriteTimeComparisonForFilter(final Expression expression) {\n \n   @SuppressWarnings(\"unchecked\")\n   public SchemaKStream<Struct> selectKey(\n+      final FormatInfo valueFormat,\n       final Expression keyExpression,\n       final Optional<FormatInfo> forceInternalKeyFormat,\n-      final Stacker contextStacker\n+      final Stacker contextStacker,\n+      final boolean forceRepartition\n   ) {\n     final boolean keyFormatChange = forceInternalKeyFormat.isPresent()\n         && !forceInternalKeyFormat.get().equals(keyFormat.getFormatInfo());\n \n-    if (!keyFormatChange && repartitionNotNeeded(ImmutableList.of(keyExpression))) {\n+    if (!keyFormatChange\n+        && repartitionNotNeeded(ImmutableList.of(keyExpression))\n+        && !forceRepartition", "originalCommit": "ad4ed3bc52af2183627a784c9feb24543245f24e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTYzMzk1MQ==", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r525633951", "bodyText": "\"easy\" meaning easy to grok or computationally easy to evaluate? (Already made the change, just curious about your motivations.)", "author": "vcrfxia", "createdAt": "2020-11-18T01:24:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU1MjI1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTYzNjE1OQ==", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r525636159", "bodyText": "both, but mostly the computationally easy one. I don't know by reading this code that repartitionNotNeeded is something lightweight - it might call out to some external service for all I know without digging into it. If we put the simple boolean checks first I don't really need to care", "author": "agavra", "createdAt": "2020-11-18T01:30:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU1MjI1NA=="}], "type": "inlineReview"}, {"oid": "94bef771f8d6c954065709e609a203f20437dfff", "url": "https://github.com/confluentinc/ksql/commit/94bef771f8d6c954065709e609a203f20437dfff", "message": "chore: fix test", "committedDate": "2020-11-18T00:57:57Z", "type": "commit"}, {"oid": "755de3bb18a7f7e6854c8fc99e6e0ab92c19eeb2", "url": "https://github.com/confluentinc/ksql/commit/755de3bb18a7f7e6854c8fc99e6e0ab92c19eeb2", "message": "chore: tweak error message, rename qtts", "committedDate": "2020-11-18T01:15:16Z", "type": "commit"}, {"oid": "3a13511a0e9714fe3d4842f1b448c6d6e9e9fcb8", "url": "https://github.com/confluentinc/ksql/commit/3a13511a0e9714fe3d4842f1b448c6d6e9e9fcb8", "message": "test: additional qtt", "committedDate": "2020-11-18T19:09:28Z", "type": "commit"}, {"oid": "12bf73f07a4975f08182f23b0d608103b1809e2c", "url": "https://github.com/confluentinc/ksql/commit/12bf73f07a4975f08182f23b0d608103b1809e2c", "message": "test: add table-table join test with nulls (not passing)", "committedDate": "2020-11-18T23:22:07Z", "type": "commit"}, {"oid": "062e9ac7bb74a9043458d38f260003cb281e59ab", "url": "https://github.com/confluentinc/ksql/commit/062e9ac7bb74a9043458d38f260003cb281e59ab", "message": "Merge branch 'master' into join-force-repartition", "committedDate": "2020-11-18T23:33:14Z", "type": "commit"}, {"oid": "fa5050e78d1e9967e5b07d68f4c1003278220949", "url": "https://github.com/confluentinc/ksql/commit/fa5050e78d1e9967e5b07d68f4c1003278220949", "message": "chore: feedback", "committedDate": "2020-11-20T03:06:23Z", "type": "commit"}, {"oid": "e4ed3260b9310b700a408029ebe8727ffc0f3409", "url": "https://github.com/confluentinc/ksql/commit/e4ed3260b9310b700a408029ebe8727ffc0f3409", "message": "fix: require key format to always be set", "committedDate": "2020-11-20T16:51:52Z", "type": "commit"}, {"oid": "a7bcc091088d0e3c10eda30e9cd87edeb68fe96a", "url": "https://github.com/confluentinc/ksql/commit/a7bcc091088d0e3c10eda30e9cd87edeb68fe96a", "message": "chore: minor cleanup to internal repartition topic names", "committedDate": "2020-11-20T18:29:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkwNzAzMg==", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r527907032", "bodyText": "\ud83d\ude02 pah. what a useless condition.", "author": "agavra", "createdAt": "2020-11-20T18:52:18Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/structured/SchemaKTable.java", "diffHunk": "@@ -140,15 +144,18 @@ public SchemaKTable(\n     );\n   }\n \n+  @SuppressFBWarnings(\"UC_USELESS_CONDITION\")", "originalCommit": "a7bcc091088d0e3c10eda30e9cd87edeb68fe96a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkwNzY2MA==", "url": "https://github.com/confluentinc/ksql/pull/6635#discussion_r527907660", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (repartitionNotNeeded(ImmutableList.of(keyExpression)) && !forceRepartition) {\n          \n          \n            \n                if (!forceRepartition && repartitionNotNeeded(ImmutableList.of(keyExpression))) {\n          \n      \n    \n    \n  \n\nnit: pet peeve of mine \ud83d\ude08", "author": "agavra", "createdAt": "2020-11-20T18:53:35Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/structured/SchemaKTable.java", "diffHunk": "@@ -140,15 +144,18 @@ public SchemaKTable(\n     );\n   }\n \n+  @SuppressFBWarnings(\"UC_USELESS_CONDITION\")\n   @SuppressWarnings(\"unchecked\")\n   @Override\n-  public SchemaKStream<Struct> selectKey(\n+  public SchemaKTable<Struct> selectKey(\n+      final FormatInfo valueFormat,\n       final Expression keyExpression,\n       final Optional<FormatInfo> forceInternalKeyFormat,\n-      final Stacker contextStacker\n+      final Stacker contextStacker,\n+      final boolean forceRepartition\n   ) {\n-    if (repartitionNotNeeded(ImmutableList.of(keyExpression))) {\n-      return (SchemaKStream<Struct>) this;\n+    if (repartitionNotNeeded(ImmutableList.of(keyExpression)) && !forceRepartition) {", "originalCommit": "a7bcc091088d0e3c10eda30e9cd87edeb68fe96a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ffd1293ea8c171a07661ec768e9935ded552ca8c", "url": "https://github.com/confluentinc/ksql/commit/ffd1293ea8c171a07661ec768e9935ded552ca8c", "message": "chore: almog's pet peeve ;o", "committedDate": "2020-11-20T20:12:08Z", "type": "commit"}, {"oid": "c9cb2d7082488bb15e9373e6c0101a275b7f39cc", "url": "https://github.com/confluentinc/ksql/commit/c9cb2d7082488bb15e9373e6c0101a275b7f39cc", "message": "Merge branch 'master' into join-force-repartition", "committedDate": "2020-11-20T20:12:45Z", "type": "commit"}]}