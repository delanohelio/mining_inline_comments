{"pr_number": 5257, "pr_title": "chore: implement new key semantics in queries", "pr_createdAt": "2020-05-04T19:08:19Z", "pr_url": "https://github.com/confluentinc/ksql/pull/5257", "timeline": [{"oid": "fd29558ba6e5e4bbfb458ef47f443d44eb8bf98e", "url": "https://github.com/confluentinc/ksql/commit/fd29558ba6e5e4bbfb458ef47f443d44eb8bf98e", "message": "chore: implement new key semantics in queries\n\nThis change implements the change in key semantics in queries outlined in [KLIP-24](https://github.com/confluentinc/ksql/pull/5115).", "committedDate": "2020-05-04T18:53:26Z", "type": "commit"}, {"oid": "630725c25d4e922ceb2ce20858b903f1c1025dfc", "url": "https://github.com/confluentinc/ksql/commit/630725c25d4e922ceb2ce20858b903f1c1025dfc", "message": "Merge branch 'master' into new_key_semantics", "committedDate": "2020-05-04T18:53:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY2Mzk4OA==", "url": "https://github.com/confluentinc/ksql/pull/5257#discussion_r419663988", "bodyText": "Added have more human friendly phrasing of error messages.  If anyone knows of an existing utility to do this I'm happy to switch...", "author": "big-andy-coates", "createdAt": "2020-05-04T19:09:45Z", "path": "ksqldb-common/src/main/java/io/confluent/ksql/util/GrammaticalJoiner.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.util;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import java.util.Iterator;\n+import java.util.Objects;\n+import java.util.stream.Stream;\n+\n+/**\n+ * An object which joins pieces of text, with a separator and additional final word, allowing more\n+ * grammatically correct joining, e,g. \"a, b, c or d\".\n+ */\n+public final class GrammaticalJoiner {", "originalCommit": "630725c25d4e922ceb2ce20858b903f1c1025dfc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY2NDczOA==", "url": "https://github.com/confluentinc/ksql/pull/5257#discussion_r419664738", "bodyText": "This is the call to throw, should the projection not include the key columns.\nOnce the any key name functionality has been turned on, this check can move into KsqlStructuredDataOutputNode to make it more OO.", "author": "big-andy-coates", "createdAt": "2020-05-04T19:11:07Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/LogicalPlanner.java", "diffHunk": "@@ -149,6 +158,11 @@ private OutputNode buildOutputNode(final PlanNode sourcePlanNode) {\n \n     final Into intoDataSource = analysis.getInto().get();\n \n+    if (ksqlConfig.getBoolean(KsqlConfig.KSQL_ANY_KEY_NAME_ENABLED)) {\n+      ((VerifiableNode) sourcePlanNode)\n+          .validateKeyPresent(intoDataSource.getName());\n+    }", "originalCommit": "630725c25d4e922ceb2ce20858b903f1c1025dfc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY2NjgwMw==", "url": "https://github.com/confluentinc/ksql/pull/5257#discussion_r419666803", "bodyText": "To be able to determine the schema of the JoinNode we must first know which of the join expressions, if any, will be used as the key column in the result.   This is a bit of a chicken and egg problem, and this isn't a great solution.\nI have thoughts on how this can be resolved in a follow up PR.", "author": "big-andy-coates", "createdAt": "2020-05-04T19:14:39Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/LogicalPlanner.java", "diffHunk": "@@ -523,16 +598,75 @@ private PlanNode buildJoin(final Join root, final String prefix) {\n           leaf.getSource(), prefix + \"Right\", root.getInfo().getRightJoinExpression());\n     }\n \n+    final boolean finalJoin = prefix.isEmpty();\n+\n+    final JoinKey joinKey = buildJoinKey(root);\n+\n     return new JoinNode(\n         new PlanNodeId(prefix + \"Join\"),\n         root.getInfo().getType(),\n+        joinKey.rewriteWith(refRewriter::process),\n+        finalJoin,\n         left,\n         right,\n         root.getInfo().getWithinExpression()\n     );\n   }\n \n-  private DataSourceNode buildNonJoinNode(final AliasedDataSource dataSource) {\n+  private JoinKey buildJoinKey(final Join join) {", "originalCommit": "630725c25d4e922ceb2ce20858b903f1c1025dfc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY2NzYxOA==", "url": "https://github.com/confluentinc/ksql/pull/5257#discussion_r419667618", "bodyText": "Added this class to help with working out what's in the projection without having to compile all the SelectExpressions, mainly as the compilation requires the source schema, as we need to work out what's in the projection of joins to work out what the schema is!", "author": "big-andy-coates", "createdAt": "2020-05-04T19:16:10Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/Projection.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.planner;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.errorprone.annotations.Immutable;\n+import io.confluent.ksql.execution.expression.tree.Expression;\n+import io.confluent.ksql.execution.expression.tree.QualifiedColumnReferenceExp;\n+import io.confluent.ksql.name.SourceName;\n+import io.confluent.ksql.parser.tree.AllColumns;\n+import io.confluent.ksql.parser.tree.SelectItem;\n+import io.confluent.ksql.parser.tree.SingleColumn;\n+import java.util.Collection;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Holds information about in a projection\n+ */\n+@Immutable\n+public final class Projection {", "originalCommit": "630725c25d4e922ceb2ce20858b903f1c1025dfc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY2NzgwMg==", "url": "https://github.com/confluentinc/ksql/pull/5257#discussion_r419667802", "bodyText": "Moved to parent class.", "author": "big-andy-coates", "createdAt": "2020-05-04T19:16:29Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/DataSourceNode.java", "diffHunk": "@@ -139,28 +153,6 @@ private static LogicalSchema buildSchema(final DataSource dataSource) {\n         .withPseudoAndKeyColsInValue(dataSource.getKsqlTopic().getKeyFormat().isWindowed());\n   }\n \n-  @SuppressWarnings(\"UnstableApiUsage\")", "originalCommit": "630725c25d4e922ceb2ce20858b903f1c1025dfc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY3MjM3MQ==", "url": "https://github.com/confluentinc/ksql/pull/5257#discussion_r419672371", "bodyText": "Both are unfortunately required at the moment because of the mess around rewritten vs original expressions.\nThe projection passed in knows about rewritten column references e.g. T_ID , not T.ID. So we need to use rewritten columns returned by joinKey.getAvailableKeys().\nUnfortunately, the T_ID won't match a T.* in the projection. For that to match we need the original T.ID - hence we need both for now.\nI've got a todo locally to see if this can be avoided. Fixing it will likely mean rethinking how the rewrites are done.", "author": "big-andy-coates", "createdAt": "2020-05-04T19:24:40Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/JoinNode.java", "diffHunk": "@@ -112,15 +145,59 @@ protected int getPartitions(final KafkaTopicClient kafkaTopicClient) {\n     return right.getPartitions(kafkaTopicClient);\n   }\n \n+  @SuppressWarnings(\"UnstableApiUsage\")\n   @Override\n   public Stream<ColumnName> resolveSelectStar(\n-      final Optional<SourceName> sourceName, final boolean valueOnly\n+      final Optional<SourceName> sourceName,\n+      final boolean valueOnly\n   ) {\n-    return getSources()\n-            .stream()\n-            .flatMap(s -> s instanceof JoinNode ? s.getSources().stream() : Stream.of(s))\n-            .filter(s -> !sourceName.isPresent() || sourceName.equals(s.getSourceName()))\n-            .flatMap(s -> s.resolveSelectStar(sourceName, false));\n+    final Stream<ColumnName> names = Stream.of(left, right)\n+        .flatMap(s -> s instanceof JoinNode ? s.getSources().stream() : Stream.of(s))\n+        .filter(s -> !sourceName.isPresent() || sourceName.equals(s.getSourceName()))\n+        .flatMap(s -> s.resolveSelectStar(sourceName, false));\n+\n+    if (sourceName.isPresent() || joinKey.getType() != Type.SYNTHETIC || !finalJoin) {\n+      return names;\n+    }\n+\n+    final Column syntheticKey = Iterables.getOnlyElement(getSchema().key());\n+\n+    return Streams.concat(Stream.of(syntheticKey.name()), names);\n+  }\n+\n+  public Expression resolveSelect(final int idx, final Expression expression) {\n+    return joinKey.resolveSelect(expression, getSchema());\n+  }\n+\n+  @SuppressWarnings(\"UnstableApiUsage\")\n+  @Override\n+  void validateKeyPresent(final SourceName sinkName, final Projection projection) {\n+\n+    final boolean atLeastOneKey = Streams.concat(\n+        joinKey.getAvailableKeys().stream(),\n+        joinKey.getOriginalAvailableKeys().stream()\n+    ).anyMatch(projection::containsExpression);", "originalCommit": "630725c25d4e922ceb2ce20858b903f1c1025dfc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY3NjY0Nw==", "url": "https://github.com/confluentinc/ksql/pull/5257#discussion_r419676647", "bodyText": "Again, not nice - tracked by #5258 as well.", "author": "big-andy-coates", "createdAt": "2020-05-04T19:32:05Z", "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/KsqlValueJoiner.java", "diffHunk": "@@ -15,38 +15,50 @@\n \n package io.confluent.ksql.execution.streams;\n \n+import static com.google.common.base.Preconditions.checkArgument;\n+\n import io.confluent.ksql.GenericRow;\n-import io.confluent.ksql.schema.ksql.LogicalSchema;\n import java.util.Objects;\n import org.apache.kafka.streams.kstream.ValueJoiner;\n \n public final class KsqlValueJoiner implements ValueJoiner<GenericRow, GenericRow, GenericRow> {\n-  private final LogicalSchema leftSchema;\n-  private final LogicalSchema rightSchema;\n \n-  KsqlValueJoiner(final LogicalSchema leftSchema, final LogicalSchema rightSchema) {\n-    this.leftSchema = Objects.requireNonNull(leftSchema, \"leftSchema\");\n-    this.rightSchema = Objects.requireNonNull(rightSchema, \"rightSchema\");\n+  private final int leftCount;\n+  private final int rightCount;\n+  private final int additionalCount;\n+\n+  KsqlValueJoiner(final int leftCount, final int rightCount, final int additionalCount) {\n+    checkArgument(leftCount >= 0, \"leftCount negative: \" + leftCount);\n+    checkArgument(rightCount >= 0, \"rightCount negative: \" + rightCount);\n+    checkArgument(additionalCount >= 0, \"additionalCount negative: \" + additionalCount);\n+\n+    this.leftCount = leftCount;\n+    this.rightCount = rightCount;\n+    this.additionalCount = additionalCount;\n   }\n \n   @Override\n   public GenericRow apply(final GenericRow left, final GenericRow right) {\n-    final GenericRow row = new GenericRow(\n-        leftSchema.value().size() + rightSchema.value().size()\n-    );\n+\n+    final GenericRow row = new GenericRow(leftCount + rightCount + additionalCount);\n \n     if (left != null) {\n       row.appendAll(left.values());\n     } else {\n-      fillWithNulls(row, leftSchema.value().size());\n+      fillWithNulls(row, leftCount);\n     }\n \n     if (right != null) {\n       row.appendAll(right.values());\n     } else {\n-      fillWithNulls(row, rightSchema.value().size());\n+      fillWithNulls(row, rightCount);\n     }\n \n+    // Potentially append additional nulls as a holder for a synthetic key columns.\n+    // These columns are not populated, as they are not accessed, but must be present for the row\n+    // to match the rows schema.\n+    fillWithNulls(row, additionalCount);", "originalCommit": "630725c25d4e922ceb2ce20858b903f1c1025dfc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc3MzM3MA==", "url": "https://github.com/confluentinc/ksql/pull/5257#discussion_r419773370", "bodyText": "I think this method belongs in JoinTree, and it probably also makes sense to make it recursive in the case of multi-joins. What if I have:\nSELECT A.foo FROM A\n   JOIN B ON A.foo = ABS(B.oof)\n   JOIN C ON ABS(B.oof) = ABS(C.falafel);\nWe don't need to use JOINKEY because we know that the key is A.foo but we can only determine that recursively.", "author": "agavra", "createdAt": "2020-05-04T22:48:07Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/LogicalPlanner.java", "diffHunk": "@@ -523,16 +598,75 @@ private PlanNode buildJoin(final Join root, final String prefix) {\n           leaf.getSource(), prefix + \"Right\", root.getInfo().getRightJoinExpression());\n     }\n \n+    final boolean finalJoin = prefix.isEmpty();\n+\n+    final JoinKey joinKey = buildJoinKey(root);\n+\n     return new JoinNode(\n         new PlanNodeId(prefix + \"Join\"),\n         root.getInfo().getType(),\n+        joinKey.rewriteWith(refRewriter::process),\n+        finalJoin,\n         left,\n         right,\n         root.getInfo().getWithinExpression()\n     );\n   }\n \n-  private DataSourceNode buildNonJoinNode(final AliasedDataSource dataSource) {\n+  private JoinKey buildJoinKey(final Join join) {\n+    if (!ksqlConfig.getBoolean(KsqlConfig.KSQL_ANY_KEY_NAME_ENABLED)) {\n+      return JoinKey.leftColumn(ImmutableList.of());\n+    }\n+\n+    final JoinInfo info = join.getInfo();\n+\n+    // Joins have a synthesised key column when:\n+\n+    // - the join is an outer join: for outer joins either join expression may be null. However,\n+    //   the key column is set to the non-null value. This means the key column is not either\n+    //   join expression: it is a _new_ column.\n+    if (info.getType() == JoinType.OUTER) {\n+      return JoinKey.syntheticColumn(info.getLeftJoinExpression(), info.getRightJoinExpression());\n+    }\n+\n+    final boolean leftIsCol = info.getLeftJoinExpression() instanceof QualifiedColumnReferenceExp;\n+    final boolean rightIsCol = info.getRightJoinExpression() instanceof QualifiedColumnReferenceExp;\n+\n+    // - neither join expression is a column reference: if neither is a column reference, by\n+    //   definition the column that holds the result is not equal to a column in either source: it\n+    //   is a _new_ column.", "originalCommit": "630725c25d4e922ceb2ce20858b903f1c1025dfc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAyNDAyMg==", "url": "https://github.com/confluentinc/ksql/pull/5257#discussion_r420024022", "bodyText": "Good catch.", "author": "big-andy-coates", "createdAt": "2020-05-05T10:57:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc3MzM3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDIwNDU2Mg==", "url": "https://github.com/confluentinc/ksql/pull/5257#discussion_r420204562", "bodyText": "Done.", "author": "big-andy-coates", "createdAt": "2020-05-05T15:35:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc3MzM3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc3NTAxNQ==", "url": "https://github.com/confluentinc/ksql/pull/5257#discussion_r419775015", "bodyText": "I worked hard to remove this method \ud83d\ude22 it seems really unfortunate that we need to \"know\" when to get the original analysis and when to use the rewritten one. Looking at the usage of original(), getPartitionBy is only used from the original - it's the join projection part that is tricky to remove usage of... anyway perhaps it can be saved for a later PR, but I'd love to get rid of this again", "author": "agavra", "createdAt": "2020-05-04T22:52:33Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/RewrittenAnalysis.java", "diffHunk": "@@ -59,6 +59,10 @@ public RewrittenAnalysis(\n     this.rewriter = Objects.requireNonNull(rewriter, \"rewriter\");\n   }\n \n+  public ImmutableAnalysis original() {\n+    return original;\n+  }", "originalCommit": "630725c25d4e922ceb2ce20858b903f1c1025dfc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAyNDc4MQ==", "url": "https://github.com/confluentinc/ksql/pull/5257#discussion_r420024781", "bodyText": "I know, I don't like putting it back either.\nThe originals are needed for error messages, so that we get errors about T.ID not being in the projection, (which is what the user needs to add), and not T_ID which would result in an error if they added it.\nImproving the way this handled is probably best left outside the scope of this PR though. :'(", "author": "big-andy-coates", "createdAt": "2020-05-05T10:58:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc3NTAxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc3NjA5Mw==", "url": "https://github.com/confluentinc/ksql/pull/5257#discussion_r419776093", "bodyText": "I'm confused, doesn't select.getAlias() return the alias for the new field? If I have SELECT 'foo' AS OLD_KEY_NAME FROM foo why should 'foo' be the new key?", "author": "agavra", "createdAt": "2020-05-04T22:55:42Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/LogicalPlanner.java", "diffHunk": "@@ -554,17 +688,55 @@ private DataSourceNode buildNonJoinNode(final AliasedDataSource dataSource) {\n   }\n \n   private LogicalSchema buildProjectionSchema(\n-      final LogicalSchema schema,\n+      final LogicalSchema parentSchema,\n       final List<SelectExpression> projection\n   ) {\n+    if (!ksqlConfig.getBoolean(KsqlConfig.KSQL_ANY_KEY_NAME_ENABLED)) {\n+      return buildLegacyProjectionSchema(parentSchema, projection);\n+    }\n+\n     final ExpressionTypeManager expressionTypeManager = new ExpressionTypeManager(\n-        schema,\n+        parentSchema,\n+        functionRegistry\n+    );\n+\n+    final Builder builder = LogicalSchema.builder();\n+\n+    final ImmutableMap.Builder<ColumnName, SqlType> keys = ImmutableMap.builder();\n+\n+    for (final SelectExpression select : projection) {\n+      final Expression expression = select.getExpression();\n+\n+      final SqlType expressionType = expressionTypeManager\n+          .getExpressionSqlType(expression);\n+\n+      final boolean keyColumn = expression instanceof ColumnReferenceExp\n+          ? parentSchema.isKeyColumn(((ColumnReferenceExp) expression).getColumnName())\n+          : parentSchema.isKeyColumn(select.getAlias());", "originalCommit": "630725c25d4e922ceb2ce20858b903f1c1025dfc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAyNjA2NA==", "url": "https://github.com/confluentinc/ksql/pull/5257#discussion_r420026064", "bodyText": "You are right - updated to:\nfinal boolean keyColumn = expression instanceof ColumnReferenceExp \n          && parentSchema.isKeyColumn(((ColumnReferenceExp) expression).getColumnName());\n(Really appreciate your thorough review! My heads been in this code for too long. Can't see the wood for the trees...)", "author": "big-andy-coates", "createdAt": "2020-05-05T11:01:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc3NjA5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc3NzgzMA==", "url": "https://github.com/confluentinc/ksql/pull/5257#discussion_r419777830", "bodyText": "nit: seems like a good utility method public static ColumnName getNextKsqlColAlias(final LogicalSchema currentSchema)", "author": "agavra", "createdAt": "2020-05-04T23:00:35Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/LogicalPlanner.java", "diffHunk": "@@ -589,54 +761,101 @@ private LogicalSchema buildAggregateSchema(\n         projectionExpressions\n     );\n \n-    final ColumnAliasGenerator keyColNameGen = ColumnNames\n-        .columnAliasGenerator(Stream.of(sourceSchema, projectionSchema));\n-\n     final List<Expression> groupByExps = groupBy.getGroupingExpressions();\n \n-    final ColumnName keyName;\n+    final Function<Expression, Optional<ColumnName>> selectResolver = expression -> {\n+      final List<ColumnName> foundInProjection = projectionExpressions.stream()\n+          .filter(e -> e.getExpression().equals(expression))\n+          .map(SelectExpression::getAlias)\n+          .collect(Collectors.toList());\n+\n+      switch (foundInProjection.size()) {\n+        case 0:\n+          return Optional.empty();\n+\n+        case 1:\n+          return Optional.of(foundInProjection.get(0));\n+\n+        default:\n+          final String keys = GrammaticalJoiner.and().join(foundInProjection);\n+          throw new KsqlException(\"The projection contains a key column more than once: \" + keys\n+              + \".\"\n+              + System.lineSeparator()\n+              + \"Each key column must only be in the projection once. \"\n+              + \"If you intended to copy the key into the value, then consider using the \"\n+              + AsValue.NAME + \" function to indicate which key reference should be copied.\"\n+          );\n+      }\n+    };\n+\n+    final Optional<ColumnName> keyName;\n     final SqlType keyType;\n+    final Set<ColumnName> keyColumnNames;\n \n     if (groupByExps.size() != 1) {\n       if (ksqlConfig.getBoolean(KsqlConfig.KSQL_ANY_KEY_NAME_ENABLED)) {\n-        keyName = groupBy.getAlias()\n-            .orElseGet(keyColNameGen::nextKsqlColAlias);\n+\n+        keyName = Optional.of(groupBy.getAlias()\n+            .orElseGet(() -> ColumnNames.columnAliasGenerator(Stream.of(\n+                sourceSchema,\n+                LogicalSchema.builder()\n+                    .valueColumns(projectionSchema.value())\n+                    .build()\n+                ))\n+                    .nextKsqlColAlias()", "originalCommit": "630725c25d4e922ceb2ce20858b903f1c1025dfc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAzMDI1Mw==", "url": "https://github.com/confluentinc/ksql/pull/5257#discussion_r420030253", "bodyText": "done.", "author": "big-andy-coates", "createdAt": "2020-05-05T11:10:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc3NzgzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc4Mzk2Nw==", "url": "https://github.com/confluentinc/ksql/pull/5257#discussion_r419783967", "bodyText": "can we pull out !anyKeyName from the stream? seems harder to read instead of:\nanyKeyName \n\t? ImmutableList.empty() \n\t: projection.stream().filter(e -> groupings.contains(e.getExpression()).collect(ImmutableList.toImmutableList())", "author": "agavra", "createdAt": "2020-05-04T23:19:07Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/AggregateNode.java", "diffHunk": "@@ -105,13 +111,20 @@ public AggregateNode(\n         .copyOf(rewrittenAggregateAnalysis.getAggregateFunctions());\n     this.requiredColumns = ImmutableList\n         .copyOf(rewrittenAggregateAnalysis.getRequiredColumns());\n-    this.finalSelectExpressions = ImmutableList.copyOf(projectionExpressions.stream()\n+\n+    this.projection = ImmutableList.copyOf(projectionExpressions.stream()\n         .map(se -> SelectExpression.of(\n             se.getAlias(),\n             ExpressionTreeRewriter\n                 .rewriteWith(aggregateExpressionRewriter::process, se.getExpression())\n         ))\n         .collect(Collectors.toList()));\n+\n+    final Set<Expression> groupings = ImmutableSet.copyOf(groupBy.getGroupingExpressions());\n+    this.finalSelectExpressions = ImmutableList.copyOf(projection.stream()\n+        .filter(e -> !anyKeyName || !groupings.contains(e.getExpression()))", "originalCommit": "630725c25d4e922ceb2ce20858b903f1c1025dfc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAzMDg5Mg==", "url": "https://github.com/confluentinc/ksql/pull/5257#discussion_r420030892", "bodyText": "Meh, that's temporary code until 'any key name' is enabled.  So... no :p", "author": "big-andy-coates", "createdAt": "2020-05-05T11:11:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc4Mzk2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc4NTkxNw==", "url": "https://github.com/confluentinc/ksql/pull/5257#discussion_r419785917", "bodyText": "if I understand correctly, this isn't actually a requirement right yet in the case of multiple column group bys? From the KLIP:\nCREATE TABLE OUTPUT AS\n   SELECT V0, ABS(V1) AS V1, COUNT(*) AS COUNT FROM INPUT GROUP BY V0, ABS(V1);\n-- resulting schema: KSQL_COL_0 STRING KEY, V0 INT, V1 INT, COUNT BIGINT\n-- where KSQL_COL_0 contains data in the form V0 + \"|+|\" + ABS(V1)\nI think it's OK to require them to select it now anyway as they will eventually need to select them, but I just wanted to make sure that this is \"future looking\" in the case of multiple columns.", "author": "agavra", "createdAt": "2020-05-04T23:25:21Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/AggregateNode.java", "diffHunk": "@@ -177,6 +190,19 @@ public PlanNode getSource() {\n     return selectRequiredOutputColumns(aggregated, contextStacker, builder);\n   }\n \n+  @Override\n+  public void validateKeyPresent(final SourceName sinkName) {\n+    final List<Expression> missing = new ArrayList<>(groupBy.getGroupingExpressions());\n+\n+    projection.stream()\n+        .map(SelectExpression::getExpression)\n+        .forEach(missing::remove);\n+\n+    if (!missing.isEmpty()) {\n+      throwKeysNotIncludedError(sinkName, \"grouping expression\", missing, and());\n+    }", "originalCommit": "630725c25d4e922ceb2ce20858b903f1c1025dfc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAzMjY3Ng==", "url": "https://github.com/confluentinc/ksql/pull/5257#discussion_r420032676", "bodyText": "The SQL you quote is explaining what would happen at the moment, not what we want to happen.\nThe KLIP says 'all key columns must be in the projection', which for multi-expression aggregations is each grouping expression.\nSo the check is correct, even if the KLIP may not be 100% clear on this. (I'll update the KLIP)", "author": "big-andy-coates", "createdAt": "2020-05-05T11:15:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc4NTkxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc4OTAwOQ==", "url": "https://github.com/confluentinc/ksql/pull/5257#discussion_r419789009", "bodyText": "just a note - all of this complexity could go away if we support materialized views without \"access\" to the key columns :P at this point I'm not sure which one was more work, enforcing the key constraint or supporting no-keys", "author": "agavra", "createdAt": "2020-05-04T23:35:28Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/JoinNode.java", "diffHunk": "@@ -112,15 +145,59 @@ protected int getPartitions(final KafkaTopicClient kafkaTopicClient) {\n     return right.getPartitions(kafkaTopicClient);\n   }\n \n+  @SuppressWarnings(\"UnstableApiUsage\")\n   @Override\n   public Stream<ColumnName> resolveSelectStar(\n-      final Optional<SourceName> sourceName, final boolean valueOnly\n+      final Optional<SourceName> sourceName,\n+      final boolean valueOnly\n   ) {\n-    return getSources()\n-            .stream()\n-            .flatMap(s -> s instanceof JoinNode ? s.getSources().stream() : Stream.of(s))\n-            .filter(s -> !sourceName.isPresent() || sourceName.equals(s.getSourceName()))\n-            .flatMap(s -> s.resolveSelectStar(sourceName, false));\n+    final Stream<ColumnName> names = Stream.of(left, right)\n+        .flatMap(s -> s instanceof JoinNode ? s.getSources().stream() : Stream.of(s))\n+        .filter(s -> !sourceName.isPresent() || sourceName.equals(s.getSourceName()))\n+        .flatMap(s -> s.resolveSelectStar(sourceName, false));\n+\n+    if (sourceName.isPresent() || joinKey.getType() != Type.SYNTHETIC || !finalJoin) {\n+      return names;\n+    }\n+\n+    final Column syntheticKey = Iterables.getOnlyElement(getSchema().key());\n+\n+    return Streams.concat(Stream.of(syntheticKey.name()), names);\n+  }\n+\n+  public Expression resolveSelect(final int idx, final Expression expression) {\n+    return joinKey.resolveSelect(expression, getSchema());\n+  }\n+\n+  @SuppressWarnings(\"UnstableApiUsage\")\n+  @Override\n+  void validateKeyPresent(final SourceName sinkName, final Projection projection) {", "originalCommit": "630725c25d4e922ceb2ce20858b903f1c1025dfc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAzMzE3OQ==", "url": "https://github.com/confluentinc/ksql/pull/5257#discussion_r420033179", "bodyText": "Yeah yeah. It's on my roadmap :p", "author": "big-andy-coates", "createdAt": "2020-05-05T11:16:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc4OTAwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc4OTQyMg==", "url": "https://github.com/confluentinc/ksql/pull/5257#discussion_r419789422", "bodyText": "shouldn't it be exactly one key? If I have:\nSELECT col1, col2 FROM A JOIN B ON A.col1 = B.col2;\nI would be selecting the same key twice, no?\n\nEDIT: or is it since we default to the left source only col1 is the key, and this works? That seems confusing, but I suppose it's acceptable as the key name really doesn't matter in this case", "author": "agavra", "createdAt": "2020-05-04T23:36:53Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/JoinNode.java", "diffHunk": "@@ -112,15 +145,59 @@ protected int getPartitions(final KafkaTopicClient kafkaTopicClient) {\n     return right.getPartitions(kafkaTopicClient);\n   }\n \n+  @SuppressWarnings(\"UnstableApiUsage\")\n   @Override\n   public Stream<ColumnName> resolveSelectStar(\n-      final Optional<SourceName> sourceName, final boolean valueOnly\n+      final Optional<SourceName> sourceName,\n+      final boolean valueOnly\n   ) {\n-    return getSources()\n-            .stream()\n-            .flatMap(s -> s instanceof JoinNode ? s.getSources().stream() : Stream.of(s))\n-            .filter(s -> !sourceName.isPresent() || sourceName.equals(s.getSourceName()))\n-            .flatMap(s -> s.resolveSelectStar(sourceName, false));\n+    final Stream<ColumnName> names = Stream.of(left, right)\n+        .flatMap(s -> s instanceof JoinNode ? s.getSources().stream() : Stream.of(s))\n+        .filter(s -> !sourceName.isPresent() || sourceName.equals(s.getSourceName()))\n+        .flatMap(s -> s.resolveSelectStar(sourceName, false));\n+\n+    if (sourceName.isPresent() || joinKey.getType() != Type.SYNTHETIC || !finalJoin) {\n+      return names;\n+    }\n+\n+    final Column syntheticKey = Iterables.getOnlyElement(getSchema().key());\n+\n+    return Streams.concat(Stream.of(syntheticKey.name()), names);\n+  }\n+\n+  public Expression resolveSelect(final int idx, final Expression expression) {\n+    return joinKey.resolveSelect(expression, getSchema());\n+  }\n+\n+  @SuppressWarnings(\"UnstableApiUsage\")\n+  @Override\n+  void validateKeyPresent(final SourceName sinkName, final Projection projection) {\n+\n+    final boolean atLeastOneKey = Streams.concat(\n+        joinKey.getAvailableKeys().stream(),\n+        joinKey.getOriginalAvailableKeys().stream()\n+    ).anyMatch(projection::containsExpression);\n+\n+    if (!atLeastOneKey) {", "originalCommit": "630725c25d4e922ceb2ce20858b903f1c1025dfc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAzMzkwNw==", "url": "https://github.com/confluentinc/ksql/pull/5257#discussion_r420033907", "bodyText": "With this PR, yes, it defaults the key column to the left join column, though you're right in that it could be the right join column.\nIn the future, both key columns should be in the key.", "author": "big-andy-coates", "createdAt": "2020-05-05T11:17:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc4OTQyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc5MDAwMg==", "url": "https://github.com/confluentinc/ksql/pull/5257#discussion_r419790002", "bodyText": "nit: since there are only two implementations I don't think this makes sense as default - just implement it inline", "author": "agavra", "createdAt": "2020-05-04T23:38:58Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/JoinNode.java", "diffHunk": "@@ -382,9 +467,206 @@ private static DataSourceType calculateSinkType(\n   }\n \n   private static LogicalSchema buildJoinSchema(\n+      final JoinKey joinKey,\n       final PlanNode left,\n       final PlanNode right\n   ) {\n-    return JoinParamsFactory.createSchema(left.getSchema(), right.getSchema());\n+    final ColumnName keyName = joinKey.resolveKeyName(left.getSchema(), right.getSchema());\n+    return JoinParamsFactory.createSchema(keyName, left.getSchema(), right.getSchema());\n+  }\n+\n+  @Immutable\n+  public interface JoinKey {\n+\n+    static JoinKey leftColumn(\n+        final Collection<QualifiedColumnReferenceExp> availableKeyColumns\n+    ) {\n+      return NonSyntheticJoinKey.left(availableKeyColumns);\n+    }\n+\n+    static JoinKey rightColumn(\n+        final Collection<QualifiedColumnReferenceExp> availableKeyColumns\n+    ) {\n+      return NonSyntheticJoinKey.right(availableKeyColumns);\n+    }\n+\n+    static JoinKey syntheticColumn(final Expression leftJoinExp, final Expression rightJoinExp) {\n+      return SyntheticJoinKey.of(leftJoinExp, rightJoinExp);\n+    }\n+\n+    enum Type {\n+      LEFT, RIGHT, SYNTHETIC\n+    }\n+\n+    /**\n+     * @return the type of the join key.\n+     */\n+    Type getType();\n+\n+    /**\n+     * @return the list of viable key expressions that can be used in the projection.\n+     */\n+    List<? extends Expression> getAvailableKeys();\n+\n+    /**\n+     * @return the list of viable key expressions, without any rewriting applied.\n+     */\n+    List<? extends Expression> getOriginalAvailableKeys();\n+\n+    /**\n+     * @return Given the left and right schemas, the name of the join key.\n+     */\n+    ColumnName resolveKeyName(LogicalSchema left, LogicalSchema right);\n+\n+    /**\n+     * Called to potentially resolve a {@link JoinKeyUdf} expression into the synthetic column\n+     * name.\n+     *\n+     * @param expression the expression to resolve.\n+     * @param schema the joined schema.\n+     * @return the resolved expression.\n+     */\n+    default Expression resolveSelect(", "originalCommit": "630725c25d4e922ceb2ce20858b903f1c1025dfc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAzNDA1Ng==", "url": "https://github.com/confluentinc/ksql/pull/5257#discussion_r420034056", "bodyText": "Good call. (There were previously more)", "author": "big-andy-coates", "createdAt": "2020-05-05T11:18:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc5MDAwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc5MTgwOQ==", "url": "https://github.com/confluentinc/ksql/pull/5257#discussion_r419791809", "bodyText": "heh this gets hairy with multi-joins, you may already have a test for this but if we select something like:\nSELECT JOINKEY(A.id, ABS(B.id) FROM A \n   JOIN A.id = ABS(B.id)\n   FULL JOIN A.id = C.foo\nThat should technically work, right? We can also just decide to make it fail and tell the user to use JONKEY(A.id, C.foo)", "author": "agavra", "createdAt": "2020-05-04T23:44:44Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/JoinNode.java", "diffHunk": "@@ -382,9 +467,206 @@ private static DataSourceType calculateSinkType(\n   }\n \n   private static LogicalSchema buildJoinSchema(\n+      final JoinKey joinKey,\n       final PlanNode left,\n       final PlanNode right\n   ) {\n-    return JoinParamsFactory.createSchema(left.getSchema(), right.getSchema());\n+    final ColumnName keyName = joinKey.resolveKeyName(left.getSchema(), right.getSchema());\n+    return JoinParamsFactory.createSchema(keyName, left.getSchema(), right.getSchema());\n+  }\n+\n+  @Immutable\n+  public interface JoinKey {\n+\n+    static JoinKey leftColumn(\n+        final Collection<QualifiedColumnReferenceExp> availableKeyColumns\n+    ) {\n+      return NonSyntheticJoinKey.left(availableKeyColumns);\n+    }\n+\n+    static JoinKey rightColumn(\n+        final Collection<QualifiedColumnReferenceExp> availableKeyColumns\n+    ) {\n+      return NonSyntheticJoinKey.right(availableKeyColumns);\n+    }\n+\n+    static JoinKey syntheticColumn(final Expression leftJoinExp, final Expression rightJoinExp) {\n+      return SyntheticJoinKey.of(leftJoinExp, rightJoinExp);\n+    }\n+\n+    enum Type {\n+      LEFT, RIGHT, SYNTHETIC\n+    }\n+\n+    /**\n+     * @return the type of the join key.\n+     */\n+    Type getType();\n+\n+    /**\n+     * @return the list of viable key expressions that can be used in the projection.\n+     */\n+    List<? extends Expression> getAvailableKeys();\n+\n+    /**\n+     * @return the list of viable key expressions, without any rewriting applied.\n+     */\n+    List<? extends Expression> getOriginalAvailableKeys();\n+\n+    /**\n+     * @return Given the left and right schemas, the name of the join key.\n+     */\n+    ColumnName resolveKeyName(LogicalSchema left, LogicalSchema right);\n+\n+    /**\n+     * Called to potentially resolve a {@link JoinKeyUdf} expression into the synthetic column\n+     * name.\n+     *\n+     * @param expression the expression to resolve.\n+     * @param schema the joined schema.\n+     * @return the resolved expression.\n+     */\n+    default Expression resolveSelect(\n+        final Expression expression,\n+        final LogicalSchema schema\n+    ) {\n+      return expression;\n+    }\n+\n+    /**\n+     * Rewrite the join key with the supplied plugin.\n+     *\n+     * @param plugin the plugin to use.\n+     * @return the rewritten join key.\n+     */\n+    JoinKey rewriteWith(BiFunction<Expression, Context<Void>, Optional<Expression>> plugin);\n+  }\n+\n+  public static final class NonSyntheticJoinKey implements JoinKey {\n+\n+    private final Type type;\n+    private final ImmutableList<QualifiedColumnReferenceExp> originalAvailableKeyColumns;\n+    private final ImmutableList<? extends ColumnReferenceExp> availableKeyColumns;\n+    private final BinaryOperator<LogicalSchema> schemaSelector;\n+\n+    static NonSyntheticJoinKey left(\n+        final Collection<QualifiedColumnReferenceExp> availableKeyColumns\n+    ) {\n+      return new NonSyntheticJoinKey(\n+          Type.LEFT, availableKeyColumns, availableKeyColumns, (left, right) -> left);\n+    }\n+\n+    static NonSyntheticJoinKey right(\n+        final Collection<QualifiedColumnReferenceExp> availableKeyColumns\n+    ) {\n+      return new NonSyntheticJoinKey(\n+          Type.RIGHT, availableKeyColumns, availableKeyColumns, (left, right) -> right);\n+    }\n+\n+    private NonSyntheticJoinKey(\n+        final Type type,\n+        final Collection<QualifiedColumnReferenceExp> originalAvailableKeyColumns,\n+        final Collection<? extends ColumnReferenceExp> availableKeyColumns,\n+        final BinaryOperator<LogicalSchema> schemaSelector\n+    ) {\n+      this.type = requireNonNull(type, \"type\");\n+      this.originalAvailableKeyColumns = ImmutableList.copyOf(originalAvailableKeyColumns);\n+      this.availableKeyColumns = ImmutableList.copyOf(availableKeyColumns);\n+      this.schemaSelector = requireNonNull(schemaSelector, \"schemaSelector\");\n+    }\n+\n+    @Override\n+    public Type getType() {\n+      return type;\n+    }\n+\n+    @Override\n+    public List<? extends Expression> getAvailableKeys() {\n+      return availableKeyColumns;\n+    }\n+\n+    @Override\n+    public List<? extends Expression> getOriginalAvailableKeys() {\n+      return originalAvailableKeyColumns;\n+    }\n+\n+    @Override\n+    public ColumnName resolveKeyName(final LogicalSchema left, final LogicalSchema right) {\n+      final LogicalSchema schema = schemaSelector.apply(left, right);\n+      return Iterables.getOnlyElement(schema.key()).name();\n+    }\n+\n+    @Override\n+    public JoinKey rewriteWith(\n+        final BiFunction<Expression, Context<Void>, Optional<Expression>> plugin\n+    ) {\n+      final List<? extends ColumnReferenceExp> rewritten = availableKeyColumns.stream()\n+          .map(e -> ExpressionTreeRewriter.rewriteWith(plugin, e))\n+          .collect(Collectors.toList());\n+\n+      return new NonSyntheticJoinKey(type, originalAvailableKeyColumns, rewritten, schemaSelector);\n+    }\n+  }\n+\n+  public static final class SyntheticJoinKey implements JoinKey {\n+\n+    private final FunctionCall originalJoinKeyUdf;\n+    private final FunctionCall joinKeyUdf;\n+\n+    static JoinKey of(final Expression leftJoinExp, final Expression rightJoinExp) {\n+      final FunctionCall udf = new FunctionCall(\n+          JoinKeyUdf.NAME,\n+          ImmutableList.of(leftJoinExp, rightJoinExp)\n+      );\n+\n+      return new SyntheticJoinKey(udf, udf);\n+    }\n+\n+    private SyntheticJoinKey(final FunctionCall originalJoinKeyUdf, final FunctionCall joinKeyUdf) {\n+      this.originalJoinKeyUdf = requireNonNull(originalJoinKeyUdf, \"originalJoinKeyUdf\");\n+      this.joinKeyUdf = requireNonNull(joinKeyUdf, \"joinKeyUdf\");\n+    }\n+\n+    @Override\n+    public Type getType() {\n+      return Type.SYNTHETIC;\n+    }\n+\n+    @Override\n+    public List<? extends Expression> getAvailableKeys() {\n+      return ImmutableList.of(joinKeyUdf);\n+    }\n+\n+    @Override\n+    public List<? extends Expression> getOriginalAvailableKeys() {\n+      return ImmutableList.of(originalJoinKeyUdf);\n+    }\n+\n+    @Override\n+    public ColumnName resolveKeyName(final LogicalSchema left, final LogicalSchema right) {\n+      return ColumnNames\n+          .columnAliasGenerator(Stream.of(left, right))\n+          .nextKsqlColAlias();\n+    }\n+\n+    @Override\n+    public Expression resolveSelect(\n+        final Expression expression,\n+        final LogicalSchema schema\n+    ) {\n+      return joinKeyUdf.equals(expression)", "originalCommit": "630725c25d4e922ceb2ce20858b903f1c1025dfc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDAzODM1MA==", "url": "https://github.com/confluentinc/ksql/pull/5257#discussion_r420038350", "bodyText": "Yeah, we currently require it to be JOINKEY(A.id, C.foo), and fail if its not.  I'd of preferred to not require any parameters, but then figuring out types becomes tricky without a lot more magic.\nThere's already a test for this... let me find it....\nHumm.. so there is a test in joinkey.json for the wrong params: with wrong join key parameters, but not a the multi-join version.\nAdded unsupported joinkey parameters to multi-joins.json to cover this.", "author": "big-andy-coates", "createdAt": "2020-05-05T11:27:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc5MTgwOQ=="}], "type": "inlineReview"}, {"oid": "4104a0c0ec58d1a6a387a093dcc077fdd0e669b4", "url": "https://github.com/confluentinc/ksql/commit/4104a0c0ec58d1a6a387a093dcc077fdd0e669b4", "message": "chore: changes requested by Almog", "committedDate": "2020-05-05T13:17:15Z", "type": "commit"}, {"oid": "77ce10b003c8abc3656467e90b6463e3d31c2db6", "url": "https://github.com/confluentinc/ksql/commit/77ce10b003c8abc3656467e90b6463e3d31c2db6", "message": "test: jointree test update", "committedDate": "2020-05-05T13:28:31Z", "type": "commit"}, {"oid": "77844dcc19308ecee61b9b8aca643fd63e0bb81a", "url": "https://github.com/confluentinc/ksql/commit/77844dcc19308ecee61b9b8aca643fd63e0bb81a", "message": "test: jointree test update", "committedDate": "2020-05-05T13:33:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5NjExMw==", "url": "https://github.com/confluentinc/ksql/pull/5257#discussion_r420296113", "bodyText": "can jackson discover private constructors? clearly the tests pass, but I'm surprised", "author": "agavra", "createdAt": "2020-05-05T17:50:10Z", "path": "ksqldb-execution/src/main/java/io/confluent/ksql/execution/plan/StreamStreamJoin.java", "diffHunk": "@@ -14,45 +14,86 @@\n \n package io.confluent.ksql.execution.plan;\n \n+import static java.util.Objects.requireNonNull;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n import com.fasterxml.jackson.annotation.JsonIgnore;\n import com.fasterxml.jackson.annotation.JsonProperty;\n import com.google.common.collect.ImmutableList;\n import com.google.errorprone.annotations.Immutable;\n+import io.confluent.ksql.name.ColumnName;\n import java.time.Duration;\n import java.util.List;\n import java.util.Objects;\n+import java.util.Optional;\n \n @Immutable\n public class StreamStreamJoin<K> implements ExecutionStep<KStreamHolder<K>> {\n \n+  // keyName was not present before 0.10.0, defaults to legacy ROWKEY\n+  // This can be removed with the next breaking change.\n+  public static final String LEGACY_KEY_COL = \"ROWKEY\";\n+\n   private final ExecutionStepPropertiesV1 properties;\n   private final JoinType joinType;\n+  private final ColumnName keyColName;\n   private final Formats leftInternalFormats;\n   private final Formats rightInternalFormats;\n   private final ExecutionStep<KStreamHolder<K>> leftSource;\n   private final ExecutionStep<KStreamHolder<K>> rightSource;\n   private final Duration beforeMillis;\n   private final Duration afterMillis;\n \n-  public StreamStreamJoin(\n+  @SuppressWarnings(\"unused\") // Invoked by reflection\n+  @JsonCreator\n+  @Deprecated() // Can be removed at next incompatible version\n+  private StreamStreamJoin(", "originalCommit": "77844dcc19308ecee61b9b8aca643fd63e0bb81a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYzNjczMw==", "url": "https://github.com/confluentinc/ksql/pull/5257#discussion_r420636733", "bodyText": "Yeah, Jackson can access private constructors, methods and even fields directly.", "author": "big-andy-coates", "createdAt": "2020-05-06T08:50:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5NjExMw=="}], "type": "inlineReview"}]}