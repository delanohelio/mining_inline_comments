{"pr_number": 5023, "pr_title": "fix: Improve error message for where/having type errors", "pr_createdAt": "2020-04-08T00:42:51Z", "pr_url": "https://github.com/confluentinc/ksql/pull/5023", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjEwMjg0NQ==", "url": "https://github.com/confluentinc/ksql/pull/5023#discussion_r406102845", "bodyText": "Let's move this validation to LogicalPlanner.buildFilterNode, as that doesn't need to worry about multiple sources etc. So we're making the problem simpler by moving the validation there.", "author": "big-andy-coates", "createdAt": "2020-04-09T10:15:24Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/Analyzer.java", "diffHunk": "@@ -486,6 +486,11 @@ protected AstNode visitSelect(final Select node, final Void context) {\n \n     private void analyzeWhere(final Expression node) {\n       analysis.setWhereExpression(node);\n+\n+      final WhereTypeValidator validator = new WhereTypeValidator(\n+          analysis.getFromSourceSchemas(false),\n+          metaStore);\n+      validator.validateWhereExpression(node);", "originalCommit": "c6752df98b0f65cddfab2069f5aedc30b9d0fa33", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ2NDI5NQ==", "url": "https://github.com/confluentinc/ksql/pull/5023#discussion_r406464295", "bodyText": "Done.", "author": "AlanConfluent", "createdAt": "2020-04-09T20:40:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjEwMjg0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU0NDU4NQ==", "url": "https://github.com/confluentinc/ksql/pull/5023#discussion_r406544585", "bodyText": "nit: error message like \"Error evaluating type for \"  + filterType.name() + \" expression\" would be more accurate", "author": "rodesai", "createdAt": "2020-04-10T00:21:31Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/FilterTypeValidator.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.analyzer;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import io.confluent.ksql.execution.expression.tree.ComparisonExpression;\n+import io.confluent.ksql.execution.expression.tree.Expression;\n+import io.confluent.ksql.execution.expression.tree.LogicalBinaryExpression;\n+import io.confluent.ksql.execution.expression.tree.VisitParentExpressionVisitor;\n+import io.confluent.ksql.execution.util.ComparisonUtil;\n+import io.confluent.ksql.execution.util.ExpressionTypeManager;\n+import io.confluent.ksql.function.FunctionRegistry;\n+import io.confluent.ksql.schema.ksql.FormatOptions;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.types.SqlType;\n+import io.confluent.ksql.schema.ksql.types.SqlTypes;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+\n+/**\n+ * Validates types used in filtering statements.\n+ */\n+public final class FilterTypeValidator {\n+\n+  private final LogicalSchema schema;\n+  private final FunctionRegistry functionRegistry;\n+  private final FilterType filterType;\n+\n+  public FilterTypeValidator(\n+      final LogicalSchema schema,\n+      final FunctionRegistry functionRegistry,\n+      final FilterType filterType\n+  ) {\n+    this.schema = requireNonNull(schema, \"schema\");\n+    this.functionRegistry = requireNonNull(functionRegistry, \"functionRegistry\");\n+    this.filterType = requireNonNull(filterType, \"filterType\");\n+  }\n+\n+  /**\n+   * Validates the given filter expression.\n+   */\n+  public void validateFilterExpression(final Expression exp) {\n+    // Construct an expression type manager to be used when checking types.\n+    final ExpressionTypeManager expressionTypeManager = new ExpressionTypeManager(schema,\n+        functionRegistry);\n+\n+    // Traverse the AST and throw errors if necessary\n+    final TypeChecker typeChecker = new TypeChecker(filterType, expressionTypeManager);\n+    typeChecker.process(exp, null);\n+  }\n+\n+  /**\n+   * Does the actual type checking, ensuring that the where expression uses the proper types and\n+   * then giving a decent error message if there's an issue.\n+   */\n+  private static final class TypeChecker extends VisitParentExpressionVisitor<Void, Object> {\n+\n+    private final FilterType filterType;\n+    private final ExpressionTypeManager expressionTypeManager;\n+\n+    TypeChecker(final FilterType filterType, final ExpressionTypeManager expressionTypeManager) {\n+      this.filterType = filterType;\n+      this.expressionTypeManager = expressionTypeManager;\n+    }\n+\n+    public Void visitExpression(final Expression exp, final Object context) {\n+      final SqlType type;\n+      try {\n+        type = expressionTypeManager.getExpressionSqlType(exp);\n+      } catch (KsqlException e) {\n+        throw new KsqlStatementException(\"Error in \" + filterType.name() + \" expression: \" +", "originalCommit": "3766f35bddac286b0138058b5b393078ec9609a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk1NjMzMA==", "url": "https://github.com/confluentinc/ksql/pull/5023#discussion_r406956330", "bodyText": "I agree that technically you're right that would be more accurate.  The issue is that some type checks are already done at the expressionTypeManager, and I'm to a degree building on that.", "author": "AlanConfluent", "createdAt": "2020-04-10T21:42:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU0NDU4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU1MDg2MA==", "url": "https://github.com/confluentinc/ksql/pull/5023#discussion_r406550860", "bodyText": "This feels like something we should check at a higher level. There's lots of expressions where it would make sense to check that the operands have compatible types. For example:\n\nNotExpression should have a binary operand\nArithmeticBinary/Unary should have arithmetic operands\n\nOne option would be to move this in to ExpressionTypeManager. Then this class can be much simpler - it just needs to resolve the expression type and throw if its non-boolean.", "author": "rodesai", "createdAt": "2020-04-10T00:47:44Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/FilterTypeValidator.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.analyzer;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import io.confluent.ksql.execution.expression.tree.ComparisonExpression;\n+import io.confluent.ksql.execution.expression.tree.Expression;\n+import io.confluent.ksql.execution.expression.tree.LogicalBinaryExpression;\n+import io.confluent.ksql.execution.expression.tree.VisitParentExpressionVisitor;\n+import io.confluent.ksql.execution.util.ComparisonUtil;\n+import io.confluent.ksql.execution.util.ExpressionTypeManager;\n+import io.confluent.ksql.function.FunctionRegistry;\n+import io.confluent.ksql.schema.ksql.FormatOptions;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.types.SqlType;\n+import io.confluent.ksql.schema.ksql.types.SqlTypes;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+\n+/**\n+ * Validates types used in filtering statements.\n+ */\n+public final class FilterTypeValidator {\n+\n+  private final LogicalSchema schema;\n+  private final FunctionRegistry functionRegistry;\n+  private final FilterType filterType;\n+\n+  public FilterTypeValidator(\n+      final LogicalSchema schema,\n+      final FunctionRegistry functionRegistry,\n+      final FilterType filterType\n+  ) {\n+    this.schema = requireNonNull(schema, \"schema\");\n+    this.functionRegistry = requireNonNull(functionRegistry, \"functionRegistry\");\n+    this.filterType = requireNonNull(filterType, \"filterType\");\n+  }\n+\n+  /**\n+   * Validates the given filter expression.\n+   */\n+  public void validateFilterExpression(final Expression exp) {\n+    // Construct an expression type manager to be used when checking types.\n+    final ExpressionTypeManager expressionTypeManager = new ExpressionTypeManager(schema,\n+        functionRegistry);\n+\n+    // Traverse the AST and throw errors if necessary\n+    final TypeChecker typeChecker = new TypeChecker(filterType, expressionTypeManager);\n+    typeChecker.process(exp, null);\n+  }\n+\n+  /**\n+   * Does the actual type checking, ensuring that the where expression uses the proper types and\n+   * then giving a decent error message if there's an issue.\n+   */\n+  private static final class TypeChecker extends VisitParentExpressionVisitor<Void, Object> {\n+\n+    private final FilterType filterType;\n+    private final ExpressionTypeManager expressionTypeManager;\n+\n+    TypeChecker(final FilterType filterType, final ExpressionTypeManager expressionTypeManager) {\n+      this.filterType = filterType;\n+      this.expressionTypeManager = expressionTypeManager;\n+    }\n+\n+    public Void visitExpression(final Expression exp, final Object context) {\n+      final SqlType type;\n+      try {\n+        type = expressionTypeManager.getExpressionSqlType(exp);\n+      } catch (KsqlException e) {\n+        throw new KsqlStatementException(\"Error in \" + filterType.name() + \" expression: \" +\n+            e.getMessage(), exp.toString());\n+      }\n+      if (!SqlTypes.BOOLEAN.equals(type)) {\n+        throw new KsqlStatementException(\"Type error in \" + filterType.name() + \" expression: \"\n+            + \"Should evaluate to boolean but is \" + exp.toString()\n+            + \" (\" + type.toString(FormatOptions.none()) + \") instead.\",\n+            exp.toString());\n+      }\n+      return null;\n+    }\n+\n+    @Override\n+    public Void visitComparisonExpression(\n+        final ComparisonExpression exp,\n+        final Object context\n+    ) {\n+      final SqlType leftType;\n+      final SqlType rightType;\n+      try {\n+        leftType = expressionTypeManager.getExpressionSqlType(exp.getLeft());\n+        rightType = expressionTypeManager.getExpressionSqlType(exp.getRight());\n+      } catch (KsqlException e) {\n+        throw new KsqlStatementException(\"Error in \" + filterType.name() + \" expression: \" +\n+            e.getMessage(), exp.toString());\n+      }\n+      if (!ComparisonUtil.isValidComparison(leftType, exp.getType(), rightType)) {", "originalCommit": "3766f35bddac286b0138058b5b393078ec9609a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk1NjY2MQ==", "url": "https://github.com/confluentinc/ksql/pull/5023#discussion_r406956661", "bodyText": "Yeah, that's what I mentioned earlier in the review.  I agree with that.  I'll try to push this down further and have just the one check here.", "author": "AlanConfluent", "createdAt": "2020-04-10T21:44:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU1MDg2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk3MzE3NQ==", "url": "https://github.com/confluentinc/ksql/pull/5023#discussion_r406973175", "bodyText": "I don't think you need this class anymore. You can just call visitExpression directly from validateFilterExpression (or inline it). So something like :\npublic void validateFilterExpression(final Expression exp) {\n    // Construct an expression type manager to be used when checking types.\n    final ExpressionTypeManager expressionTypeManager = new ExpressionTypeManager(schema,\n        functionRegistry);\n\n    // Rewrite the expression with magic timestamps, so type checking can pass\n    final Expression magicTimestampRewrite =\n        new StatementRewriteForMagicPseudoTimestamp().rewrite(exp);\n\n    final SqlType type;\n    try {\n        type = expressionTypeManager.getExpressionSqlType(magicTimestampRewrite);\n    } catch (KsqlStatementException e) {\n        throw new KsqlStatementException(\"Error in \" + filterType.name() + \" expression: \" +\n            e.getRawMessage(), e.getSqlStatement());\n    } catch (KsqlException e) {\n        throw new KsqlStatementException(\"Error in \" + filterType.name() + \" expression: \" +\n            e.getMessage(), exp.toString());\n    }\n    if (!SqlTypes.BOOLEAN.equals(type)) {\n        throw new KsqlStatementException(\"Type error in \" + filterType.name() + \" expression: \"\n            + \"Should evaluate to boolean but is \" + exp.toString()\n            + \" (\" + type.toString(FormatOptions.none()) + \") instead.\",\n            exp.toString());\n    }\n}", "author": "rodesai", "createdAt": "2020-04-10T22:47:34Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/FilterTypeValidator.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.analyzer;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import io.confluent.ksql.engine.rewrite.StatementRewriteForMagicPseudoTimestamp;\n+import io.confluent.ksql.execution.expression.tree.Expression;\n+import io.confluent.ksql.execution.expression.tree.VisitParentExpressionVisitor;\n+import io.confluent.ksql.execution.util.ExpressionTypeManager;\n+import io.confluent.ksql.function.FunctionRegistry;\n+import io.confluent.ksql.schema.ksql.FormatOptions;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.types.SqlType;\n+import io.confluent.ksql.schema.ksql.types.SqlTypes;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+\n+/**\n+ * Validates types used in filtering statements.\n+ */\n+public final class FilterTypeValidator {\n+\n+  private final LogicalSchema schema;\n+  private final FunctionRegistry functionRegistry;\n+  private final FilterType filterType;\n+\n+  public FilterTypeValidator(\n+      final LogicalSchema schema,\n+      final FunctionRegistry functionRegistry,\n+      final FilterType filterType\n+  ) {\n+    this.schema = requireNonNull(schema, \"schema\");\n+    this.functionRegistry = requireNonNull(functionRegistry, \"functionRegistry\");\n+    this.filterType = requireNonNull(filterType, \"filterType\");\n+  }\n+\n+  /**\n+   * Validates the given filter expression.\n+   */\n+  public void validateFilterExpression(final Expression exp) {\n+    // Construct an expression type manager to be used when checking types.\n+    final ExpressionTypeManager expressionTypeManager = new ExpressionTypeManager(schema,\n+        functionRegistry);\n+\n+    // Rewrite the expression with magic timestamps, so type checking can pass\n+    final Expression magicTimestampRewrite =\n+        new StatementRewriteForMagicPseudoTimestamp().rewrite(exp);\n+\n+    // Traverse the AST and throw errors if necessary\n+    final TypeChecker typeChecker = new TypeChecker(filterType, expressionTypeManager);\n+    typeChecker.process(magicTimestampRewrite, null);\n+  }\n+\n+  /**\n+   * Does the actual type checking, ensuring that the where expression uses the proper types and\n+   * then giving a decent error message if there's an issue.\n+   */\n+  private static final class TypeChecker extends VisitParentExpressionVisitor<Void, Object> {", "originalCommit": "ce9619699379a1dce101247057f69b226b68dedd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk3Njk3NA==", "url": "https://github.com/confluentinc/ksql/pull/5023#discussion_r406976974", "bodyText": "Didn't notice that I simplified out the need for traversal entirely.  Removed and simplified to what you have above.", "author": "AlanConfluent", "createdAt": "2020-04-10T23:05:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk3MzE3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ2NDUzNA==", "url": "https://github.com/confluentinc/ksql/pull/5023#discussion_r408464534", "bodyText": "nit: do comments like this add any benefit?  Isn't this line basically saying \"I'm creating an instance of ExpressionTypeManager\"??", "author": "big-andy-coates", "createdAt": "2020-04-14T22:07:06Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/FilterTypeValidator.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.analyzer;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import io.confluent.ksql.engine.rewrite.StatementRewriteForMagicPseudoTimestamp;\n+import io.confluent.ksql.execution.expression.tree.Expression;\n+import io.confluent.ksql.execution.util.ExpressionTypeManager;\n+import io.confluent.ksql.function.FunctionRegistry;\n+import io.confluent.ksql.schema.ksql.FormatOptions;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.types.SqlType;\n+import io.confluent.ksql.schema.ksql.types.SqlTypes;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+\n+/**\n+ * Validates types used in filtering statements.\n+ */\n+public final class FilterTypeValidator {\n+\n+  private final LogicalSchema schema;\n+  private final FunctionRegistry functionRegistry;\n+  private final FilterType filterType;\n+\n+  public FilterTypeValidator(\n+      final LogicalSchema schema,\n+      final FunctionRegistry functionRegistry,\n+      final FilterType filterType\n+  ) {\n+    this.schema = requireNonNull(schema, \"schema\");\n+    this.functionRegistry = requireNonNull(functionRegistry, \"functionRegistry\");\n+    this.filterType = requireNonNull(filterType, \"filterType\");\n+  }\n+\n+  /**\n+   * Validates the given filter expression.\n+   */\n+  public void validateFilterExpression(final Expression exp) {\n+    // Construct an expression type manager to be used when checking types.", "originalCommit": "667e6e5a0034a3b3f2b48616139d2bac2a0d308c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ4ODM0Mw==", "url": "https://github.com/confluentinc/ksql/pull/5023#discussion_r408488343", "bodyText": "I agree, it doesn't add much.  When the ExpressionTypeManager was going to be used in a separate Visitor class, it made a bit more sense to explain the use, but then it got simplified to be immediately below, so it's pretty obvious.", "author": "AlanConfluent", "createdAt": "2020-04-14T23:11:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ2NDUzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ2NjMzOQ==", "url": "https://github.com/confluentinc/ksql/pull/5023#discussion_r408466339", "bodyText": "Suggestion:  when you find yourself writing code like this, i.e. where you have a try/catch block that sets a variable created outside the scope of the try/catch, then it's often a sign you could easily refactor the code by pulling the try/catch into a method, e.g.\npublic void validateFilterExpression(final Expression exp) {\n  final SqlType type = getExpressionReturnType(exp);\n  if (!SqlTypes.BOOLEAN.equals(type)) {\n     // throw... \n  }\n}\n\nprivate SqlType getExpressionReturnType(final Expression exp) {\n   final ExpressionTypeManager expressionTypeManager = \n      new ExpressionTypeManager(schema, functionRegistry);\n\n    final Expression magicTimestampRewrite =\n        new StatementRewriteForMagicPseudoTimestamp().rewrite(exp);\n\n    try {\n      return expressionTypeManager.getExpressionSqlType(magicTimestampRewrite);\n    } catch (KsqlStatementException e) {\n      throw new KsqlStatementException(\"Error in \" + filterType.name() + \" expression: \"\n          + e.getRawMessage(), e.getSqlStatement());\n    } catch (KsqlException e) {\n      throw new KsqlStatementException(\"Error in \" + filterType.name() + \" expression: \"\n          + e.getMessage(), exp.toString());\n    }\n}", "author": "big-andy-coates", "createdAt": "2020-04-14T22:11:20Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/FilterTypeValidator.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.analyzer;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import io.confluent.ksql.engine.rewrite.StatementRewriteForMagicPseudoTimestamp;\n+import io.confluent.ksql.execution.expression.tree.Expression;\n+import io.confluent.ksql.execution.util.ExpressionTypeManager;\n+import io.confluent.ksql.function.FunctionRegistry;\n+import io.confluent.ksql.schema.ksql.FormatOptions;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.types.SqlType;\n+import io.confluent.ksql.schema.ksql.types.SqlTypes;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+\n+/**\n+ * Validates types used in filtering statements.\n+ */\n+public final class FilterTypeValidator {\n+\n+  private final LogicalSchema schema;\n+  private final FunctionRegistry functionRegistry;\n+  private final FilterType filterType;\n+\n+  public FilterTypeValidator(\n+      final LogicalSchema schema,\n+      final FunctionRegistry functionRegistry,\n+      final FilterType filterType\n+  ) {\n+    this.schema = requireNonNull(schema, \"schema\");\n+    this.functionRegistry = requireNonNull(functionRegistry, \"functionRegistry\");\n+    this.filterType = requireNonNull(filterType, \"filterType\");\n+  }\n+\n+  /**\n+   * Validates the given filter expression.\n+   */\n+  public void validateFilterExpression(final Expression exp) {\n+    // Construct an expression type manager to be used when checking types.\n+    final ExpressionTypeManager expressionTypeManager = new ExpressionTypeManager(schema,\n+        functionRegistry);\n+\n+    // Rewrite the expression with magic timestamps, so type checking can pass\n+    final Expression magicTimestampRewrite =\n+        new StatementRewriteForMagicPseudoTimestamp().rewrite(exp);\n+\n+    final SqlType type;\n+    try {\n+      type = expressionTypeManager.getExpressionSqlType(magicTimestampRewrite);\n+    } catch (KsqlStatementException e) {\n+      throw new KsqlStatementException(\"Error in \" + filterType.name() + \" expression: \"\n+          + e.getRawMessage(), e.getSqlStatement());\n+    } catch (KsqlException e) {\n+      throw new KsqlStatementException(\"Error in \" + filterType.name() + \" expression: \"\n+          + e.getMessage(), exp.toString());\n+    }", "originalCommit": "667e6e5a0034a3b3f2b48616139d2bac2a0d308c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ5MDEzOQ==", "url": "https://github.com/confluentinc/ksql/pull/5023#discussion_r408490139", "bodyText": "Makes sense.  Refactored.", "author": "AlanConfluent", "createdAt": "2020-04-14T23:17:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ2NjMzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ2NzI3OA==", "url": "https://github.com/confluentinc/ksql/pull/5023#discussion_r408467278", "bodyText": "I don't think you need to worry about KsqlStatementException here.  Though I could be wrong.  Generally, the code lower down just throws KsqlException, as it doesn't have the whole SQL statement.  Higher up the call stack this is caught and converted to a KsqlStatementException.", "author": "big-andy-coates", "createdAt": "2020-04-14T22:13:29Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/FilterTypeValidator.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.analyzer;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import io.confluent.ksql.engine.rewrite.StatementRewriteForMagicPseudoTimestamp;\n+import io.confluent.ksql.execution.expression.tree.Expression;\n+import io.confluent.ksql.execution.util.ExpressionTypeManager;\n+import io.confluent.ksql.function.FunctionRegistry;\n+import io.confluent.ksql.schema.ksql.FormatOptions;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.types.SqlType;\n+import io.confluent.ksql.schema.ksql.types.SqlTypes;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+\n+/**\n+ * Validates types used in filtering statements.\n+ */\n+public final class FilterTypeValidator {\n+\n+  private final LogicalSchema schema;\n+  private final FunctionRegistry functionRegistry;\n+  private final FilterType filterType;\n+\n+  public FilterTypeValidator(\n+      final LogicalSchema schema,\n+      final FunctionRegistry functionRegistry,\n+      final FilterType filterType\n+  ) {\n+    this.schema = requireNonNull(schema, \"schema\");\n+    this.functionRegistry = requireNonNull(functionRegistry, \"functionRegistry\");\n+    this.filterType = requireNonNull(filterType, \"filterType\");\n+  }\n+\n+  /**\n+   * Validates the given filter expression.\n+   */\n+  public void validateFilterExpression(final Expression exp) {\n+    // Construct an expression type manager to be used when checking types.\n+    final ExpressionTypeManager expressionTypeManager = new ExpressionTypeManager(schema,\n+        functionRegistry);\n+\n+    // Rewrite the expression with magic timestamps, so type checking can pass\n+    final Expression magicTimestampRewrite =\n+        new StatementRewriteForMagicPseudoTimestamp().rewrite(exp);\n+\n+    final SqlType type;\n+    try {\n+      type = expressionTypeManager.getExpressionSqlType(magicTimestampRewrite);\n+    } catch (KsqlStatementException e) {\n+      throw new KsqlStatementException(\"Error in \" + filterType.name() + \" expression: \"\n+          + e.getRawMessage(), e.getSqlStatement());\n+    } catch (KsqlException e) {\n+      throw new KsqlStatementException(\"Error in \" + filterType.name() + \" expression: \"\n+          + e.getMessage(), exp.toString());\n+    }", "originalCommit": "667e6e5a0034a3b3f2b48616139d2bac2a0d308c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ5MTYxNg==", "url": "https://github.com/confluentinc/ksql/pull/5023#discussion_r408491616", "bodyText": "You're right.  I've removed the special handling there and only catch KsqlException now.", "author": "AlanConfluent", "createdAt": "2020-04-14T23:21:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ2NzI3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ2NzkxNA==", "url": "https://github.com/confluentinc/ksql/pull/5023#discussion_r408467914", "bodyText": "This is a misuse of KsqlStatementException.  It takes the full sql statement as its second parameter, not the snippet of the statement that causes the error.\nAs above, just throw KsqlException. Code higher up will handle the conversion to KsqlStatementException.", "author": "big-andy-coates", "createdAt": "2020-04-14T22:15:03Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/FilterTypeValidator.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.analyzer;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import io.confluent.ksql.engine.rewrite.StatementRewriteForMagicPseudoTimestamp;\n+import io.confluent.ksql.execution.expression.tree.Expression;\n+import io.confluent.ksql.execution.util.ExpressionTypeManager;\n+import io.confluent.ksql.function.FunctionRegistry;\n+import io.confluent.ksql.schema.ksql.FormatOptions;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.types.SqlType;\n+import io.confluent.ksql.schema.ksql.types.SqlTypes;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.KsqlStatementException;\n+\n+/**\n+ * Validates types used in filtering statements.\n+ */\n+public final class FilterTypeValidator {\n+\n+  private final LogicalSchema schema;\n+  private final FunctionRegistry functionRegistry;\n+  private final FilterType filterType;\n+\n+  public FilterTypeValidator(\n+      final LogicalSchema schema,\n+      final FunctionRegistry functionRegistry,\n+      final FilterType filterType\n+  ) {\n+    this.schema = requireNonNull(schema, \"schema\");\n+    this.functionRegistry = requireNonNull(functionRegistry, \"functionRegistry\");\n+    this.filterType = requireNonNull(filterType, \"filterType\");\n+  }\n+\n+  /**\n+   * Validates the given filter expression.\n+   */\n+  public void validateFilterExpression(final Expression exp) {\n+    // Construct an expression type manager to be used when checking types.\n+    final ExpressionTypeManager expressionTypeManager = new ExpressionTypeManager(schema,\n+        functionRegistry);\n+\n+    // Rewrite the expression with magic timestamps, so type checking can pass\n+    final Expression magicTimestampRewrite =\n+        new StatementRewriteForMagicPseudoTimestamp().rewrite(exp);\n+\n+    final SqlType type;\n+    try {\n+      type = expressionTypeManager.getExpressionSqlType(magicTimestampRewrite);\n+    } catch (KsqlStatementException e) {\n+      throw new KsqlStatementException(\"Error in \" + filterType.name() + \" expression: \"\n+          + e.getRawMessage(), e.getSqlStatement());\n+    } catch (KsqlException e) {\n+      throw new KsqlStatementException(\"Error in \" + filterType.name() + \" expression: \"\n+          + e.getMessage(), exp.toString());\n+    }\n+    if (!SqlTypes.BOOLEAN.equals(type)) {\n+      throw new KsqlStatementException(\"Type error in \" + filterType.name() + \" expression: \"\n+          + \"Should evaluate to boolean but is \" + exp.toString()\n+          + \" (\" + type.toString(FormatOptions.none()) + \") instead.\",\n+          exp.toString());\n+    }", "originalCommit": "667e6e5a0034a3b3f2b48616139d2bac2a0d308c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ5MTQ4NA==", "url": "https://github.com/confluentinc/ksql/pull/5023#discussion_r408491484", "bodyText": "I see.  That makes sense.  That's what I was thinking after reading the code a bit, but I was confused about previous suggestions.  Removed the references to KsqlStatementException.", "author": "AlanConfluent", "createdAt": "2020-04-14T23:21:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ2NzkxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ2ODI3MA==", "url": "https://github.com/confluentinc/ksql/pull/5023#discussion_r408468270", "bodyText": "I think you misunderstood what I was meaning when I was talking about factory classes.  No worries. But I don't think injecting this filterNodeFactory is actually used by any testing, and its not what I had in mind, so we can probably simplify the code by removing it and just calling the function directly.", "author": "big-andy-coates", "createdAt": "2020-04-14T22:15:58Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/LogicalPlanner.java", "diffHunk": "@@ -84,26 +86,38 @@\n   private final RewrittenAnalysis analysis;\n   private final FunctionRegistry functionRegistry;\n   private final AggregateAnalyzer aggregateAnalyzer;\n+  private final BiFunction<PlanNode, Expression, FilterNode> filterNodeFactory;\n   private final ColumnReferenceRewriter refRewriter;\n \n   public LogicalPlanner(\n       final KsqlConfig ksqlConfig,\n       final ImmutableAnalysis analysis,\n-      final FunctionRegistry functionRegistry\n+      final FunctionRegistry functionRegistry,\n+      final BiFunction<PlanNode, Expression, FilterNode> filterNodeFactory", "originalCommit": "667e6e5a0034a3b3f2b48616139d2bac2a0d308c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ5MjY0MQ==", "url": "https://github.com/confluentinc/ksql/pull/5023#discussion_r408492641", "bodyText": "Yeah, it's not used directly.  LogicalPlannerTest doesn't seem to introduce any mocks, which is maybe the type of test you have in mind.\nI'll remove it for now and let a future test do that refactoring.", "author": "AlanConfluent", "createdAt": "2020-04-14T23:24:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ2ODI3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3MDI0Nw==", "url": "https://github.com/confluentinc/ksql/pull/5023#discussion_r408470247", "bodyText": "As above, let's remove this for now.", "author": "big-andy-coates", "createdAt": "2020-04-14T22:20:58Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/FilterNode.java", "diffHunk": "@@ -81,4 +82,11 @@ protected int getPartitions(final KafkaTopicClient kafkaTopicClient) {\n             contextStacker\n         );\n   }\n+\n+  public interface FilterNodeFactory {\n+    FilterNode create(\n+        FunctionRegistry functionRegistry,\n+        PlanNode sourcePlanNode,\n+        Expression filterExpression);\n+  }", "originalCommit": "667e6e5a0034a3b3f2b48616139d2bac2a0d308c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ5MzE3Nw==", "url": "https://github.com/confluentinc/ksql/pull/5023#discussion_r408493177", "bodyText": "Removed.", "author": "AlanConfluent", "createdAt": "2020-04-14T23:26:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3MDI0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3MDQzNQ==", "url": "https://github.com/confluentinc/ksql/pull/5023#discussion_r408470435", "bodyText": "ExpectedException is deprecated - use assertThrows instead. (You can search the code base for exampels)", "author": "big-andy-coates", "createdAt": "2020-04-14T22:21:33Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/analyzer/FilterTypeValidatorTest.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+\n+package io.confluent.ksql.analyzer;\n+\n+import static io.confluent.ksql.schema.ksql.Column.Namespace.VALUE;\n+import static io.confluent.ksql.schema.ksql.types.SqlTypes.INTEGER;\n+import static io.confluent.ksql.schema.ksql.types.SqlTypes.STRING;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.when;\n+\n+import io.confluent.ksql.analyzer.FilterTypeValidator.FilterType;\n+import io.confluent.ksql.execution.expression.tree.ComparisonExpression;\n+import io.confluent.ksql.execution.expression.tree.ComparisonExpression.Type;\n+import io.confluent.ksql.execution.expression.tree.Expression;\n+import io.confluent.ksql.execution.expression.tree.IntegerLiteral;\n+import io.confluent.ksql.execution.expression.tree.LogicalBinaryExpression;\n+import io.confluent.ksql.execution.expression.tree.StringLiteral;\n+import io.confluent.ksql.execution.expression.tree.UnqualifiedColumnReferenceExp;\n+import io.confluent.ksql.function.FunctionRegistry;\n+import io.confluent.ksql.name.ColumnName;\n+import io.confluent.ksql.schema.ksql.Column;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.util.KsqlException;\n+import java.util.Optional;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class FilterTypeValidatorTest {\n+  private static final ColumnName COLUMN1 = ColumnName.of(\"col1\");\n+  private static final ColumnName COLUMN2 = ColumnName.of(\"col2\");\n+\n+  @Rule\n+  public final ExpectedException expectedException = ExpectedException.none();", "originalCommit": "667e6e5a0034a3b3f2b48616139d2bac2a0d308c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ5NTI4OA==", "url": "https://github.com/confluentinc/ksql/pull/5023#discussion_r408495288", "bodyText": "Done", "author": "AlanConfluent", "createdAt": "2020-04-14T23:33:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3MDQzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3MTU3Ng==", "url": "https://github.com/confluentinc/ksql/pull/5023#discussion_r408471576", "bodyText": "Another misuse of KsqlStatementException - just throw KsqlException.", "author": "big-andy-coates", "createdAt": "2020-04-14T22:24:24Z", "path": "ksqldb-execution/src/main/java/io/confluent/ksql/execution/util/ExpressionTypeManager.java", "diffHunk": "@@ -164,7 +165,13 @@ public Void visitComparisonExpression(\n       final SqlType leftSchema = expressionTypeContext.getSqlType();\n       process(node.getRight(), expressionTypeContext);\n       final SqlType rightSchema = expressionTypeContext.getSqlType();\n-      ComparisonUtil.isValidComparison(leftSchema, node.getType(), rightSchema);\n+      if (!ComparisonUtil.isValidComparison(leftSchema, node.getType(), rightSchema)) {\n+        throw new KsqlStatementException(\"Cannot compare \"\n+            + node.getLeft().toString() + \" (\" + leftSchema.toString() + \") to \"\n+            + node.getRight().toString() + \" (\" + rightSchema.toString() + \") \"\n+            + \"with \" + node.getType() + \".\",\n+            node.toString());", "originalCommit": "667e6e5a0034a3b3f2b48616139d2bac2a0d308c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ5OTU3Ng==", "url": "https://github.com/confluentinc/ksql/pull/5023#discussion_r408499576", "bodyText": "Done.", "author": "AlanConfluent", "createdAt": "2020-04-14T23:46:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3MTU3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3MTcwNg==", "url": "https://github.com/confluentinc/ksql/pull/5023#discussion_r408471706", "bodyText": "I think this can be package private again now.", "author": "big-andy-coates", "createdAt": "2020-04-14T22:24:47Z", "path": "ksqldb-execution/src/main/java/io/confluent/ksql/execution/util/ComparisonUtil.java", "diffHunk": "@@ -27,7 +27,7 @@\n import java.util.function.BiPredicate;\n import java.util.function.Predicate;\n \n-final class ComparisonUtil {\n+public final class ComparisonUtil {", "originalCommit": "667e6e5a0034a3b3f2b48616139d2bac2a0d308c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ5OTE5MQ==", "url": "https://github.com/confluentinc/ksql/pull/5023#discussion_r408499191", "bodyText": "Done", "author": "AlanConfluent", "createdAt": "2020-04-14T23:45:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3MTcwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3MjA3MA==", "url": "https://github.com/confluentinc/ksql/pull/5023#discussion_r408472070", "bodyText": "This method appears to only be called from tests.... so should probably be deleted, and the tests changed to check the return value of isValidComparison", "author": "big-andy-coates", "createdAt": "2020-04-14T22:25:44Z", "path": "ksqldb-execution/src/main/java/io/confluent/ksql/execution/util/ComparisonUtil.java", "diffHunk": "@@ -38,25 +38,31 @@\n   private ComparisonUtil() {\n   }\n \n-  static void isValidComparison(\n+  public static void assertValidComparison(", "originalCommit": "667e6e5a0034a3b3f2b48616139d2bac2a0d308c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ5OTE2Mw==", "url": "https://github.com/confluentinc/ksql/pull/5023#discussion_r408499163", "bodyText": "Done.", "author": "AlanConfluent", "createdAt": "2020-04-14T23:45:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3MjA3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3MjY3Ng==", "url": "https://github.com/confluentinc/ksql/pull/5023#discussion_r408472676", "bodyText": "I take it these have changed before they were invalid otherwise?", "author": "big-andy-coates", "createdAt": "2020-04-14T22:27:09Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/planner/LogicalPlannerTest.java", "diffHunk": "@@ -114,7 +114,7 @@ public void testSimpleLeftJoinFilterLogicalPlan() {\n     final String\n         simpleQuery =\n         \"SELECT t1.col1, t2.col1, col5, t2.col4, t2.col2 FROM test1 t1 LEFT JOIN test2 t2 ON \"\n-        + \"t1.col0 = t2.col0 WHERE t1.col1 > 10 AND t2.col4 = 10.8 EMIT CHANGES;\";\n+        + \"t1.col0 = t2.col0 WHERE t1.col3 > 10.8 AND t2.col2 = 'foo' EMIT CHANGES;\";", "originalCommit": "667e6e5a0034a3b3f2b48616139d2bac2a0d308c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ5NTYxOA==", "url": "https://github.com/confluentinc/ksql/pull/5023#discussion_r408495618", "bodyText": "Yeah, the comparisons were invalid before and throw errors.  I just picked different fields to prevent errors.", "author": "AlanConfluent", "createdAt": "2020-04-14T23:34:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3MjY3Ng=="}], "type": "inlineReview"}, {"oid": "c2b65ad80a1bd88a7c6b780a916e60266a7b2367", "url": "https://github.com/confluentinc/ksql/commit/c2b65ad80a1bd88a7c6b780a916e60266a7b2367", "message": "fix: Improve error message for where type errors", "committedDate": "2020-04-15T15:58:49Z", "type": "commit"}, {"oid": "dbe6e881e7592d5ad04448e1b265e7419cd75dc8", "url": "https://github.com/confluentinc/ksql/commit/dbe6e881e7592d5ad04448e1b265e7419cd75dc8", "message": "Makes type checks work across sources, such as with a join", "committedDate": "2020-04-15T15:59:53Z", "type": "commit"}, {"oid": "f35c0b2cb9eb03e0695fb833214a56d167d97299", "url": "https://github.com/confluentinc/ksql/commit/f35c0b2cb9eb03e0695fb833214a56d167d97299", "message": "High level feedback", "committedDate": "2020-04-15T16:00:22Z", "type": "commit"}, {"oid": "939ea7a74fc282606a4bf71686a7e74047ed23e9", "url": "https://github.com/confluentinc/ksql/commit/939ea7a74fc282606a4bf71686a7e74047ed23e9", "message": "More feedback", "committedDate": "2020-04-15T16:00:23Z", "type": "commit"}, {"oid": "0266e2150e468c6a0bdd49240b774358b7a83ee0", "url": "https://github.com/confluentinc/ksql/commit/0266e2150e468c6a0bdd49240b774358b7a83ee0", "message": "Comment", "committedDate": "2020-04-15T16:00:23Z", "type": "commit"}, {"oid": "d59a39009bfca93e7589a3b4a2a52741695691dc", "url": "https://github.com/confluentinc/ksql/commit/d59a39009bfca93e7589a3b4a2a52741695691dc", "message": "Fixes magic rewrite error", "committedDate": "2020-04-15T16:00:23Z", "type": "commit"}, {"oid": "76630d05057a40b9f1d008058ace0fd1e67ba59a", "url": "https://github.com/confluentinc/ksql/commit/76630d05057a40b9f1d008058ace0fd1e67ba59a", "message": "Feedback to push changes to ExpressionTypeManager", "committedDate": "2020-04-15T16:00:23Z", "type": "commit"}, {"oid": "569fe9f8d51b19007f8bc977b40c8846c9ac380e", "url": "https://github.com/confluentinc/ksql/commit/569fe9f8d51b19007f8bc977b40c8846c9ac380e", "message": "More feedback", "committedDate": "2020-04-15T16:00:23Z", "type": "commit"}, {"oid": "8f8de7c178846f73e72c3e4114587dd640b96eb3", "url": "https://github.com/confluentinc/ksql/commit/8f8de7c178846f73e72c3e4114587dd640b96eb3", "message": "Moooooore feedback", "committedDate": "2020-04-15T16:00:23Z", "type": "commit"}, {"oid": "8f8de7c178846f73e72c3e4114587dd640b96eb3", "url": "https://github.com/confluentinc/ksql/commit/8f8de7c178846f73e72c3e4114587dd640b96eb3", "message": "Moooooore feedback", "committedDate": "2020-04-15T16:00:23Z", "type": "forcePushed"}, {"oid": "b46ffda184df2a9a58b6ac4837638c28e568197f", "url": "https://github.com/confluentinc/ksql/commit/b46ffda184df2a9a58b6ac4837638c28e568197f", "message": "Fixs a few test cases with updated error messages", "committedDate": "2020-04-15T16:35:28Z", "type": "commit"}]}