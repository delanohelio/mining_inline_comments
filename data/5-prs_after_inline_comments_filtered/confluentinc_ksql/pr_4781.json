{"pr_number": 4781, "pr_title": "Partition by prep", "pr_createdAt": "2020-03-16T17:56:07Z", "pr_url": "https://github.com/confluentinc/ksql/pull/4781", "timeline": [{"oid": "8d17dde25147b08474fc662252b957f82d007cb5", "url": "https://github.com/confluentinc/ksql/commit/8d17dde25147b08474fc662252b957f82d007cb5", "message": "refactor: projection expression handling\n\nPrep for https://github.com/confluentinc/ksql/issues/4749.\n\nThis commit changes the way the engine resolves '*' in a projection, e.g. `SELECT * FROM X;`.\n\nPreviously, the `Analyzer` was responsible for expanding the `*` into the set of columns of each source. However, this code was getting complicated and would be much more complicated once the key column can have any name, (https://github.com/confluentinc/ksql/issues/3536). The complexity comes about because the `Analyzer` would need to determine the presence of joins, group bys, partition bys, etc, which can effect how `*` is resolved.  This logic duplicates the logic in the `LogicalPlanner` and `PlanNode` sub-classes.\n\nWith this commit sees the logical plan and planner being responsible for resolving any `*` in the projection. This is achieved by asking the parent of the projection node to resolve the `*` into the set of columns. Parent node types that do not know how to resolve the `*`, e.g. `FilterNode`, forward requests to their parents. In this way, the resolution request ripples up the logical plan until it reaches a `DataSourceNode`, which can resolve the `*` into a list of columns. `JoinNode` knows how forward `*`, `left.*` and `right.*` appropriately.\n\nPreviously, the list of `SelectExpressions` was passed down from parent `PlanNode` to child, allowing some nodes to rewrite the expressions. For example, `FlatMapNode` would rewrite any expression involving a TableFunction to use the internal names like `KSQL_SYNTH_0`.\n\nWith this commit this is no longer necessary. Instead, when building a projection node the planner asks it's parent node to resolve any selects, allowing the parent to perform any rewrite.\n\nAt the moment, the planner is still responsible for much of this work. In the future, this logic may move into the plan itself. However, such a change would increase the complexity of this commit.", "committedDate": "2020-03-16T17:51:35Z", "type": "commit"}, {"oid": "b53fba882cbbb226a66081cbf258c1813fad81bb", "url": "https://github.com/confluentinc/ksql/commit/b53fba882cbbb226a66081cbf258c1813fad81bb", "message": "chore: historic plans", "committedDate": "2020-03-16T17:52:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIxMDcxMA==", "url": "https://github.com/confluentinc/ksql/pull/4781#discussion_r393210710", "bodyText": "Basically moved from QueryAnalyzer.", "author": "big-andy-coates", "createdAt": "2020-03-16T17:57:30Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/AggregateAnalyzer.java", "diffHunk": "@@ -15,47 +15,74 @@\n \n package io.confluent.ksql.analyzer;\n \n+import static java.util.Objects.requireNonNull;\n+\n import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Sets;\n+import com.google.common.collect.Sets.SetView;\n import io.confluent.ksql.execution.expression.tree.ColumnReferenceExp;\n import io.confluent.ksql.execution.expression.tree.Expression;\n import io.confluent.ksql.execution.expression.tree.FunctionCall;\n import io.confluent.ksql.execution.expression.tree.QualifiedColumnReferenceExp;\n import io.confluent.ksql.execution.expression.tree.TraversalExpressionVisitor;\n import io.confluent.ksql.execution.expression.tree.UnqualifiedColumnReferenceExp;\n+import io.confluent.ksql.execution.plan.SelectExpression;\n import io.confluent.ksql.function.FunctionRegistry;\n import io.confluent.ksql.name.FunctionName;\n import io.confluent.ksql.util.KsqlException;\n import io.confluent.ksql.util.SchemaUtil;\n import java.util.HashSet;\n-import java.util.Objects;\n+import java.util.List;\n+import java.util.Map;\n import java.util.Optional;\n import java.util.Set;\n import java.util.function.BiConsumer;\n+import java.util.stream.Collectors;\n \n-class AggregateAnalyzer {\n+public class AggregateAnalyzer {\n \n-  private final MutableAggregateAnalysis aggregateAnalysis;\n-  private final QualifiedColumnReferenceExp defaultArgument;\n   private final FunctionRegistry functionRegistry;\n-  private final boolean hasWindowExpression;\n \n-  AggregateAnalyzer(\n-      final MutableAggregateAnalysis aggregateAnalysis,\n-      final QualifiedColumnReferenceExp defaultArgument,\n-      final boolean hasWindowExpression,\n+  public AggregateAnalyzer(\n       final FunctionRegistry functionRegistry\n   ) {\n-    this.aggregateAnalysis = Objects.requireNonNull(aggregateAnalysis, \"aggregateAnalysis\");\n-    this.defaultArgument = Objects.requireNonNull(defaultArgument, \"defaultArgument\");\n-    this.functionRegistry = Objects.requireNonNull(functionRegistry, \"functionRegistry\");\n-    this.hasWindowExpression = hasWindowExpression;\n+    this.functionRegistry = requireNonNull(functionRegistry, \"functionRegistry\");\n   }\n \n-  void processSelect(final Expression expression) {\n+  public AggregateAnalysisResult analyze(\n+      final ImmutableAnalysis analysis,\n+      final List<SelectExpression> finalProjection\n+  ) {\n+    if (analysis.getGroupByExpressions().isEmpty()) {\n+      throw new IllegalArgumentException(\"Not an aggregate query\");\n+    }\n+\n+    final Context context = new Context(analysis);\n+\n+    finalProjection.stream()\n+        .map(SelectExpression::getExpression)\n+        .forEach(exp -> processSelect(exp, context));\n+\n+    analysis.getWhereExpression()\n+        .ifPresent(exp -> processWhere(exp, context));\n+\n+    analysis.getGroupByExpressions()\n+        .forEach(exp -> processGroupBy(exp, context));\n+\n+    analysis.getHavingExpression()\n+        .ifPresent(exp -> processHaving(exp, context));\n+\n+    enforceAggregateRules(context);\n+\n+    return context.aggregateAnalysis;\n+  }", "originalCommit": "b53fba882cbbb226a66081cbf258c1813fad81bb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIxMDk5OA==", "url": "https://github.com/confluentinc/ksql/pull/4781#discussion_r393210998", "bodyText": "Moved from QueryAnalyzer", "author": "big-andy-coates", "createdAt": "2020-03-16T17:58:01Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/AggregateAnalyzer.java", "diffHunk": "@@ -117,18 +150,91 @@ private void throwOnWindowBoundColumnIfWindowedAggregate(final ColumnReferenceEx\n     }\n   }\n \n+  private static void enforceAggregateRules(\n+      final Context context\n+  ) {\n+    if (context.aggregateAnalysis.getAggregateFunctions().isEmpty()) {\n+      throw new KsqlException(\n+          \"GROUP BY requires columns using aggregate functions in SELECT clause.\");\n+    }\n+\n+    final Set<Expression> groupByExprs = getGroupByExpressions(context.analysis);\n+\n+    final List<String> unmatchedSelects = context.aggregateAnalysis\n+        .getNonAggregateSelectExpressions()\n+        .entrySet()\n+        .stream()\n+        // Remove any that exactly match a group by expression:\n+        .filter(e -> !groupByExprs.contains(e.getKey()))\n+        // Remove any that are constants,\n+        // or expressions where all params exactly match a group by expression:\n+        .filter(e -> !Sets.difference(e.getValue(), groupByExprs).isEmpty())\n+        .map(Map.Entry::getKey)\n+        .map(Expression::toString)\n+        .sorted()\n+        .collect(Collectors.toList());\n+\n+    if (!unmatchedSelects.isEmpty()) {\n+      throw new KsqlException(\n+          \"Non-aggregate SELECT expression(s) not part of GROUP BY: \" + unmatchedSelects);\n+    }\n+\n+    final SetView<ColumnReferenceExp> unmatchedSelectsAgg = Sets\n+        .difference(context.aggregateAnalysis.getAggregateSelectFields(), groupByExprs);\n+    if (!unmatchedSelectsAgg.isEmpty()) {\n+      throw new KsqlException(\n+          \"Column used in aggregate SELECT expression(s) \"\n+              + \"outside of aggregate functions not part of GROUP BY: \" + unmatchedSelectsAgg);\n+    }\n+\n+    final Set<ColumnReferenceExp> havingColumns = context.aggregateAnalysis\n+        .getNonAggregateHavingFields().stream()\n+        .map(ref -> new UnqualifiedColumnReferenceExp(ref.getColumnName()))\n+        .collect(Collectors.toSet());\n+\n+    final Set<ColumnReferenceExp> havingOnly = Sets.difference(havingColumns, groupByExprs);\n+    if (!havingOnly.isEmpty()) {\n+      throw new KsqlException(\n+          \"Non-aggregate HAVING expression not part of GROUP BY: \" + havingOnly);\n+    }\n+  }", "originalCommit": "b53fba882cbbb226a66081cbf258c1813fad81bb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIxMTA1OA==", "url": "https://github.com/confluentinc/ksql/pull/4781#discussion_r393211058", "bodyText": "Moved from QueryAnalyzer", "author": "big-andy-coates", "createdAt": "2020-03-16T17:58:07Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/AggregateAnalyzer.java", "diffHunk": "@@ -117,18 +150,91 @@ private void throwOnWindowBoundColumnIfWindowedAggregate(final ColumnReferenceEx\n     }\n   }\n \n+  private static void enforceAggregateRules(\n+      final Context context\n+  ) {\n+    if (context.aggregateAnalysis.getAggregateFunctions().isEmpty()) {\n+      throw new KsqlException(\n+          \"GROUP BY requires columns using aggregate functions in SELECT clause.\");\n+    }\n+\n+    final Set<Expression> groupByExprs = getGroupByExpressions(context.analysis);\n+\n+    final List<String> unmatchedSelects = context.aggregateAnalysis\n+        .getNonAggregateSelectExpressions()\n+        .entrySet()\n+        .stream()\n+        // Remove any that exactly match a group by expression:\n+        .filter(e -> !groupByExprs.contains(e.getKey()))\n+        // Remove any that are constants,\n+        // or expressions where all params exactly match a group by expression:\n+        .filter(e -> !Sets.difference(e.getValue(), groupByExprs).isEmpty())\n+        .map(Map.Entry::getKey)\n+        .map(Expression::toString)\n+        .sorted()\n+        .collect(Collectors.toList());\n+\n+    if (!unmatchedSelects.isEmpty()) {\n+      throw new KsqlException(\n+          \"Non-aggregate SELECT expression(s) not part of GROUP BY: \" + unmatchedSelects);\n+    }\n+\n+    final SetView<ColumnReferenceExp> unmatchedSelectsAgg = Sets\n+        .difference(context.aggregateAnalysis.getAggregateSelectFields(), groupByExprs);\n+    if (!unmatchedSelectsAgg.isEmpty()) {\n+      throw new KsqlException(\n+          \"Column used in aggregate SELECT expression(s) \"\n+              + \"outside of aggregate functions not part of GROUP BY: \" + unmatchedSelectsAgg);\n+    }\n+\n+    final Set<ColumnReferenceExp> havingColumns = context.aggregateAnalysis\n+        .getNonAggregateHavingFields().stream()\n+        .map(ref -> new UnqualifiedColumnReferenceExp(ref.getColumnName()))\n+        .collect(Collectors.toSet());\n+\n+    final Set<ColumnReferenceExp> havingOnly = Sets.difference(havingColumns, groupByExprs);\n+    if (!havingOnly.isEmpty()) {\n+      throw new KsqlException(\n+          \"Non-aggregate HAVING expression not part of GROUP BY: \" + havingOnly);\n+    }\n+  }\n+\n+  private static Set<Expression> getGroupByExpressions(\n+      final ImmutableAnalysis analysis\n+  ) {\n+    if (!analysis.getWindowExpression().isPresent()) {\n+      return ImmutableSet.copyOf(analysis.getGroupByExpressions());\n+    }\n+\n+    // Add in window bounds columns as implicit group by columns:\n+    final Set<UnqualifiedColumnReferenceExp> windowBoundColumnRefs =\n+        SchemaUtil.windowBoundsColumnNames().stream()\n+            .map(UnqualifiedColumnReferenceExp::new)\n+            .collect(Collectors.toSet());\n+\n+    return ImmutableSet.<Expression>builder()\n+        .addAll(analysis.getGroupByExpressions())\n+        .addAll(windowBoundColumnRefs)\n+        .build();\n+  }", "originalCommit": "b53fba882cbbb226a66081cbf258c1813fad81bb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIxMTY3OA==", "url": "https://github.com/confluentinc/ksql/pull/4781#discussion_r393211678", "bodyText": "Previously, we captured the resolved select items - now we just capture the unresolved SelectItem", "author": "big-andy-coates", "createdAt": "2020-03-16T17:59:11Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/Analysis.java", "diffHunk": "@@ -89,8 +88,8 @@ ResultMaterialization getResultMaterialization() {\n     return resultMaterialization;\n   }\n \n-  void addSelectItem(final Expression expression, final ColumnName alias) {\n-    selectExpressions.add(SelectExpression.of(alias, expression));\n+  void addSelectItem(final SelectItem selectItem) {", "originalCommit": "b53fba882cbbb226a66081cbf258c1813fad81bb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIxMjYwMQ==", "url": "https://github.com/confluentinc/ksql/pull/4781#discussion_r393212601", "bodyText": "To set the serde options we need to know the number of columns, which requires any * to be resolved. Hence this code has now moved to later LogicalPlanner once any * has been resolved.", "author": "big-andy-coates", "createdAt": "2020-03-16T18:00:47Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/Analyzer.java", "diffHunk": "@@ -243,27 +218,6 @@ private KeyFormat buildKeyFormat() {\n               .getKeyFormat());\n     }\n \n-    private void setSerdeOptions(final Sink sink) {\n-      final List<ColumnName> columnNames = getColumnNames();\n-\n-      final Format valueFormat = getValueFormat(sink);\n-\n-      final Set<SerdeOption> serdeOptions = serdeOptionsSupplier.build(\n-          columnNames,\n-          valueFormat,\n-          sink.getProperties().getWrapSingleValues(),\n-          defaultSerdeOptions\n-      );\n-\n-      analysis.setSerdeOptions(serdeOptions);\n-    }", "originalCommit": "b53fba882cbbb226a66081cbf258c1813fad81bb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0d5efaafebab990b6a6578d0367150543d090c88", "url": "https://github.com/confluentinc/ksql/commit/0d5efaafebab990b6a6578d0367150543d090c88", "message": "chore: drop AggregateAnalysis", "committedDate": "2020-03-16T18:02:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIxNTI2MA==", "url": "https://github.com/confluentinc/ksql/pull/4781#discussion_r393215260", "bodyText": "Analysis of aggregates is now delayed until the creation of an AggregateNode in the LogicalPlanner.  This is necessary as this code needs any *s to have been resolved.", "author": "big-andy-coates", "createdAt": "2020-03-16T18:04:10Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/QueryAnalyzer.java", "diffHunk": "@@ -97,177 +78,4 @@ public Analysis analyze(\n \n     return analysis;\n   }\n-\n-  public AggregateAnalysis analyzeAggregate(final Query query, final Analysis analysis) {", "originalCommit": "b53fba882cbbb226a66081cbf258c1813fad81bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDAwMTQ3MQ==", "url": "https://github.com/confluentinc/ksql/pull/4781#discussion_r394001471", "bodyText": "Moving the analysis out of the analyzer seems less than ideal... I'm trying to wrap my head around what * means in the context of an aggregation. other than COUNT(*) and other aggregate functions that have the * as the argument - how can you even use * in an aggregate? If it doesn't make sense outside of function calls, can we leverage that to keep the analysis in the analyzer?", "author": "agavra", "createdAt": "2020-03-17T22:15:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIxNTI2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIyNjkwMg==", "url": "https://github.com/confluentinc/ksql/pull/4781#discussion_r394226902", "bodyText": "I think this is just a continuation of a trend Tim started with UDTFs.  Trying to extract everything up front in the analyzer, and then using this to build the logical plan, is probably not the best approach.  It often involves duplicating logic between the analyser and plan, and if we just delay the analysis till we're building the plan we can take advantage of being able to ask parent nodes for things, i.e. we can build something more object oriented and take advantage of polymorphism, rather than if statements.\nWith regards to the resolution of * for GROUP BY:  It's valid to have SELECT * FROM X GROUP BY ?,?,? just so long as the GROUP BY contains all the columns in the source.  There's a QTT test covering this somewhere.  But we don't know what columns exist in the source until we've built the plan: the source could be a join for example. Hence we now delay this analysis till later.", "author": "big-andy-coates", "createdAt": "2020-03-18T09:58:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIxNTI2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIxNjE4MQ==", "url": "https://github.com/confluentinc/ksql/pull/4781#discussion_r393216181", "bodyText": "Moved from Analyzer", "author": "big-andy-coates", "createdAt": "2020-03-16T18:05:20Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/DataSourceNode.java", "diffHunk": "@@ -124,6 +140,21 @@ private static LogicalSchema buildSchema(final DataSource dataSource) {\n         .withMetaAndKeyColsInValue(dataSource.getKsqlTopic().getKeyFormat().isWindowed());\n   }\n \n+  private static Stream<ColumnName> orderColumns(\n+      final List<Column> columns,\n+      final LogicalSchema schema\n+  ) {\n+    // When doing a `select *` system and key columns should be at the front of the column list\n+    // but are added at the back during processing for performance reasons.\n+    // Switch them around here:\n+    final Map<Boolean, List<Column>> partitioned = columns.stream().collect(Collectors\n+        .groupingBy(c -> SchemaUtil.isSystemColumn(c.name()) || schema.isKeyColumn(c.name())));\n+\n+    final List<Column> all = partitioned.get(true);\n+    all.addAll(partitioned.get(false));\n+    return all.stream().map(Column::name);\n+  }", "originalCommit": "b53fba882cbbb226a66081cbf258c1813fad81bb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIyMTA1OQ==", "url": "https://github.com/confluentinc/ksql/pull/4781#discussion_r393221059", "bodyText": "Found a bug in here when moving tests to QTT:  Comparisons to the NULL type result in SqlType of null, which caused an NPE in this method!\nUnfortunately, fixing it caused the complexity of this method to go over the checkstyle rule, so had to refactor.", "author": "big-andy-coates", "createdAt": "2020-03-16T18:11:29Z", "path": "ksqldb-execution/src/main/java/io/confluent/ksql/execution/util/ComparisonUtil.java", "diffHunk": "@@ -15,38 +15,104 @@\n \n package io.confluent.ksql.execution.util;\n \n+import static java.util.Objects.requireNonNull;\n+\n+import com.google.common.collect.ImmutableList;\n import io.confluent.ksql.execution.expression.tree.ComparisonExpression;\n+import io.confluent.ksql.execution.expression.tree.ComparisonExpression.Type;\n import io.confluent.ksql.schema.ksql.SqlBaseType;\n import io.confluent.ksql.schema.ksql.types.SqlType;\n import io.confluent.ksql.util.KsqlException;\n+import java.util.List;\n+import java.util.function.BiPredicate;\n+import java.util.function.Predicate;\n \n final class ComparisonUtil {\n \n-  private ComparisonUtil() {\n+  private static final List<Handler> HANDLERS = ImmutableList.<Handler>builder()\n+      .add(handler(SqlBaseType::isNumber, ComparisonUtil::handleNumber))\n+      .add(handler(SqlBaseType.STRING, ComparisonUtil::handleString))\n+      .add(handler(SqlBaseType.BOOLEAN, ComparisonUtil::handleBoolean))\n+      .build();\n \n+  private ComparisonUtil() {\n   }\n \n-  static boolean isValidComparison(\n+  static void isValidComparison(", "originalCommit": "b53fba882cbbb226a66081cbf258c1813fad81bb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIyMjkzOQ==", "url": "https://github.com/confluentinc/ksql/pull/4781#discussion_r393222939", "bodyText": "This actually means KSQL rejects any pull query that uses a mix of * and explicit column names in a pull query. Previously, depending on the order, the explicit columns were ignored or a weird error was returned.  At least now a meaningful error is returned.", "author": "big-andy-coates", "createdAt": "2020-03-16T18:14:49Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java", "diffHunk": "@@ -757,8 +763,15 @@ private static ComparisonTarget extractWhereClauseTarget(\n   }\n \n   private static boolean isSelectStar(final Select select) {\n-    final List<SelectItem> selects = select.getSelectItems();\n-    return selects.size() == 1 && selects.get(0) instanceof AllColumns;\n+    final boolean someStars = select.getSelectItems().stream()\n+        .anyMatch(s -> s instanceof AllColumns);\n+\n+    if (someStars && select.getSelectItems().size() != 1) {\n+      throw new KsqlException(\"Pull queries only support wildcards in the projects \"\n+          + \"if they are the only expression\");\n+    }", "originalCommit": "b53fba882cbbb226a66081cbf258c1813fad81bb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9566e591bd1d4e982c124e2780ac1ea50a9ed507", "url": "https://github.com/confluentinc/ksql/commit/9566e591bd1d4e982c124e2780ac1ea50a9ed507", "message": "chore: simplify ProjectNode.resolveSelectStar + unit tests plan nodes", "committedDate": "2020-03-17T11:08:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDAxMjA0Nw==", "url": "https://github.com/confluentinc/ksql/pull/4781#discussion_r394012047", "bodyText": "at what point do we change the names of the columns to prepend <SOURCE>_ and does it make sense to do it here instead? e.g.\nksql> CREATE STREAM s (id VARCHAR, val VARCHAR) WITH (kafka_topic='s', value_format='json', partitions=1);\nksql> CREATE TABLE t (id VARCHAR, val VARCHAR) with (kafka_topic='t', value_format='json', partitions=1, key='id');\nksql> CREATE STREAM j AS SELECT * FROM s LEFT JOIN t ON s.id = t.id;\nksql> SELECT * FROM J EMIT CHANGES;\n+-------+-------+-------+-------+-------+-------+-------+-------+-------+-------+\n|ROWTIME|ROWKEY |S_ROWTI|S_ROWKE|S_ID   |S_VAL  |T_ROWTI|T_ROWKE|T_ID   |T_VAL  |\n|       |       |ME     |Y      |       |       |ME     |Y      |       |       |\n+-------+-------+-------+-------+-------+-------+-------+-------+-------+-------+", "author": "agavra", "createdAt": "2020-03-17T22:40:07Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/JoinNode.java", "diffHunk": "@@ -111,6 +112,15 @@ protected int getPartitions(final KafkaTopicClient kafkaTopicClient) {\n     return right.getPartitions(kafkaTopicClient);\n   }\n \n+  @Override\n+  public Stream<ColumnName> resolveSelectStar(\n+      final Optional<SourceName> sourceName, final boolean valueOnly\n+  ) {\n+    return getSources().stream()\n+        .filter(s -> !sourceName.isPresent() || sourceName.equals(s.getSourceName()))\n+        .flatMap(s -> s.resolveSelectStar(sourceName, false));", "originalCommit": "8d17dde25147b08474fc662252b957f82d007cb5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIyODU1Ng==", "url": "https://github.com/confluentinc/ksql/pull/4781#discussion_r394228556", "bodyText": "@rodesai made a change to the LogicalPlanner to alias the join columns in a projection node, prior to the join node.  There's probably scope for cleaning some of that work up a little once the dust has settled from recent changes. However:\n1). I actually probably makes sense to handle the aliases in the rewriter the engine runs post-parse/pre-execute, rather than in this method.\n2) It's out of scope for this PR.", "author": "big-andy-coates", "createdAt": "2020-03-18T10:01:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDAxMjA0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDAxMjQ5Nw==", "url": "https://github.com/confluentinc/ksql/pull/4781#discussion_r394012497", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public Expression resolveSelect(final int idx, final Expression expression) {\n          \n          \n            \n              @Override\n          \n          \n            \n              public Expression resolveSelect(final int idx, final Expression expression) {", "author": "agavra", "createdAt": "2020-03-17T22:41:22Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/FlatMapNode.java", "diffHunk": "@@ -90,6 +94,10 @@ protected int getPartitions(final KafkaTopicClient kafkaTopicClient) {\n     return source.getPartitions(kafkaTopicClient);\n   }\n \n+  public Expression resolveSelect(final int idx, final Expression expression) {", "originalCommit": "8d17dde25147b08474fc662252b957f82d007cb5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIzODMyMg==", "url": "https://github.com/confluentinc/ksql/pull/4781#discussion_r394238322", "bodyText": "done.", "author": "big-andy-coates", "createdAt": "2020-03-18T10:17:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDAxMjQ5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDAxNDE4Mg==", "url": "https://github.com/confluentinc/ksql/pull/4781#discussion_r394014182", "bodyText": "this comment is a little confusing to me - where are we taking only the value columns?", "author": "agavra", "createdAt": "2020-03-17T22:46:10Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/LogicalPlanner.java", "diffHunk": "@@ -223,6 +262,46 @@ private ProjectNode buildProjectNode(\n     );\n   }\n \n+  private List<SelectExpression> buildSelectExpressions(final PlanNode parentNode) {\n+    return IntStream.range(0, analysis.getSelectItems().size())\n+        .boxed()\n+        .flatMap(idx -> resolveSelectItem(idx, parentNode))\n+        .collect(Collectors.toList());\n+  }\n+\n+  private Stream<SelectExpression> resolveSelectItem(\n+      final int idx,\n+      final PlanNode parentNode\n+  ) {\n+    final SelectItem selectItem = analysis.getSelectItems().get(idx);\n+\n+    if (selectItem instanceof SingleColumn) {\n+      final SingleColumn column = (SingleColumn) selectItem;\n+      final Expression expression = parentNode.resolveSelect(idx, column.getExpression());\n+      final ColumnName alias = column.getAlias()\n+          .orElseThrow(() -> new IllegalStateException(\"Alias should be present by this point\"));\n+\n+      return Stream.of(SelectExpression.of(alias, expression));\n+    }\n+\n+    if (selectItem instanceof AllColumns) {\n+      final AllColumns allColumns = (AllColumns) selectItem;\n+\n+      final Stream<ColumnName> columns = parentNode\n+          .resolveSelectStar(allColumns.getSource(), analysis.getInto().isPresent());\n+\n+      // Only need to take value columns as value schema includes key schema by this point", "originalCommit": "8d17dde25147b08474fc662252b957f82d007cb5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDIzOTMyMg==", "url": "https://github.com/confluentinc/ksql/pull/4781#discussion_r394239322", "bodyText": "outdated comment - remove.", "author": "big-andy-coates", "createdAt": "2020-03-18T10:19:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDAxNDE4Mg=="}], "type": "inlineReview"}, {"oid": "cc3ab547f45de923d387e87cfae80bfc7f8760f4", "url": "https://github.com/confluentinc/ksql/commit/cc3ab547f45de923d387e87cfae80bfc7f8760f4", "message": "chore: changes requested by Almog", "committedDate": "2020-03-18T10:19:54Z", "type": "commit"}, {"oid": "053e1de133f4880dcd9dd65714f9becd8a564bad", "url": "https://github.com/confluentinc/ksql/commit/053e1de133f4880dcd9dd65714f9becd8a564bad", "message": "chore: merge from master\n\nConflicting files\nksqldb-engine/src/main/java/io/confluent/ksql/planner/LogicalPlanner.java", "committedDate": "2020-03-18T10:21:30Z", "type": "commit"}, {"oid": "b8878d5acf9825cad4cad402e7630ff226d2aa63", "url": "https://github.com/confluentinc/ksql/commit/b8878d5acf9825cad4cad402e7630ff226d2aa63", "message": "chore: remove historic plans for unreleased feature", "committedDate": "2020-03-18T10:24:39Z", "type": "commit"}]}