{"pr_number": 6475, "pr_title": "feat: support `IN` operator for non-pull queries", "pr_createdAt": "2020-10-20T18:08:28Z", "pr_url": "https://github.com/confluentinc/ksql/pull/6475", "timeline": [{"oid": "2154012b395fafcf7a1707bff7741d0d1a3e66ea", "url": "https://github.com/confluentinc/ksql/commit/2154012b395fafcf7a1707bff7741d0d1a3e66ea", "message": "feat: support `IN` operator for non-pull queries\n\nfixes: https://github.com/confluentinc/ksql/issues/6473\n\nAdds support for `IN` operator for push and persistent queries.", "committedDate": "2020-10-20T18:07:25Z", "type": "commit"}, {"oid": "c4d9fd2fb5863ba47f9902caf69700450b501f17", "url": "https://github.com/confluentinc/ksql/commit/c4d9fd2fb5863ba47f9902caf69700450b501f17", "message": "test: historical plans", "committedDate": "2020-10-20T18:07:41Z", "type": "commit"}, {"oid": "4ef99d04768bee5a82aec0b8eccab39bdcc448ae", "url": "https://github.com/confluentinc/ksql/commit/4ef99d04768bee5a82aec0b8eccab39bdcc448ae", "message": "docs: docs", "committedDate": "2020-10-20T18:38:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkwOTg2NA==", "url": "https://github.com/confluentinc/ksql/pull/6475#discussion_r508909864", "bodyText": "I assume this catches the case where the pValue is null and rEntry.getValue() isn't.\nIf they are both null, then they would be considered not to match, per the null handler, right?  Is that the intended behavior for a map?", "author": "AlanConfluent", "createdAt": "2020-10-20T23:57:35Z", "path": "ksqldb-execution/src/main/java/io/confluent/ksql/execution/codegen/helpers/InListEvaluator.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.execution.codegen.helpers;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import java.math.BigDecimal;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import org.apache.kafka.connect.data.Field;\n+import org.apache.kafka.connect.data.Schema;\n+import org.apache.kafka.connect.data.Struct;\n+\n+/**\n+ * Used in the code generation to evaluate SQL 'IN (a, b, c)' expressions.\n+ *\n+ * <p>For tests, see {@code in.json} QTT test.\n+ *\n+ * @see io.confluent.ksql.execution.expression.tree.InPredicate\n+ */\n+public final class InListEvaluator {\n+\n+  private static final Object NO_MATCH = new Object();\n+\n+  private static final ImmutableList<Handler> HANDLERS = ImmutableList.<Handler>builder()\n+      .add(InListEvaluator::nullsNeverMatch)\n+      .add(handler(List.class, InListEvaluator::arraysMatch))\n+      .add(handler(Map.class, InListEvaluator::mapsMatch))\n+      .add(handler(Struct.class, InListEvaluator::structsMatch))\n+      .add(InListEvaluator::exactMatch)\n+      .add(handler(String.class, Object.class, InListEvaluator::requiredParsedMatches))\n+      .add(handler(Object.class, String.class, InListEvaluator::possibleParsedMatches))\n+      .add(handler(Long.class, Integer.class, InListEvaluator::upCastInt))\n+      .add(handler(Double.class, BigDecimal.class, InListEvaluator::downCastDecimal))\n+      .build();\n+\n+  private static final ImmutableMap<Class<?>, Function<String, ?>> STRING_PARSERS = ImmutableMap\n+      .<Class<?>, Function<String, ?>>builder()\n+      .put(Boolean.class, InListEvaluator::stringToBoolean)\n+      .put(Integer.class, Integer::valueOf)\n+      .put(Long.class, Long::valueOf)\n+      .put(Double.class, Double::valueOf)\n+      .put(BigDecimal.class, BigDecimal::new)\n+      .build();\n+\n+  private InListEvaluator() {\n+  }\n+\n+  /**\n+   * Looks for {@code value} in {@code values}.\n+   *\n+   * <p>SQL NULLs never match.\n+   *\n+   * <p>Conversion from INT to BIGINT is handled.\n+   *\n+   * <p>Conversion from DECIMAL to DOUBLE is handled.\n+   *\n+   * <p>Conversion between STRING and other primitive keys is handled.\n+   *\n+   * <p>Invalid conversions are ignored.\n+   *\n+   * @param value the value to look for\n+   * @param values the values to look in\n+   * @return {@code true} if {@code value} is in {@code values}.\n+   */\n+  public static boolean matches(final Object value, final Object... values) {\n+    if (value == null) {\n+      // SQL NULL never matches anything:\n+      return false;\n+    }\n+\n+    for (final Object v : values) {\n+      if (v == null) {\n+        // SQL NULL never matches anything:\n+        continue;\n+      }\n+\n+      if (isMatch(value, v)) {\n+        return true;\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  private static boolean isMatch(final Object requiredValue, final Object possibleMatch) {\n+    for (final Handler handler : HANDLERS) {\n+      final Optional<Boolean> result = handler.accept(requiredValue, possibleMatch);\n+      if (result.isPresent()) {\n+        return result.get();\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  private static Optional<Boolean> nullsNeverMatch(\n+      final Object requiredValue,\n+      final Object possibleMatch\n+  ) {\n+    if (requiredValue == null || possibleMatch == null) {\n+      // SQL NULL never matches anything:\n+      return Optional.of(false);\n+    }\n+\n+    return Optional.empty();\n+  }\n+\n+  private static Optional<Boolean> exactMatch(\n+      final Object requiredValue,\n+      final Object possibleMatch\n+  ) {\n+    if (requiredValue.equals(possibleMatch)) {\n+      return Optional.of(true);\n+    }\n+\n+    return Optional.empty();\n+  }\n+\n+  private static Object parseString(\n+      final String value,\n+      final Class<?> requiredType\n+  ) {\n+    final Function<String, ?> parser = STRING_PARSERS.get(requiredType);\n+    if (parser == null) {\n+      return NO_MATCH;\n+    }\n+\n+    try {\n+      return parser.apply(value);\n+    } catch (final NumberFormatException e) {\n+      return NO_MATCH;\n+    }\n+  }\n+\n+  private static boolean requiredParsedMatches(\n+      final String requiredValue,\n+      final Object possibleMatch\n+  ) {\n+    return possibleParsedMatches(possibleMatch, requiredValue);\n+  }\n+\n+  private static boolean possibleParsedMatches(\n+      final Object requiredValue,\n+      final String possibleMatch\n+  ) {\n+    final Object parsed = parseString(possibleMatch, requiredValue.getClass());\n+    return requiredValue.equals(parsed);\n+  }\n+\n+  private static boolean upCastInt(\n+      final Long requiredValue,\n+      final Integer possibleMatch\n+  ) {\n+    return requiredValue.equals(possibleMatch.longValue());\n+  }\n+\n+  private static boolean downCastDecimal(\n+      final Double requiredValue,\n+      final BigDecimal possibleMatch\n+  ) {\n+    final double d = possibleMatch.doubleValue();\n+    if (!new BigDecimal(String.valueOf(d)).equals(possibleMatch)) {\n+      // Lossy conversion:\n+      return false;\n+    }\n+\n+    return requiredValue.equals(d);\n+  }\n+\n+\n+  private static Object stringToBoolean(final String value) {\n+    switch (value.toUpperCase()) {\n+      case \"T\":\n+      case \"TRUE\":\n+        return true;\n+\n+      case \"F\":\n+      case \"FALSE\":\n+        return false;\n+\n+      default:\n+        return NO_MATCH;\n+    }\n+  }\n+\n+  private static boolean arraysMatch(final List<?> requiredValue, final List<?> possibleMatch) {\n+    final Iterator<?> rIt = requiredValue.iterator();\n+    final Iterator<?> pIt = possibleMatch.iterator();\n+\n+    while (rIt.hasNext() && pIt.hasNext()) {\n+      final Object rNext = rIt.next();\n+      final Object pNext = pIt.next();\n+\n+      if (!isMatch(rNext, pNext)) {\n+        return false;\n+      }\n+    }\n+\n+    return !rIt.hasNext() && !pIt.hasNext();\n+  }\n+\n+  private static boolean mapsMatch(final Map<?, ?> requiredValue, final Map<?, ?> possibleMatch) {\n+    if (requiredValue.size() != possibleMatch.size()) {\n+      return false;\n+    }\n+\n+    for (final Entry<?, ?> rEntry : requiredValue.entrySet()) {\n+      final Object pValue = possibleMatch.get(rEntry.getKey());\n+\n+      if (!isMatch(rEntry.getValue(), pValue)) {", "originalCommit": "4ef99d04768bee5a82aec0b8eccab39bdcc448ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTExNDE3NQ==", "url": "https://github.com/confluentinc/ksql/pull/6475#discussion_r509114175", "bodyText": "I assume this catches the case where the pValue is null and rEntry.getValue() isn't.\n\nYes it does\n\nIf they are both null, then they would be considered not to match, per the null handler, right?\n\nCorrect\n\nIs that the intended behavior for a map?\n\nYep.", "author": "big-andy-coates", "createdAt": "2020-10-21T09:06:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkwOTg2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkxNjgxMg==", "url": "https://github.com/confluentinc/ksql/pull/6475#discussion_r508916812", "bodyText": "Is it not possible to have the reverse as well, BigDecimal is required and Double is matched against?  Is that not the case with the integer/long as well?\nIt would be good to do some test that cover these casting cases.", "author": "AlanConfluent", "createdAt": "2020-10-21T00:20:48Z", "path": "ksqldb-execution/src/main/java/io/confluent/ksql/execution/codegen/helpers/InListEvaluator.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.execution.codegen.helpers;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import java.math.BigDecimal;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import org.apache.kafka.connect.data.Field;\n+import org.apache.kafka.connect.data.Schema;\n+import org.apache.kafka.connect.data.Struct;\n+\n+/**\n+ * Used in the code generation to evaluate SQL 'IN (a, b, c)' expressions.\n+ *\n+ * <p>For tests, see {@code in.json} QTT test.\n+ *\n+ * @see io.confluent.ksql.execution.expression.tree.InPredicate\n+ */\n+public final class InListEvaluator {\n+\n+  private static final Object NO_MATCH = new Object();\n+\n+  private static final ImmutableList<Handler> HANDLERS = ImmutableList.<Handler>builder()\n+      .add(InListEvaluator::nullsNeverMatch)\n+      .add(handler(List.class, InListEvaluator::arraysMatch))\n+      .add(handler(Map.class, InListEvaluator::mapsMatch))\n+      .add(handler(Struct.class, InListEvaluator::structsMatch))\n+      .add(InListEvaluator::exactMatch)\n+      .add(handler(String.class, Object.class, InListEvaluator::requiredParsedMatches))\n+      .add(handler(Object.class, String.class, InListEvaluator::possibleParsedMatches))\n+      .add(handler(Long.class, Integer.class, InListEvaluator::upCastInt))\n+      .add(handler(Double.class, BigDecimal.class, InListEvaluator::downCastDecimal))\n+      .build();\n+\n+  private static final ImmutableMap<Class<?>, Function<String, ?>> STRING_PARSERS = ImmutableMap\n+      .<Class<?>, Function<String, ?>>builder()\n+      .put(Boolean.class, InListEvaluator::stringToBoolean)\n+      .put(Integer.class, Integer::valueOf)\n+      .put(Long.class, Long::valueOf)\n+      .put(Double.class, Double::valueOf)\n+      .put(BigDecimal.class, BigDecimal::new)\n+      .build();\n+\n+  private InListEvaluator() {\n+  }\n+\n+  /**\n+   * Looks for {@code value} in {@code values}.\n+   *\n+   * <p>SQL NULLs never match.\n+   *\n+   * <p>Conversion from INT to BIGINT is handled.\n+   *\n+   * <p>Conversion from DECIMAL to DOUBLE is handled.\n+   *\n+   * <p>Conversion between STRING and other primitive keys is handled.\n+   *\n+   * <p>Invalid conversions are ignored.\n+   *\n+   * @param value the value to look for\n+   * @param values the values to look in\n+   * @return {@code true} if {@code value} is in {@code values}.\n+   */\n+  public static boolean matches(final Object value, final Object... values) {\n+    if (value == null) {\n+      // SQL NULL never matches anything:\n+      return false;\n+    }\n+\n+    for (final Object v : values) {\n+      if (v == null) {\n+        // SQL NULL never matches anything:\n+        continue;\n+      }\n+\n+      if (isMatch(value, v)) {\n+        return true;\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  private static boolean isMatch(final Object requiredValue, final Object possibleMatch) {\n+    for (final Handler handler : HANDLERS) {\n+      final Optional<Boolean> result = handler.accept(requiredValue, possibleMatch);\n+      if (result.isPresent()) {\n+        return result.get();\n+      }\n+    }\n+\n+    return false;\n+  }\n+\n+  private static Optional<Boolean> nullsNeverMatch(\n+      final Object requiredValue,\n+      final Object possibleMatch\n+  ) {\n+    if (requiredValue == null || possibleMatch == null) {\n+      // SQL NULL never matches anything:\n+      return Optional.of(false);\n+    }\n+\n+    return Optional.empty();\n+  }\n+\n+  private static Optional<Boolean> exactMatch(\n+      final Object requiredValue,\n+      final Object possibleMatch\n+  ) {\n+    if (requiredValue.equals(possibleMatch)) {\n+      return Optional.of(true);\n+    }\n+\n+    return Optional.empty();\n+  }\n+\n+  private static Object parseString(\n+      final String value,\n+      final Class<?> requiredType\n+  ) {\n+    final Function<String, ?> parser = STRING_PARSERS.get(requiredType);\n+    if (parser == null) {\n+      return NO_MATCH;\n+    }\n+\n+    try {\n+      return parser.apply(value);\n+    } catch (final NumberFormatException e) {\n+      return NO_MATCH;\n+    }\n+  }\n+\n+  private static boolean requiredParsedMatches(\n+      final String requiredValue,\n+      final Object possibleMatch\n+  ) {\n+    return possibleParsedMatches(possibleMatch, requiredValue);\n+  }\n+\n+  private static boolean possibleParsedMatches(\n+      final Object requiredValue,\n+      final String possibleMatch\n+  ) {\n+    final Object parsed = parseString(possibleMatch, requiredValue.getClass());\n+    return requiredValue.equals(parsed);\n+  }\n+\n+  private static boolean upCastInt(\n+      final Long requiredValue,\n+      final Integer possibleMatch\n+  ) {\n+    return requiredValue.equals(possibleMatch.longValue());\n+  }\n+\n+  private static boolean downCastDecimal(", "originalCommit": "4ef99d04768bee5a82aec0b8eccab39bdcc448ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTEzODQzNg==", "url": "https://github.com/confluentinc/ksql/pull/6475#discussion_r509138436", "bodyText": "Good catch. On it...", "author": "big-andy-coates", "createdAt": "2020-10-21T09:42:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkxNjgxMg=="}], "type": "inlineReview"}, {"oid": "39dc8304255420b9a673d16f0d21b6e5e3ba4985", "url": "https://github.com/confluentinc/ksql/commit/39dc8304255420b9a673d16f0d21b6e5e3ba4985", "message": "Update docs/developer-guide/ksqldb-reference/operators.md\n\nCo-authored-by: Jim Galasyn <jim.galasyn@confluent.io>", "committedDate": "2020-10-21T09:04:53Z", "type": "commit"}, {"oid": "3079b3eb16d1b8b82729191ca72a2af902aff26f", "url": "https://github.com/confluentinc/ksql/commit/3079b3eb16d1b8b82729191ca72a2af902aff26f", "message": "Update docs/developer-guide/ksqldb-reference/operators.md\n\nCo-authored-by: Jim Galasyn <jim.galasyn@confluent.io>", "committedDate": "2020-10-21T09:05:01Z", "type": "commit"}, {"oid": "4dfc6c6c9776aad5b48ecedc8979cb534943871e", "url": "https://github.com/confluentinc/ksql/commit/4dfc6c6c9776aad5b48ecedc8979cb534943871e", "message": "Update docs/developer-guide/ksqldb-reference/quick-reference.md\n\nCo-authored-by: Jim Galasyn <jim.galasyn@confluent.io>", "committedDate": "2020-10-21T09:05:07Z", "type": "commit"}, {"oid": "af4c611e612b82321a019dffe56171b2036f6aea", "url": "https://github.com/confluentinc/ksql/commit/af4c611e612b82321a019dffe56171b2036f6aea", "message": "chore: merge from master", "committedDate": "2020-11-02T17:12:49Z", "type": "commit"}, {"oid": "b4d653ebba0ccb96724b17b03b814d4e5cd0555c", "url": "https://github.com/confluentinc/ksql/commit/b4d653ebba0ccb96724b17b03b814d4e5cd0555c", "message": "Merge branch 'master' into in_exp", "committedDate": "2020-11-03T14:01:12Z", "type": "commit"}, {"oid": "6bf6b0c2096eedd37cb8ac58dd1c65a68282def4", "url": "https://github.com/confluentinc/ksql/commit/6bf6b0c2096eedd37cb8ac58dd1c65a68282def4", "message": "chore: merge from master", "committedDate": "2020-11-11T09:34:11Z", "type": "commit"}, {"oid": "230e5c47ba2605a7ca92ead31c16279aad73ccec", "url": "https://github.com/confluentinc/ksql/commit/230e5c47ba2605a7ca92ead31c16279aad73ccec", "message": "chore: revert unnecessary", "committedDate": "2020-11-11T09:37:59Z", "type": "commit"}, {"oid": "e5a48210c94a7c4e8692d42648f3543e3efbc44c", "url": "https://github.com/confluentinc/ksql/commit/e5a48210c94a7c4e8692d42648f3543e3efbc44c", "message": "chore: refactor", "committedDate": "2020-11-13T20:14:03Z", "type": "commit"}]}