{"pr_number": 5200, "pr_title": "feat(client): Java client with push + pull query support", "pr_createdAt": "2020-04-28T07:43:29Z", "pr_url": "https://github.com/confluentinc/ksql/pull/5200", "timeline": [{"oid": "461c00aec7e633e8dd0a6fc8c3865e659e3636df", "url": "https://github.com/confluentinc/ksql/commit/461c00aec7e633e8dd0a6fc8c3865e659e3636df", "message": "feat: java client push/pull query support", "committedDate": "2020-04-28T07:36:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQwMjY0NQ==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416402645", "bodyText": "I'd originally wanted to add similar methods for getting decimals but that requires either:\n\nparsing the schema to find the precision and scale\nasking the caller to specify precision and scale in the getter\n\nand neither seems great. Is it worth updating the endpoint to return the schema in a more structured form? Feels maybe like overkill.\nI also considered adding getter methods for arrays (lists) and maps but I'm not sure how valuable those methods would be without parsing the schema for specific subtypes.", "author": "vcrfxia", "createdAt": "2020-04-28T07:48:10Z", "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/Row.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client;\n+\n+import java.util.List;\n+\n+/**\n+ * A single record, returned as part of a query result.\n+ */\n+public interface Row {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  List<Object> values();\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Object getObject(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an Object.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Object getObject(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  String getString(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a string.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  String getString(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Integer getInt(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as an integer.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Integer getInt(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Long getLong(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a long.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Long getLong(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Double getDouble(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a double.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Double getDouble(String columnName);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnIndex index of column (1-indexed).\n+   * @return column value.\n+   */\n+  Boolean getBoolean(int columnIndex);\n+\n+  /**\n+   * Get the value for a particular column of the Row as a boolean.\n+   *\n+   * @param columnName name of column.\n+   * @return column value.\n+   */\n+  Boolean getBoolean(String columnName);", "originalCommit": "461c00aec7e633e8dd0a6fc8c3865e659e3636df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU0MTQwMQ==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416541401", "bodyText": "I don't think most users care too muchabout the precision of a decimal. I think we should just return a BigDecimal for a DECIMAL column with whatever scale and precision is appropriate for the value. This is what JDBC does btw https://docs.oracle.com/javase/7/docs/api/java/sql/ResultSet.html#getBigDecimal(int)", "author": "purplefox", "createdAt": "2020-04-28T11:35:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQwMjY0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU0MTY1Mw==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416541653", "bodyText": "For a struct - we can just return that as a JsonObject.", "author": "purplefox", "createdAt": "2020-04-28T11:35:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQwMjY0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU0MzE0Mg==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416543142", "bodyText": "In general, I don't think many users will care about schema either. In the vast majority of cases the back end schema will be well known and fixed, and the developer will know this when issuing queries and doing stuff with the results. Very rarely will be a front end be coding against a completely dynamic and unknown back end.", "author": "purplefox", "createdAt": "2020-04-28T11:38:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQwMjY0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEyOTgxNw==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417129817", "bodyText": "For a struct - we can just return that as a JsonObject.\n\nTo continue an offline discussion: we previously thought it made sense to use vanilla Java types (List, Map) instead of Vert.x types (JsonArray, JsonObject) in the client interfaces so that apps using the client don't need Vert.x as a dependency, but more recently you said maybe it makes sense to use the Vert.x types for better type safety.\nThis still feels strange to me, though. It's one thing to give users the option to provide their own Vert.x instance and/or Vert.x HttpClientOptions, but requiring the use of Vert.x types in order to use the client at all feels odd. IMO it feels fine to expose the fact that the client uses Vert.x under the hood in order to benefit users seeking more advanced use cases, but requiring the use of Vert.x for all client use cases seems unwarranted.\nA third option could be to wrap the Vert.x types but that seems like overkill.", "author": "vcrfxia", "createdAt": "2020-04-29T07:53:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQwMjY0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzIyNDU0OQ==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417224549", "bodyText": "Personally I think it's ok to expose the Vert.x types, or if you prefer to wrap them in our own type and delegate internally. Either way really. But I think it would be a shame to lose the functionality that those classes have which I think would be useful to users. E.g. type safe getters, easy conversion to JSON string, conversion to buffers etc.", "author": "purplefox", "createdAt": "2020-04-29T10:47:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQwMjY0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQzMjM4MA==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r422432380", "bodyText": "As discussed in KLIP-26, I plan to introduce types that wrap the Vert.x types. Stand by for a follow-up PR with this change.", "author": "vcrfxia", "createdAt": "2020-05-09T00:42:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQwMjY0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjUzODQ2NA==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416538464", "bodyText": "I notice this method is not used in tests. I think it's better to use the interface method to create a client than directly instantiating ClientImpl. This enables us to change the implementation more easily without breaking clients. We should consider hiding the constructor of ClientImpl (e.g. making package protected or private and indirecting through a factory)", "author": "purplefox", "createdAt": "2020-04-28T11:29:25Z", "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/Client.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client;\n+\n+import io.confluent.ksql.api.client.impl.ClientImpl;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import org.reactivestreams.Publisher;\n+\n+public interface Client {\n+\n+  /**\n+   * Execute a push query.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql);\n+\n+  /**\n+   * Execute a push query.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql, Map<String, Object> properties);\n+\n+  /**\n+   * Execute a pull query.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<List<Row>> executeQuery(String sql);\n+\n+  /**\n+   * Execute a pull query.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<List<Row>> executeQuery(String sql, Map<String, Object> properties);\n+\n+  CompletableFuture<Void> insertInto(String streamName, Map<String, Object> row);\n+\n+  Publisher<InsertAck> streamInserts(String streamName, Publisher<List<Object>> insertsPublisher);\n+\n+  void close();\n+\n+  static Client create(ClientOptions clientOptions) {", "originalCommit": "461c00aec7e633e8dd0a6fc8c3865e659e3636df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU0MzkzNQ==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416543935", "bodyText": "I'd also add a version of create that takes a Vertx instance. This allows the client to use any existing Vert.x the user might already be using in their app, thus alllowing thread pools to be reused etc.", "author": "purplefox", "createdAt": "2020-04-28T11:39:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjUzODQ2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEyMzU1OA==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417123558", "bodyText": "Good call on the motivation for using the interface method over directly instantiating ClientImpl. I've updated the tests, and also applied the analogous change to ClientOptionsImpl.\nI'm not seeing a way to make the constructor for ClientImpl package private, though. Client.java is in a different package from ClientImpl.java so if Client.java is able to instantiate ClientImpl, then ClientImpl must have a public method for instantiation, whether that's a constructor or a factory method. How do people usually work around this?\n\nI'd also add a version of create that takes a Vertx instance.\n\nDone.", "author": "vcrfxia", "createdAt": "2020-04-29T07:41:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjUzODQ2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzIyOTk5Mg==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417229992", "bodyText": "Take a look how it's done in Vert.x https://github.com/eclipse-vertx/vert.x/blob/master/src/main/java/io/vertx/core/Vertx.java#L86\nBasically the interface uses a static factory instance to actually create the implemention. The ServiceHelper is used to load the factory at run-time by scanning the classpath for implementations of the factory. The factory itself is in the same package as VertxImpl so the VertxImpl constructor can be package protected. It's a bit convoluted and may be overkill for us right now, might be sufficient to not worry about hiding the constructor but perhaps adding javadoc to it saying it should not be instantiated directly.", "author": "purplefox", "createdAt": "2020-04-29T10:58:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjUzODQ2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE5Mjc5Mw==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r419192793", "bodyText": "Hm interesting, the VertxImpl constructor is package protected but the factory implementation (in the same package) is still public: https://github.com/eclipse-vertx/vert.x/blob/3.8/src/main/java/io/vertx/core/impl/VertxFactoryImpl.java#L23\nso if a user wanted to circumvent the intent of the VertxImpl constructor being private they could still do so by calling new VertxImplFactory().vertx(), right?", "author": "vcrfxia", "createdAt": "2020-05-04T02:25:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjUzODQ2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg5MjEzNg==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r422892136", "bodyText": "Probably, but the intention here isn't to protect against malicious users - it's pretty trivial to construct any object, even if it has an inaccessible private/protected/package protected constructor, using reflection. The idea is to nudge users to the right API :)", "author": "purplefox", "createdAt": "2020-05-11T09:02:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjUzODQ2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjUzOTU2OA==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416539568", "bodyText": "Maybe also expose the Vert.x HttpClientOptions? There are probably other settings (e.g. pool size) that users might want to tweak.", "author": "purplefox", "createdAt": "2020-04-28T11:31:34Z", "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/ClientOptions.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client;\n+\n+public interface ClientOptions {", "originalCommit": "461c00aec7e633e8dd0a6fc8c3865e659e3636df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEyNTQyNw==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417125427", "bodyText": "I'm trying to understand the expected behavior if a user provides HttpClienttOptions: will ClientOptionsImpl update the provided HttpClienttOptions according to the other fields, or will the user-provided HttpClientOptions be used directly?\nThe latter doesn't seem very user-friendly since then the user would be responsible for duplicating the work of ClientImpl in populating HttpClientOptions based on ClientOptions, but the former also seems confusing since the user would have to know which HttpClientOptions properties will be overridden and which won't.", "author": "vcrfxia", "createdAt": "2020-04-29T07:44:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjUzOTU2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI4MTI0OQ==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417281249", "bodyText": "I would probably expose the HttpClientOptions directly and not have similar methods on ClientOptions at all. I.e. only have options on ClientOptions if they're not related to HTTP. If you're not comfortable exposing the HttpClientOptions directly you could wrap them.", "author": "purplefox", "createdAt": "2020-04-29T12:37:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjUzOTU2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE5MDE0Mw==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r419190143", "bodyText": "I.e. only have options on ClientOptions if they're not related to HTTP.\n\nWhat counts as \"not related to HTTP\"? Of the options exposed so far (host, port, useTls, trustStore, keyStore, and basicAuth), all of them have equivalents in the Vert.x HttpClientOptions besides basicAuth. If we were to only expose HttpClientOptions and not have similar options on ClientOptions then ClientOptions would become\npublic interface ClientOptions {\n\n  ClientOptions setBasicAuthCredentials(String username, String password);\n\n  boolean isUseBasicAuth();\n\n  String getBasicAuthUsername();\n\n  String getBasicAuthPassword();\n\n  ClientOptions copy();\n\n  static ClientOptions create(HttpClientOptions httpClientOptions) {\n    return new ClientOptionsImpl(httpClientOptions);\n  }\n\nIs this what you're proposing? I feel like I've misunderstood.\n\nIf you're not comfortable exposing the HttpClientOptions directly you could wrap them.\n\nI assume this means creating a wrapper type around HttpClientOptions, rather than wrapping the individual methods of HttpClientOptions into ClientOptions (as exposing too many options in ClientOptions feels like it'll overwhelm the user). If we were to create a wrapper type around HttpClientOptions, would it not be better to leave the more commonly used methods in ClientOptions itself (as is currently the case) and only wrap the other options in HttpClientOptions?", "author": "vcrfxia", "createdAt": "2020-05-04T02:03:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjUzOTU2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjk5MDQ0NA==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r422990444", "bodyText": "I'm going to change my mind on this one. I think it's ok to just use our own ClientOptions and not to expose HttpClientOptions. If we find we need to expose more properties over time on ClientOptions we can do that.\n(Aside: BTW I think we should support token auth on the client too, not just basic auth)", "author": "purplefox", "createdAt": "2020-05-11T12:03:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjUzOTU2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU0MDAxNA==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416540014", "bodyText": "I know the docs are going to be completed at a later date, but this is also used for pull query.", "author": "purplefox", "createdAt": "2020-04-28T11:32:21Z", "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/QueryResult.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client;\n+\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import org.reactivestreams.Publisher;\n+\n+/**\n+ * The result of a streaming (push) query. Records may be consumed by either subscribing to the", "originalCommit": "461c00aec7e633e8dd0a6fc8c3865e659e3636df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEyNTUwMQ==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417125501", "bodyText": "Updated.", "author": "vcrfxia", "createdAt": "2020-04-29T07:45:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU0MDAxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1MDQwMQ==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416550401", "bodyText": "The stream methods can also be used for pull queries :)\nNot all pull queries results are small enough to be collected as a set of rows in memory. For large pull queries you might want to stream, and say, straight out to a file on disk.\nSo the distinction between streaming or not, is not really about pull vs push queries it's more about the number of rows returned.", "author": "purplefox", "createdAt": "2020-04-28T11:51:22Z", "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/Client.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client;\n+\n+import io.confluent.ksql.api.client.impl.ClientImpl;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import org.reactivestreams.Publisher;\n+\n+public interface Client {\n+\n+  /**\n+   * Execute a push query.", "originalCommit": "461c00aec7e633e8dd0a6fc8c3865e659e3636df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1MTI1MQ==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416551251", "bodyText": "BTW this is the reason I named the methods \"streamQuery\" not \"executePushQuery\" :)", "author": "purplefox", "createdAt": "2020-04-28T11:52:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1MDQwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEyMTUyMQ==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417121521", "bodyText": "Makes sense. I'd actually meant to ask you about this before opening the PR but forgot :) Made the change.", "author": "vcrfxia", "createdAt": "2020-04-29T07:37:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1MDQwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1MDUyNQ==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416550525", "bodyText": "As above comment", "author": "purplefox", "createdAt": "2020-04-28T11:51:35Z", "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/Client.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client;\n+\n+import io.confluent.ksql.api.client.impl.ClientImpl;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import org.reactivestreams.Publisher;\n+\n+public interface Client {\n+\n+  /**\n+   * Execute a push query.\n+   *\n+   * @param sql statement of query to execute.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql);\n+\n+  /**\n+   * Execute a push query.\n+   *\n+   * @param sql statement of query to execute.\n+   * @param properties query properties.\n+   * @return query result.\n+   */\n+  CompletableFuture<QueryResult> streamQuery(String sql, Map<String, Object> properties);\n+\n+  /**\n+   * Execute a pull query.", "originalCommit": "461c00aec7e633e8dd0a6fc8c3865e659e3636df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEyMTU4MA==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417121580", "bodyText": "Done.", "author": "vcrfxia", "createdAt": "2020-04-29T07:37:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1MDUyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1MjI0NQ==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416552245", "bodyText": "I think whether auth is used is configured on the client options, if so then all this stuff probably doesn't need to be computed on each request.", "author": "purplefox", "createdAt": "2020-04-28T11:54:39Z", "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/impl/ClientImpl.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client.impl;\n+\n+import static io.netty.handler.codec.http.HttpHeaderNames.AUTHORIZATION;\n+import static io.netty.handler.codec.http.HttpResponseStatus.OK;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+import io.confluent.ksql.api.client.InsertAck;\n+import io.confluent.ksql.api.client.QueryResult;\n+import io.confluent.ksql.api.client.Row;\n+import io.confluent.ksql.rest.client.KsqlRestClientException;\n+import io.vertx.core.Context;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.http.HttpClient;\n+import io.vertx.core.http.HttpClientOptions;\n+import io.vertx.core.http.HttpClientRequest;\n+import io.vertx.core.http.HttpClientResponse;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.core.http.HttpVersion;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.core.net.JksOptions;\n+import io.vertx.core.net.SocketAddress;\n+import io.vertx.core.parsetools.RecordParser;\n+import java.nio.charset.Charset;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import org.reactivestreams.Publisher;\n+\n+public class ClientImpl implements Client {\n+\n+  private final ClientOptions clientOptions;\n+  private final Vertx vertx;\n+  private final HttpClient httpClient;\n+  private final SocketAddress serverSocketAddress;\n+  private final boolean ownedVertx;\n+\n+  public ClientImpl(final ClientOptions clientOptions) {\n+    this(clientOptions, Vertx.vertx(), true);\n+  }\n+\n+  public ClientImpl(final ClientOptions clientOptions, final Vertx vertx) {\n+    this(clientOptions, vertx, false);\n+  }\n+\n+  private ClientImpl(final ClientOptions clientOptions, final Vertx vertx,\n+      final boolean ownedVertx) {\n+    this.clientOptions = clientOptions.copy();\n+    this.vertx = vertx;\n+    this.ownedVertx = ownedVertx;\n+    this.httpClient = createHttpClient(vertx, clientOptions);\n+    this.serverSocketAddress = io.vertx.core.net.SocketAddress\n+        .inetSocketAddress(clientOptions.getPort(), clientOptions.getHost());\n+  }\n+\n+  @Override\n+  public CompletableFuture<QueryResult> streamQuery(final String sql) {\n+    return streamQuery(sql, Collections.emptyMap());\n+  }\n+\n+  @Override\n+  public CompletableFuture<QueryResult> streamQuery(\n+      final String sql,\n+      final Map<String, Object> properties\n+  ) {\n+    return makeQueryRequest(sql, properties, PushQueryResponseHandler::new);\n+  }\n+\n+  @Override\n+  public CompletableFuture<List<Row>> executeQuery(final String sql) {\n+    return executeQuery(sql, Collections.emptyMap());\n+  }\n+\n+  @Override\n+  public CompletableFuture<List<Row>> executeQuery(\n+      final String sql,\n+      final Map<String, Object> properties\n+  ) {\n+    return makeQueryRequest(sql, properties, PullQueryResponseHandler::new);\n+  }\n+\n+  @Override\n+  public CompletableFuture<Void> insertInto(\n+      final String streamName, final Map<String, Object> row) {\n+    return null; // not yet implemented\n+  }\n+\n+  @Override\n+  public Publisher<InsertAck> streamInserts(\n+      String streamName, Publisher<List<Object>> insertsPublisher) {\n+    return null; // not yet implemented\n+  }\n+\n+  @Override\n+  public void close() {\n+    httpClient.close();\n+    if (ownedVertx) {\n+      vertx.close();\n+    }\n+  }\n+\n+  @FunctionalInterface\n+  private interface ResponseHandlerSupplier<T> {\n+    QueryResponseHandler<T> get(Context ctx, RecordParser recordParser, CompletableFuture<T> cf);\n+  }\n+\n+  private <T> CompletableFuture<T> makeQueryRequest(\n+      final String sql,\n+      final Map<String, Object> properties,\n+      final ResponseHandlerSupplier<T> responseHandlerSupplier\n+  ) {\n+\n+    final JsonObject requestBody = new JsonObject().put(\"sql\", sql).put(\"properties\", properties);\n+\n+    final CompletableFuture<T> cf = new CompletableFuture<>();\n+\n+    HttpClientRequest request = httpClient.request(HttpMethod.POST,\n+        serverSocketAddress, clientOptions.getPort(), clientOptions.getHost(),\n+        \"/query-stream\",\n+        response -> handleResponse(response, cf, responseHandlerSupplier))\n+        .exceptionHandler(e -> handleRequestException(e, cf));\n+    if (clientOptions.isUseBasicAuth()) {\n+      request = configureBasicAuth(request);\n+    }\n+    request.end(requestBody.toBuffer());\n+\n+    return cf;\n+  }\n+\n+  private HttpClientRequest configureBasicAuth(final HttpClientRequest request) {\n+    final String creds = clientOptions.getBasicAuthUsername()", "originalCommit": "461c00aec7e633e8dd0a6fc8c3865e659e3636df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEzMjk4Mw==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417132983", "bodyText": "Good point! Fixed.", "author": "vcrfxia", "createdAt": "2020-04-29T07:58:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1MjI0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1MjU5MA==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416552590", "bodyText": "Do we really need a separate method for this?", "author": "purplefox", "createdAt": "2020-04-28T11:55:18Z", "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/impl/ClientImpl.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client.impl;\n+\n+import static io.netty.handler.codec.http.HttpHeaderNames.AUTHORIZATION;\n+import static io.netty.handler.codec.http.HttpResponseStatus.OK;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+import io.confluent.ksql.api.client.InsertAck;\n+import io.confluent.ksql.api.client.QueryResult;\n+import io.confluent.ksql.api.client.Row;\n+import io.confluent.ksql.rest.client.KsqlRestClientException;\n+import io.vertx.core.Context;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.http.HttpClient;\n+import io.vertx.core.http.HttpClientOptions;\n+import io.vertx.core.http.HttpClientRequest;\n+import io.vertx.core.http.HttpClientResponse;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.core.http.HttpVersion;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.core.net.JksOptions;\n+import io.vertx.core.net.SocketAddress;\n+import io.vertx.core.parsetools.RecordParser;\n+import java.nio.charset.Charset;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import org.reactivestreams.Publisher;\n+\n+public class ClientImpl implements Client {\n+\n+  private final ClientOptions clientOptions;\n+  private final Vertx vertx;\n+  private final HttpClient httpClient;\n+  private final SocketAddress serverSocketAddress;\n+  private final boolean ownedVertx;\n+\n+  public ClientImpl(final ClientOptions clientOptions) {\n+    this(clientOptions, Vertx.vertx(), true);\n+  }\n+\n+  public ClientImpl(final ClientOptions clientOptions, final Vertx vertx) {\n+    this(clientOptions, vertx, false);\n+  }\n+\n+  private ClientImpl(final ClientOptions clientOptions, final Vertx vertx,\n+      final boolean ownedVertx) {\n+    this.clientOptions = clientOptions.copy();\n+    this.vertx = vertx;\n+    this.ownedVertx = ownedVertx;\n+    this.httpClient = createHttpClient(vertx, clientOptions);\n+    this.serverSocketAddress = io.vertx.core.net.SocketAddress\n+        .inetSocketAddress(clientOptions.getPort(), clientOptions.getHost());\n+  }\n+\n+  @Override\n+  public CompletableFuture<QueryResult> streamQuery(final String sql) {\n+    return streamQuery(sql, Collections.emptyMap());\n+  }\n+\n+  @Override\n+  public CompletableFuture<QueryResult> streamQuery(\n+      final String sql,\n+      final Map<String, Object> properties\n+  ) {\n+    return makeQueryRequest(sql, properties, PushQueryResponseHandler::new);\n+  }\n+\n+  @Override\n+  public CompletableFuture<List<Row>> executeQuery(final String sql) {\n+    return executeQuery(sql, Collections.emptyMap());\n+  }\n+\n+  @Override\n+  public CompletableFuture<List<Row>> executeQuery(\n+      final String sql,\n+      final Map<String, Object> properties\n+  ) {\n+    return makeQueryRequest(sql, properties, PullQueryResponseHandler::new);\n+  }\n+\n+  @Override\n+  public CompletableFuture<Void> insertInto(\n+      final String streamName, final Map<String, Object> row) {\n+    return null; // not yet implemented\n+  }\n+\n+  @Override\n+  public Publisher<InsertAck> streamInserts(\n+      String streamName, Publisher<List<Object>> insertsPublisher) {\n+    return null; // not yet implemented\n+  }\n+\n+  @Override\n+  public void close() {\n+    httpClient.close();\n+    if (ownedVertx) {\n+      vertx.close();\n+    }\n+  }\n+\n+  @FunctionalInterface\n+  private interface ResponseHandlerSupplier<T> {\n+    QueryResponseHandler<T> get(Context ctx, RecordParser recordParser, CompletableFuture<T> cf);\n+  }\n+\n+  private <T> CompletableFuture<T> makeQueryRequest(\n+      final String sql,\n+      final Map<String, Object> properties,\n+      final ResponseHandlerSupplier<T> responseHandlerSupplier\n+  ) {\n+\n+    final JsonObject requestBody = new JsonObject().put(\"sql\", sql).put(\"properties\", properties);\n+\n+    final CompletableFuture<T> cf = new CompletableFuture<>();\n+\n+    HttpClientRequest request = httpClient.request(HttpMethod.POST,\n+        serverSocketAddress, clientOptions.getPort(), clientOptions.getHost(),\n+        \"/query-stream\",\n+        response -> handleResponse(response, cf, responseHandlerSupplier))\n+        .exceptionHandler(e -> handleRequestException(e, cf));\n+    if (clientOptions.isUseBasicAuth()) {\n+      request = configureBasicAuth(request);\n+    }\n+    request.end(requestBody.toBuffer());\n+\n+    return cf;\n+  }\n+\n+  private HttpClientRequest configureBasicAuth(final HttpClientRequest request) {\n+    final String creds = clientOptions.getBasicAuthUsername()\n+        + \":\"\n+        + clientOptions.getBasicAuthPassword();\n+    final String base64creds =\n+        Base64.getEncoder().encodeToString(creds.getBytes(Charset.defaultCharset()));\n+    return request.putHeader(AUTHORIZATION.toString(), \"Basic \" + base64creds);\n+  }\n+\n+  private static void handleRequestException(final Throwable t, final CompletableFuture<?> cf) {", "originalCommit": "461c00aec7e633e8dd0a6fc8c3865e659e3636df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEzMzA3MQ==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417133071", "bodyText": "Done.", "author": "vcrfxia", "createdAt": "2020-04-29T07:59:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1MjU5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1MjkzOA==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416552938", "bodyText": "I'm thinking maybe we need to set the exception handler on the recordParser too and connect it to the CF?", "author": "purplefox", "createdAt": "2020-04-28T11:55:59Z", "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/impl/ClientImpl.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client.impl;\n+\n+import static io.netty.handler.codec.http.HttpHeaderNames.AUTHORIZATION;\n+import static io.netty.handler.codec.http.HttpResponseStatus.OK;\n+\n+import io.confluent.ksql.api.client.Client;\n+import io.confluent.ksql.api.client.ClientOptions;\n+import io.confluent.ksql.api.client.InsertAck;\n+import io.confluent.ksql.api.client.QueryResult;\n+import io.confluent.ksql.api.client.Row;\n+import io.confluent.ksql.rest.client.KsqlRestClientException;\n+import io.vertx.core.Context;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.http.HttpClient;\n+import io.vertx.core.http.HttpClientOptions;\n+import io.vertx.core.http.HttpClientRequest;\n+import io.vertx.core.http.HttpClientResponse;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.core.http.HttpVersion;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.core.net.JksOptions;\n+import io.vertx.core.net.SocketAddress;\n+import io.vertx.core.parsetools.RecordParser;\n+import java.nio.charset.Charset;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import org.reactivestreams.Publisher;\n+\n+public class ClientImpl implements Client {\n+\n+  private final ClientOptions clientOptions;\n+  private final Vertx vertx;\n+  private final HttpClient httpClient;\n+  private final SocketAddress serverSocketAddress;\n+  private final boolean ownedVertx;\n+\n+  public ClientImpl(final ClientOptions clientOptions) {\n+    this(clientOptions, Vertx.vertx(), true);\n+  }\n+\n+  public ClientImpl(final ClientOptions clientOptions, final Vertx vertx) {\n+    this(clientOptions, vertx, false);\n+  }\n+\n+  private ClientImpl(final ClientOptions clientOptions, final Vertx vertx,\n+      final boolean ownedVertx) {\n+    this.clientOptions = clientOptions.copy();\n+    this.vertx = vertx;\n+    this.ownedVertx = ownedVertx;\n+    this.httpClient = createHttpClient(vertx, clientOptions);\n+    this.serverSocketAddress = io.vertx.core.net.SocketAddress\n+        .inetSocketAddress(clientOptions.getPort(), clientOptions.getHost());\n+  }\n+\n+  @Override\n+  public CompletableFuture<QueryResult> streamQuery(final String sql) {\n+    return streamQuery(sql, Collections.emptyMap());\n+  }\n+\n+  @Override\n+  public CompletableFuture<QueryResult> streamQuery(\n+      final String sql,\n+      final Map<String, Object> properties\n+  ) {\n+    return makeQueryRequest(sql, properties, PushQueryResponseHandler::new);\n+  }\n+\n+  @Override\n+  public CompletableFuture<List<Row>> executeQuery(final String sql) {\n+    return executeQuery(sql, Collections.emptyMap());\n+  }\n+\n+  @Override\n+  public CompletableFuture<List<Row>> executeQuery(\n+      final String sql,\n+      final Map<String, Object> properties\n+  ) {\n+    return makeQueryRequest(sql, properties, PullQueryResponseHandler::new);\n+  }\n+\n+  @Override\n+  public CompletableFuture<Void> insertInto(\n+      final String streamName, final Map<String, Object> row) {\n+    return null; // not yet implemented\n+  }\n+\n+  @Override\n+  public Publisher<InsertAck> streamInserts(\n+      String streamName, Publisher<List<Object>> insertsPublisher) {\n+    return null; // not yet implemented\n+  }\n+\n+  @Override\n+  public void close() {\n+    httpClient.close();\n+    if (ownedVertx) {\n+      vertx.close();\n+    }\n+  }\n+\n+  @FunctionalInterface\n+  private interface ResponseHandlerSupplier<T> {\n+    QueryResponseHandler<T> get(Context ctx, RecordParser recordParser, CompletableFuture<T> cf);\n+  }\n+\n+  private <T> CompletableFuture<T> makeQueryRequest(\n+      final String sql,\n+      final Map<String, Object> properties,\n+      final ResponseHandlerSupplier<T> responseHandlerSupplier\n+  ) {\n+\n+    final JsonObject requestBody = new JsonObject().put(\"sql\", sql).put(\"properties\", properties);\n+\n+    final CompletableFuture<T> cf = new CompletableFuture<>();\n+\n+    HttpClientRequest request = httpClient.request(HttpMethod.POST,\n+        serverSocketAddress, clientOptions.getPort(), clientOptions.getHost(),\n+        \"/query-stream\",\n+        response -> handleResponse(response, cf, responseHandlerSupplier))\n+        .exceptionHandler(e -> handleRequestException(e, cf));\n+    if (clientOptions.isUseBasicAuth()) {\n+      request = configureBasicAuth(request);\n+    }\n+    request.end(requestBody.toBuffer());\n+\n+    return cf;\n+  }\n+\n+  private HttpClientRequest configureBasicAuth(final HttpClientRequest request) {\n+    final String creds = clientOptions.getBasicAuthUsername()\n+        + \":\"\n+        + clientOptions.getBasicAuthPassword();\n+    final String base64creds =\n+        Base64.getEncoder().encodeToString(creds.getBytes(Charset.defaultCharset()));\n+    return request.putHeader(AUTHORIZATION.toString(), \"Basic \" + base64creds);\n+  }\n+\n+  private static void handleRequestException(final Throwable t, final CompletableFuture<?> cf) {\n+    cf.completeExceptionally(t);\n+  }\n+\n+  private static <T> void handleResponse(\n+      final HttpClientResponse response,\n+      final CompletableFuture<T> cf,\n+      final ResponseHandlerSupplier<T> responseHandlerSupplier) {\n+    if (response.statusCode() == OK.code()) {\n+      final RecordParser recordParser = RecordParser.newDelimited(\"\\n\", response);\n+      final QueryResponseHandler<T> responseHandler =\n+          responseHandlerSupplier.get(Vertx.currentContext(), recordParser, cf);\n+\n+      recordParser.handler(responseHandler::handleBodyBuffer);\n+      recordParser.endHandler(responseHandler::handleBodyEnd);", "originalCommit": "461c00aec7e633e8dd0a6fc8c3865e659e3636df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEzNDc1Mg==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417134752", "bodyText": "I think you're right, but I'm unsure what the exception handler should do.\nShould we fail the CompletableFuture if it hasn't already been ended? This would require synchronizing the response handler methods, which doesn't seem great.\nWhat if the CompletableFuture has already been completed, as could be the case for streamed queries? Should we close the QueryResult?", "author": "vcrfxia", "createdAt": "2020-04-29T08:02:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1MjkzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI5MzYyNw==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417293627", "bodyText": "Ah sorry, forget what I said. If cf is not ended then fail it. But if it's already ended I think the best think is to pass the exception to the response handler (e.g. add a method ResponseHandler.handleException). In the concrete implementation of that method (e.g. in PushQueryResponseHandler.handleException) call sendError on the QueryResultImpl (will need to expose this as it's protected), this will result in the subscriber getting the exception if it's subscribed.", "author": "purplefox", "createdAt": "2020-04-29T12:58:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1MjkzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTIzNjM5OA==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r419236398", "bodyText": "Done, though I don't love the method name QueryResponseHandler#handleExceptionAfterFutureCompleted(). Let me know if you've got something better haha.\nAlso, now that I better understand the vertx threading model I realize my concern above is a non-issue: the response handler methods don't need to be synchronized even though the completable future is potentially ended in multiple methods since the different methods are guaranteed to be called from the same thread.", "author": "vcrfxia", "createdAt": "2020-05-04T06:40:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1MjkzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1MzgwNw==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416553807", "bodyText": "I'm not a fan of initialising config strings to empty strings. Imho null is a better way of determining whether they have been set or not.", "author": "purplefox", "createdAt": "2020-04-28T11:57:28Z", "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/impl/ClientOptionsImpl.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client.impl;\n+\n+import io.confluent.ksql.api.client.ClientOptions;\n+import java.util.Objects;\n+\n+public class ClientOptionsImpl implements ClientOptions {\n+\n+  private String host = \"localhost\";\n+  private int port = 8088;\n+  private boolean useTls = false;\n+  private boolean useClientAuth = false;\n+  private boolean useBasicAuth = false;\n+  private String trustStorePath = \"\";", "originalCommit": "461c00aec7e633e8dd0a6fc8c3865e659e3636df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEzNTM1MQ==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417135351", "bodyText": "My original motivation for avoiding nulls was so the calling code wouldn't need perform null checks, but I've worked around this by updating the getter methods instead. I'm curious to know whether you think this is an improvement or not.", "author": "vcrfxia", "createdAt": "2020-04-29T08:03:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1MzgwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI5NTYwNg==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417295606", "bodyText": "I don't see what's wrong with the user dealing with nulls. Imho it's much more ugly for the user to have to deal with empty strings. If we're using empty strings to refer to absence of a value then what if empty string is a valid value? It gets nasty and ambiguous.", "author": "purplefox", "createdAt": "2020-04-29T13:01:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1MzgwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI0MTAzMA==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r419241030", "bodyText": "It's true there's ambiguity but for values where the empty string isn't valid (e.g., default host, trust store path, etc.) the ambiguity doesn't really matter from the user's perspective -- null and empty string can be treated the same.\nIn terms of why it's more work for the user to deal with nulls, some libraries won't accept nulls since the user then has to null check (rather than having ClientOptionsImpl simply not return nulls). For example this line in ClientImpl\nthis.serverSocketAddress = SocketAddress\n        .inetSocketAddress(clientOptions.getPort(), clientOptions.getHost());\n\nfails with java.lang.NullPointerException: no null host accepted if clientOptions.getHost() is null. Should ClientImpl try to avoid this by using clientOptions.getHost() == null ? \"\" : clientOptions.getHost(), or should we pass in clientOptions.getHost() directly and let the failure occur if it's null?", "author": "vcrfxia", "createdAt": "2020-05-04T06:54:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1MzgwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI0MTU5Ng==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r419241596", "bodyText": "To clarify: I'm happy to switch to allowing nulls to be returned from ClientOptionsImpl. Just trying to understand the full scope of your reasoning in an effort to learn :)", "author": "vcrfxia", "createdAt": "2020-05-04T06:56:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1MzgwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg5NTg0Mg==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r422895842", "bodyText": "Another reason why using empty strings to imply lack of property set is a bad idea - what if the string has some whitespace - a space, tab or CR? Do we count that as \"null\" too? This is super error prone and hard for the user to debug too (println on an empty string or a string with whitespace to the console or log looks the same)", "author": "purplefox", "createdAt": "2020-05-11T09:09:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1MzgwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg5NzUxMA==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r422897510", "bodyText": "Regarding the SocketAddress example. This doesn't allow nulls as a socket address needs both a valid host and port to be well defined. The null check is there to make sure you're passing in both. If you use null to represent no host then it will fail nice and early. If you use empty string to represent no host, it will allow the object to be created, and won't fail until some time later in the program when it actually tries to use the address to connect.", "author": "purplefox", "createdAt": "2020-05-11T09:12:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1MzgwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1NDA4Mw==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416554083", "bodyText": "what is this method used for?", "author": "purplefox", "createdAt": "2020-04-28T11:58:00Z", "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/impl/ClientOptionsImpl.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client.impl;\n+\n+import io.confluent.ksql.api.client.ClientOptions;\n+import java.util.Objects;\n+\n+public class ClientOptionsImpl implements ClientOptions {\n+\n+  private String host = \"localhost\";\n+  private int port = 8088;\n+  private boolean useTls = false;\n+  private boolean useClientAuth = false;\n+  private boolean useBasicAuth = false;\n+  private String trustStorePath = \"\";\n+  private String trustStorePassword = \"\";\n+  private String keyStorePath = \"\";\n+  private String keyStorePassword = \"\";\n+  private String basicAuthUsername = \"\";\n+  private String basicAuthPassword = \"\";\n+\n+  public ClientOptionsImpl() {\n+  }\n+\n+  // CHECKSTYLE_RULES.OFF: ParameterNumberCheck\n+  private ClientOptionsImpl(\n+      // CHECKSTYLE_RULES.ON: ParameterNumberCheck\n+      final String host, final int port,\n+      final boolean useTls, final boolean useClientAuth, final boolean useBasicAuth,\n+      final String trustStorePath, final String trustStorePassword,\n+      final String keyStorePath, final String keyStorePassword,\n+      final String basicAuthUsername, final String basicAuthPassword) {\n+    this.host = Objects.requireNonNull(host);\n+    this.port = port;\n+    this.useTls = useTls;\n+    this.useClientAuth = useClientAuth;\n+    this.useBasicAuth = useBasicAuth;\n+    this.trustStorePath = Objects.requireNonNull(trustStorePath);\n+    this.trustStorePassword = Objects.requireNonNull(trustStorePassword);\n+    this.keyStorePath = Objects.requireNonNull(keyStorePath);\n+    this.keyStorePassword = Objects.requireNonNull(keyStorePassword);\n+    this.basicAuthUsername = Objects.requireNonNull(basicAuthUsername);\n+    this.basicAuthPassword = Objects.requireNonNull(basicAuthPassword);\n+  }\n+\n+  @Override\n+  public ClientOptions setHost(final String host) {\n+    this.host = Objects.requireNonNull(host);\n+    return this;\n+  }\n+\n+  @Override\n+  public ClientOptions setPort(final int port) {\n+    this.port = port;\n+    return this;\n+  }\n+\n+  @Override\n+  public ClientOptions setUseTls(final boolean useTls) {\n+    this.useTls = useTls;\n+    return this;\n+  }\n+\n+  @Override\n+  public ClientOptions setUseClientAuth(final boolean useClientAuth) {\n+    this.useClientAuth = useClientAuth;\n+    return this;\n+  }\n+\n+  @Override\n+  public ClientOptions setTrustStore(final String trustStorePath) {\n+    this.trustStorePath = Objects.requireNonNull(trustStorePath);\n+    return this;\n+  }\n+\n+  @Override\n+  public ClientOptions setTrustStorePassword(final String trustStorePassword) {\n+    this.trustStorePassword = Objects.requireNonNull(trustStorePassword);\n+    return this;\n+  }\n+\n+  @Override\n+  public ClientOptions setKeyStore(final String keyStorePath) {\n+    this.keyStorePath = Objects.requireNonNull(keyStorePath);\n+    return this;\n+  }\n+\n+  @Override\n+  public ClientOptions setKeyStorePassword(final String keyStorePassword) {\n+    this.keyStorePassword = Objects.requireNonNull(keyStorePassword);\n+    return this;\n+  }\n+\n+  @Override\n+  public ClientOptions setBasicAuthCredentials(final String username, final String password) {\n+    Objects.requireNonNull(username);\n+    Objects.requireNonNull(password);\n+\n+    this.useBasicAuth = true;\n+    this.basicAuthUsername = username;\n+    this.basicAuthPassword = password;\n+    return this;\n+  }\n+\n+  @Override\n+  public ClientOptions unsetBasicAuthCredentials() {", "originalCommit": "461c00aec7e633e8dd0a6fc8c3865e659e3636df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEzNjIzMw==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417136233", "bodyText": "I wanted to provide a way to reset useBasicAuth back to false, but as you've pointed out I don't think this was the best way to do it. I've removed this method and wrapped that functionality into setBasicAuthCredentials() instead.", "author": "vcrfxia", "createdAt": "2020-04-29T08:05:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1NDA4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1NjMyNw==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416556327", "bodyText": "Most probably shouldn't be synchronized otherwise it will block if polling is occurring at same time.", "author": "purplefox", "createdAt": "2020-04-28T12:02:04Z", "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/impl/PollableSubscriber.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client.impl;\n+\n+import io.confluent.ksql.api.client.Row;\n+import io.confluent.ksql.reactive.BaseSubscriber;\n+import io.vertx.core.Context;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import org.reactivestreams.Subscription;\n+\n+public class PollableSubscriber extends BaseSubscriber<Row> {\n+\n+  private static final int REQUEST_BATCH_SIZE = 100;\n+  // 100ms in ns\n+  private static final long MAX_POLL_NANOS = TimeUnit.MILLISECONDS.toNanos(100);\n+\n+  private final BlockingQueue<Row> queue = new LinkedBlockingQueue<>();\n+  private int tokens;\n+  private Throwable error;\n+  private volatile boolean closed;\n+\n+  public PollableSubscriber(final Context context) {\n+    super(context);\n+  }\n+\n+  @Override\n+  protected void afterSubscribe(final Subscription subscription) {\n+    checkRequestTokens();\n+  }\n+\n+  @Override\n+  protected void handleValue(final Row row) {\n+    queue.add(row);\n+  }\n+\n+  @Override\n+  protected synchronized void handleError(final Throwable t) {", "originalCommit": "461c00aec7e633e8dd0a6fc8c3865e659e3636df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEzNjMzNw==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417136337", "bodyText": "Done.", "author": "vcrfxia", "createdAt": "2020-04-29T08:05:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1NjMyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1NjQwNA==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416556404", "bodyText": "As above.", "author": "purplefox", "createdAt": "2020-04-28T12:02:12Z", "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/impl/PollableSubscriber.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client.impl;\n+\n+import io.confluent.ksql.api.client.Row;\n+import io.confluent.ksql.reactive.BaseSubscriber;\n+import io.vertx.core.Context;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+import org.reactivestreams.Subscription;\n+\n+public class PollableSubscriber extends BaseSubscriber<Row> {\n+\n+  private static final int REQUEST_BATCH_SIZE = 100;\n+  // 100ms in ns\n+  private static final long MAX_POLL_NANOS = TimeUnit.MILLISECONDS.toNanos(100);\n+\n+  private final BlockingQueue<Row> queue = new LinkedBlockingQueue<>();\n+  private int tokens;\n+  private Throwable error;\n+  private volatile boolean closed;\n+\n+  public PollableSubscriber(final Context context) {\n+    super(context);\n+  }\n+\n+  @Override\n+  protected void afterSubscribe(final Subscription subscription) {\n+    checkRequestTokens();\n+  }\n+\n+  @Override\n+  protected void handleValue(final Row row) {\n+    queue.add(row);\n+  }\n+\n+  @Override\n+  protected synchronized void handleError(final Throwable t) {\n+    System.out.println(\"pollable subscriber encountered error: \" + t);\n+    error = t;\n+  }\n+\n+  @Override\n+  protected synchronized void handleComplete() {", "originalCommit": "461c00aec7e633e8dd0a6fc8c3865e659e3636df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEzNjM2Ng==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417136366", "bodyText": "Done.", "author": "vcrfxia", "createdAt": "2020-04-29T08:05:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1NjQwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1NzI0Mw==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416557243", "bodyText": "I'd probably not name this PullQueryResponseHandler as pull queries can also be executed via the streaming API, and theoretically you could use this for push queries too.", "author": "purplefox", "createdAt": "2020-04-28T12:03:49Z", "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/impl/PullQueryResponseHandler.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client.impl;\n+\n+import io.confluent.ksql.api.client.Row;\n+import io.confluent.ksql.api.server.protocol.QueryResponseMetadata;\n+import io.confluent.ksql.rest.client.KsqlRestClientException;\n+import io.vertx.core.Context;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.parsetools.RecordParser;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+public class PullQueryResponseHandler extends QueryResponseHandler<List<Row>> {", "originalCommit": "461c00aec7e633e8dd0a6fc8c3865e659e3636df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEzNjcwMw==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417136703", "bodyText": "Renamed to ExecuteQueryResponseHandler, for consistency with the methods in the Client interface.", "author": "vcrfxia", "createdAt": "2020-04-29T08:05:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1NzI0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1ODAwMg==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416558002", "bodyText": "It might be worth adding a check here to make sure there aren't too many rows. E.g. somewhat might use this with a non terminating push query and it ends up exhausting all memory on the client. Once more than N rows are obtained throw an exception and abort.", "author": "purplefox", "createdAt": "2020-04-28T12:05:13Z", "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/impl/PullQueryResponseHandler.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client.impl;\n+\n+import io.confluent.ksql.api.client.Row;\n+import io.confluent.ksql.api.server.protocol.QueryResponseMetadata;\n+import io.confluent.ksql.rest.client.KsqlRestClientException;\n+import io.vertx.core.Context;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.parsetools.RecordParser;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+public class PullQueryResponseHandler extends QueryResponseHandler<List<Row>> {\n+\n+  private final List<Row> rows;\n+  private List<String> columnNames;\n+  private List<String> columnTypes;\n+\n+  PullQueryResponseHandler(final Context context, final RecordParser recordParser,\n+      final CompletableFuture<List<Row>> cf) {\n+    super(context, recordParser, cf);\n+    this.rows = new ArrayList<>();\n+  }\n+\n+  @Override\n+  protected void handleMetadata(final QueryResponseMetadata queryResponseMetadata) {\n+    if (queryResponseMetadata.queryId != null && !queryResponseMetadata.queryId.isEmpty()) {\n+      cf.completeExceptionally(\n+          new KsqlRestClientException(\"Expecting pull query but was push query\"));\n+    }\n+\n+    columnNames = queryResponseMetadata.columnNames;\n+    columnTypes = queryResponseMetadata.columnTypes;\n+  }\n+\n+  @Override\n+  protected void handleRow(final Buffer buff) {\n+    final JsonArray values = new JsonArray(buff);\n+    rows.add(new RowImpl(columnNames, columnTypes, values));", "originalCommit": "461c00aec7e633e8dd0a6fc8c3865e659e3636df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEzNzQ1NQ==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417137455", "bodyText": "What do you think is a reasonable limit? 1000? I guess we could also make this configurable via the client options.", "author": "vcrfxia", "createdAt": "2020-04-29T08:07:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1ODAwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI5NjA2NA==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417296064", "bodyText": "+1 I think it should be configurable. 1000 rows seems a bit too few. How about 10000?", "author": "purplefox", "createdAt": "2020-04-29T13:01:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1ODAwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQzNDU2Mw==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r422434563", "bodyText": "Done. The config is currently a client config (rather than a param on the executeQuery() method itself) which makes more sense to me, though it does mean a user would have to client a new client rather than simply reissuing the request if they hit the limit and want to increase it.\nThe config name I put in (setExecuteQueryMaxResultRows()) isn't great. Open to suggestions!", "author": "vcrfxia", "createdAt": "2020-05-09T00:59:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1ODAwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1ODMwOQ==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416558309", "bodyText": "Again, naming. This could be used for pull queries too. Maybe StreamingQueryResponseHandler would be better?", "author": "purplefox", "createdAt": "2020-04-28T12:05:46Z", "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/impl/PushQueryResponseHandler.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client.impl;\n+\n+import io.confluent.ksql.api.client.QueryResult;\n+import io.confluent.ksql.api.client.Row;\n+import io.confluent.ksql.api.server.protocol.QueryResponseMetadata;\n+import io.confluent.ksql.rest.client.KsqlRestClientException;\n+import io.vertx.core.Context;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.parsetools.RecordParser;\n+import java.util.Collections;\n+import java.util.concurrent.CompletableFuture;\n+\n+public class PushQueryResponseHandler extends QueryResponseHandler<QueryResult> {", "originalCommit": "461c00aec7e633e8dd0a6fc8c3865e659e3636df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEzNzk1NA==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417137954", "bodyText": "Renamed to StreamQueryResponseHandler, for consistency with the methods in the Client interface.", "author": "vcrfxia", "createdAt": "2020-04-29T08:08:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1ODMwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1ODk0Nw==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416558947", "bodyText": "Maybe a checkContext here just to be sure?", "author": "purplefox", "createdAt": "2020-04-28T12:06:50Z", "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/impl/PushQueryResponseHandler.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client.impl;\n+\n+import io.confluent.ksql.api.client.QueryResult;\n+import io.confluent.ksql.api.client.Row;\n+import io.confluent.ksql.api.server.protocol.QueryResponseMetadata;\n+import io.confluent.ksql.rest.client.KsqlRestClientException;\n+import io.vertx.core.Context;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.parsetools.RecordParser;\n+import java.util.Collections;\n+import java.util.concurrent.CompletableFuture;\n+\n+public class PushQueryResponseHandler extends QueryResponseHandler<QueryResult> {\n+\n+  private QueryResultImpl queryResult;\n+  private boolean paused;\n+\n+  PushQueryResponseHandler(final Context context, final RecordParser recordParser,\n+      final CompletableFuture<QueryResult> cf) {\n+    super(context, recordParser, cf);\n+  }\n+\n+  @Override\n+  protected void handleMetadata(final QueryResponseMetadata queryResponseMetadata) {\n+    if (queryResponseMetadata.queryId == null || queryResponseMetadata.queryId.isEmpty()) {\n+      cf.completeExceptionally(\n+          new KsqlRestClientException(\"Expecting push query but was pull query\"));\n+      return;\n+    }\n+\n+    this.queryResult = new QueryResultImpl(context, queryResponseMetadata.queryId,\n+        Collections.unmodifiableList(queryResponseMetadata.columnNames),\n+        Collections.unmodifiableList(queryResponseMetadata.columnTypes));\n+    cf.complete(queryResult);\n+  }\n+\n+  @Override\n+  protected void handleRow(final Buffer buff) {\n+    if (queryResult == null) {\n+      throw new IllegalStateException(\"handleRow called before metadata processed\");\n+    }\n+\n+    final JsonArray values = new JsonArray(buff);\n+    final Row row = new RowImpl(queryResult.columnNames(), queryResult.columnTypes(), values);\n+    final boolean full = queryResult.accept(row);\n+    if (full && !paused) {\n+      recordParser.pause();\n+      queryResult.drainHandler(this::publisherReceptive);\n+      paused = true;\n+    }\n+  }\n+\n+  @Override\n+  protected void handleBodyEnd() {\n+  }\n+\n+  private void publisherReceptive() {\n+    paused = false;", "originalCommit": "461c00aec7e633e8dd0a6fc8c3865e659e3636df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEzODQ5Mw==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417138493", "bodyText": "Added. I don't fully understand what the purpose of these context checks is, though. (I've seen them throughout the server code as well but haven't fully wrapped my head around them.) What exactly are we trying to prevent?", "author": "vcrfxia", "createdAt": "2020-04-29T08:09:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1ODk0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI5Nzk1Ng==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417297956", "bodyText": "They're not strictly necessary but I like to add them as sanity checks.\nBasically they ensure that the particular method is being executed on the right thread.\nOne nice thing about the Vert.x threading model is it ensures that all handlers when set from a specific context are called on the same context too, i.e. usually that means on the same thread. That means you don't have to worry about synchronizing stuff, race conditions, deadlocks etc. Big win! However... maybe there's some other thread in your code that is mistakenly calling that method too, in which case it might silently be corrupting the state as that state is not synchronized. The checkContext calls check this isn't occurring.", "author": "purplefox", "createdAt": "2020-04-29T13:05:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1ODk0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI0MjQ2Mw==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r419242463", "bodyText": "Super helpful explanation. Thanks!", "author": "vcrfxia", "createdAt": "2020-05-04T06:59:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU1ODk0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU2MDU2Mg==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416560562", "bodyText": "Probably don't want to register this every time. And registering modules on the singleton DatabindCodec object mapper will affect any other user of Vert.x in the same process, so probably don't want to do that.\nI'd suggest we maintain our own static ObjectMapper in the ClientImpl and use that for all encoding/decoding if possible.", "author": "purplefox", "createdAt": "2020-04-28T12:09:53Z", "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/impl/QueryResponseHandler.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client.impl;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.datatype.guava.GuavaModule;\n+import com.google.common.collect.ImmutableList;\n+import io.confluent.ksql.api.server.protocol.QueryResponseMetadata;\n+import io.confluent.ksql.util.VertxUtils;\n+import io.vertx.core.Context;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.json.jackson.DatabindCodec;\n+import io.vertx.core.parsetools.RecordParser;\n+import java.util.concurrent.CompletableFuture;\n+\n+abstract class QueryResponseHandler<T> {\n+\n+  protected final Context context;\n+  protected final RecordParser recordParser;\n+  protected final CompletableFuture<T> cf;\n+  protected boolean hasReadArguments;\n+\n+  QueryResponseHandler(final Context context, final RecordParser recordParser,\n+      final CompletableFuture<T> cf) {\n+    this.context = context;\n+    this.recordParser = recordParser;\n+    this.cf = cf;\n+  }\n+\n+  public void handleBodyBuffer(final Buffer buff) {\n+    checkContext();\n+    if (!hasReadArguments) {\n+      handleArgs(buff);\n+    } else {\n+      handleRow(buff);\n+    }\n+  }\n+\n+  public void handleBodyEnd(final Void v) {\n+    checkContext();\n+    handleBodyEnd();\n+  }\n+\n+  protected abstract void handleBodyEnd();\n+\n+  protected abstract void handleMetadata(final QueryResponseMetadata queryResponseMetadata);\n+\n+  protected abstract void handleRow(final Buffer buff);\n+\n+  private void handleArgs(final Buffer buff) {\n+    hasReadArguments = true;\n+\n+    final QueryResponseMetadata queryResponseMetadata;\n+    final ObjectMapper objectMapper = DatabindCodec.mapper();\n+    objectMapper.registerModule(new GuavaModule());", "originalCommit": "461c00aec7e633e8dd0a6fc8c3865e659e3636df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEzOTAyOQ==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417139029", "bodyText": "Done, though I've put the static ObjectMapper into a separate utility (JsonMapper) rather than in ClientImpl.", "author": "vcrfxia", "createdAt": "2020-04-29T08:10:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU2MDU2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU2MjcwNg==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416562706", "bodyText": "Probably be better to take the monitor after the check if polling, otherwise if polling, the method won't be executed and the user won't see the exception.", "author": "purplefox", "createdAt": "2020-04-28T12:13:44Z", "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/impl/QueryResultImpl.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client.impl;\n+\n+import io.confluent.ksql.api.client.QueryResult;\n+import io.confluent.ksql.api.client.Row;\n+import io.confluent.ksql.reactive.BufferedPublisher;\n+import io.vertx.core.Context;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import org.reactivestreams.Subscriber;\n+\n+class QueryResultImpl extends BufferedPublisher<Row> implements QueryResult {\n+\n+  private final String queryId;\n+  private final List<String> columnNames;\n+  private final List<String> columnTypes;\n+  private final PollableSubscriber pollableSubscriber;\n+  private boolean polling;\n+  private boolean subscribing;\n+\n+  QueryResultImpl(final Context context, final String queryId, final List<String> columnNames,\n+      final List<String> columnTypes) {\n+    super(context);\n+    this.queryId = queryId;\n+    this.columnNames = columnNames;\n+    this.columnTypes = columnTypes;\n+    this.pollableSubscriber = new PollableSubscriber(ctx);\n+  }\n+\n+  @Override\n+  public List<String> columnNames() {\n+    return columnNames;\n+  }\n+\n+  @Override\n+  public List<String> columnTypes() {\n+    return columnTypes;\n+  }\n+\n+  @Override\n+  public String queryID() {\n+    return queryId;\n+  }\n+\n+  @Override\n+  public synchronized void subscribe(final Subscriber<? super Row> subscriber) {\n+    if (polling) {\n+      throw new IllegalStateException(\"Cannot set subscriber if polling\");\n+    }\n+    subscribing = true;", "originalCommit": "461c00aec7e633e8dd0a6fc8c3865e659e3636df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEzOTQ4Nw==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417139487", "bodyText": "Sorry, I'm failing to grok this comment. What does \"the monitor\" refer to?", "author": "vcrfxia", "createdAt": "2020-04-29T08:11:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU2MjcwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzMwMDY3Ng==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417300676", "bodyText": "Each Java object which uses synchronized somewhere has a monitor associated with it. You can think of it as a mutex which can be owned by a thread and must be released by the same thread. It's what does the locking when you use the synchronized keyword. http://journals.ecs.soton.ac.uk/java/tutorial/java/threads/monitors.html\nSo when I say \"take the monitor\" I mean \"lock the object\". In other words instead of synchronizing the whole method, do the polling check outside the monitor, something like this:\n  @Override\n  public void subscribe(final Subscriber<? super Row> subscriber) {\n    if (polling) {\n      throw new IllegalStateException(\"Cannot set subscriber if polling\");\n    }\n    synchronized (this) {\n        subscribing = true;\n        super.subscribe(subscriber);\n   }\n  }\n\npolling would need to made volatile too.\nSorry about the confusing language!", "author": "purplefox", "createdAt": "2020-04-29T13:09:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU2MjcwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI0Mzg0Ng==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r419243846", "bodyText": "Got it -- good catch! Made the suggested change.", "author": "vcrfxia", "createdAt": "2020-05-04T07:03:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU2MjcwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU2MzU1Nw==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416563557", "bodyText": "Always returns false?", "author": "purplefox", "createdAt": "2020-04-28T12:15:13Z", "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/impl/QueryResultImpl.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client.impl;\n+\n+import io.confluent.ksql.api.client.QueryResult;\n+import io.confluent.ksql.api.client.Row;\n+import io.confluent.ksql.reactive.BufferedPublisher;\n+import io.vertx.core.Context;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import org.reactivestreams.Subscriber;\n+\n+class QueryResultImpl extends BufferedPublisher<Row> implements QueryResult {\n+\n+  private final String queryId;\n+  private final List<String> columnNames;\n+  private final List<String> columnTypes;\n+  private final PollableSubscriber pollableSubscriber;\n+  private boolean polling;\n+  private boolean subscribing;\n+\n+  QueryResultImpl(final Context context, final String queryId, final List<String> columnNames,\n+      final List<String> columnTypes) {\n+    super(context);\n+    this.queryId = queryId;\n+    this.columnNames = columnNames;\n+    this.columnTypes = columnTypes;\n+    this.pollableSubscriber = new PollableSubscriber(ctx);\n+  }\n+\n+  @Override\n+  public List<String> columnNames() {\n+    return columnNames;\n+  }\n+\n+  @Override\n+  public List<String> columnTypes() {\n+    return columnTypes;\n+  }\n+\n+  @Override\n+  public String queryID() {\n+    return queryId;\n+  }\n+\n+  @Override\n+  public synchronized void subscribe(final Subscriber<? super Row> subscriber) {\n+    if (polling) {\n+      throw new IllegalStateException(\"Cannot set subscriber if polling\");\n+    }\n+    subscribing = true;\n+    super.subscribe(subscriber);\n+  }\n+\n+  @Override\n+  public Row poll() {\n+    return poll(0, TimeUnit.MILLISECONDS);\n+  }\n+\n+  @Override\n+  public synchronized Row poll(final long timeout, final TimeUnit timeUnit) {\n+    if (subscribing) {\n+      throw new IllegalStateException(\"Cannot poll if subscriber has been set\");\n+    }\n+    if (!polling) {\n+      subscribe(pollableSubscriber);\n+      subscribing = false;\n+      polling = true;\n+    }\n+    try {\n+      return pollableSubscriber.poll(timeout, timeUnit);\n+    } catch (final Throwable t) {\n+      sendError(new Exception(\"Failed to poll\", t));\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public boolean isComplete() {\n+    return false;", "originalCommit": "461c00aec7e633e8dd0a6fc8c3865e659e3636df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0MDk3MQ==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417140971", "bodyText": "Whoops! Forgot to implement this -- thanks for the catch.\nNow that I think about it, though, I'm unclear on what the desired behavior is. Does \"complete\" mean that the underlying connection is closed, or that all rows have been read? I see that for BufferedPublisher \"complete\" means the former, as it's possible for the BufferedPublisher to be \"complete\" even if there are buffered rows that have yet to be read, but this seems a little counterintuitive.", "author": "vcrfxia", "createdAt": "2020-04-29T08:13:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU2MzU1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzMwMjM3Mg==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417302372", "bodyText": "Complete for a subscriber means the onComplete method has been called.\nonComplete should be called for any graceful close - termination by server, end of limit, or close by the close-query api.\nThe complete method on a publisher means \"mark this publisher as complete, and send onComplete to it's subscribers once you've delivered any pending rows\"", "author": "purplefox", "createdAt": "2020-04-29T13:12:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU2MzU1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQzMzczMQ==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r422433731", "bodyText": "Got'cha. I've renamed a couple internal variables in BufferedPublisher to better reflect this. Thanks for the clarification!", "author": "vcrfxia", "createdAt": "2020-05-09T00:53:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU2MzU1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU2NDI5NA==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416564294", "bodyText": "valueToIndexMap is always the same for each row in a query result, so it seems inefficient to calculate it every time. Instead we could calculate it once and pass the map into the constructor of RowImpl", "author": "purplefox", "createdAt": "2020-04-28T12:16:29Z", "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/impl/RowImpl.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client.impl;\n+\n+import io.confluent.ksql.api.client.Row;\n+import io.vertx.core.json.JsonArray;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class RowImpl implements Row {\n+\n+  private final List<String> columnNames;\n+  private final List<String> columnTypes;\n+  private final List<Object> values;\n+  private final Map<String, Integer> columnNameToIndex;\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public RowImpl(\n+      final List<String> columnNames,\n+      final List<String> columnTypes,\n+      final JsonArray values) {\n+    this.columnNames = columnNames;\n+    this.columnTypes = columnTypes;\n+    this.values = values.getList();\n+\n+    this.columnNameToIndex = valueToIndexMap(columnNames);", "originalCommit": "461c00aec7e633e8dd0a6fc8c3865e659e3636df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0MTA4OA==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417141088", "bodyText": "Done. Good point!", "author": "vcrfxia", "createdAt": "2020-04-29T08:14:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU2NDI5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU2NTYyNw==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416565627", "bodyText": "Perhaps use a different method for this, as it's doing something different to creating a WebClient", "author": "purplefox", "createdAt": "2020-04-28T12:18:56Z", "path": "ksqldb-api-client/src/test/java/io/confluent/ksql/api/client/ClientTest.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client;\n+\n+import static io.confluent.ksql.test.util.AssertEventually.assertThatEventually;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.notNullValue;\n+import static org.hamcrest.Matchers.nullValue;\n+\n+import io.confluent.ksql.api.BaseApiTest;\n+import io.confluent.ksql.api.client.impl.ClientImpl;\n+import io.confluent.ksql.api.client.impl.ClientOptionsImpl;\n+import io.confluent.ksql.api.server.PushQueryId;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.vertx.core.Context;\n+import io.vertx.ext.web.client.WebClient;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+import org.junit.Test;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class ClientTest extends BaseApiTest {\n+\n+  @SuppressWarnings(\"unchecked\")\n+  protected static final List<String> DEFAULT_COLUMN_NAMES = BaseApiTest.DEFAULT_COLUMN_NAMES.getList();\n+  @SuppressWarnings(\"unchecked\")\n+  protected static final List<String> DEFAULT_COLUMN_TYPES = BaseApiTest.DEFAULT_COLUMN_TYPES.getList();\n+  protected static final Map<String, Object> DEFAULT_PUSH_QUERY_REQUEST_PROPERTIES =\n+      BaseApiTest.DEFAULT_PUSH_QUERY_REQUEST_PROPERTIES.getMap();\n+\n+  protected Context context;\n+  protected Client client;\n+\n+  @Override\n+  public void setUp() {\n+    super.setUp();\n+\n+    context = vertx.getOrCreateContext();\n+  }\n+\n+  @Override\n+  protected WebClient createClient() {\n+    // Use Java client for these tests, rather than a vanilla WebClient\n+    this.client = createJavaClient();", "originalCommit": "461c00aec7e633e8dd0a6fc8c3865e659e3636df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0MTE3OQ==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417141179", "bodyText": "Done.", "author": "vcrfxia", "createdAt": "2020-04-29T08:14:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU2NTYyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU2NjI2OQ==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416566269", "bodyText": "This line and then one above could be replace with a cf.get() to return the result of the cf synchronously. This makes tests like this a bit easier to follow imho. cf.get() will cause exception to be thrown if it completed exceptionally.", "author": "purplefox", "createdAt": "2020-04-28T12:20:05Z", "path": "ksqldb-api-client/src/test/java/io/confluent/ksql/api/client/ClientTest.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client;\n+\n+import static io.confluent.ksql.test.util.AssertEventually.assertThatEventually;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.notNullValue;\n+import static org.hamcrest.Matchers.nullValue;\n+\n+import io.confluent.ksql.api.BaseApiTest;\n+import io.confluent.ksql.api.client.impl.ClientImpl;\n+import io.confluent.ksql.api.client.impl.ClientOptionsImpl;\n+import io.confluent.ksql.api.server.PushQueryId;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.vertx.core.Context;\n+import io.vertx.ext.web.client.WebClient;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+import org.junit.Test;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class ClientTest extends BaseApiTest {\n+\n+  @SuppressWarnings(\"unchecked\")\n+  protected static final List<String> DEFAULT_COLUMN_NAMES = BaseApiTest.DEFAULT_COLUMN_NAMES.getList();\n+  @SuppressWarnings(\"unchecked\")\n+  protected static final List<String> DEFAULT_COLUMN_TYPES = BaseApiTest.DEFAULT_COLUMN_TYPES.getList();\n+  protected static final Map<String, Object> DEFAULT_PUSH_QUERY_REQUEST_PROPERTIES =\n+      BaseApiTest.DEFAULT_PUSH_QUERY_REQUEST_PROPERTIES.getMap();\n+\n+  protected Context context;\n+  protected Client client;\n+\n+  @Override\n+  public void setUp() {\n+    super.setUp();\n+\n+    context = vertx.getOrCreateContext();\n+  }\n+\n+  @Override\n+  protected WebClient createClient() {\n+    // Use Java client for these tests, rather than a vanilla WebClient\n+    this.client = createJavaClient();\n+\n+    return null;\n+  }\n+\n+  @Override\n+  protected void stopClient() {\n+    if (client != null) {\n+      try {\n+        client.close();\n+      } catch (Exception e) {\n+        log.error(\"Failed to close client\", e);\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void shouldStreamQueryAsync() throws Exception {\n+    // When\n+    final CompletableFuture<QueryResult> cf = client.streamQuery(DEFAULT_PUSH_QUERY, DEFAULT_PUSH_QUERY_REQUEST_PROPERTIES);\n+    assertThatEventually(cf::isDone, equalTo(true));\n+    assertThat(cf.isCompletedExceptionally(), equalTo(false));", "originalCommit": "461c00aec7e633e8dd0a6fc8c3865e659e3636df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU2Njc4Mw==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416566783", "bodyText": "Also cf.get() will block the calling thread until the cf is complete, which is more efficient than polling with assertThatEventually.", "author": "purplefox", "createdAt": "2020-04-28T12:21:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU2NjI2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0MTQwMQ==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417141401", "bodyText": "Much cleaner, thanks for the suggestion! Made the changes.", "author": "vcrfxia", "createdAt": "2020-04-29T08:14:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU2NjI2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU2NzczNQ==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416567735", "bodyText": "Wouldn't it be simpler just to fall cf.get() rather than using a latch, and handling everything asynchronously?", "author": "purplefox", "createdAt": "2020-04-28T12:22:35Z", "path": "ksqldb-api-client/src/test/java/io/confluent/ksql/api/client/ClientTest.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client;\n+\n+import static io.confluent.ksql.test.util.AssertEventually.assertThatEventually;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.notNullValue;\n+import static org.hamcrest.Matchers.nullValue;\n+\n+import io.confluent.ksql.api.BaseApiTest;\n+import io.confluent.ksql.api.client.impl.ClientImpl;\n+import io.confluent.ksql.api.client.impl.ClientOptionsImpl;\n+import io.confluent.ksql.api.server.PushQueryId;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.vertx.core.Context;\n+import io.vertx.ext.web.client.WebClient;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+import org.junit.Test;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class ClientTest extends BaseApiTest {\n+\n+  @SuppressWarnings(\"unchecked\")\n+  protected static final List<String> DEFAULT_COLUMN_NAMES = BaseApiTest.DEFAULT_COLUMN_NAMES.getList();\n+  @SuppressWarnings(\"unchecked\")\n+  protected static final List<String> DEFAULT_COLUMN_TYPES = BaseApiTest.DEFAULT_COLUMN_TYPES.getList();\n+  protected static final Map<String, Object> DEFAULT_PUSH_QUERY_REQUEST_PROPERTIES =\n+      BaseApiTest.DEFAULT_PUSH_QUERY_REQUEST_PROPERTIES.getMap();\n+\n+  protected Context context;\n+  protected Client client;\n+\n+  @Override\n+  public void setUp() {\n+    super.setUp();\n+\n+    context = vertx.getOrCreateContext();\n+  }\n+\n+  @Override\n+  protected WebClient createClient() {\n+    // Use Java client for these tests, rather than a vanilla WebClient\n+    this.client = createJavaClient();\n+\n+    return null;\n+  }\n+\n+  @Override\n+  protected void stopClient() {\n+    if (client != null) {\n+      try {\n+        client.close();\n+      } catch (Exception e) {\n+        log.error(\"Failed to close client\", e);\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void shouldStreamQueryAsync() throws Exception {\n+    // When\n+    final CompletableFuture<QueryResult> cf = client.streamQuery(DEFAULT_PUSH_QUERY, DEFAULT_PUSH_QUERY_REQUEST_PROPERTIES);\n+    assertThatEventually(cf::isDone, equalTo(true));\n+    assertThat(cf.isCompletedExceptionally(), equalTo(false));\n+    final QueryResult queryResult = cf.get();\n+\n+    // Then\n+    verifyPushQueryMetadata(queryResult);\n+\n+    shouldDeliver(queryResult, DEFAULT_ROWS.size());\n+  }\n+\n+  @Test\n+  public void shouldStreamQuerySync() throws Exception {\n+    // When\n+    final CompletableFuture<QueryResult> cf = client.streamQuery(DEFAULT_PUSH_QUERY, DEFAULT_PUSH_QUERY_REQUEST_PROPERTIES);\n+    assertThatEventually(cf::isDone, equalTo(true));\n+    assertThat(cf.isCompletedExceptionally(), equalTo(false));\n+    final QueryResult queryResult = cf.get();\n+\n+    // Then\n+    verifyPushQueryMetadata(queryResult);\n+\n+    for (int i = 0; i < DEFAULT_ROWS.size(); i++) {\n+      final Row row = queryResult.poll();\n+      assertThat(row.values(), equalTo(rowWithIndex(i).getList()));\n+      assertThat(row.columnNames(), equalTo(DEFAULT_COLUMN_NAMES));\n+      assertThat(row.columnTypes(), equalTo(DEFAULT_COLUMN_TYPES));\n+    }\n+  }\n+\n+  @Test\n+  public void shouldHandleErrorResponseFromStreamQuery() throws Exception {\n+    // Given\n+    ParseFailedException pfe = new ParseFailedException(\"invalid query blah\");\n+    testEndpoints.setCreateQueryPublisherException(pfe);\n+\n+    // When/Then\n+    assertErrorWhen(\n+        () -> client.streamQuery(\"bad query\", DEFAULT_PUSH_QUERY_REQUEST_PROPERTIES),\n+        \"Received 400 response from server\",\n+        \"invalid query blah\"\n+    );\n+  }\n+\n+  @Test\n+  public void shouldFailStreamQueryOnPullQuery() throws Exception {\n+    assertErrorWhen(\n+        () -> client.streamQuery(DEFAULT_PULL_QUERY),\n+        \"Expecting push query but was pull query\"\n+    );\n+  }\n+\n+  @Test\n+  public void shouldExecutePullQuery() throws Exception {\n+    // When\n+    final CompletableFuture<List<Row>> cf = client.executeQuery(DEFAULT_PULL_QUERY);\n+    assertThatEventually(cf::isDone, equalTo(true));\n+    assertThat(cf.isCompletedExceptionally(), equalTo(false));\n+    final List<Row> rows = cf.get();\n+\n+    // Then\n+    assertThat(testEndpoints.getLastSql(), is(DEFAULT_PULL_QUERY));\n+    assertThat(testEndpoints.getLastProperties().getMap(), is(Collections.emptyMap()));\n+\n+    assertThat(rows, hasSize(DEFAULT_ROWS.size()));\n+    for (int i = 0; i < DEFAULT_ROWS.size(); i++) {\n+      assertThat(rows.get(i).values(), equalTo(rowWithIndex(i).getList()));\n+      assertThat(rows.get(i).columnNames(), equalTo(DEFAULT_COLUMN_NAMES));\n+      assertThat(rows.get(i).columnTypes(), equalTo(DEFAULT_COLUMN_TYPES));\n+    }\n+\n+    assertThat(server.getQueryIDs(), hasSize(0));\n+  }\n+\n+  @Test\n+  public void shouldHandleErrorResponseFromExecuteQuery() throws Exception {\n+    // Given\n+    ParseFailedException pfe = new ParseFailedException(\"invalid query blah\");\n+    testEndpoints.setCreateQueryPublisherException(pfe);\n+\n+    // When/Then\n+    assertErrorWhen(\n+        () -> client.executeQuery(\"bad query\"),\n+        \"Received 400 response from server\",\n+        \"invalid query blah\"\n+    );\n+  }\n+\n+  @Test\n+  public void shouldFailExecuteQueryOnPushQuery() throws Exception {\n+    assertErrorWhen(\n+        () -> client.executeQuery(DEFAULT_PUSH_QUERY),\n+        \"Expecting pull query but was push query\"\n+    );\n+  }\n+\n+  protected Client createJavaClient() {\n+    return new ClientImpl(createJavaClientOptions(), vertx);\n+  }\n+\n+  protected ClientOptions createJavaClientOptions() {\n+    return new ClientOptionsImpl()\n+        .setHost(\"localhost\")\n+        .setPort(server.getListeners().get(0).getPort())\n+        .setUseTls(false);\n+  }\n+\n+  private void verifyPushQueryMetadata(final QueryResult queryResult) {\n+    assertThat(testEndpoints.getLastSql(), is(DEFAULT_PUSH_QUERY));\n+    assertThat(testEndpoints.getLastProperties(), is(BaseApiTest.DEFAULT_PUSH_QUERY_REQUEST_PROPERTIES));\n+\n+    assertThat(queryResult.columnNames(), is(DEFAULT_COLUMN_NAMES));\n+    assertThat(queryResult.columnTypes(), is(DEFAULT_COLUMN_TYPES));\n+\n+    String queryId = queryResult.queryID();\n+    assertThat(queryId, is(notNullValue()));\n+    assertThat(server.getQueryIDs(), hasSize(1));\n+    assertThat(server.getQueryIDs().contains(new PushQueryId(queryId)), is(true));\n+  }\n+\n+  private void shouldDeliver(final Publisher<Row> publisher, final int numRows) {\n+    TestSubscriber<Row> subscriber = new TestSubscriber<Row>() {\n+      @Override\n+      public synchronized void onSubscribe(final Subscription sub) {\n+        super.onSubscribe(sub);\n+        sub.request(numRows);\n+      }\n+    };\n+    publisher.subscribe(subscriber);\n+    assertThatEventually(subscriber::getValues, hasSize(numRows));\n+    for (int i = 0; i < numRows; i++) {\n+      assertThat(subscriber.getValues().get(i).values(), equalTo(rowWithIndex(i).getList()));\n+    }\n+    assertThat(subscriber.isCompleted(), equalTo(false));\n+    assertThat(subscriber.getError(), is(nullValue()));\n+  }\n+\n+  private void assertErrorWhen(\n+      final Supplier<CompletableFuture<?>> queryRequest,\n+      final String... errorMessages\n+  ) throws Exception {\n+    // Given\n+    CountDownLatch latch = new CountDownLatch(1);\n+", "originalCommit": "461c00aec7e633e8dd0a6fc8c3865e659e3636df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0MjA1Mw==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417142053", "bodyText": "Updated. I do think this is cleaner, though it's a bit odd that the expected exception type is always ExecutionException since that's what's thrown when .get() is called on a future that completes exceptionally. Added comments inline to avoid confusion.", "author": "vcrfxia", "createdAt": "2020-04-29T08:16:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU2NzczNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzIzMjQxNw==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417232417", "bodyText": "Yeah ExecutionException wrapping can be a pain. I think the reasoning is that any exceptions that are thrown from inside completable future handlers will be wrapped in an ExecutionException, Any exceptions thrown internally from the completablefuture framework itself, are not wrapped in ExecutionException, so it's a way of distinguishing the two kinds of exceptions.", "author": "purplefox", "createdAt": "2020-04-29T11:03:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU2NzczNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU2ODMwOQ==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416568309", "bodyText": "This and the rest of the methods should be synchronized as the results will be retrieved from a different thread.", "author": "purplefox", "createdAt": "2020-04-28T12:23:32Z", "path": "ksqldb-api-client/src/test/java/io/confluent/ksql/api/client/ClientTest.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client;\n+\n+import static io.confluent.ksql.test.util.AssertEventually.assertThatEventually;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.notNullValue;\n+import static org.hamcrest.Matchers.nullValue;\n+\n+import io.confluent.ksql.api.BaseApiTest;\n+import io.confluent.ksql.api.client.impl.ClientImpl;\n+import io.confluent.ksql.api.client.impl.ClientOptionsImpl;\n+import io.confluent.ksql.api.server.PushQueryId;\n+import io.confluent.ksql.parser.exception.ParseFailedException;\n+import io.vertx.core.Context;\n+import io.vertx.ext.web.client.WebClient;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+import org.junit.Test;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+public class ClientTest extends BaseApiTest {\n+\n+  @SuppressWarnings(\"unchecked\")\n+  protected static final List<String> DEFAULT_COLUMN_NAMES = BaseApiTest.DEFAULT_COLUMN_NAMES.getList();\n+  @SuppressWarnings(\"unchecked\")\n+  protected static final List<String> DEFAULT_COLUMN_TYPES = BaseApiTest.DEFAULT_COLUMN_TYPES.getList();\n+  protected static final Map<String, Object> DEFAULT_PUSH_QUERY_REQUEST_PROPERTIES =\n+      BaseApiTest.DEFAULT_PUSH_QUERY_REQUEST_PROPERTIES.getMap();\n+\n+  protected Context context;\n+  protected Client client;\n+\n+  @Override\n+  public void setUp() {\n+    super.setUp();\n+\n+    context = vertx.getOrCreateContext();\n+  }\n+\n+  @Override\n+  protected WebClient createClient() {\n+    // Use Java client for these tests, rather than a vanilla WebClient\n+    this.client = createJavaClient();\n+\n+    return null;\n+  }\n+\n+  @Override\n+  protected void stopClient() {\n+    if (client != null) {\n+      try {\n+        client.close();\n+      } catch (Exception e) {\n+        log.error(\"Failed to close client\", e);\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void shouldStreamQueryAsync() throws Exception {\n+    // When\n+    final CompletableFuture<QueryResult> cf = client.streamQuery(DEFAULT_PUSH_QUERY, DEFAULT_PUSH_QUERY_REQUEST_PROPERTIES);\n+    assertThatEventually(cf::isDone, equalTo(true));\n+    assertThat(cf.isCompletedExceptionally(), equalTo(false));\n+    final QueryResult queryResult = cf.get();\n+\n+    // Then\n+    verifyPushQueryMetadata(queryResult);\n+\n+    shouldDeliver(queryResult, DEFAULT_ROWS.size());\n+  }\n+\n+  @Test\n+  public void shouldStreamQuerySync() throws Exception {\n+    // When\n+    final CompletableFuture<QueryResult> cf = client.streamQuery(DEFAULT_PUSH_QUERY, DEFAULT_PUSH_QUERY_REQUEST_PROPERTIES);\n+    assertThatEventually(cf::isDone, equalTo(true));\n+    assertThat(cf.isCompletedExceptionally(), equalTo(false));\n+    final QueryResult queryResult = cf.get();\n+\n+    // Then\n+    verifyPushQueryMetadata(queryResult);\n+\n+    for (int i = 0; i < DEFAULT_ROWS.size(); i++) {\n+      final Row row = queryResult.poll();\n+      assertThat(row.values(), equalTo(rowWithIndex(i).getList()));\n+      assertThat(row.columnNames(), equalTo(DEFAULT_COLUMN_NAMES));\n+      assertThat(row.columnTypes(), equalTo(DEFAULT_COLUMN_TYPES));\n+    }\n+  }\n+\n+  @Test\n+  public void shouldHandleErrorResponseFromStreamQuery() throws Exception {\n+    // Given\n+    ParseFailedException pfe = new ParseFailedException(\"invalid query blah\");\n+    testEndpoints.setCreateQueryPublisherException(pfe);\n+\n+    // When/Then\n+    assertErrorWhen(\n+        () -> client.streamQuery(\"bad query\", DEFAULT_PUSH_QUERY_REQUEST_PROPERTIES),\n+        \"Received 400 response from server\",\n+        \"invalid query blah\"\n+    );\n+  }\n+\n+  @Test\n+  public void shouldFailStreamQueryOnPullQuery() throws Exception {\n+    assertErrorWhen(\n+        () -> client.streamQuery(DEFAULT_PULL_QUERY),\n+        \"Expecting push query but was pull query\"\n+    );\n+  }\n+\n+  @Test\n+  public void shouldExecutePullQuery() throws Exception {\n+    // When\n+    final CompletableFuture<List<Row>> cf = client.executeQuery(DEFAULT_PULL_QUERY);\n+    assertThatEventually(cf::isDone, equalTo(true));\n+    assertThat(cf.isCompletedExceptionally(), equalTo(false));\n+    final List<Row> rows = cf.get();\n+\n+    // Then\n+    assertThat(testEndpoints.getLastSql(), is(DEFAULT_PULL_QUERY));\n+    assertThat(testEndpoints.getLastProperties().getMap(), is(Collections.emptyMap()));\n+\n+    assertThat(rows, hasSize(DEFAULT_ROWS.size()));\n+    for (int i = 0; i < DEFAULT_ROWS.size(); i++) {\n+      assertThat(rows.get(i).values(), equalTo(rowWithIndex(i).getList()));\n+      assertThat(rows.get(i).columnNames(), equalTo(DEFAULT_COLUMN_NAMES));\n+      assertThat(rows.get(i).columnTypes(), equalTo(DEFAULT_COLUMN_TYPES));\n+    }\n+\n+    assertThat(server.getQueryIDs(), hasSize(0));\n+  }\n+\n+  @Test\n+  public void shouldHandleErrorResponseFromExecuteQuery() throws Exception {\n+    // Given\n+    ParseFailedException pfe = new ParseFailedException(\"invalid query blah\");\n+    testEndpoints.setCreateQueryPublisherException(pfe);\n+\n+    // When/Then\n+    assertErrorWhen(\n+        () -> client.executeQuery(\"bad query\"),\n+        \"Received 400 response from server\",\n+        \"invalid query blah\"\n+    );\n+  }\n+\n+  @Test\n+  public void shouldFailExecuteQueryOnPushQuery() throws Exception {\n+    assertErrorWhen(\n+        () -> client.executeQuery(DEFAULT_PUSH_QUERY),\n+        \"Expecting pull query but was push query\"\n+    );\n+  }\n+\n+  protected Client createJavaClient() {\n+    return new ClientImpl(createJavaClientOptions(), vertx);\n+  }\n+\n+  protected ClientOptions createJavaClientOptions() {\n+    return new ClientOptionsImpl()\n+        .setHost(\"localhost\")\n+        .setPort(server.getListeners().get(0).getPort())\n+        .setUseTls(false);\n+  }\n+\n+  private void verifyPushQueryMetadata(final QueryResult queryResult) {\n+    assertThat(testEndpoints.getLastSql(), is(DEFAULT_PUSH_QUERY));\n+    assertThat(testEndpoints.getLastProperties(), is(BaseApiTest.DEFAULT_PUSH_QUERY_REQUEST_PROPERTIES));\n+\n+    assertThat(queryResult.columnNames(), is(DEFAULT_COLUMN_NAMES));\n+    assertThat(queryResult.columnTypes(), is(DEFAULT_COLUMN_TYPES));\n+\n+    String queryId = queryResult.queryID();\n+    assertThat(queryId, is(notNullValue()));\n+    assertThat(server.getQueryIDs(), hasSize(1));\n+    assertThat(server.getQueryIDs().contains(new PushQueryId(queryId)), is(true));\n+  }\n+\n+  private void shouldDeliver(final Publisher<Row> publisher, final int numRows) {\n+    TestSubscriber<Row> subscriber = new TestSubscriber<Row>() {\n+      @Override\n+      public synchronized void onSubscribe(final Subscription sub) {\n+        super.onSubscribe(sub);\n+        sub.request(numRows);\n+      }\n+    };\n+    publisher.subscribe(subscriber);\n+    assertThatEventually(subscriber::getValues, hasSize(numRows));\n+    for (int i = 0; i < numRows; i++) {\n+      assertThat(subscriber.getValues().get(i).values(), equalTo(rowWithIndex(i).getList()));\n+    }\n+    assertThat(subscriber.isCompleted(), equalTo(false));\n+    assertThat(subscriber.getError(), is(nullValue()));\n+  }\n+\n+  private void assertErrorWhen(\n+      final Supplier<CompletableFuture<?>> queryRequest,\n+      final String... errorMessages\n+  ) throws Exception {\n+    // Given\n+    CountDownLatch latch = new CountDownLatch(1);\n+\n+    // When\n+    final CompletableFuture<?> cf = queryRequest.get()\n+        .exceptionally(error -> {\n+\n+          // Then\n+          assertThat(error, notNullValue());\n+          for (final String msg : errorMessages) {\n+            assertThat(error.getMessage(), containsString(msg));\n+          }\n+\n+          latch.countDown();\n+          return null;\n+        });\n+    awaitLatch(latch, cf);\n+  }\n+\n+  private static void awaitLatch(CountDownLatch latch, CompletableFuture<?> cf) throws Exception {\n+    // Log reason for any failures, else output of failed tests is uninformative\n+    cf.exceptionally(failure -> {\n+      System.out.println(\"Failure reason: \" + failure.getMessage());\n+      return null;\n+    });\n+\n+    awaitLatch(latch);\n+  }\n+\n+  private static void awaitLatch(CountDownLatch latch) throws Exception {\n+    assertThat(latch.await(2000, TimeUnit.MILLISECONDS), is(true));\n+  }\n+\n+  private static class TestSubscriber<T> implements Subscriber<T> {\n+\n+    private Subscription sub;\n+    private boolean completed;\n+    private Throwable error;\n+    private final List<T> values = new ArrayList<>();\n+\n+    public TestSubscriber() {\n+    }\n+\n+    @Override\n+    public synchronized void onSubscribe(final Subscription sub) {\n+      this.sub = sub;\n+    }\n+\n+    @Override\n+    public synchronized void onNext(final T value) {\n+      values.add(value);\n+    }\n+\n+    @Override\n+    public synchronized void onError(final Throwable t) {\n+      this.error = t;\n+    }\n+\n+    @Override\n+    public synchronized void onComplete() {\n+      this.completed = true;\n+    }\n+\n+    public boolean isCompleted() {", "originalCommit": "461c00aec7e633e8dd0a6fc8c3865e659e3636df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0MjEyOA==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417142128", "bodyText": "Done.", "author": "vcrfxia", "createdAt": "2020-04-29T08:16:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU2ODMwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU2OTgwNg==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416569806", "bodyText": "Imho I would like to see these kinds of tests conducted using the actual API and no mocks.\nAs you know I'm not a fan of fine grained unit tests and mocks as they can constrain the implementation, and often what you're testing doesn't really correspond to what the system really does thus resulting in bugs slipping through and a false sense of security.", "author": "purplefox", "createdAt": "2020-04-28T12:25:53Z", "path": "ksqldb-api-client/src/test/java/io/confluent/ksql/api/client/impl/QueryResultImplTest.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client.impl;\n+\n+import static org.junit.Assert.assertThrows;\n+\n+import io.confluent.ksql.api.client.Row;\n+import io.vertx.core.Context;\n+import java.util.Collections;\n+import java.util.concurrent.TimeUnit;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+import org.reactivestreams.Subscriber;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class QueryResultImplTest {\n+\n+  @Mock\n+  private Context context;\n+  @Mock\n+  private Subscriber<Row> subscriber;\n+\n+  private QueryResultImpl queryResult;\n+\n+  @Before\n+  public void setUp() {\n+    queryResult = new QueryResultImpl(context, \"queryId\", Collections.emptyList(), Collections.emptyList());\n+  }\n+\n+  @Test\n+  public void shouldNotSubscribeIfPolling() {", "originalCommit": "461c00aec7e633e8dd0a6fc8c3865e659e3636df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0NDA1MA==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417144050", "bodyText": "Sure, I'll add equivalent tests to ClientTest as part of revamping / improving test coverage. My vote is to leave these unit tests in place, though, until we see them become brittle. I think it's useful to be able to scan a test file and understand the key pieces of functionality for a class without having to dig through integration tests. Though I guess Java docs on the class/interface itself should serve this purpose in most cases, so maybe that's not a good reason...", "author": "vcrfxia", "createdAt": "2020-04-29T08:20:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU2OTgwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzMwMzM1OQ==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417303359", "bodyText": "As long as there's equivalent test coverage on the actual API I think that's fine. And as long as you won't be upset if I end up deleting them after spending an hour trying to refactor them if the implementation changes ;)", "author": "purplefox", "createdAt": "2020-04-29T13:13:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU2OTgwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQzMzU5MA==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r422433590", "bodyText": "Update: going to add these additional tests in a follow-up PR.\n\nAnd as long as you won't be upset if I end up deleting them after spending an hour trying to refactor them if the implementation changes ;)\n\nFine by me ;)", "author": "vcrfxia", "createdAt": "2020-05-09T00:52:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU2OTgwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU3MDk4Ng==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r416570986", "bodyText": "Again, not a fan of fine grained unit tests. I'd prefer to see the behaviour of a row tested on instance of Row interface returned from the actual API rather than the particular implementation RowImpl. If we later change the implementation these kinds of tests get very brittle and hard to refactor whereas tests that test against the interface don't.", "author": "purplefox", "createdAt": "2020-04-28T12:27:37Z", "path": "ksqldb-api-client/src/test/java/io/confluent/ksql/api/client/impl/RowImplTest.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client.impl;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+\n+import com.google.common.collect.ImmutableList;\n+import io.vertx.core.json.JsonArray;\n+import java.util.List;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class RowImplTest {", "originalCommit": "461c00aec7e633e8dd0a6fc8c3865e659e3636df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0NDEyMA==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r417144120", "bodyText": "As above.", "author": "vcrfxia", "createdAt": "2020-04-29T08:20:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU3MDk4Ng=="}], "type": "inlineReview"}, {"oid": "6a169a04042a9650daf9286706a7deff4bffba9d", "url": "https://github.com/confluentinc/ksql/commit/6a169a04042a9650daf9286706a7deff4bffba9d", "message": "chore: checkstyle", "committedDate": "2020-04-28T21:42:48Z", "type": "commit"}, {"oid": "c2c2c55911ad6b77697c31d9da6c0726511b8058", "url": "https://github.com/confluentinc/ksql/commit/c2c2c55911ad6b77697c31d9da6c0726511b8058", "message": "chore: allow push and pull queries via both streaming and exec", "committedDate": "2020-04-28T22:49:22Z", "type": "commit"}, {"oid": "ec989636d680b75ef8e9f22016781a1c5acb714a", "url": "https://github.com/confluentinc/ksql/commit/ec989636d680b75ef8e9f22016781a1c5acb714a", "message": "chore: feedback", "committedDate": "2020-04-28T23:20:24Z", "type": "commit"}, {"oid": "5771d712958007e1dbbcc5ac613b4c74ea8c02f6", "url": "https://github.com/confluentinc/ksql/commit/5771d712958007e1dbbcc5ac613b4c74ea8c02f6", "message": "chore: allow nulls in ClientOptions", "committedDate": "2020-04-28T23:20:46Z", "type": "commit"}, {"oid": "02fbc871e20d8493ab574d96ead47348903084f1", "url": "https://github.com/confluentinc/ksql/commit/02fbc871e20d8493ab574d96ead47348903084f1", "message": "chore: static json mapper", "committedDate": "2020-04-29T06:25:44Z", "type": "commit"}, {"oid": "d4f7f413563fcf200c7d989dc3494b7d5943a326", "url": "https://github.com/confluentinc/ksql/commit/d4f7f413563fcf200c7d989dc3494b7d5943a326", "message": "chore: fix synchronization in PollableSubscriber", "committedDate": "2020-04-29T06:55:39Z", "type": "commit"}, {"oid": "21c59fdc456d423088d56fc425189a1deb26d1ac", "url": "https://github.com/confluentinc/ksql/commit/21c59fdc456d423088d56fc425189a1deb26d1ac", "message": "test: clean up negative tests in ClientTest", "committedDate": "2020-04-29T07:05:32Z", "type": "commit"}, {"oid": "40e3582db859d97db5dd9d4a49a541bd4a1ce541", "url": "https://github.com/confluentinc/ksql/commit/40e3582db859d97db5dd9d4a49a541bd4a1ce541", "message": "test: more ClientTest cleanup", "committedDate": "2020-04-29T07:10:42Z", "type": "commit"}, {"oid": "13722fe463ba1d19069fd722fb11ba24e9078773", "url": "https://github.com/confluentinc/ksql/commit/13722fe463ba1d19069fd722fb11ba24e9078773", "message": "chore: creator for ClientOptions", "committedDate": "2020-04-29T07:40:50Z", "type": "commit"}, {"oid": "553ecf2846c2c938f8b0a3a6afdd4438afec6207", "url": "https://github.com/confluentinc/ksql/commit/553ecf2846c2c938f8b0a3a6afdd4438afec6207", "message": "chore: don't create basic auth header on each request", "committedDate": "2020-04-29T07:58:11Z", "type": "commit"}, {"oid": "c58782c7180fc30987d72cca62aa2195a82737aa", "url": "https://github.com/confluentinc/ksql/commit/c58782c7180fc30987d72cca62aa2195a82737aa", "message": "fix: basic auth", "committedDate": "2020-05-03T20:28:56Z", "type": "commit"}, {"oid": "1073dbbdbd9557cb04c488ffa89aac4eb542df6e", "url": "https://github.com/confluentinc/ksql/commit/1073dbbdbd9557cb04c488ffa89aac4eb542df6e", "message": "chore: handle record parser exception", "committedDate": "2020-05-04T06:36:41Z", "type": "commit"}, {"oid": "0f990c9346bc00f934c88fee56e7965121a8f791", "url": "https://github.com/confluentinc/ksql/commit/0f990c9346bc00f934c88fee56e7965121a8f791", "message": "fix: synchronization in QueryResultImpl", "committedDate": "2020-05-04T07:05:42Z", "type": "commit"}, {"oid": "904476714df0a29fc17e6cf8ebf38f3e898105f8", "url": "https://github.com/confluentinc/ksql/commit/904476714df0a29fc17e6cf8ebf38f3e898105f8", "message": "feat: tls tests", "committedDate": "2020-05-09T00:13:33Z", "type": "commit"}, {"oid": "8ad66e85a9aa2ba6f4b00e9f87625b7b164860e7", "url": "https://github.com/confluentinc/ksql/commit/8ad66e85a9aa2ba6f4b00e9f87625b7b164860e7", "message": "chore: checkstyle", "committedDate": "2020-05-09T00:13:33Z", "type": "commit"}, {"oid": "dff2ffbf0b715d722df53f148e9cad7d9c17aca5", "url": "https://github.com/confluentinc/ksql/commit/dff2ffbf0b715d722df53f148e9cad7d9c17aca5", "message": "fix: implement isComplete() on QueryResult", "committedDate": "2020-05-09T00:13:33Z", "type": "commit"}, {"oid": "1ac08f6a52421c86b838d5d5488ef87f32240d7b", "url": "https://github.com/confluentinc/ksql/commit/1ac08f6a52421c86b838d5d5488ef87f32240d7b", "message": "chore: limit number of rows that may be returned from executeQuery()", "committedDate": "2020-05-09T00:28:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQzNDgyNg==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r422434826", "bodyText": "These additional TLS options were needed to get the tests working. In a follow-up PR they'll either be removed in favor of exposing Vert.x HttpClientOptions (pending discussion in #5200 (comment)) or I'll refactor all the TLS options into a separate interface in order to clean up this one.", "author": "vcrfxia", "createdAt": "2020-05-09T01:01:33Z", "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/ClientOptions.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client;\n+\n+import io.confluent.ksql.api.client.impl.ClientOptionsImpl;\n+\n+public interface ClientOptions {\n+\n+  ClientOptions setHost(String host);\n+\n+  ClientOptions setPort(int port);\n+\n+  ClientOptions setUseTls(boolean useTls);\n+\n+  ClientOptions setUseClientAuth(boolean useClientAuth);\n+\n+  ClientOptions setVerifyHost(boolean verifyHost);", "originalCommit": "1ac08f6a52421c86b838d5d5488ef87f32240d7b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "dbdfcec226ac806a5b112353e85ecc7fb3445b5c", "url": "https://github.com/confluentinc/ksql/commit/dbdfcec226ac806a5b112353e85ecc7fb3445b5c", "message": "Merge branch 'master' into java-client", "committedDate": "2020-05-09T04:31:23Z", "type": "commit"}, {"oid": "bb5ac44de13c569fd327bcc6731f56ec30d2d7eb", "url": "https://github.com/confluentinc/ksql/commit/bb5ac44de13c569fd327bcc6731f56ec30d2d7eb", "message": "chore: findbugs", "committedDate": "2020-05-09T05:48:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY5Njc3OA==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r422696778", "bodyText": "@vcrfxia As mentioned on the KLIP: why do we not use Duration instead?", "author": "mjsax", "createdAt": "2020-05-10T20:34:23Z", "path": "ksqldb-api-client/src/main/java/io/confluent/ksql/api/client/QueryResult.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.client;\n+\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import org.reactivestreams.Publisher;\n+\n+/**\n+ * The result of a query (push or pull), streamed one row at time. Records may be consumed by either\n+ * subscribing to the publisher or polling (blocking) for one record at a time. These two methods of\n+ * consumption are mutually exclusive; only one method may be used (per QueryResult).\n+ */\n+public interface QueryResult extends Publisher<Row> {\n+\n+  List<String> columnNames();\n+\n+  List<String> columnTypes();\n+\n+  String queryID();\n+\n+  /**\n+   * Block until a row becomes available.\n+   *\n+   * @return the row.\n+   */\n+  Row poll();\n+\n+  /**\n+   * Block until a row becomes available or the timeout has elapsed.\n+   *\n+   * @param timeout amount of to wait for a row. Non-positive values are interpreted as no timeout.\n+   * @param timeUnit unit for timeout param.\n+   * @return the row, if available; else, null.\n+   */\n+  Row poll(long timeout, TimeUnit timeUnit);", "originalCommit": "bb5ac44de13c569fd327bcc6731f56ec30d2d7eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjc2ODE2Nw==", "url": "https://github.com/confluentinc/ksql/pull/5200#discussion_r422768167", "bodyText": "Thanks for the bump. I've updated the KLIP and will update the code in a future PR (along with a multitude of other feedback from the KLIP).", "author": "vcrfxia", "createdAt": "2020-05-11T04:06:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY5Njc3OA=="}], "type": "inlineReview"}]}