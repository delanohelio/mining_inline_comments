{"pr_number": 6814, "pr_title": "feat: Move WHERE clause handling for pull queries into logical plan", "pr_createdAt": "2020-12-22T18:39:43Z", "pr_url": "https://github.com/confluentinc/ksql/pull/6814", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ0NzA4Ng==", "url": "https://github.com/confluentinc/ksql/pull/6814#discussion_r551447086", "bodyText": "Why catch everything here?  There's already a catch all above in HARouting:\ntry {\n  future.get();\n} catch (ExecutionException e) {\n  LOG.warn(\"Error routing query {} to host {} at timestamp {} with exception {}\",\n     statement.getStatementText(), node, System.currentTimeMillis(), e.getCause());\n nextRoundRemaining.addAll(groupedByHost.get(node));\n}", "author": "AlanConfluent", "createdAt": "2021-01-04T17:06:41Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/physical/pull/HARouting.java", "diffHunk": "@@ -246,17 +246,37 @@ static PullQueryResult executeOrRouteQuery(\n   ) {\n     List<List<?>> rows = null;\n     if (node.isLocal()) {\n-      LOG.debug(\"Query {} executed locally at host {} at timestamp {}.\",\n-                statement.getStatementText(), node.location(), System.currentTimeMillis());\n-      pullQueryMetrics\n-          .ifPresent(queryExecutorMetrics -> queryExecutorMetrics.recordLocalRequests(1));\n-      rows = pullPhysicalPlan.execute(locations);\n+      try {\n+        LOG.debug(\"Query {} executed locally at host {} at timestamp {}.\",\n+                  statement.getStatementText(), node.location(), System.currentTimeMillis());\n+        pullQueryMetrics\n+            .ifPresent(queryExecutorMetrics -> queryExecutorMetrics.recordLocalRequests(1));\n+        rows = pullPhysicalPlan.execute(locations);\n+      } catch (Exception e) {", "originalCommit": "6f2567921c98122f89e8651df08ec125648e74d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA3ODEzNw==", "url": "https://github.com/confluentinc/ksql/pull/6814#discussion_r553078137", "bodyText": "It catches all because I don't know what kind of exceptions can be throw, it can be from materialization, from streams, from the code gen, from ksql. Also, It catches and then throws a KsqlException so what is the problem? We know that the exception has to do only with physical plan execution so it's not like it will catch something it shouldn't", "author": "vpapavas", "createdAt": "2021-01-07T02:43:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ0NzA4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ0NzY4MQ==", "url": "https://github.com/confluentinc/ksql/pull/6814#discussion_r551447681", "bodyText": "Is this a check for Row.EMPTY_ROW?  Why not check equality with that object if it's a special value?", "author": "AlanConfluent", "createdAt": "2021-01-04T17:07:49Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/physical/pull/PullPhysicalPlan.java", "diffHunk": "@@ -68,7 +68,9 @@ public PullPhysicalPlan(\n     final List<List<?>> localResult = new ArrayList<>();\n     List<?> row = null;\n     while ((row = (List<?>)next()) != null) {\n-      localResult.add(row);\n+      if (!row.isEmpty()) {", "originalCommit": "6f2567921c98122f89e8651df08ec125648e74d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA3OTQ0NA==", "url": "https://github.com/confluentinc/ksql/pull/6814#discussion_r553079444", "bodyText": "Removed the empty row", "author": "vpapavas", "createdAt": "2021-01-07T02:48:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ0NzY4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ1MDAyMQ==", "url": "https://github.com/confluentinc/ksql/pull/6814#discussion_r551450021", "bodyText": "I personally find it a little confusing that in some areas, we use DB language (e.g. select) and in others we use functional programming language (e.g. filter).  Can we try to be consistent?", "author": "AlanConfluent", "createdAt": "2021-01-04T17:11:56Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/physical/pull/PullPhysicalPlanBuilder.java", "diffHunk": "@@ -179,30 +161,27 @@ private ProjectOperator translateProjectNode(final PullProjectNode logicalNode)\n     );\n   }\n \n-  private SelectOperator translateFilterNode(final FilterNode logicalNode) {\n-    final boolean windowed = persistentQueryMetadata.getResultTopic().getKeyFormat().isWindowed();\n-    whereInfo = WhereInfo.extractWhereInfo(\n-        analysis.getWhereExpression().orElseThrow(\n-            () -> WhereInfo.invalidWhereClauseException(\"Missing WHERE clause\", windowed)),\n-        persistentQueryMetadata.getLogicalSchema(),\n-        windowed,\n-        metaStore,\n-        config);\n-    return new SelectOperator(logicalNode);\n+  private SelectOperator translateFilterNode(final PullFilterNode logicalNode) {\n+    isWindowed = logicalNode.isWindowed();\n+    keys = logicalNode.getKeyValues();\n+    windowBounds = logicalNode.getWindowBounds();\n+\n+    final ProcessingLogger logger = processingLogContext\n+        .getLoggerFactory()\n+        .getLogger(\n+            QueryLoggerUtil.queryLoggerName(\n+                QueryType.PULL_QUERY, contextStacker.push(\"SELECT\").getQueryContext())", "originalCommit": "6f2567921c98122f89e8651df08ec125648e74d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA3NzU1Ng==", "url": "https://github.com/confluentinc/ksql/pull/6814#discussion_r553077556", "bodyText": "Yeah I agree but this is what the existing code already does so I am trying to be consistent with persistent queries", "author": "vpapavas", "createdAt": "2021-01-07T02:40:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ1MDAyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ1MTQ1OQ==", "url": "https://github.com/confluentinc/ksql/pull/6814#discussion_r551451459", "bodyText": "nit: space after cast?", "author": "AlanConfluent", "createdAt": "2021-01-04T17:14:32Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/physical/pull/operators/SelectOperator.java", "diffHunk": "@@ -15,28 +15,82 @@\n \n package io.confluent.ksql.physical.pull.operators;\n \n-import io.confluent.ksql.planner.plan.FilterNode;\n+import com.google.common.annotations.VisibleForTesting;\n+import io.confluent.ksql.GenericRow;\n+import io.confluent.ksql.execution.streams.SqlPredicateFactory;\n+import io.confluent.ksql.execution.streams.materialization.PullProcessingContext;\n+import io.confluent.ksql.execution.streams.materialization.Row;\n+import io.confluent.ksql.execution.streams.materialization.TableRow;\n+import io.confluent.ksql.execution.streams.materialization.WindowedRow;\n+import io.confluent.ksql.execution.transform.KsqlTransformer;\n+import io.confluent.ksql.execution.transform.sqlpredicate.SqlPredicate;\n+import io.confluent.ksql.logging.processing.ProcessingLogger;\n import io.confluent.ksql.planner.plan.PlanNode;\n+import io.confluent.ksql.planner.plan.PullFilterNode;\n import java.util.List;\n import java.util.Objects;\n+import java.util.Optional;\n \n public class SelectOperator extends AbstractPhysicalOperator implements UnaryPhysicalOperator {\n \n-  private final FilterNode logicalNode;\n+  private final PullFilterNode logicalNode;\n+  private final ProcessingLogger logger;\n+  private final SqlPredicate predicate;\n+\n   private AbstractPhysicalOperator child;\n+  private KsqlTransformer<Object, Optional<GenericRow>> transformer;\n+  private TableRow row;\n+\n+  public SelectOperator(final PullFilterNode logicalNode, final ProcessingLogger logger) {\n+    this(logicalNode, logger, SqlPredicate::new);\n+  }\n \n-  public SelectOperator(final FilterNode logicalNode) {\n-    this.logicalNode = Objects.requireNonNull(logicalNode);\n+  @VisibleForTesting\n+  SelectOperator(\n+      final PullFilterNode logicalNode,\n+      final ProcessingLogger logger,\n+      final SqlPredicateFactory predicateFactory\n+  ) {\n+    this.logicalNode = Objects.requireNonNull(logicalNode, \"logicalNode\");\n+    this.logger = Objects.requireNonNull(logger, \"logger\");\n+    this.predicate = predicateFactory.create(\n+        logicalNode.getRewrittenPredicate(),\n+        logicalNode.getCompiledWhereClause()\n+    );\n   }\n \n+\n   @Override\n   public void open() {\n+    transformer = predicate.getTransformer(logger);\n     child.open();\n   }\n \n   @Override\n   public Object next() {\n-    return child.next();\n+    row = (TableRow)child.next();", "originalCommit": "6f2567921c98122f89e8651df08ec125648e74d1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ1MzgxNg==", "url": "https://github.com/confluentinc/ksql/pull/6814#discussion_r551453816", "bodyText": "Why not return null if we're at the end, or child.next if not.  That way you don't have to introduce another \"special\" value to check for.  You can put the whole block in a while (row != null) and return null otherwise.  We already do this in the other operators.\nOtherwise, you're exposing internal state that isn't meaningful to the caller.", "author": "AlanConfluent", "createdAt": "2021-01-04T17:18:34Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/physical/pull/operators/SelectOperator.java", "diffHunk": "@@ -15,28 +15,82 @@\n \n package io.confluent.ksql.physical.pull.operators;\n \n-import io.confluent.ksql.planner.plan.FilterNode;\n+import com.google.common.annotations.VisibleForTesting;\n+import io.confluent.ksql.GenericRow;\n+import io.confluent.ksql.execution.streams.SqlPredicateFactory;\n+import io.confluent.ksql.execution.streams.materialization.PullProcessingContext;\n+import io.confluent.ksql.execution.streams.materialization.Row;\n+import io.confluent.ksql.execution.streams.materialization.TableRow;\n+import io.confluent.ksql.execution.streams.materialization.WindowedRow;\n+import io.confluent.ksql.execution.transform.KsqlTransformer;\n+import io.confluent.ksql.execution.transform.sqlpredicate.SqlPredicate;\n+import io.confluent.ksql.logging.processing.ProcessingLogger;\n import io.confluent.ksql.planner.plan.PlanNode;\n+import io.confluent.ksql.planner.plan.PullFilterNode;\n import java.util.List;\n import java.util.Objects;\n+import java.util.Optional;\n \n public class SelectOperator extends AbstractPhysicalOperator implements UnaryPhysicalOperator {\n \n-  private final FilterNode logicalNode;\n+  private final PullFilterNode logicalNode;\n+  private final ProcessingLogger logger;\n+  private final SqlPredicate predicate;\n+\n   private AbstractPhysicalOperator child;\n+  private KsqlTransformer<Object, Optional<GenericRow>> transformer;\n+  private TableRow row;\n+\n+  public SelectOperator(final PullFilterNode logicalNode, final ProcessingLogger logger) {\n+    this(logicalNode, logger, SqlPredicate::new);\n+  }\n \n-  public SelectOperator(final FilterNode logicalNode) {\n-    this.logicalNode = Objects.requireNonNull(logicalNode);\n+  @VisibleForTesting\n+  SelectOperator(\n+      final PullFilterNode logicalNode,\n+      final ProcessingLogger logger,\n+      final SqlPredicateFactory predicateFactory\n+  ) {\n+    this.logicalNode = Objects.requireNonNull(logicalNode, \"logicalNode\");\n+    this.logger = Objects.requireNonNull(logger, \"logger\");\n+    this.predicate = predicateFactory.create(\n+        logicalNode.getRewrittenPredicate(),\n+        logicalNode.getCompiledWhereClause()\n+    );\n   }\n \n+\n   @Override\n   public void open() {\n+    transformer = predicate.getTransformer(logger);\n     child.open();\n   }\n \n   @Override\n   public Object next() {\n-    return child.next();\n+    row = (TableRow)child.next();\n+    if (row == null) {\n+      return null;\n+    }\n+\n+    final GenericRow intermediate = PullPhysicalOperatorUtil.getIntermediateRow(\n+        row, logicalNode.getAddAdditionalColumnsToIntermediateSchema());\n+\n+    return transformer.transform(\n+        row.key(),\n+        intermediate,\n+        new PullProcessingContext(row.rowTime()))\n+        .map(r -> {\n+          if (logicalNode.isWindowed()) {\n+            return WindowedRow.of(\n+                logicalNode.getIntermediateSchema(),\n+                ((WindowedRow) row).windowedKey(),\n+                r,\n+                row.rowTime());\n+          }\n+          return Row.of(logicalNode.getIntermediateSchema(), row.key(), r, row.rowTime());\n+        })\n+        .orElse(Row.EMPTY_ROW);", "originalCommit": "6f2567921c98122f89e8651df08ec125648e74d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA3OTU0Mw==", "url": "https://github.com/confluentinc/ksql/pull/6814#discussion_r553079543", "bodyText": "Yes, I agree. I changed it", "author": "vpapavas", "createdAt": "2021-01-07T02:48:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ1MzgxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ2MDE0Ng==", "url": "https://github.com/confluentinc/ksql/pull/6814#discussion_r551460146", "bodyText": "I don't think you need to add this.", "author": "AlanConfluent", "createdAt": "2021-01-04T17:30:39Z", "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/Row.java", "diffHunk": "@@ -27,6 +27,8 @@\n \n public final class Row implements TableRow {\n \n+  public static final Row EMPTY_ROW = new Row();", "originalCommit": "6f2567921c98122f89e8651df08ec125648e74d1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ2NTIwOA==", "url": "https://github.com/confluentinc/ksql/pull/6814#discussion_r551465208", "bodyText": "nit: unnecessary parens?", "author": "AlanConfluent", "createdAt": "2021-01-04T17:40:43Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullFilterNode.java", "diffHunk": "@@ -0,0 +1,823 @@\n+/*\n+ * Copyright 2019 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.planner.plan;\n+\n+import com.google.common.collect.BoundType;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Range;\n+import io.confluent.ksql.GenericKey;\n+import io.confluent.ksql.analyzer.PullQueryValidator;\n+import io.confluent.ksql.engine.generic.GenericExpressionResolver;\n+import io.confluent.ksql.engine.rewrite.StatementRewriteForMagicPseudoTimestamp;\n+import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n+import io.confluent.ksql.execution.codegen.CodeGenRunner;\n+import io.confluent.ksql.execution.codegen.ExpressionMetadata;\n+import io.confluent.ksql.execution.expression.tree.ComparisonExpression;\n+import io.confluent.ksql.execution.expression.tree.ComparisonExpression.Type;\n+import io.confluent.ksql.execution.expression.tree.Expression;\n+import io.confluent.ksql.execution.expression.tree.InPredicate;\n+import io.confluent.ksql.execution.expression.tree.IntegerLiteral;\n+import io.confluent.ksql.execution.expression.tree.Literal;\n+import io.confluent.ksql.execution.expression.tree.LogicalBinaryExpression;\n+import io.confluent.ksql.execution.expression.tree.LongLiteral;\n+import io.confluent.ksql.execution.expression.tree.NullLiteral;\n+import io.confluent.ksql.execution.expression.tree.StringLiteral;\n+import io.confluent.ksql.execution.expression.tree.TraversalExpressionVisitor;\n+import io.confluent.ksql.execution.expression.tree.UnqualifiedColumnReferenceExp;\n+import io.confluent.ksql.metastore.MetaStore;\n+import io.confluent.ksql.name.ColumnName;\n+import io.confluent.ksql.schema.ksql.Column;\n+import io.confluent.ksql.schema.ksql.Column.Namespace;\n+import io.confluent.ksql.schema.ksql.DefaultSqlValueCoercer;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.SystemColumns;\n+import io.confluent.ksql.schema.utils.FormatOptions;\n+import io.confluent.ksql.structured.SchemaKStream;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.timestamp.PartialStringToTimestampParser;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.BitSet;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+public class PullFilterNode extends SingleSourcePlanNode {\n+\n+  private static final Set<Type> VALID_WINDOW_BOUND_COMPARISONS = ImmutableSet.of(\n+      Type.EQUAL,\n+      Type.GREATER_THAN,\n+      Type.GREATER_THAN_OR_EQUAL,\n+      Type.LESS_THAN,\n+      Type.LESS_THAN_OR_EQUAL\n+  );\n+\n+  private final boolean isWindowed;\n+  private final ExpressionMetadata compiledWhereClause;\n+  private final boolean addAdditionalColumnsToIntermediateSchema;\n+  private final LogicalSchema intermediateSchema;\n+  private final MetaStore metaStore;\n+  private final KsqlConfig ksqlConfig;\n+  private final LogicalSchema schema = getSource().getSchema();\n+\n+  private Expression rewrittenPredicate;\n+  private boolean isKeyedQuery = false;\n+  private Optional<WindowBounds> windowBounds;\n+  private List<GenericKey> keyValues;\n+  private Set<UnqualifiedColumnReferenceExp> keyColumns;\n+  private Set<UnqualifiedColumnReferenceExp> systemColumns;\n+  private List<GenericKey> inKeys;\n+  private BitSet seenKeys;\n+  private Object[] keyContents;\n+  private boolean containsINkeys;\n+\n+  public PullFilterNode(\n+      final PlanNodeId id,\n+      final PlanNode source,\n+      final Expression predicate,\n+      final MetaStore metaStore,\n+      final KsqlConfig ksqlConfig,\n+      final boolean isWindowed\n+  ) {\n+    super(id, source.getNodeOutputType(), source.getSourceName(), source);\n+\n+    Objects.requireNonNull(predicate, \"predicate\");\n+    this.metaStore = Objects.requireNonNull(metaStore, \"metaStore\");\n+    this.ksqlConfig = Objects.requireNonNull(ksqlConfig, \"ksqlConfig\");\n+    this.rewrittenPredicate = new StatementRewriteForMagicPseudoTimestamp().rewrite(predicate);\n+    this.isWindowed = isWindowed;\n+\n+    // Basic validation of WHERE clause\n+    validateWhereClause();\n+\n+    // Validation and extractions of window bounds\n+    windowBounds = isWindowed ? Optional.of(extractWindowBounds()) : Optional.empty();\n+\n+    // Extraction of key and system columns\n+    extractKeysAndSystemCols();\n+\n+    // Extraction of key values\n+    keyValues = extractKeyValues();\n+\n+    // Compiling expression into byte code\n+    this.addAdditionalColumnsToIntermediateSchema = shouldAddAdditionalColumnsInSchema();\n+    this.intermediateSchema = PullLogicalPlanUtil.buildIntermediateSchema(\n+        source.getSchema(), addAdditionalColumnsToIntermediateSchema, isWindowed);\n+    compiledWhereClause = CodeGenRunner.compileExpression(\n+        rewrittenPredicate,\n+        \"Predicate\",\n+        intermediateSchema,\n+        ksqlConfig,\n+        metaStore\n+    );\n+\n+  }\n+\n+  public Expression getRewrittenPredicate() {\n+    return rewrittenPredicate;\n+  }\n+\n+  @Override\n+  public LogicalSchema getSchema() {\n+    return getSource().getSchema();\n+  }\n+\n+  @Override\n+  public SchemaKStream<?> buildStream(final KsqlQueryBuilder builder) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  public ExpressionMetadata getCompiledWhereClause() {\n+    return compiledWhereClause;\n+  }\n+\n+  public boolean isKeyedQuery() {\n+    return isKeyedQuery;\n+  }\n+\n+  public boolean isWindowed() {\n+    return isWindowed;\n+  }\n+\n+  public List<GenericKey> getKeyValues() {\n+    return keyValues;\n+  }\n+\n+  public Set<UnqualifiedColumnReferenceExp> getKeyColumns() {\n+    return keyColumns;\n+  }\n+\n+  public Optional<WindowBounds> getWindowBounds() {\n+    return windowBounds;\n+  }\n+\n+  public boolean getAddAdditionalColumnsToIntermediateSchema() {\n+    return addAdditionalColumnsToIntermediateSchema;\n+  }\n+\n+  public LogicalSchema getIntermediateSchema() {\n+    return intermediateSchema;\n+  }\n+\n+  private void validateWhereClause() {\n+    seenKeys = new BitSet(schema.key().size());\n+    final Validator validator = new Validator();\n+    validator.process(rewrittenPredicate, null);\n+    if (!isKeyedQuery) {\n+      throw invalidWhereClauseException(\"WHERE clause missing key column\", isWindowed);\n+    }\n+\n+    if (!seenKeys.isEmpty() && seenKeys.cardinality() != schema.key().size()) {\n+      final List<ColumnName> seenKeyNames = seenKeys\n+          .stream()\n+          .boxed()\n+          .map(i -> schema.key().get(i))\n+          .map(Column::name)\n+          .collect(Collectors.toList());\n+      throw invalidWhereClauseException(\n+          \"Multi-column sources must specify every key in the WHERE clause. Specified: \"\n+              + seenKeyNames + \" Expected: \" + schema.key(), isWindowed);\n+    }\n+  }\n+\n+  private void extractKeysAndSystemCols() {\n+    keyColumns = new HashSet<>();\n+    systemColumns = new HashSet<>();\n+    new KeyAndSystemColsExtractor().process(rewrittenPredicate, null);\n+  }\n+\n+  private List<GenericKey> extractKeyValues() {\n+    inKeys = new ArrayList<>();\n+    keyContents = new Object[schema.key().size()];\n+    seenKeys = new BitSet(schema.key().size());\n+\n+    new KeyValueExtractor().process(rewrittenPredicate, null);\n+    if (!inKeys.isEmpty()) {\n+      return (inKeys);", "originalCommit": "6f2567921c98122f89e8651df08ec125648e74d1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ3MDUwNw==", "url": "https://github.com/confluentinc/ksql/pull/6814#discussion_r551470507", "bodyText": "From my understanding of reading the code, this is the list of possible in predicate values since just one in predicate is allowed whereas keyContents and seenKeys are solely set for comparisons, right?\nAlso, presumably, as before this change, multi column lookups are still only supported with comparisons, right?\nIt would be good to get a bit more comments that state these things because it's getting a bit hard to follow.", "author": "AlanConfluent", "createdAt": "2021-01-04T17:50:58Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullFilterNode.java", "diffHunk": "@@ -0,0 +1,823 @@\n+/*\n+ * Copyright 2019 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.planner.plan;\n+\n+import com.google.common.collect.BoundType;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Range;\n+import io.confluent.ksql.GenericKey;\n+import io.confluent.ksql.analyzer.PullQueryValidator;\n+import io.confluent.ksql.engine.generic.GenericExpressionResolver;\n+import io.confluent.ksql.engine.rewrite.StatementRewriteForMagicPseudoTimestamp;\n+import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n+import io.confluent.ksql.execution.codegen.CodeGenRunner;\n+import io.confluent.ksql.execution.codegen.ExpressionMetadata;\n+import io.confluent.ksql.execution.expression.tree.ComparisonExpression;\n+import io.confluent.ksql.execution.expression.tree.ComparisonExpression.Type;\n+import io.confluent.ksql.execution.expression.tree.Expression;\n+import io.confluent.ksql.execution.expression.tree.InPredicate;\n+import io.confluent.ksql.execution.expression.tree.IntegerLiteral;\n+import io.confluent.ksql.execution.expression.tree.Literal;\n+import io.confluent.ksql.execution.expression.tree.LogicalBinaryExpression;\n+import io.confluent.ksql.execution.expression.tree.LongLiteral;\n+import io.confluent.ksql.execution.expression.tree.NullLiteral;\n+import io.confluent.ksql.execution.expression.tree.StringLiteral;\n+import io.confluent.ksql.execution.expression.tree.TraversalExpressionVisitor;\n+import io.confluent.ksql.execution.expression.tree.UnqualifiedColumnReferenceExp;\n+import io.confluent.ksql.metastore.MetaStore;\n+import io.confluent.ksql.name.ColumnName;\n+import io.confluent.ksql.schema.ksql.Column;\n+import io.confluent.ksql.schema.ksql.Column.Namespace;\n+import io.confluent.ksql.schema.ksql.DefaultSqlValueCoercer;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.SystemColumns;\n+import io.confluent.ksql.schema.utils.FormatOptions;\n+import io.confluent.ksql.structured.SchemaKStream;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.timestamp.PartialStringToTimestampParser;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.BitSet;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+public class PullFilterNode extends SingleSourcePlanNode {\n+\n+  private static final Set<Type> VALID_WINDOW_BOUND_COMPARISONS = ImmutableSet.of(\n+      Type.EQUAL,\n+      Type.GREATER_THAN,\n+      Type.GREATER_THAN_OR_EQUAL,\n+      Type.LESS_THAN,\n+      Type.LESS_THAN_OR_EQUAL\n+  );\n+\n+  private final boolean isWindowed;\n+  private final ExpressionMetadata compiledWhereClause;\n+  private final boolean addAdditionalColumnsToIntermediateSchema;\n+  private final LogicalSchema intermediateSchema;\n+  private final MetaStore metaStore;\n+  private final KsqlConfig ksqlConfig;\n+  private final LogicalSchema schema = getSource().getSchema();\n+\n+  private Expression rewrittenPredicate;\n+  private boolean isKeyedQuery = false;\n+  private Optional<WindowBounds> windowBounds;\n+  private List<GenericKey> keyValues;\n+  private Set<UnqualifiedColumnReferenceExp> keyColumns;\n+  private Set<UnqualifiedColumnReferenceExp> systemColumns;\n+  private List<GenericKey> inKeys;\n+  private BitSet seenKeys;\n+  private Object[] keyContents;\n+  private boolean containsINkeys;\n+\n+  public PullFilterNode(\n+      final PlanNodeId id,\n+      final PlanNode source,\n+      final Expression predicate,\n+      final MetaStore metaStore,\n+      final KsqlConfig ksqlConfig,\n+      final boolean isWindowed\n+  ) {\n+    super(id, source.getNodeOutputType(), source.getSourceName(), source);\n+\n+    Objects.requireNonNull(predicate, \"predicate\");\n+    this.metaStore = Objects.requireNonNull(metaStore, \"metaStore\");\n+    this.ksqlConfig = Objects.requireNonNull(ksqlConfig, \"ksqlConfig\");\n+    this.rewrittenPredicate = new StatementRewriteForMagicPseudoTimestamp().rewrite(predicate);\n+    this.isWindowed = isWindowed;\n+\n+    // Basic validation of WHERE clause\n+    validateWhereClause();\n+\n+    // Validation and extractions of window bounds\n+    windowBounds = isWindowed ? Optional.of(extractWindowBounds()) : Optional.empty();\n+\n+    // Extraction of key and system columns\n+    extractKeysAndSystemCols();\n+\n+    // Extraction of key values\n+    keyValues = extractKeyValues();\n+\n+    // Compiling expression into byte code\n+    this.addAdditionalColumnsToIntermediateSchema = shouldAddAdditionalColumnsInSchema();\n+    this.intermediateSchema = PullLogicalPlanUtil.buildIntermediateSchema(\n+        source.getSchema(), addAdditionalColumnsToIntermediateSchema, isWindowed);\n+    compiledWhereClause = CodeGenRunner.compileExpression(\n+        rewrittenPredicate,\n+        \"Predicate\",\n+        intermediateSchema,\n+        ksqlConfig,\n+        metaStore\n+    );\n+\n+  }\n+\n+  public Expression getRewrittenPredicate() {\n+    return rewrittenPredicate;\n+  }\n+\n+  @Override\n+  public LogicalSchema getSchema() {\n+    return getSource().getSchema();\n+  }\n+\n+  @Override\n+  public SchemaKStream<?> buildStream(final KsqlQueryBuilder builder) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  public ExpressionMetadata getCompiledWhereClause() {\n+    return compiledWhereClause;\n+  }\n+\n+  public boolean isKeyedQuery() {\n+    return isKeyedQuery;\n+  }\n+\n+  public boolean isWindowed() {\n+    return isWindowed;\n+  }\n+\n+  public List<GenericKey> getKeyValues() {\n+    return keyValues;\n+  }\n+\n+  public Set<UnqualifiedColumnReferenceExp> getKeyColumns() {\n+    return keyColumns;\n+  }\n+\n+  public Optional<WindowBounds> getWindowBounds() {\n+    return windowBounds;\n+  }\n+\n+  public boolean getAddAdditionalColumnsToIntermediateSchema() {\n+    return addAdditionalColumnsToIntermediateSchema;\n+  }\n+\n+  public LogicalSchema getIntermediateSchema() {\n+    return intermediateSchema;\n+  }\n+\n+  private void validateWhereClause() {\n+    seenKeys = new BitSet(schema.key().size());\n+    final Validator validator = new Validator();\n+    validator.process(rewrittenPredicate, null);\n+    if (!isKeyedQuery) {\n+      throw invalidWhereClauseException(\"WHERE clause missing key column\", isWindowed);\n+    }\n+\n+    if (!seenKeys.isEmpty() && seenKeys.cardinality() != schema.key().size()) {\n+      final List<ColumnName> seenKeyNames = seenKeys\n+          .stream()\n+          .boxed()\n+          .map(i -> schema.key().get(i))\n+          .map(Column::name)\n+          .collect(Collectors.toList());\n+      throw invalidWhereClauseException(\n+          \"Multi-column sources must specify every key in the WHERE clause. Specified: \"\n+              + seenKeyNames + \" Expected: \" + schema.key(), isWindowed);\n+    }\n+  }\n+\n+  private void extractKeysAndSystemCols() {\n+    keyColumns = new HashSet<>();\n+    systemColumns = new HashSet<>();\n+    new KeyAndSystemColsExtractor().process(rewrittenPredicate, null);\n+  }\n+\n+  private List<GenericKey> extractKeyValues() {\n+    inKeys = new ArrayList<>();", "originalCommit": "6f2567921c98122f89e8651df08ec125648e74d1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ3MTIxMQ==", "url": "https://github.com/confluentinc/ksql/pull/6814#discussion_r551471211", "bodyText": "If this is only used in the validator, why not make it a field there?", "author": "AlanConfluent", "createdAt": "2021-01-04T17:52:24Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullFilterNode.java", "diffHunk": "@@ -0,0 +1,823 @@\n+/*\n+ * Copyright 2019 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.planner.plan;\n+\n+import com.google.common.collect.BoundType;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Range;\n+import io.confluent.ksql.GenericKey;\n+import io.confluent.ksql.analyzer.PullQueryValidator;\n+import io.confluent.ksql.engine.generic.GenericExpressionResolver;\n+import io.confluent.ksql.engine.rewrite.StatementRewriteForMagicPseudoTimestamp;\n+import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n+import io.confluent.ksql.execution.codegen.CodeGenRunner;\n+import io.confluent.ksql.execution.codegen.ExpressionMetadata;\n+import io.confluent.ksql.execution.expression.tree.ComparisonExpression;\n+import io.confluent.ksql.execution.expression.tree.ComparisonExpression.Type;\n+import io.confluent.ksql.execution.expression.tree.Expression;\n+import io.confluent.ksql.execution.expression.tree.InPredicate;\n+import io.confluent.ksql.execution.expression.tree.IntegerLiteral;\n+import io.confluent.ksql.execution.expression.tree.Literal;\n+import io.confluent.ksql.execution.expression.tree.LogicalBinaryExpression;\n+import io.confluent.ksql.execution.expression.tree.LongLiteral;\n+import io.confluent.ksql.execution.expression.tree.NullLiteral;\n+import io.confluent.ksql.execution.expression.tree.StringLiteral;\n+import io.confluent.ksql.execution.expression.tree.TraversalExpressionVisitor;\n+import io.confluent.ksql.execution.expression.tree.UnqualifiedColumnReferenceExp;\n+import io.confluent.ksql.metastore.MetaStore;\n+import io.confluent.ksql.name.ColumnName;\n+import io.confluent.ksql.schema.ksql.Column;\n+import io.confluent.ksql.schema.ksql.Column.Namespace;\n+import io.confluent.ksql.schema.ksql.DefaultSqlValueCoercer;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.SystemColumns;\n+import io.confluent.ksql.schema.utils.FormatOptions;\n+import io.confluent.ksql.structured.SchemaKStream;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.timestamp.PartialStringToTimestampParser;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.BitSet;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+public class PullFilterNode extends SingleSourcePlanNode {\n+\n+  private static final Set<Type> VALID_WINDOW_BOUND_COMPARISONS = ImmutableSet.of(\n+      Type.EQUAL,\n+      Type.GREATER_THAN,\n+      Type.GREATER_THAN_OR_EQUAL,\n+      Type.LESS_THAN,\n+      Type.LESS_THAN_OR_EQUAL\n+  );\n+\n+  private final boolean isWindowed;\n+  private final ExpressionMetadata compiledWhereClause;\n+  private final boolean addAdditionalColumnsToIntermediateSchema;\n+  private final LogicalSchema intermediateSchema;\n+  private final MetaStore metaStore;\n+  private final KsqlConfig ksqlConfig;\n+  private final LogicalSchema schema = getSource().getSchema();\n+\n+  private Expression rewrittenPredicate;\n+  private boolean isKeyedQuery = false;\n+  private Optional<WindowBounds> windowBounds;\n+  private List<GenericKey> keyValues;\n+  private Set<UnqualifiedColumnReferenceExp> keyColumns;\n+  private Set<UnqualifiedColumnReferenceExp> systemColumns;\n+  private List<GenericKey> inKeys;\n+  private BitSet seenKeys;\n+  private Object[] keyContents;\n+  private boolean containsINkeys;", "originalCommit": "6f2567921c98122f89e8651df08ec125648e74d1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ3MTgxMg==", "url": "https://github.com/confluentinc/ksql/pull/6814#discussion_r551471812", "bodyText": "This is primarily used in the validator.  Move to that class?", "author": "AlanConfluent", "createdAt": "2021-01-04T17:53:33Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullFilterNode.java", "diffHunk": "@@ -0,0 +1,823 @@\n+/*\n+ * Copyright 2019 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.planner.plan;\n+\n+import com.google.common.collect.BoundType;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Range;\n+import io.confluent.ksql.GenericKey;\n+import io.confluent.ksql.analyzer.PullQueryValidator;\n+import io.confluent.ksql.engine.generic.GenericExpressionResolver;\n+import io.confluent.ksql.engine.rewrite.StatementRewriteForMagicPseudoTimestamp;\n+import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n+import io.confluent.ksql.execution.codegen.CodeGenRunner;\n+import io.confluent.ksql.execution.codegen.ExpressionMetadata;\n+import io.confluent.ksql.execution.expression.tree.ComparisonExpression;\n+import io.confluent.ksql.execution.expression.tree.ComparisonExpression.Type;\n+import io.confluent.ksql.execution.expression.tree.Expression;\n+import io.confluent.ksql.execution.expression.tree.InPredicate;\n+import io.confluent.ksql.execution.expression.tree.IntegerLiteral;\n+import io.confluent.ksql.execution.expression.tree.Literal;\n+import io.confluent.ksql.execution.expression.tree.LogicalBinaryExpression;\n+import io.confluent.ksql.execution.expression.tree.LongLiteral;\n+import io.confluent.ksql.execution.expression.tree.NullLiteral;\n+import io.confluent.ksql.execution.expression.tree.StringLiteral;\n+import io.confluent.ksql.execution.expression.tree.TraversalExpressionVisitor;\n+import io.confluent.ksql.execution.expression.tree.UnqualifiedColumnReferenceExp;\n+import io.confluent.ksql.metastore.MetaStore;\n+import io.confluent.ksql.name.ColumnName;\n+import io.confluent.ksql.schema.ksql.Column;\n+import io.confluent.ksql.schema.ksql.Column.Namespace;\n+import io.confluent.ksql.schema.ksql.DefaultSqlValueCoercer;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.SystemColumns;\n+import io.confluent.ksql.schema.utils.FormatOptions;\n+import io.confluent.ksql.structured.SchemaKStream;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.timestamp.PartialStringToTimestampParser;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.BitSet;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+public class PullFilterNode extends SingleSourcePlanNode {\n+\n+  private static final Set<Type> VALID_WINDOW_BOUND_COMPARISONS = ImmutableSet.of(\n+      Type.EQUAL,\n+      Type.GREATER_THAN,\n+      Type.GREATER_THAN_OR_EQUAL,\n+      Type.LESS_THAN,\n+      Type.LESS_THAN_OR_EQUAL\n+  );\n+\n+  private final boolean isWindowed;\n+  private final ExpressionMetadata compiledWhereClause;\n+  private final boolean addAdditionalColumnsToIntermediateSchema;\n+  private final LogicalSchema intermediateSchema;\n+  private final MetaStore metaStore;\n+  private final KsqlConfig ksqlConfig;\n+  private final LogicalSchema schema = getSource().getSchema();\n+\n+  private Expression rewrittenPredicate;\n+  private boolean isKeyedQuery = false;", "originalCommit": "6f2567921c98122f89e8651df08ec125648e74d1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ3MjYyMA==", "url": "https://github.com/confluentinc/ksql/pull/6814#discussion_r551472620", "bodyText": "You can also add as getter to validator to get this field as well.", "author": "AlanConfluent", "createdAt": "2021-01-04T17:55:03Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullFilterNode.java", "diffHunk": "@@ -0,0 +1,823 @@\n+/*\n+ * Copyright 2019 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.planner.plan;\n+\n+import com.google.common.collect.BoundType;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Range;\n+import io.confluent.ksql.GenericKey;\n+import io.confluent.ksql.analyzer.PullQueryValidator;\n+import io.confluent.ksql.engine.generic.GenericExpressionResolver;\n+import io.confluent.ksql.engine.rewrite.StatementRewriteForMagicPseudoTimestamp;\n+import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n+import io.confluent.ksql.execution.codegen.CodeGenRunner;\n+import io.confluent.ksql.execution.codegen.ExpressionMetadata;\n+import io.confluent.ksql.execution.expression.tree.ComparisonExpression;\n+import io.confluent.ksql.execution.expression.tree.ComparisonExpression.Type;\n+import io.confluent.ksql.execution.expression.tree.Expression;\n+import io.confluent.ksql.execution.expression.tree.InPredicate;\n+import io.confluent.ksql.execution.expression.tree.IntegerLiteral;\n+import io.confluent.ksql.execution.expression.tree.Literal;\n+import io.confluent.ksql.execution.expression.tree.LogicalBinaryExpression;\n+import io.confluent.ksql.execution.expression.tree.LongLiteral;\n+import io.confluent.ksql.execution.expression.tree.NullLiteral;\n+import io.confluent.ksql.execution.expression.tree.StringLiteral;\n+import io.confluent.ksql.execution.expression.tree.TraversalExpressionVisitor;\n+import io.confluent.ksql.execution.expression.tree.UnqualifiedColumnReferenceExp;\n+import io.confluent.ksql.metastore.MetaStore;\n+import io.confluent.ksql.name.ColumnName;\n+import io.confluent.ksql.schema.ksql.Column;\n+import io.confluent.ksql.schema.ksql.Column.Namespace;\n+import io.confluent.ksql.schema.ksql.DefaultSqlValueCoercer;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.SystemColumns;\n+import io.confluent.ksql.schema.utils.FormatOptions;\n+import io.confluent.ksql.structured.SchemaKStream;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.timestamp.PartialStringToTimestampParser;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.BitSet;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+public class PullFilterNode extends SingleSourcePlanNode {\n+\n+  private static final Set<Type> VALID_WINDOW_BOUND_COMPARISONS = ImmutableSet.of(\n+      Type.EQUAL,\n+      Type.GREATER_THAN,\n+      Type.GREATER_THAN_OR_EQUAL,\n+      Type.LESS_THAN,\n+      Type.LESS_THAN_OR_EQUAL\n+  );\n+\n+  private final boolean isWindowed;\n+  private final ExpressionMetadata compiledWhereClause;\n+  private final boolean addAdditionalColumnsToIntermediateSchema;\n+  private final LogicalSchema intermediateSchema;\n+  private final MetaStore metaStore;\n+  private final KsqlConfig ksqlConfig;\n+  private final LogicalSchema schema = getSource().getSchema();\n+\n+  private Expression rewrittenPredicate;\n+  private boolean isKeyedQuery = false;\n+  private Optional<WindowBounds> windowBounds;\n+  private List<GenericKey> keyValues;\n+  private Set<UnqualifiedColumnReferenceExp> keyColumns;\n+  private Set<UnqualifiedColumnReferenceExp> systemColumns;\n+  private List<GenericKey> inKeys;\n+  private BitSet seenKeys;\n+  private Object[] keyContents;\n+  private boolean containsINkeys;\n+\n+  public PullFilterNode(\n+      final PlanNodeId id,\n+      final PlanNode source,\n+      final Expression predicate,\n+      final MetaStore metaStore,\n+      final KsqlConfig ksqlConfig,\n+      final boolean isWindowed\n+  ) {\n+    super(id, source.getNodeOutputType(), source.getSourceName(), source);\n+\n+    Objects.requireNonNull(predicate, \"predicate\");\n+    this.metaStore = Objects.requireNonNull(metaStore, \"metaStore\");\n+    this.ksqlConfig = Objects.requireNonNull(ksqlConfig, \"ksqlConfig\");\n+    this.rewrittenPredicate = new StatementRewriteForMagicPseudoTimestamp().rewrite(predicate);\n+    this.isWindowed = isWindowed;\n+\n+    // Basic validation of WHERE clause\n+    validateWhereClause();\n+\n+    // Validation and extractions of window bounds\n+    windowBounds = isWindowed ? Optional.of(extractWindowBounds()) : Optional.empty();\n+\n+    // Extraction of key and system columns\n+    extractKeysAndSystemCols();\n+\n+    // Extraction of key values\n+    keyValues = extractKeyValues();\n+\n+    // Compiling expression into byte code\n+    this.addAdditionalColumnsToIntermediateSchema = shouldAddAdditionalColumnsInSchema();\n+    this.intermediateSchema = PullLogicalPlanUtil.buildIntermediateSchema(\n+        source.getSchema(), addAdditionalColumnsToIntermediateSchema, isWindowed);\n+    compiledWhereClause = CodeGenRunner.compileExpression(\n+        rewrittenPredicate,\n+        \"Predicate\",\n+        intermediateSchema,\n+        ksqlConfig,\n+        metaStore\n+    );\n+\n+  }\n+\n+  public Expression getRewrittenPredicate() {\n+    return rewrittenPredicate;\n+  }\n+\n+  @Override\n+  public LogicalSchema getSchema() {\n+    return getSource().getSchema();\n+  }\n+\n+  @Override\n+  public SchemaKStream<?> buildStream(final KsqlQueryBuilder builder) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  public ExpressionMetadata getCompiledWhereClause() {\n+    return compiledWhereClause;\n+  }\n+\n+  public boolean isKeyedQuery() {\n+    return isKeyedQuery;\n+  }\n+\n+  public boolean isWindowed() {\n+    return isWindowed;\n+  }\n+\n+  public List<GenericKey> getKeyValues() {\n+    return keyValues;\n+  }\n+\n+  public Set<UnqualifiedColumnReferenceExp> getKeyColumns() {\n+    return keyColumns;\n+  }\n+\n+  public Optional<WindowBounds> getWindowBounds() {\n+    return windowBounds;\n+  }\n+\n+  public boolean getAddAdditionalColumnsToIntermediateSchema() {\n+    return addAdditionalColumnsToIntermediateSchema;\n+  }\n+\n+  public LogicalSchema getIntermediateSchema() {\n+    return intermediateSchema;\n+  }\n+\n+  private void validateWhereClause() {\n+    seenKeys = new BitSet(schema.key().size());\n+    final Validator validator = new Validator();\n+    validator.process(rewrittenPredicate, null);\n+    if (!isKeyedQuery) {", "originalCommit": "6f2567921c98122f89e8651df08ec125648e74d1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ3NTM0Nw==", "url": "https://github.com/confluentinc/ksql/pull/6814#discussion_r551475347", "bodyText": "You're effectively using this version of seenKeys to check that they're not attempting to use a key twice, right?  If you changed this to a counter rather than a bit set, you could initialize it once in ExtractKeyValues and then just do the check in a single place without traversing the expression again.", "author": "AlanConfluent", "createdAt": "2021-01-04T17:59:57Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullFilterNode.java", "diffHunk": "@@ -0,0 +1,823 @@\n+/*\n+ * Copyright 2019 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.planner.plan;\n+\n+import com.google.common.collect.BoundType;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Range;\n+import io.confluent.ksql.GenericKey;\n+import io.confluent.ksql.analyzer.PullQueryValidator;\n+import io.confluent.ksql.engine.generic.GenericExpressionResolver;\n+import io.confluent.ksql.engine.rewrite.StatementRewriteForMagicPseudoTimestamp;\n+import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n+import io.confluent.ksql.execution.codegen.CodeGenRunner;\n+import io.confluent.ksql.execution.codegen.ExpressionMetadata;\n+import io.confluent.ksql.execution.expression.tree.ComparisonExpression;\n+import io.confluent.ksql.execution.expression.tree.ComparisonExpression.Type;\n+import io.confluent.ksql.execution.expression.tree.Expression;\n+import io.confluent.ksql.execution.expression.tree.InPredicate;\n+import io.confluent.ksql.execution.expression.tree.IntegerLiteral;\n+import io.confluent.ksql.execution.expression.tree.Literal;\n+import io.confluent.ksql.execution.expression.tree.LogicalBinaryExpression;\n+import io.confluent.ksql.execution.expression.tree.LongLiteral;\n+import io.confluent.ksql.execution.expression.tree.NullLiteral;\n+import io.confluent.ksql.execution.expression.tree.StringLiteral;\n+import io.confluent.ksql.execution.expression.tree.TraversalExpressionVisitor;\n+import io.confluent.ksql.execution.expression.tree.UnqualifiedColumnReferenceExp;\n+import io.confluent.ksql.metastore.MetaStore;\n+import io.confluent.ksql.name.ColumnName;\n+import io.confluent.ksql.schema.ksql.Column;\n+import io.confluent.ksql.schema.ksql.Column.Namespace;\n+import io.confluent.ksql.schema.ksql.DefaultSqlValueCoercer;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.SystemColumns;\n+import io.confluent.ksql.schema.utils.FormatOptions;\n+import io.confluent.ksql.structured.SchemaKStream;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.timestamp.PartialStringToTimestampParser;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.BitSet;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+public class PullFilterNode extends SingleSourcePlanNode {\n+\n+  private static final Set<Type> VALID_WINDOW_BOUND_COMPARISONS = ImmutableSet.of(\n+      Type.EQUAL,\n+      Type.GREATER_THAN,\n+      Type.GREATER_THAN_OR_EQUAL,\n+      Type.LESS_THAN,\n+      Type.LESS_THAN_OR_EQUAL\n+  );\n+\n+  private final boolean isWindowed;\n+  private final ExpressionMetadata compiledWhereClause;\n+  private final boolean addAdditionalColumnsToIntermediateSchema;\n+  private final LogicalSchema intermediateSchema;\n+  private final MetaStore metaStore;\n+  private final KsqlConfig ksqlConfig;\n+  private final LogicalSchema schema = getSource().getSchema();\n+\n+  private Expression rewrittenPredicate;\n+  private boolean isKeyedQuery = false;\n+  private Optional<WindowBounds> windowBounds;\n+  private List<GenericKey> keyValues;\n+  private Set<UnqualifiedColumnReferenceExp> keyColumns;\n+  private Set<UnqualifiedColumnReferenceExp> systemColumns;\n+  private List<GenericKey> inKeys;\n+  private BitSet seenKeys;\n+  private Object[] keyContents;\n+  private boolean containsINkeys;\n+\n+  public PullFilterNode(\n+      final PlanNodeId id,\n+      final PlanNode source,\n+      final Expression predicate,\n+      final MetaStore metaStore,\n+      final KsqlConfig ksqlConfig,\n+      final boolean isWindowed\n+  ) {\n+    super(id, source.getNodeOutputType(), source.getSourceName(), source);\n+\n+    Objects.requireNonNull(predicate, \"predicate\");\n+    this.metaStore = Objects.requireNonNull(metaStore, \"metaStore\");\n+    this.ksqlConfig = Objects.requireNonNull(ksqlConfig, \"ksqlConfig\");\n+    this.rewrittenPredicate = new StatementRewriteForMagicPseudoTimestamp().rewrite(predicate);\n+    this.isWindowed = isWindowed;\n+\n+    // Basic validation of WHERE clause\n+    validateWhereClause();\n+\n+    // Validation and extractions of window bounds\n+    windowBounds = isWindowed ? Optional.of(extractWindowBounds()) : Optional.empty();\n+\n+    // Extraction of key and system columns\n+    extractKeysAndSystemCols();\n+\n+    // Extraction of key values\n+    keyValues = extractKeyValues();\n+\n+    // Compiling expression into byte code\n+    this.addAdditionalColumnsToIntermediateSchema = shouldAddAdditionalColumnsInSchema();\n+    this.intermediateSchema = PullLogicalPlanUtil.buildIntermediateSchema(\n+        source.getSchema(), addAdditionalColumnsToIntermediateSchema, isWindowed);\n+    compiledWhereClause = CodeGenRunner.compileExpression(\n+        rewrittenPredicate,\n+        \"Predicate\",\n+        intermediateSchema,\n+        ksqlConfig,\n+        metaStore\n+    );\n+\n+  }\n+\n+  public Expression getRewrittenPredicate() {\n+    return rewrittenPredicate;\n+  }\n+\n+  @Override\n+  public LogicalSchema getSchema() {\n+    return getSource().getSchema();\n+  }\n+\n+  @Override\n+  public SchemaKStream<?> buildStream(final KsqlQueryBuilder builder) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  public ExpressionMetadata getCompiledWhereClause() {\n+    return compiledWhereClause;\n+  }\n+\n+  public boolean isKeyedQuery() {\n+    return isKeyedQuery;\n+  }\n+\n+  public boolean isWindowed() {\n+    return isWindowed;\n+  }\n+\n+  public List<GenericKey> getKeyValues() {\n+    return keyValues;\n+  }\n+\n+  public Set<UnqualifiedColumnReferenceExp> getKeyColumns() {\n+    return keyColumns;\n+  }\n+\n+  public Optional<WindowBounds> getWindowBounds() {\n+    return windowBounds;\n+  }\n+\n+  public boolean getAddAdditionalColumnsToIntermediateSchema() {\n+    return addAdditionalColumnsToIntermediateSchema;\n+  }\n+\n+  public LogicalSchema getIntermediateSchema() {\n+    return intermediateSchema;\n+  }\n+\n+  private void validateWhereClause() {\n+    seenKeys = new BitSet(schema.key().size());\n+    final Validator validator = new Validator();\n+    validator.process(rewrittenPredicate, null);\n+    if (!isKeyedQuery) {\n+      throw invalidWhereClauseException(\"WHERE clause missing key column\", isWindowed);\n+    }\n+\n+    if (!seenKeys.isEmpty() && seenKeys.cardinality() != schema.key().size()) {\n+      final List<ColumnName> seenKeyNames = seenKeys\n+          .stream()\n+          .boxed()\n+          .map(i -> schema.key().get(i))\n+          .map(Column::name)\n+          .collect(Collectors.toList());\n+      throw invalidWhereClauseException(\n+          \"Multi-column sources must specify every key in the WHERE clause. Specified: \"\n+              + seenKeyNames + \" Expected: \" + schema.key(), isWindowed);\n+    }\n+  }\n+\n+  private void extractKeysAndSystemCols() {\n+    keyColumns = new HashSet<>();\n+    systemColumns = new HashSet<>();\n+    new KeyAndSystemColsExtractor().process(rewrittenPredicate, null);\n+  }\n+\n+  private List<GenericKey> extractKeyValues() {\n+    inKeys = new ArrayList<>();\n+    keyContents = new Object[schema.key().size()];\n+    seenKeys = new BitSet(schema.key().size());\n+\n+    new KeyValueExtractor().process(rewrittenPredicate, null);\n+    if (!inKeys.isEmpty()) {\n+      return (inKeys);\n+    }\n+\n+    return ImmutableList.of(GenericKey.fromList(Arrays.asList(keyContents)));\n+  }\n+\n+  private WindowBounds extractWindowBounds() {\n+    final WindowBounds windowBounds = new WindowBounds();\n+\n+    new WindowBoundsExtractor().process(rewrittenPredicate, windowBounds);\n+    return windowBounds;\n+  }\n+\n+  /**\n+   * Validate the WHERE clause for pull queries.\n+   * 1. There must be exactly one equality condition per key\n+   * or one IN predicate that involves a key.\n+   * 2. An IN predicate can refer to a single key.\n+   * 3. The IN predicate cannot be combined with other conditions.\n+   * 4. Only AND is allowed.\n+   * 5. If there is a multi-key, conditions on all keys must be specified.\n+   * 6. The IN predicate cannot use multi-keys.\n+   */\n+  private final class Validator extends TraversalExpressionVisitor<Object> {\n+\n+    @Override\n+    public Void process(final Expression node, final Object context) {\n+      if (!(node instanceof  LogicalBinaryExpression)\n+          && !(node instanceof  ComparisonExpression)\n+          && !(node instanceof  InPredicate)) {\n+        throw invalidWhereClauseException(\"Unsupported expression in WHERE clause: \" + node, false);\n+      }\n+      super.process(node, context);\n+      return null;\n+    }\n+\n+    @Override\n+    public Void visitLogicalBinaryExpression(\n+        final LogicalBinaryExpression node,\n+        final Object context\n+    ) {\n+      if (node.getType() != LogicalBinaryExpression.Type.AND) {\n+        throw invalidWhereClauseException(\"Only AND expressions are supported: \" + node, false);\n+      }\n+      process(node.getLeft(), context);\n+      process(node.getRight(), context);\n+      return null;\n+    }\n+\n+    @Override\n+    public Void visitComparisonExpression(\n+        final ComparisonExpression node,\n+        final Object context\n+    ) {\n+      final UnqualifiedColumnReferenceExp column = getColumnRefSide(node);\n+\n+      final ColumnName columnName = column.getColumnName();\n+      if (columnName.equals(SystemColumns.WINDOWSTART_NAME)\n+          || columnName.equals(SystemColumns.WINDOWEND_NAME)) {\n+        final Type type = node.getType();\n+        if (!VALID_WINDOW_BOUND_COMPARISONS.contains(type)) {\n+          throw invalidWhereClauseException(\n+              \"Unsupported \" + columnName + \" bounds: \" + type, true);\n+        }\n+        if (!isWindowed) {\n+          throw invalidWhereClauseException(\n+              \"Cannot use WINDOWSTART/WINDOWEND on non-windowed source\",\n+              false);\n+        }\n+        return null;\n+      } else {\n+        final Column col = schema.findColumn(columnName)\n+            .orElseThrow(() -> invalidWhereClauseException(\n+                \"Bound on non-key column \" + columnName, isWindowed));\n+\n+        if (col.namespace() == Namespace.KEY) {\n+          if (node.getType() != Type.EQUAL) {\n+            throw invalidWhereClauseException(\n+                \"Bound on key columns '\" + getSource().getSchema().key()\n+                    + \"' must currently be '='\",\n+                isWindowed);\n+          }\n+          if (containsINkeys || seenKeys.get(col.index())) {\n+            throw invalidWhereClauseException(\n+                \"An equality condition on the key column cannot be combined with other comparisons\"\n+                    + \" such as an IN predicate\",\n+                isWindowed);\n+          }\n+          seenKeys.set(col.index());", "originalCommit": "6f2567921c98122f89e8651df08ec125648e74d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA4NzQ3NQ==", "url": "https://github.com/confluentinc/ksql/pull/6814#discussion_r553087475", "bodyText": "This is actually to check that every column of the key has a constraint. With the counter you lose the information of which column you have seen", "author": "vpapavas", "createdAt": "2021-01-07T03:21:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ3NTM0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ3OTE2Mg==", "url": "https://github.com/confluentinc/ksql/pull/6814#discussion_r553479162", "bodyText": "Sorry, I mean, a map of counters so you could know how many times you saw a column.  Not a huge deal.", "author": "AlanConfluent", "createdAt": "2021-01-07T17:37:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ3NTM0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ3Nzg5MQ==", "url": "https://github.com/confluentinc/ksql/pull/6814#discussion_r551477891", "bodyText": "I find the reuse, multiple times, of the field seenKeys to be confusing.  Why not just make this a field of Validator and add a getter for it to be checked below?", "author": "AlanConfluent", "createdAt": "2021-01-04T18:05:04Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullFilterNode.java", "diffHunk": "@@ -0,0 +1,823 @@\n+/*\n+ * Copyright 2019 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.planner.plan;\n+\n+import com.google.common.collect.BoundType;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Range;\n+import io.confluent.ksql.GenericKey;\n+import io.confluent.ksql.analyzer.PullQueryValidator;\n+import io.confluent.ksql.engine.generic.GenericExpressionResolver;\n+import io.confluent.ksql.engine.rewrite.StatementRewriteForMagicPseudoTimestamp;\n+import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n+import io.confluent.ksql.execution.codegen.CodeGenRunner;\n+import io.confluent.ksql.execution.codegen.ExpressionMetadata;\n+import io.confluent.ksql.execution.expression.tree.ComparisonExpression;\n+import io.confluent.ksql.execution.expression.tree.ComparisonExpression.Type;\n+import io.confluent.ksql.execution.expression.tree.Expression;\n+import io.confluent.ksql.execution.expression.tree.InPredicate;\n+import io.confluent.ksql.execution.expression.tree.IntegerLiteral;\n+import io.confluent.ksql.execution.expression.tree.Literal;\n+import io.confluent.ksql.execution.expression.tree.LogicalBinaryExpression;\n+import io.confluent.ksql.execution.expression.tree.LongLiteral;\n+import io.confluent.ksql.execution.expression.tree.NullLiteral;\n+import io.confluent.ksql.execution.expression.tree.StringLiteral;\n+import io.confluent.ksql.execution.expression.tree.TraversalExpressionVisitor;\n+import io.confluent.ksql.execution.expression.tree.UnqualifiedColumnReferenceExp;\n+import io.confluent.ksql.metastore.MetaStore;\n+import io.confluent.ksql.name.ColumnName;\n+import io.confluent.ksql.schema.ksql.Column;\n+import io.confluent.ksql.schema.ksql.Column.Namespace;\n+import io.confluent.ksql.schema.ksql.DefaultSqlValueCoercer;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.SystemColumns;\n+import io.confluent.ksql.schema.utils.FormatOptions;\n+import io.confluent.ksql.structured.SchemaKStream;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.timestamp.PartialStringToTimestampParser;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.BitSet;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+public class PullFilterNode extends SingleSourcePlanNode {\n+\n+  private static final Set<Type> VALID_WINDOW_BOUND_COMPARISONS = ImmutableSet.of(\n+      Type.EQUAL,\n+      Type.GREATER_THAN,\n+      Type.GREATER_THAN_OR_EQUAL,\n+      Type.LESS_THAN,\n+      Type.LESS_THAN_OR_EQUAL\n+  );\n+\n+  private final boolean isWindowed;\n+  private final ExpressionMetadata compiledWhereClause;\n+  private final boolean addAdditionalColumnsToIntermediateSchema;\n+  private final LogicalSchema intermediateSchema;\n+  private final MetaStore metaStore;\n+  private final KsqlConfig ksqlConfig;\n+  private final LogicalSchema schema = getSource().getSchema();\n+\n+  private Expression rewrittenPredicate;\n+  private boolean isKeyedQuery = false;\n+  private Optional<WindowBounds> windowBounds;\n+  private List<GenericKey> keyValues;\n+  private Set<UnqualifiedColumnReferenceExp> keyColumns;\n+  private Set<UnqualifiedColumnReferenceExp> systemColumns;\n+  private List<GenericKey> inKeys;\n+  private BitSet seenKeys;\n+  private Object[] keyContents;\n+  private boolean containsINkeys;\n+\n+  public PullFilterNode(\n+      final PlanNodeId id,\n+      final PlanNode source,\n+      final Expression predicate,\n+      final MetaStore metaStore,\n+      final KsqlConfig ksqlConfig,\n+      final boolean isWindowed\n+  ) {\n+    super(id, source.getNodeOutputType(), source.getSourceName(), source);\n+\n+    Objects.requireNonNull(predicate, \"predicate\");\n+    this.metaStore = Objects.requireNonNull(metaStore, \"metaStore\");\n+    this.ksqlConfig = Objects.requireNonNull(ksqlConfig, \"ksqlConfig\");\n+    this.rewrittenPredicate = new StatementRewriteForMagicPseudoTimestamp().rewrite(predicate);\n+    this.isWindowed = isWindowed;\n+\n+    // Basic validation of WHERE clause\n+    validateWhereClause();\n+\n+    // Validation and extractions of window bounds\n+    windowBounds = isWindowed ? Optional.of(extractWindowBounds()) : Optional.empty();\n+\n+    // Extraction of key and system columns\n+    extractKeysAndSystemCols();\n+\n+    // Extraction of key values\n+    keyValues = extractKeyValues();\n+\n+    // Compiling expression into byte code\n+    this.addAdditionalColumnsToIntermediateSchema = shouldAddAdditionalColumnsInSchema();\n+    this.intermediateSchema = PullLogicalPlanUtil.buildIntermediateSchema(\n+        source.getSchema(), addAdditionalColumnsToIntermediateSchema, isWindowed);\n+    compiledWhereClause = CodeGenRunner.compileExpression(\n+        rewrittenPredicate,\n+        \"Predicate\",\n+        intermediateSchema,\n+        ksqlConfig,\n+        metaStore\n+    );\n+\n+  }\n+\n+  public Expression getRewrittenPredicate() {\n+    return rewrittenPredicate;\n+  }\n+\n+  @Override\n+  public LogicalSchema getSchema() {\n+    return getSource().getSchema();\n+  }\n+\n+  @Override\n+  public SchemaKStream<?> buildStream(final KsqlQueryBuilder builder) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  public ExpressionMetadata getCompiledWhereClause() {\n+    return compiledWhereClause;\n+  }\n+\n+  public boolean isKeyedQuery() {\n+    return isKeyedQuery;\n+  }\n+\n+  public boolean isWindowed() {\n+    return isWindowed;\n+  }\n+\n+  public List<GenericKey> getKeyValues() {\n+    return keyValues;\n+  }\n+\n+  public Set<UnqualifiedColumnReferenceExp> getKeyColumns() {\n+    return keyColumns;\n+  }\n+\n+  public Optional<WindowBounds> getWindowBounds() {\n+    return windowBounds;\n+  }\n+\n+  public boolean getAddAdditionalColumnsToIntermediateSchema() {\n+    return addAdditionalColumnsToIntermediateSchema;\n+  }\n+\n+  public LogicalSchema getIntermediateSchema() {\n+    return intermediateSchema;\n+  }\n+\n+  private void validateWhereClause() {\n+    seenKeys = new BitSet(schema.key().size());", "originalCommit": "6f2567921c98122f89e8651df08ec125648e74d1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ4MTE4MQ==", "url": "https://github.com/confluentinc/ksql/pull/6814#discussion_r551481181", "bodyText": "Currently, you have to check for this case in both visitComparisonExpression and  visitInPredicate since you don't know whether you're going to hit a comparison or in predicate first.\nIf you set containsINkeys and seenKeys in ExtractKeyValues, then you can do the check just once in one spot.", "author": "AlanConfluent", "createdAt": "2021-01-04T18:12:04Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/PullFilterNode.java", "diffHunk": "@@ -0,0 +1,823 @@\n+/*\n+ * Copyright 2019 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.planner.plan;\n+\n+import com.google.common.collect.BoundType;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Range;\n+import io.confluent.ksql.GenericKey;\n+import io.confluent.ksql.analyzer.PullQueryValidator;\n+import io.confluent.ksql.engine.generic.GenericExpressionResolver;\n+import io.confluent.ksql.engine.rewrite.StatementRewriteForMagicPseudoTimestamp;\n+import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n+import io.confluent.ksql.execution.codegen.CodeGenRunner;\n+import io.confluent.ksql.execution.codegen.ExpressionMetadata;\n+import io.confluent.ksql.execution.expression.tree.ComparisonExpression;\n+import io.confluent.ksql.execution.expression.tree.ComparisonExpression.Type;\n+import io.confluent.ksql.execution.expression.tree.Expression;\n+import io.confluent.ksql.execution.expression.tree.InPredicate;\n+import io.confluent.ksql.execution.expression.tree.IntegerLiteral;\n+import io.confluent.ksql.execution.expression.tree.Literal;\n+import io.confluent.ksql.execution.expression.tree.LogicalBinaryExpression;\n+import io.confluent.ksql.execution.expression.tree.LongLiteral;\n+import io.confluent.ksql.execution.expression.tree.NullLiteral;\n+import io.confluent.ksql.execution.expression.tree.StringLiteral;\n+import io.confluent.ksql.execution.expression.tree.TraversalExpressionVisitor;\n+import io.confluent.ksql.execution.expression.tree.UnqualifiedColumnReferenceExp;\n+import io.confluent.ksql.metastore.MetaStore;\n+import io.confluent.ksql.name.ColumnName;\n+import io.confluent.ksql.schema.ksql.Column;\n+import io.confluent.ksql.schema.ksql.Column.Namespace;\n+import io.confluent.ksql.schema.ksql.DefaultSqlValueCoercer;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.SystemColumns;\n+import io.confluent.ksql.schema.utils.FormatOptions;\n+import io.confluent.ksql.structured.SchemaKStream;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.KsqlException;\n+import io.confluent.ksql.util.timestamp.PartialStringToTimestampParser;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.BitSet;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+public class PullFilterNode extends SingleSourcePlanNode {\n+\n+  private static final Set<Type> VALID_WINDOW_BOUND_COMPARISONS = ImmutableSet.of(\n+      Type.EQUAL,\n+      Type.GREATER_THAN,\n+      Type.GREATER_THAN_OR_EQUAL,\n+      Type.LESS_THAN,\n+      Type.LESS_THAN_OR_EQUAL\n+  );\n+\n+  private final boolean isWindowed;\n+  private final ExpressionMetadata compiledWhereClause;\n+  private final boolean addAdditionalColumnsToIntermediateSchema;\n+  private final LogicalSchema intermediateSchema;\n+  private final MetaStore metaStore;\n+  private final KsqlConfig ksqlConfig;\n+  private final LogicalSchema schema = getSource().getSchema();\n+\n+  private Expression rewrittenPredicate;\n+  private boolean isKeyedQuery = false;\n+  private Optional<WindowBounds> windowBounds;\n+  private List<GenericKey> keyValues;\n+  private Set<UnqualifiedColumnReferenceExp> keyColumns;\n+  private Set<UnqualifiedColumnReferenceExp> systemColumns;\n+  private List<GenericKey> inKeys;\n+  private BitSet seenKeys;\n+  private Object[] keyContents;\n+  private boolean containsINkeys;\n+\n+  public PullFilterNode(\n+      final PlanNodeId id,\n+      final PlanNode source,\n+      final Expression predicate,\n+      final MetaStore metaStore,\n+      final KsqlConfig ksqlConfig,\n+      final boolean isWindowed\n+  ) {\n+    super(id, source.getNodeOutputType(), source.getSourceName(), source);\n+\n+    Objects.requireNonNull(predicate, \"predicate\");\n+    this.metaStore = Objects.requireNonNull(metaStore, \"metaStore\");\n+    this.ksqlConfig = Objects.requireNonNull(ksqlConfig, \"ksqlConfig\");\n+    this.rewrittenPredicate = new StatementRewriteForMagicPseudoTimestamp().rewrite(predicate);\n+    this.isWindowed = isWindowed;\n+\n+    // Basic validation of WHERE clause\n+    validateWhereClause();\n+\n+    // Validation and extractions of window bounds\n+    windowBounds = isWindowed ? Optional.of(extractWindowBounds()) : Optional.empty();\n+\n+    // Extraction of key and system columns\n+    extractKeysAndSystemCols();\n+\n+    // Extraction of key values\n+    keyValues = extractKeyValues();\n+\n+    // Compiling expression into byte code\n+    this.addAdditionalColumnsToIntermediateSchema = shouldAddAdditionalColumnsInSchema();\n+    this.intermediateSchema = PullLogicalPlanUtil.buildIntermediateSchema(\n+        source.getSchema(), addAdditionalColumnsToIntermediateSchema, isWindowed);\n+    compiledWhereClause = CodeGenRunner.compileExpression(\n+        rewrittenPredicate,\n+        \"Predicate\",\n+        intermediateSchema,\n+        ksqlConfig,\n+        metaStore\n+    );\n+\n+  }\n+\n+  public Expression getRewrittenPredicate() {\n+    return rewrittenPredicate;\n+  }\n+\n+  @Override\n+  public LogicalSchema getSchema() {\n+    return getSource().getSchema();\n+  }\n+\n+  @Override\n+  public SchemaKStream<?> buildStream(final KsqlQueryBuilder builder) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  public ExpressionMetadata getCompiledWhereClause() {\n+    return compiledWhereClause;\n+  }\n+\n+  public boolean isKeyedQuery() {\n+    return isKeyedQuery;\n+  }\n+\n+  public boolean isWindowed() {\n+    return isWindowed;\n+  }\n+\n+  public List<GenericKey> getKeyValues() {\n+    return keyValues;\n+  }\n+\n+  public Set<UnqualifiedColumnReferenceExp> getKeyColumns() {\n+    return keyColumns;\n+  }\n+\n+  public Optional<WindowBounds> getWindowBounds() {\n+    return windowBounds;\n+  }\n+\n+  public boolean getAddAdditionalColumnsToIntermediateSchema() {\n+    return addAdditionalColumnsToIntermediateSchema;\n+  }\n+\n+  public LogicalSchema getIntermediateSchema() {\n+    return intermediateSchema;\n+  }\n+\n+  private void validateWhereClause() {\n+    seenKeys = new BitSet(schema.key().size());\n+    final Validator validator = new Validator();\n+    validator.process(rewrittenPredicate, null);\n+    if (!isKeyedQuery) {\n+      throw invalidWhereClauseException(\"WHERE clause missing key column\", isWindowed);\n+    }\n+\n+    if (!seenKeys.isEmpty() && seenKeys.cardinality() != schema.key().size()) {\n+      final List<ColumnName> seenKeyNames = seenKeys\n+          .stream()\n+          .boxed()\n+          .map(i -> schema.key().get(i))\n+          .map(Column::name)\n+          .collect(Collectors.toList());\n+      throw invalidWhereClauseException(\n+          \"Multi-column sources must specify every key in the WHERE clause. Specified: \"\n+              + seenKeyNames + \" Expected: \" + schema.key(), isWindowed);\n+    }\n+  }\n+\n+  private void extractKeysAndSystemCols() {\n+    keyColumns = new HashSet<>();\n+    systemColumns = new HashSet<>();\n+    new KeyAndSystemColsExtractor().process(rewrittenPredicate, null);\n+  }\n+\n+  private List<GenericKey> extractKeyValues() {\n+    inKeys = new ArrayList<>();\n+    keyContents = new Object[schema.key().size()];\n+    seenKeys = new BitSet(schema.key().size());\n+\n+    new KeyValueExtractor().process(rewrittenPredicate, null);\n+    if (!inKeys.isEmpty()) {\n+      return (inKeys);\n+    }\n+\n+    return ImmutableList.of(GenericKey.fromList(Arrays.asList(keyContents)));\n+  }\n+\n+  private WindowBounds extractWindowBounds() {\n+    final WindowBounds windowBounds = new WindowBounds();\n+\n+    new WindowBoundsExtractor().process(rewrittenPredicate, windowBounds);\n+    return windowBounds;\n+  }\n+\n+  /**\n+   * Validate the WHERE clause for pull queries.\n+   * 1. There must be exactly one equality condition per key\n+   * or one IN predicate that involves a key.\n+   * 2. An IN predicate can refer to a single key.\n+   * 3. The IN predicate cannot be combined with other conditions.\n+   * 4. Only AND is allowed.\n+   * 5. If there is a multi-key, conditions on all keys must be specified.\n+   * 6. The IN predicate cannot use multi-keys.\n+   */\n+  private final class Validator extends TraversalExpressionVisitor<Object> {\n+\n+    @Override\n+    public Void process(final Expression node, final Object context) {\n+      if (!(node instanceof  LogicalBinaryExpression)\n+          && !(node instanceof  ComparisonExpression)\n+          && !(node instanceof  InPredicate)) {\n+        throw invalidWhereClauseException(\"Unsupported expression in WHERE clause: \" + node, false);\n+      }\n+      super.process(node, context);\n+      return null;\n+    }\n+\n+    @Override\n+    public Void visitLogicalBinaryExpression(\n+        final LogicalBinaryExpression node,\n+        final Object context\n+    ) {\n+      if (node.getType() != LogicalBinaryExpression.Type.AND) {\n+        throw invalidWhereClauseException(\"Only AND expressions are supported: \" + node, false);\n+      }\n+      process(node.getLeft(), context);\n+      process(node.getRight(), context);\n+      return null;\n+    }\n+\n+    @Override\n+    public Void visitComparisonExpression(\n+        final ComparisonExpression node,\n+        final Object context\n+    ) {\n+      final UnqualifiedColumnReferenceExp column = getColumnRefSide(node);\n+\n+      final ColumnName columnName = column.getColumnName();\n+      if (columnName.equals(SystemColumns.WINDOWSTART_NAME)\n+          || columnName.equals(SystemColumns.WINDOWEND_NAME)) {\n+        final Type type = node.getType();\n+        if (!VALID_WINDOW_BOUND_COMPARISONS.contains(type)) {\n+          throw invalidWhereClauseException(\n+              \"Unsupported \" + columnName + \" bounds: \" + type, true);\n+        }\n+        if (!isWindowed) {\n+          throw invalidWhereClauseException(\n+              \"Cannot use WINDOWSTART/WINDOWEND on non-windowed source\",\n+              false);\n+        }\n+        return null;\n+      } else {\n+        final Column col = schema.findColumn(columnName)\n+            .orElseThrow(() -> invalidWhereClauseException(\n+                \"Bound on non-key column \" + columnName, isWindowed));\n+\n+        if (col.namespace() == Namespace.KEY) {\n+          if (node.getType() != Type.EQUAL) {\n+            throw invalidWhereClauseException(\n+                \"Bound on key columns '\" + getSource().getSchema().key()\n+                    + \"' must currently be '='\",\n+                isWindowed);\n+          }\n+          if (containsINkeys || seenKeys.get(col.index())) {", "originalCommit": "6f2567921c98122f89e8651df08ec125648e74d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA4ODI5Mg==", "url": "https://github.com/confluentinc/ksql/pull/6814#discussion_r553088292", "bodyText": "I am not sure I follow what you mean. The validation happens first before we extract keys so how can I set it in the ExtractKeyValues ? It makes sense to validate first so that we fail fast.", "author": "vpapavas", "createdAt": "2021-01-07T03:24:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ4MTE4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ4MDI2MQ==", "url": "https://github.com/confluentinc/ksql/pull/6814#discussion_r553480261", "bodyText": "I just meant that you don't know which expression you'll hit first. so you have to put the check twice whereas if you factored out the key use metrics, you could check for the error once.\nIf the ordering of things doesn't allow for this, then that's fine.", "author": "AlanConfluent", "createdAt": "2021-01-07T17:39:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ4MTE4MQ=="}], "type": "inlineReview"}, {"oid": "cd9e77708ab88e957fe92a48462cde8bb0f98c9a", "url": "https://github.com/confluentinc/ksql/commit/cd9e77708ab88e957fe92a48462cde8bb0f98c9a", "message": "initial logical node", "committedDate": "2021-01-08T02:49:52Z", "type": "commit"}, {"oid": "99d84ce46c520aed905cc1417a2eec21f047cb23", "url": "https://github.com/confluentinc/ksql/commit/99d84ce46c520aed905cc1417a2eec21f047cb23", "message": "work in progress", "committedDate": "2021-01-08T02:49:52Z", "type": "commit"}, {"oid": "54034b4e70d677c9249b2ad441ec18e6a9964a25", "url": "https://github.com/confluentinc/ksql/commit/54034b4e70d677c9249b2ad441ec18e6a9964a25", "message": "filter node", "committedDate": "2021-01-08T02:49:52Z", "type": "commit"}, {"oid": "4c9adf3fcc40d9240014b6c028dce75c1d261d33", "url": "https://github.com/confluentinc/ksql/commit/4c9adf3fcc40d9240014b6c028dce75c1d261d33", "message": "temp", "committedDate": "2021-01-08T02:49:52Z", "type": "commit"}, {"oid": "8d7e0d92bf6c622ba6741af1ee14f6c8e66c0072", "url": "https://github.com/confluentinc/ksql/commit/8d7e0d92bf6c622ba6741af1ee14f6c8e66c0072", "message": "working on tests", "committedDate": "2021-01-08T02:49:52Z", "type": "commit"}, {"oid": "22d0c5c13e43a2e962563881f5daec46da772023", "url": "https://github.com/confluentinc/ksql/commit/22d0c5c13e43a2e962563881f5daec46da772023", "message": "added tests and fixed tests", "committedDate": "2021-01-08T02:51:30Z", "type": "commit"}, {"oid": "eb70640c85769279f71ececd550861edb312b3d6", "url": "https://github.com/confluentinc/ksql/commit/eb70640c85769279f71ececd550861edb312b3d6", "message": "rebase master", "committedDate": "2021-01-08T02:51:33Z", "type": "commit"}, {"oid": "b91e48607afb9130b68d4f052515c99c79ed0d87", "url": "https://github.com/confluentinc/ksql/commit/b91e48607afb9130b68d4f052515c99c79ed0d87", "message": "address alan's comments", "committedDate": "2021-01-08T02:51:33Z", "type": "commit"}, {"oid": "f6f623d8b1e9e5442500b1021ae194d8e7460912", "url": "https://github.com/confluentinc/ksql/commit/f6f623d8b1e9e5442500b1021ae194d8e7460912", "message": "compilation error", "committedDate": "2021-01-08T02:51:33Z", "type": "commit"}, {"oid": "acb2a3bbb10309e45ca721021836234f4976b7a9", "url": "https://github.com/confluentinc/ksql/commit/acb2a3bbb10309e45ca721021836234f4976b7a9", "message": "rebase", "committedDate": "2021-01-11T06:33:26Z", "type": "commit"}, {"oid": "acb2a3bbb10309e45ca721021836234f4976b7a9", "url": "https://github.com/confluentinc/ksql/commit/acb2a3bbb10309e45ca721021836234f4976b7a9", "message": "rebase", "committedDate": "2021-01-11T06:33:26Z", "type": "forcePushed"}, {"oid": "8382610de75d792828e1f06d46cccf4d1ac5d32c", "url": "https://github.com/confluentinc/ksql/commit/8382610de75d792828e1f06d46cccf4d1ac5d32c", "message": "fixed rqtt", "committedDate": "2021-01-12T04:12:07Z", "type": "commit"}]}