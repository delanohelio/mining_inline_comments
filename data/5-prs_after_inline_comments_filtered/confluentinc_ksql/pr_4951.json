{"pr_number": 4951, "pr_title": "feat: Adds rate limiting to pull queries", "pr_createdAt": "2020-03-31T22:50:12Z", "pr_url": "https://github.com/confluentinc/ksql/pull/4951", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTI3MTM4OQ==", "url": "https://github.com/confluentinc/ksql/pull/4951#discussion_r401271389", "bodyText": "how does this interact with host forwarding? If I forwarded to a host that is overwhelmed will I then try it's standby? It might make sense to check the error message and not forward to another host in this scenario (not sure if that's what happens or not)", "author": "agavra", "createdAt": "2020-03-31T23:23:54Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java", "diffHunk": "@@ -168,6 +172,11 @@ public TableRowsEntity execute(\n               + \"this feature.\");\n     }\n \n+    if (!rateLimiter.tryAcquire()) {", "originalCommit": "3dc64405c7ae9933d55cb7b9d2bab2876c944628", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTI4MzI0NQ==", "url": "https://github.com/confluentinc/ksql/pull/4951#discussion_r401283245", "bodyText": "That's a fair question.  At the moment, it checks the limit at both places, which seems like a reasonable method generally since both have to take part in responding.\nIt doesn't handle this failure in a special manner at the forwarder and it would just try the standby, as you're hinting at.  This could be a way to quickly shift load from one overwhelmed host to another, though in the current scheme, next time, we'll just try the overwhelmed host again, so it's not perfect at the moment.\nTo me, being overwhelmed with queries is not unlike the host being down temporarily, and the solution we have is to fail over to a standby.  What do you think @vinothchandar ?", "author": "AlanConfluent", "createdAt": "2020-04-01T00:03:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTI3MTM4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTI5MDU1NA==", "url": "https://github.com/confluentinc/ksql/pull/4951#discussion_r401290554", "bodyText": "@AlanConfluent I don't understand from the code how it will try the standby if the active has exceeded the rate limit. The check does not happen in the forwarding loop so if the active fails, the query will fail.", "author": "vpapavas", "createdAt": "2020-04-01T00:29:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTI3MTM4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTI5NTEwMw==", "url": "https://github.com/confluentinc/ksql/pull/4951#discussion_r401295103", "bodyText": "If the rate limit check fails at the forwarding node, that it just fails.  That means that the node accessed to answer pull queries is overwhelmed.  I could move this down to the local pull query section, but it wouldn't limit someone from forwarding lots of pull queries through a single forwarding node, which seems bad.\nIf it fails the rate limit at the actual active node, then the forwarding loop will go on to the standby.\nfor (KsqlNode node : filteredAndOrderedNodes) {\n      try {\n        return routeQuery(node, statement, executionContext, serviceContext, pullQueryContext);\n      } catch (Exception t) {\n        LOG.debug(\"Error routing query {} to host {} at timestamp {}\",\n                 statement.getStatementText(), node, System.currentTimeMillis());\n      }\n    }", "author": "AlanConfluent", "createdAt": "2020-04-01T00:46:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTI3MTM4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTMxMjYxNg==", "url": "https://github.com/confluentinc/ksql/pull/4951#discussion_r401312616", "bodyText": "By forwarding node do you mean a router? The way I understand how this change would work is this: If there is a router and the router exceeds the rate limit, it will fail the query. If the router is not overwhelmed, it will go to the forwarding loop and will try the active and standbys. If there is no router, then the active will fail the query if is has exceeded the rate limit.", "author": "vpapavas", "createdAt": "2020-04-01T01:55:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTI3MTM4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc0MTAzOA==", "url": "https://github.com/confluentinc/ksql/pull/4951#discussion_r401741038", "bodyText": "Fly by comment (feel free to ignore) :): I feel we can just enforce at the router and over time, things will settle down to that rate when all routers enforce the limit.. This is a simpler model to understand..", "author": "vinothchandar", "createdAt": "2020-04-01T16:18:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTI3MTM4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk0NTIxMw==", "url": "https://github.com/confluentinc/ksql/pull/4951#discussion_r401945213", "bodyText": "Alright, I agree it's a little hard to reason about if you're trying to figure out total QPS available.\nI have it now check the rate limit so long as it's not been forwarded yet.  It should be noted that this doesn't prevent people from deliberately trying to circumvent the limit by always setting the \"forwarded\" flag, though it may not find the desired data in that case (if it lives elsewhere).  Any scheme (without internal, trusted rpcs) that tries to only check a limit for some requests has this issue since flags can be spoofed.  I think that's not an issue for this feature though since it's not meant for security.", "author": "AlanConfluent", "createdAt": "2020-04-01T22:23:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTI3MTM4OQ=="}], "type": "inlineReview"}, {"oid": "540d154cbfb048852df10a76028e5663b939cfdb", "url": "https://github.com/confluentinc/ksql/commit/540d154cbfb048852df10a76028e5663b939cfdb", "message": "feat: Adds rate limiting to pull queries", "committedDate": "2020-03-31T23:49:32Z", "type": "commit"}, {"oid": "3eb51d46b2553ba49ad688b6eaabcf8e01576f1d", "url": "https://github.com/confluentinc/ksql/commit/3eb51d46b2553ba49ad688b6eaabcf8e01576f1d", "message": "Tests", "committedDate": "2020-04-01T00:38:31Z", "type": "commit"}, {"oid": "3eb51d46b2553ba49ad688b6eaabcf8e01576f1d", "url": "https://github.com/confluentinc/ksql/commit/3eb51d46b2553ba49ad688b6eaabcf8e01576f1d", "message": "Tests", "committedDate": "2020-04-01T00:38:31Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc2OTQwOQ==", "url": "https://github.com/confluentinc/ksql/pull/4951#discussion_r401769409", "bodyText": "How does this fail here? There are no queries issued?", "author": "vpapavas", "createdAt": "2020-04-01T17:00:57Z", "path": "ksqldb-rest-app/src/test/java/io/confluent/ksql/rest/server/execution/PullQueryExecutorTest.java", "diffHunk": "@@ -118,4 +120,22 @@ public void shouldRedirectQueriesToQueryEndPoint() {\n       );\n     }\n   }\n+\n+  @RunWith(MockitoJUnitRunner.class)\n+  public static class RateLimit {\n+\n+    @Rule\n+    public final TemporaryEngine engine = new TemporaryEngine()\n+        .withConfigs(ImmutableMap.of(KsqlConfig.KSQL_QUERY_PULL_MAX_QPS_CONFIG, 2));\n+\n+    @Test\n+    public void shouldRateLimit() {", "originalCommit": "3eb51d46b2553ba49ad688b6eaabcf8e01576f1d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk0NTM1Mw==", "url": "https://github.com/confluentinc/ksql/pull/4951#discussion_r401945353", "bodyText": "It checks the limit before the request is issued.  It effectively asks for permission, and if it's at the limit, it's not given permission.", "author": "AlanConfluent", "createdAt": "2020-04-01T22:24:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc2OTQwOQ=="}], "type": "inlineReview"}, {"oid": "460aee3962782914a852ecd54db672b22fc98abb", "url": "https://github.com/confluentinc/ksql/commit/460aee3962782914a852ecd54db672b22fc98abb", "message": "Feedback", "committedDate": "2020-04-01T22:24:16Z", "type": "commit"}]}