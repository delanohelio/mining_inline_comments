{"pr_number": 6628, "pr_title": "chore: support complex key pull queries", "pr_createdAt": "2020-11-17T01:28:26Z", "pr_url": "https://github.com/confluentinc/ksql/pull/6628", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU3NDg0OQ==", "url": "https://github.com/confluentinc/ksql/pull/6628#discussion_r525574849", "bodyText": "This is just done because GenericExpressionResolver isn't as low overhead right?", "author": "AlanConfluent", "createdAt": "2020-11-17T22:44:25Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java", "diffHunk": "@@ -778,31 +798,40 @@ private static Object extractKeyWhereClause(\n     }\n \n     final Expression other = getNonColumnRefSide(comparison);\n-    if (!(other instanceof Literal)) {\n-      throw new KsqlException(\"Ony comparison to literals is currently supported: \" + comparison);\n-    }\n-\n-    if (other instanceof NullLiteral) {\n-      throw new KsqlException(\"Primary key columns can not be NULL: \" + comparison);\n-    }\n-\n-    final Object right = ((Literal) other).getValue();\n-    return coerceKey(schema, right, windowed);\n+    final Column keyColumn = schema.key().get(0);\n+    return resolveKey(other, keyColumn, executionContext, config, comparison);\n   }\n \n-  private static Object coerceKey(\n-      final LogicalSchema schema,\n-      final Object right,\n-      final boolean windowed\n+  private static Object resolveKey(\n+      final Expression exp,\n+      final Column keyColumn,\n+      final KsqlExecutionContext executionContext,\n+      final KsqlConfig config,\n+      final Expression errorMessageHint\n   ) {\n-    if (schema.key().size() != 1) {\n-      throw invalidWhereClauseException(\"Only single KEY column supported\", windowed);\n+    final Object obj;\n+    if (exp instanceof NullLiteral) {\n+      obj = null;\n+    } else if (exp instanceof Literal) {\n+      // skip the GenericExpressionResolver because this is", "originalCommit": "d48b3b6d96d97676a0d7dfc1284cef242b727746", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU4MDYzNw==", "url": "https://github.com/confluentinc/ksql/pull/6628#discussion_r525580637", "bodyText": "yup, that was exactly the idea", "author": "agavra", "createdAt": "2020-11-17T22:56:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU3NDg0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU3ODYyMw==", "url": "https://github.com/confluentinc/ksql/pull/6628#discussion_r525578623", "bodyText": "Just curious, how much overhead is it to compile the java into bytecode, load the bytecode, and then run it.  It makes a lot of sense when you compile once and then run many times, but in this case, there's a 1:1 relationship.  In general, it seems like interpreting the expression would be lower overhead and possibly faster.  Do we do it this way because this is the main method that currently exists for \"evaluating a sql expression\"?\nI'd be curious to run a benchmark doing just expression lookups (rather than literals).", "author": "AlanConfluent", "createdAt": "2020-11-17T22:52:08Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/generic/GenericExpressionResolver.java", "diffHunk": "@@ -76,11 +83,12 @@ public Object resolve(final Expression expression) {\n \n     @Override\n     protected Object visitExpression(final Expression expression, final Void context) {\n+      new EnsureNoColReferences(expression).process(expression, context);\n       final ExpressionMetadata metadata =\n           CodeGenRunner.compileExpression(", "originalCommit": "d48b3b6d96d97676a0d7dfc1284cef242b727746", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTYzMTE5MA==", "url": "https://github.com/confluentinc/ksql/pull/6628#discussion_r525631190", "bodyText": "Talked offline about this, we'll look into running specialized benchmarks to see how much the overhead is. Given that this is just \"new\" functionality, we won't block the PR on this and we'll run those benchmarks going forward.", "author": "agavra", "createdAt": "2020-11-18T01:15:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU3ODYyMw=="}], "type": "inlineReview"}, {"oid": "5dd79121d58e310f4cac749c0dbfa5a1f53fec48", "url": "https://github.com/confluentinc/ksql/commit/5dd79121d58e310f4cac749c0dbfa5a1f53fec48", "message": "chore: support complex key pull queries", "committedDate": "2020-11-19T00:29:33Z", "type": "commit"}, {"oid": "a4b4c4cd82f4549cd198a5ce358b1432e9311161", "url": "https://github.com/confluentinc/ksql/commit/a4b4c4cd82f4549cd198a5ce358b1432e9311161", "message": "chore: update to better error message", "committedDate": "2020-11-19T00:29:51Z", "type": "commit"}, {"oid": "5cb93e548b265cd4e09e1993f47d6be469394405", "url": "https://github.com/confluentinc/ksql/commit/5cb93e548b265cd4e09e1993f47d6be469394405", "message": "test: update test case for multiple IN statements", "committedDate": "2020-11-19T00:29:53Z", "type": "commit"}, {"oid": "2756cfb722218ff67e9f48ef70661da751b988f8", "url": "https://github.com/confluentinc/ksql/commit/2756cfb722218ff67e9f48ef70661da751b988f8", "message": "chore: rebase with master", "committedDate": "2020-11-19T00:58:12Z", "type": "commit"}, {"oid": "2756cfb722218ff67e9f48ef70661da751b988f8", "url": "https://github.com/confluentinc/ksql/commit/2756cfb722218ff67e9f48ef70661da751b988f8", "message": "chore: rebase with master", "committedDate": "2020-11-19T00:58:12Z", "type": "forcePushed"}, {"oid": "28c43d43dd2ff72c27ccde079ff6da375a9a4c75", "url": "https://github.com/confluentinc/ksql/commit/28c43d43dd2ff72c27ccde079ff6da375a9a4c75", "message": "chore: fix checkstyle", "committedDate": "2020-11-19T01:24:34Z", "type": "commit"}]}