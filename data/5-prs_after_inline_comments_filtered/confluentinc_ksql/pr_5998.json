{"pr_number": 5998, "pr_title": "feat: Support subscript and nested functions in grouping queries ", "pr_createdAt": "2020-08-12T19:36:25Z", "pr_url": "https://github.com/confluentinc/ksql/pull/5998", "timeline": [{"oid": "2f21890966358df12225c90e6c37fed7f32f8a48", "url": "https://github.com/confluentinc/ksql/commit/2f21890966358df12225c90e6c37fed7f32f8a48", "message": "remove intermediate topics from test file", "committedDate": "2020-08-13T00:49:12Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA1NjU1NQ==", "url": "https://github.com/confluentinc/ksql/pull/5998#discussion_r470056555", "bodyText": "nit: update the comment above (and on line 83) - might also want to mention that it is only used to validate (i.e. throw exception)", "author": "agavra", "createdAt": "2020-08-13T15:56:50Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/AggregateAnalyzer.java", "diffHunk": "@@ -68,17 +69,19 @@ public AggregateAnalysisResult analyze(\n     private final MutableAggregateAnalysis aggregateAnalysis = new MutableAggregateAnalysis();\n     private final FunctionRegistry functionRegistry;\n     private final Set<Expression> groupBy;\n+    private boolean foundExpressionInGroupBy = false;\n+\n \n     // The list of columns from the source schema that are used in aggregate columns, but not as\n     // parameters to the aggregate functions and which are not part of the GROUP BY clause:\n-    private final List<ColumnReferenceExp> aggSelectsNotPartOfGroupBy = new ArrayList<>();\n+    private final List<Expression> aggSelectsNotPartOfGroupBy = new ArrayList<>();", "originalCommit": "2f21890966358df12225c90e6c37fed7f32f8a48", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA1ODY1OA==", "url": "https://github.com/confluentinc/ksql/pull/5998#discussion_r470058658", "bodyText": "is there a reason this code is still commented out?", "author": "agavra", "createdAt": "2020-08-13T16:00:05Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/AggregateAnalyzer.java", "diffHunk": "@@ -204,9 +226,18 @@ private void throwOnWindowBoundColumnIfWindowedAggregate(\n \n     private void captureNonAggregateSelectNotPartOfGroupBy(\n         final Expression expression,\n-        final Set<ColumnReferenceExp> nonAggParams\n+        final Set<Expression> nonAggParams\n     ) {\n-      final boolean matchesGroupBy = groupBy.contains(expression);\n+\n+      boolean matchesGroupBy = false;\n+      // If the non-Agg expression is a function, then all its arguments must be part of the\n+      // grouping columns. Note, they may be nested inside other functions.\n+      /*if (expression instanceof FunctionCall) {\n+        matchesGroupBy = functionContainsOnlyGroupingColumns(expression, true);\n+      } else {\n+        matchesGroupBy = groupBy.contains(expression);\n+      }*/", "originalCommit": "2f21890966358df12225c90e6c37fed7f32f8a48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTczMjg2Ng==", "url": "https://github.com/confluentinc/ksql/pull/5998#discussion_r471732866", "bodyText": "Sorry, forgot to remove", "author": "vpapavas", "createdAt": "2020-08-17T19:39:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA1ODY1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA0ODg0MA==", "url": "https://github.com/confluentinc/ksql/pull/5998#discussion_r472048840", "bodyText": "+1", "author": "big-andy-coates", "createdAt": "2020-08-18T09:36:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA1ODY1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA1OTA0NA==", "url": "https://github.com/confluentinc/ksql/pull/5998#discussion_r470059044", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private void captureNoneAggregateHavingNotPartOfGroupBy(final Expression nonAggColumn) {\n          \n          \n            \n                private void captureNonAggregateHavingNotPartOfGroupBy(final Expression nonAggColumn) {", "author": "agavra", "createdAt": "2020-08-13T16:00:44Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/AggregateAnalyzer.java", "diffHunk": "@@ -221,15 +252,15 @@ private void captureNonAggregateSelectNotPartOfGroupBy(\n     }\n \n     private void captureAggregateSelectNotPartOfGroupBy(\n-        final Set<ColumnReferenceExp> nonAggParams\n+        final Set<Expression> nonAggParams\n     ) {\n       nonAggParams.stream()\n           .filter(param -> !groupBy.contains(param))\n           .forEach(aggSelectsNotPartOfGroupBy::add);\n     }\n \n-    private void captureNoneAggregateHavingNotPartOfGroupBy(final ColumnReferenceExp nonAggColumn) {\n-      if (groupBy.contains(new UnqualifiedColumnReferenceExp(nonAggColumn.getColumnName()))) {\n+    private void captureNoneAggregateHavingNotPartOfGroupBy(final Expression nonAggColumn) {", "originalCommit": "2f21890966358df12225c90e6c37fed7f32f8a48", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA2MTUyNw==", "url": "https://github.com/confluentinc/ksql/pull/5998#discussion_r470061527", "bodyText": "I'm a little confused here, why do we unset the foundExpressioninGroupBy here? I feel like we should set it right after we set it and call super. For example we should unset it after calling super.visitSubscriptExpression(node, context);", "author": "agavra", "createdAt": "2020-08-13T16:04:38Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/AggregateAnalyzer.java", "diffHunk": "@@ -344,8 +384,10 @@ public Void visitUnqualifiedColumnReference(\n         final UnqualifiedColumnReferenceExp node,\n         final Void context\n     ) {\n-      dereferenceCollector.accept(aggFunctionName, node);\n-\n+      if (!foundExpressionInGroupBy || visitedAggFunction) {\n+        dereferenceCollector.accept(aggFunctionName, node);\n+      }\n+      foundExpressionInGroupBy = false;", "originalCommit": "2f21890966358df12225c90e6c37fed7f32f8a48", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA2NDYyNQ==", "url": "https://github.com/confluentinc/ksql/pull/5998#discussion_r470064625", "bodyText": "are there any other expressions that we should be looking that can match exactly other than function calls and subscript expressions? i.e. what about arithmetic expressions (SELECT AS_VALUE(a + b) AS foo GROUP BY a + b)\nI think it makes sense to implement this in visitExpression instead of in each individual expression type. We would only \"override\" this behavior when we need to (e.g. inside visitFuncitonCall)", "author": "agavra", "createdAt": "2020-08-13T16:09:39Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/AggregateAnalyzer.java", "diffHunk": "@@ -359,5 +401,14 @@ public Void visitQualifiedColumnReference(\n     ) {\n       throw new UnsupportedOperationException(\"Should of been converted to unqualified\");\n     }\n+\n+    @Override\n+    public Void visitSubscriptExpression(final SubscriptExpression node, final Void context) {", "originalCommit": "2f21890966358df12225c90e6c37fed7f32f8a48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg3NDM3OQ==", "url": "https://github.com/confluentinc/ksql/pull/5998#discussion_r471874379", "bodyText": "I need to check for arithmetic expressions.\nYes, this is a good point in the sense that we need to figure out which expressions need special handling. However, there is no visitExpression in TraversalExpressionVisitor unless I misunderstand what you meant.", "author": "vpapavas", "createdAt": "2020-08-18T02:18:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA2NDYyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQzNzczNg==", "url": "https://github.com/confluentinc/ksql/pull/5998#discussion_r472437736", "bodyText": "@agavra The approach of putting the \"common\" code in process doesn't work. Reason being is that if the parent expression exists in the group by e.g. (a+b), it will set the flag foundExpressionInGroupBy to true and will continue visiting the children, a and b. If a child doesn't exist in the group by, it will set the flag to false. All the rest of the children then (b in this example), will fail and will wrongly get added to the nonAggParams.\nTLDR: the flag must be set to false only after the entire tree of the expression has been visited. And that is only possible to do in the specific method for each expression", "author": "vpapavas", "createdAt": "2020-08-18T19:43:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA2NDYyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM3MzUzMg==", "url": "https://github.com/confluentinc/ksql/pull/5998#discussion_r473373532", "bodyText": "look at my newest comment, I think we have that problem anyway. I still think we should be able to do this in the common process if you take the suggestion I have there.", "author": "agavra", "createdAt": "2020-08-19T22:09:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA2NDYyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM3NTY1OQ==", "url": "https://github.com/confluentinc/ksql/pull/5998#discussion_r473375659", "bodyText": "#5998 (comment)", "author": "agavra", "createdAt": "2020-08-19T22:12:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA2NDYyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA2ODUxNw==", "url": "https://github.com/confluentinc/ksql/pull/5998#discussion_r470068517", "bodyText": "why can't this be part of the Visitor directly? it seems weird for this to carry over between process steps (lines 95 -> 109)", "author": "agavra", "createdAt": "2020-08-13T16:16:05Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/AggregateAnalyzer.java", "diffHunk": "@@ -68,17 +69,19 @@ public AggregateAnalysisResult analyze(\n     private final MutableAggregateAnalysis aggregateAnalysis = new MutableAggregateAnalysis();\n     private final FunctionRegistry functionRegistry;\n     private final Set<Expression> groupBy;\n+    private boolean foundExpressionInGroupBy = false;", "originalCommit": "2f21890966358df12225c90e6c37fed7f32f8a48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA0Njk1NQ==", "url": "https://github.com/confluentinc/ksql/pull/5998#discussion_r472046955", "bodyText": "+1", "author": "big-andy-coates", "createdAt": "2020-08-18T09:33:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA2ODUxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA0ODY1OQ==", "url": "https://github.com/confluentinc/ksql/pull/5998#discussion_r472048659", "bodyText": "The comment on line 190 refers to code now on line 194.  Can you move this if statement above the comment please?", "author": "big-andy-coates", "createdAt": "2020-08-18T09:36:24Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/AggregateAnalyzer.java", "diffHunk": "@@ -128,48 +137,61 @@ private void processSelect(final Expression expression) {\n     }\n \n     private void processGroupBy(final Expression expression) {\n-      final AggregateVisitor visitor = new AggregateVisitor(this, (aggFuncName, node) -> {\n-        if (aggFuncName.isPresent()) {\n-          throw new KsqlException(\"GROUP BY does not support aggregate functions: \"\n-              + aggFuncName.get().text() + \" is an aggregate function.\");\n-        }\n-        throwOnWindowBoundColumnIfWindowedAggregate(node);\n-      });\n+      final AggregateVisitor visitor = new AggregateVisitor(\n+          this,\n+          groupBy,\n+          foundExpressionInGroupBy,\n+          (aggFuncName, node) -> {\n+            if (aggFuncName.isPresent()) {\n+              throw new KsqlException(\"GROUP BY does not support aggregate functions: \"\n+                  + aggFuncName.get().text() + \" is an aggregate function.\");\n+            }\n+            throwOnWindowBoundColumnIfWindowedAggregate(node);\n+          });\n \n       visitor.process(expression, null);\n     }\n \n     private void processWhere(final Expression expression) {\n-      final AggregateVisitor visitor = new AggregateVisitor(this, (aggFuncName, node) ->\n-          throwOnWindowBoundColumnIfWindowedAggregate(node));\n+      final AggregateVisitor visitor = new AggregateVisitor(\n+          this,\n+          groupBy,\n+          foundExpressionInGroupBy,\n+          (aggFuncName, node) ->\n+            throwOnWindowBoundColumnIfWindowedAggregate(node));\n \n       visitor.process(expression, null);\n     }\n \n     private void processHaving(final Expression expression) {\n-      final AggregateVisitor visitor = new AggregateVisitor(this, (aggFuncName, node) -> {\n-        throwOnWindowBoundColumnIfWindowedAggregate(node);\n-\n-        if (!aggFuncName.isPresent()) {\n-          captureNoneAggregateHavingNotPartOfGroupBy(node);\n-        }\n-      });\n+      final AggregateVisitor visitor = new AggregateVisitor(\n+          this,\n+          groupBy,\n+          foundExpressionInGroupBy,\n+          (aggFuncName, node) -> {\n+            throwOnWindowBoundColumnIfWindowedAggregate(node);\n+\n+            if (!aggFuncName.isPresent()) {\n+              captureNoneAggregateHavingNotPartOfGroupBy(node);\n+            }\n+          });\n \n       visitor.process(expression, null);\n \n       aggregateAnalysis.setHavingExpression(expression);\n     }\n \n-    private void throwOnWindowBoundColumnIfWindowedAggregate(\n-        final ColumnReferenceExp node\n-    ) {\n+    private void throwOnWindowBoundColumnIfWindowedAggregate(final Expression node) {\n       // Window bounds are supported for operations on windowed sources\n       if (!analysis.getWindowExpression().isPresent()) {\n         return;\n       }\n \n       // For non-windowed sources, with a windowed GROUP BY, they are only supported in selects:\n-      if (SystemColumns.isWindowBound(node.getColumnName())) {\n+      if (!(node instanceof ColumnReferenceExp)) {\n+        return;\n+      }", "originalCommit": "2f21890966358df12225c90e6c37fed7f32f8a48", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3b13e92ce5bf09c84b11f20223cb4edb972e9919", "url": "https://github.com/confluentinc/ksql/commit/3b13e92ce5bf09c84b11f20223cb4edb972e9919", "message": "fixed window bounds error", "committedDate": "2020-08-19T17:31:13Z", "type": "forcePushed"}, {"oid": "0ae5730aaebb0bc0866409fb2221103a7d59ed98", "url": "https://github.com/confluentinc/ksql/commit/0ae5730aaebb0bc0866409fb2221103a7d59ed98", "message": "fixed handling subscript and nested functions", "committedDate": "2020-08-19T19:34:29Z", "type": "commit"}, {"oid": "9d8c340df9b8cd219224ea08ca006a5a3fe9513d", "url": "https://github.com/confluentinc/ksql/commit/9d8c340df9b8cd219224ea08ca006a5a3fe9513d", "message": "remove intermediate topics from test file", "committedDate": "2020-08-19T19:34:29Z", "type": "commit"}, {"oid": "d81c2553142f4ca3a877edf54909b903dd330587", "url": "https://github.com/confluentinc/ksql/commit/d81c2553142f4ca3a877edf54909b903dd330587", "message": "addressed comments, handle struct and arithmetic, added plans", "committedDate": "2020-08-19T19:34:29Z", "type": "commit"}, {"oid": "1056b221b710bec7d8c01590caa249c7fa3e84e5", "url": "https://github.com/confluentinc/ksql/commit/1056b221b710bec7d8c01590caa249c7fa3e84e5", "message": "fixed window bounds error", "committedDate": "2020-08-19T19:34:30Z", "type": "commit"}, {"oid": "cdd21f7139fc6c11f2d7d8ca11a4766ffe6c63b0", "url": "https://github.com/confluentinc/ksql/commit/cdd21f7139fc6c11f2d7d8ca11a4766ffe6c63b0", "message": "adding historic plans", "committedDate": "2020-08-19T19:53:37Z", "type": "commit"}, {"oid": "cdd21f7139fc6c11f2d7d8ca11a4766ffe6c63b0", "url": "https://github.com/confluentinc/ksql/commit/cdd21f7139fc6c11f2d7d8ca11a4766ffe6c63b0", "message": "adding historic plans", "committedDate": "2020-08-19T19:53:37Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM1NjE0OA==", "url": "https://github.com/confluentinc/ksql/pull/5998#discussion_r473356148", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private boolean foundExpressionInGroupBy;\n          \n          \n            \n                private boolean currentlyInExpressionThatIsPartOfGroupBy;\n          \n      \n    \n    \n  \n\nVery lengthy name, but I think it'll make the code easier to read", "author": "agavra", "createdAt": "2020-08-19T21:48:18Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/AggregateAnalyzer.java", "diffHunk": "@@ -290,21 +278,25 @@ private void enforceAggregateRules() {\n \n   private static final class AggregateVisitor extends TraversalExpressionVisitor<Void> {\n \n-    private final BiConsumer<Optional<FunctionName>, ColumnReferenceExp> dereferenceCollector;\n+    private final BiConsumer<Optional<FunctionName>, Expression> dereferenceCollector;\n     private final ColumnReferenceExp defaultArgument;\n     private final MutableAggregateAnalysis aggregateAnalysis;\n     private final FunctionRegistry functionRegistry;\n+    private final Set<Expression> groupBy;\n+    private boolean foundExpressionInGroupBy;", "originalCommit": "cdd21f7139fc6c11f2d7d8ca11a4766ffe6c63b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM1NjQxOA==", "url": "https://github.com/confluentinc/ksql/pull/5998#discussion_r473356418", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private boolean visitedAggFunction = false;\n          \n          \n            \n                private boolean currentlyInAggegateFunctionCall = false;", "author": "agavra", "createdAt": "2020-08-19T21:48:38Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/AggregateAnalyzer.java", "diffHunk": "@@ -290,21 +278,25 @@ private void enforceAggregateRules() {\n \n   private static final class AggregateVisitor extends TraversalExpressionVisitor<Void> {\n \n-    private final BiConsumer<Optional<FunctionName>, ColumnReferenceExp> dereferenceCollector;\n+    private final BiConsumer<Optional<FunctionName>, Expression> dereferenceCollector;\n     private final ColumnReferenceExp defaultArgument;\n     private final MutableAggregateAnalysis aggregateAnalysis;\n     private final FunctionRegistry functionRegistry;\n+    private final Set<Expression> groupBy;\n+    private boolean foundExpressionInGroupBy;\n \n     private Optional<FunctionName> aggFunctionName = Optional.empty();\n     private boolean visitedAggFunction = false;", "originalCommit": "cdd21f7139fc6c11f2d7d8ca11a4766ffe6c63b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM3MTQ4Mg==", "url": "https://github.com/confluentinc/ksql/pull/5998#discussion_r473371482", "bodyText": "tl;dr this comment is a little hard to follow because I was understanding the problem as I wrote the comment. basically we need to make sure that only the first node that sets foundExpressionInGroupBy=true can set it back to false.\n\nso here's a freak scenario:\nSELECT as_value(a['idx'] + b['idx']) FROM s GROUP BY a['idx'], a['idx'] + b['idx']\nvisit a['idx'] + b['idx'] and set foundExpressionInGroupBy = true\nvisit (left)  a['idx'] and set foundExpressionInGroupBy = true\nvisit 'idx'\ngo back to a['idx'] and set foundExpressionInGroupBy = false\nvisit (right) b['idx'] and fail because b['idx'] is not in group by\nI think there are actually a few bugs here:\n\nis what I showed with the weird group by scenario\nthere is another bug where we shouldn't set foundExpressionInGroupBy to false unless the exact node that set it to true decides so\n\nthat (number 2 above) could be an even simpler bug:\n-- a is map<string, map<string, string>>\nSELECT as_value(a[b][c]) FROM s GROUP BY a[b][c];\nwe set foundExpressionInGroupBy to true when we visit a[b][c] but then set it to false when we visit a[b] causing us to fail when we visit [c]\nI think the solution here is to have a more complicated foundExpressionInGroupBy that once it is set, nobody else can set/unset it until we get back to whoever it was that first set it. You can use a tuple of (foundExpressionInGroupBy, theGroupByExpression) to achieve this\nplease add tests for this too!", "author": "agavra", "createdAt": "2020-08-19T22:07:20Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/AggregateAnalyzer.java", "diffHunk": "@@ -359,5 +359,46 @@ public Void visitQualifiedColumnReference(\n     ) {\n       throw new UnsupportedOperationException(\"Should of been converted to unqualified\");\n     }\n+\n+    @Override\n+    public Void visitSubscriptExpression(final SubscriptExpression node, final Void context) {\n+      if (groupBy.contains(node)) {\n+        foundExpressionInGroupBy = true;\n+      }\n+      super.visitSubscriptExpression(node, context);\n+      foundExpressionInGroupBy = false;\n+      return null;\n+    }\n+\n+    @Override\n+    public Void visitArithmeticBinary(final ArithmeticBinaryExpression node, final Void context) {", "originalCommit": "cdd21f7139fc6c11f2d7d8ca11a4766ffe6c63b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b76bb75946057442239f74eef06e192522d2071e", "url": "https://github.com/confluentinc/ksql/commit/b76bb75946057442239f74eef06e192522d2071e", "message": "addressed Almog's comments", "committedDate": "2020-08-20T02:12:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDExMDg0OQ==", "url": "https://github.com/confluentinc/ksql/pull/5998#discussion_r474110849", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * 1) expressions in non-aggregate functions are part of the grouping clause,\n          \n          \n            \n               * 1) expressions not in aggregate functions are part of the grouping clause,", "author": "agavra", "createdAt": "2020-08-20T16:24:13Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/AggregateAnalyzer.java", "diffHunk": "@@ -276,17 +273,31 @@ private void enforceAggregateRules() {\n     }\n   }\n \n+  /**\n+   * This visitor performs two tasks: Create the input schema to the AggregateNode and validations.\n+   *\n+   * For creating the input schema, it checks if any expression along the path from the root\n+   * expression to the leaf (UnqualifiedColumnReference) is part of the groupBy. If at least one is,\n+   * then the UnqualifiedColumnReference is added to the schema.\n+   *\n+   * For validation, the visitor checks that:\n+   * 1) expressions in non-aggregate functions are part of the grouping clause,", "originalCommit": "b76bb75946057442239f74eef06e192522d2071e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEyMjE5NA==", "url": "https://github.com/confluentinc/ksql/pull/5998#discussion_r474122194", "bodyText": "It's actually correct what I wrote :P  It will throw if expressions used in aggregate functions are not part of the group by", "author": "vpapavas", "createdAt": "2020-08-20T16:39:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDExMDg0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDEyOTQwMg==", "url": "https://github.com/confluentinc/ksql/pull/5998#discussion_r474129402", "bodyText": "It will throw if expressions used in aggregate functions are not part of the group by\n\nnow I'm more confused \ud83d\ude02 expressions in aggregate functions must not be part of the group by - SELECT id, SUM(foo) FROM s GROUP BY id works (foo is an aggregate function parameter not in group by)\nWhat you had originally written is true, but does not cover everything. It says expressions in UDFs (not UDAFs) must be part of the grouping clause (true). But it is also true that even if they're not in a UDF, as long as they're not in an aggregate function, they must be in the grouping clause:\n--- valid\nSELECT non_agg_fun(foo), COUNT(*) from s GROUP BY foo; -- (expression in non-aggregate function)\nSELECT foo, COUNT(*) from s GROUP BY foo;  -- (expression not in aggregate function)\n\n-- invalid\nSELECT foo, COUN(T*) from s GROUP BY bar; -- (expression not in aggregate function, and not in grouping)", "author": "agavra", "createdAt": "2020-08-20T16:45:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDExMDg0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE5NjI5OQ==", "url": "https://github.com/confluentinc/ksql/pull/5998#discussion_r474196299", "bodyText": "Ah sorry, I meant expressions in non-aggregate functions must be part of group-by. So much confusion :) So, the comments say that the validator will throw if any of the conditions does not hold", "author": "vpapavas", "createdAt": "2020-08-20T18:43:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDExMDg0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE5NzUzMg==", "url": "https://github.com/confluentinc/ksql/pull/5998#discussion_r474197532", "bodyText": "Ah wait, I think I now get what you are suggesting. You are suggesting to make the sentence more general. OK, will make the change", "author": "vpapavas", "createdAt": "2020-08-20T18:46:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDExMDg0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDExMDg3NQ==", "url": "https://github.com/confluentinc/ksql/pull/5998#discussion_r474110875", "bodyText": "first, yay for comments! Thanks for writing this detailed comment, helps future people (including me when I forget what this does) understand it \ud83c\udf89\nsecond, nit: i'm pretty sure checkstyle forces the following format, but if it doesn't it'll make it easier to read anyway :D\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              /**\n          \n          \n            \n               * This visitor performs two tasks: Create the input schema to the AggregateNode and validations.\n          \n          \n            \n               *\n          \n          \n            \n               * For creating the input schema, it checks if any expression along the path from the root\n          \n          \n            \n               * expression to the leaf (UnqualifiedColumnReference) is part of the groupBy. If at least one is,\n          \n          \n            \n               * then the UnqualifiedColumnReference is added to the schema.\n          \n          \n            \n               *\n          \n          \n            \n               * For validation, the visitor checks that:\n          \n          \n            \n               * 1) expressions in non-aggregate functions are part of the grouping clause,\n          \n          \n            \n               * 2) aggregate functions are not nested\n          \n          \n            \n               * 3) window clauses (windowstart, windowend) don't appear in aggregate functions or groupBy\n          \n          \n            \n               * 4) aggregate functions don't appear in the groupBy clause\n          \n          \n            \n               * 5) expressions in the having clause are either aggregate functions or grouping keys\n          \n          \n            \n               */\n          \n          \n            \n              /**\n          \n          \n            \n               * This visitor performs two tasks: Create the input schema to the AggregateNode and validations.\n          \n          \n            \n               *\n          \n          \n            \n               * <p> For creating the input schema, it checks if any expression along the path from the root\n          \n          \n            \n               * expression to the leaf (UnqualifiedColumnReference) is part of the groupBy. If at least one is,\n          \n          \n            \n               * then the UnqualifiedColumnReference is added to the schema.\n          \n          \n            \n               *\n          \n          \n            \n               * <p>For validation, the visitor checks that:\n          \n          \n            \n               * <ol>\n          \n          \n            \n               *   <li> expressions in non-aggregate functions are part of the grouping clause </li>\n          \n          \n            \n               *   <li> aggregate functions are not nested </li>\n          \n          \n            \n               *   <li> window clauses (windowstart, windowend) don't appear in aggregate functions or groupBy </li>\n          \n          \n            \n               *   <li> aggregate functions don't appear in the groupBy clause </li>\n          \n          \n            \n               *   <li> expressions in the having clause are either aggregate functions or grouping keys </li>\n          \n          \n            \n               * </ol>\n          \n          \n            \n               */", "author": "agavra", "createdAt": "2020-08-20T16:24:17Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/AggregateAnalyzer.java", "diffHunk": "@@ -276,17 +273,31 @@ private void enforceAggregateRules() {\n     }\n   }\n \n+  /**\n+   * This visitor performs two tasks: Create the input schema to the AggregateNode and validations.\n+   *\n+   * For creating the input schema, it checks if any expression along the path from the root\n+   * expression to the leaf (UnqualifiedColumnReference) is part of the groupBy. If at least one is,\n+   * then the UnqualifiedColumnReference is added to the schema.\n+   *\n+   * For validation, the visitor checks that:\n+   * 1) expressions in non-aggregate functions are part of the grouping clause,\n+   * 2) aggregate functions are not nested\n+   * 3) window clauses (windowstart, windowend) don't appear in aggregate functions or groupBy\n+   * 4) aggregate functions don't appear in the groupBy clause\n+   * 5) expressions in the having clause are either aggregate functions or grouping keys\n+   */", "originalCommit": "b76bb75946057442239f74eef06e192522d2071e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDExMjU0MA==", "url": "https://github.com/confluentinc/ksql/pull/5998#discussion_r474112540", "bodyText": "do we ever actually use the boolean? it looks like we proxy for it by checking != null", "author": "agavra", "createdAt": "2020-08-20T16:26:44Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/analyzer/AggregateAnalyzer.java", "diffHunk": "@@ -300,6 +311,19 @@ private AggregateVisitor(\n       this.dereferenceCollector = requireNonNull(dereferenceCollector, \"dereferenceCollector\");\n     }\n \n+    @Override\n+    public Void process(final Expression node, final Void context) {\n+      if (groupBy.contains(node) && currentlyInExpressionPartOfGroupBy == null) {\n+        currentlyInExpressionPartOfGroupBy = new Pair<>(node, true);", "originalCommit": "b76bb75946057442239f74eef06e192522d2071e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE5NjgyMQ==", "url": "https://github.com/confluentinc/ksql/pull/5998#discussion_r474196821", "bodyText": "You are right, will change it. The initial intention was to use it", "author": "vpapavas", "createdAt": "2020-08-20T18:44:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDExMjU0MA=="}], "type": "inlineReview"}, {"oid": "3a50410accd82614ed30f12bae414b41720e7d74", "url": "https://github.com/confluentinc/ksql/commit/3a50410accd82614ed30f12bae414b41720e7d74", "message": "minor fixes", "committedDate": "2020-08-20T19:33:47Z", "type": "commit"}]}