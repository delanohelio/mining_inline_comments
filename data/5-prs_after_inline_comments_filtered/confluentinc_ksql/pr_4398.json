{"pr_number": 4398, "pr_title": "feat: Implement pull query routing to standbys if active is down", "pr_createdAt": "2020-01-28T21:45:05Z", "pr_url": "https://github.com/confluentinc/ksql/pull/4398", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU2MDgzMA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r372560830", "bodyText": "Is this an outstanding todo?", "author": "big-andy-coates", "createdAt": "2020-01-29T18:40:22Z", "path": "ksql-common/src/main/java/io/confluent/ksql/util/KsqlConfig.java", "diffHunk": "@@ -165,12 +165,25 @@\n       \"Config to enable or disable transient pull queries on a specific KSQL server.\";\n   public static final boolean KSQL_QUERY_PULL_ENABLE_DEFAULT = true;\n \n+  // Shall we remove this config?", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ5NDUxNQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r374494515", "bodyText": "If its not used anymore, yes. lets remove it", "author": "vinothchandar", "createdAt": "2020-02-04T06:32:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU2MDgzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDgyMDQ5NA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r374820494", "bodyText": "REmoved", "author": "vpapavas", "createdAt": "2020-02-04T17:39:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU2MDgzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU2MTk0MA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r372561940", "bodyText": "Might be worth briefly mentioning how accuracy is sacrificed when using standbys, i.e. call out that standbys are updated asynchronously from the changelog topic, which the primary produces to on its write path.", "author": "big-andy-coates", "createdAt": "2020-01-29T18:42:36Z", "path": "ksql-common/src/main/java/io/confluent/ksql/util/KsqlConfig.java", "diffHunk": "@@ -165,12 +165,25 @@\n       \"Config to enable or disable transient pull queries on a specific KSQL server.\";\n   public static final boolean KSQL_QUERY_PULL_ENABLE_DEFAULT = true;\n \n+  // Shall we remove this config?\n   public static final String KSQL_QUERY_PULL_ROUTING_TIMEOUT_MS_CONFIG =\n       \"ksql.query.pull.routing.timeout.ms\";\n   public static final Long KSQL_QUERY_PULL_ROUTING_TIMEOUT_MS_DEFAULT = 30000L;\n   public static final String KSQL_QUERY_PULL_ROUTING_TIMEOUT_MS_DOC = \"Timeout in milliseconds \"\n       + \"when waiting for the lookup of the owner of a row key\";\n \n+\n+  public static final String KSQL_QUERY_PULL_ENABLE_STALE_READS =\n+      \"ksql.query.pull.enable.stale.reads\";\n+  private static final String KSQL_QUERY_PULL_ENABLE_STALE_READS_DOC =\n+      \"Config to enable/disable forwarding pull queries to standby hosts when the active is dead. \"\n+          + \"Effectively, the accuracy of pull queries is sacrificed for higher availability. \"\n+          + \"Possible values are \\\"true\\\", \\\"false\\\". Setting to \\\"true\\\" guarantees high \"\n+          + \"availability for pull queries. If set to \\\"false\\\", pull queries will fail when\"\n+          + \"the active is dead and until a new active is elected. Default value is \\\"false\\\". \";", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU2MjM4NA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r372562384", "bodyText": "Personally, I'd inline this. Nothing else references it. But not biggie either way.", "author": "big-andy-coates", "createdAt": "2020-01-29T18:43:25Z", "path": "ksql-common/src/main/java/io/confluent/ksql/util/KsqlConfig.java", "diffHunk": "@@ -165,12 +165,25 @@\n       \"Config to enable or disable transient pull queries on a specific KSQL server.\";\n   public static final boolean KSQL_QUERY_PULL_ENABLE_DEFAULT = true;\n \n+  // Shall we remove this config?\n   public static final String KSQL_QUERY_PULL_ROUTING_TIMEOUT_MS_CONFIG =\n       \"ksql.query.pull.routing.timeout.ms\";\n   public static final Long KSQL_QUERY_PULL_ROUTING_TIMEOUT_MS_DEFAULT = 30000L;\n   public static final String KSQL_QUERY_PULL_ROUTING_TIMEOUT_MS_DOC = \"Timeout in milliseconds \"\n       + \"when waiting for the lookup of the owner of a row key\";\n \n+\n+  public static final String KSQL_QUERY_PULL_ENABLE_STALE_READS =\n+      \"ksql.query.pull.enable.stale.reads\";\n+  private static final String KSQL_QUERY_PULL_ENABLE_STALE_READS_DOC =\n+      \"Config to enable/disable forwarding pull queries to standby hosts when the active is dead. \"\n+          + \"Effectively, the accuracy of pull queries is sacrificed for higher availability. \"\n+          + \"Possible values are \\\"true\\\", \\\"false\\\". Setting to \\\"true\\\" guarantees high \"\n+          + \"availability for pull queries. If set to \\\"false\\\", pull queries will fail when\"\n+          + \"the active is dead and until a new active is elected. Default value is \\\"false\\\". \";\n+  public static final boolean KSQL_QUERY_PULL_ENABLE_STALE_READS_DEFAULT = false;", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzU2MDY2MA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373560660", "bodyText": "I actually like having it named because otherwise it's hard to know what it stands for in the method call", "author": "agavra", "createdAt": "2020-01-31T16:13:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU2MjM4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU2MjgwOA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r372562808", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Send a request to remote Ksql server to inquire to inquire about which state stores the\n          \n          \n            \n               * Send a request to remote Ksql server to inquire about which state stores the", "author": "big-andy-coates", "createdAt": "2020-01-29T18:44:16Z", "path": "ksql-execution/src/main/java/io/confluent/ksql/services/SimpleKsqlClient.java", "diffHunk": "@@ -55,4 +56,12 @@ void makeAsyncHeartbeatRequest(\n    * @return response containing the cluster status.\n    */\n   RestResponse<ClusterStatusResponse> makeClusterStatusRequest(URI serverEndPoint);\n+\n+  /**\n+   * Send a request to remote Ksql server to inquire to inquire about which state stores the", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU2NDIyMQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r372564221", "bodyText": "Personally, I'd leave this called hostsStatus.  Generally, avoid naming things by their type or the types attributes, e.g. avoid immutable, final List, Map etc in the name of things.\nThis is especially true in this case as the value the field points to can be changed!  Sure, the map is immutable, but the field isn't.   The map's HostValue type is also currently mutable.\nIn short, this field is not immutable in any way, shape, or form ;)\nIf HostInfo immutable? It probably should be if it's going to be the key of a map.", "author": "big-andy-coates", "createdAt": "2020-01-29T18:47:02Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java", "diffHunk": "@@ -76,18 +72,18 @@\n   private static final int SERVICE_TIMEOUT_SEC = 2;\n   private static final int CHECK_HEARTBEAT_DELAY_MS = 1000;\n   private static final int SEND_HEARTBEAT_DELAY_MS = 100;\n+  private static final int DISCOVER_CLUSTER_DELAY_MS = 50;\n   private static final Logger LOG = LoggerFactory.getLogger(HeartbeatAgent.class);\n \n   private final KsqlEngine engine;\n   private final ServiceContext serviceContext;\n   private final HeartbeatConfig config;\n-  private final ConcurrentHashMap<String, TreeMap<Long, HeartbeatInfo>> receivedHeartbeats;\n-  private final ConcurrentHashMap<String, HostStatusEntity> hostsStatus;\n+  private final ConcurrentHashMap<HostInfo, TreeMap<Long, HeartbeatInfo>> receivedHeartbeats;\n+  private final AtomicReference<ImmutableMap<HostInfo, HostStatus>> immutableHostsStatus;", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzczNTg1MA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373735850", "bodyText": "I renamed it and created KsqlHost as an immutable class since HostInfo is from KStreams", "author": "vpapavas", "createdAt": "2020-02-01T00:03:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU2NDIyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU2NDQ1Mg==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r372564452", "bodyText": "this.immutableHostsStatus = new AtomicReference<>(ImmutableMap.of());", "author": "big-andy-coates", "createdAt": "2020-01-29T18:47:30Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java", "diffHunk": "@@ -105,7 +101,8 @@ private HeartbeatAgent(final KsqlEngine engine,\n     this.serviceManager = new ServiceManager(Arrays.asList(\n         new DiscoverClusterService(), new SendHeartbeatService(), new CheckHeartbeatService()));\n     this.receivedHeartbeats = new ConcurrentHashMap<>();\n-    this.hostsStatus = new ConcurrentHashMap<>();\n+    this.immutableHostsStatus = new AtomicReference<>();\n+    immutableHostsStatus.set(ImmutableMap.of());", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU2NDg4MQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r372564881", "bodyText": "immutableHostsStatus.set(ImmutableMap.copyOf(status);", "author": "big-andy-coates", "createdAt": "2020-01-29T18:48:21Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java", "diffHunk": "@@ -128,13 +124,14 @@ public void receiveHeartbeat(final HostInfo hostInfo, final long timestamp) {\n    * Returns the current view of the cluster containing all hosts discovered (whether alive or dead)\n    * @return status of discovered hosts\n    */\n-  public Map<String, HostStatusEntity> getHostsStatus() {\n-    return Collections.unmodifiableMap(hostsStatus);\n+  public Map<HostInfo, HostStatus> getHostsStatus() {\n+    return immutableHostsStatus.get();\n   }\n \n   @VisibleForTesting\n-  void setHostsStatus(final Map<String, HostStatusEntity> status) {\n-    hostsStatus.putAll(status);\n+  void setHostsStatus(final Map<HostInfo, HostStatus> status) {\n+    immutableHostsStatus.set(new ImmutableMap.Builder<HostInfo, HostStatus>()\n+                                 .putAll(status).build());", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU2NTY1NQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r372565655", "bodyText": "immutableHostsStatus.set(ImmutableMap.copyOf(copyOnWrite));", "author": "big-andy-coates", "createdAt": "2020-01-29T18:49:51Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java", "diffHunk": "@@ -233,42 +211,50 @@ protected ScheduledExecutorService executor() {\n      * @param windowEnd the end time in ms of the current window\n      */\n     private void processHeartbeats(final long windowStart, final long windowEnd) {\n+\n+      final Map<HostInfo, HostStatus> copyOnWrite = new HashMap<>(immutableHostsStatus.get());\n       // No heartbeats received -> mark all hosts as dead\n       if (receivedHeartbeats.isEmpty()) {\n-        hostsStatus.forEach((host, status) -> {\n-          if (!host.equals(localHostString)) {\n+        copyOnWrite.forEach((host, status) -> {\n+          if (!host.equals(localHostInfo)) {\n             status.setHostAlive(false);\n           }\n         });\n+        immutableHostsStatus.set(new ImmutableMap.Builder<HostInfo, HostStatus>()\n+                                     .putAll(copyOnWrite).build());", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzU2NzAyNQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373567025", "bodyText": "we're copying the map twice here (once on L215 and once here). Maybe in this case it makes more sense to use Collections.unmodifiableMap(copyOnWrite) to enforce the immutability instead of actually making a new copy if this is performance critical code (applies generally across the code base here)\nthought note, might be premature optimization given that the map is probably pretty small...", "author": "agavra", "createdAt": "2020-01-31T16:26:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU2NTY1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzczNjQyMA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373736420", "bodyText": "It is a very small map, as many entries as Ksql servers in the cluster.", "author": "vpapavas", "createdAt": "2020-02-01T00:07:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU2NTY1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU2NzUxMg==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r372567512", "bodyText": "Is HostStatus being updated/read from multiple threads?\nYou may be better making this an immutable type, which avoids race-conditions and threading issues, where the setters return new instances, e.g.\n@Immutable\npublic final class HostStatus {\n  \n  private final boolean hostAlive;\n  private final long lastStatusUpdateMs;\n\n  public HostStatus(\n      final boolean hostAlive,\n      final long lastStatusUpdateMs\n  ) {\n    this.hostAlive = hostAlive;\n    this.lastStatusUpdateMs = lastStatusUpdateMs;\n  }\n\n  public HostStatus withHostAlive(final boolean hostAlive) {\n    return new HostStatus(hostAlive, lastStatusUpdateMs);\n  }\n\n  public HostStatus setLastStatusUpdateMs(final long lastStatusUpdateMs) {\n    return new HostStatus(hostAlive, lastStatusUpdateMs);\n  }\n\n  public long getLastStatusUpdateMs() {\n    return lastStatusUpdateMs;\n  }\n\n  public boolean isHostAlive() {\n    return hostAlive;\n  }\n\n  @Override\n  public String toString() {\n    return hostAlive + \",\" + lastStatusUpdateMs;\n  }\n}", "author": "big-andy-coates", "createdAt": "2020-01-29T18:53:24Z", "path": "ksql-common/src/main/java/io/confluent/ksql/util/HostStatus.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.util;\n+\n+/**\n+ * Represent the status of a ksql host in the cluster as determined by the Heartbeat agent.\n+ * A host can alive or dead annotated with the timestamp of the last update in status.\n+ */\n+public class HostStatus {", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY5NDg5Ng==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373694896", "bodyText": "Done", "author": "vpapavas", "createdAt": "2020-01-31T21:32:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU2NzUxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQzNzgzOQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373437839", "bodyText": "Note: Without my suggested change to make HostStatus immutable, this is still leaking mutable state.", "author": "big-andy-coates", "createdAt": "2020-01-31T11:35:01Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java", "diffHunk": "@@ -128,13 +124,14 @@ public void receiveHeartbeat(final HostInfo hostInfo, final long timestamp) {\n    * Returns the current view of the cluster containing all hosts discovered (whether alive or dead)\n    * @return status of discovered hosts\n    */\n-  public Map<String, HostStatusEntity> getHostsStatus() {\n-    return Collections.unmodifiableMap(hostsStatus);\n+  public Map<HostInfo, HostStatus> getHostsStatus() {\n+    return immutableHostsStatus.get();", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzczNjEyNw==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373736127", "bodyText": "@AlanConfluent made HostStatus immutable in his PR. I thought we would only make the change in one place but I realize now that was not a good decision as it makes reviewing hard and messy. I made HostStatus immutable as well.", "author": "vpapavas", "createdAt": "2020-02-01T00:05:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQzNzgzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQzOTA5MQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373439091", "bodyText": "Wondering why you've moved this to a field?\nIMHO, making it a field makes it more likely people will try to access it before its being initialized. Explicitly passing it around makes this impossible...", "author": "big-andy-coates", "createdAt": "2020-01-31T11:38:33Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/KsqlRestApplication.java", "diffHunk": "@@ -160,6 +161,10 @@\n   private final Consumer<KsqlConfig> rocksDBConfigSetterHandler;\n   private final Optional<HeartbeatAgent> heartbeatAgent;\n \n+  // Cannot be set in constructor, depends on parent server start\n+  private KsqlConfig ksqlConfigWithPort;", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ4MjI1Mg==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r374482252", "bodyText": "Changed it back to how it was", "author": "vpapavas", "createdAt": "2020-02-04T05:36:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQzOTA5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQzOTQ2Ng==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373439466", "bodyText": "Why only if null?\nIf I were to have auto-port configuration, i.e. set the port to 0 so its auto allocated on startup, and then was to start-stop-start the server, the second start may well get a different port, so we'd need to always build the config with the port.", "author": "big-andy-coates", "createdAt": "2020-01-31T11:39:47Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/KsqlRestApplication.java", "diffHunk": "@@ -233,21 +238,28 @@ public void setupResources(final Configurable<?> config, final KsqlRestConfig ap\n   @Override\n   public void startAsync() {\n     log.info(\"KSQL RESTful API listening on {}\", StringUtils.join(getListeners(), \", \"));\n-    final KsqlConfig ksqlConfigWithPort = buildConfigWithPort();\n+    if (ksqlConfigWithPort == null) {\n+      ksqlConfigWithPort = buildConfigWithPort();\n+    }", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzU3MDIxNA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373570214", "bodyText": "@big-andy-coates - the Guava Service model doesn't allow start-stop-start, the error/sthudown states are terminal", "author": "agavra", "createdAt": "2020-01-31T16:32:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQzOTQ2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQzOTYyOA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373439628", "bodyText": "super nit: remove.", "author": "big-andy-coates", "createdAt": "2020-01-31T11:40:20Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/KsqlRestConfig.java", "diffHunk": "@@ -151,6 +151,7 @@\n   private static final String KSQL_HEARTBEAT_THREAD_POOL_SIZE_CONFIG_DOC =\n       \"Size of thread pool used for sending / processing heartbeats and cluster discovery.\";\n \n+", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ0MDg0OA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373440848", "bodyText": "This can be simplified to:\n    final HostStatus  status = allHostsStatus.get(hostInfo);\n    return status == null\n           ? true\n            : status.isHostAlive();\nwhich avoids the double lookup.\nNo biggie if you want to leave as is, but do remove the redundant allHostsStatus.isEmpty() || .\nOut of interest, how come we assume a host is alive if we have no info on it?  Naively, it would of assumed the opposite.", "author": "big-andy-coates", "createdAt": "2020-01-31T11:44:07Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/LivenessFilter.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.server;\n+\n+import io.confluent.ksql.execution.streams.RoutingFilter;\n+import io.confluent.ksql.util.HostStatus;\n+import java.util.Map;\n+import org.apache.kafka.streams.state.HostInfo;\n+\n+/**\n+ * Filters ksql hosts based on whether they are alive or dead.\n+ */\n+public class LivenessFilter implements RoutingFilter {\n+\n+  public LivenessFilter() {\n+  }\n+\n+  /**\n+   * Returns true if the host is alive. If the heartbeat agent is not enabled, all hosts are\n+   * assumed to be alive.\n+   * @param hostInfo The host for which the status is checked\n+   * @param storeName Ignored\n+   * @param partition Ignored\n+   * @return true if the host is alive, false otherwise.\n+   */\n+  @Override\n+  public boolean filter(\n+      final Map<HostInfo, HostStatus> allHostsStatus,\n+      final HostInfo hostInfo,\n+      final String storeName,\n+      final int partition) {\n+\n+    if (allHostsStatus.isEmpty() || !allHostsStatus.containsKey(hostInfo)) {\n+      return true;\n+    }\n+    return allHostsStatus.get(hostInfo).isHostAlive();", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ0MzkxOA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373443918", "bodyText": "I'd avoid logging at info for every pull query. That's a lot of noise in the logs!", "author": "big-andy-coates", "createdAt": "2020-01-31T11:53:18Z", "path": "ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsLocator.java", "diffHunk": "@@ -51,20 +63,54 @@\n   }\n \n   @Override\n-  @SuppressWarnings(\"deprecation\")\n-  public Optional<KsqlNode> locate(final Struct key) {\n-    final StreamsMetadata metadata = kafkaStreams\n-        .metadataForKey(stateStoreName, key, keySerializer);\n-\n-    if (metadata == StreamsMetadata.NOT_AVAILABLE) {\n-      return Optional.empty();\n+  public List<KsqlNode> locate(\n+      final Struct key,\n+      final Map<HostInfo, HostStatus> allHostsStatus,\n+      final List<RoutingFilter> routingFilters\n+  ) {\n+    final KeyQueryMetadata metadata = kafkaStreams\n+        .queryMetadataForKey(stateStoreName, key, keySerializer);\n+\n+    // Fail fast if Streams not ready. Let client handle it\n+    if (metadata == KeyQueryMetadata.NOT_AVAILABLE) {\n+      LOG.debug(\"KeyQueryMetadata not available for state store {} and key {}\",\n+                stateStoreName, key);\n+      throw new MaterializationException(String.format(\n+          \"KeyQueryMetadata not available for state store %s and key %s\", stateStoreName, key));\n     }\n \n-    final HostInfo hostInfo = metadata.hostInfo();\n-    return Optional.of(asNode(hostInfo));\n+    final HostInfo activeHost = metadata.getActiveHost();\n+    final Set<HostInfo> standByHosts = metadata.getStandbyHosts();\n+\n+    LOG.info(\"Before filtering: Active host {} , standby hosts {}\", activeHost, standByHosts);", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU3NDQ2MQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375574461", "bodyText": "lets move this to DEBUG or TRACE please", "author": "vinothchandar", "createdAt": "2020-02-05T23:55:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ0MzkxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ0NDg2Mw==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373444863", "bodyText": "FYI, rather than allocating a new buffer (twice) to hold all the entries, when all you want to do is iterate around them, you can just do:\nStreams.concat(Stream.of(activeHost), standByHosts.stream())", "author": "big-andy-coates", "createdAt": "2020-01-31T11:55:53Z", "path": "ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsLocator.java", "diffHunk": "@@ -51,20 +63,54 @@\n   }\n \n   @Override\n-  @SuppressWarnings(\"deprecation\")\n-  public Optional<KsqlNode> locate(final Struct key) {\n-    final StreamsMetadata metadata = kafkaStreams\n-        .metadataForKey(stateStoreName, key, keySerializer);\n-\n-    if (metadata == StreamsMetadata.NOT_AVAILABLE) {\n-      return Optional.empty();\n+  public List<KsqlNode> locate(\n+      final Struct key,\n+      final Map<HostInfo, HostStatus> allHostsStatus,\n+      final List<RoutingFilter> routingFilters\n+  ) {\n+    final KeyQueryMetadata metadata = kafkaStreams\n+        .queryMetadataForKey(stateStoreName, key, keySerializer);\n+\n+    // Fail fast if Streams not ready. Let client handle it\n+    if (metadata == KeyQueryMetadata.NOT_AVAILABLE) {\n+      LOG.debug(\"KeyQueryMetadata not available for state store {} and key {}\",\n+                stateStoreName, key);\n+      throw new MaterializationException(String.format(\n+          \"KeyQueryMetadata not available for state store %s and key %s\", stateStoreName, key));\n     }\n \n-    final HostInfo hostInfo = metadata.hostInfo();\n-    return Optional.of(asNode(hostInfo));\n+    final HostInfo activeHost = metadata.getActiveHost();\n+    final Set<HostInfo> standByHosts = metadata.getStandbyHosts();\n+\n+    LOG.info(\"Before filtering: Active host {} , standby hosts {}\", activeHost, standByHosts);\n+\n+    final List<HostInfo> hosts = new ArrayList<>();\n+    hosts.add(activeHost);\n+    hosts.addAll(standByHosts);", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ1MDI2MA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373450260", "bodyText": "Rather that passing a List<RoutingFilter> around, requiring all users to handle the iteration, you could just pass a single RoutingFilter which internally handles the iteration.\nThere are two main ways of achieving this:\n\nThe classic way of implementing a type that handles the iteration:\n\npublic final class RoutingFilters implements RoutingFilter {\n   \n    public RoutingFilters(final List<? extends RoutingFilter> filters) {\n         this.filters = ImmutableList.copyOf(requireNonNull(filters));\n    }\n\n   public  boolean filter(\n      Map<HostInfo, HostStatus> allHostsStatus,\n      HostInfo hostInfo,\n      String storeName,\n      int partition\n  ) {\n     return filters.stream()\n        .allMatch(f -> f.filter(allHostsStatus, hostInfo, storeName, partition));\n  }\n}\n\nThe more functional way of handling filter composition:\n\n@FunctionalInterface\npublic interface RoutingFilter {\n\n  boolean filter(\n      Map<HostInfo, HostStatus> allHostsStatus,\n      HostInfo hostInfo,\n      String storeName,\n      int partition);\n\n  default RoutingFilter and(final RoutingFilter other) {\n    Objects.requireNonNull(other);\n    return (allHostsStatus, hostInfo, storeName, partition) -> \n        filter(allHostsStatus, hostInfo, storeName, partition) \n            && other.filter(allHostsStatus, hostInfo, storeName, partition);\n  }\n}\nThen you can compose a list of filters into a single filter with:\nfinal Optional<RoutingFilter> reduce = filters.stream()\n        .reduce(RoutingFilter::and);\nNote, the result is an Optional to handle the case where filters is empty.  If the list is not empty you can just call get().  If the list may be empty then you could use a no-op filter as the default:\nfinal RoutingFilter filter = filters.stream()\n        .reduce(RoutingFilter::and)\n        .orElse(RoutingFilter.always());\nWhere always() is:\nstatic RoutingFilter always() {\n    return (allHostsStatus, hostInfo, storeName, partition) -> true;\n  }", "author": "big-andy-coates", "createdAt": "2020-01-31T12:11:31Z", "path": "ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsLocator.java", "diffHunk": "@@ -51,20 +63,54 @@\n   }\n \n   @Override\n-  @SuppressWarnings(\"deprecation\")\n-  public Optional<KsqlNode> locate(final Struct key) {\n-    final StreamsMetadata metadata = kafkaStreams\n-        .metadataForKey(stateStoreName, key, keySerializer);\n-\n-    if (metadata == StreamsMetadata.NOT_AVAILABLE) {\n-      return Optional.empty();\n+  public List<KsqlNode> locate(\n+      final Struct key,\n+      final Map<HostInfo, HostStatus> allHostsStatus,\n+      final List<RoutingFilter> routingFilters", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ1MDgyOA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373450828", "bodyText": "Maybe call it LivelinessFilter?", "author": "big-andy-coates", "createdAt": "2020-01-31T12:13:11Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/LivenessFilter.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.server;\n+\n+import io.confluent.ksql.execution.streams.RoutingFilter;\n+import io.confluent.ksql.util.HostStatus;\n+import java.util.Map;\n+import org.apache.kafka.streams.state.HostInfo;\n+\n+/**\n+ * Filters ksql hosts based on whether they are alive or dead.\n+ */\n+public class LivenessFilter implements RoutingFilter {", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzU3MTgxOA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373571818", "bodyText": "If I understand correctly, Liveness is a technical term (and I believe it's somewhat correctly used here): https://en.wikipedia.org/wiki/Liveness", "author": "agavra", "createdAt": "2020-01-31T16:35:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ1MDgyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzU3MjQ2Mw==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373572463", "bodyText": "I think Liveness is a technical term which applies (somewhat) to this situation: https://en.wikipedia.org/wiki/Liveness", "author": "agavra", "createdAt": "2020-01-31T16:36:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ1MDgyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ1MTY5Ng==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373451696", "bodyText": "var name suggests these are 'ordered', but they don't seem to be ordered by lag yet.  Though I see the primary is first in the list, if alive.   Is the ordering coming later, or am I missing something?", "author": "big-andy-coates", "createdAt": "2020-01-31T12:15:46Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java", "diffHunk": "@@ -173,61 +173,149 @@ public static TableRowsEntity execute(\n \n       final Struct rowKey = asKeyStruct(whereInfo.rowkey, query.getPhysicalSchema());\n \n-      final KsqlConfig ksqlConfig = statement.getConfig();\n-      final KsqlNode owner = getOwner(ksqlConfig, rowKey, mat);\n-      if (!owner.isLocal()) {\n-        return proxyTo(owner, statement, serviceContext);\n-      }\n-\n-      final Result result;\n-      if (whereInfo.windowStartBounds.isPresent()) {\n-        final Range<Instant> windowStart = whereInfo.windowStartBounds.get();\n+      final PullQueryContext pullQueryContext = new PullQueryContext(\n+          rowKey,\n+          mat,\n+          analysis,\n+          whereInfo,\n+          queryId,\n+          contextStacker);\n+\n+      return handlePullQuery(\n+          statement,\n+          executionContext,\n+          serviceContext,\n+          pullQueryContext,\n+          heartbeatAgent,\n+          routingFilters\n+      );\n \n-        final List<? extends TableRow> rows = mat.windowed()\n-            .get(rowKey, windowStart);\n+    } catch (final Exception e) {\n+      throw new KsqlStatementException(\n+          e.getMessage() == null ? \"Server Error\" : e.getMessage(),\n+          statement.getStatementText(),\n+          e\n+      );\n+    }\n+  }\n \n-        result = new Result(mat.schema(), rows);\n-      } else {\n-        final List<? extends TableRow> rows = mat.nonWindowed()\n-            .get(rowKey)\n-            .map(ImmutableList::of)\n-            .orElse(ImmutableList.of());\n+  private static TableRowsEntity handlePullQuery(\n+      final ConfiguredStatement<Query> statement,\n+      final KsqlExecutionContext executionContext,\n+      final ServiceContext serviceContext,\n+      final PullQueryContext pullQueryContext,\n+      final Optional<HeartbeatAgent> heartbeatAgent,\n+      final List<RoutingFilter> routingFilters\n+  ) {\n+    try {\n+      // Get active and standby nodes for this key\n+      final Locator locator = pullQueryContext.mat.locator();\n+      final List<KsqlNode> filteredAndOrderedNodes = locator.locate(\n+          pullQueryContext.rowKey,", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY4MDY0NQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373680645", "bodyText": "Yes, the ordering is coming in a later PR", "author": "vpapavas", "createdAt": "2020-01-31T20:54:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ1MTY5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ1Mjc1NQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373452755", "bodyText": "This if statement would be better handled as a filter, i.e. if stale reads are not enabled you install a filter at the start of the filter chain that filters out all but the primary.\nThis would massively simplify this method: all this method would need to do is iterate around the returned list.", "author": "big-andy-coates", "createdAt": "2020-01-31T12:18:33Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java", "diffHunk": "@@ -173,61 +173,149 @@ public static TableRowsEntity execute(\n \n       final Struct rowKey = asKeyStruct(whereInfo.rowkey, query.getPhysicalSchema());\n \n-      final KsqlConfig ksqlConfig = statement.getConfig();\n-      final KsqlNode owner = getOwner(ksqlConfig, rowKey, mat);\n-      if (!owner.isLocal()) {\n-        return proxyTo(owner, statement, serviceContext);\n-      }\n-\n-      final Result result;\n-      if (whereInfo.windowStartBounds.isPresent()) {\n-        final Range<Instant> windowStart = whereInfo.windowStartBounds.get();\n+      final PullQueryContext pullQueryContext = new PullQueryContext(\n+          rowKey,\n+          mat,\n+          analysis,\n+          whereInfo,\n+          queryId,\n+          contextStacker);\n+\n+      return handlePullQuery(\n+          statement,\n+          executionContext,\n+          serviceContext,\n+          pullQueryContext,\n+          heartbeatAgent,\n+          routingFilters\n+      );\n \n-        final List<? extends TableRow> rows = mat.windowed()\n-            .get(rowKey, windowStart);\n+    } catch (final Exception e) {\n+      throw new KsqlStatementException(\n+          e.getMessage() == null ? \"Server Error\" : e.getMessage(),\n+          statement.getStatementText(),\n+          e\n+      );\n+    }\n+  }\n \n-        result = new Result(mat.schema(), rows);\n-      } else {\n-        final List<? extends TableRow> rows = mat.nonWindowed()\n-            .get(rowKey)\n-            .map(ImmutableList::of)\n-            .orElse(ImmutableList.of());\n+  private static TableRowsEntity handlePullQuery(\n+      final ConfiguredStatement<Query> statement,\n+      final KsqlExecutionContext executionContext,\n+      final ServiceContext serviceContext,\n+      final PullQueryContext pullQueryContext,\n+      final Optional<HeartbeatAgent> heartbeatAgent,\n+      final List<RoutingFilter> routingFilters\n+  ) {\n+    try {\n+      // Get active and standby nodes for this key\n+      final Locator locator = pullQueryContext.mat.locator();\n+      final List<KsqlNode> filteredAndOrderedNodes = locator.locate(\n+          pullQueryContext.rowKey,\n+          heartbeatAgent.map(HeartbeatAgent::getHostsStatus).orElse(ImmutableMap.of()),\n+          routingFilters);\n+\n+      if (filteredAndOrderedNodes.isEmpty()) {\n+        throw new MaterializationException(\"All nodes are dead or exceed max allowed lag.\");\n+      }\n \n-        result = new Result(mat.schema(), rows);\n+      if (statement.getConfig().getBoolean(KsqlConfig.KSQL_QUERY_PULL_ENABLE_STALE_READS)) {", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk5MTgwMQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r374991801", "bodyText": "Done", "author": "vpapavas", "createdAt": "2020-02-04T23:57:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ1Mjc1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ1MzEzNg==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373453136", "bodyText": "potential bug: If the primary is dead filteredAndOrderedNodes.get(0) might not return the primary!\nIf you switch KSQL_QUERY_PULL_ENABLE_STALE_READS handling to a filter, as I suggest above, this would fix this issue.", "author": "big-andy-coates", "createdAt": "2020-01-31T12:19:40Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java", "diffHunk": "@@ -173,61 +173,149 @@ public static TableRowsEntity execute(\n \n       final Struct rowKey = asKeyStruct(whereInfo.rowkey, query.getPhysicalSchema());\n \n-      final KsqlConfig ksqlConfig = statement.getConfig();\n-      final KsqlNode owner = getOwner(ksqlConfig, rowKey, mat);\n-      if (!owner.isLocal()) {\n-        return proxyTo(owner, statement, serviceContext);\n-      }\n-\n-      final Result result;\n-      if (whereInfo.windowStartBounds.isPresent()) {\n-        final Range<Instant> windowStart = whereInfo.windowStartBounds.get();\n+      final PullQueryContext pullQueryContext = new PullQueryContext(\n+          rowKey,\n+          mat,\n+          analysis,\n+          whereInfo,\n+          queryId,\n+          contextStacker);\n+\n+      return handlePullQuery(\n+          statement,\n+          executionContext,\n+          serviceContext,\n+          pullQueryContext,\n+          heartbeatAgent,\n+          routingFilters\n+      );\n \n-        final List<? extends TableRow> rows = mat.windowed()\n-            .get(rowKey, windowStart);\n+    } catch (final Exception e) {\n+      throw new KsqlStatementException(\n+          e.getMessage() == null ? \"Server Error\" : e.getMessage(),\n+          statement.getStatementText(),\n+          e\n+      );\n+    }\n+  }\n \n-        result = new Result(mat.schema(), rows);\n-      } else {\n-        final List<? extends TableRow> rows = mat.nonWindowed()\n-            .get(rowKey)\n-            .map(ImmutableList::of)\n-            .orElse(ImmutableList.of());\n+  private static TableRowsEntity handlePullQuery(\n+      final ConfiguredStatement<Query> statement,\n+      final KsqlExecutionContext executionContext,\n+      final ServiceContext serviceContext,\n+      final PullQueryContext pullQueryContext,\n+      final Optional<HeartbeatAgent> heartbeatAgent,\n+      final List<RoutingFilter> routingFilters\n+  ) {\n+    try {\n+      // Get active and standby nodes for this key\n+      final Locator locator = pullQueryContext.mat.locator();\n+      final List<KsqlNode> filteredAndOrderedNodes = locator.locate(\n+          pullQueryContext.rowKey,\n+          heartbeatAgent.map(HeartbeatAgent::getHostsStatus).orElse(ImmutableMap.of()),\n+          routingFilters);\n+\n+      if (filteredAndOrderedNodes.isEmpty()) {\n+        throw new MaterializationException(\"All nodes are dead or exceed max allowed lag.\");\n+      }\n \n-        result = new Result(mat.schema(), rows);\n+      if (statement.getConfig().getBoolean(KsqlConfig.KSQL_QUERY_PULL_ENABLE_STALE_READS)) {\n+        // Nodes are ordered by preference: active is first if alive then standby nodes in\n+        // increasing order of lag.\n+        for (KsqlNode node : filteredAndOrderedNodes) {\n+          try {\n+            return routeQuery(node, statement, executionContext, serviceContext, pullQueryContext);\n+          } catch (Throwable t) {\n+            LOG.info(\"Error routing query {} to host {} \", statement.getStatementText(), node, t);\n+          }\n+        }\n       }\n+      // Only active handles the query.\n+      // Fail fast if active is dead: Let client handle retries.\n+      return routeQuery(\n+          filteredAndOrderedNodes.get(0), statement, executionContext, serviceContext,\n+          pullQueryContext);", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ5OTEyMQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r374499121", "bodyText": "+1 would be good to push that into a filter.. and keep the single loop here.", "author": "vinothchandar", "createdAt": "2020-02-04T06:50:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ1MzEzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk5MTY5NA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r374991694", "bodyText": "Done", "author": "vpapavas", "createdAt": "2020-02-04T23:57:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ1MzEzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ1MzY4OA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373453688", "bodyText": "don't catch Throwable as it includes errors.  This is bad practice.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      } catch (Throwable t) {\n          \n          \n            \n                      } catch (final Exception t) {", "author": "big-andy-coates", "createdAt": "2020-01-31T12:21:14Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java", "diffHunk": "@@ -173,61 +173,149 @@ public static TableRowsEntity execute(\n \n       final Struct rowKey = asKeyStruct(whereInfo.rowkey, query.getPhysicalSchema());\n \n-      final KsqlConfig ksqlConfig = statement.getConfig();\n-      final KsqlNode owner = getOwner(ksqlConfig, rowKey, mat);\n-      if (!owner.isLocal()) {\n-        return proxyTo(owner, statement, serviceContext);\n-      }\n-\n-      final Result result;\n-      if (whereInfo.windowStartBounds.isPresent()) {\n-        final Range<Instant> windowStart = whereInfo.windowStartBounds.get();\n+      final PullQueryContext pullQueryContext = new PullQueryContext(\n+          rowKey,\n+          mat,\n+          analysis,\n+          whereInfo,\n+          queryId,\n+          contextStacker);\n+\n+      return handlePullQuery(\n+          statement,\n+          executionContext,\n+          serviceContext,\n+          pullQueryContext,\n+          heartbeatAgent,\n+          routingFilters\n+      );\n \n-        final List<? extends TableRow> rows = mat.windowed()\n-            .get(rowKey, windowStart);\n+    } catch (final Exception e) {\n+      throw new KsqlStatementException(\n+          e.getMessage() == null ? \"Server Error\" : e.getMessage(),\n+          statement.getStatementText(),\n+          e\n+      );\n+    }\n+  }\n \n-        result = new Result(mat.schema(), rows);\n-      } else {\n-        final List<? extends TableRow> rows = mat.nonWindowed()\n-            .get(rowKey)\n-            .map(ImmutableList::of)\n-            .orElse(ImmutableList.of());\n+  private static TableRowsEntity handlePullQuery(\n+      final ConfiguredStatement<Query> statement,\n+      final KsqlExecutionContext executionContext,\n+      final ServiceContext serviceContext,\n+      final PullQueryContext pullQueryContext,\n+      final Optional<HeartbeatAgent> heartbeatAgent,\n+      final List<RoutingFilter> routingFilters\n+  ) {\n+    try {\n+      // Get active and standby nodes for this key\n+      final Locator locator = pullQueryContext.mat.locator();\n+      final List<KsqlNode> filteredAndOrderedNodes = locator.locate(\n+          pullQueryContext.rowKey,\n+          heartbeatAgent.map(HeartbeatAgent::getHostsStatus).orElse(ImmutableMap.of()),\n+          routingFilters);\n+\n+      if (filteredAndOrderedNodes.isEmpty()) {\n+        throw new MaterializationException(\"All nodes are dead or exceed max allowed lag.\");\n+      }\n \n-        result = new Result(mat.schema(), rows);\n+      if (statement.getConfig().getBoolean(KsqlConfig.KSQL_QUERY_PULL_ENABLE_STALE_READS)) {\n+        // Nodes are ordered by preference: active is first if alive then standby nodes in\n+        // increasing order of lag.\n+        for (KsqlNode node : filteredAndOrderedNodes) {\n+          try {\n+            return routeQuery(node, statement, executionContext, serviceContext, pullQueryContext);\n+          } catch (Throwable t) {", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ1NDkxNQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373454915", "bodyText": "I would be tempted to change this log line to a debug as its kind of expected behaviour during a bounce of the cluster.\nI'd also throw a MaterializationException after the iteration to avoid trying the first element of filteredAndOrderedNodes twice.  (Though this becomes a moot point if you add the filter I'm suggesting).", "author": "big-andy-coates", "createdAt": "2020-01-31T12:24:56Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java", "diffHunk": "@@ -173,61 +173,149 @@ public static TableRowsEntity execute(\n \n       final Struct rowKey = asKeyStruct(whereInfo.rowkey, query.getPhysicalSchema());\n \n-      final KsqlConfig ksqlConfig = statement.getConfig();\n-      final KsqlNode owner = getOwner(ksqlConfig, rowKey, mat);\n-      if (!owner.isLocal()) {\n-        return proxyTo(owner, statement, serviceContext);\n-      }\n-\n-      final Result result;\n-      if (whereInfo.windowStartBounds.isPresent()) {\n-        final Range<Instant> windowStart = whereInfo.windowStartBounds.get();\n+      final PullQueryContext pullQueryContext = new PullQueryContext(\n+          rowKey,\n+          mat,\n+          analysis,\n+          whereInfo,\n+          queryId,\n+          contextStacker);\n+\n+      return handlePullQuery(\n+          statement,\n+          executionContext,\n+          serviceContext,\n+          pullQueryContext,\n+          heartbeatAgent,\n+          routingFilters\n+      );\n \n-        final List<? extends TableRow> rows = mat.windowed()\n-            .get(rowKey, windowStart);\n+    } catch (final Exception e) {\n+      throw new KsqlStatementException(\n+          e.getMessage() == null ? \"Server Error\" : e.getMessage(),\n+          statement.getStatementText(),\n+          e\n+      );\n+    }\n+  }\n \n-        result = new Result(mat.schema(), rows);\n-      } else {\n-        final List<? extends TableRow> rows = mat.nonWindowed()\n-            .get(rowKey)\n-            .map(ImmutableList::of)\n-            .orElse(ImmutableList.of());\n+  private static TableRowsEntity handlePullQuery(\n+      final ConfiguredStatement<Query> statement,\n+      final KsqlExecutionContext executionContext,\n+      final ServiceContext serviceContext,\n+      final PullQueryContext pullQueryContext,\n+      final Optional<HeartbeatAgent> heartbeatAgent,\n+      final List<RoutingFilter> routingFilters\n+  ) {\n+    try {\n+      // Get active and standby nodes for this key\n+      final Locator locator = pullQueryContext.mat.locator();\n+      final List<KsqlNode> filteredAndOrderedNodes = locator.locate(\n+          pullQueryContext.rowKey,\n+          heartbeatAgent.map(HeartbeatAgent::getHostsStatus).orElse(ImmutableMap.of()),\n+          routingFilters);\n+\n+      if (filteredAndOrderedNodes.isEmpty()) {\n+        throw new MaterializationException(\"All nodes are dead or exceed max allowed lag.\");\n+      }\n \n-        result = new Result(mat.schema(), rows);\n+      if (statement.getConfig().getBoolean(KsqlConfig.KSQL_QUERY_PULL_ENABLE_STALE_READS)) {\n+        // Nodes are ordered by preference: active is first if alive then standby nodes in\n+        // increasing order of lag.\n+        for (KsqlNode node : filteredAndOrderedNodes) {\n+          try {\n+            return routeQuery(node, statement, executionContext, serviceContext, pullQueryContext);\n+          } catch (Throwable t) {\n+            LOG.info(\"Error routing query {} to host {} \", statement.getStatementText(), node, t);", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ1NTA2MA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373455060", "bodyText": "I'd avoid logging at info for each pull query.", "author": "big-andy-coates", "createdAt": "2020-01-31T12:25:24Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java", "diffHunk": "@@ -173,61 +173,149 @@ public static TableRowsEntity execute(\n \n       final Struct rowKey = asKeyStruct(whereInfo.rowkey, query.getPhysicalSchema());\n \n-      final KsqlConfig ksqlConfig = statement.getConfig();\n-      final KsqlNode owner = getOwner(ksqlConfig, rowKey, mat);\n-      if (!owner.isLocal()) {\n-        return proxyTo(owner, statement, serviceContext);\n-      }\n-\n-      final Result result;\n-      if (whereInfo.windowStartBounds.isPresent()) {\n-        final Range<Instant> windowStart = whereInfo.windowStartBounds.get();\n+      final PullQueryContext pullQueryContext = new PullQueryContext(\n+          rowKey,\n+          mat,\n+          analysis,\n+          whereInfo,\n+          queryId,\n+          contextStacker);\n+\n+      return handlePullQuery(\n+          statement,\n+          executionContext,\n+          serviceContext,\n+          pullQueryContext,\n+          heartbeatAgent,\n+          routingFilters\n+      );\n \n-        final List<? extends TableRow> rows = mat.windowed()\n-            .get(rowKey, windowStart);\n+    } catch (final Exception e) {\n+      throw new KsqlStatementException(\n+          e.getMessage() == null ? \"Server Error\" : e.getMessage(),\n+          statement.getStatementText(),\n+          e\n+      );\n+    }\n+  }\n \n-        result = new Result(mat.schema(), rows);\n-      } else {\n-        final List<? extends TableRow> rows = mat.nonWindowed()\n-            .get(rowKey)\n-            .map(ImmutableList::of)\n-            .orElse(ImmutableList.of());\n+  private static TableRowsEntity handlePullQuery(\n+      final ConfiguredStatement<Query> statement,\n+      final KsqlExecutionContext executionContext,\n+      final ServiceContext serviceContext,\n+      final PullQueryContext pullQueryContext,\n+      final Optional<HeartbeatAgent> heartbeatAgent,\n+      final List<RoutingFilter> routingFilters\n+  ) {\n+    try {\n+      // Get active and standby nodes for this key\n+      final Locator locator = pullQueryContext.mat.locator();\n+      final List<KsqlNode> filteredAndOrderedNodes = locator.locate(\n+          pullQueryContext.rowKey,\n+          heartbeatAgent.map(HeartbeatAgent::getHostsStatus).orElse(ImmutableMap.of()),\n+          routingFilters);\n+\n+      if (filteredAndOrderedNodes.isEmpty()) {\n+        throw new MaterializationException(\"All nodes are dead or exceed max allowed lag.\");\n+      }\n \n-        result = new Result(mat.schema(), rows);\n+      if (statement.getConfig().getBoolean(KsqlConfig.KSQL_QUERY_PULL_ENABLE_STALE_READS)) {\n+        // Nodes are ordered by preference: active is first if alive then standby nodes in\n+        // increasing order of lag.\n+        for (KsqlNode node : filteredAndOrderedNodes) {\n+          try {\n+            return routeQuery(node, statement, executionContext, serviceContext, pullQueryContext);\n+          } catch (Throwable t) {\n+            LOG.info(\"Error routing query {} to host {} \", statement.getStatementText(), node, t);\n+          }\n+        }\n       }\n+      // Only active handles the query.\n+      // Fail fast if active is dead: Let client handle retries.\n+      return routeQuery(\n+          filteredAndOrderedNodes.get(0), statement, executionContext, serviceContext,\n+          pullQueryContext);\n \n-      final LogicalSchema outputSchema;\n-      final List<List<?>> rows;\n-      if (isSelectStar(statement.getStatement().getSelect())) {\n-        outputSchema = TableRowsEntityFactory.buildSchema(result.schema, mat.windowType());\n-        rows = TableRowsEntityFactory.createRows(result.rows);\n-      } else {\n-        outputSchema = selectOutputSchema(result, executionContext, analysis);\n+    } catch (Throwable t) {\n+      throw new MaterializationException(String.format(\n+          \"Unable to execute pull query: %s. Error: %s\", statement.getStatementText(),\n+          t.getMessage()), t);\n+    }\n+  }\n \n-        rows = handleSelects(\n-            result,\n+  private static TableRowsEntity routeQuery(\n+      final KsqlNode node,\n+      final ConfiguredStatement<Query> statement,\n+      final KsqlExecutionContext executionContext,\n+      final ServiceContext serviceContext,\n+      final PullQueryContext pullQueryContext\n+  ) {\n+    try {\n+      if (node.isLocal()) {\n+        LOG.info(\"Query {} executed locally at host {}.\",\n+                 statement.getStatementText(), node.location());", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ1NTEwMQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373455101", "bodyText": "I'd avoid logging at info for each pull query.", "author": "big-andy-coates", "createdAt": "2020-01-31T12:25:31Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java", "diffHunk": "@@ -173,61 +173,149 @@ public static TableRowsEntity execute(\n \n       final Struct rowKey = asKeyStruct(whereInfo.rowkey, query.getPhysicalSchema());\n \n-      final KsqlConfig ksqlConfig = statement.getConfig();\n-      final KsqlNode owner = getOwner(ksqlConfig, rowKey, mat);\n-      if (!owner.isLocal()) {\n-        return proxyTo(owner, statement, serviceContext);\n-      }\n-\n-      final Result result;\n-      if (whereInfo.windowStartBounds.isPresent()) {\n-        final Range<Instant> windowStart = whereInfo.windowStartBounds.get();\n+      final PullQueryContext pullQueryContext = new PullQueryContext(\n+          rowKey,\n+          mat,\n+          analysis,\n+          whereInfo,\n+          queryId,\n+          contextStacker);\n+\n+      return handlePullQuery(\n+          statement,\n+          executionContext,\n+          serviceContext,\n+          pullQueryContext,\n+          heartbeatAgent,\n+          routingFilters\n+      );\n \n-        final List<? extends TableRow> rows = mat.windowed()\n-            .get(rowKey, windowStart);\n+    } catch (final Exception e) {\n+      throw new KsqlStatementException(\n+          e.getMessage() == null ? \"Server Error\" : e.getMessage(),\n+          statement.getStatementText(),\n+          e\n+      );\n+    }\n+  }\n \n-        result = new Result(mat.schema(), rows);\n-      } else {\n-        final List<? extends TableRow> rows = mat.nonWindowed()\n-            .get(rowKey)\n-            .map(ImmutableList::of)\n-            .orElse(ImmutableList.of());\n+  private static TableRowsEntity handlePullQuery(\n+      final ConfiguredStatement<Query> statement,\n+      final KsqlExecutionContext executionContext,\n+      final ServiceContext serviceContext,\n+      final PullQueryContext pullQueryContext,\n+      final Optional<HeartbeatAgent> heartbeatAgent,\n+      final List<RoutingFilter> routingFilters\n+  ) {\n+    try {\n+      // Get active and standby nodes for this key\n+      final Locator locator = pullQueryContext.mat.locator();\n+      final List<KsqlNode> filteredAndOrderedNodes = locator.locate(\n+          pullQueryContext.rowKey,\n+          heartbeatAgent.map(HeartbeatAgent::getHostsStatus).orElse(ImmutableMap.of()),\n+          routingFilters);\n+\n+      if (filteredAndOrderedNodes.isEmpty()) {\n+        throw new MaterializationException(\"All nodes are dead or exceed max allowed lag.\");\n+      }\n \n-        result = new Result(mat.schema(), rows);\n+      if (statement.getConfig().getBoolean(KsqlConfig.KSQL_QUERY_PULL_ENABLE_STALE_READS)) {\n+        // Nodes are ordered by preference: active is first if alive then standby nodes in\n+        // increasing order of lag.\n+        for (KsqlNode node : filteredAndOrderedNodes) {\n+          try {\n+            return routeQuery(node, statement, executionContext, serviceContext, pullQueryContext);\n+          } catch (Throwable t) {\n+            LOG.info(\"Error routing query {} to host {} \", statement.getStatementText(), node, t);\n+          }\n+        }\n       }\n+      // Only active handles the query.\n+      // Fail fast if active is dead: Let client handle retries.\n+      return routeQuery(\n+          filteredAndOrderedNodes.get(0), statement, executionContext, serviceContext,\n+          pullQueryContext);\n \n-      final LogicalSchema outputSchema;\n-      final List<List<?>> rows;\n-      if (isSelectStar(statement.getStatement().getSelect())) {\n-        outputSchema = TableRowsEntityFactory.buildSchema(result.schema, mat.windowType());\n-        rows = TableRowsEntityFactory.createRows(result.rows);\n-      } else {\n-        outputSchema = selectOutputSchema(result, executionContext, analysis);\n+    } catch (Throwable t) {\n+      throw new MaterializationException(String.format(\n+          \"Unable to execute pull query: %s. Error: %s\", statement.getStatementText(),\n+          t.getMessage()), t);\n+    }\n+  }\n \n-        rows = handleSelects(\n-            result,\n+  private static TableRowsEntity routeQuery(\n+      final KsqlNode node,\n+      final ConfiguredStatement<Query> statement,\n+      final KsqlExecutionContext executionContext,\n+      final ServiceContext serviceContext,\n+      final PullQueryContext pullQueryContext\n+  ) {\n+    try {\n+      if (node.isLocal()) {\n+        LOG.info(\"Query {} executed locally at host {}.\",\n+                 statement.getStatementText(), node.location());\n+        return queryRowsLocally(\n             statement,\n             executionContext,\n-            analysis,\n-            outputSchema,\n-            queryId,\n-            contextStacker\n-        );\n+            pullQueryContext);\n+      } else {\n+        LOG.info(\"Query {} routed to host {}.\", statement.getStatementText(), node.location());", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ1NTIyOA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373455228", "bodyText": "As above, don't catch Throwable.", "author": "big-andy-coates", "createdAt": "2020-01-31T12:25:50Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java", "diffHunk": "@@ -173,61 +173,149 @@ public static TableRowsEntity execute(\n \n       final Struct rowKey = asKeyStruct(whereInfo.rowkey, query.getPhysicalSchema());\n \n-      final KsqlConfig ksqlConfig = statement.getConfig();\n-      final KsqlNode owner = getOwner(ksqlConfig, rowKey, mat);\n-      if (!owner.isLocal()) {\n-        return proxyTo(owner, statement, serviceContext);\n-      }\n-\n-      final Result result;\n-      if (whereInfo.windowStartBounds.isPresent()) {\n-        final Range<Instant> windowStart = whereInfo.windowStartBounds.get();\n+      final PullQueryContext pullQueryContext = new PullQueryContext(\n+          rowKey,\n+          mat,\n+          analysis,\n+          whereInfo,\n+          queryId,\n+          contextStacker);\n+\n+      return handlePullQuery(\n+          statement,\n+          executionContext,\n+          serviceContext,\n+          pullQueryContext,\n+          heartbeatAgent,\n+          routingFilters\n+      );\n \n-        final List<? extends TableRow> rows = mat.windowed()\n-            .get(rowKey, windowStart);\n+    } catch (final Exception e) {\n+      throw new KsqlStatementException(\n+          e.getMessage() == null ? \"Server Error\" : e.getMessage(),\n+          statement.getStatementText(),\n+          e\n+      );\n+    }\n+  }\n \n-        result = new Result(mat.schema(), rows);\n-      } else {\n-        final List<? extends TableRow> rows = mat.nonWindowed()\n-            .get(rowKey)\n-            .map(ImmutableList::of)\n-            .orElse(ImmutableList.of());\n+  private static TableRowsEntity handlePullQuery(\n+      final ConfiguredStatement<Query> statement,\n+      final KsqlExecutionContext executionContext,\n+      final ServiceContext serviceContext,\n+      final PullQueryContext pullQueryContext,\n+      final Optional<HeartbeatAgent> heartbeatAgent,\n+      final List<RoutingFilter> routingFilters\n+  ) {\n+    try {\n+      // Get active and standby nodes for this key\n+      final Locator locator = pullQueryContext.mat.locator();\n+      final List<KsqlNode> filteredAndOrderedNodes = locator.locate(\n+          pullQueryContext.rowKey,\n+          heartbeatAgent.map(HeartbeatAgent::getHostsStatus).orElse(ImmutableMap.of()),\n+          routingFilters);\n+\n+      if (filteredAndOrderedNodes.isEmpty()) {\n+        throw new MaterializationException(\"All nodes are dead or exceed max allowed lag.\");\n+      }\n \n-        result = new Result(mat.schema(), rows);\n+      if (statement.getConfig().getBoolean(KsqlConfig.KSQL_QUERY_PULL_ENABLE_STALE_READS)) {\n+        // Nodes are ordered by preference: active is first if alive then standby nodes in\n+        // increasing order of lag.\n+        for (KsqlNode node : filteredAndOrderedNodes) {\n+          try {\n+            return routeQuery(node, statement, executionContext, serviceContext, pullQueryContext);\n+          } catch (Throwable t) {\n+            LOG.info(\"Error routing query {} to host {} \", statement.getStatementText(), node, t);\n+          }\n+        }\n       }\n+      // Only active handles the query.\n+      // Fail fast if active is dead: Let client handle retries.\n+      return routeQuery(\n+          filteredAndOrderedNodes.get(0), statement, executionContext, serviceContext,\n+          pullQueryContext);\n \n-      final LogicalSchema outputSchema;\n-      final List<List<?>> rows;\n-      if (isSelectStar(statement.getStatement().getSelect())) {\n-        outputSchema = TableRowsEntityFactory.buildSchema(result.schema, mat.windowType());\n-        rows = TableRowsEntityFactory.createRows(result.rows);\n-      } else {\n-        outputSchema = selectOutputSchema(result, executionContext, analysis);\n+    } catch (Throwable t) {\n+      throw new MaterializationException(String.format(\n+          \"Unable to execute pull query: %s. Error: %s\", statement.getStatementText(),\n+          t.getMessage()), t);\n+    }\n+  }\n \n-        rows = handleSelects(\n-            result,\n+  private static TableRowsEntity routeQuery(\n+      final KsqlNode node,\n+      final ConfiguredStatement<Query> statement,\n+      final KsqlExecutionContext executionContext,\n+      final ServiceContext serviceContext,\n+      final PullQueryContext pullQueryContext\n+  ) {\n+    try {\n+      if (node.isLocal()) {\n+        LOG.info(\"Query {} executed locally at host {}.\",\n+                 statement.getStatementText(), node.location());\n+        return queryRowsLocally(\n             statement,\n             executionContext,\n-            analysis,\n-            outputSchema,\n-            queryId,\n-            contextStacker\n-        );\n+            pullQueryContext);\n+      } else {\n+        LOG.info(\"Query {} routed to host {}.\", statement.getStatementText(), node.location());\n+        return forwardTo(node, statement, serviceContext);\n       }\n+    } catch (Throwable t) {", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ1NTQxMQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373455411", "bodyText": "nit: move this throw into the catch block.", "author": "big-andy-coates", "createdAt": "2020-01-31T12:26:21Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java", "diffHunk": "@@ -173,61 +173,149 @@ public static TableRowsEntity execute(\n \n       final Struct rowKey = asKeyStruct(whereInfo.rowkey, query.getPhysicalSchema());\n \n-      final KsqlConfig ksqlConfig = statement.getConfig();\n-      final KsqlNode owner = getOwner(ksqlConfig, rowKey, mat);\n-      if (!owner.isLocal()) {\n-        return proxyTo(owner, statement, serviceContext);\n-      }\n-\n-      final Result result;\n-      if (whereInfo.windowStartBounds.isPresent()) {\n-        final Range<Instant> windowStart = whereInfo.windowStartBounds.get();\n+      final PullQueryContext pullQueryContext = new PullQueryContext(\n+          rowKey,\n+          mat,\n+          analysis,\n+          whereInfo,\n+          queryId,\n+          contextStacker);\n+\n+      return handlePullQuery(\n+          statement,\n+          executionContext,\n+          serviceContext,\n+          pullQueryContext,\n+          heartbeatAgent,\n+          routingFilters\n+      );\n \n-        final List<? extends TableRow> rows = mat.windowed()\n-            .get(rowKey, windowStart);\n+    } catch (final Exception e) {\n+      throw new KsqlStatementException(\n+          e.getMessage() == null ? \"Server Error\" : e.getMessage(),\n+          statement.getStatementText(),\n+          e\n+      );\n+    }\n+  }\n \n-        result = new Result(mat.schema(), rows);\n-      } else {\n-        final List<? extends TableRow> rows = mat.nonWindowed()\n-            .get(rowKey)\n-            .map(ImmutableList::of)\n-            .orElse(ImmutableList.of());\n+  private static TableRowsEntity handlePullQuery(\n+      final ConfiguredStatement<Query> statement,\n+      final KsqlExecutionContext executionContext,\n+      final ServiceContext serviceContext,\n+      final PullQueryContext pullQueryContext,\n+      final Optional<HeartbeatAgent> heartbeatAgent,\n+      final List<RoutingFilter> routingFilters\n+  ) {\n+    try {\n+      // Get active and standby nodes for this key\n+      final Locator locator = pullQueryContext.mat.locator();\n+      final List<KsqlNode> filteredAndOrderedNodes = locator.locate(\n+          pullQueryContext.rowKey,\n+          heartbeatAgent.map(HeartbeatAgent::getHostsStatus).orElse(ImmutableMap.of()),\n+          routingFilters);\n+\n+      if (filteredAndOrderedNodes.isEmpty()) {\n+        throw new MaterializationException(\"All nodes are dead or exceed max allowed lag.\");\n+      }\n \n-        result = new Result(mat.schema(), rows);\n+      if (statement.getConfig().getBoolean(KsqlConfig.KSQL_QUERY_PULL_ENABLE_STALE_READS)) {\n+        // Nodes are ordered by preference: active is first if alive then standby nodes in\n+        // increasing order of lag.\n+        for (KsqlNode node : filteredAndOrderedNodes) {\n+          try {\n+            return routeQuery(node, statement, executionContext, serviceContext, pullQueryContext);\n+          } catch (Throwable t) {\n+            LOG.info(\"Error routing query {} to host {} \", statement.getStatementText(), node, t);\n+          }\n+        }\n       }\n+      // Only active handles the query.\n+      // Fail fast if active is dead: Let client handle retries.\n+      return routeQuery(\n+          filteredAndOrderedNodes.get(0), statement, executionContext, serviceContext,\n+          pullQueryContext);\n \n-      final LogicalSchema outputSchema;\n-      final List<List<?>> rows;\n-      if (isSelectStar(statement.getStatement().getSelect())) {\n-        outputSchema = TableRowsEntityFactory.buildSchema(result.schema, mat.windowType());\n-        rows = TableRowsEntityFactory.createRows(result.rows);\n-      } else {\n-        outputSchema = selectOutputSchema(result, executionContext, analysis);\n+    } catch (Throwable t) {\n+      throw new MaterializationException(String.format(\n+          \"Unable to execute pull query: %s. Error: %s\", statement.getStatementText(),\n+          t.getMessage()), t);\n+    }\n+  }\n \n-        rows = handleSelects(\n-            result,\n+  private static TableRowsEntity routeQuery(\n+      final KsqlNode node,\n+      final ConfiguredStatement<Query> statement,\n+      final KsqlExecutionContext executionContext,\n+      final ServiceContext serviceContext,\n+      final PullQueryContext pullQueryContext\n+  ) {\n+    try {\n+      if (node.isLocal()) {\n+        LOG.info(\"Query {} executed locally at host {}.\",\n+                 statement.getStatementText(), node.location());\n+        return queryRowsLocally(\n             statement,\n             executionContext,\n-            analysis,\n-            outputSchema,\n-            queryId,\n-            contextStacker\n-        );\n+            pullQueryContext);\n+      } else {\n+        LOG.info(\"Query {} routed to host {}.\", statement.getStatementText(), node.location());\n+        return forwardTo(node, statement, serviceContext);\n       }\n+    } catch (Throwable t) {\n+      LOG.info(\"Error routing query \" + statement.getStatementText() + \" to \" + node, t);\n+    }\n+    throw new MaterializationException(\n+        \"Unable to execute pull query :\" + statement.getStatementText());", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk5MTYwOQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r374991609", "bodyText": "I removed the try-catch altogether. I think it is cleaner now", "author": "vpapavas", "createdAt": "2020-02-04T23:57:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ1NTQxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ1NTc2Ng==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373455766", "bodyText": "Generally, avoid the 'log and throw' pattern. It's an anti-pattern that generally results in the same error being logged multiple times.  Better just to throw the exception and allow the exception to bubble up. The caller can determine if this is an error worth logging or not.", "author": "big-andy-coates", "createdAt": "2020-01-31T12:27:30Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java", "diffHunk": "@@ -173,61 +173,149 @@ public static TableRowsEntity execute(\n \n       final Struct rowKey = asKeyStruct(whereInfo.rowkey, query.getPhysicalSchema());\n \n-      final KsqlConfig ksqlConfig = statement.getConfig();\n-      final KsqlNode owner = getOwner(ksqlConfig, rowKey, mat);\n-      if (!owner.isLocal()) {\n-        return proxyTo(owner, statement, serviceContext);\n-      }\n-\n-      final Result result;\n-      if (whereInfo.windowStartBounds.isPresent()) {\n-        final Range<Instant> windowStart = whereInfo.windowStartBounds.get();\n+      final PullQueryContext pullQueryContext = new PullQueryContext(\n+          rowKey,\n+          mat,\n+          analysis,\n+          whereInfo,\n+          queryId,\n+          contextStacker);\n+\n+      return handlePullQuery(\n+          statement,\n+          executionContext,\n+          serviceContext,\n+          pullQueryContext,\n+          heartbeatAgent,\n+          routingFilters\n+      );\n \n-        final List<? extends TableRow> rows = mat.windowed()\n-            .get(rowKey, windowStart);\n+    } catch (final Exception e) {\n+      throw new KsqlStatementException(\n+          e.getMessage() == null ? \"Server Error\" : e.getMessage(),\n+          statement.getStatementText(),\n+          e\n+      );\n+    }\n+  }\n \n-        result = new Result(mat.schema(), rows);\n-      } else {\n-        final List<? extends TableRow> rows = mat.nonWindowed()\n-            .get(rowKey)\n-            .map(ImmutableList::of)\n-            .orElse(ImmutableList.of());\n+  private static TableRowsEntity handlePullQuery(\n+      final ConfiguredStatement<Query> statement,\n+      final KsqlExecutionContext executionContext,\n+      final ServiceContext serviceContext,\n+      final PullQueryContext pullQueryContext,\n+      final Optional<HeartbeatAgent> heartbeatAgent,\n+      final List<RoutingFilter> routingFilters\n+  ) {\n+    try {\n+      // Get active and standby nodes for this key\n+      final Locator locator = pullQueryContext.mat.locator();\n+      final List<KsqlNode> filteredAndOrderedNodes = locator.locate(\n+          pullQueryContext.rowKey,\n+          heartbeatAgent.map(HeartbeatAgent::getHostsStatus).orElse(ImmutableMap.of()),\n+          routingFilters);\n+\n+      if (filteredAndOrderedNodes.isEmpty()) {\n+        throw new MaterializationException(\"All nodes are dead or exceed max allowed lag.\");\n+      }\n \n-        result = new Result(mat.schema(), rows);\n+      if (statement.getConfig().getBoolean(KsqlConfig.KSQL_QUERY_PULL_ENABLE_STALE_READS)) {\n+        // Nodes are ordered by preference: active is first if alive then standby nodes in\n+        // increasing order of lag.\n+        for (KsqlNode node : filteredAndOrderedNodes) {\n+          try {\n+            return routeQuery(node, statement, executionContext, serviceContext, pullQueryContext);\n+          } catch (Throwable t) {\n+            LOG.info(\"Error routing query {} to host {} \", statement.getStatementText(), node, t);\n+          }\n+        }\n       }\n+      // Only active handles the query.\n+      // Fail fast if active is dead: Let client handle retries.\n+      return routeQuery(\n+          filteredAndOrderedNodes.get(0), statement, executionContext, serviceContext,\n+          pullQueryContext);\n \n-      final LogicalSchema outputSchema;\n-      final List<List<?>> rows;\n-      if (isSelectStar(statement.getStatement().getSelect())) {\n-        outputSchema = TableRowsEntityFactory.buildSchema(result.schema, mat.windowType());\n-        rows = TableRowsEntityFactory.createRows(result.rows);\n-      } else {\n-        outputSchema = selectOutputSchema(result, executionContext, analysis);\n+    } catch (Throwable t) {\n+      throw new MaterializationException(String.format(\n+          \"Unable to execute pull query: %s. Error: %s\", statement.getStatementText(),\n+          t.getMessage()), t);\n+    }\n+  }\n \n-        rows = handleSelects(\n-            result,\n+  private static TableRowsEntity routeQuery(\n+      final KsqlNode node,\n+      final ConfiguredStatement<Query> statement,\n+      final KsqlExecutionContext executionContext,\n+      final ServiceContext serviceContext,\n+      final PullQueryContext pullQueryContext\n+  ) {\n+    try {\n+      if (node.isLocal()) {\n+        LOG.info(\"Query {} executed locally at host {}.\",\n+                 statement.getStatementText(), node.location());\n+        return queryRowsLocally(\n             statement,\n             executionContext,\n-            analysis,\n-            outputSchema,\n-            queryId,\n-            contextStacker\n-        );\n+            pullQueryContext);\n+      } else {\n+        LOG.info(\"Query {} routed to host {}.\", statement.getStatementText(), node.location());\n+        return forwardTo(node, statement, serviceContext);\n       }\n+    } catch (Throwable t) {\n+      LOG.info(\"Error routing query \" + statement.getStatementText() + \" to \" + node, t);", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk5MTM3NQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r374991375", "bodyText": "Done", "author": "vpapavas", "createdAt": "2020-02-04T23:56:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ1NTc2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ1Njc4OQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373456789", "bodyText": "nice :D", "author": "big-andy-coates", "createdAt": "2020-01-31T12:30:43Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java", "diffHunk": "@@ -247,6 +335,55 @@ private static ImmutableAnalysis analyze(\n     return queryAnalyzer.analyze(statement.getStatement(), Optional.empty());\n   }\n \n+  private static final class PullQueryContext {", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ1NjkwMg==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373456902", "bodyText": "nit: validate params that will be stored in object state; ensuring object does not get into an invalid state.", "author": "big-andy-coates", "createdAt": "2020-01-31T12:31:01Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/ClusterStatusResource.java", "diffHunk": "@@ -34,9 +49,11 @@\n @Produces({Versions.KSQL_V1_JSON, MediaType.APPLICATION_JSON})\n public class ClusterStatusResource {\n \n+  private final KsqlEngine engine;\n   private final HeartbeatAgent heartbeatAgent;\n \n-  public ClusterStatusResource(final HeartbeatAgent heartbeatAgent) {\n+  public ClusterStatusResource(final KsqlEngine engine,final HeartbeatAgent heartbeatAgent) {\n+    this.engine = engine;", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ1NzU1Nw==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373457557", "bodyText": "I'd be tempted to have the HostInfoEntity constructor take a HostInfo and the HostStatusEntity take a HostStatus.  Purely so that this code doesn't need to change if/when we add more fields to either source type.", "author": "big-andy-coates", "createdAt": "2020-01-31T12:32:48Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/ClusterStatusResource.java", "diffHunk": "@@ -47,6 +64,51 @@ public Response checkClusterStatus() {\n   }\n \n   private ClusterStatusResponse getResponse() {\n-    return new ClusterStatusResponse(heartbeatAgent.getHostsStatus());\n+    final Map<HostInfo, HostStatus> allHostStatus = heartbeatAgent.getHostsStatus();\n+\n+    final Map<HostInfoEntity, HostStatusEntity> response = allHostStatus\n+        .entrySet()\n+        .stream()\n+        .collect(Collectors.toMap(\n+            entry -> new HostInfoEntity(entry.getKey().host(), entry.getKey().port()) ,\n+            entry -> new HostStatusEntity(entry.getValue().isHostAlive(),\n+                                          entry.getValue().getLastStatusUpdateMs(),", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjAwNzU0OA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r376007548", "bodyText": "Since these are JSON entities, If they take the objects as arguments, I would need to write a serializer/deserializer which means they would depend on changes in the source. At least now, they are independent of additions of new fields.", "author": "vpapavas", "createdAt": "2020-02-06T18:30:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ1NzU1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ1ODMxMg==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373458312", "bodyText": "Avoid null checks like this by ensuring getAllMetadata returns an empty list, not null!  This puts the null check in one place - inside getAllMetadata. Otherwise we have to duplicate that null check everywhere that calls that method.", "author": "big-andy-coates", "createdAt": "2020-01-31T12:34:58Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/ClusterStatusResource.java", "diffHunk": "@@ -47,6 +64,51 @@ public Response checkClusterStatus() {\n   }\n \n   private ClusterStatusResponse getResponse() {\n-    return new ClusterStatusResponse(heartbeatAgent.getHostsStatus());\n+    final Map<HostInfo, HostStatus> allHostStatus = heartbeatAgent.getHostsStatus();\n+\n+    final Map<HostInfoEntity, HostStatusEntity> response = allHostStatus\n+        .entrySet()\n+        .stream()\n+        .collect(Collectors.toMap(\n+            entry -> new HostInfoEntity(entry.getKey().host(), entry.getKey().port()) ,\n+            entry -> new HostStatusEntity(entry.getValue().isHostAlive(),\n+                                          entry.getValue().getLastStatusUpdateMs(),\n+                                          getActiveStandbyInformation(entry.getKey()))));\n+\n+    return new ClusterStatusResponse(response);\n+  }\n+\n+  private Map<String, ActiveStandbyEntity> getActiveStandbyInformation(final HostInfo hostInfo) {\n+    final List<PersistentQueryMetadata> currentQueries = engine.getPersistentQueries();\n+    if (currentQueries.isEmpty()) {\n+      // empty response\n+      return Collections.emptyMap();\n+    }\n+\n+    final Map<String, ActiveStandbyEntity> perQueryMap = new HashMap<>();\n+    for (PersistentQueryMetadata persistentMetadata: currentQueries) {\n+      for (StreamsMetadata streamsMetadata : persistentMetadata\n+          .getAllMetadata()) {\n+        if (streamsMetadata == null || !streamsMetadata.hostInfo().equals(hostInfo)) {", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ1OTAzMw==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373459033", "bodyText": "Covered already by if (... !streamsMetadata.hostInfo().equals(hostInfo)), right?", "author": "big-andy-coates", "createdAt": "2020-01-31T12:37:03Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/ClusterStatusResource.java", "diffHunk": "@@ -47,6 +64,51 @@ public Response checkClusterStatus() {\n   }\n \n   private ClusterStatusResponse getResponse() {\n-    return new ClusterStatusResponse(heartbeatAgent.getHostsStatus());\n+    final Map<HostInfo, HostStatus> allHostStatus = heartbeatAgent.getHostsStatus();\n+\n+    final Map<HostInfoEntity, HostStatusEntity> response = allHostStatus\n+        .entrySet()\n+        .stream()\n+        .collect(Collectors.toMap(\n+            entry -> new HostInfoEntity(entry.getKey().host(), entry.getKey().port()) ,\n+            entry -> new HostStatusEntity(entry.getValue().isHostAlive(),\n+                                          entry.getValue().getLastStatusUpdateMs(),\n+                                          getActiveStandbyInformation(entry.getKey()))));\n+\n+    return new ClusterStatusResponse(response);\n+  }\n+\n+  private Map<String, ActiveStandbyEntity> getActiveStandbyInformation(final HostInfo hostInfo) {\n+    final List<PersistentQueryMetadata> currentQueries = engine.getPersistentQueries();\n+    if (currentQueries.isEmpty()) {\n+      // empty response\n+      return Collections.emptyMap();\n+    }\n+\n+    final Map<String, ActiveStandbyEntity> perQueryMap = new HashMap<>();\n+    for (PersistentQueryMetadata persistentMetadata: currentQueries) {\n+      for (StreamsMetadata streamsMetadata : persistentMetadata\n+          .getAllMetadata()) {\n+        if (streamsMetadata == null || !streamsMetadata.hostInfo().equals(hostInfo)) {\n+          continue;\n+        }\n+        if (streamsMetadata == StreamsMetadata.NOT_AVAILABLE) {\n+          continue;\n+        }", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ2MzAyNw==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373463027", "bodyText": "There's nothing wrong with the implementation here.  However, you may find its more readable if you make use of streams, e.g. what do you think of this:\nprivate Map<String, ActiveStandbyEntity> getActiveStandbyInformation(final HostInfo hostInfo) {\n\n    return engine.getPersistentQueries().stream()\n        .flatMap(query -> query.getAllMetadata().stream()\n            .map(md -> new AppIdAndSteamMetadata(query.getQueryApplicationId(), md)))\n        .filter(md -> md.streamsMetadata.hostInfo().equals(hostInfo))\n        .collect(Collectors.toMap(\n            md -> md.applicationId,\n            AppIdAndSteamMetadata::toActiveStandbyEntity\n        ));\n  }\n\n  private static final class AppIdAndSteamMetadata {\n\n    final String applicationId;\n    final StreamsMetadata streamsMetadata;\n\n    AppIdAndSteamMetadata(\n        final String applicationId,\n        final StreamsMetadata streamsMetadata\n    ) {\n      this.applicationId = requireNonNull(applicationId, \"applicationId\");\n      this.streamsMetadata = requireNonNull(streamsMetadata, \"md\");\n    }\n\n    public ActiveStandbyEntity toActiveStandbyEntity() {\n      final Set<String> activePartitions = streamsMetadata.topicPartitions()\n          .stream()\n          .map(TopicPartition::toString)\n          .collect(Collectors.toSet());\n\n      final Set<String> standByPartitions = streamsMetadata.standbyTopicPartitions()\n          .stream()\n          .map(TopicPartition::toString)\n          .collect(Collectors.toSet());\n\n      return new ActiveStandbyEntity(\n          streamsMetadata.stateStoreNames(),\n          activePartitions,\n          streamsMetadata.standbyStateStoreNames(),\n          standByPartitions);\n    }\n  }", "author": "big-andy-coates", "createdAt": "2020-01-31T12:48:12Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/ClusterStatusResource.java", "diffHunk": "@@ -47,6 +64,51 @@ public Response checkClusterStatus() {\n   }\n \n   private ClusterStatusResponse getResponse() {\n-    return new ClusterStatusResponse(heartbeatAgent.getHostsStatus());\n+    final Map<HostInfo, HostStatus> allHostStatus = heartbeatAgent.getHostsStatus();\n+\n+    final Map<HostInfoEntity, HostStatusEntity> response = allHostStatus\n+        .entrySet()\n+        .stream()\n+        .collect(Collectors.toMap(\n+            entry -> new HostInfoEntity(entry.getKey().host(), entry.getKey().port()) ,\n+            entry -> new HostStatusEntity(entry.getValue().isHostAlive(),\n+                                          entry.getValue().getLastStatusUpdateMs(),\n+                                          getActiveStandbyInformation(entry.getKey()))));\n+\n+    return new ClusterStatusResponse(response);\n+  }\n+\n+  private Map<String, ActiveStandbyEntity> getActiveStandbyInformation(final HostInfo hostInfo) {", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ1OTUyNw==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375459527", "bodyText": "Agreed and done", "author": "vpapavas", "createdAt": "2020-02-05T19:25:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ2MzAyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ2MzU3Ng==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373463576", "bodyText": "Rather than passing these down, it may be time to change PullQueryExecutor to take these in its constructor...\nYou can probably pass in ksqlEngine in the constructor too.   Though I think serviceContext needs to be per-call to support running queries under the security context of the calling user.", "author": "big-andy-coates", "createdAt": "2020-01-31T12:49:39Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/PullQueryPublisher.java", "diffHunk": "@@ -40,33 +43,43 @@\n   private final ServiceContext serviceContext;\n   private final ConfiguredStatement<Query> query;\n   private final TheQueryExecutor pullQueryExecutor;\n+  private final Optional<HeartbeatAgent> heartbeatAgent;\n+  private final List<RoutingFilter> routingFilters;\n \n   PullQueryPublisher(\n       final KsqlEngine ksqlEngine,\n       final ServiceContext serviceContext,\n-      final ConfiguredStatement<Query> query\n+      final ConfiguredStatement<Query> query,\n+      final Optional<HeartbeatAgent> heartbeatAgent,\n+      final List<RoutingFilter> routingFilters", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk3OTAzMw==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r374979033", "bodyText": "Done", "author": "vpapavas", "createdAt": "2020-02-04T23:17:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ2MzU3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ2NDU1Ng==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373464556", "bodyText": "As above - it looks like it's time to for PullQueryExecutor to have a constructor.  Adding these here is just unnecessary coupling.", "author": "big-andy-coates", "createdAt": "2020-01-31T12:52:10Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/StreamedQueryResource.java", "diffHunk": "@@ -99,20 +105,26 @@ public StreamedQueryResource(\n         commandQueueCatchupTimeout,\n         activenessRegistrar,\n         authorizationValidator,\n-        errorHandler\n+        errorHandler,\n+        heartbeatAgent,\n+        routingFilters\n     );\n   }\n \n   @VisibleForTesting\n+  // CHECKSTYLE_RULES.OFF: ParameterNumberCheck\n   StreamedQueryResource(\n+      // CHECKSTYLE_RULES.OFF: ParameterNumberCheck\n       final KsqlEngine ksqlEngine,\n       final StatementParser statementParser,\n       final CommandQueue commandQueue,\n       final Duration disconnectCheckInterval,\n       final Duration commandQueueCatchupTimeout,\n       final ActivenessRegistrar activenessRegistrar,\n       final Optional<KsqlAuthorizationValidator> authorizationValidator,\n-      final Errors errorHandler\n+      final Errors errorHandler,\n+      final Optional<HeartbeatAgent> heartbeatAgent,\n+      final List<RoutingFilter> routingFilters", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA1OTIzMQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375059231", "bodyText": "Done", "author": "vpapavas", "createdAt": "2020-02-05T04:57:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ2NDU1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ2NDc1Nw==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373464757", "bodyText": "As above.", "author": "big-andy-coates", "createdAt": "2020-01-31T12:52:42Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/streaming/WSQueryEndpoint.java", "diffHunk": "@@ -119,7 +123,9 @@ public WSQueryEndpoint(\n       final Errors errorHandler,\n       final KsqlSecurityExtension securityExtension,\n       final ServerState serverState,\n-      final Supplier<SchemaRegistryClient> schemaRegistryClientFactory\n+      final Supplier<SchemaRegistryClient> schemaRegistryClientFactory,\n+      final Optional<HeartbeatAgent> heartbeatAgent,\n+      final List<RoutingFilter> routingFilters", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ2NTMyMA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373465320", "bodyText": "would be nice to factor this out into a method, e.g. target. At the moment its duplicated in every method.", "author": "big-andy-coates", "createdAt": "2020-01-31T12:54:09Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/services/DefaultKsqlClient.java", "diffHunk": "@@ -126,4 +127,15 @@ public void makeAsyncHeartbeatRequest(\n         .orElse(target)\n         .getClusterStatus();\n   }\n+\n+  @Override\n+  public RestResponse<ActiveStandbyResponse> makeActiveStandbyRequest(final URI serverEndPoint) {\n+    final KsqlTarget target = sharedClient\n+        .target(serverEndPoint);\n+\n+    return authHeader\n+        .map(target::authorizationHeader)", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk1MjkwOA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r374952908", "bodyText": "Done", "author": "vpapavas", "createdAt": "2020-02-04T22:13:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ2NTMyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ2NTY1OA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373465658", "bodyText": "static imports would make these tests more readable IMHO", "author": "big-andy-coates", "createdAt": "2020-01-31T12:55:03Z", "path": "ksql-rest-app/src/test/java/io/confluent/ksql/rest/integration/HeartbeatAgentFunctionalTest.java", "diffHunk": "@@ -107,156 +102,63 @@ public void tearDown() {\n   @Test(timeout = 60000)\n   public void shouldMarkServersAsUp() {\n     // Given:\n-    waitForClusterToBeDiscovered();\n-    waitForRemoteServerToChangeStatus(this::remoteServerIsDown);\n+    HighAvailabilityTestUtil.waitForClusterToBeDiscovered(REST_APP_0, 2);\n+    HighAvailabilityTestUtil.waitForRemoteServerToChangeStatus(\n+        REST_APP_0, host1, HighAvailabilityTestUtil::remoteServerIsDown);\n \n     // When:\n-    sendHeartbeartsEveryIntervalForWindowLength(100, 3000);\n-    final ClusterStatusResponse clusterStatusResponseUp = waitForRemoteServerToChangeStatus(\n-        this::remoteServerIsUp);\n+    HighAvailabilityTestUtil.sendHeartbeartsForWindowLength(REST_APP_0, host1, 3000);\n+    final ClusterStatusResponse clusterStatusResponseUp = HighAvailabilityTestUtil.waitForRemoteServerToChangeStatus(\n+        REST_APP_0, host1, HighAvailabilityTestUtil::remoteServerIsUp);\n \n     // Then:\n-    assertThat(clusterStatusResponseUp.getClusterStatus().get(host0.toString()).getHostAlive(), is(true));\n-    assertThat(clusterStatusResponseUp.getClusterStatus().get(host1.toString()).getHostAlive(), is(true));\n+    assertThat(clusterStatusResponseUp.getClusterStatus().get(host0).getHostAlive(), is(true));\n+    assertThat(clusterStatusResponseUp.getClusterStatus().get(host1).getHostAlive(), is(true));\n   }\n \n   @Test(timeout = 60000)\n   public void shouldMarkRemoteServerAsDown() {\n     // Given:\n-    waitForClusterToBeDiscovered();\n+    HighAvailabilityTestUtil.waitForClusterToBeDiscovered(REST_APP_0, 2);\n \n     // When:\n-    ClusterStatusResponse clusterStatusResponse = waitForRemoteServerToChangeStatus(\n-        this::remoteServerIsDown);\n+    ClusterStatusResponse clusterStatusResponse = HighAvailabilityTestUtil.waitForRemoteServerToChangeStatus(\n+        REST_APP_0, host1, HighAvailabilityTestUtil::remoteServerIsDown);\n \n     // Then:\n-    assertThat(clusterStatusResponse.getClusterStatus().get(host0.toString()).getHostAlive(), is(true));\n-    assertThat(clusterStatusResponse.getClusterStatus().get(host1.toString()).getHostAlive(), is(false));\n+    assertThat(clusterStatusResponse.getClusterStatus().get(host0).getHostAlive(), is(true));\n+    assertThat(clusterStatusResponse.getClusterStatus().get(host1).getHostAlive(), is(false));\n   }\n \n   @Test(timeout = 60000)\n   public void shouldMarkRemoteServerAsUpThenDownThenUp() {\n     // Given:\n-    waitForClusterToBeDiscovered();\n-    sendHeartbeartsEveryIntervalForWindowLength(100, 2000);\n+    HighAvailabilityTestUtil.waitForClusterToBeDiscovered(REST_APP_0, 2);", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk1MTI2Nw==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r374951267", "bodyText": "Done", "author": "vpapavas", "createdAt": "2020-02-04T22:09:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ2NTY1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ2NzAwNw==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373467007", "bodyText": "Using a TemporaryFolder this way means it will never be cleaned up - i.e. the data on disk will never be deleted.\nIt think it should work if you add:\n@AfterClass\n  public static void classTearDown() {\n    TMP.delete();\n  }", "author": "big-andy-coates", "createdAt": "2020-01-31T12:58:49Z", "path": "ksql-rest-app/src/test/java/io/confluent/ksql/rest/integration/PullQueryRoutingFunctionalTest.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.integration;\n+\n+import static io.confluent.ksql.util.KsqlConfig.KSQL_STREAMS_PREFIX;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.not;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Iterables;\n+import io.confluent.common.utils.IntegrationTest;\n+import io.confluent.ksql.integration.IntegrationTestHarness;\n+import io.confluent.ksql.integration.Retry;\n+import io.confluent.ksql.name.ColumnName;\n+import io.confluent.ksql.rest.entity.ActiveStandbyEntity;\n+import io.confluent.ksql.rest.entity.ClusterStatusResponse;\n+import io.confluent.ksql.rest.entity.HostInfoEntity;\n+import io.confluent.ksql.rest.entity.StreamedRow;\n+import io.confluent.ksql.rest.server.KsqlRestConfig;\n+import io.confluent.ksql.rest.server.TestKsqlRestApp;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.PhysicalSchema;\n+import io.confluent.ksql.schema.ksql.types.SqlTypes;\n+import io.confluent.ksql.serde.Format;\n+import io.confluent.ksql.serde.SerdeOption;\n+import io.confluent.ksql.test.util.KsqlIdentifierTestUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.Pair;\n+import io.confluent.ksql.util.UserDataProvider;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import kafka.zookeeper.ZooKeeperClientException;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.rules.ExpectedException;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TemporaryFolder;\n+\n+/**\n+ * Test to ensure pull queries route across multiple KSQL nodes correctly.\n+ *\n+ * <p>For tests on general syntax and handled see RestQueryTranslationTest's\n+ * materialized-aggregate-static-queries.json\n+ */\n+@SuppressWarnings(\"OptionalGetWithoutIsPresent\")\n+@Category({IntegrationTest.class})\n+public class PullQueryRoutingFunctionalTest {\n+\n+  private static final TemporaryFolder TMP = new TemporaryFolder();\n+\n+  static {\n+    try {\n+      TMP.create();\n+    } catch (final IOException e) {\n+      throw new AssertionError(\"Failed to init TMP\", e);\n+    }\n+  }", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQzMjkxNA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375432914", "bodyText": "Done", "author": "vpapavas", "createdAt": "2020-02-05T18:33:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ2NzAwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ2ODMyMQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373468321", "bodyText": "consider pulling common config out:\nprivate static final Map<String, Object> COMMON_CONFIG = ImmutableMap.<String, Object>builder()\n      .put(KSQL_STREAMS_PREFIX + StreamsConfig.NUM_STREAM_THREADS_CONFIG, 1)\n      .put(KsqlRestConfig.KSQL_HEARTBEAT_ENABLE_CONFIG, true)\n      .put(KsqlRestConfig.KSQL_HEARTBEAT_SEND_INTERVAL_MS_CONFIG, 600000)\n      .put(KsqlRestConfig.KSQL_HEARTBEAT_CHECK_INTERVAL_MS_CONFIG, 200)\n      .put(KsqlRestConfig.KSQL_HEARTBEAT_DISCOVER_CLUSTER_MS_CONFIG, 2000)\n      .put(KsqlConfig.KSQL_QUERY_PULL_ENABLE_STALE_READS, true)\n      .put(KsqlConfig.KSQL_STREAMS_PREFIX + \"num.standby.replicas\", 1)\n      .build();\n\n  private static final TestKsqlRestApp REST_APP_0 = TestKsqlRestApp\n      .builder(TEST_HARNESS::kafkaBootstrapServers)\n      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.STATE_DIR_CONFIG, getNewStateDir())\n      .withProperty(KsqlRestConfig.LISTENERS_CONFIG, \"http://localhost:8088\")\n      .withProperty(KsqlRestConfig.ADVERTISED_LISTENER_CONFIG, \"http://localhost:8088\")\n      .withProperties(COMMON_CONFIG)\n      .build();\n\n  private static final TestKsqlRestApp REST_APP_1 = TestKsqlRestApp\n      .builder(TEST_HARNESS::kafkaBootstrapServers)\n      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.STATE_DIR_CONFIG, getNewStateDir())\n      .withProperty(KsqlRestConfig.LISTENERS_CONFIG, \"http://localhost:8089\")\n      .withProperty(KsqlRestConfig.ADVERTISED_LISTENER_CONFIG, \"http://localhost:8089\")\n      .withProperties(COMMON_CONFIG)\n      .build();\n\n  private static final TestKsqlRestApp REST_APP_2 = TestKsqlRestApp\n      .builder(TEST_HARNESS::kafkaBootstrapServers)\n      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.STATE_DIR_CONFIG, getNewStateDir())\n      .withProperty(KsqlRestConfig.LISTENERS_CONFIG, \"http://localhost:8087\")\n      .withProperty(KsqlRestConfig.ADVERTISED_LISTENER_CONFIG, \"http://localhost:8087\")\n      .withProperties(COMMON_CONFIG)\n      .build();", "author": "big-andy-coates", "createdAt": "2020-01-31T13:02:15Z", "path": "ksql-rest-app/src/test/java/io/confluent/ksql/rest/integration/PullQueryRoutingFunctionalTest.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.integration;\n+\n+import static io.confluent.ksql.util.KsqlConfig.KSQL_STREAMS_PREFIX;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.not;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Iterables;\n+import io.confluent.common.utils.IntegrationTest;\n+import io.confluent.ksql.integration.IntegrationTestHarness;\n+import io.confluent.ksql.integration.Retry;\n+import io.confluent.ksql.name.ColumnName;\n+import io.confluent.ksql.rest.entity.ActiveStandbyEntity;\n+import io.confluent.ksql.rest.entity.ClusterStatusResponse;\n+import io.confluent.ksql.rest.entity.HostInfoEntity;\n+import io.confluent.ksql.rest.entity.StreamedRow;\n+import io.confluent.ksql.rest.server.KsqlRestConfig;\n+import io.confluent.ksql.rest.server.TestKsqlRestApp;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.PhysicalSchema;\n+import io.confluent.ksql.schema.ksql.types.SqlTypes;\n+import io.confluent.ksql.serde.Format;\n+import io.confluent.ksql.serde.SerdeOption;\n+import io.confluent.ksql.test.util.KsqlIdentifierTestUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.Pair;\n+import io.confluent.ksql.util.UserDataProvider;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import kafka.zookeeper.ZooKeeperClientException;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.rules.ExpectedException;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TemporaryFolder;\n+\n+/**\n+ * Test to ensure pull queries route across multiple KSQL nodes correctly.\n+ *\n+ * <p>For tests on general syntax and handled see RestQueryTranslationTest's\n+ * materialized-aggregate-static-queries.json\n+ */\n+@SuppressWarnings(\"OptionalGetWithoutIsPresent\")\n+@Category({IntegrationTest.class})\n+public class PullQueryRoutingFunctionalTest {\n+\n+  private static final TemporaryFolder TMP = new TemporaryFolder();\n+\n+  static {\n+    try {\n+      TMP.create();\n+    } catch (final IOException e) {\n+      throw new AssertionError(\"Failed to init TMP\", e);\n+    }\n+  }\n+  private static final HostInfoEntity host0 = new HostInfoEntity(\"localhost\", 8088);\n+  private static final HostInfoEntity host1 = new HostInfoEntity(\"localhost\",8089);\n+  private static final HostInfoEntity host2 = new HostInfoEntity(\"localhost\",8087);\n+  private static final String USER_TOPIC = \"user_topic\";\n+  private static final String USERS_STREAM = \"users\";\n+  private static final UserDataProvider USER_PROVIDER = new UserDataProvider();\n+  private static final Format VALUE_FORMAT = Format.JSON;\n+  private static final int HEADER = 1;\n+  private static String output;\n+  private static final IntegrationTestHarness TEST_HARNESS = IntegrationTestHarness.build();\n+  private static final int BASE_TIME = 1_000_000;\n+  private static final String QUERY_ID = \"_confluent-ksql-default_query_CTAS_ID_0_0\";\n+\n+  private static final PhysicalSchema AGGREGATE_SCHEMA = PhysicalSchema.from(\n+      LogicalSchema.builder()\n+          .valueColumn(ColumnName.of(\"COUNT\"), SqlTypes.BIGINT)\n+          .build(),\n+      SerdeOption.none()\n+  );\n+\n+  private static final TestKsqlRestApp REST_APP_0 = TestKsqlRestApp\n+      .builder(TEST_HARNESS::kafkaBootstrapServers)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.NUM_STREAM_THREADS_CONFIG, 1)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.STATE_DIR_CONFIG, getNewStateDir())\n+      .withProperty(KsqlRestConfig.LISTENERS_CONFIG, \"http://localhost:8088\")\n+      .withProperty(KsqlRestConfig.ADVERTISED_LISTENER_CONFIG, \"http://localhost:8088\")\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_ENABLE_CONFIG, true)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_SEND_INTERVAL_MS_CONFIG, 600000)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_CHECK_INTERVAL_MS_CONFIG, 200)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_DISCOVER_CLUSTER_MS_CONFIG, 2000)\n+      .withProperty(KsqlConfig.KSQL_QUERY_PULL_ENABLE_STALE_READS, true)\n+      .withProperty(KsqlConfig.KSQL_STREAMS_PREFIX + \"num.standby.replicas\", 1)\n+      .build();\n+\n+  private static final TestKsqlRestApp REST_APP_1 = TestKsqlRestApp\n+      .builder(TEST_HARNESS::kafkaBootstrapServers)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.NUM_STREAM_THREADS_CONFIG, 1)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.STATE_DIR_CONFIG, getNewStateDir())\n+      .withProperty(KsqlRestConfig.LISTENERS_CONFIG, \"http://localhost:8089\")\n+      .withProperty(KsqlRestConfig.ADVERTISED_LISTENER_CONFIG, \"http://localhost:8089\")\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_ENABLE_CONFIG, true)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_SEND_INTERVAL_MS_CONFIG, 600000)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_CHECK_INTERVAL_MS_CONFIG, 200)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_DISCOVER_CLUSTER_MS_CONFIG, 2000)\n+      .withProperty(KsqlConfig.KSQL_QUERY_PULL_ENABLE_STALE_READS, true)\n+      .withProperty(KsqlConfig.KSQL_STREAMS_PREFIX + \"num.standby.replicas\", 1)\n+      .build();", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA1OTY4NA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375059684", "bodyText": "Done", "author": "vpapavas", "createdAt": "2020-02-05T04:59:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ2ODMyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ2OTI3MQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373469271", "bodyText": "why do you stop / start the servers on each test? This is going to make the tests run a lot slower!\nIf you truly need them to start / stop on each test, then change them to be a @Rule rather than a @ClassRule.", "author": "big-andy-coates", "createdAt": "2020-01-31T13:04:52Z", "path": "ksql-rest-app/src/test/java/io/confluent/ksql/rest/integration/PullQueryRoutingFunctionalTest.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.integration;\n+\n+import static io.confluent.ksql.util.KsqlConfig.KSQL_STREAMS_PREFIX;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.not;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Iterables;\n+import io.confluent.common.utils.IntegrationTest;\n+import io.confluent.ksql.integration.IntegrationTestHarness;\n+import io.confluent.ksql.integration.Retry;\n+import io.confluent.ksql.name.ColumnName;\n+import io.confluent.ksql.rest.entity.ActiveStandbyEntity;\n+import io.confluent.ksql.rest.entity.ClusterStatusResponse;\n+import io.confluent.ksql.rest.entity.HostInfoEntity;\n+import io.confluent.ksql.rest.entity.StreamedRow;\n+import io.confluent.ksql.rest.server.KsqlRestConfig;\n+import io.confluent.ksql.rest.server.TestKsqlRestApp;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.PhysicalSchema;\n+import io.confluent.ksql.schema.ksql.types.SqlTypes;\n+import io.confluent.ksql.serde.Format;\n+import io.confluent.ksql.serde.SerdeOption;\n+import io.confluent.ksql.test.util.KsqlIdentifierTestUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.Pair;\n+import io.confluent.ksql.util.UserDataProvider;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import kafka.zookeeper.ZooKeeperClientException;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.rules.ExpectedException;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TemporaryFolder;\n+\n+/**\n+ * Test to ensure pull queries route across multiple KSQL nodes correctly.\n+ *\n+ * <p>For tests on general syntax and handled see RestQueryTranslationTest's\n+ * materialized-aggregate-static-queries.json\n+ */\n+@SuppressWarnings(\"OptionalGetWithoutIsPresent\")\n+@Category({IntegrationTest.class})\n+public class PullQueryRoutingFunctionalTest {\n+\n+  private static final TemporaryFolder TMP = new TemporaryFolder();\n+\n+  static {\n+    try {\n+      TMP.create();\n+    } catch (final IOException e) {\n+      throw new AssertionError(\"Failed to init TMP\", e);\n+    }\n+  }\n+  private static final HostInfoEntity host0 = new HostInfoEntity(\"localhost\", 8088);\n+  private static final HostInfoEntity host1 = new HostInfoEntity(\"localhost\",8089);\n+  private static final HostInfoEntity host2 = new HostInfoEntity(\"localhost\",8087);\n+  private static final String USER_TOPIC = \"user_topic\";\n+  private static final String USERS_STREAM = \"users\";\n+  private static final UserDataProvider USER_PROVIDER = new UserDataProvider();\n+  private static final Format VALUE_FORMAT = Format.JSON;\n+  private static final int HEADER = 1;\n+  private static String output;\n+  private static final IntegrationTestHarness TEST_HARNESS = IntegrationTestHarness.build();\n+  private static final int BASE_TIME = 1_000_000;\n+  private static final String QUERY_ID = \"_confluent-ksql-default_query_CTAS_ID_0_0\";\n+\n+  private static final PhysicalSchema AGGREGATE_SCHEMA = PhysicalSchema.from(\n+      LogicalSchema.builder()\n+          .valueColumn(ColumnName.of(\"COUNT\"), SqlTypes.BIGINT)\n+          .build(),\n+      SerdeOption.none()\n+  );\n+\n+  private static final TestKsqlRestApp REST_APP_0 = TestKsqlRestApp\n+      .builder(TEST_HARNESS::kafkaBootstrapServers)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.NUM_STREAM_THREADS_CONFIG, 1)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.STATE_DIR_CONFIG, getNewStateDir())\n+      .withProperty(KsqlRestConfig.LISTENERS_CONFIG, \"http://localhost:8088\")\n+      .withProperty(KsqlRestConfig.ADVERTISED_LISTENER_CONFIG, \"http://localhost:8088\")\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_ENABLE_CONFIG, true)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_SEND_INTERVAL_MS_CONFIG, 600000)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_CHECK_INTERVAL_MS_CONFIG, 200)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_DISCOVER_CLUSTER_MS_CONFIG, 2000)\n+      .withProperty(KsqlConfig.KSQL_QUERY_PULL_ENABLE_STALE_READS, true)\n+      .withProperty(KsqlConfig.KSQL_STREAMS_PREFIX + \"num.standby.replicas\", 1)\n+      .build();\n+\n+  private static final TestKsqlRestApp REST_APP_1 = TestKsqlRestApp\n+      .builder(TEST_HARNESS::kafkaBootstrapServers)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.NUM_STREAM_THREADS_CONFIG, 1)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.STATE_DIR_CONFIG, getNewStateDir())\n+      .withProperty(KsqlRestConfig.LISTENERS_CONFIG, \"http://localhost:8089\")\n+      .withProperty(KsqlRestConfig.ADVERTISED_LISTENER_CONFIG, \"http://localhost:8089\")\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_ENABLE_CONFIG, true)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_SEND_INTERVAL_MS_CONFIG, 600000)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_CHECK_INTERVAL_MS_CONFIG, 200)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_DISCOVER_CLUSTER_MS_CONFIG, 2000)\n+      .withProperty(KsqlConfig.KSQL_QUERY_PULL_ENABLE_STALE_READS, true)\n+      .withProperty(KsqlConfig.KSQL_STREAMS_PREFIX + \"num.standby.replicas\", 1)\n+      .build();\n+\n+  private static final TestKsqlRestApp REST_APP_2 = TestKsqlRestApp\n+      .builder(TEST_HARNESS::kafkaBootstrapServers)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.NUM_STREAM_THREADS_CONFIG, 1)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.STATE_DIR_CONFIG, getNewStateDir())\n+      .withProperty(KsqlRestConfig.LISTENERS_CONFIG, \"http://localhost:8087\")\n+      .withProperty(KsqlRestConfig.ADVERTISED_LISTENER_CONFIG, \"http://localhost:8087\")\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_ENABLE_CONFIG, true)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_SEND_INTERVAL_MS_CONFIG, 600000)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_CHECK_INTERVAL_MS_CONFIG, 200)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_DISCOVER_CLUSTER_MS_CONFIG, 2000)\n+      .withProperty(KsqlConfig.KSQL_QUERY_PULL_ENABLE_STALE_READS, true)\n+      .withProperty(KsqlConfig.KSQL_STREAMS_PREFIX + \"num.standby.replicas\", 1)\n+      .build();\n+\n+  @ClassRule\n+  public static final RuleChain CHAIN = RuleChain\n+      .outerRule(Retry.of(3, ZooKeeperClientException.class, 3, TimeUnit.SECONDS))\n+      .around(TEST_HARNESS)\n+      .around(REST_APP_0)\n+      .around(REST_APP_1)\n+      .around(REST_APP_2);\n+\n+  @Rule\n+  public final ExpectedException expectedException = ExpectedException.none();\n+\n+  @BeforeClass\n+  public static void setUpClass() {\n+    //Create topic with 1 partition to control who is active and standby\n+    TEST_HARNESS.ensureTopics(1, USER_TOPIC);\n+\n+    final AtomicLong timestampSupplier = new AtomicLong(BASE_TIME);\n+\n+    TEST_HARNESS.produceRows(\n+        USER_TOPIC,\n+        USER_PROVIDER,\n+        VALUE_FORMAT,\n+        timestampSupplier::getAndIncrement\n+    );\n+\n+    //Create stream\n+    makeAdminRequest(\n+        \"CREATE STREAM \" + USERS_STREAM\n+            + \" (\" + USER_PROVIDER.ksqlSchemaString() + \")\"\n+            + \" WITH (\"\n+            + \"   kafka_topic='\" + USER_TOPIC + \"', \"\n+            + \"   key='\" + USER_PROVIDER.key() + \"', \"\n+            + \"   value_format='\" + VALUE_FORMAT + \"'\"\n+            + \");\"\n+    );\n+  }\n+\n+  @Before\n+  public void setUp() {\n+    REST_APP_0.start();\n+    REST_APP_1.start();\n+    REST_APP_2.start();\n+    output = KsqlIdentifierTestUtil.uniqueIdentifierName();\n+\n+  }\n+\n+  @After\n+  public void cleanUp() {\n+    REST_APP_0.stop();\n+    REST_APP_1.stop();\n+    REST_APP_2.stop();\n+  }", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQzMjg0MA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375432840", "bodyText": "Done", "author": "vpapavas", "createdAt": "2020-02-05T18:33:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ2OTI3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ2OTY0OA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373469648", "bodyText": "Rather than having timeouts on each test us a:\n@Rule\n  @Rule\n  public final Timeout timeout = Timeout.builder()\n      .withTimeout(1, TimeUnit.MINUTE)\n      .withLookingForStuckThread(true) <-- optional.\n      .build();", "author": "big-andy-coates", "createdAt": "2020-01-31T13:05:56Z", "path": "ksql-rest-app/src/test/java/io/confluent/ksql/rest/integration/PullQueryRoutingFunctionalTest.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.integration;\n+\n+import static io.confluent.ksql.util.KsqlConfig.KSQL_STREAMS_PREFIX;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.not;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Iterables;\n+import io.confluent.common.utils.IntegrationTest;\n+import io.confluent.ksql.integration.IntegrationTestHarness;\n+import io.confluent.ksql.integration.Retry;\n+import io.confluent.ksql.name.ColumnName;\n+import io.confluent.ksql.rest.entity.ActiveStandbyEntity;\n+import io.confluent.ksql.rest.entity.ClusterStatusResponse;\n+import io.confluent.ksql.rest.entity.HostInfoEntity;\n+import io.confluent.ksql.rest.entity.StreamedRow;\n+import io.confluent.ksql.rest.server.KsqlRestConfig;\n+import io.confluent.ksql.rest.server.TestKsqlRestApp;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.PhysicalSchema;\n+import io.confluent.ksql.schema.ksql.types.SqlTypes;\n+import io.confluent.ksql.serde.Format;\n+import io.confluent.ksql.serde.SerdeOption;\n+import io.confluent.ksql.test.util.KsqlIdentifierTestUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.Pair;\n+import io.confluent.ksql.util.UserDataProvider;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import kafka.zookeeper.ZooKeeperClientException;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.rules.ExpectedException;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TemporaryFolder;\n+\n+/**\n+ * Test to ensure pull queries route across multiple KSQL nodes correctly.\n+ *\n+ * <p>For tests on general syntax and handled see RestQueryTranslationTest's\n+ * materialized-aggregate-static-queries.json\n+ */\n+@SuppressWarnings(\"OptionalGetWithoutIsPresent\")\n+@Category({IntegrationTest.class})\n+public class PullQueryRoutingFunctionalTest {\n+\n+  private static final TemporaryFolder TMP = new TemporaryFolder();\n+\n+  static {\n+    try {\n+      TMP.create();\n+    } catch (final IOException e) {\n+      throw new AssertionError(\"Failed to init TMP\", e);\n+    }\n+  }\n+  private static final HostInfoEntity host0 = new HostInfoEntity(\"localhost\", 8088);\n+  private static final HostInfoEntity host1 = new HostInfoEntity(\"localhost\",8089);\n+  private static final HostInfoEntity host2 = new HostInfoEntity(\"localhost\",8087);\n+  private static final String USER_TOPIC = \"user_topic\";\n+  private static final String USERS_STREAM = \"users\";\n+  private static final UserDataProvider USER_PROVIDER = new UserDataProvider();\n+  private static final Format VALUE_FORMAT = Format.JSON;\n+  private static final int HEADER = 1;\n+  private static String output;\n+  private static final IntegrationTestHarness TEST_HARNESS = IntegrationTestHarness.build();\n+  private static final int BASE_TIME = 1_000_000;\n+  private static final String QUERY_ID = \"_confluent-ksql-default_query_CTAS_ID_0_0\";\n+\n+  private static final PhysicalSchema AGGREGATE_SCHEMA = PhysicalSchema.from(\n+      LogicalSchema.builder()\n+          .valueColumn(ColumnName.of(\"COUNT\"), SqlTypes.BIGINT)\n+          .build(),\n+      SerdeOption.none()\n+  );\n+\n+  private static final TestKsqlRestApp REST_APP_0 = TestKsqlRestApp\n+      .builder(TEST_HARNESS::kafkaBootstrapServers)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.NUM_STREAM_THREADS_CONFIG, 1)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.STATE_DIR_CONFIG, getNewStateDir())\n+      .withProperty(KsqlRestConfig.LISTENERS_CONFIG, \"http://localhost:8088\")\n+      .withProperty(KsqlRestConfig.ADVERTISED_LISTENER_CONFIG, \"http://localhost:8088\")\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_ENABLE_CONFIG, true)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_SEND_INTERVAL_MS_CONFIG, 600000)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_CHECK_INTERVAL_MS_CONFIG, 200)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_DISCOVER_CLUSTER_MS_CONFIG, 2000)\n+      .withProperty(KsqlConfig.KSQL_QUERY_PULL_ENABLE_STALE_READS, true)\n+      .withProperty(KsqlConfig.KSQL_STREAMS_PREFIX + \"num.standby.replicas\", 1)\n+      .build();\n+\n+  private static final TestKsqlRestApp REST_APP_1 = TestKsqlRestApp\n+      .builder(TEST_HARNESS::kafkaBootstrapServers)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.NUM_STREAM_THREADS_CONFIG, 1)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.STATE_DIR_CONFIG, getNewStateDir())\n+      .withProperty(KsqlRestConfig.LISTENERS_CONFIG, \"http://localhost:8089\")\n+      .withProperty(KsqlRestConfig.ADVERTISED_LISTENER_CONFIG, \"http://localhost:8089\")\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_ENABLE_CONFIG, true)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_SEND_INTERVAL_MS_CONFIG, 600000)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_CHECK_INTERVAL_MS_CONFIG, 200)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_DISCOVER_CLUSTER_MS_CONFIG, 2000)\n+      .withProperty(KsqlConfig.KSQL_QUERY_PULL_ENABLE_STALE_READS, true)\n+      .withProperty(KsqlConfig.KSQL_STREAMS_PREFIX + \"num.standby.replicas\", 1)\n+      .build();\n+\n+  private static final TestKsqlRestApp REST_APP_2 = TestKsqlRestApp\n+      .builder(TEST_HARNESS::kafkaBootstrapServers)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.NUM_STREAM_THREADS_CONFIG, 1)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.STATE_DIR_CONFIG, getNewStateDir())\n+      .withProperty(KsqlRestConfig.LISTENERS_CONFIG, \"http://localhost:8087\")\n+      .withProperty(KsqlRestConfig.ADVERTISED_LISTENER_CONFIG, \"http://localhost:8087\")\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_ENABLE_CONFIG, true)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_SEND_INTERVAL_MS_CONFIG, 600000)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_CHECK_INTERVAL_MS_CONFIG, 200)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_DISCOVER_CLUSTER_MS_CONFIG, 2000)\n+      .withProperty(KsqlConfig.KSQL_QUERY_PULL_ENABLE_STALE_READS, true)\n+      .withProperty(KsqlConfig.KSQL_STREAMS_PREFIX + \"num.standby.replicas\", 1)\n+      .build();\n+\n+  @ClassRule\n+  public static final RuleChain CHAIN = RuleChain\n+      .outerRule(Retry.of(3, ZooKeeperClientException.class, 3, TimeUnit.SECONDS))\n+      .around(TEST_HARNESS)\n+      .around(REST_APP_0)\n+      .around(REST_APP_1)\n+      .around(REST_APP_2);\n+\n+  @Rule\n+  public final ExpectedException expectedException = ExpectedException.none();\n+\n+  @BeforeClass\n+  public static void setUpClass() {\n+    //Create topic with 1 partition to control who is active and standby\n+    TEST_HARNESS.ensureTopics(1, USER_TOPIC);\n+\n+    final AtomicLong timestampSupplier = new AtomicLong(BASE_TIME);\n+\n+    TEST_HARNESS.produceRows(\n+        USER_TOPIC,\n+        USER_PROVIDER,\n+        VALUE_FORMAT,\n+        timestampSupplier::getAndIncrement\n+    );\n+\n+    //Create stream\n+    makeAdminRequest(\n+        \"CREATE STREAM \" + USERS_STREAM\n+            + \" (\" + USER_PROVIDER.ksqlSchemaString() + \")\"\n+            + \" WITH (\"\n+            + \"   kafka_topic='\" + USER_TOPIC + \"', \"\n+            + \"   key='\" + USER_PROVIDER.key() + \"', \"\n+            + \"   value_format='\" + VALUE_FORMAT + \"'\"\n+            + \");\"\n+    );\n+  }\n+\n+  @Before\n+  public void setUp() {\n+    REST_APP_0.start();\n+    REST_APP_1.start();\n+    REST_APP_2.start();\n+    output = KsqlIdentifierTestUtil.uniqueIdentifierName();\n+\n+  }\n+\n+  @After\n+  public void cleanUp() {\n+    REST_APP_0.stop();\n+    REST_APP_1.stop();\n+    REST_APP_2.stop();\n+  }\n+\n+  @Test(timeout = 60000)", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQzNjIzMw==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375436233", "bodyText": "Done", "author": "vpapavas", "createdAt": "2020-02-05T18:40:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ2OTY0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ3MDU3Ng==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373470576", "bodyText": "This is common to each test.  Moving it to setUp would make your tests much more readable.\nIn general, try to make your tests read like a storey.  The test body should only have the important bits in the Given section, i.e. the bits that set up this test in a specific way, not the general setup.  This makes it much easier to see what it is about the test setup that is different and influencing the result.", "author": "big-andy-coates", "createdAt": "2020-01-31T13:08:33Z", "path": "ksql-rest-app/src/test/java/io/confluent/ksql/rest/integration/PullQueryRoutingFunctionalTest.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.integration;\n+\n+import static io.confluent.ksql.util.KsqlConfig.KSQL_STREAMS_PREFIX;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.not;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Iterables;\n+import io.confluent.common.utils.IntegrationTest;\n+import io.confluent.ksql.integration.IntegrationTestHarness;\n+import io.confluent.ksql.integration.Retry;\n+import io.confluent.ksql.name.ColumnName;\n+import io.confluent.ksql.rest.entity.ActiveStandbyEntity;\n+import io.confluent.ksql.rest.entity.ClusterStatusResponse;\n+import io.confluent.ksql.rest.entity.HostInfoEntity;\n+import io.confluent.ksql.rest.entity.StreamedRow;\n+import io.confluent.ksql.rest.server.KsqlRestConfig;\n+import io.confluent.ksql.rest.server.TestKsqlRestApp;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.PhysicalSchema;\n+import io.confluent.ksql.schema.ksql.types.SqlTypes;\n+import io.confluent.ksql.serde.Format;\n+import io.confluent.ksql.serde.SerdeOption;\n+import io.confluent.ksql.test.util.KsqlIdentifierTestUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.Pair;\n+import io.confluent.ksql.util.UserDataProvider;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import kafka.zookeeper.ZooKeeperClientException;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.rules.ExpectedException;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TemporaryFolder;\n+\n+/**\n+ * Test to ensure pull queries route across multiple KSQL nodes correctly.\n+ *\n+ * <p>For tests on general syntax and handled see RestQueryTranslationTest's\n+ * materialized-aggregate-static-queries.json\n+ */\n+@SuppressWarnings(\"OptionalGetWithoutIsPresent\")\n+@Category({IntegrationTest.class})\n+public class PullQueryRoutingFunctionalTest {\n+\n+  private static final TemporaryFolder TMP = new TemporaryFolder();\n+\n+  static {\n+    try {\n+      TMP.create();\n+    } catch (final IOException e) {\n+      throw new AssertionError(\"Failed to init TMP\", e);\n+    }\n+  }\n+  private static final HostInfoEntity host0 = new HostInfoEntity(\"localhost\", 8088);\n+  private static final HostInfoEntity host1 = new HostInfoEntity(\"localhost\",8089);\n+  private static final HostInfoEntity host2 = new HostInfoEntity(\"localhost\",8087);\n+  private static final String USER_TOPIC = \"user_topic\";\n+  private static final String USERS_STREAM = \"users\";\n+  private static final UserDataProvider USER_PROVIDER = new UserDataProvider();\n+  private static final Format VALUE_FORMAT = Format.JSON;\n+  private static final int HEADER = 1;\n+  private static String output;\n+  private static final IntegrationTestHarness TEST_HARNESS = IntegrationTestHarness.build();\n+  private static final int BASE_TIME = 1_000_000;\n+  private static final String QUERY_ID = \"_confluent-ksql-default_query_CTAS_ID_0_0\";\n+\n+  private static final PhysicalSchema AGGREGATE_SCHEMA = PhysicalSchema.from(\n+      LogicalSchema.builder()\n+          .valueColumn(ColumnName.of(\"COUNT\"), SqlTypes.BIGINT)\n+          .build(),\n+      SerdeOption.none()\n+  );\n+\n+  private static final TestKsqlRestApp REST_APP_0 = TestKsqlRestApp\n+      .builder(TEST_HARNESS::kafkaBootstrapServers)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.NUM_STREAM_THREADS_CONFIG, 1)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.STATE_DIR_CONFIG, getNewStateDir())\n+      .withProperty(KsqlRestConfig.LISTENERS_CONFIG, \"http://localhost:8088\")\n+      .withProperty(KsqlRestConfig.ADVERTISED_LISTENER_CONFIG, \"http://localhost:8088\")\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_ENABLE_CONFIG, true)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_SEND_INTERVAL_MS_CONFIG, 600000)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_CHECK_INTERVAL_MS_CONFIG, 200)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_DISCOVER_CLUSTER_MS_CONFIG, 2000)\n+      .withProperty(KsqlConfig.KSQL_QUERY_PULL_ENABLE_STALE_READS, true)\n+      .withProperty(KsqlConfig.KSQL_STREAMS_PREFIX + \"num.standby.replicas\", 1)\n+      .build();\n+\n+  private static final TestKsqlRestApp REST_APP_1 = TestKsqlRestApp\n+      .builder(TEST_HARNESS::kafkaBootstrapServers)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.NUM_STREAM_THREADS_CONFIG, 1)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.STATE_DIR_CONFIG, getNewStateDir())\n+      .withProperty(KsqlRestConfig.LISTENERS_CONFIG, \"http://localhost:8089\")\n+      .withProperty(KsqlRestConfig.ADVERTISED_LISTENER_CONFIG, \"http://localhost:8089\")\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_ENABLE_CONFIG, true)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_SEND_INTERVAL_MS_CONFIG, 600000)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_CHECK_INTERVAL_MS_CONFIG, 200)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_DISCOVER_CLUSTER_MS_CONFIG, 2000)\n+      .withProperty(KsqlConfig.KSQL_QUERY_PULL_ENABLE_STALE_READS, true)\n+      .withProperty(KsqlConfig.KSQL_STREAMS_PREFIX + \"num.standby.replicas\", 1)\n+      .build();\n+\n+  private static final TestKsqlRestApp REST_APP_2 = TestKsqlRestApp\n+      .builder(TEST_HARNESS::kafkaBootstrapServers)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.NUM_STREAM_THREADS_CONFIG, 1)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.STATE_DIR_CONFIG, getNewStateDir())\n+      .withProperty(KsqlRestConfig.LISTENERS_CONFIG, \"http://localhost:8087\")\n+      .withProperty(KsqlRestConfig.ADVERTISED_LISTENER_CONFIG, \"http://localhost:8087\")\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_ENABLE_CONFIG, true)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_SEND_INTERVAL_MS_CONFIG, 600000)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_CHECK_INTERVAL_MS_CONFIG, 200)\n+      .withProperty(KsqlRestConfig.KSQL_HEARTBEAT_DISCOVER_CLUSTER_MS_CONFIG, 2000)\n+      .withProperty(KsqlConfig.KSQL_QUERY_PULL_ENABLE_STALE_READS, true)\n+      .withProperty(KsqlConfig.KSQL_STREAMS_PREFIX + \"num.standby.replicas\", 1)\n+      .build();\n+\n+  @ClassRule\n+  public static final RuleChain CHAIN = RuleChain\n+      .outerRule(Retry.of(3, ZooKeeperClientException.class, 3, TimeUnit.SECONDS))\n+      .around(TEST_HARNESS)\n+      .around(REST_APP_0)\n+      .around(REST_APP_1)\n+      .around(REST_APP_2);\n+\n+  @Rule\n+  public final ExpectedException expectedException = ExpectedException.none();\n+\n+  @BeforeClass\n+  public static void setUpClass() {\n+    //Create topic with 1 partition to control who is active and standby\n+    TEST_HARNESS.ensureTopics(1, USER_TOPIC);\n+\n+    final AtomicLong timestampSupplier = new AtomicLong(BASE_TIME);\n+\n+    TEST_HARNESS.produceRows(\n+        USER_TOPIC,\n+        USER_PROVIDER,\n+        VALUE_FORMAT,\n+        timestampSupplier::getAndIncrement\n+    );\n+\n+    //Create stream\n+    makeAdminRequest(\n+        \"CREATE STREAM \" + USERS_STREAM\n+            + \" (\" + USER_PROVIDER.ksqlSchemaString() + \")\"\n+            + \" WITH (\"\n+            + \"   kafka_topic='\" + USER_TOPIC + \"', \"\n+            + \"   key='\" + USER_PROVIDER.key() + \"', \"\n+            + \"   value_format='\" + VALUE_FORMAT + \"'\"\n+            + \");\"\n+    );\n+  }\n+\n+  @Before\n+  public void setUp() {\n+    REST_APP_0.start();\n+    REST_APP_1.start();\n+    REST_APP_2.start();\n+    output = KsqlIdentifierTestUtil.uniqueIdentifierName();\n+\n+  }\n+\n+  @After\n+  public void cleanUp() {\n+    REST_APP_0.stop();\n+    REST_APP_1.stop();\n+    REST_APP_2.stop();\n+  }\n+\n+  @Test(timeout = 60000)\n+  public void shouldQueryActiveWhenActiveAliveQueryIssuedToStandby() {\n+    // Given:\n+    final String key = Iterables.get(USER_PROVIDER.data().keySet(), 0);\n+    final String sql = \"SELECT * FROM \" + output + \" WHERE ROWKEY = '\" + key + \"';\";\n+    makeAdminRequest(\n+        \"CREATE TABLE \" + output + \" AS\"\n+            + \" SELECT COUNT(1) AS COUNT FROM \" + USERS_STREAM\n+            + \" GROUP BY \" + USER_PROVIDER.key() + \";\"\n+    );\n+    waitForTableRows();\n+    HighAvailabilityTestUtil.waitForClusterToBeDiscovered(REST_APP_0, 3);\n+    HighAvailabilityTestUtil.waitForStreamsMetadataToInitialize(\n+        REST_APP_0, ImmutableList.of(host0, host1, host2), QUERY_ID);\n+    ClusterFormation clusterFormation = findClusterFormation();", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQzNjMyNA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375436324", "bodyText": "Done", "author": "vpapavas", "createdAt": "2020-02-05T18:40:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ3MDU3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ3MTQ5NQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373471495", "bodyText": "how about:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                assertThat(heartbeatAgent.getHostsStatus().containsKey(remoteHostInfo), is(true));\n          \n          \n            \n                assertThat(heartbeatAgent.getHostsStatus(), hasKey(remoteHostInfo));", "author": "big-andy-coates", "createdAt": "2020-01-31T13:10:56Z", "path": "ksql-rest-app/src/test/java/io/confluent/ksql/rest/server/HeartbeatAgentTest.java", "diffHunk": "@@ -100,7 +97,7 @@ public void shouldDiscoverServersInCluster() {\n     discoverService.runOneIteration();\n \n     // Then:\n-    assertThat(heartbeatAgent.getHostsStatus().keySet().contains(remoteHostInfo.toString()), is(true));\n+    assertThat(heartbeatAgent.getHostsStatus().containsKey(remoteHostInfo), is(true));", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ3MTc1NA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373471754", "bodyText": "nit: remove.", "author": "big-andy-coates", "createdAt": "2020-01-31T13:11:35Z", "path": "ksql-rest-app/src/test/java/io/confluent/ksql/rest/server/TestKsqlRestApp.java", "diffHunk": "@@ -400,6 +400,7 @@ private static KsqlRestConfig buildConfig(\n \n     config.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers.get());\n     config.putIfAbsent(KsqlRestConfig.LISTENERS_CONFIG, \"http://localhost:0,https://localhost:0\");\n+    //config.putIfAbsent(KsqlRestConfig.ADVERTISED_LISTENER_CONFIG, \"http://localhost:1234\");", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ3MzIyNQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373473225", "bodyText": "this is actually storing topic-partitions, right?  In the form <topic-name>-<partition-number> and its relying on TopicPartition.toString()` to build that string, which we don't control.\nMuch better to have Set<TopicPartitionEntity> so we / others don't need to parse the string and we're decoupled from any changes to TopicPartition.", "author": "big-andy-coates", "createdAt": "2020-01-31T13:15:02Z", "path": "ksql-rest-model/src/main/java/io/confluent/ksql/rest/entity/ActiveStandbyEntity.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.entity;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.collect.ImmutableSet;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+@JsonIgnoreProperties(ignoreUnknown = true)\n+public class ActiveStandbyEntity {\n+\n+  private final Set<String> activeStores;\n+  private final Set<String> activePartitions;", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk0OTU4OQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r374949589", "bodyText": "Done", "author": "vpapavas", "createdAt": "2020-02-04T22:05:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ3MzIyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ3MzYxMg==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373473612", "bodyText": "Can we make this immutable please?\nYou'll need to make the fields ImmutableSet.\n(Run ImmutableTest to ensure everything is good)", "author": "big-andy-coates", "createdAt": "2020-01-31T13:16:02Z", "path": "ksql-rest-model/src/main/java/io/confluent/ksql/rest/entity/ActiveStandbyEntity.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.entity;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.collect.ImmutableSet;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+@JsonIgnoreProperties(ignoreUnknown = true)\n+public class ActiveStandbyEntity {", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA1NTc3OQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375055779", "bodyText": "Done", "author": "vpapavas", "createdAt": "2020-02-05T04:38:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ3MzYxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ3Mzc2Mg==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373473762", "bodyText": "to be immutable ActiveStandbyEntity must be immutable too.", "author": "big-andy-coates", "createdAt": "2020-01-31T13:16:29Z", "path": "ksql-rest-model/src/main/java/io/confluent/ksql/rest/entity/ActiveStandbyResponse.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.entity;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.errorprone.annotations.Immutable;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+@JsonIgnoreProperties(ignoreUnknown = true)\n+@Immutable", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ3NTIyMg==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373475222", "bodyText": "This will throw a number parsing error if the second part is not a number, which ain't nice.\nHow about:\nCan we throw a more descriptive exception here? e.g. \n\n```java\nfinal String [] parts = serializedPair.split(\":\");\nif (parts.length != 2) {\n   throw new KsqlException(\"Invalid host info. Expected format: <hostname>:<port>, but was \" + seirlizedPair;\n}\n\nthis.host = Objects.requireNonNull(parts[0], \"host\");\n\ntry {\n   this.port = Integer.parseInt(parts[1]);\n} catch (final Exception e) {\n   throw new KsqlException(\"Invalid host info. Expected format: <hostname>:<port>, but was \" + seirlizedPair, e);\n}", "author": "big-andy-coates", "createdAt": "2020-01-31T13:20:32Z", "path": "ksql-rest-model/src/main/java/io/confluent/ksql/rest/entity/HostInfoEntity.java", "diffHunk": "@@ -26,15 +27,22 @@\n   private final String host;\n   private final int port;\n \n-  @JsonCreator\n   public HostInfoEntity(\n-      @JsonProperty(\"host\") final String host,\n-      @JsonProperty(\"port\") final int port\n+      final String host,\n+      final int port\n   ) {\n     this.host = Objects.requireNonNull(host, \"host\");\n     this.port = Objects.requireNonNull(port, \"port\");\n   }\n \n+  @JsonCreator\n+  public HostInfoEntity(final String serializedPair) {\n+    final String [] parts = serializedPair.split(\":\");\n+    Preconditions.checkArgument(parts.length == 2);\n+    this.host = Objects.requireNonNull(parts[0], \"host\");\n+    this.port = Integer.parseInt(parts[1]);\n+  }", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ3NTM1NA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373475354", "bodyText": "nit: validate params that will be stored in object state; ensuring object does not get into an invalid state.", "author": "big-andy-coates", "createdAt": "2020-01-31T13:20:53Z", "path": "ksql-rest-model/src/main/java/io/confluent/ksql/rest/entity/HostStatusEntity.java", "diffHunk": "@@ -18,28 +18,26 @@\n import com.fasterxml.jackson.annotation.JsonCreator;\n import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n import com.fasterxml.jackson.annotation.JsonProperty;\n+import java.util.Map;\n import java.util.Objects;\n \n @JsonIgnoreProperties(ignoreUnknown = true)\n public class HostStatusEntity {\n \n-  private HostInfoEntity hostInfoEntity;\n   private boolean hostAlive;\n   private long lastStatusUpdateMs;\n+  private Map<String, ActiveStandbyEntity> perQueryActiveStandbyEntity;\n \n   @JsonCreator\n   public HostStatusEntity(\n-      @JsonProperty(\"hostInfoEntity\") final HostInfoEntity hostInfoEntity,\n       @JsonProperty(\"hostAlive\") final boolean hostAlive,\n-      @JsonProperty(\"lastStatusUpdateMs\") final long lastStatusUpdateMs\n+      @JsonProperty(\"lastStatusUpdateMs\") final long lastStatusUpdateMs,\n+      @JsonProperty(\"perQueryActiveStandbyEntity\")\n+      final Map<String, ActiveStandbyEntity> perQueryActiveStandbyEntity\n   ) {\n-    this.hostInfoEntity = Objects.requireNonNull(hostInfoEntity, \"hostInfoEntity\");\n     this.hostAlive = hostAlive;\n     this.lastStatusUpdateMs = lastStatusUpdateMs;\n-  }\n-\n-  public HostInfoEntity getHostInfoEntity() {\n-    return hostInfoEntity;\n+    this.perQueryActiveStandbyEntity = perQueryActiveStandbyEntity;", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA1NTgyMg==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375055822", "bodyText": "Done", "author": "vpapavas", "createdAt": "2020-02-05T04:38:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ3NTM1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ3NTcyMA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373475720", "bodyText": "Can we make this type immutable please?\nChange this to a withPerQueryActiveStandbyEntity that returns a new instance.", "author": "big-andy-coates", "createdAt": "2020-01-31T13:21:48Z", "path": "ksql-rest-model/src/main/java/io/confluent/ksql/rest/entity/HostStatusEntity.java", "diffHunk": "@@ -62,6 +60,11 @@ public void setLastStatusUpdateMs(final long lastStatusUpdateMs) {\n     this.lastStatusUpdateMs = lastStatusUpdateMs;\n   }\n \n+  public void setPerQueryActiveStandbyEntity(\n+      final Map<String, ActiveStandbyEntity> perQueryActiveStandbyEntity) {\n+    this.perQueryActiveStandbyEntity = perQueryActiveStandbyEntity;\n+  }", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ3NjU5Mw==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373476593", "bodyText": "Can we avoid StringBuilder in toString please:\n@Override\n  public String toString() {\n    return \"ActiveAndStandByNodes{\" +\n        \"active=\" + active +\n        \", standBys=\" + standBys +\n        '}';\n  }", "author": "big-andy-coates", "createdAt": "2020-01-31T13:24:14Z", "path": "ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/ActiveAndStandByNodes.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.execution.streams.materialization.ks;\n+\n+import io.confluent.ksql.execution.streams.materialization.Locator.KsqlNode;\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+public class ActiveAndStandByNodes {\n+\n+  private final KsqlNode active;\n+  private final Set<KsqlNode> standBys;\n+\n+  public ActiveAndStandByNodes(final KsqlNode active) {\n+    this.active = Objects.requireNonNull(active, \"active\");\n+    this.standBys = new HashSet<>();\n+  }\n+\n+  public KsqlNode getActive() {\n+    return active;\n+  }\n+\n+  public Set<KsqlNode> getStandBys() {\n+    return standBys;\n+  }\n+\n+  public void addStandBy(final KsqlNode standBy) {\n+    this.standBys.add(standBy);\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return new StringBuilder()\n+        .append(String.format(\"active = %s ,\", active))\n+        .append(String.format(\"stanbys = %s .\", standBys))\n+        .toString();", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ4NzQ5Ng==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r374487496", "bodyText": "This class no longer exists", "author": "vpapavas", "createdAt": "2020-02-04T06:01:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ3NjU5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ3Njg1OQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373476859", "bodyText": "Is it possible to make this type immutable?  e.g. use a builder pattern, or have this return a new instance?\nIs this method called?", "author": "big-andy-coates", "createdAt": "2020-01-31T13:24:58Z", "path": "ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/ActiveAndStandByNodes.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.execution.streams.materialization.ks;\n+\n+import io.confluent.ksql.execution.streams.materialization.Locator.KsqlNode;\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+public class ActiveAndStandByNodes {\n+\n+  private final KsqlNode active;\n+  private final Set<KsqlNode> standBys;\n+\n+  public ActiveAndStandByNodes(final KsqlNode active) {\n+    this.active = Objects.requireNonNull(active, \"active\");\n+    this.standBys = new HashSet<>();\n+  }\n+\n+  public KsqlNode getActive() {\n+    return active;\n+  }\n+\n+  public Set<KsqlNode> getStandBys() {\n+    return standBys;\n+  }\n+\n+  public void addStandBy(final KsqlNode standBy) {\n+    this.standBys.add(standBy);\n+  }", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ3NzAwMg==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373477002", "bodyText": "Use string concat.", "author": "big-andy-coates", "createdAt": "2020-01-31T13:25:18Z", "path": "ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsLocator.java", "diffHunk": "@@ -114,5 +160,34 @@ public boolean isLocal() {\n     public URI location() {\n       return location;\n     }\n+\n+    @Override\n+    public String toString() {\n+      return new StringBuilder()\n+          .append(String.format(\"local = %s ,\", local))\n+          .append(String.format(\"location = %s ,\", location))\n+          .toString();\n+    }", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ3NzgyOA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373477828", "bodyText": "add a test that the third boolean parameter is actually being passed correctly.", "author": "big-andy-coates", "createdAt": "2020-01-31T13:27:22Z", "path": "ksql-streams/src/test/java/io/confluent/ksql/execution/streams/materialization/ks/KsStateStoreTest.java", "diffHunk": "@@ -211,7 +213,7 @@ public void shouldReturnSessionStore() {\n   public void shouldReturnWindowStore() {\n     // Given:\n     final ReadOnlyWindowStore<?, ?> windowStore = mock(ReadOnlyWindowStore.class);\n-    when(kafkaStreams.store(any(), any())).thenReturn(windowStore);\n+    when(kafkaStreams.store(any(), any(), anyBoolean())).thenReturn(windowStore);", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzU2MDMxNA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373560314", "bodyText": "I feel like we should change this config to something like enable.standby.reads because (optimistically) in the future we may have some stronger sense of consistency and define what \"stale\" means. It also may not be stale if the update rate is slow and the standbys are caught up", "author": "agavra", "createdAt": "2020-01-31T16:13:05Z", "path": "ksql-common/src/main/java/io/confluent/ksql/util/KsqlConfig.java", "diffHunk": "@@ -165,12 +165,25 @@\n       \"Config to enable or disable transient pull queries on a specific KSQL server.\";\n   public static final boolean KSQL_QUERY_PULL_ENABLE_DEFAULT = true;\n \n+  // Shall we remove this config?\n   public static final String KSQL_QUERY_PULL_ROUTING_TIMEOUT_MS_CONFIG =\n       \"ksql.query.pull.routing.timeout.ms\";\n   public static final Long KSQL_QUERY_PULL_ROUTING_TIMEOUT_MS_DEFAULT = 30000L;\n   public static final String KSQL_QUERY_PULL_ROUTING_TIMEOUT_MS_DOC = \"Timeout in milliseconds \"\n       + \"when waiting for the lookup of the owner of a row key\";\n \n+\n+  public static final String KSQL_QUERY_PULL_ENABLE_STALE_READS =\n+      \"ksql.query.pull.enable.stale.reads\";", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ5NDM5Mg==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r374494392", "bodyText": "+1 standbys can actually be caught up.not necessarily stale", "author": "vinothchandar", "createdAt": "2020-02-04T06:32:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzU2MDMxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTA2MzA2Mw==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375063063", "bodyText": "Changed to standby", "author": "vpapavas", "createdAt": "2020-02-05T05:16:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzU2MDMxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzU2NDU2Mw==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373564563", "bodyText": "nit: instead of writing this in a comment, enforce it \ud83d\ude04\nPreconditions.ensureState(immutableHostsStatus.get().isEmpty(), \"expected empty host info on startup\");", "author": "agavra", "createdAt": "2020-01-31T16:21:30Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java", "diffHunk": "@@ -157,37 +154,18 @@ void stopAgent() {\n \n   void setLocalAddress(final String applicationServer) {\n \n-    this.localHostInfo = parseHostInfo(applicationServer);\n-    this.localHostString = localHostInfo.toString();\n+    this.localHostInfo = ServerUtil.parseHostInfo(applicationServer);\n     try {\n       this.localURL = new URL(applicationServer);\n     } catch (final Exception e) {\n       throw new IllegalStateException(\"Failed to convert remote host info to URL.\"\n                                           + \" remoteInfo: \" + localHostInfo.host() + \":\"\n                                           + localHostInfo.host());\n     }\n-    this.hostsStatus.putIfAbsent(localHostString, new HostStatusEntity(\n-        new HostInfoEntity(localHostInfo.host(), localHostInfo.port()),\n-        true,\n-        clock.millis()));\n+    //This is called on startup of the heartbeat agent, no other entries should exist in the map", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzU2NTU1Ng==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373565556", "bodyText": "note that this doesn't do a deep copy, so andy's comment (https://github.com/confluentinc/ksql/pull/4398/files#r372567512) is extra important, otherwise even though the map is immutable the entries within the map would be mutable (e.g. L220 actually affects the source map too!)", "author": "agavra", "createdAt": "2020-01-31T16:23:26Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java", "diffHunk": "@@ -233,42 +211,50 @@ protected ScheduledExecutorService executor() {\n      * @param windowEnd the end time in ms of the current window\n      */\n     private void processHeartbeats(final long windowStart, final long windowEnd) {\n+\n+      final Map<HostInfo, HostStatus> copyOnWrite = new HashMap<>(immutableHostsStatus.get());", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzcxMTgxMg==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373711812", "bodyText": "Yes, @AlanConfluent's PR and the subsequent merge of our both PR's adds the immutable internal objects. We wanted to do it one place to make merging easier but I guess it doesn't because it complicates reviewing. I am making all the internal ones immutable as well", "author": "vpapavas", "createdAt": "2020-01-31T22:22:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzU2NTU1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzU2ODUyNA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r373568524", "bodyText": "I would be more comfortable if we split this into two PRs: the first makes the concurrency model clearer (avoiding concurrent maps, doing copy-on-write) and the second implementing the pull query routing. that way we can focus on each individual problem", "author": "agavra", "createdAt": "2020-01-31T16:29:09Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/HeartbeatAgent.java", "diffHunk": "@@ -105,7 +101,8 @@ private HeartbeatAgent(final KsqlEngine engine,\n     this.serviceManager = new ServiceManager(Arrays.asList(\n         new DiscoverClusterService(), new SendHeartbeatService(), new CheckHeartbeatService()));\n     this.receivedHeartbeats = new ConcurrentHashMap<>();\n-    this.hostsStatus = new ConcurrentHashMap<>();\n+    this.immutableHostsStatus = new AtomicReference<>();", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ5NTY4MA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r374495680", "bodyText": "reword: Effectively, stale values may be returned for some keys sacrificing consistency for higher availability. ?", "author": "vinothchandar", "createdAt": "2020-02-04T06:37:31Z", "path": "ksql-common/src/main/java/io/confluent/ksql/util/KsqlConfig.java", "diffHunk": "@@ -165,12 +165,25 @@\n       \"Config to enable or disable transient pull queries on a specific KSQL server.\";\n   public static final boolean KSQL_QUERY_PULL_ENABLE_DEFAULT = true;\n \n+  // Shall we remove this config?\n   public static final String KSQL_QUERY_PULL_ROUTING_TIMEOUT_MS_CONFIG =\n       \"ksql.query.pull.routing.timeout.ms\";\n   public static final Long KSQL_QUERY_PULL_ROUTING_TIMEOUT_MS_DEFAULT = 30000L;\n   public static final String KSQL_QUERY_PULL_ROUTING_TIMEOUT_MS_DOC = \"Timeout in milliseconds \"\n       + \"when waiting for the lookup of the owner of a row key\";\n \n+\n+  public static final String KSQL_QUERY_PULL_ENABLE_STALE_READS =\n+      \"ksql.query.pull.enable.stale.reads\";\n+  private static final String KSQL_QUERY_PULL_ENABLE_STALE_READS_DOC =\n+      \"Config to enable/disable forwarding pull queries to standby hosts when the active is dead. \"\n+          + \"Effectively, the accuracy of pull queries is sacrificed for higher availability. \"", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ5NjkwMg==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r374496902", "bodyText": "I had left an earlier suggestion to munge this into the cluster status endpoint.. if you want to keep this separate, thats fine as well. but can we give this a better name than ActiveStandby[Request|Response]?  May be TablePartitionStatus or TableReplicaStatus? something that denotes this is returning status information.", "author": "vinothchandar", "createdAt": "2020-02-04T06:42:23Z", "path": "ksql-execution/src/main/java/io/confluent/ksql/services/SimpleKsqlClient.java", "diffHunk": "@@ -55,4 +56,12 @@ void makeAsyncHeartbeatRequest(\n    * @return response containing the cluster status.\n    */\n   RestResponse<ClusterStatusResponse> makeClusterStatusRequest(URI serverEndPoint);\n+\n+  /**\n+   * Send a request to remote Ksql server to inquire to inquire about which state stores the\n+   * remote server maintains as an active and standby.\n+   * @param serverEndPoint the remote destination.\n+   * @return response containing the state stores for which the remote host is active and standby.\n+   */\n+  RestResponse<ActiveStandbyResponse> makeActiveStandbyRequest(URI serverEndPoint);", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDgxNzk5MQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r374817991", "bodyText": "It is already part of ClusterStatusResource/Response", "author": "vpapavas", "createdAt": "2020-02-04T17:34:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ5NjkwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ5ODAxMg==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r374498012", "bodyText": "locate is doing more than just locating... Can we rename Locator to Router (and its implementations) and change locate() to route()?", "author": "vinothchandar", "createdAt": "2020-02-04T06:46:31Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java", "diffHunk": "@@ -173,61 +173,149 @@ public static TableRowsEntity execute(\n \n       final Struct rowKey = asKeyStruct(whereInfo.rowkey, query.getPhysicalSchema());\n \n-      final KsqlConfig ksqlConfig = statement.getConfig();\n-      final KsqlNode owner = getOwner(ksqlConfig, rowKey, mat);\n-      if (!owner.isLocal()) {\n-        return proxyTo(owner, statement, serviceContext);\n-      }\n-\n-      final Result result;\n-      if (whereInfo.windowStartBounds.isPresent()) {\n-        final Range<Instant> windowStart = whereInfo.windowStartBounds.get();\n+      final PullQueryContext pullQueryContext = new PullQueryContext(\n+          rowKey,\n+          mat,\n+          analysis,\n+          whereInfo,\n+          queryId,\n+          contextStacker);\n+\n+      return handlePullQuery(\n+          statement,\n+          executionContext,\n+          serviceContext,\n+          pullQueryContext,\n+          heartbeatAgent,\n+          routingFilters\n+      );\n \n-        final List<? extends TableRow> rows = mat.windowed()\n-            .get(rowKey, windowStart);\n+    } catch (final Exception e) {\n+      throw new KsqlStatementException(\n+          e.getMessage() == null ? \"Server Error\" : e.getMessage(),\n+          statement.getStatementText(),\n+          e\n+      );\n+    }\n+  }\n \n-        result = new Result(mat.schema(), rows);\n-      } else {\n-        final List<? extends TableRow> rows = mat.nonWindowed()\n-            .get(rowKey)\n-            .map(ImmutableList::of)\n-            .orElse(ImmutableList.of());\n+  private static TableRowsEntity handlePullQuery(\n+      final ConfiguredStatement<Query> statement,\n+      final KsqlExecutionContext executionContext,\n+      final ServiceContext serviceContext,\n+      final PullQueryContext pullQueryContext,\n+      final Optional<HeartbeatAgent> heartbeatAgent,\n+      final List<RoutingFilter> routingFilters\n+  ) {\n+    try {\n+      // Get active and standby nodes for this key\n+      final Locator locator = pullQueryContext.mat.locator();\n+      final List<KsqlNode> filteredAndOrderedNodes = locator.locate(", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk1NDE0Mg==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r374954142", "bodyText": "Locator is not routing, it is locating and filtering. I feel the name serves the purpose better than Router", "author": "vpapavas", "createdAt": "2020-02-04T22:16:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ5ODAxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUwMTM3MQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r374501371", "bodyText": "Given the LivenessFilter object is created together with the heartbeat agent, does it make sense to pass the agent into constructor... Having the allHostsStatus map here in the filter() method seems very specific to the liveness filter implementation.. (e.g there could be another filter implementation which just filters based on host datacenter say)..\nIn this model, PullQueryExecutor need not obtain this map everytime and instead just invoke filter(hostInfo, storeName, partition) and let the LivenessFilter class interact with the agent and obtain the information it needs to do the filtering..", "author": "vinothchandar", "createdAt": "2020-02-04T06:59:41Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/LivenessFilter.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.server;\n+\n+import io.confluent.ksql.execution.streams.RoutingFilter;\n+import io.confluent.ksql.util.HostStatus;\n+import java.util.Map;\n+import org.apache.kafka.streams.state.HostInfo;\n+\n+/**\n+ * Filters ksql hosts based on whether they are alive or dead.\n+ */\n+public class LivenessFilter implements RoutingFilter {\n+\n+  public LivenessFilter() {\n+  }\n+\n+  /**\n+   * Returns true if the host is alive. If the heartbeat agent is not enabled, all hosts are\n+   * assumed to be alive.\n+   * @param hostInfo The host for which the status is checked\n+   * @param storeName Ignored\n+   * @param partition Ignored\n+   * @return true if the host is alive, false otherwise.\n+   */\n+  @Override\n+  public boolean filter(\n+      final Map<HostInfo, HostStatus> allHostsStatus,", "originalCommit": "a0de6e1d39f813ef4608f14e8d9e2ba6afe573bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk5NjYwMA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r374996600", "bodyText": "If I do what you say, then then we create a new map per host per filter that may use the map. Whereas with what I did, we use a single map per query.", "author": "vpapavas", "createdAt": "2020-02-05T00:15:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUwMTM3MQ=="}], "type": "inlineReview"}, {"oid": "6f331862a48140db4d3eedc12e66e6002312bb8c", "url": "https://github.com/confluentinc/ksql/commit/6f331862a48140db4d3eedc12e66e6002312bb8c", "message": "mock heartbeat for standby routing\n\nprogress\n\nAdded functional test for routing and endpoint for active standby info\n\nundo changes to log files\n\nfixing tests\n\nfixed tests\n\naddressed vinoth's comments\n\nfixed tests\n\nfixed broken test after kafka merge\n\naddress alans comments\n\nadd missed file\n\nmade hostStatus map atomic reference, changed copy-on-read to copy-on-write\n\nfix dead store bug?\n\napplying andy's comments\n\nsuccessful rebase\n\nrebase and apply comments", "committedDate": "2020-02-05T01:53:48Z", "type": "commit"}, {"oid": "626b7ef2dcd973245b9a329aa37543085c248e8f", "url": "https://github.com/confluentinc/ksql/commit/626b7ef2dcd973245b9a329aa37543085c248e8f", "message": "all tests pass", "committedDate": "2020-02-05T04:41:42Z", "type": "commit"}, {"oid": "626b7ef2dcd973245b9a329aa37543085c248e8f", "url": "https://github.com/confluentinc/ksql/commit/626b7ef2dcd973245b9a329aa37543085c248e8f", "message": "all tests pass", "committedDate": "2020-02-05T04:41:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ0NDczNw==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375444737", "bodyText": "Bad merge", "author": "AlanConfluent", "createdAt": "2020-02-05T18:56:40Z", "path": "ksql-execution/src/main/java/io/confluent/ksql/services/SimpleKsqlClient.java", "diffHunk": "@@ -58,7 +58,12 @@ void makeAsyncHeartbeatRequest(\n   RestResponse<ClusterStatusResponse> makeClusterStatusRequest(URI serverEndPoint);\n \n   /**\n+<<<<<<< HEAD", "originalCommit": "626b7ef2dcd973245b9a329aa37543085c248e8f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ0OTI4Mg==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375449282", "bodyText": "I will likely similarly add a max end offset to this interface for lag purposes.\nAlso applicationQueryId, since this is how lags are keyed.", "author": "AlanConfluent", "createdAt": "2020-02-05T19:05:33Z", "path": "ksql-streams/src/main/java/io/confluent/ksql/execution/streams/RoutingFilter.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.execution.streams;\n+\n+import io.confluent.ksql.util.HostStatus;\n+import io.confluent.ksql.util.KsqlHost;\n+import java.util.Map;\n+import org.apache.kafka.streams.state.HostInfo;\n+\n+/**\n+ * Used to filter ksql hosts based on criteria specified in implementing classes.\n+ * One such example is a filter that checks whether hosts are alive or dead as determined\n+ * by the heartbeat agent.\n+ */\n+public interface RoutingFilter {\n+\n+  boolean filter(\n+      Map<KsqlHost, HostStatus> allHostsStatus,", "originalCommit": "626b7ef2dcd973245b9a329aa37543085c248e8f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ2NzQxOA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375467418", "bodyText": "I removed the map", "author": "vpapavas", "createdAt": "2020-02-05T19:40:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ0OTI4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ1NDc1Mw==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375454753", "bodyText": "extra parens? asKsqlHost((activeHost))", "author": "AlanConfluent", "createdAt": "2020-02-05T19:16:15Z", "path": "ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsLocator.java", "diffHunk": "@@ -51,27 +64,61 @@\n   }\n \n   @Override\n-  @SuppressWarnings(\"deprecation\")\n-  public Optional<KsqlNode> locate(final Struct key) {\n-    final StreamsMetadata metadata = kafkaStreams\n-        .metadataForKey(stateStoreName, key, keySerializer);\n-\n-    if (metadata == StreamsMetadata.NOT_AVAILABLE) {\n-      return Optional.empty();\n+  public List<KsqlNode> locate(\n+      final Struct key,\n+      final Map<KsqlHost, HostStatus> allHostsStatus,\n+      final RoutingFilter routingFilters\n+  ) {\n+    final KeyQueryMetadata metadata = kafkaStreams\n+        .queryMetadataForKey(stateStoreName, key, keySerializer);\n+\n+    // Fail fast if Streams not ready. Let client handle it\n+    if (metadata == KeyQueryMetadata.NOT_AVAILABLE) {\n+      LOG.debug(\"KeyQueryMetadata not available for state store {} and key {}\",\n+                stateStoreName, key);\n+      throw new MaterializationException(String.format(\n+          \"KeyQueryMetadata not available for state store %s and key %s\", stateStoreName, key));\n     }\n \n-    final HostInfo hostInfo = metadata.hostInfo();\n-    return Optional.of(asNode(hostInfo));\n+    final HostInfo activeHost = metadata.getActiveHost();\n+    final Set<HostInfo> standByHosts = metadata.getStandbyHosts();\n+    LOG.info(\"Before filtering: Active host {} , standby hosts {}\", activeHost, standByHosts);\n+\n+    final Stream<KsqlHost> active = Stream.of(asKsqlHost((activeHost)));", "originalCommit": "626b7ef2dcd973245b9a329aa37543085c248e8f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ1Njc2NQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375456765", "bodyText": "host.equals(activeHost)?", "author": "AlanConfluent", "createdAt": "2020-02-05T19:19:56Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/ActiveHostFilter.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.server;\n+\n+import io.confluent.ksql.execution.streams.RoutingFilter;\n+import io.confluent.ksql.util.HostStatus;\n+import io.confluent.ksql.util.KsqlHost;\n+import java.util.Map;\n+import org.apache.kafka.streams.state.HostInfo;\n+\n+/**\n+ * Filters for the active host.\n+ */\n+public class ActiveHostFilter implements RoutingFilter {\n+\n+  public ActiveHostFilter() {\n+  }\n+\n+  /**\n+   * Returns true if the host is alive. If the heartbeat agent is not enabled, all hosts are\n+   * assumed to be alive.\n+   * @param allHostsStatus status of all hosts as provided by heartbeat agent\n+   * @param activeHost the active host for a particular state store\n+   * @param host The host for which the status is checked\n+   * @param storeName Ignored\n+   * @param partition Ignored\n+   * @return true if the host is alive, false otherwise.\n+   */\n+  @Override\n+  public boolean filter(\n+      final Map<KsqlHost, HostStatus> allHostsStatus,\n+      final HostInfo activeHost,\n+      final KsqlHost host,\n+      final String storeName,\n+      final int partition) {\n+\n+    return host.host().equals(activeHost.host()) && host.port() == activeHost.port();", "originalCommit": "626b7ef2dcd973245b9a329aa37543085c248e8f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ2MjIwMg==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375462202", "bodyText": "One last pitch for the factory idea here.  You could have something like List<RoutingFilter> routingFilters = factory.createRoutingFilters(activeHost, standByHosts); or if using the new composition, a single RoutingFilter\nWithin this factory, you could get allHostsStatus and pass it into the constructor of the filter, removing the need to pipe this all the way through.  Also, for lags, I could compute the max end offset from that same info and pass that into the constructor of the lag filter.\nThen we would modify a single factory which would register all of the filters and set them up.  Just an idea which would generalize fairly well.", "author": "AlanConfluent", "createdAt": "2020-02-05T19:29:57Z", "path": "ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsLocator.java", "diffHunk": "@@ -51,27 +64,61 @@\n   }\n \n   @Override\n-  @SuppressWarnings(\"deprecation\")\n-  public Optional<KsqlNode> locate(final Struct key) {\n-    final StreamsMetadata metadata = kafkaStreams\n-        .metadataForKey(stateStoreName, key, keySerializer);\n-\n-    if (metadata == StreamsMetadata.NOT_AVAILABLE) {\n-      return Optional.empty();\n+  public List<KsqlNode> locate(\n+      final Struct key,\n+      final Map<KsqlHost, HostStatus> allHostsStatus,", "originalCommit": "626b7ef2dcd973245b9a329aa37543085c248e8f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ2NjgxOQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375466819", "bodyText": "I can also do this in a followup with my lags change.", "author": "AlanConfluent", "createdAt": "2020-02-05T19:38:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ2MjIwMg=="}], "type": "inlineReview"}, {"oid": "58f3691b8654ef33b0c93b2b0f51ac48b75e5282", "url": "https://github.com/confluentinc/ksql/commit/58f3691b8654ef33b0c93b2b0f51ac48b75e5282", "message": "Applied all comments", "committedDate": "2020-02-05T20:59:22Z", "type": "commit"}, {"oid": "2327c7a98e878b3278785170a6ce004859f2db7c", "url": "https://github.com/confluentinc/ksql/commit/2327c7a98e878b3278785170a6ce004859f2db7c", "message": "minor fixes", "committedDate": "2020-02-05T21:43:43Z", "type": "commit"}, {"oid": "98a397131093a6ddea14deaf0ab90c58540be4a4", "url": "https://github.com/confluentinc/ksql/commit/98a397131093a6ddea14deaf0ab90c58540be4a4", "message": "added timestamp to log, removed system.out", "committedDate": "2020-02-05T22:40:24Z", "type": "commit"}, {"oid": "37025d83ad0e92a0e42d6b18514428dd0c4c87ca", "url": "https://github.com/confluentinc/ksql/commit/37025d83ad0e92a0e42d6b18514428dd0c4c87ca", "message": "changed back log files", "committedDate": "2020-02-05T22:42:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU2MzgxNg==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375563816", "bodyText": "we should also add a note that for this to work, standby replicas must be turned on using ksql.streams.num.standby.replicas >= 1 . Ideally we should auto set the standby replication.. Thats another way to go about it.. May be file an issue for later?", "author": "vinothchandar", "createdAt": "2020-02-05T23:20:51Z", "path": "ksql-common/src/main/java/io/confluent/ksql/util/KsqlConfig.java", "diffHunk": "@@ -167,11 +167,19 @@\n       \"Config to enable or disable transient pull queries on a specific KSQL server.\";\n   public static final boolean KSQL_QUERY_PULL_ENABLE_DEFAULT = true;\n \n-  public static final String KSQL_QUERY_PULL_ROUTING_TIMEOUT_MS_CONFIG =\n-      \"ksql.query.pull.routing.timeout.ms\";\n-  public static final Long KSQL_QUERY_PULL_ROUTING_TIMEOUT_MS_DEFAULT = 30000L;\n-  public static final String KSQL_QUERY_PULL_ROUTING_TIMEOUT_MS_DOC = \"Timeout in milliseconds \"\n-      + \"when waiting for the lookup of the owner of a row key\";\n+  public static final String KSQL_QUERY_PULL_ENABLE_STANDBY_READS =\n+        \"ksql.query.pull.enable.stale.reads\";\n+  private static final String KSQL_QUERY_PULL_ENABLE_STANDBY_READS_DOC =", "originalCommit": "37025d83ad0e92a0e42d6b18514428dd0c4c87ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU4MDQ2Nw==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375580467", "bodyText": "#4454 4454", "author": "vpapavas", "createdAt": "2020-02-06T00:16:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU2MzgxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU2NDQyOA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375564428", "bodyText": "can we rename host to otherHost or thatHost for better readability?", "author": "vinothchandar", "createdAt": "2020-02-05T23:22:39Z", "path": "ksql-common/src/main/java/io/confluent/ksql/util/KsqlHost.java", "diffHunk": "@@ -42,8 +43,8 @@ public boolean equals(final Object o) {\n       return false;\n     }\n \n-    final KsqlHost hostInfo = (KsqlHost) o;\n-    return port == hostInfo.port && host.equals(hostInfo.host);\n+    final KsqlHost host = (KsqlHost) o;\n+    return this.host.equals(host.host) && port == host.port;", "originalCommit": "37025d83ad0e92a0e42d6b18514428dd0c4c87ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU2NTI1MQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375565251", "bodyText": "Another suggestion.. Can we name this class KsqlHostPort or KsqlHostInfo, since it already has a member host", "author": "vinothchandar", "createdAt": "2020-02-05T23:25:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU2NDQyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU4MTA0Mw==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375581043", "bodyText": "Done", "author": "vpapavas", "createdAt": "2020-02-06T00:18:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU2NDQyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU2NDc5Nw==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375564797", "bodyText": "change the javadocs based on what this filter() implementation does?", "author": "vinothchandar", "createdAt": "2020-02-05T23:23:46Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/ActiveHostFilter.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.server;\n+\n+import io.confluent.ksql.execution.streams.RoutingFilter;\n+import io.confluent.ksql.util.KsqlHost;\n+import org.apache.kafka.streams.state.HostInfo;\n+\n+/**\n+ * Filters for the active host.\n+ */\n+public class ActiveHostFilter implements RoutingFilter {\n+\n+  public ActiveHostFilter() {\n+  }\n+\n+  /**\n+   * Returns true if the host is alive. If the heartbeat agent is not enabled, all hosts are", "originalCommit": "37025d83ad0e92a0e42d6b18514428dd0c4c87ca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU2NTYyNA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375565624", "bodyText": "nit: remove extra line?", "author": "vinothchandar", "createdAt": "2020-02-05T23:26:08Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/KsqlRestApplication.java", "diffHunk": "@@ -191,6 +195,7 @@ public static SourceName getCommandsStreamName() {\n       final Consumer<KsqlConfig> rocksDBConfigSetterHandler,\n       final Optional<HeartbeatAgent> heartbeatAgent,\n       final Optional<LagReportingAgent> lagReportingAgent\n+", "originalCommit": "37025d83ad0e92a0e42d6b18514428dd0c4c87ca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU2NTY5Ng==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375565696", "bodyText": "extra line?", "author": "vinothchandar", "createdAt": "2020-02-05T23:26:21Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/KsqlRestApplication.java", "diffHunk": "@@ -163,6 +166,7 @@\n   private final Optional<HeartbeatAgent> heartbeatAgent;\n   private final Optional<LagReportingAgent> lagReportingAgent;\n \n+", "originalCommit": "37025d83ad0e92a0e42d6b18514428dd0c4c87ca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU2NjI2MQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375566261", "bodyText": "file a follow up for fixing this? I understand doing that in this PR will balloon scope", "author": "vinothchandar", "createdAt": "2020-02-05T23:28:01Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/KsqlRestApplication.java", "diffHunk": "@@ -528,6 +541,7 @@ static KsqlRestApplication buildApplication(\n             new KsqlSecurityContextBinder(config, securityExtension, schemaRegistryClientFactory));\n   }\n \n+  @SuppressWarnings(\"checkstyle:MethodLength\")", "originalCommit": "37025d83ad0e92a0e42d6b18514428dd0c4c87ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU4MTY4Nw==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375581687", "bodyText": "Actually, not needed. I had already fixed it but forgot the supress", "author": "vpapavas", "createdAt": "2020-02-06T00:21:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU2NjI2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU2NzMxOQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375567319", "bodyText": "this could be set per request? is that why we have this here in addition to KsqlConfig?", "author": "vinothchandar", "createdAt": "2020-02-05T23:31:19Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/KsqlRestConfig.java", "diffHunk": "@@ -153,12 +153,17 @@\n       KSQL_CONFIG_PREFIX + \"lag.reporting.enable\";\n   private static final String KSQL_LAG_REPORTING_ENABLE_DOC =\n       \"Whether lag reporting is enabled or not. It is disabled by default.\";\n-\n   public static final String KSQL_LAG_REPORTING_SEND_INTERVAL_MS_CONFIG =\n       KSQL_CONFIG_PREFIX + \"lag.reporting.send.interval.ms\";\n   private static final String KSQL_LAG_REPORTING_SEND_INTERVAL_MS_DOC =\n       \"Interval at which lag reports are broadcasted to servers.\";\n \n+  public static final String KSQL_QUERY_STANDBY_ENABLE_CONFIG =", "originalCommit": "37025d83ad0e92a0e42d6b18514428dd0c4c87ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU4MjI0MA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375582240", "bodyText": "No . It got wrongly added with the rebase. Good catch", "author": "vpapavas", "createdAt": "2020-02-06T00:23:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU2NzMxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU4MjgzMw==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375582833", "bodyText": "It seems like you could just use KSQL_QUERY_PULL_ENABLE_STANDBY_READS rather than both.", "author": "AlanConfluent", "createdAt": "2020-02-06T00:25:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU2NzMxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU2OTc3NQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375569775", "bodyText": "Nice work on cleaning up this class!", "author": "vinothchandar", "createdAt": "2020-02-05T23:39:24Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java", "diffHunk": "@@ -251,6 +329,55 @@ private static ImmutableAnalysis analyze(\n     return queryAnalyzer.analyze(statement.getStatement(), Optional.empty());\n   }\n \n+  private static final class PullQueryContext {", "originalCommit": "37025d83ad0e92a0e42d6b18514428dd0c4c87ca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU3MDA5MA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375570090", "bodyText": "typo: StreamsMetadata?", "author": "vinothchandar", "createdAt": "2020-02-05T23:40:27Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/resources/ClusterStatusResource.java", "diffHunk": "@@ -71,15 +83,70 @@ private ClusterStatusResponse getResponse() {\n             entry -> new KsqlHostEntity(entry.getKey().host(), entry.getKey().port()) ,\n             entry -> new HostStatusEntity(entry.getValue().isHostAlive(),\n                                           entry.getValue().getLastStatusUpdateMs(),\n+                                          getActiveStandbyInformation(entry.getKey()),\n                                           getHostStoreLags(entry.getKey()))\n         ));\n \n     return new ClusterStatusResponse(response);\n   }\n \n+\n   private HostStoreLags getHostStoreLags(final KsqlHost ksqlHost) {\n     return lagReportingAgent\n-      .flatMap(agent -> agent.getLagPerHost(ksqlHost))\n+        .flatMap(agent -> agent.getLagPerHost(ksqlHost))\n         .orElse(EMPTY_HOST_STORE_LAGS);\n   }\n+\n+  private Map<String, ActiveStandbyEntity> getActiveStandbyInformation(final KsqlHost ksqlHost) {\n+    return engine.getPersistentQueries().stream()\n+    .flatMap(persistentQueryMetadata -> persistentQueryMetadata.getAllMetadata()\n+        .stream()\n+        .map(streamsMetadata -> new QueryIdAndSteamMetadata(\n+            persistentQueryMetadata.getQueryId().toString(), streamsMetadata)))\n+        .filter(queryIdAndSteamMetadata ->\n+                    queryIdAndSteamMetadata.streamsMetadata != StreamsMetadata.NOT_AVAILABLE)\n+        .filter(queryIdAndSteamMetadata ->\n+                    queryIdAndSteamMetadata.streamsMetadata.hostInfo().equals(asHostInfo(ksqlHost)))\n+        .collect(Collectors.toMap(queryIdAndSteamMetadata ->\n+                                      queryIdAndSteamMetadata.queryId ,\n+                                      QueryIdAndSteamMetadata::toActiveStandbyEntity));\n+  }\n+\n+  private static final class QueryIdAndSteamMetadata {", "originalCommit": "37025d83ad0e92a0e42d6b18514428dd0c4c87ca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU3MTQ1Ng==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375571456", "bodyText": "nice!", "author": "vinothchandar", "createdAt": "2020-02-05T23:45:09Z", "path": "ksql-rest-app/src/test/java/io/confluent/ksql/rest/integration/PullQueryRoutingFunctionalTest.java", "diffHunk": "@@ -0,0 +1,398 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.integration;\n+\n+import static io.confluent.ksql.rest.integration.HighAvailabilityTestUtil.sendHeartbeartsForWindowLength;\n+import static io.confluent.ksql.rest.integration.HighAvailabilityTestUtil.waitForClusterToBeDiscovered;\n+import static io.confluent.ksql.rest.integration.HighAvailabilityTestUtil.waitForRemoteServerToChangeStatus;\n+import static io.confluent.ksql.rest.integration.HighAvailabilityTestUtil.waitForStreamsMetadataToInitialize;\n+import static io.confluent.ksql.util.KsqlConfig.KSQL_STREAMS_PREFIX;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.not;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Iterables;\n+import io.confluent.common.utils.IntegrationTest;\n+import io.confluent.ksql.integration.IntegrationTestHarness;\n+import io.confluent.ksql.integration.Retry;\n+import io.confluent.ksql.name.ColumnName;\n+import io.confluent.ksql.rest.entity.ActiveStandbyEntity;\n+import io.confluent.ksql.rest.entity.ClusterStatusResponse;\n+import io.confluent.ksql.rest.entity.KsqlEntity;\n+import io.confluent.ksql.rest.entity.KsqlHostEntity;\n+import io.confluent.ksql.rest.entity.StreamedRow;\n+import io.confluent.ksql.rest.server.KsqlRestConfig;\n+import io.confluent.ksql.rest.server.TestKsqlRestApp;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.PhysicalSchema;\n+import io.confluent.ksql.schema.ksql.types.SqlTypes;\n+import io.confluent.ksql.serde.Format;\n+import io.confluent.ksql.serde.SerdeOption;\n+import io.confluent.ksql.test.util.KsqlIdentifierTestUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.Pair;\n+import io.confluent.ksql.util.UserDataProvider;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.regex.Pattern;\n+import kafka.zookeeper.ZooKeeperClientException;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.rules.ExpectedException;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.rules.Timeout;\n+\n+/**\n+ * Test to ensure pull queries route across multiple KSQL nodes correctly.\n+ *\n+ * <p>For tests on general syntax and handled see RestQueryTranslationTest's\n+ * materialized-aggregate-static-queries.json\n+ */\n+@SuppressWarnings(\"OptionalGetWithoutIsPresent\")\n+@Category({IntegrationTest.class})\n+public class PullQueryRoutingFunctionalTest {\n+\n+  private static final TemporaryFolder TMP = new TemporaryFolder();\n+\n+  static {\n+    try {\n+      TMP.create();\n+    } catch (final IOException e) {\n+      throw new AssertionError(\"Failed to init TMP\", e);\n+    }\n+  }\n+\n+  private static final Pattern QUERY_ID_PATTERN = Pattern.compile(\"with query ID: (\\\\S+)\");\n+  private static final KsqlHostEntity host0 = new KsqlHostEntity(\"localhost\", 8088);\n+  private static final KsqlHostEntity host1 = new KsqlHostEntity(\"localhost\",8089);\n+  private static final KsqlHostEntity host2 = new KsqlHostEntity(\"localhost\",8087);\n+  private static final String USER_TOPIC = \"user_topic\";\n+  private static final String USERS_STREAM = \"users\";\n+  private static final UserDataProvider USER_PROVIDER = new UserDataProvider();\n+  private static final Format VALUE_FORMAT = Format.JSON;\n+  private static final int HEADER = 1;\n+  private static final IntegrationTestHarness TEST_HARNESS = IntegrationTestHarness.build();\n+  private static final int BASE_TIME = 1_000_000;\n+  private final static String KEY = Iterables.get(USER_PROVIDER.data().keySet(), 0);\n+  private String output;\n+  private String QUERY_ID;\n+  private String sql;\n+\n+  private static final PhysicalSchema AGGREGATE_SCHEMA = PhysicalSchema.from(\n+      LogicalSchema.builder()\n+          .valueColumn(ColumnName.of(\"COUNT\"), SqlTypes.BIGINT)\n+          .build(),\n+      SerdeOption.none()\n+  );\n+\n+  private static final Map<String, Object> COMMON_CONFIG = ImmutableMap.<String, Object>builder()\n+      .put(KSQL_STREAMS_PREFIX + StreamsConfig.NUM_STREAM_THREADS_CONFIG, 1)\n+      .put(KsqlRestConfig.KSQL_HEARTBEAT_ENABLE_CONFIG, true)\n+      .put(KsqlRestConfig.KSQL_HEARTBEAT_SEND_INTERVAL_MS_CONFIG, 600000)\n+      .put(KsqlRestConfig.KSQL_HEARTBEAT_CHECK_INTERVAL_MS_CONFIG, 200)\n+      .put(KsqlRestConfig.KSQL_HEARTBEAT_DISCOVER_CLUSTER_MS_CONFIG, 2000)\n+      .put(KsqlConfig.KSQL_QUERY_PULL_ENABLE_STANDBY_READS, true)\n+      .put(KsqlConfig.KSQL_STREAMS_PREFIX + \"num.standby.replicas\", 1)\n+      .put(KsqlConfig.KSQL_SHUTDOWN_TIMEOUT_MS_CONFIG, 1000)\n+      .build();\n+\n+  @Rule\n+  public final TestKsqlRestApp REST_APP_0 = TestKsqlRestApp\n+      .builder(TEST_HARNESS::kafkaBootstrapServers)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.NUM_STREAM_THREADS_CONFIG, 1)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.STATE_DIR_CONFIG, getNewStateDir())\n+      .withProperty(KsqlRestConfig.LISTENERS_CONFIG, \"http://localhost:8088\")\n+      .withProperty(KsqlRestConfig.ADVERTISED_LISTENER_CONFIG, \"http://localhost:8088\")\n+      .withProperties(COMMON_CONFIG)\n+      .build();\n+\n+  @Rule\n+  public final TestKsqlRestApp REST_APP_1 = TestKsqlRestApp\n+      .builder(TEST_HARNESS::kafkaBootstrapServers)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.NUM_STREAM_THREADS_CONFIG, 1)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.STATE_DIR_CONFIG, getNewStateDir())\n+      .withProperty(KsqlRestConfig.LISTENERS_CONFIG, \"http://localhost:8089\")\n+      .withProperty(KsqlRestConfig.ADVERTISED_LISTENER_CONFIG, \"http://localhost:8089\")\n+      .withProperties(COMMON_CONFIG)\n+      .build();\n+\n+  @Rule\n+  public final TestKsqlRestApp REST_APP_2 = TestKsqlRestApp\n+      .builder(TEST_HARNESS::kafkaBootstrapServers)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.NUM_STREAM_THREADS_CONFIG, 1)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.STATE_DIR_CONFIG, getNewStateDir())\n+      .withProperty(KsqlRestConfig.LISTENERS_CONFIG, \"http://localhost:8087\")\n+      .withProperty(KsqlRestConfig.ADVERTISED_LISTENER_CONFIG, \"http://localhost:8087\")\n+      .withProperties(COMMON_CONFIG)\n+      .build();\n+\n+  @ClassRule\n+  public static final RuleChain CHAIN = RuleChain\n+      .outerRule(Retry.of(3, ZooKeeperClientException.class, 3, TimeUnit.SECONDS))\n+      .around(TEST_HARNESS);\n+\n+  @Rule\n+  public final Timeout timeout = Timeout.builder()\n+      .withTimeout(1, TimeUnit.MINUTES)\n+      .withLookingForStuckThread(true)\n+      .build();\n+\n+  @Rule\n+  public final ExpectedException expectedException = ExpectedException.none();\n+\n+  @BeforeClass\n+  public static void setUpClass() {\n+    //Create topic with 1 partition to control who is active and standby\n+    TEST_HARNESS.ensureTopics(1, USER_TOPIC);\n+\n+    final AtomicLong timestampSupplier = new AtomicLong(BASE_TIME);\n+\n+    TEST_HARNESS.produceRows(\n+        USER_TOPIC,\n+        USER_PROVIDER,\n+        VALUE_FORMAT,\n+        timestampSupplier::getAndIncrement\n+    );\n+  }\n+\n+  @Before\n+  public void setUp() {\n+    //Create stream\n+    makeAdminRequest(\n+        REST_APP_0,\n+        \"CREATE STREAM \" + USERS_STREAM\n+            + \" (\" + USER_PROVIDER.ksqlSchemaString() + \")\"\n+            + \" WITH (\"\n+            + \"   kafka_topic='\" + USER_TOPIC + \"', \"\n+            + \"   key='\" + USER_PROVIDER.key() + \"', \"\n+            + \"   value_format='\" + VALUE_FORMAT + \"'\"\n+            + \");\"\n+    );\n+    //Create table\n+    output = KsqlIdentifierTestUtil.uniqueIdentifierName();\n+    sql = \"SELECT * FROM \" + output + \" WHERE ROWKEY = '\" + KEY + \"';\";\n+    List<KsqlEntity> res = makeAdminRequestWithResponse(\n+        REST_APP_0,\n+        \"CREATE TABLE \" + output + \" AS\"\n+            + \" SELECT COUNT(1) AS COUNT FROM \" + USERS_STREAM\n+            + \" GROUP BY \" + USER_PROVIDER.key() + \";\"\n+    );\n+    QUERY_ID = extractQueryId(res.get(0).toString());\n+    QUERY_ID = QUERY_ID.substring(0, QUERY_ID.length()-1);\n+    waitForTableRows();\n+    waitForStreamsMetadataToInitialize(\n+        REST_APP_0, ImmutableList.of(host0, host1, host2), QUERY_ID);\n+  }\n+\n+  @After\n+  public void cleanUp() {\n+    REST_APP_0.closePersistentQueries();\n+    REST_APP_0.dropSourcesExcept();\n+  }\n+\n+  @AfterClass\n+  public static void classTearDown() {\n+    TMP.delete();\n+  }\n+\n+  @Test\n+  public void shouldQueryActiveWhenActiveAliveQueryIssuedToStandby() {\n+    // Given:\n+    ClusterFormation clusterFormation = findClusterFormation(REST_APP_0, REST_APP_1, REST_APP_2);\n+    waitForClusterToBeDiscovered(clusterFormation.standBy.right, 3);\n+    sendHeartbeartsForWindowLength(\n+        clusterFormation.standBy.right, clusterFormation.active.left, 2000);\n+    waitForRemoteServerToChangeStatus(\n+        clusterFormation.standBy.right, clusterFormation.active.left, HighAvailabilityTestUtil::remoteServerIsUp);\n+\n+    // When:\n+    final List<StreamedRow> rows_0 = makePullQueryRequest(clusterFormation.standBy.right, sql);\n+\n+    // Then:\n+    assertThat(rows_0, hasSize(HEADER + 1));\n+    assertThat(rows_0.get(1).getRow(), is(not(Optional.empty())));\n+    assertThat(rows_0.get(1).getRow().get().values(), is(ImmutableList.of(KEY, BASE_TIME, 1)));\n+  }\n+\n+\n+  @Test\n+  public void shouldQueryActiveWhenActiveAliveStandbyDeadQueryIssuedToRouter() {\n+    // Given:\n+    ClusterFormation clusterFormation = findClusterFormation(REST_APP_0, REST_APP_1, REST_APP_2);\n+    waitForClusterToBeDiscovered(clusterFormation.router.right, 3);\n+    sendHeartbeartsForWindowLength(\n+        clusterFormation.router.right, clusterFormation.active.left, 2000);\n+    waitForRemoteServerToChangeStatus(\n+        clusterFormation.router.right,\n+        clusterFormation.active.left,\n+        HighAvailabilityTestUtil::remoteServerIsUp);\n+\n+    // When:\n+    final List<StreamedRow> rows_0 = makePullQueryRequest(clusterFormation.router.right, sql);\n+\n+    // Then:\n+    assertThat(rows_0, hasSize(HEADER + 1));\n+    assertThat(rows_0.get(1).getRow(), is(not(Optional.empty())));\n+    assertThat(rows_0.get(1).getRow().get().values(), is(ImmutableList.of(KEY, BASE_TIME, 1)));\n+  }\n+\n+  @Test\n+  public void shouldQueryStandbyWhenActiveDeadStandbyAliveQueryIssuedToRouter() {\n+    // Given:\n+    ClusterFormation clusterFormation = findClusterFormation(REST_APP_0, REST_APP_1, REST_APP_2);\n+    waitForClusterToBeDiscovered(clusterFormation.router.right, 3);\n+    sendHeartbeartsForWindowLength(\n+        clusterFormation.router.right, clusterFormation.standBy.left, 2000);\n+    waitForRemoteServerToChangeStatus(\n+        clusterFormation.router.right,\n+        clusterFormation.standBy.left,\n+        HighAvailabilityTestUtil::remoteServerIsUp);\n+\n+    // When:\n+    final List<StreamedRow> rows_0 = makePullQueryRequest(clusterFormation.router.right, sql);\n+\n+    // Then:\n+    assertThat(rows_0, hasSize(HEADER + 1));\n+    assertThat(rows_0.get(1).getRow(), is(not(Optional.empty())));\n+    assertThat(rows_0.get(1).getRow().get().values(), is(ImmutableList.of(KEY, BASE_TIME, 1)));\n+  }\n+\n+  private List<StreamedRow> makePullQueryRequest(\n+      final TestKsqlRestApp target,\n+      final String sql\n+  ) {\n+    return RestIntegrationTestUtil.makeQueryRequest(target, sql, Optional.empty());\n+  }\n+\n+  private static void makeAdminRequest(TestKsqlRestApp restApp, final String sql) {\n+    RestIntegrationTestUtil.makeKsqlRequest(restApp, sql, Optional.empty());\n+  }\n+\n+  private List<KsqlEntity> makeAdminRequestWithResponse(\n+      TestKsqlRestApp restApp, final String sql) {\n+    return RestIntegrationTestUtil.makeKsqlRequest(restApp, sql, Optional.empty());\n+  }\n+\n+  private ClusterFormation findClusterFormation(", "originalCommit": "37025d83ad0e92a0e42d6b18514428dd0c4c87ca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU3MjY5Mg==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375572692", "bodyText": "IIUC since there is just 1 partition, a query to standby returning should mean it was answered by active? Technically, it can be answered by standby locally as well right? Let's assume we introduce a bug that we query locally first always before proxying.. Would this test still pass then?", "author": "vinothchandar", "createdAt": "2020-02-05T23:49:08Z", "path": "ksql-rest-app/src/test/java/io/confluent/ksql/rest/integration/PullQueryRoutingFunctionalTest.java", "diffHunk": "@@ -0,0 +1,398 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.integration;\n+\n+import static io.confluent.ksql.rest.integration.HighAvailabilityTestUtil.sendHeartbeartsForWindowLength;\n+import static io.confluent.ksql.rest.integration.HighAvailabilityTestUtil.waitForClusterToBeDiscovered;\n+import static io.confluent.ksql.rest.integration.HighAvailabilityTestUtil.waitForRemoteServerToChangeStatus;\n+import static io.confluent.ksql.rest.integration.HighAvailabilityTestUtil.waitForStreamsMetadataToInitialize;\n+import static io.confluent.ksql.util.KsqlConfig.KSQL_STREAMS_PREFIX;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.not;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Iterables;\n+import io.confluent.common.utils.IntegrationTest;\n+import io.confluent.ksql.integration.IntegrationTestHarness;\n+import io.confluent.ksql.integration.Retry;\n+import io.confluent.ksql.name.ColumnName;\n+import io.confluent.ksql.rest.entity.ActiveStandbyEntity;\n+import io.confluent.ksql.rest.entity.ClusterStatusResponse;\n+import io.confluent.ksql.rest.entity.KsqlEntity;\n+import io.confluent.ksql.rest.entity.KsqlHostEntity;\n+import io.confluent.ksql.rest.entity.StreamedRow;\n+import io.confluent.ksql.rest.server.KsqlRestConfig;\n+import io.confluent.ksql.rest.server.TestKsqlRestApp;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.PhysicalSchema;\n+import io.confluent.ksql.schema.ksql.types.SqlTypes;\n+import io.confluent.ksql.serde.Format;\n+import io.confluent.ksql.serde.SerdeOption;\n+import io.confluent.ksql.test.util.KsqlIdentifierTestUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.Pair;\n+import io.confluent.ksql.util.UserDataProvider;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.regex.Pattern;\n+import kafka.zookeeper.ZooKeeperClientException;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.rules.ExpectedException;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.rules.Timeout;\n+\n+/**\n+ * Test to ensure pull queries route across multiple KSQL nodes correctly.\n+ *\n+ * <p>For tests on general syntax and handled see RestQueryTranslationTest's\n+ * materialized-aggregate-static-queries.json\n+ */\n+@SuppressWarnings(\"OptionalGetWithoutIsPresent\")\n+@Category({IntegrationTest.class})\n+public class PullQueryRoutingFunctionalTest {\n+\n+  private static final TemporaryFolder TMP = new TemporaryFolder();\n+\n+  static {\n+    try {\n+      TMP.create();\n+    } catch (final IOException e) {\n+      throw new AssertionError(\"Failed to init TMP\", e);\n+    }\n+  }\n+\n+  private static final Pattern QUERY_ID_PATTERN = Pattern.compile(\"with query ID: (\\\\S+)\");\n+  private static final KsqlHostEntity host0 = new KsqlHostEntity(\"localhost\", 8088);\n+  private static final KsqlHostEntity host1 = new KsqlHostEntity(\"localhost\",8089);\n+  private static final KsqlHostEntity host2 = new KsqlHostEntity(\"localhost\",8087);\n+  private static final String USER_TOPIC = \"user_topic\";\n+  private static final String USERS_STREAM = \"users\";\n+  private static final UserDataProvider USER_PROVIDER = new UserDataProvider();\n+  private static final Format VALUE_FORMAT = Format.JSON;\n+  private static final int HEADER = 1;\n+  private static final IntegrationTestHarness TEST_HARNESS = IntegrationTestHarness.build();\n+  private static final int BASE_TIME = 1_000_000;\n+  private final static String KEY = Iterables.get(USER_PROVIDER.data().keySet(), 0);\n+  private String output;\n+  private String QUERY_ID;\n+  private String sql;\n+\n+  private static final PhysicalSchema AGGREGATE_SCHEMA = PhysicalSchema.from(\n+      LogicalSchema.builder()\n+          .valueColumn(ColumnName.of(\"COUNT\"), SqlTypes.BIGINT)\n+          .build(),\n+      SerdeOption.none()\n+  );\n+\n+  private static final Map<String, Object> COMMON_CONFIG = ImmutableMap.<String, Object>builder()\n+      .put(KSQL_STREAMS_PREFIX + StreamsConfig.NUM_STREAM_THREADS_CONFIG, 1)\n+      .put(KsqlRestConfig.KSQL_HEARTBEAT_ENABLE_CONFIG, true)\n+      .put(KsqlRestConfig.KSQL_HEARTBEAT_SEND_INTERVAL_MS_CONFIG, 600000)\n+      .put(KsqlRestConfig.KSQL_HEARTBEAT_CHECK_INTERVAL_MS_CONFIG, 200)\n+      .put(KsqlRestConfig.KSQL_HEARTBEAT_DISCOVER_CLUSTER_MS_CONFIG, 2000)\n+      .put(KsqlConfig.KSQL_QUERY_PULL_ENABLE_STANDBY_READS, true)\n+      .put(KsqlConfig.KSQL_STREAMS_PREFIX + \"num.standby.replicas\", 1)\n+      .put(KsqlConfig.KSQL_SHUTDOWN_TIMEOUT_MS_CONFIG, 1000)\n+      .build();\n+\n+  @Rule\n+  public final TestKsqlRestApp REST_APP_0 = TestKsqlRestApp\n+      .builder(TEST_HARNESS::kafkaBootstrapServers)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.NUM_STREAM_THREADS_CONFIG, 1)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.STATE_DIR_CONFIG, getNewStateDir())\n+      .withProperty(KsqlRestConfig.LISTENERS_CONFIG, \"http://localhost:8088\")\n+      .withProperty(KsqlRestConfig.ADVERTISED_LISTENER_CONFIG, \"http://localhost:8088\")\n+      .withProperties(COMMON_CONFIG)\n+      .build();\n+\n+  @Rule\n+  public final TestKsqlRestApp REST_APP_1 = TestKsqlRestApp\n+      .builder(TEST_HARNESS::kafkaBootstrapServers)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.NUM_STREAM_THREADS_CONFIG, 1)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.STATE_DIR_CONFIG, getNewStateDir())\n+      .withProperty(KsqlRestConfig.LISTENERS_CONFIG, \"http://localhost:8089\")\n+      .withProperty(KsqlRestConfig.ADVERTISED_LISTENER_CONFIG, \"http://localhost:8089\")\n+      .withProperties(COMMON_CONFIG)\n+      .build();\n+\n+  @Rule\n+  public final TestKsqlRestApp REST_APP_2 = TestKsqlRestApp\n+      .builder(TEST_HARNESS::kafkaBootstrapServers)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.NUM_STREAM_THREADS_CONFIG, 1)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.STATE_DIR_CONFIG, getNewStateDir())\n+      .withProperty(KsqlRestConfig.LISTENERS_CONFIG, \"http://localhost:8087\")\n+      .withProperty(KsqlRestConfig.ADVERTISED_LISTENER_CONFIG, \"http://localhost:8087\")\n+      .withProperties(COMMON_CONFIG)\n+      .build();\n+\n+  @ClassRule\n+  public static final RuleChain CHAIN = RuleChain\n+      .outerRule(Retry.of(3, ZooKeeperClientException.class, 3, TimeUnit.SECONDS))\n+      .around(TEST_HARNESS);\n+\n+  @Rule\n+  public final Timeout timeout = Timeout.builder()\n+      .withTimeout(1, TimeUnit.MINUTES)\n+      .withLookingForStuckThread(true)\n+      .build();\n+\n+  @Rule\n+  public final ExpectedException expectedException = ExpectedException.none();\n+\n+  @BeforeClass\n+  public static void setUpClass() {\n+    //Create topic with 1 partition to control who is active and standby\n+    TEST_HARNESS.ensureTopics(1, USER_TOPIC);\n+\n+    final AtomicLong timestampSupplier = new AtomicLong(BASE_TIME);\n+\n+    TEST_HARNESS.produceRows(\n+        USER_TOPIC,\n+        USER_PROVIDER,\n+        VALUE_FORMAT,\n+        timestampSupplier::getAndIncrement\n+    );\n+  }\n+\n+  @Before\n+  public void setUp() {\n+    //Create stream\n+    makeAdminRequest(\n+        REST_APP_0,\n+        \"CREATE STREAM \" + USERS_STREAM\n+            + \" (\" + USER_PROVIDER.ksqlSchemaString() + \")\"\n+            + \" WITH (\"\n+            + \"   kafka_topic='\" + USER_TOPIC + \"', \"\n+            + \"   key='\" + USER_PROVIDER.key() + \"', \"\n+            + \"   value_format='\" + VALUE_FORMAT + \"'\"\n+            + \");\"\n+    );\n+    //Create table\n+    output = KsqlIdentifierTestUtil.uniqueIdentifierName();\n+    sql = \"SELECT * FROM \" + output + \" WHERE ROWKEY = '\" + KEY + \"';\";\n+    List<KsqlEntity> res = makeAdminRequestWithResponse(\n+        REST_APP_0,\n+        \"CREATE TABLE \" + output + \" AS\"\n+            + \" SELECT COUNT(1) AS COUNT FROM \" + USERS_STREAM\n+            + \" GROUP BY \" + USER_PROVIDER.key() + \";\"\n+    );\n+    QUERY_ID = extractQueryId(res.get(0).toString());\n+    QUERY_ID = QUERY_ID.substring(0, QUERY_ID.length()-1);\n+    waitForTableRows();\n+    waitForStreamsMetadataToInitialize(\n+        REST_APP_0, ImmutableList.of(host0, host1, host2), QUERY_ID);\n+  }\n+\n+  @After\n+  public void cleanUp() {\n+    REST_APP_0.closePersistentQueries();\n+    REST_APP_0.dropSourcesExcept();\n+  }\n+\n+  @AfterClass\n+  public static void classTearDown() {\n+    TMP.delete();\n+  }\n+\n+  @Test\n+  public void shouldQueryActiveWhenActiveAliveQueryIssuedToStandby() {\n+    // Given:\n+    ClusterFormation clusterFormation = findClusterFormation(REST_APP_0, REST_APP_1, REST_APP_2);\n+    waitForClusterToBeDiscovered(clusterFormation.standBy.right, 3);\n+    sendHeartbeartsForWindowLength(\n+        clusterFormation.standBy.right, clusterFormation.active.left, 2000);\n+    waitForRemoteServerToChangeStatus(\n+        clusterFormation.standBy.right, clusterFormation.active.left, HighAvailabilityTestUtil::remoteServerIsUp);\n+\n+    // When:\n+    final List<StreamedRow> rows_0 = makePullQueryRequest(clusterFormation.standBy.right, sql);", "originalCommit": "37025d83ad0e92a0e42d6b18514428dd0c4c87ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU4NTgxNQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375585815", "bodyText": "Correct, there is no way of checking which server serves a query. We could introduce this information in the response?", "author": "vpapavas", "createdAt": "2020-02-06T00:36:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU3MjY5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU4OTM1NQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375589355", "bodyText": "yes.. how much work would that be? This would also be incredibly useful debug information", "author": "vinothchandar", "createdAt": "2020-02-06T00:50:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU3MjY5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU5MDc5Mw==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375590793", "bodyText": "This might be a breaking change? Not sure if any applications use the response and expect it to be of certain format. How much work? Not sure. Don't know that code path", "author": "vpapavas", "createdAt": "2020-02-06T00:55:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU3MjY5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU5MzQ1Mg==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375593452", "bodyText": "I was saying this a few days ago.  For the lag sorting functionality where you expect that either of two standbys could answer a query (and they're both alive and not too behind), a functional test for it couldn't know which was the one that answered.  It would be impossible to test that it was the lower lag host.\nThis would be a nice thing to add at some point.", "author": "AlanConfluent", "createdAt": "2020-02-06T01:05:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU3MjY5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU5NjAwNw==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375596007", "bodyText": "Adding a new response header won't be a breaking change .. its actually a good backwards compatible change... But I can see there is some non-trivial work here.. So lets file few another follow up.. For now, the tests definitely cover the happy path and if we have other tests that guard against (KsLocatorTest may be already has them) the bug I used as an example, we might be fine.", "author": "vinothchandar", "createdAt": "2020-02-06T01:15:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU3MjY5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU5NzI3MQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375597271", "bodyText": "Tracked here: #4455", "author": "vpapavas", "createdAt": "2020-02-06T01:20:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU3MjY5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU3MjkwMA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375572900", "bodyText": "how are we sure that the standby is dead here?", "author": "vinothchandar", "createdAt": "2020-02-05T23:49:52Z", "path": "ksql-rest-app/src/test/java/io/confluent/ksql/rest/integration/PullQueryRoutingFunctionalTest.java", "diffHunk": "@@ -0,0 +1,398 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.integration;\n+\n+import static io.confluent.ksql.rest.integration.HighAvailabilityTestUtil.sendHeartbeartsForWindowLength;\n+import static io.confluent.ksql.rest.integration.HighAvailabilityTestUtil.waitForClusterToBeDiscovered;\n+import static io.confluent.ksql.rest.integration.HighAvailabilityTestUtil.waitForRemoteServerToChangeStatus;\n+import static io.confluent.ksql.rest.integration.HighAvailabilityTestUtil.waitForStreamsMetadataToInitialize;\n+import static io.confluent.ksql.util.KsqlConfig.KSQL_STREAMS_PREFIX;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.not;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Iterables;\n+import io.confluent.common.utils.IntegrationTest;\n+import io.confluent.ksql.integration.IntegrationTestHarness;\n+import io.confluent.ksql.integration.Retry;\n+import io.confluent.ksql.name.ColumnName;\n+import io.confluent.ksql.rest.entity.ActiveStandbyEntity;\n+import io.confluent.ksql.rest.entity.ClusterStatusResponse;\n+import io.confluent.ksql.rest.entity.KsqlEntity;\n+import io.confluent.ksql.rest.entity.KsqlHostEntity;\n+import io.confluent.ksql.rest.entity.StreamedRow;\n+import io.confluent.ksql.rest.server.KsqlRestConfig;\n+import io.confluent.ksql.rest.server.TestKsqlRestApp;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.PhysicalSchema;\n+import io.confluent.ksql.schema.ksql.types.SqlTypes;\n+import io.confluent.ksql.serde.Format;\n+import io.confluent.ksql.serde.SerdeOption;\n+import io.confluent.ksql.test.util.KsqlIdentifierTestUtil;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.Pair;\n+import io.confluent.ksql.util.UserDataProvider;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.regex.Pattern;\n+import kafka.zookeeper.ZooKeeperClientException;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.rules.ExpectedException;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.rules.Timeout;\n+\n+/**\n+ * Test to ensure pull queries route across multiple KSQL nodes correctly.\n+ *\n+ * <p>For tests on general syntax and handled see RestQueryTranslationTest's\n+ * materialized-aggregate-static-queries.json\n+ */\n+@SuppressWarnings(\"OptionalGetWithoutIsPresent\")\n+@Category({IntegrationTest.class})\n+public class PullQueryRoutingFunctionalTest {\n+\n+  private static final TemporaryFolder TMP = new TemporaryFolder();\n+\n+  static {\n+    try {\n+      TMP.create();\n+    } catch (final IOException e) {\n+      throw new AssertionError(\"Failed to init TMP\", e);\n+    }\n+  }\n+\n+  private static final Pattern QUERY_ID_PATTERN = Pattern.compile(\"with query ID: (\\\\S+)\");\n+  private static final KsqlHostEntity host0 = new KsqlHostEntity(\"localhost\", 8088);\n+  private static final KsqlHostEntity host1 = new KsqlHostEntity(\"localhost\",8089);\n+  private static final KsqlHostEntity host2 = new KsqlHostEntity(\"localhost\",8087);\n+  private static final String USER_TOPIC = \"user_topic\";\n+  private static final String USERS_STREAM = \"users\";\n+  private static final UserDataProvider USER_PROVIDER = new UserDataProvider();\n+  private static final Format VALUE_FORMAT = Format.JSON;\n+  private static final int HEADER = 1;\n+  private static final IntegrationTestHarness TEST_HARNESS = IntegrationTestHarness.build();\n+  private static final int BASE_TIME = 1_000_000;\n+  private final static String KEY = Iterables.get(USER_PROVIDER.data().keySet(), 0);\n+  private String output;\n+  private String QUERY_ID;\n+  private String sql;\n+\n+  private static final PhysicalSchema AGGREGATE_SCHEMA = PhysicalSchema.from(\n+      LogicalSchema.builder()\n+          .valueColumn(ColumnName.of(\"COUNT\"), SqlTypes.BIGINT)\n+          .build(),\n+      SerdeOption.none()\n+  );\n+\n+  private static final Map<String, Object> COMMON_CONFIG = ImmutableMap.<String, Object>builder()\n+      .put(KSQL_STREAMS_PREFIX + StreamsConfig.NUM_STREAM_THREADS_CONFIG, 1)\n+      .put(KsqlRestConfig.KSQL_HEARTBEAT_ENABLE_CONFIG, true)\n+      .put(KsqlRestConfig.KSQL_HEARTBEAT_SEND_INTERVAL_MS_CONFIG, 600000)\n+      .put(KsqlRestConfig.KSQL_HEARTBEAT_CHECK_INTERVAL_MS_CONFIG, 200)\n+      .put(KsqlRestConfig.KSQL_HEARTBEAT_DISCOVER_CLUSTER_MS_CONFIG, 2000)\n+      .put(KsqlConfig.KSQL_QUERY_PULL_ENABLE_STANDBY_READS, true)\n+      .put(KsqlConfig.KSQL_STREAMS_PREFIX + \"num.standby.replicas\", 1)\n+      .put(KsqlConfig.KSQL_SHUTDOWN_TIMEOUT_MS_CONFIG, 1000)\n+      .build();\n+\n+  @Rule\n+  public final TestKsqlRestApp REST_APP_0 = TestKsqlRestApp\n+      .builder(TEST_HARNESS::kafkaBootstrapServers)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.NUM_STREAM_THREADS_CONFIG, 1)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.STATE_DIR_CONFIG, getNewStateDir())\n+      .withProperty(KsqlRestConfig.LISTENERS_CONFIG, \"http://localhost:8088\")\n+      .withProperty(KsqlRestConfig.ADVERTISED_LISTENER_CONFIG, \"http://localhost:8088\")\n+      .withProperties(COMMON_CONFIG)\n+      .build();\n+\n+  @Rule\n+  public final TestKsqlRestApp REST_APP_1 = TestKsqlRestApp\n+      .builder(TEST_HARNESS::kafkaBootstrapServers)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.NUM_STREAM_THREADS_CONFIG, 1)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.STATE_DIR_CONFIG, getNewStateDir())\n+      .withProperty(KsqlRestConfig.LISTENERS_CONFIG, \"http://localhost:8089\")\n+      .withProperty(KsqlRestConfig.ADVERTISED_LISTENER_CONFIG, \"http://localhost:8089\")\n+      .withProperties(COMMON_CONFIG)\n+      .build();\n+\n+  @Rule\n+  public final TestKsqlRestApp REST_APP_2 = TestKsqlRestApp\n+      .builder(TEST_HARNESS::kafkaBootstrapServers)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.NUM_STREAM_THREADS_CONFIG, 1)\n+      .withProperty(KSQL_STREAMS_PREFIX + StreamsConfig.STATE_DIR_CONFIG, getNewStateDir())\n+      .withProperty(KsqlRestConfig.LISTENERS_CONFIG, \"http://localhost:8087\")\n+      .withProperty(KsqlRestConfig.ADVERTISED_LISTENER_CONFIG, \"http://localhost:8087\")\n+      .withProperties(COMMON_CONFIG)\n+      .build();\n+\n+  @ClassRule\n+  public static final RuleChain CHAIN = RuleChain\n+      .outerRule(Retry.of(3, ZooKeeperClientException.class, 3, TimeUnit.SECONDS))\n+      .around(TEST_HARNESS);\n+\n+  @Rule\n+  public final Timeout timeout = Timeout.builder()\n+      .withTimeout(1, TimeUnit.MINUTES)\n+      .withLookingForStuckThread(true)\n+      .build();\n+\n+  @Rule\n+  public final ExpectedException expectedException = ExpectedException.none();\n+\n+  @BeforeClass\n+  public static void setUpClass() {\n+    //Create topic with 1 partition to control who is active and standby\n+    TEST_HARNESS.ensureTopics(1, USER_TOPIC);\n+\n+    final AtomicLong timestampSupplier = new AtomicLong(BASE_TIME);\n+\n+    TEST_HARNESS.produceRows(\n+        USER_TOPIC,\n+        USER_PROVIDER,\n+        VALUE_FORMAT,\n+        timestampSupplier::getAndIncrement\n+    );\n+  }\n+\n+  @Before\n+  public void setUp() {\n+    //Create stream\n+    makeAdminRequest(\n+        REST_APP_0,\n+        \"CREATE STREAM \" + USERS_STREAM\n+            + \" (\" + USER_PROVIDER.ksqlSchemaString() + \")\"\n+            + \" WITH (\"\n+            + \"   kafka_topic='\" + USER_TOPIC + \"', \"\n+            + \"   key='\" + USER_PROVIDER.key() + \"', \"\n+            + \"   value_format='\" + VALUE_FORMAT + \"'\"\n+            + \");\"\n+    );\n+    //Create table\n+    output = KsqlIdentifierTestUtil.uniqueIdentifierName();\n+    sql = \"SELECT * FROM \" + output + \" WHERE ROWKEY = '\" + KEY + \"';\";\n+    List<KsqlEntity> res = makeAdminRequestWithResponse(\n+        REST_APP_0,\n+        \"CREATE TABLE \" + output + \" AS\"\n+            + \" SELECT COUNT(1) AS COUNT FROM \" + USERS_STREAM\n+            + \" GROUP BY \" + USER_PROVIDER.key() + \";\"\n+    );\n+    QUERY_ID = extractQueryId(res.get(0).toString());\n+    QUERY_ID = QUERY_ID.substring(0, QUERY_ID.length()-1);\n+    waitForTableRows();\n+    waitForStreamsMetadataToInitialize(\n+        REST_APP_0, ImmutableList.of(host0, host1, host2), QUERY_ID);\n+  }\n+\n+  @After\n+  public void cleanUp() {\n+    REST_APP_0.closePersistentQueries();\n+    REST_APP_0.dropSourcesExcept();\n+  }\n+\n+  @AfterClass\n+  public static void classTearDown() {\n+    TMP.delete();\n+  }\n+\n+  @Test\n+  public void shouldQueryActiveWhenActiveAliveQueryIssuedToStandby() {\n+    // Given:\n+    ClusterFormation clusterFormation = findClusterFormation(REST_APP_0, REST_APP_1, REST_APP_2);\n+    waitForClusterToBeDiscovered(clusterFormation.standBy.right, 3);\n+    sendHeartbeartsForWindowLength(\n+        clusterFormation.standBy.right, clusterFormation.active.left, 2000);\n+    waitForRemoteServerToChangeStatus(\n+        clusterFormation.standBy.right, clusterFormation.active.left, HighAvailabilityTestUtil::remoteServerIsUp);\n+\n+    // When:\n+    final List<StreamedRow> rows_0 = makePullQueryRequest(clusterFormation.standBy.right, sql);\n+\n+    // Then:\n+    assertThat(rows_0, hasSize(HEADER + 1));\n+    assertThat(rows_0.get(1).getRow(), is(not(Optional.empty())));\n+    assertThat(rows_0.get(1).getRow().get().values(), is(ImmutableList.of(KEY, BASE_TIME, 1)));\n+  }\n+\n+\n+  @Test\n+  public void shouldQueryActiveWhenActiveAliveStandbyDeadQueryIssuedToRouter() {\n+    // Given:\n+    ClusterFormation clusterFormation = findClusterFormation(REST_APP_0, REST_APP_1, REST_APP_2);\n+    waitForClusterToBeDiscovered(clusterFormation.router.right, 3);\n+    sendHeartbeartsForWindowLength(\n+        clusterFormation.router.right, clusterFormation.active.left, 2000);\n+    waitForRemoteServerToChangeStatus(\n+        clusterFormation.router.right,\n+        clusterFormation.active.left,\n+        HighAvailabilityTestUtil::remoteServerIsUp);\n+\n+    // When:\n+    final List<StreamedRow> rows_0 = makePullQueryRequest(clusterFormation.router.right, sql);", "originalCommit": "37025d83ad0e92a0e42d6b18514428dd0c4c87ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU3MzA2MQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375573061", "bodyText": "I see you are waiting till route and active or up.. but standby could also be up by then. no?", "author": "vinothchandar", "createdAt": "2020-02-05T23:50:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU3MjkwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU4NTQwMA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375585400", "bodyText": "Standby is not heartbeating, it cannot be up", "author": "vpapavas", "createdAt": "2020-02-06T00:35:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU3MjkwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU3MzI4OQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375573289", "bodyText": "remove?", "author": "vinothchandar", "createdAt": "2020-02-05T23:51:17Z", "path": "ksql-rest-app/src/test/java/io/confluent/ksql/rest/integration/RestIntegrationTestUtil.java", "diffHunk": "@@ -67,6 +67,7 @@ private RestIntegrationTestUtil() {\n \n       final RestResponse<KsqlEntityList> res = restClient.makeKsqlRequest(sql);\n \n+      System.out.println(\"------------> Create stream response = \" + res);", "originalCommit": "37025d83ad0e92a0e42d6b18514428dd0c4c87ca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU3NDIyOA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375574228", "bodyText": "I would have had a List passed in here and have the KsLocator make use of RoutingFilters. But okay with this as well, in the interest of moving forward", "author": "vinothchandar", "createdAt": "2020-02-05T23:54:33Z", "path": "ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/Locator.java", "diffHunk": "@@ -28,16 +30,18 @@\n public interface Locator {\n \n   /**\n-   * Locate which KSQL node stores the supplied {@code key}.\n+   * Locate which KSQL nodes store the supplied {@code key}.\n    *\n    * <p>Implementations are free to return {@link Optional#empty()} if the location is not known at\n    * this time.\n    *\n    * @param key the required key.\n-   * @return the owning node, if known.\n+   * @return the list of nodes, that can potentially serve the key.\n    */\n-  Optional<KsqlNode> locate(Struct key);\n-\n+  List<KsqlNode> locate(\n+      Struct key,\n+      RoutingFilter routingFilters", "originalCommit": "37025d83ad0e92a0e42d6b18514428dd0c4c87ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU4MzM3OQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375583379", "bodyText": "Look at Andy's comment here: #4398 (comment)", "author": "vpapavas", "createdAt": "2020-02-06T00:27:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU3NDIyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU4NDM5Nw==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375584397", "bodyText": "ha ha", "author": "vinothchandar", "createdAt": "2020-02-06T00:31:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU3NDIyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU3NDc0MQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375574741", "bodyText": "nit: better to avoid comments/variable naming that represents future work.. and have them just on the current PR ?", "author": "vinothchandar", "createdAt": "2020-02-05T23:56:26Z", "path": "ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsLocator.java", "diffHunk": "@@ -51,27 +62,59 @@\n   }\n \n   @Override\n-  @SuppressWarnings(\"deprecation\")\n-  public Optional<KsqlNode> locate(final Struct key) {\n-    final StreamsMetadata metadata = kafkaStreams\n-        .metadataForKey(stateStoreName, key, keySerializer);\n-\n-    if (metadata == StreamsMetadata.NOT_AVAILABLE) {\n-      return Optional.empty();\n+  public List<KsqlNode> locate(\n+      final Struct key,\n+      final RoutingFilter routingFilters\n+  ) {\n+    final KeyQueryMetadata metadata = kafkaStreams\n+        .queryMetadataForKey(stateStoreName, key, keySerializer);\n+\n+    // Fail fast if Streams not ready. Let client handle it\n+    if (metadata == KeyQueryMetadata.NOT_AVAILABLE) {\n+      LOG.debug(\"KeyQueryMetadata not available for state store {} and key {}\",\n+                stateStoreName, key);\n+      throw new MaterializationException(String.format(\n+          \"KeyQueryMetadata not available for state store %s and key %s\", stateStoreName, key));\n     }\n \n-    final HostInfo hostInfo = metadata.hostInfo();\n-    return Optional.of(asNode(hostInfo));\n+    final HostInfo activeHost = metadata.getActiveHost();\n+    final Set<HostInfo> standByHosts = metadata.getStandbyHosts();\n+    LOG.info(\"Before filtering: Active host {} , standby hosts {}\", activeHost, standByHosts);\n+\n+    final Stream<KsqlHost> active = Stream.of(asKsqlHost(activeHost));\n+    final Stream<KsqlHost> standby = standByHosts\n+        .stream()\n+        .map(this::asKsqlHost);\n+    final Stream<KsqlHost> hostStream = Stream.concat(active, standby);\n+\n+    // Filter out hosts based on liveness and lag filters.\n+    // The list is ordered by routing preference: active node is first, then standby nodes", "originalCommit": "37025d83ad0e92a0e42d6b18514428dd0c4c87ca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU3NTA0OQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375575049", "bodyText": "lets also move this to DEBUG or TRACE.. can you please make a pass and remove any INFO level log statements from the pull query execution path", "author": "vinothchandar", "createdAt": "2020-02-05T23:57:30Z", "path": "ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsLocator.java", "diffHunk": "@@ -51,27 +62,59 @@\n   }\n \n   @Override\n-  @SuppressWarnings(\"deprecation\")\n-  public Optional<KsqlNode> locate(final Struct key) {\n-    final StreamsMetadata metadata = kafkaStreams\n-        .metadataForKey(stateStoreName, key, keySerializer);\n-\n-    if (metadata == StreamsMetadata.NOT_AVAILABLE) {\n-      return Optional.empty();\n+  public List<KsqlNode> locate(\n+      final Struct key,\n+      final RoutingFilter routingFilters\n+  ) {\n+    final KeyQueryMetadata metadata = kafkaStreams\n+        .queryMetadataForKey(stateStoreName, key, keySerializer);\n+\n+    // Fail fast if Streams not ready. Let client handle it\n+    if (metadata == KeyQueryMetadata.NOT_AVAILABLE) {\n+      LOG.debug(\"KeyQueryMetadata not available for state store {} and key {}\",\n+                stateStoreName, key);\n+      throw new MaterializationException(String.format(\n+          \"KeyQueryMetadata not available for state store %s and key %s\", stateStoreName, key));\n     }\n \n-    final HostInfo hostInfo = metadata.hostInfo();\n-    return Optional.of(asNode(hostInfo));\n+    final HostInfo activeHost = metadata.getActiveHost();\n+    final Set<HostInfo> standByHosts = metadata.getStandbyHosts();\n+    LOG.info(\"Before filtering: Active host {} , standby hosts {}\", activeHost, standByHosts);\n+\n+    final Stream<KsqlHost> active = Stream.of(asKsqlHost(activeHost));\n+    final Stream<KsqlHost> standby = standByHosts\n+        .stream()\n+        .map(this::asKsqlHost);\n+    final Stream<KsqlHost> hostStream = Stream.concat(active, standby);\n+\n+    // Filter out hosts based on liveness and lag filters.\n+    // The list is ordered by routing preference: active node is first, then standby nodes\n+    // in order of increasing lag.\n+    // If heartbeat is not enabled, all hosts are considered alive.\n+    final List<KsqlNode> filteredHosts = hostStream\n+        .filter(hostInfo -> routingFilters.filter(\n+              activeHost, hostInfo, stateStoreName, metadata.getPartition()))\n+        .map(this::asNode)\n+        .collect(Collectors.toList());\n+\n+    LOG.info(\"Filtered and ordered hosts: {}\", filteredHosts);", "originalCommit": "37025d83ad0e92a0e42d6b18514428dd0c4c87ca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU3NTI2Mw==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375575263", "bodyText": "how is the KsqlRestConfig entry used", "author": "vinothchandar", "createdAt": "2020-02-05T23:58:11Z", "path": "ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsStateStore.java", "diffHunk": "@@ -72,9 +72,15 @@ LogicalSchema schema() {\n     awaitRunning();\n \n     try {\n-\n-      return kafkaStreams\n-          .store(StoreQueryParams.fromNameAndType(stateStoreName, queryableStoreType));\n+      if (ksqlConfig.getBoolean(KsqlConfig.KSQL_PULL_QUERIES_ENABLE_CONFIG)) {", "originalCommit": "37025d83ad0e92a0e42d6b18514428dd0c4c87ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU4MjI0Ng==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375582246", "bodyText": "I assume this is meant to be KSQL_QUERY_PULL_ENABLE_STANDBY_READS", "author": "AlanConfluent", "createdAt": "2020-02-06T00:23:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU3NTI2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU4MzcwMA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375583700", "bodyText": "It's not", "author": "vpapavas", "createdAt": "2020-02-06T00:28:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU3NTI2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU4Njg5Mg==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375586892", "bodyText": "Actually @AlanConfluent is right.. we should tie the standby routing to this, right?  not the pull query feature itself.", "author": "vinothchandar", "createdAt": "2020-02-06T00:40:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU3NTI2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU4OTcyNA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375589724", "bodyText": "Yes, the rebase overwrote my change. Fixed it now (again!)", "author": "vpapavas", "createdAt": "2020-02-06T00:51:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU3NTI2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU3NTM1Mg==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375575352", "bodyText": "move to an else block?", "author": "vinothchandar", "createdAt": "2020-02-05T23:58:31Z", "path": "ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsStateStore.java", "diffHunk": "@@ -72,9 +72,15 @@ LogicalSchema schema() {\n     awaitRunning();\n \n     try {\n-\n-      return kafkaStreams\n-          .store(StoreQueryParams.fromNameAndType(stateStoreName, queryableStoreType));\n+      if (ksqlConfig.getBoolean(KsqlConfig.KSQL_PULL_QUERIES_ENABLE_CONFIG)) {\n+        // True flag allows queries on standby and replica state stores\n+        return kafkaStreams.store(\n+            StoreQueryParams.fromNameAndType(stateStoreName, queryableStoreType)\n+                .enableStaleStores());\n+      }\n+      // False flag allows queries only on active state store\n+      return kafkaStreams.store(", "originalCommit": "37025d83ad0e92a0e42d6b18514428dd0c4c87ca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1349579b3b1941cd209d9e8e58dfd49e4934629c", "url": "https://github.com/confluentinc/ksql/commit/1349579b3b1941cd209d9e8e58dfd49e4934629c", "message": "applied vinoth's comments", "committedDate": "2020-02-06T01:20:40Z", "type": "commit"}, {"oid": "5344fe6cef9900e71e9f7cc4bdc22345ce62a054", "url": "https://github.com/confluentinc/ksql/commit/5344fe6cef9900e71e9f7cc4bdc22345ce62a054", "message": "fixed tests", "committedDate": "2020-02-06T02:48:58Z", "type": "commit"}, {"oid": "ed85a69ee3269eb2a88db6feabc7c2ba76e83a62", "url": "https://github.com/confluentinc/ksql/commit/ed85a69ee3269eb2a88db6feabc7c2ba76e83a62", "message": "added extra check in routing test", "committedDate": "2020-02-06T02:55:20Z", "type": "commit"}, {"oid": "78c6b2fb3db6b637564ea83c4001c853bfc53b3f", "url": "https://github.com/confluentinc/ksql/commit/78c6b2fb3db6b637564ea83c4001c853bfc53b3f", "message": "nit", "committedDate": "2020-02-06T03:01:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY1MDYxNg==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375650616", "bodyText": "remove or move to logger.debug??", "author": "vinothchandar", "createdAt": "2020-02-06T05:47:32Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java", "diffHunk": "@@ -175,70 +183,140 @@ public static TableRowsEntity execute(\n \n       final Struct rowKey = asKeyStruct(whereInfo.rowkey, query.getPhysicalSchema());\n \n-      final KsqlConfig ksqlConfig = statement.getConfig();\n-      final KsqlNode owner = getOwner(ksqlConfig, rowKey, mat);\n-      if (!owner.isLocal()) {\n-        return proxyTo(owner, statement, serviceContext);\n-      }\n+      final PullQueryContext pullQueryContext = new PullQueryContext(\n+          rowKey,\n+          mat,\n+          analysis,\n+          whereInfo,\n+          queryId,\n+          contextStacker);\n \n-      final Result result;\n-      if (whereInfo.windowStartBounds.isPresent()) {\n-        final Range<Instant> windowStart = whereInfo.windowStartBounds.get();\n+      return handlePullQuery(\n+          statement,\n+          executionContext,\n+          serviceContext,\n+          pullQueryContext\n+      );\n \n-        final List<? extends TableRow> rows = mat.windowed()\n-            .get(rowKey, windowStart);\n+    } catch (final Exception e) {\n+      throw new KsqlStatementException(\n+          e.getMessage() == null ? \"Server Error\" : e.getMessage(),\n+          statement.getStatementText(),\n+          e\n+      );\n+    }\n+  }\n \n-        result = new Result(mat.schema(), rows);\n-      } else {\n-        final List<? extends TableRow> rows = mat.nonWindowed()\n-            .get(rowKey)\n-            .map(ImmutableList::of)\n-            .orElse(ImmutableList.of());\n+  private TableRowsEntity handlePullQuery(\n+      final ConfiguredStatement<Query> statement,\n+      final KsqlExecutionContext executionContext,\n+      final ServiceContext serviceContext,\n+      final PullQueryContext pullQueryContext\n+  ) {\n+    // Get active and standby nodes for this key\n+    final Locator locator = pullQueryContext.mat.locator();\n+    final List<KsqlNode> filteredAndOrderedNodes = locator.locate(\n+        pullQueryContext.rowKey,\n+        routingFilters\n+    );\n \n-        result = new Result(mat.schema(), rows);\n-      }\n+    if (filteredAndOrderedNodes.isEmpty()) {\n+      throw new MaterializationException(\"All nodes are dead or exceed max allowed lag.\");\n+    }\n \n-      final LogicalSchema outputSchema;\n-      final List<List<?>> rows;\n-      if (isSelectStar(statement.getStatement().getSelect())) {\n-        outputSchema = TableRowsEntityFactory\n-            .buildSchema(result.schema, mat.windowType().isPresent());\n-        rows = TableRowsEntityFactory.createRows(result.rows);\n-      } else {\n-        outputSchema = selectOutputSchema(result, executionContext, analysis, mat.windowType());\n-\n-        rows = handleSelects(\n-            result,\n-            statement,\n-            executionContext,\n-            analysis,\n-            outputSchema,\n-            mat.windowType(),\n-            queryId,\n-            contextStacker\n-        );\n+    // Nodes are ordered by preference: active is first if alive then standby nodes in\n+    // increasing order of lag.\n+    for (KsqlNode node : filteredAndOrderedNodes) {\n+      try {\n+        return routeQuery(node, statement, executionContext, serviceContext, pullQueryContext);\n+      } catch (Exception t) {\n+        LOG.debug(\"Error routing query {} to host {} at timestamp {}\",\n+                 statement.getStatementText(), node, System.currentTimeMillis());\n       }\n+    }\n+    throw new MaterializationException(String.format(\n+        \"Unable to execute pull query: %s\", statement.getStatementText()));\n+  }\n \n-      return new TableRowsEntity(\n-          statement.getStatementText(),\n-          queryId,\n+  private TableRowsEntity routeQuery(\n+      final KsqlNode node,\n+      final ConfiguredStatement<Query> statement,\n+      final KsqlExecutionContext executionContext,\n+      final ServiceContext serviceContext,\n+      final PullQueryContext pullQueryContext\n+  ) {\n+\n+    if (node.isLocal()) {\n+      LOG.debug(\"Query {} executed locally at host {} at timestamp {}.\",\n+               statement.getStatementText(), node.location(), System.currentTimeMillis());\n+      return queryRowsLocally(\n+          statement,\n+          executionContext,\n+          pullQueryContext);\n+    } else {\n+      LOG.debug(\"Query {} routed to host {} at timestamp {}.\",\n+                statement.getStatementText(), node.location(), System.currentTimeMillis());\n+      return forwardTo(node, statement, serviceContext);\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  TableRowsEntity queryRowsLocally(\n+      final ConfiguredStatement<Query> statement,\n+      final KsqlExecutionContext executionContext,\n+      final PullQueryContext pullQueryContext\n+  ) {\n+    final Result result;\n+    if (pullQueryContext.whereInfo.windowStartBounds.isPresent()) {\n+      final Range<Instant> windowStart = pullQueryContext.whereInfo.windowStartBounds.get();\n+\n+      final List<? extends TableRow> rows = pullQueryContext.mat.windowed()\n+          .get(pullQueryContext.rowKey, windowStart);\n+\n+      result = new Result(pullQueryContext.mat.schema(), rows);\n+    } else {\n+      final List<? extends TableRow> rows = pullQueryContext.mat.nonWindowed()\n+          .get(pullQueryContext.rowKey)\n+          .map(ImmutableList::of)\n+          .orElse(ImmutableList.of());\n+\n+      result = new Result(pullQueryContext.mat.schema(), rows);\n+    }\n+\n+    final LogicalSchema outputSchema;\n+    final List<List<?>> rows;\n+    if (isSelectStar(statement.getStatement().getSelect())) {\n+      outputSchema = TableRowsEntityFactory.buildSchema(\n+          result.schema, pullQueryContext.mat.windowType().isPresent());\n+      rows = TableRowsEntityFactory.createRows(result.rows);\n+    } else {\n+      outputSchema = selectOutputSchema(\n+          result, executionContext, pullQueryContext.analysis, pullQueryContext.mat.windowType());\n+      rows = handleSelects(\n+          result,\n+          statement,\n+          executionContext,\n+          pullQueryContext.analysis,\n           outputSchema,\n-          rows\n-      );\n-    } catch (final Exception e) {\n-      throw new KsqlStatementException(\n-          e.getMessage() == null ? \"Server Error\" : e.getMessage(),\n-          statement.getStatementText(),\n-          e\n+          pullQueryContext.mat.windowType(),\n+          pullQueryContext.queryId,\n+          pullQueryContext.contextStacker\n       );\n     }\n+    System.out.println(\"Result of pull query = \" + rows);", "originalCommit": "78c6b2fb3db6b637564ea83c4001c853bfc53b3f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY1NDgxNw==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375654817", "bodyText": "Sorry, intellij indexing doesn't work. I have searched to remove all System.out but nothing came up", "author": "vpapavas", "createdAt": "2020-02-06T06:07:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY1MDYxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY1MTYyMQ==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375651621", "bodyText": "can we use Objects.equals instead to be safe on null handling", "author": "vinothchandar", "createdAt": "2020-02-06T05:52:26Z", "path": "ksql-rest-model/src/main/java/io/confluent/ksql/rest/entity/ActiveStandbyEntity.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.entity;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.errorprone.annotations.Immutable;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+@Immutable\n+@JsonIgnoreProperties(ignoreUnknown = true)\n+public class ActiveStandbyEntity {\n+\n+  private final ImmutableSet<String> activeStores;\n+  private final ImmutableSet<TopicPartitionEntity> activePartitions;\n+  private final ImmutableSet<String> standByStores;\n+  private final ImmutableSet<TopicPartitionEntity> standByPartitions;\n+\n+  @JsonCreator\n+  public ActiveStandbyEntity(\n+      @JsonProperty(\"activeStores\") final Set<String> activeStores,\n+      @JsonProperty(\"activePartitions\") final Set<TopicPartitionEntity> activePartitions,\n+      @JsonProperty(\"standByStores\") final Set<String> standByStores,\n+      @JsonProperty(\"standByPartitions\") final Set<TopicPartitionEntity> standByPartitions\n+  ) {\n+    this.activeStores = ImmutableSet.copyOf(requireNonNull(activeStores));\n+    this.activePartitions = ImmutableSet.copyOf(requireNonNull(activePartitions));\n+    this.standByStores = ImmutableSet.copyOf(requireNonNull(standByStores));\n+    this.standByPartitions = ImmutableSet.copyOf(requireNonNull(standByPartitions));\n+  }\n+\n+  public Set<String> getActiveStores() {\n+    return activeStores;\n+  }\n+\n+  public Set<String> getStandByStores() {\n+    return standByStores;\n+  }\n+\n+  public Set<TopicPartitionEntity> getActivePartitions() {\n+    return activePartitions;\n+  }\n+\n+  public Set<TopicPartitionEntity> getStandByPartitions() {\n+    return standByPartitions;\n+  }\n+\n+  @Override\n+  public boolean equals(final Object o) {\n+    if (this == o) {\n+      return true;\n+    }\n+\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+\n+    final ActiveStandbyEntity that = (ActiveStandbyEntity) o;\n+    return activeStores.equals(that.activeStores)", "originalCommit": "78c6b2fb3db6b637564ea83c4001c853bfc53b3f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY1NTc1NA==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375655754", "bodyText": "Done", "author": "vpapavas", "createdAt": "2020-02-06T06:11:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY1MTYyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY1MTk5Mw==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375651993", "bodyText": "do we have a queryId to log here as well? it might help trace a query through the routing.. if we can include it for all log statements", "author": "vinothchandar", "createdAt": "2020-02-06T05:54:18Z", "path": "ksql-streams/src/main/java/io/confluent/ksql/execution/streams/materialization/ks/KsLocator.java", "diffHunk": "@@ -51,27 +62,58 @@\n   }\n \n   @Override\n-  @SuppressWarnings(\"deprecation\")\n-  public Optional<KsqlNode> locate(final Struct key) {\n-    final StreamsMetadata metadata = kafkaStreams\n-        .metadataForKey(stateStoreName, key, keySerializer);\n-\n-    if (metadata == StreamsMetadata.NOT_AVAILABLE) {\n-      return Optional.empty();\n+  public List<KsqlNode> locate(\n+      final Struct key,\n+      final RoutingFilter routingFilters\n+  ) {\n+    final KeyQueryMetadata metadata = kafkaStreams\n+        .queryMetadataForKey(stateStoreName, key, keySerializer);\n+\n+    // Fail fast if Streams not ready. Let client handle it\n+    if (metadata == KeyQueryMetadata.NOT_AVAILABLE) {\n+      LOG.debug(\"KeyQueryMetadata not available for state store {} and key {}\",\n+                stateStoreName, key);\n+      throw new MaterializationException(String.format(\n+          \"KeyQueryMetadata not available for state store %s and key %s\", stateStoreName, key));\n     }\n \n-    final HostInfo hostInfo = metadata.hostInfo();\n-    return Optional.of(asNode(hostInfo));\n+    final HostInfo activeHost = metadata.getActiveHost();\n+    final Set<HostInfo> standByHosts = metadata.getStandbyHosts();\n+    LOG.debug(\"Before filtering: Active host {} , standby hosts {}\", activeHost, standByHosts);", "originalCommit": "78c6b2fb3db6b637564ea83c4001c853bfc53b3f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY1NTcyNg==", "url": "https://github.com/confluentinc/ksql/pull/4398#discussion_r375655726", "bodyText": "No, we don't have access to the query, only KafkaStreams", "author": "vpapavas", "createdAt": "2020-02-06T06:11:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTY1MTk5Mw=="}], "type": "inlineReview"}, {"oid": "053b99a134437e4665748bf3166c17288d6d93d3", "url": "https://github.com/confluentinc/ksql/commit/053b99a134437e4665748bf3166c17288d6d93d3", "message": "last comments", "committedDate": "2020-02-06T06:12:24Z", "type": "commit"}]}