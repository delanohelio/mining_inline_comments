{"pr_number": 6018, "pr_title": "fix: set restarted query as healthy during a time threshold", "pr_createdAt": "2020-08-13T18:22:40Z", "pr_url": "https://github.com/confluentinc/ksql/pull/6018", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE2NTYyOQ==", "url": "https://github.com/confluentinc/ksql/pull/6018#discussion_r470165629", "bodyText": "yay! I hate .forEach with a large nested lambda \ud83d\ude02", "author": "agavra", "createdAt": "2020-08-13T18:36:57Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/QueryMonitor.java", "diffHunk": "@@ -120,32 +123,52 @@ private void maybeRestartQueries() {\n     final long now = ticker.read();\n \n     // Restart queries that has passed the waiting timeout\n-    final List<QueryId> deleteRetryEvents = new ArrayList<>();\n-    queriesRetries.entrySet().stream()\n-        .forEach(mapEntry -> {\n-          final QueryId queryId = mapEntry.getKey();\n-          final RetryEvent retryEvent = mapEntry.getValue();\n-          final Optional<PersistentQueryMetadata> query = ksqlEngine.getPersistentQuery(queryId);\n-\n-          // Query was terminated manually if no present\n-          if (!query.isPresent()) {\n-            deleteRetryEvents.add(queryId);\n-          } else if (query.get().isError() && now > retryEvent.nextRestartTimeMs()) {\n-            // Retry again if it's still in ERROR state\n-            retryEvent.restart();\n-          } else if (now > retryEvent.queryHealthyTime()) {\n-            // Clean the errors queue & delete the query from future retries now the query is\n-            // healthy\n-            query.ifPresent(QueryMetadata::clearErrors);\n-            deleteRetryEvents.add(queryId);\n-          }\n-        });\n-\n-    deleteRetryEvents.stream().forEach(queriesRetries::remove);\n+    final Iterator<Map.Entry<QueryId, RetryEvent>> it = queriesRetries.entrySet().iterator();\n+    while (it.hasNext()) {", "originalCommit": "625ff195e441d52081188b9c15d8cf394d5b9a0f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE2NzY0Nw==", "url": "https://github.com/confluentinc/ksql/pull/6018#discussion_r470167647", "bodyText": "I don't think we should include CREATED in this - to make sure that the backoff loop doesn't get reset if the state is in CREATED as it'll probably soon transfer to RUNNING", "author": "agavra", "createdAt": "2020-08-13T18:40:28Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/QueryMonitor.java", "diffHunk": "@@ -120,32 +123,52 @@ private void maybeRestartQueries() {\n     final long now = ticker.read();\n \n     // Restart queries that has passed the waiting timeout\n-    final List<QueryId> deleteRetryEvents = new ArrayList<>();\n-    queriesRetries.entrySet().stream()\n-        .forEach(mapEntry -> {\n-          final QueryId queryId = mapEntry.getKey();\n-          final RetryEvent retryEvent = mapEntry.getValue();\n-          final Optional<PersistentQueryMetadata> query = ksqlEngine.getPersistentQuery(queryId);\n-\n-          // Query was terminated manually if no present\n-          if (!query.isPresent()) {\n-            deleteRetryEvents.add(queryId);\n-          } else if (query.get().isError() && now > retryEvent.nextRestartTimeMs()) {\n-            // Retry again if it's still in ERROR state\n-            retryEvent.restart();\n-          } else if (now > retryEvent.queryHealthyTime()) {\n-            // Clean the errors queue & delete the query from future retries now the query is\n-            // healthy\n-            query.ifPresent(QueryMetadata::clearErrors);\n-            deleteRetryEvents.add(queryId);\n-          }\n-        });\n-\n-    deleteRetryEvents.stream().forEach(queriesRetries::remove);\n+    final Iterator<Map.Entry<QueryId, RetryEvent>> it = queriesRetries.entrySet().iterator();\n+    while (it.hasNext()) {\n+      final Map.Entry<QueryId, RetryEvent> mapEntry = it.next();\n+\n+      final QueryId queryId = mapEntry.getKey();\n+      final RetryEvent retryEvent = mapEntry.getValue();\n+      final Optional<PersistentQueryMetadata> query = ksqlEngine.getPersistentQuery(queryId);\n+\n+      // Query was terminated manually if no present\n+      if (!query.isPresent()) {\n+        it.remove();\n+      } else {\n+        final PersistentQueryMetadata queryMetadata = query.get();\n+        switch (queryMetadata.getState()) {\n+          case ERROR:\n+            if (now >= retryEvent.nextRestartTimeMs()) {\n+              retryEvent.restart(queryMetadata);\n+            }\n+            break;\n+          case RUNNING:\n+          case REBALANCING:\n+            if (now >= retryEvent.queryHealthyTime()) {\n+              // Clean the errors queue & delete the query from future retries now the query is\n+              // healthy and has been running after some threshold time\n+              query.ifPresent(QueryMetadata::clearErrors);\n+              it.remove();\n+            }\n+            break;\n+          default:\n+            // Stop attempting restarts for any other status. Either the query is pending\n+            // a shutdown or other status that do not track.\n+            it.remove();", "originalCommit": "625ff195e441d52081188b9c15d8cf394d5b9a0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTEwMDAyOA==", "url": "https://github.com/confluentinc/ksql/pull/6018#discussion_r471100028", "bodyText": "Done", "author": "spena", "createdAt": "2020-08-16T11:17:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE2NzY0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE2ODYyMg==", "url": "https://github.com/confluentinc/ksql/pull/6018#discussion_r470168622", "bodyText": "nit: we know it's present, can we just queryMetadata.clearErrors()?", "author": "agavra", "createdAt": "2020-08-13T18:41:58Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/QueryMonitor.java", "diffHunk": "@@ -120,32 +123,52 @@ private void maybeRestartQueries() {\n     final long now = ticker.read();\n \n     // Restart queries that has passed the waiting timeout\n-    final List<QueryId> deleteRetryEvents = new ArrayList<>();\n-    queriesRetries.entrySet().stream()\n-        .forEach(mapEntry -> {\n-          final QueryId queryId = mapEntry.getKey();\n-          final RetryEvent retryEvent = mapEntry.getValue();\n-          final Optional<PersistentQueryMetadata> query = ksqlEngine.getPersistentQuery(queryId);\n-\n-          // Query was terminated manually if no present\n-          if (!query.isPresent()) {\n-            deleteRetryEvents.add(queryId);\n-          } else if (query.get().isError() && now > retryEvent.nextRestartTimeMs()) {\n-            // Retry again if it's still in ERROR state\n-            retryEvent.restart();\n-          } else if (now > retryEvent.queryHealthyTime()) {\n-            // Clean the errors queue & delete the query from future retries now the query is\n-            // healthy\n-            query.ifPresent(QueryMetadata::clearErrors);\n-            deleteRetryEvents.add(queryId);\n-          }\n-        });\n-\n-    deleteRetryEvents.stream().forEach(queriesRetries::remove);\n+    final Iterator<Map.Entry<QueryId, RetryEvent>> it = queriesRetries.entrySet().iterator();\n+    while (it.hasNext()) {\n+      final Map.Entry<QueryId, RetryEvent> mapEntry = it.next();\n+\n+      final QueryId queryId = mapEntry.getKey();\n+      final RetryEvent retryEvent = mapEntry.getValue();\n+      final Optional<PersistentQueryMetadata> query = ksqlEngine.getPersistentQuery(queryId);\n+\n+      // Query was terminated manually if no present\n+      if (!query.isPresent()) {\n+        it.remove();\n+      } else {\n+        final PersistentQueryMetadata queryMetadata = query.get();\n+        switch (queryMetadata.getState()) {\n+          case ERROR:\n+            if (now >= retryEvent.nextRestartTimeMs()) {\n+              retryEvent.restart(queryMetadata);\n+            }\n+            break;\n+          case RUNNING:\n+          case REBALANCING:\n+            if (now >= retryEvent.queryHealthyTime()) {\n+              // Clean the errors queue & delete the query from future retries now the query is\n+              // healthy and has been running after some threshold time\n+              query.ifPresent(QueryMetadata::clearErrors);", "originalCommit": "625ff195e441d52081188b9c15d8cf394d5b9a0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTEwMDAzNA==", "url": "https://github.com/confluentinc/ksql/pull/6018#discussion_r471100034", "bodyText": "Done", "author": "spena", "createdAt": "2020-08-16T11:17:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE2ODYyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE3MDcwOA==", "url": "https://github.com/confluentinc/ksql/pull/6018#discussion_r470170708", "bodyText": "this seems a little high - can we set it to 2700 instead? (3x the max query backoff)", "author": "agavra", "createdAt": "2020-08-13T18:45:35Z", "path": "ksqldb-common/src/main/java/io/confluent/ksql/util/KsqlConfig.java", "diffHunk": "@@ -340,6 +340,12 @@\n       + \"error messages (per query) to hold in the internal query errors queue and display\"\n       + \"in the query description when executing the `EXPLAIN <query>` command.\";\n \n+  public static final String KSQL_QUERY_STATUS_RUNNING_THRESHOLD_SECS =\n+      \"ksql.query.status.running.threshold.seconds\";\n+  private static final Integer KSQL_QUERY_STATUS_RUNNING_THRESHOLD_SECS_DEFAULT = 18000;", "originalCommit": "625ff195e441d52081188b9c15d8cf394d5b9a0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTEwMDE1Nw==", "url": "https://github.com/confluentinc/ksql/pull/6018#discussion_r471100157", "bodyText": "I miss typed the value here. It should be 300 (5-min) which is mentioned in Rohan's design.", "author": "spena", "createdAt": "2020-08-16T11:18:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE3MDcwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE3MzQ5NA==", "url": "https://github.com/confluentinc/ksql/pull/6018#discussion_r470173494", "bodyText": "tracking this way is OK, but I think it would be better if we exposed how long the query was actually running from the query metadata. That way, we can know that what we're measuring is exactly query uptime, and not just time since the last attempted restart.\nWe can implement this using a KafkaStreams.StateListener to start the timer when transitioning to RUNNING for the first time.", "author": "agavra", "createdAt": "2020-08-13T18:50:39Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/engine/QueryMonitor.java", "diffHunk": "@@ -168,31 +191,35 @@ public void run() {\n   }\n \n   static class RetryEvent {\n-    private final KsqlEngine ksqlEngine;\n     private final QueryId queryId;\n     private final Ticker ticker;\n+    private final long statusRunningThresholdMs;\n \n     private int numRetries = 0;\n     private long waitingTimeMs;\n     private long expiryTimeMs;\n     private long retryBackoffMaxMs;\n     private long baseWaitingTimeMs;\n+    private long healthyTimeMs;\n \n     RetryEvent(\n-        final KsqlEngine ksqlEngine,\n         final QueryId queryId,\n         final long baseWaitingTimeMs,\n         final long retryBackoffMaxMs,\n+        final long statusRunningThresholdMs,\n         final Ticker ticker\n     ) {\n-      this.ksqlEngine = ksqlEngine;\n       this.queryId = queryId;\n       this.ticker = ticker;\n+      this.statusRunningThresholdMs = statusRunningThresholdMs;\n+\n+      final long now = ticker.read();\n \n       this.baseWaitingTimeMs = baseWaitingTimeMs;\n       this.waitingTimeMs = baseWaitingTimeMs;\n-      this.expiryTimeMs = ticker.read() + baseWaitingTimeMs;\n       this.retryBackoffMaxMs = retryBackoffMaxMs;\n+      this.expiryTimeMs = now + baseWaitingTimeMs;\n+      this.healthyTimeMs = now + statusRunningThresholdMs;", "originalCommit": "625ff195e441d52081188b9c15d8cf394d5b9a0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTEwMDMzOQ==", "url": "https://github.com/confluentinc/ksql/pull/6018#discussion_r471100339", "bodyText": "Done. I added this change in the last commit. The QueryStateListener tracks the up time when the state transitions to RUNNING or REBALANCING. This up time is obtained in the QueryMonitor through the QueryMetadata.uptime() call. Zero uptime is returned when the query is not running or rebalancing.", "author": "spena", "createdAt": "2020-08-16T11:20:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE3MzQ5NA=="}], "type": "inlineReview"}, {"oid": "3c97bdca81b525f99e6fd230602f17300dd13c72", "url": "https://github.com/confluentinc/ksql/commit/3c97bdca81b525f99e6fd230602f17300dd13c72", "message": "fix: set restarted query as healthy during a time threshold", "committedDate": "2020-08-16T11:15:52Z", "type": "commit"}, {"oid": "86e4cf60183e01e4c80f043421fc972842b85aaf", "url": "https://github.com/confluentinc/ksql/commit/86e4cf60183e01e4c80f043421fc972842b85aaf", "message": "fix: address Almog'ts feedback", "committedDate": "2020-08-16T11:15:52Z", "type": "commit"}, {"oid": "f4d44185d6cca5af04b95b5b6cda31e9c4e99468", "url": "https://github.com/confluentinc/ksql/commit/f4d44185d6cca5af04b95b5b6cda31e9c4e99468", "message": "fix: set uptime on QueryMetadata using QueryStateListener", "committedDate": "2020-08-16T11:15:52Z", "type": "commit"}, {"oid": "f4d44185d6cca5af04b95b5b6cda31e9c4e99468", "url": "https://github.com/confluentinc/ksql/commit/f4d44185d6cca5af04b95b5b6cda31e9c4e99468", "message": "fix: set uptime on QueryMetadata using QueryStateListener", "committedDate": "2020-08-16T11:15:52Z", "type": "forcePushed"}]}