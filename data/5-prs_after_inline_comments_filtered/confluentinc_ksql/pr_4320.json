{"pr_number": 4320, "pr_title": "feat: Bare bones API server", "pr_createdAt": "2020-01-15T15:04:36Z", "pr_url": "https://github.com/confluentinc/ksql/pull/4320", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA3OTUyNg==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r367079526", "bodyText": "Could we consider camelCase instead of kebab-case for the metadata object keys?\nI have the JS client in mind, where it would be more natural to operate on objects with the former.\nconst { columnNames, columnTypes } = queryMetadata;\n// vs\nconst columnNames = queryMetadata[\"column-names\"];\nconst columnTypes = queryMetadata[\"column-types\"];", "author": "colinhicks", "createdAt": "2020-01-15T20:02:26Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/ServerVerticle.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Copyright 2019 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_MISSING_PARAM;\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_UNKNOWN_QUERY_ID;\n+import static io.confluent.ksql.api.server.ServerUtils.handleError;\n+\n+import io.confluent.ksql.api.impl.Utils;\n+import io.confluent.ksql.api.spi.Endpoints;\n+import io.confluent.ksql.api.spi.QueryPublisher;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.core.Promise;\n+import io.vertx.core.http.HttpConnection;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.core.http.HttpServer;\n+import io.vertx.core.http.HttpServerOptions;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.core.parsetools.RecordParser;\n+import io.vertx.ext.web.Router;\n+import io.vertx.ext.web.RoutingContext;\n+import io.vertx.ext.web.handler.BodyHandler;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The server deploys multiple server verticles. This is where the HTTP2 requests are handled. The\n+ * actual implementation of the endpoints is provided by an implementation of {@code Endpoints}.\n+ */\n+public class ServerVerticle extends AbstractVerticle {\n+\n+  private static final Logger log = LoggerFactory.getLogger(ServerVerticle.class);\n+\n+  private final Endpoints endpoints;\n+  private final HttpServerOptions httpServerOptions;\n+  private final Server server;\n+  private final Map<HttpConnection, ConnectionQueries> connectionsMap = new HashMap<>();\n+  private HttpServer httpServer;\n+\n+  public ServerVerticle(final Endpoints endpoints, final HttpServerOptions httpServerOptions,\n+      final Server server) {\n+    this.endpoints = endpoints;\n+    this.httpServerOptions = httpServerOptions;\n+    this.server = server;\n+  }\n+\n+  @Override\n+  public void start(final Promise<Void> startPromise) {\n+    httpServer = vertx.createHttpServer(httpServerOptions).requestHandler(setupRouter());\n+    httpServer.exceptionHandler(ServerUtils::handleException);\n+    Future<HttpServer> listenFuture = Promise.<HttpServer>promise().future();\n+    Utils.connectPromise(listenFuture.map(s -> null), startPromise);\n+    httpServer.listen(listenFuture);\n+    vertx.getOrCreateContext().exceptionHandler(ServerUtils::handleException);\n+  }\n+\n+  @Override\n+  public void stop(final Promise<Void> stopPromise) {\n+    if (httpServer == null) {\n+      stopPromise.complete();\n+    } else {\n+      httpServer.close(stopPromise.future());\n+    }\n+  }\n+\n+  private Router setupRouter() {\n+    Router router = Router.router(vertx);\n+    router.route(HttpMethod.POST, \"/query-stream\").handler(BodyHandler.create())\n+        .handler(this::handleQueryStream);\n+    router.route(HttpMethod.POST, \"/inserts-stream\").handler(this::handleInsertsStream);\n+    router.route(HttpMethod.POST, \"/close-query\").handler(BodyHandler.create())\n+        .handler(this::handleCloseQuery);\n+    return router;\n+  }\n+\n+  private void handleInsertsStream(final RoutingContext routingContext) {\n+    RecordParser recordParser = RecordParser\n+        .newDelimited(\"\\n\", new InsertsBodyParser(endpoints, routingContext)::handleBodyBuffer);\n+    routingContext.request()\n+        .handler(recordParser);\n+  }\n+\n+  private void handleQueryStream(final RoutingContext routingContext) {\n+    HttpConnection conn = routingContext.request().connection();\n+    ConnectionQueries connectionQueries = connectionsMap.get(conn);\n+    if (connectionQueries == null) {\n+      connectionQueries = new ConnectionQueries(conn);\n+      connectionsMap.put(conn, connectionQueries);\n+      conn.closeHandler(connectionQueries);\n+      server.registerQueryConnection(conn);\n+    }\n+    JsonObject requestBody = routingContext.getBodyAsJson();\n+    String sql = requestBody.getString(\"sql\");\n+    if (sql == null) {\n+      handleError(routingContext.response(), 400, ERROR_CODE_MISSING_PARAM, \"No sql in arguments\");\n+      return;\n+    }\n+    Boolean push = requestBody.getBoolean(\"push\");\n+    if (push == null) {\n+      handleError(routingContext.response(), 400, ERROR_CODE_MISSING_PARAM, \"No push in arguments\");\n+      return;\n+    }\n+    JsonObject properties = requestBody.getJsonObject(\"properties\");\n+    QueryPublisher queryPublisher = endpoints.createQueryPublisher(sql, push, properties);\n+    QuerySubscriber querySubscriber = new QuerySubscriber(routingContext.response());\n+\n+    String queryID = server.registerQuery(querySubscriber);\n+    connectionQueries.addQuery(queryID);\n+    JsonObject metadata = new JsonObject();\n+    metadata.put(\"column-names\", queryPublisher.getColumnNames());\n+    metadata.put(\"column-types\", queryPublisher.getColumnTypes());\n+    metadata.put(\"query-id\", queryID);\n+    if (!push) {\n+      metadata.put(\"row-count\", queryPublisher.getRowCount());", "originalCommit": "c40735e2be6944f3ccbb84adf34c0b4c64abd139", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIyNzUwNA==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r367227504", "bodyText": "+1 on camelCase - would be friendlier for JS.", "author": "purplefox", "createdAt": "2020-01-16T04:37:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA3OTUyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQwMjU0Mg==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r367402542", "bodyText": "nit: null check params.", "author": "big-andy-coates", "createdAt": "2020-01-16T12:57:55Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/AcksSubscriber.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_INTERNAL_ERROR;\n+\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.HttpServerResponse;\n+import io.vertx.core.json.JsonObject;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * As the stream of inserts is processed by the back-end, it communicates success (or failure) of\n+ * each insert by sending a stream of acks back in the other direction. This class is the subscriber\n+ * which subscribes to that stream of acks and sends them back to the client. It's a reactive\n+ * streams subscriber so implements back pressure.\n+ */\n+public class AcksSubscriber implements Subscriber<Void> {\n+\n+  private static final Logger log = LoggerFactory.getLogger(AcksSubscriber.class);\n+  private static final int BATCH_SIZE = 4;\n+  private static final Buffer ACK_RESPONSE_LINE = new JsonObject().put(\"status\", \"ok\").toBuffer()\n+      .appendString(\"\\n\");\n+\n+  private final HttpServerResponse response;\n+  private Subscription subscription;\n+  private long tokens;\n+  private Long insertsSent;\n+  private long acksSent;\n+\n+  public AcksSubscriber(final HttpServerResponse response) {\n+    this.response = response;", "originalCommit": "92ac3ce0feac9acd143b159b24e085c57ada49aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc3MDY3Mg==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r367770672", "bodyText": "I don't think you're ever going to give up with the null check comments ;)\nAs you know, I don't really agree with null checking args for internal classes (external APIs, yes), but in the interests of an easy life and simpler reviews I'm just going to swallow my pride and conform.", "author": "purplefox", "createdAt": "2020-01-17T05:05:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQwMjU0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODYyOTg4Mw==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r368629883", "bodyText": "Thanks. We can discuss more over a pint some time.", "author": "big-andy-coates", "createdAt": "2020-01-20T16:16:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQwMjU0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQwMjY3NA==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r367402674", "bodyText": "nit: null check params.", "author": "big-andy-coates", "createdAt": "2020-01-16T12:58:11Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/AcksSubscriber.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_INTERNAL_ERROR;\n+\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.HttpServerResponse;\n+import io.vertx.core.json.JsonObject;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * As the stream of inserts is processed by the back-end, it communicates success (or failure) of\n+ * each insert by sending a stream of acks back in the other direction. This class is the subscriber\n+ * which subscribes to that stream of acks and sends them back to the client. It's a reactive\n+ * streams subscriber so implements back pressure.\n+ */\n+public class AcksSubscriber implements Subscriber<Void> {\n+\n+  private static final Logger log = LoggerFactory.getLogger(AcksSubscriber.class);\n+  private static final int BATCH_SIZE = 4;\n+  private static final Buffer ACK_RESPONSE_LINE = new JsonObject().put(\"status\", \"ok\").toBuffer()\n+      .appendString(\"\\n\");\n+\n+  private final HttpServerResponse response;\n+  private Subscription subscription;\n+  private long tokens;\n+  private Long insertsSent;\n+  private long acksSent;\n+\n+  public AcksSubscriber(final HttpServerResponse response) {\n+    this.response = response;\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(final Subscription subscription) {\n+    if (this.subscription != null) {\n+      throw new IllegalStateException(\"Already subscribed\");\n+    }\n+    this.subscription = subscription;", "originalCommit": "92ac3ce0feac9acd143b159b24e085c57ada49aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQwMzQxMg==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r367403412", "bodyText": "nit: null check params.", "author": "big-andy-coates", "createdAt": "2020-01-16T12:59:54Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/InsertsBodyParser.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_MISSING_PARAM;\n+import static io.confluent.ksql.api.server.ServerUtils.handleError;\n+\n+import io.confluent.ksql.api.spi.Endpoints;\n+import io.confluent.ksql.api.spi.InsertsSubscriber;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.web.RoutingContext;\n+\n+/**\n+ * This class handles the parsing of the request body for a stream of inserts. The user can send a\n+ * stream of inserts to the server by opening an HTTP2 request to the server at the appropriate uri\n+ * and POSTing a request. The request must contain an initial JSON object (encoded as UTF-8 text)\n+ * which contains the arguments for the request (e.g. the target to insert into, and whether acks\n+ * are wanted) This must be followed by a new line, and then followed by zero or more JSON objects\n+ * (also encoded as UTF-8 text) each representing a row to insert. The last JSON object must be\n+ * followed by a new-line.\n+ */\n+public class InsertsBodyParser {\n+\n+  private final Endpoints endpoints;\n+  private final RoutingContext routingContext;\n+  private boolean readArguments;\n+  private InsertsPublisher publisher;\n+  private long rowsReceived;\n+  private AcksSubscriber acksSubscriber;\n+\n+  public InsertsBodyParser(final Endpoints endpoints, final RoutingContext routingContext) {\n+    this.endpoints = endpoints;", "originalCommit": "92ac3ce0feac9acd143b159b24e085c57ada49aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQwNDE4Ng==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r367404186", "bodyText": "Could we deserialize the JSON in POJOs? I think this would make the code more readable and maintainable.  It's also self documenting on what's expected, i.e. users can dig into the code to see, or we can build the docs from the POJOs.\nWhat do you think?", "author": "big-andy-coates", "createdAt": "2020-01-16T13:01:50Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/InsertsBodyParser.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_MISSING_PARAM;\n+import static io.confluent.ksql.api.server.ServerUtils.handleError;\n+\n+import io.confluent.ksql.api.spi.Endpoints;\n+import io.confluent.ksql.api.spi.InsertsSubscriber;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.web.RoutingContext;\n+\n+/**\n+ * This class handles the parsing of the request body for a stream of inserts. The user can send a\n+ * stream of inserts to the server by opening an HTTP2 request to the server at the appropriate uri\n+ * and POSTing a request. The request must contain an initial JSON object (encoded as UTF-8 text)\n+ * which contains the arguments for the request (e.g. the target to insert into, and whether acks\n+ * are wanted) This must be followed by a new line, and then followed by zero or more JSON objects\n+ * (also encoded as UTF-8 text) each representing a row to insert. The last JSON object must be\n+ * followed by a new-line.\n+ */\n+public class InsertsBodyParser {\n+\n+  private final Endpoints endpoints;\n+  private final RoutingContext routingContext;\n+  private boolean readArguments;\n+  private InsertsPublisher publisher;\n+  private long rowsReceived;\n+  private AcksSubscriber acksSubscriber;\n+\n+  public InsertsBodyParser(final Endpoints endpoints, final RoutingContext routingContext) {\n+    this.endpoints = endpoints;\n+    this.routingContext = routingContext;\n+    routingContext.response().endHandler(v -> {\n+      if (publisher != null) {\n+        publisher.close();\n+      }\n+    });\n+  }\n+\n+  public void handleBodyEnd(final Void v) {\n+    if (acksSubscriber == null) {\n+      routingContext.response().end();\n+    } else {\n+      // We close the response after the stream of acks has been sent\n+      acksSubscriber.insertsSent(rowsReceived);\n+    }\n+  }\n+\n+  public void handleBodyBuffer(final Buffer buff) {\n+    if (!readArguments) {\n+      JsonObject args = new JsonObject(buff);\n+      readArguments = true;\n+      String target = args.getString(\"target\");\n+      if (target == null) {\n+        handleError(routingContext.response(), 400, ERROR_CODE_MISSING_PARAM,\n+            \"No target in arguments\");\n+        return;\n+      }\n+      Boolean acks = args.getBoolean(\"acks\");\n+      if (acks == null) {\n+        handleError(routingContext.response(), 400, ERROR_CODE_MISSING_PARAM,\n+            \"No acks in arguments\");\n+        return;\n+      }\n+      JsonObject properties = args.getJsonObject(\"properties\");\n+      routingContext.request().endHandler(this::handleBodyEnd);\n+      acksSubscriber = acks ? new AcksSubscriber(routingContext.response()) : null;\n+      InsertsSubscriber insertsSubscriber = endpoints\n+          .createInsertsSubscriber(target, properties, acksSubscriber);\n+      publisher = new InsertsPublisher();\n+      publisher.subscribe(insertsSubscriber);\n+    } else if (publisher != null) {\n+      JsonObject row = new JsonObject(buff);\n+      publisher.receiveRow(row);\n+      rowsReceived++;\n+    }\n+  }", "originalCommit": "92ac3ce0feac9acd143b159b24e085c57ada49aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzUzMzcwMw==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r367533703", "bodyText": "As you probably know, I tend to err on the side of minimalism and avoid proliferation of classes, especially for simple things. In this case we're just extracting a couple of fields from a map so I did the simplest possible thing.\nI think it would be possible to use a Jackson ObjectMapper and create POJOs for the arguments (although it's not obvious to me exactly how I would do this, especially considering the params to query-stream contains a nested JsonObject in the properties field), but it would certainly result in a lot more code. Considering these args classes would never be used outside this specific method, my initial thoughts are this would be overkill. If the POJOs were passed to other parts of the program, I think the case would be more clear cut.", "author": "purplefox", "createdAt": "2020-01-16T16:52:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQwNDE4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU4MzI4MA==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r367583280", "bodyText": "I will however look into how hard this would be to do. One other thing to bear in mind that Vert. uses JsonObject in many APIs - it's kind of the \"Vert.x-way\" to do JSON. One of the reasons for that is also performance.", "author": "purplefox", "createdAt": "2020-01-16T18:37:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQwNDE4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzYzMzU2MQ==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r367633561", "bodyText": "#4333", "author": "purplefox", "createdAt": "2020-01-16T20:29:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQwNDE4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODExNTYzOQ==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r368115639", "bodyText": "Adding my thoughts here - I tend to agree with Andy on this one. If there's a legitimate concern on performance than perhaps JSON objects that are used exclusively internally and are not exposed can be hand crafted - but it would be nice to have them constructed in a centralized place so that we can define the \"API\" coherently.\nOn the other hand, anything that is exposed externally I feel should definitely have an associated POJO to define the public API and allow us to automatically generate documentation on it.", "author": "agavra", "createdAt": "2020-01-17T20:08:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQwNDE4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODY0MTQ4MQ==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r368641481", "bodyText": "If you're looking for examples of how to use Pojos with Json then take a look at the pojos in the current API are used; they're in the io.confluent.ksql.rest.entity package.\nthe general pattern is that you need a Jackson ObjectMapper and it can serialize a pojo to JSON and deserialize the JSON to a pojo.\nIdeally, put the model into a different module, so that it can be shared between client and server.\nActually, that makes me think: we're looking at clients with different languages, so what we really need for the API is the JSON schema.  We can then use this to generate / validate clients.   We can generate the schema from the Java pojos: @rohan has done this for our internal command API.  Alternatively, you may wish to hand write the JSON schema, from which we may be able to generate the Pojos.\nThoughts?", "author": "big-andy-coates", "createdAt": "2020-01-20T16:40:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQwNDE4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODcyNTM3NQ==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r368725375", "bodyText": "Chatted with Andy about this privately. Here's what code would like if we had to deserialize into POJOs and catch various exceptions so we can send back the right error codes on the wire: https://gist.github.com/purplefox/8975123fcc97da9c7f00eb2ce5ccf8ec\nSuper ugly I hope you agree. Now, sure we can hide this in a utility class but still.", "author": "purplefox", "createdAt": "2020-01-20T21:05:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQwNDE4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQwNDY2Mw==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r367404663", "bodyText": "nit: null checks", "author": "big-andy-coates", "createdAt": "2020-01-16T13:02:58Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/InsertsPublisher.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import io.vertx.core.json.JsonObject;\n+import java.util.LinkedList;\n+import java.util.Queue;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+/**\n+ * This class is a reactive streams publisher which publishes the inserts to a subscriber which is\n+ * provided by the back-end. As it's reactive streams it supports back pressure.\n+ */\n+public class InsertsPublisher implements Publisher<JsonObject> {\n+\n+  private final Queue<JsonObject> buffer = new LinkedList<>();\n+  private long demand;\n+  private Subscriber<? super JsonObject> subscriber;\n+\n+  @Override\n+  public void subscribe(final Subscriber<? super JsonObject> subscriber) {\n+    this.subscriber = subscriber;", "originalCommit": "92ac3ce0feac9acd143b159b24e085c57ada49aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQwNTEwMQ==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r367405101", "bodyText": "nit: make private?", "author": "big-andy-coates", "createdAt": "2020-01-16T13:04:08Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/InsertsPublisher.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import io.vertx.core.json.JsonObject;\n+import java.util.LinkedList;\n+import java.util.Queue;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+/**\n+ * This class is a reactive streams publisher which publishes the inserts to a subscriber which is\n+ * provided by the back-end. As it's reactive streams it supports back pressure.\n+ */\n+public class InsertsPublisher implements Publisher<JsonObject> {\n+\n+  private final Queue<JsonObject> buffer = new LinkedList<>();\n+  private long demand;\n+  private Subscriber<? super JsonObject> subscriber;\n+\n+  @Override\n+  public void subscribe(final Subscriber<? super JsonObject> subscriber) {\n+    this.subscriber = subscriber;\n+    subscriber.onSubscribe(new InsertsSubscription());\n+  }\n+\n+  public synchronized void receiveRow(final JsonObject row) {\n+    if (subscriber == null) {\n+      return;\n+    }\n+    if (demand > 0) {\n+      demand--;\n+      subscriber.onNext(row);\n+    } else {\n+      buffer.add(row);\n+    }\n+  }\n+\n+  synchronized void acceptTokens(final long number) {\n+    demand += number;\n+    for (int i = 0; i < buffer.size(); i++) {\n+      JsonObject row = buffer.poll();\n+      demand--;\n+      subscriber.onNext(row);\n+    }\n+  }\n+\n+  synchronized void close() {\n+    subscriber.onComplete();\n+    subscriber = null;\n+  }\n+\n+  class InsertsSubscription implements Subscription {", "originalCommit": "92ac3ce0feac9acd143b159b24e085c57ada49aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU4MzU0OQ==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r367583549", "bodyText": "Ack", "author": "purplefox", "createdAt": "2020-01-16T18:37:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQwNTEwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQwNTI1Mw==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r367405253", "bodyText": "nit: null check.", "author": "big-andy-coates", "createdAt": "2020-01-16T13:04:32Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/QuerySubscriber.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_INTERNAL_ERROR;\n+\n+import io.vertx.core.http.HttpServerResponse;\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.json.JsonObject;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This is a reactive streams subscriber which receives a stream of results from a publisher which\n+ * is implemented by the back-end. The results are then written to the HTTP2 response.\n+ */\n+public class QuerySubscriber implements Subscriber<JsonArray> {\n+\n+  private static final Logger log = LoggerFactory.getLogger(QuerySubscriber.class);\n+\n+  private final HttpServerResponse response;\n+  private Subscription subscription;\n+  private long tokens;\n+\n+  private static final int BATCH_SIZE = 4;\n+\n+  public QuerySubscriber(final HttpServerResponse response) {\n+    this.response = response;", "originalCommit": "92ac3ce0feac9acd143b159b24e085c57ada49aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQwNTI5Nw==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r367405297", "bodyText": "nit: null check.", "author": "big-andy-coates", "createdAt": "2020-01-16T13:04:40Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/QuerySubscriber.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_INTERNAL_ERROR;\n+\n+import io.vertx.core.http.HttpServerResponse;\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.json.JsonObject;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This is a reactive streams subscriber which receives a stream of results from a publisher which\n+ * is implemented by the back-end. The results are then written to the HTTP2 response.\n+ */\n+public class QuerySubscriber implements Subscriber<JsonArray> {\n+\n+  private static final Logger log = LoggerFactory.getLogger(QuerySubscriber.class);\n+\n+  private final HttpServerResponse response;\n+  private Subscription subscription;\n+  private long tokens;\n+\n+  private static final int BATCH_SIZE = 4;\n+\n+  public QuerySubscriber(final HttpServerResponse response) {\n+    this.response = response;\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(final Subscription subscription) {\n+    if (this.subscription != null) {\n+      throw new IllegalStateException(\"Already subscribed\");\n+    }\n+    this.subscription = subscription;", "originalCommit": "92ac3ce0feac9acd143b159b24e085c57ada49aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODY0Mjk3Ng==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r368642976", "bodyText": "By bad: this one's actually not needed! The if above checks this.", "author": "big-andy-coates", "createdAt": "2020-01-20T16:43:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQwNTI5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQwNTY1NA==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r367405654", "bodyText": "nit: null checks", "author": "big-andy-coates", "createdAt": "2020-01-16T13:05:33Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/Server.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import io.confluent.ksql.api.impl.VertxCompletableFuture;\n+import io.confluent.ksql.api.spi.Endpoints;\n+import io.vertx.core.DeploymentOptions;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.http.HttpConnection;\n+import io.vertx.core.http.HttpServerOptions;\n+import io.vertx.core.impl.ConcurrentHashSet;\n+import io.vertx.core.json.JsonObject;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class represents the API server. On start-up it deploys multiple server verticles to spread\n+ * the load across available cores.\n+ */\n+public class Server {\n+\n+  private static final Logger log = LoggerFactory.getLogger(Server.class);\n+\n+  private final Vertx vertx;\n+  private final JsonObject config;\n+  private final Endpoints endpoints;\n+  private final HttpServerOptions httpServerOptions;\n+  private final Map<String, QuerySubscriber> queries = new ConcurrentHashMap<>();\n+  private final Set<HttpConnection> connections = new ConcurrentHashSet<>();\n+  private String deploymentID;\n+\n+  public Server(final Vertx vertx, final JsonObject config, final Endpoints endpoints,\n+      final HttpServerOptions httpServerOptions) {\n+    this.vertx = vertx;\n+    this.config = config;\n+    this.endpoints = endpoints;\n+    this.httpServerOptions = httpServerOptions;", "originalCommit": "92ac3ce0feac9acd143b159b24e085c57ada49aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQwNjQxMg==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r367406412", "bodyText": "We generally use AbstractConfig as a base for config classes, as this provides a fair amount of functionality that can be useful, including defining validators and defaults: which keeps the calling code a lot cleaner.\nIn the future, we can also generate the docs from the config class.", "author": "big-andy-coates", "createdAt": "2020-01-16T13:07:20Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/Server.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import io.confluent.ksql.api.impl.VertxCompletableFuture;\n+import io.confluent.ksql.api.spi.Endpoints;\n+import io.vertx.core.DeploymentOptions;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.http.HttpConnection;\n+import io.vertx.core.http.HttpServerOptions;\n+import io.vertx.core.impl.ConcurrentHashSet;\n+import io.vertx.core.json.JsonObject;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class represents the API server. On start-up it deploys multiple server verticles to spread\n+ * the load across available cores.\n+ */\n+public class Server {\n+\n+  private static final Logger log = LoggerFactory.getLogger(Server.class);\n+\n+  private final Vertx vertx;\n+  private final JsonObject config;", "originalCommit": "92ac3ce0feac9acd143b159b24e085c57ada49aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzUzNTk1OA==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r367535958", "bodyText": "#4330", "author": "purplefox", "createdAt": "2020-01-16T16:56:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQwNjQxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQwNzUxNg==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r367407516", "bodyText": "Consider throwing a more specific exception type, e.g. KsqlServerException, and include more info, e.g. \"Failed to start server\".", "author": "big-andy-coates", "createdAt": "2020-01-16T13:09:56Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/Server.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import io.confluent.ksql.api.impl.VertxCompletableFuture;\n+import io.confluent.ksql.api.spi.Endpoints;\n+import io.vertx.core.DeploymentOptions;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.http.HttpConnection;\n+import io.vertx.core.http.HttpServerOptions;\n+import io.vertx.core.impl.ConcurrentHashSet;\n+import io.vertx.core.json.JsonObject;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class represents the API server. On start-up it deploys multiple server verticles to spread\n+ * the load across available cores.\n+ */\n+public class Server {\n+\n+  private static final Logger log = LoggerFactory.getLogger(Server.class);\n+\n+  private final Vertx vertx;\n+  private final JsonObject config;\n+  private final Endpoints endpoints;\n+  private final HttpServerOptions httpServerOptions;\n+  private final Map<String, QuerySubscriber> queries = new ConcurrentHashMap<>();\n+  private final Set<HttpConnection> connections = new ConcurrentHashSet<>();\n+  private String deploymentID;\n+\n+  public Server(final Vertx vertx, final JsonObject config, final Endpoints endpoints,\n+      final HttpServerOptions httpServerOptions) {\n+    this.vertx = vertx;\n+    this.config = config;\n+    this.endpoints = endpoints;\n+    this.httpServerOptions = httpServerOptions;\n+  }\n+\n+  public synchronized void start() {\n+    if (deploymentID != null) {\n+      throw new IllegalStateException(\"Already started\");\n+    }\n+    DeploymentOptions options = new DeploymentOptions();\n+    Integer verticleInstances = config.getInteger(\"verticle-instances\");\n+    if (verticleInstances == null) {\n+      options.setInstances(Runtime.getRuntime().availableProcessors() * 2);\n+    } else {\n+      options.setInstances(verticleInstances);\n+    }\n+    log.info(\"Deploying \" + options.getInstances() + \" instances of server verticle\");\n+    options.setConfig(config);\n+    VertxCompletableFuture<String> future = new VertxCompletableFuture<>();\n+    vertx.deployVerticle(\n+        () -> new ServerVerticle(endpoints, httpServerOptions, this), options, future);\n+    try {\n+      deploymentID = future.get();\n+    } catch (Exception e) {\n+      throw new RuntimeException(e);", "originalCommit": "92ac3ce0feac9acd143b159b24e085c57ada49aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU4MzQxMw==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r367583413", "bodyText": "Ack", "author": "purplefox", "createdAt": "2020-01-16T18:37:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQwNzUxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODY1Mjk4OQ==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r368652989", "bodyText": "FYI, use KsqlServerException, not KsqlException.", "author": "big-andy-coates", "createdAt": "2020-01-20T17:05:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQwNzUxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQwNzY5MA==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r367407690", "bodyText": "Consider throwing a more specific exception type, e.g. KsqlServerException, and include more info, e.g. \"failed to stop server\".", "author": "big-andy-coates", "createdAt": "2020-01-16T13:10:18Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/Server.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import io.confluent.ksql.api.impl.VertxCompletableFuture;\n+import io.confluent.ksql.api.spi.Endpoints;\n+import io.vertx.core.DeploymentOptions;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.http.HttpConnection;\n+import io.vertx.core.http.HttpServerOptions;\n+import io.vertx.core.impl.ConcurrentHashSet;\n+import io.vertx.core.json.JsonObject;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class represents the API server. On start-up it deploys multiple server verticles to spread\n+ * the load across available cores.\n+ */\n+public class Server {\n+\n+  private static final Logger log = LoggerFactory.getLogger(Server.class);\n+\n+  private final Vertx vertx;\n+  private final JsonObject config;\n+  private final Endpoints endpoints;\n+  private final HttpServerOptions httpServerOptions;\n+  private final Map<String, QuerySubscriber> queries = new ConcurrentHashMap<>();\n+  private final Set<HttpConnection> connections = new ConcurrentHashSet<>();\n+  private String deploymentID;\n+\n+  public Server(final Vertx vertx, final JsonObject config, final Endpoints endpoints,\n+      final HttpServerOptions httpServerOptions) {\n+    this.vertx = vertx;\n+    this.config = config;\n+    this.endpoints = endpoints;\n+    this.httpServerOptions = httpServerOptions;\n+  }\n+\n+  public synchronized void start() {\n+    if (deploymentID != null) {\n+      throw new IllegalStateException(\"Already started\");\n+    }\n+    DeploymentOptions options = new DeploymentOptions();\n+    Integer verticleInstances = config.getInteger(\"verticle-instances\");\n+    if (verticleInstances == null) {\n+      options.setInstances(Runtime.getRuntime().availableProcessors() * 2);\n+    } else {\n+      options.setInstances(verticleInstances);\n+    }\n+    log.info(\"Deploying \" + options.getInstances() + \" instances of server verticle\");\n+    options.setConfig(config);\n+    VertxCompletableFuture<String> future = new VertxCompletableFuture<>();\n+    vertx.deployVerticle(\n+        () -> new ServerVerticle(endpoints, httpServerOptions, this), options, future);\n+    try {\n+      deploymentID = future.get();\n+    } catch (Exception e) {\n+      throw new RuntimeException(e);\n+    }\n+    log.info(\"API server started: \" + deploymentID);\n+  }\n+\n+  public synchronized void stop() {\n+    if (deploymentID == null) {\n+      throw new IllegalStateException(\"Not started\");\n+    }\n+    VertxCompletableFuture<Void> future = new VertxCompletableFuture<>();\n+    vertx.undeploy(deploymentID, future);\n+    try {\n+      future.get();\n+    } catch (Exception e) {\n+      throw new RuntimeException(e);", "originalCommit": "92ac3ce0feac9acd143b159b24e085c57ada49aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU4MzQ2MQ==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r367583461", "bodyText": "Ack", "author": "purplefox", "createdAt": "2020-01-16T18:37:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQwNzY5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQwODA3Mg==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r367408072", "bodyText": "nit: null check state.", "author": "big-andy-coates", "createdAt": "2020-01-16T13:11:08Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/Server.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import io.confluent.ksql.api.impl.VertxCompletableFuture;\n+import io.confluent.ksql.api.spi.Endpoints;\n+import io.vertx.core.DeploymentOptions;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.http.HttpConnection;\n+import io.vertx.core.http.HttpServerOptions;\n+import io.vertx.core.impl.ConcurrentHashSet;\n+import io.vertx.core.json.JsonObject;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class represents the API server. On start-up it deploys multiple server verticles to spread\n+ * the load across available cores.\n+ */\n+public class Server {\n+\n+  private static final Logger log = LoggerFactory.getLogger(Server.class);\n+\n+  private final Vertx vertx;\n+  private final JsonObject config;\n+  private final Endpoints endpoints;\n+  private final HttpServerOptions httpServerOptions;\n+  private final Map<String, QuerySubscriber> queries = new ConcurrentHashMap<>();\n+  private final Set<HttpConnection> connections = new ConcurrentHashSet<>();\n+  private String deploymentID;\n+\n+  public Server(final Vertx vertx, final JsonObject config, final Endpoints endpoints,\n+      final HttpServerOptions httpServerOptions) {\n+    this.vertx = vertx;\n+    this.config = config;\n+    this.endpoints = endpoints;\n+    this.httpServerOptions = httpServerOptions;\n+  }\n+\n+  public synchronized void start() {\n+    if (deploymentID != null) {\n+      throw new IllegalStateException(\"Already started\");\n+    }\n+    DeploymentOptions options = new DeploymentOptions();\n+    Integer verticleInstances = config.getInteger(\"verticle-instances\");\n+    if (verticleInstances == null) {\n+      options.setInstances(Runtime.getRuntime().availableProcessors() * 2);\n+    } else {\n+      options.setInstances(verticleInstances);\n+    }\n+    log.info(\"Deploying \" + options.getInstances() + \" instances of server verticle\");\n+    options.setConfig(config);\n+    VertxCompletableFuture<String> future = new VertxCompletableFuture<>();\n+    vertx.deployVerticle(\n+        () -> new ServerVerticle(endpoints, httpServerOptions, this), options, future);\n+    try {\n+      deploymentID = future.get();\n+    } catch (Exception e) {\n+      throw new RuntimeException(e);\n+    }\n+    log.info(\"API server started: \" + deploymentID);\n+  }\n+\n+  public synchronized void stop() {\n+    if (deploymentID == null) {\n+      throw new IllegalStateException(\"Not started\");\n+    }\n+    VertxCompletableFuture<Void> future = new VertxCompletableFuture<>();\n+    vertx.undeploy(deploymentID, future);\n+    try {\n+      future.get();\n+    } catch (Exception e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  String registerQuery(final QuerySubscriber querySubscriber) {\n+    String uuid = UUID.randomUUID().toString();\n+    queries.put(uuid, querySubscriber);", "originalCommit": "92ac3ce0feac9acd143b159b24e085c57ada49aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQwODE4MA==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r367408180", "bodyText": "nit: null check state.", "author": "big-andy-coates", "createdAt": "2020-01-16T13:11:22Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/Server.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import io.confluent.ksql.api.impl.VertxCompletableFuture;\n+import io.confluent.ksql.api.spi.Endpoints;\n+import io.vertx.core.DeploymentOptions;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.http.HttpConnection;\n+import io.vertx.core.http.HttpServerOptions;\n+import io.vertx.core.impl.ConcurrentHashSet;\n+import io.vertx.core.json.JsonObject;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class represents the API server. On start-up it deploys multiple server verticles to spread\n+ * the load across available cores.\n+ */\n+public class Server {\n+\n+  private static final Logger log = LoggerFactory.getLogger(Server.class);\n+\n+  private final Vertx vertx;\n+  private final JsonObject config;\n+  private final Endpoints endpoints;\n+  private final HttpServerOptions httpServerOptions;\n+  private final Map<String, QuerySubscriber> queries = new ConcurrentHashMap<>();\n+  private final Set<HttpConnection> connections = new ConcurrentHashSet<>();\n+  private String deploymentID;\n+\n+  public Server(final Vertx vertx, final JsonObject config, final Endpoints endpoints,\n+      final HttpServerOptions httpServerOptions) {\n+    this.vertx = vertx;\n+    this.config = config;\n+    this.endpoints = endpoints;\n+    this.httpServerOptions = httpServerOptions;\n+  }\n+\n+  public synchronized void start() {\n+    if (deploymentID != null) {\n+      throw new IllegalStateException(\"Already started\");\n+    }\n+    DeploymentOptions options = new DeploymentOptions();\n+    Integer verticleInstances = config.getInteger(\"verticle-instances\");\n+    if (verticleInstances == null) {\n+      options.setInstances(Runtime.getRuntime().availableProcessors() * 2);\n+    } else {\n+      options.setInstances(verticleInstances);\n+    }\n+    log.info(\"Deploying \" + options.getInstances() + \" instances of server verticle\");\n+    options.setConfig(config);\n+    VertxCompletableFuture<String> future = new VertxCompletableFuture<>();\n+    vertx.deployVerticle(\n+        () -> new ServerVerticle(endpoints, httpServerOptions, this), options, future);\n+    try {\n+      deploymentID = future.get();\n+    } catch (Exception e) {\n+      throw new RuntimeException(e);\n+    }\n+    log.info(\"API server started: \" + deploymentID);\n+  }\n+\n+  public synchronized void stop() {\n+    if (deploymentID == null) {\n+      throw new IllegalStateException(\"Not started\");\n+    }\n+    VertxCompletableFuture<Void> future = new VertxCompletableFuture<>();\n+    vertx.undeploy(deploymentID, future);\n+    try {\n+      future.get();\n+    } catch (Exception e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  String registerQuery(final QuerySubscriber querySubscriber) {\n+    String uuid = UUID.randomUUID().toString();\n+    queries.put(uuid, querySubscriber);\n+    return uuid;\n+  }\n+\n+  QuerySubscriber removeQuery(final String queryID) {\n+    return queries.remove(queryID);\n+  }\n+\n+  public Set<String> getQueryIDs() {\n+    return new HashSet<>(queries.keySet());\n+  }\n+\n+  void registerQueryConnection(final HttpConnection connection) {\n+    this.connections.add(connection);", "originalCommit": "92ac3ce0feac9acd143b159b24e085c57ada49aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQwODUzNg==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r367408536", "bodyText": "As above, consider using a Pojo.", "author": "big-andy-coates", "createdAt": "2020-01-16T13:12:12Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/ServerUtils.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import io.vertx.core.http.HttpServerResponse;\n+import io.vertx.core.json.JsonObject;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * static util methods used in the server\n+ */\n+public class ServerUtils {\n+\n+  private static final Logger log = LoggerFactory.getLogger(ServerUtils.class);\n+\n+  public static void handleError(final HttpServerResponse response, final int statusCode,\n+      final int errorCode, final String errMsg) {\n+    JsonObject errResponse = new JsonObject().put(\"status\", \"error\").put(\"errorCode\", errorCode)\n+        .put(\"message\", errMsg);\n+    response.setStatusCode(statusCode).end(errResponse.toBuffer());", "originalCommit": "92ac3ce0feac9acd143b159b24e085c57ada49aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQwODk1OQ==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r367408959", "bodyText": "nit: Function name out of whack with impl, e.g. consider naming it unhandledExceptionHandler or logUnhandledExcpetion, or similar.\nOut of interest, when would this be called? / should this be called in normal operation?\nOr is this just WIP?", "author": "big-andy-coates", "createdAt": "2020-01-16T13:13:07Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/ServerUtils.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import io.vertx.core.http.HttpServerResponse;\n+import io.vertx.core.json.JsonObject;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * static util methods used in the server\n+ */\n+public class ServerUtils {\n+\n+  private static final Logger log = LoggerFactory.getLogger(ServerUtils.class);\n+\n+  public static void handleError(final HttpServerResponse response, final int statusCode,\n+      final int errorCode, final String errMsg) {\n+    JsonObject errResponse = new JsonObject().put(\"status\", \"error\").put(\"errorCode\", errorCode)\n+        .put(\"message\", errMsg);\n+    response.setStatusCode(statusCode).end(errResponse.toBuffer());\n+  }\n+\n+  public static void handleException(final Throwable t) {\n+    log.error(\"Unhandled exception\", t);\n+  }", "originalCommit": "92ac3ce0feac9acd143b159b24e085c57ada49aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzUzOTMxMA==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r367539310", "bodyText": "It will be called for any unchecked exceptions thrown from handlers.", "author": "purplefox", "createdAt": "2020-01-16T17:02:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQwODk1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQwOTY2Mg==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r367409662", "bodyText": "nit: null checks.", "author": "big-andy-coates", "createdAt": "2020-01-16T13:14:47Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/ServerVerticle.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_MISSING_PARAM;\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_UNKNOWN_QUERY_ID;\n+import static io.confluent.ksql.api.server.ServerUtils.handleError;\n+\n+import io.confluent.ksql.api.impl.Utils;\n+import io.confluent.ksql.api.spi.Endpoints;\n+import io.confluent.ksql.api.spi.QueryPublisher;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.core.Promise;\n+import io.vertx.core.http.HttpConnection;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.core.http.HttpServer;\n+import io.vertx.core.http.HttpServerOptions;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.core.parsetools.RecordParser;\n+import io.vertx.ext.web.Router;\n+import io.vertx.ext.web.RoutingContext;\n+import io.vertx.ext.web.handler.BodyHandler;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The server deploys multiple server verticles. This is where the HTTP2 requests are handled. The\n+ * actual implementation of the endpoints is provided by an implementation of {@code Endpoints}.\n+ */\n+public class ServerVerticle extends AbstractVerticle {\n+\n+  private static final Logger log = LoggerFactory.getLogger(ServerVerticle.class);\n+\n+  private final Endpoints endpoints;\n+  private final HttpServerOptions httpServerOptions;\n+  private final Server server;\n+  private final Map<HttpConnection, ConnectionQueries> connectionsMap = new HashMap<>();\n+  private HttpServer httpServer;\n+\n+  public ServerVerticle(final Endpoints endpoints, final HttpServerOptions httpServerOptions,\n+      final Server server) {\n+    this.endpoints = endpoints;", "originalCommit": "92ac3ce0feac9acd143b159b24e085c57ada49aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQxMDU1MQ==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r367410551", "bodyText": "Can't say I'm a fan of Utils classes.  This has the risk it will just become a dumping ground for a load of unrelated methods.  Could we possibly have a more targeted name? e.g. ReactiveUtils ?", "author": "big-andy-coates", "createdAt": "2020-01-16T13:16:46Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/impl/Utils.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.impl;\n+\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+\n+/**\n+ * General purpose utils (not limited to the server, could be used by client too) for the API\n+ * module.\n+ */\n+public class Utils {", "originalCommit": "92ac3ce0feac9acd143b159b24e085c57ada49aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQxMTYyNQ==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r367411625", "bodyText": "Again, can we use Pojo's to avoid this manual / inline handling and validation of Json, please?", "author": "big-andy-coates", "createdAt": "2020-01-16T13:19:12Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/ServerVerticle.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_MISSING_PARAM;\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_UNKNOWN_QUERY_ID;\n+import static io.confluent.ksql.api.server.ServerUtils.handleError;\n+\n+import io.confluent.ksql.api.impl.Utils;\n+import io.confluent.ksql.api.spi.Endpoints;\n+import io.confluent.ksql.api.spi.QueryPublisher;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.core.Promise;\n+import io.vertx.core.http.HttpConnection;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.core.http.HttpServer;\n+import io.vertx.core.http.HttpServerOptions;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.core.parsetools.RecordParser;\n+import io.vertx.ext.web.Router;\n+import io.vertx.ext.web.RoutingContext;\n+import io.vertx.ext.web.handler.BodyHandler;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The server deploys multiple server verticles. This is where the HTTP2 requests are handled. The\n+ * actual implementation of the endpoints is provided by an implementation of {@code Endpoints}.\n+ */\n+public class ServerVerticle extends AbstractVerticle {\n+\n+  private static final Logger log = LoggerFactory.getLogger(ServerVerticle.class);\n+\n+  private final Endpoints endpoints;\n+  private final HttpServerOptions httpServerOptions;\n+  private final Server server;\n+  private final Map<HttpConnection, ConnectionQueries> connectionsMap = new HashMap<>();\n+  private HttpServer httpServer;\n+\n+  public ServerVerticle(final Endpoints endpoints, final HttpServerOptions httpServerOptions,\n+      final Server server) {\n+    this.endpoints = endpoints;\n+    this.httpServerOptions = httpServerOptions;\n+    this.server = server;\n+  }\n+\n+  @Override\n+  public void start(final Promise<Void> startPromise) {\n+    httpServer = vertx.createHttpServer(httpServerOptions).requestHandler(setupRouter())\n+        .exceptionHandler(ServerUtils::handleException);\n+    Future<HttpServer> listenFuture = Promise.<HttpServer>promise().future();\n+    Utils.connectPromise(listenFuture.map(s -> null), startPromise);\n+    httpServer.listen(listenFuture);\n+    vertx.getOrCreateContext().exceptionHandler(ServerUtils::handleException);\n+  }\n+\n+  @Override\n+  public void stop(final Promise<Void> stopPromise) {\n+    if (httpServer == null) {\n+      stopPromise.complete();\n+    } else {\n+      httpServer.close(stopPromise.future());\n+    }\n+  }\n+\n+  private Router setupRouter() {\n+    Router router = Router.router(vertx);\n+    router.route(HttpMethod.POST, \"/query-stream\").handler(BodyHandler.create())\n+        .handler(this::handleQueryStream);\n+    router.route(HttpMethod.POST, \"/inserts-stream\").handler(this::handleInsertsStream);\n+    router.route(HttpMethod.POST, \"/close-query\").handler(BodyHandler.create())\n+        .handler(this::handleCloseQuery);\n+    return router;\n+  }\n+\n+  private void handleInsertsStream(final RoutingContext routingContext) {\n+    RecordParser recordParser = RecordParser\n+        .newDelimited(\"\\n\", new InsertsBodyParser(endpoints, routingContext)::handleBodyBuffer);\n+    routingContext.request()\n+        .handler(recordParser);\n+  }\n+\n+  private void handleQueryStream(final RoutingContext routingContext) {\n+    HttpConnection conn = routingContext.request().connection();\n+    ConnectionQueries connectionQueries = connectionsMap.get(conn);\n+    if (connectionQueries == null) {\n+      connectionQueries = new ConnectionQueries(conn);\n+      connectionsMap.put(conn, connectionQueries);\n+      conn.closeHandler(connectionQueries);\n+      server.registerQueryConnection(conn);\n+    }\n+    JsonObject requestBody = routingContext.getBodyAsJson();\n+    String sql = requestBody.getString(\"sql\");\n+    if (sql == null) {\n+      handleError(routingContext.response(), 400, ERROR_CODE_MISSING_PARAM, \"No sql in arguments\");\n+      return;\n+    }\n+    Boolean push = requestBody.getBoolean(\"push\");\n+    if (push == null) {\n+      handleError(routingContext.response(), 400, ERROR_CODE_MISSING_PARAM, \"No push in arguments\");\n+      return;\n+    }\n+    JsonObject properties = requestBody.getJsonObject(\"properties\");", "originalCommit": "92ac3ce0feac9acd143b159b24e085c57ada49aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU4NDA0Mw==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r367584043", "bodyText": "Perhaps you could give an example of how you would do this with a POJO as it's not clear to me.", "author": "purplefox", "createdAt": "2020-01-16T18:39:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQxMTYyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODY1NTU1MQ==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r368655551", "bodyText": "See above.", "author": "big-andy-coates", "createdAt": "2020-01-20T17:12:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQxMTYyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQxMjIxMw==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r367412213", "bodyText": "Is this queryId the same as our QueryId class that is used to identify queries?  If it is, can we use the more strongly typed QueryId class?\nIf its not... maybe use a different type to differentiate and avoid confusion?", "author": "big-andy-coates", "createdAt": "2020-01-16T13:20:31Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/ServerVerticle.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_MISSING_PARAM;\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_UNKNOWN_QUERY_ID;\n+import static io.confluent.ksql.api.server.ServerUtils.handleError;\n+\n+import io.confluent.ksql.api.impl.Utils;\n+import io.confluent.ksql.api.spi.Endpoints;\n+import io.confluent.ksql.api.spi.QueryPublisher;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.core.Promise;\n+import io.vertx.core.http.HttpConnection;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.core.http.HttpServer;\n+import io.vertx.core.http.HttpServerOptions;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.core.parsetools.RecordParser;\n+import io.vertx.ext.web.Router;\n+import io.vertx.ext.web.RoutingContext;\n+import io.vertx.ext.web.handler.BodyHandler;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The server deploys multiple server verticles. This is where the HTTP2 requests are handled. The\n+ * actual implementation of the endpoints is provided by an implementation of {@code Endpoints}.\n+ */\n+public class ServerVerticle extends AbstractVerticle {\n+\n+  private static final Logger log = LoggerFactory.getLogger(ServerVerticle.class);\n+\n+  private final Endpoints endpoints;\n+  private final HttpServerOptions httpServerOptions;\n+  private final Server server;\n+  private final Map<HttpConnection, ConnectionQueries> connectionsMap = new HashMap<>();\n+  private HttpServer httpServer;\n+\n+  public ServerVerticle(final Endpoints endpoints, final HttpServerOptions httpServerOptions,\n+      final Server server) {\n+    this.endpoints = endpoints;\n+    this.httpServerOptions = httpServerOptions;\n+    this.server = server;\n+  }\n+\n+  @Override\n+  public void start(final Promise<Void> startPromise) {\n+    httpServer = vertx.createHttpServer(httpServerOptions).requestHandler(setupRouter())\n+        .exceptionHandler(ServerUtils::handleException);\n+    Future<HttpServer> listenFuture = Promise.<HttpServer>promise().future();\n+    Utils.connectPromise(listenFuture.map(s -> null), startPromise);\n+    httpServer.listen(listenFuture);\n+    vertx.getOrCreateContext().exceptionHandler(ServerUtils::handleException);\n+  }\n+\n+  @Override\n+  public void stop(final Promise<Void> stopPromise) {\n+    if (httpServer == null) {\n+      stopPromise.complete();\n+    } else {\n+      httpServer.close(stopPromise.future());\n+    }\n+  }\n+\n+  private Router setupRouter() {\n+    Router router = Router.router(vertx);\n+    router.route(HttpMethod.POST, \"/query-stream\").handler(BodyHandler.create())\n+        .handler(this::handleQueryStream);\n+    router.route(HttpMethod.POST, \"/inserts-stream\").handler(this::handleInsertsStream);\n+    router.route(HttpMethod.POST, \"/close-query\").handler(BodyHandler.create())\n+        .handler(this::handleCloseQuery);\n+    return router;\n+  }\n+\n+  private void handleInsertsStream(final RoutingContext routingContext) {\n+    RecordParser recordParser = RecordParser\n+        .newDelimited(\"\\n\", new InsertsBodyParser(endpoints, routingContext)::handleBodyBuffer);\n+    routingContext.request()\n+        .handler(recordParser);\n+  }\n+\n+  private void handleQueryStream(final RoutingContext routingContext) {\n+    HttpConnection conn = routingContext.request().connection();\n+    ConnectionQueries connectionQueries = connectionsMap.get(conn);\n+    if (connectionQueries == null) {\n+      connectionQueries = new ConnectionQueries(conn);\n+      connectionsMap.put(conn, connectionQueries);\n+      conn.closeHandler(connectionQueries);\n+      server.registerQueryConnection(conn);\n+    }\n+    JsonObject requestBody = routingContext.getBodyAsJson();\n+    String sql = requestBody.getString(\"sql\");\n+    if (sql == null) {\n+      handleError(routingContext.response(), 400, ERROR_CODE_MISSING_PARAM, \"No sql in arguments\");\n+      return;\n+    }\n+    Boolean push = requestBody.getBoolean(\"push\");\n+    if (push == null) {\n+      handleError(routingContext.response(), 400, ERROR_CODE_MISSING_PARAM, \"No push in arguments\");\n+      return;\n+    }\n+    JsonObject properties = requestBody.getJsonObject(\"properties\");\n+    QueryPublisher queryPublisher = endpoints.createQueryPublisher(sql, push, properties);\n+    QuerySubscriber querySubscriber = new QuerySubscriber(routingContext.response());\n+\n+    String queryID = server.registerQuery(querySubscriber);", "originalCommit": "92ac3ce0feac9acd143b159b24e085c57ada49aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzYzNDk1MQ==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r367634951", "bodyText": "It's a cryptographically secure, random UUID.", "author": "purplefox", "createdAt": "2020-01-16T20:32:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQxMjIxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc3OTkwMg==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r367779902", "bodyText": "Ack wil change to a custom type", "author": "purplefox", "createdAt": "2020-01-17T05:57:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQxMjIxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQxMjMwNA==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r367412304", "bodyText": "Replace with Pojo?", "author": "big-andy-coates", "createdAt": "2020-01-16T13:20:43Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/ServerVerticle.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_MISSING_PARAM;\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_UNKNOWN_QUERY_ID;\n+import static io.confluent.ksql.api.server.ServerUtils.handleError;\n+\n+import io.confluent.ksql.api.impl.Utils;\n+import io.confluent.ksql.api.spi.Endpoints;\n+import io.confluent.ksql.api.spi.QueryPublisher;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.core.Promise;\n+import io.vertx.core.http.HttpConnection;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.core.http.HttpServer;\n+import io.vertx.core.http.HttpServerOptions;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.core.parsetools.RecordParser;\n+import io.vertx.ext.web.Router;\n+import io.vertx.ext.web.RoutingContext;\n+import io.vertx.ext.web.handler.BodyHandler;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The server deploys multiple server verticles. This is where the HTTP2 requests are handled. The\n+ * actual implementation of the endpoints is provided by an implementation of {@code Endpoints}.\n+ */\n+public class ServerVerticle extends AbstractVerticle {\n+\n+  private static final Logger log = LoggerFactory.getLogger(ServerVerticle.class);\n+\n+  private final Endpoints endpoints;\n+  private final HttpServerOptions httpServerOptions;\n+  private final Server server;\n+  private final Map<HttpConnection, ConnectionQueries> connectionsMap = new HashMap<>();\n+  private HttpServer httpServer;\n+\n+  public ServerVerticle(final Endpoints endpoints, final HttpServerOptions httpServerOptions,\n+      final Server server) {\n+    this.endpoints = endpoints;\n+    this.httpServerOptions = httpServerOptions;\n+    this.server = server;\n+  }\n+\n+  @Override\n+  public void start(final Promise<Void> startPromise) {\n+    httpServer = vertx.createHttpServer(httpServerOptions).requestHandler(setupRouter())\n+        .exceptionHandler(ServerUtils::handleException);\n+    Future<HttpServer> listenFuture = Promise.<HttpServer>promise().future();\n+    Utils.connectPromise(listenFuture.map(s -> null), startPromise);\n+    httpServer.listen(listenFuture);\n+    vertx.getOrCreateContext().exceptionHandler(ServerUtils::handleException);\n+  }\n+\n+  @Override\n+  public void stop(final Promise<Void> stopPromise) {\n+    if (httpServer == null) {\n+      stopPromise.complete();\n+    } else {\n+      httpServer.close(stopPromise.future());\n+    }\n+  }\n+\n+  private Router setupRouter() {\n+    Router router = Router.router(vertx);\n+    router.route(HttpMethod.POST, \"/query-stream\").handler(BodyHandler.create())\n+        .handler(this::handleQueryStream);\n+    router.route(HttpMethod.POST, \"/inserts-stream\").handler(this::handleInsertsStream);\n+    router.route(HttpMethod.POST, \"/close-query\").handler(BodyHandler.create())\n+        .handler(this::handleCloseQuery);\n+    return router;\n+  }\n+\n+  private void handleInsertsStream(final RoutingContext routingContext) {\n+    RecordParser recordParser = RecordParser\n+        .newDelimited(\"\\n\", new InsertsBodyParser(endpoints, routingContext)::handleBodyBuffer);\n+    routingContext.request()\n+        .handler(recordParser);\n+  }\n+\n+  private void handleQueryStream(final RoutingContext routingContext) {\n+    HttpConnection conn = routingContext.request().connection();\n+    ConnectionQueries connectionQueries = connectionsMap.get(conn);\n+    if (connectionQueries == null) {\n+      connectionQueries = new ConnectionQueries(conn);\n+      connectionsMap.put(conn, connectionQueries);\n+      conn.closeHandler(connectionQueries);\n+      server.registerQueryConnection(conn);\n+    }\n+    JsonObject requestBody = routingContext.getBodyAsJson();\n+    String sql = requestBody.getString(\"sql\");\n+    if (sql == null) {\n+      handleError(routingContext.response(), 400, ERROR_CODE_MISSING_PARAM, \"No sql in arguments\");\n+      return;\n+    }\n+    Boolean push = requestBody.getBoolean(\"push\");\n+    if (push == null) {\n+      handleError(routingContext.response(), 400, ERROR_CODE_MISSING_PARAM, \"No push in arguments\");\n+      return;\n+    }\n+    JsonObject properties = requestBody.getJsonObject(\"properties\");\n+    QueryPublisher queryPublisher = endpoints.createQueryPublisher(sql, push, properties);\n+    QuerySubscriber querySubscriber = new QuerySubscriber(routingContext.response());\n+\n+    String queryID = server.registerQuery(querySubscriber);\n+    connectionQueries.addQuery(queryID);\n+    JsonObject metadata = new JsonObject();\n+    metadata.put(\"columnNames\", queryPublisher.getColumnNames());\n+    metadata.put(\"columnTypes\", queryPublisher.getColumnTypes());\n+    metadata.put(\"queryID\", queryID);\n+    if (!push) {\n+      metadata.put(\"rowCount\", queryPublisher.getRowCount());\n+    }\n+    routingContext.response().write(metadata.toBuffer()).write(\"\\n\");", "originalCommit": "92ac3ce0feac9acd143b159b24e085c57ada49aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQxMjYxNA==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r367412614", "bodyText": "out of interest, what does returning false actually mean?", "author": "big-andy-coates", "createdAt": "2020-01-16T13:21:27Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/ServerVerticle.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_MISSING_PARAM;\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_UNKNOWN_QUERY_ID;\n+import static io.confluent.ksql.api.server.ServerUtils.handleError;\n+\n+import io.confluent.ksql.api.impl.Utils;\n+import io.confluent.ksql.api.spi.Endpoints;\n+import io.confluent.ksql.api.spi.QueryPublisher;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.core.Promise;\n+import io.vertx.core.http.HttpConnection;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.core.http.HttpServer;\n+import io.vertx.core.http.HttpServerOptions;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.core.parsetools.RecordParser;\n+import io.vertx.ext.web.Router;\n+import io.vertx.ext.web.RoutingContext;\n+import io.vertx.ext.web.handler.BodyHandler;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The server deploys multiple server verticles. This is where the HTTP2 requests are handled. The\n+ * actual implementation of the endpoints is provided by an implementation of {@code Endpoints}.\n+ */\n+public class ServerVerticle extends AbstractVerticle {\n+\n+  private static final Logger log = LoggerFactory.getLogger(ServerVerticle.class);\n+\n+  private final Endpoints endpoints;\n+  private final HttpServerOptions httpServerOptions;\n+  private final Server server;\n+  private final Map<HttpConnection, ConnectionQueries> connectionsMap = new HashMap<>();\n+  private HttpServer httpServer;\n+\n+  public ServerVerticle(final Endpoints endpoints, final HttpServerOptions httpServerOptions,\n+      final Server server) {\n+    this.endpoints = endpoints;\n+    this.httpServerOptions = httpServerOptions;\n+    this.server = server;\n+  }\n+\n+  @Override\n+  public void start(final Promise<Void> startPromise) {\n+    httpServer = vertx.createHttpServer(httpServerOptions).requestHandler(setupRouter())\n+        .exceptionHandler(ServerUtils::handleException);\n+    Future<HttpServer> listenFuture = Promise.<HttpServer>promise().future();\n+    Utils.connectPromise(listenFuture.map(s -> null), startPromise);\n+    httpServer.listen(listenFuture);\n+    vertx.getOrCreateContext().exceptionHandler(ServerUtils::handleException);\n+  }\n+\n+  @Override\n+  public void stop(final Promise<Void> stopPromise) {\n+    if (httpServer == null) {\n+      stopPromise.complete();\n+    } else {\n+      httpServer.close(stopPromise.future());\n+    }\n+  }\n+\n+  private Router setupRouter() {\n+    Router router = Router.router(vertx);\n+    router.route(HttpMethod.POST, \"/query-stream\").handler(BodyHandler.create())\n+        .handler(this::handleQueryStream);\n+    router.route(HttpMethod.POST, \"/inserts-stream\").handler(this::handleInsertsStream);\n+    router.route(HttpMethod.POST, \"/close-query\").handler(BodyHandler.create())\n+        .handler(this::handleCloseQuery);\n+    return router;\n+  }\n+\n+  private void handleInsertsStream(final RoutingContext routingContext) {\n+    RecordParser recordParser = RecordParser\n+        .newDelimited(\"\\n\", new InsertsBodyParser(endpoints, routingContext)::handleBodyBuffer);\n+    routingContext.request()\n+        .handler(recordParser);\n+  }\n+\n+  private void handleQueryStream(final RoutingContext routingContext) {\n+    HttpConnection conn = routingContext.request().connection();\n+    ConnectionQueries connectionQueries = connectionsMap.get(conn);\n+    if (connectionQueries == null) {\n+      connectionQueries = new ConnectionQueries(conn);\n+      connectionsMap.put(conn, connectionQueries);\n+      conn.closeHandler(connectionQueries);\n+      server.registerQueryConnection(conn);\n+    }\n+    JsonObject requestBody = routingContext.getBodyAsJson();\n+    String sql = requestBody.getString(\"sql\");\n+    if (sql == null) {\n+      handleError(routingContext.response(), 400, ERROR_CODE_MISSING_PARAM, \"No sql in arguments\");\n+      return;\n+    }\n+    Boolean push = requestBody.getBoolean(\"push\");\n+    if (push == null) {\n+      handleError(routingContext.response(), 400, ERROR_CODE_MISSING_PARAM, \"No push in arguments\");\n+      return;\n+    }\n+    JsonObject properties = requestBody.getJsonObject(\"properties\");\n+    QueryPublisher queryPublisher = endpoints.createQueryPublisher(sql, push, properties);\n+    QuerySubscriber querySubscriber = new QuerySubscriber(routingContext.response());\n+\n+    String queryID = server.registerQuery(querySubscriber);\n+    connectionQueries.addQuery(queryID);\n+    JsonObject metadata = new JsonObject();\n+    metadata.put(\"columnNames\", queryPublisher.getColumnNames());\n+    metadata.put(\"columnTypes\", queryPublisher.getColumnTypes());\n+    metadata.put(\"queryID\", queryID);\n+    if (!push) {\n+      metadata.put(\"rowCount\", queryPublisher.getRowCount());\n+    }\n+    routingContext.response().write(metadata.toBuffer()).write(\"\\n\");\n+    queryPublisher.subscribe(querySubscriber);\n+\n+    // When response is complete, publisher should be closed and query unregistered\n+    routingContext.response().endHandler(v -> closeQuery(queryID, routingContext));\n+  }\n+\n+  private boolean closeQuery(final String queryID, final RoutingContext routingContext) {\n+    QuerySubscriber querySubscriber = server.removeQuery(queryID);\n+    if (querySubscriber == null) {\n+      return false;", "originalCommit": "92ac3ce0feac9acd143b159b24e085c57ada49aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzUwNjc2MA==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r367506760", "bodyText": "It means the query wasn't found", "author": "purplefox", "createdAt": "2020-01-16T16:07:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQxMjYxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODYzMzc1NA==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r368633754", "bodyText": "lol!!!! I realize that!!!!\nI meant, what does returning false mean in the context of the return value, which is used here:\nroutingContext.response().endHandler(v -> closeQuery(queryID, routingContext));\n\nShould of been more clear! I guess what I mean was what does endHandler do with that boolean?", "author": "big-andy-coates", "createdAt": "2020-01-20T16:24:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQxMjYxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODYzNjQ4Ng==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r368636486", "bodyText": "The lambda you see there is the handler that is called when the response is ended. So, at response end we close the query. The return value of closeQuery is ignored in this case as we don't care in this case.", "author": "purplefox", "createdAt": "2020-01-20T16:30:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQxMjYxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODY1NzA4Nw==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r368657087", "bodyText": "Cool. Thanks for clarifying!", "author": "big-andy-coates", "createdAt": "2020-01-20T17:16:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQxMjYxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQxMzgxMA==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r367413810", "bodyText": "Might benefit from some javadocs explain the params.", "author": "big-andy-coates", "createdAt": "2020-01-16T13:24:05Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/spi/Endpoints.java", "diffHunk": "@@ -0,0 +1,33 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.spi;\n+\n+import io.vertx.core.json.JsonObject;\n+import org.reactivestreams.Subscriber;\n+\n+/**\n+ * In order to keep a clean separation between the plumbing of the API server and actual back-end\n+ * implementation of the endpoints we define this interface to encapsulate the actual endpoint\n+ * implementation.\n+ */\n+public interface Endpoints {", "originalCommit": "92ac3ce0feac9acd143b159b24e085c57ada49aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQxNTU3OA==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r367415578", "bodyText": "Are you up for adopting the Given/When/Then that everyone else in the team uses?  It can help really spell out what is setup, what is the exact bit under test, and what is expected outcome.  You've already added blank lines to separate by the looks of it, e.g. this test would become:\n@Test\n  public void shouldExecutePullQuery() throws Exception {\n    // Given:\n    JsonObject requestBody = new JsonObject().put(\"sql\", \"select * from foo\").put(\"push\", false);\n    JsonObject properties = new JsonObject().put(\"prop1\", \"val1\").put(\"prop2\", 23);\n    requestBody.put(\"properties\", properties);\n\n    // When:\n    HttpResponse<Buffer> response = sendRequest(\"/query-stream\", requestBody.toBuffer());\n\n    // Then:\n    assertEquals(200, response.statusCode());\n    assertEquals(\"OK\", response.statusMessage());\n    assertEquals(\"select * from foo\", testEndpoints.getLastSql());\n    assertFalse(testEndpoints.getLastPush());\n    assertEquals(properties, testEndpoints.getLastProperties());\n\n    QueryResponse queryResponse = new QueryResponse(response.bodyAsString());\n    assertEquals(DEFAULT_COLUMN_NAMES, queryResponse.responseObject.getJsonArray(\"columnNames\"));\n    assertEquals(DEFAULT_COLUMN_TYPES, queryResponse.responseObject.getJsonArray(\"columnTypes\"));\n    assertEquals(DEFAULT_ROWS, queryResponse.rows);\n    assertEquals(0, server.getQueryIDs().size());\n    String queryID = queryResponse.responseObject.getString(\"queryID\");\n    assertNotNull(queryID);\n    assertFalse(server.getQueryIDs().contains(queryID));\n    Integer rowCount = queryResponse.responseObject.getInteger(\"rowCount\");\n    assertNotNull(rowCount);\n    assertEquals(DEFAULT_ROWS.size(), rowCount.intValue());\n  }\nThis is obviously not enforced by any tooling, but it a widely used pattern by most of the newer tests in the code base.", "author": "big-andy-coates", "createdAt": "2020-01-16T13:27:49Z", "path": "ksql-api/src/test/java/io/confluent/ksql/api/ApiTest.java", "diffHunk": "@@ -0,0 +1,885 @@\n+/*\n+ * Copyright 2019 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api;\n+\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_INTERNAL_ERROR;\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_MISSING_PARAM;\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_UNKNOWN_QUERY_ID;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import io.confluent.ksql.api.TestQueryPublisher.ListRowGenerator;\n+import io.confluent.ksql.api.impl.VertxCompletableFuture;\n+import io.confluent.ksql.api.server.Server;\n+import io.vertx.codegen.annotations.Nullable;\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.HttpServerOptions;\n+import io.vertx.core.http.HttpVersion;\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.core.net.PemKeyCertOptions;\n+import io.vertx.core.streams.ReadStream;\n+import io.vertx.core.streams.WriteStream;\n+import io.vertx.ext.web.client.HttpResponse;\n+import io.vertx.ext.web.client.WebClient;\n+import io.vertx.ext.web.client.WebClientOptions;\n+import io.vertx.ext.web.codec.BodyCodec;\n+import java.io.FileNotFoundException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Supplier;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class ApiTest {\n+\n+  private static final long WAIT_TIMEOUT = 10000;\n+  private static final JsonArray DEFAULT_COLUMN_NAMES = new JsonArray().add(\"name\").add(\"age\")\n+      .add(\"male\");\n+  private static final JsonArray DEFAULT_COLUMN_TYPES = new JsonArray().add(\"STRING\").add(\"INT\")\n+      .add(\"BOOLEAN\");\n+  private static final List<JsonArray> DEFAULT_ROWS = generateRows();\n+\n+  private Vertx vertx;\n+  private Server server;\n+  private TestEndpoints testEndpoints;\n+  private WebClient client;\n+\n+  @Before\n+  public void setUp() throws Throwable {\n+\n+    vertx = Vertx.vertx();\n+\n+    HttpServerOptions httpServerOptions =\n+        new HttpServerOptions()\n+            .setHost(\"localhost\")\n+            .setPort(8089)\n+            .setUseAlpn(true)\n+            .setSsl(true)\n+            .setPemKeyCertOptions(\n+                new PemKeyCertOptions().setKeyPath(findFilePath(\"test-server-key.pem\"))\n+                    .setCertPath(findFilePath(\"test-server-cert.pem\"))\n+            );\n+\n+    testEndpoints = new TestEndpoints(vertx);\n+    JsonObject config = new JsonObject().put(\"verticle-instances\", 4);\n+    server = new Server(vertx, config, testEndpoints, httpServerOptions);\n+    server.start();\n+    client = createClient();\n+    setDefaultRowGenerator();\n+  }\n+\n+  @After\n+  public void tearDown() {\n+    if (client != null) {\n+      client.close();\n+    }\n+    if (server != null) {\n+      server.stop();\n+    }\n+  }\n+\n+  @Test\n+  public void shouldExecutePullQuery() throws Exception {\n+\n+    JsonObject requestBody = new JsonObject().put(\"sql\", \"select * from foo\").put(\"push\", false);\n+    JsonObject properties = new JsonObject().put(\"prop1\", \"val1\").put(\"prop2\", 23);\n+    requestBody.put(\"properties\", properties);\n+\n+    HttpResponse<Buffer> response = sendRequest(\"/query-stream\", requestBody.toBuffer());\n+\n+    assertEquals(200, response.statusCode());\n+    assertEquals(\"OK\", response.statusMessage());\n+    assertEquals(\"select * from foo\", testEndpoints.getLastSql());\n+    assertFalse(testEndpoints.getLastPush());\n+    assertEquals(properties, testEndpoints.getLastProperties());\n+\n+    QueryResponse queryResponse = new QueryResponse(response.bodyAsString());\n+    assertEquals(DEFAULT_COLUMN_NAMES, queryResponse.responseObject.getJsonArray(\"columnNames\"));\n+    assertEquals(DEFAULT_COLUMN_TYPES, queryResponse.responseObject.getJsonArray(\"columnTypes\"));\n+    assertEquals(DEFAULT_ROWS, queryResponse.rows);\n+    assertEquals(0, server.getQueryIDs().size());\n+    String queryID = queryResponse.responseObject.getString(\"queryID\");\n+    assertNotNull(queryID);\n+    assertFalse(server.getQueryIDs().contains(queryID));\n+    Integer rowCount = queryResponse.responseObject.getInteger(\"rowCount\");\n+    assertNotNull(rowCount);\n+    assertEquals(DEFAULT_ROWS.size(), rowCount.intValue());\n+  }\n+", "originalCommit": "92ac3ce0feac9acd143b159b24e085c57ada49aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU0ODQxNg==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r367548416", "bodyText": "Tbh, I find the given, when, then thing quite forced and simplistic. I can add it for some of the simpler tests.\nBut other tests won't fit so easily into this pattern. E.g. in some test I do things like start a bunch of push queries then do some asserts on the state, then I close the queries and do another bunch of asserts on the state. In this case there are multiple \"whens\" in the test .", "author": "purplefox", "createdAt": "2020-01-16T17:20:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQxNTU3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODExNjU0NA==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r368116544", "bodyText": "I've found the Given/When/Then pattern a forcing function to make tests simple. There are admittedly some tests that are way more difficult to write when following that pattern, but those should be the exception not the rule IMO.", "author": "agavra", "createdAt": "2020-01-17T20:11:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQxNTU3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODYzNDI1MQ==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r368634251", "bodyText": "Yep, that's its purpose. If you've got a test that doesn't fit, it generally means you're trying to test too much in one test and it would be better split into multiple.\n\nE.g. in some test I do things like start a bunch of push queries then do some asserts on the state, then I close the queries and do another bunch of asserts on the state. In this case there are multiple \"whens\" in the test .\n\nThat sounds like two tests: the first tests the newly created query is in the right state. A second test tests the query is in the right state once its closed.\nUnit tests should, ideally, only test a single thing, e.g. the state of a query after its closed.", "author": "big-andy-coates", "createdAt": "2020-01-20T16:25:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQxNTU3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQxNzkxMA==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r367417910", "bodyText": "Would you mind using the hamcrest matchers along with most others in the team? I appreciate this requires some time to skill up on, but the return is worth it IMHO.\nThey provide a lot more functionality and, importantly, tend to provide a lot more info when things fail, e.g.\nassertFalse(queryResponse.responseObject.containsKey(\"rowCount\"));\nWhen it fails will just say something like \"expected false, but was true\".\nHowever, hamcrest equivalent:\nassertThat(queryResponse.responseObject, hasKey(\"rowCount\"));\nWill fail with something like: \"Expected map to have key rowCount, actual keys: {rowcount, a, b}\".\nI hope you agree the latter is more helpful, especially when the test is only failing on the build server!!!\nI'll add some hamcrest equivalents below to get you started.", "author": "big-andy-coates", "createdAt": "2020-01-16T13:32:30Z", "path": "ksql-api/src/test/java/io/confluent/ksql/api/ApiTest.java", "diffHunk": "@@ -0,0 +1,885 @@\n+/*\n+ * Copyright 2019 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api;\n+\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_INTERNAL_ERROR;\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_MISSING_PARAM;\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_UNKNOWN_QUERY_ID;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import io.confluent.ksql.api.TestQueryPublisher.ListRowGenerator;\n+import io.confluent.ksql.api.impl.VertxCompletableFuture;\n+import io.confluent.ksql.api.server.Server;\n+import io.vertx.codegen.annotations.Nullable;\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.HttpServerOptions;\n+import io.vertx.core.http.HttpVersion;\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.core.net.PemKeyCertOptions;\n+import io.vertx.core.streams.ReadStream;\n+import io.vertx.core.streams.WriteStream;\n+import io.vertx.ext.web.client.HttpResponse;\n+import io.vertx.ext.web.client.WebClient;\n+import io.vertx.ext.web.client.WebClientOptions;\n+import io.vertx.ext.web.codec.BodyCodec;\n+import java.io.FileNotFoundException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Supplier;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class ApiTest {\n+\n+  private static final long WAIT_TIMEOUT = 10000;\n+  private static final JsonArray DEFAULT_COLUMN_NAMES = new JsonArray().add(\"name\").add(\"age\")\n+      .add(\"male\");\n+  private static final JsonArray DEFAULT_COLUMN_TYPES = new JsonArray().add(\"STRING\").add(\"INT\")\n+      .add(\"BOOLEAN\");\n+  private static final List<JsonArray> DEFAULT_ROWS = generateRows();\n+\n+  private Vertx vertx;\n+  private Server server;\n+  private TestEndpoints testEndpoints;\n+  private WebClient client;\n+\n+  @Before\n+  public void setUp() throws Throwable {\n+\n+    vertx = Vertx.vertx();\n+\n+    HttpServerOptions httpServerOptions =\n+        new HttpServerOptions()\n+            .setHost(\"localhost\")\n+            .setPort(8089)\n+            .setUseAlpn(true)\n+            .setSsl(true)\n+            .setPemKeyCertOptions(\n+                new PemKeyCertOptions().setKeyPath(findFilePath(\"test-server-key.pem\"))\n+                    .setCertPath(findFilePath(\"test-server-cert.pem\"))\n+            );\n+\n+    testEndpoints = new TestEndpoints(vertx);\n+    JsonObject config = new JsonObject().put(\"verticle-instances\", 4);\n+    server = new Server(vertx, config, testEndpoints, httpServerOptions);\n+    server.start();\n+    client = createClient();\n+    setDefaultRowGenerator();\n+  }\n+\n+  @After\n+  public void tearDown() {\n+    if (client != null) {\n+      client.close();\n+    }\n+    if (server != null) {\n+      server.stop();\n+    }\n+  }\n+\n+  @Test\n+  public void shouldExecutePullQuery() throws Exception {\n+\n+    JsonObject requestBody = new JsonObject().put(\"sql\", \"select * from foo\").put(\"push\", false);\n+    JsonObject properties = new JsonObject().put(\"prop1\", \"val1\").put(\"prop2\", 23);\n+    requestBody.put(\"properties\", properties);\n+\n+    HttpResponse<Buffer> response = sendRequest(\"/query-stream\", requestBody.toBuffer());\n+\n+    assertEquals(200, response.statusCode());\n+    assertEquals(\"OK\", response.statusMessage());\n+    assertEquals(\"select * from foo\", testEndpoints.getLastSql());\n+    assertFalse(testEndpoints.getLastPush());\n+    assertEquals(properties, testEndpoints.getLastProperties());\n+\n+    QueryResponse queryResponse = new QueryResponse(response.bodyAsString());\n+    assertEquals(DEFAULT_COLUMN_NAMES, queryResponse.responseObject.getJsonArray(\"columnNames\"));\n+    assertEquals(DEFAULT_COLUMN_TYPES, queryResponse.responseObject.getJsonArray(\"columnTypes\"));\n+    assertEquals(DEFAULT_ROWS, queryResponse.rows);\n+    assertEquals(0, server.getQueryIDs().size());\n+    String queryID = queryResponse.responseObject.getString(\"queryID\");\n+    assertNotNull(queryID);\n+    assertFalse(server.getQueryIDs().contains(queryID));\n+    Integer rowCount = queryResponse.responseObject.getInteger(\"rowCount\");\n+    assertNotNull(rowCount);\n+    assertEquals(DEFAULT_ROWS.size(), rowCount.intValue());\n+  }\n+\n+  @Test\n+  public void shouldExecutePushQuery() throws Exception {\n+\n+    JsonObject requestBody = new JsonObject().put(\"sql\", \"select * from foo\").put(\"push\", true);\n+    JsonObject properties = new JsonObject().put(\"prop1\", \"val1\").put(\"prop2\", 23);\n+    requestBody.put(\"properties\", properties);\n+\n+    QueryResponse queryResponse = executePushQueryAndWaitForRows(requestBody);\n+\n+    assertEquals(\"select * from foo\", testEndpoints.getLastSql());\n+    assertTrue(testEndpoints.getLastPush());\n+    assertEquals(properties, testEndpoints.getLastProperties());\n+\n+    assertEquals(DEFAULT_COLUMN_NAMES, queryResponse.responseObject.getJsonArray(\"columnNames\"));\n+    assertEquals(DEFAULT_COLUMN_TYPES, queryResponse.responseObject.getJsonArray(\"columnTypes\"));\n+    assertEquals(DEFAULT_ROWS, queryResponse.rows);\n+    assertEquals(1, server.getQueryIDs().size());\n+    String queryID = queryResponse.responseObject.getString(\"queryID\");\n+    assertNotNull(queryID);\n+    assertTrue(server.getQueryIDs().contains(queryID));\n+    assertFalse(queryResponse.responseObject.containsKey(\"rowCount\"));\n+  }", "originalCommit": "92ac3ce0feac9acd143b159b24e085c57ada49aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU1NzI5OA==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r367557298", "bodyText": "I agree that Hamcrest can provide better error messages, but we write or refactor tests way more often than tests fail on build servers. Imho, we should optimise for ease of writing/refactoring tests not for good error messages. Hamcrest does the latter, and I find tests way harder to write with it. Imho that's not a good optimisation.", "author": "purplefox", "createdAt": "2020-01-16T17:39:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQxNzkxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU1NzcyNw==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r367557727", "bodyText": "Imho Junit is clear, simple and straight to the point. Anyone can understand and build a new Junit assert without any special knowledge of the library. Invoking KISS principle ;)", "author": "purplefox", "createdAt": "2020-01-16T17:40:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQxNzkxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU4NTUxNA==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r367585514", "bodyText": "#4332", "author": "purplefox", "createdAt": "2020-01-16T18:42:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQxNzkxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQxODQ2Mw==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r367418463", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  assertEquals(i + 1, server.getQueryIDs().size());\n          \n          \n            \n                  assertThat(server.getQueryIDs(), hasSize(i + 1));", "author": "big-andy-coates", "createdAt": "2020-01-16T13:33:39Z", "path": "ksql-api/src/test/java/io/confluent/ksql/api/ApiTest.java", "diffHunk": "@@ -0,0 +1,885 @@\n+/*\n+ * Copyright 2019 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api;\n+\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_INTERNAL_ERROR;\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_MISSING_PARAM;\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_UNKNOWN_QUERY_ID;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import io.confluent.ksql.api.TestQueryPublisher.ListRowGenerator;\n+import io.confluent.ksql.api.impl.VertxCompletableFuture;\n+import io.confluent.ksql.api.server.Server;\n+import io.vertx.codegen.annotations.Nullable;\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.HttpServerOptions;\n+import io.vertx.core.http.HttpVersion;\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.core.net.PemKeyCertOptions;\n+import io.vertx.core.streams.ReadStream;\n+import io.vertx.core.streams.WriteStream;\n+import io.vertx.ext.web.client.HttpResponse;\n+import io.vertx.ext.web.client.WebClient;\n+import io.vertx.ext.web.client.WebClientOptions;\n+import io.vertx.ext.web.codec.BodyCodec;\n+import java.io.FileNotFoundException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Supplier;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class ApiTest {\n+\n+  private static final long WAIT_TIMEOUT = 10000;\n+  private static final JsonArray DEFAULT_COLUMN_NAMES = new JsonArray().add(\"name\").add(\"age\")\n+      .add(\"male\");\n+  private static final JsonArray DEFAULT_COLUMN_TYPES = new JsonArray().add(\"STRING\").add(\"INT\")\n+      .add(\"BOOLEAN\");\n+  private static final List<JsonArray> DEFAULT_ROWS = generateRows();\n+\n+  private Vertx vertx;\n+  private Server server;\n+  private TestEndpoints testEndpoints;\n+  private WebClient client;\n+\n+  @Before\n+  public void setUp() throws Throwable {\n+\n+    vertx = Vertx.vertx();\n+\n+    HttpServerOptions httpServerOptions =\n+        new HttpServerOptions()\n+            .setHost(\"localhost\")\n+            .setPort(8089)\n+            .setUseAlpn(true)\n+            .setSsl(true)\n+            .setPemKeyCertOptions(\n+                new PemKeyCertOptions().setKeyPath(findFilePath(\"test-server-key.pem\"))\n+                    .setCertPath(findFilePath(\"test-server-cert.pem\"))\n+            );\n+\n+    testEndpoints = new TestEndpoints(vertx);\n+    JsonObject config = new JsonObject().put(\"verticle-instances\", 4);\n+    server = new Server(vertx, config, testEndpoints, httpServerOptions);\n+    server.start();\n+    client = createClient();\n+    setDefaultRowGenerator();\n+  }\n+\n+  @After\n+  public void tearDown() {\n+    if (client != null) {\n+      client.close();\n+    }\n+    if (server != null) {\n+      server.stop();\n+    }\n+  }\n+\n+  @Test\n+  public void shouldExecutePullQuery() throws Exception {\n+\n+    JsonObject requestBody = new JsonObject().put(\"sql\", \"select * from foo\").put(\"push\", false);\n+    JsonObject properties = new JsonObject().put(\"prop1\", \"val1\").put(\"prop2\", 23);\n+    requestBody.put(\"properties\", properties);\n+\n+    HttpResponse<Buffer> response = sendRequest(\"/query-stream\", requestBody.toBuffer());\n+\n+    assertEquals(200, response.statusCode());\n+    assertEquals(\"OK\", response.statusMessage());\n+    assertEquals(\"select * from foo\", testEndpoints.getLastSql());\n+    assertFalse(testEndpoints.getLastPush());\n+    assertEquals(properties, testEndpoints.getLastProperties());\n+\n+    QueryResponse queryResponse = new QueryResponse(response.bodyAsString());\n+    assertEquals(DEFAULT_COLUMN_NAMES, queryResponse.responseObject.getJsonArray(\"columnNames\"));\n+    assertEquals(DEFAULT_COLUMN_TYPES, queryResponse.responseObject.getJsonArray(\"columnTypes\"));\n+    assertEquals(DEFAULT_ROWS, queryResponse.rows);\n+    assertEquals(0, server.getQueryIDs().size());\n+    String queryID = queryResponse.responseObject.getString(\"queryID\");\n+    assertNotNull(queryID);\n+    assertFalse(server.getQueryIDs().contains(queryID));\n+    Integer rowCount = queryResponse.responseObject.getInteger(\"rowCount\");\n+    assertNotNull(rowCount);\n+    assertEquals(DEFAULT_ROWS.size(), rowCount.intValue());\n+  }\n+\n+  @Test\n+  public void shouldExecutePushQuery() throws Exception {\n+\n+    JsonObject requestBody = new JsonObject().put(\"sql\", \"select * from foo\").put(\"push\", true);\n+    JsonObject properties = new JsonObject().put(\"prop1\", \"val1\").put(\"prop2\", 23);\n+    requestBody.put(\"properties\", properties);\n+\n+    QueryResponse queryResponse = executePushQueryAndWaitForRows(requestBody);\n+\n+    assertEquals(\"select * from foo\", testEndpoints.getLastSql());\n+    assertTrue(testEndpoints.getLastPush());\n+    assertEquals(properties, testEndpoints.getLastProperties());\n+\n+    assertEquals(DEFAULT_COLUMN_NAMES, queryResponse.responseObject.getJsonArray(\"columnNames\"));\n+    assertEquals(DEFAULT_COLUMN_TYPES, queryResponse.responseObject.getJsonArray(\"columnTypes\"));\n+    assertEquals(DEFAULT_ROWS, queryResponse.rows);\n+    assertEquals(1, server.getQueryIDs().size());\n+    String queryID = queryResponse.responseObject.getString(\"queryID\");\n+    assertNotNull(queryID);\n+    assertTrue(server.getQueryIDs().contains(queryID));\n+    assertFalse(queryResponse.responseObject.containsKey(\"rowCount\"));\n+  }\n+\n+  @Test\n+  public void shouldExecuteMultiplePushQueries() throws Exception {\n+\n+    JsonObject requestBody = new JsonObject().put(\"sql\", \"select * from foo\").put(\"push\", true);\n+    JsonObject properties = new JsonObject().put(\"prop1\", \"val1\").put(\"prop2\", 23);\n+    requestBody.put(\"properties\", properties);\n+\n+    int numQueries = 10;\n+    for (int i = 0; i < numQueries; i++) {\n+      QueryResponse queryResponse = executePushQueryAndWaitForRows(requestBody);\n+      assertEquals(i + 1, server.getQueryIDs().size());", "originalCommit": "92ac3ce0feac9acd143b159b24e085c57ada49aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQxODYxNQ==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r367418615", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  assertNotNull(queryID);\n          \n          \n            \n                  assertThat(queryID, is(notNullValue()));", "author": "big-andy-coates", "createdAt": "2020-01-16T13:33:59Z", "path": "ksql-api/src/test/java/io/confluent/ksql/api/ApiTest.java", "diffHunk": "@@ -0,0 +1,885 @@\n+/*\n+ * Copyright 2019 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api;\n+\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_INTERNAL_ERROR;\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_MISSING_PARAM;\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_UNKNOWN_QUERY_ID;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import io.confluent.ksql.api.TestQueryPublisher.ListRowGenerator;\n+import io.confluent.ksql.api.impl.VertxCompletableFuture;\n+import io.confluent.ksql.api.server.Server;\n+import io.vertx.codegen.annotations.Nullable;\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.HttpServerOptions;\n+import io.vertx.core.http.HttpVersion;\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.core.net.PemKeyCertOptions;\n+import io.vertx.core.streams.ReadStream;\n+import io.vertx.core.streams.WriteStream;\n+import io.vertx.ext.web.client.HttpResponse;\n+import io.vertx.ext.web.client.WebClient;\n+import io.vertx.ext.web.client.WebClientOptions;\n+import io.vertx.ext.web.codec.BodyCodec;\n+import java.io.FileNotFoundException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Supplier;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class ApiTest {\n+\n+  private static final long WAIT_TIMEOUT = 10000;\n+  private static final JsonArray DEFAULT_COLUMN_NAMES = new JsonArray().add(\"name\").add(\"age\")\n+      .add(\"male\");\n+  private static final JsonArray DEFAULT_COLUMN_TYPES = new JsonArray().add(\"STRING\").add(\"INT\")\n+      .add(\"BOOLEAN\");\n+  private static final List<JsonArray> DEFAULT_ROWS = generateRows();\n+\n+  private Vertx vertx;\n+  private Server server;\n+  private TestEndpoints testEndpoints;\n+  private WebClient client;\n+\n+  @Before\n+  public void setUp() throws Throwable {\n+\n+    vertx = Vertx.vertx();\n+\n+    HttpServerOptions httpServerOptions =\n+        new HttpServerOptions()\n+            .setHost(\"localhost\")\n+            .setPort(8089)\n+            .setUseAlpn(true)\n+            .setSsl(true)\n+            .setPemKeyCertOptions(\n+                new PemKeyCertOptions().setKeyPath(findFilePath(\"test-server-key.pem\"))\n+                    .setCertPath(findFilePath(\"test-server-cert.pem\"))\n+            );\n+\n+    testEndpoints = new TestEndpoints(vertx);\n+    JsonObject config = new JsonObject().put(\"verticle-instances\", 4);\n+    server = new Server(vertx, config, testEndpoints, httpServerOptions);\n+    server.start();\n+    client = createClient();\n+    setDefaultRowGenerator();\n+  }\n+\n+  @After\n+  public void tearDown() {\n+    if (client != null) {\n+      client.close();\n+    }\n+    if (server != null) {\n+      server.stop();\n+    }\n+  }\n+\n+  @Test\n+  public void shouldExecutePullQuery() throws Exception {\n+\n+    JsonObject requestBody = new JsonObject().put(\"sql\", \"select * from foo\").put(\"push\", false);\n+    JsonObject properties = new JsonObject().put(\"prop1\", \"val1\").put(\"prop2\", 23);\n+    requestBody.put(\"properties\", properties);\n+\n+    HttpResponse<Buffer> response = sendRequest(\"/query-stream\", requestBody.toBuffer());\n+\n+    assertEquals(200, response.statusCode());\n+    assertEquals(\"OK\", response.statusMessage());\n+    assertEquals(\"select * from foo\", testEndpoints.getLastSql());\n+    assertFalse(testEndpoints.getLastPush());\n+    assertEquals(properties, testEndpoints.getLastProperties());\n+\n+    QueryResponse queryResponse = new QueryResponse(response.bodyAsString());\n+    assertEquals(DEFAULT_COLUMN_NAMES, queryResponse.responseObject.getJsonArray(\"columnNames\"));\n+    assertEquals(DEFAULT_COLUMN_TYPES, queryResponse.responseObject.getJsonArray(\"columnTypes\"));\n+    assertEquals(DEFAULT_ROWS, queryResponse.rows);\n+    assertEquals(0, server.getQueryIDs().size());\n+    String queryID = queryResponse.responseObject.getString(\"queryID\");\n+    assertNotNull(queryID);\n+    assertFalse(server.getQueryIDs().contains(queryID));\n+    Integer rowCount = queryResponse.responseObject.getInteger(\"rowCount\");\n+    assertNotNull(rowCount);\n+    assertEquals(DEFAULT_ROWS.size(), rowCount.intValue());\n+  }\n+\n+  @Test\n+  public void shouldExecutePushQuery() throws Exception {\n+\n+    JsonObject requestBody = new JsonObject().put(\"sql\", \"select * from foo\").put(\"push\", true);\n+    JsonObject properties = new JsonObject().put(\"prop1\", \"val1\").put(\"prop2\", 23);\n+    requestBody.put(\"properties\", properties);\n+\n+    QueryResponse queryResponse = executePushQueryAndWaitForRows(requestBody);\n+\n+    assertEquals(\"select * from foo\", testEndpoints.getLastSql());\n+    assertTrue(testEndpoints.getLastPush());\n+    assertEquals(properties, testEndpoints.getLastProperties());\n+\n+    assertEquals(DEFAULT_COLUMN_NAMES, queryResponse.responseObject.getJsonArray(\"columnNames\"));\n+    assertEquals(DEFAULT_COLUMN_TYPES, queryResponse.responseObject.getJsonArray(\"columnTypes\"));\n+    assertEquals(DEFAULT_ROWS, queryResponse.rows);\n+    assertEquals(1, server.getQueryIDs().size());\n+    String queryID = queryResponse.responseObject.getString(\"queryID\");\n+    assertNotNull(queryID);\n+    assertTrue(server.getQueryIDs().contains(queryID));\n+    assertFalse(queryResponse.responseObject.containsKey(\"rowCount\"));\n+  }\n+\n+  @Test\n+  public void shouldExecuteMultiplePushQueries() throws Exception {\n+\n+    JsonObject requestBody = new JsonObject().put(\"sql\", \"select * from foo\").put(\"push\", true);\n+    JsonObject properties = new JsonObject().put(\"prop1\", \"val1\").put(\"prop2\", 23);\n+    requestBody.put(\"properties\", properties);\n+\n+    int numQueries = 10;\n+    for (int i = 0; i < numQueries; i++) {\n+      QueryResponse queryResponse = executePushQueryAndWaitForRows(requestBody);\n+      assertEquals(i + 1, server.getQueryIDs().size());\n+      String queryID = queryResponse.responseObject.getString(\"queryID\");\n+      assertNotNull(queryID);", "originalCommit": "92ac3ce0feac9acd143b159b24e085c57ada49aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQxODgzMQ==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r367418831", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  assertTrue(server.getQueryIDs().contains(queryID));\n          \n          \n            \n                  assertThat(server.getQueryIDs(), hasItem(queryID));", "author": "big-andy-coates", "createdAt": "2020-01-16T13:34:29Z", "path": "ksql-api/src/test/java/io/confluent/ksql/api/ApiTest.java", "diffHunk": "@@ -0,0 +1,885 @@\n+/*\n+ * Copyright 2019 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api;\n+\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_INTERNAL_ERROR;\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_MISSING_PARAM;\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_UNKNOWN_QUERY_ID;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import io.confluent.ksql.api.TestQueryPublisher.ListRowGenerator;\n+import io.confluent.ksql.api.impl.VertxCompletableFuture;\n+import io.confluent.ksql.api.server.Server;\n+import io.vertx.codegen.annotations.Nullable;\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.HttpServerOptions;\n+import io.vertx.core.http.HttpVersion;\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.core.net.PemKeyCertOptions;\n+import io.vertx.core.streams.ReadStream;\n+import io.vertx.core.streams.WriteStream;\n+import io.vertx.ext.web.client.HttpResponse;\n+import io.vertx.ext.web.client.WebClient;\n+import io.vertx.ext.web.client.WebClientOptions;\n+import io.vertx.ext.web.codec.BodyCodec;\n+import java.io.FileNotFoundException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Supplier;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class ApiTest {\n+\n+  private static final long WAIT_TIMEOUT = 10000;\n+  private static final JsonArray DEFAULT_COLUMN_NAMES = new JsonArray().add(\"name\").add(\"age\")\n+      .add(\"male\");\n+  private static final JsonArray DEFAULT_COLUMN_TYPES = new JsonArray().add(\"STRING\").add(\"INT\")\n+      .add(\"BOOLEAN\");\n+  private static final List<JsonArray> DEFAULT_ROWS = generateRows();\n+\n+  private Vertx vertx;\n+  private Server server;\n+  private TestEndpoints testEndpoints;\n+  private WebClient client;\n+\n+  @Before\n+  public void setUp() throws Throwable {\n+\n+    vertx = Vertx.vertx();\n+\n+    HttpServerOptions httpServerOptions =\n+        new HttpServerOptions()\n+            .setHost(\"localhost\")\n+            .setPort(8089)\n+            .setUseAlpn(true)\n+            .setSsl(true)\n+            .setPemKeyCertOptions(\n+                new PemKeyCertOptions().setKeyPath(findFilePath(\"test-server-key.pem\"))\n+                    .setCertPath(findFilePath(\"test-server-cert.pem\"))\n+            );\n+\n+    testEndpoints = new TestEndpoints(vertx);\n+    JsonObject config = new JsonObject().put(\"verticle-instances\", 4);\n+    server = new Server(vertx, config, testEndpoints, httpServerOptions);\n+    server.start();\n+    client = createClient();\n+    setDefaultRowGenerator();\n+  }\n+\n+  @After\n+  public void tearDown() {\n+    if (client != null) {\n+      client.close();\n+    }\n+    if (server != null) {\n+      server.stop();\n+    }\n+  }\n+\n+  @Test\n+  public void shouldExecutePullQuery() throws Exception {\n+\n+    JsonObject requestBody = new JsonObject().put(\"sql\", \"select * from foo\").put(\"push\", false);\n+    JsonObject properties = new JsonObject().put(\"prop1\", \"val1\").put(\"prop2\", 23);\n+    requestBody.put(\"properties\", properties);\n+\n+    HttpResponse<Buffer> response = sendRequest(\"/query-stream\", requestBody.toBuffer());\n+\n+    assertEquals(200, response.statusCode());\n+    assertEquals(\"OK\", response.statusMessage());\n+    assertEquals(\"select * from foo\", testEndpoints.getLastSql());\n+    assertFalse(testEndpoints.getLastPush());\n+    assertEquals(properties, testEndpoints.getLastProperties());\n+\n+    QueryResponse queryResponse = new QueryResponse(response.bodyAsString());\n+    assertEquals(DEFAULT_COLUMN_NAMES, queryResponse.responseObject.getJsonArray(\"columnNames\"));\n+    assertEquals(DEFAULT_COLUMN_TYPES, queryResponse.responseObject.getJsonArray(\"columnTypes\"));\n+    assertEquals(DEFAULT_ROWS, queryResponse.rows);\n+    assertEquals(0, server.getQueryIDs().size());\n+    String queryID = queryResponse.responseObject.getString(\"queryID\");\n+    assertNotNull(queryID);\n+    assertFalse(server.getQueryIDs().contains(queryID));\n+    Integer rowCount = queryResponse.responseObject.getInteger(\"rowCount\");\n+    assertNotNull(rowCount);\n+    assertEquals(DEFAULT_ROWS.size(), rowCount.intValue());\n+  }\n+\n+  @Test\n+  public void shouldExecutePushQuery() throws Exception {\n+\n+    JsonObject requestBody = new JsonObject().put(\"sql\", \"select * from foo\").put(\"push\", true);\n+    JsonObject properties = new JsonObject().put(\"prop1\", \"val1\").put(\"prop2\", 23);\n+    requestBody.put(\"properties\", properties);\n+\n+    QueryResponse queryResponse = executePushQueryAndWaitForRows(requestBody);\n+\n+    assertEquals(\"select * from foo\", testEndpoints.getLastSql());\n+    assertTrue(testEndpoints.getLastPush());\n+    assertEquals(properties, testEndpoints.getLastProperties());\n+\n+    assertEquals(DEFAULT_COLUMN_NAMES, queryResponse.responseObject.getJsonArray(\"columnNames\"));\n+    assertEquals(DEFAULT_COLUMN_TYPES, queryResponse.responseObject.getJsonArray(\"columnTypes\"));\n+    assertEquals(DEFAULT_ROWS, queryResponse.rows);\n+    assertEquals(1, server.getQueryIDs().size());\n+    String queryID = queryResponse.responseObject.getString(\"queryID\");\n+    assertNotNull(queryID);\n+    assertTrue(server.getQueryIDs().contains(queryID));\n+    assertFalse(queryResponse.responseObject.containsKey(\"rowCount\"));\n+  }\n+\n+  @Test\n+  public void shouldExecuteMultiplePushQueries() throws Exception {\n+\n+    JsonObject requestBody = new JsonObject().put(\"sql\", \"select * from foo\").put(\"push\", true);\n+    JsonObject properties = new JsonObject().put(\"prop1\", \"val1\").put(\"prop2\", 23);\n+    requestBody.put(\"properties\", properties);\n+\n+    int numQueries = 10;\n+    for (int i = 0; i < numQueries; i++) {\n+      QueryResponse queryResponse = executePushQueryAndWaitForRows(requestBody);\n+      assertEquals(i + 1, server.getQueryIDs().size());\n+      String queryID = queryResponse.responseObject.getString(\"queryID\");\n+      assertNotNull(queryID);\n+      assertTrue(server.getQueryIDs().contains(queryID));", "originalCommit": "92ac3ce0feac9acd143b159b24e085c57ada49aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQxOTM2Mw==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r367419363", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                assertEquals(400, response.statusCode());\n          \n          \n            \n                assertThat(response.statusCode(), is(HttpStatus.SC_BAD_REQUEST));", "author": "big-andy-coates", "createdAt": "2020-01-16T13:35:39Z", "path": "ksql-api/src/test/java/io/confluent/ksql/api/ApiTest.java", "diffHunk": "@@ -0,0 +1,885 @@\n+/*\n+ * Copyright 2019 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api;\n+\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_INTERNAL_ERROR;\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_MISSING_PARAM;\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_UNKNOWN_QUERY_ID;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import io.confluent.ksql.api.TestQueryPublisher.ListRowGenerator;\n+import io.confluent.ksql.api.impl.VertxCompletableFuture;\n+import io.confluent.ksql.api.server.Server;\n+import io.vertx.codegen.annotations.Nullable;\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.HttpServerOptions;\n+import io.vertx.core.http.HttpVersion;\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.core.net.PemKeyCertOptions;\n+import io.vertx.core.streams.ReadStream;\n+import io.vertx.core.streams.WriteStream;\n+import io.vertx.ext.web.client.HttpResponse;\n+import io.vertx.ext.web.client.WebClient;\n+import io.vertx.ext.web.client.WebClientOptions;\n+import io.vertx.ext.web.codec.BodyCodec;\n+import java.io.FileNotFoundException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Supplier;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class ApiTest {\n+\n+  private static final long WAIT_TIMEOUT = 10000;\n+  private static final JsonArray DEFAULT_COLUMN_NAMES = new JsonArray().add(\"name\").add(\"age\")\n+      .add(\"male\");\n+  private static final JsonArray DEFAULT_COLUMN_TYPES = new JsonArray().add(\"STRING\").add(\"INT\")\n+      .add(\"BOOLEAN\");\n+  private static final List<JsonArray> DEFAULT_ROWS = generateRows();\n+\n+  private Vertx vertx;\n+  private Server server;\n+  private TestEndpoints testEndpoints;\n+  private WebClient client;\n+\n+  @Before\n+  public void setUp() throws Throwable {\n+\n+    vertx = Vertx.vertx();\n+\n+    HttpServerOptions httpServerOptions =\n+        new HttpServerOptions()\n+            .setHost(\"localhost\")\n+            .setPort(8089)\n+            .setUseAlpn(true)\n+            .setSsl(true)\n+            .setPemKeyCertOptions(\n+                new PemKeyCertOptions().setKeyPath(findFilePath(\"test-server-key.pem\"))\n+                    .setCertPath(findFilePath(\"test-server-cert.pem\"))\n+            );\n+\n+    testEndpoints = new TestEndpoints(vertx);\n+    JsonObject config = new JsonObject().put(\"verticle-instances\", 4);\n+    server = new Server(vertx, config, testEndpoints, httpServerOptions);\n+    server.start();\n+    client = createClient();\n+    setDefaultRowGenerator();\n+  }\n+\n+  @After\n+  public void tearDown() {\n+    if (client != null) {\n+      client.close();\n+    }\n+    if (server != null) {\n+      server.stop();\n+    }\n+  }\n+\n+  @Test\n+  public void shouldExecutePullQuery() throws Exception {\n+\n+    JsonObject requestBody = new JsonObject().put(\"sql\", \"select * from foo\").put(\"push\", false);\n+    JsonObject properties = new JsonObject().put(\"prop1\", \"val1\").put(\"prop2\", 23);\n+    requestBody.put(\"properties\", properties);\n+\n+    HttpResponse<Buffer> response = sendRequest(\"/query-stream\", requestBody.toBuffer());\n+\n+    assertEquals(200, response.statusCode());\n+    assertEquals(\"OK\", response.statusMessage());\n+    assertEquals(\"select * from foo\", testEndpoints.getLastSql());\n+    assertFalse(testEndpoints.getLastPush());\n+    assertEquals(properties, testEndpoints.getLastProperties());\n+\n+    QueryResponse queryResponse = new QueryResponse(response.bodyAsString());\n+    assertEquals(DEFAULT_COLUMN_NAMES, queryResponse.responseObject.getJsonArray(\"columnNames\"));\n+    assertEquals(DEFAULT_COLUMN_TYPES, queryResponse.responseObject.getJsonArray(\"columnTypes\"));\n+    assertEquals(DEFAULT_ROWS, queryResponse.rows);\n+    assertEquals(0, server.getQueryIDs().size());\n+    String queryID = queryResponse.responseObject.getString(\"queryID\");\n+    assertNotNull(queryID);\n+    assertFalse(server.getQueryIDs().contains(queryID));\n+    Integer rowCount = queryResponse.responseObject.getInteger(\"rowCount\");\n+    assertNotNull(rowCount);\n+    assertEquals(DEFAULT_ROWS.size(), rowCount.intValue());\n+  }\n+\n+  @Test\n+  public void shouldExecutePushQuery() throws Exception {\n+\n+    JsonObject requestBody = new JsonObject().put(\"sql\", \"select * from foo\").put(\"push\", true);\n+    JsonObject properties = new JsonObject().put(\"prop1\", \"val1\").put(\"prop2\", 23);\n+    requestBody.put(\"properties\", properties);\n+\n+    QueryResponse queryResponse = executePushQueryAndWaitForRows(requestBody);\n+\n+    assertEquals(\"select * from foo\", testEndpoints.getLastSql());\n+    assertTrue(testEndpoints.getLastPush());\n+    assertEquals(properties, testEndpoints.getLastProperties());\n+\n+    assertEquals(DEFAULT_COLUMN_NAMES, queryResponse.responseObject.getJsonArray(\"columnNames\"));\n+    assertEquals(DEFAULT_COLUMN_TYPES, queryResponse.responseObject.getJsonArray(\"columnTypes\"));\n+    assertEquals(DEFAULT_ROWS, queryResponse.rows);\n+    assertEquals(1, server.getQueryIDs().size());\n+    String queryID = queryResponse.responseObject.getString(\"queryID\");\n+    assertNotNull(queryID);\n+    assertTrue(server.getQueryIDs().contains(queryID));\n+    assertFalse(queryResponse.responseObject.containsKey(\"rowCount\"));\n+  }\n+\n+  @Test\n+  public void shouldExecuteMultiplePushQueries() throws Exception {\n+\n+    JsonObject requestBody = new JsonObject().put(\"sql\", \"select * from foo\").put(\"push\", true);\n+    JsonObject properties = new JsonObject().put(\"prop1\", \"val1\").put(\"prop2\", 23);\n+    requestBody.put(\"properties\", properties);\n+\n+    int numQueries = 10;\n+    for (int i = 0; i < numQueries; i++) {\n+      QueryResponse queryResponse = executePushQueryAndWaitForRows(requestBody);\n+      assertEquals(i + 1, server.getQueryIDs().size());\n+      String queryID = queryResponse.responseObject.getString(\"queryID\");\n+      assertNotNull(queryID);\n+      assertTrue(server.getQueryIDs().contains(queryID));\n+    }\n+  }\n+\n+  @Test\n+  public void shouldCloseQueriesOnDifferentConnectionsWhenConnectionsAreClosed() throws Exception {\n+\n+    JsonObject requestBody = new JsonObject().put(\"sql\", \"select * from foo\").put(\"push\", true);\n+    JsonObject properties = new JsonObject().put(\"prop1\", \"val1\").put(\"prop2\", 23);\n+    requestBody.put(\"properties\", properties);\n+\n+    int numQueries = 10;\n+    List<WebClient> clients = new ArrayList<>();\n+    for (int i = 0; i < numQueries; i++) {\n+      // We use different clients to ensure requests are sent on different connections\n+      WebClient client = createClient();\n+      clients.add(client);\n+      QueryResponse queryResponse = executePushQueryAndWaitForRows(client, requestBody);\n+      String queryID = queryResponse.responseObject.getString(\"queryID\");\n+      assertNotNull(queryID);\n+      assertTrue(server.getQueryIDs().contains(queryID));\n+      assertEquals(i + 1, server.getQueryIDs().size());\n+      assertEquals(i + 1, server.queryConnectionCount());\n+    }\n+    assertAllQueries(numQueries, true);\n+\n+    int count = 0;\n+    for (WebClient client : clients) {\n+      client.close();\n+      int num = numQueries - count - 1;\n+      assertTrue(waitUntil(() -> server.queryConnectionCount() == num));\n+      assertEquals(num, server.getQueryIDs().size());\n+      count++;\n+    }\n+    assertAllQueries(numQueries, false);\n+  }\n+\n+  @Test\n+  public void shouldCloseQueriesOnSameConnectionsWhenConnectionsAreClosed() throws Exception {\n+\n+    JsonObject requestBody = new JsonObject().put(\"sql\", \"select * from foo\").put(\"push\", true);\n+    JsonObject properties = new JsonObject().put(\"prop1\", \"val1\").put(\"prop2\", 23);\n+    requestBody.put(\"properties\", properties);\n+\n+    int numQueries = 10;\n+    for (int i = 0; i < numQueries; i++) {\n+      QueryResponse queryResponse = executePushQueryAndWaitForRows(requestBody);\n+      String queryID = queryResponse.responseObject.getString(\"queryID\");\n+      assertNotNull(queryID);\n+      assertTrue(server.getQueryIDs().contains(queryID));\n+      assertEquals(i + 1, server.getQueryIDs().size());\n+    }\n+    assertEquals(1, server.queryConnectionCount());\n+    assertAllQueries(numQueries, true);\n+\n+    client.close();\n+    assertTrue(waitUntil(() -> server.queryConnectionCount() == 0));\n+    assertTrue(server.getQueryIDs().isEmpty());\n+    client = null;\n+\n+    assertAllQueries(numQueries, false);\n+  }\n+\n+  @Test\n+  public void shouldCloseMultipleQueriesOnDifferentConnectionsWhenConnectionsAreClosed()\n+      throws Exception {\n+\n+    JsonObject requestBody = new JsonObject().put(\"sql\", \"select * from foo\").put(\"push\", true);\n+    JsonObject properties = new JsonObject().put(\"prop1\", \"val1\").put(\"prop2\", 23);\n+    requestBody.put(\"properties\", properties);\n+\n+    int numConnections = 5;\n+    int numQueries = 5;\n+    List<WebClient> clients = new ArrayList<>();\n+    for (int i = 0; i < numConnections; i++) {\n+      WebClient client = createClient();\n+      clients.add(client);\n+      for (int j = 0; j < numQueries; j++) {\n+        QueryResponse queryResponse = executePushQueryAndWaitForRows(client, requestBody);\n+        String queryID = queryResponse.responseObject.getString(\"queryID\");\n+        assertNotNull(queryID);\n+        assertTrue(server.getQueryIDs().contains(queryID));\n+        int queries = i * numQueries + j + 1;\n+        assertEquals(i * numQueries + j + 1, server.getQueryIDs().size());\n+        assertEquals(i + 1, server.queryConnectionCount());\n+        assertAllQueries(queries, true);\n+      }\n+    }\n+\n+    int count = 0;\n+    for (WebClient client : clients) {\n+      client.close();\n+      int connections = numConnections - count - 1;\n+      assertTrue(waitUntil(() -> server.queryConnectionCount() == connections));\n+      assertEquals(numQueries * connections, server.getQueryIDs().size());\n+      count++;\n+    }\n+\n+    assertAllQueries(numConnections * numQueries, false);\n+  }\n+\n+  @Test\n+  public void shouldHandleQueryWithMissingSql() throws Exception {\n+\n+    JsonObject requestBody = new JsonObject().put(\"foo\", \"bar\");\n+\n+    HttpResponse<Buffer> response = sendRequest(\"/query-stream\", requestBody.toBuffer());\n+\n+    assertEquals(400, response.statusCode());", "originalCommit": "92ac3ce0feac9acd143b159b24e085c57ada49aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQyODEzOA==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r367428138", "bodyText": "Take a look at assertThatEventually. I think you can use this in place of waitUtil in at least some cases.", "author": "big-andy-coates", "createdAt": "2020-01-16T13:53:23Z", "path": "ksql-api/src/test/java/io/confluent/ksql/api/ApiTest.java", "diffHunk": "@@ -0,0 +1,885 @@\n+/*\n+ * Copyright 2019 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api;\n+\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_INTERNAL_ERROR;\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_MISSING_PARAM;\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_UNKNOWN_QUERY_ID;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import io.confluent.ksql.api.TestQueryPublisher.ListRowGenerator;\n+import io.confluent.ksql.api.impl.VertxCompletableFuture;\n+import io.confluent.ksql.api.server.Server;\n+import io.vertx.codegen.annotations.Nullable;\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.HttpServerOptions;\n+import io.vertx.core.http.HttpVersion;\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.core.net.PemKeyCertOptions;\n+import io.vertx.core.streams.ReadStream;\n+import io.vertx.core.streams.WriteStream;\n+import io.vertx.ext.web.client.HttpResponse;\n+import io.vertx.ext.web.client.WebClient;\n+import io.vertx.ext.web.client.WebClientOptions;\n+import io.vertx.ext.web.codec.BodyCodec;\n+import java.io.FileNotFoundException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Supplier;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class ApiTest {\n+\n+  private static final long WAIT_TIMEOUT = 10000;\n+  private static final JsonArray DEFAULT_COLUMN_NAMES = new JsonArray().add(\"name\").add(\"age\")\n+      .add(\"male\");\n+  private static final JsonArray DEFAULT_COLUMN_TYPES = new JsonArray().add(\"STRING\").add(\"INT\")\n+      .add(\"BOOLEAN\");\n+  private static final List<JsonArray> DEFAULT_ROWS = generateRows();\n+\n+  private Vertx vertx;\n+  private Server server;\n+  private TestEndpoints testEndpoints;\n+  private WebClient client;\n+\n+  @Before\n+  public void setUp() throws Throwable {\n+\n+    vertx = Vertx.vertx();\n+\n+    HttpServerOptions httpServerOptions =\n+        new HttpServerOptions()\n+            .setHost(\"localhost\")\n+            .setPort(8089)\n+            .setUseAlpn(true)\n+            .setSsl(true)\n+            .setPemKeyCertOptions(\n+                new PemKeyCertOptions().setKeyPath(findFilePath(\"test-server-key.pem\"))\n+                    .setCertPath(findFilePath(\"test-server-cert.pem\"))\n+            );\n+\n+    testEndpoints = new TestEndpoints(vertx);\n+    JsonObject config = new JsonObject().put(\"verticle-instances\", 4);\n+    server = new Server(vertx, config, testEndpoints, httpServerOptions);\n+    server.start();\n+    client = createClient();\n+    setDefaultRowGenerator();\n+  }\n+\n+  @After\n+  public void tearDown() {\n+    if (client != null) {\n+      client.close();\n+    }\n+    if (server != null) {\n+      server.stop();\n+    }\n+  }\n+\n+  @Test\n+  public void shouldExecutePullQuery() throws Exception {\n+\n+    JsonObject requestBody = new JsonObject().put(\"sql\", \"select * from foo\").put(\"push\", false);\n+    JsonObject properties = new JsonObject().put(\"prop1\", \"val1\").put(\"prop2\", 23);\n+    requestBody.put(\"properties\", properties);\n+\n+    HttpResponse<Buffer> response = sendRequest(\"/query-stream\", requestBody.toBuffer());\n+\n+    assertEquals(200, response.statusCode());\n+    assertEquals(\"OK\", response.statusMessage());\n+    assertEquals(\"select * from foo\", testEndpoints.getLastSql());\n+    assertFalse(testEndpoints.getLastPush());\n+    assertEquals(properties, testEndpoints.getLastProperties());\n+\n+    QueryResponse queryResponse = new QueryResponse(response.bodyAsString());\n+    assertEquals(DEFAULT_COLUMN_NAMES, queryResponse.responseObject.getJsonArray(\"columnNames\"));\n+    assertEquals(DEFAULT_COLUMN_TYPES, queryResponse.responseObject.getJsonArray(\"columnTypes\"));\n+    assertEquals(DEFAULT_ROWS, queryResponse.rows);\n+    assertEquals(0, server.getQueryIDs().size());\n+    String queryID = queryResponse.responseObject.getString(\"queryID\");\n+    assertNotNull(queryID);\n+    assertFalse(server.getQueryIDs().contains(queryID));\n+    Integer rowCount = queryResponse.responseObject.getInteger(\"rowCount\");\n+    assertNotNull(rowCount);\n+    assertEquals(DEFAULT_ROWS.size(), rowCount.intValue());\n+  }\n+\n+  @Test\n+  public void shouldExecutePushQuery() throws Exception {\n+\n+    JsonObject requestBody = new JsonObject().put(\"sql\", \"select * from foo\").put(\"push\", true);\n+    JsonObject properties = new JsonObject().put(\"prop1\", \"val1\").put(\"prop2\", 23);\n+    requestBody.put(\"properties\", properties);\n+\n+    QueryResponse queryResponse = executePushQueryAndWaitForRows(requestBody);\n+\n+    assertEquals(\"select * from foo\", testEndpoints.getLastSql());\n+    assertTrue(testEndpoints.getLastPush());\n+    assertEquals(properties, testEndpoints.getLastProperties());\n+\n+    assertEquals(DEFAULT_COLUMN_NAMES, queryResponse.responseObject.getJsonArray(\"columnNames\"));\n+    assertEquals(DEFAULT_COLUMN_TYPES, queryResponse.responseObject.getJsonArray(\"columnTypes\"));\n+    assertEquals(DEFAULT_ROWS, queryResponse.rows);\n+    assertEquals(1, server.getQueryIDs().size());\n+    String queryID = queryResponse.responseObject.getString(\"queryID\");\n+    assertNotNull(queryID);\n+    assertTrue(server.getQueryIDs().contains(queryID));\n+    assertFalse(queryResponse.responseObject.containsKey(\"rowCount\"));\n+  }\n+\n+  @Test\n+  public void shouldExecuteMultiplePushQueries() throws Exception {\n+\n+    JsonObject requestBody = new JsonObject().put(\"sql\", \"select * from foo\").put(\"push\", true);\n+    JsonObject properties = new JsonObject().put(\"prop1\", \"val1\").put(\"prop2\", 23);\n+    requestBody.put(\"properties\", properties);\n+\n+    int numQueries = 10;\n+    for (int i = 0; i < numQueries; i++) {\n+      QueryResponse queryResponse = executePushQueryAndWaitForRows(requestBody);\n+      assertEquals(i + 1, server.getQueryIDs().size());\n+      String queryID = queryResponse.responseObject.getString(\"queryID\");\n+      assertNotNull(queryID);\n+      assertTrue(server.getQueryIDs().contains(queryID));\n+    }\n+  }\n+\n+  @Test\n+  public void shouldCloseQueriesOnDifferentConnectionsWhenConnectionsAreClosed() throws Exception {\n+\n+    JsonObject requestBody = new JsonObject().put(\"sql\", \"select * from foo\").put(\"push\", true);\n+    JsonObject properties = new JsonObject().put(\"prop1\", \"val1\").put(\"prop2\", 23);\n+    requestBody.put(\"properties\", properties);\n+\n+    int numQueries = 10;\n+    List<WebClient> clients = new ArrayList<>();\n+    for (int i = 0; i < numQueries; i++) {\n+      // We use different clients to ensure requests are sent on different connections\n+      WebClient client = createClient();\n+      clients.add(client);\n+      QueryResponse queryResponse = executePushQueryAndWaitForRows(client, requestBody);\n+      String queryID = queryResponse.responseObject.getString(\"queryID\");\n+      assertNotNull(queryID);\n+      assertTrue(server.getQueryIDs().contains(queryID));\n+      assertEquals(i + 1, server.getQueryIDs().size());\n+      assertEquals(i + 1, server.queryConnectionCount());\n+    }\n+    assertAllQueries(numQueries, true);\n+\n+    int count = 0;\n+    for (WebClient client : clients) {\n+      client.close();\n+      int num = numQueries - count - 1;\n+      assertTrue(waitUntil(() -> server.queryConnectionCount() == num));\n+      assertEquals(num, server.getQueryIDs().size());\n+      count++;\n+    }\n+    assertAllQueries(numQueries, false);\n+  }\n+\n+  @Test\n+  public void shouldCloseQueriesOnSameConnectionsWhenConnectionsAreClosed() throws Exception {\n+\n+    JsonObject requestBody = new JsonObject().put(\"sql\", \"select * from foo\").put(\"push\", true);\n+    JsonObject properties = new JsonObject().put(\"prop1\", \"val1\").put(\"prop2\", 23);\n+    requestBody.put(\"properties\", properties);\n+\n+    int numQueries = 10;\n+    for (int i = 0; i < numQueries; i++) {\n+      QueryResponse queryResponse = executePushQueryAndWaitForRows(requestBody);\n+      String queryID = queryResponse.responseObject.getString(\"queryID\");\n+      assertNotNull(queryID);\n+      assertTrue(server.getQueryIDs().contains(queryID));\n+      assertEquals(i + 1, server.getQueryIDs().size());\n+    }\n+    assertEquals(1, server.queryConnectionCount());\n+    assertAllQueries(numQueries, true);\n+\n+    client.close();\n+    assertTrue(waitUntil(() -> server.queryConnectionCount() == 0));\n+    assertTrue(server.getQueryIDs().isEmpty());\n+    client = null;\n+\n+    assertAllQueries(numQueries, false);\n+  }\n+\n+  @Test\n+  public void shouldCloseMultipleQueriesOnDifferentConnectionsWhenConnectionsAreClosed()\n+      throws Exception {\n+\n+    JsonObject requestBody = new JsonObject().put(\"sql\", \"select * from foo\").put(\"push\", true);\n+    JsonObject properties = new JsonObject().put(\"prop1\", \"val1\").put(\"prop2\", 23);\n+    requestBody.put(\"properties\", properties);\n+\n+    int numConnections = 5;\n+    int numQueries = 5;\n+    List<WebClient> clients = new ArrayList<>();\n+    for (int i = 0; i < numConnections; i++) {\n+      WebClient client = createClient();\n+      clients.add(client);\n+      for (int j = 0; j < numQueries; j++) {\n+        QueryResponse queryResponse = executePushQueryAndWaitForRows(client, requestBody);\n+        String queryID = queryResponse.responseObject.getString(\"queryID\");\n+        assertNotNull(queryID);\n+        assertTrue(server.getQueryIDs().contains(queryID));\n+        int queries = i * numQueries + j + 1;\n+        assertEquals(i * numQueries + j + 1, server.getQueryIDs().size());\n+        assertEquals(i + 1, server.queryConnectionCount());\n+        assertAllQueries(queries, true);\n+      }\n+    }\n+\n+    int count = 0;\n+    for (WebClient client : clients) {\n+      client.close();\n+      int connections = numConnections - count - 1;\n+      assertTrue(waitUntil(() -> server.queryConnectionCount() == connections));\n+      assertEquals(numQueries * connections, server.getQueryIDs().size());\n+      count++;\n+    }\n+\n+    assertAllQueries(numConnections * numQueries, false);\n+  }\n+\n+  @Test\n+  public void shouldHandleQueryWithMissingSql() throws Exception {\n+\n+    JsonObject requestBody = new JsonObject().put(\"foo\", \"bar\");\n+\n+    HttpResponse<Buffer> response = sendRequest(\"/query-stream\", requestBody.toBuffer());\n+\n+    assertEquals(400, response.statusCode());\n+    assertEquals(\"Bad Request\", response.statusMessage());\n+\n+    QueryResponse queryResponse = new QueryResponse(response.bodyAsString());\n+    validateError(ERROR_CODE_MISSING_PARAM, \"No sql in arguments\", queryResponse.responseObject);\n+  }\n+\n+  @Test\n+  public void shouldHandleQueryWithMissingPush() throws Exception {\n+\n+    JsonObject requestBody = new JsonObject().put(\"sql\", \"select * from foo\");\n+\n+    HttpResponse<Buffer> response = sendRequest(\"/query-stream\", requestBody.toBuffer());\n+\n+    assertEquals(400, response.statusCode());\n+    assertEquals(\"Bad Request\", response.statusMessage());\n+\n+    QueryResponse queryResponse = new QueryResponse(response.bodyAsString());\n+    validateError(ERROR_CODE_MISSING_PARAM, \"No push in arguments\", queryResponse.responseObject);\n+  }\n+\n+  @Test\n+  public void shouldHandleErrorInProcessingQuery() throws Exception {\n+\n+    JsonObject requestBody = new JsonObject().put(\"sql\", \"select * from foo\").put(\"push\", true);\n+    JsonObject properties = new JsonObject().put(\"prop1\", \"val1\").put(\"prop2\", 23);\n+    requestBody.put(\"properties\", properties);\n+\n+    testEndpoints.setRowsBeforePublisherError(DEFAULT_ROWS.size() - 1);\n+\n+    HttpResponse<Buffer> response = sendRequest(\"/query-stream\", requestBody.toBuffer());\n+\n+    assertEquals(200, response.statusCode());\n+    assertEquals(\"OK\", response.statusMessage());\n+\n+    QueryResponse queryResponse = new QueryResponse(response.bodyAsString());\n+    assertEquals(DEFAULT_ROWS.size() - 1, queryResponse.rows.size());\n+    validateError(ERROR_CODE_INTERNAL_ERROR, \"Error in processing query\", queryResponse.error);\n+\n+    assertEquals(1, testEndpoints.getQueryPublishers().size());\n+    assertFalse(testEndpoints.getQueryPublishers().iterator().next().hasSubscriber());\n+    assertTrue(server.getQueryIDs().isEmpty());\n+  }\n+\n+  @Test\n+  public void shouldCloseQuery() throws Exception {\n+\n+    JsonObject queryRequestBody = new JsonObject().put(\"sql\", \"select * from foo\")\n+        .put(\"push\", true);\n+    JsonObject properties = new JsonObject().put(\"prop1\", \"val1\").put(\"prop2\", 23);\n+    queryRequestBody.put(\"properties\", properties);\n+\n+    ReceiveStream writeStream = new ReceiveStream(vertx);\n+\n+    client.post(8089, \"localhost\", \"/query-stream\")\n+        .as(BodyCodec.pipe(writeStream))\n+        .sendJsonObject(queryRequestBody, ar -> {\n+        });\n+\n+    // Wait for all rows to arrive\n+    assertTrue(waitUntil(() -> {\n+      Buffer buff = writeStream.getBody();\n+      try {\n+        QueryResponse queryResponse = new QueryResponse(buff.toString());\n+        return queryResponse.rows.size() == DEFAULT_ROWS.size();\n+      } catch (Throwable t) {\n+        return false;\n+      }\n+    }));\n+\n+    assertFalse(writeStream.isEnded());\n+\n+    QueryResponse queryResponse = new QueryResponse(writeStream.getBody().toString());\n+    String queryID = queryResponse.responseObject.getString(\"queryID\");\n+    assertTrue(server.getQueryIDs().contains(queryID));\n+    assertEquals(1, server.getQueryIDs().size());\n+    assertEquals(1, testEndpoints.getQueryPublishers().size());\n+\n+    JsonObject closeQueryRequestBody = new JsonObject().put(\"queryID\", queryID);\n+    HttpResponse<Buffer> closeQueryResponse = sendRequest(client, \"/close-query\",\n+        closeQueryRequestBody.toBuffer());\n+    assertEquals(200, closeQueryResponse.statusCode());\n+    assertFalse(server.getQueryIDs().contains(queryID));\n+    assertEquals(0, server.getQueryIDs().size());\n+\n+    // This should trigger the response to end\n+    assertTrue(waitUntil(writeStream::isEnded));\n+\n+    assertEquals(1, testEndpoints.getQueryPublishers().size());\n+    assertFalse(testEndpoints.getQueryPublishers().iterator().next().hasSubscriber());\n+  }\n+\n+  @Test\n+  public void shouldHandleMissingQueryIDInCloseQuery() throws Exception {\n+\n+    JsonObject closeQueryRequestBody = new JsonObject().put(\"foo\", \"bar\");\n+    HttpResponse<Buffer> response = sendRequest(client, \"/close-query\",\n+        closeQueryRequestBody.toBuffer());\n+\n+    assertEquals(400, response.statusCode());\n+    assertEquals(\"Bad Request\", response.statusMessage());\n+\n+    QueryResponse queryResponse = new QueryResponse(response.bodyAsString());\n+    validateError(ERROR_CODE_MISSING_PARAM, \"No queryID in arguments\",\n+        queryResponse.responseObject);\n+  }\n+\n+  @Test\n+  public void shouldHandleUnknownQueryIDInCloseQuery() throws Exception {\n+\n+    JsonObject closeQueryRequestBody = new JsonObject().put(\"queryID\", \"xyzfasgf\");\n+    HttpResponse<Buffer> response = sendRequest(client, \"/close-query\",\n+        closeQueryRequestBody.toBuffer());\n+\n+    assertEquals(400, response.statusCode());\n+    assertEquals(\"Bad Request\", response.statusMessage());\n+\n+    QueryResponse queryResponse = new QueryResponse(response.bodyAsString());\n+    validateError(ERROR_CODE_UNKNOWN_QUERY_ID, \"No query with id xyzfasgf\",\n+        queryResponse.responseObject);\n+  }\n+\n+  @Test\n+  public void shouldInsertWithNoAcksStream() throws Exception {\n+\n+    JsonObject params = new JsonObject().put(\"target\", \"test-stream\").put(\"acks\", false);\n+\n+    List<JsonObject> rows = generateInsertRows();\n+    Buffer requestBody = Buffer.buffer();\n+    requestBody.appendBuffer(params.toBuffer()).appendString(\"\\n\");\n+    for (JsonObject row : rows) {\n+      requestBody.appendBuffer(row.toBuffer()).appendString(\"\\n\");\n+    }\n+\n+    HttpResponse<Buffer> response = sendRequest(\"/inserts-stream\", requestBody);\n+    assertEquals(200, response.statusCode());\n+    assertEquals(\"OK\", response.statusMessage());\n+\n+    assertEquals(rows, testEndpoints.getInsertsSubscriber().getRowsInserted());\n+    assertTrue(testEndpoints.getInsertsSubscriber().isCompleted());\n+    assertEquals(\"test-stream\", testEndpoints.getLastTarget());\n+  }\n+\n+  @Test\n+  public void shouldInsertWithAcksStream() throws Exception {\n+\n+    JsonObject params = new JsonObject().put(\"target\", \"test-stream\").put(\"acks\", true);\n+\n+    List<JsonObject> rows = generateInsertRows();\n+    Buffer requestBody = Buffer.buffer();\n+    requestBody.appendBuffer(params.toBuffer()).appendString(\"\\n\");\n+    for (JsonObject row : rows) {\n+      requestBody.appendBuffer(row.toBuffer()).appendString(\"\\n\");\n+    }\n+\n+    HttpResponse<Buffer> response = sendRequest(\"/inserts-stream\", requestBody);\n+    assertEquals(200, response.statusCode());\n+    assertEquals(\"OK\", response.statusMessage());\n+\n+    String responseBody = response.bodyAsString();\n+    InsertsResponse insertsResponse = new InsertsResponse(responseBody);\n+    assertEquals(rows.size(), insertsResponse.acks.size());\n+\n+    assertEquals(rows, testEndpoints.getInsertsSubscriber().getRowsInserted());\n+    assertTrue(testEndpoints.getInsertsSubscriber().isCompleted());\n+    assertEquals(\"test-stream\", testEndpoints.getLastTarget());\n+  }\n+\n+  @Test\n+  public void shouldStreamInserts() throws Exception {\n+\n+    JsonObject params = new JsonObject().put(\"target\", \"test-stream\").put(\"acks\", true);\n+\n+    SendStream readStream = new SendStream(vertx);\n+    ReceiveStream writeStream = new ReceiveStream(vertx);\n+    VertxCompletableFuture<HttpResponse<Void>> fut = new VertxCompletableFuture<>();\n+    List<JsonObject> rows = generateInsertRows();\n+\n+    client.post(8089, \"localhost\", \"/inserts-stream\")\n+        .as(BodyCodec.pipe(writeStream))\n+        .sendStream(readStream, fut);\n+\n+    readStream.acceptBuffer(params.toBuffer().appendString(\"\\n\"));\n+\n+    AtomicInteger rowIndex = new AtomicInteger();\n+    vertx.setPeriodic(100, tid -> {\n+      readStream.acceptBuffer(rows.get(rowIndex.getAndIncrement()).toBuffer().appendString(\"\\n\"));\n+      if (rowIndex.get() == rows.size()) {\n+        vertx.cancelTimer(tid);\n+        readStream.end();\n+      }\n+    });\n+\n+    HttpResponse<Void> response = fut.get();\n+\n+    assertEquals(200, response.statusCode());\n+    assertEquals(\"OK\", response.statusMessage());\n+\n+    InsertsResponse insertsResponse = new InsertsResponse(writeStream.getBody().toString());\n+    assertEquals(rows.size(), insertsResponse.acks.size());\n+    assertEquals(rows, testEndpoints.getInsertsSubscriber().getRowsInserted());\n+    assertTrue(testEndpoints.getInsertsSubscriber().isCompleted());\n+    // When response is complete the acks subscriber should be unsubscribed\n+    assertFalse(testEndpoints.getAcksPublisher().hasSubscriber());\n+\n+    // Ensure we received at last some of the response before all the request body was written\n+    // Yay HTTP2!\n+    assertTrue(readStream.getLastSentTime() > writeStream.getFirstReceivedTime());\n+  }\n+\n+  @Test\n+  public void shouldHandleMissingTargetInInserts() throws Exception {\n+\n+    JsonObject requestBody = new JsonObject().put(\"acks\", true);\n+\n+    HttpResponse<Buffer> response = sendRequest(\"/inserts-stream\",\n+        requestBody.toBuffer().appendString(\"\\n\"));\n+\n+    assertEquals(400, response.statusCode());\n+    assertEquals(\"Bad Request\", response.statusMessage());\n+\n+    QueryResponse queryResponse = new QueryResponse(response.bodyAsString());\n+    validateError(ERROR_CODE_MISSING_PARAM, \"No target in arguments\", queryResponse.responseObject);\n+  }\n+\n+  @Test\n+  public void shouldHandleMissingAcksInInserts() throws Exception {\n+\n+    JsonObject requestBody = new JsonObject().put(\"target\", \"some-stream\");\n+\n+    HttpResponse<Buffer> response = sendRequest(\"/inserts-stream\",\n+        requestBody.toBuffer().appendString(\"\\n\"));\n+\n+    assertEquals(400, response.statusCode());\n+    assertEquals(\"Bad Request\", response.statusMessage());\n+\n+    QueryResponse queryResponse = new QueryResponse(response.bodyAsString());\n+    validateError(ERROR_CODE_MISSING_PARAM, \"No acks in arguments\",\n+        queryResponse.responseObject);\n+  }\n+\n+  @Test\n+  public void shouldHandleErrorInProcessingInserts() throws Exception {\n+\n+    JsonObject params = new JsonObject().put(\"target\", \"test-stream\").put(\"acks\", true);\n+\n+    List<JsonObject> rows = generateInsertRows();\n+    Buffer requestBody = Buffer.buffer();\n+    requestBody.appendBuffer(params.toBuffer()).appendString(\"\\n\");\n+    for (JsonObject row : rows) {\n+      requestBody.appendBuffer(row.toBuffer()).appendString(\"\\n\");\n+    }\n+\n+    // Inject an error on last row inserted\n+    testEndpoints.setAcksBeforePublisherError(rows.size() - 1);\n+\n+    // The HTTP response will be OK as the error is later in the stream after response\n+    // headers have been written\n+    HttpResponse<Buffer> response = sendRequest(\"/inserts-stream\", requestBody);\n+    assertEquals(200, response.statusCode());\n+    assertEquals(\"OK\", response.statusMessage());\n+\n+    String responseBody = response.bodyAsString();\n+    InsertsResponse insertsResponse = new InsertsResponse(responseBody);\n+    assertEquals(rows.size() - 1, insertsResponse.acks.size());\n+    validateError(ERROR_CODE_INTERNAL_ERROR, \"Error in processing inserts\", insertsResponse.error);\n+\n+    assertTrue(testEndpoints.getInsertsSubscriber().isCompleted());\n+  }\n+\n+  private QueryResponse executePushQueryAndWaitForRows(final JsonObject requestBody)\n+      throws Exception {\n+    return executePushQueryAndWaitForRows(client, requestBody);\n+  }\n+\n+  private QueryResponse executePushQueryAndWaitForRows(final WebClient client,\n+      final JsonObject requestBody)\n+      throws Exception {\n+\n+    ReceiveStream writeStream = new ReceiveStream(vertx);\n+\n+    client.post(8089, \"localhost\", \"/query-stream\")\n+        .as(BodyCodec.pipe(writeStream))\n+        .sendJsonObject(requestBody, ar -> {\n+        });\n+\n+    // Wait for all rows to arrive\n+    assertTrue(waitUntil(() -> {\n+      Buffer buff = writeStream.getBody();\n+      try {\n+        QueryResponse queryResponse = new QueryResponse(buff.toString());\n+        return queryResponse.rows.size() == DEFAULT_ROWS.size();\n+      } catch (Throwable t) {\n+        return false;\n+      }\n+    }));\n+\n+    // Note, the response hasn't ended at this point\n+    assertFalse(writeStream.isEnded());\n+\n+    return new QueryResponse(writeStream.getBody().toString());\n+  }\n+\n+  private WebClient createClient() {\n+    WebClientOptions options = new WebClientOptions().setSsl(true).\n+        setUseAlpn(true).\n+        setProtocolVersion(HttpVersion.HTTP_2).\n+        setTrustAll(true);\n+\n+    return WebClient.create(vertx, options);\n+  }\n+\n+  private static void validateError(final int errorCode, final String message,\n+      final JsonObject error) {\n+    assertEquals(\"error\", error.getString(\"status\"));\n+    assertEquals(errorCode, error.getInteger(\"errorCode\").intValue());\n+    assertEquals(message, error.getString(\"message\"));\n+    assertEquals(3, error.size());\n+  }\n+\n+  private void assertAllQueries(final int num, final boolean open) {\n+    assertEquals(num, testEndpoints.getQueryPublishers().size());\n+    for (TestQueryPublisher queryPublisher : testEndpoints.getQueryPublishers()) {\n+      if (open) {\n+        assertTrue(queryPublisher.hasSubscriber());\n+      } else {\n+        assertFalse(queryPublisher.hasSubscriber());\n+      }\n+    }\n+  }\n+\n+  private HttpResponse<Buffer> sendRequest(final String uri, final Buffer requestBody)\n+      throws Exception {\n+    return sendRequest(client, uri, requestBody);\n+  }\n+\n+  private HttpResponse<Buffer> sendRequest(final WebClient client, final String uri,\n+      final Buffer requestBody)\n+      throws Exception {\n+    VertxCompletableFuture<HttpResponse<Buffer>> requestFuture = new VertxCompletableFuture<>();\n+    client\n+        .post(8089, \"localhost\", uri)\n+        .sendBuffer(requestBody, requestFuture);\n+    return requestFuture.get();\n+  }\n+\n+  private void setDefaultRowGenerator() {\n+    testEndpoints.setRowGeneratorFactory(\n+        () -> new ListRowGenerator(DEFAULT_COLUMN_NAMES, DEFAULT_COLUMN_TYPES,\n+            DEFAULT_ROWS));\n+  }\n+\n+  private static boolean waitUntil(final Supplier<Boolean> test) throws Exception {", "originalCommit": "92ac3ce0feac9acd143b159b24e085c57ada49aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzYzNjA5MQ==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r367636091", "bodyText": "I think that requires a hamcrest matcher as opposed to this version which works more simply with a Supplier.", "author": "purplefox", "createdAt": "2020-01-16T20:34:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQyODEzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODY1ODMwOA==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r368658308", "bodyText": "Yep, meaning assertThatEventually has richer functionality.", "author": "big-andy-coates", "createdAt": "2020-01-20T17:19:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQyODEzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQyODg1MQ==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r367428851", "bodyText": "It's hard to tell what is going on in this test TBH.  You may understand it, but someone else may struggle if this starts failing when they change something.\nIMHO it would benefit from being refactored into methods with more descriptive names, using Given/When/Then to make it clear which is the actual bit under test, and avoid testing the same things in many tests e.g.\n@Test\npublic void shouldCloseQuery() throws Exception {\n   // Given:\n   QueryResponse queryResponse = executePushQueryAndWaitForRows(queryRequestBody);\n   String queryID = queryResponse.responseObject.getString(\"queryID\");\n\n    // When:\n    HttpResponse<Buffer> closeQueryResponse = sendRequest(closeRequest(queryId)));\n  \n    // Then:\n    assertThat(closeQueryResponse.statusCode(), is(200));\n    assertThat(server.getQueryIDs(), not(hasItem(queryID)));\n\n    // This should trigger the response to end\n    assertThatEventually(writeStream::isEnded, is(true)));\n\n    assertThat(testEndpoints.getQueryPublishers(), hasSize(1));\n    assertThat(testEndpoints.getQueryPublishers().iterator().next().hasSubscriber(), is(true));\n}\nNote, I excluded some lines from the test, as they are tested elsewhere:\n    assertTrue(server.getQueryIDs().contains(queryID));\n    assertEquals(1, server.getQueryIDs().size());\n    assertEquals(1, testEndpoints.getQueryPublishers().size());\n\n    assertEquals(0, server.getQueryIDs().size()); \n\nTBH, there's also a some code duplication in this test file. For example:\n\nmany tests create the same queryRequestBody.  Maybe this could just be in a constant?\nmany tests create new SendStream(vertx) or new ReceiveStream(vertx). Maybe these could be created in setUp method and stored in fields?\n\nRefactoring in this way removes the noise from test cases, making them much easier for the next person to understand.", "author": "big-andy-coates", "createdAt": "2020-01-16T13:54:44Z", "path": "ksql-api/src/test/java/io/confluent/ksql/api/ApiTest.java", "diffHunk": "@@ -0,0 +1,885 @@\n+/*\n+ * Copyright 2019 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api;\n+\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_INTERNAL_ERROR;\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_MISSING_PARAM;\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_UNKNOWN_QUERY_ID;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import io.confluent.ksql.api.TestQueryPublisher.ListRowGenerator;\n+import io.confluent.ksql.api.impl.VertxCompletableFuture;\n+import io.confluent.ksql.api.server.Server;\n+import io.vertx.codegen.annotations.Nullable;\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.HttpServerOptions;\n+import io.vertx.core.http.HttpVersion;\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.core.net.PemKeyCertOptions;\n+import io.vertx.core.streams.ReadStream;\n+import io.vertx.core.streams.WriteStream;\n+import io.vertx.ext.web.client.HttpResponse;\n+import io.vertx.ext.web.client.WebClient;\n+import io.vertx.ext.web.client.WebClientOptions;\n+import io.vertx.ext.web.codec.BodyCodec;\n+import java.io.FileNotFoundException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Supplier;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class ApiTest {\n+\n+  private static final long WAIT_TIMEOUT = 10000;\n+  private static final JsonArray DEFAULT_COLUMN_NAMES = new JsonArray().add(\"name\").add(\"age\")\n+      .add(\"male\");\n+  private static final JsonArray DEFAULT_COLUMN_TYPES = new JsonArray().add(\"STRING\").add(\"INT\")\n+      .add(\"BOOLEAN\");\n+  private static final List<JsonArray> DEFAULT_ROWS = generateRows();\n+\n+  private Vertx vertx;\n+  private Server server;\n+  private TestEndpoints testEndpoints;\n+  private WebClient client;\n+\n+  @Before\n+  public void setUp() throws Throwable {\n+\n+    vertx = Vertx.vertx();\n+\n+    HttpServerOptions httpServerOptions =\n+        new HttpServerOptions()\n+            .setHost(\"localhost\")\n+            .setPort(8089)\n+            .setUseAlpn(true)\n+            .setSsl(true)\n+            .setPemKeyCertOptions(\n+                new PemKeyCertOptions().setKeyPath(findFilePath(\"test-server-key.pem\"))\n+                    .setCertPath(findFilePath(\"test-server-cert.pem\"))\n+            );\n+\n+    testEndpoints = new TestEndpoints(vertx);\n+    JsonObject config = new JsonObject().put(\"verticle-instances\", 4);\n+    server = new Server(vertx, config, testEndpoints, httpServerOptions);\n+    server.start();\n+    client = createClient();\n+    setDefaultRowGenerator();\n+  }\n+\n+  @After\n+  public void tearDown() {\n+    if (client != null) {\n+      client.close();\n+    }\n+    if (server != null) {\n+      server.stop();\n+    }\n+  }\n+\n+  @Test\n+  public void shouldExecutePullQuery() throws Exception {\n+\n+    JsonObject requestBody = new JsonObject().put(\"sql\", \"select * from foo\").put(\"push\", false);\n+    JsonObject properties = new JsonObject().put(\"prop1\", \"val1\").put(\"prop2\", 23);\n+    requestBody.put(\"properties\", properties);\n+\n+    HttpResponse<Buffer> response = sendRequest(\"/query-stream\", requestBody.toBuffer());\n+\n+    assertEquals(200, response.statusCode());\n+    assertEquals(\"OK\", response.statusMessage());\n+    assertEquals(\"select * from foo\", testEndpoints.getLastSql());\n+    assertFalse(testEndpoints.getLastPush());\n+    assertEquals(properties, testEndpoints.getLastProperties());\n+\n+    QueryResponse queryResponse = new QueryResponse(response.bodyAsString());\n+    assertEquals(DEFAULT_COLUMN_NAMES, queryResponse.responseObject.getJsonArray(\"columnNames\"));\n+    assertEquals(DEFAULT_COLUMN_TYPES, queryResponse.responseObject.getJsonArray(\"columnTypes\"));\n+    assertEquals(DEFAULT_ROWS, queryResponse.rows);\n+    assertEquals(0, server.getQueryIDs().size());\n+    String queryID = queryResponse.responseObject.getString(\"queryID\");\n+    assertNotNull(queryID);\n+    assertFalse(server.getQueryIDs().contains(queryID));\n+    Integer rowCount = queryResponse.responseObject.getInteger(\"rowCount\");\n+    assertNotNull(rowCount);\n+    assertEquals(DEFAULT_ROWS.size(), rowCount.intValue());\n+  }\n+\n+  @Test\n+  public void shouldExecutePushQuery() throws Exception {\n+\n+    JsonObject requestBody = new JsonObject().put(\"sql\", \"select * from foo\").put(\"push\", true);\n+    JsonObject properties = new JsonObject().put(\"prop1\", \"val1\").put(\"prop2\", 23);\n+    requestBody.put(\"properties\", properties);\n+\n+    QueryResponse queryResponse = executePushQueryAndWaitForRows(requestBody);\n+\n+    assertEquals(\"select * from foo\", testEndpoints.getLastSql());\n+    assertTrue(testEndpoints.getLastPush());\n+    assertEquals(properties, testEndpoints.getLastProperties());\n+\n+    assertEquals(DEFAULT_COLUMN_NAMES, queryResponse.responseObject.getJsonArray(\"columnNames\"));\n+    assertEquals(DEFAULT_COLUMN_TYPES, queryResponse.responseObject.getJsonArray(\"columnTypes\"));\n+    assertEquals(DEFAULT_ROWS, queryResponse.rows);\n+    assertEquals(1, server.getQueryIDs().size());\n+    String queryID = queryResponse.responseObject.getString(\"queryID\");\n+    assertNotNull(queryID);\n+    assertTrue(server.getQueryIDs().contains(queryID));\n+    assertFalse(queryResponse.responseObject.containsKey(\"rowCount\"));\n+  }\n+\n+  @Test\n+  public void shouldExecuteMultiplePushQueries() throws Exception {\n+\n+    JsonObject requestBody = new JsonObject().put(\"sql\", \"select * from foo\").put(\"push\", true);\n+    JsonObject properties = new JsonObject().put(\"prop1\", \"val1\").put(\"prop2\", 23);\n+    requestBody.put(\"properties\", properties);\n+\n+    int numQueries = 10;\n+    for (int i = 0; i < numQueries; i++) {\n+      QueryResponse queryResponse = executePushQueryAndWaitForRows(requestBody);\n+      assertEquals(i + 1, server.getQueryIDs().size());\n+      String queryID = queryResponse.responseObject.getString(\"queryID\");\n+      assertNotNull(queryID);\n+      assertTrue(server.getQueryIDs().contains(queryID));\n+    }\n+  }\n+\n+  @Test\n+  public void shouldCloseQueriesOnDifferentConnectionsWhenConnectionsAreClosed() throws Exception {\n+\n+    JsonObject requestBody = new JsonObject().put(\"sql\", \"select * from foo\").put(\"push\", true);\n+    JsonObject properties = new JsonObject().put(\"prop1\", \"val1\").put(\"prop2\", 23);\n+    requestBody.put(\"properties\", properties);\n+\n+    int numQueries = 10;\n+    List<WebClient> clients = new ArrayList<>();\n+    for (int i = 0; i < numQueries; i++) {\n+      // We use different clients to ensure requests are sent on different connections\n+      WebClient client = createClient();\n+      clients.add(client);\n+      QueryResponse queryResponse = executePushQueryAndWaitForRows(client, requestBody);\n+      String queryID = queryResponse.responseObject.getString(\"queryID\");\n+      assertNotNull(queryID);\n+      assertTrue(server.getQueryIDs().contains(queryID));\n+      assertEquals(i + 1, server.getQueryIDs().size());\n+      assertEquals(i + 1, server.queryConnectionCount());\n+    }\n+    assertAllQueries(numQueries, true);\n+\n+    int count = 0;\n+    for (WebClient client : clients) {\n+      client.close();\n+      int num = numQueries - count - 1;\n+      assertTrue(waitUntil(() -> server.queryConnectionCount() == num));\n+      assertEquals(num, server.getQueryIDs().size());\n+      count++;\n+    }\n+    assertAllQueries(numQueries, false);\n+  }\n+\n+  @Test\n+  public void shouldCloseQueriesOnSameConnectionsWhenConnectionsAreClosed() throws Exception {\n+\n+    JsonObject requestBody = new JsonObject().put(\"sql\", \"select * from foo\").put(\"push\", true);\n+    JsonObject properties = new JsonObject().put(\"prop1\", \"val1\").put(\"prop2\", 23);\n+    requestBody.put(\"properties\", properties);\n+\n+    int numQueries = 10;\n+    for (int i = 0; i < numQueries; i++) {\n+      QueryResponse queryResponse = executePushQueryAndWaitForRows(requestBody);\n+      String queryID = queryResponse.responseObject.getString(\"queryID\");\n+      assertNotNull(queryID);\n+      assertTrue(server.getQueryIDs().contains(queryID));\n+      assertEquals(i + 1, server.getQueryIDs().size());\n+    }\n+    assertEquals(1, server.queryConnectionCount());\n+    assertAllQueries(numQueries, true);\n+\n+    client.close();\n+    assertTrue(waitUntil(() -> server.queryConnectionCount() == 0));\n+    assertTrue(server.getQueryIDs().isEmpty());\n+    client = null;\n+\n+    assertAllQueries(numQueries, false);\n+  }\n+\n+  @Test\n+  public void shouldCloseMultipleQueriesOnDifferentConnectionsWhenConnectionsAreClosed()\n+      throws Exception {\n+\n+    JsonObject requestBody = new JsonObject().put(\"sql\", \"select * from foo\").put(\"push\", true);\n+    JsonObject properties = new JsonObject().put(\"prop1\", \"val1\").put(\"prop2\", 23);\n+    requestBody.put(\"properties\", properties);\n+\n+    int numConnections = 5;\n+    int numQueries = 5;\n+    List<WebClient> clients = new ArrayList<>();\n+    for (int i = 0; i < numConnections; i++) {\n+      WebClient client = createClient();\n+      clients.add(client);\n+      for (int j = 0; j < numQueries; j++) {\n+        QueryResponse queryResponse = executePushQueryAndWaitForRows(client, requestBody);\n+        String queryID = queryResponse.responseObject.getString(\"queryID\");\n+        assertNotNull(queryID);\n+        assertTrue(server.getQueryIDs().contains(queryID));\n+        int queries = i * numQueries + j + 1;\n+        assertEquals(i * numQueries + j + 1, server.getQueryIDs().size());\n+        assertEquals(i + 1, server.queryConnectionCount());\n+        assertAllQueries(queries, true);\n+      }\n+    }\n+\n+    int count = 0;\n+    for (WebClient client : clients) {\n+      client.close();\n+      int connections = numConnections - count - 1;\n+      assertTrue(waitUntil(() -> server.queryConnectionCount() == connections));\n+      assertEquals(numQueries * connections, server.getQueryIDs().size());\n+      count++;\n+    }\n+\n+    assertAllQueries(numConnections * numQueries, false);\n+  }\n+\n+  @Test\n+  public void shouldHandleQueryWithMissingSql() throws Exception {\n+\n+    JsonObject requestBody = new JsonObject().put(\"foo\", \"bar\");\n+\n+    HttpResponse<Buffer> response = sendRequest(\"/query-stream\", requestBody.toBuffer());\n+\n+    assertEquals(400, response.statusCode());\n+    assertEquals(\"Bad Request\", response.statusMessage());\n+\n+    QueryResponse queryResponse = new QueryResponse(response.bodyAsString());\n+    validateError(ERROR_CODE_MISSING_PARAM, \"No sql in arguments\", queryResponse.responseObject);\n+  }\n+\n+  @Test\n+  public void shouldHandleQueryWithMissingPush() throws Exception {\n+\n+    JsonObject requestBody = new JsonObject().put(\"sql\", \"select * from foo\");\n+\n+    HttpResponse<Buffer> response = sendRequest(\"/query-stream\", requestBody.toBuffer());\n+\n+    assertEquals(400, response.statusCode());\n+    assertEquals(\"Bad Request\", response.statusMessage());\n+\n+    QueryResponse queryResponse = new QueryResponse(response.bodyAsString());\n+    validateError(ERROR_CODE_MISSING_PARAM, \"No push in arguments\", queryResponse.responseObject);\n+  }\n+\n+  @Test\n+  public void shouldHandleErrorInProcessingQuery() throws Exception {\n+\n+    JsonObject requestBody = new JsonObject().put(\"sql\", \"select * from foo\").put(\"push\", true);\n+    JsonObject properties = new JsonObject().put(\"prop1\", \"val1\").put(\"prop2\", 23);\n+    requestBody.put(\"properties\", properties);\n+\n+    testEndpoints.setRowsBeforePublisherError(DEFAULT_ROWS.size() - 1);\n+\n+    HttpResponse<Buffer> response = sendRequest(\"/query-stream\", requestBody.toBuffer());\n+\n+    assertEquals(200, response.statusCode());\n+    assertEquals(\"OK\", response.statusMessage());\n+\n+    QueryResponse queryResponse = new QueryResponse(response.bodyAsString());\n+    assertEquals(DEFAULT_ROWS.size() - 1, queryResponse.rows.size());\n+    validateError(ERROR_CODE_INTERNAL_ERROR, \"Error in processing query\", queryResponse.error);\n+\n+    assertEquals(1, testEndpoints.getQueryPublishers().size());\n+    assertFalse(testEndpoints.getQueryPublishers().iterator().next().hasSubscriber());\n+    assertTrue(server.getQueryIDs().isEmpty());\n+  }\n+\n+  @Test\n+  public void shouldCloseQuery() throws Exception {\n+\n+    JsonObject queryRequestBody = new JsonObject().put(\"sql\", \"select * from foo\")\n+        .put(\"push\", true);\n+    JsonObject properties = new JsonObject().put(\"prop1\", \"val1\").put(\"prop2\", 23);\n+    queryRequestBody.put(\"properties\", properties);\n+\n+    ReceiveStream writeStream = new ReceiveStream(vertx);\n+\n+    client.post(8089, \"localhost\", \"/query-stream\")\n+        .as(BodyCodec.pipe(writeStream))\n+        .sendJsonObject(queryRequestBody, ar -> {\n+        });\n+\n+    // Wait for all rows to arrive\n+    assertTrue(waitUntil(() -> {\n+      Buffer buff = writeStream.getBody();\n+      try {\n+        QueryResponse queryResponse = new QueryResponse(buff.toString());\n+        return queryResponse.rows.size() == DEFAULT_ROWS.size();\n+      } catch (Throwable t) {\n+        return false;\n+      }\n+    }));\n+\n+    assertFalse(writeStream.isEnded());\n+\n+    QueryResponse queryResponse = new QueryResponse(writeStream.getBody().toString());\n+    String queryID = queryResponse.responseObject.getString(\"queryID\");\n+    assertTrue(server.getQueryIDs().contains(queryID));\n+    assertEquals(1, server.getQueryIDs().size());\n+    assertEquals(1, testEndpoints.getQueryPublishers().size());\n+\n+    JsonObject closeQueryRequestBody = new JsonObject().put(\"queryID\", queryID);\n+    HttpResponse<Buffer> closeQueryResponse = sendRequest(client, \"/close-query\",\n+        closeQueryRequestBody.toBuffer());\n+    assertEquals(200, closeQueryResponse.statusCode());\n+    assertFalse(server.getQueryIDs().contains(queryID));\n+    assertEquals(0, server.getQueryIDs().size());\n+\n+    // This should trigger the response to end\n+    assertTrue(waitUntil(writeStream::isEnded));\n+\n+    assertEquals(1, testEndpoints.getQueryPublishers().size());\n+    assertFalse(testEndpoints.getQueryPublishers().iterator().next().hasSubscriber());\n+  }", "originalCommit": "92ac3ce0feac9acd143b159b24e085c57ada49aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzYzNjI3MA==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r367636270", "bodyText": "I've added a bunch more comments to it to make it clearer what it does.", "author": "purplefox", "createdAt": "2020-01-16T20:35:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQyODg1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQzMDExMA==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r367430110", "bodyText": "Not sure, but maybe ServerKeyStore or ClientTrustStore or similar can help simplify the test here?", "author": "big-andy-coates", "createdAt": "2020-01-16T13:57:03Z", "path": "ksql-api/src/test/java/io/confluent/ksql/api/ApiTest.java", "diffHunk": "@@ -0,0 +1,885 @@\n+/*\n+ * Copyright 2019 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api;\n+\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_INTERNAL_ERROR;\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_MISSING_PARAM;\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_UNKNOWN_QUERY_ID;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import io.confluent.ksql.api.TestQueryPublisher.ListRowGenerator;\n+import io.confluent.ksql.api.impl.VertxCompletableFuture;\n+import io.confluent.ksql.api.server.Server;\n+import io.vertx.codegen.annotations.Nullable;\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.HttpServerOptions;\n+import io.vertx.core.http.HttpVersion;\n+import io.vertx.core.json.JsonArray;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.core.net.PemKeyCertOptions;\n+import io.vertx.core.streams.ReadStream;\n+import io.vertx.core.streams.WriteStream;\n+import io.vertx.ext.web.client.HttpResponse;\n+import io.vertx.ext.web.client.WebClient;\n+import io.vertx.ext.web.client.WebClientOptions;\n+import io.vertx.ext.web.codec.BodyCodec;\n+import java.io.FileNotFoundException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Supplier;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class ApiTest {\n+\n+  private static final long WAIT_TIMEOUT = 10000;\n+  private static final JsonArray DEFAULT_COLUMN_NAMES = new JsonArray().add(\"name\").add(\"age\")\n+      .add(\"male\");\n+  private static final JsonArray DEFAULT_COLUMN_TYPES = new JsonArray().add(\"STRING\").add(\"INT\")\n+      .add(\"BOOLEAN\");\n+  private static final List<JsonArray> DEFAULT_ROWS = generateRows();\n+\n+  private Vertx vertx;\n+  private Server server;\n+  private TestEndpoints testEndpoints;\n+  private WebClient client;\n+\n+  @Before\n+  public void setUp() throws Throwable {\n+\n+    vertx = Vertx.vertx();\n+\n+    HttpServerOptions httpServerOptions =\n+        new HttpServerOptions()\n+            .setHost(\"localhost\")\n+            .setPort(8089)\n+            .setUseAlpn(true)\n+            .setSsl(true)\n+            .setPemKeyCertOptions(\n+                new PemKeyCertOptions().setKeyPath(findFilePath(\"test-server-key.pem\"))\n+                    .setCertPath(findFilePath(\"test-server-cert.pem\"))\n+            );", "originalCommit": "92ac3ce0feac9acd143b159b24e085c57ada49aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzUxNzM5NQ==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r367517395", "bodyText": "Do you know what kind of key store ServerKeyStore contains? Is it JKS? I had an initial attempt to get it to work with Vert.x, but it didn't like it.", "author": "purplefox", "createdAt": "2020-01-16T16:24:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQzMDExMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzUyMDQzMg==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r367520432", "bodyText": "One thing with Vert.x - you can also provide the keystore/truststore as a buffer, so no need to save it to a temporary file and load it from there. Once we get to the point of removing Jetty we can simplify the ServerKeyStore class to be fully in memory.", "author": "purplefox", "createdAt": "2020-01-16T16:29:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzQzMDExMA=="}], "type": "inlineReview"}, {"oid": "6e3ab13e06f480e63c038bd634fb050b27e979b7", "url": "https://github.com/confluentinc/ksql/commit/6e3ab13e06f480e63c038bd634fb050b27e979b7", "message": "Implement bare bones server", "committedDate": "2020-01-16T20:40:14Z", "type": "commit"}, {"oid": "6e3ab13e06f480e63c038bd634fb050b27e979b7", "url": "https://github.com/confluentinc/ksql/commit/6e3ab13e06f480e63c038bd634fb050b27e979b7", "message": "Implement bare bones server", "committedDate": "2020-01-16T20:40:14Z", "type": "forcePushed"}, {"oid": "521fa777964c12a51492923ead5fdbf9d918f648", "url": "https://github.com/confluentinc/ksql/commit/521fa777964c12a51492923ead5fdbf9d918f648", "message": "Updates from review", "committedDate": "2020-01-17T06:31:47Z", "type": "commit"}, {"oid": "93e53febe73e22a9af84c510e6c3c6877f326d82", "url": "https://github.com/confluentinc/ksql/commit/93e53febe73e22a9af84c510e6c3c6877f326d82", "message": "a few more updates", "committedDate": "2020-01-17T06:54:41Z", "type": "commit"}, {"oid": "941a4ca39f1c9d0198948f02bcac4736f351239a", "url": "https://github.com/confluentinc/ksql/commit/941a4ca39f1c9d0198948f02bcac4736f351239a", "message": "findbugs and checkstyle", "committedDate": "2020-01-17T08:24:24Z", "type": "commit"}, {"oid": "1abba4b5eab82f21a93441721e3d988a1080248e", "url": "https://github.com/confluentinc/ksql/commit/1abba4b5eab82f21a93441721e3d988a1080248e", "message": "checkstyle", "committedDate": "2020-01-17T09:30:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA2NDc2Mw==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r368064763", "bodyText": "javadoc please \ud83d\ude4f  unless this is some standard terminology I'm not aware of, I'm not sure what \"connecting a promise\" means", "author": "agavra", "createdAt": "2020-01-17T18:03:08Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/impl/Utils.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.impl;\n+\n+import io.vertx.core.Future;\n+import io.vertx.core.Promise;\n+\n+/**\n+ * General purpose utils (not limited to the server, could be used by client too) for the API\n+ * module.\n+ */\n+public final class Utils {\n+\n+  private Utils() {\n+  }\n+\n+  public static <T> void connectPromise(final Future<T> future, final Promise<T> promise) {", "originalCommit": "1abba4b5eab82f21a93441721e3d988a1080248e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ1NzExNA==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r369457114", "bodyText": "Added some javadoc", "author": "purplefox", "createdAt": "2020-01-22T09:45:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA2NDc2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA3NDAwNg==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r368074006", "bodyText": "It took me some time to understand what this API does. Does it indicate that we've completed all the inserts we want to send? Do we expect it to be called more than once? Maybe we can name it requestClose(final long expectedAcks). Would also help to have javadoc around here.\nAlso instead of using a single Long to indicate two things: both that we should close and the value of acks expected, I think it would be safer (avoid unboxing a null value) and easier to read if we split it into a flag boolean closeRequested and long expectedAcks", "author": "agavra", "createdAt": "2020-01-17T18:26:19Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/AcksSubscriber.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_INTERNAL_ERROR;\n+\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.HttpServerResponse;\n+import io.vertx.core.json.JsonObject;\n+import java.util.Objects;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * As the stream of inserts is processed by the back-end, it communicates success (or failure) of\n+ * each insert by sending a stream of acks back in the other direction. This class is the subscriber\n+ * which subscribes to that stream of acks and sends them back to the client. It's a reactive\n+ * streams subscriber so implements back pressure.\n+ */\n+public class AcksSubscriber implements Subscriber<Void> {\n+\n+  private static final Logger log = LoggerFactory.getLogger(AcksSubscriber.class);\n+  private static final int BATCH_SIZE = 4;\n+  private static final Buffer ACK_RESPONSE_LINE = new JsonObject().put(\"status\", \"ok\").toBuffer()\n+      .appendString(\"\\n\");\n+\n+  private final HttpServerResponse response;\n+  private Subscription subscription;\n+  private long tokens;\n+  private Long insertsSent;\n+  private long acksSent;\n+\n+  public AcksSubscriber(final HttpServerResponse response) {\n+    this.response = Objects.requireNonNull(response);\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(final Subscription subscription) {\n+    Objects.requireNonNull(subscription);\n+    if (this.subscription != null) {\n+      throw new IllegalStateException(\"Already subscribed\");\n+    }\n+    this.subscription = subscription;\n+    checkRequestTokens();\n+  }\n+\n+  @Override\n+  public synchronized void onNext(final Void vo) {\n+    if (tokens == 0) {\n+      throw new IllegalStateException(\"Unsolicited data\");\n+    }\n+    response.write(ACK_RESPONSE_LINE);\n+    acksSent++;\n+    tokens--;\n+    if (insertsSent != null && insertsSent == acksSent) {\n+      close();\n+    } else if (response.writeQueueFull()) {\n+      response.drainHandler(v -> checkRequestTokens());\n+    } else {\n+      checkRequestTokens();\n+    }\n+  }\n+\n+  synchronized void insertsSent(final long num) {", "originalCommit": "1abba4b5eab82f21a93441721e3d988a1080248e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ1NzI3Ng==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r369457276", "bodyText": "out of date", "author": "purplefox", "createdAt": "2020-01-22T09:45:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA3NDAwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA3NTUzNQ==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r368075535", "bodyText": "I'm unclear what this drainHandler method does. Looking at the JavaDoc it suggests that it sets the handler - is there any reason we need to set it every time the response queue fills up or can we just set it once on startup?", "author": "agavra", "createdAt": "2020-01-17T18:30:10Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/AcksSubscriber.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_INTERNAL_ERROR;\n+\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.HttpServerResponse;\n+import io.vertx.core.json.JsonObject;\n+import java.util.Objects;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * As the stream of inserts is processed by the back-end, it communicates success (or failure) of\n+ * each insert by sending a stream of acks back in the other direction. This class is the subscriber\n+ * which subscribes to that stream of acks and sends them back to the client. It's a reactive\n+ * streams subscriber so implements back pressure.\n+ */\n+public class AcksSubscriber implements Subscriber<Void> {\n+\n+  private static final Logger log = LoggerFactory.getLogger(AcksSubscriber.class);\n+  private static final int BATCH_SIZE = 4;\n+  private static final Buffer ACK_RESPONSE_LINE = new JsonObject().put(\"status\", \"ok\").toBuffer()\n+      .appendString(\"\\n\");\n+\n+  private final HttpServerResponse response;\n+  private Subscription subscription;\n+  private long tokens;\n+  private Long insertsSent;\n+  private long acksSent;\n+\n+  public AcksSubscriber(final HttpServerResponse response) {\n+    this.response = Objects.requireNonNull(response);\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(final Subscription subscription) {\n+    Objects.requireNonNull(subscription);\n+    if (this.subscription != null) {\n+      throw new IllegalStateException(\"Already subscribed\");\n+    }\n+    this.subscription = subscription;\n+    checkRequestTokens();\n+  }\n+\n+  @Override\n+  public synchronized void onNext(final Void vo) {\n+    if (tokens == 0) {\n+      throw new IllegalStateException(\"Unsolicited data\");\n+    }\n+    response.write(ACK_RESPONSE_LINE);\n+    acksSent++;\n+    tokens--;\n+    if (insertsSent != null && insertsSent == acksSent) {\n+      close();\n+    } else if (response.writeQueueFull()) {\n+      response.drainHandler(v -> checkRequestTokens());", "originalCommit": "1abba4b5eab82f21a93441721e3d988a1080248e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ1NzQ5OA==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r369457498", "bodyText": "answered in subsequent PR", "author": "purplefox", "createdAt": "2020-01-22T09:45:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA3NTUzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA3NjgwNw==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r368076807", "bodyText": "I thought I saw @big-andy-coates comment this somewhere, but I agree with him that it's better if we can have jackson POJOs for these (and the ACK_RESPONSE_LINE) so that the schema is clear and well defined. Something I've found very useful is to be able to go to a single package and see all of the serialized object schemas that we're sending (e.g. io.confluent.ksql.rest.entity). I understand this adds a little bulk, but I think it's worth it in this case.", "author": "agavra", "createdAt": "2020-01-17T18:33:13Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/AcksSubscriber.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_INTERNAL_ERROR;\n+\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.HttpServerResponse;\n+import io.vertx.core.json.JsonObject;\n+import java.util.Objects;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * As the stream of inserts is processed by the back-end, it communicates success (or failure) of\n+ * each insert by sending a stream of acks back in the other direction. This class is the subscriber\n+ * which subscribes to that stream of acks and sends them back to the client. It's a reactive\n+ * streams subscriber so implements back pressure.\n+ */\n+public class AcksSubscriber implements Subscriber<Void> {\n+\n+  private static final Logger log = LoggerFactory.getLogger(AcksSubscriber.class);\n+  private static final int BATCH_SIZE = 4;\n+  private static final Buffer ACK_RESPONSE_LINE = new JsonObject().put(\"status\", \"ok\").toBuffer()\n+      .appendString(\"\\n\");\n+\n+  private final HttpServerResponse response;\n+  private Subscription subscription;\n+  private long tokens;\n+  private Long insertsSent;\n+  private long acksSent;\n+\n+  public AcksSubscriber(final HttpServerResponse response) {\n+    this.response = Objects.requireNonNull(response);\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(final Subscription subscription) {\n+    Objects.requireNonNull(subscription);\n+    if (this.subscription != null) {\n+      throw new IllegalStateException(\"Already subscribed\");\n+    }\n+    this.subscription = subscription;\n+    checkRequestTokens();\n+  }\n+\n+  @Override\n+  public synchronized void onNext(final Void vo) {\n+    if (tokens == 0) {\n+      throw new IllegalStateException(\"Unsolicited data\");\n+    }\n+    response.write(ACK_RESPONSE_LINE);\n+    acksSent++;\n+    tokens--;\n+    if (insertsSent != null && insertsSent == acksSent) {\n+      close();\n+    } else if (response.writeQueueFull()) {\n+      response.drainHandler(v -> checkRequestTokens());\n+    } else {\n+      checkRequestTokens();\n+    }\n+  }\n+\n+  synchronized void insertsSent(final long num) {\n+    this.insertsSent = num;\n+    if (acksSent == num) {\n+      close();\n+    }\n+  }\n+\n+  private void close() {\n+    response.end();\n+    subscription.cancel();\n+  }\n+\n+  private void checkRequestTokens() {\n+    if (tokens == 0) {\n+      tokens = BATCH_SIZE;\n+      subscription.request(BATCH_SIZE);\n+    }\n+  }\n+\n+  @Override\n+  public synchronized void onError(final Throwable t) {\n+    log.error(\"Error in processing inserts\", t);\n+    final JsonObject err = new JsonObject().put(\"status\", \"error\")\n+        .put(\"errorCode\", ERROR_CODE_INTERNAL_ERROR)\n+        .put(\"message\", \"Error in processing inserts\");", "originalCommit": "1abba4b5eab82f21a93441721e3d988a1080248e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ1NzYxNQ==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r369457615", "bodyText": "addressed in POJO PR", "author": "purplefox", "createdAt": "2020-01-22T09:46:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA3NjgwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA3NzcyNw==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r368077727", "bodyText": "if subscription.cancel is idempotent can we just call close here?", "author": "agavra", "createdAt": "2020-01-17T18:35:29Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/AcksSubscriber.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_INTERNAL_ERROR;\n+\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.HttpServerResponse;\n+import io.vertx.core.json.JsonObject;\n+import java.util.Objects;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * As the stream of inserts is processed by the back-end, it communicates success (or failure) of\n+ * each insert by sending a stream of acks back in the other direction. This class is the subscriber\n+ * which subscribes to that stream of acks and sends them back to the client. It's a reactive\n+ * streams subscriber so implements back pressure.\n+ */\n+public class AcksSubscriber implements Subscriber<Void> {\n+\n+  private static final Logger log = LoggerFactory.getLogger(AcksSubscriber.class);\n+  private static final int BATCH_SIZE = 4;\n+  private static final Buffer ACK_RESPONSE_LINE = new JsonObject().put(\"status\", \"ok\").toBuffer()\n+      .appendString(\"\\n\");\n+\n+  private final HttpServerResponse response;\n+  private Subscription subscription;\n+  private long tokens;\n+  private Long insertsSent;\n+  private long acksSent;\n+\n+  public AcksSubscriber(final HttpServerResponse response) {\n+    this.response = Objects.requireNonNull(response);\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(final Subscription subscription) {\n+    Objects.requireNonNull(subscription);\n+    if (this.subscription != null) {\n+      throw new IllegalStateException(\"Already subscribed\");\n+    }\n+    this.subscription = subscription;\n+    checkRequestTokens();\n+  }\n+\n+  @Override\n+  public synchronized void onNext(final Void vo) {\n+    if (tokens == 0) {\n+      throw new IllegalStateException(\"Unsolicited data\");\n+    }\n+    response.write(ACK_RESPONSE_LINE);\n+    acksSent++;\n+    tokens--;\n+    if (insertsSent != null && insertsSent == acksSent) {\n+      close();\n+    } else if (response.writeQueueFull()) {\n+      response.drainHandler(v -> checkRequestTokens());\n+    } else {\n+      checkRequestTokens();\n+    }\n+  }\n+\n+  synchronized void insertsSent(final long num) {\n+    this.insertsSent = num;\n+    if (acksSent == num) {\n+      close();\n+    }\n+  }\n+\n+  private void close() {\n+    response.end();\n+    subscription.cancel();\n+  }\n+\n+  private void checkRequestTokens() {\n+    if (tokens == 0) {\n+      tokens = BATCH_SIZE;\n+      subscription.request(BATCH_SIZE);\n+    }\n+  }\n+\n+  @Override\n+  public synchronized void onError(final Throwable t) {\n+    log.error(\"Error in processing inserts\", t);\n+    final JsonObject err = new JsonObject().put(\"status\", \"error\")\n+        .put(\"errorCode\", ERROR_CODE_INTERNAL_ERROR)\n+        .put(\"message\", \"Error in processing inserts\");\n+    subscription.cancel();\n+    response.end(err.toBuffer());\n+  }\n+\n+  @Override\n+  public synchronized void onComplete() {\n+    response.end();", "originalCommit": "1abba4b5eab82f21a93441721e3d988a1080248e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ1Nzc0Nw==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r369457747", "bodyText": "out of date", "author": "purplefox", "createdAt": "2020-01-22T09:46:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA3NzcyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA3ODExMw==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r368078113", "bodyText": "does the drainHandler trigger asyncrhonously? if so this method may also need to be synchronized", "author": "agavra", "createdAt": "2020-01-17T18:36:22Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/AcksSubscriber.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_INTERNAL_ERROR;\n+\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.HttpServerResponse;\n+import io.vertx.core.json.JsonObject;\n+import java.util.Objects;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * As the stream of inserts is processed by the back-end, it communicates success (or failure) of\n+ * each insert by sending a stream of acks back in the other direction. This class is the subscriber\n+ * which subscribes to that stream of acks and sends them back to the client. It's a reactive\n+ * streams subscriber so implements back pressure.\n+ */\n+public class AcksSubscriber implements Subscriber<Void> {\n+\n+  private static final Logger log = LoggerFactory.getLogger(AcksSubscriber.class);\n+  private static final int BATCH_SIZE = 4;\n+  private static final Buffer ACK_RESPONSE_LINE = new JsonObject().put(\"status\", \"ok\").toBuffer()\n+      .appendString(\"\\n\");\n+\n+  private final HttpServerResponse response;\n+  private Subscription subscription;\n+  private long tokens;\n+  private Long insertsSent;\n+  private long acksSent;\n+\n+  public AcksSubscriber(final HttpServerResponse response) {\n+    this.response = Objects.requireNonNull(response);\n+  }\n+\n+  @Override\n+  public synchronized void onSubscribe(final Subscription subscription) {\n+    Objects.requireNonNull(subscription);\n+    if (this.subscription != null) {\n+      throw new IllegalStateException(\"Already subscribed\");\n+    }\n+    this.subscription = subscription;\n+    checkRequestTokens();\n+  }\n+\n+  @Override\n+  public synchronized void onNext(final Void vo) {\n+    if (tokens == 0) {\n+      throw new IllegalStateException(\"Unsolicited data\");\n+    }\n+    response.write(ACK_RESPONSE_LINE);\n+    acksSent++;\n+    tokens--;\n+    if (insertsSent != null && insertsSent == acksSent) {\n+      close();\n+    } else if (response.writeQueueFull()) {\n+      response.drainHandler(v -> checkRequestTokens());\n+    } else {\n+      checkRequestTokens();\n+    }\n+  }\n+\n+  synchronized void insertsSent(final long num) {\n+    this.insertsSent = num;\n+    if (acksSent == num) {\n+      close();\n+    }\n+  }\n+\n+  private void close() {", "originalCommit": "1abba4b5eab82f21a93441721e3d988a1080248e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ1Nzg5Nw==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r369457897", "bodyText": "out of date / answered in other PR", "author": "purplefox", "createdAt": "2020-01-22T09:46:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA3ODExMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA4MDMwNw==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r368080307", "bodyText": "nit: since this is a \"public\" API, it might benefit from giving an example so people don't need to grok descriptions", "author": "agavra", "createdAt": "2020-01-17T18:41:59Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/InsertsBodyParser.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_MISSING_PARAM;\n+import static io.confluent.ksql.api.server.ServerUtils.handleError;\n+\n+import io.confluent.ksql.api.spi.Endpoints;\n+import io.confluent.ksql.api.spi.InsertsSubscriber;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.web.RoutingContext;\n+import java.util.Objects;\n+\n+/**\n+ * This class handles the parsing of the request body for a stream of inserts. The user can send a\n+ * stream of inserts to the server by opening an HTTP2 request to the server at the appropriate uri\n+ * and POSTing a request. The request must contain an initial JSON object (encoded as UTF-8 text)\n+ * which contains the arguments for the request (e.g. the target to insert into, and whether acks\n+ * are wanted) This must be followed by a new line, and then followed by zero or more JSON objects\n+ * (also encoded as UTF-8 text) each representing a row to insert. The last JSON object must be\n+ * followed by a new-line.", "originalCommit": "1abba4b5eab82f21a93441721e3d988a1080248e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ1ODEwMg==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r369458102", "bodyText": "Overkill at this stage imho", "author": "purplefox", "createdAt": "2020-01-22T09:47:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA4MDMwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA4MDc3Mw==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r368080773", "bodyText": "does this need to be synchronized with handleBodyBuffer or is it impossible that they will come in concurrently?", "author": "agavra", "createdAt": "2020-01-17T18:43:03Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/InsertsBodyParser.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_MISSING_PARAM;\n+import static io.confluent.ksql.api.server.ServerUtils.handleError;\n+\n+import io.confluent.ksql.api.spi.Endpoints;\n+import io.confluent.ksql.api.spi.InsertsSubscriber;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.web.RoutingContext;\n+import java.util.Objects;\n+\n+/**\n+ * This class handles the parsing of the request body for a stream of inserts. The user can send a\n+ * stream of inserts to the server by opening an HTTP2 request to the server at the appropriate uri\n+ * and POSTing a request. The request must contain an initial JSON object (encoded as UTF-8 text)\n+ * which contains the arguments for the request (e.g. the target to insert into, and whether acks\n+ * are wanted) This must be followed by a new line, and then followed by zero or more JSON objects\n+ * (also encoded as UTF-8 text) each representing a row to insert. The last JSON object must be\n+ * followed by a new-line.\n+ */\n+public class InsertsBodyParser {\n+\n+  private final Endpoints endpoints;\n+  private final RoutingContext routingContext;\n+  private boolean readArguments;\n+  private InsertsPublisher publisher;\n+  private long rowsReceived;\n+  private AcksSubscriber acksSubscriber;\n+\n+  public InsertsBodyParser(final Endpoints endpoints, final RoutingContext routingContext) {\n+    this.endpoints = Objects.requireNonNull(endpoints);\n+    this.routingContext = Objects.requireNonNull(routingContext);\n+    routingContext.response().endHandler(v -> {\n+      if (publisher != null) {\n+        publisher.close();\n+      }", "originalCommit": "1abba4b5eab82f21a93441721e3d988a1080248e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ1ODI3Mg==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r369458272", "bodyText": "it's impossible as per Vert.x threading model", "author": "purplefox", "createdAt": "2020-01-22T09:47:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA4MDc3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA4MTgxNw==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r368081817", "bodyText": "personal preference and totally unenforceable (so feel free to disagree) but I would be made very happy if we added some white space in this method to split up logical components \ud83d\ude02 code without whitespace feels like a run-on sentence", "author": "agavra", "createdAt": "2020-01-17T18:45:50Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/InsertsBodyParser.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_MISSING_PARAM;\n+import static io.confluent.ksql.api.server.ServerUtils.handleError;\n+\n+import io.confluent.ksql.api.spi.Endpoints;\n+import io.confluent.ksql.api.spi.InsertsSubscriber;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.web.RoutingContext;\n+import java.util.Objects;\n+\n+/**\n+ * This class handles the parsing of the request body for a stream of inserts. The user can send a\n+ * stream of inserts to the server by opening an HTTP2 request to the server at the appropriate uri\n+ * and POSTing a request. The request must contain an initial JSON object (encoded as UTF-8 text)\n+ * which contains the arguments for the request (e.g. the target to insert into, and whether acks\n+ * are wanted) This must be followed by a new line, and then followed by zero or more JSON objects\n+ * (also encoded as UTF-8 text) each representing a row to insert. The last JSON object must be\n+ * followed by a new-line.\n+ */\n+public class InsertsBodyParser {\n+\n+  private final Endpoints endpoints;\n+  private final RoutingContext routingContext;\n+  private boolean readArguments;\n+  private InsertsPublisher publisher;\n+  private long rowsReceived;\n+  private AcksSubscriber acksSubscriber;\n+\n+  public InsertsBodyParser(final Endpoints endpoints, final RoutingContext routingContext) {\n+    this.endpoints = Objects.requireNonNull(endpoints);\n+    this.routingContext = Objects.requireNonNull(routingContext);\n+    routingContext.response().endHandler(v -> {\n+      if (publisher != null) {\n+        publisher.close();\n+      }\n+    });\n+  }\n+\n+  public void handleBodyEnd(final Void v) {\n+    if (acksSubscriber == null) {\n+      routingContext.response().end();\n+    } else {\n+      // We close the response after the stream of acks has been sent\n+      acksSubscriber.insertsSent(rowsReceived);\n+    }\n+  }\n+\n+  public void handleBodyBuffer(final Buffer buff) {", "originalCommit": "1abba4b5eab82f21a93441721e3d988a1080248e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ1ODQzMQ==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r369458431", "bodyText": "Noted", "author": "purplefox", "createdAt": "2020-01-22T09:47:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA4MTgxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA4MjI0MQ==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r368082241", "bodyText": "same comment as above - it would be nice to have Jackson handle this schema validation for us (and as a way of documenting the public API programmatically)", "author": "agavra", "createdAt": "2020-01-17T18:46:53Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/InsertsBodyParser.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_MISSING_PARAM;\n+import static io.confluent.ksql.api.server.ServerUtils.handleError;\n+\n+import io.confluent.ksql.api.spi.Endpoints;\n+import io.confluent.ksql.api.spi.InsertsSubscriber;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.web.RoutingContext;\n+import java.util.Objects;\n+\n+/**\n+ * This class handles the parsing of the request body for a stream of inserts. The user can send a\n+ * stream of inserts to the server by opening an HTTP2 request to the server at the appropriate uri\n+ * and POSTing a request. The request must contain an initial JSON object (encoded as UTF-8 text)\n+ * which contains the arguments for the request (e.g. the target to insert into, and whether acks\n+ * are wanted) This must be followed by a new line, and then followed by zero or more JSON objects\n+ * (also encoded as UTF-8 text) each representing a row to insert. The last JSON object must be\n+ * followed by a new-line.\n+ */\n+public class InsertsBodyParser {\n+\n+  private final Endpoints endpoints;\n+  private final RoutingContext routingContext;\n+  private boolean readArguments;\n+  private InsertsPublisher publisher;\n+  private long rowsReceived;\n+  private AcksSubscriber acksSubscriber;\n+\n+  public InsertsBodyParser(final Endpoints endpoints, final RoutingContext routingContext) {\n+    this.endpoints = Objects.requireNonNull(endpoints);\n+    this.routingContext = Objects.requireNonNull(routingContext);\n+    routingContext.response().endHandler(v -> {\n+      if (publisher != null) {\n+        publisher.close();\n+      }\n+    });\n+  }\n+\n+  public void handleBodyEnd(final Void v) {\n+    if (acksSubscriber == null) {\n+      routingContext.response().end();\n+    } else {\n+      // We close the response after the stream of acks has been sent\n+      acksSubscriber.insertsSent(rowsReceived);\n+    }\n+  }\n+\n+  public void handleBodyBuffer(final Buffer buff) {\n+    if (!readArguments) {\n+      final JsonObject args = new JsonObject(buff);\n+      readArguments = true;\n+      final String target = args.getString(\"target\");\n+      if (target == null) {\n+        handleError(routingContext.response(), 400, ERROR_CODE_MISSING_PARAM,\n+            \"No target in arguments\");\n+        return;\n+      }\n+      final Boolean acks = args.getBoolean(\"acks\");\n+      if (acks == null) {\n+        handleError(routingContext.response(), 400, ERROR_CODE_MISSING_PARAM,\n+            \"No acks in arguments\");\n+        return;\n+      }\n+      final JsonObject properties = args.getJsonObject(\"properties\");", "originalCommit": "1abba4b5eab82f21a93441721e3d988a1080248e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ1ODU4NA==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r369458584", "bodyText": "See POJOs PR", "author": "purplefox", "createdAt": "2020-01-22T09:47:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA4MjI0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA4MjUyOA==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r368082528", "bodyText": "we should name this something like requireAcks - acks sounds like a count of acks, not a boolean. Since this is public API I do feel like it's important to make it extra clear", "author": "agavra", "createdAt": "2020-01-17T18:47:38Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/InsertsBodyParser.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_MISSING_PARAM;\n+import static io.confluent.ksql.api.server.ServerUtils.handleError;\n+\n+import io.confluent.ksql.api.spi.Endpoints;\n+import io.confluent.ksql.api.spi.InsertsSubscriber;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.web.RoutingContext;\n+import java.util.Objects;\n+\n+/**\n+ * This class handles the parsing of the request body for a stream of inserts. The user can send a\n+ * stream of inserts to the server by opening an HTTP2 request to the server at the appropriate uri\n+ * and POSTing a request. The request must contain an initial JSON object (encoded as UTF-8 text)\n+ * which contains the arguments for the request (e.g. the target to insert into, and whether acks\n+ * are wanted) This must be followed by a new line, and then followed by zero or more JSON objects\n+ * (also encoded as UTF-8 text) each representing a row to insert. The last JSON object must be\n+ * followed by a new-line.\n+ */\n+public class InsertsBodyParser {\n+\n+  private final Endpoints endpoints;\n+  private final RoutingContext routingContext;\n+  private boolean readArguments;\n+  private InsertsPublisher publisher;\n+  private long rowsReceived;\n+  private AcksSubscriber acksSubscriber;\n+\n+  public InsertsBodyParser(final Endpoints endpoints, final RoutingContext routingContext) {\n+    this.endpoints = Objects.requireNonNull(endpoints);\n+    this.routingContext = Objects.requireNonNull(routingContext);\n+    routingContext.response().endHandler(v -> {\n+      if (publisher != null) {\n+        publisher.close();\n+      }\n+    });\n+  }\n+\n+  public void handleBodyEnd(final Void v) {\n+    if (acksSubscriber == null) {\n+      routingContext.response().end();\n+    } else {\n+      // We close the response after the stream of acks has been sent\n+      acksSubscriber.insertsSent(rowsReceived);\n+    }\n+  }\n+\n+  public void handleBodyBuffer(final Buffer buff) {\n+    if (!readArguments) {\n+      final JsonObject args = new JsonObject(buff);\n+      readArguments = true;\n+      final String target = args.getString(\"target\");\n+      if (target == null) {\n+        handleError(routingContext.response(), 400, ERROR_CODE_MISSING_PARAM,\n+            \"No target in arguments\");\n+        return;\n+      }\n+      final Boolean acks = args.getBoolean(\"acks\");", "originalCommit": "1abba4b5eab82f21a93441721e3d988a1080248e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ1ODY1OQ==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r369458659", "bodyText": "Ack", "author": "purplefox", "createdAt": "2020-01-22T09:48:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA4MjUyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA4NDk3OA==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r368084978", "bodyText": "nit s/readArguments/hasReadArguments/ because the past tense and command form of \"read\" are the spelled same \ud83d\ude02", "author": "agavra", "createdAt": "2020-01-17T18:53:23Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/InsertsBodyParser.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_MISSING_PARAM;\n+import static io.confluent.ksql.api.server.ServerUtils.handleError;\n+\n+import io.confluent.ksql.api.spi.Endpoints;\n+import io.confluent.ksql.api.spi.InsertsSubscriber;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.web.RoutingContext;\n+import java.util.Objects;\n+\n+/**\n+ * This class handles the parsing of the request body for a stream of inserts. The user can send a\n+ * stream of inserts to the server by opening an HTTP2 request to the server at the appropriate uri\n+ * and POSTing a request. The request must contain an initial JSON object (encoded as UTF-8 text)\n+ * which contains the arguments for the request (e.g. the target to insert into, and whether acks\n+ * are wanted) This must be followed by a new line, and then followed by zero or more JSON objects\n+ * (also encoded as UTF-8 text) each representing a row to insert. The last JSON object must be\n+ * followed by a new-line.\n+ */\n+public class InsertsBodyParser {\n+\n+  private final Endpoints endpoints;\n+  private final RoutingContext routingContext;\n+  private boolean readArguments;\n+  private InsertsPublisher publisher;\n+  private long rowsReceived;\n+  private AcksSubscriber acksSubscriber;\n+\n+  public InsertsBodyParser(final Endpoints endpoints, final RoutingContext routingContext) {\n+    this.endpoints = Objects.requireNonNull(endpoints);\n+    this.routingContext = Objects.requireNonNull(routingContext);\n+    routingContext.response().endHandler(v -> {\n+      if (publisher != null) {\n+        publisher.close();\n+      }\n+    });\n+  }\n+\n+  public void handleBodyEnd(final Void v) {\n+    if (acksSubscriber == null) {\n+      routingContext.response().end();\n+    } else {\n+      // We close the response after the stream of acks has been sent\n+      acksSubscriber.insertsSent(rowsReceived);\n+    }\n+  }\n+\n+  public void handleBodyBuffer(final Buffer buff) {\n+    if (!readArguments) {", "originalCommit": "1abba4b5eab82f21a93441721e3d988a1080248e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ1ODk0Mw==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r369458943", "bodyText": "ack", "author": "purplefox", "createdAt": "2020-01-22T09:48:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA4NDk3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA4NTQ0MA==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r368085440", "bodyText": "I'm trying to understand the control flow here - if readArguments is true, and publisher is null (say because we handled an error) then should we be receiving any more body buffers? maybe we should throw an exception in a final else clause", "author": "agavra", "createdAt": "2020-01-17T18:54:27Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/InsertsBodyParser.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_MISSING_PARAM;\n+import static io.confluent.ksql.api.server.ServerUtils.handleError;\n+\n+import io.confluent.ksql.api.spi.Endpoints;\n+import io.confluent.ksql.api.spi.InsertsSubscriber;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.web.RoutingContext;\n+import java.util.Objects;\n+\n+/**\n+ * This class handles the parsing of the request body for a stream of inserts. The user can send a\n+ * stream of inserts to the server by opening an HTTP2 request to the server at the appropriate uri\n+ * and POSTing a request. The request must contain an initial JSON object (encoded as UTF-8 text)\n+ * which contains the arguments for the request (e.g. the target to insert into, and whether acks\n+ * are wanted) This must be followed by a new line, and then followed by zero or more JSON objects\n+ * (also encoded as UTF-8 text) each representing a row to insert. The last JSON object must be\n+ * followed by a new-line.\n+ */\n+public class InsertsBodyParser {\n+\n+  private final Endpoints endpoints;\n+  private final RoutingContext routingContext;\n+  private boolean readArguments;\n+  private InsertsPublisher publisher;\n+  private long rowsReceived;\n+  private AcksSubscriber acksSubscriber;\n+\n+  public InsertsBodyParser(final Endpoints endpoints, final RoutingContext routingContext) {\n+    this.endpoints = Objects.requireNonNull(endpoints);\n+    this.routingContext = Objects.requireNonNull(routingContext);\n+    routingContext.response().endHandler(v -> {\n+      if (publisher != null) {\n+        publisher.close();\n+      }\n+    });\n+  }\n+\n+  public void handleBodyEnd(final Void v) {\n+    if (acksSubscriber == null) {\n+      routingContext.response().end();\n+    } else {\n+      // We close the response after the stream of acks has been sent\n+      acksSubscriber.insertsSent(rowsReceived);\n+    }\n+  }\n+\n+  public void handleBodyBuffer(final Buffer buff) {\n+    if (!readArguments) {\n+      final JsonObject args = new JsonObject(buff);\n+      readArguments = true;\n+      final String target = args.getString(\"target\");\n+      if (target == null) {\n+        handleError(routingContext.response(), 400, ERROR_CODE_MISSING_PARAM,\n+            \"No target in arguments\");\n+        return;\n+      }\n+      final Boolean acks = args.getBoolean(\"acks\");\n+      if (acks == null) {\n+        handleError(routingContext.response(), 400, ERROR_CODE_MISSING_PARAM,\n+            \"No acks in arguments\");\n+        return;\n+      }\n+      final JsonObject properties = args.getJsonObject(\"properties\");\n+      routingContext.request().endHandler(this::handleBodyEnd);\n+      acksSubscriber = acks ? new AcksSubscriber(routingContext.response()) : null;\n+      final InsertsSubscriber insertsSubscriber = endpoints\n+          .createInsertsSubscriber(target, properties, acksSubscriber);\n+      publisher = new InsertsPublisher();\n+      publisher.subscribe(insertsSubscriber);\n+    } else if (publisher != null) {", "originalCommit": "1abba4b5eab82f21a93441721e3d988a1080248e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ2MDI4NA==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r369460284", "bodyText": "It seems correct to me. If arguments have been read and publisher is null then we drop any more buffers coming in. Note the the client may have written many inserts to the wire before we handle the args so it should be expected more will arrive after validation error", "author": "purplefox", "createdAt": "2020-01-22T09:51:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA4NTQ0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwMTg4NQ==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r368101885", "bodyText": "can this be private?", "author": "agavra", "createdAt": "2020-01-17T19:33:52Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/InsertsPublisher.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import io.vertx.core.json.JsonObject;\n+import java.util.LinkedList;\n+import java.util.Objects;\n+import java.util.Queue;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+/**\n+ * This class is a reactive streams publisher which publishes the inserts to a subscriber which is\n+ * provided by the back-end. As it's reactive streams it supports back pressure.\n+ */\n+public class InsertsPublisher implements Publisher<JsonObject> {\n+\n+  private final Queue<JsonObject> buffer = new LinkedList<>();\n+  private long demand;\n+  private Subscriber<? super JsonObject> subscriber;\n+\n+  @Override\n+  public synchronized void subscribe(final Subscriber<? super JsonObject> subscriber) {\n+    this.subscriber = Objects.requireNonNull(subscriber);\n+    subscriber.onSubscribe(new InsertsSubscription());\n+  }\n+\n+  public synchronized void receiveRow(final JsonObject row) {\n+    if (subscriber == null) {\n+      return;\n+    }\n+    if (demand > 0) {\n+      demand--;\n+      subscriber.onNext(row);\n+    } else {\n+      buffer.add(row);\n+    }\n+  }\n+\n+  synchronized void acceptTokens(final long number) {", "originalCommit": "1abba4b5eab82f21a93441721e3d988a1080248e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ2MDM4MQ==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r369460381", "bodyText": "out of date", "author": "purplefox", "createdAt": "2020-01-22T09:51:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwMTg4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwMzQ0MQ==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r368103441", "bodyText": "what happens if demand goes below 0. Is that Okay?", "author": "agavra", "createdAt": "2020-01-17T19:37:50Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/InsertsPublisher.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import io.vertx.core.json.JsonObject;\n+import java.util.LinkedList;\n+import java.util.Objects;\n+import java.util.Queue;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+/**\n+ * This class is a reactive streams publisher which publishes the inserts to a subscriber which is\n+ * provided by the back-end. As it's reactive streams it supports back pressure.\n+ */\n+public class InsertsPublisher implements Publisher<JsonObject> {\n+\n+  private final Queue<JsonObject> buffer = new LinkedList<>();\n+  private long demand;\n+  private Subscriber<? super JsonObject> subscriber;\n+\n+  @Override\n+  public synchronized void subscribe(final Subscriber<? super JsonObject> subscriber) {\n+    this.subscriber = Objects.requireNonNull(subscriber);\n+    subscriber.onSubscribe(new InsertsSubscription());\n+  }\n+\n+  public synchronized void receiveRow(final JsonObject row) {\n+    if (subscriber == null) {\n+      return;\n+    }\n+    if (demand > 0) {\n+      demand--;\n+      subscriber.onNext(row);\n+    } else {\n+      buffer.add(row);\n+    }\n+  }\n+\n+  synchronized void acceptTokens(final long number) {\n+    demand += number;\n+    for (int i = 0; i < buffer.size(); i++) {\n+      final JsonObject row = buffer.poll();\n+      demand--;", "originalCommit": "1abba4b5eab82f21a93441721e3d988a1080248e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ2MDQ2OA==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r369460468", "bodyText": "out of date", "author": "purplefox", "createdAt": "2020-01-22T09:51:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwMzQ0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwNDIwNw==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r368104207", "bodyText": "since this is a blocking operation, does it need to be inside the synchronized block? I'm worried all of these interlocking synchronized calls may cause some deadlocks at some point \ud83d\ude02 perhaps we can cross that bridge when we get there though", "author": "agavra", "createdAt": "2020-01-17T19:39:44Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/InsertsPublisher.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import io.vertx.core.json.JsonObject;\n+import java.util.LinkedList;\n+import java.util.Objects;\n+import java.util.Queue;\n+import org.reactivestreams.Publisher;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+\n+/**\n+ * This class is a reactive streams publisher which publishes the inserts to a subscriber which is\n+ * provided by the back-end. As it's reactive streams it supports back pressure.\n+ */\n+public class InsertsPublisher implements Publisher<JsonObject> {\n+\n+  private final Queue<JsonObject> buffer = new LinkedList<>();\n+  private long demand;\n+  private Subscriber<? super JsonObject> subscriber;\n+\n+  @Override\n+  public synchronized void subscribe(final Subscriber<? super JsonObject> subscriber) {\n+    this.subscriber = Objects.requireNonNull(subscriber);\n+    subscriber.onSubscribe(new InsertsSubscription());\n+  }\n+\n+  public synchronized void receiveRow(final JsonObject row) {\n+    if (subscriber == null) {\n+      return;\n+    }\n+    if (demand > 0) {\n+      demand--;\n+      subscriber.onNext(row);", "originalCommit": "1abba4b5eab82f21a93441721e3d988a1080248e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ2MDU0MA==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r369460540", "bodyText": "out of date", "author": "purplefox", "createdAt": "2020-01-22T09:51:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwNDIwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwNDMwMA==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r368104300", "bodyText": "nit: 2020", "author": "agavra", "createdAt": "2020-01-17T19:39:57Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/QueryID.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Copyright 2019 Confluent Inc.", "originalCommit": "1abba4b5eab82f21a93441721e3d988a1080248e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ2MDYwNQ==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r369460605", "bodyText": "ack", "author": "purplefox", "createdAt": "2020-01-22T09:51:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwNDMwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwNDcxMQ==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r368104711", "bodyText": "We already have a QueryID class in the code base - can we name this something more descriptive? Maybe this one should be ClientQueryId and the other PersistentQueryId", "author": "agavra", "createdAt": "2020-01-17T19:40:55Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/QueryID.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Copyright 2019 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import java.util.Objects;\n+import java.util.UUID;\n+\n+/**\n+ * Handle to a query that is passed to the client on query creation and can subsequently be used to\n+ * close a query. Uses UUID.randomUUID() which internally uses SecureRandom - this makes the id\n+ * cryptographically secure. This is important as we don't want random users guessing query IDs and\n+ * closing other peoples queries.\n+ */\n+public final class QueryID {", "originalCommit": "1abba4b5eab82f21a93441721e3d988a1080248e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODY1NjIzNQ==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r368656235", "bodyText": "Not PersistentQueryId.. we already have persitent queries...", "author": "big-andy-coates", "createdAt": "2020-01-20T17:13:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwNDcxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ2MTAzNA==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r369461034", "bodyText": "ack", "author": "purplefox", "createdAt": "2020-01-22T09:52:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwNDcxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwNTg2MA==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r368105860", "bodyText": "same comment as above - whitespace please if you're so kind \ud83d\ude4f", "author": "agavra", "createdAt": "2020-01-17T19:43:48Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/Server.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import io.confluent.ksql.api.impl.VertxCompletableFuture;\n+import io.confluent.ksql.api.spi.Endpoints;\n+import io.confluent.ksql.util.KsqlException;\n+import io.vertx.core.DeploymentOptions;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.http.HttpConnection;\n+import io.vertx.core.http.HttpServerOptions;\n+import io.vertx.core.impl.ConcurrentHashSet;\n+import io.vertx.core.json.JsonObject;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class represents the API server. On start-up it deploys multiple server verticles to spread\n+ * the load across available cores.\n+ */\n+public class Server {\n+\n+  private static final Logger log = LoggerFactory.getLogger(Server.class);\n+\n+  private final Vertx vertx;\n+  private final JsonObject config;\n+  private final Endpoints endpoints;\n+  private final HttpServerOptions httpServerOptions;\n+  private final Map<QueryID, QuerySubscriber> queries = new ConcurrentHashMap<>();\n+  private final Set<HttpConnection> connections = new ConcurrentHashSet<>();\n+  private String deploymentID;\n+\n+  public Server(final Vertx vertx, final JsonObject config, final Endpoints endpoints,\n+      final HttpServerOptions httpServerOptions) {\n+    this.vertx = Objects.requireNonNull(vertx);\n+    this.config = Objects.requireNonNull(config);\n+    this.endpoints = Objects.requireNonNull(endpoints);\n+    this.httpServerOptions = Objects.requireNonNull(httpServerOptions);\n+  }\n+\n+  public synchronized void start() {\n+    if (deploymentID != null) {", "originalCommit": "1abba4b5eab82f21a93441721e3d988a1080248e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ2MTE1Nw==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r369461157", "bodyText": "noted", "author": "purplefox", "createdAt": "2020-01-22T09:53:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwNTg2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwNjI1NQ==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r368106255", "bodyText": "nit: ksql configurations are usually . separated or camel case (e.g. ksql.vertex.verticleInstances", "author": "agavra", "createdAt": "2020-01-17T19:44:50Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/Server.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import io.confluent.ksql.api.impl.VertxCompletableFuture;\n+import io.confluent.ksql.api.spi.Endpoints;\n+import io.confluent.ksql.util.KsqlException;\n+import io.vertx.core.DeploymentOptions;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.http.HttpConnection;\n+import io.vertx.core.http.HttpServerOptions;\n+import io.vertx.core.impl.ConcurrentHashSet;\n+import io.vertx.core.json.JsonObject;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class represents the API server. On start-up it deploys multiple server verticles to spread\n+ * the load across available cores.\n+ */\n+public class Server {\n+\n+  private static final Logger log = LoggerFactory.getLogger(Server.class);\n+\n+  private final Vertx vertx;\n+  private final JsonObject config;\n+  private final Endpoints endpoints;\n+  private final HttpServerOptions httpServerOptions;\n+  private final Map<QueryID, QuerySubscriber> queries = new ConcurrentHashMap<>();\n+  private final Set<HttpConnection> connections = new ConcurrentHashSet<>();\n+  private String deploymentID;\n+\n+  public Server(final Vertx vertx, final JsonObject config, final Endpoints endpoints,\n+      final HttpServerOptions httpServerOptions) {\n+    this.vertx = Objects.requireNonNull(vertx);\n+    this.config = Objects.requireNonNull(config);\n+    this.endpoints = Objects.requireNonNull(endpoints);\n+    this.httpServerOptions = Objects.requireNonNull(httpServerOptions);\n+  }\n+\n+  public synchronized void start() {\n+    if (deploymentID != null) {\n+      throw new IllegalStateException(\"Already started\");\n+    }\n+    final DeploymentOptions options = new DeploymentOptions();\n+    final Integer verticleInstances = config.getInteger(\"verticle-instances\");", "originalCommit": "1abba4b5eab82f21a93441721e3d988a1080248e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ2MTQxOQ==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r369461419", "bodyText": "out of date with AbstractConfig PR", "author": "purplefox", "createdAt": "2020-01-22T09:53:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwNjI1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwNjcxOQ==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r368106719", "bodyText": "can we just return? if we never started do we need to throw an exception?", "author": "agavra", "createdAt": "2020-01-17T19:45:51Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/Server.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import io.confluent.ksql.api.impl.VertxCompletableFuture;\n+import io.confluent.ksql.api.spi.Endpoints;\n+import io.confluent.ksql.util.KsqlException;\n+import io.vertx.core.DeploymentOptions;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.http.HttpConnection;\n+import io.vertx.core.http.HttpServerOptions;\n+import io.vertx.core.impl.ConcurrentHashSet;\n+import io.vertx.core.json.JsonObject;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class represents the API server. On start-up it deploys multiple server verticles to spread\n+ * the load across available cores.\n+ */\n+public class Server {\n+\n+  private static final Logger log = LoggerFactory.getLogger(Server.class);\n+\n+  private final Vertx vertx;\n+  private final JsonObject config;\n+  private final Endpoints endpoints;\n+  private final HttpServerOptions httpServerOptions;\n+  private final Map<QueryID, QuerySubscriber> queries = new ConcurrentHashMap<>();\n+  private final Set<HttpConnection> connections = new ConcurrentHashSet<>();\n+  private String deploymentID;\n+\n+  public Server(final Vertx vertx, final JsonObject config, final Endpoints endpoints,\n+      final HttpServerOptions httpServerOptions) {\n+    this.vertx = Objects.requireNonNull(vertx);\n+    this.config = Objects.requireNonNull(config);\n+    this.endpoints = Objects.requireNonNull(endpoints);\n+    this.httpServerOptions = Objects.requireNonNull(httpServerOptions);\n+  }\n+\n+  public synchronized void start() {\n+    if (deploymentID != null) {\n+      throw new IllegalStateException(\"Already started\");\n+    }\n+    final DeploymentOptions options = new DeploymentOptions();\n+    final Integer verticleInstances = config.getInteger(\"verticle-instances\");\n+    if (verticleInstances == null) {\n+      options.setInstances(Runtime.getRuntime().availableProcessors() * 2);\n+    } else {\n+      options.setInstances(verticleInstances);\n+    }\n+    log.info(\"Deploying \" + options.getInstances() + \" instances of server verticle\");\n+    options.setConfig(config);\n+    final VertxCompletableFuture<String> future = new VertxCompletableFuture<>();\n+    vertx.deployVerticle(\n+        () -> new ServerVerticle(endpoints, httpServerOptions, this), options, future);\n+    try {\n+      deploymentID = future.get();\n+    } catch (Exception e) {\n+      throw new KsqlException(\"Failed to start API server\", e);\n+    }\n+    log.info(\"API server started: \" + deploymentID);\n+  }\n+\n+  public synchronized void stop() {\n+    if (deploymentID == null) {\n+      throw new IllegalStateException(\"Not started\");", "originalCommit": "1abba4b5eab82f21a93441721e3d988a1080248e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ2MTgwNQ==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r369461805", "bodyText": "I like throwing an exception as it can highlight errors in the callers life cycle management code.", "author": "purplefox", "createdAt": "2020-01-22T09:54:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwNjcxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwNzI1MA==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r368107250", "bodyText": "I think it could be nice to model this using Guava's AbstractIdleService which handles transitions between nascent, starting, running, shutting down, shutdown and failure. We can add a ticket for this to be done in the future", "author": "agavra", "createdAt": "2020-01-17T19:47:13Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/Server.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import io.confluent.ksql.api.impl.VertxCompletableFuture;\n+import io.confluent.ksql.api.spi.Endpoints;\n+import io.confluent.ksql.util.KsqlException;\n+import io.vertx.core.DeploymentOptions;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.http.HttpConnection;\n+import io.vertx.core.http.HttpServerOptions;\n+import io.vertx.core.impl.ConcurrentHashSet;\n+import io.vertx.core.json.JsonObject;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class represents the API server. On start-up it deploys multiple server verticles to spread\n+ * the load across available cores.\n+ */\n+public class Server {", "originalCommit": "1abba4b5eab82f21a93441721e3d988a1080248e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ2MzgyMg==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r369463822", "bodyText": "I would rather not use 3rd party libraries unless there is an extremely good reason to. I appreciate my bar is probably higher in this regard to others in the team.\nThis comes from many years writing frameworks and clients where it's super important to have minimal deps as they will be dragged into the user's application too. The more deps you have the longer the build, the bigger the binary size, and the probability of version clashes gets higher (especially with commonly used libs such as apache commons or Guava), and the surface area for security issues increases. Not to mention the barrier to entry for a new developer gets higher as they have to understand N libraries in order to understand the code.", "author": "purplefox", "createdAt": "2020-01-22T09:57:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwNzI1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwNzk5Ng==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r368107996", "bodyText": "putIfAbsent to avoid races in the (very) unlikely chance of a collision", "author": "agavra", "createdAt": "2020-01-17T19:49:06Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/Server.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import io.confluent.ksql.api.impl.VertxCompletableFuture;\n+import io.confluent.ksql.api.spi.Endpoints;\n+import io.confluent.ksql.util.KsqlException;\n+import io.vertx.core.DeploymentOptions;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.http.HttpConnection;\n+import io.vertx.core.http.HttpServerOptions;\n+import io.vertx.core.impl.ConcurrentHashSet;\n+import io.vertx.core.json.JsonObject;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class represents the API server. On start-up it deploys multiple server verticles to spread\n+ * the load across available cores.\n+ */\n+public class Server {\n+\n+  private static final Logger log = LoggerFactory.getLogger(Server.class);\n+\n+  private final Vertx vertx;\n+  private final JsonObject config;\n+  private final Endpoints endpoints;\n+  private final HttpServerOptions httpServerOptions;\n+  private final Map<QueryID, QuerySubscriber> queries = new ConcurrentHashMap<>();\n+  private final Set<HttpConnection> connections = new ConcurrentHashSet<>();\n+  private String deploymentID;\n+\n+  public Server(final Vertx vertx, final JsonObject config, final Endpoints endpoints,\n+      final HttpServerOptions httpServerOptions) {\n+    this.vertx = Objects.requireNonNull(vertx);\n+    this.config = Objects.requireNonNull(config);\n+    this.endpoints = Objects.requireNonNull(endpoints);\n+    this.httpServerOptions = Objects.requireNonNull(httpServerOptions);\n+  }\n+\n+  public synchronized void start() {\n+    if (deploymentID != null) {\n+      throw new IllegalStateException(\"Already started\");\n+    }\n+    final DeploymentOptions options = new DeploymentOptions();\n+    final Integer verticleInstances = config.getInteger(\"verticle-instances\");\n+    if (verticleInstances == null) {\n+      options.setInstances(Runtime.getRuntime().availableProcessors() * 2);\n+    } else {\n+      options.setInstances(verticleInstances);\n+    }\n+    log.info(\"Deploying \" + options.getInstances() + \" instances of server verticle\");\n+    options.setConfig(config);\n+    final VertxCompletableFuture<String> future = new VertxCompletableFuture<>();\n+    vertx.deployVerticle(\n+        () -> new ServerVerticle(endpoints, httpServerOptions, this), options, future);\n+    try {\n+      deploymentID = future.get();\n+    } catch (Exception e) {\n+      throw new KsqlException(\"Failed to start API server\", e);\n+    }\n+    log.info(\"API server started: \" + deploymentID);\n+  }\n+\n+  public synchronized void stop() {\n+    if (deploymentID == null) {\n+      throw new IllegalStateException(\"Not started\");\n+    }\n+    final VertxCompletableFuture<Void> future = new VertxCompletableFuture<>();\n+    vertx.undeploy(deploymentID, future);\n+    try {\n+      future.get();\n+    } catch (Exception e) {\n+      throw new KsqlException(\"Failure in stopping API server\", e);\n+    }\n+  }\n+\n+  QueryID registerQuery(final QuerySubscriber querySubscriber) {\n+    Objects.requireNonNull(querySubscriber);\n+    final QueryID queryID = new QueryID();\n+    queries.put(queryID, querySubscriber);", "originalCommit": "1abba4b5eab82f21a93441721e3d988a1080248e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ2NTAyNQ==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r369465025", "bodyText": "It won't happen, QueryID wraps a crytographically secure (i.e. evenly distributed) random UUID.", "author": "purplefox", "createdAt": "2020-01-22T10:00:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwNzk5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwODM2Mw==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r368108363", "bodyText": "we should document that this can return null if the query doesnt' exist (or maybe instead just return an Optional to indicate that)", "author": "agavra", "createdAt": "2020-01-17T19:50:02Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/Server.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import io.confluent.ksql.api.impl.VertxCompletableFuture;\n+import io.confluent.ksql.api.spi.Endpoints;\n+import io.confluent.ksql.util.KsqlException;\n+import io.vertx.core.DeploymentOptions;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.http.HttpConnection;\n+import io.vertx.core.http.HttpServerOptions;\n+import io.vertx.core.impl.ConcurrentHashSet;\n+import io.vertx.core.json.JsonObject;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class represents the API server. On start-up it deploys multiple server verticles to spread\n+ * the load across available cores.\n+ */\n+public class Server {\n+\n+  private static final Logger log = LoggerFactory.getLogger(Server.class);\n+\n+  private final Vertx vertx;\n+  private final JsonObject config;\n+  private final Endpoints endpoints;\n+  private final HttpServerOptions httpServerOptions;\n+  private final Map<QueryID, QuerySubscriber> queries = new ConcurrentHashMap<>();\n+  private final Set<HttpConnection> connections = new ConcurrentHashSet<>();\n+  private String deploymentID;\n+\n+  public Server(final Vertx vertx, final JsonObject config, final Endpoints endpoints,\n+      final HttpServerOptions httpServerOptions) {\n+    this.vertx = Objects.requireNonNull(vertx);\n+    this.config = Objects.requireNonNull(config);\n+    this.endpoints = Objects.requireNonNull(endpoints);\n+    this.httpServerOptions = Objects.requireNonNull(httpServerOptions);\n+  }\n+\n+  public synchronized void start() {\n+    if (deploymentID != null) {\n+      throw new IllegalStateException(\"Already started\");\n+    }\n+    final DeploymentOptions options = new DeploymentOptions();\n+    final Integer verticleInstances = config.getInteger(\"verticle-instances\");\n+    if (verticleInstances == null) {\n+      options.setInstances(Runtime.getRuntime().availableProcessors() * 2);\n+    } else {\n+      options.setInstances(verticleInstances);\n+    }\n+    log.info(\"Deploying \" + options.getInstances() + \" instances of server verticle\");\n+    options.setConfig(config);\n+    final VertxCompletableFuture<String> future = new VertxCompletableFuture<>();\n+    vertx.deployVerticle(\n+        () -> new ServerVerticle(endpoints, httpServerOptions, this), options, future);\n+    try {\n+      deploymentID = future.get();\n+    } catch (Exception e) {\n+      throw new KsqlException(\"Failed to start API server\", e);\n+    }\n+    log.info(\"API server started: \" + deploymentID);\n+  }\n+\n+  public synchronized void stop() {\n+    if (deploymentID == null) {\n+      throw new IllegalStateException(\"Not started\");\n+    }\n+    final VertxCompletableFuture<Void> future = new VertxCompletableFuture<>();\n+    vertx.undeploy(deploymentID, future);\n+    try {\n+      future.get();\n+    } catch (Exception e) {\n+      throw new KsqlException(\"Failure in stopping API server\", e);\n+    }\n+  }\n+\n+  QueryID registerQuery(final QuerySubscriber querySubscriber) {\n+    Objects.requireNonNull(querySubscriber);\n+    final QueryID queryID = new QueryID();\n+    queries.put(queryID, querySubscriber);\n+    return queryID;\n+  }\n+\n+  QuerySubscriber removeQuery(final QueryID queryID) {\n+    return queries.remove(queryID);", "originalCommit": "1abba4b5eab82f21a93441721e3d988a1080248e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ2NTU1NA==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r369465554", "bodyText": "Most probably this will change before production so I want to hold off putting in too much Javadoc", "author": "purplefox", "createdAt": "2020-01-22T10:01:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwODM2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwODU0OA==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r368108548", "bodyText": "Maybe ImmutableSet.copyOf?", "author": "agavra", "createdAt": "2020-01-17T19:50:31Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/Server.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import io.confluent.ksql.api.impl.VertxCompletableFuture;\n+import io.confluent.ksql.api.spi.Endpoints;\n+import io.confluent.ksql.util.KsqlException;\n+import io.vertx.core.DeploymentOptions;\n+import io.vertx.core.Vertx;\n+import io.vertx.core.http.HttpConnection;\n+import io.vertx.core.http.HttpServerOptions;\n+import io.vertx.core.impl.ConcurrentHashSet;\n+import io.vertx.core.json.JsonObject;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class represents the API server. On start-up it deploys multiple server verticles to spread\n+ * the load across available cores.\n+ */\n+public class Server {\n+\n+  private static final Logger log = LoggerFactory.getLogger(Server.class);\n+\n+  private final Vertx vertx;\n+  private final JsonObject config;\n+  private final Endpoints endpoints;\n+  private final HttpServerOptions httpServerOptions;\n+  private final Map<QueryID, QuerySubscriber> queries = new ConcurrentHashMap<>();\n+  private final Set<HttpConnection> connections = new ConcurrentHashSet<>();\n+  private String deploymentID;\n+\n+  public Server(final Vertx vertx, final JsonObject config, final Endpoints endpoints,\n+      final HttpServerOptions httpServerOptions) {\n+    this.vertx = Objects.requireNonNull(vertx);\n+    this.config = Objects.requireNonNull(config);\n+    this.endpoints = Objects.requireNonNull(endpoints);\n+    this.httpServerOptions = Objects.requireNonNull(httpServerOptions);\n+  }\n+\n+  public synchronized void start() {\n+    if (deploymentID != null) {\n+      throw new IllegalStateException(\"Already started\");\n+    }\n+    final DeploymentOptions options = new DeploymentOptions();\n+    final Integer verticleInstances = config.getInteger(\"verticle-instances\");\n+    if (verticleInstances == null) {\n+      options.setInstances(Runtime.getRuntime().availableProcessors() * 2);\n+    } else {\n+      options.setInstances(verticleInstances);\n+    }\n+    log.info(\"Deploying \" + options.getInstances() + \" instances of server verticle\");\n+    options.setConfig(config);\n+    final VertxCompletableFuture<String> future = new VertxCompletableFuture<>();\n+    vertx.deployVerticle(\n+        () -> new ServerVerticle(endpoints, httpServerOptions, this), options, future);\n+    try {\n+      deploymentID = future.get();\n+    } catch (Exception e) {\n+      throw new KsqlException(\"Failed to start API server\", e);\n+    }\n+    log.info(\"API server started: \" + deploymentID);\n+  }\n+\n+  public synchronized void stop() {\n+    if (deploymentID == null) {\n+      throw new IllegalStateException(\"Not started\");\n+    }\n+    final VertxCompletableFuture<Void> future = new VertxCompletableFuture<>();\n+    vertx.undeploy(deploymentID, future);\n+    try {\n+      future.get();\n+    } catch (Exception e) {\n+      throw new KsqlException(\"Failure in stopping API server\", e);\n+    }\n+  }\n+\n+  QueryID registerQuery(final QuerySubscriber querySubscriber) {\n+    Objects.requireNonNull(querySubscriber);\n+    final QueryID queryID = new QueryID();\n+    queries.put(queryID, querySubscriber);\n+    return queryID;\n+  }\n+\n+  QuerySubscriber removeQuery(final QueryID queryID) {\n+    return queries.remove(queryID);\n+  }\n+\n+  public Set<QueryID> getQueryIDs() {\n+    return new HashSet<>(queries.keySet());", "originalCommit": "1abba4b5eab82f21a93441721e3d988a1080248e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODY1Mjg0Ng==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r368652846", "bodyText": "Immutable types by default :D", "author": "big-andy-coates", "createdAt": "2020-01-20T17:05:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEwODU0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODExMTQ5MA==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r368111490", "bodyText": "I'm no REST expert, but wouldn't it be more \"restful\" to have this be HttpMethod.DELETE on a /query endpoint?", "author": "agavra", "createdAt": "2020-01-17T19:57:42Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/ServerVerticle.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_MISSING_PARAM;\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_UNKNOWN_QUERY_ID;\n+import static io.confluent.ksql.api.server.ServerUtils.handleError;\n+\n+import io.confluent.ksql.api.impl.Utils;\n+import io.confluent.ksql.api.spi.Endpoints;\n+import io.confluent.ksql.api.spi.QueryPublisher;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.core.Promise;\n+import io.vertx.core.http.HttpConnection;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.core.http.HttpServer;\n+import io.vertx.core.http.HttpServerOptions;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.core.parsetools.RecordParser;\n+import io.vertx.ext.web.Router;\n+import io.vertx.ext.web.RoutingContext;\n+import io.vertx.ext.web.handler.BodyHandler;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The server deploys multiple server verticles. This is where the HTTP2 requests are handled. The\n+ * actual implementation of the endpoints is provided by an implementation of {@code Endpoints}.\n+ */\n+public class ServerVerticle extends AbstractVerticle {\n+\n+  private static final Logger log = LoggerFactory.getLogger(ServerVerticle.class);\n+\n+  private final Endpoints endpoints;\n+  private final HttpServerOptions httpServerOptions;\n+  private final Server server;\n+  private final Map<HttpConnection, ConnectionQueries> connectionsMap = new HashMap<>();\n+  private HttpServer httpServer;\n+\n+  public ServerVerticle(final Endpoints endpoints, final HttpServerOptions httpServerOptions,\n+      final Server server) {\n+    this.endpoints = endpoints;\n+    this.httpServerOptions = httpServerOptions;\n+    this.server = server;\n+  }\n+\n+  @Override\n+  public void start(final Promise<Void> startPromise) {\n+    httpServer = vertx.createHttpServer(httpServerOptions).requestHandler(setupRouter())\n+        .exceptionHandler(ServerUtils::unhandledExceptonHandler);\n+    final Future<HttpServer> listenFuture = Promise.<HttpServer>promise().future();\n+    Utils.connectPromise(listenFuture.map(s -> null), startPromise);\n+    httpServer.listen(listenFuture);\n+    vertx.getOrCreateContext().exceptionHandler(ServerUtils::unhandledExceptonHandler);\n+  }\n+\n+  @Override\n+  public void stop(final Promise<Void> stopPromise) {\n+    if (httpServer == null) {\n+      stopPromise.complete();\n+    } else {\n+      httpServer.close(stopPromise.future());\n+    }\n+  }\n+\n+  private Router setupRouter() {\n+    final Router router = Router.router(vertx);\n+    router.route(HttpMethod.POST, \"/query-stream\").handler(BodyHandler.create())\n+        .handler(this::handleQueryStream);\n+    router.route(HttpMethod.POST, \"/inserts-stream\").handler(this::handleInsertsStream);\n+    router.route(HttpMethod.POST, \"/close-query\").handler(BodyHandler.create())", "originalCommit": "1abba4b5eab82f21a93441721e3d988a1080248e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ2NTg2Mw==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r369465863", "bodyText": "It's not a REST API ;)", "author": "purplefox", "createdAt": "2020-01-22T10:01:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODExMTQ5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODExMjY1MQ==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r368112651", "bodyText": "again - having the API defined inline in the code as string literals makes it really hard to construct automated documentation about our public API. would be nice to have Jackson objects that we can generate documentation from", "author": "agavra", "createdAt": "2020-01-17T20:00:29Z", "path": "ksql-api/src/main/java/io/confluent/ksql/api/server/ServerVerticle.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_MISSING_PARAM;\n+import static io.confluent.ksql.api.server.ErrorCodes.ERROR_CODE_UNKNOWN_QUERY_ID;\n+import static io.confluent.ksql.api.server.ServerUtils.handleError;\n+\n+import io.confluent.ksql.api.impl.Utils;\n+import io.confluent.ksql.api.spi.Endpoints;\n+import io.confluent.ksql.api.spi.QueryPublisher;\n+import io.vertx.core.AbstractVerticle;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.core.Promise;\n+import io.vertx.core.http.HttpConnection;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.core.http.HttpServer;\n+import io.vertx.core.http.HttpServerOptions;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.core.parsetools.RecordParser;\n+import io.vertx.ext.web.Router;\n+import io.vertx.ext.web.RoutingContext;\n+import io.vertx.ext.web.handler.BodyHandler;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The server deploys multiple server verticles. This is where the HTTP2 requests are handled. The\n+ * actual implementation of the endpoints is provided by an implementation of {@code Endpoints}.\n+ */\n+public class ServerVerticle extends AbstractVerticle {\n+\n+  private static final Logger log = LoggerFactory.getLogger(ServerVerticle.class);\n+\n+  private final Endpoints endpoints;\n+  private final HttpServerOptions httpServerOptions;\n+  private final Server server;\n+  private final Map<HttpConnection, ConnectionQueries> connectionsMap = new HashMap<>();\n+  private HttpServer httpServer;\n+\n+  public ServerVerticle(final Endpoints endpoints, final HttpServerOptions httpServerOptions,\n+      final Server server) {\n+    this.endpoints = endpoints;\n+    this.httpServerOptions = httpServerOptions;\n+    this.server = server;\n+  }\n+\n+  @Override\n+  public void start(final Promise<Void> startPromise) {\n+    httpServer = vertx.createHttpServer(httpServerOptions).requestHandler(setupRouter())\n+        .exceptionHandler(ServerUtils::unhandledExceptonHandler);\n+    final Future<HttpServer> listenFuture = Promise.<HttpServer>promise().future();\n+    Utils.connectPromise(listenFuture.map(s -> null), startPromise);\n+    httpServer.listen(listenFuture);\n+    vertx.getOrCreateContext().exceptionHandler(ServerUtils::unhandledExceptonHandler);\n+  }\n+\n+  @Override\n+  public void stop(final Promise<Void> stopPromise) {\n+    if (httpServer == null) {\n+      stopPromise.complete();\n+    } else {\n+      httpServer.close(stopPromise.future());\n+    }\n+  }\n+\n+  private Router setupRouter() {\n+    final Router router = Router.router(vertx);\n+    router.route(HttpMethod.POST, \"/query-stream\").handler(BodyHandler.create())\n+        .handler(this::handleQueryStream);\n+    router.route(HttpMethod.POST, \"/inserts-stream\").handler(this::handleInsertsStream);\n+    router.route(HttpMethod.POST, \"/close-query\").handler(BodyHandler.create())\n+        .handler(this::handleCloseQuery);\n+    return router;\n+  }\n+\n+  private void handleInsertsStream(final RoutingContext routingContext) {\n+    final RecordParser recordParser = RecordParser\n+        .newDelimited(\"\\n\", new InsertsBodyParser(endpoints, routingContext)::handleBodyBuffer);\n+    routingContext.request()\n+        .handler(recordParser);\n+  }\n+\n+  private void handleQueryStream(final RoutingContext routingContext) {\n+    final HttpConnection conn = routingContext.request().connection();\n+    ConnectionQueries connectionQueries = connectionsMap.get(conn);\n+    if (connectionQueries == null) {\n+      connectionQueries = new ConnectionQueries(conn);\n+      connectionsMap.put(conn, connectionQueries);\n+      conn.closeHandler(connectionQueries);\n+      server.registerQueryConnection(conn);\n+    }\n+    final JsonObject requestBody = routingContext.getBodyAsJson();\n+    final String sql = requestBody.getString(\"sql\");\n+    if (sql == null) {\n+      handleError(routingContext.response(), 400, ERROR_CODE_MISSING_PARAM, \"No sql in arguments\");\n+      return;\n+    }\n+    final Boolean push = requestBody.getBoolean(\"push\");\n+    if (push == null) {\n+      handleError(routingContext.response(), 400, ERROR_CODE_MISSING_PARAM, \"No push in arguments\");\n+      return;\n+    }\n+    final JsonObject properties = requestBody.getJsonObject(\"properties\");\n+    final QueryPublisher queryPublisher = endpoints.createQueryPublisher(sql, push, properties);\n+    final QuerySubscriber querySubscriber = new QuerySubscriber(routingContext.response());\n+\n+    final QueryID queryID = server.registerQuery(querySubscriber);\n+    connectionQueries.addQuery(queryID);\n+    final JsonObject metadata = new JsonObject();\n+    metadata.put(\"columnNames\", queryPublisher.getColumnNames());\n+    metadata.put(\"columnTypes\", queryPublisher.getColumnTypes());\n+    metadata.put(\"queryID\", queryID.toString());\n+    if (!push) {\n+      metadata.put(\"rowCount\", queryPublisher.getRowCount());\n+    }\n+    routingContext.response().write(metadata.toBuffer()).write(\"\\n\");\n+    queryPublisher.subscribe(querySubscriber);\n+\n+    // When response is complete, publisher should be closed and query unregistered\n+    routingContext.response().endHandler(v -> closeQuery(queryID, routingContext));\n+  }\n+\n+  private boolean closeQuery(final QueryID queryID, final RoutingContext routingContext) {\n+    final QuerySubscriber querySubscriber = server.removeQuery(queryID);\n+    if (querySubscriber == null) {\n+      return false;\n+    }\n+    final HttpConnection conn = routingContext.request().connection();\n+    final ConnectionQueries connectionQueries = connectionsMap.get(conn);\n+    connectionQueries.removeQuery(queryID);\n+    querySubscriber.close();\n+    return true;\n+  }\n+\n+  private void handleCloseQuery(final RoutingContext routingContext) {\n+    final JsonObject requestBody = routingContext.getBodyAsJson();\n+    final String queryIDArg = requestBody.getString(\"queryID\");", "originalCommit": "1abba4b5eab82f21a93441721e3d988a1080248e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ2NjAwNQ==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r369466005", "bodyText": "see POJOs PR", "author": "purplefox", "createdAt": "2020-01-22T10:01:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODExMjY1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODExMzU4Nw==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r368113587", "bodyText": "All the tests seem to also have 2019 in copyright", "author": "agavra", "createdAt": "2020-01-17T20:03:05Z", "path": "ksql-api/src/test/java/io/confluent/ksql/api/TestEndpoints.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Copyright 2019 Confluent Inc.", "originalCommit": "1abba4b5eab82f21a93441721e3d988a1080248e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ2NjA4NQ==", "url": "https://github.com/confluentinc/ksql/pull/4320#discussion_r369466085", "bodyText": "Ack", "author": "purplefox", "createdAt": "2020-01-22T10:02:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODExMzU4Nw=="}], "type": "inlineReview"}]}