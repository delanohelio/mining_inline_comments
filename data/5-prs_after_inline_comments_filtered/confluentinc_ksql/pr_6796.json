{"pr_number": 6796, "pr_title": "chore: support multi-col pull queries", "pr_createdAt": "2020-12-17T05:11:38Z", "pr_url": "https://github.com/confluentinc/ksql/pull/6796", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI5Njk2Mw==", "url": "https://github.com/confluentinc/ksql/pull/6796#discussion_r545296963", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public void shouldSupportMultiKeyExpressionsThatDontCoverAllKeys() {\n          \n          \n            \n              public void shouldNotSupportMultiKeyExpressionsThatDontCoverAllKeys() {", "author": "vcrfxia", "createdAt": "2020-12-17T18:09:28Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/physical/pull/operators/WhereInfoTest.java", "diffHunk": "@@ -700,13 +684,32 @@ public void shouldThrowOnMultiKeyExpressions() {\n         expression2\n     );\n \n+    // When:\n+    final WhereInfo where = WhereInfo.extractWhereInfo(expression, MULTI_KEY_SCHEMA, true, METASTORE, CONFIG);\n+\n+    // Then:\n+    assertThat(where.getKeysBound(), is(ImmutableList.of(GenericKey.genericKey(1, 2))));\n+  }\n+\n+\n+  @Test\n+  public void shouldSupportMultiKeyExpressionsThatDontCoverAllKeys() {", "originalCommit": "d3c348e226e2d65daa0f2c6468b4521ef8192adb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI5NzUxNQ==", "url": "https://github.com/confluentinc/ksql/pull/6796#discussion_r545297515", "bodyText": "Do we have plans to support this before 0.15? If not it might be good to slip a line calling out the limitation into the docs.", "author": "vcrfxia", "createdAt": "2020-12-17T18:10:22Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/physical/pull/operators/WhereInfo.java", "diffHunk": "@@ -185,38 +187,67 @@ public boolean isWindowed() {\n     return getWindowBounds().isPresent();\n   }\n \n-  private static List<Object> extractKeysFromInPredicate(\n+  private static List<GenericKey> extractKeysFromInPredicate(\n       final List<InPredicate> inPredicates,\n       final LogicalSchema schema,\n       final MetaStore metaStore,\n       final KsqlConfig config\n   ) {\n+    if (schema.key().size() > 1) {\n+      throw invalidWhereClauseException(\"Schemas with multiple \"\n+          + \"KEY columns are not supported\", false);", "originalCommit": "d3c348e226e2d65daa0f2c6468b4521ef8192adb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTMwNDU5OQ==", "url": "https://github.com/confluentinc/ksql/pull/6796#discussion_r545304599", "bodyText": "I don't have plans at the moment, it would be relatively straightforward to add once we decide on a syntax/spec but it's not super clear to me what that spec should be. I'll document it.", "author": "agavra", "createdAt": "2020-12-17T18:21:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI5NzUxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM5NzE1OA==", "url": "https://github.com/confluentinc/ksql/pull/6796#discussion_r545397158", "bodyText": "You mean schemas with multiple key columns are not supported for use with in predicates, right? (After all this PR is meant to support exactly that using other expressions).  Maybe have the message mention in predicates?", "author": "AlanConfluent", "createdAt": "2020-12-17T20:54:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI5NzUxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQwNDM2MA==", "url": "https://github.com/confluentinc/ksql/pull/6796#discussion_r545404360", "bodyText": "I'm not super familiar with BitSet, but is this the number of unique bits or the highest bit value you have to account for?\nAnd are key column indexes guaranteed to be the first 0...N indexes or can they skip around?\nI'm just asking to to be sure this has the capacity and because I'm curious to learn the answers.  :-)", "author": "AlanConfluent", "createdAt": "2020-12-17T21:07:44Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/physical/pull/operators/WhereInfo.java", "diffHunk": "@@ -185,38 +187,67 @@ public boolean isWindowed() {\n     return getWindowBounds().isPresent();\n   }\n \n-  private static List<Object> extractKeysFromInPredicate(\n+  private static List<GenericKey> extractKeysFromInPredicate(\n       final List<InPredicate> inPredicates,\n       final LogicalSchema schema,\n       final MetaStore metaStore,\n       final KsqlConfig config\n   ) {\n+    if (schema.key().size() > 1) {\n+      throw invalidWhereClauseException(\"Schemas with multiple \"\n+          + \"KEY columns are not supported\", false);\n+    }\n+\n     final InPredicate inPredicate = Iterables.getLast(inPredicates);\n     final Column keyColumn = Iterables.getOnlyElement(schema.key());\n     return inPredicate.getValueList()\n         .getValues()\n         .stream()\n         .map(expression -> resolveKey(expression, keyColumn, metaStore, config, inPredicate))\n+        .map(GenericKey::genericKey)\n         .collect(Collectors.toList());\n   }\n \n-  private static Object extractKeyWhereClause(\n+  private static GenericKey extractKeyWhereClause(\n       final List<ComparisonExpression> comparisons,\n       final boolean windowed,\n       final LogicalSchema schema,\n       final MetaStore metaStore,\n       final KsqlConfig config\n   ) {\n-    final ComparisonExpression comparison = Iterables.getLast(comparisons);\n-    if (comparison.getType() != Type.EQUAL) {\n-      final ColumnName keyColumn = Iterables.getOnlyElement(schema.key()).name();\n-      throw invalidWhereClauseException(\"Bound on '\" + keyColumn.text()\n-          + \"' must currently be '='\", windowed);\n+    final Object[] keyContents = new Object[schema.key().size()];\n+    final BitSet seenKeys = new BitSet(schema.key().size());", "originalCommit": "d3c348e226e2d65daa0f2c6468b4521ef8192adb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQxNDQzOQ==", "url": "https://github.com/confluentinc/ksql/pull/6796#discussion_r545414439", "bodyText": "/**\n     * Creates a bit set whose initial size is large enough to explicitly\n     * represent bits with indices in the range {@code 0} through\n     * {@code nbits-1}. All bits are initially {@code false}.\n     *\n     * @param  nbits the initial size of the bit set\n     * @throws NegativeArraySizeException if the specified initial size\n     *         is negative\n     */\n    public BitSet(int nbits) {\nA bitset is essentially boolean[] but with one bit per boolean - I'm not entirely sure what the difference is between \"number of unique bits or the highest bit value you have to account for\".\n\nAnd are key column indexes guaranteed to be the first 0...N indexes or can they skip around?\n\nWhen you take it from schema.key() they are indexed as a sepearate namespace from the values. So there is a 0-indexed key and a 0-indexed value.", "author": "agavra", "createdAt": "2020-12-17T21:27:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQwNDM2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQyMzYxNA==", "url": "https://github.com/confluentinc/ksql/pull/6796#discussion_r545423614", "bodyText": "Ah, ok.  that makes sense.  I didn't realize that.  If they weren't compacted like that, the index could be greater than the number of keys (and hence my mentioning unique keys vs highest index), but that's not the case here.", "author": "AlanConfluent", "createdAt": "2020-12-17T21:45:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQwNDM2MA=="}], "type": "inlineReview"}, {"oid": "81c8e710d3202b9fcfa7edf6f8b85247e45230b5", "url": "https://github.com/confluentinc/ksql/commit/81c8e710d3202b9fcfa7edf6f8b85247e45230b5", "message": "chore: support multi-col pull queries", "committedDate": "2020-12-17T22:55:23Z", "type": "commit"}, {"oid": "106f49ff2447b931d5d29ca9908e314800cd046f", "url": "https://github.com/confluentinc/ksql/commit/106f49ff2447b931d5d29ca9908e314800cd046f", "message": "docs: add docs", "committedDate": "2020-12-17T22:55:24Z", "type": "commit"}, {"oid": "424065ce84457414198fea17d25aa4770da0fc52", "url": "https://github.com/confluentinc/ksql/commit/424065ce84457414198fea17d25aa4770da0fc52", "message": "chore: rebase", "committedDate": "2020-12-17T22:55:37Z", "type": "forcePushed"}, {"oid": "e6025c74489315e5c44ac5925a91035f444bc5b5", "url": "https://github.com/confluentinc/ksql/commit/e6025c74489315e5c44ac5925a91035f444bc5b5", "message": "chore: rebase", "committedDate": "2020-12-17T22:56:34Z", "type": "forcePushed"}, {"oid": "85a5b3aff1f83e1f5098f7d83111905894317de5", "url": "https://github.com/confluentinc/ksql/commit/85a5b3aff1f83e1f5098f7d83111905894317de5", "message": "chore: review comments", "committedDate": "2020-12-17T23:01:37Z", "type": "commit"}, {"oid": "85a5b3aff1f83e1f5098f7d83111905894317de5", "url": "https://github.com/confluentinc/ksql/commit/85a5b3aff1f83e1f5098f7d83111905894317de5", "message": "chore: review comments", "committedDate": "2020-12-17T23:01:37Z", "type": "forcePushed"}]}