{"pr_number": 5482, "pr_title": "feat: Adds SSL mutual auth support to intra-cluster requests", "pr_createdAt": "2020-05-26T23:18:33Z", "pr_url": "https://github.com/confluentinc/ksql/pull/5482", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4MTQ1Mg==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r430981452", "bodyText": "I'm not a fan of fine grained unit tests like these - they end up being very brittle and can provide a false sense of security. Would much rather see more coarse grained tests :)", "author": "purplefox", "createdAt": "2020-05-27T09:26:40Z", "path": "ksqldb-rest-app/src/test/java/io/confluent/ksql/api/auth/SystemAuthenticationHandlerTest.java", "diffHunk": "@@ -0,0 +1,87 @@\n+package io.confluent.ksql.api.auth;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.confluent.ksql.api.server.Server;\n+import io.confluent.ksql.rest.server.KsqlRestConfig;\n+import io.vertx.ext.web.RoutingContext;\n+import java.util.Optional;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class SystemAuthenticationHandlerTest {", "originalCommit": "1ede2cb2c076eba8338baefffd2d0c3b68cce0cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUyNDQyNg==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r431524426", "bodyText": "Unit tests are often somewhat brittle for this reason, but the benefit is that you can test every code path.\nI think this is fairly in line with the codebase.  What would you change to make it coarser?", "author": "AlanConfluent", "createdAt": "2020-05-28T00:56:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4MTQ1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTcxMTU0Ng==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r431711546", "bodyText": "It's a bit incongruous to add a fine grained mock test for this handler - the other handlers don't have this and that's been the approach we've taken with the new API. Instead we use much more coarse grained test which test the code as it would actually be used in a real setup. E.g. take a look at AuthTest.", "author": "purplefox", "createdAt": "2020-05-28T09:43:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4MTQ1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTcxNDY3MA==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r431714670", "bodyText": "Unlike full blown integration tests these kinds of tests run really fast, so you should be able to write enough tests that exercise all the code paths, but unlike fine grained unit tests, they run exactly as they would in the real system, and we're not testing the implementation directly thus allowing it to evolve and be refactored much more easily.\nBTW... I'm well known for my opinion on fine grained unit tests (you should see my Twitter conversations), and I'm currently thinking of writing a blog post on them and why I think this approach - mainly championed by \"TDD\" has been super damaging in our industry ;)", "author": "purplefox", "createdAt": "2020-05-28T09:48:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4MTQ1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc2MTUyNA==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r432761524", "bodyText": "I was following the pattern in ksqldb-rest-app/src/test/java/io/confluent/ksql/api/auth/... where other auth handers do this kind of test.  It would seem a shame to delete my nice test.\nI'm happen to try to write a few test cases in AuthTest to specifically test this, though it's likely going to be a bit complex since it requires setting up https.  I'll give this a shot.", "author": "AlanConfluent", "createdAt": "2020-05-29T22:08:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4MTQ1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk3MzIzMQ==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r430973231", "bodyText": "Why do we have an Optional<Boolean> for isInternalListener.  Surely it either is an internal listerned or it isn't!  It's very confusing having it as an optional.\nWhat does Optional.of(false) mean for isInternalListerner?", "author": "big-andy-coates", "createdAt": "2020-05-27T09:13:36Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/api/server/AuthHandlers.java", "diffHunk": "@@ -37,12 +38,17 @@\n   private AuthHandlers() {\n   }\n \n-  static void setupAuthHandlers(final Server server, final Router router) {\n+  static void setupAuthHandlers(final Server server, final Router router,\n+      final Optional<Boolean> isInternalListener) {", "originalCommit": "1ede2cb2c076eba8338baefffd2d0c3b68cce0cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUxMTU0Mw==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r431511543", "bodyText": "Optional.empty() means that no internal listener is set.  Optional.of(false) means that there is, but this is not it.  Optional.of(true) means there is and this is it.\nIt makes sense to have these three states in ServerVerticle given how the InternalEndpointHandler is installed, but i don't think it does here.  I'll simplify it to just a boolean.", "author": "AlanConfluent", "createdAt": "2020-05-28T00:09:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk3MzIzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk3Mzk3NQ==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r430973975", "bodyText": "We should have internal endpoints for internally proxied requests, e.g. show queries and pull queries.  These too should NOT require authetication.", "author": "big-andy-coates", "createdAt": "2020-05-27T09:14:49Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/api/server/InternalEndpointHandler.java", "diffHunk": "@@ -26,7 +26,7 @@\n public class InternalEndpointHandler implements Handler<RoutingContext> {\n   public static final String CONTEXT_DATA_IS_INTERNAL = \"isInternal\";\n \n-  private static final Set<String> INTERNAL_PATHS = ImmutableSet.of(\n+  public static final Set<String> INTERNAL_PATHS = ImmutableSet.of(", "originalCommit": "1ede2cb2c076eba8338baefffd2d0c3b68cce0cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUxNzIxMg==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r431517212", "bodyText": "The current code does.  This set INTERNAL_PATHS says that if these are used on a public listener, it's an error.  This was the recommended strategy vs not installing the endpoints at all on the public listener.\nI no longer use this in SystemAuthenticationHandler which is only installed on the internal listener and accepts requests for all paths, but verifies they come on an SSL connection with a verified peer.", "author": "AlanConfluent", "createdAt": "2020-05-28T00:29:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk3Mzk3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk3ODQwMQ==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r430978401", "bodyText": "This feels very wrong.   This is the client that each node uses to talk to other nodes right?  It shouldn't have two KsqlClient instances.  All communication within the cluster should be trusted once the connections are authenticated.\nBoth pull requests and the show queries requests can be moved to a different internal specific endpoint, such that they can be differentiated from client requests.  This then means only a single sharedClient is needed here.  Not two, and then the code/engineer needs to know which to use for which internal requests.", "author": "big-andy-coates", "createdAt": "2020-05-27T09:21:42Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/services/DefaultKsqlClient.java", "diffHunk": "@@ -45,26 +47,32 @@\n \n   private final Optional<String> authHeader;\n   private final KsqlClient sharedClient;\n+  private final KsqlClient internalClient;\n \n-  DefaultKsqlClient(final Optional<String> authHeader, final Map<String, Object> clientProps) {\n+  DefaultKsqlClient(final Optional<String> authHeader, final Map<String, Object> clientProps,\n+      final Optional<HostAliasResolver> hostAliasResolver) {\n     this(\n         authHeader,\n         new KsqlClient(\n             toClientProps(clientProps),\n             Optional.empty(),\n             new LocalProperties(ImmutableMap.of()),\n-            createClientOptions()\n-        )\n+            createClientOptions(),\n+            hostAliasResolver\n+        ),\n+        getInternalClient(toClientProps(clientProps), hostAliasResolver)\n     );\n   }\n \n   @VisibleForTesting\n   DefaultKsqlClient(\n       final Optional<String> authHeader,\n-      final KsqlClient sharedClient\n+      final KsqlClient sharedClient,\n+      final KsqlClient internalClient", "originalCommit": "1ede2cb2c076eba8338baefffd2d0c3b68cce0cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUyMTg4NQ==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r431521885", "bodyText": "Good call.  When this wasn't enabled for all internal endpoints, both had to be maintained, but with your previous suggestion to make use the SystemUser for all endpoints on the internal listener, there's just one KsqlClient now.\nI agree about splitting up internal vs external endpoints.  I had previously done that in my internal listener change.  I was asked to undo it and instead expose the same set of endpoints, but have a handler that makes the real internal ones unauthorized on the public listener.  Either way, only one client is now needed here since DefaultKsqlClient is only for inter-node communication.", "author": "AlanConfluent", "createdAt": "2020-05-28T00:46:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk3ODQwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk3OTE5Mw==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r430979193", "bodyText": "nit: all the new tests being added by people tend to use the shouldXXX naming style.  If there some reason you've moved away from this?", "author": "big-andy-coates", "createdAt": "2020-05-27T09:23:00Z", "path": "ksqldb-rest-app/src/test/java/io/confluent/ksql/api/auth/SystemAuthenticationHandlerTest.java", "diffHunk": "@@ -0,0 +1,87 @@\n+package io.confluent.ksql.api.auth;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.confluent.ksql.api.server.Server;\n+import io.confluent.ksql.rest.server.KsqlRestConfig;\n+import io.vertx.ext.web.RoutingContext;\n+import java.util.Optional;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class SystemAuthenticationHandlerTest {\n+\n+  @Mock Server server;\n+  @Mock RoutingContext routingContext;\n+\n+  @Test\n+  public void noListener() {", "originalCommit": "1ede2cb2c076eba8338baefffd2d0c3b68cce0cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUyNDc0MA==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r431524740", "bodyText": "Nope, not really intentional.  'Should' it is.", "author": "AlanConfluent", "createdAt": "2020-05-28T00:58:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk3OTE5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk3OTI4Nw==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r430979287", "bodyText": "nit: private.", "author": "big-andy-coates", "createdAt": "2020-05-27T09:23:08Z", "path": "ksqldb-rest-app/src/test/java/io/confluent/ksql/api/auth/SystemAuthenticationHandlerTest.java", "diffHunk": "@@ -0,0 +1,87 @@\n+package io.confluent.ksql.api.auth;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.confluent.ksql.api.server.Server;\n+import io.confluent.ksql.rest.server.KsqlRestConfig;\n+import io.vertx.ext.web.RoutingContext;\n+import java.util.Optional;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class SystemAuthenticationHandlerTest {\n+\n+  @Mock Server server;\n+  @Mock RoutingContext routingContext;", "originalCommit": "1ede2cb2c076eba8338baefffd2d0c3b68cce0cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUyNDU5OA==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r431524598", "bodyText": "Done", "author": "AlanConfluent", "createdAt": "2020-05-28T00:57:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk3OTI4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk3OTk0Mw==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r430979943", "bodyText": "success here meaning....? Running with mutual auth internally?", "author": "big-andy-coates", "createdAt": "2020-05-27T09:24:07Z", "path": "ksqldb-rest-app/src/test/java/io/confluent/ksql/api/auth/SystemAuthenticationHandlerTest.java", "diffHunk": "@@ -0,0 +1,87 @@\n+package io.confluent.ksql.api.auth;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.confluent.ksql.api.server.Server;\n+import io.confluent.ksql.rest.server.KsqlRestConfig;\n+import io.vertx.ext.web.RoutingContext;\n+import java.util.Optional;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class SystemAuthenticationHandlerTest {\n+\n+  @Mock Server server;\n+  @Mock RoutingContext routingContext;\n+\n+  @Test\n+  public void noListener() {\n+    when(server.getConfig()).thenReturn(new KsqlRestConfig(ImmutableMap.of()));\n+    Optional<SystemAuthenticationHandler> handler =\n+        SystemAuthenticationHandler.getSystemAuthenticationHandler(server, Optional.empty());\n+    assertThat(handler.isPresent(), is(false));\n+  }\n+\n+  @Test\n+  public void notMutualAuth() {\n+    when(server.getConfig()).thenReturn(new KsqlRestConfig(ImmutableMap.of(\n+        KsqlRestConfig.INTERNAL_LISTENER_CONFIG, \"https://localhost:9188\",\n+        KsqlRestConfig.KSQL_INTERNAL_SSL_CLIENT_AUTHENTICATION_CONFIG,\n+        KsqlRestConfig.SSL_CLIENT_AUTHENTICATION_NONE\n+    )));\n+    Optional<SystemAuthenticationHandler> handler =\n+        SystemAuthenticationHandler.getSystemAuthenticationHandler(server, Optional.of(true));\n+    assertThat(handler.isPresent(), is(false));\n+  }\n+\n+  @Test\n+  public void notInternal() {\n+    when(server.getConfig()).thenReturn(new KsqlRestConfig(ImmutableMap.of(\n+        KsqlRestConfig.INTERNAL_LISTENER_CONFIG, \"https://localhost:9188\",\n+        KsqlRestConfig.KSQL_INTERNAL_SSL_CLIENT_AUTHENTICATION_CONFIG,\n+        KsqlRestConfig.SSL_CLIENT_AUTHENTICATION_REQUIRED\n+    )));\n+    Optional<SystemAuthenticationHandler> handler =\n+        SystemAuthenticationHandler.getSystemAuthenticationHandler(server, Optional.of(false));\n+    assertThat(handler.isPresent(), is(false));\n+  }\n+\n+  @Test\n+  public void success() {", "originalCommit": "1ede2cb2c076eba8338baefffd2d0c3b68cce0cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUyNTQ4NA==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r431525484", "bodyText": "Returned the handler.  Improved the name.", "author": "AlanConfluent", "createdAt": "2020-05-28T01:01:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk3OTk0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4MDQ3Mg==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r430980472", "bodyText": "why does this need to change?", "author": "big-andy-coates", "createdAt": "2020-05-27T09:25:03Z", "path": "ksqldb-rest-app/src/test/java/io/confluent/ksql/rest/integration/HighAvailabilityTestUtil.java", "diffHunk": "@@ -38,9 +40,29 @@\n \n   private static final Logger LOG = LoggerFactory.getLogger(HighAvailabilityTestUtil.class);\n \n-  static ClusterStatusResponse sendClusterStatusRequest(final TestKsqlRestApp restApp) {\n-    try (final KsqlRestClient restClient = restApp.buildInternalKsqlClient()) {\n-      final RestResponse<ClusterStatusResponse> res = restClient.makeClusterStatusRequest();\n+  static ClusterStatusResponse sendClusterStatusRequest(\n+      final TestKsqlRestApp restApp) {\n+    try (final KsqlRestClient restClient = restApp.buildKsqlClient()) {", "originalCommit": "1ede2cb2c076eba8338baefffd2d0c3b68cce0cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUyNTg4Mw==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r431525883", "bodyText": "I had previously added the additional version below which allowed for https calls to the client API, so I could use different certs for the public listener and private.  But this wasn't really what I was testing, so I removed all of these and just added a simple auth credential version.", "author": "AlanConfluent", "createdAt": "2020-05-28T01:02:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4MDQ3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4MzA5MQ==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r430983091", "bodyText": "Can we move all of this out into a different class? This this class stays focussed on the simple case?", "author": "big-andy-coates", "createdAt": "2020-05-27T09:29:25Z", "path": "ksqldb-test-util/src/main/java/io/confluent/ksql/test/util/secure/ClientTrustStore.java", "diffHunk": "@@ -42,7 +43,48 @@\n       + \"7rKeqVDlpM5lUidfckmrF3TxmS6d1aN/1WSZtDZCnNK8+h6LrrbtSQMsS6tc1Cv5YjJ/7KB+rQmTmGJCdzI5E=\";\n \n   private static final String TRUSTSTORE_PASSWORD = \"password\";\n+\n+  // Trust store containing two certs, for internal.example.com and external.example.com\n+  private static final String BASE64_ENCODED_STORE_MULTIPLE =", "originalCommit": "1ede2cb2c076eba8338baefffd2d0c3b68cce0cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUyNzM3Mg==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r431527372", "bodyText": "Done, moved to MultiNodeKeyStore.", "author": "AlanConfluent", "createdAt": "2020-05-28T01:08:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4MzA5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4MzI3Mg==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r430983272", "bodyText": "Likewise.", "author": "big-andy-coates", "createdAt": "2020-05-27T09:29:42Z", "path": "ksqldb-test-util/src/main/java/io/confluent/ksql/test/util/secure/ServerKeyStore.java", "diffHunk": "@@ -88,7 +89,103 @@\n   private static final String KEY_PASSWORD = \"password\";\n   private static final String KEYSTORE_PASSWORD = \"password\";\n   private static final String TRUSTSTORE_PASSWORD = \"password\";\n+\n+  // Keystore containing two certs, for external.example.com and internal.example.com\n+  private static final String BASE64_ENCODED_STORE_MULTIPLE =", "originalCommit": "1ede2cb2c076eba8338baefffd2d0c3b68cce0cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUyNzQ2MQ==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r431527461", "bodyText": "Done, moved to MultiNodeTrustStore.", "author": "AlanConfluent", "createdAt": "2020-05-28T01:08:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4MzI3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk5MDMxOA==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r430990318", "bodyText": "We should be capturing the name of the entity connecting to use, i.e. the hostname of the remote server, and storing this in the principle.  This can then be used later when logging out request information so that we/users can see which node a remove request came from.", "author": "big-andy-coates", "createdAt": "2020-05-27T09:41:34Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/api/auth/SystemAuthenticationHandler.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.auth;\n+\n+import io.confluent.ksql.api.server.InternalEndpointHandler;\n+import io.confluent.ksql.api.server.Server;\n+import io.confluent.ksql.rest.server.KsqlRestConfig;\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Handler;\n+import io.vertx.core.http.ClientAuth;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.auth.AuthProvider;\n+import io.vertx.ext.auth.User;\n+import io.vertx.ext.web.RoutingContext;\n+import java.net.URI;\n+import java.security.Principal;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+public class SystemAuthenticationHandler implements Handler<RoutingContext> {\n+\n+  public SystemAuthenticationHandler() {}\n+\n+  @Override\n+  public void handle(final RoutingContext routingContext) {\n+    if (InternalEndpointHandler.INTERNAL_PATHS.contains(routingContext.normalisedPath())) {\n+      routingContext.setUser(new SystemUser(new SystemPrincipal()));\n+    }\n+    routingContext.next();\n+  }", "originalCommit": "1ede2cb2c076eba8338baefffd2d0c3b68cce0cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTUxMDE1NA==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r431510154", "bodyText": "Good idea.  Done.", "author": "AlanConfluent", "createdAt": "2020-05-28T00:03:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk5MDMxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzEyNTQ5Ng==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r433125496", "bodyText": "Can't this just be:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (SystemAuthenticationHandler.hasAuthorization(routingContext)) {\n          \n          \n            \n                if (SystemAuthenticationHandler. isAuthenticatedAsSystemUser(routingContext)) {\n          \n      \n    \n    \n  \n\nNot sure the second hasAuthorization method adds anything here...", "author": "big-andy-coates", "createdAt": "2020-06-01T09:11:42Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/api/auth/KsqlAuthorizationProviderHandler.java", "diffHunk": "@@ -54,6 +54,11 @@ public void handle(final RoutingContext routingContext) {\n       return;\n     }\n \n+    if (SystemAuthenticationHandler.hasAuthorization(routingContext)) {", "originalCommit": "51f0152d2fb11214d27f069e56e038e1a980ab1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU4NTAwNQ==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r435585005", "bodyText": "Ok.  Done.", "author": "AlanConfluent", "createdAt": "2020-06-04T22:22:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzEyNTQ5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzEyNTgwMg==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r433125802", "bodyText": "Nice! Thanks for grabbing this info.", "author": "big-andy-coates", "createdAt": "2020-06-01T09:12:25Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/api/auth/SystemAuthenticationHandler.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.auth;\n+\n+import io.confluent.ksql.api.server.Server;\n+import io.confluent.ksql.rest.server.KsqlRestConfig;\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Handler;\n+import io.vertx.core.http.ClientAuth;\n+import io.vertx.core.http.HttpConnection;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.auth.AuthProvider;\n+import io.vertx.ext.auth.User;\n+import io.vertx.ext.web.RoutingContext;\n+import java.net.URI;\n+import java.security.Principal;\n+import java.util.Objects;\n+import java.util.Optional;\n+import javax.net.ssl.SSLPeerUnverifiedException;\n+import javax.net.ssl.SSLSession;\n+\n+public class SystemAuthenticationHandler implements Handler<RoutingContext> {\n+\n+  public SystemAuthenticationHandler() {}\n+\n+  @Override\n+  public void handle(final RoutingContext routingContext) {\n+    final HttpConnection httpConnection = routingContext.request().connection();\n+    if (!httpConnection.isSsl()) {\n+      throw new IllegalStateException(\"Should only have ssl connections\");\n+    }\n+    final Principal peerPrincipal = getPeerPrincipal(httpConnection.sslSession());\n+    routingContext.setUser(new SystemUser(peerPrincipal));", "originalCommit": "51f0152d2fb11214d27f069e56e038e1a980ab1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU4NTIyOA==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r435585228", "bodyText": "\ud83d\udc4d", "author": "AlanConfluent", "createdAt": "2020-06-04T22:23:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzEyNTgwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzEyNzAzMg==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r433127032", "bodyText": "Does this call fail is auth mode is set to NONE?\nIf that's the case, then we shouldn't be throwing an exception here is auth mode is controlled by the user, right? i.e. if they want internal communication encrypted, but don't care about mutual auth, then this shouldn't be failing.", "author": "big-andy-coates", "createdAt": "2020-06-01T09:15:13Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/api/auth/SystemAuthenticationHandler.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.auth;\n+\n+import io.confluent.ksql.api.server.Server;\n+import io.confluent.ksql.rest.server.KsqlRestConfig;\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Handler;\n+import io.vertx.core.http.ClientAuth;\n+import io.vertx.core.http.HttpConnection;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.auth.AuthProvider;\n+import io.vertx.ext.auth.User;\n+import io.vertx.ext.web.RoutingContext;\n+import java.net.URI;\n+import java.security.Principal;\n+import java.util.Objects;\n+import java.util.Optional;\n+import javax.net.ssl.SSLPeerUnverifiedException;\n+import javax.net.ssl.SSLSession;\n+\n+public class SystemAuthenticationHandler implements Handler<RoutingContext> {\n+\n+  public SystemAuthenticationHandler() {}\n+\n+  @Override\n+  public void handle(final RoutingContext routingContext) {\n+    final HttpConnection httpConnection = routingContext.request().connection();\n+    if (!httpConnection.isSsl()) {\n+      throw new IllegalStateException(\"Should only have ssl connections\");\n+    }\n+    final Principal peerPrincipal = getPeerPrincipal(httpConnection.sslSession());\n+    routingContext.setUser(new SystemUser(peerPrincipal));\n+    routingContext.next();\n+  }\n+\n+  private static Principal getPeerPrincipal(final SSLSession sslSession) {\n+    try {\n+      return sslSession.getPeerPrincipal();\n+    } catch (SSLPeerUnverifiedException e) {\n+      throw new IllegalStateException(\"Peer should always be verified\", e);\n+    }", "originalCommit": "51f0152d2fb11214d27f069e56e038e1a980ab1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU4NTU0OQ==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r435585549", "bodyText": "If auth mode is set to None, this handler won't even be installed.  It's only installed when mutual auth is enabled.", "author": "AlanConfluent", "createdAt": "2020-06-04T22:24:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzEyNzAzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzEyNzY1Ng==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r433127656", "bodyText": "nit: This would be better as JavaDocs - either on the method, or on the class.   JavaDocs are available to developers within the IDE, e.g CTRL+J in my setup, these comments aren't.", "author": "big-andy-coates", "createdAt": "2020-06-01T09:16:37Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/api/auth/SystemAuthenticationHandler.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.auth;\n+\n+import io.confluent.ksql.api.server.Server;\n+import io.confluent.ksql.rest.server.KsqlRestConfig;\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Handler;\n+import io.vertx.core.http.ClientAuth;\n+import io.vertx.core.http.HttpConnection;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.auth.AuthProvider;\n+import io.vertx.ext.auth.User;\n+import io.vertx.ext.web.RoutingContext;\n+import java.net.URI;\n+import java.security.Principal;\n+import java.util.Objects;\n+import java.util.Optional;\n+import javax.net.ssl.SSLPeerUnverifiedException;\n+import javax.net.ssl.SSLSession;\n+\n+public class SystemAuthenticationHandler implements Handler<RoutingContext> {\n+\n+  public SystemAuthenticationHandler() {}\n+\n+  @Override\n+  public void handle(final RoutingContext routingContext) {\n+    final HttpConnection httpConnection = routingContext.request().connection();\n+    if (!httpConnection.isSsl()) {\n+      throw new IllegalStateException(\"Should only have ssl connections\");\n+    }\n+    final Principal peerPrincipal = getPeerPrincipal(httpConnection.sslSession());\n+    routingContext.setUser(new SystemUser(peerPrincipal));\n+    routingContext.next();\n+  }\n+\n+  private static Principal getPeerPrincipal(final SSLSession sslSession) {\n+    try {\n+      return sslSession.getPeerPrincipal();\n+    } catch (SSLPeerUnverifiedException e) {\n+      throw new IllegalStateException(\"Peer should always be verified\", e);\n+    }\n+  }\n+\n+  public static boolean isAuthenticatedAsSystemUser(final RoutingContext routingContext) {\n+    final User user = routingContext.user();\n+    return user instanceof SystemUser;\n+  }\n+\n+  public static boolean hasAuthorization(final RoutingContext routingContext) {\n+    return isAuthenticatedAsSystemUser(routingContext);\n+  }\n+\n+  public static Optional<SystemAuthenticationHandler> getSystemAuthenticationHandler(\n+      final Server server, final boolean isInternalListener) {\n+    // The requirements for being considered a system call on behalf of the SystemUser are that\n+    // SSL mutual auth is in effect for the connection (meaning that the request is verified to be\n+    // coming from a known set of servers in the cluster), and that it came on the internal\n+    // listener interface, meaning that it's being done with the authorization of the system\n+    // rather than directly on behalf of the user. Mutual auth is only enforced when SSL is used.", "originalCommit": "51f0152d2fb11214d27f069e56e038e1a980ab1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU4NTcxNw==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r435585717", "bodyText": "Good point.  Moved to java docs.", "author": "AlanConfluent", "createdAt": "2020-06-04T22:25:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzEyNzY1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzEzMzM0OA==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r433133348", "bodyText": "Rather than passing isInternalListener to SystemAuthenticationHandler.getSystemAuthenticationHandler, why not just only call this method if isInternalListener is true?  This decouples SystemAuthenticationHandler from any concept of internal.\nPersonally, I'd be tempted to go further: I'd move the logic of when the system auth handler should be installed into this AuthHandlers class. i.e. move the getSystemAuthenticationHandler into this class.   Why?  It's generally a good pattern to separate the logic of when something should be used from the something itself.  This decoupling allows the same something to be used in the future in some other way without needing to be changed.\nThe systemAuthenticationHandler.ifPresent(handler -> router.route().handler(handler)); could then also be moved into the call.\nBut this is just a suggestion. Feel free to ignore me.", "author": "big-andy-coates", "createdAt": "2020-06-01T09:29:58Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/api/server/AuthHandlers.java", "diffHunk": "@@ -37,12 +38,17 @@\n   private AuthHandlers() {\n   }\n \n-  static void setupAuthHandlers(final Server server, final Router router) {\n+  static void setupAuthHandlers(final Server server, final Router router,\n+      final boolean isInternalListener) {\n     final Optional<AuthHandler> jaasAuthHandler = getJaasAuthHandler(server);\n     final KsqlSecurityExtension securityExtension = server.getSecurityExtension();\n     final Optional<AuthenticationPlugin> authenticationPlugin = server.getAuthenticationPlugin();\n     final Optional<Handler<RoutingContext>> pluginHandler =\n         authenticationPlugin.map(plugin -> new AuthenticationPluginHandler(server, plugin));\n+    final Optional<SystemAuthenticationHandler> systemAuthenticationHandler\n+        = SystemAuthenticationHandler.getSystemAuthenticationHandler(server, isInternalListener);", "originalCommit": "51f0152d2fb11214d27f069e56e038e1a980ab1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU4OTY3MQ==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r435589671", "bodyText": "I think it's generally good to have the isInternalListener in getSystemAuthenticationHandler so that all of the logic is in one place so it's easy to reason about.\nI'm fine to move getSystemAuthenticationHandler here.  I put it in SystemAuthenticationHandler to organize related logic together, but I get your point about decoupling installation from the logic itself.", "author": "AlanConfluent", "createdAt": "2020-06-04T22:36:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzEzMzM0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzEzNDE2MA==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r433134160", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            listener.getScheme().equalsIgnoreCase(\"https\"), isInternalListener),\n          \n          \n            \n                            listener.getScheme().equalsIgnoreCase(\"https\"), isInternalListener.orElse(false)),", "author": "big-andy-coates", "createdAt": "2020-06-01T09:31:54Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/api/server/Server.java", "diffHunk": "@@ -115,7 +117,7 @@ public synchronized void start() {\n         final VertxCompletableFuture<String> vcf = new VertxCompletableFuture<>();\n         final ServerVerticle serverVerticle = new ServerVerticle(endpoints,\n             createHttpServerOptions(config, listener.getHost(), listener.getPort(),\n-                listener.getScheme().equalsIgnoreCase(\"https\")),\n+                listener.getScheme().equalsIgnoreCase(\"https\"), isInternalListener),", "originalCommit": "51f0152d2fb11214d27f069e56e038e1a980ab1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU5NDQyMg==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r435594422", "bodyText": "Done", "author": "AlanConfluent", "createdAt": "2020-06-04T22:49:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzEzNDE2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzEzNDI1OA==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r433134258", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  final Optional<Boolean> isInternalListener) {\n          \n          \n            \n                  final boolean isInternalListener) {", "author": "big-andy-coates", "createdAt": "2020-06-01T09:32:08Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/api/server/Server.java", "diffHunk": "@@ -239,7 +241,8 @@ public int queryConnectionCount() {\n   }\n \n   private static HttpServerOptions createHttpServerOptions(final KsqlRestConfig ksqlRestConfig,\n-      final String host, final int port, final boolean tls) {\n+      final String host, final int port, final boolean tls,\n+      final Optional<Boolean> isInternalListener) {", "originalCommit": "51f0152d2fb11214d27f069e56e038e1a980ab1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU5NDQ1OA==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r435594458", "bodyText": "Done", "author": "AlanConfluent", "createdAt": "2020-06-04T22:49:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzEzNDI1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzEzNDM1Mg==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r433134352", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (isInternalListener.isPresent() && isInternalListener.get()) {\n          \n          \n            \n                  if (isInternalListener) {", "author": "big-andy-coates", "createdAt": "2020-06-01T09:32:22Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/api/server/Server.java", "diffHunk": "@@ -251,30 +254,54 @@ private static HttpServerOptions createHttpServerOptions(final KsqlRestConfig ks\n         .setPerFrameWebSocketCompressionSupported(true);\n \n     if (tls) {\n-      options.setUseAlpn(true).setSsl(true);\n-\n-      final String keyStorePath = ksqlRestConfig\n-          .getString(SslConfigs.SSL_KEYSTORE_LOCATION_CONFIG);\n-      final Password keyStorePassword = ksqlRestConfig\n-          .getPassword(SslConfigs.SSL_KEYSTORE_PASSWORD_CONFIG);\n-      if (keyStorePath != null && !keyStorePath.isEmpty()) {\n-        options.setKeyStoreOptions(\n-            new JksOptions().setPath(keyStorePath).setPassword(keyStorePassword.value()));\n+      final String externalAlias = ksqlRestConfig\n+          .getString(KsqlRestConfig.KSQL_SSL_KEYSTORE_ALIAS_EXTERNAL_CONFIG);\n+      final String internalAlias = ksqlRestConfig\n+          .getString(KsqlRestConfig.KSQL_SSL_KEYSTORE_ALIAS_INTERNAL_CONFIG);\n+      if (isInternalListener.isPresent() && isInternalListener.get()) {", "originalCommit": "51f0152d2fb11214d27f069e56e038e1a980ab1e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzEzNDU1MA==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r433134550", "bodyText": "nit: move these into the appropriate branch of the if/else?", "author": "big-andy-coates", "createdAt": "2020-06-01T09:32:51Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/api/server/Server.java", "diffHunk": "@@ -251,30 +254,54 @@ private static HttpServerOptions createHttpServerOptions(final KsqlRestConfig ks\n         .setPerFrameWebSocketCompressionSupported(true);\n \n     if (tls) {\n-      options.setUseAlpn(true).setSsl(true);\n-\n-      final String keyStorePath = ksqlRestConfig\n-          .getString(SslConfigs.SSL_KEYSTORE_LOCATION_CONFIG);\n-      final Password keyStorePassword = ksqlRestConfig\n-          .getPassword(SslConfigs.SSL_KEYSTORE_PASSWORD_CONFIG);\n-      if (keyStorePath != null && !keyStorePath.isEmpty()) {\n-        options.setKeyStoreOptions(\n-            new JksOptions().setPath(keyStorePath).setPassword(keyStorePassword.value()));\n+      final String externalAlias = ksqlRestConfig\n+          .getString(KsqlRestConfig.KSQL_SSL_KEYSTORE_ALIAS_EXTERNAL_CONFIG);\n+      final String internalAlias = ksqlRestConfig\n+          .getString(KsqlRestConfig.KSQL_SSL_KEYSTORE_ALIAS_INTERNAL_CONFIG);", "originalCommit": "51f0152d2fb11214d27f069e56e038e1a980ab1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU5NDUxOQ==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r435594519", "bodyText": "Done", "author": "AlanConfluent", "createdAt": "2020-06-04T22:50:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzEzNDU1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE0MzMzNg==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r433143336", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                AuthHandlers.setupAuthHandlers(server, router,\n          \n          \n            \n                    isInternalListener.isPresent() && isInternalListener.get());\n          \n          \n            \n                AuthHandlers.setupAuthHandlers(server, router,  isInternalListener.orElse(false));\n          \n      \n    \n    \n  \n\n??", "author": "big-andy-coates", "createdAt": "2020-06-01T09:53:56Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/api/server/ServerVerticle.java", "diffHunk": "@@ -118,7 +118,8 @@ private Router setupRouter() {\n     isInternalListener.ifPresent(isInternal ->\n         router.route().handler(new InternalEndpointHandler(isInternal)));\n \n-    AuthHandlers.setupAuthHandlers(server, router);\n+    AuthHandlers.setupAuthHandlers(server, router,\n+        isInternalListener.isPresent() && isInternalListener.get());", "originalCommit": "51f0152d2fb11214d27f069e56e038e1a980ab1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU5ODkxOQ==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r435598919", "bodyText": "Done", "author": "AlanConfluent", "createdAt": "2020-06-04T23:03:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE0MzMzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE0NDQ2Ng==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r433144466", "bodyText": "default value for the aliases in the config is an empty string. Adding a validator to the KsqlRestConfig  for the two alias configs can ensure the value is never null, making this:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (keyStoreAlias != null && !keyStoreAlias.isEmpty()) {\n          \n          \n            \n                  if (!keyStoreAlias.isEmpty()) {", "author": "big-andy-coates", "createdAt": "2020-06-01T09:56:29Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/api/server/Server.java", "diffHunk": "@@ -251,30 +254,54 @@ private static HttpServerOptions createHttpServerOptions(final KsqlRestConfig ks\n         .setPerFrameWebSocketCompressionSupported(true);\n \n     if (tls) {\n-      options.setUseAlpn(true).setSsl(true);\n-\n-      final String keyStorePath = ksqlRestConfig\n-          .getString(SslConfigs.SSL_KEYSTORE_LOCATION_CONFIG);\n-      final Password keyStorePassword = ksqlRestConfig\n-          .getPassword(SslConfigs.SSL_KEYSTORE_PASSWORD_CONFIG);\n-      if (keyStorePath != null && !keyStorePath.isEmpty()) {\n-        options.setKeyStoreOptions(\n-            new JksOptions().setPath(keyStorePath).setPassword(keyStorePassword.value()));\n+      final String externalAlias = ksqlRestConfig\n+          .getString(KsqlRestConfig.KSQL_SSL_KEYSTORE_ALIAS_EXTERNAL_CONFIG);\n+      final String internalAlias = ksqlRestConfig\n+          .getString(KsqlRestConfig.KSQL_SSL_KEYSTORE_ALIAS_INTERNAL_CONFIG);\n+      if (isInternalListener.isPresent() && isInternalListener.get()) {\n+        setTlsOptions(ksqlRestConfig, options, internalAlias,\n+            ksqlRestConfig.getClientAuthInternal());\n+      } else {\n+        setTlsOptions(ksqlRestConfig, options, externalAlias, ksqlRestConfig.getClientAuth());\n       }\n+    }\n+    return options;\n+  }\n \n-      final String trustStorePath = ksqlRestConfig\n-          .getString(SslConfigs.SSL_TRUSTSTORE_LOCATION_CONFIG);\n-      final Password trustStorePassword = ksqlRestConfig\n-          .getPassword(SslConfigs.SSL_TRUSTSTORE_PASSWORD_CONFIG);\n-      if (trustStorePath != null && !trustStorePath.isEmpty()) {\n-        options.setTrustStoreOptions(\n-            new JksOptions().setPath(trustStorePath).setPassword(trustStorePassword.value()));\n+  private static void setTlsOptions(\n+      final KsqlRestConfig ksqlRestConfig,\n+      final HttpServerOptions options,\n+      final String keyStoreAlias,\n+      final ClientAuth clientAuth\n+  ) {\n+    options.setUseAlpn(true).setSsl(true);\n+\n+    final String keyStorePath = ksqlRestConfig\n+        .getString(SslConfigs.SSL_KEYSTORE_LOCATION_CONFIG);\n+    final Password keyStorePassword = ksqlRestConfig\n+        .getPassword(SslConfigs.SSL_KEYSTORE_PASSWORD_CONFIG);\n+    if (keyStorePath != null && !keyStorePath.isEmpty()) {\n+      final JksOptions keyStoreOptions = new JksOptions()\n+          .setPassword(keyStorePassword.value());\n+      if (keyStoreAlias != null && !keyStoreAlias.isEmpty()) {", "originalCommit": "51f0152d2fb11214d27f069e56e038e1a980ab1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU5NTA0MQ==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r435595041", "bodyText": "Done.  If I have \"\" as the default, is there a way for it to ever be null?", "author": "AlanConfluent", "createdAt": "2020-06-04T22:51:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE0NDQ2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDExNTczMw==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r440115733", "bodyText": "Not sure. Maybe explicitly setting it via ksql.what.ever=null in the config file?  If that doesn't allow nulls then great!", "author": "big-andy-coates", "createdAt": "2020-06-15T11:41:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE0NDQ2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM1MzM3NA==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r440353374", "bodyText": "I tested that and it was the string \"null\" so I think we're good here.", "author": "AlanConfluent", "createdAt": "2020-06-15T18:04:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE0NDQ2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE0NTQ4MQ==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r433145481", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        \"\",\n          \n          \n            \n                        \"\",\n          \n          \n            \n                        new NonNullValidator(),", "author": "big-andy-coates", "createdAt": "2020-06-01T09:58:54Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/KsqlRestConfig.java", "diffHunk": "@@ -364,6 +384,27 @@\n             Importance.MEDIUM,\n             \"\"\n         ).define(\n+            KSQL_INTERNAL_SSL_CLIENT_AUTHENTICATION_CONFIG,\n+            Type.STRING,\n+            SSL_CLIENT_AUTHENTICATION_NONE,\n+            SSL_CLIENT_AUTHENTICATION_VALIDATOR,\n+            Importance.MEDIUM,\n+            KSQL_INTERNAL_SSL_CLIENT_AUTHENTICATION_DOC\n+        ).define(\n+            KSQL_SSL_KEYSTORE_ALIAS_EXTERNAL_CONFIG,\n+            Type.STRING,\n+            \"\",\n+            Importance.MEDIUM,\n+            KSQL_SSL_KEYSTORE_ALIAS_EXTERNAL_DOC\n+        )\n+        .define(\n+            KSQL_SSL_KEYSTORE_ALIAS_INTERNAL_CONFIG,\n+            Type.STRING,\n+            \"\",", "originalCommit": "51f0152d2fb11214d27f069e56e038e1a980ab1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwNDcxMw==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r435604713", "bodyText": "Same here", "author": "AlanConfluent", "createdAt": "2020-06-04T23:22:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE0NTQ4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE0NTUwNw==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r433145507", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        \"\",\n          \n          \n            \n                        \"\",\n          \n          \n            \n                        new NonNullValidator(),", "author": "big-andy-coates", "createdAt": "2020-06-01T09:58:58Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/KsqlRestConfig.java", "diffHunk": "@@ -364,6 +384,27 @@\n             Importance.MEDIUM,\n             \"\"\n         ).define(\n+            KSQL_INTERNAL_SSL_CLIENT_AUTHENTICATION_CONFIG,\n+            Type.STRING,\n+            SSL_CLIENT_AUTHENTICATION_NONE,\n+            SSL_CLIENT_AUTHENTICATION_VALIDATOR,\n+            Importance.MEDIUM,\n+            KSQL_INTERNAL_SSL_CLIENT_AUTHENTICATION_DOC\n+        ).define(\n+            KSQL_SSL_KEYSTORE_ALIAS_EXTERNAL_CONFIG,\n+            Type.STRING,\n+            \"\",", "originalCommit": "51f0152d2fb11214d27f069e56e038e1a980ab1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwNDYzOQ==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r435604639", "bodyText": "I tested it out by passing \"null\" and empty string and I can't get it to be null when it has a default as \"\".  I'm pretty sure this validator isn't required.", "author": "AlanConfluent", "createdAt": "2020-06-04T23:22:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE0NTUwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDExNTA3Mg==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r440115072", "bodyText": "cool", "author": "big-andy-coates", "createdAt": "2020-06-15T11:40:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE0NTUwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE0ODA2MA==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r433148060", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (trustStoreLocation != null) {\n          \n          \n            \n                  if (trustStoreLocation != null && !trustStoreLocation.isEmpty()) {\n          \n      \n    \n    \n  \n\n???", "author": "big-andy-coates", "createdAt": "2020-06-01T10:05:20Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/services/DefaultKsqlClient.java", "diffHunk": "@@ -164,5 +167,50 @@ private static HttpClientOptions createClientOptions() {\n     return clientProps;\n   }\n \n+  private static Consumer<HttpClientOptions> prepareHttpOptionsForSSL(\n+      final Map<String, String> clientProps, final boolean verifyHost) {\n+    return (httpClientOptions) -> {\n+      httpClientOptions.setVerifyHost(verifyHost);\n+      httpClientOptions.setSsl(true);\n+      final String internalAlias = clientProps\n+          .get(KsqlRestConfig.KSQL_SSL_KEYSTORE_ALIAS_INTERNAL_CONFIG);\n+      final String trustStoreLocation = clientProps.get(SslConfigs.SSL_TRUSTSTORE_LOCATION_CONFIG);\n+      if (trustStoreLocation != null) {", "originalCommit": "51f0152d2fb11214d27f069e56e038e1a980ab1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwNTE5OA==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r435605198", "bodyText": "Done", "author": "AlanConfluent", "createdAt": "2020-06-04T23:24:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE0ODA2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE0ODQwMQ==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r433148401", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (keyStoreLocation != null) {\n          \n          \n            \n                    if (keyStoreLocation != null && !keyStoreLocation.isEmpty()) {\n          \n      \n    \n    \n  \n\n???\nPITA these configs don't default to \"\" and have a validator to ensure they're not null!", "author": "big-andy-coates", "createdAt": "2020-06-01T10:06:05Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/services/DefaultKsqlClient.java", "diffHunk": "@@ -164,5 +167,50 @@ private static HttpClientOptions createClientOptions() {\n     return clientProps;\n   }\n \n+  private static Consumer<HttpClientOptions> prepareHttpOptionsForSSL(\n+      final Map<String, String> clientProps, final boolean verifyHost) {\n+    return (httpClientOptions) -> {\n+      httpClientOptions.setVerifyHost(verifyHost);\n+      httpClientOptions.setSsl(true);\n+      final String internalAlias = clientProps\n+          .get(KsqlRestConfig.KSQL_SSL_KEYSTORE_ALIAS_INTERNAL_CONFIG);\n+      final String trustStoreLocation = clientProps.get(SslConfigs.SSL_TRUSTSTORE_LOCATION_CONFIG);\n+      if (trustStoreLocation != null) {\n+        final String suppliedTruststorePassword = clientProps\n+            .get(SslConfigs.SSL_TRUSTSTORE_PASSWORD_CONFIG);\n+        httpClientOptions.setTrustStoreOptions(new JksOptions().setPath(trustStoreLocation)\n+            .setPassword(suppliedTruststorePassword == null ? \"\" : suppliedTruststorePassword));\n+\n+        final String keyStoreLocation = clientProps.get(SslConfigs.SSL_KEYSTORE_LOCATION_CONFIG);\n+        if (keyStoreLocation != null) {", "originalCommit": "51f0152d2fb11214d27f069e56e038e1a980ab1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwNzQ0MQ==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r435607441", "bodyText": "I wasn't able to get this to have a null value, even when I don't set it...  It appears to have a default of \"\".", "author": "AlanConfluent", "createdAt": "2020-06-04T23:32:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE0ODQwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE0ODg0Mg==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r433148842", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      if (internalAlias != null && !internalAlias.isEmpty()) {\n          \n          \n            \n                      if (!internalAlias.isEmpty()) {\n          \n      \n    \n    \n  \n\nThis one we control, so can have suitable defaults and validators to ensure never null.", "author": "big-andy-coates", "createdAt": "2020-06-01T10:07:09Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/services/DefaultKsqlClient.java", "diffHunk": "@@ -164,5 +167,50 @@ private static HttpClientOptions createClientOptions() {\n     return clientProps;\n   }\n \n+  private static Consumer<HttpClientOptions> prepareHttpOptionsForSSL(\n+      final Map<String, String> clientProps, final boolean verifyHost) {\n+    return (httpClientOptions) -> {\n+      httpClientOptions.setVerifyHost(verifyHost);\n+      httpClientOptions.setSsl(true);\n+      final String internalAlias = clientProps\n+          .get(KsqlRestConfig.KSQL_SSL_KEYSTORE_ALIAS_INTERNAL_CONFIG);\n+      final String trustStoreLocation = clientProps.get(SslConfigs.SSL_TRUSTSTORE_LOCATION_CONFIG);\n+      if (trustStoreLocation != null) {\n+        final String suppliedTruststorePassword = clientProps\n+            .get(SslConfigs.SSL_TRUSTSTORE_PASSWORD_CONFIG);\n+        httpClientOptions.setTrustStoreOptions(new JksOptions().setPath(trustStoreLocation)\n+            .setPassword(suppliedTruststorePassword == null ? \"\" : suppliedTruststorePassword));\n+\n+        final String keyStoreLocation = clientProps.get(SslConfigs.SSL_KEYSTORE_LOCATION_CONFIG);\n+        if (keyStoreLocation != null) {\n+          final String suppliedKeyStorePassord = Strings.nullToEmpty(clientProps\n+              .get(SslConfigs.SSL_KEYSTORE_PASSWORD_CONFIG));\n+          final JksOptions keyStoreOptions = new JksOptions()\n+              .setPassword(suppliedKeyStorePassord);\n+          if (internalAlias != null && !internalAlias.isEmpty()) {", "originalCommit": "51f0152d2fb11214d27f069e56e038e1a980ab1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYwODU2Mg==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r435608562", "bodyText": "Done", "author": "AlanConfluent", "createdAt": "2020-06-04T23:33:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE0ODg0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE0OTE5Mg==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r433149192", "bodyText": "Does this work if mode is REQUESTED?", "author": "big-andy-coates", "createdAt": "2020-06-01T10:08:01Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/services/DefaultKsqlClient.java", "diffHunk": "@@ -164,5 +167,50 @@ private static HttpClientOptions createClientOptions() {\n     return clientProps;\n   }\n \n+  private static Consumer<HttpClientOptions> prepareHttpOptionsForSSL(\n+      final Map<String, String> clientProps, final boolean verifyHost) {\n+    return (httpClientOptions) -> {\n+      httpClientOptions.setVerifyHost(verifyHost);\n+      httpClientOptions.setSsl(true);\n+      final String internalAlias = clientProps\n+          .get(KsqlRestConfig.KSQL_SSL_KEYSTORE_ALIAS_INTERNAL_CONFIG);\n+      final String trustStoreLocation = clientProps.get(SslConfigs.SSL_TRUSTSTORE_LOCATION_CONFIG);\n+      if (trustStoreLocation != null) {\n+        final String suppliedTruststorePassword = clientProps\n+            .get(SslConfigs.SSL_TRUSTSTORE_PASSWORD_CONFIG);\n+        httpClientOptions.setTrustStoreOptions(new JksOptions().setPath(trustStoreLocation)\n+            .setPassword(suppliedTruststorePassword == null ? \"\" : suppliedTruststorePassword));\n+\n+        final String keyStoreLocation = clientProps.get(SslConfigs.SSL_KEYSTORE_LOCATION_CONFIG);\n+        if (keyStoreLocation != null) {\n+          final String suppliedKeyStorePassord = Strings.nullToEmpty(clientProps\n+              .get(SslConfigs.SSL_KEYSTORE_PASSWORD_CONFIG));\n+          final JksOptions keyStoreOptions = new JksOptions()\n+              .setPassword(suppliedKeyStorePassord);\n+          if (internalAlias != null && !internalAlias.isEmpty()) {\n+            keyStoreOptions.setValue(KeystoreUtil.getKeyStore(\n+                keyStoreLocation, suppliedKeyStorePassord, internalAlias));\n+          } else {\n+            keyStoreOptions.setPath(keyStoreLocation);\n+          }\n+          httpClientOptions.setKeyStoreOptions(keyStoreOptions);\n+        }\n+      }\n+    };\n+  }\n \n+  private static KsqlClient getInternalClient(final Map<String, String> clientProps,\n+      final Optional<HostAliasResolver> hostAliasResolver) {\n+    final boolean verifyHost =\n+        !KsqlRestConfig.SSL_CLIENT_AUTHENTICATION_NONE.equals(clientProps.get(\n+        KsqlRestConfig.KSQL_INTERNAL_SSL_CLIENT_AUTHENTICATION_CONFIG));", "originalCommit": "51f0152d2fb11214d27f069e56e038e1a980ab1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYxNzQ1MA==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r435617450", "bodyText": "If the server requires anything other than NONE for requesting clients, then then it will also verify identities as a requesting client when doing internal communication.  If REQUESTED is done, while https is in use, it requires that their certs check out.\nThis is a little arbitrary.  I wanted a simple way to allow for having https, but not doing verification here (i.e. \"NONE\") without introducing another config.  What do you think?", "author": "AlanConfluent", "createdAt": "2020-06-04T23:46:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE0OTE5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE0OTcyMw==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r433149723", "bodyText": "Better to encode the optionality of password into the signature of the method? i.e. Optional<String> password?", "author": "big-andy-coates", "createdAt": "2020-06-01T10:09:12Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/util/KeystoreUtil.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.util;\n+\n+import io.confluent.ksql.util.KsqlException;\n+import io.vertx.core.buffer.Buffer;\n+import java.io.ByteArrayOutputStream;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.security.KeyStore;\n+import java.security.PrivateKey;\n+import java.security.cert.Certificate;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public final class KeystoreUtil {\n+  private static final Logger LOG = LoggerFactory.getLogger(KeystoreUtil.class);\n+  private static final String KEYSTORE_TYPE = \"JKS\";\n+\n+  private KeystoreUtil() {}\n+\n+  /**\n+   * Utility to fetch a Vert.x Buffer that is the serialized version of the key store from the\n+   * given path, but which contains only the entry for the given alias.  This circumvents Vert.x's\n+   * direct support of an alias option.\n+   * @param keyStorePath The original key store which may contain multiple certificates\n+   * @param password The key store password\n+   * @param alias The alias of the entry to extract\n+   * @return The Buffer containing the keystore\n+   */\n+  public static Buffer getKeyStore(\n+      final String keyStorePath,\n+      final String password,\n+      final String alias\n+  ) {\n+    final char[] pw = password != null ? password.toCharArray() : null;", "originalCommit": "51f0152d2fb11214d27f069e56e038e1a980ab1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYxODI3MQ==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r435618271", "bodyText": "Done", "author": "AlanConfluent", "createdAt": "2020-06-04T23:49:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE0OTcyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE1MDM5MA==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r433150390", "bodyText": "Is this assuming the same password for the keystore and the key?  Isn't it possible these are different?", "author": "big-andy-coates", "createdAt": "2020-06-01T10:10:47Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/util/KeystoreUtil.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.util;\n+\n+import io.confluent.ksql.util.KsqlException;\n+import io.vertx.core.buffer.Buffer;\n+import java.io.ByteArrayOutputStream;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.security.KeyStore;\n+import java.security.PrivateKey;\n+import java.security.cert.Certificate;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public final class KeystoreUtil {\n+  private static final Logger LOG = LoggerFactory.getLogger(KeystoreUtil.class);\n+  private static final String KEYSTORE_TYPE = \"JKS\";\n+\n+  private KeystoreUtil() {}\n+\n+  /**\n+   * Utility to fetch a Vert.x Buffer that is the serialized version of the key store from the\n+   * given path, but which contains only the entry for the given alias.  This circumvents Vert.x's\n+   * direct support of an alias option.\n+   * @param keyStorePath The original key store which may contain multiple certificates\n+   * @param password The key store password\n+   * @param alias The alias of the entry to extract\n+   * @return The Buffer containing the keystore\n+   */\n+  public static Buffer getKeyStore(\n+      final String keyStorePath,\n+      final String password,\n+      final String alias\n+  ) {\n+    final char[] pw = password != null ? password.toCharArray() : null;\n+    final KeyStore keyStore = loadExistingKeyStore(keyStorePath, pw);\n+\n+    final PrivateKey key;\n+    final Certificate[] chain;\n+    try {\n+      key = (PrivateKey) keyStore.getKey(alias, pw);\n+      chain = keyStore.getCertificateChain(alias);", "originalCommit": "51f0152d2fb11214d27f069e56e038e1a980ab1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYxODI5OA==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r435618298", "bodyText": "You're right.  Made it a separate parameter.  By default, I'm passing the same password for both, since we don't appear to use the key password in ksql at the moment.\nThe keytool will use the same password for keys as for the keystore if you don't provide a separate one, so this seems like the default behavior.", "author": "AlanConfluent", "createdAt": "2020-06-04T23:50:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE1MDM5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE1MDY1Ng==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r433150656", "bodyText": "Include the alias in the message to make it clear which is failing?", "author": "big-andy-coates", "createdAt": "2020-06-01T10:11:19Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/util/KeystoreUtil.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.util;\n+\n+import io.confluent.ksql.util.KsqlException;\n+import io.vertx.core.buffer.Buffer;\n+import java.io.ByteArrayOutputStream;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.security.KeyStore;\n+import java.security.PrivateKey;\n+import java.security.cert.Certificate;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public final class KeystoreUtil {\n+  private static final Logger LOG = LoggerFactory.getLogger(KeystoreUtil.class);\n+  private static final String KEYSTORE_TYPE = \"JKS\";\n+\n+  private KeystoreUtil() {}\n+\n+  /**\n+   * Utility to fetch a Vert.x Buffer that is the serialized version of the key store from the\n+   * given path, but which contains only the entry for the given alias.  This circumvents Vert.x's\n+   * direct support of an alias option.\n+   * @param keyStorePath The original key store which may contain multiple certificates\n+   * @param password The key store password\n+   * @param alias The alias of the entry to extract\n+   * @return The Buffer containing the keystore\n+   */\n+  public static Buffer getKeyStore(\n+      final String keyStorePath,\n+      final String password,\n+      final String alias\n+  ) {\n+    final char[] pw = password != null ? password.toCharArray() : null;\n+    final KeyStore keyStore = loadExistingKeyStore(keyStorePath, pw);\n+\n+    final PrivateKey key;\n+    final Certificate[] chain;\n+    try {\n+      key = (PrivateKey) keyStore.getKey(alias, pw);\n+      chain = keyStore.getCertificateChain(alias);\n+    } catch (Exception e) {\n+      throw new KsqlException(\"Error fetching key/certificate\", e);", "originalCommit": "51f0152d2fb11214d27f069e56e038e1a980ab1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYyNTA0NQ==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r435625045", "bodyText": "Done", "author": "AlanConfluent", "createdAt": "2020-06-05T00:16:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE1MDY1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE1MTM1OQ==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r433151359", "bodyText": "Why not use try-with-resource, removing the need for finally block\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                try {\n          \n          \n            \n                try (FileInputStream input = new InputStream(keyStoreParth) {", "author": "big-andy-coates", "createdAt": "2020-06-01T10:12:59Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/util/KeystoreUtil.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.util;\n+\n+import io.confluent.ksql.util.KsqlException;\n+import io.vertx.core.buffer.Buffer;\n+import java.io.ByteArrayOutputStream;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.security.KeyStore;\n+import java.security.PrivateKey;\n+import java.security.cert.Certificate;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public final class KeystoreUtil {\n+  private static final Logger LOG = LoggerFactory.getLogger(KeystoreUtil.class);\n+  private static final String KEYSTORE_TYPE = \"JKS\";\n+\n+  private KeystoreUtil() {}\n+\n+  /**\n+   * Utility to fetch a Vert.x Buffer that is the serialized version of the key store from the\n+   * given path, but which contains only the entry for the given alias.  This circumvents Vert.x's\n+   * direct support of an alias option.\n+   * @param keyStorePath The original key store which may contain multiple certificates\n+   * @param password The key store password\n+   * @param alias The alias of the entry to extract\n+   * @return The Buffer containing the keystore\n+   */\n+  public static Buffer getKeyStore(\n+      final String keyStorePath,\n+      final String password,\n+      final String alias\n+  ) {\n+    final char[] pw = password != null ? password.toCharArray() : null;\n+    final KeyStore keyStore = loadExistingKeyStore(keyStorePath, pw);\n+\n+    final PrivateKey key;\n+    final Certificate[] chain;\n+    try {\n+      key = (PrivateKey) keyStore.getKey(alias, pw);\n+      chain = keyStore.getCertificateChain(alias);\n+    } catch (Exception e) {\n+      throw new KsqlException(\"Error fetching key/certificate\", e);\n+    }\n+\n+    if (key == null || chain == null) {\n+      throw new KsqlException(\"Alias doesn't exist in keystore: \" + alias);\n+    }\n+\n+    final byte[] singleValueKeyStore = createSingleValueKeyStore(key, chain, pw, alias);\n+    return Buffer.buffer(singleValueKeyStore);\n+  }\n+\n+  private static KeyStore loadExistingKeyStore(final String keyStorePath, final char[] pw) {\n+    FileInputStream input = null;\n+    try {", "originalCommit": "51f0152d2fb11214d27f069e56e038e1a980ab1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYyNTgyNQ==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r435625825", "bodyText": "Done", "author": "AlanConfluent", "createdAt": "2020-06-05T00:19:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE1MTM1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE1MTc3MA==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r433151770", "bodyText": "input stream leak...\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  keyStore.load(new FileInputStream(keyStorePath), pw);\n          \n          \n            \n                  keyStore.load(input, pw);", "author": "big-andy-coates", "createdAt": "2020-06-01T10:14:03Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/util/KeystoreUtil.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.util;\n+\n+import io.confluent.ksql.util.KsqlException;\n+import io.vertx.core.buffer.Buffer;\n+import java.io.ByteArrayOutputStream;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.security.KeyStore;\n+import java.security.PrivateKey;\n+import java.security.cert.Certificate;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public final class KeystoreUtil {\n+  private static final Logger LOG = LoggerFactory.getLogger(KeystoreUtil.class);\n+  private static final String KEYSTORE_TYPE = \"JKS\";\n+\n+  private KeystoreUtil() {}\n+\n+  /**\n+   * Utility to fetch a Vert.x Buffer that is the serialized version of the key store from the\n+   * given path, but which contains only the entry for the given alias.  This circumvents Vert.x's\n+   * direct support of an alias option.\n+   * @param keyStorePath The original key store which may contain multiple certificates\n+   * @param password The key store password\n+   * @param alias The alias of the entry to extract\n+   * @return The Buffer containing the keystore\n+   */\n+  public static Buffer getKeyStore(\n+      final String keyStorePath,\n+      final String password,\n+      final String alias\n+  ) {\n+    final char[] pw = password != null ? password.toCharArray() : null;\n+    final KeyStore keyStore = loadExistingKeyStore(keyStorePath, pw);\n+\n+    final PrivateKey key;\n+    final Certificate[] chain;\n+    try {\n+      key = (PrivateKey) keyStore.getKey(alias, pw);\n+      chain = keyStore.getCertificateChain(alias);\n+    } catch (Exception e) {\n+      throw new KsqlException(\"Error fetching key/certificate\", e);\n+    }\n+\n+    if (key == null || chain == null) {\n+      throw new KsqlException(\"Alias doesn't exist in keystore: \" + alias);\n+    }\n+\n+    final byte[] singleValueKeyStore = createSingleValueKeyStore(key, chain, pw, alias);\n+    return Buffer.buffer(singleValueKeyStore);\n+  }\n+\n+  private static KeyStore loadExistingKeyStore(final String keyStorePath, final char[] pw) {\n+    FileInputStream input = null;\n+    try {\n+      input = new FileInputStream(keyStorePath);\n+      final KeyStore keyStore = KeyStore.getInstance(KEYSTORE_TYPE);\n+      keyStore.load(new FileInputStream(keyStorePath), pw);", "originalCommit": "51f0152d2fb11214d27f069e56e038e1a980ab1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYyNTg4Mw==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r435625883", "bodyText": "oops.  Good catch", "author": "AlanConfluent", "createdAt": "2020-06-05T00:19:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE1MTc3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE1NDE0Mg==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r433154142", "bodyText": "why are we passing in a consumer that is just called back with the httpClientOptions passed in?  This feels like an anti-pattern to me.", "author": "big-andy-coates", "createdAt": "2020-06-01T10:20:10Z", "path": "ksqldb-rest-client/src/main/java/io/confluent/ksql/rest/client/KsqlClient.java", "diffHunk": "@@ -44,27 +45,50 @@\n   private final HttpClient httpTlsClient;\n   private final LocalProperties localProperties;\n   private final Optional<String> basicAuthHeader;\n+  private final Optional<HostAliasResolver> hostAliasResolver;\n \n   public KsqlClient(\n       final Map<String, String> clientProps,\n       final Optional<BasicCredentials> credentials,\n       final LocalProperties localProperties,\n-      final HttpClientOptions httpClientOptions\n+      final HttpClientOptions httpClientOptions,\n+      final Optional<HostAliasResolver> hostAliasResolver\n   ) {\n     this.vertx = Vertx.vertx();\n     this.basicAuthHeader = createBasicAuthHeader(\n         Objects.requireNonNull(credentials, \"credentials\"));\n     this.localProperties = Objects.requireNonNull(localProperties, \"localProperties\");\n+    this.hostAliasResolver = Objects.requireNonNull(hostAliasResolver, \"hostAliasResolver\");\n     this.httpNonTlsClient = createHttpClient(vertx, clientProps, httpClientOptions, false);\n     this.httpTlsClient = createHttpClient(vertx, clientProps, httpClientOptions, true);\n   }\n \n+  public KsqlClient(\n+      final Optional<BasicCredentials> credentials,\n+      final LocalProperties localProperties,\n+      final HttpClientOptions httpClientOptions,\n+      final Consumer<HttpClientOptions> sslHttpClientOptionsConsumer,", "originalCommit": "51f0152d2fb11214d27f069e56e038e1a980ab1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYzMzY0OA==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r435633648", "bodyText": "Because it's only used when SSL is used...  I agree I don't like it.  I'll instead pass in a Function<Boolean, HttpClientOptions> factory that takes in if it's ssl in place of this as well as the HttpClientOptions before it.", "author": "AlanConfluent", "createdAt": "2020-06-05T00:52:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE1NDE0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE1NDYwNg==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r433154606", "bodyText": "Rather than store a Optional<HostResolver>, why not default to a HostResolver impl that just returns the value passed? e.g. Function.identify().  This would simplify this code.", "author": "big-andy-coates", "createdAt": "2020-06-01T10:21:22Z", "path": "ksqldb-rest-client/src/main/java/io/confluent/ksql/rest/client/KsqlClient.java", "diffHunk": "@@ -44,27 +45,50 @@\n   private final HttpClient httpTlsClient;\n   private final LocalProperties localProperties;\n   private final Optional<String> basicAuthHeader;\n+  private final Optional<HostAliasResolver> hostAliasResolver;\n \n   public KsqlClient(\n       final Map<String, String> clientProps,\n       final Optional<BasicCredentials> credentials,\n       final LocalProperties localProperties,\n-      final HttpClientOptions httpClientOptions\n+      final HttpClientOptions httpClientOptions,\n+      final Optional<HostAliasResolver> hostAliasResolver\n   ) {\n     this.vertx = Vertx.vertx();\n     this.basicAuthHeader = createBasicAuthHeader(\n         Objects.requireNonNull(credentials, \"credentials\"));\n     this.localProperties = Objects.requireNonNull(localProperties, \"localProperties\");\n+    this.hostAliasResolver = Objects.requireNonNull(hostAliasResolver, \"hostAliasResolver\");\n     this.httpNonTlsClient = createHttpClient(vertx, clientProps, httpClientOptions, false);\n     this.httpTlsClient = createHttpClient(vertx, clientProps, httpClientOptions, true);\n   }\n \n+  public KsqlClient(\n+      final Optional<BasicCredentials> credentials,\n+      final LocalProperties localProperties,\n+      final HttpClientOptions httpClientOptions,\n+      final Consumer<HttpClientOptions> sslHttpClientOptionsConsumer,\n+      final Optional<HostAliasResolver> hostAliasResolver\n+  ) {\n+    this.vertx = Vertx.vertx();\n+    this.basicAuthHeader = createBasicAuthHeader(\n+        Objects.requireNonNull(credentials, \"credentials\"));\n+    this.localProperties = Objects.requireNonNull(localProperties, \"localProperties\");\n+    this.hostAliasResolver = Objects.requireNonNull(hostAliasResolver, \"hostAliasResolver\");\n+    this.httpNonTlsClient = createHttpClient(vertx, httpClientOptions, sslHttpClientOptionsConsumer,\n+        false);\n+    this.httpTlsClient = createHttpClient(vertx, httpClientOptions, sslHttpClientOptionsConsumer,\n+        true);\n+  }\n+\n   public KsqlTarget target(final URI server) {\n     final boolean isUriTls = server.getScheme().equalsIgnoreCase(\"https\");\n     final HttpClient client = isUriTls ? httpTlsClient : httpNonTlsClient;\n+    final String aliasHost = hostAliasResolver.map(resolver -> resolver.resolve(server.getHost()))\n+        .orElse(server.getHost());", "originalCommit": "51f0152d2fb11214d27f069e56e038e1a980ab1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY1ODY5MA==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r435658690", "bodyText": "I effectively did this with your BiFunction<Integer, String, SocketAddress> socketAddressFactory suggestion.", "author": "AlanConfluent", "createdAt": "2020-06-05T02:36:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE1NDYwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE1NTYxNw==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r433155617", "bodyText": "It seems a shame to require every use of this production class to supply a HostAliasResolver, given this should only be passed for test cases, right?  And most test cases won't need this either. Just one or two specific tests that are testing the new code you're adding. Yet HostAliasResolver is mentioned around 40 times in this PR.\nIs there another way?\nAt the very least you could remove this parameter from this constructor and add another constructor, annotated with @VisibleForTesting that takes the resolver.  However, ideally, the production code should know nothing of HostAliasResolver...\nI think this can be achieved by injecting an interface to handle the SocketAddress.inetSocketAddress call.   So rather than taking a HostAliasResolver the @VisiableForTesting constructor takes BiFunction<Integer, String, SocketAddress> socketAddressFactory.  Test code can then use this to perform the same aliasing that HostAliasResolver does now.   Please see if you can remove HostAliasResolver from the production code base, or at least from the non- @VisibleForTesting constructors.\nSocketAddress.inetSocketAddress(server.getPort(), aliasHost)", "author": "big-andy-coates", "createdAt": "2020-06-01T10:23:57Z", "path": "ksqldb-rest-client/src/main/java/io/confluent/ksql/rest/client/KsqlClient.java", "diffHunk": "@@ -44,27 +45,50 @@\n   private final HttpClient httpTlsClient;\n   private final LocalProperties localProperties;\n   private final Optional<String> basicAuthHeader;\n+  private final Optional<HostAliasResolver> hostAliasResolver;\n \n   public KsqlClient(\n       final Map<String, String> clientProps,\n       final Optional<BasicCredentials> credentials,\n       final LocalProperties localProperties,\n-      final HttpClientOptions httpClientOptions\n+      final HttpClientOptions httpClientOptions,\n+      final Optional<HostAliasResolver> hostAliasResolver", "originalCommit": "51f0152d2fb11214d27f069e56e038e1a980ab1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYzMzEwNQ==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r435633105", "bodyText": "Yeah, I agree I didn't really like having to add this, but you need some \"seam\" to inject the test version.\nNice suggestion. I did the factory as you mentioned.  A named interface is definitely a little misleading for test-only code.  Now I have a @VisibleForTesting constructor where I take it, and the other just uses the default SocketAddress::inetSocketAddress.", "author": "AlanConfluent", "createdAt": "2020-06-05T00:50:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE1NTYxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE2MDE5OQ==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r433160199", "bodyText": "why are we passing in host here? I'm assuming this is different to socketAddress.getHost.  This is really counter-intuitive and the kind of thing that will trip people up later when they make changes to this class.\nIs there any reason by you can't just change the calling code to pass in the right socketAdrress?", "author": "big-andy-coates", "createdAt": "2020-06-01T10:34:59Z", "path": "ksqldb-rest-client/src/main/java/io/confluent/ksql/rest/client/KsqlTarget.java", "diffHunk": "@@ -73,28 +73,31 @@\n   private final SocketAddress socketAddress;\n   private final LocalProperties localProperties;\n   private final Optional<String> authHeader;\n+  private final String host;\n \n   KsqlTarget(\n       final HttpClient httpClient,\n       final SocketAddress socketAddress,\n       final LocalProperties localProperties,\n-      final Optional<String> authHeader\n+      final Optional<String> authHeader,\n+      final String host", "originalCommit": "51f0152d2fb11214d27f069e56e038e1a980ab1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY2MzkzNw==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r435663937", "bodyText": "This host value is what's passed to the server as the host header rather than what's used to actually connect.  This is what allows you to connect to localhost while claiming you're talking to example.com and to compare the returned cert to example.com.\nI agree it's a little confusing, though this is the exact API we use in Vert.x: https://vertx.io/docs/apidocs/io/vertx/core/http/HttpClient.html#request-io.vertx.core.http.HttpMethod-io.vertx.core.net.SocketAddress-int-java.lang.String-java.lang.String-io.vertx.core.Handler-\nThe difference there is that they have a lot of overloaded versions that don't require this additional host parameter, so you have to read about it if you want to us it.  I tried adding documentation.  Tell me if you have other ideas.  (One such thing might be taking in arbitrary headers and then I could set the host header explicitly, and use the socketAddress.host() as before, though I don't really consider this cleaner).", "author": "AlanConfluent", "createdAt": "2020-06-05T02:59:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE2MDE5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDEyMDQ3Mg==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r440120472", "bodyText": "Looks good.", "author": "big-andy-coates", "createdAt": "2020-06-15T11:51:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE2MDE5OQ=="}], "type": "inlineReview"}, {"oid": "8c465a732a69fe85cfdc91b1eee10944ae62f419", "url": "https://github.com/confluentinc/ksql/commit/8c465a732a69fe85cfdc91b1eee10944ae62f419", "message": "More feedback", "committedDate": "2020-06-05T03:08:22Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDExNDM1Mw==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r440114353", "bodyText": "Just a suggestion but:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (isInternalListener) {\n          \n          \n            \n                    final String internalAlias = ksqlRestConfig\n          \n          \n            \n                        .getString(KsqlRestConfig.KSQL_SSL_KEYSTORE_ALIAS_INTERNAL_CONFIG);\n          \n          \n            \n                    setTlsOptions(ksqlRestConfig, options, internalAlias,\n          \n          \n            \n                        ksqlRestConfig.getClientAuthInternal());\n          \n          \n            \n                  } else {\n          \n          \n            \n                    final String externalAlias = ksqlRestConfig\n          \n          \n            \n                        .getString(KsqlRestConfig.KSQL_SSL_KEYSTORE_ALIAS_EXTERNAL_CONFIG);\n          \n          \n            \n                    setTlsOptions(ksqlRestConfig, options, externalAlias, ksqlRestConfig.getClientAuth());\n          \n          \n            \n                  final String ksConfigName = isInternalListener:\n          \n          \n            \n                       ? KsqlRestConfig.KSQL_SSL_KEYSTORE_ALIAS_INTERNAL_CONFIG\n          \n          \n            \n                       : KsqlRestConfig.KSQL_SSL_KEYSTORE_ALIAS_EXTERNAL_CONFIG;\n          \n          \n            \n                       \n          \n          \n            \n                  final String alias = ksqlRestConfig.getString(ksConfigName);\n          \n          \n            \n                  setTlsOptions(ksqlRestConfig, options, alias, ksqlRestConfig.getClientAuthInternal());", "author": "big-andy-coates", "createdAt": "2020-06-15T11:38:37Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/api/server/Server.java", "diffHunk": "@@ -251,30 +255,57 @@ private static HttpServerOptions createHttpServerOptions(final KsqlRestConfig ks\n         .setPerFrameWebSocketCompressionSupported(true);\n \n     if (tls) {\n-      options.setUseAlpn(true).setSsl(true);\n-\n-      final String keyStorePath = ksqlRestConfig\n-          .getString(SslConfigs.SSL_KEYSTORE_LOCATION_CONFIG);\n-      final Password keyStorePassword = ksqlRestConfig\n-          .getPassword(SslConfigs.SSL_KEYSTORE_PASSWORD_CONFIG);\n-      if (keyStorePath != null && !keyStorePath.isEmpty()) {\n-        options.setKeyStoreOptions(\n-            new JksOptions().setPath(keyStorePath).setPassword(keyStorePassword.value()));\n+      if (isInternalListener) {\n+        final String internalAlias = ksqlRestConfig\n+            .getString(KsqlRestConfig.KSQL_SSL_KEYSTORE_ALIAS_INTERNAL_CONFIG);\n+        setTlsOptions(ksqlRestConfig, options, internalAlias,\n+            ksqlRestConfig.getClientAuthInternal());\n+      } else {\n+        final String externalAlias = ksqlRestConfig\n+            .getString(KsqlRestConfig.KSQL_SSL_KEYSTORE_ALIAS_EXTERNAL_CONFIG);\n+        setTlsOptions(ksqlRestConfig, options, externalAlias, ksqlRestConfig.getClientAuth());", "originalCommit": "dc801b4f9a8ab90b578d343bdc5e7003e7d2dec7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM1MjkyOA==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r440352928", "bodyText": "Done.", "author": "AlanConfluent", "createdAt": "2020-06-15T18:04:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDExNDM1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDExNzc3MA==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r440117770", "bodyText": "Avoid hardcoded ports in tests - it causes tests to fail if the ports in use, e.g.\n\nIf the build server is running two builds on the same box\nAn engineer is running two builds, for two different change sets, at the same time.\nAn engineer is running ksql to test something else, while they've also got a build running.\netc.\n\nI think you should be able to just set it to http://0.0.0.0:0 and the server will auto-pick a free port.  It certainly did in Jetty days, not sure about Vert.x.  Check with Tim if it doesn't work. I'm sure he'll know how to.\nPlease update all places the port is hardcoded.", "author": "big-andy-coates", "createdAt": "2020-06-15T11:45:51Z", "path": "ksqldb-rest-app/src/test/java/io/confluent/ksql/rest/integration/SystemAuthenticationFunctionalTest.java", "diffHunk": "@@ -0,0 +1,331 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.integration;\n+\n+import static io.confluent.ksql.rest.integration.HighAvailabilityTestUtil.sendClusterStatusRequest;\n+import static io.confluent.ksql.rest.integration.HighAvailabilityTestUtil.waitForClusterToBeDiscovered;\n+import static io.confluent.ksql.rest.integration.HighAvailabilityTestUtil.waitForRemoteServerToChangeStatus;\n+import static io.confluent.ksql.test.util.EmbeddedSingleNodeKafkaCluster.JAAS_KAFKA_PROPS_NAME;\n+import static io.confluent.ksql.test.util.EmbeddedSingleNodeKafkaCluster.VALID_USER1;\n+import static io.confluent.ksql.util.KsqlConfig.KSQL_STREAMS_PREFIX;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.AdditionalMatchers.not;\n+import static org.mockito.ArgumentMatchers.argThat;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+\n+import com.google.common.collect.ImmutableMap;\n+import io.confluent.common.utils.IntegrationTest;\n+import io.confluent.ksql.integration.IntegrationTestHarness;\n+import io.confluent.ksql.integration.Retry;\n+import io.confluent.ksql.rest.client.BasicCredentials;\n+import io.confluent.ksql.rest.entity.ClusterStatusResponse;\n+import io.confluent.ksql.rest.entity.KsqlHostInfoEntity;\n+import io.confluent.ksql.rest.server.KsqlRestConfig;\n+import io.confluent.ksql.rest.server.TestKsqlRestApp;\n+import io.confluent.ksql.security.KsqlAuthorizationProvider;\n+import io.confluent.ksql.serde.FormatFactory;\n+import io.confluent.ksql.test.util.secure.MultiNodeKeyStore;\n+import io.confluent.ksql.test.util.secure.MultiNodeTrustStore;\n+import io.confluent.ksql.test.util.secure.ServerKeyStore;\n+import io.confluent.ksql.util.KsqlConfig;\n+import io.confluent.ksql.util.PageViewDataProvider;\n+import io.vertx.core.net.SocketAddress;\n+import java.io.IOException;\n+import java.security.Principal;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import kafka.zookeeper.ZooKeeperClientException;\n+import org.apache.kafka.common.config.SslConfigs;\n+import org.apache.kafka.streams.StreamsConfig;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.experimental.runners.Enclosed;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.RunWith;\n+import org.mockito.ArgumentMatcher;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+@Category({IntegrationTest.class})\n+@RunWith(Enclosed.class)\n+public class SystemAuthenticationFunctionalTest {\n+\n+  private static final TemporaryFolder TMP = new TemporaryFolder();\n+\n+  static {\n+    try {\n+      TMP.create();\n+    } catch (final IOException e) {\n+      throw new AssertionError(\"Failed to init TMP\", e);\n+    }\n+  }\n+\n+  private static final PageViewDataProvider PAGE_VIEWS_PROVIDER = new PageViewDataProvider();\n+  private static final String PAGE_VIEW_TOPIC = PAGE_VIEWS_PROVIDER.topicName();\n+  private static final String PAGE_VIEW_STREAM = PAGE_VIEWS_PROVIDER.kstreamName();\n+  private static final KsqlHostInfoEntity host0 = new KsqlHostInfoEntity(\"node-1.example.com\",\n+      8188);\n+  private static final KsqlHostInfoEntity host1 = new KsqlHostInfoEntity(\"node-2.example.com\",\n+      8189);\n+  private static final BiFunction<Integer, String, SocketAddress> LOCALHOST_FACTORY =\n+      (port, host) -> SocketAddress.inetSocketAddress(port, \"localhost\");\n+\n+  private static final Map<String, Object> JASS_AUTH_CONFIG = ImmutableMap.<String, Object>builder()\n+      .put(\"authentication.method\", \"BASIC\")\n+      .put(\"authentication.roles\", \"**\")\n+      // Reuse the Kafka JAAS config for KSQL authentication which has the same valid users\n+      .put(\"authentication.realm\", JAAS_KAFKA_PROPS_NAME)\n+      .put(\n+          KsqlConfig.KSQL_SECURITY_EXTENSION_CLASS,\n+          MockKsqlSecurityExtension.class.getName()\n+      )\n+      .build();\n+\n+  private static final Map<String, Object> COMMON_CONFIG = ImmutableMap.<String, Object>builder()\n+      .put(KsqlRestConfig.KSQL_HEARTBEAT_ENABLE_CONFIG, true)\n+      .put(KsqlRestConfig.KSQL_HEARTBEAT_SEND_INTERVAL_MS_CONFIG, 200)\n+      .put(KsqlRestConfig.KSQL_HEARTBEAT_CHECK_INTERVAL_MS_CONFIG, 1000)\n+      .put(KsqlRestConfig.KSQL_HEARTBEAT_DISCOVER_CLUSTER_MS_CONFIG, 1000)\n+      .put(KSQL_STREAMS_PREFIX + StreamsConfig.STATE_DIR_CONFIG, getNewStateDir())\n+      .put(KSQL_STREAMS_PREFIX + StreamsConfig.NUM_STANDBY_REPLICAS_CONFIG, 1)\n+      .put(KsqlConfig.KSQL_SHUTDOWN_TIMEOUT_MS_CONFIG, 1000)\n+      .putAll(ServerKeyStore.keyStoreProps())\n+      .build();\n+\n+  private static Map<String, String> internalKeyStoreProps(boolean node1) {\n+    Map<String, String> keyStoreProps = node1\n+        ? MultiNodeKeyStore.keyStoreNode1Props()\n+        : MultiNodeKeyStore.keyStoreNode2Props();\n+    Map<String, String> trustStoreProps = MultiNodeTrustStore.trustStoreNode1Node2Props();\n+    return ImmutableMap.of(\n+        SslConfigs.SSL_KEYSTORE_LOCATION_CONFIG,\n+        keyStoreProps.get(SslConfigs.SSL_KEYSTORE_LOCATION_CONFIG),\n+        SslConfigs.SSL_KEYSTORE_PASSWORD_CONFIG,\n+        keyStoreProps.get(SslConfigs.SSL_KEYSTORE_PASSWORD_CONFIG),\n+        SslConfigs.SSL_TRUSTSTORE_LOCATION_CONFIG,\n+        trustStoreProps.get(SslConfigs.SSL_TRUSTSTORE_LOCATION_CONFIG),\n+        SslConfigs.SSL_TRUSTSTORE_PASSWORD_CONFIG,\n+        trustStoreProps.get(SslConfigs.SSL_TRUSTSTORE_PASSWORD_CONFIG)\n+    );\n+  }\n+\n+  private static final BasicCredentials USER1 = BasicCredentials.of(\n+      VALID_USER1.username,\n+      VALID_USER1.password\n+  );\n+\n+  private static void commonClassSetup(final IntegrationTestHarness TEST_HARNESS,\n+      final TestKsqlRestApp REST_APP_0) {\n+    TEST_HARNESS.ensureTopics(2, PAGE_VIEW_TOPIC);\n+    TEST_HARNESS.produceRows(PAGE_VIEW_TOPIC, PAGE_VIEWS_PROVIDER, FormatFactory.JSON);\n+    RestIntegrationTestUtil.createStream(REST_APP_0, PAGE_VIEWS_PROVIDER, Optional.of(USER1));\n+    RestIntegrationTestUtil.makeKsqlRequest(\n+        REST_APP_0,\n+        \"CREATE STREAM S AS SELECT * FROM \" + PAGE_VIEW_STREAM + \";\",\n+        Optional.of(USER1)\n+    );\n+  }\n+\n+  @RunWith(MockitoJUnitRunner.class)\n+  public static class MutualAuth {\n+    private static final IntegrationTestHarness TEST_HARNESS = IntegrationTestHarness.build();\n+    private static final TestKsqlRestApp REST_APP_0 = TestKsqlRestApp\n+        .builder(TEST_HARNESS::kafkaBootstrapServers)\n+        .withEnabledKsqlClient(LOCALHOST_FACTORY)\n+        .withProperty(KsqlRestConfig.LISTENERS_CONFIG, \"http://0.0.0.0:8088\")", "originalCommit": "dc801b4f9a8ab90b578d343bdc5e7003e7d2dec7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM2NDMxNA==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r440364314", "bodyText": "This works fine for listeners, so I did that there.  There's a bit of an issue with doing this for KsqlRestConfig.INTERNAL_LISTENER_CONFIG because I have to also reference the port when setting KsqlRestConfig.ADVERTISED_LISTENER_CONFIG.  At the moment, configs have to be set by the time the server starts up, and yet using port 0, the port doesn't get resolved until the server starts.\nThis can possibly be resolved by reworking the code a bit, but that seems like work for a followup.", "author": "AlanConfluent", "createdAt": "2020-06-15T18:25:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDExNzc3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDExODc2NQ==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r440118765", "bodyText": "Is it worth having two versions: one with and one without this function?  Seems like most things won't need the ability to override the host.", "author": "big-andy-coates", "createdAt": "2020-06-15T11:47:57Z", "path": "ksqldb-rest-app/src/test/java/io/confluent/ksql/rest/server/services/TestDefaultKsqlClientFactory.java", "diffHunk": "@@ -11,8 +13,9 @@\n public class TestDefaultKsqlClientFactory {\n \n   // Creates an instance with no auth\n-  public static SimpleKsqlClient instance(Map<String, Object> clientProps) {\n-    return new DefaultKsqlClient(Optional.empty(), clientProps);\n+  public static SimpleKsqlClient instance(Map<String, Object> clientProps,\n+      final BiFunction<Integer, String, SocketAddress> socketAddressFactory) {", "originalCommit": "dc801b4f9a8ab90b578d343bdc5e7003e7d2dec7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM2NDU2Mw==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r440364563", "bodyText": "Sure, added.", "author": "AlanConfluent", "createdAt": "2020-06-15T18:26:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDExODc2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDExOTg3Mg==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r440119872", "bodyText": "Worth adding java docs on the params?  The new socketAddressFactory probably isn't obvious", "author": "big-andy-coates", "createdAt": "2020-06-15T11:50:15Z", "path": "ksqldb-rest-client/src/main/java/io/confluent/ksql/rest/client/KsqlClient.java", "diffHunk": "@@ -55,16 +58,33 @@ public KsqlClient(\n     this.basicAuthHeader = createBasicAuthHeader(\n         Objects.requireNonNull(credentials, \"credentials\"));\n     this.localProperties = Objects.requireNonNull(localProperties, \"localProperties\");\n+    this.socketAddressFactory = SocketAddress::inetSocketAddress;\n     this.httpNonTlsClient = createHttpClient(vertx, clientProps, httpClientOptions, false);\n     this.httpTlsClient = createHttpClient(vertx, clientProps, httpClientOptions, true);\n   }\n \n+  public KsqlClient(", "originalCommit": "dc801b4f9a8ab90b578d343bdc5e7003e7d2dec7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM2OTYwMA==", "url": "https://github.com/confluentinc/ksql/pull/5482#discussion_r440369600", "bodyText": "Done", "author": "AlanConfluent", "createdAt": "2020-06-15T18:35:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDExOTg3Mg=="}], "type": "inlineReview"}, {"oid": "9454c9d1c9f1b282e4759e244366aa6d4a56bbac", "url": "https://github.com/confluentinc/ksql/commit/9454c9d1c9f1b282e4759e244366aa6d4a56bbac", "message": "feat: Adds SSL mutual auth support to intra-cluster requests", "committedDate": "2020-06-15T21:53:07Z", "type": "commit"}, {"oid": "f11bfb4bb65a2fa4561d4328128c72307efbdd2e", "url": "https://github.com/confluentinc/ksql/commit/f11bfb4bb65a2fa4561d4328128c72307efbdd2e", "message": "feat: Adds SSL mutual auth to system calls and authenticates then as a SystemUser", "committedDate": "2020-06-15T21:54:36Z", "type": "commit"}, {"oid": "1f2eb1fb046363463a23a085f12ae8db69f3f635", "url": "https://github.com/confluentinc/ksql/commit/1f2eb1fb046363463a23a085f12ae8db69f3f635", "message": "Uses normal keystore", "committedDate": "2020-06-15T21:55:22Z", "type": "commit"}, {"oid": "ea5b011c99afa1df22e35e71f64d4d8fcfb67bf4", "url": "https://github.com/confluentinc/ksql/commit/ea5b011c99afa1df22e35e71f64d4d8fcfb67bf4", "message": "Remove comment block", "committedDate": "2020-06-15T21:55:23Z", "type": "commit"}, {"oid": "6323bba25dbbe262aeb24636a36563077be36b7a", "url": "https://github.com/confluentinc/ksql/commit/6323bba25dbbe262aeb24636a36563077be36b7a", "message": "Gets everything working", "committedDate": "2020-06-15T21:56:17Z", "type": "commit"}, {"oid": "b19ce41bd7aaed62d7f8b41236f4ebbd798a8994", "url": "https://github.com/confluentinc/ksql/commit/b19ce41bd7aaed62d7f8b41236f4ebbd798a8994", "message": "Does docs and fixes style", "committedDate": "2020-06-15T21:56:18Z", "type": "commit"}, {"oid": "92840c2684233fc64a0e64f06a23048c8e495eb2", "url": "https://github.com/confluentinc/ksql/commit/92840c2684233fc64a0e64f06a23048c8e495eb2", "message": "Reverts configs", "committedDate": "2020-06-15T21:56:18Z", "type": "commit"}, {"oid": "13e31ed47153d3dc5bf5006234c0c432ac14fecf", "url": "https://github.com/confluentinc/ksql/commit/13e31ed47153d3dc5bf5006234c0c432ac14fecf", "message": "Removed unused field", "committedDate": "2020-06-15T21:56:18Z", "type": "commit"}, {"oid": "da8b0e9984326c60032f281af5958583a81360b9", "url": "https://github.com/confluentinc/ksql/commit/da8b0e9984326c60032f281af5958583a81360b9", "message": "Apply suggestions from code review\n\nCo-authored-by: Jim Galasyn <jim.galasyn@confluent.io>\nCo-authored-by: Andy Coates <8012398+big-andy-coates@users.noreply.github.com>", "committedDate": "2020-06-15T21:56:18Z", "type": "commit"}, {"oid": "dd7fa0f6a378e745322578be5e71362a208aea2e", "url": "https://github.com/confluentinc/ksql/commit/dd7fa0f6a378e745322578be5e71362a208aea2e", "message": "Feedback", "committedDate": "2020-06-15T21:56:46Z", "type": "commit"}, {"oid": "1523b4ae82a5b51df8e277a90df5dfb04b29e176", "url": "https://github.com/confluentinc/ksql/commit/1523b4ae82a5b51df8e277a90df5dfb04b29e176", "message": "Fixes lint warnings", "committedDate": "2020-06-15T21:57:03Z", "type": "commit"}, {"oid": "7cb00a20b2fa755cc65a303f6d6e80bf97853cf5", "url": "https://github.com/confluentinc/ksql/commit/7cb00a20b2fa755cc65a303f6d6e80bf97853cf5", "message": "Updated docs", "committedDate": "2020-06-15T21:57:04Z", "type": "commit"}, {"oid": "c0d3c26c73ed3b9892c34b326c04a99434824296", "url": "https://github.com/confluentinc/ksql/commit/c0d3c26c73ed3b9892c34b326c04a99434824296", "message": "Used aliases rather than new configs", "committedDate": "2020-06-15T21:57:04Z", "type": "commit"}, {"oid": "d4535ceeec7970aa4579fe456753178eca80fca5", "url": "https://github.com/confluentinc/ksql/commit/d4535ceeec7970aa4579fe456753178eca80fca5", "message": "Updated docs", "committedDate": "2020-06-15T21:57:04Z", "type": "commit"}, {"oid": "93d2ceeb2da501ab3b549542cd27b732e45239e5", "url": "https://github.com/confluentinc/ksql/commit/93d2ceeb2da501ab3b549542cd27b732e45239e5", "message": "Fixes warning for InputStream", "committedDate": "2020-06-15T21:57:04Z", "type": "commit"}, {"oid": "9e8a9b8631294ff1f7c48e2fe345fca625bba815", "url": "https://github.com/confluentinc/ksql/commit/9e8a9b8631294ff1f7c48e2fe345fca625bba815", "message": "Bunch of feedback", "committedDate": "2020-06-15T21:57:05Z", "type": "commit"}, {"oid": "2029ec68e31996e871717881f816ef469f8753ec", "url": "https://github.com/confluentinc/ksql/commit/2029ec68e31996e871717881f816ef469f8753ec", "message": "More feedback", "committedDate": "2020-06-15T21:57:05Z", "type": "commit"}, {"oid": "4820d75f92e61d09f21bc08a7f4965096e97565a", "url": "https://github.com/confluentinc/ksql/commit/4820d75f92e61d09f21bc08a7f4965096e97565a", "message": "fixes test", "committedDate": "2020-06-15T21:57:05Z", "type": "commit"}, {"oid": "25459cde3f7dbf42d39fa2bcbc0e48e81706c3ab", "url": "https://github.com/confluentinc/ksql/commit/25459cde3f7dbf42d39fa2bcbc0e48e81706c3ab", "message": "Feedback", "committedDate": "2020-06-15T21:57:05Z", "type": "commit"}, {"oid": "e01f92bcf2caba04796e6ce8c31c73d334ea15ac", "url": "https://github.com/confluentinc/ksql/commit/e01f92bcf2caba04796e6ce8c31c73d334ea15ac", "message": "Latest feedback", "committedDate": "2020-06-15T22:40:26Z", "type": "commit"}, {"oid": "e01f92bcf2caba04796e6ce8c31c73d334ea15ac", "url": "https://github.com/confluentinc/ksql/commit/e01f92bcf2caba04796e6ce8c31c73d334ea15ac", "message": "Latest feedback", "committedDate": "2020-06-15T22:40:26Z", "type": "forcePushed"}, {"oid": "2c87b67575970d48f5c03594ac0be8a7f7fdad74", "url": "https://github.com/confluentinc/ksql/commit/2c87b67575970d48f5c03594ac0be8a7f7fdad74", "message": "One last rejig of docs", "committedDate": "2020-06-15T22:56:45Z", "type": "commit"}, {"oid": "910b08697de0df726d6d7198a4d147ae37d0268d", "url": "https://github.com/confluentinc/ksql/commit/910b08697de0df726d6d7198a4d147ae37d0268d", "message": "Apply suggestions from code review\n\nCo-authored-by: Jim Galasyn <jim.galasyn@confluent.io>", "committedDate": "2020-06-16T00:04:29Z", "type": "commit"}, {"oid": "a7de9880dcb6ac4031037149ff6b33a00a3b4c3f", "url": "https://github.com/confluentinc/ksql/commit/a7de9880dcb6ac4031037149ff6b33a00a3b4c3f", "message": "Fixes many links in doc", "committedDate": "2020-06-16T00:51:36Z", "type": "commit"}]}