{"pr_number": 5029, "pr_title": "feat: add KsqlQueryStatus to decouple from KafkaStreams.State", "pr_createdAt": "2020-04-08T16:57:04Z", "pr_url": "https://github.com/confluentinc/ksql/pull/5029", "timeline": [{"oid": "89c2492ad6b3dad3e7270ff4a40de473d9b5d40b", "url": "https://github.com/confluentinc/ksql/commit/89c2492ad6b3dad3e7270ff4a40de473d9b5d40b", "message": "feat: add KsqlQueryState to decouple from KafkaStreams.State", "committedDate": "2020-04-08T19:25:45Z", "type": "forcePushed"}, {"oid": "f42c11bae1c6980533d46e860a4a1d51424d9638", "url": "https://github.com/confluentinc/ksql/commit/f42c11bae1c6980533d46e860a4a1d51424d9638", "message": "feat: add KsqlQueryState to decouple from KafkaStreams.State", "committedDate": "2020-04-08T21:06:18Z", "type": "forcePushed"}, {"oid": "e34a12743792dc0963b702acd25a0e31ad456f83", "url": "https://github.com/confluentinc/ksql/commit/e34a12743792dc0963b702acd25a0e31ad456f83", "message": "feat: add KsqlQueryState to decouple from KafkaStreams.State", "committedDate": "2020-04-08T22:49:19Z", "type": "forcePushed"}, {"oid": "9a475bdadead4b63164918efa52745e9c2a12ae5", "url": "https://github.com/confluentinc/ksql/commit/9a475bdadead4b63164918efa52745e9c2a12ae5", "message": "feat: add KsqlQueryState to decouple from KafkaStreams.State", "committedDate": "2020-04-09T16:17:37Z", "type": "commit"}, {"oid": "9a475bdadead4b63164918efa52745e9c2a12ae5", "url": "https://github.com/confluentinc/ksql/commit/9a475bdadead4b63164918efa52745e9c2a12ae5", "message": "feat: add KsqlQueryState to decouple from KafkaStreams.State", "committedDate": "2020-04-09T16:17:37Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjMzNzAwOA==", "url": "https://github.com/confluentinc/ksql/pull/5029#discussion_r406337008", "bodyText": "KsqlQueryState makes it sounds like its referring to a state store or underlying state.. May be KsqlQueryStatus is a better name?\nJust a thought. Leave it to you :)", "author": "vinothchandar", "createdAt": "2020-04-09T16:44:54Z", "path": "ksqldb-common/src/main/java/io/confluent/ksql/util/KsqlConstants.java", "diffHunk": "@@ -44,7 +49,24 @@ private KsqlConstants() {\n   public static final String AVRO_SCHEMA_NAMESPACE = \"io.confluent.ksql.avro_schemas\";\n   public static final String AVRO_SCHEMA_NAME = \"KsqlDataSourceSchema\";\n   public static final String DEFAULT_AVRO_SCHEMA_FULL_NAME =\n-          AVRO_SCHEMA_NAMESPACE + \".\" + AVRO_SCHEMA_NAME;\n+      AVRO_SCHEMA_NAMESPACE + \".\" + AVRO_SCHEMA_NAME;\n+\n+  public enum KsqlQueryState {", "originalCommit": "9a475bdadead4b63164918efa52745e9c2a12ae5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQxMjAzNw==", "url": "https://github.com/confluentinc/ksql/pull/5029#discussion_r406412037", "bodyText": "hmm, I see what you mean and I agree. I used state here because we previously had getState for the QueryMetadata object so I just continued using State in the recent changes I made and this current one.\nI'm not sure exactly what we want to be calling this, should we just make the change in this PR to try to use status wherever we can instead of state?", "author": "stevenpyzhang", "createdAt": "2020-04-09T18:57:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjMzNzAwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ2OTI3Mw==", "url": "https://github.com/confluentinc/ksql/pull/5029#discussion_r406469273", "bodyText": "@vinothchandar I think I'm leaning more on the side of just keeping it state for now since I'm keeping the state field in the RunningQuery and QueryDescription response objects for backwards compatibility.\nAny thoughts @rodesai ? The upcoming query error handling would be using this enum.", "author": "stevenpyzhang", "createdAt": "2020-04-09T20:50:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjMzNzAwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ5ODgzMg==", "url": "https://github.com/confluentinc/ksql/pull/5029#discussion_r406498832", "bodyText": "I vote for status to disambiguate from queryable state.", "author": "rodesai", "createdAt": "2020-04-09T21:52:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjMzNzAwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUzMzUzMA==", "url": "https://github.com/confluentinc/ksql/pull/5029#discussion_r406533530", "bodyText": "error and status go more hand in hand IMO.. I do see this is \"Streams' state\" per se. leave it to you :)", "author": "vinothchandar", "createdAt": "2020-04-09T23:39:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjMzNzAwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU0OTE0MQ==", "url": "https://github.com/confluentinc/ksql/pull/5029#discussion_r406549141", "bodyText": "I've changed it to KsqlQueryStatus now", "author": "stevenpyzhang", "createdAt": "2020-04-10T00:40:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjMzNzAwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ0MTk5MA==", "url": "https://github.com/confluentinc/ksql/pull/5029#discussion_r406441990", "bodyText": "nit: I feel like this is better implemented as a method:\npublic static KsqlQueryState fromStreamsState(final KafkaStreams.State state) {\n  return state == KafkaStreams.State.ERROR ? KsqlQueryState.ERROR : KsqlQueryState.RUNNING;\n}\n\nthe benefit is that you avoid the static constructor, which can cause very confusing ClassNotFoundException if it fails due to some errror", "author": "agavra", "createdAt": "2020-04-09T19:55:33Z", "path": "ksqldb-common/src/main/java/io/confluent/ksql/util/KsqlConstants.java", "diffHunk": "@@ -44,7 +49,24 @@ private KsqlConstants() {\n   public static final String AVRO_SCHEMA_NAMESPACE = \"io.confluent.ksql.avro_schemas\";\n   public static final String AVRO_SCHEMA_NAME = \"KsqlDataSourceSchema\";\n   public static final String DEFAULT_AVRO_SCHEMA_FULL_NAME =\n-          AVRO_SCHEMA_NAMESPACE + \".\" + AVRO_SCHEMA_NAME;\n+      AVRO_SCHEMA_NAMESPACE + \".\" + AVRO_SCHEMA_NAME;\n+\n+  public enum KsqlQueryState {\n+    RUNNING,\n+    ERROR,\n+    UNRESPONSIVE,\n+  }\n+\n+  public static final Map<KafkaStreams.State, KsqlQueryState> STREAMS_STATE_TO_KSQL_QUERY_STATE;\n+\n+  static {\n+    final Map<KafkaStreams.State, KsqlQueryState> stateMapping = new HashMap<>();\n+    for (KafkaStreams.State state:KafkaStreams.State.values()) {\n+      stateMapping.put(state, KsqlQueryState.RUNNING);\n+    }\n+    stateMapping.put(KafkaStreams.State.ERROR, KsqlQueryState.ERROR);\n+    STREAMS_STATE_TO_KSQL_QUERY_STATE = ImmutableMap.copyOf(stateMapping);\n+  }", "originalCommit": "9a475bdadead4b63164918efa52745e9c2a12ae5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUxMDI1MQ==", "url": "https://github.com/confluentinc/ksql/pull/5029#discussion_r406510251", "bodyText": "moved to a method in QueryStatusCount class", "author": "stevenpyzhang", "createdAt": "2020-04-09T22:23:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ0MTk5MA=="}], "type": "inlineReview"}, {"oid": "079f4aea5fb1f84e791c7e9abd6e7580b3d7707f", "url": "https://github.com/confluentinc/ksql/commit/079f4aea5fb1f84e791c7e9abd6e7580b3d7707f", "message": "comments", "committedDate": "2020-04-09T21:51:00Z", "type": "commit"}, {"oid": "e9b067fa0570c974448b48639b63cf394bdf4077", "url": "https://github.com/confluentinc/ksql/commit/e9b067fa0570c974448b48639b63cf394bdf4077", "message": "change mentions of state to status", "committedDate": "2020-04-09T22:24:01Z", "type": "forcePushed"}, {"oid": "2110c883b8705a130a0d043b85c1fa85d3727012", "url": "https://github.com/confluentinc/ksql/commit/2110c883b8705a130a0d043b85c1fa85d3727012", "message": "change mentions of state to status", "committedDate": "2020-04-09T23:12:52Z", "type": "forcePushed"}, {"oid": "706d514d69c025f50b00cff571c74d0b76055417", "url": "https://github.com/confluentinc/ksql/commit/706d514d69c025f50b00cff571c74d0b76055417", "message": "change mentions of state to status", "committedDate": "2020-04-09T23:16:53Z", "type": "commit"}, {"oid": "706d514d69c025f50b00cff571c74d0b76055417", "url": "https://github.com/confluentinc/ksql/commit/706d514d69c025f50b00cff571c74d0b76055417", "message": "change mentions of state to status", "committedDate": "2020-04-09T23:16:53Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE0ODU0NQ==", "url": "https://github.com/confluentinc/ksql/pull/5029#discussion_r408148545", "bodyText": "It would be better if CompletableFuture was used here instead of the legacy blocking Future class.\nThat way we wouldn't have to refactor this code when we move to a non blocking model.\nThis is a general point really, we shouldn't be using Future in new code.", "author": "purplefox", "createdAt": "2020-04-14T13:46:35Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/ListQueriesExecutor.java", "diffHunk": "@@ -168,43 +181,55 @@ private static void mergeSimple(\n                 query,\n                 Collections.singletonMap(\n                     new KsqlHostInfoEntity(sessionProperties.getKsqlHostInfo()),\n-                    query.getState()))));\n+                    KsqlConstants.fromStreamsState(\n+                        KafkaStreams.State.valueOf(query.getState()))\n+                ))));\n   }\n \n   private static void mergeExtended(\n-      final List<KsqlEntity> remoteResults,\n+      final Pair<List<KsqlEntity>, Set<HostInfo>> remoteResults,\n       final Map<QueryId, QueryDescription> allResults\n   ) {\n-    final List<QueryDescription> remoteQueryDescriptions = remoteResults.stream()\n+    final List<KsqlEntity> remoteQueries = remoteResults.getLeft();\n+    final List<QueryDescription> remoteQueryDescriptions = remoteQueries.stream()\n         .map(QueryDescriptionList.class::cast)\n         .map(QueryDescriptionList::getQueryDescriptions)\n         .flatMap(List::stream)\n         .collect(Collectors.toList());\n     for (QueryDescription q : remoteQueryDescriptions) {\n       final QueryId queryId = q.getId();\n \n-      // If the query has already been discovered, add to the ksqlQueryHostState mapping\n+      // If the query has already been discovered, add to the ksqlQueryHostStatus mapping\n       if (allResults.containsKey(queryId)) {\n-        for (Map.Entry<KsqlHostInfoEntity, String> entry :\n-            q.getKsqlHostQueryState().entrySet()) {\n+        for (Map.Entry<KsqlHostInfoEntity, KsqlQueryStatus> entry :\n+            q.getKsqlHostQueryStatus().entrySet()) {\n           allResults\n               .get(queryId)\n-              .updateKsqlHostQueryState(entry.getKey(), entry.getValue());\n+              .updateKsqlHostQueryStatus(entry.getKey(), entry.getValue());\n         }\n       } else {\n         allResults.put(queryId, q);\n       }\n     }\n+    \n+    final Set<HostInfo> unresponsiveRemoteHosts = remoteResults.getRight();\n+    for (HostInfo hostInfo: unresponsiveRemoteHosts) {\n+      for (QueryDescription queryDescription: allResults.values()) {\n+        queryDescription.updateKsqlHostQueryStatus(\n+            new KsqlHostInfoEntity(hostInfo.host(), hostInfo.port()),\n+            KsqlQueryStatus.UNRESPONSIVE);\n+      }\n+    }\n   }\n \n-  private static List<KsqlEntity> scatterGather(\n+  private static Pair<List<KsqlEntity>, Set<HostInfo>> scatterGather(", "originalCommit": "706d514d69c025f50b00cff571c74d0b76055417", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM3MDg5Mg==", "url": "https://github.com/confluentinc/ksql/pull/5029#discussion_r408370892", "bodyText": "I can open another PR to change it to use CompletableFuture", "author": "stevenpyzhang", "createdAt": "2020-04-14T19:08:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE0ODU0NQ=="}], "type": "inlineReview"}]}