{"pr_number": 6535, "pr_title": "feat: CASE expressions can now handle 12+ conditions in docker + cloud", "pr_createdAt": "2020-10-28T05:43:08Z", "pr_url": "https://github.com/confluentinc/ksql/pull/6535", "timeline": [{"oid": "e9e3f3eff6d15f59056221212f906aa2932abd62", "url": "https://github.com/confluentinc/ksql/commit/e9e3f3eff6d15f59056221212f906aa2932abd62", "message": "replaced ImmutableList.of() with ImmutableList.copyOf(Arrays.asList())", "committedDate": "2020-10-28T05:32:46Z", "type": "commit"}, {"oid": "45e4e12c036a59ccbf06c98f6ac6f729e58ccf7c", "url": "https://github.com/confluentinc/ksql/commit/45e4e12c036a59ccbf06c98f6ac6f729e58ccf7c", "message": "semantic", "committedDate": "2020-10-28T05:37:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYwNzcxMg==", "url": "https://github.com/confluentinc/ksql/pull/6535#discussion_r513607712", "bodyText": "I believe every time this is evaluated for a given row, it creates this list and iterates through.  It would be good to avoid additional copies if possible.  I read through the documentation for Arrays.asList and it actually seems to just wrap the array and not copy it, so I think this does just one copy, which is what the original code did.  You might want to verify that, but I think you're good.\nI would make sure to add comments here documenting why this combination is necessary!  Otherwise someone will simplify it again and rebreak it.\nConsider making a separate static method in CodeGenUtil that's documented well so that it's use stands out.  If all variadic args works fine, it could be something like:\npublic static <T> List<T> listOf(final T... a) {\n    return ImmutableList.copyOf(a);\n  }", "author": "AlanConfluent", "createdAt": "2020-10-28T16:55:35Z", "path": "ksqldb-execution/src/main/java/io/confluent/ksql/execution/codegen/SqlToJavaVisitor.java", "diffHunk": "@@ -765,10 +766,11 @@ private String visitBooleanComparisonExpression(final ComparisonExpression.Type\n           : \"null\";\n \n       final String codeString = \"((\" + resultSchemaString + \")\"\n-          + functionClassName + \".searchedCaseFunction(ImmutableList.of( \"\n-          + StringUtils.join(lazyWhenClause, \", \") + \"),\"\n+          + functionClassName + \".searchedCaseFunction(ImmutableList.copyOf(Arrays.asList( \"", "originalCommit": "45e4e12c036a59ccbf06c98f6ac6f729e58ccf7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzczMzk5Ng==", "url": "https://github.com/confluentinc/ksql/pull/6535#discussion_r513733996", "bodyText": "Let's just play it safe keep the composition of the 2 standard methods", "author": "cprasad1", "createdAt": "2020-10-28T20:18:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYwNzcxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYwODI4NQ==", "url": "https://github.com/confluentinc/ksql/pull/6535#discussion_r513608285", "bodyText": "Add a new test case with 13 case statements to ensure that we don't regress on this bug.", "author": "AlanConfluent", "createdAt": "2020-10-28T16:56:16Z", "path": "ksqldb-execution/src/test/java/io/confluent/ksql/execution/codegen/SqlToJavaVisitorTest.java", "diffHunk": "@@ -486,7 +486,7 @@ public void shouldGenerateCorrectCodeForCaseStatement() {\n     // ThenL\n     assertThat(\n         javaExpression, equalTo(\n-            \"((java.lang.String)SearchedCaseFunction.searchedCaseFunction(ImmutableList.of( SearchedCaseFunction.whenClause( new Supplier<Boolean>() { @Override public Boolean get() { return ((((Object)(COL7)) == null || ((Object)(10)) == null) ? false : (COL7 < 10)); }},  new Supplier<java.lang.String>() { @Override public java.lang.String get() { return \\\"small\\\"; }}), SearchedCaseFunction.whenClause( new Supplier<Boolean>() { @Override public Boolean get() { return ((((Object)(COL7)) == null || ((Object)(100)) == null) ? false : (COL7 < 100)); }},  new Supplier<java.lang.String>() { @Override public java.lang.String get() { return \\\"medium\\\"; }})), new Supplier<java.lang.String>() { @Override public java.lang.String get() { return \\\"large\\\"; }}))\"));\n+            \"((java.lang.String)SearchedCaseFunction.searchedCaseFunction(ImmutableList.copyOf(Arrays.asList( SearchedCaseFunction.whenClause( new Supplier<Boolean>() { @Override public Boolean get() { return ((((Object)(COL7)) == null || ((Object)(10)) == null) ? false : (COL7 < 10)); }},  new Supplier<java.lang.String>() { @Override public java.lang.String get() { return \\\"small\\\"; }}), SearchedCaseFunction.whenClause( new Supplier<Boolean>() { @Override public Boolean get() { return ((((Object)(COL7)) == null || ((Object)(100)) == null) ? false : (COL7 < 100)); }},  new Supplier<java.lang.String>() { @Override public java.lang.String get() { return \\\"medium\\\"; }}))), new Supplier<java.lang.String>() { @Override public java.lang.String get() { return \\\"large\\\"; }}))\"));", "originalCommit": "45e4e12c036a59ccbf06c98f6ac6f729e58ccf7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzczNDA1MA==", "url": "https://github.com/confluentinc/ksql/pull/6535#discussion_r513734050", "bodyText": "added", "author": "cprasad1", "createdAt": "2020-10-28T20:18:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYwODI4NQ=="}], "type": "inlineReview"}, {"oid": "51b3dead6233fc7dbb82fce3af6e0040e06c8f99", "url": "https://github.com/confluentinc/ksql/commit/51b3dead6233fc7dbb82fce3af6e0040e06c8f99", "message": "added test with 13 cases and comments", "committedDate": "2020-10-28T20:17:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzczNTkzMA==", "url": "https://github.com/confluentinc/ksql/pull/6535#discussion_r513735930", "bodyText": "You might want to mention that it's the janino compiler that chokes on the combination of normal and variadic args (assuming we verified that as the cause).  This avoids that.", "author": "AlanConfluent", "createdAt": "2020-10-28T20:22:04Z", "path": "ksqldb-execution/src/main/java/io/confluent/ksql/execution/codegen/SqlToJavaVisitor.java", "diffHunk": "@@ -764,11 +765,15 @@ private String visitBooleanComparisonExpression(final ComparisonExpression.Type\n           ? process(node.getDefaultValue().get(), context).getLeft()\n           : \"null\";\n \n+      // ImmutableList.copyOf(Arrays.asList()) replaced ImmutableList.of() to avoid", "originalCommit": "51b3dead6233fc7dbb82fce3af6e0040e06c8f99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc0MzE0NQ==", "url": "https://github.com/confluentinc/ksql/pull/6535#discussion_r513743145", "bodyText": "I have linked the github issue because I thought that anyone who encounters this can go to that issue and check out the detailed discussions there", "author": "cprasad1", "createdAt": "2020-10-28T20:35:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzczNTkzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzczOTAyNg==", "url": "https://github.com/confluentinc/ksql/pull/6535#discussion_r513739026", "bodyText": "This part always worked, producing the java.  Is there a place where we can actually cook and evaluate this code to verify that it does't cause an exception?  I think there used to be a CodeGenRunnerTest.    It would be great to have a test there.", "author": "AlanConfluent", "createdAt": "2020-10-28T20:27:40Z", "path": "ksqldb-execution/src/test/java/io/confluent/ksql/execution/codegen/SqlToJavaVisitorTest.java", "diffHunk": "@@ -486,7 +488,37 @@ public void shouldGenerateCorrectCodeForCaseStatement() {\n     // ThenL\n     assertThat(\n         javaExpression, equalTo(\n-            \"((java.lang.String)SearchedCaseFunction.searchedCaseFunction(ImmutableList.of( SearchedCaseFunction.whenClause( new Supplier<Boolean>() { @Override public Boolean get() { return ((((Object)(COL7)) == null || ((Object)(10)) == null) ? false : (COL7 < 10)); }},  new Supplier<java.lang.String>() { @Override public java.lang.String get() { return \\\"small\\\"; }}), SearchedCaseFunction.whenClause( new Supplier<Boolean>() { @Override public Boolean get() { return ((((Object)(COL7)) == null || ((Object)(100)) == null) ? false : (COL7 < 100)); }},  new Supplier<java.lang.String>() { @Override public java.lang.String get() { return \\\"medium\\\"; }})), new Supplier<java.lang.String>() { @Override public java.lang.String get() { return \\\"large\\\"; }}))\"));\n+            \"((java.lang.String)SearchedCaseFunction.searchedCaseFunction(ImmutableList.copyOf(Arrays.asList( SearchedCaseFunction.whenClause( new Supplier<Boolean>() { @Override public Boolean get() { return ((((Object)(COL7)) == null || ((Object)(10)) == null) ? false : (COL7 < 10)); }},  new Supplier<java.lang.String>() { @Override public java.lang.String get() { return \\\"small\\\"; }}), SearchedCaseFunction.whenClause( new Supplier<Boolean>() { @Override public Boolean get() { return ((((Object)(COL7)) == null || ((Object)(100)) == null) ? false : (COL7 < 100)); }},  new Supplier<java.lang.String>() { @Override public java.lang.String get() { return \\\"medium\\\"; }}))), new Supplier<java.lang.String>() { @Override public java.lang.String get() { return \\\"large\\\"; }}))\"));\n+  }\n+\n+  @Test\n+  public void shouldGenerateCorrectCodeForCaseStatementWith13Conditions() {\n+    // Given:\n+    final ImmutableList<Integer> numbers = ImmutableList.of(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12);\n+    final ImmutableList<String> numberNames = ImmutableList.of(\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\",\n+                                                       \"six\", \"seven\", \"eight\", \"nine\", \"ten\",\n+                                                       \"eleven\", \"twelve\");\n+\n+    final ImmutableList arg = numbers\n+            .stream()\n+            .map(n -> new WhenClause(\n+            new ComparisonExpression(\n+                    ComparisonExpression.Type.EQUAL, COL7, new IntegerLiteral(n)),\n+            new StringLiteral(numberNames.get(n))\n+    )).collect(ImmutableList.toImmutableList());\n+\n+    final Expression expression = new SearchedCaseExpression(\n+            arg,\n+            Optional.empty()\n+    );\n+\n+    // When:\n+    final String javaExpression = sqlToJavaVisitor.process(expression);\n+\n+    // ThenL\n+    assertThat(\n+            javaExpression, equalTo(\n+                    \"((java.lang.String)SearchedCaseFunction.searchedCaseFunction(ImmutableList.copyOf(Arrays.asList( SearchedCaseFunction.whenClause( new Supplier<Boolean>() { @Override public Boolean get() { return ((((Object)(COL7)) == null || ((Object)(0)) == null) ? false : ((COL7 <= 0) && (COL7 >= 0))); }},  new Supplier<java.lang.String>() { @Override public java.lang.String get() { return \\\"zero\\\"; }}), SearchedCaseFunction.whenClause( new Supplier<Boolean>() { @Override public Boolean get() { return ((((Object)(COL7)) == null || ((Object)(1)) == null) ? false : ((COL7 <= 1) && (COL7 >= 1))); }},  new Supplier<java.lang.String>() { @Override public java.lang.String get() { return \\\"one\\\"; }}), SearchedCaseFunction.whenClause( new Supplier<Boolean>() { @Override public Boolean get() { return ((((Object)(COL7)) == null || ((Object)(2)) == null) ? false : ((COL7 <= 2) && (COL7 >= 2))); }},  new Supplier<java.lang.String>() { @Override public java.lang.String get() { return \\\"two\\\"; }}), SearchedCaseFunction.whenClause( new Supplier<Boolean>() { @Override public Boolean get() { return ((((Object)(COL7)) == null || ((Object)(3)) == null) ? false : ((COL7 <= 3) && (COL7 >= 3))); }},  new Supplier<java.lang.String>() { @Override public java.lang.String get() { return \\\"three\\\"; }}), SearchedCaseFunction.whenClause( new Supplier<Boolean>() { @Override public Boolean get() { return ((((Object)(COL7)) == null || ((Object)(4)) == null) ? false : ((COL7 <= 4) && (COL7 >= 4))); }},  new Supplier<java.lang.String>() { @Override public java.lang.String get() { return \\\"four\\\"; }}), SearchedCaseFunction.whenClause( new Supplier<Boolean>() { @Override public Boolean get() { return ((((Object)(COL7)) == null || ((Object)(5)) == null) ? false : ((COL7 <= 5) && (COL7 >= 5))); }},  new Supplier<java.lang.String>() { @Override public java.lang.String get() { return \\\"five\\\"; }}), SearchedCaseFunction.whenClause( new Supplier<Boolean>() { @Override public Boolean get() { return ((((Object)(COL7)) == null || ((Object)(6)) == null) ? false : ((COL7 <= 6) && (COL7 >= 6))); }},  new Supplier<java.lang.String>() { @Override public java.lang.String get() { return \\\"six\\\"; }}), SearchedCaseFunction.whenClause( new Supplier<Boolean>() { @Override public Boolean get() { return ((((Object)(COL7)) == null || ((Object)(7)) == null) ? false : ((COL7 <= 7) && (COL7 >= 7))); }},  new Supplier<java.lang.String>() { @Override public java.lang.String get() { return \\\"seven\\\"; }}), SearchedCaseFunction.whenClause( new Supplier<Boolean>() { @Override public Boolean get() { return ((((Object)(COL7)) == null || ((Object)(8)) == null) ? false : ((COL7 <= 8) && (COL7 >= 8))); }},  new Supplier<java.lang.String>() { @Override public java.lang.String get() { return \\\"eight\\\"; }}), SearchedCaseFunction.whenClause( new Supplier<Boolean>() { @Override public Boolean get() { return ((((Object)(COL7)) == null || ((Object)(9)) == null) ? false : ((COL7 <= 9) && (COL7 >= 9))); }},  new Supplier<java.lang.String>() { @Override public java.lang.String get() { return \\\"nine\\\"; }}), SearchedCaseFunction.whenClause( new Supplier<Boolean>() { @Override public Boolean get() { return ((((Object)(COL7)) == null || ((Object)(10)) == null) ? false : ((COL7 <= 10) && (COL7 >= 10))); }},  new Supplier<java.lang.String>() { @Override public java.lang.String get() { return \\\"ten\\\"; }}), SearchedCaseFunction.whenClause( new Supplier<Boolean>() { @Override public Boolean get() { return ((((Object)(COL7)) == null || ((Object)(11)) == null) ? false : ((COL7 <= 11) && (COL7 >= 11))); }},  new Supplier<java.lang.String>() { @Override public java.lang.String get() { return \\\"eleven\\\"; }}), SearchedCaseFunction.whenClause( new Supplier<Boolean>() { @Override public Boolean get() { return ((((Object)(COL7)) == null || ((Object)(12)) == null) ? false : ((COL7 <= 12) && (COL7 >= 12))); }},  new Supplier<java.lang.String>() { @Override public java.lang.String get() { return \\\"twelve\\\"; }}))), new Supplier<java.lang.String>() { @Override public java.lang.String get() { return null; }}))\"));", "originalCommit": "51b3dead6233fc7dbb82fce3af6e0040e06c8f99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc0MDYzNA==", "url": "https://github.com/confluentinc/ksql/pull/6535#discussion_r513740634", "bodyText": "The cooking part would pass with the earlier code as well", "author": "cprasad1", "createdAt": "2020-10-28T20:30:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzczOTAyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc0MjI2Mw==", "url": "https://github.com/confluentinc/ksql/pull/6535#discussion_r513742263", "bodyText": "The code choked during runtime with janino 3.0.7 and jdk 11. It compiled (cooked) just fine. idk how to test for the differing runtime environments.", "author": "cprasad1", "createdAt": "2020-10-28T20:33:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzczOTAyNg=="}], "type": "inlineReview"}]}