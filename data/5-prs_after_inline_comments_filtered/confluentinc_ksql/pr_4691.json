{"pr_number": 4691, "pr_title": "refactor: Introduce HTTP proxy", "pr_createdAt": "2020-03-03T13:02:27Z", "pr_url": "https://github.com/confluentinc/ksql/pull/4691", "timeline": [{"oid": "67f6b422aa5bca6fbcaa2e9faa074e4a86843d36", "url": "https://github.com/confluentinc/ksql/commit/67f6b422aa5bca6fbcaa2e9faa074e4a86843d36", "message": "Create http proxy", "committedDate": "2020-03-03T15:57:32Z", "type": "commit"}, {"oid": "96a7d08f3dc846a0afc95efd723f09ef2009a0e0", "url": "https://github.com/confluentinc/ksql/commit/96a7d08f3dc846a0afc95efd723f09ef2009a0e0", "message": "proxy", "committedDate": "2020-03-03T15:59:46Z", "type": "commit"}, {"oid": "8c638abcf8ef231899d4dc49dcec66dfa8b832bf", "url": "https://github.com/confluentinc/ksql/commit/8c638abcf8ef231899d4dc49dcec66dfa8b832bf", "message": "proxy", "committedDate": "2020-03-03T15:59:49Z", "type": "commit"}, {"oid": "2e504503561bd5891b33ed44db71eaaad03a3183", "url": "https://github.com/confluentinc/ksql/commit/2e504503561bd5891b33ed44db71eaaad03a3183", "message": "proxy", "committedDate": "2020-03-03T15:59:50Z", "type": "commit"}, {"oid": "ccdf5ca9cd8197b60a6e5e4659dbbb6b073971f8", "url": "https://github.com/confluentinc/ksql/commit/ccdf5ca9cd8197b60a6e5e4659dbbb6b073971f8", "message": "proxy", "committedDate": "2020-03-03T15:59:50Z", "type": "commit"}, {"oid": "6ee2b9553d6439e304f47713dd1556b7909c5d5b", "url": "https://github.com/confluentinc/ksql/commit/6ee2b9553d6439e304f47713dd1556b7909c5d5b", "message": "proxy", "committedDate": "2020-03-03T15:59:50Z", "type": "commit"}, {"oid": "6ec2306d242b2ec2bf22ff3b7e483d2089647bc9", "url": "https://github.com/confluentinc/ksql/commit/6ec2306d242b2ec2bf22ff3b7e483d2089647bc9", "message": "force jenkins build", "committedDate": "2020-03-03T15:59:50Z", "type": "commit"}, {"oid": "6ec2306d242b2ec2bf22ff3b7e483d2089647bc9", "url": "https://github.com/confluentinc/ksql/commit/6ec2306d242b2ec2bf22ff3b7e483d2089647bc9", "message": "force jenkins build", "committedDate": "2020-03-03T15:59:50Z", "type": "forcePushed"}, {"oid": "8648c13c9b61899b945b275b9c37286b1fd44578", "url": "https://github.com/confluentinc/ksql/commit/8648c13c9b61899b945b275b9c37286b1fd44578", "message": "proxy updates", "committedDate": "2020-03-03T16:47:11Z", "type": "commit"}, {"oid": "e30a8fcc97d7ca7e01192bb9128bfb7019e9a523", "url": "https://github.com/confluentinc/ksql/commit/e30a8fcc97d7ca7e01192bb9128bfb7019e9a523", "message": "proxy", "committedDate": "2020-03-04T07:03:25Z", "type": "commit"}, {"oid": "2182f6f35e6faee48be9a14b46520a59ba5d53b5", "url": "https://github.com/confluentinc/ksql/commit/2182f6f35e6faee48be9a14b46520a59ba5d53b5", "message": "proxy", "committedDate": "2020-03-04T08:06:34Z", "type": "commit"}, {"oid": "e93bb2f5edab0c94c24b0e691c538d74e4161a27", "url": "https://github.com/confluentinc/ksql/commit/e93bb2f5edab0c94c24b0e691c538d74e4161a27", "message": "Added new test for CLI client auth", "committedDate": "2020-03-04T09:58:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODE0MzUwMQ==", "url": "https://github.com/confluentinc/ksql/pull/4691#discussion_r388143501", "bodyText": "This property is unused now and may be removed, right?", "author": "vcrfxia", "createdAt": "2020-03-05T08:36:08Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/api/server/ApiServerConfig.java", "diffHunk": "@@ -38,18 +38,13 @@\n   public static final int DEFAULT_VERTICLE_INSTANCES =\n       2 * Runtime.getRuntime().availableProcessors();\n   public static final String VERTICLE_INSTANCES_DOC =\n-      \"The number of server verticle instances to start. Usually you want at least many instances\"\n-          + \" as there are cores you want to use, as each instance is single threaded.\";\n+      \"The number of server verticle instances to start per listener. Usually you want at least \"\n+          + \"many instances as there are cores you want to use, as each instance is single \"\n+          + \"threaded.\";\n \n-  public static final String LISTEN_HOST = propertyName(\"listen.host\");\n-  public static final String DEFAULT_LISTEN_HOST = \"localhost\";\n-  public static final String LISTEN_HOST_DOC =\n-      \"The hostname to listen on\";\n-\n-  public static final String LISTEN_PORT = propertyName(\"listen.port\");\n-  public static final int DEFAULT_LISTEN_PORT = 8088;\n-  public static final String LISTEN_PORT_DOC =\n-      \"The port to listen on\";\n+  public static final String LISTENERS = propertyName(\"listeners\");\n+  public static final String DEFAULT_LISTENERS = \"http://0.0.0.0:8088\";\n+  public static final String LISTENERS_DOC = \"List of listeners to listen for connections on\";\n \n   public static final String TLS_ENABLED = propertyName(\"tls.enabled\");", "originalCommit": "e93bb2f5edab0c94c24b0e691c538d74e4161a27", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIwNzA0NQ==", "url": "https://github.com/confluentinc/ksql/pull/4691#discussion_r388207045", "bodyText": "ack", "author": "purplefox", "createdAt": "2020-03-05T10:33:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODE0MzUwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODE0NDAwNg==", "url": "https://github.com/confluentinc/ksql/pull/4691#discussion_r388144006", "bodyText": "How come we only log on 500 errors?", "author": "vcrfxia", "createdAt": "2020-03-05T08:37:15Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/api/server/ServerVerticle.java", "diffHunk": "@@ -86,6 +109,107 @@ private Router setupRouter() {\n         .handler(new InsertsStreamHandler(context, endpoints, server.getWorkerExecutor()));\n     router.route(HttpMethod.POST, \"/close-query\").handler(BodyHandler.create())\n         .handler(new CloseQueryHandler(server));\n+    router.route(HttpMethod.GET, \"/ws/*\").handler(this::websocketHandler);\n+\n+    if (proxyEnabled) {\n+      // Everything else is proxied\n+      // The proxying is temporary and will go away once all the Jetty endpoints have been\n+      // migrated to Vert.x\n+      router.route().handler(new ProxyHandler(proxyTarget, proxyClient, server));\n+    }\n+    router.route().failureHandler(this::handleFailure);\n     return router;\n   }\n+\n+  private void handleFailure(final RoutingContext routingContext) {\n+    if (routingContext.statusCode() == 500) {", "originalCommit": "e93bb2f5edab0c94c24b0e691c538d74e4161a27", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIxMDQwOA==", "url": "https://github.com/confluentinc/ksql/pull/4691#discussion_r388210408", "bodyText": "ack, this can be improved", "author": "purplefox", "createdAt": "2020-03-05T10:39:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODE0NDAwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODE0NTc2OA==", "url": "https://github.com/confluentinc/ksql/pull/4691#discussion_r388145768", "bodyText": "How come the HTTPS listener was removed from here?", "author": "vcrfxia", "createdAt": "2020-03-05T08:40:46Z", "path": "ksql-rest-app/src/test/java/io/confluent/ksql/rest/server/TestKsqlRestApp.java", "diffHunk": "@@ -403,7 +408,8 @@ private static KsqlRestConfig buildConfig(\n     final HashMap<String, Object> config = new HashMap<>(baseConfig);\n \n     config.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers.get());\n-    config.putIfAbsent(KsqlRestConfig.LISTENERS_CONFIG, \"http://localhost:0,https://localhost:0\");", "originalCommit": "e93bb2f5edab0c94c24b0e691c538d74e4161a27", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIxMTI4MQ==", "url": "https://github.com/confluentinc/ksql/pull/4691#discussion_r388211281", "bodyText": "It doesn't appear to be used (the SSL tests override this config), and also the new server doesn't support having an https listener if you haven't configured a key store. The old server did seem to support this, which seems a bit weird (how can you server https without having a server certificate?)", "author": "purplefox", "createdAt": "2020-03-05T10:40:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODE0NTc2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODE0NjU4Nw==", "url": "https://github.com/confluentinc/ksql/pull/4691#discussion_r388146587", "bodyText": "Out of curiosity, how come we chose \"request\" instead of \"requested\"? Seems to break parallelism with \"required\" which was preserved.", "author": "vcrfxia", "createdAt": "2020-03-05T08:42:27Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/api/server/ApiServerConfig.java", "diffHunk": "@@ -168,6 +156,9 @@ public ApiServerConfig(final Map<?, ?> map) {\n     super(CONFIG_DEF, map);\n   }\n \n+  // Note that this expects config value that is not standard Confluent as defined in BaseConfig.\n+  // For \"request\" client auth, confluent value is \"REQUESTED\" where value expected here is", "originalCommit": "e93bb2f5edab0c94c24b0e691c538d74e4161a27", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIxMjcxMA==", "url": "https://github.com/confluentinc/ksql/pull/4691#discussion_r388212710", "bodyText": "This is because of the Vert.x ClientAuth enum:\nhttps://github.com/eclipse-vertx/vert.x/blob/master/src/main/java/io/vertx/core/http/ClientAuth.java\nwhich uses \"REQUIRE\" and we map directly from strings to the enum.\nWe should probably make this consistent with the standard Confluent config (i.e. do a manual mapping from string to Vert.x enum)", "author": "purplefox", "createdAt": "2020-03-05T10:43:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODE0NjU4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODE0Njc0Nw==", "url": "https://github.com/confluentinc/ksql/pull/4691#discussion_r388146747", "bodyText": "Out of curiosity, how come this was removed?", "author": "vcrfxia", "createdAt": "2020-03-05T08:42:47Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/services/DefaultKsqlClient.java", "diffHunk": "@@ -125,14 +125,19 @@ public void makeAsyncLagReportRequest(\n     getTarget(target, authHeader).postAsyncLagReportingRequest(lagReportingMessage);\n   }\n \n+  @Override\n+  public void close() {\n+    sharedClient.close();\n+  }\n+\n   private KsqlTarget getTarget(final KsqlTarget target, final Optional<String> authHeader) {\n     return authHeader\n         .map(target::authorizationHeader)\n         .orElse(target);\n   }\n \n   private static HttpClientOptions createClientOptions() {\n-    return new HttpClientOptions().setMaxPoolSize(100);", "originalCommit": "e93bb2f5edab0c94c24b0e691c538d74e4161a27", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIxNTk1OA==", "url": "https://github.com/confluentinc/ksql/pull/4691#discussion_r388215958", "bodyText": "My reasoning was, if the client is being created for each request, then no point in having a large pool size.", "author": "purplefox", "createdAt": "2020-03-05T10:49:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODE0Njc0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODE0NzExMw==", "url": "https://github.com/confluentinc/ksql/pull/4691#discussion_r388147113", "bodyText": "The client suppliers are memoized: \n  \n    \n      ksql/ksql-engine/src/main/java/io/confluent/ksql/services/DefaultServiceContext.java\n    \n    \n         Line 96\n      in\n      9bc2220\n    \n    \n    \n    \n\n        \n          \n           this.ksqlClientSupplier = new MemoizedSupplier<>(ksqlClientSupplier); \n        \n    \n  \n\n\nDoes that address the concern?", "author": "vcrfxia", "createdAt": "2020-03-05T08:43:31Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/services/RestServiceContextFactory.java", "diffHunk": "@@ -74,6 +74,7 @@ public static ServiceContext create(\n         srClientFactory,\n         () -> new DefaultConnectClient(ksqlConfig.getString(KsqlConfig.CONNECT_URL_PROPERTY),\n                                        authHeader),\n+        // We should be re-using this not creating one each time!", "originalCommit": "e93bb2f5edab0c94c24b0e691c538d74e4161a27", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIxNzQ0OA==", "url": "https://github.com/confluentinc/ksql/pull/4691#discussion_r388217448", "bodyText": "Ah I see, so we are reusing :) In which case I can retain the larger pool size.", "author": "purplefox", "createdAt": "2020-03-05T10:52:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODE0NzExMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODE0NzMyOQ==", "url": "https://github.com/confluentinc/ksql/pull/4691#discussion_r388147329", "bodyText": "What's the purpose of setMaxInitialLineLength() here?", "author": "vcrfxia", "createdAt": "2020-03-05T08:43:55Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/api/server/ServerVerticle.java", "diffHunk": "@@ -38,24 +49,31 @@\n   private final Endpoints endpoints;\n   private final HttpServerOptions httpServerOptions;\n   private final Server server;\n+  private final boolean proxyEnabled;\n   private ConnectionQueryManager connectionQueryManager;\n-  private HttpServer httpServer;\n+  private volatile HttpServer httpServer;\n+\n+  private HttpClient proxyClient;\n+  private SocketAddress proxyTarget;\n \n   public ServerVerticle(final Endpoints endpoints, final HttpServerOptions httpServerOptions,\n-      final Server server) {\n+      final Server server, final boolean proxyEnabled) {\n     this.endpoints = Objects.requireNonNull(endpoints);\n     this.httpServerOptions = Objects.requireNonNull(httpServerOptions);\n     this.server = Objects.requireNonNull(server);\n+    this.proxyEnabled = proxyEnabled;\n   }\n \n   @Override\n   public void start(final Promise<Void> startPromise) {\n+    this.proxyClient = proxyEnabled ? vertx\n+        .createHttpClient(\n+            new HttpClientOptions().setMaxPoolSize(10).setMaxInitialLineLength(65536)) : null;", "originalCommit": "e93bb2f5edab0c94c24b0e691c538d74e4161a27", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIxODYwMA==", "url": "https://github.com/confluentinc/ksql/pull/4691#discussion_r388218600", "bodyText": "It shouldn't be needed. Will remove.", "author": "purplefox", "createdAt": "2020-03-05T10:54:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODE0NzMyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODE0NzU1Mg==", "url": "https://github.com/confluentinc/ksql/pull/4691#discussion_r388147552", "bodyText": "Out of curiosity, what goes wrong if the \"host\" header is not removed from the proxy request?", "author": "vcrfxia", "createdAt": "2020-03-05T08:44:29Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/api/server/ProxyHandler.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.api.server;\n+\n+import io.vertx.core.Handler;\n+import io.vertx.core.MultiMap;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.core.http.HttpClient;\n+import io.vertx.core.http.HttpClientRequest;\n+import io.vertx.core.http.HttpClientResponse;\n+import io.vertx.core.http.HttpServerRequest;\n+import io.vertx.core.http.HttpServerResponse;\n+import io.vertx.core.net.SocketAddress;\n+import io.vertx.core.streams.ReadStream;\n+import io.vertx.core.streams.WriteStream;\n+import io.vertx.ext.web.RoutingContext;\n+import java.util.Map;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class ProxyHandler implements Handler<RoutingContext> {\n+\n+  private static final Logger log = LoggerFactory.getLogger(ProxyHandler.class);\n+\n+  private final HttpClient proxyClient;\n+  private final Server server;\n+  private SocketAddress proxyTarget;\n+\n+  public ProxyHandler(final SocketAddress proxyTarget, final HttpClient proxyClient,\n+      final Server server) {\n+    this.proxyTarget = proxyTarget;\n+    this.proxyClient = proxyClient;\n+    this.server = server;\n+  }\n+\n+  @Override\n+  public void handle(final RoutingContext routingContext) {\n+    if (proxyTarget == null) {\n+      proxyTarget = server.getProxyTarget();\n+    }\n+    final HttpServerRequest serverRequest = routingContext.request();\n+    final HttpClientRequest clientRequest = proxyClient.request(serverRequest.method(),\n+        proxyTarget, proxyTarget.port(), proxyTarget.host(),\n+        serverRequest.path(),\n+        resp -> responseHandler(resp, serverRequest))\n+        .exceptionHandler(ProxyHandler::exceptionHandler);\n+\n+    final MultiMap headers = MultiMap.caseInsensitiveMultiMap();\n+    for (Map.Entry<String, String> header : serverRequest.headers()) {\n+      if (!header.getKey().equalsIgnoreCase(\"host\")) {", "originalCommit": "e93bb2f5edab0c94c24b0e691c538d74e4161a27", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIyMDA2Ng==", "url": "https://github.com/confluentinc/ksql/pull/4691#discussion_r388220066", "bodyText": "It's probably not necessary, will try and remove", "author": "purplefox", "createdAt": "2020-03-05T10:57:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODE0NzU1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODE0ODEyOA==", "url": "https://github.com/confluentinc/ksql/pull/4691#discussion_r388148128", "bodyText": "nit: should we add a log message here?", "author": "vcrfxia", "createdAt": "2020-03-05T08:45:41Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/api/server/ServerVerticle.java", "diffHunk": "@@ -86,6 +109,107 @@ private Router setupRouter() {\n         .handler(new InsertsStreamHandler(context, endpoints, server.getWorkerExecutor()));\n     router.route(HttpMethod.POST, \"/close-query\").handler(BodyHandler.create())\n         .handler(new CloseQueryHandler(server));\n+    router.route(HttpMethod.GET, \"/ws/*\").handler(this::websocketHandler);\n+\n+    if (proxyEnabled) {\n+      // Everything else is proxied\n+      // The proxying is temporary and will go away once all the Jetty endpoints have been\n+      // migrated to Vert.x\n+      router.route().handler(new ProxyHandler(proxyTarget, proxyClient, server));\n+    }\n+    router.route().failureHandler(this::handleFailure);\n     return router;\n   }\n+\n+  private void handleFailure(final RoutingContext routingContext) {\n+    if (routingContext.statusCode() == 500) {\n+      log.error(\"Unexpected exception in router\", routingContext.failure());\n+    }\n+    routingContext.response().setStatusCode(routingContext.statusCode()).end();\n+  }\n+\n+  private void websocketHandler(final RoutingContext routingContext) {\n+    if (proxyTarget == null) {\n+      proxyTarget = server.getProxyTarget();\n+    }\n+    final HttpServerRequest request = routingContext.request();\n+    final WebSocketConnectOptions options = new WebSocketConnectOptions()\n+        .setHost(proxyTarget.host())\n+        .setPort(proxyTarget.port())\n+        .setHeaders(request.headers())\n+        .setURI(request.uri());\n+    request.pause();\n+    proxyClient.webSocket(options, ar -> {\n+      request.resume();\n+      if (ar.succeeded()) {\n+        final WebSocket webSocket = ar.result();\n+        final ServerWebSocket serverWebSocket = request.upgrade();\n+        WebsocketPipe.pipe(serverWebSocket, webSocket);\n+        WebsocketPipe.pipe(webSocket, serverWebSocket);\n+      } else {\n+        if (ar.cause() instanceof UpgradeRejectedException) {\n+          final UpgradeRejectedException uge = (UpgradeRejectedException) ar.cause();", "originalCommit": "e93bb2f5edab0c94c24b0e691c538d74e4161a27", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIyMDc2Ng==", "url": "https://github.com/confluentinc/ksql/pull/4691#discussion_r388220766", "bodyText": "This will occur for things like authorization failure, in which case presumably the old Jetty server already logs this.", "author": "purplefox", "createdAt": "2020-03-05T10:58:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODE0ODEyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODE0OTY0OQ==", "url": "https://github.com/confluentinc/ksql/pull/4691#discussion_r388149649", "bodyText": "Is it important that this call is made before the REST server is started? (Wondering if there's a reason this call was moved to the top.)", "author": "vcrfxia", "createdAt": "2020-03-05T08:48:50Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/KsqlRestApplication.java", "diffHunk": "@@ -261,7 +300,8 @@ public void setupResources(final Configurable<?> config, final KsqlRestConfig ap\n \n   @Override\n   public void startAsync() {\n-    log.info(\"KSQL RESTful API listening on {}\", StringUtils.join(getListeners(), \", \"));\n+    startApiServer(ksqlConfigNoPort);", "originalCommit": "e93bb2f5edab0c94c24b0e691c538d74e4161a27", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIyMTg4OA==", "url": "https://github.com/confluentinc/ksql/pull/4691#discussion_r388221888", "bodyText": "Yep, the apiServer now serves al traffic and has the real listeners, so don't know the listeners until it's started.", "author": "purplefox", "createdAt": "2020-03-05T11:00:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODE0OTY0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODE1MDc5Nw==", "url": "https://github.com/confluentinc/ksql/pull/4691#discussion_r388150797", "bodyText": "Having trouble understanding what this property means... how come it needs to be increased here?", "author": "vcrfxia", "createdAt": "2020-03-05T08:51:08Z", "path": "ksql-rest-app/src/test/java/io/confluent/ksql/rest/server/TestKsqlRestApp.java", "diffHunk": "@@ -108,6 +111,10 @@\n   private KsqlExecutionContext ksqlEngine;\n   private KsqlRestApplication ksqlRestApplication;\n \n+  static {\n+    // Increase the default - it's low (100)\n+    System.setProperty(\"sun.net.maxDatagramSockets\", \"1024\");", "originalCommit": "e93bb2f5edab0c94c24b0e691c538d74e4161a27", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIyMzA0NA==", "url": "https://github.com/confluentinc/ksql/pull/4691#discussion_r388223044", "bodyText": "When doing DNS lookups, Netty uses it's own resolver that uses UDP, and it caches resolvers per event loop. When we start the api server we create 2 * number of cores * number of listeners event loops. Also in some tests we start multiple api servers. This means the number of udp sockets required can be > the OS default, which is 100, which will cause tests to fail.", "author": "purplefox", "createdAt": "2020-03-05T11:02:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODE1MDc5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ2OTQzNg==", "url": "https://github.com/confluentinc/ksql/pull/4691#discussion_r388469436", "bodyText": "Thanks for the context! Very helpful.", "author": "vcrfxia", "createdAt": "2020-03-05T18:08:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODE1MDc5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODE1MTE4NQ==", "url": "https://github.com/confluentinc/ksql/pull/4691#discussion_r388151185", "bodyText": "nit: de-dup these helper methods between this file and SslFunctionalTest.java?", "author": "vcrfxia", "createdAt": "2020-03-05T08:51:55Z", "path": "ksql-cli/src/test/java/io/confluent/ksql/cli/SslClientAuthFunctionalTest.java", "diffHunk": "@@ -0,0 +1,289 @@\n+/*\n+ * Copyright 2019 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.cli;\n+\n+import static io.confluent.ksql.serde.FormatFactory.JSON;\n+import static java.util.Collections.emptyMap;\n+import static org.hamcrest.CoreMatchers.instanceOf;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.internal.matchers.ThrowableCauseMatcher.hasCause;\n+\n+import com.google.common.net.UrlEscapers;\n+import io.confluent.common.utils.IntegrationTest;\n+import io.confluent.ksql.integration.IntegrationTestHarness;\n+import io.confluent.ksql.integration.Retry;\n+import io.confluent.ksql.rest.client.KsqlClient;\n+import io.confluent.ksql.rest.client.KsqlRestClient;\n+import io.confluent.ksql.rest.client.KsqlRestClientException;\n+import io.confluent.ksql.rest.client.RestResponse;\n+import io.confluent.ksql.rest.server.TestKsqlRestApp;\n+import io.confluent.ksql.test.util.secure.ClientTrustStore;\n+import io.confluent.ksql.test.util.secure.ServerKeyStore;\n+import io.confluent.ksql.util.OrderDataProvider;\n+import io.confluent.rest.RestConfig;\n+import java.net.URI;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import javax.net.ssl.SSLHandshakeException;\n+import kafka.zookeeper.ZooKeeperClientException;\n+import org.apache.kafka.common.config.SslConfigs;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.eclipse.jetty.http.HttpStatus.Code;\n+import org.eclipse.jetty.util.ssl.SslContextFactory;\n+import org.eclipse.jetty.util.ssl.SslContextFactory.Server;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketConnect;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketError;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketMessage;\n+import org.eclipse.jetty.websocket.api.annotations.WebSocket;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.rules.ExpectedException;\n+import org.junit.rules.RuleChain;\n+\n+@Category({IntegrationTest.class})\n+public class SslClientAuthFunctionalTest {\n+\n+  private static final String TOPIC_NAME = new OrderDataProvider().topicName();\n+\n+  private static final String JSON_KSQL_REQUEST = UrlEscapers.urlFormParameterEscaper()\n+      .escape(\"{\"\n+          + \" \\\"ksql\\\": \\\"PRINT \" + TOPIC_NAME + \" FROM BEGINNING;\\\"\"\n+          + \"}\");\n+\n+  public static final IntegrationTestHarness TEST_HARNESS = IntegrationTestHarness.build();\n+\n+  @SuppressWarnings(\"deprecation\")\n+  private static final TestKsqlRestApp REST_APP = TestKsqlRestApp\n+      .builder(TEST_HARNESS::kafkaBootstrapServers)\n+      .withProperties(ServerKeyStore.keyStoreProps())\n+      .withProperty(SslConfigs.SSL_CLIENT_AUTH_CONFIG, true)\n+      .withProperty(RestConfig.LISTENERS_CONFIG, \"https://localhost:0\")\n+      .build();\n+\n+  @ClassRule\n+  public static final RuleChain CHAIN = RuleChain\n+      .outerRule(Retry.of(3, ZooKeeperClientException.class, 3, TimeUnit.SECONDS))\n+      .around(TEST_HARNESS)\n+      .around(REST_APP);\n+\n+  @Rule\n+  public final ExpectedException expectedException = ExpectedException.none();\n+\n+  private Map<String, String> clientProps;\n+  private SslContextFactory sslContextFactory;\n+\n+  @BeforeClass\n+  public static void classSetUp() {\n+    final OrderDataProvider dataProvider = new OrderDataProvider();\n+    TEST_HARNESS.getKafkaCluster().createTopics(TOPIC_NAME);\n+    TEST_HARNESS.produceRows(dataProvider.topicName(), dataProvider, JSON);\n+  }\n+\n+  @Before\n+  public void setUp() {\n+    clientProps = new HashMap<>();\n+    clientProps.put(KsqlClient.DISABLE_HOSTNAME_VERIFICATION_PROP_NAME, \"true\");\n+    sslContextFactory = new Server();\n+  }\n+\n+  @Test\n+  public void shouldNotBeAbleToUseCliIfClientDoesNotProvideCertificate() {\n+\n+    // Given:\n+    givenClientConfiguredWithoutCertificate();\n+\n+    // Then:\n+    expectedException.expect(KsqlRestClientException.class);\n+    expectedException.expectCause(is(instanceOf(ExecutionException.class)));\n+    expectedException.expectCause(hasCause(is(instanceOf(SSLHandshakeException.class))));\n+\n+    // When:\n+    canMakeCliRequest();\n+  }\n+\n+  @Test\n+  public void shouldBeAbleToUseCliOverHttps() {\n+    // Given:\n+    givenClientConfiguredWithCertificate();\n+\n+    // When:\n+    final Code result = canMakeCliRequest();\n+\n+    // Then:\n+    assertThat(result, is(Code.OK));\n+  }\n+\n+  @Test\n+  public void shouldNotBeAbleToUseWssIfClientDoesNotTrustServerCert() throws Exception {\n+    // Given:\n+    givenClientConfiguredWithoutCertificate();\n+\n+    // Then:\n+    expectedException.expect(SSLHandshakeException.class);\n+    expectedException.expectMessage(\"Received fatal alert: handshake_failure\");\n+\n+    // When:\n+    makeWsRequest();\n+  }\n+\n+  @Test\n+  public void shouldBeAbleToUseWss() throws Exception {\n+    // Given:\n+    givenClientConfiguredWithCertificate();\n+\n+    // When:\n+    makeWsRequest();\n+\n+    // Then: did not throw.\n+  }\n+\n+  private void givenClientConfiguredWithCertificate() {\n+\n+    String clientCertPath = ServerKeyStore.keyStoreProps()\n+        .get(SslConfigs.SSL_TRUSTSTORE_LOCATION_CONFIG);\n+    String clientCertPassword = ServerKeyStore.keyStoreProps()\n+        .get(SslConfigs.SSL_TRUSTSTORE_PASSWORD_CONFIG);\n+\n+    // HTTP:\n+    clientProps = new HashMap<>();\n+    clientProps.putAll(ClientTrustStore.trustStoreProps());\n+\n+    clientProps.put(SslConfigs.SSL_KEYSTORE_LOCATION_CONFIG, clientCertPath);\n+    clientProps.put(SslConfigs.SSL_KEYSTORE_PASSWORD_CONFIG, clientCertPassword);\n+\n+    clientProps.put(KsqlClient.DISABLE_HOSTNAME_VERIFICATION_PROP_NAME, \"true\");\n+    clientProps.put(KsqlClient.TLS_ENABLED_PROP_NAME, \"true\");\n+\n+    // WS:\n+    sslContextFactory.setTrustStorePath(ClientTrustStore.trustStorePath());\n+    sslContextFactory.setTrustStorePassword(ClientTrustStore.trustStorePassword());\n+    sslContextFactory.setKeyStorePath(clientCertPath);\n+    sslContextFactory.setKeyStorePassword(clientCertPassword);\n+    sslContextFactory.setEndpointIdentificationAlgorithm(\"\");\n+  }\n+\n+  private void givenClientConfiguredWithoutCertificate() {\n+\n+    // HTTP:\n+    clientProps = new HashMap<>();\n+    clientProps.putAll(ClientTrustStore.trustStoreProps());\n+\n+    clientProps.put(KsqlClient.DISABLE_HOSTNAME_VERIFICATION_PROP_NAME, \"true\");\n+    clientProps.put(KsqlClient.TLS_ENABLED_PROP_NAME, \"true\");\n+\n+    // WS:\n+    sslContextFactory.setTrustStorePath(ClientTrustStore.trustStorePath());\n+    sslContextFactory.setTrustStorePassword(ClientTrustStore.trustStorePassword());\n+    sslContextFactory.setEndpointIdentificationAlgorithm(\"\");\n+  }\n+\n+  private Code canMakeCliRequest() {", "originalCommit": "e93bb2f5edab0c94c24b0e691c538d74e4161a27", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIyMzg0Mg==", "url": "https://github.com/confluentinc/ksql/pull/4691#discussion_r388223842", "bodyText": "I tried to do this originally. But unfortunately SslFunctionalTest uses static test fixtures so I can't push things up into a common base class as I would like to :(", "author": "purplefox", "createdAt": "2020-03-05T11:04:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODE1MTE4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ2ODk2NQ==", "url": "https://github.com/confluentinc/ksql/pull/4691#discussion_r388468965", "bodyText": "Not sure I follow. Can we not de-dup the methods by making them static, e.g.,\nprivate Code canMakeCliRequest() { ... }\n\nbecomes\nstatic Code canMakeCliRequest(final TestKsqlRestApp restApp, final Map<String, String> clientProps) { ... }\n\n(and similarly for the others)?", "author": "vcrfxia", "createdAt": "2020-03-05T18:07:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODE1MTE4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ3NjIwNw==", "url": "https://github.com/confluentinc/ksql/pull/4691#discussion_r388476207", "bodyText": "Then to keep the individual tests cleaner each can have:\nprivate Code canMakeCliRequest() {\n    return canMakeCliRequest(REST_APP, clientProps);\n}\n\n(and similar).\nThese methods would still have to be duplicated between the two tests but they seem tiny enough and the actual implementation of the helper methods would only appear in one place. WDYT?", "author": "vcrfxia", "createdAt": "2020-03-05T18:21:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODE1MTE4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODE1MTY3Mg==", "url": "https://github.com/confluentinc/ksql/pull/4691#discussion_r388151672", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Send a request to remote Ksql server to inquire to inquire about which state stores the remote\n          \n          \n            \n               * Send a request to remote Ksql server to inquire about which state stores the remote\n          \n      \n    \n    \n  \n\nsuper nit (not your code): typo.", "author": "vcrfxia", "createdAt": "2020-03-05T08:52:52Z", "path": "ksql-execution/src/main/java/io/confluent/ksql/services/SimpleKsqlClient.java", "diffHunk": "@@ -69,13 +69,19 @@ void makeAsyncHeartbeatRequest(\n   RestResponse<ClusterStatusResponse> makeClusterStatusRequest(URI serverEndPoint);\n \n   /**\n-   * Send a request to remote Ksql server to inquire to inquire about which state stores the\n-   * remote server maintains as an active and standby.\n-   * @param serverEndPoint the remote destination.\n+   * Send a request to remote Ksql server to inquire to inquire about which state stores the remote", "originalCommit": "e93bb2f5edab0c94c24b0e691c538d74e4161a27", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIyNDUyMA==", "url": "https://github.com/confluentinc/ksql/pull/4691#discussion_r388224520", "bodyText": "ack... also shouldn't it be \"enquire\" ? (Or maybe that's a US vs UK thing, but inquire seems wrong to me)", "author": "purplefox", "createdAt": "2020-03-05T11:05:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODE1MTY3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ2OTI4MQ==", "url": "https://github.com/confluentinc/ksql/pull/4691#discussion_r388469281", "bodyText": "Yup, US vs. UK (though this blog suggests both versions are used in the UK) -- haha!", "author": "vcrfxia", "createdAt": "2020-03-05T18:07:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODE1MTY3Mg=="}], "type": "inlineReview"}, {"oid": "9e1d466a4dc70d74bb1fff47ba34d1628bd8d030", "url": "https://github.com/confluentinc/ksql/commit/9e1d466a4dc70d74bb1fff47ba34d1628bd8d030", "message": "review updates", "committedDate": "2020-03-05T11:10:26Z", "type": "commit"}, {"oid": "42253d54ad9dbc340a05fba5b00efa1f1ea38f76", "url": "https://github.com/confluentinc/ksql/commit/42253d54ad9dbc340a05fba5b00efa1f1ea38f76", "message": "fixed test", "committedDate": "2020-03-05T11:52:50Z", "type": "commit"}, {"oid": "a231fd2b036d68bdd9c7678f25be207c7d11a649", "url": "https://github.com/confluentinc/ksql/commit/a231fd2b036d68bdd9c7678f25be207c7d11a649", "message": "review updates", "committedDate": "2020-03-05T12:03:06Z", "type": "commit"}]}