{"pr_number": 5002, "pr_title": "feat: speed up restarts by not building topologies for terminated queries", "pr_createdAt": "2020-04-06T11:46:21Z", "pr_url": "https://github.com/confluentinc/ksql/pull/5002", "timeline": [{"oid": "6730a11c78b93d168a7b00990901ccb9e8007f72", "url": "https://github.com/confluentinc/ksql/commit/6730a11c78b93d168a7b00990901ccb9e8007f72", "message": "feat: speed up restarts by not building topologies for terminated queries\n\nfixes: https://github.com/confluentinc/ksql/issues/4923\n\nPreviously, on a restart, each ksqlDB node would build a query topology for each previously submitted persistent queries, i.e. CREATE TABLE AS SELECT, CREATE STREAM AS SELECT or INSERT INTO statement, _even if the associated query has already been terminated_.\n\nBuilding the query topology takes a reasonable amount of time. By avoiding building these topologies for terminated queries the restart time will be much reduced for clusters with a lot of historic commands in the command topic.\n\nA more complete solution to this problem is to move to a compacted topic for storing commands: https://github.com/confluentinc/ksql/pull/4659", "committedDate": "2020-04-06T11:38:47Z", "type": "commit"}, {"oid": "632b2ab7a7cd42b4485db9f07a1763cde466d133", "url": "https://github.com/confluentinc/ksql/commit/632b2ab7a7cd42b4485db9f07a1763cde466d133", "message": "chore: handle INSERT INTO queries", "committedDate": "2020-04-06T12:28:13Z", "type": "commit"}, {"oid": "f116df722d83e6a14d6a77159ca7a2de9d0d2fce", "url": "https://github.com/confluentinc/ksql/commit/f116df722d83e6a14d6a77159ca7a2de9d0d2fce", "message": "chore: fix test", "committedDate": "2020-04-06T13:41:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDIzMjc3OQ==", "url": "https://github.com/confluentinc/ksql/pull/5002#discussion_r404232779", "bodyText": "this feels needlessly complicated (in place modification using the iterator is really hard for me to follow as I need to track which source collection is being modified and used where). Can we simplify it by having a first pass just collect the index of terminated queries and the terminate commands in restoreCommands and then have a second pass that just copies the ones we need (modifying the ones that need to be modified) into a new list?\nThat would also obviate the need for using IdentityHashMap as we're using the index in the list to uniquely identify a command.", "author": "agavra", "createdAt": "2020-04-06T16:38:54Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/computation/RestoreCommandsCompactor.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.server.computation;\n+\n+import io.confluent.ksql.engine.KsqlPlan;\n+import io.confluent.ksql.query.QueryId;\n+import io.confluent.ksql.rest.entity.CommandId.Type;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.IdentityHashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * Util for compacting the restore commands\n+ */\n+public final class RestoreCommandsCompactor {\n+\n+  private RestoreCommandsCompactor() {\n+  }\n+\n+  /**\n+   * Compact the list of commands to restore.\n+   *\n+   * <p>Finds any command's whose queries plans that are later terminated. Any such commands have\n+   * their query plan and associated terminate command removed.\n+   *\n+   * <p>This compaction stops unnecessary creation of Streams topologies on a server restart.\n+   * Building such topologies is relatively slow and best avoided.\n+   *\n+   * @param restoreCommands the list of commands to compact.\n+   * @return the compacted list of commands.\n+   */\n+  static List<QueuedCommand> compact(final List<QueuedCommand> restoreCommands) {", "originalCommit": "f116df722d83e6a14d6a77159ca7a2de9d0d2fce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY5OTQ1Ng==", "url": "https://github.com/confluentinc/ksql/pull/5002#discussion_r404699456", "bodyText": "Meh, I don't really see this as being complicated and, given this is throw away work as we're moving to key compacted topic, do we really want to spend more time on it?  You're basically asking me to totally re-write the algo.", "author": "big-andy-coates", "createdAt": "2020-04-07T10:20:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDIzMjc3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM2NTI4NQ==", "url": "https://github.com/confluentinc/ksql/pull/5002#discussion_r404365285", "bodyText": "probably better to use a linked list here since we're removing random elements", "author": "rodesai", "createdAt": "2020-04-06T20:24:14Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/computation/RestoreCommandsCompactor.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.server.computation;\n+\n+import io.confluent.ksql.engine.KsqlPlan;\n+import io.confluent.ksql.query.QueryId;\n+import io.confluent.ksql.rest.entity.CommandId.Type;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.IdentityHashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * Util for compacting the restore commands\n+ */\n+public final class RestoreCommandsCompactor {\n+\n+  private RestoreCommandsCompactor() {\n+  }\n+\n+  /**\n+   * Compact the list of commands to restore.\n+   *\n+   * <p>Finds any command's whose queries plans that are later terminated. Any such commands have\n+   * their query plan and associated terminate command removed.\n+   *\n+   * <p>This compaction stops unnecessary creation of Streams topologies on a server restart.\n+   * Building such topologies is relatively slow and best avoided.\n+   *\n+   * @param restoreCommands the list of commands to compact.\n+   * @return the compacted list of commands.\n+   */\n+  static List<QueuedCommand> compact(final List<QueuedCommand> restoreCommands) {\n+    final List<QueuedCommand> compacted = new ArrayList<>(restoreCommands);", "originalCommit": "f116df722d83e6a14d6a77159ca7a2de9d0d2fce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDcwMDAzMA==", "url": "https://github.com/confluentinc/ksql/pull/5002#discussion_r404700030", "bodyText": "done", "author": "big-andy-coates", "createdAt": "2020-04-07T10:21:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM2NTI4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM3MDQ4NA==", "url": "https://github.com/confluentinc/ksql/pull/5002#discussion_r404370484", "bodyText": "This loop could be simplified. We now run a protocol to ensure that no invalid commands get enqueued, so you can assume all terminates are valid.", "author": "rodesai", "createdAt": "2020-04-06T20:33:31Z", "path": "ksqldb-rest-app/src/main/java/io/confluent/ksql/rest/server/computation/RestoreCommandsCompactor.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.rest.server.computation;\n+\n+import io.confluent.ksql.engine.KsqlPlan;\n+import io.confluent.ksql.query.QueryId;\n+import io.confluent.ksql.rest.entity.CommandId.Type;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.IdentityHashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * Util for compacting the restore commands\n+ */\n+public final class RestoreCommandsCompactor {\n+\n+  private RestoreCommandsCompactor() {\n+  }\n+\n+  /**\n+   * Compact the list of commands to restore.\n+   *\n+   * <p>Finds any command's whose queries plans that are later terminated. Any such commands have\n+   * their query plan and associated terminate command removed.\n+   *\n+   * <p>This compaction stops unnecessary creation of Streams topologies on a server restart.\n+   * Building such topologies is relatively slow and best avoided.\n+   *\n+   * @param restoreCommands the list of commands to compact.\n+   * @return the compacted list of commands.\n+   */\n+  static List<QueuedCommand> compact(final List<QueuedCommand> restoreCommands) {\n+    final List<QueuedCommand> compacted = new ArrayList<>(restoreCommands);\n+\n+    final Set<QueuedCommand> terminatedQueries =\n+        findTerminatedQueriesAndRemoveTerminateCommands(compacted);\n+\n+    removeQueryPlansOfTerminated(compacted, terminatedQueries);\n+\n+    return compacted;\n+  }\n+\n+  private static Set<QueuedCommand> findTerminatedQueriesAndRemoveTerminateCommands(\n+      final List<QueuedCommand> commands\n+  ) {\n+    final Map<QueryId, QueuedCommand> queries = new HashMap<>();\n+    final Set<QueuedCommand> terminatedQueries = Collections.newSetFromMap(new IdentityHashMap<>());\n+\n+    final Iterator<QueuedCommand> it = commands.iterator();\n+    while (it.hasNext()) {", "originalCommit": "f116df722d83e6a14d6a77159ca7a2de9d0d2fce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDYzMTU2Ng==", "url": "https://github.com/confluentinc/ksql/pull/5002#discussion_r404631566", "bodyText": "Yeah, I know that all queued commands are now meant to be validated. However, I'd prefer to code this defensively. That way, if a bug is introduced in the code that means a duplicate or none-validated command is produced, this code won't just blow up.", "author": "big-andy-coates", "createdAt": "2020-04-07T08:31:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM3MDQ4NA=="}], "type": "inlineReview"}, {"oid": "8a56b9a4b61c4028548df4d9fd15eacfa73be379", "url": "https://github.com/confluentinc/ksql/commit/8a56b9a4b61c4028548df4d9fd15eacfa73be379", "message": "chore: rohan's requested changes", "committedDate": "2020-04-07T10:23:53Z", "type": "commit"}]}