{"pr_number": 6762, "pr_title": "chore: set internal key serde features when necessary", "pr_createdAt": "2020-12-11T16:37:31Z", "pr_url": "https://github.com/confluentinc/ksql/pull/6762", "timeline": [{"oid": "45ef76de689404b67819bdd6537cf68622cce9be", "url": "https://github.com/confluentinc/ksql/commit/45ef76de689404b67819bdd6537cf68622cce9be", "message": "chore: set internal key serde features when necessary", "committedDate": "2020-12-11T16:12:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTA4NTE2OA==", "url": "https://github.com/confluentinc/ksql/pull/6762#discussion_r541085168", "bodyText": "It's odd to me that we're wiping value features on internal topics while passing along key features. I need to think more about the implications here. We might need to write key serde features into all the execution steps if we want this to be evolvable in the future.", "author": "vcrfxia", "createdAt": "2020-12-11T16:51:15Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/serde/InternalFormats.java", "diffHunk": "@@ -50,16 +50,16 @@ private InternalFormats() {\n    * @see <a href=https://github.com/confluentinc/ksql/issues/6296>Issue 6296</a>\n    * @see SerdeFeaturesFactory#buildInternal\n    */\n-  public static Formats of(final FormatInfo keyFormat, final FormatInfo valueFormat) {\n+  public static Formats of(final KeyFormat keyFormat, final FormatInfo valueFormat) {\n     // Do not use NONE format for internal topics:\n-    if (keyFormat.getFormat().equals(NoneFormat.NAME)) {\n+    if (keyFormat.getFormatInfo().getFormat().equals(NoneFormat.NAME)) {\n       throw new IllegalArgumentException(NoneFormat.NAME + \" can not be used for internal topics\");\n     }\n \n     return Formats.of(\n-        keyFormat,\n+        keyFormat.getFormatInfo(),\n         valueFormat,\n-        SerdeFeaturesFactory.buildInternal(FormatFactory.fromName(keyFormat.getFormat())),\n+        keyFormat.getFeatures(),", "originalCommit": "099fb853b8b410a3623ddf39a70bedfdff29db4e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE4Mjc2NA==", "url": "https://github.com/confluentinc/ksql/pull/6762#discussion_r541182764", "bodyText": "Took a deeper look -- looks like we already write serde features into the execution steps that need them, so that shouldn't be a concern.\nThe only potential evolvability concern is that until now, our execution plans have always specified key wrapping in ambiguous situations (single key column with format that supports both wrapping and unwrapping). That changes with this PR, which means we'd be locking ourselves into the current default choices for each format -- namely, always wrap by default. Are we happy with this default, or should we consider defaulting key wrapping to unwrap even though value wrapping default wrapping? If most users unwrap single keys, we may prefer the former despite the inconsistency.", "author": "vcrfxia", "createdAt": "2020-12-11T19:14:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTA4NTE2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTMwMjczOA==", "url": "https://github.com/confluentinc/ksql/pull/6762#discussion_r541302738", "bodyText": "What changes with this PR, which means we'd be locking ourselves into the current default choices for each format -- namely, always wrap by default.\n\nWhy does it mean that? If we write the serde features into the execution steps then we can always change the logical plan to produce different execution steps while keeping all of the old ones compatible.\n\nIf most users unwrap single keys, we may prefer the former despite the inconsistency.\n\nUsers shouldn't see what happens underneath the hood, we still \"inherit\" the desired serde features to the sink independent of what happens in the internal topics. You can see the example I've given in the \"testing done\" where the table is wrapped and the stream is unwrapped. The \"final\" chooses the left topic's information, which is to UNWRAP_SINGLES", "author": "agavra", "createdAt": "2020-12-11T21:19:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTA4NTE2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTMzMTA1NQ==", "url": "https://github.com/confluentinc/ksql/pull/6762#discussion_r541331055", "bodyText": "It's odd to me that we're wiping value features on internal topics while passing along key features.\n\nI agree, it felt a little sticky to me as well. I think it's possible to pass along the value format as well, but it's not as interesting (it would be mostly for hygiene) because we can always serialize it into the desired format at the edges (our semantics don't depend on the value format).\nIf we do this, we can do it as a follow-up.", "author": "agavra", "createdAt": "2020-12-11T21:50:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTA4NTE2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTA4NjU5OA==", "url": "https://github.com/confluentinc/ksql/pull/6762#discussion_r541086598", "bodyText": "This change is strange to me -- what was your motivation? This will have to be updated to support multi-column group by's, since the new schema (post group by) needs to be taken into account when deciding what key serde features to set. (I can do that as part of my group by PR, just curious why this change is being made here when it'll have to change again soon anyway.)\nI also notice that the analogous change wasn't made in SchemaKStream.", "author": "vcrfxia", "createdAt": "2020-12-11T16:53:24Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/structured/SchemaKTable.java", "diffHunk": "@@ -224,12 +216,12 @@ public SchemaKGroupedTable groupBy(\n       final Stacker contextStacker\n   ) {\n     final KeyFormat groupedKeyFormat = KeyFormat\n-        .nonWindowed(keyFormat.getFormatInfo(), SerdeFeatures.of());\n+        .nonWindowed(keyFormat.getFormatInfo(), keyFormat.getFeatures());", "originalCommit": "099fb853b8b410a3623ddf39a70bedfdff29db4e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTE4NTE3OQ==", "url": "https://github.com/confluentinc/ksql/pull/6762#discussion_r541185179", "bodyText": "I think I answered my own question: there is no analogous change in SchemaKStream since stream group bys don't need key format. Defaulting to propagating key serde features in table group bys means fewer historic execution plans change, since internal topics today always unwrap single keys (which is what gets propagated with this change, else we'd get new plans with empty serde features after table group bys).\nI don't think this inconsistency between stream and table group bys makes sense in the long run, but the logic here will change with the next PR anyway so I think it's fine.", "author": "vcrfxia", "createdAt": "2020-12-11T19:17:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTA4NjU5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTMzMjI3MQ==", "url": "https://github.com/confluentinc/ksql/pull/6762#discussion_r541332271", "bodyText": "Yeah, I assumed that with multi-col group bys you'd need to generate a new key format and probably change the key features. But what's nice with this approach is that whatever mechanism you decide should be used for generating the key format will automagically be propagated down the line.", "author": "agavra", "createdAt": "2020-12-11T21:52:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTA4NjU5OA=="}], "type": "inlineReview"}, {"oid": "f515954f2deff725a45fc31d74d8d312de303bb5", "url": "https://github.com/confluentinc/ksql/commit/f515954f2deff725a45fc31d74d8d312de303bb5", "message": "chore: fix missing key format propogation", "committedDate": "2020-12-12T00:14:13Z", "type": "commit"}, {"oid": "5da865f4e2be798d9bd7b52f3ef35915a63d037b", "url": "https://github.com/confluentinc/ksql/commit/5da865f4e2be798d9bd7b52f3ef35915a63d037b", "message": "chore: set the key format eagerly on rekeys", "committedDate": "2020-12-14T20:44:44Z", "type": "commit"}, {"oid": "187d88c095e041c72bea0f415058fac72c203d4b", "url": "https://github.com/confluentinc/ksql/commit/187d88c095e041c72bea0f415058fac72c203d4b", "message": "chore: historical plans", "committedDate": "2020-12-14T20:48:46Z", "type": "commit"}, {"oid": "187d88c095e041c72bea0f415058fac72c203d4b", "url": "https://github.com/confluentinc/ksql/commit/187d88c095e041c72bea0f415058fac72c203d4b", "message": "chore: historical plans", "committedDate": "2020-12-14T20:48:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg2NzEzOA==", "url": "https://github.com/confluentinc/ksql/pull/6762#discussion_r542867138", "bodyText": "I thought this class was marked Immutable?", "author": "vcrfxia", "createdAt": "2020-12-14T22:22:08Z", "path": "ksqldb-serde/src/main/java/io/confluent/ksql/serde/KeyFormat.java", "diffHunk": "@@ -36,7 +37,7 @@\n public final class KeyFormat {\n \n   private final FormatInfo format;\n-  private final SerdeFeatures features;\n+  private SerdeFeatures features;", "originalCommit": "187d88c095e041c72bea0f415058fac72c203d4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg4NDE3Nw==", "url": "https://github.com/confluentinc/ksql/pull/6762#discussion_r542884177", "bodyText": "um... yes it should be. I'm not sure why this changed (it might've been an accidental automated refactor)", "author": "agavra", "createdAt": "2020-12-14T22:38:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg2NzEzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg3MjcxMA==", "url": "https://github.com/confluentinc/ksql/pull/6762#discussion_r542872710", "bodyText": "If this is removed and we instead hard-code isSingleKey=true for now (as we have been, and as is still the case in this PR for table group bys) for purposes of setting internal key features, do the changes in QTT historic plans go away? If so, I'd prefer that instead. I'll re-introduce this change in my multi-column group by PR where plans will change anyway.", "author": "vcrfxia", "createdAt": "2020-12-14T22:27:30Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/structured/SchemaKStream.java", "diffHunk": "@@ -364,37 +358,33 @@ public SchemaKGroupedStream groupBy(\n       final Stacker contextStacker\n   ) {\n     if (!repartitionNeeded(groupByExpressions)) {\n-      return groupByKey(keyFormat.getFormatInfo(), valueFormat, contextStacker);\n+      return groupByKey(keyFormat, valueFormat, contextStacker);\n     }\n \n-    final FormatInfo keyFmtInfo = keyFormat.getFormatInfo().getFormat().equals(NoneFormat.NAME)\n-        ? FormatInfo.of(ksqlConfig.getString(KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG))\n-        : keyFormat.getFormatInfo();\n-\n-    final KeyFormat rekeyedKeyFormat = KeyFormat\n-        .nonWindowed(keyFmtInfo, SerdeFeatures.of());\n-\n+    final boolean isSingleKey = groupByExpressions.size() == 1;", "originalCommit": "187d88c095e041c72bea0f415058fac72c203d4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg4NDU1Mw==", "url": "https://github.com/confluentinc/ksql/pull/6762#discussion_r542884553", "bodyText": "sounds good, I can do that", "author": "agavra", "createdAt": "2020-12-14T22:39:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg3MjcxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg3Mzk1OA==", "url": "https://github.com/confluentinc/ksql/pull/6762#discussion_r542873958", "bodyText": "We're testing two things, right?\n\nIf key wrapping is present, then the key serde feature is inherited\nIf key wrapping is not present, then it is populated\n\nSeems like it should be two separate unit tests? Same for the other test file below.", "author": "vcrfxia", "createdAt": "2020-12-14T22:28:42Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/structured/SchemaKGroupedStreamTest.java", "diffHunk": "@@ -162,9 +163,10 @@ public void shouldBuildStepForAggregate() {\n   }\n \n   @Test\n-  public void shouldBuildStepForAggregateWhereKeyFormatSupportsBothWrappingAndUnwrapping() {\n+  public void shouldBuildStepForAggregateWithKeyFormatSerdeFeatures() {", "originalCommit": "187d88c095e041c72bea0f415058fac72c203d4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg3Njc5OA==", "url": "https://github.com/confluentinc/ksql/pull/6762#discussion_r542876798", "bodyText": "Upon first reading I was confused why this wasn't being sanitized with SerdeFeaturesFactory#sanitizeKeyFeatures(). Looks like the reason is all the sanitization happens in SchemaKStream and SchemaKTable instead. Might be worth adding that into the javadocs for the method?", "author": "vcrfxia", "createdAt": "2020-12-14T22:31:26Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/JoinNode.java", "diffHunk": "@@ -254,16 +255,17 @@ private void ensureMatchingPartitionCounts(final KafkaTopicClient kafkaTopicClie\n             + \"number of partitions match.\");\n   }\n \n-  private FormatInfo getDefaultSourceKeyFormat() {\n+  private KeyFormat getDefaultSourceKeyFormat() {\n     return Stream.of(left, right)\n         .flatMap(PlanNode::getSourceNodes)\n         .map(DataSourceNode::getDataSource)\n         .map(DataSource::getKsqlTopic)\n         .map(KsqlTopic::getKeyFormat)\n-        .map(KeyFormat::getFormatInfo)\n-        .filter(format -> !format.getFormat().equals(NoneFormat.NAME))\n+        .filter(format -> !format.getFormatInfo().getFormat().equals(NoneFormat.NAME))\n         .findFirst()\n-        .orElse(FormatInfo.of(defaultKeyFormat));\n+        // if none exist, assume non-Windowed since that would mean that both sources\n+        // were of NONE format, which doesn't support windowed operations\n+        .orElse(KeyFormat.nonWindowed(FormatInfo.of(defaultKeyFormat), SerdeFeatures.of()));", "originalCommit": "187d88c095e041c72bea0f415058fac72c203d4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg3NzE4NQ==", "url": "https://github.com/confluentinc/ksql/pull/6762#discussion_r542877185", "bodyText": "This isn't just for aggregations, right? I'm confused by this javadoc.", "author": "vcrfxia", "createdAt": "2020-12-14T22:31:48Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/serde/SerdeFeaturesFactory.java", "diffHunk": "@@ -87,6 +88,57 @@ public static SerdeFeatures buildValueFeatures(\n     return SerdeFeatures.from(builder.build());\n   }\n \n+  /**\n+   * Not all {@code KeyFormat}s are valid internal topic formats. Specifically,\n+   * we want to ensure that the key format is (1) not NONE and (2) explicitly sets\n+   * the wrapping if it contains only a single column. This method ensures that\n+   * both of these are eagerly set.\n+   *\n+   * @return the key format to use for the output of the aggregation", "originalCommit": "187d88c095e041c72bea0f415058fac72c203d4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg4NTU3MQ==", "url": "https://github.com/confluentinc/ksql/pull/6762#discussion_r542885571", "bodyText": "yes you are right. I wrote the javadoc and then I did some refactoring and it no longer applies! good catch", "author": "agavra", "createdAt": "2020-12-14T22:40:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg3NzE4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg3OTc3Ng==", "url": "https://github.com/confluentinc/ksql/pull/6762#discussion_r542879776", "bodyText": "I'm confused. Why are we populating a key format in the case where the key format is NONE? This seems like it changes behavior of things like PARTITION BY NULL where we in fact want the resulting key format to be NONE...?", "author": "vcrfxia", "createdAt": "2020-12-14T22:34:22Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/serde/SerdeFeaturesFactory.java", "diffHunk": "@@ -87,6 +88,57 @@ public static SerdeFeatures buildValueFeatures(\n     return SerdeFeatures.from(builder.build());\n   }\n \n+  /**\n+   * Not all {@code KeyFormat}s are valid internal topic formats. Specifically,\n+   * we want to ensure that the key format is (1) not NONE and (2) explicitly sets\n+   * the wrapping if it contains only a single column. This method ensures that\n+   * both of these are eagerly set.\n+   *\n+   * @return the key format to use for the output of the aggregation\n+   */\n+  public static KeyFormat sanitizeKeyFormat(\n+      final KsqlConfig ksqlConfig,\n+      final KeyFormat keyFormat,\n+      final boolean isSingleKey\n+  ) {\n+    if (keyFormat.getFormatInfo().getFormat().equals(NoneFormat.NAME)) {\n+      // explicitly resolve the current default wrapping and write it into the", "originalCommit": "187d88c095e041c72bea0f415058fac72c203d4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg4NjQ0OA==", "url": "https://github.com/confluentinc/ksql/pull/6762#discussion_r542886448", "bodyText": "hmm, let me look into this. I think it might be the same issue as above (I first used this just for aggregates and then I made it fit to everything). I'm not sure why this doesn't cause things to fail.", "author": "agavra", "createdAt": "2020-12-14T22:40:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg3OTc3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk0OTY1NA==", "url": "https://github.com/confluentinc/ksql/pull/6762#discussion_r542949654", "bodyText": "I think it was working because we were always setting the right format in the output anyway and there wasn't any repartition step. I've changed the logic to only \"fix\" the format on group bys", "author": "agavra", "createdAt": "2020-12-15T00:21:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg3OTc3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg4MDMyNw==", "url": "https://github.com/confluentinc/ksql/pull/6762#discussion_r542880327", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // or no-key, in which case there would not have been specified\n          \n          \n            \n                // a wrapping configuration - we should specify one here\n          \n          \n            \n                // or no-key, in which case there would not have been\n          \n          \n            \n                // a wrapping configuration specified - we should specify one here", "author": "vcrfxia", "createdAt": "2020-12-14T22:34:54Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/serde/SerdeFeaturesFactory.java", "diffHunk": "@@ -87,6 +88,57 @@ public static SerdeFeatures buildValueFeatures(\n     return SerdeFeatures.from(builder.build());\n   }\n \n+  /**\n+   * Not all {@code KeyFormat}s are valid internal topic formats. Specifically,\n+   * we want to ensure that the key format is (1) not NONE and (2) explicitly sets\n+   * the wrapping if it contains only a single column. This method ensures that\n+   * both of these are eagerly set.\n+   *\n+   * @return the key format to use for the output of the aggregation\n+   */\n+  public static KeyFormat sanitizeKeyFormat(\n+      final KsqlConfig ksqlConfig,\n+      final KeyFormat keyFormat,\n+      final boolean isSingleKey\n+  ) {\n+    if (keyFormat.getFormatInfo().getFormat().equals(NoneFormat.NAME)) {\n+      // explicitly resolve the current default wrapping and write it into the\n+      // format so that the execution step has it serialized for future backwards\n+      // incompatible changes to what the default may be\n+      final FormatInfo defaultFormat = FormatInfo.of(\n+          ksqlConfig.getString(KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG));\n+      final SerdeFeatures defaultWrapping = getKeyWrapping(isSingleKey, defaultFormat.getFormat())\n+          .map(SerdeFeatures::of)\n+          .orElse(SerdeFeatures.of());\n+\n+      return KeyFormat.nonWindowed(defaultFormat, defaultWrapping);\n+    }\n+\n+    // it is possible that the source format was either multi-key\n+    // or no-key, in which case there would not have been specified\n+    // a wrapping configuration - we should specify one here", "originalCommit": "187d88c095e041c72bea0f415058fac72c203d4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg4MDQ4NA==", "url": "https://github.com/confluentinc/ksql/pull/6762#discussion_r542880484", "bodyText": "nit: any particular reason we extract the format name from FormatInfo and then call FormatFacory.fromName(), rather than directly calling FormatFactory.of()?", "author": "vcrfxia", "createdAt": "2020-12-14T22:35:03Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/serde/SerdeFeaturesFactory.java", "diffHunk": "@@ -87,6 +88,57 @@ public static SerdeFeatures buildValueFeatures(\n     return SerdeFeatures.from(builder.build());\n   }\n \n+  /**\n+   * Not all {@code KeyFormat}s are valid internal topic formats. Specifically,\n+   * we want to ensure that the key format is (1) not NONE and (2) explicitly sets\n+   * the wrapping if it contains only a single column. This method ensures that\n+   * both of these are eagerly set.\n+   *\n+   * @return the key format to use for the output of the aggregation\n+   */\n+  public static KeyFormat sanitizeKeyFormat(\n+      final KsqlConfig ksqlConfig,\n+      final KeyFormat keyFormat,\n+      final boolean isSingleKey\n+  ) {\n+    if (keyFormat.getFormatInfo().getFormat().equals(NoneFormat.NAME)) {\n+      // explicitly resolve the current default wrapping and write it into the\n+      // format so that the execution step has it serialized for future backwards\n+      // incompatible changes to what the default may be\n+      final FormatInfo defaultFormat = FormatInfo.of(\n+          ksqlConfig.getString(KsqlConfig.KSQL_DEFAULT_KEY_FORMAT_CONFIG));\n+      final SerdeFeatures defaultWrapping = getKeyWrapping(isSingleKey, defaultFormat.getFormat())\n+          .map(SerdeFeatures::of)\n+          .orElse(SerdeFeatures.of());\n+\n+      return KeyFormat.nonWindowed(defaultFormat, defaultWrapping);\n+    }\n+\n+    // it is possible that the source format was either multi-key\n+    // or no-key, in which case there would not have been specified\n+    // a wrapping configuration - we should specify one here\n+    final boolean hasWrappingFeature = keyFormat\n+        .getFeatures()\n+        .findAny(SerdeFeatures.WRAPPING_FEATURES)\n+        .isPresent();\n+\n+    if (isSingleKey && !hasWrappingFeature) {\n+      final SerdeFeatures defaultWrapping = getKeyWrapping(true, keyFormat.getFormat())\n+          .map(SerdeFeatures::of)\n+          .orElse(SerdeFeatures.of());\n+      return keyFormat.withSerdeFeature(defaultWrapping);\n+    } else {\n+      return keyFormat;\n+    }\n+  }\n+\n+  private static Optional<SerdeFeature> getKeyWrapping(\n+      final boolean singleKey,\n+      final String format\n+  ) {\n+    return getKeyWrapping(singleKey, FormatFactory.fromName(format));", "originalCommit": "187d88c095e041c72bea0f415058fac72c203d4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjkyNzQ0NQ==", "url": "https://github.com/confluentinc/ksql/pull/6762#discussion_r542927445", "bodyText": "changed, it was leftover from a refactor where I had a little bit more complicated logic", "author": "agavra", "createdAt": "2020-12-14T23:42:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg4MDQ4NA=="}], "type": "inlineReview"}, {"oid": "5c063a1118215b12f59135d2bad29d93b53f42d2", "url": "https://github.com/confluentinc/ksql/commit/5c063a1118215b12f59135d2bad29d93b53f42d2", "message": "chore: review comments", "committedDate": "2020-12-15T04:21:10Z", "type": "commit"}]}