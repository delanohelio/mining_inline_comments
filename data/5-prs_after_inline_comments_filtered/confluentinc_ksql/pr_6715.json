{"pr_number": 6715, "pr_title": "chore: avoid extra state store when repartitioning tables for joins", "pr_createdAt": "2020-12-03T04:50:58Z", "pr_url": "https://github.com/confluentinc/ksql/pull/6715", "timeline": [{"oid": "6352cae20d39e92abbdb07e45d41044528f09682", "url": "https://github.com/confluentinc/ksql/commit/6352cae20d39e92abbdb07e45d41044528f09682", "message": "chore: avoid extra state store when repartitioning tables for joins", "committedDate": "2020-12-03T04:16:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDY2Njc2MA==", "url": "https://github.com/confluentinc/ksql/pull/6715#discussion_r534666760", "bodyText": "The current expectation is that this variant is only called by QueryExecutor, on output nodes, and not from any intermediate nodes. Is it worth enforcing this assumption by throwing an exception if the method is called a non-output-node execution step?", "author": "vcrfxia", "createdAt": "2020-12-03T04:51:39Z", "path": "ksqldb-execution/src/main/java/io/confluent/ksql/execution/plan/ExecutionStep.java", "diffHunk": "@@ -60,7 +60,13 @@\n   @JsonIgnore\n   List<ExecutionStep<?>> getSources();\n \n-  S build(PlanBuilder planBuilder);\n+  default S build(PlanBuilder planBuilder) {", "originalCommit": "6352cae20d39e92abbdb07e45d41044528f09682", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTcxODcxNQ==", "url": "https://github.com/confluentinc/ksql/pull/6715#discussion_r535718715", "bodyText": "+1. If we do not expect other callers, make it more strict is preferred.", "author": "guozhangwang", "createdAt": "2020-12-03T23:21:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDY2Njc2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTc3MjczNg==", "url": "https://github.com/confluentinc/ksql/pull/6715#discussion_r535772736", "bodyText": "Turns out I was mistaken here. In the case of transient queries, there is no designated output node, so the QueryExecutor may call this variation of build() on essentially any node (whatever the last step in the execution step plan of a particular transient query happens to be).", "author": "vcrfxia", "createdAt": "2020-12-04T01:40:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDY2Njc2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDY2NjkzOQ==", "url": "https://github.com/confluentinc/ksql/pull/6715#discussion_r534666939", "bodyText": "Today, we only ever repartition tables to enable joins, and it is not possible to repartition a table after a table operation that requires materialization (e.g., joining on a table that is the result of grouping by another table, in the same query) so it is correct to only track repartitions when deciding whether to force materialization at the table source or not. However, if in the future we allow table repartitions after table operations that require materialization, then this logic will have to be updated to account for that. Does it make sense to future-proof this and add in the more complicated logic now, or would that be overcomplicating things?", "author": "vcrfxia", "createdAt": "2020-12-03T04:52:08Z", "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/KSPlanInfoExtractor.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (final the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.execution.streams;\n+\n+import io.confluent.ksql.execution.plan.ExecutionStep;\n+import io.confluent.ksql.execution.plan.PlanInfoExtractor;\n+import io.confluent.ksql.execution.plan.StreamAggregate;\n+import io.confluent.ksql.execution.plan.StreamFilter;\n+import io.confluent.ksql.execution.plan.StreamFlatMap;\n+import io.confluent.ksql.execution.plan.StreamGroupBy;\n+import io.confluent.ksql.execution.plan.StreamGroupByKey;\n+import io.confluent.ksql.execution.plan.StreamSelect;\n+import io.confluent.ksql.execution.plan.StreamSelectKey;\n+import io.confluent.ksql.execution.plan.StreamSelectKeyV1;\n+import io.confluent.ksql.execution.plan.StreamSink;\n+import io.confluent.ksql.execution.plan.StreamSource;\n+import io.confluent.ksql.execution.plan.StreamStreamJoin;\n+import io.confluent.ksql.execution.plan.StreamTableJoin;\n+import io.confluent.ksql.execution.plan.StreamWindowedAggregate;\n+import io.confluent.ksql.execution.plan.TableAggregate;\n+import io.confluent.ksql.execution.plan.TableFilter;\n+import io.confluent.ksql.execution.plan.TableGroupBy;\n+import io.confluent.ksql.execution.plan.TableSelect;\n+import io.confluent.ksql.execution.plan.TableSelectKey;\n+import io.confluent.ksql.execution.plan.TableSink;\n+import io.confluent.ksql.execution.plan.TableSource;\n+import io.confluent.ksql.execution.plan.TableSuppress;\n+import io.confluent.ksql.execution.plan.TableTableJoin;\n+import io.confluent.ksql.execution.plan.WindowedStreamSource;\n+import io.confluent.ksql.execution.plan.WindowedTableSource;\n+\n+/**\n+ * Visitor for extracting {@link KSPlanInfo} from an execution step plan.\n+ * See {@link KSPlanInfo} description for more.\n+ */\n+public class KSPlanInfoExtractor implements PlanInfoExtractor {\n+  \n+  @Override\n+  public <K> KSPlanInfo visitStreamFilter(final StreamFilter<K> streamFilter) {\n+    return visitSingleSourceStep(streamFilter);\n+  }\n+\n+  @Override\n+  public <K> KSPlanInfo visitStreamGroupBy(final StreamGroupBy<K> streamGroupBy) {\n+    return visitSingleSourceStep(streamGroupBy);\n+  }\n+\n+  @Override\n+  public KSPlanInfo visitStreamGroupByKey(final StreamGroupByKey streamGroupByKey) {\n+    return visitSingleSourceStep(streamGroupByKey);\n+  }\n+\n+  @Override\n+  public KSPlanInfo visitStreamAggregate(final StreamAggregate streamAggregate) {\n+    return visitSingleSourceStep(streamAggregate);\n+  }\n+\n+  @Override\n+  public <K> KSPlanInfo visitStreamSelect(final StreamSelect<K> streamSelect) {\n+    return visitSingleSourceStep(streamSelect);\n+  }\n+\n+  @Override\n+  public <K> KSPlanInfo visitFlatMap(final StreamFlatMap<K> streamFlatMap) {\n+    return visitSingleSourceStep(streamFlatMap);\n+  }\n+\n+  @Override\n+  public KSPlanInfo visitStreamSelectKey(final StreamSelectKeyV1 streamSelectKey) {\n+    return visitRepartitionStep(streamSelectKey);\n+  }\n+\n+  @Override\n+  public <K> KSPlanInfo visitStreamSelectKey(final StreamSelectKey<K> streamSelectKey) {\n+    return visitRepartitionStep(streamSelectKey);\n+  }\n+\n+  @Override\n+  public <K> KSPlanInfo visitStreamSink(final StreamSink<K> streamSink) {\n+    return visitSingleSourceStep(streamSink);\n+  }\n+\n+  @Override\n+  public KSPlanInfo visitStreamSource(final StreamSource streamSource) {\n+    return visitSourceStep(streamSource);\n+  }\n+\n+  @Override\n+  public KSPlanInfo visitWindowedStreamSource(final WindowedStreamSource windowedStreamSource) {\n+    return visitSourceStep(windowedStreamSource);\n+  }\n+\n+  @Override\n+  public <K> KSPlanInfo visitStreamStreamJoin(final StreamStreamJoin<K> streamStreamJoin) {\n+    return visitJoinStep(streamStreamJoin);\n+  }\n+\n+  @Override\n+  public <K> KSPlanInfo visitStreamTableJoin(final StreamTableJoin<K> streamTableJoin) {\n+    return visitJoinStep(streamTableJoin);\n+  }\n+\n+  @Override\n+  public KSPlanInfo visitTableSource(final TableSource tableSource) {\n+    return visitSourceStep(tableSource);\n+  }\n+\n+  @Override\n+  public KSPlanInfo visitWindowedTableSource(final WindowedTableSource windowedTableSource) {\n+    return visitSourceStep(windowedTableSource);\n+  }\n+\n+  @Override\n+  public KSPlanInfo visitStreamWindowedAggregate(\n+      final StreamWindowedAggregate streamWindowedAggregate\n+  ) {\n+    return visitSingleSourceStep(streamWindowedAggregate);\n+  }\n+\n+  @Override\n+  public KSPlanInfo visitTableAggregate(final TableAggregate tableAggregate) {\n+    return visitSingleSourceStep(tableAggregate);\n+  }\n+\n+  @Override\n+  public <K> KSPlanInfo visitTableFilter(final TableFilter<K> tableFilter) {\n+    return visitSingleSourceStep(tableFilter);\n+  }\n+\n+  @Override\n+  public <K> KSPlanInfo visitTableGroupBy(final TableGroupBy<K> tableGroupBy) {\n+    return visitSingleSourceStep(tableGroupBy);\n+  }\n+\n+  @Override\n+  public <K> KSPlanInfo visitTableSelect(final TableSelect<K> tableSelect) {\n+    return visitSingleSourceStep(tableSelect);\n+  }\n+\n+  @Override\n+  public <K> KSPlanInfo visitTableSelectKey(final TableSelectKey<K> tableSelectKey) {\n+    return visitRepartitionStep(tableSelectKey);\n+  }\n+\n+  @Override\n+  public <K> KSPlanInfo visitTableSink(final TableSink<K> tableSink) {\n+    return visitSingleSourceStep(tableSink);\n+  }\n+\n+  @Override\n+  public <K> KSPlanInfo visitTableSuppress(final TableSuppress<K> tableSuppress) {\n+    return visitSingleSourceStep(tableSuppress);\n+  }\n+\n+  @Override\n+  public <K> KSPlanInfo visitTableTableJoin(final TableTableJoin<K> tableTableJoin) {\n+    return visitJoinStep(tableTableJoin);\n+  }\n+\n+  private KSPlanInfo visitSourceStep(final ExecutionStep<?> step) {\n+    return new KSPlanInfo(step);\n+  }\n+\n+  private KSPlanInfo visitRepartitionStep(final ExecutionStep<?> step) {", "originalCommit": "6352cae20d39e92abbdb07e45d41044528f09682", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTc3MzcyMQ==", "url": "https://github.com/confluentinc/ksql/pull/6715#discussion_r535773721", "bodyText": "I'm going to merge this PR without future-proofing as there are other PRs blocked behind this.\n@agavra do you think it makes sense to try to future-proof this logic in a follow-up PR? It should be a small change. The reason I'm hesitant is because it requires making strong assumptions about which steps require materialization at the Kafka Streams level, and it feels weird to bake in these assumptions as they could in theory evolve in the future.", "author": "vcrfxia", "createdAt": "2020-12-04T01:43:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDY2NjkzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjIyMTYwMg==", "url": "https://github.com/confluentinc/ksql/pull/6715#discussion_r536221602", "bodyText": "The benefit of baking in the assumptions is that if they evolve we'll be conscious about it. I'm ok either way since we have pretty good test coverage here; we will catch in QTT if things change unexpectedly.", "author": "agavra", "createdAt": "2020-12-04T16:27:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDY2NjkzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY1NTM1MQ==", "url": "https://github.com/confluentinc/ksql/pull/6715#discussion_r539655351", "bodyText": "Discussed (thoroughly \ud83d\ude02 ) offline: my concern is that if we support a new type of query that allows table aggregations prior to joins (in the same query), we may forget to update the logic in PlanInfoExtractor at that time, exposing us to the Avro schema name bug that the forced materialization at table sources tries to avoid. This would not be caught by existing QTTs as it would be for a new type of query. Summary of our discussion including how to proceed is here: #6750", "author": "vcrfxia", "createdAt": "2020-12-09T21:19:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDY2NjkzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDY2NzA3NA==", "url": "https://github.com/confluentinc/ksql/pull/6715#discussion_r534667074", "bodyText": "Is it weird that this interface is empty? It's unclear to me which (if any) parts of the KSPlanInfo implementation are generic enough to warrant being moved into the interface.", "author": "vcrfxia", "createdAt": "2020-12-03T04:52:30Z", "path": "ksqldb-execution/src/main/java/io/confluent/ksql/execution/plan/PlanInfo.java", "diffHunk": "@@ -0,0 +1,23 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.execution.plan;\n+\n+/**\n+ * Information about an execution step plan to be passed to a {@link PlanBuilder}\n+ * for use when converting an execution step plan into a physical plan.\n+ */\n+public interface PlanInfo {", "originalCommit": "6352cae20d39e92abbdb07e45d41044528f09682", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ2NTUyNA==", "url": "https://github.com/confluentinc/ksql/pull/6715#discussion_r535465524", "bodyText": "I think the abstract builder pattern makes sense for PlanBuilder, but less so for PlanInfoExtractor because we may want different PlanBuilders if we decide to implement a non-KS physical plan (ignoring for a sec that KStreamHolder isn't actually generic enough to support non-KS implementations yet). The PlanInfo, however, should make sense to any corresponding physical plan we decide to build (it's an analysis of the steps and has nothing to do with Kafka Streams specifically). All we have to do is rename \"repartition\" to \"keyChange\" and this change becomes entirely generic.\nthe tl;dr is that I don't think we need to have this be an interface (and I don't think we need an interface for PlanInfoExtractor either (though see my general comment about a different approach to this)", "author": "agavra", "createdAt": "2020-12-03T18:10:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDY2NzA3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ5MzAwNQ==", "url": "https://github.com/confluentinc/ksql/pull/6715#discussion_r535493005", "bodyText": "I agree with your reasoning regarding the visitor pattern for PlanBuilder. My thinking in abstracting PlanInfoExtractor was that different plan builder implementations will likely want different information from the plan. For example, a non-Kafka-Streams implementation might not care about repartitions.\nThis is all very up in the clouds, though, since having a non-Kafka-Streams implementation is very far off. If you prefer nixing the interface I'm happy to do so.", "author": "vcrfxia", "createdAt": "2020-12-03T18:49:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDY2NzA3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTczOTY5Ng==", "url": "https://github.com/confluentinc/ksql/pull/6715#discussion_r535739696", "bodyText": "I'd rather nix the interface \ud83d\ude02 fewer lines of code to refactor when we inevitably do", "author": "agavra", "createdAt": "2020-12-04T00:11:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDY2NzA3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDY2NzQ3OA==", "url": "https://github.com/confluentinc/ksql/pull/6715#discussion_r534667478", "bodyText": "Not sure why we had both easymock and mockito in this test file but easymock is gone now \ud83d\udc80", "author": "vcrfxia", "createdAt": "2020-12-03T04:53:53Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/structured/SchemaKTableTest.java", "diffHunk": "@@ -15,24 +15,22 @@\n \n package io.confluent.ksql.structured;\n \n-import static org.easymock.EasyMock.anyObject;", "originalCommit": "6352cae20d39e92abbdb07e45d41044528f09682", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDY2ODM4Mg==", "url": "https://github.com/confluentinc/ksql/pull/6715#discussion_r534668382", "bodyText": "I assumed if we're removing the Materialized we might as well remove the dummy mapValues step too. This change is backwards compatible (between releases) since this pathway is only hit in the case of forcing table repartitions to enable joins, which are new as of master (not currently released). However, if we think it's confusing that sometimes there is a dummy mapValues step on table sources and sometimes there isn't, I can put the dummy mapValues step back in with no materialization.", "author": "vcrfxia", "createdAt": "2020-12-03T04:56:40Z", "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/SourceBuilder.java", "diffHunk": "@@ -330,12 +335,23 @@ private static PhysicalSchema getPhysicalSchema(final SourceStep<?> streamSource\n       final KTable<K, GenericRow> source = queryBuilder\n           .getStreamsBuilder()\n           .table(streamSource.getTopicName(), consumed);\n-      // add this identity mapValues call to prevent the source-changelog\n-      // optimization in kafka streams - we don't want this optimization to\n-      // be enabled because we cannot require symmetric serialization between\n-      // producer and KSQL (see https://issues.apache.org/jira/browse/KAFKA-10179\n-      // and https://github.com/confluentinc/ksql/issues/5673 for more details)\n-      table = source.mapValues(row -> row, materialized);\n+\n+      final boolean forceMaterialization = !planInfo.isRepartitionedInPlan(streamSource);\n+      if (forceMaterialization) {\n+        // add this identity mapValues call to prevent the source-changelog\n+        // optimization in kafka streams - we don't want this optimization to\n+        // be enabled because we cannot require symmetric serialization between\n+        // producer and KSQL (see https://issues.apache.org/jira/browse/KAFKA-10179\n+        // and https://github.com/confluentinc/ksql/issues/5673 for more details)\n+        table = source.mapValues(row -> row, materialized);\n+      } else {\n+        // if we know this table source is repartitioned later in the topology,\n+        // we do not need to force a materialization at this source step since the\n+        // re-partitioned topic will be used for any subsequent state stores, in lieu\n+        // of the original source topic, thus avoiding the issues above.\n+        // See https://github.com/confluentinc/ksql/issues/6650\n+        table = source;", "originalCommit": "6352cae20d39e92abbdb07e45d41044528f09682", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQyOTAwNQ==", "url": "https://github.com/confluentinc/ksql/pull/6715#discussion_r535429005", "bodyText": "I think it makes sense to remove it", "author": "agavra", "createdAt": "2020-12-03T17:17:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDY2ODM4Mg=="}], "type": "inlineReview"}, {"oid": "d9bf50372b3d9e69ca7f43e0ffae3dd25d42b471", "url": "https://github.com/confluentinc/ksql/commit/d9bf50372b3d9e69ca7f43e0ffae3dd25d42b471", "message": "chore: remove PlanInfo interface", "committedDate": "2020-12-04T01:16:02Z", "type": "commit"}, {"oid": "bf170086e6b6f8e0317c54181869dd8eea897267", "url": "https://github.com/confluentinc/ksql/commit/bf170086e6b6f8e0317c54181869dd8eea897267", "message": "chore: rename PlanInfoExtractor", "committedDate": "2020-12-04T01:26:40Z", "type": "commit"}, {"oid": "37ec0b8de4943e6a3816b0bf9611ae185a685c9f", "url": "https://github.com/confluentinc/ksql/commit/37ec0b8de4943e6a3816b0bf9611ae185a685c9f", "message": "chore: cleanup", "committedDate": "2020-12-04T01:37:38Z", "type": "commit"}, {"oid": "476326f52f477619014f8bed5ea04ea2349009e2", "url": "https://github.com/confluentinc/ksql/commit/476326f52f477619014f8bed5ea04ea2349009e2", "message": "chore: remove ExecutionStepVisitor", "committedDate": "2020-12-04T01:37:48Z", "type": "commit"}]}