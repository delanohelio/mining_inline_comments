{"pr_number": 6014, "pr_title": "feat: latest and earliest ByOffset UDFs to capture N values", "pr_createdAt": "2020-08-13T08:43:24Z", "pr_url": "https://github.com/confluentinc/ksql/pull/6014", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkxMTIyNw==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469911227", "bodyText": "Would you mind backing out formatting changes such as this. It causes unnecessary churn in the code base, (making merges and diffs harder) and adds unnecessary code changes that need reviewing. Thanks.\n(I think some of these formatting changes may also make the build fail!)\nI'll take other formatting changes in the PR that should be backed out to with 'revert formatting please'", "author": "big-andy-coates", "createdAt": "2020-08-13T12:23:41Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java", "diffHunk": "@@ -1,16 +1,15 @@\n /*\n  * Copyright 2020 Confluent Inc.\n  *\n- * Licensed under the Confluent Community License (the \"License\"; you may not use\n- * this file except in compliance with the License. You may obtain a copy of the\n- * License at\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use this file except", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkxMTI3Nw==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469911277", "bodyText": "revert formatting please", "author": "big-andy-coates", "createdAt": "2020-08-13T12:23:47Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java", "diffHunk": "@@ -1,16 +1,15 @@\n /*\n  * Copyright 2020 Confluent Inc.\n  *\n- * Licensed under the Confluent Community License (the \"License\"; you may not use\n- * this file except in compliance with the License. You may obtain a copy of the\n- * License at\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n  *\n  * http://www.confluent.io/confluent-community-license\n  *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations under the License.\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and limitations under the\n+ * License.", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkxMTM0OQ==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469911349", "bodyText": "revert formatting please", "author": "big-andy-coates", "createdAt": "2020-08-13T12:23:55Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java", "diffHunk": "@@ -28,53 +27,86 @@\n import io.confluent.ksql.function.udaf.UdafDescription;\n import io.confluent.ksql.function.udaf.UdafFactory;\n import io.confluent.ksql.util.KsqlConstants;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Collectors;\n import org.apache.kafka.connect.data.Schema;\n import org.apache.kafka.connect.data.Struct;\n \n-@UdafDescription(\n-    name = \"EARLIEST_BY_OFFSET\",\n-    description = EarliestByOffset.DESCRIPTION,\n-    author = KsqlConstants.CONFLUENT_AUTHOR\n-)\n+@UdafDescription(name = \"EARLIEST_BY_OFFSET\", description = EarliestByOffset.DESCRIPTION,\n+    author = KsqlConstants.CONFLUENT_AUTHOR)", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkxMTYwNw==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469911607", "bodyText": "revert formatting please", "author": "big-andy-coates", "createdAt": "2020-08-13T12:24:20Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java", "diffHunk": "@@ -28,53 +27,86 @@\n import io.confluent.ksql.function.udaf.UdafDescription;\n import io.confluent.ksql.function.udaf.UdafFactory;\n import io.confluent.ksql.util.KsqlConstants;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Collectors;\n import org.apache.kafka.connect.data.Schema;\n import org.apache.kafka.connect.data.Struct;\n \n-@UdafDescription(\n-    name = \"EARLIEST_BY_OFFSET\",\n-    description = EarliestByOffset.DESCRIPTION,\n-    author = KsqlConstants.CONFLUENT_AUTHOR\n-)\n+@UdafDescription(name = \"EARLIEST_BY_OFFSET\", description = EarliestByOffset.DESCRIPTION,\n+    author = KsqlConstants.CONFLUENT_AUTHOR)\n public final class EarliestByOffset {\n   static final String DESCRIPTION =\n-      \"This function returns the oldest value for the column, computed by offset.\";\n+      \"This function returns the oldest N value for the column, computed by offset.\";\n \n-  private EarliestByOffset() {\n-  }\n+  private EarliestByOffset() {}", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkxMjExNQ==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469912115", "bodyText": "revert formatting please", "author": "big-andy-coates", "createdAt": "2020-08-13T12:25:10Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java", "diffHunk": "@@ -1,16 +1,15 @@\n /*\n  * Copyright 2019 Confluent Inc.\n  *\n- * Licensed under the Confluent Community License (the \"License\"; you may not use\n- * this file except in compliance with the License. You may obtain a copy of the\n- * License at\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkxMjE1Nw==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469912157", "bodyText": "revert formatting please", "author": "big-andy-coates", "createdAt": "2020-08-13T12:25:14Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java", "diffHunk": "@@ -1,16 +1,15 @@\n /*\n  * Copyright 2019 Confluent Inc.\n  *\n- * Licensed under the Confluent Community License (the \"License\"; you may not use\n- * this file except in compliance with the License. You may obtain a copy of the\n- * License at\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n  *\n  * http://www.confluent.io/confluent-community-license\n  *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations under the License.\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and limitations under the\n+ * License.", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkxMjIzNg==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469912236", "bodyText": "revert formatting please", "author": "big-andy-coates", "createdAt": "2020-08-13T12:25:24Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java", "diffHunk": "@@ -35,8 +36,7 @@\n   @Test\n   public void shouldInitialize() {\n     // Given:\n-    final Udaf<Integer, Struct, Integer> udaf = LatestByOffset\n-        .latest(STRUCT_LONG);\n+    final Udaf<Integer, Struct, Integer> udaf = LatestByOffset.latest(STRUCT_LONG);", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkxMjM1NQ==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469912355", "bodyText": "revert formatting please", "author": "big-andy-coates", "createdAt": "2020-08-13T12:25:38Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java", "diffHunk": "@@ -45,19 +45,48 @@ public void shouldInitialize() {\n     assertThat(init, is(notNullValue()));\n   }\n \n+  @Test\n+  public void shouldInitializeLatest2Integers() {\n+    // Given:\n+    final Udaf<Integer, List<Struct>, List<Integer>> udaf = LatestByOffset.latestN(STRUCT_LONG, 2);\n+\n+    // When:\n+    List<Struct> init = udaf.initialize();\n+\n+    // Then:\n+    assertThat(init, is(notNullValue()));\n+  }\n+\n   @Test\n   public void shouldComputeLatestInteger() {\n     // Given:\n     final Udaf<Integer, Struct, Integer> udaf = LatestByOffset.latestInteger();\n \n     // When:\n-    Struct res = udaf\n-        .aggregate(123, LatestByOffset.createStruct(STRUCT_INTEGER, 321));\n+    Struct res = udaf.aggregate(123, LatestByOffset.createStruct(STRUCT_INTEGER, 321));", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkxMjQwMw==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469912403", "bodyText": "revert formatting please", "author": "big-andy-coates", "createdAt": "2020-08-13T12:25:43Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java", "diffHunk": "@@ -96,57 +148,150 @@ public void shouldMergeWithOverflow() {\n     assertThat(merged2, is(agg2));\n   }\n \n+  @Test\n+  public void shouldMergeWithOverflow1Integer() {\n+    // Given:\n+    final Udaf<Integer, List<Struct>, List<Integer>> udaf = LatestByOffset.latestInteger(1);\n+\n+    LatestByOffset.sequence.set(Long.MAX_VALUE);\n+\n+    List<Struct> agg1 =\n+        new ArrayList<>(Arrays.asList(LatestByOffset.createStruct(STRUCT_INTEGER, 123)));\n+    List<Struct> agg2 =\n+        new ArrayList<>(Arrays.asList(LatestByOffset.createStruct(STRUCT_INTEGER, 321)));\n+    List<Struct> agg3 =\n+        new ArrayList<>(Arrays.asList(agg1.get(0),agg2.get(0)));\n+\n+    // When:\n+    List<Struct> merged1 = udaf.merge(agg1, agg2);\n+    List<Struct> merged2 = udaf.merge(agg2, agg1);\n+\n+    // Then:\n+    assertThat(agg1.get(0).getInt64(SEQ_FIELD), is(Long.MAX_VALUE));\n+    assertThat(agg2.get(0).getInt64(SEQ_FIELD), is(Long.MIN_VALUE));\n+    assertThat(merged1, is(agg2));\n+    assertThat(merged2, is(agg2));\n+  }\n+\n \n   @Test\n   public void shouldComputeLatestLong() {\n     // Given:\n     final Udaf<Long, Struct, Long> udaf = LatestByOffset.latestLong();\n \n     // When:\n-    Struct res = udaf\n-        .aggregate(123L, LatestByOffset.createStruct(STRUCT_LONG, 321L));\n+    Struct res = udaf.aggregate(123L, LatestByOffset.createStruct(STRUCT_LONG, 321L));", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkxMjQzMg==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469912432", "bodyText": "revert formatting please", "author": "big-andy-coates", "createdAt": "2020-08-13T12:25:47Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java", "diffHunk": "@@ -96,57 +148,150 @@ public void shouldMergeWithOverflow() {\n     assertThat(merged2, is(agg2));\n   }\n \n+  @Test\n+  public void shouldMergeWithOverflow1Integer() {\n+    // Given:\n+    final Udaf<Integer, List<Struct>, List<Integer>> udaf = LatestByOffset.latestInteger(1);\n+\n+    LatestByOffset.sequence.set(Long.MAX_VALUE);\n+\n+    List<Struct> agg1 =\n+        new ArrayList<>(Arrays.asList(LatestByOffset.createStruct(STRUCT_INTEGER, 123)));\n+    List<Struct> agg2 =\n+        new ArrayList<>(Arrays.asList(LatestByOffset.createStruct(STRUCT_INTEGER, 321)));\n+    List<Struct> agg3 =\n+        new ArrayList<>(Arrays.asList(agg1.get(0),agg2.get(0)));\n+\n+    // When:\n+    List<Struct> merged1 = udaf.merge(agg1, agg2);\n+    List<Struct> merged2 = udaf.merge(agg2, agg1);\n+\n+    // Then:\n+    assertThat(agg1.get(0).getInt64(SEQ_FIELD), is(Long.MAX_VALUE));\n+    assertThat(agg2.get(0).getInt64(SEQ_FIELD), is(Long.MIN_VALUE));\n+    assertThat(merged1, is(agg2));\n+    assertThat(merged2, is(agg2));\n+  }\n+\n \n   @Test\n   public void shouldComputeLatestLong() {\n     // Given:\n     final Udaf<Long, Struct, Long> udaf = LatestByOffset.latestLong();\n \n     // When:\n-    Struct res = udaf\n-        .aggregate(123L, LatestByOffset.createStruct(STRUCT_LONG, 321L));\n+    Struct res = udaf.aggregate(123L, LatestByOffset.createStruct(STRUCT_LONG, 321L));\n \n     // Then:\n     assertThat(res.getInt64(VAL_FIELD), is(123L));\n   }\n+  \n+  @Test\n+  public void shouldComputeLatest2Longs() {\n+    // Given:\n+    final Udaf<Long, List<Struct>, List<Long>> udaf = LatestByOffset.latestLong(2);\n+\n+    List<Struct> list = new ArrayList<>();\n+    list.add(LatestByOffset.createStruct(STRUCT_LONG, 321L));\n+\n+    // When:\n+    List<Struct> res = udaf.aggregate(123L, list);\n+\n+    assertThat(list.size(), is(2));\n+    // Then:\n+    assertThat(res.get(0).get(VAL_FIELD), is(321L));\n+    assertThat(res.get(1).get(VAL_FIELD), is(123L));\n+\n+  }\n \n   @Test\n   public void shouldComputeLatestDouble() {\n     // Given:\n     final Udaf<Double, Struct, Double> udaf = LatestByOffset.latestDouble();\n \n     // When:\n-    Struct res = udaf\n-        .aggregate(1.1d, LatestByOffset.createStruct(STRUCT_DOUBLE, 2.2d));\n+    Struct res = udaf.aggregate(1.1d, LatestByOffset.createStruct(STRUCT_DOUBLE, 2.2d));", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkxMjQ1NQ==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469912455", "bodyText": "revert formatting please", "author": "big-andy-coates", "createdAt": "2020-08-13T12:25:50Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java", "diffHunk": "@@ -96,57 +148,150 @@ public void shouldMergeWithOverflow() {\n     assertThat(merged2, is(agg2));\n   }\n \n+  @Test\n+  public void shouldMergeWithOverflow1Integer() {\n+    // Given:\n+    final Udaf<Integer, List<Struct>, List<Integer>> udaf = LatestByOffset.latestInteger(1);\n+\n+    LatestByOffset.sequence.set(Long.MAX_VALUE);\n+\n+    List<Struct> agg1 =\n+        new ArrayList<>(Arrays.asList(LatestByOffset.createStruct(STRUCT_INTEGER, 123)));\n+    List<Struct> agg2 =\n+        new ArrayList<>(Arrays.asList(LatestByOffset.createStruct(STRUCT_INTEGER, 321)));\n+    List<Struct> agg3 =\n+        new ArrayList<>(Arrays.asList(agg1.get(0),agg2.get(0)));\n+\n+    // When:\n+    List<Struct> merged1 = udaf.merge(agg1, agg2);\n+    List<Struct> merged2 = udaf.merge(agg2, agg1);\n+\n+    // Then:\n+    assertThat(agg1.get(0).getInt64(SEQ_FIELD), is(Long.MAX_VALUE));\n+    assertThat(agg2.get(0).getInt64(SEQ_FIELD), is(Long.MIN_VALUE));\n+    assertThat(merged1, is(agg2));\n+    assertThat(merged2, is(agg2));\n+  }\n+\n \n   @Test\n   public void shouldComputeLatestLong() {\n     // Given:\n     final Udaf<Long, Struct, Long> udaf = LatestByOffset.latestLong();\n \n     // When:\n-    Struct res = udaf\n-        .aggregate(123L, LatestByOffset.createStruct(STRUCT_LONG, 321L));\n+    Struct res = udaf.aggregate(123L, LatestByOffset.createStruct(STRUCT_LONG, 321L));\n \n     // Then:\n     assertThat(res.getInt64(VAL_FIELD), is(123L));\n   }\n+  \n+  @Test\n+  public void shouldComputeLatest2Longs() {\n+    // Given:\n+    final Udaf<Long, List<Struct>, List<Long>> udaf = LatestByOffset.latestLong(2);\n+\n+    List<Struct> list = new ArrayList<>();\n+    list.add(LatestByOffset.createStruct(STRUCT_LONG, 321L));\n+\n+    // When:\n+    List<Struct> res = udaf.aggregate(123L, list);\n+\n+    assertThat(list.size(), is(2));\n+    // Then:\n+    assertThat(res.get(0).get(VAL_FIELD), is(321L));\n+    assertThat(res.get(1).get(VAL_FIELD), is(123L));\n+\n+  }\n \n   @Test\n   public void shouldComputeLatestDouble() {\n     // Given:\n     final Udaf<Double, Struct, Double> udaf = LatestByOffset.latestDouble();\n \n     // When:\n-    Struct res = udaf\n-        .aggregate(1.1d, LatestByOffset.createStruct(STRUCT_DOUBLE, 2.2d));\n+    Struct res = udaf.aggregate(1.1d, LatestByOffset.createStruct(STRUCT_DOUBLE, 2.2d));\n \n     // Then:\n     assertThat(res.getFloat64(VAL_FIELD), is(1.1d));\n   }\n+  \n+  @Test\n+  public void shouldComputeLatest2Doubles() {\n+    // Given:\n+    final Udaf<Double, List<Struct>, List<Double>> udaf = LatestByOffset.latestDouble(2);\n+\n+    List<Struct> list = new ArrayList<>();\n+    list.add(LatestByOffset.createStruct(STRUCT_DOUBLE, 2.2d));\n+\n+    // When:\n+    List<Struct> res = udaf.aggregate(1.1d, list);\n+\n+    assertThat(list.size(), is(2));\n+    // Then:\n+    assertThat(res.get(0).get(VAL_FIELD), is(2.2d));\n+    assertThat(res.get(1).get(VAL_FIELD), is(1.1d));\n+\n+  }\n \n   @Test\n   public void shouldComputeLatestBoolean() {\n     // Given:\n     final Udaf<Boolean, Struct, Boolean> udaf = LatestByOffset.latestBoolean();\n \n     // When:\n-    Struct res = udaf\n-        .aggregate(true, LatestByOffset.createStruct(STRUCT_BOOLEAN, false));\n+    Struct res = udaf.aggregate(true, LatestByOffset.createStruct(STRUCT_BOOLEAN, false));", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkxMjQ3Nw==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469912477", "bodyText": "revert formatting please", "author": "big-andy-coates", "createdAt": "2020-08-13T12:25:53Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java", "diffHunk": "@@ -96,57 +148,150 @@ public void shouldMergeWithOverflow() {\n     assertThat(merged2, is(agg2));\n   }\n \n+  @Test\n+  public void shouldMergeWithOverflow1Integer() {\n+    // Given:\n+    final Udaf<Integer, List<Struct>, List<Integer>> udaf = LatestByOffset.latestInteger(1);\n+\n+    LatestByOffset.sequence.set(Long.MAX_VALUE);\n+\n+    List<Struct> agg1 =\n+        new ArrayList<>(Arrays.asList(LatestByOffset.createStruct(STRUCT_INTEGER, 123)));\n+    List<Struct> agg2 =\n+        new ArrayList<>(Arrays.asList(LatestByOffset.createStruct(STRUCT_INTEGER, 321)));\n+    List<Struct> agg3 =\n+        new ArrayList<>(Arrays.asList(agg1.get(0),agg2.get(0)));\n+\n+    // When:\n+    List<Struct> merged1 = udaf.merge(agg1, agg2);\n+    List<Struct> merged2 = udaf.merge(agg2, agg1);\n+\n+    // Then:\n+    assertThat(agg1.get(0).getInt64(SEQ_FIELD), is(Long.MAX_VALUE));\n+    assertThat(agg2.get(0).getInt64(SEQ_FIELD), is(Long.MIN_VALUE));\n+    assertThat(merged1, is(agg2));\n+    assertThat(merged2, is(agg2));\n+  }\n+\n \n   @Test\n   public void shouldComputeLatestLong() {\n     // Given:\n     final Udaf<Long, Struct, Long> udaf = LatestByOffset.latestLong();\n \n     // When:\n-    Struct res = udaf\n-        .aggregate(123L, LatestByOffset.createStruct(STRUCT_LONG, 321L));\n+    Struct res = udaf.aggregate(123L, LatestByOffset.createStruct(STRUCT_LONG, 321L));\n \n     // Then:\n     assertThat(res.getInt64(VAL_FIELD), is(123L));\n   }\n+  \n+  @Test\n+  public void shouldComputeLatest2Longs() {\n+    // Given:\n+    final Udaf<Long, List<Struct>, List<Long>> udaf = LatestByOffset.latestLong(2);\n+\n+    List<Struct> list = new ArrayList<>();\n+    list.add(LatestByOffset.createStruct(STRUCT_LONG, 321L));\n+\n+    // When:\n+    List<Struct> res = udaf.aggregate(123L, list);\n+\n+    assertThat(list.size(), is(2));\n+    // Then:\n+    assertThat(res.get(0).get(VAL_FIELD), is(321L));\n+    assertThat(res.get(1).get(VAL_FIELD), is(123L));\n+\n+  }\n \n   @Test\n   public void shouldComputeLatestDouble() {\n     // Given:\n     final Udaf<Double, Struct, Double> udaf = LatestByOffset.latestDouble();\n \n     // When:\n-    Struct res = udaf\n-        .aggregate(1.1d, LatestByOffset.createStruct(STRUCT_DOUBLE, 2.2d));\n+    Struct res = udaf.aggregate(1.1d, LatestByOffset.createStruct(STRUCT_DOUBLE, 2.2d));\n \n     // Then:\n     assertThat(res.getFloat64(VAL_FIELD), is(1.1d));\n   }\n+  \n+  @Test\n+  public void shouldComputeLatest2Doubles() {\n+    // Given:\n+    final Udaf<Double, List<Struct>, List<Double>> udaf = LatestByOffset.latestDouble(2);\n+\n+    List<Struct> list = new ArrayList<>();\n+    list.add(LatestByOffset.createStruct(STRUCT_DOUBLE, 2.2d));\n+\n+    // When:\n+    List<Struct> res = udaf.aggregate(1.1d, list);\n+\n+    assertThat(list.size(), is(2));\n+    // Then:\n+    assertThat(res.get(0).get(VAL_FIELD), is(2.2d));\n+    assertThat(res.get(1).get(VAL_FIELD), is(1.1d));\n+\n+  }\n \n   @Test\n   public void shouldComputeLatestBoolean() {\n     // Given:\n     final Udaf<Boolean, Struct, Boolean> udaf = LatestByOffset.latestBoolean();\n \n     // When:\n-    Struct res = udaf\n-        .aggregate(true, LatestByOffset.createStruct(STRUCT_BOOLEAN, false));\n+    Struct res = udaf.aggregate(true, LatestByOffset.createStruct(STRUCT_BOOLEAN, false));\n \n     // Then:\n     assertThat(res.getBoolean(VAL_FIELD), is(true));\n   }\n+  \n+  @Test\n+  public void shouldComputeLatest2Booleans() {\n+    // Given:\n+    final Udaf<Boolean, List<Struct>, List<Boolean>> udaf = LatestByOffset.latestBoolean(2);\n+\n+    List<Struct> list = new ArrayList<>();\n+    list.add(LatestByOffset.createStruct(STRUCT_BOOLEAN, true));\n+\n+    // When:\n+    List<Struct> res = udaf.aggregate(false, list);\n+\n+    assertThat(list.size(), is(2));\n+    // Then:\n+    assertThat(res.get(0).get(VAL_FIELD), is(true));\n+    assertThat(res.get(1).get(VAL_FIELD), is(false));\n+\n+  }\n \n   @Test\n   public void shouldComputeLatestString() {\n     // Given:\n     final Udaf<String, Struct, String> udaf = LatestByOffset.latestString();\n \n     // When:\n-    Struct res = udaf\n-        .aggregate(\"foo\", LatestByOffset.createStruct(STRUCT_STRING, \"bar\"));\n+    Struct res = udaf.aggregate(\"foo\", LatestByOffset.createStruct(STRUCT_STRING, \"bar\"));", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkxNTAyNA==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469915024", "bodyText": "nit: can be private.", "author": "big-andy-coates", "createdAt": "2020-08-13T12:30:12Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java", "diffHunk": "@@ -28,53 +27,86 @@\n import io.confluent.ksql.function.udaf.UdafDescription;\n import io.confluent.ksql.function.udaf.UdafFactory;\n import io.confluent.ksql.util.KsqlConstants;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Collectors;\n import org.apache.kafka.connect.data.Schema;\n import org.apache.kafka.connect.data.Struct;\n \n-@UdafDescription(\n-    name = \"EARLIEST_BY_OFFSET\",\n-    description = EarliestByOffset.DESCRIPTION,\n-    author = KsqlConstants.CONFLUENT_AUTHOR\n-)\n+@UdafDescription(name = \"EARLIEST_BY_OFFSET\", description = EarliestByOffset.DESCRIPTION,\n+    author = KsqlConstants.CONFLUENT_AUTHOR)\n public final class EarliestByOffset {\n   static final String DESCRIPTION =\n-      \"This function returns the oldest value for the column, computed by offset.\";\n+      \"This function returns the oldest N value for the column, computed by offset.\";\n \n-  private EarliestByOffset() {\n-  }\n+  private EarliestByOffset() {}\n \n   static AtomicLong sequence = new AtomicLong();\n \n+  static final Comparator<Struct> structComparator = new EarliestStructComparator();", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkxNTA2OA==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469915068", "bodyText": "nit: can be private.", "author": "big-andy-coates", "createdAt": "2020-08-13T12:30:17Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/LatestByOffset.java", "diffHunk": "@@ -40,43 +45,75 @@\n public final class LatestByOffset {\n \n   static final String DESCRIPTION =\n-      \"This function returns the most recent value for the column, computed by offset.\";\n+      \"This function returns the most recent n values for the column, computed by offset.\";\n \n   private LatestByOffset() {\n   }\n \n   static AtomicLong sequence = new AtomicLong();\n+  \n+  static final Comparator<Struct> structComparator  = new LatestStructComparator();", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkxNzc2Ng==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469917766", "bodyText": "Can I request two changes to each of these new methods please?\n\nCan we make these new methods plural, please? e.g. earliestIntegers given they return multiple. (The method name can be logged in some places and this will help differentiate from the existing method).\nCan we rename the parameter topNSize to something like earliestN?. (The parameter is output during a DESCRIBE of the function and this name is more intuitive.  topNSize suggests functionality akin to TOPK method, which this is not).\n\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public static Udaf<Integer, List<Struct>, List<Integer>> earliestInteger(final int topNSize) {\n          \n          \n            \n              public static Udaf<Integer, List<Struct>, List<Integer>> earliestIntegers(final int earliestN) {\n          \n      \n    \n    \n  \n\nCan you make the same changes to each of the methods in this class and LatestByOffset please, (obviously changing the param to latestN.", "author": "big-andy-coates", "createdAt": "2020-08-13T12:35:17Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java", "diffHunk": "@@ -28,53 +27,86 @@\n import io.confluent.ksql.function.udaf.UdafDescription;\n import io.confluent.ksql.function.udaf.UdafFactory;\n import io.confluent.ksql.util.KsqlConstants;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Collectors;\n import org.apache.kafka.connect.data.Schema;\n import org.apache.kafka.connect.data.Struct;\n \n-@UdafDescription(\n-    name = \"EARLIEST_BY_OFFSET\",\n-    description = EarliestByOffset.DESCRIPTION,\n-    author = KsqlConstants.CONFLUENT_AUTHOR\n-)\n+@UdafDescription(name = \"EARLIEST_BY_OFFSET\", description = EarliestByOffset.DESCRIPTION,\n+    author = KsqlConstants.CONFLUENT_AUTHOR)\n public final class EarliestByOffset {\n   static final String DESCRIPTION =\n-      \"This function returns the oldest value for the column, computed by offset.\";\n+      \"This function returns the oldest N value for the column, computed by offset.\";\n \n-  private EarliestByOffset() {\n-  }\n+  private EarliestByOffset() {}\n \n   static AtomicLong sequence = new AtomicLong();\n \n+  static final Comparator<Struct> structComparator = new EarliestStructComparator();\n+\n   @UdafFactory(description = \"return the earliest value of an integer column\",\n       aggregateSchema = \"STRUCT<SEQ BIGINT, VAL INT>\")\n   public static Udaf<Integer, Struct, Integer> earliestInteger() {\n     return earliest(STRUCT_INTEGER);\n   }\n \n+  @UdafFactory(description = \"return the earliest n values of an integer column\",\n+      aggregateSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL INT>>\")\n+  public static Udaf<Integer, List<Struct>, List<Integer>> earliestInteger(final int topNSize) {", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkxODAwOQ==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469918009", "bodyText": "Bug!\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                return earliestN(STRUCT_LONG, 2);\n          \n          \n            \n                return earliestN(STRUCT_LONG, topNSize);", "author": "big-andy-coates", "createdAt": "2020-08-13T12:35:45Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java", "diffHunk": "@@ -28,53 +27,86 @@\n import io.confluent.ksql.function.udaf.UdafDescription;\n import io.confluent.ksql.function.udaf.UdafFactory;\n import io.confluent.ksql.util.KsqlConstants;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Collectors;\n import org.apache.kafka.connect.data.Schema;\n import org.apache.kafka.connect.data.Struct;\n \n-@UdafDescription(\n-    name = \"EARLIEST_BY_OFFSET\",\n-    description = EarliestByOffset.DESCRIPTION,\n-    author = KsqlConstants.CONFLUENT_AUTHOR\n-)\n+@UdafDescription(name = \"EARLIEST_BY_OFFSET\", description = EarliestByOffset.DESCRIPTION,\n+    author = KsqlConstants.CONFLUENT_AUTHOR)\n public final class EarliestByOffset {\n   static final String DESCRIPTION =\n-      \"This function returns the oldest value for the column, computed by offset.\";\n+      \"This function returns the oldest N value for the column, computed by offset.\";\n \n-  private EarliestByOffset() {\n-  }\n+  private EarliestByOffset() {}\n \n   static AtomicLong sequence = new AtomicLong();\n \n+  static final Comparator<Struct> structComparator = new EarliestStructComparator();\n+\n   @UdafFactory(description = \"return the earliest value of an integer column\",\n       aggregateSchema = \"STRUCT<SEQ BIGINT, VAL INT>\")\n   public static Udaf<Integer, Struct, Integer> earliestInteger() {\n     return earliest(STRUCT_INTEGER);\n   }\n \n+  @UdafFactory(description = \"return the earliest n values of an integer column\",\n+      aggregateSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL INT>>\")\n+  public static Udaf<Integer, List<Struct>, List<Integer>> earliestInteger(final int topNSize) {\n+    return earliestN(STRUCT_INTEGER, topNSize);\n+  }\n+\n   @UdafFactory(description = \"return the earliest value of an big integer column\",\n       aggregateSchema = \"STRUCT<SEQ BIGINT, VAL BIGINT>\")\n   public static Udaf<Long, Struct, Long> earliestLong() {\n     return earliest(STRUCT_LONG);\n   }\n+  \n+  @UdafFactory(description = \"return the earliest n values of an long column\",\n+      aggregateSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL BIGINT>>\")\n+  public static Udaf<Long, List<Struct>, List<Long>> earliestLong(final int topNSize) {\n+    return earliestN(STRUCT_LONG, 2);", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkxODE1NA==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469918154", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                return earliestN(STRUCT_BOOLEAN, 2);\n          \n          \n            \n                return earliestN(STRUCT_BOOLEAN, topNSize);", "author": "big-andy-coates", "createdAt": "2020-08-13T12:36:02Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java", "diffHunk": "@@ -28,53 +27,86 @@\n import io.confluent.ksql.function.udaf.UdafDescription;\n import io.confluent.ksql.function.udaf.UdafFactory;\n import io.confluent.ksql.util.KsqlConstants;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Collectors;\n import org.apache.kafka.connect.data.Schema;\n import org.apache.kafka.connect.data.Struct;\n \n-@UdafDescription(\n-    name = \"EARLIEST_BY_OFFSET\",\n-    description = EarliestByOffset.DESCRIPTION,\n-    author = KsqlConstants.CONFLUENT_AUTHOR\n-)\n+@UdafDescription(name = \"EARLIEST_BY_OFFSET\", description = EarliestByOffset.DESCRIPTION,\n+    author = KsqlConstants.CONFLUENT_AUTHOR)\n public final class EarliestByOffset {\n   static final String DESCRIPTION =\n-      \"This function returns the oldest value for the column, computed by offset.\";\n+      \"This function returns the oldest N value for the column, computed by offset.\";\n \n-  private EarliestByOffset() {\n-  }\n+  private EarliestByOffset() {}\n \n   static AtomicLong sequence = new AtomicLong();\n \n+  static final Comparator<Struct> structComparator = new EarliestStructComparator();\n+\n   @UdafFactory(description = \"return the earliest value of an integer column\",\n       aggregateSchema = \"STRUCT<SEQ BIGINT, VAL INT>\")\n   public static Udaf<Integer, Struct, Integer> earliestInteger() {\n     return earliest(STRUCT_INTEGER);\n   }\n \n+  @UdafFactory(description = \"return the earliest n values of an integer column\",\n+      aggregateSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL INT>>\")\n+  public static Udaf<Integer, List<Struct>, List<Integer>> earliestInteger(final int topNSize) {\n+    return earliestN(STRUCT_INTEGER, topNSize);\n+  }\n+\n   @UdafFactory(description = \"return the earliest value of an big integer column\",\n       aggregateSchema = \"STRUCT<SEQ BIGINT, VAL BIGINT>\")\n   public static Udaf<Long, Struct, Long> earliestLong() {\n     return earliest(STRUCT_LONG);\n   }\n+  \n+  @UdafFactory(description = \"return the earliest n values of an long column\",\n+      aggregateSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL BIGINT>>\")\n+  public static Udaf<Long, List<Struct>, List<Long>> earliestLong(final int topNSize) {\n+    return earliestN(STRUCT_LONG, 2);\n+  }\n \n   @UdafFactory(description = \"return the earliest value of a double column\",\n       aggregateSchema = \"STRUCT<SEQ BIGINT, VAL DOUBLE>\")\n   public static Udaf<Double, Struct, Double> earliestDouble() {\n     return earliest(STRUCT_DOUBLE);\n   }\n+  \n+  @UdafFactory(description = \"return the earliest n values of a double column\",\n+      aggregateSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL DOUBLE>>\")\n+  public static Udaf<Double, List<Struct>, List<Double>> earliestDouble(final int topNSize) {\n+    return earliestN(STRUCT_DOUBLE, topNSize);\n+  }\n \n   @UdafFactory(description = \"return the earliest value of a boolean column\",\n       aggregateSchema = \"STRUCT<SEQ BIGINT, VAL BOOLEAN>\")\n   public static Udaf<Boolean, Struct, Boolean> earliestBoolean() {\n     return earliest(STRUCT_BOOLEAN);\n   }\n+  \n+  @UdafFactory(description = \"return the earliest n values of a boolean column\",\n+      aggregateSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL BOOLEAN>>\")\n+  public static Udaf<Boolean, List<Struct>, List<Boolean>> earliestBoolean(final int topNSize) {\n+    return earliestN(STRUCT_BOOLEAN, 2);", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkyMDUxMQ==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469920511", "bodyText": "Can preallocate and also don't need the generics:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return new ArrayList<Struct>();\n          \n          \n            \n                    return new ArrayList<>(topNSize);", "author": "big-andy-coates", "createdAt": "2020-08-13T12:40:14Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java", "diffHunk": "@@ -123,4 +155,54 @@ public T map(final Struct agg) {\n       }\n     };\n   }\n+\n+\n+  @UdafFactory(description = \"Earliest N by offset\")\n+  static <T> Udaf<T, List<Struct>, List<T>> earliestN(final Schema structSchema,\n+      final int topNSize) {\n+    return new Udaf<T, List<Struct>, List<T>>() {\n+      @Override\n+      public List<Struct> initialize() {\n+        return new ArrayList<Struct>();", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkyNTAxMA==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469925010", "bodyText": "Formatting + subList call isn't needed.\nHow about:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  @Override\n          \n          \n            \n                  public List<Struct> aggregate(final T current, final List<Struct> aggregate) {\n          \n          \n            \n                    final int currentSize = aggregate.size();\n          \n          \n            \n                    if (currentSize == topNSize) {\n          \n          \n            \n                      return aggregate;\n          \n          \n            \n                    } else {\n          \n          \n            \n            \n          \n          \n            \n                      if (current == null) {\n          \n          \n            \n                        return aggregate;\n          \n          \n            \n                      }\n          \n          \n            \n            \n          \n          \n            \n                      aggregate.add(createStruct(structSchema, current));\n          \n          \n            \n                      return aggregate.subList(0, aggregate.size());\n          \n          \n            \n                    }\n          \n          \n            \n            \n          \n          \n            \n            \n          \n          \n            \n                  }\n          \n          \n            \n                  @Override\n          \n          \n            \n                  public List<Struct> aggregate(final T current, final List<Struct> aggregate) {\n          \n          \n            \n                    if (current == null) {\n          \n          \n            \n                      return aggregate;\n          \n          \n            \n                    }\n          \n          \n            \n            \n          \n          \n            \n                    if (aggregate.size() < topNSize) {\n          \n          \n            \n                      aggregate.add(createStruct(structSchema, current));\n          \n          \n            \n                    }\n          \n          \n            \n            \n          \n          \n            \n                    return aggregate;\n          \n          \n            \n                  }", "author": "big-andy-coates", "createdAt": "2020-08-13T12:47:48Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java", "diffHunk": "@@ -123,4 +155,54 @@ public T map(final Struct agg) {\n       }\n     };\n   }\n+\n+\n+  @UdafFactory(description = \"Earliest N by offset\")\n+  static <T> Udaf<T, List<Struct>, List<T>> earliestN(final Schema structSchema,\n+      final int topNSize) {\n+    return new Udaf<T, List<Struct>, List<T>>() {\n+      @Override\n+      public List<Struct> initialize() {\n+        return new ArrayList<Struct>();\n+      }\n+\n+      @Override\n+      public List<Struct> aggregate(final T current, final List<Struct> aggregate) {\n+        final int currentSize = aggregate.size();\n+        if (currentSize == topNSize) {\n+          return aggregate;\n+        } else {\n+\n+          if (current == null) {\n+            return aggregate;\n+          }\n+\n+          aggregate.add(createStruct(structSchema, current));\n+          return aggregate.subList(0, aggregate.size());\n+        }\n+\n+\n+      }", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkyNTUyMQ==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469925521", "bodyText": "Not required - this line can be deleted. This is not a UDAF factory. (The function above you copied is wrong too in case you were wondering).", "author": "big-andy-coates", "createdAt": "2020-08-13T12:48:41Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java", "diffHunk": "@@ -123,4 +155,54 @@ public T map(final Struct agg) {\n       }\n     };\n   }\n+\n+\n+  @UdafFactory(description = \"Earliest N by offset\")", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYxNDM5Ng==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r470614396", "bodyText": "will remove. it was in the original methods for earliest() and latest(). will remove those too.", "author": "sarwarbhuiyan", "createdAt": "2020-08-14T13:11:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkyNTUyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkzNDMyMg==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469934322", "bodyText": "Can pre-allocate the array and simplify the code:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  @Override\n          \n          \n            \n                  public List<Struct> merge(final List<Struct> aggOne, final List<Struct> aggTwo) {\n          \n          \n            \n                    final List<Struct> merged = new ArrayList<>();\n          \n          \n            \n                    merged.addAll(aggOne);\n          \n          \n            \n                    merged.addAll(aggTwo);\n          \n          \n            \n                    final int currentSize = merged.size();\n          \n          \n            \n                    Collections.sort(merged, structComparator);\n          \n          \n            \n                    if (currentSize <= topNSize) {\n          \n          \n            \n                      return merged;\n          \n          \n            \n                    } else {\n          \n          \n            \n                      return merged.subList(0, topNSize);\n          \n          \n            \n                    }\n          \n          \n            \n                  }\n          \n          \n            \n                  @Override\n          \n          \n            \n                  public List<Struct> merge(final List<Struct> aggOne, final List<Struct> aggTwo) {\n          \n          \n            \n                    final List<Struct> merged = new ArrayList<>(aggOne.size() + aggTwo.size());\n          \n          \n            \n                    merged.addAll(aggOne);\n          \n          \n            \n                    merged.addAll(aggTwo);\n          \n          \n            \n                    merged.sort(structComparator);\n          \n          \n            \n                    return merged.subList(0, Math.min(topNSize, merged.size()));\n          \n          \n            \n                  }\n          \n      \n    \n    \n  \n\nPlus, I noticed there's not test to cover the code path where the merged array is smaller than topNSize. Worth adding that.", "author": "big-andy-coates", "createdAt": "2020-08-13T13:03:23Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java", "diffHunk": "@@ -123,4 +155,54 @@ public T map(final Struct agg) {\n       }\n     };\n   }\n+\n+\n+  @UdafFactory(description = \"Earliest N by offset\")\n+  static <T> Udaf<T, List<Struct>, List<T>> earliestN(final Schema structSchema,\n+      final int topNSize) {\n+    return new Udaf<T, List<Struct>, List<T>>() {\n+      @Override\n+      public List<Struct> initialize() {\n+        return new ArrayList<Struct>();\n+      }\n+\n+      @Override\n+      public List<Struct> aggregate(final T current, final List<Struct> aggregate) {\n+        final int currentSize = aggregate.size();\n+        if (currentSize == topNSize) {\n+          return aggregate;\n+        } else {\n+\n+          if (current == null) {\n+            return aggregate;\n+          }\n+\n+          aggregate.add(createStruct(structSchema, current));\n+          return aggregate.subList(0, aggregate.size());\n+        }\n+\n+\n+      }\n+\n+      @Override\n+      public List<Struct> merge(final List<Struct> aggOne, final List<Struct> aggTwo) {\n+        final List<Struct> merged = new ArrayList<>();\n+        merged.addAll(aggOne);\n+        merged.addAll(aggTwo);\n+        final int currentSize = merged.size();\n+        Collections.sort(merged, structComparator);\n+        if (currentSize <= topNSize) {\n+          return merged;\n+        } else {\n+          return merged.subList(0, topNSize);\n+        }\n+      }", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYxOTQ0NQ==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r470619445", "bodyText": "added", "author": "sarwarbhuiyan", "createdAt": "2020-08-14T13:21:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkzNDMyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk0NTE0MQ==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469945141", "bodyText": "This class is duplicate LatestStructComparator, i.e. the code is the same!  And the function below duplicates the exist KudafByOffsetUtils.compareStructs.\nCan I suggest deleting these two new comparator files, and instead replacing the compareStructs method in KudafByOffsetUtils with a comparator, e.g.\nclass  KudafByOffsetUtils {\n  ...\n  public static final Comparator<Struct> INTERMEDIATE_STRUCT_COMPARATOR = (struct1, struct2) -> {\n    // Deal with overflow - we assume if one is positive and the other negative then the sequence\n    // has overflowed - in which case the latest is the one with the smallest sequence\n    final long sequence1 = struct1.getInt64(SEQ_FIELD);\n    final long sequence2 = struct2.getInt64(SEQ_FIELD);\n    if (sequence1 < 0 && sequence2 >= 0) {\n      return 1;\n    } else if (sequence2 < 0 && sequence1 >= 0) {\n      return -1;\n    } else {\n      return Long.compare(sequence1, sequence2);\n    }\n  };\n  ...\n}\nAnd then use this everywhere, including replacing the current use of compareStructs with INTERMEDIATE_STRUCT_COMPARATOR.compare.", "author": "big-andy-coates", "createdAt": "2020-08-13T13:20:11Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestStructComparator.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ * Copyright 2019 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.function.udaf.offset;\n+\n+import static io.confluent.ksql.function.udaf.KudafByOffsetUtils.SEQ_FIELD;\n+\n+import java.io.Serializable;\n+import java.util.Comparator;\n+import org.apache.kafka.connect.data.Struct;\n+\n+public class EarliestStructComparator implements Comparator<Struct>, Serializable {", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDYxOTYyNw==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r470619627", "bodyText": "done", "author": "sarwarbhuiyan", "createdAt": "2020-08-14T13:21:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk0NTE0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk0NTYwMg==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469945602", "bodyText": "As above, delete this.", "author": "big-andy-coates", "createdAt": "2020-08-13T13:20:53Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/LatestStructComparator.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"; you may not use\n+ * this file except in compliance with the License. You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.function.udaf.offset;\n+\n+import static io.confluent.ksql.function.udaf.KudafByOffsetUtils.SEQ_FIELD;\n+\n+import java.io.Serializable;\n+import java.util.Comparator;\n+import org.apache.kafka.connect.data.Struct;\n+\n+public class LatestStructComparator implements Comparator<Struct>, Serializable {", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk0NjI5NA==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469946294", "bodyText": "Same changes to the new functions in this file, as were done to the ones in EarliestByOffset, i.e. plural method names and param names changes to latestN.", "author": "big-andy-coates", "createdAt": "2020-08-13T13:21:53Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/LatestByOffset.java", "diffHunk": "@@ -40,43 +45,75 @@\n public final class LatestByOffset {\n \n   static final String DESCRIPTION =\n-      \"This function returns the most recent value for the column, computed by offset.\";\n+      \"This function returns the most recent n values for the column, computed by offset.\";\n \n   private LatestByOffset() {\n   }\n \n   static AtomicLong sequence = new AtomicLong();\n+  \n+  static final Comparator<Struct> structComparator  = new LatestStructComparator();\n \n   @UdafFactory(description = \"return the latest value of an integer column\",\n       aggregateSchema = \"STRUCT<SEQ BIGINT, VAL INT>\")\n   public static Udaf<Integer, Struct, Integer> latestInteger() {\n     return latest(STRUCT_INTEGER);\n   }\n+  \n+  @UdafFactory(description = \"return the latest value of an integer column\",\n+      aggregateSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL INT>>\")\n+  public static Udaf<Integer, List<Struct>, List<Integer>> latestInteger(final int topNSize) {\n+    return latestN(STRUCT_INTEGER, topNSize);\n+  }", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk0NzU2Mg==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469947562", "bodyText": "We'd want to validate topNSize (please add unit test for this too):\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              static <T> Udaf<T, List<Struct>, List<T>> earliestN(final Schema structSchema,\n          \n          \n            \n                  final int topNSize) {\n          \n          \n            \n                return new Udaf<T, List<Struct>, List<T>>() {\n          \n          \n            \n              static <T> Udaf<T, List<Struct>, List<T>> earliestN(\n          \n          \n            \n                  final Schema structSchema,\n          \n          \n            \n                  final int earliestN\n          \n          \n            \n                ) {\n          \n          \n            \n                \n          \n          \n            \n                if (earliestN <= 0) {\n          \n          \n            \n                  throw new KsqlFunctionException(\"earliestN must be 1 or greater\");\n          \n          \n            \n                }\n          \n          \n            \n                \n          \n          \n            \n                return new Udaf<T, List<Struct>, List<T>>() {", "author": "big-andy-coates", "createdAt": "2020-08-13T13:23:55Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java", "diffHunk": "@@ -123,4 +155,54 @@ public T map(final Struct agg) {\n       }\n     };\n   }\n+\n+\n+  @UdafFactory(description = \"Earliest N by offset\")\n+  static <T> Udaf<T, List<Struct>, List<T>> earliestN(final Schema structSchema,\n+      final int topNSize) {\n+    return new Udaf<T, List<Struct>, List<T>>() {", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA0ODkxOQ==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r470048919", "bodyText": "Good point. Should there be an upper limit too?", "author": "sarwarbhuiyan", "createdAt": "2020-08-13T15:45:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk0NzU2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk0ODE2NQ==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469948165", "bodyText": "Please make corresponding changes to this code, as were suggested for the EarliestByOffset code.", "author": "big-andy-coates", "createdAt": "2020-08-13T13:24:50Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/LatestByOffset.java", "diffHunk": "@@ -124,5 +161,50 @@ public T map(final Struct agg) {\n       }\n     };\n   }\n+  \n+  @UdafFactory(description = \"Latest N by offset\")\n+  static <T> Udaf<T, List<Struct>, List<T>> latestN(final Schema structSchema, final int topNSize) {\n+    return new Udaf<T, List<Struct>, List<T>>() {\n+      @Override\n+      public List<Struct> initialize() {\n+        return new ArrayList<Struct>();\n+      }\n+\n+      @Override\n+      public List<Struct> aggregate(final T current, final List<Struct> aggregate) {\n+        if (current == null) {\n+          return aggregate;\n+        }\n+\n+        aggregate.add(createStruct(structSchema, current));\n+        final int currentSize = aggregate.size();\n+        if (currentSize <= topNSize) {\n+          return aggregate;\n+        } else {\n+          return aggregate.subList(currentSize - topNSize, currentSize);\n+        }\n+      }\n+\n+      @Override\n+      public List<Struct> merge(final List<Struct> aggOne, final List<Struct> aggTwo) {\n+        final List<Struct> merged = new ArrayList<>();\n+        merged.addAll(aggOne);\n+        merged.addAll(aggTwo);\n+        final int currentSize = merged.size();\n+        Collections.sort(merged, structComparator);\n+        if (currentSize <= topNSize) {\n+          return merged;\n+        } else {\n+          return merged.subList(currentSize - topNSize, currentSize);\n+        }\n+      }\n+\n+      @Override\n+      @SuppressWarnings(\"unchecked\")\n+      public List<T> map(final List<Struct> agg) {\n+        return (List<T>) agg.stream().map(s -> s.get(VAL_FIELD)).collect(Collectors.toList());\n+      }\n+    };\n+  }", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk1MDQyNA==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469950424", "bodyText": "FYI: Just Arrays.asList needed. No need for the new ArrayList<>( bit.", "author": "big-andy-coates", "createdAt": "2020-08-13T13:28:17Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/EarliestByOffsetUdafTest.java", "diffHunk": "@@ -55,6 +70,29 @@ public void shouldComputeEarliestInteger() {\n \n     // Then:\n     assertThat(res.get(VAL_FIELD), is(321));\n+  }\n+  \n+  @Test\n+  public void shouldComputeEarliest2Integers() {\n+    // Given:\n+    final Udaf<Integer, List<Struct>, List<Integer>> udaf = EarliestByOffset.earliestInteger(2);\n+\n+    // When:\n+    List<Struct> res = udaf\n+        .aggregate(123, new ArrayList<>(Arrays.asList(EarliestByOffset.createStruct(STRUCT_INTEGER, 321))));", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk1MjU4NA==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469952584", "bodyText": "Probably better structured as two tests:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              @Test\n          \n          \n            \n              public void shouldComputeEarliest2Integers() {\n          \n          \n            \n                // Given:\n          \n          \n            \n                final Udaf<Integer, List<Struct>, List<Integer>> udaf = EarliestByOffset.earliestInteger(2);\n          \n          \n            \n            \n          \n          \n            \n                // When:\n          \n          \n            \n                List<Struct> res = udaf\n          \n          \n            \n                    .aggregate(123, new ArrayList<>(Arrays.asList(EarliestByOffset.createStruct(STRUCT_INTEGER, 321))));\n          \n          \n            \n            \n          \n          \n            \n                // Then:\n          \n          \n            \n                assertThat(res.get(0).get(VAL_FIELD), is(321));\n          \n          \n            \n                assertThat(res.get(1).get(VAL_FIELD), is(123));\n          \n          \n            \n                \n          \n          \n            \n                List<Struct> res2 = udaf\n          \n          \n            \n                    .aggregate(543, res);\n          \n          \n            \n                assertThat(res2.size(), is(2));\n          \n          \n            \n                assertThat(res2.get(0).get(VAL_FIELD), is(321));\n          \n          \n            \n                assertThat(res2.get(1).get(VAL_FIELD), is(123));\n          \n          \n            \n                \n          \n          \n            \n                \n          \n          \n            \n                \n          \n          \n            \n            @Test\n          \n          \n            \n              public void shouldCaptureValuesUpToN() {\n          \n          \n            \n                // Given:\n          \n          \n            \n                final Udaf<Integer, List<Struct>, List<Integer>> udaf = EarliestByOffset.earliestInteger(2);\n          \n          \n            \n            \n          \n          \n            \n                // When:\n          \n          \n            \n                List<Struct> res0 = udaf.aggregate(321, new ArrayList<>());\n          \n          \n            \n                List<Struct> res1 = udaf.aggregate(123, res0);\n          \n          \n            \n            \n          \n          \n            \n                assertThat(res1, hasSize(2));\n          \n          \n            \n                assertThat(res1.get(0).get(VAL_FIELD), is(321));\n          \n          \n            \n                assertThat(res1.get(1).get(VAL_FIELD), is(123));\n          \n          \n            \n              }\n          \n          \n            \n            \n          \n          \n            \n              @Test\n          \n          \n            \n              public void shouldIgnoreValuesPastN() {\n          \n          \n            \n                // Given:\n          \n          \n            \n                final Udaf<Integer, List<Struct>, List<Integer>> udaf = EarliestByOffset.earliestInteger(2);\n          \n          \n            \n            \n          \n          \n            \n                final List<Struct> aggregate = Arrays.asList(\n          \n          \n            \n                    EarliestByOffset.createStruct(STRUCT_INTEGER, 10),\n          \n          \n            \n                    EarliestByOffset.createStruct(STRUCT_INTEGER, 3)\n          \n          \n            \n                );\n          \n          \n            \n            \n          \n          \n            \n                // When:\n          \n          \n            \n                final List<Struct> result = udaf.aggregate(2, aggregate);\n          \n          \n            \n            \n          \n          \n            \n                assertThat(result, hasSize(2));\n          \n          \n            \n                assertThat(result.get(0).get(VAL_FIELD), is(10));\n          \n          \n            \n                assertThat(result.get(1).get(VAL_FIELD), is(3));\n          \n          \n            \n              }```", "author": "big-andy-coates", "createdAt": "2020-08-13T13:31:14Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/EarliestByOffsetUdafTest.java", "diffHunk": "@@ -55,6 +70,29 @@ public void shouldComputeEarliestInteger() {\n \n     // Then:\n     assertThat(res.get(VAL_FIELD), is(321));\n+  }\n+  \n+  @Test\n+  public void shouldComputeEarliest2Integers() {\n+    // Given:\n+    final Udaf<Integer, List<Struct>, List<Integer>> udaf = EarliestByOffset.earliestInteger(2);\n+\n+    // When:\n+    List<Struct> res = udaf\n+        .aggregate(123, new ArrayList<>(Arrays.asList(EarliestByOffset.createStruct(STRUCT_INTEGER, 321))));\n+\n+    // Then:\n+    assertThat(res.get(0).get(VAL_FIELD), is(321));\n+    assertThat(res.get(1).get(VAL_FIELD), is(123));\n+    \n+    List<Struct> res2 = udaf\n+        .aggregate(543, res);\n+    assertThat(res2.size(), is(2));\n+    assertThat(res2.get(0).get(VAL_FIELD), is(321));\n+    assertThat(res2.get(1).get(VAL_FIELD), is(123));\n+    \n+    \n+    ", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk2MDAyNg==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469960026", "bodyText": "A better test would be if the structs in each parameter had interleaved sequence numbers, as this ensures the sort is happening:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              @Test\n          \n          \n            \n              public void shouldMerge2Integers() {\n          \n          \n            \n                // Given:\n          \n          \n            \n                final Udaf<Integer, List<Struct>, List<Integer>> udaf = EarliestByOffset.earliestInteger(2);\n          \n          \n            \n            \n          \n          \n            \n                Struct struct1 = EarliestByOffset.createStruct(STRUCT_INTEGER, 123);\n          \n          \n            \n                Struct struct2 = EarliestByOffset.createStruct(STRUCT_INTEGER, 321);\n          \n          \n            \n                List<Struct> agg1 = new ArrayList<>(Arrays.asList(struct1, struct2));\n          \n          \n            \n                \n          \n          \n            \n                Struct struct3 = EarliestByOffset.createStruct(STRUCT_INTEGER, 543);\n          \n          \n            \n                Struct struct4 = EarliestByOffset.createStruct(STRUCT_INTEGER, 654);\n          \n          \n            \n                List<Struct> agg2 = new ArrayList<>(Arrays.asList(struct3, struct4));\n          \n          \n            \n                \n          \n          \n            \n                // When:\n          \n          \n            \n                List<Struct> merged1 = udaf.merge(agg1, agg2);\n          \n          \n            \n                List<Struct> merged2 = udaf.merge(agg2, agg1);\n          \n          \n            \n            \n          \n          \n            \n                // Then:\n          \n          \n            \n                assertThat(merged1, is(agg1));\n          \n          \n            \n                assertThat(merged2, is(agg1));\n          \n          \n            \n              }\n          \n          \n            \n              @Test\n          \n          \n            \n              public void shouldMergeIntegers() {\n          \n          \n            \n                // Given:\n          \n          \n            \n                final Udaf<Integer, List<Struct>, List<Integer>> udaf = EarliestByOffset.earliestInteger(2);\n          \n          \n            \n            \n          \n          \n            \n                final Struct struct1 = EarliestByOffset.createStruct(STRUCT_INTEGER, 123);\n          \n          \n            \n                final Struct struct2 = EarliestByOffset.createStruct(STRUCT_INTEGER, 321);\n          \n          \n            \n                final Struct struct3 = EarliestByOffset.createStruct(STRUCT_INTEGER, 543);\n          \n          \n            \n                final Struct struct4 = EarliestByOffset.createStruct(STRUCT_INTEGER, 654);\n          \n          \n            \n                final List<Struct> agg1 = new ArrayList<>(Arrays.asList(struct1, struct4));\n          \n          \n            \n                final List<Struct> agg2 = new ArrayList<>(Arrays.asList(struct2, struct3));\n          \n          \n            \n                \n          \n          \n            \n                // When:\n          \n          \n            \n                final List<Struct> merged1 = udaf.merge(agg1, agg2);\n          \n          \n            \n                final List<Struct> merged2 = udaf.merge(agg2, agg1);\n          \n          \n            \n            \n          \n          \n            \n                // Then:\n          \n          \n            \n                assertThat(merged1, contains(struct1, struct2));\n          \n          \n            \n                assertThat(merged2, contains(struct1, struct2));\n          \n          \n            \n              }", "author": "big-andy-coates", "createdAt": "2020-08-13T13:42:01Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/EarliestByOffsetUdafTest.java", "diffHunk": "@@ -73,6 +111,28 @@ public void shouldMerge() {\n     assertThat(merged1, is(agg1));\n     assertThat(merged2, is(agg1));\n   }\n+  \n+  @Test\n+  public void shouldMerge2Integers() {\n+    // Given:\n+    final Udaf<Integer, List<Struct>, List<Integer>> udaf = EarliestByOffset.earliestInteger(2);\n+\n+    Struct struct1 = EarliestByOffset.createStruct(STRUCT_INTEGER, 123);\n+    Struct struct2 = EarliestByOffset.createStruct(STRUCT_INTEGER, 321);\n+    List<Struct> agg1 = new ArrayList<>(Arrays.asList(struct1, struct2));\n+    \n+    Struct struct3 = EarliestByOffset.createStruct(STRUCT_INTEGER, 543);\n+    Struct struct4 = EarliestByOffset.createStruct(STRUCT_INTEGER, 654);\n+    List<Struct> agg2 = new ArrayList<>(Arrays.asList(struct3, struct4));\n+    \n+    // When:\n+    List<Struct> merged1 = udaf.merge(agg1, agg2);\n+    List<Struct> merged2 = udaf.merge(agg2, agg1);\n+\n+    // Then:\n+    assertThat(merged1, is(agg1));\n+    assertThat(merged2, is(agg1));\n+  }", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk2MDkwOA==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469960908", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public void shouldComputeEarliest2Longs() {\n          \n          \n            \n              public void shouldComputeEarliestLongs() {\n          \n      \n    \n    \n  \n\nSame for other new methods.", "author": "big-andy-coates", "createdAt": "2020-08-13T13:43:15Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/EarliestByOffsetUdafTest.java", "diffHunk": "@@ -108,6 +194,26 @@ public void shouldComputeEarliestLong() {\n     // Then:\n     assertThat(res.getInt64(VAL_FIELD), is(321L));\n   }\n+  \n+  @Test\n+  public void shouldComputeEarliest2Longs() {", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk2MTUzOA==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469961538", "bodyText": "Consider changing the value of earlestN, so not all tests use 2.  Alternate between 1, 2 & 3, maybe?", "author": "big-andy-coates", "createdAt": "2020-08-13T13:44:09Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/EarliestByOffsetUdafTest.java", "diffHunk": "@@ -108,6 +194,26 @@ public void shouldComputeEarliestLong() {\n     // Then:\n     assertThat(res.getInt64(VAL_FIELD), is(321L));\n   }\n+  \n+  @Test\n+  public void shouldComputeEarliest2Longs() {\n+    // Given:\n+    final Udaf<Long, List<Struct>, List<Long>> udaf = EarliestByOffset.earliestLong(2);", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk2MjI1MQ==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r469962251", "bodyText": "Apply same changes to this file as were made to the EarliestByOffsetTest file.", "author": "big-andy-coates", "createdAt": "2020-08-13T13:45:08Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java", "diffHunk": "@@ -45,19 +45,48 @@ public void shouldInitialize() {\n     assertThat(init, is(notNullValue()));\n   }\n \n+  @Test", "originalCommit": "f0ff29dca7ce4c5e2001ff9c4a3495ece9d60552", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6fae7bd11c4ebdc00c542d772caeb9f9fa6f07e1", "url": "https://github.com/confluentinc/ksql/commit/6fae7bd11c4ebdc00c542d772caeb9f9fa6f07e1", "message": "Merged code for Latest N", "committedDate": "2020-09-04T16:09:02Z", "type": "commit"}, {"oid": "2bbaf7afb2fc85b5801a5c544f8d9943dc7bc241", "url": "https://github.com/confluentinc/ksql/commit/2bbaf7afb2fc85b5801a5c544f8d9943dc7bc241", "message": "Added explicit paramSchema in @UdafFactory annotation for latestbyoffset udaf", "committedDate": "2020-09-04T16:09:02Z", "type": "commit"}, {"oid": "ed7eb40071f83e22cce5b397bf2d9ce66bcab45d", "url": "https://github.com/confluentinc/ksql/commit/ed7eb40071f83e22cce5b397bf2d9ce66bcab45d", "message": "Removed paramSchema as that had no effect on UDFIndex", "committedDate": "2020-09-04T16:09:02Z", "type": "commit"}, {"oid": "061a26025491be147f2e0df077943c5478ea18ca", "url": "https://github.com/confluentinc/ksql/commit/061a26025491be147f2e0df077943c5478ea18ca", "message": "Updated unit tests and functional tests for LatestByOffset and EarliestByOffset", "committedDate": "2020-09-04T16:09:02Z", "type": "commit"}, {"oid": "c2f37f9bbbb7c46924b0fdcc8e2f70be3249542c", "url": "https://github.com/confluentinc/ksql/commit/c2f37f9bbbb7c46924b0fdcc8e2f70be3249542c", "message": "Fixed tests according to PR review comments", "committedDate": "2020-09-04T18:30:12Z", "type": "commit"}, {"oid": "c2f37f9bbbb7c46924b0fdcc8e2f70be3249542c", "url": "https://github.com/confluentinc/ksql/commit/c2f37f9bbbb7c46924b0fdcc8e2f70be3249542c", "message": "Fixed tests according to PR review comments", "committedDate": "2020-09-04T18:30:12Z", "type": "forcePushed"}, {"oid": "dead8472fa492043ff4652efca08dfa36929e9ea", "url": "https://github.com/confluentinc/ksql/commit/dead8472fa492043ff4652efca08dfa36929e9ea", "message": "Fixed checkstyle errors", "committedDate": "2020-09-07T09:21:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ4NjQ2OQ==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r484486469", "bodyText": "Fix spot bugs issue:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  final Udaf<Integer, List<Struct>, List<Integer>> udaf = EarliestByOffset\n          \n          \n            \n                  EarliestByOffset", "author": "big-andy-coates", "createdAt": "2020-09-07T15:12:17Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/EarliestByOffsetUdafTest.java", "diffHunk": "@@ -23,39 +23,110 @@\n import static io.confluent.ksql.function.udaf.KudafByOffsetUtils.STRUCT_STRING;\n import static io.confluent.ksql.function.udaf.KudafByOffsetUtils.VAL_FIELD;\n import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.hasSize;\n import static org.hamcrest.Matchers.is;\n import static org.hamcrest.Matchers.notNullValue;\n \n+import com.google.common.collect.Lists;\n import io.confluent.ksql.function.udaf.Udaf;\n+import io.confluent.ksql.util.KsqlException;\n+import java.util.ArrayList;\n+import java.util.List;\n import org.apache.kafka.connect.data.Struct;\n import org.junit.Test;\n \n+\n public class EarliestByOffsetUdafTest {\n+  \n   @Test\n   public void shouldInitialize() {\n     // Given:\n-    final Udaf<Integer, Struct, Integer> udaf = EarliestByOffset\n-        .earliest(STRUCT_LONG);\n+    final Udaf<Integer, Struct, Integer> udaf = EarliestByOffset.earliest(STRUCT_LONG);\n \n     // When:\n     Struct init = udaf.initialize();\n \n     // Then:\n     assertThat(init, is(notNullValue()));\n   }\n+  \n+  @Test\n+  public void shouldInitializeN() {\n+    // Given:\n+    final Udaf<Integer, List<Struct>, List<Integer>> udaf = EarliestByOffset.earliestN(STRUCT_LONG, 2);\n+\n+    // When:\n+    List<Struct> init = udaf.initialize();\n+\n+    // Then:\n+    assertThat(init, is(notNullValue()));\n+  }\n+  \n+  @Test\n+  public void shouldThrowExceptionForInvalidN() {\n+    try {\n+      final Udaf<Integer, List<Struct>, List<Integer>> udaf = EarliestByOffset", "originalCommit": "dead8472fa492043ff4652efca08dfa36929e9ea", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ4Njg0NA==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r484486844", "bodyText": "Fix spot bugs issue:\nEither asset the contents of res and res2 or remove them as variables.", "author": "big-andy-coates", "createdAt": "2020-09-07T15:13:06Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java", "diffHunk": "@@ -96,57 +209,146 @@ public void shouldMergeWithOverflow() {\n     assertThat(merged2, is(agg2));\n   }\n \n+  @Test\n+  public void shouldMergeWithOverflowNIntegers() {\n+    // Given:\n+    final Udaf<Integer, List<Struct>, List<Integer>> udaf = LatestByOffset.latestIntegers(2);\n+\n+    LatestByOffset.sequence.set(Long.MAX_VALUE - 1);\n+\n+    Struct struct1 = LatestByOffset.createStruct(STRUCT_INTEGER, 123);\n+    Struct struct2 = LatestByOffset.createStruct(STRUCT_INTEGER, 321);\n+    Struct struct3 = LatestByOffset.createStruct(STRUCT_INTEGER, 543);\n+    Struct struct4 = LatestByOffset.createStruct(STRUCT_INTEGER, 654);\n+    \n+    List<Struct> agg1 = Lists.newArrayList(struct1, struct2);\n+    List<Struct> agg2 = Lists.newArrayList(struct3, struct4);\n+\n+    // When:\n+    final List<Struct> merged1 = udaf.merge(agg1, agg2);\n+    final List<Struct> merged2 = udaf.merge(agg2, agg1);\n+\n+    // Then:\n+    assertThat(agg1.get(0).getInt64(SEQ_FIELD), is(Long.MAX_VALUE - 1));\n+    assertThat(agg2.get(0).getInt64(SEQ_FIELD), is(Long.MIN_VALUE));\n+    assertThat(merged1, contains(struct3, struct4));\n+    assertThat(merged2, contains(struct3, struct4));\n+  }\n \n   @Test\n   public void shouldComputeLatestLong() {\n     // Given:\n     final Udaf<Long, Struct, Long> udaf = LatestByOffset.latestLong();\n \n     // When:\n-    Struct res = udaf\n-        .aggregate(123L, LatestByOffset.createStruct(STRUCT_LONG, 321L));\n+    Struct res = udaf.aggregate(123L, LatestByOffset.createStruct(STRUCT_LONG, 321L));\n \n     // Then:\n     assertThat(res.getInt64(VAL_FIELD), is(123L));\n   }\n+  \n+  @Test\n+  public void shouldComputeLatestNLongs() {\n+    // Given:\n+    final Udaf<Long, List<Struct>, List<Long>> udaf = LatestByOffset.latestLong(3);\n+\n+    // When:\n+    List<Struct> res = udaf\n+        .aggregate(123L, Lists.newArrayList(LatestByOffset.createStruct(STRUCT_LONG, 321L)));\n+    \n+    List<Struct> res2 = udaf\n+        .aggregate(543L, res);\n+    \n+    List<Struct> res3 = udaf\n+        .aggregate(654L, res);", "originalCommit": "dead8472fa492043ff4652efca08dfa36929e9ea", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ4NzAxNA==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r484487014", "bodyText": "Fix spot bugs error:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  final Udaf<Integer, List<Struct>, List<Integer>> udaf = LatestByOffset\n          \n          \n            \n                  LatestByOffset", "author": "big-andy-coates", "createdAt": "2020-09-07T15:13:29Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/function/udaf/offset/LatestByOffsetUdafTest.java", "diffHunk": "@@ -45,19 +51,83 @@ public void shouldInitialize() {\n     assertThat(init, is(notNullValue()));\n   }\n \n+  @Test\n+  public void shouldInitializeLatestN() {\n+    // Given:\n+    final Udaf<Integer, List<Struct>, List<Integer>> udaf = LatestByOffset.latestN(STRUCT_LONG, 2);\n+\n+    // When:\n+    List<Struct> init = udaf.initialize();\n+\n+    // Then:\n+    assertThat(init, is(notNullValue()));\n+  }\n+  \n+  @Test\n+  public void shouldThrowExceptionForInvalidN() {\n+    try {\n+      final Udaf<Integer, List<Struct>, List<Integer>> udaf = LatestByOffset", "originalCommit": "dead8472fa492043ff4652efca08dfa36929e9ea", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ4OTQ4NQ==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r484489485", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  \"This function returns the oldest N value for the column, computed by offset.\";\n          \n          \n            \n                  \"This function returns the oldest N values for the column, computed by offset.\";", "author": "big-andy-coates", "createdAt": "2020-09-07T15:19:10Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java", "diffHunk": "@@ -38,8 +42,9 @@\n     author = KsqlConstants.CONFLUENT_AUTHOR\n )\n public final class EarliestByOffset {\n+\n   static final String DESCRIPTION =\n-      \"This function returns the oldest value for the column, computed by offset.\";\n+      \"This function returns the oldest N value for the column, computed by offset.\";", "originalCommit": "dead8472fa492043ff4652efca08dfa36929e9ea", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ4OTY2OA==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r484489668", "bodyText": "please don't update existing copyright dates", "author": "big-andy-coates", "createdAt": "2020-09-07T15:19:34Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/LatestByOffset.java", "diffHunk": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2019 Confluent Inc.\n+ * Copyright 2020 Confluent Inc.", "originalCommit": "dead8472fa492043ff4652efca08dfa36929e9ea", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ5MDMxNw==", "url": "https://github.com/confluentinc/ksql/pull/6014#discussion_r484490317", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public static Udaf<Boolean, Struct, Boolean> earliestBooleans() {\n          \n          \n            \n              public static Udaf<Boolean, Struct, Boolean> earliestBoolean() {", "author": "big-andy-coates", "createdAt": "2020-09-07T15:21:02Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/function/udaf/offset/EarliestByOffset.java", "diffHunk": "@@ -52,30 +57,60 @@ private EarliestByOffset() {\n     return earliest(STRUCT_INTEGER);\n   }\n \n+  @UdafFactory(description = \"return the earliest N values of an integer column\",\n+      aggregateSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL INT>>\")\n+  public static Udaf<Integer, List<Struct>, List<Integer>> earliestIntegers(final int earliestN) {\n+    return earliestN(STRUCT_INTEGER, earliestN);\n+  }\n+\n   @UdafFactory(description = \"return the earliest value of an big integer column\",\n       aggregateSchema = \"STRUCT<SEQ BIGINT, VAL BIGINT>\")\n   public static Udaf<Long, Struct, Long> earliestLong() {\n     return earliest(STRUCT_LONG);\n   }\n+  \n+  @UdafFactory(description = \"return the earliest N values of an long column\",\n+      aggregateSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL BIGINT>>\")\n+  public static Udaf<Long, List<Struct>, List<Long>> earliestLongs(final int earliestN) {\n+    return earliestN(STRUCT_LONG, earliestN);\n+  }\n \n   @UdafFactory(description = \"return the earliest value of a double column\",\n       aggregateSchema = \"STRUCT<SEQ BIGINT, VAL DOUBLE>\")\n   public static Udaf<Double, Struct, Double> earliestDouble() {\n     return earliest(STRUCT_DOUBLE);\n   }\n+  \n+  @UdafFactory(description = \"return the earliest N values of a double column\",\n+      aggregateSchema = \"ARRAY<STRUCT<SEQ BIGINT, VAL DOUBLE>>\")\n+  public static Udaf<Double, List<Struct>, List<Double>> earliestDoubles(final int earliestN) {\n+    return earliestN(STRUCT_DOUBLE, earliestN);\n+  }\n \n   @UdafFactory(description = \"return the earliest value of a boolean column\",\n       aggregateSchema = \"STRUCT<SEQ BIGINT, VAL BOOLEAN>\")\n-  public static Udaf<Boolean, Struct, Boolean> earliestBoolean() {\n+  public static Udaf<Boolean, Struct, Boolean> earliestBooleans() {", "originalCommit": "dead8472fa492043ff4652efca08dfa36929e9ea", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1c32270252cb1efd1661528c91fc0028a53cd749", "url": "https://github.com/confluentinc/ksql/commit/1c32270252cb1efd1661528c91fc0028a53cd749", "message": "Updated fixed for spotbugs and updated reference", "committedDate": "2020-09-07T16:09:30Z", "type": "commit"}, {"oid": "5dd4ed72b1a53932821884b4fd40898c41af53a7", "url": "https://github.com/confluentinc/ksql/commit/5dd4ed72b1a53932821884b4fd40898c41af53a7", "message": "fixed ksqldb-functional-tests", "committedDate": "2020-09-07T19:55:47Z", "type": "commit"}, {"oid": "db667b683e99e3eda8e2e7333113f3fb4e3f7af5", "url": "https://github.com/confluentinc/ksql/commit/db667b683e99e3eda8e2e7333113f3fb4e3f7af5", "message": "Removed ksqbdb-function-tests doc folder", "committedDate": "2020-09-08T08:51:44Z", "type": "commit"}, {"oid": "3d7c7d1a2bb5cf28e859f713d00a61d0fb0289ee", "url": "https://github.com/confluentinc/ksql/commit/3d7c7d1a2bb5cf28e859f713d00a61d0fb0289ee", "message": "Fixed some pluralization and reverted copyright year to 2019", "committedDate": "2020-09-08T09:00:57Z", "type": "commit"}, {"oid": "9627c2afd8d37d2b459889234619c33b6b5c61fa", "url": "https://github.com/confluentinc/ksql/commit/9627c2afd8d37d2b459889234619c33b6b5c61fa", "message": "Fixed compilation error due to refactoring plural", "committedDate": "2020-09-08T10:00:06Z", "type": "commit"}]}