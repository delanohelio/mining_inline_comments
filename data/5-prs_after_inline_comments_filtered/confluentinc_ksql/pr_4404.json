{"pr_number": 4404, "pr_title": " chore: add full window bounds support to pull queries", "pr_createdAt": "2020-01-29T19:01:09Z", "pr_url": "https://github.com/confluentinc/ksql/pull/4404", "timeline": [{"oid": "d9d4b3901c55df2968221d7793c492d9ae507bc1", "url": "https://github.com/confluentinc/ksql/commit/d9d4b3901c55df2968221d7793c492d9ae507bc1", "message": "chore: support window bounds columns in persistent and pull queries\n\nfixes: https://github.com/confluentinc/ksql/issues/3871\n\nIs needed to fix:\n- https://github.com/confluentinc/ksql/issues/3633\n- https://github.com/confluentinc/ksql/issues/4015\n\nBefore this change the version of `ROWKEY` copied to the value schema during processing of data in the Streams topology was always of type `STRING` regardless of the actual key type. This is because windowed keys had a `ROWKEY` in the format `<actual key> : Window{start=<windowStart>, end=<windowEnd>}`. While `ROWKEY` in the value schema was a `STRING`, `ROWKEY` in the key schema was the actual type, e.g. `INT`.  This is confusing and will lead to bugs.  Also, the formated string isn't very friendly for users.\n\nThis change looks to introduce the `WINDOWSTART` and `WINDOWEND` columns that were reserved in https://github.com/confluentinc/ksql/pull/4388. The obvious approach would be to add `WINDOWSTART` and `WINDOWEND` as columns in the key schema. Unfortunately, this would be a much bigger change as many parts of the code currently rely on there being only a single key column. The planned structured key work will resolve this.\n\nFor now, we only add the windows bounds columns when we `LogicalSchema.withMetaAndKeyColsInValue(true)`. This is a bit of a temporary hack, but gets us where we need to be. This will be cleaned up as part of the structured key work.\n\nWith this change `ROWKEY` for windowed sources no longer has the format `<actual key> : Window{start=<windowStart>, end=<windowEnd>}`: `ROWKEY` is now only the _actual_ key and the window bounds can be accessed by `WINDOWSTART` and `WINDOWEND`. These two window bounds columns are included in a pull `SELECT *` query. Likewise a join will include the window bounds columns from both sides in the join result if the join is `SELECT *`.\n\n## Examples:\n\n### Push queries\n\n* A select * on a windowed source will not include `WINDOWSTART` and `WINDOWEND`. `ROWKEY` will be the actual key, not a formatted string.\n\n```\nksql> SELECT * FROM windowedSource emit changes\n\n-- old output\n+---------------+------------------------------------------------------+--------+---------+------+\n| ROWTIME       | ROWKEY                                               | USERID | PAGEID  | TOTAL|\n+---------------+------------------------------------------------------+--------+---------+------+\n| 1557183929488 | User_9|+|Page_39 : Window{start=1557183900000 end=-} | User_9 | Page_39 | 1    |\n| 1557183930211 | User_1|+|Page_79 : Window{start=1557183900000 end=-} | User_1 | Page_79 | 1    |\n\n-- new output\n+---------------+---------------+---------------+------------------+--------+---------+------+\n| ROWTIME       | WINDOWSTART   | WINDOWEND     | ROWKEY           | USERID | PAGEID  | TOTAL|\n+---------------+---------------+---------------+------------------+--------+---------+------+\n| 1557183919786 | 1557183900000 | 1557183960000 | User_5|+|Page_12 | User_5 | Page_12 | 1    |\n| 1557183929488 | 1557183900000 | 1557183960000 | User_9|+|Page_39 | User_9 | Page_39 | 1    |\n```\n\n* `WINDOWSTART` and `WINDOWEND` are available in the SELECT, GROUPBY, WHERE, HAVING clauses etc.\n\nFor example:\n\n```sql\nSELECT TIMESTAMPTOSTRING(WINDOWSTART,'yyyy-MM-dd HH:mm:ss Z') FROM windowedSource emit changes;\n```\n\nHowever, don't get too excited just yet as there is a known limitation that drastically reduces the availability of this syntax:\n\n**KNOWN LIMITATION**\nWhere a query builds a windowed source from a non-windowed source the window bounds columns are not available.  For example:\n\n```\n-- won't yet work:\nSELECT WINDOWSTART FROM FROM someSource WINDOW TUMBLING (SIZE 1 SECOND) group by ROWKEY;\n```\n\nThis issue is tracked by: https://github.com/confluentinc/ksql/issues/4397\n\n* Joins of windowed sources include the `WINDOWSTART` and `WINDOWEND` columns from both sides.\n\n### Pull queries\n\n**KNOWN LIMITATION**\nPull queries have not been updated yet. This will be done in a follow up PR https://github.com/confluentinc/ksql/issues/3633. This is mainly to keep this PR manageable.\n\n### Persistent queries\n\nPersistent C*AS queries work similar to push queries and have the same known limitation.\n\nBREAKING CHANGE: Any query of a windowed source that uses `ROWKEY` in the SELECT projection will see the contents of `ROWKEY` change from a formatted `STRING` containing the underlying key and the window bounds, to just the underlying key.  Queries can access the window bounds using `WINDOWSTART` and `WINDOWEND`.\n\nBREAKING CHANGE: Joins on windowed sources now include `WINDOWSTART` and `WINDOWEND` columns from both sides on a `SELECT *`.", "committedDate": "2020-01-29T11:24:27Z", "type": "commit"}, {"oid": "acd9f27000a7fa80024d5dc5dfee12a28db6784d", "url": "https://github.com/confluentinc/ksql/commit/acd9f27000a7fa80024d5dc5dfee12a28db6784d", "message": "chore: must of been tripping\n\nKSQL does support `<` operator for strings... revert doc change & add test", "committedDate": "2020-01-29T12:03:01Z", "type": "commit"}, {"oid": "537aa562f086c1694ecf55843db623c4a00a898e", "url": "https://github.com/confluentinc/ksql/commit/537aa562f086c1694ecf55843db623c4a00a898e", "message": "chore: add full window bounds support to pull queries\n\nfixes: https://github.com/confluentinc/ksql/issues/3633\n\nThis change sees pull queries share more functionality and code around the window bounds columns `WINDOWSTART` and `WINDOWEND` introduced in https://github.com/confluentinc/ksql/pull/4388 and https://github.com/confluentinc/ksql/pull/4401.\n\n* pull queries on time windowed sources, i.e. `TUMBLING` and `HOPPING`, now have a `WINDOWEND` in their schema, just like `SESSION` and the new push query functionality.\n* window bound columns are now accessible within the projection of a pull query, e.g. `SELECT WINDOWSTART, WINDOWEND FROM FOO WHERE ROWKEY=1;`", "committedDate": "2020-01-29T19:00:08Z", "type": "commit"}, {"oid": "22239bbb730084ab53d8dd5feead9d45eacccd99", "url": "https://github.com/confluentinc/ksql/commit/22239bbb730084ab53d8dd5feead9d45eacccd99", "message": "chore: merge from master\n\nConflicting files\ndocs-md/developer-guide/create-a-stream.md\ndocs-md/developer-guide/create-a-table.md", "committedDate": "2020-01-29T21:44:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY1MTc0NQ==", "url": "https://github.com/confluentinc/ksql/pull/4404#discussion_r372651745", "bodyText": "Bit hacky, but will work for now.", "author": "big-andy-coates", "createdAt": "2020-01-29T21:53:57Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java", "diffHunk": "@@ -647,22 +657,27 @@ private static void validateProjection(\n   private static LogicalSchema selectOutputSchema(\n       final Result input,\n       final KsqlExecutionContext executionContext,\n-      final ImmutableAnalysis analysis\n+      final ImmutableAnalysis analysis,\n+      final Optional<WindowType> windowType\n   ) {\n     final Builder schemaBuilder = LogicalSchema.builder()\n         .noImplicitColumns();\n \n-    final ExpressionTypeManager expressionTypeManager = new ExpressionTypeManager(\n-        input.schema,\n-        executionContext.getMetaStore(),\n-        false\n-    );\n+    // Copy meta & key columns into the value schema as SelectValueMapper expects it:\n+    final LogicalSchema schema = input.schema\n+        .withMetaAndKeyColsInValue(windowType.isPresent());\n+\n+    final ExpressionTypeManager expressionTypeManager =\n+        new ExpressionTypeManager(schema, executionContext.getMetaStore());\n \n     for (int idx = 0; idx < analysis.getSelectExpressions().size(); idx++) {\n       final SelectExpression select = analysis.getSelectExpressions().get(idx);\n       final SqlType type = expressionTypeManager.getExpressionSqlType(select.getExpression());\n \n-      if (input.schema.isKeyColumn(select.getAlias())) {\n+      if (input.schema.isKeyColumn(select.getAlias())\n+          || select.getAlias().equals(SchemaUtil.WINDOWSTART_NAME)\n+          || select.getAlias().equals(SchemaUtil.WINDOWEND_NAME)", "originalCommit": "22239bbb730084ab53d8dd5feead9d45eacccd99", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjcwNjg1OQ==", "url": "https://github.com/confluentinc/ksql/pull/4404#discussion_r372706859", "bodyText": "just sanity checking, the reason we're adding this at 1 and 2 is so that they come after the ROWTIME but before the ROWKEY? Might help to have constants for these numbers. Also might help to add the key fields after the start/end. Super nits.", "author": "agavra", "createdAt": "2020-01-30T00:36:35Z", "path": "ksql-rest-app/src/main/java/io/confluent/ksql/rest/server/execution/PullQueryExecutor.java", "diffHunk": "@@ -559,37 +563,43 @@ private static boolean isSelectStar(final Select select) {\n       final KsqlExecutionContext executionContext,\n       final ImmutableAnalysis analysis,\n       final LogicalSchema outputSchema,\n+      final Optional<WindowType> windowType,\n       final QueryId queryId,\n       final Stacker contextStacker\n   ) {\n-    final boolean referencesRowTime = analysis.getSelectColumnRefs().stream()\n-        .anyMatch(ref -> ref.name().equals(SchemaUtil.ROWTIME_NAME));\n-\n-    final boolean referencesRowKey = analysis.getSelectColumnRefs().stream()\n-        .anyMatch(ref -> ref.name().equals(SchemaUtil.ROWKEY_NAME));\n+    final boolean noSystemColumns = analysis.getSelectColumnRefs().stream()\n+        .noneMatch(ref -> SchemaUtil.systemColumnNames().contains(ref.name()));\n \n     final LogicalSchema intermediateSchema;\n-    final PreSelectTransformer preSelectTransform;\n-    if (!referencesRowTime && !referencesRowKey) {\n+    final Function<TableRow, GenericRow> preSelectTransform;\n+    if (noSystemColumns) {\n       intermediateSchema = input.schema;\n-      preSelectTransform = (rowTime, key, value) -> value;\n+      preSelectTransform = TableRow::value;\n     } else {\n       // SelectValueMapper requires the rowTime & key fields in the value schema :(\n-      intermediateSchema = LogicalSchema.builder()\n-          .keyColumns(input.schema.key())\n-          .valueColumns(input.schema.value())\n-          .valueColumns(input.schema.metadata())\n-          .valueColumns(input.schema.key())\n-          .build();\n-\n-      preSelectTransform = (rowTime, key, value) -> {\n-        value.getColumns().add(rowTime);\n-\n-        key.schema().fields().forEach(f -> {\n-          final Object keyField = key.get(f);\n-          value.getColumns().add(keyField);\n+      final boolean windowed = windowType.isPresent();\n+\n+      intermediateSchema = input.schema\n+          .withMetaAndKeyColsInValue(windowed);\n+\n+      preSelectTransform = row -> {\n+        final Struct key = row.key();\n+        final List<Object> columns = row.value().getColumns();\n+\n+        columns.add(0, row.rowTime());\n+\n+        final List<Object> keyFields = key.schema().fields().stream()\n+            .map(key::get)\n+            .collect(Collectors.toList());\n+\n+        columns.addAll(1, keyFields);\n+\n+        row.window().ifPresent(window -> {\n+          columns.add(1, window.start().toEpochMilli());\n+          columns.add(2, window.end().toEpochMilli());", "originalCommit": "22239bbb730084ab53d8dd5feead9d45eacccd99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg2NTY1OA==", "url": "https://github.com/confluentinc/ksql/pull/4404#discussion_r372865658", "bodyText": "This will change in the next PR, so I'm not worried.", "author": "big-andy-coates", "createdAt": "2020-01-30T10:21:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjcwNjg1OQ=="}], "type": "inlineReview"}]}