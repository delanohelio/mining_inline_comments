{"pr_number": 6182, "pr_title": "fix: fail on non-string MAP keys", "pr_createdAt": "2020-09-10T19:09:34Z", "pr_url": "https://github.com/confluentinc/ksql/pull/6182", "timeline": [{"oid": "8d3ff5a42089238c36293901a9623f11af017d12", "url": "https://github.com/confluentinc/ksql/commit/8d3ff5a42089238c36293901a9623f11af017d12", "message": "fix: fail on non-string MAP keys\n\nfixes: https://github.com/confluentinc/ksql/issues/6181\n\nFixes ksqlDB so that statements that create maps with non-string keys fail.\n\nCrux of the issue was in `SqlTypeParser`, which ignored the key type.\n\nAdditionally, there were many places in the code that checked for non-STRING keys, but they always were STRING keys by this point.  These checks have generally been removed in prep for supporting non-STRING keys.  It is the format that should decide if it can handle non-STRING keys or not, hence the code now fails these statements because the key/value format rejects them as unsupported. This opens the way to PROTOBUF supporting integer keys in the future: only the Protobuf Serde could should need to change. (https://github.com/confluentinc/ksql/issues/6177).", "committedDate": "2020-09-10T19:06:55Z", "type": "commit"}, {"oid": "0e169b638f2c658909e3774dc7f0bbde48a7046e", "url": "https://github.com/confluentinc/ksql/commit/0e169b638f2c658909e3774dc7f0bbde48a7046e", "message": "chore: include SqlTypeWalker", "committedDate": "2020-09-10T19:20:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcyMzg4OQ==", "url": "https://github.com/confluentinc/ksql/pull/6182#discussion_r486723889", "bodyText": "This error message doesn't make sense to me. The block above throws if any key types are null, so if we reach here and keyTypes.size() is zero, that means no keys were specified, but that's not possible either since if (exp.getMap().isEmpty()) is already checked and handled at the start of the method.", "author": "vcrfxia", "createdAt": "2020-09-11T01:41:12Z", "path": "ksqldb-execution/src/main/java/io/confluent/ksql/execution/util/ExpressionTypeManager.java", "diffHunk": "@@ -401,12 +401,14 @@ public Void visitCreateMapExpression(\n           })\n           .collect(Collectors.toList());\n \n-      if (keyTypes.stream().anyMatch(type -> !SqlTypes.STRING.equals(type))) {\n-        final String types = keyTypes.stream()\n-            .map(type -> type == null ? \"NULL\" : type.toString())\n-            .collect(Collectors.joining(\", \", \"[\", \"]\"));\n+      if (keyTypes.stream().anyMatch(type -> type == null)) {\n+        throw new KsqlException(\"Map keys can not be NULL\");\n+      }\n \n-        throw new KsqlException(\"Only STRING keys are supported in maps but got: \" + types);\n+      if (keyTypes.size() == 0) {\n+        throw new KsqlException(\"Cannot construct a map with all NULL key \"", "originalCommit": "0e169b638f2c658909e3774dc7f0bbde48a7046e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk3Mzc0OQ==", "url": "https://github.com/confluentinc/ksql/pull/6182#discussion_r486973749", "bodyText": "Removed.", "author": "big-andy-coates", "createdAt": "2020-09-11T11:06:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcyMzg4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcyNDk5NA==", "url": "https://github.com/confluentinc/ksql/pull/6182#discussion_r486724994", "bodyText": "Why are we catching KsqlStatementException and throwing a different KsqlStatementException here? Did you mean to catch KsqlException instead?", "author": "vcrfxia", "createdAt": "2020-09-11T01:45:02Z", "path": "ksqldb-functional-tests/src/main/java/io/confluent/ksql/test/tools/TestExecutorUtil.java", "diffHunk": "@@ -308,15 +308,20 @@ private static ExecuteResultAndSources executePlan(\n       final KsqlExecutionContext executionContext,\n       final ConfiguredKsqlPlan plan\n   ) {\n-    final ExecuteResult executeResult = executionContext.execute(\n-        executionContext.getServiceContext(),\n-        plan\n-    );\n+    try {\n+      final ExecuteResult executeResult = executionContext.execute(\n+          executionContext.getServiceContext(),\n+          plan\n+      );\n \n-    final Optional<List<DataSource>> dataSources = plan.getPlan().getQueryPlan()\n-        .map(queryPlan -> getSources(queryPlan.getSources(), executionContext.getMetaStore()));\n+      final Optional<List<DataSource>> dataSources = plan.getPlan().getQueryPlan()\n+          .map(queryPlan -> getSources(queryPlan.getSources(), executionContext.getMetaStore()));\n \n-    return new ExecuteResultAndSources(executeResult, dataSources);\n+      return new ExecuteResultAndSources(executeResult, dataSources);\n+    } catch (final KsqlStatementException e) {", "originalCommit": "0e169b638f2c658909e3774dc7f0bbde48a7046e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk3MTcwMw==", "url": "https://github.com/confluentinc/ksql/pull/6182#discussion_r486971703", "bodyText": "Nope, the code is attempting to catch a KsqlStatementException thrown by the engine, which will have the reformatted SQL in it, and throw a almost matching KsqlStatementException that contains the pre-formatted sql.  Its a hack, but not a new one, this is copied for somewhere else in the test code.\nAlso, in this case it doesn't work - as the code only has the reformatted SQL - forgot I hadn't fixed this, let me take a look.", "author": "big-andy-coates", "createdAt": "2020-09-11T11:01:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcyNDk5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAxNTIwNQ==", "url": "https://github.com/confluentinc/ksql/pull/6182#discussion_r487015205", "bodyText": "Resolved.", "author": "big-andy-coates", "createdAt": "2020-09-11T12:36:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcyNDk5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcyNzQ0Mw==", "url": "https://github.com/confluentinc/ksql/pull/6182#discussion_r486727443", "bodyText": "SchemaInfo doesn't currently expose the key schema for maps. Is this intended as follow-up work for when ksqlDB's use of protobuf is actually extended to support non-string keys?", "author": "vcrfxia", "createdAt": "2020-09-11T01:54:12Z", "path": "ksqldb-rest-app/src/test/java/io/confluent/ksql/rest/util/EntityUtilTest.java", "diffHunk": "@@ -61,7 +61,7 @@ public void shouldBuildCorrectBooleanField() {\n   public void shouldBuildCorrectMapField() {\n     // Given:\n     final LogicalSchema schema = LogicalSchema.builder()\n-        .valueColumn(ColumnName.of(\"field\"), SqlTypes.map(SqlTypes.INTEGER))\n+        .valueColumn(ColumnName.of(\"field\"), SqlTypes.map(SqlTypes.BIGINT, SqlTypes.INTEGER))", "originalCommit": "0e169b638f2c658909e3774dc7f0bbde48a7046e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk3MjIwNw==", "url": "https://github.com/confluentinc/ksql/pull/6182#discussion_r486972207", "bodyText": "Correct, it's already called out in #6177", "author": "big-andy-coates", "createdAt": "2020-09-11T11:03:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcyNzQ0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcyODU1Mw==", "url": "https://github.com/confluentinc/ksql/pull/6182#discussion_r486728553", "bodyText": "Why this change? Statements with non-string map keys in Avro format should've already been rejected during validation, before reaching this, right? Same question for the other serde changes below.", "author": "vcrfxia", "createdAt": "2020-09-11T01:58:02Z", "path": "ksqldb-serde/src/main/java/io/confluent/ksql/serde/avro/AvroDataTranslator.java", "diffHunk": "@@ -135,7 +136,7 @@ private static Schema throwOnInvalidSchema(final Schema schema) {\n       @Override\n       public Void visitMap(final Schema schema, final Void key, final Void value) {\n         if (schema.keySchema().type() != Type.STRING) {\n-          throw new IllegalArgumentException(\"Avro only supports MAPs with STRING keys\");\n+          throw new KsqlException(\"Avro only supports MAPs with STRING keys\");", "originalCommit": "0e169b638f2c658909e3774dc7f0bbde48a7046e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk3NTIwNQ==", "url": "https://github.com/confluentinc/ksql/pull/6182#discussion_r486975205", "bodyText": "On investigation, the AvroFormat wasn't validating the schema before this point. It does now and the validation code is now common.", "author": "big-andy-coates", "createdAt": "2020-09-11T11:09:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcyODU1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA1MzMzNA==", "url": "https://github.com/confluentinc/ksql/pull/6182#discussion_r487053334", "bodyText": "To check my understanding: you're saying this same code path is also used for validation, and that's why it's better to throw KsqlException than IllegalArgumentException?", "author": "vcrfxia", "createdAt": "2020-09-11T13:42:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcyODU1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcyOTE1Mg==", "url": "https://github.com/confluentinc/ksql/pull/6182#discussion_r486729152", "bodyText": "This looks like it should be SqlMap.of(SqlTypes.STRING, SqlPrimitiveType.of(SqlTypes.BOOLEAN)) instead?", "author": "vcrfxia", "createdAt": "2020-09-11T02:00:11Z", "path": "ksqldb-udf/src/test/java/io/confluent/ksql/schema/ksql/types/SqlArrayTest.java", "diffHunk": "@@ -36,7 +36,7 @@ public void shouldImplementHashCodeAndEqualsProperly() {\n     new EqualsTester()\n         .addEqualityGroup(SqlArray.of(SOME_TYPE), SqlArray.of(SOME_TYPE))\n         .addEqualityGroup(SqlArray.of(SqlPrimitiveType.of(SqlBaseType.BOOLEAN)))\n-        .addEqualityGroup(SqlMap.of(SqlPrimitiveType.of(SqlBaseType.BOOLEAN)))\n+        .addEqualityGroup(SqlMap.of(SqlTypes.STRING, SqlTypes.BOOLEAN))", "originalCommit": "0e169b638f2c658909e3774dc7f0bbde48a7046e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk3MjQ4Nw==", "url": "https://github.com/confluentinc/ksql/pull/6182#discussion_r486972487", "bodyText": "No difference. Same thing.", "author": "big-andy-coates", "createdAt": "2020-09-11T11:03:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcyOTE1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcyOTg5OQ==", "url": "https://github.com/confluentinc/ksql/pull/6182#discussion_r486729899", "bodyText": "Not your code but I notice that shouldLoadParameterizedListParams() (the test above this one in this file) doesn't test what it says it's testing. Wanna fix it while you're in here?", "author": "vcrfxia", "createdAt": "2020-09-11T02:02:54Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/function/UdtfLoaderTest.java", "diffHunk": "@@ -97,13 +97,13 @@ public void shouldLoadParameterizedMapParams() {\n ", "originalCommit": "0e169b638f2c658909e3774dc7f0bbde48a7046e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk3NjQ1Mw==", "url": "https://github.com/confluentinc/ksql/pull/6182#discussion_r486976453", "bodyText": "done", "author": "big-andy-coates", "createdAt": "2020-09-11T11:12:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcyOTg5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcyOTkwOA==", "url": "https://github.com/confluentinc/ksql/pull/6182#discussion_r486729908", "bodyText": "Curious: why the addition of a timeout to this test file in particular? Seems unrelated to the changes in this PR?", "author": "vcrfxia", "createdAt": "2020-09-11T02:02:56Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/integration/SecureIntegrationTest.java", "diffHunk": "@@ -112,6 +114,10 @@\n       .outerRule(Retry.of(3, ZooKeeperClientException.class, 3, TimeUnit.SECONDS))\n       .around(TEST_HARNESS);\n \n+\n+  @Rule\n+  public final Timeout timeout = Timeout.seconds(30);", "originalCommit": "0e169b638f2c658909e3774dc7f0bbde48a7046e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk3MjgwMA==", "url": "https://github.com/confluentinc/ksql/pull/6182#discussion_r486972800", "bodyText": "Is unrelated, but given this test deadlocked locally, I thought I'd just add the timeout.", "author": "big-andy-coates", "createdAt": "2020-09-11T11:04:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcyOTkwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcyOTkxNg==", "url": "https://github.com/confluentinc/ksql/pull/6182#discussion_r486729916", "bodyText": "Any particular reason this is reversed?", "author": "vcrfxia", "createdAt": "2020-09-11T02:02:59Z", "path": "ksqldb-parser/src/test/java/io/confluent/ksql/parser/json/KsqlTypesSerdeModuleTest.java", "diffHunk": "@@ -75,19 +78,22 @@ public void shouldSerDeSqlArrayTypes() throws JsonProcessingException {\n   @Test\n   public void shouldSerDeSqlMapTypes() throws JsonProcessingException {\n     // Given:\n-    final SqlType[] types = new SqlType[]{\n+    final List<SqlType> types = ImmutableList.of(\n         SqlTypes.INTEGER,\n         SqlTypes.BIGINT,\n         SqlTypes.DOUBLE,\n         SqlTypes.STRING\n-    };\n+    );\n \n-    for (final SqlType type : types) {\n-      // When:\n-      final SqlType out = MAPPER.readValue(MAPPER.writeValueAsString(SqlMap.of(type)), SqlType.class);\n+    for (final SqlType keyType : types) {\n+      for (final SqlType valueType : Lists.reverse(types)) {", "originalCommit": "0e169b638f2c658909e3774dc7f0bbde48a7046e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk3MzAzMA==", "url": "https://github.com/confluentinc/ksql/pull/6182#discussion_r486973030", "bodyText": "So they don't match.  Otherwise the code could be flipping key and value and the test would still pass.", "author": "big-andy-coates", "createdAt": "2020-09-11T11:05:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcyOTkxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA1NTE4OQ==", "url": "https://github.com/confluentinc/ksql/pull/6182#discussion_r487055189", "bodyText": "I get why the additional for-loop was added (for that reason), but I'm wondering by there's Lists.reverse() in there. Is it because Guava contains a convenient method for copying a list and reversing its contents, but not for directly copying the list...?", "author": "vcrfxia", "createdAt": "2020-09-11T13:45:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcyOTkxNg=="}], "type": "inlineReview"}, {"oid": "c8925e97ae7463c70f202621d3c6a1f92d8e8548", "url": "https://github.com/confluentinc/ksql/commit/c8925e97ae7463c70f202621d3c6a1f92d8e8548", "message": "test: requested changes", "committedDate": "2020-09-11T11:31:21Z", "type": "commit"}, {"oid": "57fccd4f73f6b4538b4127a5a86f421a5e636234", "url": "https://github.com/confluentinc/ksql/commit/57fccd4f73f6b4538b4127a5a86f421a5e636234", "message": "test: avoid the need to 'correct' KsqlStatementExceptions in QTT\n\nNegative test cases should if it is not the last statement in the test case that causes the expected exception to be thrown.  This is so that there aren't test cases were the author thinks it is the last statement that fails, but its actually an earlier one.\n\nTo achieve this, the code was testing the contents of the `KsqlStatementException` to assert it matched the last statement in the test case.  However, because the engine reformts code it the test executor needed to mess around correcting the contents of the statement exception.\n\nThis commit simplifies things by just asserting the last statement failed, rather than relying on `KqlStatementException` contents.", "committedDate": "2020-09-11T12:36:28Z", "type": "commit"}]}