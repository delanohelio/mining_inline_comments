{"pr_number": 4899, "pr_title": "chore: add GROUP BY support for any key names", "pr_createdAt": "2020-03-26T00:46:11Z", "pr_url": "https://github.com/confluentinc/ksql/pull/4899", "timeline": [{"oid": "7b0a2e0f0890ee635653a448cc29254606d88e34", "url": "https://github.com/confluentinc/ksql/commit/7b0a2e0f0890ee635653a448cc29254606d88e34", "message": "chore: add GROUP BY support for any key names\n\nfixes: #4898\n\nThis commit sees the result of a GROUP BY on a single column reference have a schema with a key column matching the name of the column, e.g.\n\n```sql\n-- source schema: A -> B, C\nCREATE STREAM OUTPUT AS SELECT COUNT(1) AS COUNT FROM INPUT GROUP BY B;\n-- output schema: B -> COUNT\n```\n\nIf the GROUP BY is on anything other than a single column reference then the key column will be a unique generated column name, e.g.\n\n```sql\n-- source schema: A -> B, C\nCREATE STREAM OUTPUT AS SELECT COUNT(1) FROM INPUT GROUP BY B+1;\n-- output schema: KSQL_COL_1 -> KSQL_COL_0  (Both names are generated)\n```\n\nBREAKING CHANGE: Existing queries that reference a single GROUP BY column in the projection would fail if they were resubmitted, due to a duplicate column. The same existing queries will continue to run if already running, i.e. this is only a change for newly submitted queries. Existing queries will use the old query semantics.", "committedDate": "2020-03-26T20:10:16Z", "type": "commit"}, {"oid": "467ffa30c273b615b0f13ce5da86bded1be443d8", "url": "https://github.com/confluentinc/ksql/commit/467ffa30c273b615b0f13ce5da86bded1be443d8", "message": "test: add the historical plans", "committedDate": "2020-03-26T20:10:42Z", "type": "commit"}, {"oid": "467ffa30c273b615b0f13ce5da86bded1be443d8", "url": "https://github.com/confluentinc/ksql/commit/467ffa30c273b615b0f13ce5da86bded1be443d8", "message": "test: add the historical plans", "committedDate": "2020-03-26T20:10:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODg2NzgzNA==", "url": "https://github.com/confluentinc/ksql/pull/4899#discussion_r398867834", "bodyText": "\ud83d\udc4e that is an abuse of Optional. Just making my opinion known, but as it's a style thing feel free to ignore me", "author": "agavra", "createdAt": "2020-03-26T20:23:55Z", "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/GroupByParamsFactory.java", "diffHunk": "@@ -44,48 +50,72 @@ private GroupByParamsFactory() {\n \n   public static LogicalSchema buildSchema(\n       final LogicalSchema sourceSchema,\n-      final List<ExpressionMetadata> expressions\n+      final List<ExpressionMetadata> groupBys,\n+      final KsqlConfig ksqlConfig\n   ) {\n-    return expressions.size() == 1\n-        ? singleExpressionSchema(sourceSchema, expressions.get(0).getExpressionType())\n-        : multiExpressionSchema(sourceSchema);\n+    return groupBys.size() == 1\n+        ? singleExpressionSchema(sourceSchema, groupBys.get(0), ksqlConfig)\n+        : multiExpressionSchema(sourceSchema, ksqlConfig);\n   }\n \n   public static GroupByParams build(\n       final LogicalSchema sourceSchema,\n-      final List<ExpressionMetadata> expressions,\n-      final ProcessingLogger logger\n+      final List<ExpressionMetadata> groupBys,\n+      final ProcessingLogger logger,\n+      final KsqlConfig ksqlConfig\n   ) {\n-    final Function<GenericRow, Struct> mapper = expressions.size() == 1\n-        ? new SingleExpressionGrouper(expressions.get(0), logger)::apply\n-        : new MultiExpressionGrouper(expressions, logger)::apply;\n+    if (groupBys.isEmpty()) {\n+      throw new IllegalArgumentException(\"No GROUP BY groupBys\");\n+    }\n \n-    final LogicalSchema schema = buildSchema(sourceSchema, expressions);\n+    final Function<GenericRow, Struct> mapper = groupBys.size() == 1\n+        ? new SingleExpressionGrouper(groupBys.get(0), logger)::apply\n+        : new MultiExpressionGrouper(groupBys, logger)::apply;\n+\n+    final LogicalSchema schema = buildSchema(sourceSchema, groupBys, ksqlConfig);\n \n     return new GroupByParams(schema, mapper);\n   }\n \n   private static LogicalSchema multiExpressionSchema(\n-      final LogicalSchema sourceSchema\n+      final LogicalSchema sourceSchema,\n+      final KsqlConfig ksqlConfig\n   ) {\n-    return buildSchemaWithKeyType(sourceSchema, SqlTypes.STRING);\n+    return buildSchemaWithKeyType(sourceSchema, Optional.empty(), SqlTypes.STRING, ksqlConfig);\n   }\n \n   private static LogicalSchema singleExpressionSchema(\n       final LogicalSchema sourceSchema,\n-      final SqlType keyType\n+      final ExpressionMetadata groupBy,\n+      final KsqlConfig ksqlConfig\n   ) {\n-    return buildSchemaWithKeyType(sourceSchema, keyType);\n+    final SqlType keyType = groupBy.getExpressionType();\n+\n+    final Optional<ColumnName> singleColumnName = Optional.of(groupBy.getExpression())\n+        .filter(colRef -> ksqlConfig.getBoolean(KsqlConfig.KSQL_ANY_KEY_NAME_ENABLED))\n+        .filter(gb -> gb instanceof ColumnReferenceExp)\n+        .map(ColumnReferenceExp.class::cast)\n+        .map(ColumnReferenceExp::getColumnName);", "originalCommit": "7b0a2e0f0890ee635653a448cc29254606d88e34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTE2MjI3Nw==", "url": "https://github.com/confluentinc/ksql/pull/4899#discussion_r399162277", "bodyText": "I agree - I'm being super lazy and this code is going very soon.  Next PR removes this.", "author": "big-andy-coates", "createdAt": "2020-03-27T10:17:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODg2NzgzNA=="}], "type": "inlineReview"}]}