{"pr_number": 6642, "pr_title": "chore: make StreamSelectKey generic to handle window repartitions", "pr_createdAt": "2020-11-19T00:25:49Z", "pr_url": "https://github.com/confluentinc/ksql/pull/6642", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk3MTI2Mg==", "url": "https://github.com/confluentinc/ksql/pull/6642#discussion_r527971262", "bodyText": "For my own edification, what's the purpose of marking this EffectivelyImmutable? Is it just as a clue to the reader, or is it necessary since KStreamHolder is marked as Immutable?", "author": "vcrfxia", "createdAt": "2020-11-20T21:10:08Z", "path": "ksqldb-execution/src/main/java/io/confluent/ksql/execution/plan/ExecutionKeyFactory.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Copyright 2019 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License; you may not use this file\n+ * except in compliance with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.execution.plan;\n+\n+import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n+import io.confluent.ksql.execution.context.QueryContext;\n+import io.confluent.ksql.schema.ksql.PhysicalSchema;\n+import io.confluent.ksql.serde.FormatInfo;\n+import io.confluent.ksql.serde.WindowInfo;\n+import io.confluent.ksql.testing.EffectivelyImmutable;\n+import java.util.Objects;\n+import org.apache.kafka.common.serialization.Serde;\n+import org.apache.kafka.connect.data.Struct;\n+import org.apache.kafka.streams.kstream.Windowed;\n+\n+/**\n+ * The {@code ExecutionKeyFactory} is in charge of creating the keys\n+ * and the Serdes for the keys of any particular execution step.\n+ *\n+ * @param <K> the type of the key, usually either {@code Struct}\n+ *            or {@code Windowed<Struct>}\n+ */\n+@EffectivelyImmutable", "originalCommit": "156027493a902e576d65572d68c8ce69a8009c39", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODc4NjgyOQ==", "url": "https://github.com/confluentinc/ksql/pull/6642#discussion_r528786829", "bodyText": "The latter (also I just copied it over from KeySerdeFactory, GH couldn't keep track that it's actually the same file because I made so many changes", "author": "agavra", "createdAt": "2020-11-23T15:29:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk3MTI2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk3MjE0Mw==", "url": "https://github.com/confluentinc/ksql/pull/6642#discussion_r527972143", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * @return a new key of type {@code K} given the struct conents of the key\n          \n          \n            \n               * @return a new key of type {@code K} given the struct contents of the new key and the old key being updated\n          \n      \n    \n    \n  \n\nWould it make more sense to rename this to something like updateKey? I was surprised to see the old key required in a method called constructKey, but maybe updateKey is even more confusing. getNewKey? constructNewKey?", "author": "vcrfxia", "createdAt": "2020-11-20T21:12:17Z", "path": "ksqldb-execution/src/main/java/io/confluent/ksql/execution/plan/ExecutionKeyFactory.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Copyright 2019 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License; you may not use this file\n+ * except in compliance with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.execution.plan;\n+\n+import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n+import io.confluent.ksql.execution.context.QueryContext;\n+import io.confluent.ksql.schema.ksql.PhysicalSchema;\n+import io.confluent.ksql.serde.FormatInfo;\n+import io.confluent.ksql.serde.WindowInfo;\n+import io.confluent.ksql.testing.EffectivelyImmutable;\n+import java.util.Objects;\n+import org.apache.kafka.common.serialization.Serde;\n+import org.apache.kafka.connect.data.Struct;\n+import org.apache.kafka.streams.kstream.Windowed;\n+\n+/**\n+ * The {@code ExecutionKeyFactory} is in charge of creating the keys\n+ * and the Serdes for the keys of any particular execution step.\n+ *\n+ * @param <K> the type of the key, usually either {@code Struct}\n+ *            or {@code Windowed<Struct>}\n+ */\n+@EffectivelyImmutable\n+public interface ExecutionKeyFactory<K> {\n+\n+  Serde<K> buildKeySerde(\n+      FormatInfo format,\n+      PhysicalSchema physicalSchema,\n+      QueryContext queryContext\n+  );\n+\n+  /**\n+   * @return a new {@code ExecutionKeyFactory}\n+   */\n+  ExecutionKeyFactory<K> withQueryBuilder(KsqlQueryBuilder builder);\n+\n+  /**\n+   * @return a new key of type {@code K} given the struct conents of the key", "originalCommit": "156027493a902e576d65572d68c8ce69a8009c39", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk3MjMwNg==", "url": "https://github.com/confluentinc/ksql/pull/6642#discussion_r527972306", "bodyText": "Rename to getKeyFactory() or getExecutionKeyFactory()?", "author": "vcrfxia", "createdAt": "2020-11-20T21:12:42Z", "path": "ksqldb-execution/src/main/java/io/confluent/ksql/execution/plan/KStreamHolder.java", "diffHunk": "@@ -25,21 +25,21 @@\n public final class KStreamHolder<K> {\n \n   private final KStream<K, GenericRow> stream;\n-  private final KeySerdeFactory<K> keySerdeFactory;\n+  private final ExecutionKeyFactory<K> executionKeyFactory;\n   private final LogicalSchema schema;\n \n   public KStreamHolder(\n       final KStream<K, GenericRow> stream,\n       final LogicalSchema schema,\n-      final KeySerdeFactory<K> keySerdeFactory\n+      final ExecutionKeyFactory<K> executionKeyFactory\n   ) {\n     this.stream = Objects.requireNonNull(stream, \"stream\");\n-    this.keySerdeFactory = Objects.requireNonNull(keySerdeFactory, \"keySerdeFactory\");\n+    this.executionKeyFactory = Objects.requireNonNull(executionKeyFactory, \"keySerdeFactory\");\n     this.schema = Objects.requireNonNull(schema, \"schema\");\n   }\n \n-  public KeySerdeFactory<K> getKeySerdeFactory() {\n-    return keySerdeFactory;\n+  public ExecutionKeyFactory<K> getKeySerdeFactory() {", "originalCommit": "156027493a902e576d65572d68c8ce69a8009c39", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg3NjY3NA==", "url": "https://github.com/confluentinc/ksql/pull/6642#discussion_r528876674", "bodyText": "It doesn't look like changes were made even though this comment was resolved?", "author": "vcrfxia", "createdAt": "2020-11-23T17:29:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk3MjMwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkyMjE1NQ==", "url": "https://github.com/confluentinc/ksql/pull/6642#discussion_r528922155", "bodyText": "ah oops! I had made this change somewhere else and just assumed that was the place this was pointing at. I'll update it", "author": "agavra", "createdAt": "2020-11-23T18:47:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk3MjMwNg=="}], "type": "inlineReview"}, {"oid": "9dcc4b79de97caaa578d8ffc23b163a2546de610", "url": "https://github.com/confluentinc/ksql/commit/9dcc4b79de97caaa578d8ffc23b163a2546de610", "message": "chore: make StreamSelectKey generic to handle window repartitions", "committedDate": "2020-11-20T23:56:28Z", "type": "commit"}, {"oid": "207dc4e94ae2260b112e1c000767aae8f8fea467", "url": "https://github.com/confluentinc/ksql/commit/207dc4e94ae2260b112e1c000767aae8f8fea467", "message": "chore: rebase and update for table select key", "committedDate": "2020-11-23T15:48:39Z", "type": "forcePushed"}, {"oid": "d5f39267b18df0c3bc7c4de9d94ff20458ce956a", "url": "https://github.com/confluentinc/ksql/commit/d5f39267b18df0c3bc7c4de9d94ff20458ce956a", "message": "chore: rebase and update for table select key", "committedDate": "2020-11-23T15:52:06Z", "type": "commit"}, {"oid": "d5f39267b18df0c3bc7c4de9d94ff20458ce956a", "url": "https://github.com/confluentinc/ksql/commit/d5f39267b18df0c3bc7c4de9d94ff20458ce956a", "message": "chore: rebase and update for table select key", "committedDate": "2020-11-23T15:52:06Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg3NDMwNw==", "url": "https://github.com/confluentinc/ksql/pull/6642#discussion_r528874307", "bodyText": "Out of curiosity, what's the thinking for removing this conditional? Even though it's currently the case that this block can only be entered if forceRepartition is true, that may not be the case in the future.\nIf you're going to remove this, you should be able to remove the UC_USELESS_CONDITION suppression at the top of the method as well.", "author": "vcrfxia", "createdAt": "2020-11-23T17:25:42Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/structured/SchemaKTable.java", "diffHunk": "@@ -175,12 +173,11 @@ public SchemaKTable(\n     if (keyFormat.isWindowed()) {\n       final String errorMsg = \"Implicit repartitioning of windowed sources is not supported. \"\n           + \"See https://github.com/confluentinc/ksql/issues/4385.\";\n-      final String additionalMsg = forceRepartition", "originalCommit": "d5f39267b18df0c3bc7c4de9d94ff20458ce956a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkyNDYxOQ==", "url": "https://github.com/confluentinc/ksql/pull/6642#discussion_r528924619", "bodyText": "I just blindly followed IntelliJ's recommendations. I'll change it back", "author": "agavra", "createdAt": "2020-11-23T18:52:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg3NDMwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg3NjYzMQ==", "url": "https://github.com/confluentinc/ksql/pull/6642#discussion_r528876631", "bodyText": "Hm, the word \"representation\" is confusing to me. I don't think I'd understand this comment without the context in this PR. This makes more sense to me:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * This method can construct a new key given the contents of the old key and the\n          \n          \n            \n               * desired Struct representation of the new key. This is helpful if we intended\n          \n          \n            \n               * This method can construct a new key given the old key and the\n          \n          \n            \n               * desired contents of the new key. This is helpful if we intended\n          \n      \n    \n    \n  \n\nbut I guess \"contents\" means different things to different people. The number of calls to this method are relatively few so it's probably fine if the comment isn't crystal clear.", "author": "vcrfxia", "createdAt": "2020-11-23T17:29:19Z", "path": "ksqldb-execution/src/main/java/io/confluent/ksql/execution/plan/ExecutionKeyFactory.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Copyright 2019 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License; you may not use this file\n+ * except in compliance with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.execution.plan;\n+\n+import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n+import io.confluent.ksql.execution.context.QueryContext;\n+import io.confluent.ksql.schema.ksql.PhysicalSchema;\n+import io.confluent.ksql.serde.FormatInfo;\n+import io.confluent.ksql.serde.WindowInfo;\n+import io.confluent.ksql.testing.EffectivelyImmutable;\n+import java.util.Objects;\n+import org.apache.kafka.common.serialization.Serde;\n+import org.apache.kafka.connect.data.Struct;\n+import org.apache.kafka.streams.kstream.Windowed;\n+\n+/**\n+ * The {@code ExecutionKeyFactory} is in charge of creating the keys\n+ * and the Serdes for the keys of any particular execution step.\n+ *\n+ * @param <K> the type of the key, usually either {@code Struct}\n+ *            or {@code Windowed<Struct>}\n+ */\n+@EffectivelyImmutable\n+public interface ExecutionKeyFactory<K> {\n+\n+  Serde<K> buildKeySerde(\n+      FormatInfo format,\n+      PhysicalSchema physicalSchema,\n+      QueryContext queryContext\n+  );\n+\n+  /**\n+   * @return a new {@code ExecutionKeyFactory}\n+   */\n+  ExecutionKeyFactory<K> withQueryBuilder(KsqlQueryBuilder builder);\n+\n+  /**\n+   * This method can construct a new key given the contents of the old key and the\n+   * desired Struct representation of the new key. This is helpful if we intended", "originalCommit": "d5f39267b18df0c3bc7c4de9d94ff20458ce956a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg3NjcxNg==", "url": "https://github.com/confluentinc/ksql/pull/6642#discussion_r528876716", "bodyText": "nit: spacing", "author": "vcrfxia", "createdAt": "2020-11-23T17:29:28Z", "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/PartitionByParamsFactory.java", "diffHunk": "@@ -181,15 +183,15 @@ private static LogicalSchema buildSchema(\n \n     final KeyBuilder keyBuilder = StructKeyUtil.keyBuilder(resultSchema);\n \n-    return (k, v) -> {\n-      final Object newKey = evaluator.evaluate(k, v);\n-      final Struct structKey = keyBuilder.build(newKey, 0);\n+    return (oldK, row) -> {\n+      final Object newKey = evaluator.evaluate(oldK, row);\n+      final K key = executionKeyFactory.constructNewKey(oldK ,keyBuilder.build(newKey, 0));", "originalCommit": "d5f39267b18df0c3bc7c4de9d94ff20458ce956a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg3Njc0NQ==", "url": "https://github.com/confluentinc/ksql/pull/6642#discussion_r528876745", "bodyText": "How come we create a new ExecutionKeyFactory implementation here rather than using ExecutionKeyFactory.unwindowed() with a mock query builder?", "author": "vcrfxia", "createdAt": "2020-11-23T17:29:33Z", "path": "ksqldb-streams/src/test/java/io/confluent/ksql/execution/streams/PartitionByParamsFactoryTest.java", "diffHunk": "@@ -396,9 +400,35 @@ public void shouldNotChangeValueIfPartitioningByNull() {\n     assertThat(result.value, is(GenericRow.fromList(originals)));\n   }\n \n-  private PartitionByParams partitionBy(final Expression expression) {\n+  private PartitionByParams<Struct> partitionBy(final Expression expression) {\n+    final ExecutionKeyFactory<Struct> factory = new ExecutionKeyFactory<Struct>() {", "originalCommit": "d5f39267b18df0c3bc7c4de9d94ff20458ce956a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkyNjgwMA==", "url": "https://github.com/confluentinc/ksql/pull/6642#discussion_r528926800", "bodyText": "No good reason, I've changed it to do this.", "author": "agavra", "createdAt": "2020-11-23T18:56:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg3Njc0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg3Njc3OA==", "url": "https://github.com/confluentinc/ksql/pull/6642#discussion_r528876778", "bodyText": "nit: spacing", "author": "vcrfxia", "createdAt": "2020-11-23T17:29:36Z", "path": "ksqldb-streams/src/test/java/io/confluent/ksql/execution/streams/StreamSelectKeyBuilderTest.java", "diffHunk": "@@ -148,7 +157,7 @@ public void shouldPassCorrectArgsToParamBuilder() {\n     // Then:\n     verify(paramBuilder).build(\n         SOURCE_SCHEMA,\n-        KEY,\n+        stream.getKeySerdeFactory(), KEY,", "originalCommit": "d5f39267b18df0c3bc7c4de9d94ff20458ce956a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODkyNzEwMg==", "url": "https://github.com/confluentinc/ksql/pull/6642#discussion_r528927102", "bodyText": ":) auto-refactoring - thanks for catching", "author": "agavra", "createdAt": "2020-11-23T18:56:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODg3Njc3OA=="}], "type": "inlineReview"}, {"oid": "4874c2b1abb1dc71fb78aa1b4a1566d178b5a147", "url": "https://github.com/confluentinc/ksql/commit/4874c2b1abb1dc71fb78aa1b4a1566d178b5a147", "message": "chore: some minor updates", "committedDate": "2020-11-23T18:57:35Z", "type": "commit"}, {"oid": "ab156b9857b475cc51de51003af027da21a7b065", "url": "https://github.com/confluentinc/ksql/commit/ab156b9857b475cc51de51003af027da21a7b065", "message": "test me", "committedDate": "2020-11-23T19:45:23Z", "type": "commit"}]}