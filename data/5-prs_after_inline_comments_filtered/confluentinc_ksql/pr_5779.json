{"pr_number": 5779, "pr_title": "feat: add suppress node", "pr_createdAt": "2020-07-07T23:52:54Z", "pr_url": "https://github.com/confluentinc/ksql/pull/5779", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTY1OTA3MQ==", "url": "https://github.com/confluentinc/ksql/pull/5779#discussion_r451659071", "bodyText": "let's make sure the date and license are right!", "author": "agavra", "createdAt": "2020-07-08T16:06:37Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/SuppressNode.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright 2018 Confluent Inc.", "originalCommit": "539399b84e4aa46fa46efc42867baca93a58dcd4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTY1OTc5Mw==", "url": "https://github.com/confluentinc/ksql/pull/5779#discussion_r451659793", "bodyText": "I think we should add a detailed description of the design for the implementation in the PR description, and get at least one person other than me to +1 this PR to \"approve\" the design as well", "author": "agavra", "createdAt": "2020-07-08T16:07:43Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/LogicalPlanner.java", "diffHunk": "@@ -138,6 +140,10 @@ public OutputNode buildPlan() {\n       currentNode = buildUserProjectNode(currentNode);\n     }\n \n+    if (analysis.getResultMaterialization().get() == ResultMaterialization.FINAL) {\n+      currentNode = buildSuppressNode(currentNode, analysis.getResultMaterialization().get());", "originalCommit": "539399b84e4aa46fa46efc42867baca93a58dcd4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTY2NDAxOA==", "url": "https://github.com/confluentinc/ksql/pull/5779#discussion_r451664018", "bodyText": "It would be helpful for people who read this code in the future if we included a detailed javadoc description of what the suppress node is, how it works and where/why it is used.\nHistorically, our code base isn't really good about this but for anything new we should strive to keep good documentation! For some examples (choosing my own stuff because I know of them) you can take a look at https://github.com/confluentinc/ksql/blob/master/ksqldb-engine/src/main/java/io/confluent/ksql/planner/JoinTree.java and https://github.com/confluentinc/ksql/blob/master/ksqldb-common/src/main/java/io/confluent/ksql/function/UdfIndex.java", "author": "agavra", "createdAt": "2020-07-08T16:14:06Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/SuppressNode.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright 2018 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.planner.plan;\n+\n+import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n+import io.confluent.ksql.execution.context.QueryContext;\n+import io.confluent.ksql.parser.ResultMaterialization;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.structured.SchemaKStream;\n+import io.confluent.ksql.structured.SchemaKTable;\n+import java.util.Collections;\n+import java.util.Objects;\n+import org.apache.kafka.clients.consumer.ConsumerConfig;\n+\n+\n+\n+public class SuppressNode extends SingleSourcePlanNode {", "originalCommit": "539399b84e4aa46fa46efc42867baca93a58dcd4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTY2Njk0OQ==", "url": "https://github.com/confluentinc/ksql/pull/5779#discussion_r451666949", "bodyText": "this should be a KsqlException, and we should have a more detailed error message that includes (1) what is happening (i.e. building a suppress node) and (2) any context that might help debug it (e.g. the stream name)", "author": "agavra", "createdAt": "2020-07-08T16:18:39Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/SuppressNode.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright 2018 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.planner.plan;\n+\n+import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n+import io.confluent.ksql.execution.context.QueryContext;\n+import io.confluent.ksql.parser.ResultMaterialization;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.structured.SchemaKStream;\n+import io.confluent.ksql.structured.SchemaKTable;\n+import java.util.Collections;\n+import java.util.Objects;\n+import org.apache.kafka.clients.consumer.ConsumerConfig;\n+\n+\n+\n+public class SuppressNode extends SingleSourcePlanNode {\n+\n+  private final ResultMaterialization resultMaterialization;\n+\n+  public SuppressNode(\n+      final PlanNodeId id,\n+      final PlanNode source,\n+      final ResultMaterialization resultMaterialization\n+  ) {\n+    super(id, source.getNodeOutputType(), source.getSourceName(), source);\n+\n+    this.resultMaterialization = Objects.requireNonNull(\n+        resultMaterialization, \"resultMaterialization\");\n+  }\n+\n+  public ResultMaterialization getResultMaterialization() {\n+    return resultMaterialization;\n+  }\n+\n+  @Override\n+  public LogicalSchema getSchema() {\n+    return getSource().getSchema();\n+  }\n+\n+  @Override\n+  public SchemaKStream<?> buildStream(final KsqlQueryBuilder builder) {\n+    final QueryContext.Stacker contextStacker = builder.buildNodeContext(getId().toString());\n+    final SchemaKStream<?> schemaKStream = getSource().buildStream(\n+        builder.withKsqlConfig(builder.getKsqlConfig()\n+            .cloneWithPropertyOverwrite(Collections.singletonMap(\n+                ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, \"earliest\")))\n+    );\n+\n+    if (!(schemaKStream instanceof SchemaKTable)) {\n+      throw new RuntimeException(\"Expected to find a Table, found a stream instead.\");", "originalCommit": "539399b84e4aa46fa46efc42867baca93a58dcd4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTY2NzcxMg==", "url": "https://github.com/confluentinc/ksql/pull/5779#discussion_r451667712", "bodyText": "since we haven't implemented anything here yet, we should make sure that we throw a meaningful exception (e.g. throw new KsqlException(\"EMIT FINAL is not yet supported\")", "author": "agavra", "createdAt": "2020-07-08T16:19:49Z", "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/TableSuppressBuilder.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/*\n+ * Copyright 2019 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.execution.streams;\n+\n+import io.confluent.ksql.execution.plan.KTableHolder;\n+\n+public final class TableSuppressBuilder {\n+\n+  private TableSuppressBuilder() {\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public static <K> KTableHolder<K> build(\n+      final KTableHolder<K> table\n+  ) {\n+    return table;", "originalCommit": "539399b84e4aa46fa46efc42867baca93a58dcd4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTY2ODIyMA==", "url": "https://github.com/confluentinc/ksql/pull/5779#discussion_r451668220", "bodyText": "why are we adding this config to the suppress node?", "author": "agavra", "createdAt": "2020-07-08T16:20:36Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/SuppressNode.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright 2018 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.planner.plan;\n+\n+import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n+import io.confluent.ksql.execution.context.QueryContext;\n+import io.confluent.ksql.parser.ResultMaterialization;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.structured.SchemaKStream;\n+import io.confluent.ksql.structured.SchemaKTable;\n+import java.util.Collections;\n+import java.util.Objects;\n+import org.apache.kafka.clients.consumer.ConsumerConfig;\n+\n+\n+\n+public class SuppressNode extends SingleSourcePlanNode {\n+\n+  private final ResultMaterialization resultMaterialization;\n+\n+  public SuppressNode(\n+      final PlanNodeId id,\n+      final PlanNode source,\n+      final ResultMaterialization resultMaterialization\n+  ) {\n+    super(id, source.getNodeOutputType(), source.getSourceName(), source);\n+\n+    this.resultMaterialization = Objects.requireNonNull(\n+        resultMaterialization, \"resultMaterialization\");\n+  }\n+\n+  public ResultMaterialization getResultMaterialization() {\n+    return resultMaterialization;\n+  }\n+\n+  @Override\n+  public LogicalSchema getSchema() {\n+    return getSource().getSchema();\n+  }\n+\n+  @Override\n+  public SchemaKStream<?> buildStream(final KsqlQueryBuilder builder) {\n+    final QueryContext.Stacker contextStacker = builder.buildNodeContext(getId().toString());\n+    final SchemaKStream<?> schemaKStream = getSource().buildStream(\n+        builder.withKsqlConfig(builder.getKsqlConfig()\n+            .cloneWithPropertyOverwrite(Collections.singletonMap(\n+                ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, \"earliest\")))\n+    );", "originalCommit": "539399b84e4aa46fa46efc42867baca93a58dcd4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTY5NDg3Ng==", "url": "https://github.com/confluentinc/ksql/pull/5779#discussion_r451694876", "bodyText": "any reason to have another method to call out to instead of inlining return schema here?", "author": "agavra", "createdAt": "2020-07-08T17:02:40Z", "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/StepSchemaResolver.java", "diffHunk": "@@ -293,6 +295,13 @@ private LogicalSchema handleTableSelect(\n     return buildSelectSchema(schema, step.getKeyColumnNames(), step.getSelectExpressions());\n   }\n \n+  private LogicalSchema handleTableSuppress(\n+      final LogicalSchema schema,\n+      final TableSuppress<?> step\n+  ) {\n+    return buildSuppressSchema(schema);", "originalCommit": "539399b84e4aa46fa46efc42867baca93a58dcd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTcwNzcwNQ==", "url": "https://github.com/confluentinc/ksql/pull/5779#discussion_r451707705", "bodyText": "No we can simply just use the existing method sameSchema  instead of creating handleTableSuppress and buildSuppressSchema methods, since Suppress does not alter the schema", "author": "nae701", "createdAt": "2020-07-08T17:24:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTY5NDg3Ng=="}], "type": "inlineReview"}, {"oid": "b2b80285b58a97f1a299c38889cb4dea6a974eb7", "url": "https://github.com/confluentinc/ksql/commit/b2b80285b58a97f1a299c38889cb4dea6a974eb7", "message": "test: add unit tests for suppress node", "committedDate": "2020-07-10T21:20:12Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA5NDc3Mg==", "url": "https://github.com/confluentinc/ksql/pull/5779#discussion_r453094772", "bodyText": "This is an unneccesary import", "author": "nae701", "createdAt": "2020-07-10T21:56:37Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/planner/LogicalPlannerTest.java", "diffHunk": "@@ -32,10 +32,12 @@\n import io.confluent.ksql.name.SourceName;\n import io.confluent.ksql.planner.plan.DataSourceNode;\n import io.confluent.ksql.planner.plan.FilterNode;\n+import io.confluent.ksql.planner.plan.FinalProjectNode;", "originalCommit": "b2b80285b58a97f1a299c38889cb4dea6a974eb7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA5NDE4OA==", "url": "https://github.com/confluentinc/ksql/pull/5779#discussion_r453094188", "bodyText": "can this just be buildStream(builder) do we need to reset the ksqlConfig?", "author": "agavra", "createdAt": "2020-07-10T21:55:03Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/SuppressNode.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.planner.plan;\n+\n+import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n+import io.confluent.ksql.execution.context.QueryContext;\n+import io.confluent.ksql.name.SourceName;\n+import io.confluent.ksql.parser.ResultMaterialization;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.structured.SchemaKStream;\n+import io.confluent.ksql.structured.SchemaKTable;\n+import java.util.Objects;\n+\n+import io.confluent.ksql.util.KsqlException;\n+\n+\n+/**\n+ The suppress node is a plan node that is added to the logical plan if the user specifies in their\n+ ksqlDB query that the result materialization should be EMIT FINAL. The physical plan is then built\n+ and executed using the logical plan, and executes all of the plan nodes that were added from the\n+ logical plan including the suppress node if it was added. Currently the suppress node needs to be\n+ added at the end of the logical plan right before we build the output node, this is so that we can\n+ suppress results that may need to be aggregated or altered somehow. Using a suppress node also\n+ allows for more flexibility in the future in terms of enhancements or different types of\n+ suppression being supported.\n+ */\n+public class SuppressNode extends SingleSourcePlanNode implements VerifiableNode {\n+\n+  private final ResultMaterialization resultMaterialization;\n+\n+  public SuppressNode(\n+      final PlanNodeId id,\n+      final PlanNode source,\n+      final ResultMaterialization resultMaterialization\n+  ) {\n+    super(id, source.getNodeOutputType(), source.getSourceName(), source);\n+\n+    this.resultMaterialization = Objects.requireNonNull(\n+        resultMaterialization, \"resultMaterialization\");\n+  }\n+\n+  public ResultMaterialization getResultMaterialization() {\n+    return resultMaterialization;\n+  }\n+\n+  @Override\n+  public LogicalSchema getSchema() {\n+    return getSource().getSchema();\n+  }\n+\n+  @Override\n+  public SchemaKStream<?> buildStream(final KsqlQueryBuilder builder) {\n+    final QueryContext.Stacker contextStacker = builder.buildNodeContext(getId().toString());\n+    final SchemaKStream<?> schemaKStream = getSource().buildStream(\n+        builder.withKsqlConfig(builder.getKsqlConfig())", "originalCommit": "b2b80285b58a97f1a299c38889cb4dea6a974eb7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA5NTIyNQ==", "url": "https://github.com/confluentinc/ksql/pull/5779#discussion_r453095225", "bodyText": "schemaKStream.toString() doesn't seem to be very helpful - it'll probably give us something like SchemaKStream@[b1234. I know I originally asked you to put this in, but I'm not actually sure what name we could put here that would be meaningful - we can change it back to just Expected to find a Table but found a stream", "author": "agavra", "createdAt": "2020-07-10T21:57:58Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/SuppressNode.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.planner.plan;\n+\n+import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n+import io.confluent.ksql.execution.context.QueryContext;\n+import io.confluent.ksql.name.SourceName;\n+import io.confluent.ksql.parser.ResultMaterialization;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.structured.SchemaKStream;\n+import io.confluent.ksql.structured.SchemaKTable;\n+import java.util.Objects;\n+\n+import io.confluent.ksql.util.KsqlException;\n+\n+\n+/**\n+ The suppress node is a plan node that is added to the logical plan if the user specifies in their\n+ ksqlDB query that the result materialization should be EMIT FINAL. The physical plan is then built\n+ and executed using the logical plan, and executes all of the plan nodes that were added from the\n+ logical plan including the suppress node if it was added. Currently the suppress node needs to be\n+ added at the end of the logical plan right before we build the output node, this is so that we can\n+ suppress results that may need to be aggregated or altered somehow. Using a suppress node also\n+ allows for more flexibility in the future in terms of enhancements or different types of\n+ suppression being supported.\n+ */\n+public class SuppressNode extends SingleSourcePlanNode implements VerifiableNode {\n+\n+  private final ResultMaterialization resultMaterialization;\n+\n+  public SuppressNode(\n+      final PlanNodeId id,\n+      final PlanNode source,\n+      final ResultMaterialization resultMaterialization\n+  ) {\n+    super(id, source.getNodeOutputType(), source.getSourceName(), source);\n+\n+    this.resultMaterialization = Objects.requireNonNull(\n+        resultMaterialization, \"resultMaterialization\");\n+  }\n+\n+  public ResultMaterialization getResultMaterialization() {\n+    return resultMaterialization;\n+  }\n+\n+  @Override\n+  public LogicalSchema getSchema() {\n+    return getSource().getSchema();\n+  }\n+\n+  @Override\n+  public SchemaKStream<?> buildStream(final KsqlQueryBuilder builder) {\n+    final QueryContext.Stacker contextStacker = builder.buildNodeContext(getId().toString());\n+    final SchemaKStream<?> schemaKStream = getSource().buildStream(\n+        builder.withKsqlConfig(builder.getKsqlConfig())\n+    );\n+\n+    if (!(schemaKStream instanceof SchemaKTable)) {\n+      throw new KsqlException(\"Failed to build suppress node. Expected to find a Table, but \"\n+          + \"found a stream named \" + schemaKStream.toString() + \" instead.\");", "originalCommit": "b2b80285b58a97f1a299c38889cb4dea6a974eb7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA5NzY2OQ==", "url": "https://github.com/confluentinc/ksql/pull/5779#discussion_r453097669", "bodyText": "we should delegate the the source node and call source.validateKeyPresent(sinkName) (we'll have to assert that source is instance of VerifiableNode and then cast it)", "author": "agavra", "createdAt": "2020-07-10T22:03:18Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/SuppressNode.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.planner.plan;\n+\n+import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n+import io.confluent.ksql.execution.context.QueryContext;\n+import io.confluent.ksql.name.SourceName;\n+import io.confluent.ksql.parser.ResultMaterialization;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.structured.SchemaKStream;\n+import io.confluent.ksql.structured.SchemaKTable;\n+import java.util.Objects;\n+\n+import io.confluent.ksql.util.KsqlException;\n+\n+\n+/**\n+ The suppress node is a plan node that is added to the logical plan if the user specifies in their\n+ ksqlDB query that the result materialization should be EMIT FINAL. The physical plan is then built\n+ and executed using the logical plan, and executes all of the plan nodes that were added from the\n+ logical plan including the suppress node if it was added. Currently the suppress node needs to be\n+ added at the end of the logical plan right before we build the output node, this is so that we can\n+ suppress results that may need to be aggregated or altered somehow. Using a suppress node also\n+ allows for more flexibility in the future in terms of enhancements or different types of\n+ suppression being supported.\n+ */\n+public class SuppressNode extends SingleSourcePlanNode implements VerifiableNode {\n+\n+  private final ResultMaterialization resultMaterialization;\n+\n+  public SuppressNode(\n+      final PlanNodeId id,\n+      final PlanNode source,\n+      final ResultMaterialization resultMaterialization\n+  ) {\n+    super(id, source.getNodeOutputType(), source.getSourceName(), source);\n+\n+    this.resultMaterialization = Objects.requireNonNull(\n+        resultMaterialization, \"resultMaterialization\");\n+  }\n+\n+  public ResultMaterialization getResultMaterialization() {\n+    return resultMaterialization;\n+  }\n+\n+  @Override\n+  public LogicalSchema getSchema() {\n+    return getSource().getSchema();\n+  }\n+\n+  @Override\n+  public SchemaKStream<?> buildStream(final KsqlQueryBuilder builder) {\n+    final QueryContext.Stacker contextStacker = builder.buildNodeContext(getId().toString());\n+    final SchemaKStream<?> schemaKStream = getSource().buildStream(\n+        builder.withKsqlConfig(builder.getKsqlConfig())\n+    );\n+\n+    if (!(schemaKStream instanceof SchemaKTable)) {\n+      throw new KsqlException(\"Failed to build suppress node. Expected to find a Table, but \"\n+          + \"found a stream named \" + schemaKStream.toString() + \" instead.\");\n+    }\n+\n+    return (((SchemaKTable<?>) schemaKStream)\n+        .suppress(\n+            resultMaterialization,\n+            contextStacker\n+        ));\n+  }\n+\n+  @Override\n+  public void validateKeyPresent(final SourceName sinkName) {", "originalCommit": "b2b80285b58a97f1a299c38889cb4dea6a974eb7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzEwMDg2NQ==", "url": "https://github.com/confluentinc/ksql/pull/5779#discussion_r453100865", "bodyText": "we might want to make this test a window aggregation, we probably actually want to fail in this scenario in the logical planner and throw \"EMIT FINAL is only supported for windowed aggregations\" until (if) we support non-windowed suppressed", "author": "agavra", "createdAt": "2020-07-10T22:13:51Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/planner/LogicalPlannerTest.java", "diffHunk": "@@ -132,6 +134,17 @@ public void testSimpleLeftJoinFilterLogicalPlan() {\n     assertThat(rightSource.getSources().get(0), instanceOf(RepartitionNode.class));\n   }\n \n+  @Test\n+  public void testSimpleSuppressLogicalPlan() {\n+    final String simpleQuery = \"SELECT * FROM test2 EMIT FINAL;\";", "originalCommit": "b2b80285b58a97f1a299c38889cb4dea6a974eb7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzEyNDk3Ng==", "url": "https://github.com/confluentinc/ksql/pull/5779#discussion_r453124976", "bodyText": "these should be in the //Given section. I know it says \"when\" but for the Given/When/Then pattern, the \"When\" should be the functionality that we are testing, the \"Given\" should be the setup required to test that, and the \"Then\" should be assertions", "author": "agavra", "createdAt": "2020-07-10T23:53:47Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/planner/plan/SuppressNodeTest.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.planner.plan;\n+\n+import static io.confluent.ksql.metastore.model.DataSource.DataSourceType;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.junit.Assert.assertThrows;\n+import static org.mockito.ArgumentMatchers.any;\n+\n+import static org.mockito.Mockito.when;\n+\n+import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n+import io.confluent.ksql.execution.context.QueryContext.Stacker;\n+import io.confluent.ksql.parser.ResultMaterialization;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.structured.SchemaKStream;\n+import io.confluent.ksql.structured.SchemaKTable;\n+import io.confluent.ksql.util.KsqlException;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+\n+public class SuppressNodeTest {\n+\n+  private static final PlanNodeId NODE_ID = new PlanNodeId(\"nodeid\");\n+\n+  @Mock\n+  private ResultMaterialization resultMaterialization;\n+  @Mock\n+  private PlanNode sourceNode;\n+  @Mock\n+  private SchemaKStream schemaKStream;\n+  @Mock\n+  private SchemaKTable schemaKTable;\n+  @Mock\n+  private KsqlQueryBuilder ksqlStreamBuilder;\n+  @Mock\n+  private Stacker stacker;\n+\n+  private SuppressNode node;\n+\n+  @Rule\n+  public final MockitoRule mockitoRule = MockitoJUnit.rule();\n+\n+  @Test\n+  @SuppressWarnings(\"unchecked\")\n+  public void shouldThrowOnSuppressOnStream() {\n+\n+    // When:\n+    when(sourceNode.getSchema()).thenReturn(LogicalSchema.builder().build());\n+    when(sourceNode.buildStream(any()))\n+        .thenReturn(schemaKStream);\n+    when(sourceNode.getNodeOutputType()).thenReturn(DataSourceType.KSTREAM);\n+    when(schemaKTable.suppress(any(), any()))\n+        .thenReturn(schemaKTable);", "originalCommit": "b2b80285b58a97f1a299c38889cb4dea6a974eb7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzEyNTA1Nw==", "url": "https://github.com/confluentinc/ksql/pull/5779#discussion_r453125057", "bodyText": "we should have a test that ensures SchemaKStream#suppress is called when buildStream is called on a SuppressNode (you can use Mockito#verify for that)", "author": "agavra", "createdAt": "2020-07-10T23:54:22Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/planner/plan/SuppressNodeTest.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.planner.plan;\n+\n+import static io.confluent.ksql.metastore.model.DataSource.DataSourceType;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.junit.Assert.assertThrows;\n+import static org.mockito.ArgumentMatchers.any;\n+\n+import static org.mockito.Mockito.when;\n+\n+import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n+import io.confluent.ksql.execution.context.QueryContext.Stacker;\n+import io.confluent.ksql.parser.ResultMaterialization;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.structured.SchemaKStream;\n+import io.confluent.ksql.structured.SchemaKTable;\n+import io.confluent.ksql.util.KsqlException;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+\n+public class SuppressNodeTest {\n+\n+  private static final PlanNodeId NODE_ID = new PlanNodeId(\"nodeid\");\n+\n+  @Mock\n+  private ResultMaterialization resultMaterialization;\n+  @Mock\n+  private PlanNode sourceNode;\n+  @Mock\n+  private SchemaKStream schemaKStream;\n+  @Mock\n+  private SchemaKTable schemaKTable;\n+  @Mock\n+  private KsqlQueryBuilder ksqlStreamBuilder;\n+  @Mock\n+  private Stacker stacker;\n+\n+  private SuppressNode node;\n+\n+  @Rule\n+  public final MockitoRule mockitoRule = MockitoJUnit.rule();\n+\n+  @Test\n+  @SuppressWarnings(\"unchecked\")\n+  public void shouldThrowOnSuppressOnStream() {", "originalCommit": "b2b80285b58a97f1a299c38889cb4dea6a974eb7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzEyNTUyNg==", "url": "https://github.com/confluentinc/ksql/pull/5779#discussion_r453125526", "bodyText": "for extensibility, we might want to wrap this in a Refinement class that we introduce. Imagine in the future we want to add a EMIT EVERY N SECONDS, the result materialization would be parameterized so an enum wouldn't fly. We could have the ResultMaterialization be TIMED and then have the refinement specify the time interval.\nin general, having enums in model classes is a little bit of an anti-pattern because they're tough to evolve in a backwards compatible way\nalso not your fault, but materialization is a super overloaded word \ud83d\ude22 it might be nice to change this to outputRefinement sooner rather than later (especially in the physical plan, where this stuff gets persisted into our API and can't change easily) so that the terminology is easier to understand", "author": "agavra", "createdAt": "2020-07-10T23:56:47Z", "path": "ksqldb-execution/src/main/java/io/confluent/ksql/execution/plan/TableSuppress.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright 2019 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License; you may not use this file\n+ * except in compliance with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.execution.plan;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.errorprone.annotations.Immutable;\n+import io.confluent.ksql.parser.ResultMaterialization;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+\n+@Immutable\n+public class TableSuppress<K> implements ExecutionStep<KTableHolder<K>> {\n+\n+  private final ExecutionStepPropertiesV1 properties;\n+  private final ExecutionStep<KTableHolder<K>> source;\n+  private final ResultMaterialization resultMaterialization;\n+\n+  public TableSuppress(\n+      @JsonProperty(value = \"properties\", required = true) final ExecutionStepPropertiesV1 props,\n+      @JsonProperty(value = \"source\", required = true) final ExecutionStep<KTableHolder<K>> source,\n+      @JsonProperty(value = \"resultMaterialization\",\n+          required = true) final ResultMaterialization resultMaterialization", "originalCommit": "b2b80285b58a97f1a299c38889cb4dea6a974eb7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzEyNjQyMA==", "url": "https://github.com/confluentinc/ksql/pull/5779#discussion_r453126420", "bodyText": "why is there a suppress here?", "author": "agavra", "createdAt": "2020-07-11T00:01:19Z", "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/TableSuppressBuilder.java", "diffHunk": "@@ -0,0 +1,32 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.execution.streams;\n+\n+import io.confluent.ksql.execution.plan.KTableHolder;\n+import io.confluent.ksql.util.KsqlException;\n+\n+public final class TableSuppressBuilder {\n+\n+  private TableSuppressBuilder() {\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")", "originalCommit": "b2b80285b58a97f1a299c38889cb4dea6a974eb7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9b3a105c8b4ea0be76fcdd4ea321ea681c0764a3", "url": "https://github.com/confluentinc/ksql/commit/9b3a105c8b4ea0be76fcdd4ea321ea681c0764a3", "message": "test: add RefinementInfo tests", "committedDate": "2020-07-16T23:35:47Z", "type": "forcePushed"}, {"oid": "23c674efbeef3235565b403424c90a58245eb3ee", "url": "https://github.com/confluentinc/ksql/commit/23c674efbeef3235565b403424c90a58245eb3ee", "message": "feat: add suppress node", "committedDate": "2020-07-17T00:19:24Z", "type": "commit"}, {"oid": "647d4e62363caa4f40a2ca9461c19303a2ae1060", "url": "https://github.com/confluentinc/ksql/commit/647d4e62363caa4f40a2ca9461c19303a2ae1060", "message": "chore: trim redundant condition", "committedDate": "2020-07-17T00:19:24Z", "type": "commit"}, {"oid": "6303bc5c157a4637a1f6f5f5ee08af2444ec6bed", "url": "https://github.com/confluentinc/ksql/commit/6303bc5c157a4637a1f6f5f5ee08af2444ec6bed", "message": "fix: correct license year, remove redundancy in schema resolver", "committedDate": "2020-07-17T00:19:24Z", "type": "commit"}, {"oid": "f858f8700bf32429fa139fb162b9fa74604a5cdb", "url": "https://github.com/confluentinc/ksql/commit/f858f8700bf32429fa139fb162b9fa74604a5cdb", "message": "test: add unit tests for suppress node", "committedDate": "2020-07-17T00:21:34Z", "type": "commit"}, {"oid": "b55a19eb3ea906100a6fb762d2c702d5e4fa7083", "url": "https://github.com/confluentinc/ksql/commit/b55a19eb3ea906100a6fb762d2c702d5e4fa7083", "message": "feat: add refinementInfo wrapper", "committedDate": "2020-07-17T00:21:34Z", "type": "commit"}, {"oid": "1e0f2baf0cbfb03eac911a2685d31ada6b773e9e", "url": "https://github.com/confluentinc/ksql/commit/1e0f2baf0cbfb03eac911a2685d31ada6b773e9e", "message": "test: fix tests for refinement", "committedDate": "2020-07-17T00:21:34Z", "type": "commit"}, {"oid": "7237084ecd2766b7b64883f99e3601bd1e5c290f", "url": "https://github.com/confluentinc/ksql/commit/7237084ecd2766b7b64883f99e3601bd1e5c290f", "message": "test: add RefinementInfo tests", "committedDate": "2020-07-17T00:21:34Z", "type": "commit"}, {"oid": "67af3c33eacf45dbd5cdbb62d905851ae5ab7a0f", "url": "https://github.com/confluentinc/ksql/commit/67af3c33eacf45dbd5cdbb62d905851ae5ab7a0f", "message": "chore: remove comments and fix nits", "committedDate": "2020-07-17T00:21:34Z", "type": "commit"}, {"oid": "67af3c33eacf45dbd5cdbb62d905851ae5ab7a0f", "url": "https://github.com/confluentinc/ksql/commit/67af3c33eacf45dbd5cdbb62d905851ae5ab7a0f", "message": "chore: remove comments and fix nits", "committedDate": "2020-07-17T00:21:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE2Mzc2NA==", "url": "https://github.com/confluentinc/ksql/pull/5779#discussion_r456163764", "bodyText": "I'm confused, why is the OutputRefinement an optional? I feel like if you have a RefinementInfo it should have an OutputRefinement", "author": "agavra", "createdAt": "2020-07-17T01:14:14Z", "path": "ksqldb-common/src/main/java/io/confluent/ksql/serde/RefinementInfo.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.serde;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.errorprone.annotations.Immutable;\n+import io.confluent.ksql.parser.OutputRefinement;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+/**\n+ * Immutable pojo for storing info about a refinement.\n+ */\n+@Immutable\n+public final class RefinementInfo {\n+\n+  private final Optional<OutputRefinement> outputRefinement;\n+\n+  @JsonCreator\n+  public static RefinementInfo of(\n+      @JsonProperty(value = \"outputRefinement\", required = true)\n+      final Optional<OutputRefinement> outputRefinement", "originalCommit": "67af3c33eacf45dbd5cdbb62d905851ae5ab7a0f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE2NDI2NA==", "url": "https://github.com/confluentinc/ksql/pull/5779#discussion_r456164264", "bodyText": "this is an awesome tool to use for testing! you probably don't need each equality group to have the same thing twice though. If the first equality group has something twice it's testing \"if the same object is .equals with itself, does it return true?\" - you only need to test that once.", "author": "agavra", "createdAt": "2020-07-17T01:15:49Z", "path": "ksqldb-common/src/test/java/io/confluent/ksql/serde/RefinementInfoTest.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.serde;\n+\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.is;\n+\n+import com.google.common.testing.EqualsTester;\n+import com.google.common.testing.NullPointerTester;\n+import java.util.Optional;\n+\n+import io.confluent.ksql.parser.OutputRefinement;\n+import org.junit.Test;\n+\n+public class RefinementInfoTest {\n+  @Test\n+  public void shouldThrowNPEs() {\n+    new NullPointerTester()\n+        .testAllPublicStaticMethods(RefinementInfo.class);\n+  }\n+\n+  @Test\n+  public void shouldImplementEquals() {\n+    new EqualsTester()", "originalCommit": "67af3c33eacf45dbd5cdbb62d905851ae5ab7a0f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE2NDQ2MQ==", "url": "https://github.com/confluentinc/ksql/pull/5779#discussion_r456164461", "bodyText": "in my opinion, this test doesn't really add much - testing getters/setters is usually too much testing (which I think is a real thing!)", "author": "agavra", "createdAt": "2020-07-17T01:16:24Z", "path": "ksqldb-common/src/test/java/io/confluent/ksql/serde/RefinementInfoTest.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.serde;\n+\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.is;\n+\n+import com.google.common.testing.EqualsTester;\n+import com.google.common.testing.NullPointerTester;\n+import java.util.Optional;\n+\n+import io.confluent.ksql.parser.OutputRefinement;\n+import org.junit.Test;\n+\n+public class RefinementInfoTest {\n+  @Test\n+  public void shouldThrowNPEs() {\n+    new NullPointerTester()\n+        .testAllPublicStaticMethods(RefinementInfo.class);\n+  }\n+\n+  @Test\n+  public void shouldImplementEquals() {\n+    new EqualsTester()\n+        .addEqualityGroup(\n+            RefinementInfo.of(Optional.of(OutputRefinement.FINAL)),\n+            RefinementInfo.of(Optional.of(OutputRefinement.FINAL))\n+        )\n+        .addEqualityGroup(\n+            RefinementInfo.of(Optional.of(OutputRefinement.CHANGES)),\n+            RefinementInfo.of(Optional.of(OutputRefinement.CHANGES))\n+        )\n+        .addEqualityGroup(\n+            RefinementInfo.of(Optional.empty()),\n+            RefinementInfo.of(Optional.empty())\n+        )\n+        .testEquals();\n+  }\n+\n+  @Test\n+  public void shouldImplementToString() {\n+    // Given:\n+    final RefinementInfo refinementInfo = RefinementInfo.of(Optional.of(OutputRefinement.FINAL));\n+\n+    // When:\n+    final String result = refinementInfo.toString();\n+\n+    // Then:\n+    assertThat(result, containsString(\"FINAL\"));\n+  }\n+\n+  @Test\n+  public void shouldGetOutputRefinement() {", "originalCommit": "67af3c33eacf45dbd5cdbb62d905851ae5ab7a0f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjE2OTk1Nw==", "url": "https://github.com/confluentinc/ksql/pull/5779#discussion_r456169957", "bodyText": "super-nit: this should be IllegalStateException - meaning something happened that is the server's fault but shouldn't happen. IllegalArgumentException is usually reserved for the user passing in a bad argument. I do realize this is what KsqlStructuredOutputNode does, but I think it's wrong \ud83d\ude02", "author": "agavra", "createdAt": "2020-07-17T01:36:36Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/planner/plan/SuppressNode.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.planner.plan;\n+\n+import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n+import io.confluent.ksql.execution.context.QueryContext;\n+import io.confluent.ksql.name.SourceName;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.serde.RefinementInfo;\n+import io.confluent.ksql.structured.SchemaKStream;\n+import io.confluent.ksql.structured.SchemaKTable;\n+import io.confluent.ksql.util.KsqlException;\n+import java.util.Objects;\n+\n+\n+\n+/**\n+ The suppress node is a plan node that is added to the logical plan if the user specifies in their\n+ ksqlDB query that the result materialization should be EMIT FINAL. The physical plan is then built\n+ and executed using the logical plan, and executes all of the plan nodes that were added from the\n+ logical plan including the suppress node if it was added. Currently the suppress node needs to be\n+ added at the end of the logical plan right before we build the output node, this is so that we can\n+ suppress results that may need to be aggregated or altered somehow. Using a suppress node also\n+ allows for more flexibility in the future in terms of enhancements or different types of\n+ suppression being supported.\n+ */\n+public class SuppressNode extends SingleSourcePlanNode implements VerifiableNode {\n+\n+  private final RefinementInfo refinementInfo;\n+\n+  public SuppressNode(\n+      final PlanNodeId id,\n+      final PlanNode source,\n+      final RefinementInfo refinementInfo\n+  ) {\n+    super(id, source.getNodeOutputType(), source.getSourceName(), source);\n+\n+    this.refinementInfo = Objects.requireNonNull(\n+        refinementInfo, \"refinementInfo\");\n+  }\n+\n+  public RefinementInfo getRefinementInfo() {\n+    return refinementInfo;\n+  }\n+\n+  @Override\n+  public LogicalSchema getSchema() {\n+    return getSource().getSchema();\n+  }\n+\n+  @Override\n+  public SchemaKStream<?> buildStream(final KsqlQueryBuilder builder) {\n+    final QueryContext.Stacker contextStacker = builder.buildNodeContext(getId().toString());\n+    final SchemaKStream<?> schemaKStream = getSource().buildStream(builder);\n+\n+    if (!(schemaKStream instanceof SchemaKTable)) {\n+      throw new KsqlException(\"Failed in suppress node. Expected to find a Table, but \"\n+          + \"found a stream instead.\");\n+    }\n+\n+\n+    return (((SchemaKTable<?>) schemaKStream)\n+        .suppress(\n+            refinementInfo,\n+            contextStacker\n+        ));\n+  }\n+\n+  @Override\n+  public void validateKeyPresent(final SourceName sinkName) {\n+    if (!(this.getSource() instanceof VerifiableNode)) {\n+      throw new IllegalArgumentException(\"VerifiableNode required\");", "originalCommit": "67af3c33eacf45dbd5cdbb62d905851ae5ab7a0f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUyOTY1MQ==", "url": "https://github.com/confluentinc/ksql/pull/5779#discussion_r456529651", "bodyText": "nit: this method call can be in an @Before method", "author": "agavra", "createdAt": "2020-07-17T15:54:52Z", "path": "ksqldb-engine/src/test/java/io/confluent/ksql/planner/plan/SuppressNodeTest.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.planner.plan;\n+\n+import static io.confluent.ksql.metastore.model.DataSource.DataSourceType;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.junit.Assert.assertThrows;\n+import static org.mockito.ArgumentMatchers.any;\n+\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import io.confluent.ksql.execution.builder.KsqlQueryBuilder;\n+import io.confluent.ksql.execution.context.QueryContext.Stacker;\n+import io.confluent.ksql.parser.OutputRefinement;\n+import io.confluent.ksql.serde.RefinementInfo;\n+import io.confluent.ksql.structured.SchemaKTable;\n+import io.confluent.ksql.util.KsqlException;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnit;\n+import org.mockito.junit.MockitoRule;\n+\n+public class SuppressNodeTest {\n+\n+  private static final PlanNodeId NODE_ID = new PlanNodeId(\"nodeid\");\n+\n+  @Mock\n+  private RefinementInfo refinementInfo;\n+  @Mock\n+  private PlanNode sourceNode;\n+  @Mock\n+  private SchemaKTable schemaKTable;\n+  @Mock\n+  private KsqlQueryBuilder ksqlStreamBuilder;\n+  @Mock\n+  private Stacker stacker;\n+\n+  private SuppressNode node;\n+\n+  @Rule\n+  public final MockitoRule mockitoRule = MockitoJUnit.rule();\n+\n+  @Test\n+  @SuppressWarnings(\"unchecked\")\n+  public void shouldThrowOnSuppressOnStream() {\n+\n+    // Given:\n+    when(sourceNode.getNodeOutputType()).thenReturn(DataSourceType.KSTREAM);\n+    when(ksqlStreamBuilder.buildNodeContext(NODE_ID.toString())).thenReturn(stacker);", "originalCommit": "67af3c33eacf45dbd5cdbb62d905851ae5ab7a0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY4NzU0NQ==", "url": "https://github.com/confluentinc/ksql/pull/5779#discussion_r456687545", "bodyText": "I don't think I can in this case because the first test requires a stream so that it fails and the second test requires a table so it can succeed, and thus I can't use the @Before to set both up.", "author": "nae701", "createdAt": "2020-07-17T21:45:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUyOTY1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY5MTI4OA==", "url": "https://github.com/confluentinc/ksql/pull/5779#discussion_r456691288", "bodyText": "I meant just the second of the two (about the stacker)", "author": "agavra", "createdAt": "2020-07-17T21:57:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjUyOTY1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY1NTYwNQ==", "url": "https://github.com/confluentinc/ksql/pull/5779#discussion_r456655605", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  final Optional<RefinementInfo> refinementInfo;\n          \n          \n            \n                  if (!pullQuery) {\n          \n          \n            \n                    refinementInfo = Optional.of(RefinementInfo.of(outputRefinement));\n          \n          \n            \n                  } else {\n          \n          \n            \n                    refinementInfo = Optional.empty();\n          \n          \n            \n            \n          \n          \n            \n                  }\n          \n          \n            \n                  final Optional<RefinementInfo> refinementInfo = outputRefinement.map(RefinementInfo::of);\n          \n      \n    \n    \n  \n\nThis way we don't duplicate the if (!pullQuery) logic from above and just rely on knowing that if it's a pull query the outputRefinement will already be Optional.empy()", "author": "agavra", "createdAt": "2020-07-17T20:19:06Z", "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/AstBuilder.java", "diffHunk": "@@ -398,34 +399,40 @@ public Query visitQuery(final SqlBaseParser.QueryContext context) {\n \n       final boolean pullQuery = context.EMIT() == null && !buildingPersistentQuery;\n \n-      final Optional<ResultMaterialization> resultMaterialization;\n+      final Optional<OutputRefinement> outputRefinement;\n \n       if (pullQuery) {\n-        resultMaterialization = Optional.empty();\n+        outputRefinement = Optional.empty();\n       } else if (buildingPersistentQuery) {\n-        resultMaterialization = Optional.of(Optional\n+        outputRefinement = Optional.of(Optional\n             .ofNullable(context.resultMaterialization())\n             .map(rm -> rm.FINAL() == null\n-                ? ResultMaterialization.CHANGES\n-                : ResultMaterialization.FINAL\n+                ? OutputRefinement.CHANGES\n+                : OutputRefinement.FINAL\n             )\n-            .orElse(ResultMaterialization.CHANGES));\n+            .orElse(OutputRefinement.CHANGES));\n         // Else must be a push query, which must specify a materialization\n       } else {\n-        resultMaterialization = Optional\n+        outputRefinement = Optional\n             .of(context.resultMaterialization().CHANGES() == null\n-                ? ResultMaterialization.FINAL\n-                : ResultMaterialization.CHANGES\n+                ? OutputRefinement.FINAL\n+                : OutputRefinement.CHANGES\n             );\n       }\n+      final Optional<RefinementInfo> refinementInfo;\n+      if (!pullQuery) {\n+        refinementInfo = Optional.of(RefinementInfo.of(outputRefinement));\n+      } else {\n+        refinementInfo = Optional.empty();\n+\n+      }", "originalCommit": "67af3c33eacf45dbd5cdbb62d905851ae5ab7a0f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY1NzAzMA==", "url": "https://github.com/confluentinc/ksql/pull/5779#discussion_r456657030", "bodyText": "this goes back to my comment above that the OutputRefinement inside the RefinementInfo shouldn't be optional - we expect it to be present. If it's possible that it's not present, then we need to check isPresent (which I'm not sure what we'd do if its not)", "author": "agavra", "createdAt": "2020-07-17T20:22:52Z", "path": "ksqldb-parser/src/main/java/io/confluent/ksql/parser/SqlFormatter.java", "diffHunk": "@@ -127,9 +127,12 @@ protected Void visitQuery(final Query node, final Integer indent) {\n       }\n \n       if (!node.isPullQuery()) {\n-        if (node.getResultMaterialization().isPresent()) {\n+        if (node.getRefinement().isPresent()\n+            && node.getRefinement().get().getOutputRefinement().isPresent()) {\n           append(indent, \"EMIT \");\n-          append(indent, node.getResultMaterialization()\n+          append(indent, node.getRefinement()\n+              .get()\n+              .getOutputRefinement()", "originalCommit": "67af3c33eacf45dbd5cdbb62d905851ae5ab7a0f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "494261eb5b39052e8056115526d513d108c7a1d3", "url": "https://github.com/confluentinc/ksql/commit/494261eb5b39052e8056115526d513d108c7a1d3", "message": "chore: fix style issues and nits", "committedDate": "2020-07-17T22:32:12Z", "type": "commit"}, {"oid": "dd49ddb7a5bdd24122bfb281713129d0d0d68b16", "url": "https://github.com/confluentinc/ksql/commit/dd49ddb7a5bdd24122bfb281713129d0d0d68b16", "message": "chore: remove unused imports", "committedDate": "2020-07-17T22:35:17Z", "type": "commit"}]}