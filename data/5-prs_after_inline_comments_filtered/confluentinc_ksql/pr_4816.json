{"pr_number": 4816, "pr_title": "fix: fix repartition semantics", "pr_createdAt": "2020-03-18T18:44:29Z", "pr_url": "https://github.com/confluentinc/ksql/pull/4816", "timeline": [{"oid": "ef63feb5b97cac2771ff15be113eb629eb4ad498", "url": "https://github.com/confluentinc/ksql/commit/ef63feb5b97cac2771ff15be113eb629eb4ad498", "message": "fix: fix repartition semantics\n\nFixes: https://github.com/confluentinc/ksql/issues/4749\n\n##### Background\n\nThis change fixes an issue with our repartition semantics.\n\nOld style query semantics for partition by are broken:\n\nS1: ROWKEY => B, C  (Meaning S1 has a schema with ROWKEY as the key column, and B and C as value columns - types aren't important).\n\n```sql\nCREATE STREAM S2 AS SELECT * FROM S1 PARTITION BY B;\n```\n\nS2: ROWKEY => B, C\n\nAs you can see the schema of S2 is still the same.  However, the old data in the key has been lost as its been overridden with the data from B, and the key now duplicates the data stored in B.\n\nThis loss of data on a `SELECT * .. PARTITION BY` needed fixing.\n\nSecondly, with new primitive key [work to remove the restriction on key column naming](https://github.com/confluentinc/ksql/issues/3536), the same query semantics do not work. e.g.\n\nS1: A => B, C\n\n```sql\nCREATE STREAM S2 AS SELECT * FROM S1 PARTITION BY B;\n```\n\nS2: B => B, C\n\nThis fails as the `B` value column clashes with the `B` key column!\n\n##### The fix\n\nThis commit fixes the PARTITION BY semantics so that any PARTITION BY on a specific column sees the old key column being moved to the value and the new key column being moved from the value to the key. For example,\n\nS1: A => B, C\n\n```sql\nCREATE STREAM S2 AS SELECT * FROM S1 PARTITION BY B;\n```\n\nResults in the schema: S2: B => C, A.\n\nIf a PARTITION BY is an expression other than a column reference, then ksql will synthesis a new column name. For example,\n\nS1: A => B, C\n\n```sql\nCREATE STREAM S2 AS SELECT * FROM S1 PARTITION BY CAST(B AS INT);\n```\n\nResults in the schema: S2: KSQL_COL_0 => B, C, A.\n\n[This github issue](https://github.com/confluentinc/ksql/issues/4813) will add the ability to use aliases in PARTITION BY expressions, allowing a custom name to be assigned.", "committedDate": "2020-03-18T18:42:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTIxOTcwNA==", "url": "https://github.com/confluentinc/ksql/pull/4816#discussion_r395219704", "bodyText": "clearly this happens somewhere, but I'm not sure where, don't we need to remove the paritionByCol if it existed in the value?", "author": "agavra", "createdAt": "2020-03-19T18:01:54Z", "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/PartitionByParamsFactory.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.execution.streams;\n+\n+import io.confluent.ksql.GenericRow;\n+import io.confluent.ksql.execution.codegen.CodeGenRunner;\n+import io.confluent.ksql.execution.codegen.ExpressionMetadata;\n+import io.confluent.ksql.execution.expression.tree.ColumnReferenceExp;\n+import io.confluent.ksql.execution.expression.tree.Expression;\n+import io.confluent.ksql.execution.util.EngineProcessingLogMessageFactory;\n+import io.confluent.ksql.execution.util.ExpressionTypeManager;\n+import io.confluent.ksql.execution.util.StructKeyUtil;\n+import io.confluent.ksql.execution.util.StructKeyUtil.KeyBuilder;\n+import io.confluent.ksql.function.FunctionRegistry;\n+import io.confluent.ksql.logging.processing.ProcessingLogger;\n+import io.confluent.ksql.name.ColumnName;\n+import io.confluent.ksql.name.ColumnNames;\n+import io.confluent.ksql.schema.ksql.Column;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.LogicalSchema.Builder;\n+import io.confluent.ksql.schema.ksql.types.SqlType;\n+import io.confluent.ksql.util.KsqlConfig;\n+import java.util.Optional;\n+import java.util.function.BiFunction;\n+import java.util.function.BiPredicate;\n+import java.util.function.Function;\n+import org.apache.kafka.connect.data.Struct;\n+import org.apache.kafka.streams.KeyValue;\n+\n+public final class PartitionByParamsFactory {\n+\n+  private PartitionByParamsFactory() {\n+  }\n+\n+  public static PartitionByParams build(\n+      final LogicalSchema sourceSchema,\n+      final Expression partitionBy,\n+      final KsqlConfig ksqlConfig,\n+      final FunctionRegistry functionRegistry,\n+      final ProcessingLogger logger\n+  ) {\n+    final Optional<Column> partitionByCol = getPartitionByCol(sourceSchema, partitionBy);\n+\n+    final Function<GenericRow, Object> evaluator = buildExpressionEvaluator(\n+        sourceSchema,\n+        partitionBy,\n+        ksqlConfig,\n+        functionRegistry,\n+        logger\n+    );\n+\n+    final LogicalSchema resultSchema =\n+        buildSchema(sourceSchema, partitionBy, functionRegistry, partitionByCol);\n+\n+    return buildMapper(resultSchema, partitionByCol, evaluator);\n+  }\n+\n+  public static LogicalSchema buildSchema(\n+      final LogicalSchema sourceSchema,\n+      final Expression partitionBy,\n+      final FunctionRegistry functionRegistry\n+  ) {\n+    final Optional<Column> partitionByCol = getPartitionByCol(sourceSchema, partitionBy);\n+    return buildSchema(sourceSchema, partitionBy, functionRegistry, partitionByCol);\n+  }\n+\n+  private static LogicalSchema buildSchema(\n+      final LogicalSchema sourceSchema,\n+      final Expression partitionBy,\n+      final FunctionRegistry functionRegistry,\n+      final Optional<Column> partitionByCol\n+  ) {\n+    final ExpressionTypeManager expressionTypeManager =\n+        new ExpressionTypeManager(sourceSchema, functionRegistry);\n+\n+    final SqlType keyType = expressionTypeManager\n+        .getExpressionSqlType(partitionBy);\n+\n+    final ColumnName newKeyName = partitionByCol\n+        .map(Column::name)\n+        .orElseGet(() -> ColumnNames.nextGeneratedColumnAlias(sourceSchema));\n+\n+    final Builder builder = LogicalSchema.builder()\n+        .withRowTime()\n+        .keyColumn(newKeyName, keyType)\n+        .valueColumns(sourceSchema.value());", "originalCommit": "ef63feb5b97cac2771ff15be113eb629eb4ad498", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU1OTcyMw==", "url": "https://github.com/confluentinc/ksql/pull/4816#discussion_r395559723", "bodyText": "No, we don't need to remove it, cos we need it there.\nConsider:\nA => B, C\nAnd applying PARTITION BY B.\nThe final schema should be:\nB => C, A\nHowever, during processing we copy the key columns into the value, hence the source schema is:\nA => B, C, A\nWhen we repartition this becomes:\nB => B, C, A\nNotice, no need to change the value!\nHowever, if PARTITION BY UDF(B), then:\nA => B, C\nBecomes:\nKSQL_COL_0 => B, C, A\nWhich during processing is actually:\nA => B, C, A\nBecoming\nKSQL_COL_0 => B, C, A, KSQL_COL_0.\nThis would all likely be a lot clearer if we had a LogicalSchema and a ProcessingSchema type, but ... that would be a lot of work!", "author": "big-andy-coates", "createdAt": "2020-03-20T10:50:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTIxOTcwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU2NDQzNw==", "url": "https://github.com/confluentinc/ksql/pull/4816#discussion_r395564437", "bodyText": "I've added Java docs to cover this.", "author": "big-andy-coates", "createdAt": "2020-03-20T11:01:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTIxOTcwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTIyMTMwOA==", "url": "https://github.com/confluentinc/ksql/pull/4816#discussion_r395221308", "bodyText": "we might already have been doing this, but why do we filter out null keys and values?\n\nEDIT: just saw #4823", "author": "agavra", "createdAt": "2020-03-19T18:04:35Z", "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/PartitionByParamsFactory.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Confluent Community License (the \"License\"); you may not use\n+ * this file except in compliance with the License.  You may obtain a copy of the\n+ * License at\n+ *\n+ * http://www.confluent.io/confluent-community-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OF ANY KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package io.confluent.ksql.execution.streams;\n+\n+import io.confluent.ksql.GenericRow;\n+import io.confluent.ksql.execution.codegen.CodeGenRunner;\n+import io.confluent.ksql.execution.codegen.ExpressionMetadata;\n+import io.confluent.ksql.execution.expression.tree.ColumnReferenceExp;\n+import io.confluent.ksql.execution.expression.tree.Expression;\n+import io.confluent.ksql.execution.util.EngineProcessingLogMessageFactory;\n+import io.confluent.ksql.execution.util.ExpressionTypeManager;\n+import io.confluent.ksql.execution.util.StructKeyUtil;\n+import io.confluent.ksql.execution.util.StructKeyUtil.KeyBuilder;\n+import io.confluent.ksql.function.FunctionRegistry;\n+import io.confluent.ksql.logging.processing.ProcessingLogger;\n+import io.confluent.ksql.name.ColumnName;\n+import io.confluent.ksql.name.ColumnNames;\n+import io.confluent.ksql.schema.ksql.Column;\n+import io.confluent.ksql.schema.ksql.LogicalSchema;\n+import io.confluent.ksql.schema.ksql.LogicalSchema.Builder;\n+import io.confluent.ksql.schema.ksql.types.SqlType;\n+import io.confluent.ksql.util.KsqlConfig;\n+import java.util.Optional;\n+import java.util.function.BiFunction;\n+import java.util.function.BiPredicate;\n+import java.util.function.Function;\n+import org.apache.kafka.connect.data.Struct;\n+import org.apache.kafka.streams.KeyValue;\n+\n+public final class PartitionByParamsFactory {\n+\n+  private PartitionByParamsFactory() {\n+  }\n+\n+  public static PartitionByParams build(\n+      final LogicalSchema sourceSchema,\n+      final Expression partitionBy,\n+      final KsqlConfig ksqlConfig,\n+      final FunctionRegistry functionRegistry,\n+      final ProcessingLogger logger\n+  ) {\n+    final Optional<Column> partitionByCol = getPartitionByCol(sourceSchema, partitionBy);\n+\n+    final Function<GenericRow, Object> evaluator = buildExpressionEvaluator(\n+        sourceSchema,\n+        partitionBy,\n+        ksqlConfig,\n+        functionRegistry,\n+        logger\n+    );\n+\n+    final LogicalSchema resultSchema =\n+        buildSchema(sourceSchema, partitionBy, functionRegistry, partitionByCol);\n+\n+    return buildMapper(resultSchema, partitionByCol, evaluator);\n+  }\n+\n+  public static LogicalSchema buildSchema(\n+      final LogicalSchema sourceSchema,\n+      final Expression partitionBy,\n+      final FunctionRegistry functionRegistry\n+  ) {\n+    final Optional<Column> partitionByCol = getPartitionByCol(sourceSchema, partitionBy);\n+    return buildSchema(sourceSchema, partitionBy, functionRegistry, partitionByCol);\n+  }\n+\n+  private static LogicalSchema buildSchema(\n+      final LogicalSchema sourceSchema,\n+      final Expression partitionBy,\n+      final FunctionRegistry functionRegistry,\n+      final Optional<Column> partitionByCol\n+  ) {\n+    final ExpressionTypeManager expressionTypeManager =\n+        new ExpressionTypeManager(sourceSchema, functionRegistry);\n+\n+    final SqlType keyType = expressionTypeManager\n+        .getExpressionSqlType(partitionBy);\n+\n+    final ColumnName newKeyName = partitionByCol\n+        .map(Column::name)\n+        .orElseGet(() -> ColumnNames.nextGeneratedColumnAlias(sourceSchema));\n+\n+    final Builder builder = LogicalSchema.builder()\n+        .withRowTime()\n+        .keyColumn(newKeyName, keyType)\n+        .valueColumns(sourceSchema.value());\n+\n+    if (!partitionByCol.isPresent()) {\n+      // New key column added, copy in to value schema:\n+      builder.valueColumn(newKeyName, keyType);\n+    }\n+\n+    return builder.build();\n+  }\n+\n+  private static Optional<Column> getPartitionByCol(\n+      final LogicalSchema sourceSchema,\n+      final Expression partitionBy\n+  ) {\n+    if (!(partitionBy instanceof ColumnReferenceExp)) {\n+      return Optional.empty();\n+    }\n+\n+    final ColumnName columnName = ((ColumnReferenceExp) partitionBy).getColumnName();\n+\n+    final Column column = sourceSchema\n+        .findValueColumn(columnName)\n+        .orElseThrow(() -> new IllegalStateException(\"Unknown partition by column: \" + columnName));\n+\n+    return Optional.of(column);\n+  }\n+\n+  private static PartitionByParams buildMapper(\n+      final LogicalSchema resultSchema,\n+      final Optional<Column> partitionByCol,\n+      final Function<GenericRow, Object> evaluator\n+  ) {\n+    // If partitioning by something other than an existing column, then a new key will have\n+    // been synthesized. This new key must be appended to the value to make it available for\n+    // stream processing, in the same way SourceBuilder appends the key and rowtime to the value:\n+    final boolean appendNewKey = !partitionByCol.isPresent();\n+\n+    final KeyBuilder keyBuilder = StructKeyUtil.keyBuilder(resultSchema);\n+\n+    final BiPredicate<Struct, GenericRow> predicate = (k, v) -> {\n+      if (v == null) {\n+        return false;\n+      }\n+\n+      return evaluator.apply(v) != null;\n+    };", "originalCommit": "ef63feb5b97cac2771ff15be113eb629eb4ad498", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU1NzQyNQ==", "url": "https://github.com/confluentinc/ksql/pull/4816#discussion_r395557425", "bodyText": "Yeah, this was existing functionality copied across, but thought exactly the same when I was moving it. Hence #4823", "author": "big-andy-coates", "createdAt": "2020-03-20T10:46:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTIyMTMwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTIyMjY4Mg==", "url": "https://github.com/confluentinc/ksql/pull/4816#discussion_r395222682", "bodyText": "I thought we should never get to the situation where a key and value column have the same name? (or is this now temporarily possible during the partition by step? that seems not ideal)", "author": "agavra", "createdAt": "2020-03-19T18:06:58Z", "path": "ksqldb-streams/src/test/java/io/confluent/ksql/execution/streams/StreamSelectKeyBuilderTest.java", "diffHunk": "@@ -75,7 +79,7 @@\n \n   private static final LogicalSchema RESULT_SCHEMA = LogicalSchema.builder()\n       .withRowTime()\n-      .keyColumn(SchemaUtil.ROWKEY_NAME, SqlTypes.BIGINT)\n+      .keyColumn(ColumnName.of(\"BOI\"), SqlTypes.BIGINT)", "originalCommit": "ef63feb5b97cac2771ff15be113eb629eb4ad498", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU1NzgxMg==", "url": "https://github.com/confluentinc/ksql/pull/4816#discussion_r395557812", "bodyText": "The key and rowkey columns are copied into the value... so yes, we always have duplicates in the schema used during processing...", "author": "big-andy-coates", "createdAt": "2020-03-20T10:46:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTIyMjY4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTIyNzAwNQ==", "url": "https://github.com/confluentinc/ksql/pull/4816#discussion_r395227005", "bodyText": "I feel like we should generate the name of the partition by column during the AstSanitizer step (just as we do for other expressions without column names). Unfortunately that probably requires supporting column names in PARTITION BY - is that something that's on your radar? This isn't a blocker for this PR, but I want to make sure we have a path forward that's backwards compatible.\nThis change might be hard to implement in the future - we generate KSQL_COL_x based on the location of the column, not the number of previous generated columns, so the algorithms wouldn't necessarily line up. Is this nextGeneratedColumnAlias specified anywhere in the serialized plan?", "author": "agavra", "createdAt": "2020-03-19T18:14:36Z", "path": "ksqldb-common/src/main/java/io/confluent/ksql/name/ColumnNames.java", "diffHunk": "@@ -61,4 +70,42 @@ public static ColumnName generatedJoinColumnAlias(\n   public static boolean isAggregate(final ColumnName name) {\n     return name.text().startsWith(AGGREGATE_COLUMN_PREFIX);\n   }\n+\n+  /**\n+   * Determines the next unique column alias.\n+   *\n+   * <p>Finds any existing {@code KSQL_COL_x} column names in the supplied {@code sourceSchema} to\n+   * ensure the returned generated column name is unique.\n+   *\n+   * @param sourceSchema the source schema.\n+   * @return a column name in the form {@code KSQL_COL_x} which does not clash with source schema.\n+   */\n+  public static ColumnName nextGeneratedColumnAlias(final LogicalSchema sourceSchema) {", "originalCommit": "ef63feb5b97cac2771ff15be113eb629eb4ad498", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU2NjM1NQ==", "url": "https://github.com/confluentinc/ksql/pull/4816#discussion_r395566355", "bodyText": "Aliasing in PARTITION BY is definitely on my radar: #4813.  I was hoping you may be able to pick that one up!\nAnd yes, once this is done we can make this call from AstSanitizer\n\nThis change might be hard to implement in the future - we generate KSQL_COL_x based on the location of the column, not the number of previous generated columns, so the algorithms wouldn't necessarily line up.\n\nWith #4827 we actually generate the index based on other column names.\n\nIs this nextGeneratedColumnAlias specified anywhere in the serialized plan?\n\nThe sink schema is in the serialized plan.", "author": "big-andy-coates", "createdAt": "2020-03-20T11:05:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTIyNzAwNQ=="}], "type": "inlineReview"}, {"oid": "8e35587a5d918307a002546289414b63fa829624", "url": "https://github.com/confluentinc/ksql/commit/8e35587a5d918307a002546289414b63fa829624", "message": "chore: changes requested by Almog", "committedDate": "2020-03-20T11:09:49Z", "type": "commit"}]}