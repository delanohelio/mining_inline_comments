{"pr_number": 6119, "pr_title": "chore: support ASSERT STREAM and ASSERT TABLE in KsqlTester", "pr_createdAt": "2020-08-27T21:41:03Z", "pr_url": "https://github.com/confluentinc/ksql/pull/6119", "timeline": [{"oid": "a40554e2e5b0ec3b8ed06ba6eadeb632ccab0806", "url": "https://github.com/confluentinc/ksql/commit/a40554e2e5b0ec3b8ed06ba6eadeb632ccab0806", "message": "chore: support ASSERT STREAM and ASSERT TABLE in KsqlTester", "committedDate": "2020-08-28T00:00:13Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI5NDA2Mg==", "url": "https://github.com/confluentinc/ksql/pull/6119#discussion_r480294062", "bodyText": "What about other properties that could be specified? For example, timestamp, timestamp format, or wrap single values? If we aren't planning to support validating them in the tester it'd be nice to (1) document this (apologies if I've simply missed it) and (2) fail if they're provided so the user knows they aren't valid rather than thinking they're being checked when they aren't.", "author": "vcrfxia", "createdAt": "2020-08-31T17:58:35Z", "path": "ksqldb-functional-tests/src/main/java/io/confluent/ksql/test/driver/AssertExecutor.java", "diffHunk": "@@ -122,12 +129,57 @@ private static void assertContent(\n     }\n   }\n \n-  public static void assertStream(final AssertStream assertStatement) {\n-    throw new UnsupportedOperationException();\n+  public static void assertStream(\n+      final KsqlExecutionContext engine,\n+      final AssertStream assertStatement\n+  ) {\n+    assertSourceMatch(engine, assertStatement.getStatement());\n+  }\n+\n+  public static void assertTable(\n+      final KsqlExecutionContext engine,\n+      final AssertTable assertStatement\n+  ) {\n+    assertSourceMatch(engine, assertStatement.getStatement());\n   }\n \n-  public static void assertTable(final AssertTable assertStatement) {\n-    throw new UnsupportedOperationException();\n+  private static void assertSourceMatch(\n+      final KsqlExecutionContext engine,\n+      final CreateSource statement\n+  ) {\n+    final SourceName source = statement.getName();\n+    final DataSource dataSource = engine.getMetaStore().getSource(source);\n+    final LogicalSchema actual = dataSource.getSchema();\n+    final LogicalSchema expected = statement.getElements().toLogicalSchema();\n+    if (!actual.equals(expected)) {\n+      throw new KsqlException(\n+          String.format(\n+              \"Expected schema does not match actual.%n\\tExpected: %s%n\\tActual: %s\",\n+              expected,\n+              actual\n+          )\n+      );\n+    }\n+\n+    final DataSourceType type = dataSource.getDataSourceType();\n+    if (statement instanceof CreateStream && type != DataSourceType.KSTREAM) {\n+      throw new KsqlException(\"Expected source \" + source + \" to be a STREAM but was \" + type);\n+    } else if (statement instanceof CreateTable  && type != DataSourceType.KTABLE) {\n+      throw new KsqlException(\"Expected source \" + source + \" to be a TABLE but was \" + type);\n+    }\n+\n+    final KsqlTopic topic = dataSource.getKsqlTopic();\n+    if (!topic.getKafkaTopicName().equals(statement.getProperties().getKafkaTopic())) {\n+      throw new KsqlException(\"Expected source \" + source + \" to have kafka topic \"\n+          + topic.getKafkaTopicName() + \" but was \" + statement.getProperties().getKafkaTopic());\n+    }\n+\n+    if (!topic.getValueFormat().getFormatInfo().equals(statement.getProperties().getFormatInfo())) {\n+      throw new KsqlException(\"Expected source \" + source + \" to have value format of \"\n+          + topic.getValueFormat().getFormatInfo() + \" but got \"\n+          + statement.getProperties().getFormatInfo()\n+      );\n+    }", "originalCommit": "a40554e2e5b0ec3b8ed06ba6eadeb632ccab0806", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM1NjU5NA==", "url": "https://github.com/confluentinc/ksql/pull/6119#discussion_r480356594", "bodyText": "I gave this some thought during implementation but now that I'm revisiting it, I'm not sure why I decided against having these checks. I'll add them back in", "author": "agavra", "createdAt": "2020-08-31T19:39:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI5NDA2Mg=="}], "type": "inlineReview"}, {"oid": "13134f43fc15d07f6baea9241183e5a2d3cac7b5", "url": "https://github.com/confluentinc/ksql/commit/13134f43fc15d07f6baea9241183e5a2d3cac7b5", "message": "chore: add more comparisons", "committedDate": "2020-08-31T23:41:13Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTEyODI1MQ==", "url": "https://github.com/confluentinc/ksql/pull/6119#discussion_r481128251", "bodyText": "As I'm sure you're aware, this is a very fragile pattern. It's highly likely that people will forget to add things to this list when adding new fields to DataSource.\nAs a good example, getSerdeOptions was added recently and must match, but isn't in this list...\nIdeally, what we want is for this to 'just work' when new fields are added, or to fail to compile when new fields / properties are added.  OF course, this is tricky without duplicating code!\nNot sure of the right approach here.  One partial solution would be to have the code fail if it encounters a WITH clause property for which it doesn't have a rule in the above list.  You can probably achieve the same, but better, with a meta test in AssertExecutorTest that ensures there is a rule for each property defined in the CreateConfigs and CreateAsConfigs classes.", "author": "big-andy-coates", "createdAt": "2020-09-01T13:15:26Z", "path": "ksqldb-functional-tests/src/main/java/io/confluent/ksql/test/driver/AssertExecutor.java", "diffHunk": "@@ -47,6 +54,44 @@\n  */\n public final class AssertExecutor {\n \n+\n+  private static final List<SourceProperty> MUST_MATCH = ImmutableList.<SourceProperty>builder()\n+      .add(\n+          new SourceProperty(\n+              DataSource::getSchema,\n+              cs -> cs.getElements().toLogicalSchema(),\n+              \"schema\"\n+      )).add(\n+          new SourceProperty(\n+              DataSource::getDataSourceType,\n+              cs -> cs instanceof CreateTable ? DataSourceType.KTABLE : DataSourceType.KSTREAM,\n+              \"type\"\n+      )).add(\n+          new SourceProperty(\n+              DataSource::getKafkaTopicName,\n+              cs -> cs.getProperties().getKafkaTopic(),\n+              \"kafka topic\"\n+      )).add(\n+          new SourceProperty(\n+              ds -> ds.getKsqlTopic().getValueFormat().getFormatInfo().getFormat(),\n+              cs -> cs.getProperties().getValueFormat().name(),\n+              \"value format\"\n+          )).add(new SourceProperty(\n+              DataSource::getSerdeOptions,\n+              cs -> cs.getProperties().getSerdeOptions(),\n+              \"serde options\"\n+      )).add(\n+          new SourceProperty(\n+              ds -> ds.getTimestampColumn().map(TimestampColumn::getColumn),\n+              cs -> cs.getProperties().getTimestampColumnName(),\n+              \"timestamp column\"\n+      )).add(\n+          new SourceProperty(\n+              ds -> ds.getTimestampColumn().flatMap(TimestampColumn::getFormat),\n+              cs -> cs.getProperties().getTimestampFormat(),\n+              \"timestamp format\"\n+      )).build();", "originalCommit": "9426ec6d8946e3d548d1f48a73a033c2807d87f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ4OTMyNg==", "url": "https://github.com/confluentinc/ksql/pull/6119#discussion_r481489326", "bodyText": "Makes sense, I'll think about it but it is quite tough... (I don't, for example, have access to the original WITH clause at this point so I don't even know what was typed and what is just resolved to default).\n\nAs a good example, getSerdeOptions was added recently and must match, but isn't in this list...\n\nLet the record show, though, that I did indeed include this in the original code :P (it even shows in the part you highlighted!)", "author": "agavra", "createdAt": "2020-09-01T23:35:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTEyODI1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjIxOTkyNw==", "url": "https://github.com/confluentinc/ksql/pull/6119#discussion_r482219927", "bodyText": "Let the record show, though, that I did indeed include this in the original code :P (it even shows in the part you highlighted!)\n\nOh year ;)\n\nI don't, for example, have access to the original WITH clause at this point so I don't even know what was typed and what is just resolved to default\n\nWell, we do have them.  Take CreateSourceProperties, it has a props field of type PropertiesConfig. You can get the exact values in the WITH clause from props.copyOfOriginalLiterals() or props.originals().  We'd just need to expose this from CreateSourceProperties.\nHowever, I don't think we necessarily need to do that.  A good first step would just be to ensure we have a rule in the above map for each known WITH property.  The list of those can be got from the properties defined in CreateConfigs.CONFIG_DEF and CreateAsConfigs.CONFIG_DEF. So maybe adding a meta test in AssertExecutorTest that compiled the list and then ensured rules exist for all these properties is enough, for now, to give at least some protection from people forgetting to upgrade this when they make changes else where.\nAnother approach would be to annotate the getters of DataSource with something that execluded them from the comparison and then using reflection to do the comparison.  I think this is a better approach.  Happy for this to be done in follow up PR to unblock things, as long as ited tracked and done soon. Otherwise, it's only a matter of time before this diverges from the code its testing.", "author": "big-andy-coates", "createdAt": "2020-09-02T16:54:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTEyODI1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjM4MzUzMg==", "url": "https://github.com/confluentinc/ksql/pull/6119#discussion_r482383532", "bodyText": "I took your suggestion and found a way to make a test out of it - added the meta-test, thanks for the input!", "author": "agavra", "createdAt": "2020-09-02T20:01:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTEyODI1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTEyODg4MQ==", "url": "https://github.com/confluentinc/ksql/pull/6119#discussion_r481128881", "bodyText": "Again with the KsqlException ;).   How about AssertError?", "author": "big-andy-coates", "createdAt": "2020-09-01T13:16:22Z", "path": "ksqldb-functional-tests/src/main/java/io/confluent/ksql/test/driver/AssertExecutor.java", "diffHunk": "@@ -172,12 +217,61 @@ private static TabularRow fromGenericRow(\n     return TabularRow.createRow(80, contents, false, 0);\n   }\n \n-  public static void assertStream(final AssertStream assertStatement) {\n-    throw new UnsupportedOperationException();\n+  public static void assertStream(\n+      final KsqlExecutionContext engine,\n+      final AssertStream assertStatement\n+  ) {\n+    assertSourceMatch(engine, assertStatement.getStatement());\n+  }\n+\n+  public static void assertTable(\n+      final KsqlExecutionContext engine,\n+      final AssertTable assertStatement\n+  ) {\n+    assertSourceMatch(engine, assertStatement.getStatement());\n   }\n \n-  public static void assertTable(final AssertTable assertStatement) {\n-    throw new UnsupportedOperationException();\n+\n+  private static void assertSourceMatch(\n+      final KsqlExecutionContext engine,\n+      final CreateSource statement\n+  ) {\n+    final SourceName source = statement.getName();\n+    final DataSource dataSource = engine.getMetaStore().getSource(source);\n+\n+    MUST_MATCH.forEach(prop -> prop.compare(dataSource, statement));\n+  }\n+\n+  private static final class SourceProperty {\n+    final Function<DataSource, Object> extractSource;\n+    final Function<CreateSource, Object> extractStatement;\n+    final String propertyName;\n+\n+    private SourceProperty(\n+        final Function<DataSource, Object> extractSource,\n+        final Function<CreateSource, Object> extractStatement,\n+        final String propertyName\n+    ) {\n+      this.extractSource = extractSource;\n+      this.extractStatement = extractStatement;\n+      this.propertyName = propertyName;\n+    }\n+\n+    private void compare(final DataSource dataSource, final CreateSource statement) {\n+      final Object expected = extractStatement.apply(statement);\n+      final Object actual = extractSource.apply(dataSource);\n+      if (!actual.equals(expected)) {\n+        throw new KsqlException(", "originalCommit": "9426ec6d8946e3d548d1f48a73a033c2807d87f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ2Nzk0NQ==", "url": "https://github.com/confluentinc/ksql/pull/6119#discussion_r481467945", "bodyText": "AssertionError is not part of Exception which makes it a little bit of a pain to deal with - though I can change it if you feel super strongly about it.", "author": "agavra", "createdAt": "2020-09-01T22:30:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTEyODg4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjIxMTk3Mg==", "url": "https://github.com/confluentinc/ksql/pull/6119#discussion_r482211972", "bodyText": "But this is an assertion failure, so using an AssertError is the right approach IMHO.  This is a definite 'the test has failed', rather than something else went wrong.  Makes it almost impossible for someone to come along and inadvertently add a new catch block that accidentally catches the error.\nQTT TestExcutor uses this pattern and it works well.", "author": "big-andy-coates", "createdAt": "2020-09-02T16:42:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTEyODg4MQ=="}], "type": "inlineReview"}, {"oid": "c5efe108aea3428db5ff804edf595cfd42350333", "url": "https://github.com/confluentinc/ksql/commit/c5efe108aea3428db5ff804edf595cfd42350333", "message": "chore: support ASSERT STREAM and ASSERT TABLE in KsqlTester", "committedDate": "2020-09-02T15:49:50Z", "type": "commit"}, {"oid": "333d763ccf3efc2b4d6cd69846f8860c39495eda", "url": "https://github.com/confluentinc/ksql/commit/333d763ccf3efc2b4d6cd69846f8860c39495eda", "message": "chore: add more comparisons", "committedDate": "2020-09-02T15:49:50Z", "type": "commit"}, {"oid": "3a9c66f53369529bf78c2ea6f5e35e87b8b63ffa", "url": "https://github.com/confluentinc/ksql/commit/3a9c66f53369529bf78c2ea6f5e35e87b8b63ffa", "message": "chore: checkstyle", "committedDate": "2020-09-02T15:49:50Z", "type": "commit"}, {"oid": "8cfdadecee046db4d47a752f79bde7f92997aa4e", "url": "https://github.com/confluentinc/ksql/commit/8cfdadecee046db4d47a752f79bde7f92997aa4e", "message": "chore: add metatest to assert exec and change error type to AssertionError", "committedDate": "2020-09-02T19:06:21Z", "type": "commit"}, {"oid": "8cfdadecee046db4d47a752f79bde7f92997aa4e", "url": "https://github.com/confluentinc/ksql/commit/8cfdadecee046db4d47a752f79bde7f92997aa4e", "message": "chore: add metatest to assert exec and change error type to AssertionError", "committedDate": "2020-09-02T19:06:21Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjUwNjQyNw==", "url": "https://github.com/confluentinc/ksql/pull/6119#discussion_r482506427", "bodyText": "To get the full list you need to use CreateConfigs.CONFIG_DEF and CreateAsConfigs.CONFIG_DEF.  This is currently only testing configs that are common to both.\nIf someone adds a new one to only one, it will be missed by this test.", "author": "big-andy-coates", "createdAt": "2020-09-02T21:47:40Z", "path": "ksqldb-functional-tests/src/test/java/io/confluent/ksql/test/driver/AssertExecutorMetaTest.java", "diffHunk": "@@ -0,0 +1,48 @@\n+package io.confluent.ksql.test.driver;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.Sets;\n+import io.confluent.ksql.properties.with.CommonCreateConfigs;\n+import java.util.Arrays;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.kafka.common.config.ConfigDef;\n+import org.hamcrest.Matchers;\n+import org.junit.Test;\n+\n+/**\n+ * Most test coverage for the AssertExecutor is in the sql-tests/test.sql file\n+ * which is run through the KsqlTesterTest tool. This class is here to ensure\n+ * that the class evolves properly.\n+ */\n+public class AssertExecutorMetaTest {\n+\n+  /**\n+   * These are excluded from coverage\n+   */\n+  private final Set<String> excluded = ImmutableSet.of(\n+      CommonCreateConfigs.SOURCE_NUMBER_OF_PARTITIONS, // testing tool does not support partitions\n+      CommonCreateConfigs.SOURCE_NUMBER_OF_REPLICAS    // testing tool does not support replicas\n+  );\n+\n+  @Test\n+  public void shouldCoverAllWithClauses() {\n+    // Given:\n+    final ConfigDef def = new ConfigDef();\n+    CommonCreateConfigs.addToConfigDef(def, true, true);\n+    final Set<String> allValidProps = def.names();\n+\n+    // When:\n+    final Set<String> coverage = AssertExecutor.MUST_MATCH\n+        .stream()\n+        .map(sp -> sp.withClauseName)\n+        .flatMap(Arrays::stream)\n+        .collect(Collectors.toSet());\n+\n+    // Then:\n+    assertThat(Sets.difference(allValidProps, coverage), Matchers.is(excluded));", "originalCommit": "8cfdadecee046db4d47a752f79bde7f92997aa4e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYxMDM1NQ==", "url": "https://github.com/confluentinc/ksql/pull/6119#discussion_r482610355", "bodyText": "I had thought about this, but I don't think it really makes sense - you can only assert sources for CREATE AS (it doesn't really make sense to assert for a CREATE) and you specify it using the same syntax as CREATE schemas, meaning that it won't actually compile if you use the CREATE AS configs (though at the moment there are no configs in CREATE AS that aren't in CREATE, and I'm not sure I understand why there would be)", "author": "agavra", "createdAt": "2020-09-03T00:09:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjUwNjQyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ4NDY5NA==", "url": "https://github.com/confluentinc/ksql/pull/6119#discussion_r484484694", "bodyText": "Hummm... I guess we can cross this bring if/when we come to it.", "author": "big-andy-coates", "createdAt": "2020-09-07T15:08:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjUwNjQyNw=="}], "type": "inlineReview"}]}