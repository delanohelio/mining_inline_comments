{"pr_number": 5851, "pr_title": "chore: do not try to re-register schema multiple times on failure", "pr_createdAt": "2020-07-21T01:08:30Z", "pr_url": "https://github.com/confluentinc/ksql/pull/5851", "timeline": [{"oid": "018574e1aa6d2e15e16eb276f0f72c067bd132cf", "url": "https://github.com/confluentinc/ksql/commit/018574e1aa6d2e15e16eb276f0f72c067bd132cf", "message": "chore: do not try to re-register schema multiple times on failure", "committedDate": "2020-07-21T00:59:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc3NjU1NQ==", "url": "https://github.com/confluentinc/ksql/pull/5851#discussion_r457776555", "bodyText": "added this to this PR because in a recent incident I thought this would be nice to have, unrelated to the main change", "author": "agavra", "createdAt": "2020-07-21T01:08:55Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/query/MissingTopicClassifier.java", "diffHunk": "@@ -48,7 +48,12 @@ public MissingTopicClassifier(\n \n   @Override\n   public Type classify(final Throwable e) {\n-    LOG.info(\"Attempting to classify error for {}\", queryId);\n+    LOG.info(", "originalCommit": "018574e1aa6d2e15e16eb276f0f72c067bd132cf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIwNzY4OA==", "url": "https://github.com/confluentinc/ksql/pull/5851#discussion_r458207688", "bodyText": "nit: can we move the query ID to the end of the message to make it more searchable? Something like \"Attempting to classify error for query as missing topic error. Query ID: {}. Required topics: {}\"\nThis is actually @big-andy-coates 's peeve but after struggling to search logs the other day (for a different log message, not this one) I'm a believer too ;)", "author": "vcrfxia", "createdAt": "2020-07-21T15:56:04Z", "path": "ksqldb-engine/src/main/java/io/confluent/ksql/query/MissingTopicClassifier.java", "diffHunk": "@@ -48,7 +48,12 @@ public MissingTopicClassifier(\n \n   @Override\n   public Type classify(final Throwable e) {\n-    LOG.info(\"Attempting to classify error for {}\", queryId);\n+    LOG.info(\n+        \"Attempting to classify error for {} as missing topic error. Required topics: {}\",", "originalCommit": "018574e1aa6d2e15e16eb276f0f72c067bd132cf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIwODg0Mw==", "url": "https://github.com/confluentinc/ksql/pull/5851#discussion_r458208843", "bodyText": "Does it make sense to try multiple times, rather than just once? Wondering about transient failures. Though I guess if it's a network failure and the next record arrives shortly after, the network issue is unlikely to have been resolved in that time. (Thinking out loud here -- happy with what's in the PR.)", "author": "vcrfxia", "createdAt": "2020-07-21T15:57:39Z", "path": "ksqldb-streams/src/test/java/io/confluent/ksql/execution/streams/RegisterSchemaCallbackTest.java", "diffHunk": "@@ -55,4 +61,37 @@ public void shouldRegisterIdFromData() throws IOException, RestClientException {\n     verify(srClient).register(CHANGELOG + SUFFIX, schema);\n   }\n \n+  @Test\n+  public void shouldNotRegisterFailedIdTwice() throws IOException, RestClientException {", "originalCommit": "018574e1aa6d2e15e16eb276f0f72c067bd132cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIzNjA4Nw==", "url": "https://github.com/confluentinc/ksql/pull/5851#discussion_r458236087", "bodyText": "given my answer to the comment below, and that this is only stored in memory (meaning that a restart will try again to register) I'm happy not retrying as the I think it's more likely to not work and hurt SR than it is to work on a retry", "author": "agavra", "createdAt": "2020-07-21T16:38:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIwODg0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIxMjIyOQ==", "url": "https://github.com/confluentinc/ksql/pull/5851#discussion_r458212229", "bodyText": "To confirm my understanding: if we fail to proactively register a schema and hit the bug, we'd see the same query failure as we do today (inability to deserialize state store record). In other words, we'll have fixed the problem for cases where the source schema is compatible with the ksqlDB changelog schema (assuming no transient failures while registering the new schema), but there is still a gap in the case where the source schema is incompatible?", "author": "vcrfxia", "createdAt": "2020-07-21T16:02:21Z", "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/RegisterSchemaCallback.java", "diffHunk": "@@ -43,17 +44,66 @@ public void onDeserializationFailure(\n   ) {\n     final String sourceSubject = source + KsqlConstants.SCHEMA_REGISTRY_VALUE_SUFFIX;\n     final String changelogSubject = changelog + KsqlConstants.SCHEMA_REGISTRY_VALUE_SUFFIX;\n+\n+    // all schema registry events start with a magic byte 0x0 and then four bytes\n+    // indicating the schema id - we extract that schema id from the data that failed\n+    // to deserialize and then register it into the changelog subject\n+    final int id = ByteBuffer.wrap(data, 1, Integer.BYTES).getInt();\n+    final SchemaRegisterEvent event = new SchemaRegisterEvent(id, sourceSubject, changelogSubject);\n+\n     try {\n-      // all schema registry events start with a magic byte 0x0 and then four bytes\n-      // indicating the schema id - we extract that schema id from the data that failed\n-      // to deserialize and then register it into the changelog subject\n-      final int id = ByteBuffer.wrap(data, 1, Integer.BYTES).getInt();\n-\n-      LOG.info(\"Trying to fetch & register schema id {} under subject {}\", id, changelogSubject);\n-      final ParsedSchema schema = srClient.getSchemaBySubjectAndId(sourceSubject, id);\n-      srClient.register(changelogSubject, schema);\n-    } catch (IOException | RestClientException e) {\n-      LOG.warn(\"Failed during deserialization callback for topic \" + source, e);\n+      if (!failedAttempts.contains(event)) {\n+        LOG.info(\"Trying to fetch & register schema id {} under subject {}\", id, changelogSubject);\n+        final ParsedSchema schema = srClient.getSchemaBySubjectAndId(sourceSubject, id);\n+        srClient.register(changelogSubject, schema);\n+      }\n+    } catch (Exception e) {\n+      LOG.warn(\"Failed during deserialization callback for topic {}. \"\n+          + \"Will not try again to register id {} under subject {}.\",", "originalCommit": "018574e1aa6d2e15e16eb276f0f72c067bd132cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIzNzk4MQ==", "url": "https://github.com/confluentinc/ksql/pull/5851#discussion_r458237981", "bodyText": "that is not correct - the deserialization will actually succeed (see behavior in https://github.com/confluentinc/ksql/blob/master/ksqldb-serde/src/main/java/io/confluent/ksql/serde/StaticTopicSerde.java) it will just do the following for every message:\n\ndeserialize under the changelog topic subject\nfail because schema id doesn't exist\ndeserialize under the source topic subject (succeed)\n\nRegistering the schema is an optimization so that step 1 succeeds in the future (prevent us from checking if the schema exists and deserializing the schemaID twice for every message). Perhaps this was a premature optimization, so mea culpa...", "author": "agavra", "createdAt": "2020-07-21T16:40:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIxMjIyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ5MTIzNQ==", "url": "https://github.com/confluentinc/ksql/pull/5851#discussion_r458491235", "bodyText": "Got'cha -- love to hear it! Thanks for clarifying.", "author": "vcrfxia", "createdAt": "2020-07-22T02:07:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIxMjIyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIzMTA3OQ==", "url": "https://github.com/confluentinc/ksql/pull/5851#discussion_r458231079", "bodyText": "Does it make sense to use some kind of retry n times, with a backoff, or is this likely to work after an additional attempt?", "author": "AlanConfluent", "createdAt": "2020-07-21T16:30:14Z", "path": "ksqldb-streams/src/main/java/io/confluent/ksql/execution/streams/RegisterSchemaCallback.java", "diffHunk": "@@ -43,17 +44,66 @@ public void onDeserializationFailure(\n   ) {\n     final String sourceSubject = source + KsqlConstants.SCHEMA_REGISTRY_VALUE_SUFFIX;\n     final String changelogSubject = changelog + KsqlConstants.SCHEMA_REGISTRY_VALUE_SUFFIX;\n+\n+    // all schema registry events start with a magic byte 0x0 and then four bytes\n+    // indicating the schema id - we extract that schema id from the data that failed\n+    // to deserialize and then register it into the changelog subject\n+    final int id = ByteBuffer.wrap(data, 1, Integer.BYTES).getInt();\n+    final SchemaRegisterEvent event = new SchemaRegisterEvent(id, sourceSubject, changelogSubject);\n+\n     try {\n-      // all schema registry events start with a magic byte 0x0 and then four bytes\n-      // indicating the schema id - we extract that schema id from the data that failed\n-      // to deserialize and then register it into the changelog subject\n-      final int id = ByteBuffer.wrap(data, 1, Integer.BYTES).getInt();\n-\n-      LOG.info(\"Trying to fetch & register schema id {} under subject {}\", id, changelogSubject);\n-      final ParsedSchema schema = srClient.getSchemaBySubjectAndId(sourceSubject, id);\n-      srClient.register(changelogSubject, schema);\n-    } catch (IOException | RestClientException e) {\n-      LOG.warn(\"Failed during deserialization callback for topic \" + source, e);\n+      if (!failedAttempts.contains(event)) {\n+        LOG.info(\"Trying to fetch & register schema id {} under subject {}\", id, changelogSubject);\n+        final ParsedSchema schema = srClient.getSchemaBySubjectAndId(sourceSubject, id);\n+        srClient.register(changelogSubject, schema);\n+      }\n+    } catch (Exception e) {\n+      LOG.warn(\"Failed during deserialization callback for topic {}. \"", "originalCommit": "018574e1aa6d2e15e16eb276f0f72c067bd132cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIzODMyOA==", "url": "https://github.com/confluentinc/ksql/pull/5851#discussion_r458238328", "bodyText": "see inline responses to @vcrfxia's review", "author": "agavra", "createdAt": "2020-07-21T16:41:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIzMTA3OQ=="}], "type": "inlineReview"}, {"oid": "78c5bdc73ee4c48365c144487b827bb02ff4605b", "url": "https://github.com/confluentinc/ksql/commit/78c5bdc73ee4c48365c144487b827bb02ff4605b", "message": "chore: change log line", "committedDate": "2020-07-21T16:51:40Z", "type": "commit"}]}