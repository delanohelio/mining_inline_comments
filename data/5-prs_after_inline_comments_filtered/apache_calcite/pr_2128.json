{"pr_number": 2128, "pr_title": "[CALCITE-4197] Provide utility to visualize RelNode plans", "pr_createdAt": "2020-09-01T09:06:24Z", "pr_url": "https://github.com/apache/calcite/pull/2128", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTU3NzQ3Nw==", "url": "https://github.com/apache/calcite/pull/2128#discussion_r481577477", "bodyText": "Minor: it is time to dump the plan -> it is time to dump the plan.", "author": "chunweilei", "createdAt": "2020-09-02T02:46:52Z", "path": "core/src/main/java/org/apache/calcite/rel/externalize/RelDotWriter.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.rel.externalize;\n+\n+import org.apache.calcite.plan.hep.HepRelVertex;\n+import org.apache.calcite.plan.volcano.RelSubset;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.RelWriter;\n+import org.apache.calcite.sql.SqlExplainLevel;\n+import org.apache.calcite.util.Pair;\n+import org.apache.calcite.util.Util;\n+\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.Multimap;\n+\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Utility to dump a rel node plan in dot format.\n+ */\n+public class RelDotWriter extends RelWriterImpl {\n+\n+  //~ Instance fields --------------------------------------------------------\n+\n+  /**\n+   * Adjacent list of the plan graph.\n+   */\n+  private final Map<RelNode, List<RelNode>> outArcTable = new LinkedHashMap<>();\n+\n+  private Map<RelNode, String> nodeLabels = new HashMap<>();\n+\n+  private Multimap<RelNode, String> nodeStyles = HashMultimap.create();\n+\n+  private final WriteOption option;\n+\n+  //~ Constructors -----------------------------------------------------------\n+\n+  public RelDotWriter(\n+      PrintWriter pw, SqlExplainLevel detailLevel,\n+      boolean withIdPrefix) {\n+    this(pw, detailLevel, withIdPrefix, new WriteOption());\n+  }\n+\n+  public RelDotWriter(\n+      PrintWriter pw, SqlExplainLevel detailLevel,\n+      boolean withIdPrefix, WriteOption option) {\n+    super(pw, detailLevel, withIdPrefix);\n+    this.option = option;\n+  }\n+\n+  //~ Methods ----------------------------------------------------------------\n+\n+  protected void explain_(RelNode rel,\n+                          List<Pair<String, Object>> values) {\n+    // get inputs\n+    List<RelNode> inputs = getInputs(rel);\n+    outArcTable.put(rel, inputs);\n+\n+    // generate node label\n+    StringBuilder relDesc = new StringBuilder();\n+    populateRelNodeLabel(rel, values, relDesc);\n+    nodeLabels.put(rel, option.formatNodeLabel(relDesc.toString()));\n+\n+    if (option.highlightNode(rel)) {\n+      nodeStyles.put(rel, \"bold\");\n+    }\n+\n+    explainInputs(inputs);\n+  }\n+\n+  private List<RelNode> getInputs(RelNode parent) {\n+    return parent.getInputs().stream().map(child -> {\n+      if (child instanceof HepRelVertex) {\n+        return ((HepRelVertex) child).getCurrentRel();\n+      } else if (child instanceof RelSubset) {\n+        RelSubset subset = (RelSubset) child;\n+        return Util.first(subset.getBest(), subset.getOriginal());\n+      } else {\n+        return child;\n+      }\n+    }).collect(Collectors.toList());\n+  }\n+\n+  private void explainInputs(List<RelNode> inputs) {\n+    for (RelNode input : inputs) {\n+      if (input == null || nodeLabels.containsKey(input)) {\n+        continue;\n+      }\n+      input.explain(this);\n+    }\n+  }\n+\n+  public RelWriter done(RelNode node) {\n+    int numOfVisitedNodes = nodeLabels.size();\n+    super.done(node);\n+    if (numOfVisitedNodes == 0) {\n+      // When we enter this method call, no node\n+      // has been visited. So the current node must be the root of the plan.\n+      // Now we are exiting the method, all nodes in the plan\n+      // have been visited, so it is time to dump the plan\n+", "originalCommit": "a2ecc6ff958cb3ddd125667c74148b69d00461a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk3OTc4Mg==", "url": "https://github.com/apache/calcite/pull/2128#discussion_r481979782", "bodyText": "Nice catch. Thank you.", "author": "liyafan82", "createdAt": "2020-09-02T10:53:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTU3NzQ3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTU4MTM3OA==", "url": "https://github.com/apache/calcite/pull/2128#discussion_r481581378", "bodyText": "Text such as LogicalAggregate(gro\\\\nup=[{0}] and LogicalTableScan(tab\\\\nle= is a little weird. Maybe we can change it to LogicalAggregate\\n(group=[{0}]. What do you think?", "author": "chunweilei", "createdAt": "2020-09-02T02:53:00Z", "path": "core/src/test/java/org/apache/calcite/plan/RelWriterTest.java", "diffHunk": "@@ -658,14 +658,25 @@\n     final RelJsonWriter jsonWriter = new RelJsonWriter();\n     rel.explain(jsonWriter);\n     final String relJson = jsonWriter.asString();\n-    String s = deserializeAndDumpToTextFormat(getSchema(rel), relJson);\n-    final String expected = \"\"\n+    String s = deserializeAndDumpToTextFormat(getSchema(rel), relJson, format);\n+    assertThat(s, isLinux(expected));\n+  }\n+\n+  @Test void testAggregateWithAlias() {\n+    testAggregateWithAlias0(SqlExplainFormat.TEXT, \"\"\n         + \"LogicalProject(max_sal=[$1])\\n\"\n         + \"  LogicalAggregate(group=[{0}], max_sal=[MAX($1)])\\n\"\n         + \"    LogicalProject(JOB=[$2], SAL=[$5])\\n\"\n-        + \"      LogicalTableScan(table=[[scott, EMP]])\\n\";\n+        + \"      LogicalTableScan(table=[[scott, EMP]])\\n\");\n \n-    assertThat(s, isLinux(expected));\n+    testAggregateWithAlias0(SqlExplainFormat.DOT, \"digraph {\\n\"\n+        + \"\\\"LogicalProject(max_s\\\\nal=[$1])\\\" -> \\\"LogicalAggregate(gro\\\\nup=[{0}], \"\n+        + \"max_sal=[M\\\\nAX($1)])\\\" [label=\\\"0\\\"]\\n\"\n+        + \"\\\"LogicalAggregate(gro\\\\nup=[{0}], max_sal=[M\\\\nAX($1)])\\\" -> \\\"LogicalProject\"", "originalCommit": "a2ecc6ff958cb3ddd125667c74148b69d00461a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk4MDEwNQ==", "url": "https://github.com/apache/calcite/pull/2128#discussion_r481980105", "bodyText": "Sounds reasonable. It seems @danny0405 has a similar suggestion.\nI have revised the PR to fix this.", "author": "liyafan82", "createdAt": "2020-09-02T10:54:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTU4MTM3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTY0NzYyNw==", "url": "https://github.com/apache/calcite/pull/2128#discussion_r481647627", "bodyText": "This function should be called as deserializeAndDumpToFormat?", "author": "amaliujia", "createdAt": "2020-09-02T04:11:59Z", "path": "core/src/test/java/org/apache/calcite/plan/RelWriterTest.java", "diffHunk": "@@ -883,7 +917,8 @@ private RelOptSchema getSchema(RelNode rel) {\n    * Deserialize a relnode from the json string by {@link RelJsonReader},\n    * and dump it to text format.\n    */\n-  private String deserializeAndDumpToTextFormat(RelOptSchema schema, String relJson) {\n+  private String deserializeAndDumpToTextFormat(", "originalCommit": "a2ecc6ff958cb3ddd125667c74148b69d00461a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTg2OTU0MQ==", "url": "https://github.com/apache/calcite/pull/2128#discussion_r481869541", "bodyText": "or maybe just deserializeAndDump. BTW the javadoc needs to be updated as well.", "author": "rubenada", "createdAt": "2020-09-02T08:13:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTY0NzYyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk4MDMzNA==", "url": "https://github.com/apache/calcite/pull/2128#discussion_r481980334", "bodyText": "Thanks for your careful review. I have revised the PR accordingly.", "author": "liyafan82", "createdAt": "2020-09-02T10:54:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTY0NzYyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc0MzQ0NQ==", "url": "https://github.com/apache/calcite/pull/2128#discussion_r481743445", "bodyText": "Did you try the Config as an ImmutableBeans ?", "author": "danny0405", "createdAt": "2020-09-02T05:49:28Z", "path": "core/src/main/java/org/apache/calcite/rel/externalize/RelDotWriter.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.rel.externalize;\n+\n+import org.apache.calcite.plan.hep.HepRelVertex;\n+import org.apache.calcite.plan.volcano.RelSubset;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.RelWriter;\n+import org.apache.calcite.sql.SqlExplainLevel;\n+import org.apache.calcite.util.Pair;\n+import org.apache.calcite.util.Util;\n+\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.Multimap;\n+\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Utility to dump a rel node plan in dot format.\n+ */\n+public class RelDotWriter extends RelWriterImpl {\n+\n+  //~ Instance fields --------------------------------------------------------\n+\n+  /**\n+   * Adjacent list of the plan graph.\n+   */\n+  private final Map<RelNode, List<RelNode>> outArcTable = new LinkedHashMap<>();\n+\n+  private Map<RelNode, String> nodeLabels = new HashMap<>();\n+\n+  private Multimap<RelNode, String> nodeStyles = HashMultimap.create();\n+\n+  private final WriteOption option;\n+\n+  //~ Constructors -----------------------------------------------------------\n+\n+  public RelDotWriter(\n+      PrintWriter pw, SqlExplainLevel detailLevel,\n+      boolean withIdPrefix) {\n+    this(pw, detailLevel, withIdPrefix, new WriteOption());\n+  }\n+\n+  public RelDotWriter(\n+      PrintWriter pw, SqlExplainLevel detailLevel,\n+      boolean withIdPrefix, WriteOption option) {\n+    super(pw, detailLevel, withIdPrefix);\n+    this.option = option;\n+  }\n+\n+  //~ Methods ----------------------------------------------------------------\n+\n+  protected void explain_(RelNode rel,\n+                          List<Pair<String, Object>> values) {\n+    // get inputs\n+    List<RelNode> inputs = getInputs(rel);\n+    outArcTable.put(rel, inputs);\n+\n+    // generate node label\n+    StringBuilder relDesc = new StringBuilder();\n+    populateRelNodeLabel(rel, values, relDesc);\n+    nodeLabels.put(rel, option.formatNodeLabel(relDesc.toString()));\n+\n+    if (option.highlightNode(rel)) {\n+      nodeStyles.put(rel, \"bold\");\n+    }\n+\n+    explainInputs(inputs);\n+  }\n+\n+  private List<RelNode> getInputs(RelNode parent) {\n+    return parent.getInputs().stream().map(child -> {\n+      if (child instanceof HepRelVertex) {\n+        return ((HepRelVertex) child).getCurrentRel();\n+      } else if (child instanceof RelSubset) {\n+        RelSubset subset = (RelSubset) child;\n+        return Util.first(subset.getBest(), subset.getOriginal());\n+      } else {\n+        return child;\n+      }\n+    }).collect(Collectors.toList());\n+  }\n+\n+  private void explainInputs(List<RelNode> inputs) {\n+    for (RelNode input : inputs) {\n+      if (input == null || nodeLabels.containsKey(input)) {\n+        continue;\n+      }\n+      input.explain(this);\n+    }\n+  }\n+\n+  public RelWriter done(RelNode node) {\n+    int numOfVisitedNodes = nodeLabels.size();\n+    super.done(node);\n+    if (numOfVisitedNodes == 0) {\n+      // When we enter this method call, no node\n+      // has been visited. So the current node must be the root of the plan.\n+      // Now we are exiting the method, all nodes in the plan\n+      // have been visited, so it is time to dump the plan\n+\n+      pw.println(\"digraph {\");\n+\n+      // print nodes with styles\n+      for (RelNode rel : nodeStyles.keySet()) {\n+        String style = String.join(\",\", nodeStyles.get(rel));\n+        pw.println(nodeLabels.get(rel) + \" [style=\\\"\" + style + \"\\\"]\");\n+      }\n+\n+      // ordinary arcs\n+      for (Map.Entry<RelNode, List<RelNode>> entry : outArcTable.entrySet()) {\n+        RelNode src = entry.getKey();\n+        String srcDesc = nodeLabels.get(src);\n+        for (int i = 0; i < entry.getValue().size(); i++) {\n+          RelNode dst = entry.getValue().get(i);\n+\n+          // label is the ordinal of the arc\n+          pw.println(srcDesc + \" -> \" + nodeLabels.get(dst) + \" [label=\\\"\" + i + \"\\\"]\");\n+        }\n+      }\n+      pw.println(\"}\");\n+      pw.flush();\n+    }\n+    return this;\n+  }\n+\n+  /**\n+   * Options for displaying the rel node plan in dot format.\n+   */\n+  public static class WriteOption {\n+\n+    /**", "originalCommit": "a2ecc6ff958cb3ddd125667c74148b69d00461a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk4MDgwNw==", "url": "https://github.com/apache/calcite/pull/2128#discussion_r481980807", "bodyText": "Sounds reasonable. I have revised the PR so that each configuration item is immutable.", "author": "liyafan82", "createdAt": "2020-09-02T10:55:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc0MzQ0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAwOTQ2MQ==", "url": "https://github.com/apache/calcite/pull/2128#discussion_r482009461", "bodyText": "I mean you can use a ImmutableBeans as configuration code instead of a specific class WriteOption here, an interface is enough, see how we do to SqlValidatorImpl .", "author": "danny0405", "createdAt": "2020-09-02T11:51:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc0MzQ0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjg0NDQyMQ==", "url": "https://github.com/apache/calcite/pull/2128#discussion_r482844421", "bodyText": "Revised accordingly. Thanks for your clarification.", "author": "liyafan82", "createdAt": "2020-09-03T09:35:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc0MzQ0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc0NTQ3Mg==", "url": "https://github.com/apache/calcite/pull/2128#discussion_r481745472", "bodyText": "Can we make RelWriterTest parameterized instead of modifying and abstract common test base ?", "author": "danny0405", "createdAt": "2020-09-02T05:51:22Z", "path": "core/src/test/java/org/apache/calcite/plan/RelWriterTest.java", "diffHunk": "@@ -839,12 +863,22 @@\n         .build();\n     final String relJson = RelOptUtil.dumpPlan(\"\", rel,\n         SqlExplainFormat.JSON, SqlExplainLevel.EXPPLAN_ATTRIBUTES);\n-    final String result = deserializeAndDumpToTextFormat(getSchema(rel), relJson);\n-    final String expected = \"\"\n+    final String result = deserializeAndDumpToTextFormat(getSchema(rel), relJson, format);\n+    assertThat(result, isLinux(expected));\n+  }\n+\n+  @Test void testUDAF() {\n+    testUDAF0(SqlExplainFormat.TEXT, \"\"", "originalCommit": "a2ecc6ff958cb3ddd125667c74148b69d00461a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk4MjI5Ng==", "url": "https://github.com/apache/calcite/pull/2128#discussion_r481982296", "bodyText": "Sounds reasonable.\nI was having similar thoughts, but gave up because\n\nsome test cases in the class are not suitable for parameterized testing.\nsince the strings of the expected results take up much space of the class, parameterizing the class does not significantly reduce the code size.\n\nDo you have any suggestions?", "author": "liyafan82", "createdAt": "2020-09-02T10:58:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc0NTQ3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAxMDQ0NQ==", "url": "https://github.com/apache/calcite/pull/2128#discussion_r482010445", "bodyText": "For case 1 you can use junit Assume to skip the param you do not want to test.", "author": "danny0405", "createdAt": "2020-09-02T11:53:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc0NTQ3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjg0NDcwMQ==", "url": "https://github.com/apache/calcite/pull/2128#discussion_r482844701", "bodyText": "I have revised them to parameterized tests. Thank you.", "author": "liyafan82", "createdAt": "2020-09-03T09:35:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc0NTQ3Mg=="}], "type": "inlineReview"}, {"oid": "94ab8187fc6c497ea9179399f08f5635c2e215a6", "url": "https://github.com/apache/calcite/commit/94ab8187fc6c497ea9179399f08f5635c2e215a6", "message": "[CALCITE-4197] Provide utility to visualize RelNode plans", "committedDate": "2020-09-11T08:00:24Z", "type": "commit"}, {"oid": "94ab8187fc6c497ea9179399f08f5635c2e215a6", "url": "https://github.com/apache/calcite/commit/94ab8187fc6c497ea9179399f08f5635c2e215a6", "message": "[CALCITE-4197] Provide utility to visualize RelNode plans", "committedDate": "2020-09-11T08:00:24Z", "type": "forcePushed"}]}