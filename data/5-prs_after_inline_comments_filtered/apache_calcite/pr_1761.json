{"pr_number": 1761, "pr_title": "[CALCITE-3737][CALCITE-3780] Implement HOP and SESSION table functions", "pr_createdAt": "2020-01-15T06:34:16Z", "pr_url": "https://github.com/apache/calcite/pull/1761", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc0MjA3Mw==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r366742073", "bodyText": "extra line?", "author": "DonnyZone", "createdAt": "2020-01-15T08:20:35Z", "path": "core/src/main/java/org/apache/calcite/sql/SqlWindowTableFunction.java", "diffHunk": "@@ -20,17 +20,16 @@\n import org.apache.calcite.rel.type.RelDataTypeField;\n import org.apache.calcite.rel.type.RelDataTypeFieldImpl;\n import org.apache.calcite.rel.type.RelRecordType;\n-import org.apache.calcite.sql.type.SqlOperandCountRanges;\n import org.apache.calcite.sql.type.SqlReturnTypeInference;\n import org.apache.calcite.sql.type.SqlTypeName;\n-import org.apache.calcite.sql.type.SqlTypeUtil;\n import org.apache.calcite.sql.validate.SqlValidator;\n \n import java.util.ArrayList;\n import java.util.List;\n \n import static org.apache.calcite.util.Static.RESOURCE;\n \n+", "originalCommit": "fb0fb9a874db5a61364ce7aa9b707d4ec3d2f698", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA4NTc5MA==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r367085790", "bodyText": "thanks! I will hold the change a bit until receive enough comments (and will address all style like comments at a time).", "author": "amaliujia", "createdAt": "2020-01-15T20:16:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc0MjA3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc5NTcyNQ==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r369795725", "bodyText": "fixed!", "author": "amaliujia", "createdAt": "2020-01-22T20:51:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc0MjA3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc0NTE0NA==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r366745144", "bodyText": "Why we remove these methods? Each window table function has its own implementation?", "author": "DonnyZone", "createdAt": "2020-01-15T08:28:54Z", "path": "core/src/main/java/org/apache/calcite/sql/SqlWindowTableFunction.java", "diffHunk": "@@ -44,28 +43,21 @@ public SqlWindowTableFunction(String name) {\n         SqlFunctionCategory.SYSTEM);\n   }\n \n-  @Override public SqlOperandCountRange getOperandCountRange() {\n-    return SqlOperandCountRanges.of(3);\n-  }\n-\n-  @Override public boolean checkOperandTypes(SqlCallBinding callBinding,", "originalCommit": "fb0fb9a874db5a61364ce7aa9b707d4ec3d2f698", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA4NDE4OA==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r367084188", "bodyText": "Yes. Each windowing table-valued function shall check their own operands. The check of DESCRIPTOR names are also left for each function (which makes sense as each function has its own interpretation of names).", "author": "amaliujia", "createdAt": "2020-01-15T20:13:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc0NTE0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA4NTI2MQ==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r367085261", "bodyText": "extra line", "author": "amaliujia", "createdAt": "2020-01-15T20:15:37Z", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumUtils.java", "diffHunk": "@@ -796,4 +800,86 @@ static Expression windowSelector(\n         outputPhysType.record(expressions),\n         parameter);\n   }\n+\n+  /**\n+   * Create enumerable implementation that applies hoping on each element from the input\n+   * enumerator and produces at least one element for each input element.\n+   */\n+  public static Enumerable<Object[]> hoping(Enumerator<Object[]> inputEnumerator,\n+                                            int indexOfWatermarkedColumn,\n+                                            long emitFrequency,\n+                                            long intervalSize) {\n+    return new AbstractEnumerable<Object[]>() {\n+      @Override public Enumerator<Object[]> enumerator() {\n+        return new HopEnumerator(inputEnumerator,\n+            indexOfWatermarkedColumn, emitFrequency, intervalSize);\n+      }\n+    };\n+  }\n+\n+  private static class HopEnumerator implements Enumerator<Object[]> {\n+    private final Enumerator<Object[]> inputEnumerator;\n+    private final int indexOfWatermarkedColumn;\n+    private final long emitFrequency;\n+    private final long intervalSize;\n+    private LinkedList<Object[]> list;\n+\n+    HopEnumerator(Enumerator<Object[]> inputEnumerator,\n+                  int indexOfWatermarkedColumn, long emitFrequency, long intervalSize) {\n+      this.inputEnumerator = inputEnumerator;\n+      this.indexOfWatermarkedColumn = indexOfWatermarkedColumn;\n+      this.emitFrequency = emitFrequency;\n+      this.intervalSize = intervalSize;\n+      list = new LinkedList<>();\n+    }\n+\n+    public Object[] current() {\n+      if (list.size() > 0) {\n+        return takeOne();\n+      } else {\n+        Object[] current = inputEnumerator.current();\n+        List<Pair> windows = hopWindows(SqlFunctions.toLong(current[indexOfWatermarkedColumn]),\n+            emitFrequency, intervalSize);\n+        for (Pair window : windows) {\n+          Object[] curWithWindow = new Object[current.length + 2];\n+          System.arraycopy(current, 0, curWithWindow, 0, current.length);\n+          curWithWindow[current.length] = window.left;\n+          curWithWindow[current.length + 1] = window.right;\n+          list.offer(curWithWindow);\n+        }\n+        return takeOne();\n+      }\n+", "originalCommit": "fb0fb9a874db5a61364ce7aa9b707d4ec3d2f698", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE1MTA5Mg==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r367151092", "bodyText": "will fix bases as a typo.", "author": "amaliujia", "createdAt": "2020-01-15T22:56:27Z", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumUtils.java", "diffHunk": "@@ -744,9 +748,9 @@ static Expression generatePredicate(\n     return Expressions.lambda(Predicate2.class, builder.toBlock(), left_, right_);\n   }\n \n-  /** Generates a window selector which appends attribute of the window based on\n+  /** Generates a window selector which appends attribute of the window bases on", "originalCommit": "fb0fb9a874db5a61364ce7aa9b707d4ec3d2f698", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzczNjQxNQ==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r367736415", "bodyText": "Here we can use Math.toIntExact.", "author": "XuQianJin-Stars", "createdAt": "2020-01-17T01:52:07Z", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumUtils.java", "diffHunk": "@@ -796,4 +800,86 @@ static Expression windowSelector(\n         outputPhysType.record(expressions),\n         parameter);\n   }\n+\n+  /**\n+   * Create enumerable implementation that applies hoping on each element from the input\n+   * enumerator and produces at least one element for each input element.\n+   */\n+  public static Enumerable<Object[]> hoping(Enumerator<Object[]> inputEnumerator,\n+                                            int indexOfWatermarkedColumn,\n+                                            long emitFrequency,\n+                                            long intervalSize) {\n+    return new AbstractEnumerable<Object[]>() {\n+      @Override public Enumerator<Object[]> enumerator() {\n+        return new HopEnumerator(inputEnumerator,\n+            indexOfWatermarkedColumn, emitFrequency, intervalSize);\n+      }\n+    };\n+  }\n+\n+  private static class HopEnumerator implements Enumerator<Object[]> {\n+    private final Enumerator<Object[]> inputEnumerator;\n+    private final int indexOfWatermarkedColumn;\n+    private final long emitFrequency;\n+    private final long intervalSize;\n+    private LinkedList<Object[]> list;\n+\n+    HopEnumerator(Enumerator<Object[]> inputEnumerator,\n+                  int indexOfWatermarkedColumn, long emitFrequency, long intervalSize) {\n+      this.inputEnumerator = inputEnumerator;\n+      this.indexOfWatermarkedColumn = indexOfWatermarkedColumn;\n+      this.emitFrequency = emitFrequency;\n+      this.intervalSize = intervalSize;\n+      list = new LinkedList<>();\n+    }\n+\n+    public Object[] current() {\n+      if (list.size() > 0) {\n+        return takeOne();\n+      } else {\n+        Object[] current = inputEnumerator.current();\n+        List<Pair> windows = hopWindows(SqlFunctions.toLong(current[indexOfWatermarkedColumn]),\n+            emitFrequency, intervalSize);\n+        for (Pair window : windows) {\n+          Object[] curWithWindow = new Object[current.length + 2];\n+          System.arraycopy(current, 0, curWithWindow, 0, current.length);\n+          curWithWindow[current.length] = window.left;\n+          curWithWindow[current.length + 1] = window.right;\n+          list.offer(curWithWindow);\n+        }\n+        return takeOne();\n+      }\n+\n+    }\n+\n+    public boolean moveNext() {\n+      if (list.size() > 0) {\n+        return true;\n+      }\n+      return inputEnumerator.moveNext();\n+    }\n+\n+    public void reset() {\n+      inputEnumerator.reset();\n+      list.clear();\n+    }\n+\n+    public void close() {\n+    }\n+\n+    private Object[] takeOne() {\n+      return list.pollFirst();\n+    }\n+  }\n+\n+  private static List<Pair> hopWindows(long tsMillis, long periodMillis, long sizeMillis) {\n+    ArrayList<Pair> ret = new ArrayList<>((int) (sizeMillis / periodMillis));", "originalCommit": "fb0fb9a874db5a61364ce7aa9b707d4ec3d2f698", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzczNzMyNQ==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r367737325", "bodyText": "809L-811L The indentation format seems a bit problematic.\nThere are several more functions with indentation format below.", "author": "XuQianJin-Stars", "createdAt": "2020-01-17T01:57:08Z", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumUtils.java", "diffHunk": "@@ -796,4 +800,86 @@ static Expression windowSelector(\n         outputPhysType.record(expressions),\n         parameter);\n   }\n+\n+  /**\n+   * Create enumerable implementation that applies hoping on each element from the input\n+   * enumerator and produces at least one element for each input element.\n+   */\n+  public static Enumerable<Object[]> hoping(Enumerator<Object[]> inputEnumerator,\n+                                            int indexOfWatermarkedColumn,", "originalCommit": "fb0fb9a874db5a61364ce7aa9b707d4ec3d2f698", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7b6a3fd569b64d0bb83d9f386bffe8270d6c967b", "url": "https://github.com/apache/calcite/commit/7b6a3fd569b64d0bb83d9f386bffe8270d6c967b", "message": "[CALCITE-3737] HOP Table-valued Function (Rui Wang)", "committedDate": "2020-01-23T21:39:21Z", "type": "forcePushed"}, {"oid": "a3510f94f9a72b58895e8bcddd101a8d4487f74e", "url": "https://github.com/apache/calcite/commit/a3510f94f9a72b58895e8bcddd101a8d4487f74e", "message": "[CALCITE-3737] HOP Table-valued Function (Rui Wang)", "committedDate": "2020-01-23T21:51:22Z", "type": "forcePushed"}, {"oid": "949ab21f76773211c25a84f9dc8fb16807c4d1f5", "url": "https://github.com/apache/calcite/commit/949ab21f76773211c25a84f9dc8fb16807c4d1f5", "message": "[CALCITE-3737] HOP Table-valued Function (Rui Wang)", "committedDate": "2020-01-23T22:35:31Z", "type": "forcePushed"}, {"oid": "e446488a1865bbeeededce9a8c0923e6fd3597fb", "url": "https://github.com/apache/calcite/commit/e446488a1865bbeeededce9a8c0923e6fd3597fb", "message": "[CALCITE-3737] HOP Table-valued Function (Rui Wang)", "committedDate": "2020-02-02T06:52:20Z", "type": "forcePushed"}, {"oid": "4b70c23fc071064d0a3f51b4c6d825acfede8774", "url": "https://github.com/apache/calcite/commit/4b70c23fc071064d0a3f51b4c6d825acfede8774", "message": "fixup! fix reference.md", "committedDate": "2020-02-12T21:59:22Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEwNDM3OA==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r394104378", "bodyText": "Just of curious, is the \"TVF\" a commonly-used abbreviation?", "author": "DonnyZone", "createdAt": "2020-03-18T04:45:49Z", "path": "core/src/main/java/org/apache/calcite/sql/fun/SqlStdOperatorTable.java", "diffHunk": "@@ -2273,8 +2275,14 @@ public void unparse(\n   /** DESCRIPTOR(column_name, ...). */\n   public static final SqlOperator DESCRIPTOR = new SqlDescriptorOperator();\n \n-  /** TUMBLE as a table-value function. */\n-  public static final SqlFunction TUMBLE_TVF = new SqlWindowTableFunction(SqlKind.TUMBLE.name());\n+  /** TUMBLE as a table function. */\n+  public static final SqlFunction TUMBLE_TVF = new SqlTumbleTableFunction();", "originalCommit": "7fa58910ba0f4ba139aad40b9ae3d6de5f10b69a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEwNDY1Mw==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r394104653", "bodyText": "Why we need to change the function name here?", "author": "DonnyZone", "createdAt": "2020-03-18T04:47:10Z", "path": "core/src/main/java/org/apache/calcite/sql/fun/SqlStdOperatorTable.java", "diffHunk": "@@ -2312,7 +2320,7 @@ public void unparse(\n \n   /** The {@code HOP} group function. */\n   public static final SqlGroupedWindowFunction HOP =\n-      new SqlGroupedWindowFunction(SqlKind.HOP.name(), SqlKind.HOP, null,\n+      new SqlGroupedWindowFunction(\"$HOP\", SqlKind.HOP, null,", "originalCommit": "7fa58910ba0f4ba139aad40b9ae3d6de5f10b69a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE0NTkyMQ==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r396145921", "bodyText": "Here is the context about this change: https://github.com/apache/calcite/blob/master/core/src/main/java/org/apache/calcite/sql/fun/SqlStdOperatorTable.java#L2304", "author": "amaliujia", "createdAt": "2020-03-22T21:58:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEwNDY1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE4NDcxMA==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r396184710", "bodyText": "I see, thanks for explanation.", "author": "DonnyZone", "createdAt": "2020-03-23T02:21:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEwNDY1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEwNTA5NA==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r394105094", "bodyText": "Any special reasons to implement tumbling and hopping&sessionize in different places?", "author": "DonnyZone", "createdAt": "2020-03-18T04:49:14Z", "path": "core/src/main/java/org/apache/calcite/util/BuiltInMethod.java", "diffHunk": "@@ -586,7 +587,11 @@\n       \"resultSelector\", Function2.class),\n   AGG_LAMBDA_FACTORY_ACC_SINGLE_GROUP_RESULT_SELECTOR(AggregateLambdaFactory.class,\n       \"singleGroupResultSelector\", Function1.class),\n-  TUMBLING(EnumerableDefaults.class, \"tumbling\", Enumerable.class, Function1.class);\n+  TUMBLING(EnumerableDefaults.class, \"tumbling\", Enumerable.class, Function1.class),\n+  HOPPING(EnumUtils.class, \"hopping\", Enumerator.class, int.class, long.class,", "originalCommit": "7fa58910ba0f4ba139aad40b9ae3d6de5f10b69a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE0NjA0MA==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r396146040", "bodyText": "I see. No special reason. Would you suggest I put it in the same class? If so, which class is better?", "author": "amaliujia", "createdAt": "2020-03-22T21:59:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEwNTA5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE4NTMxMQ==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r396185311", "bodyText": "Current now, I personally suggest to put them in EnumUtils. It is a little strange in Linq4j. But if we will add more streaming functions later, I think we can create a separate class for them. It's more clear.", "author": "DonnyZone", "createdAt": "2020-03-23T02:25:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEwNTA5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzQyODA1MQ==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r397428051", "bodyText": "Done!", "author": "amaliujia", "createdAt": "2020-03-24T20:06:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEwNTA5NA=="}], "type": "inlineReview"}, {"oid": "a94446e35592b69b3eee805919257f6072099e85", "url": "https://github.com/apache/calcite/commit/a94446e35592b69b3eee805919257f6072099e85", "message": "fixup! address comments", "committedDate": "2020-04-07T22:12:47Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM0NjkyMw==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r407346923", "bodyText": "nitpicking: indent", "author": "DonnyZone", "createdAt": "2020-04-13T06:56:02Z", "path": "core/src/main/java/org/apache/calcite/sql/SqlSessionTableFunction.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.sql;\n+\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.sql.type.SqlOperandCountRanges;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+import org.apache.calcite.sql.type.SqlTypeUtil;\n+import org.apache.calcite.sql.validate.SqlValidator;\n+\n+/**\n+ * SqlSessionTableFunction implements an operator for per-key sessionization. It allows\n+ * four parameters:\n+ * 1. a table.\n+ * 2. a descriptor to provide a watermarked column name from the input table.\n+ * 3. a descriptor to provide a column as key, on which sessionization will be applied.\n+ * 4. an interval parameter to specify a inactive activity gap to break sessions.\n+ */\n+public class SqlSessionTableFunction extends SqlWindowTableFunction {\n+  public SqlSessionTableFunction() {\n+    super(SqlKind.SESSION.name());\n+  }\n+\n+  @Override public SqlOperandCountRange getOperandCountRange() {\n+    return SqlOperandCountRanges.of(4);\n+  }\n+\n+  @Override public boolean checkOperandTypes(SqlCallBinding callBinding,\n+                                             boolean throwOnFailure) {", "originalCommit": "a94446e35592b69b3eee805919257f6072099e85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzcxMjY3Ng==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r407712676", "bodyText": "oops. Fixed", "author": "amaliujia", "createdAt": "2020-04-13T20:49:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM0NjkyMw=="}], "type": "inlineReview"}, {"oid": "14a165a47cb329720c1cbf649b976573ab1b11b1", "url": "https://github.com/apache/calcite/commit/14a165a47cb329720c1cbf649b976573ab1b11b1", "message": "[CALCITE-3780] SESSION table-valued function (Rui Wang)", "committedDate": "2020-04-13T20:51:21Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4NjM1Mw==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r410586353", "bodyText": "Give doc for these parameters. Same for other codes.", "author": "danny0405", "createdAt": "2020-04-18T03:22:35Z", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumUtils.java", "diffHunk": "@@ -796,4 +803,244 @@ static Expression windowSelector(\n         outputPhysType.record(expressions),\n         parameter);\n   }\n+\n+  /**\n+   * Create enumerable implementation that applies sessionization to elements from the input\n+   * enumerator based on a specified key. Elements are windowed into sessions separated by\n+   * periods with no input for at least the duration specified by gap parameter.\n+   */\n+  public static Enumerable<Object[]> sessionize(Enumerator<Object[]> inputEnumerator,\n+      int indexOfWatermarkedColumn, int indexOfKeyColumn, long gap) {\n+    return new AbstractEnumerable<Object[]>() {\n+      @Override public Enumerator<Object[]> enumerator() {\n+        return new SessionizationEnumerator(inputEnumerator,\n+            indexOfWatermarkedColumn, indexOfKeyColumn, gap);\n+      }\n+    };\n+  }\n+\n+  private static class SessionizationEnumerator implements Enumerator<Object[]> {\n+    private final Enumerator<Object[]> inputEnumerator;\n+    private final int indexOfWatermarkedColumn;\n+    private final int indexOfKeyColumn;\n+    private final long gap;\n+    private LinkedList<Object[]> list;\n+    private boolean initialized;\n+\n+    SessionizationEnumerator(Enumerator<Object[]> inputEnumerator,\n+        int indexOfWatermarkedColumn, int indexOfKeyColumn, long gap) {\n+      this.inputEnumerator = inputEnumerator;", "originalCommit": "14a165a47cb329720c1cbf649b976573ab1b11b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTEwMjU5NQ==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r411102595", "bodyText": "Done.", "author": "amaliujia", "createdAt": "2020-04-20T05:29:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4NjM1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4NjUwMA==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r410586500", "bodyText": "Create -> Creates, same for other codes.", "author": "danny0405", "createdAt": "2020-04-18T03:22:52Z", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumUtils.java", "diffHunk": "@@ -796,4 +803,244 @@ static Expression windowSelector(\n         outputPhysType.record(expressions),\n         parameter);\n   }\n+\n+  /**\n+   * Create enumerable implementation that applies sessionization to elements from the input\n+   * enumerator based on a specified key. Elements are windowed into sessions separated by", "originalCommit": "14a165a47cb329720c1cbf649b976573ab1b11b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTEwMjU2NQ==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r411102565", "bodyText": "Done.", "author": "amaliujia", "createdAt": "2020-04-20T05:29:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4NjUwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4NzI3Mw==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r410587273", "bodyText": "Is this true ? Shouldn't we rely on the watermark and gap to decide if a session is expired ? What about the late arrive data ?\nThis implementation should not be blocking.", "author": "danny0405", "createdAt": "2020-04-18T03:24:37Z", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumUtils.java", "diffHunk": "@@ -796,4 +803,244 @@ static Expression windowSelector(\n         outputPhysType.record(expressions),\n         parameter);\n   }\n+\n+  /**\n+   * Create enumerable implementation that applies sessionization to elements from the input\n+   * enumerator based on a specified key. Elements are windowed into sessions separated by\n+   * periods with no input for at least the duration specified by gap parameter.\n+   */\n+  public static Enumerable<Object[]> sessionize(Enumerator<Object[]> inputEnumerator,\n+      int indexOfWatermarkedColumn, int indexOfKeyColumn, long gap) {\n+    return new AbstractEnumerable<Object[]>() {\n+      @Override public Enumerator<Object[]> enumerator() {\n+        return new SessionizationEnumerator(inputEnumerator,\n+            indexOfWatermarkedColumn, indexOfKeyColumn, gap);\n+      }\n+    };\n+  }\n+\n+  private static class SessionizationEnumerator implements Enumerator<Object[]> {\n+    private final Enumerator<Object[]> inputEnumerator;\n+    private final int indexOfWatermarkedColumn;\n+    private final int indexOfKeyColumn;\n+    private final long gap;\n+    private LinkedList<Object[]> list;\n+    private boolean initialized;\n+\n+    SessionizationEnumerator(Enumerator<Object[]> inputEnumerator,\n+        int indexOfWatermarkedColumn, int indexOfKeyColumn, long gap) {\n+      this.inputEnumerator = inputEnumerator;\n+      this.indexOfWatermarkedColumn = indexOfWatermarkedColumn;\n+      this.indexOfKeyColumn = indexOfKeyColumn;\n+      this.gap = gap;\n+      list = new LinkedList<>();\n+      initialized = false;\n+    }\n+\n+    @Override public Object[] current() {\n+      if (!initialized) {\n+        initialize();\n+        initialized = true;\n+      }\n+      return list.pollFirst();\n+    }\n+\n+    @Override public boolean moveNext() {\n+      return initialized ? list.size() > 0 : inputEnumerator.moveNext();\n+    }\n+\n+    @Override public void reset() {\n+      list.clear();\n+      inputEnumerator.reset();\n+      initialized = false;\n+    }\n+\n+    @Override public void close() {\n+      list.clear();\n+      inputEnumerator.close();\n+      initialized = false;\n+    }\n+\n+    private void initialize() {\n+      List<Object[]> elements = new ArrayList<>();\n+      // initialize() will be called when inputEnumerator.moveNext() is true,\n+      // thus firstly should take the current element.\n+      elements.add(inputEnumerator.current());\n+      // sessionization needs to see all data.\n+      while (inputEnumerator.moveNext()) {", "originalCommit": "14a165a47cb329720c1cbf649b976573ab1b11b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA4OTI3Mg==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r411089272", "bodyText": "It is true because this is batch only implementation.\nFor streaming cases, it needs to rely on watermark to know when it's ready to emit data. For batch cases, technically watermark always advances to the positive infinite at the beginning to mark all data has arrived (because it is bounded, or pre-known input data set). So this implementation is correct for batch case, because \"watermark = positive infinity\" means all data need to be processed.\nI do have a plan to introduce watermark into calcite, and along with it, there should also be a test unbounded/streaming input source be built. By doing so we should be able to migrate current batch only implementation to batch-streaming unified implementation, which depends on watermark. However it will take some time to reach that point (with the support of community).", "author": "amaliujia", "createdAt": "2020-04-20T04:44:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4NzI3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg1NTMwMw==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r411855303", "bodyText": "I hear your concerns, but the operator did have a param named watermark.", "author": "danny0405", "createdAt": "2020-04-21T04:14:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4NzI3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg2MTc3Ng==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r411861776", "bodyText": "Sorry I might have missed something. What's the param that is named watermark? You mean the watermarked column, e.g. timestamp column specified by descriptor?\nTo clarify, that column is not named watermark. It is just a timestamp column which we say \"watermark is built upon\". For SQL, watermark is not visible to users. Users cannot tell a \"watermark\" from the query, and watermark is not a part of algebra.\nWatermark is supposed to be implemented by SQL engine, which usually is tied with sources. For example, in Apache Beam, we have two interfaces for sources: bounded source 1 and unbounded source 2. For bounded source, there is no watermark since it is the batch case, but windowing still applies: just applying windowing based on a timestamp column without considering late data. Calcite's Enumerable interface is like bounded source in Beam.", "author": "amaliujia", "createdAt": "2020-04-21T04:35:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4NzI3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTkyNzMzMw==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r411927333", "bodyText": "Then why there are param named indexOfWatermarkedColumn  ?", "author": "danny0405", "createdAt": "2020-04-21T07:08:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4NzI3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ4ODUyNw==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r412488527", "bodyText": "Watermark is a concept that is used to indicate the completeness of data, and it is not necessary an implementation.\nThe naming of \"WatermarkedColumn\" really means two things:\n\nThis is the column that provide event timestamp, which has the \"event timestamp\" semantic. (You can find \"Event time vs. processing time\" section in https://www.oreilly.com/radar/the-world-beyond-batch-streaming-101/ to know more about this semantic)\nBecause it has \"event timestamp\" semantic, we reply on \"watermark\" to know the data completeness and define late data.\n\nAnd windowing implemented by these series of PRs are coupled with \"event timestamp\" semantic, or we can just call it \"event timestamp windowing\" semantic.\nWhat does it mean for batch and streaming sources? Say \"hey,  this is the watermarked column, which gives the event timestamp. Let's apply windowing on this column. Wait a minute, how do I know the data is complete, thus I can close a window?\"\nFor streaming source: \"Hey it is streaming case, and we have watermark! If the watermark passes the end of window, you can mark the window is closed and all future data falls into that window is late\".\nFor batch source: \"Hey it is batch case, all data is known and there is no late data. Just close the window when all data are processed. And watermark also applies because when you ask the watermark, it always tell you that you can close the window\". In this case we can either implement watermark, which explicitly tell all window can be closed, or we just close them because this is batch. After all, it is just an implementation choice,\nI think it is really a high-level argument and depends on if you accept this statement: batch is a special case of streaming. If you do accept this statement, using \"watermark\" is not wrong. Batch case can use all streaming terms (note that I am not saying using the same implementation). Also in the future, after streaming sources are built, either we change code here, or not, the behavior of what is build in this PR won't change cause it matches with \"event timestamp windowing\" semantic. So it is backward compatible.", "author": "amaliujia", "createdAt": "2020-04-21T21:01:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4NzI3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYwODY4MQ==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r412608681", "bodyText": "I do understand what a watermark is, no need to explain more, what i have concern upon is that the implementation has no relationship with a \"watermark\" definition but in the function doc, we represent it everywhere, which i think is not in consistent.", "author": "danny0405", "createdAt": "2020-04-22T01:47:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4NzI3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYxNTIzNQ==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r412615235", "bodyText": "Ok what's the recommendation then? Do you want \"watermark\" as a word removed?", "author": "amaliujia", "createdAt": "2020-04-22T02:05:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4NzI3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYxOTc5Nw==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r412619797", "bodyText": "How about we add some notes in the function document that we only implements batch group window.", "author": "danny0405", "createdAt": "2020-04-22T02:19:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4NzI3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzI5NzI4MQ==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r413297281", "bodyText": "Sure. Added a note for each windowing implementation to say they work for batch only.", "author": "amaliujia", "createdAt": "2020-04-22T20:15:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4NzI3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4ODAwMA==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r410588000", "bodyText": "indexOfWatermarkedColumn  -> wmIndex ?", "author": "danny0405", "createdAt": "2020-04-18T03:26:28Z", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumUtils.java", "diffHunk": "@@ -796,4 +803,244 @@ static Expression windowSelector(\n         outputPhysType.record(expressions),\n         parameter);\n   }\n+\n+  /**\n+   * Create enumerable implementation that applies sessionization to elements from the input\n+   * enumerator based on a specified key. Elements are windowed into sessions separated by\n+   * periods with no input for at least the duration specified by gap parameter.\n+   */\n+  public static Enumerable<Object[]> sessionize(Enumerator<Object[]> inputEnumerator,\n+      int indexOfWatermarkedColumn, int indexOfKeyColumn, long gap) {\n+    return new AbstractEnumerable<Object[]>() {\n+      @Override public Enumerator<Object[]> enumerator() {\n+        return new SessionizationEnumerator(inputEnumerator,\n+            indexOfWatermarkedColumn, indexOfKeyColumn, gap);\n+      }\n+    };\n+  }\n+\n+  private static class SessionizationEnumerator implements Enumerator<Object[]> {\n+    private final Enumerator<Object[]> inputEnumerator;\n+    private final int indexOfWatermarkedColumn;\n+    private final int indexOfKeyColumn;\n+    private final long gap;\n+    private LinkedList<Object[]> list;\n+    private boolean initialized;\n+\n+    SessionizationEnumerator(Enumerator<Object[]> inputEnumerator,\n+        int indexOfWatermarkedColumn, int indexOfKeyColumn, long gap) {\n+      this.inputEnumerator = inputEnumerator;\n+      this.indexOfWatermarkedColumn = indexOfWatermarkedColumn;\n+      this.indexOfKeyColumn = indexOfKeyColumn;\n+      this.gap = gap;\n+      list = new LinkedList<>();\n+      initialized = false;\n+    }\n+\n+    @Override public Object[] current() {\n+      if (!initialized) {\n+        initialize();\n+        initialized = true;\n+      }\n+      return list.pollFirst();\n+    }\n+\n+    @Override public boolean moveNext() {\n+      return initialized ? list.size() > 0 : inputEnumerator.moveNext();\n+    }\n+\n+    @Override public void reset() {\n+      list.clear();\n+      inputEnumerator.reset();\n+      initialized = false;\n+    }\n+\n+    @Override public void close() {\n+      list.clear();\n+      inputEnumerator.close();\n+      initialized = false;\n+    }\n+\n+    private void initialize() {\n+      List<Object[]> elements = new ArrayList<>();\n+      // initialize() will be called when inputEnumerator.moveNext() is true,\n+      // thus firstly should take the current element.\n+      elements.add(inputEnumerator.current());\n+      // sessionization needs to see all data.\n+      while (inputEnumerator.moveNext()) {\n+        elements.add(inputEnumerator.current());\n+      }\n+\n+      Map<Object, SortedMultiMap<Pair<Long, Long>, Object[]>> sessionKeyMap = new HashMap<>();\n+      for (Object[] element : elements) {\n+        sessionKeyMap.putIfAbsent(element[indexOfKeyColumn], new SortedMultiMap<>());\n+        Pair initWindow = computeInitWindow(\n+            SqlFunctions.toLong(element[indexOfWatermarkedColumn]), gap);\n+        sessionKeyMap.get(element[indexOfKeyColumn]).putMulti(initWindow, element);\n+      }\n+\n+      // merge per key session windows if there is any overlap between windows.\n+      for (Map.Entry<Object, SortedMultiMap<Pair<Long, Long>, Object[]>> perKeyEntry\n+          : sessionKeyMap.entrySet()) {\n+        Map<Pair<Long, Long>, List<Object[]>> finalWindowElementsMap = new HashMap<>();\n+        Pair<Long, Long> currentWindow = null;\n+        List<Object[]> tempElementList = new ArrayList<>();\n+        for (Map.Entry<Pair<Long, Long>, List<Object[]>> sessionEntry\n+            : perKeyEntry.getValue().entrySet()) {\n+          // check the next window can be merged.\n+          if (currentWindow == null || !isOverlapped(currentWindow, sessionEntry.getKey())) {\n+            // cannot merge window as there is no overlap\n+            if (currentWindow != null) {\n+              finalWindowElementsMap.put(currentWindow, new ArrayList<>(tempElementList));\n+            }\n+\n+            currentWindow = sessionEntry.getKey();\n+            tempElementList.clear();\n+            tempElementList.addAll(sessionEntry.getValue());\n+          } else {\n+            // merge windows.\n+            currentWindow = mergeWindows(currentWindow, sessionEntry.getKey());\n+            // merge elements in windows.\n+            tempElementList.addAll(sessionEntry.getValue());\n+          }\n+        }\n+\n+        if (!tempElementList.isEmpty()) {\n+          finalWindowElementsMap.put(currentWindow, new ArrayList<>(tempElementList));\n+        }\n+\n+        // construct final results from finalWindowElementsMap.\n+        for (Map.Entry<Pair<Long, Long>, List<Object[]>> finalWindowElementsEntry\n+            : finalWindowElementsMap.entrySet()) {\n+          for (Object[] element : finalWindowElementsEntry.getValue()) {\n+            Object[] curWithWindow = new Object[element.length + 2];\n+            System.arraycopy(element, 0, curWithWindow, 0, element.length);\n+            curWithWindow[element.length] = finalWindowElementsEntry.getKey().left;\n+            curWithWindow[element.length + 1] = finalWindowElementsEntry.getKey().right;\n+            list.offer(curWithWindow);\n+          }\n+        }\n+      }\n+    }\n+\n+    private boolean isOverlapped(Pair<Long, Long> a, Pair<Long, Long> b) {\n+      return !(b.left >= a.right);\n+    }\n+\n+    private Pair<Long, Long> mergeWindows(Pair<Long, Long> a, Pair<Long, Long> b) {\n+      return new Pair<>(a.left <= b.left ? a.left : b.left, a.right >= b.right ? a.right : b.right);\n+    }\n+\n+    private Pair<Long, Long> computeInitWindow(long ts, long gap) {\n+      return new Pair<>(ts, ts + gap);\n+    }\n+  }\n+\n+  /**\n+   * Create enumerable implementation that applies hopping on each element from the input\n+   * enumerator and produces at least one element for each input element.\n+   */\n+  public static Enumerable<Object[]> hopping(Enumerator<Object[]> inputEnumerator,\n+      int indexOfWatermarkedColumn, long emitFrequency, long intervalSize) {\n+    return new AbstractEnumerable<Object[]>() {\n+      @Override public Enumerator<Object[]> enumerator() {\n+        return new HopEnumerator(inputEnumerator,\n+            indexOfWatermarkedColumn, emitFrequency, intervalSize);\n+      }\n+    };\n+  }\n+\n+  private static class HopEnumerator implements Enumerator<Object[]> {\n+    private final Enumerator<Object[]> inputEnumerator;\n+    private final int indexOfWatermarkedColumn;\n+    private final long emitFrequency;\n+    private final long intervalSize;\n+    private LinkedList<Object[]> list;\n+\n+    HopEnumerator(Enumerator<Object[]> inputEnumerator,\n+        int indexOfWatermarkedColumn, long emitFrequency, long intervalSize) {\n+      this.inputEnumerator = inputEnumerator;\n+      this.indexOfWatermarkedColumn = indexOfWatermarkedColumn;\n+      this.emitFrequency = emitFrequency;", "originalCommit": "14a165a47cb329720c1cbf649b976573ab1b11b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA4NzQ4OA==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r411087488", "bodyText": "I prefer to keep \"watermark\". This is the relatively new concept for Calcite, so abbreviation could make people confused.\nActually I have observed it on \"TVF\" (table-valued function or table function). Seems like people are already confused on such abbreviation.", "author": "amaliujia", "createdAt": "2020-04-20T04:37:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4ODAwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTEwMzIwMw==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r411103203", "bodyText": "Use \"table function\" sounds better, i don't really know what a \"table-valued function\" means.", "author": "danny0405", "createdAt": "2020-04-20T05:31:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4ODAwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4ODMyMg==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r410588322", "bodyText": "Also remove the values keyword from the commit message.", "author": "danny0405", "createdAt": "2020-04-18T03:27:23Z", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/RexImpTable.java", "diffHunk": "@@ -966,8 +970,8 @@ public MatchImplementor get(final SqlMatchFunction function) {\n     }\n   }\n \n-  public TableValuedFunctionCallImplementor get(final SqlWindowTableFunction operator) {\n-    final Supplier<? extends TableValuedFunctionCallImplementor> supplier =\n+  public TableFunctionCallImplementor get(final SqlWindowTableFunction operator) {\n+    final Supplier<? extends TableFunctionCallImplementor> supplier =", "originalCommit": "14a165a47cb329720c1cbf649b976573ab1b11b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTEwMzA1Mg==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r411103052", "bodyText": "Done.", "author": "amaliujia", "createdAt": "2020-04-20T05:30:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4ODMyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4ODg3MQ==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r410588871", "bodyText": "Give these intervalExpression  more meaningful name. e.g. windowSize and slidingInterval ?", "author": "danny0405", "createdAt": "2020-04-18T03:28:29Z", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/RexImpTable.java", "diffHunk": "@@ -3143,11 +3147,62 @@ private Expression normalize(SqlTypeName typeName, Expression e) {\n       return Expressions.call(\n           BuiltInMethod.TUMBLING.method,\n           inputEnumerable,\n-          EnumUtils.windowSelector(\n+          EnumUtils.tumblingWindowSelector(\n               inputPhysType,\n               outputPhysType,\n               translatedOperands.get(0),\n               translatedOperands.get(1)));\n     }\n   }\n+\n+  /** Implements hopping. */\n+  private static class HopImplementor implements TableFunctionCallImplementor {\n+    @Override public Expression implement(RexToLixTranslator translator,\n+        Expression inputEnumerable, RexCall call, PhysType inputPhysType, PhysType outputPhysType) {\n+      Expression intervalExpression = translator.translate(call.getOperands().get(2));\n+      Expression intervalExpression2 = translator.translate(call.getOperands().get(3));\n+      RexCall descriptor = (RexCall) call.getOperands().get(1);", "originalCommit": "14a165a47cb329720c1cbf649b976573ab1b11b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTEwMjUwNQ==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r411102505", "bodyText": "Done.", "author": "amaliujia", "createdAt": "2020-04-20T05:29:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4ODg3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4OTM3Mw==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r410589373", "bodyText": "What does the TVF mean ? How about just name it HOP_FUN", "author": "danny0405", "createdAt": "2020-04-18T03:29:41Z", "path": "core/src/main/java/org/apache/calcite/sql/fun/SqlStdOperatorTable.java", "diffHunk": "@@ -2296,8 +2298,14 @@ public void unparse(\n   /** DESCRIPTOR(column_name, ...). */\n   public static final SqlOperator DESCRIPTOR = new SqlDescriptorOperator();\n \n-  /** TUMBLE as a table-value function. */\n-  public static final SqlFunction TUMBLE_TVF = new SqlWindowTableFunction(SqlKind.TUMBLE.name());\n+  /** TUMBLE as a table function. */\n+  public static final SqlFunction TUMBLE_TVF = new SqlTumbleTableFunction();\n+\n+  /** HOP as a table function. */\n+  public static final SqlFunction HOP_TVF = new SqlHopTableFunction();\n+\n+  /** SESSION as a table function. */\n+  public static final SqlFunction SESSION_TVF = new SqlSessionTableFunction();\n ", "originalCommit": "14a165a47cb329720c1cbf649b976573ab1b11b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA5MDIyMA==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r411090220", "bodyText": "TVF is the abbrev for \"table-valued function\".  To clarify, \"table-valued function\" is the term used in SQL standard. But seems like people in Calcite community like the short version: table function.\nI can rename it, but it will be better to use, e.g. HOP_TABLE_FUNCTION. What do you think?", "author": "amaliujia", "createdAt": "2020-04-20T04:47:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4OTM3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTEwNDUxOA==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r411104518", "bodyText": "I would prefer to name it directly \"HOP\" and rename the old one to \"_HOP\", after all, we already rename the group window with prefix \"$\".", "author": "danny0405", "createdAt": "2020-04-20T05:35:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4OTM3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYwNDUyNQ==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r411604525", "bodyText": "I am using e.g. \"SESSION_TABLE_FUNCTION\" right now.\nRegarding old one to \"_HOP\" and use \"HOP\" for the new, how about put this rename in a deprecation process? Directly renaming is not backward compatible. I plan to send a discussion email to community to discuss the deprecation of group window functions. We can decide how to rename it based on the discussion (e.g. if people don't want to deprecate group window functions, it probably means that they want keep HOP for hopping by group windowing function).", "author": "amaliujia", "createdAt": "2020-04-20T18:39:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4OTM3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYwNDg3NA==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r411604874", "bodyText": "My personal idea is to fully deprecate group window function. HOP,TUMBLE and SESSION will be reserved for table function windowing only.", "author": "amaliujia", "createdAt": "2020-04-20T18:40:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4OTM3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg1NTY3NA==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r411855674", "bodyText": "Go ahead and send the mail ~", "author": "danny0405", "createdAt": "2020-04-21T04:15:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4OTM3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM0NDUyNw==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r412344527", "bodyText": "After a second thought, I think I will just make the change about \"HOP\" and \"_HOP\" for old and new in this PR, because as you have said, I have already used \"$\" in the name.\nThe email discussion I want is about a bigger discussion on if we should fully deprecate group window function. I will do it later and that discussion is not relevant to this PR.", "author": "amaliujia", "createdAt": "2020-04-21T17:20:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4OTM3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzI5NTc0OA==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r413295748", "bodyText": "There is a naming constraint:\nName '_TUMBLE' must match pattern '^[A-Z][A-Z0-9]*(_[A-Z0-9]+)*$'.\nSo the realistic naming is TUMBLE_. Do you think it is a good idea to rename all group window function operator with \"_\" as suffix?", "author": "amaliujia", "createdAt": "2020-04-22T20:12:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4OTM3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI0MDM1OQ==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r414240359", "bodyText": "I'm fine with that.", "author": "danny0405", "createdAt": "2020-04-24T02:06:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4OTM3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQ1NDI0Mw==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r415454243", "bodyText": "Used , for example, TUMBLE_OLD as the naming for grouped window functions (check style does not allow _ as the last character)", "author": "amaliujia", "createdAt": "2020-04-27T01:37:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4OTM3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4OTU4MA==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r410589580", "bodyText": "Also add tests for SESSION and HOP.", "author": "danny0405", "createdAt": "2020-04-18T03:30:19Z", "path": "core/src/test/java/org/apache/calcite/test/SqlToRelConverterTest.java", "diffHunk": "@@ -1778,15 +1778,16 @@ public final Sql sql(String sql) {\n \n   // In generated plan, the first parameter of TUMBLE function will always be the last field\n   // of it's input. There isn't a way to give the first operand a proper type.\n-  @Test void testTableValuedFunctionTumble() {\n+\n+  @Test public void testTableFunctionTumble() {\n     final String sql = \"select *\\n\"\n         + \"from table(tumble(table Shipments, descriptor(rowtime), INTERVAL '1' MINUTE))\";\n     sql(sql).ok();\n   }\n \n   // In generated plan, the first parameter of TUMBLE function will always be the last field\n   // of it's input. There isn't a way to give the first operand a proper type.\n-  @Test void testTableValuedFunctionTumbleWithSubQueryParam() {\n+  @Test public void testTableFunctionTumbleWithSubQueryParam() {\n     final String sql = \"select *\\n\"\n         + \"from table(tumble((select * from Shipments), descriptor(rowtime), INTERVAL '1' MINUTE))\";", "originalCommit": "14a165a47cb329720c1cbf649b976573ab1b11b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTEwMjQ4Mw==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r411102483", "bodyText": "Done", "author": "amaliujia", "createdAt": "2020-04-20T05:28:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU4OTU4MA=="}], "type": "inlineReview"}, {"oid": "c92f9f544271c0a0cf27f1206d7e1595daefe68f", "url": "https://github.com/apache/calcite/commit/c92f9f544271c0a0cf27f1206d7e1595daefe68f", "message": "[CALCITE-3780] SESSION Table function (Rui Wang)", "committedDate": "2020-04-20T05:32:02Z", "type": "forcePushed"}, {"oid": "2283f49381cfb958a1b36e475887aa1f0198ec28", "url": "https://github.com/apache/calcite/commit/2283f49381cfb958a1b36e475887aa1f0198ec28", "message": "[CALCITE-3780] SESSION Table function (Rui Wang)", "committedDate": "2020-04-20T18:48:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg4NzUwOA==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r411887508", "bodyText": "Why we must have 2 DESCRIPTOR here ?", "author": "danny0405", "createdAt": "2020-04-21T05:48:46Z", "path": "core/src/main/java/org/apache/calcite/sql/SqlSessionTableFunction.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.sql;\n+\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.sql.type.SqlOperandCountRanges;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+import org.apache.calcite.sql.type.SqlTypeUtil;\n+import org.apache.calcite.sql.validate.SqlValidator;\n+\n+/**\n+ * SqlSessionTableFunction implements an operator for per-key sessionization. It allows\n+ * four parameters:\n+ * 1. a table.\n+ * 2. a descriptor to provide a watermarked column name from the input table.\n+ * 3. a descriptor to provide a column as key, on which sessionization will be applied.\n+ * 4. an interval parameter to specify a inactive activity gap to break sessions.\n+ */\n+public class SqlSessionTableFunction extends SqlWindowTableFunction {\n+  public SqlSessionTableFunction() {\n+    super(SqlKind.SESSION.name());\n+  }\n+\n+  @Override public SqlOperandCountRange getOperandCountRange() {\n+    return SqlOperandCountRanges.of(4);\n+  }\n+\n+  @Override public boolean checkOperandTypes(SqlCallBinding callBinding,\n+      boolean throwOnFailure) {\n+    final SqlNode operand0 = callBinding.operand(0);\n+    final SqlValidator validator = callBinding.getValidator();\n+    final RelDataType type = validator.getValidatedNodeType(operand0);\n+    if (type.getSqlTypeName() != SqlTypeName.ROW) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    final SqlNode operand1 = callBinding.operand(1);\n+    if (operand1.getKind() != SqlKind.DESCRIPTOR) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    validateColumnNames(validator, type.getFieldNames(), ((SqlCall) operand1).getOperandList());\n+    final SqlNode operand2 = callBinding.operand(2);\n+    if (operand2.getKind() != SqlKind.DESCRIPTOR) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    validateColumnNames(validator, type.getFieldNames(), ((SqlCall) operand2).getOperandList());\n+    final RelDataType type3 = validator.getValidatedNodeType(callBinding.operand(3));\n+    if (!SqlTypeUtil.isInterval(type3)) {\n+      return throwValidationSignatureErrorOrReturnFalse(callBinding, throwOnFailure);\n+    }\n+    return true;\n+  }\n+\n+  @Override public String getAllowedSignatures(String opNameToUse) {\n+    return getName() + \"(TABLE table_name, DESCRIPTOR(col), \"\n+        + \"DESCRIPTOR(col), datetime interval)\";", "originalCommit": "2283f49381cfb958a1b36e475887aa1f0198ec28", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTkyMDE4OA==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r411920188", "bodyText": "For session, usually common usage is per key. E.g. per user session. That's what the second descriptor used for: offer a session key.\nThe group window function does not have this problem because that style of windowing happens at GROUP BY, where users can put separate GROUP BY key as session key.", "author": "amaliujia", "createdAt": "2020-04-21T06:55:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg4NzUwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTkyODM4OQ==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r411928389", "bodyText": "I mean why couldn't we have one DESCRIPTOR with 2 columns ?", "author": "danny0405", "createdAt": "2020-04-21T07:10:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg4NzUwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM0OTM4OQ==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r412349389", "bodyText": "Because descriptor only provide column names so far. If there is only one descriptor in which there are two column names, it will have a problem to know which one is the timestamp column that apply windowing upon and which one is the session key(note that session could be timestamp type as well). Of course a workaround is to define, say: the first column name is for windowing, and the second column is for session key. But this is error-prone, both from user usage and documentation perspectives: users have to use the right column name on the right position and documentation needs to explain the meaning of each position.\nTwo descriptors is better as each one has its clear semantic and require one column only.\nSo I think it's a good API design than single descriptor.", "author": "amaliujia", "createdAt": "2020-04-21T17:27:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg4NzUwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYwNzY4Mw==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r412607683", "bodyText": "I don't think so, use two descriptors also has such concerns, people would also ask \"which column is timestamp column\"", "author": "danny0405", "createdAt": "2020-04-22T01:44:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg4NzUwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYxNTY0Ng==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r412615646", "bodyText": "It's ok that you don't think that benefit holds. Even if so, then seems to me that there is no difference between one descriptor and two descriptors, in terms of benefits. What do you think?", "author": "amaliujia", "createdAt": "2020-04-22T02:07:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg4NzUwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI0MDk4Mg==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r414240982", "bodyText": "The descriptor keyword itself is too verbose, why we must have that ? Couldn't we just put a column name there directly ?", "author": "danny0405", "createdAt": "2020-04-24T02:09:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg4NzUwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM1MDY2OA==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r414350668", "bodyText": "In fact, DESCRIPTOR is a part of  SQL standard 2016: Polymorphic table functions (https://issues.apache.org/jira/browse/CALCITE-2270). DESCRIPTOR is designed to specify columns explicitly in table functions. That was one of the purpose  it was created for.\nYou can find a free copy of SQL standard 2016:  Polymorphic table functions in this link: https://modern-sql.com/standard", "author": "amaliujia", "createdAt": "2020-04-24T07:17:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg4NzUwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM5MzI1NQ==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r414393255", "bodyText": "Thanks for the explanations, personally i think one DESCRIPTOR is more concise, i'm wondering what other people think ?", "author": "danny0405", "createdAt": "2020-04-24T08:29:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg4NzUwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE4NTQ4OQ==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r415185489", "bodyText": "Can the session key be multiple keys ?", "author": "danny0405", "createdAt": "2020-04-26T01:32:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg4NzUwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQ0OTY3Nw==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r415449677", "bodyText": "This is a good point. In my implementation, it is single key only (cause that is the typical usage). But compound key is feasible and valid use case.\nIf there is a need to support compound key, then I think two descriptors will be better.", "author": "amaliujia", "createdAt": "2020-04-27T01:19:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg4NzUwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQ1MTc3MQ==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r415451771", "bodyText": "Yes, two descriptor is more feasible to support multiple session keys, we better add a test in  SqlToRelConverterTest to support multiple session keys.", "author": "danny0405", "createdAt": "2020-04-27T01:27:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg4NzUwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQ2MDA3NA==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r415460074", "bodyText": "Added a testTableFunctionSessionCompoundSessionKey in SqlToRelConverterTest for verifying that generated plan is correct when there are multiple session key.", "author": "amaliujia", "createdAt": "2020-04-27T01:59:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg4NzUwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY2MzM5OQ==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r417663399", "bodyText": "Another reason why we use descriptor than just a column name: https://issues.apache.org/jira/browse/CALCITE-3964\nBasically there is a missing feature of DESCRIPTOR: an optional data type, which can be used to do type validation. It's useful for event timestamp windowing because such windowing should be apply on TIMESTAMP column. DESCRIPTOR will be handy to validate if user query applies windowing on a right column.", "author": "amaliujia", "createdAt": "2020-04-29T23:06:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg4NzUwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzcyMzIwOQ==", "url": "https://github.com/apache/calcite/pull/1761#discussion_r417723209", "bodyText": "From the paper, the DESCRIPTOR only appears in the function definition, that is, it is in the DDL, here we are not creating a function, but use it directly, i'm not sure if we should use the descriptor, as for the first argument, i would fix it as a cursor.", "author": "danny0405", "createdAt": "2020-04-30T02:42:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg4NzUwOA=="}], "type": "inlineReview"}, {"oid": "3ed7e66db2a3b5519c98ca8f8f45d21e502144e8", "url": "https://github.com/apache/calcite/commit/3ed7e66db2a3b5519c98ca8f8f45d21e502144e8", "message": "[CALCITE-3780] SESSION Table function (Rui Wang)", "committedDate": "2020-04-22T20:14:15Z", "type": "forcePushed"}, {"oid": "aba2e4fded2e3164b012b25f7e272945ace25b41", "url": "https://github.com/apache/calcite/commit/aba2e4fded2e3164b012b25f7e272945ace25b41", "message": "[CALCITE-3780] SESSION Table function (Rui Wang)", "committedDate": "2020-04-27T01:45:43Z", "type": "forcePushed"}, {"oid": "ea320ed3bf1ddc59d1dbd5473b6f9812d3734098", "url": "https://github.com/apache/calcite/commit/ea320ed3bf1ddc59d1dbd5473b6f9812d3734098", "message": "[CALCITE-3737] HOP Table Function (Rui Wang)", "committedDate": "2020-04-27T01:59:41Z", "type": "commit"}, {"oid": "cf089edf925b13db01bf08c5c928e1727928f676", "url": "https://github.com/apache/calcite/commit/cf089edf925b13db01bf08c5c928e1727928f676", "message": "[CALCITE-3780] SESSION Table function (Rui Wang)", "committedDate": "2020-04-27T01:59:42Z", "type": "commit"}, {"oid": "cf089edf925b13db01bf08c5c928e1727928f676", "url": "https://github.com/apache/calcite/commit/cf089edf925b13db01bf08c5c928e1727928f676", "message": "[CALCITE-3780] SESSION Table function (Rui Wang)", "committedDate": "2020-04-27T01:59:42Z", "type": "forcePushed"}]}