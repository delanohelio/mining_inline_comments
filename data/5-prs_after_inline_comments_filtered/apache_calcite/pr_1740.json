{"pr_number": 1740, "pr_title": "[CALCITE-3713] Remove column names from Project#digest", "pr_createdAt": "2020-01-09T17:20:48Z", "pr_url": "https://github.com/apache/calcite/pull/1740", "timeline": [{"oid": "43e583e8a04c65342afbf3abacec44ff40caba30", "url": "https://github.com/apache/calcite/commit/43e583e8a04c65342afbf3abacec44ff40caba30", "message": "[CALCITE-3713] Remove column names from Project#digest\n\nProjects that differ with column names only are equivalent,\nso the planning space can be reduced if field names\ndo not participate in relation matching.\n\nFor instance, Project(input=rel#1,empid=$0) and\nProject(input=rel#1,deptno=$0) are equivalent", "committedDate": "2020-01-09T18:47:11Z", "type": "forcePushed"}, {"oid": "df79468c2e30285b0c7c83223cedb8d25969cf9f", "url": "https://github.com/apache/calcite/commit/df79468c2e30285b0c7c83223cedb8d25969cf9f", "message": "Refine ColumnUniqueness for Subset(input=Sort)\n\nIt fixes StackOverflowError in FoodmartTest.test query id=5871\nThe optimizer generated dummy Project(Aggregate(Sort(Project(Aggregate(Sort(...\nchains, and it was not able to see that extra aggregation adds nothing.\n\nNow it figures out that columns already are unique, so it sees\nthat an extra Aggregate adds nothing.", "committedDate": "2020-01-09T21:56:47Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTA2OTMyNA==", "url": "https://github.com/apache/calcite/pull/1740#discussion_r365069324", "bodyText": "I'm confused with the code snippet\n        && (kind == kind.reverse()\n        || !op.getName().equals(kind.sql)\n        || sb.length() < 2 || sb.charAt(sb.length() - 1) != '(')", "author": "danny0405", "createdAt": "2020-01-10T04:33:54Z", "path": "core/src/main/java/org/apache/calcite/rex/RexCall.java", "diffHunk": "@@ -127,11 +137,83 @@ protected final StringBuilder appendOperands(StringBuilder sb) {\n           includeType = RexDigestIncludeType.NO_TYPE;\n         }\n       }\n-      sb.append(((RexLiteral) operand).computeDigest(includeType));\n+      operandDigests.add(((RexLiteral) operand).computeDigest(includeType));\n+    }\n+    int totalLength = (operandDigests.size() - 1) * 2; // commas\n+    for (String s : operandDigests) {\n+      totalLength += s.length();\n+    }\n+    sb.ensureCapacity(sb.length() + totalLength);\n+    sortOperandsIfNeeded(sb, operands, operandDigests);\n+    for (int i = 0; i < operandDigests.size(); i++) {\n+      String op = operandDigests.get(i);\n+      if (i != 0) {\n+        sb.append(\", \");\n+      }\n+      sb.append(op);\n     }\n     return sb;\n   }\n \n+  private void sortOperandsIfNeeded(StringBuilder sb,\n+      List<RexNode> operands, List<String> operandDigests) {\n+    if (operands.isEmpty() || !needNormalize()) {\n+      return;\n+    }\n+    final SqlKind kind = op.getKind();\n+    if (SqlKind.SYMMETRICAL_SAME_ARG_TYPE.contains(kind)) {\n+      final RelDataType firstType = operands.get(0).getType();\n+      for (int i = 1; i < operands.size(); i++) {\n+        if (!equalSansNullability(firstType, operands.get(i).getType())) {\n+          // Arguments have different type, thus they must not be sorted\n+          return;\n+        }\n+      }\n+      // fall through: order arguments below\n+    } else if (!SqlKind.SYMMETRICAL.contains(kind)\n+        && (kind == kind.reverse()\n+        || !op.getName().equals(kind.sql)\n+        || sb.length() < 2 || sb.charAt(sb.length() - 1) != '(')) {\n+      // The operations have to be either symmetrical or reversible", "originalCommit": "df79468c2e30285b0c7c83223cedb8d25969cf9f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTA3MDA2MQ==", "url": "https://github.com/apache/calcite/pull/1740#discussion_r365070061", "bodyText": "We can make a sort if:\n\nThere is no decimals in the PLUS\nThere is no INTERVALs in TIMES", "author": "danny0405", "createdAt": "2020-01-10T04:39:21Z", "path": "core/src/main/java/org/apache/calcite/rex/RexCall.java", "diffHunk": "@@ -127,11 +137,83 @@ protected final StringBuilder appendOperands(StringBuilder sb) {\n           includeType = RexDigestIncludeType.NO_TYPE;\n         }\n       }\n-      sb.append(((RexLiteral) operand).computeDigest(includeType));\n+      operandDigests.add(((RexLiteral) operand).computeDigest(includeType));\n+    }\n+    int totalLength = (operandDigests.size() - 1) * 2; // commas\n+    for (String s : operandDigests) {\n+      totalLength += s.length();\n+    }\n+    sb.ensureCapacity(sb.length() + totalLength);\n+    sortOperandsIfNeeded(sb, operands, operandDigests);\n+    for (int i = 0; i < operandDigests.size(); i++) {\n+      String op = operandDigests.get(i);\n+      if (i != 0) {\n+        sb.append(\", \");\n+      }\n+      sb.append(op);\n     }\n     return sb;\n   }\n \n+  private void sortOperandsIfNeeded(StringBuilder sb,\n+      List<RexNode> operands, List<String> operandDigests) {\n+    if (operands.isEmpty() || !needNormalize()) {\n+      return;\n+    }\n+    final SqlKind kind = op.getKind();\n+    if (SqlKind.SYMMETRICAL_SAME_ARG_TYPE.contains(kind)) {\n+      final RelDataType firstType = operands.get(0).getType();\n+      for (int i = 1; i < operands.size(); i++) {\n+        if (!equalSansNullability(firstType, operands.get(i).getType())) {\n+          // Arguments have different type, thus they must not be sorted", "originalCommit": "df79468c2e30285b0c7c83223cedb8d25969cf9f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTA5MTk1Mg==", "url": "https://github.com/apache/calcite/pull/1740#discussion_r365091952", "bodyText": "Why drop decimals?\nWhy drop INTERVAL?", "author": "vlsi", "createdAt": "2020-01-10T06:45:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTA3MDA2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTA5Mzg5Nw==", "url": "https://github.com/apache/calcite/pull/1740#discussion_r365093897", "bodyText": "Because of the return type inference, see RetirnTypes.NULLABLE_SUM and ReturnTypes.PRODUCT_NULLABLE.", "author": "danny0405", "createdAt": "2020-01-10T06:54:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTA3MDA2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTA5NTgzNw==", "url": "https://github.com/apache/calcite/pull/1740#discussion_r365095837", "bodyText": "I do not follow you.\nI ensure the operands have to be of the same type, so I don't see why we should reject reordering in DECIMAL(5,0) + DECIMAL(5,0).", "author": "vlsi", "createdAt": "2020-01-10T07:03:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTA3MDA2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTEwODc4MA==", "url": "https://github.com/apache/calcite/pull/1740#discussion_r365108780", "bodyText": "Oh, you mis-understood what i mean, i means to support more reordering for PLUS and TIMES even their operands types are different. For example, DECIMAL(3,0) + DECIMAL(5,0) can also be reordered.", "author": "danny0405", "createdAt": "2020-01-10T07:56:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTA3MDA2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTExNTc0MQ==", "url": "https://github.com/apache/calcite/pull/1740#discussion_r365115741", "bodyText": "Do we want to support strict floating-point non-associativity here?\nTechnically speaking, PLUS for FLOATs is not associative :(\nhttps://stackoverflow.com/a/10371890/1261287\n\ni means to support more reordering for PLUS and TIMES even their operands types are differen\n\nI wanted the first iteration to be as simple as it could be.\nProper cost estimates are more interesting for me than spending time on DECIMAL(3,0) + DECIMAL(5,0) normalization.\nReordering of DECIMAL(3,0) + DECIMAL(5,0) might be tricky, especially if it is nested: DECIMAL(3,0) + DECIMAL(3,0) + DECIMAL(5,0) might probably return different result than DECIMAL(5,0) + DECIMAL(3,0) + DECIMAL(3,0), so I don't want to spend time on exploring those scenarios as they are quite rare for me.", "author": "vlsi", "createdAt": "2020-01-10T08:20:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTA3MDA2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTExNjgyMw==", "url": "https://github.com/apache/calcite/pull/1740#discussion_r365116823", "bodyText": "I agree for the first iteration, we can keep it as simple as possible.\nWhy do you think PLUS for different data types are rare cases, i believe there would be many cases in production ~", "author": "danny0405", "createdAt": "2020-01-10T08:24:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTA3MDA2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTExODM0Ng==", "url": "https://github.com/apache/calcite/pull/1740#discussion_r365118346", "bodyText": "I've no idea. We could probably add a logger or counter to so it would count the number of times the normalization was skipped for + / *.\nIf you have production-like queries/test-cases, it would be nice if you could add them.\nHowever, I still think refining cost estimates and uniqueness metadata (see #1702 ) has better benefits than enhanced + * normalization.", "author": "vlsi", "createdAt": "2020-01-10T08:29:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTA3MDA2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTMxNjcxNw==", "url": "https://github.com/apache/calcite/pull/1740#discussion_r365316717", "bodyText": "In production the types will be the same: https://twitter.com/pysailor_de/status/1213126545642065920 :)", "author": "vlsi", "createdAt": "2020-01-10T16:23:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTA3MDA2MQ=="}], "type": "inlineReview"}, {"oid": "1e9b4da0573ec73d332d4e65fb7fd30491b4318d", "url": "https://github.com/apache/calcite/commit/1e9b4da0573ec73d332d4e65fb7fd30491b4318d", "message": "[CALCITE-3713] Remove column names from Project#digest\n\nProjects that differ with column names only are equivalent,\nso the planning space can be reduced if field names\ndo not participate in relation matching.\n\nFor instance, Project(input=rel#1,empid=$0) and\nProject(input=rel#1,deptno=$0) are equivalent", "committedDate": "2020-01-10T06:59:49Z", "type": "commit"}, {"oid": "4bfc291326ad08ba4203d8e1bb43f2db1ad90b1a", "url": "https://github.com/apache/calcite/commit/4bfc291326ad08ba4203d8e1bb43f2db1ad90b1a", "message": "Refine ColumnUniqueness for Subset(input=Sort)\n\nIt fixes StackOverflowError in FoodmartTest.test query id=5871\nThe optimizer generated dummy Project(Aggregate(Sort(Project(Aggregate(Sort(...\nchains, and it was not able to see that extra aggregation adds nothing.\n\nNow it figures out that columns already are unique, so it sees\nthat an extra Aggregate adds nothing.", "committedDate": "2020-01-10T06:59:49Z", "type": "forcePushed"}, {"oid": "3092159056280ab1f3c284394ed99ae8211b3f6d", "url": "https://github.com/apache/calcite/commit/3092159056280ab1f3c284394ed99ae8211b3f6d", "message": "Refine ColumnUniqueness for Subset(input=Sort)\n\nIt fixes StackOverflowError in FoodmartTest.test query id=5871\nThe optimizer generated dummy Project(Aggregate(Sort(Project(Aggregate(Sort(...\nchains, and it was not able to see that extra aggregation adds nothing.\n\nNow it figures out that columns already are unique, so it sees\nthat an extra Aggregate adds nothing.", "committedDate": "2020-01-10T08:23:13Z", "type": "commit"}, {"oid": "3092159056280ab1f3c284394ed99ae8211b3f6d", "url": "https://github.com/apache/calcite/commit/3092159056280ab1f3c284394ed99ae8211b3f6d", "message": "Refine ColumnUniqueness for Subset(input=Sort)\n\nIt fixes StackOverflowError in FoodmartTest.test query id=5871\nThe optimizer generated dummy Project(Aggregate(Sort(Project(Aggregate(Sort(...\nchains, and it was not able to see that extra aggregation adds nothing.\n\nNow it figures out that columns already are unique, so it sees\nthat an extra Aggregate adds nothing.", "committedDate": "2020-01-10T08:23:13Z", "type": "forcePushed"}]}