{"pr_number": 1862, "pr_title": "[CALCITE-3864] Supports CONCAT for variable arguments", "pr_createdAt": "2020-03-19T13:57:16Z", "pr_url": "https://github.com/apache/calcite/pull/1862", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU5ODExMQ==", "url": "https://github.com/apache/calcite/pull/1862#discussion_r396598111", "bodyText": "I noticed that the number of function parameters in different databases is different:\nMysql\nCONCAT(string1,string2, ... );\n\nOracle\nCONCAT(char1, char2)\n\nPostgreSql\nCONCAT(str_1, str_2, ...)", "author": "XuQianJin-Stars", "createdAt": "2020-03-23T16:47:24Z", "path": "core/src/main/java/org/apache/calcite/runtime/SqlFunctions.java", "diffHunk": "@@ -460,6 +460,15 @@ public static ByteString concat(ByteString s0, ByteString s1) {\n     return s0.concat(s1);\n   }\n \n+  /** SQL function CONCAT(arg, ...)*/", "originalCommit": "8f0a0031e67f5261a38665660a250a122cb92eb7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzAzMzYwMw==", "url": "https://github.com/apache/calcite/pull/1862#discussion_r397033603", "bodyText": "I noticed this problem too, and I found that creating two SqlFunction for CONCAT is redundant and unnecessary, what's more, it maybe cause exception when look up method.\nI have updated this pull request, concat function is equivalent to || operator.", "author": "wenhuitang", "createdAt": "2020-03-24T10:04:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU5ODExMQ=="}], "type": "inlineReview"}, {"oid": "689780e87195e6db10f83f22411fe30e36b96443", "url": "https://github.com/apache/calcite/commit/689780e87195e6db10f83f22411fe30e36b96443", "message": "[CALCITE-3864] Add Implementation for SqlLibraryOperators.CONCAT_FUNCTION in SqlFunctions and correct the return type inference of SqlLibraryOperators.CONCAT_FUNCTION (Wenhui Tang)", "committedDate": "2020-03-24T09:52:02Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzAzOTk0MA==", "url": "https://github.com/apache/calcite/pull/1862#discussion_r397039940", "bodyText": "oracle CONCAT (char1, char2) only accept how to reflect two parameters?", "author": "XuQianJin-Stars", "createdAt": "2020-03-24T10:15:15Z", "path": "core/src/test/java/org/apache/calcite/sql/test/SqlOperatorBaseTest.java", "diffHunk": "@@ -2169,6 +2170,21 @@ protected static Calendar getCalendarNotTooNear(int timeUnit) {\n         \"VARCHAR(33335) NOT NULL\");\n     tester.checkNull(\"x'ff' || cast(null as varbinary)\");\n     tester.checkNull(\" cast(null as ANY) || cast(null as ANY) \");\n+    tester.checkString(\"cast('a' as varchar) || cast('b' as varchar) \"\n+        + \"|| cast('c' as varchar)\", \"abc\", \"VARCHAR NOT NULL\");\n+\n+    final SqlTester tester1 = tester(SqlLibrary.MYSQL);\n+    final SqlTester tester2 = tester(SqlLibrary.POSTGRESQL);\n+    final SqlTester tester3 = tester(SqlLibrary.ORACLE);", "originalCommit": "689780e87195e6db10f83f22411fe30e36b96443", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA1NjEzMg==", "url": "https://github.com/apache/calcite/pull/1862#discussion_r397056132", "bodyText": "I don't think that it is a serious problem since concat function will be translated to || operator and it can work well for oracle and also support concat('a', 'b'). In a practical application scenario, we may use two SqlLibaray at a same time, if they have different concat function, ambiguity will be caused when check arguements, even we register oracle concat as a alias of SqlStdOperatorTable.CONCAT.", "author": "wenhuitang", "createdAt": "2020-03-24T10:42:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzAzOTk0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzA2MjM0OA==", "url": "https://github.com/apache/calcite/pull/1862#discussion_r397062348", "bodyText": "I don't think that it is a serious problem since concat function will be translated to || operator and it can work well for oracle and also support concat('a', 'b'). In a practical application scenario, we may use two SqlLibaray at a same time, if they have different concat function, ambiguity will be caused when check arguements, even we register oracle concat as a alias of SqlStdOperatorTable.CONCAT.\n\nI did not say that this is a serious problem, but I noticed that oracle's concat is a special case of your concat implementation. Because oracle concat only supports two parameters.", "author": "XuQianJin-Stars", "createdAt": "2020-03-24T10:53:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzAzOTk0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzExMzAyOA==", "url": "https://github.com/apache/calcite/pull/1862#discussion_r397113028", "bodyText": "Please move this piece of code before switch-case block, you can refer to the style in OracleSqlDialect.", "author": "DonnyZone", "createdAt": "2020-03-24T12:26:00Z", "path": "core/src/main/java/org/apache/calcite/sql/dialect/MysqlSqlDialect.java", "diffHunk": "@@ -208,12 +212,52 @@ public boolean supportsAliasedValues() {\n \n       unparseFloor(writer, call);\n       break;\n-\n     default:\n+      if (call.getOperator() == SqlStdOperatorTable.CONCAT) {", "originalCommit": "689780e87195e6db10f83f22411fe30e36b96443", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzExMzU4NQ==", "url": "https://github.com/apache/calcite/pull/1862#discussion_r397113585", "bodyText": "Can we add some doc here?", "author": "DonnyZone", "createdAt": "2020-03-24T12:27:04Z", "path": "core/src/main/java/org/apache/calcite/sql/fun/SqlLibraryOperators.java", "diffHunk": "@@ -286,8 +286,13 @@ private SqlLibraryOperators() {\n               opBinding -> {\n                 int precision = opBinding.collectOperandTypes().stream()\n                     .mapToInt(RelDataType::getPrecision).sum();\n-                return opBinding.getTypeFactory()\n-                    .createSqlType(SqlTypeName.VARCHAR, precision);\n+                if (precision > 0) {", "originalCommit": "689780e87195e6db10f83f22411fe30e36b96443", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzE1OTI0NA==", "url": "https://github.com/apache/calcite/pull/1862#discussion_r397159244", "bodyText": "Thanks a lot, I have already addressed. And make a little change of code.", "author": "wenhuitang", "createdAt": "2020-03-24T13:40:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzExMzU4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEyNDkxNg==", "url": "https://github.com/apache/calcite/pull/1862#discussion_r397124916", "bodyText": "Why do we need to expand operands? operand.unparse can recursively handle nested case in nature.", "author": "DonnyZone", "createdAt": "2020-03-24T12:47:02Z", "path": "core/src/main/java/org/apache/calcite/sql/dialect/MysqlSqlDialect.java", "diffHunk": "@@ -208,12 +212,52 @@ public boolean supportsAliasedValues() {\n \n       unparseFloor(writer, call);\n       break;\n-\n     default:\n+      if (call.getOperator() == SqlStdOperatorTable.CONCAT) {\n+        unparseConcat(writer, call);\n+        break;\n+      }\n       super.unparseCall(writer, call, leftPrec, rightPrec);\n     }\n   }\n \n+  /**\n+   * Unparses String concatenation operator for Mysql, Mysql uses Concat as string concatenation\n+   * operator when PIPES_AS_CONCAT is not enabled. CONCAT concatenation characters are used by\n+   * default.\n+   *\n+   * @param writer writer\n+   * @param call call\n+   */\n+  private void unparseConcat(SqlWriter writer, SqlCall call) {\n+    List<SqlNode> expandOperandList = new ArrayList<>();\n+    expandConcatOperands(call, expandOperandList);", "originalCommit": "689780e87195e6db10f83f22411fe30e36b96443", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzE2MTQ4MQ==", "url": "https://github.com/apache/calcite/pull/1862#discussion_r397161481", "bodyText": "Why do we need to expand operands? operand.unparse can recursively handle nested case in nature.\n\nExpand operands for CONCAT, so we can generate CONCAT(fname, '', '', lname) instead of CONCAT(CONCAT(CONCAT(fname, ''), ''), lname)", "author": "wenhuitang", "createdAt": "2020-03-24T13:43:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEyNDkxNg=="}], "type": "inlineReview"}, {"oid": "517d0d53105fdd594d112d1f493b4a246db4ffe4", "url": "https://github.com/apache/calcite/commit/517d0d53105fdd594d112d1f493b4a246db4ffe4", "message": "[CALCITE-3864] Add Implementation for SqlLibraryOperators.CONCAT_FUNCTION in SqlFunctions and correct the return type inference of SqlLibraryOperators.CONCAT_FUNCTION (Wenhui Tang)", "committedDate": "2020-03-24T13:39:37Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzU5NDE5Nw==", "url": "https://github.com/apache/calcite/pull/1862#discussion_r397594197", "bodyText": "In concat(x, y, z), if the precision of x, y, z are specified (i.e., precision != PRECISION_NOT_SPECIFIED), the return type is the sum of them. However, if one operand's precision is PRECISION_NOT_SPECIFIED, the return type should also be PRECISION_NOT_SPECIFIED.\nE.g., for concat('aaa', cast('bb' as varchar), 'ccc'), operand's precisions are: [3, -1, 3]. The return type's precision (3-1+3=5) is not resonable.", "author": "DonnyZone", "createdAt": "2020-03-25T03:46:20Z", "path": "core/src/main/java/org/apache/calcite/sql/fun/SqlLibraryOperators.java", "diffHunk": "@@ -286,6 +286,9 @@ private SqlLibraryOperators() {\n               opBinding -> {\n                 int precision = opBinding.collectOperandTypes().stream()\n                     .mapToInt(RelDataType::getPrecision).sum();\n+                // precision may be smaller than -1 when operands' precision are not be specified,\n+                // which is not allowed.\n+                precision = Math.max(precision, -1);", "originalCommit": "517d0d53105fdd594d112d1f493b4a246db4ffe4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "703357f0542b02ed75b75eca6c86c9c00d8f36b7", "url": "https://github.com/apache/calcite/commit/703357f0542b02ed75b75eca6c86c9c00d8f36b7", "message": "[CALCITE-3864] Add Implementation for SqlLibraryOperators.CONCAT_FUNCTION in SqlFunctions and correct the return type inference of SqlLibraryOperators.CONCAT_FUNCTION (Wenhui Tang)", "committedDate": "2020-03-25T09:18:53Z", "type": "forcePushed"}, {"oid": "2cf7349335c2574d281dc91cf09ed5d439ba9858", "url": "https://github.com/apache/calcite/commit/2cf7349335c2574d281dc91cf09ed5d439ba9858", "message": "[CALCITE-3864] Add Implementation for SqlLibraryOperators.CONCAT_FUNCTION in SqlFunctions and correct the return type inference of SqlLibraryOperators.CONCAT_FUNCTION (Wenhui Tang)", "committedDate": "2020-03-25T09:21:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzcxMTc1NA==", "url": "https://github.com/apache/calcite/pull/1862#discussion_r397711754", "bodyText": "You can use String.join(\"\", args).", "author": "DonnyZone", "createdAt": "2020-03-25T09:27:04Z", "path": "core/src/main/java/org/apache/calcite/runtime/SqlFunctions.java", "diffHunk": "@@ -460,6 +460,14 @@ public static ByteString concat(ByteString s0, ByteString s1) {\n     return s0.concat(s1);\n   }\n \n+  /** SQL {@code concat(string0, string2, string3, ...)} function. */\n+  public static String concat(String... args) {\n+    List<String> argList = Arrays.asList(args);", "originalCommit": "2cf7349335c2574d281dc91cf09ed5d439ba9858", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzcxMzIxMw==", "url": "https://github.com/apache/calcite/pull/1862#discussion_r397713213", "bodyText": "Maybe there is no need to register CONCAT2 into RexImpTable. In runtime, Calcite can automatically find the concat function. You can have a try.", "author": "DonnyZone", "createdAt": "2020-03-25T09:29:16Z", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/RexImpTable.java", "diffHunk": "@@ -332,6 +334,8 @@\n         NullPolicy.STRICT);\n     defineMethod(CONCAT, BuiltInMethod.STRING_CONCAT.method,\n         NullPolicy.STRICT);\n+    defineMethod(CONCAT2, BuiltInMethod.STRING_CONCAT.method, NullPolicy.STRICT);", "originalCommit": "2cf7349335c2574d281dc91cf09ed5d439ba9858", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzgwMTk1MA==", "url": "https://github.com/apache/calcite/pull/1862#discussion_r397801950", "bodyText": "Still keep defineMethod for CONCAT2 for looking up method clearly.", "author": "wenhuitang", "createdAt": "2020-03-25T12:02:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzcxMzIxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzcxNDc2Mw==", "url": "https://github.com/apache/calcite/pull/1862#discussion_r397714763", "bodyText": "To align with args, \"arg0, arg1...\" is better than \"string0, ..\" in doc.", "author": "DonnyZone", "createdAt": "2020-03-25T09:31:36Z", "path": "core/src/main/java/org/apache/calcite/runtime/SqlFunctions.java", "diffHunk": "@@ -460,6 +460,14 @@ public static ByteString concat(ByteString s0, ByteString s1) {\n     return s0.concat(s1);\n   }\n \n+  /** SQL {@code concat(string0, string2, string3, ...)} function. */", "originalCommit": "2cf7349335c2574d281dc91cf09ed5d439ba9858", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzc0MTQzMQ==", "url": "https://github.com/apache/calcite/pull/1862#discussion_r397741431", "bodyText": "You can directly break the iteration when: 1) encountering PRECISION_NOT_SPECIFIED, 2) amount large than max precision.", "author": "DonnyZone", "createdAt": "2020-03-25T10:14:53Z", "path": "core/src/main/java/org/apache/calcite/sql/type/ReturnTypes.java", "diffHunk": "@@ -655,6 +655,54 @@ public int size() {\n         return ret;\n       };\n \n+\n+  /**\n+   * Type-inference strategy for String concatenation.\n+   * For example,\n+   *\n+   * concat(cast('a' as varchar(2)), cast('b' as varchar(3)),cast('c' as varchar(2)))\n+   * returns varchar(7),\n+   *\n+   * concat(cast('a' as varchar), cast('b' as varchar(2), cast('c' as varchar(2))))\n+   * returns varchar,\n+   *\n+   * concat(cast('a' as varchar(65535)), cast('b' as varchar(2)), cast('c' as varchar(2)))\n+   * returns varchar\n+   */\n+  public static final SqlReturnTypeInference MULTIVALENT_STRING_SUM_PRECISION =\n+      opBinding -> {\n+        boolean hasPrecisionNotSpecifiedOperand = false;\n+        int typePrecision;\n+        long amount = 0;\n+        List<RelDataType> operandTypes = opBinding.collectOperandTypes();\n+        for (RelDataType operandType: operandTypes) {", "originalCommit": "2cf7349335c2574d281dc91cf09ed5d439ba9858", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzc0ODcxNQ==", "url": "https://github.com/apache/calcite/pull/1862#discussion_r397748715", "bodyText": "Improve the comment, you can refer to DYADIC_STRING_SUM_PRECISION for \"||\" operator.", "author": "DonnyZone", "createdAt": "2020-03-25T10:26:51Z", "path": "core/src/main/java/org/apache/calcite/sql/type/ReturnTypes.java", "diffHunk": "@@ -655,6 +655,54 @@ public int size() {\n         return ret;\n       };\n \n+\n+  /**\n+   * Type-inference strategy for String concatenation.", "originalCommit": "2cf7349335c2574d281dc91cf09ed5d439ba9858", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d0d787bdb09cb2605093a5e36c36967bf6a00cb5", "url": "https://github.com/apache/calcite/commit/d0d787bdb09cb2605093a5e36c36967bf6a00cb5", "message": "[CALCITE-3684] Implement Concat function.(Wenhui Tang)", "committedDate": "2020-03-25T11:56:20Z", "type": "forcePushed"}, {"oid": "782123bc8409ed82c7f2842925a48b26ab8aca03", "url": "https://github.com/apache/calcite/commit/782123bc8409ed82c7f2842925a48b26ab8aca03", "message": "[CALCITE-3684] Implement Concat function.(Wenhui Tang)", "committedDate": "2020-03-25T13:04:17Z", "type": "forcePushed"}, {"oid": "7152d72d11d22f53d921a1a0130ef052651e1aef", "url": "https://github.com/apache/calcite/commit/7152d72d11d22f53d921a1a0130ef052651e1aef", "message": "[CALCITE-3684] Implement Concat function (Wenhui Tang)", "committedDate": "2020-03-26T02:43:18Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTAxNDI3OQ==", "url": "https://github.com/apache/calcite/pull/1862#discussion_r399014279", "bodyText": "Please add a test case whose parameter is empty.", "author": "chunweilei", "createdAt": "2020-03-27T03:22:43Z", "path": "core/src/test/java/org/apache/calcite/sql/test/SqlOperatorBaseTest.java", "diffHunk": "@@ -2169,6 +2173,31 @@ protected static Calendar getCalendarNotTooNear(int timeUnit) {\n         \"VARCHAR(33335) NOT NULL\");\n     tester.checkNull(\"x'ff' || cast(null as varbinary)\");\n     tester.checkNull(\" cast(null as ANY) || cast(null as ANY) \");\n+    tester.checkString(\"cast('a' as varchar) || cast('b' as varchar) \"\n+        + \"|| cast('c' as varchar)\", \"abc\", \"VARCHAR NOT NULL\");\n+\n+    final SqlTester tester1 = tester(SqlLibrary.MYSQL);\n+    final SqlTester tester2 = tester(SqlLibrary.POSTGRESQL);\n+    final SqlTester tester3 = tester(SqlLibrary.ORACLE);\n+    for (SqlTester sqlTester: ImmutableList.of(tester1, tester2)) {\n+      sqlTester.setFor(SqlLibraryOperators.CONCAT_FUNCTION);\n+      sqlTester.checkString(\"concat('a', 'b', 'c')\", \"abc\",\n+          \"VARCHAR(3) NOT NULL\");\n+      sqlTester.checkString(\"concat(cast('a' as varchar), cast('b' as varchar), \"\n+          + \"cast('c' as varchar))\", \"abc\", \"VARCHAR NOT NULL\");\n+      sqlTester.checkNull(\"concat('a', 'b', cast(null as char(2)))\");\n+      sqlTester.checkNull(\"concat(cast(null as ANY), 'b', cast(null as char(2)))\");\n+    }\n+    tester3.setFor(SqlLibraryOperators.CONCAT2);\n+    tester3.checkString(\"concat(cast('fe' as char(2)), cast('df' as varchar(65535)))\",\n+        \"fedf\", \"VARCHAR NOT NULL\");\n+    tester3.checkString(\"concat(cast('fe' as char(2)), cast('df' as varchar))\",", "originalCommit": "7152d72d11d22f53d921a1a0130ef052651e1aef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODYwMjA1NQ==", "url": "https://github.com/apache/calcite/pull/1862#discussion_r398602055", "bodyText": "End up the comment with dot.", "author": "danny0405", "createdAt": "2020-03-26T14:10:24Z", "path": "core/src/main/java/org/apache/calcite/sql/type/ReturnTypes.java", "diffHunk": "@@ -655,6 +655,59 @@ public int size() {\n         return ret;\n       };\n \n+\n+  /**\n+   * Type-inference strategy for String concatenation.\n+   * Result is varying if either input is; otherwise fixed.\n+   * For example,\n+   *\n+   * concat(cast('a' as varchar(2)), cast('b' as varchar(3)),cast('c' as varchar(2)))\n+   * returns varchar(7),\n+   *\n+   * concat(cast('a' as varchar), cast('b' as varchar(2), cast('c' as varchar(2))))\n+   * returns varchar,\n+   *\n+   * concat(cast('a' as varchar(65535)), cast('b' as varchar(2)), cast('c' as varchar(2)))\n+   * returns varchar\n+   */\n+  public static final SqlReturnTypeInference MULTIVALENT_STRING_SUM_PRECISION =\n+      opBinding -> {\n+        boolean hasPrecisionNotSpecifiedOperand = false;\n+        boolean precisionOverflow = false;\n+        int typePrecision;\n+        long amount = 0;\n+        List<RelDataType> operandTypes = opBinding.collectOperandTypes();\n+        final RelDataTypeFactory typeFactory = opBinding.getTypeFactory();\n+        final RelDataTypeSystem typeSystem = typeFactory.getTypeSystem();\n+        for (RelDataType operandType: operandTypes) {\n+          int operandPrecision = operandType.getPrecision();\n+          amount = (long) operandPrecision + amount;\n+          if (operandPrecision == RelDataType.PRECISION_NOT_SPECIFIED) {\n+            hasPrecisionNotSpecifiedOperand = true;\n+            break;\n+          }\n+          if (amount > typeSystem.getMaxPrecision(SqlTypeName.VARCHAR)) {\n+            precisionOverflow = true;\n+            break;\n+          }\n+        }\n+        if (hasPrecisionNotSpecifiedOperand || precisionOverflow) {\n+          typePrecision = RelDataType.PRECISION_NOT_SPECIFIED;\n+        } else {\n+          typePrecision = (int) amount;\n+        }\n+\n+        return opBinding.getTypeFactory()\n+            .createSqlType(SqlTypeName.VARCHAR, typePrecision);\n+      };\n+\n+  /**\n+   * Same as {@link #MULTIVALENT_STRING_SUM_PRECISION} and using\n+   * {@link org.apache.calcite.sql.type.SqlTypeTransforms#TO_NULLABLE}\n+   */", "originalCommit": "7152d72d11d22f53d921a1a0130ef052651e1aef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODYwMzkwNA==", "url": "https://github.com/apache/calcite/pull/1862#discussion_r398603904", "bodyText": "Start with <p> If there is a blank line ahead. And end with dot.", "author": "danny0405", "createdAt": "2020-03-26T14:12:49Z", "path": "core/src/main/java/org/apache/calcite/sql/type/ReturnTypes.java", "diffHunk": "@@ -655,6 +655,59 @@ public int size() {\n         return ret;\n       };\n \n+\n+  /**\n+   * Type-inference strategy for String concatenation.\n+   * Result is varying if either input is; otherwise fixed.\n+   * For example,\n+   *\n+   * concat(cast('a' as varchar(2)), cast('b' as varchar(3)),cast('c' as varchar(2)))\n+   * returns varchar(7),\n+   *\n+   * concat(cast('a' as varchar), cast('b' as varchar(2), cast('c' as varchar(2))))\n+   * returns varchar,\n+   *\n+   * concat(cast('a' as varchar(65535)), cast('b' as varchar(2)), cast('c' as varchar(2)))\n+   * returns varchar\n+   */", "originalCommit": "7152d72d11d22f53d921a1a0130ef052651e1aef", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "413be6fc73c5a5b5c785e10c518034b8b1fd37d9", "url": "https://github.com/apache/calcite/commit/413be6fc73c5a5b5c785e10c518034b8b1fd37d9", "message": "[CALCITE-3684] Supports CONCAT for variable arguments (Wenhui Tang)", "committedDate": "2020-03-27T10:49:43Z", "type": "commit"}, {"oid": "413be6fc73c5a5b5c785e10c518034b8b1fd37d9", "url": "https://github.com/apache/calcite/commit/413be6fc73c5a5b5c785e10c518034b8b1fd37d9", "message": "[CALCITE-3684] Supports CONCAT for variable arguments (Wenhui Tang)", "committedDate": "2020-03-27T10:49:43Z", "type": "forcePushed"}]}