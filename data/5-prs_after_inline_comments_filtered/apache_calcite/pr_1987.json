{"pr_number": 1987, "pr_title": "[CALCITE-4020] Support Calc operator in RelFieldTrimmer ", "pr_createdAt": "2020-05-22T02:29:05Z", "pr_url": "https://github.com/apache/calcite/pull/1987", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDEyODAzOQ==", "url": "https://github.com/apache/calcite/pull/1987#discussion_r430128039", "bodyText": "What's the difference between testCalcFieldTrimmer0  and testCalcFieldTrimmer1?", "author": "chunweilei", "createdAt": "2020-05-26T02:37:21Z", "path": "core/src/test/java/org/apache/calcite/sql2rel/RelFieldTrimmerTest.java", "diffHunk": "@@ -183,4 +190,96 @@\n     assertThat(trimmed, hasTree(expected));\n   }\n \n+  @Test public void testCalcFieldTrimmer0() {\n+    final RelBuilder builder = RelBuilder.create(config().build());\n+    final RelNode root =\n+        builder.scan(\"EMP\")\n+            .project(builder.field(\"EMPNO\"), builder.field(\"ENAME\"), builder.field(\"DEPTNO\"))\n+            .exchange(RelDistributions.SINGLETON)\n+            .project(builder.field(\"EMPNO\"), builder.field(\"ENAME\"))\n+            .build();\n+", "originalCommit": "2b7c1ecddfde961f767a418baab5e5dd55b6a94d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDEzNjM0MQ==", "url": "https://github.com/apache/calcite/pull/1987#discussion_r430136341", "bodyText": "testCalcFieldTrimmer0 is used for check Project operator.\ntestCalcFieldTrimmer1 is used for check Filter operator.", "author": "xy2953396112", "createdAt": "2020-05-26T03:18:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDEyODAzOQ=="}], "type": "inlineReview"}, {"oid": "a9a4d81ed9732650701307c25b2747623539275b", "url": "https://github.com/apache/calcite/commit/a9a4d81ed9732650701307c25b2747623539275b", "message": "[CALCITE-4020] Support calc operator in RelFieldTrimmer (Xu Zhaohui)", "committedDate": "2020-06-09T09:20:31Z", "type": "forcePushed"}, {"oid": "9e4a043c53165ca7b8f715838f60c8b9c4fe3be8", "url": "https://github.com/apache/calcite/commit/9e4a043c53165ca7b8f715838f60c8b9c4fe3be8", "message": "[CALCITE-4020] Support calc operator in RelFieldTrimmer (Xu Zhaohui)", "committedDate": "2020-06-12T00:16:51Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI1NzI1NQ==", "url": "https://github.com/apache/calcite/pull/1987#discussion_r439257255", "bodyText": "Hints need to be transferred from the original Calc to the new Calc (see CALCITE-4055).\nAlso, IMHO this piece of code could be refactored, to avoid duplicating instructions at the end of the \"if\" and \"else\" block, something like:\nRexNode newConditionExpr = null;\nif (rexProgram.getCondition() != null) {\n  ...\n  newConditionExpr = conditionExpr.accept(shuttle);\n}\nfinal RexProgram newRexProgram = ...\nfinal LogicalCalc logicalCalc = LogicalCalc.create(newInputRelNode, newRexProgram);\nlogicalCalc.withHints(calc.getHints()); // transfer hints\nreturn result(logicalCalc, mapping);", "author": "rubenada", "createdAt": "2020-06-12T07:36:30Z", "path": "core/src/main/java/org/apache/calcite/sql2rel/RelFieldTrimmer.java", "diffHunk": "@@ -350,6 +354,100 @@ public TrimResult trimFields(\n         Mappings.createIdentity(rel.getRowType().getFieldCount()));\n   }\n \n+  /**\n+   * Variant of {@link #trimFields(RelNode, ImmutableBitSet, Set)} for\n+   * {@link org.apache.calcite.rel.logical.LogicalCalc}.\n+   */\n+  public TrimResult trimFields(\n+      Calc calc,\n+      ImmutableBitSet fieldsUsed,\n+      Set<RelDataTypeField> extraFields) {\n+    final RexProgram rexProgram = calc.getProgram();\n+    final List<RexNode> projs = Lists.transform(rexProgram.getProjectList(),\n+        rexProgram::expandLocalRef);\n+\n+    final RelDataType rowType = calc.getRowType();\n+    final int fieldCount = rowType.getFieldCount();\n+    final RelNode input = calc.getInput();\n+\n+    final Set<RelDataTypeField> inputExtraFields =\n+        new LinkedHashSet<>(extraFields);\n+    RelOptUtil.InputFinder inputFinder =\n+        new RelOptUtil.InputFinder(inputExtraFields);\n+    for (Ord<RexNode> ord : Ord.zip(projs)) {\n+      if (fieldsUsed.get(ord.i)) {\n+        ord.e.accept(inputFinder);\n+      }\n+    }\n+    ImmutableBitSet inputFieldsUsed = inputFinder.inputBitSet.build();\n+\n+    // Create input with trimmed columns.\n+    TrimResult trimResult =\n+        trimChild(calc, input, inputFieldsUsed, inputExtraFields);\n+    RelNode newInput = trimResult.left;\n+    final Mapping inputMapping = trimResult.right;\n+\n+    // If the input is unchanged, and we need to project all columns,\n+    // there's nothing we can do.\n+    if (newInput == input\n+        && fieldsUsed.cardinality() == fieldCount) {\n+      return result(calc, Mappings.createIdentity(fieldCount));\n+    }\n+\n+    // Some parts of the system can't handle rows with zero fields, so\n+    // pretend that one field is used.\n+    if (fieldsUsed.cardinality() == 0) {\n+      return dummyProject(fieldCount, newInput);\n+    }\n+\n+    // Build new project expressions, and populate the mapping.\n+    final List<RexNode> newProjects = new ArrayList<>();\n+    final RexVisitor<RexNode> shuttle =\n+        new RexPermuteInputsShuttle(\n+            inputMapping, newInput);\n+    final Mapping mapping =\n+        Mappings.create(\n+            MappingType.INVERSE_SURJECTION,\n+            fieldCount,\n+            fieldsUsed.cardinality());\n+    for (Ord<RexNode> ord : Ord.zip(projs)) {\n+      if (fieldsUsed.get(ord.i)) {\n+        mapping.set(ord.i, newProjects.size());\n+        RexNode newProjectExpr = ord.e.accept(shuttle);\n+        newProjects.add(newProjectExpr);\n+      }\n+    }\n+\n+    final RelDataType newRowType =\n+        RelOptUtil.permute(calc.getCluster().getTypeFactory(), rowType,\n+            mapping);\n+\n+    final RelNode newInputRelNode = relBuilder.push(newInput).build();\n+    if (rexProgram.getCondition() != null) {\n+      final List<RexNode> filter = Lists.transform(\n+          ImmutableList.of(\n+          rexProgram.getCondition()), rexProgram::expandLocalRef);\n+      assert filter.size() == 1;\n+      final RexNode conditionExpr = filter.get(0);\n+\n+      final RexNode newConditionExpr =\n+          conditionExpr.accept(shuttle);\n+      final RexProgram newRexProgram = RexProgram.create(newInputRelNode.getRowType(),\n+          newProjects, newConditionExpr, newRowType.getFieldNames(),\n+          newInputRelNode.getCluster().getRexBuilder());\n+      LogicalCalc logicalCalc = LogicalCalc.create(newInputRelNode, newRexProgram);\n+\n+      return result(logicalCalc, mapping);\n+    } else {\n+      final RexProgram newRexProgram = RexProgram\n+          .create(newInputRelNode.getRowType(), newProjects, null,\n+              newRowType.getFieldNames(), newInputRelNode.getCluster().getRexBuilder());\n+\n+      LogicalCalc logicalCalc = LogicalCalc.create(newInputRelNode, newRexProgram);\n+      return result(logicalCalc, mapping);", "originalCommit": "9e4a043c53165ca7b8f715838f60c8b9c4fe3be8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcyNDE3Mw==", "url": "https://github.com/apache/calcite/pull/1987#discussion_r439724173", "bodyText": "There is still duplicated code in the if + else block, I think the refactoring I proposed in my comment above would make the code cleaner.", "author": "rubenada", "createdAt": "2020-06-13T09:19:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI1NzI1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcyNjQxNA==", "url": "https://github.com/apache/calcite/pull/1987#discussion_r439726414", "bodyText": "Thanks, clean up the code.", "author": "xy2953396112", "createdAt": "2020-06-13T09:55:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI1NzI1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI1ODE2OQ==", "url": "https://github.com/apache/calcite/pull/1987#discussion_r439258169", "bodyText": "I am not sure if, in this situation, the hints from the original Calc must / can be transferred into the new \"dummy Project\". What do you think @danny0405 ?", "author": "rubenada", "createdAt": "2020-06-12T07:38:45Z", "path": "core/src/main/java/org/apache/calcite/sql2rel/RelFieldTrimmer.java", "diffHunk": "@@ -350,6 +354,100 @@ public TrimResult trimFields(\n         Mappings.createIdentity(rel.getRowType().getFieldCount()));\n   }\n \n+  /**\n+   * Variant of {@link #trimFields(RelNode, ImmutableBitSet, Set)} for\n+   * {@link org.apache.calcite.rel.logical.LogicalCalc}.\n+   */\n+  public TrimResult trimFields(\n+      Calc calc,\n+      ImmutableBitSet fieldsUsed,\n+      Set<RelDataTypeField> extraFields) {\n+    final RexProgram rexProgram = calc.getProgram();\n+    final List<RexNode> projs = Lists.transform(rexProgram.getProjectList(),\n+        rexProgram::expandLocalRef);\n+\n+    final RelDataType rowType = calc.getRowType();\n+    final int fieldCount = rowType.getFieldCount();\n+    final RelNode input = calc.getInput();\n+\n+    final Set<RelDataTypeField> inputExtraFields =\n+        new LinkedHashSet<>(extraFields);\n+    RelOptUtil.InputFinder inputFinder =\n+        new RelOptUtil.InputFinder(inputExtraFields);\n+    for (Ord<RexNode> ord : Ord.zip(projs)) {\n+      if (fieldsUsed.get(ord.i)) {\n+        ord.e.accept(inputFinder);\n+      }\n+    }\n+    ImmutableBitSet inputFieldsUsed = inputFinder.inputBitSet.build();\n+\n+    // Create input with trimmed columns.\n+    TrimResult trimResult =\n+        trimChild(calc, input, inputFieldsUsed, inputExtraFields);\n+    RelNode newInput = trimResult.left;\n+    final Mapping inputMapping = trimResult.right;\n+\n+    // If the input is unchanged, and we need to project all columns,\n+    // there's nothing we can do.\n+    if (newInput == input\n+        && fieldsUsed.cardinality() == fieldCount) {\n+      return result(calc, Mappings.createIdentity(fieldCount));\n+    }\n+\n+    // Some parts of the system can't handle rows with zero fields, so\n+    // pretend that one field is used.\n+    if (fieldsUsed.cardinality() == 0) {\n+      return dummyProject(fieldCount, newInput);", "originalCommit": "9e4a043c53165ca7b8f715838f60c8b9c4fe3be8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0e1c03554808853ef939d290bde3c0d0eaa1f964", "url": "https://github.com/apache/calcite/commit/0e1c03554808853ef939d290bde3c0d0eaa1f964", "message": "[CALCITE-4020] Support calc operator in RelFieldTrimmer (Xu Zhaohui)", "committedDate": "2020-06-13T00:11:01Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcyNDI5OQ==", "url": "https://github.com/apache/calcite/pull/1987#discussion_r439724299", "bodyText": "minor: I think in this test it would also make sense to verify that the original Calc (relNode.getInput(0).getInput(0)) contains the hints.", "author": "rubenada", "createdAt": "2020-06-13T09:20:49Z", "path": "core/src/test/java/org/apache/calcite/sql2rel/RelFieldTrimmerTest.java", "diffHunk": "@@ -306,4 +314,139 @@\n     assertTrue(project.getHints().contains(projectHint));\n   }\n \n+  @Test void testCalcFieldTrimmer0() {\n+    final RelBuilder builder = RelBuilder.create(config().build());\n+    final RelNode root =\n+        builder.scan(\"EMP\")\n+            .project(builder.field(\"EMPNO\"), builder.field(\"ENAME\"), builder.field(\"DEPTNO\"))\n+            .exchange(RelDistributions.SINGLETON)\n+            .project(builder.field(\"EMPNO\"), builder.field(\"ENAME\"))\n+            .build();\n+\n+    final HepProgram hepProgram = new HepProgramBuilder().\n+        addRuleInstance(ProjectToCalcRule.INSTANCE).build();\n+\n+    final HepPlanner hepPlanner = new HepPlanner(hepProgram);\n+    hepPlanner.setRoot(root);\n+    final RelNode relNode = hepPlanner.findBestExp();\n+    final RelFieldTrimmer fieldTrimmer = new RelFieldTrimmer(null, builder);\n+    final RelNode trimmed = fieldTrimmer.trim(relNode);\n+\n+    final String expected = \"\"\n+        + \"LogicalCalc(expr#0..1=[{inputs}], proj#0..1=[{exprs}])\\n\"\n+        + \"  LogicalExchange(distribution=[single])\\n\"\n+        + \"    LogicalCalc(expr#0..1=[{inputs}], proj#0..1=[{exprs}])\\n\"\n+        + \"      LogicalProject(EMPNO=[$0], ENAME=[$1])\\n\"\n+        + \"        LogicalTableScan(table=[[scott, EMP]])\\n\";\n+    assertThat(trimmed, hasTree(expected));\n+  }\n+\n+  @Test void testCalcFieldTrimmer1() {\n+    final RelBuilder builder = RelBuilder.create(config().build());\n+    final RelNode root =\n+        builder.scan(\"EMP\")\n+            .project(builder.field(\"EMPNO\"), builder.field(\"ENAME\"), builder.field(\"DEPTNO\"))\n+            .exchange(RelDistributions.SINGLETON)\n+            .filter(\n+                builder.call(SqlStdOperatorTable.GREATER_THAN,\n+                    builder.field(\"EMPNO\"), builder.literal(100)))\n+            .build();\n+\n+    final HepProgram hepProgram = new HepProgramBuilder()\n+        .addRuleInstance(ProjectToCalcRule.INSTANCE)\n+        .addRuleInstance(FilterToCalcRule.INSTANCE)\n+        .build();\n+\n+    final HepPlanner hepPlanner = new HepPlanner(hepProgram);\n+    hepPlanner.setRoot(root);\n+    final RelNode relNode = hepPlanner.findBestExp();\n+    final RelFieldTrimmer fieldTrimmer = new RelFieldTrimmer(null, builder);\n+    final RelNode trimmed = fieldTrimmer.trim(relNode);\n+\n+    final String expected = \"\"\n+        + \"LogicalCalc(expr#0..2=[{inputs}], expr#3=[100], expr#4=[>($t0, $t3)], proj#0.\"\n+        + \".2=[{exprs}], $condition=[$t4])\\n\"\n+        + \"  LogicalExchange(distribution=[single])\\n\"\n+        + \"    LogicalCalc(expr#0..2=[{inputs}], proj#0..2=[{exprs}])\\n\"\n+        + \"      LogicalProject(EMPNO=[$0], ENAME=[$1], DEPTNO=[$7])\\n\"\n+        + \"        LogicalTableScan(table=[[scott, EMP]])\\n\";\n+    assertThat(trimmed, hasTree(expected));\n+  }\n+\n+  @Test void testCalcFieldTrimmer2() {\n+    final RelBuilder builder = RelBuilder.create(config().build());\n+    final RelNode root =\n+        builder.scan(\"EMP\")\n+            .project(builder.field(\"EMPNO\"), builder.field(\"ENAME\"), builder.field(\"DEPTNO\"))\n+            .exchange(RelDistributions.SINGLETON)\n+            .filter(\n+                builder.call(SqlStdOperatorTable.GREATER_THAN,\n+                    builder.field(\"EMPNO\"), builder.literal(100)))\n+            .project(builder.field(\"EMPNO\"), builder.field(\"ENAME\"))\n+            .build();\n+\n+    final HepProgram hepProgram = new HepProgramBuilder()\n+        .addRuleInstance(ProjectToCalcRule.INSTANCE)\n+        .addRuleInstance(FilterToCalcRule.INSTANCE)\n+        .addRuleInstance(CalcMergeRule.INSTANCE).build();\n+\n+    final HepPlanner hepPlanner = new HepPlanner(hepProgram);\n+    hepPlanner.setRoot(root);\n+    final RelNode relNode = hepPlanner.findBestExp();\n+    final RelFieldTrimmer fieldTrimmer = new RelFieldTrimmer(null, builder);\n+    final RelNode trimmed = fieldTrimmer.trim(relNode);\n+\n+    final String expected = \"\"\n+        + \"LogicalCalc(expr#0..1=[{inputs}], expr#2=[100], expr#3=[>($t0, $t2)], proj#0.\"\n+        + \".1=[{exprs}], $condition=[$t3])\\n\"\n+        + \"  LogicalExchange(distribution=[single])\\n\"\n+        + \"    LogicalCalc(expr#0..1=[{inputs}], proj#0..1=[{exprs}])\\n\"\n+        + \"      LogicalProject(EMPNO=[$0], ENAME=[$1])\\n\"\n+        + \"        LogicalTableScan(table=[[scott, EMP]])\\n\";\n+    assertThat(trimmed, hasTree(expected));\n+  }\n+\n+  @Test void testCalcWithHints() {\n+    final RelHint calcHint = RelHint.builder(\"resource\").build();\n+    final RelBuilder builder = RelBuilder.create(config().build());\n+    builder.getCluster().setHintStrategies(\n+        HintStrategyTable.builder().hintStrategy(\"resource\", HintPredicates.CALC).build());\n+    final RelNode original =\n+        builder.scan(\"EMP\")\n+            .project(\n+                builder.field(\"EMPNO\"),\n+                builder.field(\"ENAME\"),\n+                builder.field(\"DEPTNO\")\n+            ).hints(calcHint)\n+            .sort(builder.field(\"EMPNO\"))\n+            .project(builder.field(\"EMPNO\"))\n+            .build();\n+\n+    final HepProgram hepProgram = new HepProgramBuilder()\n+        .addRuleInstance(ProjectToCalcRule.INSTANCE)\n+        .build();\n+    final HepPlanner hepPlanner = new HepPlanner(hepProgram);\n+    hepPlanner.setRoot(original);\n+    final RelNode relNode = hepPlanner.findBestExp();\n+\n+    final RelFieldTrimmer fieldTrimmer = new RelFieldTrimmer(null, builder);\n+    final RelNode trimmed = fieldTrimmer.trim(relNode);\n+\n+    final String expected = \"\"\n+        + \"LogicalCalc(expr#0=[{inputs}], EMPNO=[$t0])\\n\"\n+        + \"  LogicalSort(sort0=[$0], dir0=[ASC])\\n\"\n+        + \"    LogicalCalc(expr#0=[{inputs}], EMPNO=[$t0])\\n\"\n+        + \"      LogicalProject(EMPNO=[$0])\\n\"\n+        + \"        LogicalTableScan(table=[[scott, EMP]])\\n\";\n+    assertThat(trimmed, hasTree(expected));\n+\n+    assertTrue(original.getInput(0).getInput(0) instanceof Project);", "originalCommit": "0e1c03554808853ef939d290bde3c0d0eaa1f964", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcyNjU2NA==", "url": "https://github.com/apache/calcite/pull/1987#discussion_r439726564", "bodyText": "Thanks, Add the verification logic of the original Calc contains the hints.", "author": "xy2953396112", "createdAt": "2020-06-13T09:57:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcyNDI5OQ=="}], "type": "inlineReview"}, {"oid": "37db058e10ba8ef399a8bc1c99b3ce2ca3f044bc", "url": "https://github.com/apache/calcite/commit/37db058e10ba8ef399a8bc1c99b3ce2ca3f044bc", "message": "[CALCITE-4020] Support calc operator in RelFieldTrimmer (Xu Zhaohui)", "committedDate": "2020-06-13T09:42:50Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkwNzEyNw==", "url": "https://github.com/apache/calcite/pull/1987#discussion_r439907127", "bodyText": "Do we have to use LinkedHashSet ? Looks like HashSet is enough.", "author": "chunweilei", "createdAt": "2020-06-15T02:57:01Z", "path": "core/src/main/java/org/apache/calcite/sql2rel/RelFieldTrimmer.java", "diffHunk": "@@ -350,6 +354,92 @@ public TrimResult trimFields(\n         Mappings.createIdentity(rel.getRowType().getFieldCount()));\n   }\n \n+  /**\n+   * Variant of {@link #trimFields(RelNode, ImmutableBitSet, Set)} for\n+   * {@link org.apache.calcite.rel.logical.LogicalCalc}.\n+   */\n+  public TrimResult trimFields(\n+      Calc calc,\n+      ImmutableBitSet fieldsUsed,\n+      Set<RelDataTypeField> extraFields) {\n+    final RexProgram rexProgram = calc.getProgram();\n+    final List<RexNode> projs = Lists.transform(rexProgram.getProjectList(),\n+        rexProgram::expandLocalRef);\n+\n+    final RelDataType rowType = calc.getRowType();\n+    final int fieldCount = rowType.getFieldCount();\n+    final RelNode input = calc.getInput();\n+\n+    final Set<RelDataTypeField> inputExtraFields =\n+        new LinkedHashSet<>(extraFields);\n+    RelOptUtil.InputFinder inputFinder =", "originalCommit": "37db058e10ba8ef399a8bc1c99b3ce2ca3f044bc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk1NTYyOA==", "url": "https://github.com/apache/calcite/pull/1987#discussion_r439955628", "bodyText": "ok", "author": "xy2953396112", "createdAt": "2020-06-15T06:31:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkwNzEyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkwODY5Nw==", "url": "https://github.com/apache/calcite/pull/1987#discussion_r439908697", "bodyText": "Should we use Calc#copy to generate new Calc?", "author": "chunweilei", "createdAt": "2020-06-15T03:04:18Z", "path": "core/src/main/java/org/apache/calcite/sql2rel/RelFieldTrimmer.java", "diffHunk": "@@ -350,6 +354,92 @@ public TrimResult trimFields(\n         Mappings.createIdentity(rel.getRowType().getFieldCount()));\n   }\n \n+  /**\n+   * Variant of {@link #trimFields(RelNode, ImmutableBitSet, Set)} for\n+   * {@link org.apache.calcite.rel.logical.LogicalCalc}.\n+   */\n+  public TrimResult trimFields(\n+      Calc calc,\n+      ImmutableBitSet fieldsUsed,\n+      Set<RelDataTypeField> extraFields) {\n+    final RexProgram rexProgram = calc.getProgram();\n+    final List<RexNode> projs = Lists.transform(rexProgram.getProjectList(),\n+        rexProgram::expandLocalRef);\n+\n+    final RelDataType rowType = calc.getRowType();\n+    final int fieldCount = rowType.getFieldCount();\n+    final RelNode input = calc.getInput();\n+\n+    final Set<RelDataTypeField> inputExtraFields =\n+        new LinkedHashSet<>(extraFields);\n+    RelOptUtil.InputFinder inputFinder =\n+        new RelOptUtil.InputFinder(inputExtraFields);\n+    for (Ord<RexNode> ord : Ord.zip(projs)) {\n+      if (fieldsUsed.get(ord.i)) {\n+        ord.e.accept(inputFinder);\n+      }\n+    }\n+    ImmutableBitSet inputFieldsUsed = inputFinder.build();\n+\n+    // Create input with trimmed columns.\n+    TrimResult trimResult =\n+        trimChild(calc, input, inputFieldsUsed, inputExtraFields);\n+    RelNode newInput = trimResult.left;\n+    final Mapping inputMapping = trimResult.right;\n+\n+    // If the input is unchanged, and we need to project all columns,\n+    // there's nothing we can do.\n+    if (newInput == input\n+        && fieldsUsed.cardinality() == fieldCount) {\n+      return result(calc, Mappings.createIdentity(fieldCount));\n+    }\n+\n+    // Some parts of the system can't handle rows with zero fields, so\n+    // pretend that one field is used.\n+    if (fieldsUsed.cardinality() == 0) {\n+      return dummyProject(fieldCount, newInput);\n+    }\n+\n+    // Build new project expressions, and populate the mapping.\n+    final List<RexNode> newProjects = new ArrayList<>();\n+    final RexVisitor<RexNode> shuttle =\n+        new RexPermuteInputsShuttle(\n+            inputMapping, newInput);\n+    final Mapping mapping =\n+        Mappings.create(\n+            MappingType.INVERSE_SURJECTION,\n+            fieldCount,\n+            fieldsUsed.cardinality());\n+    for (Ord<RexNode> ord : Ord.zip(projs)) {\n+      if (fieldsUsed.get(ord.i)) {\n+        mapping.set(ord.i, newProjects.size());\n+        RexNode newProjectExpr = ord.e.accept(shuttle);\n+        newProjects.add(newProjectExpr);\n+      }\n+    }\n+\n+    final RelDataType newRowType =\n+        RelOptUtil.permute(calc.getCluster().getTypeFactory(), rowType,\n+            mapping);\n+\n+    final RelNode newInputRelNode = relBuilder.push(newInput).build();\n+    RexNode newConditionExpr = null;\n+    if (rexProgram.getCondition() != null) {\n+      final List<RexNode> filter = Lists.transform(\n+          ImmutableList.of(\n+              rexProgram.getCondition()), rexProgram::expandLocalRef);\n+      assert filter.size() == 1;\n+      final RexNode conditionExpr = filter.get(0);\n+      newConditionExpr = conditionExpr.accept(shuttle);\n+    }\n+    final RexProgram newRexProgram = RexProgram.create(newInputRelNode.getRowType(),\n+        newProjects, newConditionExpr, newRowType.getFieldNames(),\n+        newInputRelNode.getCluster().getRexBuilder());\n+    final LogicalCalc logicalCalc = LogicalCalc.create(newInputRelNode, newRexProgram);\n+    // transfer hints\n+    return result(logicalCalc.withHints(calc.getHints()), mapping);\n+  }", "originalCommit": "37db058e10ba8ef399a8bc1c99b3ce2ca3f044bc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk1NTczMQ==", "url": "https://github.com/apache/calcite/pull/1987#discussion_r439955731", "bodyText": "Calc#copy is better.", "author": "xy2953396112", "createdAt": "2020-06-15T06:31:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkwODY5Nw=="}], "type": "inlineReview"}, {"oid": "6c5c5c6d72edfbe6af2f6ee2c90f1f6584830834", "url": "https://github.com/apache/calcite/commit/6c5c5c6d72edfbe6af2f6ee2c90f1f6584830834", "message": "[CALCITE-4020] Support Calc operator in RelFieldTrimmer (Xu Zhaohui)", "committedDate": "2020-06-15T05:57:22Z", "type": "commit"}, {"oid": "6c5c5c6d72edfbe6af2f6ee2c90f1f6584830834", "url": "https://github.com/apache/calcite/commit/6c5c5c6d72edfbe6af2f6ee2c90f1f6584830834", "message": "[CALCITE-4020] Support Calc operator in RelFieldTrimmer (Xu Zhaohui)", "committedDate": "2020-06-15T05:57:22Z", "type": "forcePushed"}]}