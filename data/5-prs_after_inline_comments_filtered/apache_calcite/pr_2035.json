{"pr_number": 2035, "pr_title": "[CALCITE-4008] Implement Code generation for EnumerableSortedAggregat\u2026", "pr_createdAt": "2020-06-18T18:11:00Z", "pr_url": "https://github.com/apache/calcite/pull/2035", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQxNjc1Mg==", "url": "https://github.com/apache/calcite/pull/2035#discussion_r442416752", "bodyText": "I will need to double check and probably revise this part to make KeySelector match with KeyComparator.", "author": "amaliujia", "createdAt": "2020-06-18T18:19:29Z", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableSortedAggregate.java", "diffHunk": "@@ -90,6 +101,133 @@ public EnumerableSortedAggregate(\n   }\n \n   public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n-    throw Util.needToImplement(\"EnumerableSortedAggregate\");\n+    if (getGroupType() != Group.SIMPLE\n+        || aggCalls.isEmpty()) {\n+      throw Util.needToImplement(\"EnumerableSortedAggregate\");\n+    }\n+\n+    final JavaTypeFactory typeFactory = implementor.getTypeFactory();\n+    final BlockBuilder builder = new BlockBuilder();\n+    final EnumerableRel child = (EnumerableRel) getInput();\n+    final Result result = implementor.visitChild(this, 0, child, pref);\n+    Expression childExp =\n+        builder.append(\n+            \"child\",\n+            result.block);\n+\n+    final PhysType physType =\n+        PhysTypeImpl.of(\n+            typeFactory, getRowType(), pref.preferCustom());\n+\n+    final PhysType inputPhysType = result.physType;\n+\n+    ParameterExpression parameter =\n+        Expressions.parameter(inputPhysType.getJavaRowType(), \"a0\");\n+\n+    final PhysType keyPhysType =\n+        inputPhysType.project(groupSet.asList(), getGroupType() != Group.SIMPLE,\n+            JavaRowFormat.LIST);\n+    final int groupCount = getGroupCount();\n+\n+    final List<AggImpState> aggs = new ArrayList<>(aggCalls.size());\n+    for (Ord<AggregateCall> call : Ord.zip(aggCalls)) {\n+      aggs.add(new AggImpState(call.i, call.e, false));\n+    }\n+\n+    // Function0<Object[]> accumulatorInitializer =\n+    //     new Function0<Object[]>() {\n+    //         public Object[] apply() {\n+    //             return new Object[] {0, 0};\n+    //         }\n+    //     };\n+    final List<Expression> initExpressions = new ArrayList<>();\n+    final BlockBuilder initBlock = new BlockBuilder();\n+\n+    final List<Type> aggStateTypes = createAggStateTypes(\n+        initExpressions, initBlock, aggs, typeFactory);\n+\n+    final PhysType accPhysType =\n+        PhysTypeImpl.of(typeFactory,\n+            typeFactory.createSyntheticType(aggStateTypes));\n+\n+    declareParentAccumulator(initExpressions, initBlock, accPhysType);\n+\n+    final Expression accumulatorInitializer =\n+        builder.append(\"accumulatorInitializer\",\n+            Expressions.lambda(\n+                Function0.class,\n+                initBlock.toBlock()));\n+\n+    // Function2<Object[], Employee, Object[]> accumulatorAdder =\n+    //     new Function2<Object[], Employee, Object[]>() {\n+    //         public Object[] apply(Object[] acc, Employee in) {\n+    //              acc[0] = ((Integer) acc[0]) + 1;\n+    //              acc[1] = ((Integer) acc[1]) + in.salary;\n+    //             return acc;\n+    //         }\n+    //     };\n+    final ParameterExpression inParameter =\n+        Expressions.parameter(inputPhysType.getJavaRowType(), \"in\");\n+    final ParameterExpression acc_ =\n+        Expressions.parameter(accPhysType.getJavaRowType(), \"acc\");\n+\n+    createAccumulatorAdders(\n+        inParameter, aggs, accPhysType, acc_, inputPhysType, builder, implementor, typeFactory);\n+\n+    final ParameterExpression lambdaFactory =\n+        Expressions.parameter(AggregateLambdaFactory.class,\n+            builder.newName(\"lambdaFactory\"));\n+\n+    implementLambdaFactory(builder, inputPhysType, aggs, accumulatorInitializer,\n+        false, lambdaFactory);\n+\n+    final BlockBuilder resultBlock = new BlockBuilder();\n+    final List<Expression> results = Expressions.list();\n+    final ParameterExpression key_;\n+    final Type keyType = keyPhysType.getJavaRowType();\n+    key_ = Expressions.parameter(keyType, \"key\");\n+    for (int j = 0; j < groupCount; j++) {\n+      final Expression ref = keyPhysType.fieldReference(key_, j);\n+      results.add(ref);\n+    }\n+\n+    for (final AggImpState agg : aggs) {\n+      results.add(\n+          agg.implementor.implementResult(agg.context,\n+              new AggResultContextImpl(resultBlock, agg.call, agg.state, key_,\n+                  keyPhysType)));\n+    }\n+    resultBlock.add(physType.record(results));\n+\n+    final Expression keySelector_ =\n+        builder.append(\"keySelector\",\n+            inputPhysType.generateSelector(parameter,\n+                groupSet.asList(),\n+                keyPhysType.getFormat()));\n+    // Generate the appropriate key Comparator.\n+    final Expression comparator = keyPhysType.generateComparator(getTraitSet().getCollation());", "originalCommit": "bc7ef9a39ec56a9cdcd48f0c38b43c7a2624337c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjMyMDkwMQ==", "url": "https://github.com/apache/calcite/pull/2035#discussion_r446320901", "bodyText": "In fact. I cannot find a way to turn on top down opt by Hook.PLANNER", "author": "amaliujia", "createdAt": "2020-06-26T17:38:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQxNjc1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQxNzE0MA==", "url": "https://github.com/apache/calcite/pull/2035#discussion_r442417140", "bodyText": "@hsyuan any suggestion that what extra tests are useful for EnumerableSortedAggregate?", "author": "amaliujia", "createdAt": "2020-06-18T18:20:14Z", "path": "core/src/test/java/org/apache/calcite/test/enumerable/EnumerableSortedAggregateTest.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.test.enumerable;\n+\n+import org.apache.calcite.adapter.enumerable.EnumerableRules;\n+import org.apache.calcite.adapter.java.ReflectiveSchema;\n+import org.apache.calcite.config.CalciteConnectionProperty;\n+import org.apache.calcite.config.Lex;\n+import org.apache.calcite.plan.RelOptPlanner;\n+import org.apache.calcite.runtime.Hook;\n+import org.apache.calcite.test.CalciteAssert;\n+import org.apache.calcite.test.JdbcTest;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.function.Consumer;\n+\n+public class EnumerableSortedAggregateTest {\n+  @Test void sortedAgg() {", "originalCommit": "bc7ef9a39ec56a9cdcd48f0c38b43c7a2624337c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM1MTcxMw==", "url": "https://github.com/apache/calcite/pull/2035#discussion_r445351713", "bodyText": "I would propose e.g.\n\ngroup by X, Y (several columns)\ngroup by X + order by X\ngroup by X + order by Y", "author": "rubenada", "createdAt": "2020-06-25T07:13:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQxNzE0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTczNDc0NA==", "url": "https://github.com/apache/calcite/pull/2035#discussion_r445734744", "bodyText": "Missed this comment. Will add more tests.", "author": "amaliujia", "createdAt": "2020-06-25T17:51:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQxNzE0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTc4NDE1Mw==", "url": "https://github.com/apache/calcite/pull/2035#discussion_r445784153", "bodyText": "Thanks for your suggestion. I added a unit test for each of the suggested items.", "author": "amaliujia", "createdAt": "2020-06-25T19:18:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQxNzE0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQwNjE4Ng==", "url": "https://github.com/apache/calcite/pull/2035#discussion_r443406186", "bodyText": "Would it be possible to extract these conditions as an auxiliary method isSupported ?\nBy doing this, we could make EnumerableSortedAggregateRule to check it, and in case of not supported, do not generate the EnumerableSortedAggregate (otherwise the rule would generate an operator that will fail when trying to implement).", "author": "rubenada", "createdAt": "2020-06-22T08:45:11Z", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableSortedAggregate.java", "diffHunk": "@@ -90,6 +101,133 @@ public EnumerableSortedAggregate(\n   }\n \n   public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n-    throw Util.needToImplement(\"EnumerableSortedAggregate\");\n+    if (getGroupType() != Group.SIMPLE", "originalCommit": "71991f7985112f9cff2aaced0aa95cfc99e93971", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDY1ODk5OA==", "url": "https://github.com/apache/calcite/pull/2035#discussion_r444658998", "bodyText": "That'a good point. In fact, I think I should follow https://github.com/apache/calcite/blob/master/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableSortedAggregateRule.java#L41", "author": "amaliujia", "createdAt": "2020-06-24T05:50:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQwNjE4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ0NjA2NQ==", "url": "https://github.com/apache/calcite/pull/2035#discussion_r443446065", "bodyText": "Would it be possible for a key to be null? Do we need to add a check for that?", "author": "rubenada", "createdAt": "2020-06-22T09:54:44Z", "path": "linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java", "diffHunk": "@@ -817,6 +817,112 @@ public void remove() {\n         resultSelector);\n   }\n \n+  /**\n+   * Group keys are sorted already. Key values are compared by using a\n+   * specified comparator. Groups the elements of a sequence according to a\n+   * specified key selector function and initializing one accumulator at a time.\n+   * Go over elements sequentially, adding to accumulator each time an element\n+   * with the same key is seen. When key changes, creates a result value from the\n+   * accumulator and then re-initializes the accumulator.\n+   */\n+  public static <TSource, TKey, TAccumulate, TResult> Enumerable<TResult> sortedGroupBy(\n+      Enumerable<TSource> enumerable,\n+      Function1<TSource, TKey> keySelector,\n+      Function0<TAccumulate> accumulatorInitializer,\n+      Function2<TAccumulate, TSource, TAccumulate> accumulatorAdder,\n+      final Function2<TKey, TAccumulate, TResult> resultSelector,\n+      final Comparator<TKey> comparator) {\n+    return new AbstractEnumerable<TResult>() {\n+      public Enumerator<TResult> enumerator() {\n+        return new SortedAggregateEnumerator(\n+          enumerable, keySelector, accumulatorInitializer,\n+          accumulatorAdder, resultSelector, comparator);\n+      }\n+    };\n+  }\n+\n+  private static class SortedAggregateEnumerator<TSource, TKey, TAccumulate, TResult>\n+      implements Enumerator<TResult> {\n+    private final Enumerable<TSource> enumerable;\n+    private final Function1<TSource, TKey> keySelector;\n+    private final Function0<TAccumulate> accumulatorInitializer;\n+    private final Function2<TAccumulate, TSource, TAccumulate> accumulatorAdder;\n+    private final Function2<TKey, TAccumulate, TResult> resultSelector;\n+    private final Comparator<TKey> comparator;\n+    private boolean isInitialized;\n+    private TAccumulate curAccumulator;\n+    private Enumerator<TSource> enumerator;\n+\n+    SortedAggregateEnumerator(\n+        Enumerable<TSource> enumerable,\n+        Function1<TSource, TKey> keySelector,\n+        Function0<TAccumulate> accumulatorInitializer,\n+        Function2<TAccumulate, TSource, TAccumulate> accumulatorAdder,\n+        final Function2<TKey, TAccumulate, TResult> resultSelector,\n+        final Comparator<TKey> comparator) {\n+      this.enumerable = enumerable;\n+      this.keySelector = keySelector;\n+      this.accumulatorInitializer = accumulatorInitializer;\n+      this.accumulatorAdder = accumulatorAdder;\n+      this.resultSelector = resultSelector;\n+      this.comparator = comparator;\n+      isInitialized = false;\n+      curAccumulator = null;\n+      enumerator = enumerable.enumerator();\n+    }\n+\n+    @Override public TResult current() {\n+      if (curAccumulator == null) {\n+        curAccumulator = accumulatorInitializer.apply();\n+      }\n+      TResult result = null;\n+      TSource o = enumerator.current();\n+      TKey prevKey = keySelector.apply(o);\n+      curAccumulator = accumulatorAdder.apply(curAccumulator, o);\n+      while (enumerator.moveNext()) {\n+        o = enumerator.current();\n+        TKey curKey = keySelector.apply(o);", "originalCommit": "71991f7985112f9cff2aaced0aa95cfc99e93971", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDY1ODYzNw==", "url": "https://github.com/apache/calcite/pull/2035#discussion_r444658637", "bodyText": "This is a good question.\nIf we allow null, then comparator should give a consistent ordering for null (e.g. https://stackoverflow.com/a/2401629/10055573)\nIf we don't allow null, indeed we should have a check somewhere.\nHowever, the problem is I don't know if all those comparator give a consistent ordering for null.\nAlso\n        // mergeJoin assumes inputs sorted in ascending order with nulls last,\n        // if we reach a null key, we are done.\n\nI actually not sure what should be the right resolution. What do you think?", "author": "amaliujia", "createdAt": "2020-06-24T05:49:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ0NjA2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDczODk4MA==", "url": "https://github.com/apache/calcite/pull/2035#discussion_r444738980", "bodyText": "NULLs should always come at the beginning or at the end, so I assume the current algorithm would work... if the comparator is able to support nulls. Otherwise, as you say, we would need to add an extra check for null values.\nI guess this will be an good scenario for a unit test", "author": "rubenada", "createdAt": "2020-06-24T08:43:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ0NjA2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTIxMzE4Mw==", "url": "https://github.com/apache/calcite/pull/2035#discussion_r445213183", "bodyText": "Added a test to test null values. Based on the test, null is put at the last position (ASC) by comparator.", "author": "amaliujia", "createdAt": "2020-06-24T22:48:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ0NjA2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM0OTM1OQ==", "url": "https://github.com/apache/calcite/pull/2035#discussion_r445349359", "bodyText": "Thanks for adding test, good example.\nMaybe it might be worth it adding a line in sortedGroupBy javadocs specifying that in case of null keys, the comparator must be able to support null values (or something along these lines).", "author": "rubenada", "createdAt": "2020-06-25T07:07:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ0NjA2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTczMzcxOA==", "url": "https://github.com/apache/calcite/pull/2035#discussion_r445733718", "bodyText": "added this requirement to both javadoc of sortedGroupBy and relevant lines in EnumerableSortedAggregate.", "author": "amaliujia", "createdAt": "2020-06-25T17:49:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ0NjA2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ1MTUwMA==", "url": "https://github.com/apache/calcite/pull/2035#discussion_r443451500", "bodyText": "I think this implementation of current does not respect this part of the contract:\nThis method does not move the position of the enumerator, and\nconsecutive calls to {@code current} return the same object until either\n{@code moveNext} or {@code reset} is called.\n\nI have the impression that consecutive calls to current will return different results. I think the logic that we have here should be transferred as part of moveNext, and the \"current object\" should be somehow saved; finally current should do no processing, just returning the \"current object\" saved by the moveNext process, or something like that.", "author": "rubenada", "createdAt": "2020-06-22T10:04:17Z", "path": "linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java", "diffHunk": "@@ -817,6 +817,112 @@ public void remove() {\n         resultSelector);\n   }\n \n+  /**\n+   * Group keys are sorted already. Key values are compared by using a\n+   * specified comparator. Groups the elements of a sequence according to a\n+   * specified key selector function and initializing one accumulator at a time.\n+   * Go over elements sequentially, adding to accumulator each time an element\n+   * with the same key is seen. When key changes, creates a result value from the\n+   * accumulator and then re-initializes the accumulator.\n+   */\n+  public static <TSource, TKey, TAccumulate, TResult> Enumerable<TResult> sortedGroupBy(\n+      Enumerable<TSource> enumerable,\n+      Function1<TSource, TKey> keySelector,\n+      Function0<TAccumulate> accumulatorInitializer,\n+      Function2<TAccumulate, TSource, TAccumulate> accumulatorAdder,\n+      final Function2<TKey, TAccumulate, TResult> resultSelector,\n+      final Comparator<TKey> comparator) {\n+    return new AbstractEnumerable<TResult>() {\n+      public Enumerator<TResult> enumerator() {\n+        return new SortedAggregateEnumerator(\n+          enumerable, keySelector, accumulatorInitializer,\n+          accumulatorAdder, resultSelector, comparator);\n+      }\n+    };\n+  }\n+\n+  private static class SortedAggregateEnumerator<TSource, TKey, TAccumulate, TResult>\n+      implements Enumerator<TResult> {\n+    private final Enumerable<TSource> enumerable;\n+    private final Function1<TSource, TKey> keySelector;\n+    private final Function0<TAccumulate> accumulatorInitializer;\n+    private final Function2<TAccumulate, TSource, TAccumulate> accumulatorAdder;\n+    private final Function2<TKey, TAccumulate, TResult> resultSelector;\n+    private final Comparator<TKey> comparator;\n+    private boolean isInitialized;\n+    private TAccumulate curAccumulator;\n+    private Enumerator<TSource> enumerator;\n+\n+    SortedAggregateEnumerator(\n+        Enumerable<TSource> enumerable,\n+        Function1<TSource, TKey> keySelector,\n+        Function0<TAccumulate> accumulatorInitializer,\n+        Function2<TAccumulate, TSource, TAccumulate> accumulatorAdder,\n+        final Function2<TKey, TAccumulate, TResult> resultSelector,\n+        final Comparator<TKey> comparator) {\n+      this.enumerable = enumerable;\n+      this.keySelector = keySelector;\n+      this.accumulatorInitializer = accumulatorInitializer;\n+      this.accumulatorAdder = accumulatorAdder;\n+      this.resultSelector = resultSelector;\n+      this.comparator = comparator;\n+      isInitialized = false;\n+      curAccumulator = null;\n+      enumerator = enumerable.enumerator();\n+    }\n+\n+    @Override public TResult current() {", "originalCommit": "71991f7985112f9cff2aaced0aa95cfc99e93971", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDY1NzQ0Nw==", "url": "https://github.com/apache/calcite/pull/2035#discussion_r444657447", "bodyText": "This is a great point. Indeed current should return same object unless it moves to next or resets.\nI move a bunch of code to moveNext and only keep return a cached current result in current now.", "author": "amaliujia", "createdAt": "2020-06-24T05:45:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ1MTUwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc0NDg2Mw==", "url": "https://github.com/apache/calcite/pull/2035#discussion_r444744863", "bodyText": "Also a minor detail, please notice that, per contract, current must throw NoSuchElementException if moveNext has not been called, in your case I think it would just return null.\nYou can easily fix this by using a DUMMY object, see e.g. lazyCollectionSpool method", "author": "rubenada", "createdAt": "2020-06-24T08:53:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ1MTUwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTIxMjkyNg==", "url": "https://github.com/apache/calcite/pull/2035#discussion_r445212926", "bodyText": "Thanks for the example!\nI doubled check the contract and have the following conclusion:\n   * <p>After an enumerator is created or after the {@link #reset} method is\n   * called, the {@link #moveNext} method must be called to advance the\n   * enumerator to the first element of the collection before reading the\n   * value of the {@code current} property; otherwise, {@code current} is\n   * undefined.\n\nSo in this case, return null is right as the result is undefined.\n   * <p>This method also throws {@link java.util.NoSuchElementException} if\n   * the last call to {@code moveNext} returned {@code false}, which indicates\n   * the end of the collection.\n\nI updated the code to make sure it throws NoSuchElementException in this case.", "author": "amaliujia", "createdAt": "2020-06-24T22:47:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ1MTUwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM0NzY0MQ==", "url": "https://github.com/apache/calcite/pull/2035#discussion_r445347641", "bodyText": "You're right. Re-reading the javadoc of current and its throws clauses, I find it a bit confusing, even contradictory, regarding this type of situations. In any case, this is out of the scope of the current PR, so IMO your current proposal is ok.", "author": "rubenada", "createdAt": "2020-06-25T07:03:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ1MTUwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ4NjYzNw==", "url": "https://github.com/apache/calcite/pull/2035#discussion_r443486637", "bodyText": "Maybe we should put curAccumulator = null; as part of the reset", "author": "rubenada", "createdAt": "2020-06-22T11:15:06Z", "path": "linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java", "diffHunk": "@@ -817,6 +817,112 @@ public void remove() {\n         resultSelector);\n   }\n \n+  /**\n+   * Group keys are sorted already. Key values are compared by using a\n+   * specified comparator. Groups the elements of a sequence according to a\n+   * specified key selector function and initializing one accumulator at a time.\n+   * Go over elements sequentially, adding to accumulator each time an element\n+   * with the same key is seen. When key changes, creates a result value from the\n+   * accumulator and then re-initializes the accumulator.\n+   */\n+  public static <TSource, TKey, TAccumulate, TResult> Enumerable<TResult> sortedGroupBy(\n+      Enumerable<TSource> enumerable,\n+      Function1<TSource, TKey> keySelector,\n+      Function0<TAccumulate> accumulatorInitializer,\n+      Function2<TAccumulate, TSource, TAccumulate> accumulatorAdder,\n+      final Function2<TKey, TAccumulate, TResult> resultSelector,\n+      final Comparator<TKey> comparator) {\n+    return new AbstractEnumerable<TResult>() {\n+      public Enumerator<TResult> enumerator() {\n+        return new SortedAggregateEnumerator(\n+          enumerable, keySelector, accumulatorInitializer,\n+          accumulatorAdder, resultSelector, comparator);\n+      }\n+    };\n+  }\n+\n+  private static class SortedAggregateEnumerator<TSource, TKey, TAccumulate, TResult>\n+      implements Enumerator<TResult> {\n+    private final Enumerable<TSource> enumerable;\n+    private final Function1<TSource, TKey> keySelector;\n+    private final Function0<TAccumulate> accumulatorInitializer;\n+    private final Function2<TAccumulate, TSource, TAccumulate> accumulatorAdder;\n+    private final Function2<TKey, TAccumulate, TResult> resultSelector;\n+    private final Comparator<TKey> comparator;\n+    private boolean isInitialized;\n+    private TAccumulate curAccumulator;\n+    private Enumerator<TSource> enumerator;\n+\n+    SortedAggregateEnumerator(\n+        Enumerable<TSource> enumerable,\n+        Function1<TSource, TKey> keySelector,\n+        Function0<TAccumulate> accumulatorInitializer,\n+        Function2<TAccumulate, TSource, TAccumulate> accumulatorAdder,\n+        final Function2<TKey, TAccumulate, TResult> resultSelector,\n+        final Comparator<TKey> comparator) {\n+      this.enumerable = enumerable;\n+      this.keySelector = keySelector;\n+      this.accumulatorInitializer = accumulatorInitializer;\n+      this.accumulatorAdder = accumulatorAdder;\n+      this.resultSelector = resultSelector;\n+      this.comparator = comparator;\n+      isInitialized = false;\n+      curAccumulator = null;\n+      enumerator = enumerable.enumerator();\n+    }\n+\n+    @Override public TResult current() {\n+      if (curAccumulator == null) {\n+        curAccumulator = accumulatorInitializer.apply();\n+      }\n+      TResult result = null;\n+      TSource o = enumerator.current();\n+      TKey prevKey = keySelector.apply(o);\n+      curAccumulator = accumulatorAdder.apply(curAccumulator, o);\n+      while (enumerator.moveNext()) {\n+        o = enumerator.current();\n+        TKey curKey = keySelector.apply(o);\n+        if (comparator.compare(prevKey, curKey) != 0) {\n+          // current key is different from previous key, get accumulated results and re-create\n+          // accumulator for current key.\n+          result = resultSelector.apply(prevKey, curAccumulator);\n+          curAccumulator = accumulatorInitializer.apply();\n+          break;\n+        } else {\n+          curAccumulator = accumulatorAdder.apply(curAccumulator, o);\n+        }\n+        prevKey = curKey;\n+      }\n+\n+      if (result == null) {\n+        // current key is the last key.\n+        result = resultSelector.apply(prevKey, curAccumulator);\n+        // no need to keep accumulator for the last key.\n+        curAccumulator = null;\n+      }\n+\n+      return result;\n+    }\n+\n+    @Override public boolean moveNext() {\n+      if (!isInitialized) {\n+        isInitialized = true;\n+        return enumerator.moveNext();\n+      } else {\n+        return curAccumulator != null;\n+      }\n+    }\n+\n+    @Override public void reset() {\n+      enumerator.reset();", "originalCommit": "71991f7985112f9cff2aaced0aa95cfc99e93971", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDY1NzQ3Mw==", "url": "https://github.com/apache/calcite/pull/2035#discussion_r444657473", "bodyText": "Done.", "author": "amaliujia", "createdAt": "2020-06-24T05:45:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ4NjYzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM1MjMyOA==", "url": "https://github.com/apache/calcite/pull/2035#discussion_r445352328", "bodyText": "I think we can remove the else, because there is a break at the end of the if block. IMO that would meake the code clearer.", "author": "rubenada", "createdAt": "2020-06-25T07:14:25Z", "path": "linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java", "diffHunk": "@@ -817,6 +817,132 @@ public void remove() {\n         resultSelector);\n   }\n \n+  /**\n+   * Group keys are sorted already. Key values are compared by using a\n+   * specified comparator. Groups the elements of a sequence according to a\n+   * specified key selector function and initializing one accumulator at a time.\n+   * Go over elements sequentially, adding to accumulator each time an element\n+   * with the same key is seen. When key changes, creates a result value from the\n+   * accumulator and then re-initializes the accumulator.\n+   */\n+  public static <TSource, TKey, TAccumulate, TResult> Enumerable<TResult> sortedGroupBy(\n+      Enumerable<TSource> enumerable,\n+      Function1<TSource, TKey> keySelector,\n+      Function0<TAccumulate> accumulatorInitializer,\n+      Function2<TAccumulate, TSource, TAccumulate> accumulatorAdder,\n+      final Function2<TKey, TAccumulate, TResult> resultSelector,\n+      final Comparator<TKey> comparator) {\n+    return new AbstractEnumerable<TResult>() {\n+      public Enumerator<TResult> enumerator() {\n+        return new SortedAggregateEnumerator(\n+          enumerable, keySelector, accumulatorInitializer,\n+          accumulatorAdder, resultSelector, comparator);\n+      }\n+    };\n+  }\n+\n+  private static class SortedAggregateEnumerator<TSource, TKey, TAccumulate, TResult>\n+      implements Enumerator<TResult> {\n+    private final Enumerable<TSource> enumerable;\n+    private final Function1<TSource, TKey> keySelector;\n+    private final Function0<TAccumulate> accumulatorInitializer;\n+    private final Function2<TAccumulate, TSource, TAccumulate> accumulatorAdder;\n+    private final Function2<TKey, TAccumulate, TResult> resultSelector;\n+    private final Comparator<TKey> comparator;\n+    private boolean isInitialized;\n+    private boolean isLastMoveNextFalse;\n+    private TAccumulate curAccumulator;\n+    private Enumerator<TSource> enumerator;\n+    private TResult curResult;\n+\n+    SortedAggregateEnumerator(\n+        Enumerable<TSource> enumerable,\n+        Function1<TSource, TKey> keySelector,\n+        Function0<TAccumulate> accumulatorInitializer,\n+        Function2<TAccumulate, TSource, TAccumulate> accumulatorAdder,\n+        final Function2<TKey, TAccumulate, TResult> resultSelector,\n+        final Comparator<TKey> comparator) {\n+      this.enumerable = enumerable;\n+      this.keySelector = keySelector;\n+      this.accumulatorInitializer = accumulatorInitializer;\n+      this.accumulatorAdder = accumulatorAdder;\n+      this.resultSelector = resultSelector;\n+      this.comparator = comparator;\n+      isInitialized = false;\n+      curAccumulator = null;\n+      enumerator = enumerable.enumerator();\n+      curResult = null;\n+      isLastMoveNextFalse = false;\n+    }\n+\n+    @Override public TResult current() {\n+      if (isLastMoveNextFalse) {\n+        throw new NoSuchElementException();\n+      }\n+      return curResult;\n+    }\n+\n+    @Override public boolean moveNext() {\n+      if (!isInitialized) {\n+        isInitialized = true;\n+        // input is empty\n+        if (!enumerator.moveNext()) {\n+          isLastMoveNextFalse = true;\n+          return false;\n+        }\n+      } else if (isInitialized && curAccumulator == null) {\n+        // input has been exhausted.\n+        isLastMoveNextFalse = true;\n+        return false;\n+      }\n+\n+      if (curAccumulator == null) {\n+        curAccumulator = accumulatorInitializer.apply();\n+      }\n+\n+      // reset result because now it can move to next aggregated result.\n+      curResult = null;\n+      TSource o = enumerator.current();\n+      TKey prevKey = keySelector.apply(o);\n+      curAccumulator = accumulatorAdder.apply(curAccumulator, o);\n+      while (enumerator.moveNext()) {\n+        o = enumerator.current();\n+        TKey curKey = keySelector.apply(o);\n+        if (comparator.compare(prevKey, curKey) != 0) {\n+          // current key is different from previous key, get accumulated results and re-create\n+          // accumulator for current key.\n+          curResult = resultSelector.apply(prevKey, curAccumulator);\n+          curAccumulator = accumulatorInitializer.apply();\n+          break;\n+        } else {", "originalCommit": "a25d8a03be0a67677d7c3492ac707430b83052ec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTczMzgyOA==", "url": "https://github.com/apache/calcite/pull/2035#discussion_r445733828", "bodyText": "Yes! Removed else", "author": "amaliujia", "createdAt": "2020-06-25T17:50:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM1MjMyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM1MzMxMQ==", "url": "https://github.com/apache/calcite/pull/2035#discussion_r445353311", "bodyText": "I think checking isInitialized in this line is redundant. At this point isInitialized will always be true (otherwise we would have went into the first if block).", "author": "rubenada", "createdAt": "2020-06-25T07:16:15Z", "path": "linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java", "diffHunk": "@@ -817,6 +817,132 @@ public void remove() {\n         resultSelector);\n   }\n \n+  /**\n+   * Group keys are sorted already. Key values are compared by using a\n+   * specified comparator. Groups the elements of a sequence according to a\n+   * specified key selector function and initializing one accumulator at a time.\n+   * Go over elements sequentially, adding to accumulator each time an element\n+   * with the same key is seen. When key changes, creates a result value from the\n+   * accumulator and then re-initializes the accumulator.\n+   */\n+  public static <TSource, TKey, TAccumulate, TResult> Enumerable<TResult> sortedGroupBy(\n+      Enumerable<TSource> enumerable,\n+      Function1<TSource, TKey> keySelector,\n+      Function0<TAccumulate> accumulatorInitializer,\n+      Function2<TAccumulate, TSource, TAccumulate> accumulatorAdder,\n+      final Function2<TKey, TAccumulate, TResult> resultSelector,\n+      final Comparator<TKey> comparator) {\n+    return new AbstractEnumerable<TResult>() {\n+      public Enumerator<TResult> enumerator() {\n+        return new SortedAggregateEnumerator(\n+          enumerable, keySelector, accumulatorInitializer,\n+          accumulatorAdder, resultSelector, comparator);\n+      }\n+    };\n+  }\n+\n+  private static class SortedAggregateEnumerator<TSource, TKey, TAccumulate, TResult>\n+      implements Enumerator<TResult> {\n+    private final Enumerable<TSource> enumerable;\n+    private final Function1<TSource, TKey> keySelector;\n+    private final Function0<TAccumulate> accumulatorInitializer;\n+    private final Function2<TAccumulate, TSource, TAccumulate> accumulatorAdder;\n+    private final Function2<TKey, TAccumulate, TResult> resultSelector;\n+    private final Comparator<TKey> comparator;\n+    private boolean isInitialized;\n+    private boolean isLastMoveNextFalse;\n+    private TAccumulate curAccumulator;\n+    private Enumerator<TSource> enumerator;\n+    private TResult curResult;\n+\n+    SortedAggregateEnumerator(\n+        Enumerable<TSource> enumerable,\n+        Function1<TSource, TKey> keySelector,\n+        Function0<TAccumulate> accumulatorInitializer,\n+        Function2<TAccumulate, TSource, TAccumulate> accumulatorAdder,\n+        final Function2<TKey, TAccumulate, TResult> resultSelector,\n+        final Comparator<TKey> comparator) {\n+      this.enumerable = enumerable;\n+      this.keySelector = keySelector;\n+      this.accumulatorInitializer = accumulatorInitializer;\n+      this.accumulatorAdder = accumulatorAdder;\n+      this.resultSelector = resultSelector;\n+      this.comparator = comparator;\n+      isInitialized = false;\n+      curAccumulator = null;\n+      enumerator = enumerable.enumerator();\n+      curResult = null;\n+      isLastMoveNextFalse = false;\n+    }\n+\n+    @Override public TResult current() {\n+      if (isLastMoveNextFalse) {\n+        throw new NoSuchElementException();\n+      }\n+      return curResult;\n+    }\n+\n+    @Override public boolean moveNext() {\n+      if (!isInitialized) {\n+        isInitialized = true;\n+        // input is empty\n+        if (!enumerator.moveNext()) {\n+          isLastMoveNextFalse = true;\n+          return false;\n+        }\n+      } else if (isInitialized && curAccumulator == null) {", "originalCommit": "a25d8a03be0a67677d7c3492ac707430b83052ec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTczNDEwNQ==", "url": "https://github.com/apache/calcite/pull/2035#discussion_r445734105", "bodyText": "Yes! Removed isInitialized. It indeed should be true after the first call of moveNext.", "author": "amaliujia", "createdAt": "2020-06-25T17:50:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTM1MzMxMQ=="}], "type": "inlineReview"}, {"oid": "55f335df7ac8b8ae31647cf0f16736aadff0b772", "url": "https://github.com/apache/calcite/commit/55f335df7ac8b8ae31647cf0f16736aadff0b772", "message": "[CALCITE-4008] Implement Code generation for EnumerableSortedAggregate (Rui Wang).", "committedDate": "2020-06-29T07:35:14Z", "type": "commit"}, {"oid": "55f335df7ac8b8ae31647cf0f16736aadff0b772", "url": "https://github.com/apache/calcite/commit/55f335df7ac8b8ae31647cf0f16736aadff0b772", "message": "[CALCITE-4008] Implement Code generation for EnumerableSortedAggregate (Rui Wang).", "committedDate": "2020-06-29T07:35:14Z", "type": "forcePushed"}]}