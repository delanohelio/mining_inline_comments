{"pr_number": 2109, "pr_title": "[CALCITE-3920] Improve ORDER BY computation in Enumerable convention by exploiting LIMIT", "pr_createdAt": "2020-08-13T10:23:18Z", "pr_url": "https://github.com/apache/calcite/pull/2109", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkzNDQ5Nw==", "url": "https://github.com/apache/calcite/pull/2109#discussion_r469934497", "bodyText": "minor: for consistency reasons inside this method, please declare all variables as \"final\" (if they are effectively final)", "author": "rubenada", "createdAt": "2020-08-13T13:03:39Z", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableLimitSort.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.adapter.enumerable;\n+\n+import org.apache.calcite.linq4j.tree.BlockBuilder;\n+import org.apache.calcite.linq4j.tree.Expression;\n+import org.apache.calcite.linq4j.tree.Expressions;\n+import org.apache.calcite.plan.RelOptCluster;\n+import org.apache.calcite.plan.RelOptCost;\n+import org.apache.calcite.plan.RelOptPlanner;\n+import org.apache.calcite.plan.RelTraitSet;\n+import org.apache.calcite.rel.RelCollation;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.core.Sort;\n+import org.apache.calcite.rel.metadata.RelMetadataQuery;\n+import org.apache.calcite.rex.RexLiteral;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.util.BuiltInMethod;\n+import org.apache.calcite.util.Pair;\n+\n+import static org.apache.calcite.adapter.enumerable.EnumerableLimit.getExpression;\n+\n+/**\n+ * Implementation of {@link org.apache.calcite.rel.core.Sort} in\n+ * {@link org.apache.calcite.adapter.enumerable.EnumerableConvention enumerable calling convention}.\n+ * It optimizes sorts that have a limit and an optional offset.\n+ */\n+public class EnumerableLimitSort extends Sort implements EnumerableRel {\n+\n+  /**\n+   * Creates an EnumerableLimitSort.\n+   *\n+   * <p>Use {@link #create} unless you know what you're doing.\n+   */\n+  public EnumerableLimitSort(\n+      RelOptCluster cluster,\n+      RelTraitSet traitSet,\n+      RelNode input,\n+      RelCollation collation,\n+      RexNode offset,\n+      RexNode fetch) {\n+    super(cluster, traitSet, input, collation, offset, fetch);\n+    assert this.getConvention() instanceof EnumerableConvention;\n+    assert this.getConvention() == input.getConvention();\n+  }\n+\n+  /** Creates an EnumerableLimitSort. */\n+  public static EnumerableLimitSort create(\n+      RelNode input,\n+      RelCollation collation,\n+      RexNode offset,\n+      RexNode fetch) {\n+    final RelOptCluster cluster = input.getCluster();\n+    final RelTraitSet traitSet = cluster.traitSetOf(EnumerableConvention.INSTANCE).replace(\n+        collation);\n+    return new EnumerableLimitSort(cluster, traitSet, input, collation, offset, fetch);\n+  }\n+\n+  @Override public EnumerableLimitSort copy(\n+      RelTraitSet traitSet,\n+      RelNode newInput,\n+      RelCollation newCollation,\n+      RexNode offset,\n+      RexNode fetch) {\n+    return new EnumerableLimitSort(\n+        this.getCluster(),\n+        traitSet,\n+        newInput,\n+        newCollation,\n+        offset,\n+        fetch);\n+  }\n+\n+  @Override public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n+    final BlockBuilder builder = new BlockBuilder();\n+    final EnumerableRel child = (EnumerableRel) this.getInput();\n+    final Result result = implementor.visitChild(this, 0, child, pref);\n+    final PhysType physType = PhysTypeImpl.of(\n+        implementor.getTypeFactory(),\n+        this.getRowType(),\n+        result.format);\n+    Expression childExp = builder.append(\"child\", result.block);", "originalCommit": "a777643adb49dcaf3c31066ec40e08a55e529c72", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkzODAyNA==", "url": "https://github.com/apache/calcite/pull/2109#discussion_r469938024", "bodyText": "Inside implement method you allow this.fetch to be a dynamic parameter; however here (computeSelfCost) you assume it will be a RexLiteral (I have the impression that arriving at this point with a RexDynamicParam will throw an exception).\nEither we modify cost computation (but it will be impossible to give a precise cost in case of dynamic parameter); or to simplify things we could decide that EnumerableLimitSort only supports fetch (and offset) in the form of RexLiteral (and adapt EnumerableLimitSortRule accordingly).", "author": "rubenada", "createdAt": "2020-08-13T13:09:11Z", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableLimitSort.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.adapter.enumerable;\n+\n+import org.apache.calcite.linq4j.tree.BlockBuilder;\n+import org.apache.calcite.linq4j.tree.Expression;\n+import org.apache.calcite.linq4j.tree.Expressions;\n+import org.apache.calcite.plan.RelOptCluster;\n+import org.apache.calcite.plan.RelOptCost;\n+import org.apache.calcite.plan.RelOptPlanner;\n+import org.apache.calcite.plan.RelTraitSet;\n+import org.apache.calcite.rel.RelCollation;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.core.Sort;\n+import org.apache.calcite.rel.metadata.RelMetadataQuery;\n+import org.apache.calcite.rex.RexLiteral;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.util.BuiltInMethod;\n+import org.apache.calcite.util.Pair;\n+\n+import static org.apache.calcite.adapter.enumerable.EnumerableLimit.getExpression;\n+\n+/**\n+ * Implementation of {@link org.apache.calcite.rel.core.Sort} in\n+ * {@link org.apache.calcite.adapter.enumerable.EnumerableConvention enumerable calling convention}.\n+ * It optimizes sorts that have a limit and an optional offset.\n+ */\n+public class EnumerableLimitSort extends Sort implements EnumerableRel {\n+\n+  /**\n+   * Creates an EnumerableLimitSort.\n+   *\n+   * <p>Use {@link #create} unless you know what you're doing.\n+   */\n+  public EnumerableLimitSort(\n+      RelOptCluster cluster,\n+      RelTraitSet traitSet,\n+      RelNode input,\n+      RelCollation collation,\n+      RexNode offset,\n+      RexNode fetch) {\n+    super(cluster, traitSet, input, collation, offset, fetch);\n+    assert this.getConvention() instanceof EnumerableConvention;\n+    assert this.getConvention() == input.getConvention();\n+  }\n+\n+  /** Creates an EnumerableLimitSort. */\n+  public static EnumerableLimitSort create(\n+      RelNode input,\n+      RelCollation collation,\n+      RexNode offset,\n+      RexNode fetch) {\n+    final RelOptCluster cluster = input.getCluster();\n+    final RelTraitSet traitSet = cluster.traitSetOf(EnumerableConvention.INSTANCE).replace(\n+        collation);\n+    return new EnumerableLimitSort(cluster, traitSet, input, collation, offset, fetch);\n+  }\n+\n+  @Override public EnumerableLimitSort copy(\n+      RelTraitSet traitSet,\n+      RelNode newInput,\n+      RelCollation newCollation,\n+      RexNode offset,\n+      RexNode fetch) {\n+    return new EnumerableLimitSort(\n+        this.getCluster(),\n+        traitSet,\n+        newInput,\n+        newCollation,\n+        offset,\n+        fetch);\n+  }\n+\n+  @Override public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n+    final BlockBuilder builder = new BlockBuilder();\n+    final EnumerableRel child = (EnumerableRel) this.getInput();\n+    final Result result = implementor.visitChild(this, 0, child, pref);\n+    final PhysType physType = PhysTypeImpl.of(\n+        implementor.getTypeFactory(),\n+        this.getRowType(),\n+        result.format);\n+    Expression childExp = builder.append(\"child\", result.block);\n+\n+    PhysType inputPhysType = result.physType;\n+    final Pair<Expression, Expression> pair =\n+        inputPhysType.generateCollationKey(this.collation.getFieldCollations());\n+\n+    Expression fetchVal;\n+    if (this.fetch == null) {\n+      fetchVal = Expressions.constant(Integer.valueOf(Integer.MAX_VALUE));\n+    } else {\n+      fetchVal = getExpression(this.fetch);\n+    }\n+\n+    Expression offsetVal = this.offset == null ? Expressions.constant(Integer.valueOf(0))\n+        : getExpression(this.offset);\n+\n+    builder.add(\n+        Expressions.return_(\n+            null, Expressions.call(\n+                BuiltInMethod.ORDER_BY_WITH_FETCH_AND_OFFSET.method, Expressions.list(\n+                    childExp,\n+                    builder.append(\"keySelector\", pair.left))\n+                    .appendIfNotNull(builder.appendIfNotNull(\"comparator\", pair.right))\n+                    .appendIfNotNull(\n+                        builder.appendIfNotNull(\"offset\",\n+                            Expressions.constant(offsetVal)))\n+                    .appendIfNotNull(\n+                        builder.appendIfNotNull(\"fetch\",\n+                            Expressions.constant(fetchVal)))\n+            )));\n+    return implementor.result(physType, builder.toBlock());\n+  }\n+\n+  @Override public RelOptCost computeSelfCost(RelOptPlanner planner, RelMetadataQuery mq) {\n+    final double rowCount = mq.getRowCount(this.input).doubleValue();\n+    double toSort = this.fetch == null ? rowCount : RexLiteral.intValue(this.fetch);", "originalCommit": "a777643adb49dcaf3c31066ec40e08a55e529c72", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjEzMjY3Mw==", "url": "https://github.com/apache/calcite/pull/2109#discussion_r472132673", "bodyText": "I've modified the cost, so that it falls back to the row count if there are dynamic parameters", "author": "thomasrebele", "createdAt": "2020-08-18T12:16:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkzODAyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk0MjUxNg==", "url": "https://github.com/apache/calcite/pull/2109#discussion_r469942516", "bodyText": "this if condition looks wrong/useless", "author": "rubenada", "createdAt": "2020-08-13T13:15:59Z", "path": "linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java", "diffHunk": "@@ -2624,6 +2624,86 @@ public static boolean isMergeJoinSupported(JoinType joinType) {\n     };\n   }\n \n+\n+  /**\n+   * A sort implementation optimized for a sort with a fetch size (LIMIT).\n+   * @param offset how many rows are skipped from the sorted output.\n+   *               Must be greater than or equal to 0.\n+   * @param fetch how many rows are retrieved. Must be greater than 0.\n+   */\n+  public static <TSource, TKey> Enumerable<TSource> orderBy(\n+      Enumerable<TSource> source,\n+      Function1<TSource, TKey> keySelector,\n+      Comparator<TKey> comparator,\n+      int offset, int fetch) {\n+    return new AbstractEnumerable<TSource>() {\n+      @Override public Enumerator<TSource> enumerator() {\n+        TreeMap<TKey, List<TSource>> map = new TreeMap<>(comparator);\n+        long size = 0;\n+        long needed = fetch + offset;\n+\n+        try (Enumerator<TSource> os = source.enumerator()) {\n+          while (os.moveNext()) {\n+            TSource o = os.current();\n+            TKey key = keySelector.apply(o);\n+            if (needed >= 0 && size >= needed) {\n+              if (comparator.compare(key, map.lastKey()) >= 0) {\n+                continue;\n+              }\n+              // remove last entry from tree map\n+              List<TSource> l = map.get(map.lastKey());\n+              if (l.size() == 1) {\n+                map.remove(map.lastKey());\n+              } else {\n+                l.remove(l.size() - 1);\n+              }\n+              size--;\n+            }\n+            map.compute(key, (k, l) -> {\n+              if (l == null) {\n+                return Collections.singletonList(o);\n+              }\n+              if (l.size() == 1) {\n+                l = new ArrayList<>(l);\n+              }\n+              l.add(o);\n+              return l;\n+            });\n+            size++;\n+          }\n+        }\n+\n+        if (offset > 0) {\n+          // search until which key we have to remove entries from the map\n+          int skipped = 0;\n+          TKey until = null;\n+          for (Map.Entry<TKey, List<TSource>> e : map.entrySet()) {\n+            skipped += e.getValue().size();\n+\n+            if (skipped > offset) {\n+              // we might need to remove entries from the list\n+              List<TSource> l = e.getValue();\n+              int toKeep = skipped - offset;\n+              if (toKeep < l.size()) {\n+                l.subList(0, l.size() - toKeep).clear();\n+              }\n+\n+              until = e.getKey();\n+              break;\n+            }\n+          }\n+          if (until == null) {\n+            return Linq4j.emptyEnumerator();\n+          } else if (until != null) {", "originalCommit": "a777643adb49dcaf3c31066ec40e08a55e529c72", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk0OTQ3MA==", "url": "https://github.com/apache/calcite/pull/2109#discussion_r469949470", "bodyText": "also, since we have a return inside the previous if, I think we could just remove the else", "author": "rubenada", "createdAt": "2020-08-13T13:26:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk0MjUxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk1MjI0OQ==", "url": "https://github.com/apache/calcite/pull/2109#discussion_r469952249", "bodyText": "minor: maybe adding here the same comment that we have in toLookup_ to explain the choice of List implementation?\n// for first entry, use a singleton list to save space\n// when we go from 1 to 2 elements, switch to array list", "author": "rubenada", "createdAt": "2020-08-13T13:30:48Z", "path": "linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java", "diffHunk": "@@ -2624,6 +2624,86 @@ public static boolean isMergeJoinSupported(JoinType joinType) {\n     };\n   }\n \n+\n+  /**\n+   * A sort implementation optimized for a sort with a fetch size (LIMIT).\n+   * @param offset how many rows are skipped from the sorted output.\n+   *               Must be greater than or equal to 0.\n+   * @param fetch how many rows are retrieved. Must be greater than 0.\n+   */\n+  public static <TSource, TKey> Enumerable<TSource> orderBy(\n+      Enumerable<TSource> source,\n+      Function1<TSource, TKey> keySelector,\n+      Comparator<TKey> comparator,\n+      int offset, int fetch) {\n+    return new AbstractEnumerable<TSource>() {\n+      @Override public Enumerator<TSource> enumerator() {\n+        TreeMap<TKey, List<TSource>> map = new TreeMap<>(comparator);\n+        long size = 0;\n+        long needed = fetch + offset;\n+\n+        try (Enumerator<TSource> os = source.enumerator()) {\n+          while (os.moveNext()) {\n+            TSource o = os.current();\n+            TKey key = keySelector.apply(o);\n+            if (needed >= 0 && size >= needed) {\n+              if (comparator.compare(key, map.lastKey()) >= 0) {\n+                continue;\n+              }\n+              // remove last entry from tree map\n+              List<TSource> l = map.get(map.lastKey());\n+              if (l.size() == 1) {\n+                map.remove(map.lastKey());\n+              } else {\n+                l.remove(l.size() - 1);\n+              }\n+              size--;\n+            }\n+            map.compute(key, (k, l) -> {\n+              if (l == null) {\n+                return Collections.singletonList(o);", "originalCommit": "a777643adb49dcaf3c31066ec40e08a55e529c72", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI3NDczMg==", "url": "https://github.com/apache/calcite/pull/2109#discussion_r470274732", "bodyText": "+1. I was also looking for some comments to explain the algorithm briefly.", "author": "amaliujia", "createdAt": "2020-08-13T22:05:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk1MjI0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjEzNDAxNg==", "url": "https://github.com/apache/calcite/pull/2109#discussion_r472134016", "bodyText": "@amaliujia, do you mean that I should add some comments that explain the implementation of the new orderBy method.", "author": "thomasrebele", "createdAt": "2020-08-18T12:18:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk1MjI0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjY2MTkwOQ==", "url": "https://github.com/apache/calcite/pull/2109#discussion_r472661909", "bodyText": "Yes.\nOr you can link the JIRA but update the JIRA with the final detailed algorithm you have chosen.\nI found the JIRA has many discussions so was confused on which algorithm you finally chose, until I read the implementation here :). Something to help people understand the implementation directly in the future will be very helpful.", "author": "amaliujia", "createdAt": "2020-08-19T04:03:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk1MjI0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg1OTc2NQ==", "url": "https://github.com/apache/calcite/pull/2109#discussion_r472859765", "bodyText": "I've added an explanation at the beginning and more comments in the actual code to make the algorithm easier to understand.", "author": "thomasrebele", "createdAt": "2020-08-19T08:36:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk1MjI0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI2ODkzOA==", "url": "https://github.com/apache/calcite/pull/2109#discussion_r470268938", "bodyText": "remove the extra //", "author": "amaliujia", "createdAt": "2020-08-13T21:50:31Z", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableLimitSortRule.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.adapter.enumerable;\n+\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.plan.RelRule;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.core.Sort;\n+import org.apache.calcite.rel.logical.LogicalSort;\n+\n+/**\n+ * Rule to convert an {@link EnumerableLimit} of on\n+ * {@link EnumerableSort} into an {@link EnumerableLimitSort}.\n+ */\n+public class EnumerableLimitSortRule extends RelRule<EnumerableLimitSortRule.Config> {\n+\n+  /**\n+   * Creates a EnumerableLimitSortRule.\n+   */\n+  public EnumerableLimitSortRule(Config config) {\n+    super(config);\n+  }\n+\n+  @Override public void onMatch(RelOptRuleCall call) {\n+    final LogicalSort sort = call.rel(0);\n+    RelNode input = sort.getInput();\n+    final Sort o = EnumerableLimitSort.create(//", "originalCommit": "a777643adb49dcaf3c31066ec40e08a55e529c72", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI3MTIzNg==", "url": "https://github.com/apache/calcite/pull/2109#discussion_r470271236", "bodyText": "Out of curiosity: why do you decide to extend Sort?", "author": "amaliujia", "createdAt": "2020-08-13T21:56:04Z", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableLimitSort.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.adapter.enumerable;\n+\n+import org.apache.calcite.linq4j.tree.BlockBuilder;\n+import org.apache.calcite.linq4j.tree.Expression;\n+import org.apache.calcite.linq4j.tree.Expressions;\n+import org.apache.calcite.plan.RelOptCluster;\n+import org.apache.calcite.plan.RelOptCost;\n+import org.apache.calcite.plan.RelOptPlanner;\n+import org.apache.calcite.plan.RelTraitSet;\n+import org.apache.calcite.rel.RelCollation;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.core.Sort;\n+import org.apache.calcite.rel.metadata.RelMetadataQuery;\n+import org.apache.calcite.rex.RexLiteral;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.util.BuiltInMethod;\n+import org.apache.calcite.util.Pair;\n+\n+import static org.apache.calcite.adapter.enumerable.EnumerableLimit.getExpression;\n+\n+/**\n+ * Implementation of {@link org.apache.calcite.rel.core.Sort} in\n+ * {@link org.apache.calcite.adapter.enumerable.EnumerableConvention enumerable calling convention}.\n+ * It optimizes sorts that have a limit and an optional offset.\n+ */\n+public class EnumerableLimitSort extends Sort implements EnumerableRel {", "originalCommit": "a777643adb49dcaf3c31066ec40e08a55e529c72", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjEzNTIyNA==", "url": "https://github.com/apache/calcite/pull/2109#discussion_r472135224", "bodyText": "For the same reason that EnumerableSort extends Sort. I guess it is because both classes provide an implementation of a Sort algorithm.", "author": "thomasrebele", "createdAt": "2020-08-18T12:21:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI3MTIzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI3MjYyOQ==", "url": "https://github.com/apache/calcite/pull/2109#discussion_r470272629", "bodyText": "Do you need\n            EnumerableRules.ENUMERABLE_SORT_RULE,\n            EnumerableRules.ENUMERABLE_LIMIT_RULE,\n\nas you have listed EnumerableRules.ENUMERABLE_LIMIT_SORT_RULE in the list?", "author": "amaliujia", "createdAt": "2020-08-13T21:59:40Z", "path": "core/src/test/java/org/apache/calcite/test/RelOptRulesTest.java", "diffHunk": "@@ -1039,6 +1039,54 @@ private void basePushFilterPastAggWithGroupingSets(boolean unchanged) {\n         .check();\n   }\n \n+  /**\n+   * Test if limit and sort are replaced by a limit sort.\n+   * Test case for\n+   * <a href=\"https://issues.apache.org/jira/browse/CALCITE-3920\">[CALCITE-3920]\n+   * Improve ORDER BY computation in Enumerable convention by exploiting LIMIT</a>.\n+   */\n+  @Test void testLimitSort() {\n+    final String sql = \"select mgr from sales.emp\\n\"\n+        + \"union select mgr from sales.emp\\n\"\n+        + \"order by mgr limit 10 offset 5\";\n+\n+    VolcanoPlanner planner = new VolcanoPlanner(null, null);\n+    planner.addRelTraitDef(ConventionTraitDef.INSTANCE);\n+    RelOptUtil.registerDefaultRules(planner, false, false);\n+    planner.addRule(EnumerableRules.ENUMERABLE_LIMIT_SORT_RULE);\n+\n+    Tester tester = createTester().withDecorrelation(true)\n+        .withClusterFactory(\n+            relOptCluster -> RelOptCluster.create(planner, relOptCluster.getRexBuilder()));\n+\n+    RelRoot root = tester.convertSqlToRel(sql);\n+\n+    String planBefore = NL + RelOptUtil.toString(root.rel);\n+    getDiffRepos().assertEquals(\"planBefore\", \"${planBefore}\", planBefore);\n+\n+    RuleSet ruleSet =\n+        RuleSets.ofList(\n+            EnumerableRules.ENUMERABLE_SORT_RULE,\n+            EnumerableRules.ENUMERABLE_LIMIT_RULE,\n+            EnumerableRules.ENUMERABLE_LIMIT_SORT_RULE,", "originalCommit": "a777643adb49dcaf3c31066ec40e08a55e529c72", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjEzNTg3MQ==", "url": "https://github.com/apache/calcite/pull/2109#discussion_r472135871", "bodyText": "Yes, to check whether the new operator is chosen correctly. A plan with EnumerableLimit(EnumerableSort(...)) should have a higher cost.", "author": "thomasrebele", "createdAt": "2020-08-18T12:22:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI3MjYyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjY2MzExMQ==", "url": "https://github.com/apache/calcite/pull/2109#discussion_r472663111", "bodyText": "Thanks for your clarification!", "author": "amaliujia", "createdAt": "2020-08-19T04:05:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI3MjYyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI3NjA3Nw==", "url": "https://github.com/apache/calcite/pull/2109#discussion_r470276077", "bodyText": "Does it make sense to name this function as topNOrderBy or topNSortLimit?", "author": "amaliujia", "createdAt": "2020-08-13T22:08:36Z", "path": "linq4j/src/main/java/org/apache/calcite/linq4j/EnumerableDefaults.java", "diffHunk": "@@ -2624,6 +2624,86 @@ public static boolean isMergeJoinSupported(JoinType joinType) {\n     };\n   }\n \n+\n+  /**\n+   * A sort implementation optimized for a sort with a fetch size (LIMIT).\n+   * @param offset how many rows are skipped from the sorted output.\n+   *               Must be greater than or equal to 0.\n+   * @param fetch how many rows are retrieved. Must be greater than 0.\n+   */\n+  public static <TSource, TKey> Enumerable<TSource> orderBy(", "originalCommit": "a777643adb49dcaf3c31066ec40e08a55e529c72", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjEzNjU1OQ==", "url": "https://github.com/apache/calcite/pull/2109#discussion_r472136559", "bodyText": "Might make sense, I'm not yet familiar how the Calcite project chooses names.", "author": "thomasrebele", "createdAt": "2020-08-18T12:23:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI3NjA3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjE0MTQ0Nw==", "url": "https://github.com/apache/calcite/pull/2109#discussion_r472141447", "bodyText": "Since the limit parameter is \"optional\" (it can take Integer.MAX_VALUE if fetch is null in EnumerableLimitSort, I think the current method name is ok.", "author": "rubenada", "createdAt": "2020-08-18T12:32:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI3NjA3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjY2MzM0Ng==", "url": "https://github.com/apache/calcite/pull/2109#discussion_r472663346", "bodyText": "I see. That makes sense.", "author": "amaliujia", "createdAt": "2020-08-19T04:05:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI3NjA3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI3NjQ5Mg==", "url": "https://github.com/apache/calcite/pull/2109#discussion_r470276492", "bodyText": "Why not use max?", "author": "amaliujia", "createdAt": "2020-08-13T22:09:40Z", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableLimitSort.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.adapter.enumerable;\n+\n+import org.apache.calcite.linq4j.tree.BlockBuilder;\n+import org.apache.calcite.linq4j.tree.Expression;\n+import org.apache.calcite.linq4j.tree.Expressions;\n+import org.apache.calcite.plan.RelOptCluster;\n+import org.apache.calcite.plan.RelOptCost;\n+import org.apache.calcite.plan.RelOptPlanner;\n+import org.apache.calcite.plan.RelTraitSet;\n+import org.apache.calcite.rel.RelCollation;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.core.Sort;\n+import org.apache.calcite.rel.metadata.RelMetadataQuery;\n+import org.apache.calcite.rex.RexLiteral;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.util.BuiltInMethod;\n+import org.apache.calcite.util.Pair;\n+\n+import static org.apache.calcite.adapter.enumerable.EnumerableLimit.getExpression;\n+\n+/**\n+ * Implementation of {@link org.apache.calcite.rel.core.Sort} in\n+ * {@link org.apache.calcite.adapter.enumerable.EnumerableConvention enumerable calling convention}.\n+ * It optimizes sorts that have a limit and an optional offset.\n+ */\n+public class EnumerableLimitSort extends Sort implements EnumerableRel {\n+\n+  /**\n+   * Creates an EnumerableLimitSort.\n+   *\n+   * <p>Use {@link #create} unless you know what you're doing.\n+   */\n+  public EnumerableLimitSort(\n+      RelOptCluster cluster,\n+      RelTraitSet traitSet,\n+      RelNode input,\n+      RelCollation collation,\n+      RexNode offset,\n+      RexNode fetch) {\n+    super(cluster, traitSet, input, collation, offset, fetch);\n+    assert this.getConvention() instanceof EnumerableConvention;\n+    assert this.getConvention() == input.getConvention();\n+  }\n+\n+  /** Creates an EnumerableLimitSort. */\n+  public static EnumerableLimitSort create(\n+      RelNode input,\n+      RelCollation collation,\n+      RexNode offset,\n+      RexNode fetch) {\n+    final RelOptCluster cluster = input.getCluster();\n+    final RelTraitSet traitSet = cluster.traitSetOf(EnumerableConvention.INSTANCE).replace(\n+        collation);\n+    return new EnumerableLimitSort(cluster, traitSet, input, collation, offset, fetch);\n+  }\n+\n+  @Override public EnumerableLimitSort copy(\n+      RelTraitSet traitSet,\n+      RelNode newInput,\n+      RelCollation newCollation,\n+      RexNode offset,\n+      RexNode fetch) {\n+    return new EnumerableLimitSort(\n+        this.getCluster(),\n+        traitSet,\n+        newInput,\n+        newCollation,\n+        offset,\n+        fetch);\n+  }\n+\n+  @Override public Result implement(EnumerableRelImplementor implementor, Prefer pref) {\n+    final BlockBuilder builder = new BlockBuilder();\n+    final EnumerableRel child = (EnumerableRel) this.getInput();\n+    final Result result = implementor.visitChild(this, 0, child, pref);\n+    final PhysType physType = PhysTypeImpl.of(\n+        implementor.getTypeFactory(),\n+        this.getRowType(),\n+        result.format);\n+    Expression childExp = builder.append(\"child\", result.block);\n+\n+    PhysType inputPhysType = result.physType;\n+    final Pair<Expression, Expression> pair =\n+        inputPhysType.generateCollationKey(this.collation.getFieldCollations());\n+\n+    Expression fetchVal;\n+    if (this.fetch == null) {\n+      fetchVal = Expressions.constant(Integer.valueOf(Integer.MAX_VALUE));\n+    } else {\n+      fetchVal = getExpression(this.fetch);\n+    }\n+\n+    Expression offsetVal = this.offset == null ? Expressions.constant(Integer.valueOf(0))\n+        : getExpression(this.offset);\n+\n+    builder.add(\n+        Expressions.return_(\n+            null, Expressions.call(\n+                BuiltInMethod.ORDER_BY_WITH_FETCH_AND_OFFSET.method, Expressions.list(\n+                    childExp,\n+                    builder.append(\"keySelector\", pair.left))\n+                    .appendIfNotNull(builder.appendIfNotNull(\"comparator\", pair.right))\n+                    .appendIfNotNull(\n+                        builder.appendIfNotNull(\"offset\",\n+                            Expressions.constant(offsetVal)))\n+                    .appendIfNotNull(\n+                        builder.appendIfNotNull(\"fetch\",\n+                            Expressions.constant(fetchVal)))\n+            )));\n+    return implementor.result(physType, builder.toBlock());\n+  }\n+\n+  @Override public RelOptCost computeSelfCost(RelOptPlanner planner, RelMetadataQuery mq) {\n+    final double rowCount = mq.getRowCount(this.input).doubleValue();\n+    double toSort = this.fetch == null ? rowCount : RexLiteral.intValue(this.fetch);\n+    if (this.offset != null) {\n+      toSort += RexLiteral.intValue(this.offset);\n+    }\n+    toSort = Math.min(rowCount, toSort);", "originalCommit": "a777643adb49dcaf3c31066ec40e08a55e529c72", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjEzODI5OQ==", "url": "https://github.com/apache/calcite/pull/2109#discussion_r472138299", "bodyText": "If there are only rowCount rows, we only need to sort that many. E.g., if fetch is 100, but there are only 10 rows in the input, we only need to do lookups for the 10 rows.", "author": "thomasrebele", "createdAt": "2020-08-18T12:26:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI3NjQ5Mg=="}], "type": "inlineReview"}, {"oid": "acc1b44c9e466d4e2603b98389a89120818797c2", "url": "https://github.com/apache/calcite/commit/acc1b44c9e466d4e2603b98389a89120818797c2", "message": "[CALCITE-3920] Improve ORDER BY computation in Enumerable convention by exploiting LIMIT", "committedDate": "2020-08-18T10:48:42Z", "type": "forcePushed"}, {"oid": "d92beec74a043aad5807c154bef5062bab1074ca", "url": "https://github.com/apache/calcite/commit/d92beec74a043aad5807c154bef5062bab1074ca", "message": "[CALCITE-3920] Improve ORDER BY computation in Enumerable convention by exploiting LIMIT", "committedDate": "2020-08-18T10:49:29Z", "type": "forcePushed"}, {"oid": "de5200dd34f0e9997a4440b63ca1c0d25af97b18", "url": "https://github.com/apache/calcite/commit/de5200dd34f0e9997a4440b63ca1c0d25af97b18", "message": "[CALCITE-3920] Improve ORDER BY computation in Enumerable convention by exploiting LIMIT", "committedDate": "2020-08-19T08:34:38Z", "type": "forcePushed"}, {"oid": "18942d77a1ec9c18a6a8e3aaf3f4f5cebad3e21f", "url": "https://github.com/apache/calcite/commit/18942d77a1ec9c18a6a8e3aaf3f4f5cebad3e21f", "message": "[CALCITE-3920] Improve ORDER BY computation in Enumerable convention by exploiting LIMIT", "committedDate": "2020-09-02T09:53:44Z", "type": "forcePushed"}, {"oid": "a809ca073b14443b643c39002155a9802bb1fe19", "url": "https://github.com/apache/calcite/commit/a809ca073b14443b643c39002155a9802bb1fe19", "message": "[CALCITE-3920] Improve ORDER BY computation in Enumerable convention by exploiting LIMIT", "committedDate": "2020-09-02T10:32:05Z", "type": "forcePushed"}, {"oid": "2507ea29b223eaaa59663774a151c445510d683f", "url": "https://github.com/apache/calcite/commit/2507ea29b223eaaa59663774a151c445510d683f", "message": "[CALCITE-3920] Improve ORDER BY computation in Enumerable convention by exploiting LIMIT", "committedDate": "2020-09-02T11:58:56Z", "type": "forcePushed"}, {"oid": "01b38c4545ba272329ec3565c961cc28484e6494", "url": "https://github.com/apache/calcite/commit/01b38c4545ba272329ec3565c961cc28484e6494", "message": "[CALCITE-3920] Improve ORDER BY computation in Enumerable convention by exploiting LIMIT (Thomas Rebele)", "committedDate": "2020-09-02T12:30:36Z", "type": "commit"}, {"oid": "01b38c4545ba272329ec3565c961cc28484e6494", "url": "https://github.com/apache/calcite/commit/01b38c4545ba272329ec3565c961cc28484e6494", "message": "[CALCITE-3920] Improve ORDER BY computation in Enumerable convention by exploiting LIMIT (Thomas Rebele)", "committedDate": "2020-09-02T12:30:36Z", "type": "forcePushed"}]}