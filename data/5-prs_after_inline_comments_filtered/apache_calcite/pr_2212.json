{"pr_number": 2212, "pr_title": "[CALCITE-4325] RexSimplify incorrectly simplifies complex expressions that contain Sarg and IS NULL", "pr_createdAt": "2020-10-13T22:29:12Z", "pr_url": "https://github.com/apache/calcite/pull/2212", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDI5NzcxMA==", "url": "https://github.com/apache/calcite/pull/2212#discussion_r504297710", "bodyText": "Should this be int complexity = rangeSet.asRanges().size(), and then if (...) { complexity = 1;}?", "author": "vlsi", "createdAt": "2020-10-13T22:36:34Z", "path": "core/src/main/java/org/apache/calcite/util/Sarg.java", "diffHunk": "@@ -149,4 +150,33 @@ public boolean isComplementedPoints() {\n         && rangeSet.complement().asRanges().stream()\n             .allMatch(RangeSets::isPoint);\n   }\n+\n+  /** Returns a measure of the complexity of this expression.\n+   *\n+   * <p>It is basically the number of values that need to be checked against\n+   * (including NULL).\n+   *\n+   * <p>Examples:\n+   * <ul>\n+   *   <li>{@code x = 1}, {@code x <> 1}, {@code x > 1} have complexity 1\n+   *   <li>{@code x > 1 or x is null} has complexity 2\n+   *   <li>{@code x in (2, 4, 6) or x > 20} has complexity 4\n+   *   <li>{@code x between 3 and 8 or x between 10 and 20} has complexity 2\n+   * </ul>\n+   */\n+  public int complexity() {\n+    int complexity;\n+    if (rangeSet.asRanges().size() == 2\n+        && rangeSet.complement().asRanges().size() == 1\n+        && RangeSets.isPoint(\n+            Iterables.getOnlyElement(rangeSet.complement().asRanges()))) {\n+      complexity = 1;\n+    } else {\n+      complexity = rangeSet.asRanges().size();", "originalCommit": "ecf7a8d25157dda11f6c295b066f9337076e5c5b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDMwMDg3Mw==", "url": "https://github.com/apache/calcite/pull/2212#discussion_r504300873", "bodyText": "It's a matter of taste. I prefer not to re-assign variables.", "author": "julianhyde", "createdAt": "2020-10-13T22:45:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDI5NzcxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDMwNjI0Ng==", "url": "https://github.com/apache/calcite/pull/2212#discussion_r504306246", "bodyText": "Then please avoid re-computing the same things again and again.\nIt is hard to review and analyze how these .asRanges().size() differ.", "author": "vlsi", "createdAt": "2020-10-13T23:00:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDI5NzcxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDMwNzA2Mw==", "url": "https://github.com/apache/calcite/pull/2212#discussion_r504307063", "bodyText": "Is this computation important for something?\nPlease add the relevant comment: if it is important, then clarify so. If it is just a fine detail, then comment so. The intention behind the conditions is not really visible.", "author": "vlsi", "createdAt": "2020-10-13T23:02:52Z", "path": "core/src/main/java/org/apache/calcite/util/Sarg.java", "diffHunk": "@@ -149,4 +150,33 @@ public boolean isComplementedPoints() {\n         && rangeSet.complement().asRanges().stream()\n             .allMatch(RangeSets::isPoint);\n   }\n+\n+  /** Returns a measure of the complexity of this expression.\n+   *\n+   * <p>It is basically the number of values that need to be checked against\n+   * (including NULL).\n+   *\n+   * <p>Examples:\n+   * <ul>\n+   *   <li>{@code x = 1}, {@code x <> 1}, {@code x > 1} have complexity 1\n+   *   <li>{@code x > 1 or x is null} has complexity 2\n+   *   <li>{@code x in (2, 4, 6) or x > 20} has complexity 4\n+   *   <li>{@code x between 3 and 8 or x between 10 and 20} has complexity 2\n+   * </ul>\n+   */\n+  public int complexity() {\n+    int complexity;\n+    if (rangeSet.asRanges().size() == 2\n+        && rangeSet.complement().asRanges().size() == 1\n+        && RangeSets.isPoint(\n+            Iterables.getOnlyElement(rangeSet.complement().asRanges()))) {", "originalCommit": "ecf7a8d25157dda11f6c295b066f9337076e5c5b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDMwNzQ0OQ==", "url": "https://github.com/apache/calcite/pull/2212#discussion_r504307449", "bodyText": "Oh, this code already existed. Then I'm puzzled.", "author": "vlsi", "createdAt": "2020-10-13T23:04:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDMwNzA2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDMwODY5OQ==", "url": "https://github.com/apache/calcite/pull/2212#discussion_r504308699", "bodyText": "Yeah, there aren't many comments in the code. But there are reasonable method javadoc comments. Also a test, testSargComplexity. Run the test, and all will become clear.\nI moved the code so that I could add a test.", "author": "julianhyde", "createdAt": "2020-10-13T23:08:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDMwNzA2Mw=="}], "type": "inlineReview"}, {"oid": "d25d75f787dfdd74be8398e66d2f29ef51f73e4a", "url": "https://github.com/apache/calcite/commit/d25d75f787dfdd74be8398e66d2f29ef51f73e4a", "message": "[CALCITE-4325] RexSimplify incorrectly simplifies complex expressions that contain Sarg and IS NULL\n\nImprove how class Sarg handles IS NULL and IS NOT NULL\nconditions. They are now handled symmetrically, using fields\nnullCount and notNullCount, whereas previously we used\ncontainsNull, which could handle IS NULL only in certain\ncircumstances and IS NOT NULL not at all.", "committedDate": "2020-10-14T20:37:58Z", "type": "forcePushed"}, {"oid": "8c6957d3659a7f9f791ddde99a7ca30b26ff2082", "url": "https://github.com/apache/calcite/commit/8c6957d3659a7f9f791ddde99a7ca30b26ff2082", "message": "[CALCITE-4325] RexSimplify incorrectly simplifies complex expressions that contain Sarg and IS NULL\n\nImprove how class Sarg handles IS NULL and IS NOT NULL\nconditions. They are now handled symmetrically, using fields\nnullCount and notNullCount, whereas previously we used\ncontainsNull, which could handle IS NULL only in certain\ncircumstances and IS NOT NULL not at all.\n\nIn CalciteAssert, correct rounding floating point rounding\nerrors before comparing SQL column values. For example,\n'236.55000000000007' becomes '236.55'. This fixes some\nintermittent Druid test failures.", "committedDate": "2020-10-15T00:15:04Z", "type": "forcePushed"}, {"oid": "ee5c78444558117c71cc7058a79bc920a52cad59", "url": "https://github.com/apache/calcite/commit/ee5c78444558117c71cc7058a79bc920a52cad59", "message": "[CALCITE-4325] RexSimplify incorrectly simplifies complex expressions that contain Sarg and IS NULL\n\nImprove how class Sarg handles IS NULL and IS NOT NULL\nconditions. They are now handled symmetrically, using fields\nnullCount and notNullCount, whereas previously we used\ncontainsNull, which could handle IS NULL only in certain\ncircumstances and IS NOT NULL not at all.\n\nIn CalciteAssert, correct rounding floating point rounding\nerrors before comparing SQL column values. For example,\n'236.55000000000007' becomes '236.55'. This fixes some\nintermittent Druid test failures.", "committedDate": "2020-10-15T01:15:13Z", "type": "commit"}, {"oid": "10c80d61c074214963e2c2541ab584f6d74064e6", "url": "https://github.com/apache/calcite/commit/10c80d61c074214963e2c2541ab584f6d74064e6", "message": "more 4204", "committedDate": "2020-10-15T02:08:11Z", "type": "forcePushed"}, {"oid": "ffc1e3b05e7f920d95c48f7c75fd48372684b8e7", "url": "https://github.com/apache/calcite/commit/ffc1e3b05e7f920d95c48f7c75fd48372684b8e7", "message": "Make progress on [CALCITE-4204] Intermittent precision in Druid results when using aggregation functions over columns of type DOUBLE\n\nIf a query returns a column value that has at least four\nzeros or nines after the decimal point (indicating that\nrounding has occurred) clean up the rounding. For example,\n'12.3449999962' becomes '12.345'. Most queries have a result\nthat is decimal exact to a small number of decimal places;\nsuch queries are re-enabled in this change, because they are\nnow deterministic. There are still a few queries whose\ndecimal does not terminate (perhaps it is a rational number)\nand therefore [CALCITE-4204] remains open.", "committedDate": "2020-10-15T19:18:56Z", "type": "commit"}, {"oid": "ffc1e3b05e7f920d95c48f7c75fd48372684b8e7", "url": "https://github.com/apache/calcite/commit/ffc1e3b05e7f920d95c48f7c75fd48372684b8e7", "message": "Make progress on [CALCITE-4204] Intermittent precision in Druid results when using aggregation functions over columns of type DOUBLE\n\nIf a query returns a column value that has at least four\nzeros or nines after the decimal point (indicating that\nrounding has occurred) clean up the rounding. For example,\n'12.3449999962' becomes '12.345'. Most queries have a result\nthat is decimal exact to a small number of decimal places;\nsuch queries are re-enabled in this change, because they are\nnow deterministic. There are still a few queries whose\ndecimal does not terminate (perhaps it is a rational number)\nand therefore [CALCITE-4204] remains open.", "committedDate": "2020-10-15T19:18:56Z", "type": "forcePushed"}]}