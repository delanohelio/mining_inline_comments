{"pr_number": 2011, "pr_title": "[CALCITE-4016] Support trait propagation for EnumerableCalc", "pr_createdAt": "2020-06-09T03:25:07Z", "pr_url": "https://github.com/apache/calcite/pull/2011", "timeline": [{"oid": "5c59c73d9ff52d5c2ced0d1da01931c6f64e20c3", "url": "https://github.com/apache/calcite/commit/5c59c73d9ff52d5c2ced0d1da01931c6f64e20c3", "message": "[CALCITE-4016] Support trait propagation for EnumerableCalc", "committedDate": "2020-06-09T03:32:28Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzExOTIzMQ==", "url": "https://github.com/apache/calcite/pull/2011#discussion_r437119231", "bodyText": "I am not sure whether RelOptUtil is the best place to hold these methods. Any suggestion is appreciated.", "author": "chunweilei", "createdAt": "2020-06-09T03:35:53Z", "path": "core/src/main/java/org/apache/calcite/plan/RelOptUtil.java", "diffHunk": "@@ -3766,6 +3771,115 @@ private static void fix(List<RexNode> operands, int before, int after) {\n     }\n   }\n \n+  /**\n+   * Gets a shuttle to expand RexLocalRef.\n+   */\n+  public static RexShuttle getExpandShuttle(RexProgram rexProgram) {\n+    return new RexShuttle() {\n+      @Override public RexNode visitLocalRef(RexLocalRef localRef) {\n+        return rexProgram.expandLocalRef(localRef);\n+      }\n+    };\n+  }\n+\n+  /**\n+   * Determine whether there is mapping between project input and output fields.\n+   * Bail out if sort relies on non-trivial expressions.\n+   */\n+  private static boolean isCollationOnTrivialExpr(\n+      List<RexNode> projects,RelDataTypeFactory typeFactory,\n+      Mappings.TargetMapping map, RelFieldCollation fc, boolean passDown) {\n+    final int index = fc.getFieldIndex();\n+    int target = map.getTargetOpt(index);", "originalCommit": "5c59c73d9ff52d5c2ced0d1da01931c6f64e20c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzU4NjkwOA==", "url": "https://github.com/apache/calcite/pull/2011#discussion_r437586908", "bodyText": "I think the part of construct pairs of traits for passThroughTraits and dervieTratis are better kept in Enumerable nodes, at least for better readability.", "author": "amaliujia", "createdAt": "2020-06-09T17:07:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzExOTIzMQ=="}], "type": "inlineReview"}, {"oid": "b3a2c2ada69b913e263f3e91628d5f4b5deac5f5", "url": "https://github.com/apache/calcite/commit/b3a2c2ada69b913e263f3e91628d5f4b5deac5f5", "message": "[CALCITE-4016] Support trait propagation for EnumerableCalc", "committedDate": "2020-06-09T03:44:10Z", "type": "forcePushed"}, {"oid": "728ffe32a32416f2446123213cd18d29f73373aa", "url": "https://github.com/apache/calcite/commit/728ffe32a32416f2446123213cd18d29f73373aa", "message": "[CALCITE-4016] Support trait propagation for EnumerableCalc", "committedDate": "2020-06-09T07:42:25Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzU4ODI3Nw==", "url": "https://github.com/apache/calcite/pull/2011#discussion_r437588277", "bodyText": "I think I made a mistake on such tests. To improve readability, it's better to do\nselect cast(deptno as float) from sales.emp order by  deptno desc.\nBut these two queries are testing the same thing.", "author": "amaliujia", "createdAt": "2020-06-09T17:10:07Z", "path": "core/src/test/java/org/apache/calcite/test/TopDownOptTest.java", "diffHunk": "@@ -573,6 +575,112 @@\n         .removeRule(EnumerableRules.ENUMERABLE_SORT_RULE)\n         .check();\n   }\n+\n+  // test if \"order by mgr desc nulls last\" can be pushed through the calc (\"select mgr\").\n+  @Test void testSortCalc() {\n+    final String sql = \"select mgr from sales.emp order by mgr desc nulls last\";\n+    Query.create(sql)\n+        .addRule(ProjectToCalcRule.INSTANCE)\n+        .addRule(EnumerableRules.ENUMERABLE_CALC_RULE)\n+        .removeRule(EnumerableRules.ENUMERABLE_SORT_RULE)\n+        .removeRule(EnumerableRules.ENUMERABLE_PROJECT_RULE)\n+        .check();\n+  }\n+\n+  // test that Sort cannot push through calc because of non-trival call\n+  // (e.g. RexCall(sal * -1)). In this example, the reason is that \"sal * -1\"\n+  // creates opposite ordering if Sort is pushed down.\n+  @Test void testSortCalcOnRexCall() {\n+    final String sql = \"select ename, sal * -1 as sal, mgr from\\n\"\n+        + \"sales.emp order by ename desc, sal desc, mgr desc nulls last\";\n+    Query.create(sql)\n+        .addRule(ProjectToCalcRule.INSTANCE)\n+        .addRule(EnumerableRules.ENUMERABLE_CALC_RULE)\n+        .removeRule(EnumerableRules.ENUMERABLE_SORT_RULE)\n+        .removeRule(EnumerableRules.ENUMERABLE_PROJECT_RULE)\n+        .check();\n+  }\n+\n+  // test that Sort can push through calc when cast is monotonic.\n+  @Test void testSortCalcWhenCastLeadingToMonotonic() {\n+    final String sql = \"select deptno from sales.emp order by cast(deptno as float) desc\";", "originalCommit": "728ffe32a32416f2446123213cd18d29f73373aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgyNzQ3Nw==", "url": "https://github.com/apache/calcite/pull/2011#discussion_r437827477", "bodyText": "Makes sense.", "author": "chunweilei", "createdAt": "2020-06-10T02:38:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzU4ODI3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzU5MjQzOQ==", "url": "https://github.com/apache/calcite/pull/2011#discussion_r437592439", "bodyText": "Depends on if we want move all most all the code to RelOptUtil, I feel like only isCollationOnTrivialExpr can be moved to RelOptUtil.\nAt least RelOptUtil.passThroughTraits and RelOptTuil. deriveTraits, seems to me, could encourage people write all passThroughTraits and deriveTraits into RelOptUtil, because names here are too generic.\nFor example, I might ask, why not move implementations in Enumerable Joins to RelOptUtil, etc. And will they become a part of RelOptUtil.passThroughTraits and RelOptTuil. deriveTraits?", "author": "amaliujia", "createdAt": "2020-06-09T17:17:12Z", "path": "core/src/main/java/org/apache/calcite/plan/RelOptUtil.java", "diffHunk": "@@ -3766,6 +3771,104 @@ private static void fix(List<RexNode> operands, int before, int after) {\n     }\n   }\n \n+  /**\n+   * Determine whether there is mapping between project input and output fields.\n+   * Bail out if sort relies on non-trivial expressions.\n+   */\n+  private static boolean isCollationOnTrivialExpr(\n+      List<RexNode> projects, RelDataTypeFactory typeFactory,\n+      Mappings.TargetMapping map, RelFieldCollation fc, boolean passDown) {\n+    final int index = fc.getFieldIndex();\n+    int target = map.getTargetOpt(index);\n+    if (target < 0) {\n+      return false;\n+    }\n+\n+    final RexNode node = passDown ? projects.get(index) : projects.get(target);\n+    if (node.isA(SqlKind.CAST)) {\n+      // Check whether it is a monotonic preserving cast\n+      final RexCall cast = (RexCall) node;\n+      RelFieldCollation newFc = Objects.requireNonNull(RexUtil.apply(map, fc));\n+      final RexCallBinding binding =\n+          RexCallBinding.create(typeFactory, cast,\n+              ImmutableList.of(RelCollations.of(newFc)));\n+      if (cast.getOperator().getMonotonicity(binding)\n+          == SqlMonotonicity.NOT_MONOTONIC) {\n+        return false;\n+      }\n+    }\n+\n+    return true;\n+  }\n+\n+  public static Pair<RelTraitSet, List<RelTraitSet>> passThroughTraits(", "originalCommit": "728ffe32a32416f2446123213cd18d29f73373aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY1ODQxNw==", "url": "https://github.com/apache/calcite/pull/2011#discussion_r437658417", "bodyText": "I had the same feeling. How about add a package level internal interface for EnumerableProject and EnumerableCalc with default implementation so that both operators just need to implement the interface?", "author": "hsyuan", "createdAt": "2020-06-09T19:12:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzU5MjQzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgyOTczOA==", "url": "https://github.com/apache/calcite/pull/2011#discussion_r437829738", "bodyText": "@hsyuan Instead of adding an interface, how about adding an EnumTraitUtils to hold these methods?  IMO, an interface seems not necessary since only Calc and Project should implement it.", "author": "chunweilei", "createdAt": "2020-06-10T02:47:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzU5MjQzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgzMDA3OQ==", "url": "https://github.com/apache/calcite/pull/2011#discussion_r437830079", "bodyText": "@amaliujia We could change the name to clarify what it is doing.", "author": "chunweilei", "createdAt": "2020-06-10T02:48:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzU5MjQzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI5NjY5MQ==", "url": "https://github.com/apache/calcite/pull/2011#discussion_r438296691", "bodyText": "Sure. Either have a EnumTraitUtils (to host as much code to share for traits propagation) or rename it is fine.\nI find there is another case to share trait propagation code: https://jira.apache.org/jira/browse/CALCITE-4057. So after this PR to build a code sharing place, we can also apply it to  CALCITE-4057.", "author": "amaliujia", "createdAt": "2020-06-10T17:35:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzU5MjQzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMxNzM2Nw==", "url": "https://github.com/apache/calcite/pull/2011#discussion_r438317367", "bodyText": "Sounds fare. Be sure to make it package level class, and mark it for internal use.", "author": "hsyuan", "createdAt": "2020-06-10T18:11:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzU5MjQzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODUxNDY5NA==", "url": "https://github.com/apache/calcite/pull/2011#discussion_r438514694", "bodyText": "Updated.", "author": "chunweilei", "createdAt": "2020-06-11T02:55:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzU5MjQzOQ=="}], "type": "inlineReview"}, {"oid": "b68cf78b345c1dcecb0799c06529627aad353a5f", "url": "https://github.com/apache/calcite/commit/b68cf78b345c1dcecb0799c06529627aad353a5f", "message": "address comments", "committedDate": "2020-06-11T03:06:58Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA1MzE3OQ==", "url": "https://github.com/apache/calcite/pull/2011#discussion_r439053179", "bodyText": "Can you rename it to passThroughTraitsProject? I will also move some code for NestedLoopJoin here, so I can use passThroughTraitsNestedLoopJoin to differentiate.", "author": "amaliujia", "createdAt": "2020-06-11T20:28:00Z", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumTraitsUtils.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.adapter.enumerable;\n+\n+import org.apache.calcite.linq4j.Ord;\n+import org.apache.calcite.plan.RelOptUtil;\n+import org.apache.calcite.plan.RelTraitSet;\n+import org.apache.calcite.rel.RelCollation;\n+import org.apache.calcite.rel.RelCollations;\n+import org.apache.calcite.rel.RelFieldCollation;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rel.type.RelDataTypeFactory;\n+import org.apache.calcite.rex.RexCall;\n+import org.apache.calcite.rex.RexCallBinding;\n+import org.apache.calcite.rex.RexInputRef;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.rex.RexUtil;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.validate.SqlMonotonicity;\n+import org.apache.calcite.util.Pair;\n+import org.apache.calcite.util.mapping.MappingType;\n+import org.apache.calcite.util.mapping.Mappings;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import org.apiguardian.api.API;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * Utilities for traits propagation.\n+ */\n+@API(since = \"1.24\", status = API.Status.INTERNAL)\n+class EnumTraitsUtils {\n+\n+  private EnumTraitsUtils() {}\n+\n+  /**\n+   * Determine whether there is mapping between project input and output fields.\n+   * Bail out if sort relies on non-trivial expressions.\n+   */\n+  private static boolean isCollationOnTrivialExpr(\n+      List<RexNode> projects, RelDataTypeFactory typeFactory,\n+      Mappings.TargetMapping map, RelFieldCollation fc, boolean passDown) {\n+    final int index = fc.getFieldIndex();\n+    int target = map.getTargetOpt(index);\n+    if (target < 0) {\n+      return false;\n+    }\n+\n+    final RexNode node = passDown ? projects.get(index) : projects.get(target);\n+    if (node.isA(SqlKind.CAST)) {\n+      // Check whether it is a monotonic preserving cast\n+      final RexCall cast = (RexCall) node;\n+      RelFieldCollation newFieldCollation = Objects.requireNonNull(RexUtil.apply(map, fc));\n+      final RexCallBinding binding =\n+          RexCallBinding.create(typeFactory, cast,\n+              ImmutableList.of(RelCollations.of(newFieldCollation)));\n+      if (cast.getOperator().getMonotonicity(binding)\n+          == SqlMonotonicity.NOT_MONOTONIC) {\n+        return false;\n+      }\n+    }\n+\n+    return true;\n+  }\n+\n+  static Pair<RelTraitSet, List<RelTraitSet>> passThroughTraits(", "originalCommit": "b68cf78b345c1dcecb0799c06529627aad353a5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE2ODM3NA==", "url": "https://github.com/apache/calcite/pull/2011#discussion_r439168374", "bodyText": "Sure.", "author": "chunweilei", "createdAt": "2020-06-12T02:04:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA1MzE3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA1MzIyMQ==", "url": "https://github.com/apache/calcite/pull/2011#discussion_r439053221", "bodyText": "Same for deriveTraits", "author": "amaliujia", "createdAt": "2020-06-11T20:28:07Z", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumTraitsUtils.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.adapter.enumerable;\n+\n+import org.apache.calcite.linq4j.Ord;\n+import org.apache.calcite.plan.RelOptUtil;\n+import org.apache.calcite.plan.RelTraitSet;\n+import org.apache.calcite.rel.RelCollation;\n+import org.apache.calcite.rel.RelCollations;\n+import org.apache.calcite.rel.RelFieldCollation;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rel.type.RelDataTypeFactory;\n+import org.apache.calcite.rex.RexCall;\n+import org.apache.calcite.rex.RexCallBinding;\n+import org.apache.calcite.rex.RexInputRef;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.rex.RexUtil;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.validate.SqlMonotonicity;\n+import org.apache.calcite.util.Pair;\n+import org.apache.calcite.util.mapping.MappingType;\n+import org.apache.calcite.util.mapping.Mappings;\n+\n+import com.google.common.collect.ImmutableList;\n+\n+import org.apiguardian.api.API;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * Utilities for traits propagation.\n+ */\n+@API(since = \"1.24\", status = API.Status.INTERNAL)\n+class EnumTraitsUtils {\n+\n+  private EnumTraitsUtils() {}\n+\n+  /**\n+   * Determine whether there is mapping between project input and output fields.\n+   * Bail out if sort relies on non-trivial expressions.\n+   */\n+  private static boolean isCollationOnTrivialExpr(\n+      List<RexNode> projects, RelDataTypeFactory typeFactory,\n+      Mappings.TargetMapping map, RelFieldCollation fc, boolean passDown) {\n+    final int index = fc.getFieldIndex();\n+    int target = map.getTargetOpt(index);\n+    if (target < 0) {\n+      return false;\n+    }\n+\n+    final RexNode node = passDown ? projects.get(index) : projects.get(target);\n+    if (node.isA(SqlKind.CAST)) {\n+      // Check whether it is a monotonic preserving cast\n+      final RexCall cast = (RexCall) node;\n+      RelFieldCollation newFieldCollation = Objects.requireNonNull(RexUtil.apply(map, fc));\n+      final RexCallBinding binding =\n+          RexCallBinding.create(typeFactory, cast,\n+              ImmutableList.of(RelCollations.of(newFieldCollation)));\n+      if (cast.getOperator().getMonotonicity(binding)\n+          == SqlMonotonicity.NOT_MONOTONIC) {\n+        return false;\n+      }\n+    }\n+\n+    return true;\n+  }\n+\n+  static Pair<RelTraitSet, List<RelTraitSet>> passThroughTraits(\n+      RelTraitSet required,\n+      List<RexNode> exps,\n+      RelDataType inputRowType,\n+      RelDataTypeFactory typeFactory,\n+      RelTraitSet currentTraits) {\n+    final RelCollation collation = required.getCollation();\n+    if (collation == null || collation == RelCollations.EMPTY) {\n+      return null;\n+    }\n+\n+    final Mappings.TargetMapping map =\n+        RelOptUtil.permutationIgnoreCast(\n+            exps, inputRowType);\n+\n+    if (collation.getFieldCollations().stream().anyMatch(\n+        rc -> !isCollationOnTrivialExpr(exps, typeFactory,\n+            map, rc, true))) {\n+      return null;\n+    }\n+\n+    final RelCollation newCollation = collation.apply(map);\n+    return Pair.of(currentTraits.replace(collation),\n+        ImmutableList.of(currentTraits.replace(newCollation)));\n+  }\n+\n+  static Pair<RelTraitSet, List<RelTraitSet>> deriveTraits(", "originalCommit": "b68cf78b345c1dcecb0799c06529627aad353a5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d95831ea83da9ccc82771a50d6d4dbead038c83f", "url": "https://github.com/apache/calcite/commit/d95831ea83da9ccc82771a50d6d4dbead038c83f", "message": "[CALCITE-4016] Support trait propagation for EnumerableCalc", "committedDate": "2020-06-12T02:23:26Z", "type": "commit"}, {"oid": "d95831ea83da9ccc82771a50d6d4dbead038c83f", "url": "https://github.com/apache/calcite/commit/d95831ea83da9ccc82771a50d6d4dbead038c83f", "message": "[CALCITE-4016] Support trait propagation for EnumerableCalc", "committedDate": "2020-06-12T02:23:26Z", "type": "forcePushed"}]}