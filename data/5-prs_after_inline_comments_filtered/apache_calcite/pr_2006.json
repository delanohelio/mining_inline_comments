{"pr_number": 2006, "pr_title": "[CALCITE-4015] Pass through parent collation request on subset or sup\u2026", "pr_createdAt": "2020-06-07T09:01:36Z", "pr_url": "https://github.com/apache/calcite/pull/2006", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM4NjIzNQ==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r436386235", "bodyText": "I will probably add more comments to these new methods to explain what they are doing.", "author": "amaliujia", "createdAt": "2020-06-07T17:48:24Z", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -194,6 +250,81 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n     return DeriveMode.BOTH;\n   }\n \n+  private List<Integer> immutableIntListToList(ImmutableIntList intList, int offset) {", "originalCommit": "995031ec5b29a425abb1f09ad5bb33c767334386", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA2MjM1OA==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r437062358", "bodyText": "Can you rebase on master? I just updated this file.\nUse ImmutableIntList.incr instead.", "author": "hsyuan", "createdAt": "2020-06-08T23:52:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM4NjIzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA2Mjg1Ng==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r437062856", "bodyText": "See RelCollations.containsOrderless, you can make the private one public is necessary.", "author": "hsyuan", "createdAt": "2020-06-08T23:54:16Z", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -194,6 +250,81 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n     return DeriveMode.BOTH;\n   }\n \n+  private List<Integer> immutableIntListToList(ImmutableIntList intList, int offset) {\n+    ArrayList<Integer> arrayList = new ArrayList<>(intList.size());\n+    for (int i : intList) {\n+      arrayList.add(i + offset);\n+    }\n+    return arrayList;\n+  }\n+\n+  private boolean isSubset(List<Integer> a, List<Integer> b) {\n+    if (a.size() > b.size()) {\n+      return false;\n+    }\n+    Set<Integer> set = new HashSet<>(b);\n+    for (int i = 0; i < a.size(); i++) {\n+      if (!set.contains(a.get(i))) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  private boolean isPrefixOrderingNotRequired(List<Integer> a, List<Integer> b) {", "originalCommit": "995031ec5b29a425abb1f09ad5bb33c767334386", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzExNTgxOA==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r437115818", "bodyText": "nice catch. in case the keys are 1,1,2,2. IMHO, we shouldn't see duplicate join keys in physical merge/hash join operators. They should be optimized away, because that means the predicate is not pushed down at all.\nlike foo.a = bar.b and foo.a=bar.c. The predicate bar.b=bar.c should be pushed down for table bar.", "author": "hsyuan", "createdAt": "2020-06-09T03:21:06Z", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -101,28 +103,55 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n     // Required collation keys can be subset or superset of merge join keys.\n     RelCollation collation = required.getTrait(RelCollationTraitDef.INSTANCE);\n     List<Integer> reqKeys = RelCollations.ordinals(collation);\n-    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n+    // need to copy reqKeys because it is not sortable.\n+    reqKeys = new ArrayList<>(reqKeys);\n+    List<Integer> leftKeys = immutableIntListToList(joinInfo.leftKeys, 0);\n+    List<Integer> rightKeys = immutableIntListToList(joinInfo.rightKeys,\n+        left.getRowType().getFieldCount());\n+    List<Integer> rightKeysNotShifted = immutableIntListToList(joinInfo.rightKeys, 0);\n \n+    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n     ImmutableBitSet leftKeySet = ImmutableBitSet.of(joinInfo.leftKeys);\n     ImmutableBitSet rightKeySet = ImmutableBitSet.of(joinInfo.rightKeys)\n         .shift(left.getRowType().getFieldCount());\n \n     Map<Integer, Integer> keyMap = new HashMap<>();\n-    final int keyCount = leftKeySet.cardinality();\n+    final int keyCount = leftKeys.size();", "originalCommit": "995031ec5b29a425abb1f09ad5bb33c767334386", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzExNjU0Ng==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r437116546", "bodyText": "why do you want to sort it?", "author": "hsyuan", "createdAt": "2020-06-09T03:24:13Z", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -101,28 +103,55 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n     // Required collation keys can be subset or superset of merge join keys.\n     RelCollation collation = required.getTrait(RelCollationTraitDef.INSTANCE);\n     List<Integer> reqKeys = RelCollations.ordinals(collation);\n-    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n+    // need to copy reqKeys because it is not sortable.\n+    reqKeys = new ArrayList<>(reqKeys);", "originalCommit": "995031ec5b29a425abb1f09ad5bb33c767334386", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEyNjg1NQ==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r437126855", "bodyText": "isPrefixOrderingNotRequired sorts its input, and reqKeys is used as this function's parameter below.\nBut since you have suggested RelCollations.containsOrderless, I might not need this anymore.", "author": "amaliujia", "createdAt": "2020-06-09T04:11:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzExNjU0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzExNzAxNQ==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r437117015", "bodyText": "You can use RelCollations.containsOrderless", "author": "hsyuan", "createdAt": "2020-06-09T03:26:14Z", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -101,28 +103,55 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n     // Required collation keys can be subset or superset of merge join keys.\n     RelCollation collation = required.getTrait(RelCollationTraitDef.INSTANCE);\n     List<Integer> reqKeys = RelCollations.ordinals(collation);\n-    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n+    // need to copy reqKeys because it is not sortable.\n+    reqKeys = new ArrayList<>(reqKeys);\n+    List<Integer> leftKeys = immutableIntListToList(joinInfo.leftKeys, 0);\n+    List<Integer> rightKeys = immutableIntListToList(joinInfo.rightKeys,\n+        left.getRowType().getFieldCount());\n+    List<Integer> rightKeysNotShifted = immutableIntListToList(joinInfo.rightKeys, 0);\n \n+    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n     ImmutableBitSet leftKeySet = ImmutableBitSet.of(joinInfo.leftKeys);\n     ImmutableBitSet rightKeySet = ImmutableBitSet.of(joinInfo.rightKeys)\n         .shift(left.getRowType().getFieldCount());\n \n     Map<Integer, Integer> keyMap = new HashMap<>();\n-    final int keyCount = leftKeySet.cardinality();\n+    final int keyCount = leftKeys.size();\n     for (int i = 0; i < keyCount; i++) {\n       keyMap.put(joinInfo.leftKeys.get(i), joinInfo.rightKeys.get(i));\n     }\n     Mappings.TargetMapping mapping = Mappings.target(keyMap,\n         left.getRowType().getFieldCount(),\n         right.getRowType().getFieldCount());\n \n-    // Only consider exact key match for now\n+\n     if (reqKeySet.equals(leftKeySet)) {\n+      // if sort keys equal to left join keys, we can pass through all collations directly.\n       RelCollation rightCollation = RexUtil.apply(mapping, collation);\n       return Pair.of(\n           required, ImmutableList.of(required,\n           required.replace(rightCollation)));\n+    } else if (isSubset(reqKeys, leftKeys)) {\n+      // if sort keys are subset of left join keys, we can extend collations to make sure all join\n+      // keys are sorted.\n+      collation = extendCollation(collation, leftKeys);\n+      RelCollation rightCollation = RexUtil.apply(mapping, collation);\n+      return Pair.of(\n+          required, ImmutableList.of(required.replace(collation),\n+              required.replace(rightCollation)));\n+    } else if (isPrefixOrderingNotRequired(leftKeys, reqKeys)", "originalCommit": "995031ec5b29a425abb1f09ad5bb33c767334386", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg4OTAzMg==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r437889032", "bodyText": "isPrefixOrderingNotRequired probably is the one I cannot use RelCollations.containsOrderless. It is designed for superset case. In which join keys should be 1) an orderless subset 2) prefix of required collations.\nRelCollations.containsOrderless does not consider prefix requirement.\nAlternatively, I am ok to move isPrefixOrderingNotRequired to RelCollations as a util function.", "author": "amaliujia", "createdAt": "2020-06-10T06:32:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzExNzAxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg5MDEyMg==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r437890122", "bodyText": "For supset case, for example if required collation is [d, b, a ,c]\nthen join keys [d, b, a] is valid\njoin keys [d,a,c] is not (if push down [d,b,a,c], it does not guarantee the ordering of [d,a,c]", "author": "amaliujia", "createdAt": "2020-06-10T06:35:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzExNzAxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ0ODQ0Nw==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r438448447", "bodyText": "can you explain RelCollations.containsOrderless does not consider prefix requirement.?", "author": "hsyuan", "createdAt": "2020-06-10T22:46:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzExNzAxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODUzNDI5OQ==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r438534299", "bodyText": "containsOrderless only consider if one is another's subset, for example:\n[1, 2, 3] is [2, 3, 4, 1]'s subset\n[3, 2, 1] is [2, 1, 3, 4] 's subset\nThe prefix requirement is, still use examples above, but apply sublist:\n[2,3,4,1] -> [2,3,4], then containsOrderless([1,2,3]) = false.\n[2,1,3,4] ->[2,1,3], then containsOrderless([3,2,1]) = true.", "author": "amaliujia", "createdAt": "2020-06-11T04:20:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzExNzAxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODUzNzk3Mg==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r438537972", "bodyText": "In fact, I mis-read how containsOrderless is implemented. It actually meets the need here.\nHave changed to containsOrderless and dropped unused code.", "author": "amaliujia", "createdAt": "2020-06-11T04:37:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzExNzAxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY4NDYyMA==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r437684620", "bodyText": "let's use a var to store left.getRowType().getFieldCount().", "author": "hsyuan", "createdAt": "2020-06-09T20:01:41Z", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -131,8 +160,35 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n           required, ImmutableList.of(\n           required.replace(leftCollation),\n           required.replace(rightCollation)));\n+    } else if (isSubset(reqKeys, rightKeys)) {\n+      // if sort keys are subset of right join keys, we can extend collations to make sure all join\n+      // keys are sorted.\n+      collation = extendCollation(collation, rightKeys);\n+      RelCollation rightCollation = RelCollations.shift(collation,\n+          -left.getRowType().getFieldCount());\n+      Mappings.TargetMapping invMapping = mapping.inverse();\n+      RelCollation leftCollation = RexUtil.apply(invMapping, rightCollation);\n+      return Pair.of(\n+          required, ImmutableList.of(\n+              required.replace(leftCollation),\n+              required.replace(rightCollation)));\n+    } else if (isPrefixOrderingNotRequired(rightKeys, reqKeys)\n+        && allElementsGe(reqKeys, getLeft().getRowType().getFieldCount())) {\n+      // if sort keys are superset of right join keys, and right join keys is prefix of sort keys\n+      // (order not matter), also sort keys are all from right join input.\n+      RelCollation rightCollation = RelCollations.shift(collation,\n+          -left.getRowType().getFieldCount());", "originalCommit": "995031ec5b29a425abb1f09ad5bb33c767334386", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY4NTg2Mw==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r437685863", "bodyText": "can we use reqKeys.stream().allMatch()?", "author": "hsyuan", "createdAt": "2020-06-09T20:04:14Z", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -131,8 +160,35 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n           required, ImmutableList.of(\n           required.replace(leftCollation),\n           required.replace(rightCollation)));\n+    } else if (isSubset(reqKeys, rightKeys)) {\n+      // if sort keys are subset of right join keys, we can extend collations to make sure all join\n+      // keys are sorted.\n+      collation = extendCollation(collation, rightKeys);\n+      RelCollation rightCollation = RelCollations.shift(collation,\n+          -left.getRowType().getFieldCount());\n+      Mappings.TargetMapping invMapping = mapping.inverse();\n+      RelCollation leftCollation = RexUtil.apply(invMapping, rightCollation);\n+      return Pair.of(\n+          required, ImmutableList.of(\n+              required.replace(leftCollation),\n+              required.replace(rightCollation)));\n+    } else if (isPrefixOrderingNotRequired(rightKeys, reqKeys)\n+        && allElementsGe(reqKeys, getLeft().getRowType().getFieldCount())) {", "originalCommit": "995031ec5b29a425abb1f09ad5bb33c767334386", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg4Njg4NQ==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r437886885", "bodyText": "Done! Thanks!", "author": "amaliujia", "createdAt": "2020-06-10T06:27:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY4NTg2Mw=="}], "type": "inlineReview"}, {"oid": "5c09c3695883b67f056179caa06441100360ac5e", "url": "https://github.com/apache/calcite/commit/5c09c3695883b67f056179caa06441100360ac5e", "message": "fixup! address comments", "committedDate": "2020-06-10T06:28:30Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MjI3NA==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r439782274", "bodyText": "Why toIntegerList?", "author": "hsyuan", "createdAt": "2020-06-14T01:19:04Z", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -134,31 +137,83 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n       final RelTraitSet required) {\n     // Required collation keys can be subset or superset of merge join keys.\n     RelCollation collation = required.getCollation();\n+    int leftInputFieldCount = left.getRowType().getFieldCount();\n+\n     List<Integer> reqKeys = RelCollations.ordinals(collation);\n-    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n+    List<Integer> leftKeys = joinInfo.leftKeys.toIntegerList();\n+    List<Integer> rightKeys =\n+        joinInfo.rightKeys.incr(leftInputFieldCount).toIntegerList();\n+    List<Integer> rightKeysNotShifted = joinInfo.rightKeys.toIntegerList();", "originalCommit": "fee95d236a1042baa7672bf74b764e82f8465717", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MzU3Nw==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r439783577", "bodyText": "To this specific case, toIntegerList to get a list of key indexes (not shifted, so index from 0). Then, later, in superset cases, we can use this list to remove collations that are not on keys. Use this query as an example:\nselect * from foo join bar on foo.a=bar.a and foo.b=bar.b order by bar.a, bar.b, bar.c; \nwe can push\ncollation a b to left\ncollation a, b, c to right\nThus the output of join should still be sorted by a, b, c.\nThen, the toIntegerList helps to to that only a, b needs to pushed to left.  It works along with\nRelCollation rightCollation = RelCollations.shift(collation, -leftInputFieldCount);\nMappings.TargetMapping mapping = buildMapping(false);\nRelCollation leftCollation =\n          RexUtil.apply(\n              mapping,\n              removeCollationFieldsNotOnJoinKey(rightCollation, rightKeysNotShifted));", "author": "amaliujia", "createdAt": "2020-06-14T01:51:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MjI3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MzczNQ==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r439783735", "bodyText": "why ImmutableIntList is not suitable?", "author": "hsyuan", "createdAt": "2020-06-14T01:54:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MjI3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4NDc3MA==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r439784770", "bodyText": "Let me check if this process can be simplified somehow.\nFor the example above, I am only looking for a way to\nleftCollation = requiredCollation.apply(join keys) // only need collation defined on keys for left input,", "author": "amaliujia", "createdAt": "2020-06-14T02:18:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MjI3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4OTc4Nw==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r439789787", "bodyText": "I still don't understand, why can't just use joinInfo.rightKeys, instead use joinInfo.rightKeys. toIntegerList?", "author": "hsyuan", "createdAt": "2020-06-14T04:13:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MjI3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc5MTg2Ng==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r439791866", "bodyText": "yes joinInfo.rightKeys can be used because ImmutableIntList implements IndexOf. I will change it to joinInfo.rightKeys", "author": "amaliujia", "createdAt": "2020-06-14T04:56:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MjI3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MjMxNQ==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r439782315", "bodyText": "It is not obvious to get the meaning from method name. An example and comment will help.", "author": "hsyuan", "createdAt": "2020-06-14T01:20:02Z", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -222,6 +277,30 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n     return mapping;\n   }\n \n+  private RelCollation extendCollation(RelCollation collation, List<Integer> keys) {\n+    List<RelFieldCollation> fieldsForNewCollation = new ArrayList<>(keys.size());\n+    fieldsForNewCollation.addAll(collation.getFieldCollations());\n+    Set<Integer> keySet = new HashSet<>(keys);\n+    for (RelFieldCollation rf : collation.getFieldCollations()) {\n+      keySet.remove(rf.getFieldIndex());\n+    }\n+    for (Integer i : keySet) {\n+      fieldsForNewCollation.add(new RelFieldCollation(i));\n+    }\n+    return RelCollations.of(fieldsForNewCollation);\n+  }\n+\n+  private RelCollation removeCollationFieldsNotOnJoinKey(", "originalCommit": "fee95d236a1042baa7672bf74b764e82f8465717", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4NDE0Ng==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r439784146", "bodyText": "Let me add some comments with an example (a little bit complicated but let me try).", "author": "amaliujia", "createdAt": "2020-06-14T02:04:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MjMxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzAwNjI2NQ==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r473006265", "bodyText": "I also think the method name is counter-intuitive. It is actually not removing anything, it just builds a new collation based on a \"source\" collation, considering only the fields which are part of the joinKeys. I would propose as name e.g. reduceCollation, intersect, or something like that..", "author": "rubenada", "createdAt": "2020-08-19T12:55:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MjMxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ0OTMzMA==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r475449330", "bodyText": "friendly reminder about these comments", "author": "rubenada", "createdAt": "2020-08-24T09:09:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MjMxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc1OTYyNg==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r475759626", "bodyText": "oops. I have missed this comment.\nWill address this one and another comment.", "author": "amaliujia", "createdAt": "2020-08-24T16:57:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MjMxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc2NzA1Nw==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r475767057", "bodyText": "intersectCollationAndJoinKey is a reasonable name for me.", "author": "amaliujia", "createdAt": "2020-08-24T17:11:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MjMxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MjQzNA==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r439782434", "bodyText": "Do we need to keep the keys order?", "author": "hsyuan", "createdAt": "2020-06-14T01:23:33Z", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -222,6 +277,30 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n     return mapping;\n   }\n \n+  private RelCollation extendCollation(RelCollation collation, List<Integer> keys) {\n+    List<RelFieldCollation> fieldsForNewCollation = new ArrayList<>(keys.size());\n+    fieldsForNewCollation.addAll(collation.getFieldCollations());\n+    Set<Integer> keySet = new HashSet<>(keys);", "originalCommit": "fee95d236a1042baa7672bf74b764e82f8465717", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4NDEyMQ==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r439784121", "bodyText": "No for subset cases. For example, required collation [foo.a, foo.b] defined on foo.a=bar.a and foo.b=bar.b and foo.c=bar.c and foo.d=bar.d, either pass down [foo.a, foo.b, foo.c, foo.d] or pass down [foo.a, foo.b, foo.d, foo.c] will give correct answer (same to push the same collations to right join input).\nIt is because, for MergeJoin implementation, the pointers moves when left tuple not equals to right tuple, and the only requirement is next tuple should be bigger than previous ones.\nStill use example above:\nleft join input and right join input both are sorted by [a, b, d, c]. So\n\nleft_tuple.compare(right_tuple) < 0, move left pointer, of course next tuple will be both bigger than a) the previous left tuple b) the current right tuple (due to they are all sorted by [a, b]).\nsame for ``left_tuple.compare(right_tuple) > 0` case.", "author": "amaliujia", "createdAt": "2020-06-14T02:03:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MjQzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4NDI0OA==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r439784248", "bodyText": "to add a bit explanation on the example above, the only usefulness of pushed collocations on [d, c], is just to maintain increasing order when move left pointer on left join input during merging. Thus [c, d] will achieve the same thing.", "author": "amaliujia", "createdAt": "2020-06-14T02:06:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MjQzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc5MDIzNg==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r439790236", "bodyText": "Why not just use bitset.except to compute the diff keys?", "author": "hsyuan", "createdAt": "2020-06-14T04:24:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MjQzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc5MTcyNw==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r439791727", "bodyText": "Will check how to use bitset.except.\nMeanwhile, in fact, the ordering does matter for EnumerableMergeJoin, it is because key selector and key comparator are constructed by join key ordering.\nThus we have to follow join key ordering to extend required collations.", "author": "amaliujia", "createdAt": "2020-06-14T04:54:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MjQzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkyODQ2Mw==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r439928463", "bodyText": "Use bitset.except now to compute diff.", "author": "amaliujia", "createdAt": "2020-06-15T04:48:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MjQzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc5MDA2NA==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r439790064", "bodyText": "How can it be true if sort keys are subset of left join keys?", "author": "hsyuan", "createdAt": "2020-06-14T04:19:53Z", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -134,31 +137,83 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n       final RelTraitSet required) {\n     // Required collation keys can be subset or superset of merge join keys.\n     RelCollation collation = required.getCollation();\n+    int leftInputFieldCount = left.getRowType().getFieldCount();\n+\n     List<Integer> reqKeys = RelCollations.ordinals(collation);\n-    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n+    List<Integer> leftKeys = joinInfo.leftKeys.toIntegerList();\n+    List<Integer> rightKeys =\n+        joinInfo.rightKeys.incr(leftInputFieldCount).toIntegerList();\n+    List<Integer> rightKeysNotShifted = joinInfo.rightKeys.toIntegerList();\n \n+    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n     ImmutableBitSet leftKeySet = ImmutableBitSet.of(joinInfo.leftKeys);\n     ImmutableBitSet rightKeySet = ImmutableBitSet.of(joinInfo.rightKeys)\n-        .shift(left.getRowType().getFieldCount());\n+        .shift(leftInputFieldCount);\n \n-    // Only consider exact key match for now\n     if (reqKeySet.equals(leftKeySet)) {\n+      // if sort keys equal to left join keys, we can pass through all collations directly.\n       Mappings.TargetMapping mapping = buildMapping(true);\n       RelCollation rightCollation = collation.apply(mapping);\n       return Pair.of(\n           required, ImmutableList.of(required,\n           required.replace(rightCollation)));\n+    } else if (containsOrderless(collation, leftKeys)) {", "originalCommit": "fee95d236a1042baa7672bf74b764e82f8465717", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc5MTY4NA==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r439791684", "bodyText": "You might not notice, I have changed the code of containsOrderless and added this\n    if (colKeys.size() < distinctKeys.size()) {\n      return containsOrderlessSubset(collation.getKeys().toIntegerList(), distinctKeys);\n    } else {\n\nSo firstly, collations contains fields less than join keys is allowed. Then, it is only legal if collations follows the ordering of sort keys (and later at runtime, key selector and key comparator are constructed by sort key ordering).", "author": "amaliujia", "createdAt": "2020-06-14T04:53:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc5MDA2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc5MTkwMg==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r439791902", "bodyText": "This breaks the definition of the method name. containsOrderless means the former contains the latter. We can create another method containsOrderless(List<Integer>, List<Integer>) if necessary.", "author": "hsyuan", "createdAt": "2020-06-14T04:57:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc5MDA2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc5MTk1OQ==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r439791959", "bodyText": "I need to update containsOrderlessSubset to make it consider list ordering.", "author": "amaliujia", "createdAt": "2020-06-14T04:58:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc5MDA2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkyODUyNw==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r439928527", "bodyText": "Add containsOrderless(List<Integer>, List<Integer>) now to obey the naming convention.", "author": "amaliujia", "createdAt": "2020-06-15T04:48:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc5MDA2NA=="}], "type": "inlineReview"}, {"oid": "003479ad81f463ff120a987c349ccc6c2e9396e9", "url": "https://github.com/apache/calcite/commit/003479ad81f463ff120a987c349ccc6c2e9396e9", "message": "[CALCITE-4015] Pass through parent collation request on subset or superset of join keys for EnumerableMergeJoin.\n\nCollations can pass through even when required collations are subset or superset on join keys.\n\nFor subset case, collations must be extended to make sure join keys are all sorted. Collations must be the prefix of sort keys.\n\nFor superset case, collations must be either all defined on left join input, or right join input. Collations must be prefix of join keys. All collations can be pushed down to the side on which collations are fully defiend. Only collations that are defined on join keys can be pushed down to another side.", "committedDate": "2020-06-20T20:17:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg2MzgxNw==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r472863817", "bodyText": "I would name this method (and the following one) just containsOrderless, i.e. provide 4 overloaded methods with that name.", "author": "rubenada", "createdAt": "2020-08-19T08:42:38Z", "path": "core/src/main/java/org/apache/calcite/rel/RelCollations.java", "diffHunk": "@@ -199,25 +199,45 @@ public static boolean contains(List<RelCollation> collations,\n    * @param keys List of keys\n    * @return Whether the collection contains the given keys\n    */\n-  private static boolean containsOrderless(RelCollation collation,\n+  public static boolean containsOrderless(RelCollation collation,\n       List<Integer> keys) {\n     final List<Integer> distinctKeys = Util.distinctList(keys);\n     final ImmutableBitSet keysBitSet = ImmutableBitSet.of(distinctKeys);\n     List<Integer> colKeys = Util.distinctList(collation.getKeys());\n+\n     if (colKeys.size() < distinctKeys.size()) {\n       return false;\n+    } else {\n+      ImmutableBitSet bitset = ImmutableBitSet.of(\n+          colKeys.subList(0, distinctKeys.size()));\n+      return bitset.equals(keysBitSet);\n+    }\n+  }\n+\n+  /** Returns whether a collation is contained by a given list of keys regardless ordering.\n+   *\n+   * @param collation Collation\n+   * @param keys List of keys\n+   * @return Whether the collection contains the given keys\n+   */\n+  public static boolean containsOrderless(\n+      List<Integer> keys, RelCollation collation) {\n+    final List<Integer> distinctKeys = Util.distinctList(keys);\n+    List<Integer> colKeys = Util.distinctList(collation.getKeys());\n+\n+    if (colKeys.size() > distinctKeys.size()) {\n+      return false;\n+    } else {\n+      return colKeys.stream().allMatch(i -> distinctKeys.contains(i));\n     }\n-    ImmutableBitSet bitset = ImmutableBitSet.of(\n-        colKeys.subList(0, distinctKeys.size()));\n-    return bitset.equals(keysBitSet);\n   }\n \n   /**\n    * Returns whether one of a list of collations contains the given list of keys\n    * regardless the order.\n    */\n-  public static boolean containsOrderless(List<RelCollation> collations,\n-      List<Integer> keys) {\n+  public static boolean collationsContainKeysOrderless(", "originalCommit": "003479ad81f463ff120a987c349ccc6c2e9396e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzMxNjcyNw==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r473316727", "bodyText": "The reasons that I didn't use overloaded approach\n\nthese names are in the format of A verb B, means the first parameter contains the second parameter. And arguments of these functions have an ordering of A and B. I think this is more readable.\nFor Java, List is the same type. For example, List<Integer>  and List<Collation> are both List<T> thus List<Object>. So we cannot overload, for example collationsContainKeysOrderless and keysContainCollationsOrderless", "author": "amaliujia", "createdAt": "2020-08-19T21:02:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg2MzgxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzkzMDMxOA==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r473930318", "bodyText": "Ok, I understand, thanks for the explanation.", "author": "rubenada", "createdAt": "2020-08-20T12:25:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg2MzgxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg2NTI0NQ==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r472865245", "bodyText": "minor: typo in 'defiend'", "author": "rubenada", "createdAt": "2020-08-19T08:44:54Z", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -222,6 +277,48 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n     return mapping;\n   }\n \n+  /**\n+   * This function extends collation by appending new collation fields defiend on keys.", "originalCommit": "003479ad81f463ff120a987c349ccc6c2e9396e9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjk0MTE3OQ==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r472941179", "bodyText": "Given that containsOrderless already does a Util.distinctList(keys), we could skip it here.\nThe same applies to collationsContainKeysOrderless", "author": "rubenada", "createdAt": "2020-08-19T10:55:25Z", "path": "core/src/main/java/org/apache/calcite/rel/RelCollations.java", "diffHunk": "@@ -227,6 +247,21 @@ public static boolean containsOrderless(List<RelCollation> collations,\n     return false;\n   }\n \n+  /**\n+   * Returns whether one of a list of collations is contained by the given list of keys\n+   * regardless the order.\n+   */\n+  public static boolean keysContainCollationsOrderless(\n+      List<Integer> keys,  List<RelCollation> collations) {\n+    final List<Integer> distinctKeys = Util.distinctList(keys);", "originalCommit": "003479ad81f463ff120a987c349ccc6c2e9396e9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzAwMTAwNQ==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r473001005", "bodyText": "I think it would be helpful to describe the general logic and all the different cases in a javadoc on passThroughTraits", "author": "rubenada", "createdAt": "2020-08-19T12:46:29Z", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -134,31 +138,82 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n       final RelTraitSet required) {\n     // Required collation keys can be subset or superset of merge join keys.\n     RelCollation collation = required.getCollation();\n+    int leftInputFieldCount = left.getRowType().getFieldCount();\n+\n     List<Integer> reqKeys = RelCollations.ordinals(collation);\n-    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n+    List<Integer> leftKeys = joinInfo.leftKeys.toIntegerList();\n+    List<Integer> rightKeys =\n+        joinInfo.rightKeys.incr(leftInputFieldCount).toIntegerList();\n \n+    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n     ImmutableBitSet leftKeySet = ImmutableBitSet.of(joinInfo.leftKeys);\n     ImmutableBitSet rightKeySet = ImmutableBitSet.of(joinInfo.rightKeys)\n-        .shift(left.getRowType().getFieldCount());\n+        .shift(leftInputFieldCount);\n \n-    // Only consider exact key match for now\n     if (reqKeySet.equals(leftKeySet)) {\n+      // if sort keys equal to left join keys, we can pass through all collations directly.\n       Mappings.TargetMapping mapping = buildMapping(true);\n       RelCollation rightCollation = collation.apply(mapping);\n       return Pair.of(\n           required, ImmutableList.of(required,\n           required.replace(rightCollation)));\n+    } else if (containsOrderless(leftKeys, collation)) {", "originalCommit": "003479ad81f463ff120a987c349ccc6c2e9396e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE5MzY3OA==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r473193678", "bodyText": "Got it. Will give a summary as java doc.", "author": "amaliujia", "createdAt": "2020-08-19T17:11:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzAwMTAwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzMzODg0Mg==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r473338842", "bodyText": "Added a summary.", "author": "amaliujia", "createdAt": "2020-08-19T21:27:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzAwMTAwNQ=="}], "type": "inlineReview"}, {"oid": "b3af0bb59afb080641b10455804ef65847e09800", "url": "https://github.com/apache/calcite/commit/b3af0bb59afb080641b10455804ef65847e09800", "message": "fixup! address comment", "committedDate": "2020-08-19T21:27:06Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ0ODkzNw==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r475448937", "bodyText": "maybe we could also add some unit tests for the new method keysContainCollationsOrderless?", "author": "rubenada", "createdAt": "2020-08-24T09:08:53Z", "path": "core/src/test/java/org/apache/calcite/rel/RelCollationTest.java", "diffHunk": "@@ -84,18 +84,36 @@\n         is(true));\n   }\n \n-  /** Unit test for {@link RelCollations#containsOrderless(List, List)}. */\n+  /** Unit test for {@link RelCollations#collationsContainKeysOrderless(List, List)}. */", "originalCommit": "9cbb7c31d1e0b616792f15abf6c46646a1c61a1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgyOTg2NA==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r475829864", "bodyText": "Makes sense. Added the test.", "author": "amaliujia", "createdAt": "2020-08-24T19:00:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ0ODkzNw=="}], "type": "inlineReview"}, {"oid": "a1bbb09a5eee38621cf1bf8b1448a9f9f7255fa6", "url": "https://github.com/apache/calcite/commit/a1bbb09a5eee38621cf1bf8b1448a9f9f7255fa6", "message": "[CALCITE-4015] Pass through parent collation request on subset or superset of join keys for EnumerableMergeJoin.\n\nCollations can pass through even when required collations are subset or superset on join keys.\n\nFor subset case, collations must be extended to make sure join keys are all sorted. Collations must be the prefix of sort keys.\n\nFor superset case, collations must be either all defined on left join input, or right join input. Collations must be prefix of join keys. All collations can be pushed down to the side on which collations are fully defiend. Only collations that are defined on join keys can be pushed down to another side.", "committedDate": "2020-08-24T22:12:44Z", "type": "commit"}, {"oid": "a1bbb09a5eee38621cf1bf8b1448a9f9f7255fa6", "url": "https://github.com/apache/calcite/commit/a1bbb09a5eee38621cf1bf8b1448a9f9f7255fa6", "message": "[CALCITE-4015] Pass through parent collation request on subset or superset of join keys for EnumerableMergeJoin.\n\nCollations can pass through even when required collations are subset or superset on join keys.\n\nFor subset case, collations must be extended to make sure join keys are all sorted. Collations must be the prefix of sort keys.\n\nFor superset case, collations must be either all defined on left join input, or right join input. Collations must be prefix of join keys. All collations can be pushed down to the side on which collations are fully defiend. Only collations that are defined on join keys can be pushed down to another side.", "committedDate": "2020-08-24T22:12:44Z", "type": "forcePushed"}]}