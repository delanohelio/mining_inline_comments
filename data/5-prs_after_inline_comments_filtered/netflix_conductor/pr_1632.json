{"pr_number": 1632, "pr_title": "use semaphore instead of inmemory queue for processing system tasks", "pr_createdAt": "2020-04-09T07:59:24Z", "pr_url": "https://github.com/Netflix/conductor/pull/1632", "timeline": [{"oid": "18b2f08a5465a67821d4c96630ea24bb672a8cd1", "url": "https://github.com/Netflix/conductor/commit/18b2f08a5465a67821d4c96630ea24bb672a8cd1", "message": "use semaphore instead of inmemory queue for processing system tasks", "committedDate": "2020-04-09T08:10:18Z", "type": "forcePushed"}, {"oid": "53a458811d5a92fefeed83340ede1518b79f3118", "url": "https://github.com/Netflix/conductor/commit/53a458811d5a92fefeed83340ede1518b79f3118", "message": "use semaphore instead of inmemory queue for processing system tasks", "committedDate": "2020-04-09T23:02:44Z", "type": "forcePushed"}, {"oid": "45cf1f0eafb9da7a31bc0d3e24261dd2e67b2b43", "url": "https://github.com/Netflix/conductor/commit/45cf1f0eafb9da7a31bc0d3e24261dd2e67b2b43", "message": "use semaphore instead of inmemory queue for processing system tasks", "committedDate": "2020-04-09T23:17:41Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUzMDM3NQ==", "url": "https://github.com/Netflix/conductor/pull/1632#discussion_r406530375", "bodyText": "Consider monitoring this to see how often we run into this and potentially leverage this metric to scale out system task workers.", "author": "kishorebanala", "createdAt": "2020-04-09T23:27:45Z", "path": "core/src/main/java/com/netflix/conductor/core/execution/tasks/SystemTaskExecutor.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.netflix.conductor.core.execution.tasks;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.netflix.conductor.core.config.Configuration;\n+import com.netflix.conductor.core.execution.WorkflowExecutor;\n+import com.netflix.conductor.core.utils.QueueUtils;\n+import com.netflix.conductor.core.utils.SemaphoreUtil;\n+import com.netflix.conductor.dao.QueueDAO;\n+import com.netflix.conductor.metrics.Monitors;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Manages the threadpool used by system task workers for execution.\n+ */\n+public class SystemTaskExecutor {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(SystemTaskExecutor.class);\n+\n+    private final int callbackTime;\n+    private final QueueDAO queueDAO;\n+\n+    ExecutionConfig defaultExecutionConfig;\n+    private final WorkflowExecutor workflowExecutor;\n+    private final Configuration config;\n+\n+    ConcurrentHashMap<String, ExecutionConfig> queueExecutionConfigMap = new ConcurrentHashMap<>();\n+\n+    SystemTaskExecutor(QueueDAO queueDAO, WorkflowExecutor workflowExecutor, Configuration config) {\n+        this.config = config;\n+        int threadCount = config.getIntProperty(\"workflow.system.task.worker.thread.count\", 10);\n+        this.callbackTime = config.getIntProperty(\"workflow.system.task.worker.callback.seconds\", 30);\n+\n+        String threadNameFormat = \"system-task-worker-%d\";\n+        this.defaultExecutionConfig = new ExecutionConfig(threadCount, threadNameFormat);\n+        this.workflowExecutor = workflowExecutor;\n+        this.queueDAO = queueDAO;\n+\n+        LOGGER.info(\"Initialized the SystemTaskExecutor with {} threads and callback time: {} seconds\", threadCount,\n+            callbackTime);\n+    }\n+\n+    void pollAndExecute(String queueName) {\n+        // get the remaining capacity of worker queue to prevent queue full exception\n+        ExecutionConfig executionConfig = getExecutionConfig(queueName);\n+        SemaphoreUtil semaphoreUtil = executionConfig.getSemaphoreUtil();\n+        ExecutorService executorService = executionConfig.getExecutorService();\n+        String taskName = QueueUtils.getTaskType(queueName);\n+\n+        if (!semaphoreUtil.canProcess()) {\n+            // no available permits, do not poll", "originalCommit": "45cf1f0eafb9da7a31bc0d3e24261dd2e67b2b43", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUzMDg0NQ==", "url": "https://github.com/Netflix/conductor/pull/1632#discussion_r406530845", "bodyText": "semaphoreUtil.completeProcessing(); this can be part of finally block.", "author": "kishorebanala", "createdAt": "2020-04-09T23:29:10Z", "path": "core/src/main/java/com/netflix/conductor/core/execution/tasks/SystemTaskExecutor.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.netflix.conductor.core.execution.tasks;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.netflix.conductor.core.config.Configuration;\n+import com.netflix.conductor.core.execution.WorkflowExecutor;\n+import com.netflix.conductor.core.utils.QueueUtils;\n+import com.netflix.conductor.core.utils.SemaphoreUtil;\n+import com.netflix.conductor.dao.QueueDAO;\n+import com.netflix.conductor.metrics.Monitors;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Manages the threadpool used by system task workers for execution.\n+ */\n+public class SystemTaskExecutor {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(SystemTaskExecutor.class);\n+\n+    private final int callbackTime;\n+    private final QueueDAO queueDAO;\n+\n+    ExecutionConfig defaultExecutionConfig;\n+    private final WorkflowExecutor workflowExecutor;\n+    private final Configuration config;\n+\n+    ConcurrentHashMap<String, ExecutionConfig> queueExecutionConfigMap = new ConcurrentHashMap<>();\n+\n+    SystemTaskExecutor(QueueDAO queueDAO, WorkflowExecutor workflowExecutor, Configuration config) {\n+        this.config = config;\n+        int threadCount = config.getIntProperty(\"workflow.system.task.worker.thread.count\", 10);\n+        this.callbackTime = config.getIntProperty(\"workflow.system.task.worker.callback.seconds\", 30);\n+\n+        String threadNameFormat = \"system-task-worker-%d\";\n+        this.defaultExecutionConfig = new ExecutionConfig(threadCount, threadNameFormat);\n+        this.workflowExecutor = workflowExecutor;\n+        this.queueDAO = queueDAO;\n+\n+        LOGGER.info(\"Initialized the SystemTaskExecutor with {} threads and callback time: {} seconds\", threadCount,\n+            callbackTime);\n+    }\n+\n+    void pollAndExecute(String queueName) {\n+        // get the remaining capacity of worker queue to prevent queue full exception\n+        ExecutionConfig executionConfig = getExecutionConfig(queueName);\n+        SemaphoreUtil semaphoreUtil = executionConfig.getSemaphoreUtil();\n+        ExecutorService executorService = executionConfig.getExecutorService();\n+        String taskName = QueueUtils.getTaskType(queueName);\n+\n+        if (!semaphoreUtil.canProcess()) {\n+            // no available permits, do not poll\n+            return;\n+        }\n+        try {\n+            List<String> polledTaskIds = queueDAO.pop(queueName, 1, 200);\n+            Monitors.recordTaskPoll(queueName);\n+            LOGGER.debug(\"Polling queue:{}, got {} tasks\", queueName, polledTaskIds.size());\n+            if (polledTaskIds.size() == 1 && StringUtils.isNotBlank(polledTaskIds.get(0))) {\n+                String taskId = polledTaskIds.get(0);\n+                LOGGER.debug(\"Task: {} from queue: {} being sent to the workflow executor\", taskId, queueName);\n+                Monitors.recordTaskPollCount(queueName, \"\", 1);\n+\n+                WorkflowSystemTask systemTask = SystemTaskWorkerCoordinator.taskNameWorkflowTaskMapping.get(taskName);\n+                CompletableFuture<Void> taskCompletableFuture = CompletableFuture.runAsync(() ->\n+                    workflowExecutor.executeSystemTask(systemTask, taskId, callbackTime), executorService);\n+\n+                // release permit after processing is complete\n+                taskCompletableFuture.whenComplete((r, e) -> semaphoreUtil.completeProcessing());\n+            } else {\n+                // no task polled, release permit\n+                semaphoreUtil.completeProcessing();\n+            }\n+        } catch (Exception e) {\n+            // release the permit if exception is thrown during polling, because the thread would not be busy\n+            semaphoreUtil.completeProcessing();", "originalCommit": "45cf1f0eafb9da7a31bc0d3e24261dd2e67b2b43", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU1MjUyNA==", "url": "https://github.com/Netflix/conductor/pull/1632#discussion_r406552524", "bodyText": "If this is put in a finally block, permits will be released twice in case of successful system task execution, once at line 88 (after the future is completed) and then again in finally block.", "author": "apanicker-nflx", "createdAt": "2020-04-10T00:54:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUzMDg0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUzMzMwNQ==", "url": "https://github.com/Netflix/conductor/pull/1632#discussion_r406533305", "bodyText": "+1", "author": "kishorebanala", "createdAt": "2020-04-09T23:38:57Z", "path": "core/src/main/java/com/netflix/conductor/core/execution/tasks/SystemTaskWorkerCoordinator.java", "diffHunk": "@@ -13,220 +13,116 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-/**\n- *\n- */\n package com.netflix.conductor.core.execution.tasks;\n \n import com.google.common.annotations.VisibleForTesting;\n-import com.google.common.util.concurrent.ThreadFactoryBuilder;\n import com.netflix.conductor.core.config.Configuration;\n import com.netflix.conductor.core.execution.WorkflowExecutor;\n import com.netflix.conductor.core.utils.QueueUtils;\n import com.netflix.conductor.dao.QueueDAO;\n import com.netflix.conductor.metrics.Monitors;\n import java.util.HashSet;\n-import java.util.List;\n import java.util.Map;\n import java.util.Objects;\n import java.util.Set;\n import java.util.concurrent.BlockingQueue;\n import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Executors;\n import java.util.concurrent.LinkedBlockingQueue;\n-import java.util.concurrent.RejectedExecutionException;\n-import java.util.concurrent.ThreadFactory;\n-import java.util.concurrent.ThreadPoolExecutor;\n import java.util.concurrent.TimeUnit;\n import javax.inject.Inject;\n import javax.inject.Singleton;\n import org.apache.commons.lang3.StringUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-/**\n- * @author Viren\n- *\n- */\n @Singleton\n public class SystemTaskWorkerCoordinator {\n \n-\tprivate static final Logger logger = LoggerFactory.getLogger(SystemTaskWorkerCoordinator.class);\n-\n-\tprivate QueueDAO queueDAO;\n-\n-\tprivate WorkflowExecutor workflowExecutor;\n-\n-\tprivate ExecutorService executorService;\n-\n-\tprivate int workerQueueSize;\n-\n-\t//Number of items to poll for\n-\tprivate int pollCount;\n-\n-\t//Interval in ms at which the polling is done\n-\tprivate int pollInterval;\n-\n-\tprivate LinkedBlockingQueue<Runnable> workerQueue;\n-\n-\tprivate int unackTimeout;\n-\n-\tprivate Configuration config;\n-\n-\tprivate final String executionNameSpace;\n-\n-\tstatic BlockingQueue<String> queue = new LinkedBlockingQueue<>();\n-\n-\tprivate static Set<String> listeningTaskQueues = new HashSet<>();\n-\n-\tExecutionConfig defaultExecutionConfig;\n-\n-\tConcurrentHashMap<String, ExecutionConfig> queueExecutionConfigMap = new ConcurrentHashMap<>();\n-\n-\tpublic static Map<String, WorkflowSystemTask> taskNameWorkFlowTaskMapping = new ConcurrentHashMap<>();\n-\n-\tprivate static final String className = SystemTaskWorkerCoordinator.class.getName();\n-\n-\t@Inject\n-\tpublic SystemTaskWorkerCoordinator(QueueDAO queueDAO, WorkflowExecutor workflowExecutor, Configuration config) {\n-\t\tthis.queueDAO = queueDAO;\n-\t\tthis.workflowExecutor = workflowExecutor;\n-\t\tthis.config = config;\n-\t\tthis.unackTimeout = config.getIntProperty(\"workflow.system.task.worker.callback.seconds\", 30);\n-\t\tint threadCount = config.getIntProperty(\"workflow.system.task.worker.thread.count\", 10);\n-\t\tthis.pollCount = config.getIntProperty(\"workflow.system.task.worker.poll.count\", 10);\n-\t\tthis.pollInterval = config.getIntProperty(\"workflow.system.task.worker.poll.interval\", 50);\n-\t\tthis.workerQueueSize = config.getIntProperty(\"workflow.system.task.worker.queue.size\", 100);\n-\t\tthis.workerQueue = new LinkedBlockingQueue<>(workerQueueSize);\n-\t\tthis.executionNameSpace =config.getProperty(\"workflow.system.task.worker.executionNameSpace\",\"\");\n-\n-\t\tif(threadCount > 0) {\n-\t\t\tThreadFactory threadFactory = new ThreadFactoryBuilder().setNameFormat(\"system-task-worker-%d\").build();\n-\t\t\tthis.executorService = new ThreadPoolExecutor(threadCount, threadCount,\n-\t                0L, TimeUnit.MILLISECONDS,\n-\t                workerQueue,\n-\t                threadFactory);\n-\t\t\tthis.defaultExecutionConfig = new ExecutionConfig(this.executorService, this.workerQueue);\n-\t\t\tnew Thread(this::listen).start();\n-\t\t\tlogger.info(\"System Task Worker initialized with {} threads and a callback time of {} seconds and queue size: {} with pollCount: {} and poll interval: {}\", threadCount, unackTimeout, workerQueueSize, pollCount, pollInterval);\n-\t\t} else {\n-\t\t\tlogger.info(\"System Task Worker DISABLED\");\n-\t\t}\n-\t}\n-\n-\tstatic synchronized void add(WorkflowSystemTask systemTask) {\n-\t\tlogger.info(\"Adding the queue for system task: {}\", systemTask.getName());\n-\t\ttaskNameWorkFlowTaskMapping.put(systemTask.getName(),systemTask);\n-\t\tqueue.add(systemTask.getName());\n-\t}\n-\n-\tprivate void listen() {\n-\t\ttry {\n-\t\t\t//noinspection InfiniteLoopStatement\n-\t\t\tfor(;;) {\n-\t\t\t\tString workflowSystemTaskQueueName = queue.poll(60, TimeUnit.SECONDS);\n-\t\t\t\tif (workflowSystemTaskQueueName != null && !listeningTaskQueues.contains(workflowSystemTaskQueueName) && shouldListen(workflowSystemTaskQueueName)) {\n-\t\t\t\t\tlisten(workflowSystemTaskQueueName);\n-\t\t\t\t\tlisteningTaskQueues.add(workflowSystemTaskQueueName);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}catch(InterruptedException ie) {\n-\t\t\tMonitors.error(className, \"listen\");\n-\t\t\tlogger.warn(\"Error listening for workflow system tasks\", ie);\n-\t\t}\n-\t}\n-\n-\tprivate void listen(String queueName) {\n-\t\tExecutors.newSingleThreadScheduledExecutor().scheduleWithFixedDelay(() -> pollAndExecute(queueName), 1000, pollInterval, TimeUnit.MILLISECONDS);\n-\t\tlogger.info(\"Started listening for queue: {}\", queueName);\n-\t}\n-\n-\t@VisibleForTesting\n-\tvoid pollAndExecute(String queueName) {\n-\t\ttry {\n-\t\t\tif(config.disableAsyncWorkers()) {\n-\t\t\t\tlogger.warn(\"System Task Worker is DISABLED.  Not polling for system task in queue : {}\", queueName);\n-\t\t\t\treturn;\n-\t\t\t}\n-\t\t\t// get the remaining capacity of worker queue to prevent queue full exception\n-\t\t\tExecutionConfig executionConfig = getExecutionConfig(queueName);\n-\t\t\tLinkedBlockingQueue<Runnable> workerQueue = executionConfig.workerQueue;\n-\t\t\tint realPollCount = Math.min(workerQueue.remainingCapacity(), pollCount);\n-\t\t\tif (realPollCount <= 0) {\n-                logger.debug(\"All workers are busy, not polling. queue size: {}, max: {}, task:{}\", workerQueue.size(),\n-\t\t\t\t\tworkerQueueSize, queueName);\n-                return;\n-\t\t\t}\n-\n-\t\t\tList<String> polledTaskIds = queueDAO.pop(queueName, realPollCount, 200);\n-\t\t\tMonitors.recordTaskPoll(queueName);\n-\t\t\tlogger.debug(\"Polling for {}, got {} tasks\", queueName, polledTaskIds.size());\n-\t\t\tfor(String taskId : polledTaskIds) {\n-\t\t\t\tlogger.debug(\"Task: {} from queue: {} being sent to the workflow executor\", taskId, queueName);\n-\t\t\t\ttry {\n-\t\t\t\t\tString taskName = QueueUtils.getTaskType(queueName);\n-\t\t\t\t\tWorkflowSystemTask systemTask = taskNameWorkFlowTaskMapping.get(taskName);\n-\t\t\t\t\tExecutorService executorService = executionConfig.service;\n-\t\t\t\t\texecutorService.submit(() -> workflowExecutor.executeSystemTask(systemTask, taskId, unackTimeout));\n-\t\t\t\t} catch(RejectedExecutionException ree) {\n-\t\t\t\t\tlogger.warn(\"Queue full for workers. Size: {}, queue:{}\", workerQueue.size(), queueName);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t} catch (Exception e) {\n-\t\t\tMonitors.error(className, \"pollAndExecute\");\n-\t\t\tlogger.error(\"Error executing system task in queue:{}\", queueName, e);\n-\t\t}\n-\t}\n-\n-\n-\tpublic boolean isFromCoordinatorExecutionNameSpace(String queueName) {\n-\t\tString queueExecutionNameSpace = QueueUtils.getExecutionNameSpace(queueName);\n-\t\treturn StringUtils.equals(queueExecutionNameSpace, this.executionNameSpace);\n-\t}\n-\n-\tprivate boolean shouldListen(String workflowSystemTaskQueueName) {\n-\t\treturn isFromCoordinatorExecutionNameSpace(workflowSystemTaskQueueName) && isSystemTask(workflowSystemTaskQueueName);\n-\t}\n-\n-\n-\tpublic static boolean isSystemTask(String queue) {\n-\n-\t\tString taskType = QueueUtils.getTaskType(queue);\n-\n-\t\tif(StringUtils.isNotBlank(taskType)) {\n-\n-\t\t\tWorkflowSystemTask task = taskNameWorkFlowTaskMapping.get(taskType);\n-\t\t\treturn Objects.nonNull(task) && task.isAsync();\n-\n-\t\t}\n-\n-\t\treturn false;\n-\t}\n-\n-\n-\n-\tpublic ExecutionConfig getExecutionConfig(String taskQueue) {\n-\n-\t\tif (!QueueUtils.isIsolatedQueue(taskQueue)) {\n-\t\t\treturn this.defaultExecutionConfig;\n-\t\t}\n-\n-\t\treturn queueExecutionConfigMap.computeIfAbsent(taskQueue, __ -> this.createExecutionConfig());\n-\n-\t}\n-\n-\tprivate ExecutionConfig createExecutionConfig() {\n-\n-\t\tint workerQueueSize = config.getIntProperty(\"workflow.isolated.system.task.worker.queue.size\", 100);\n-\t\tLinkedBlockingQueue<Runnable> workerQueue = new LinkedBlockingQueue<>(workerQueueSize);\n-\t\tint threadCount = config.getIntProperty(\"workflow.isolated.system.task.worker.thread.count\", 1);\n-\t\tThreadFactory threadFactory = new ThreadFactoryBuilder().setNameFormat(\"isolated-system-task-worker-%d\").build();\n-\n-\t\treturn new ExecutionConfig(new ThreadPoolExecutor(threadCount, threadCount,\n-\t\t\t\t0L, TimeUnit.MILLISECONDS,\n-\t\t\t\tworkerQueue,\n-\t\t\t\tthreadFactory), workerQueue);\n-\n-\t}\n+    private static final Logger LOGGER = LoggerFactory.getLogger(SystemTaskWorkerCoordinator.class);\n+\n+    private SystemTaskExecutor systemTaskExecutor;\n+    private final Configuration config;\n+\n+    private final int pollInterval;\n+    private final String executionNameSpace;\n+\n+    static BlockingQueue<String> queue = new LinkedBlockingQueue<>();\n+    private static Set<String> listeningTaskQueues = new HashSet<>();\n+    public static Map<String, WorkflowSystemTask> taskNameWorkflowTaskMapping = new ConcurrentHashMap<>();\n+\n+    private static final String CLASS_NAME = SystemTaskWorkerCoordinator.class.getName();\n+\n+    @Inject\n+    public SystemTaskWorkerCoordinator(QueueDAO queueDAO, WorkflowExecutor workflowExecutor, Configuration config) {\n+        this.config = config;\n+\n+        this.executionNameSpace = config.getProperty(\"workflow.system.task.worker.executionNameSpace\", \"\");\n+        this.pollInterval = config.getIntProperty(\"workflow.system.task.worker.poll.interval\", 50);\n+        int threadCount = config.getIntProperty(\"workflow.system.task.worker.thread.count\", 10);\n+        if (threadCount > 0) {\n+            this.systemTaskExecutor = new SystemTaskExecutor(queueDAO, workflowExecutor, config);\n+            new Thread(this::listen).start();\n+            LOGGER.info(\"System Task Worker Coordinator initialized with poll interval: {}\", pollInterval);\n+        } else {\n+            LOGGER.info(\"System Task Worker DISABLED\");\n+        }\n+    }\n+\n+    static synchronized void add(WorkflowSystemTask systemTask) {\n+        LOGGER.info(\"Adding the queue for system task: {}\", systemTask.getName());\n+        taskNameWorkflowTaskMapping.put(systemTask.getName(), systemTask);\n+        queue.add(systemTask.getName());\n+    }\n+\n+    private void listen() {\n+        try {\n+            for (; ; ) {\n+                String workflowSystemTaskQueueName = queue.poll(60, TimeUnit.SECONDS);\n+                if (workflowSystemTaskQueueName != null && !listeningTaskQueues.contains(workflowSystemTaskQueueName)\n+                    && shouldListen(workflowSystemTaskQueueName)) {\n+                    listen(workflowSystemTaskQueueName);\n+                    listeningTaskQueues.add(workflowSystemTaskQueueName);\n+                }\n+            }\n+        } catch (InterruptedException ie) {\n+            Monitors.error(CLASS_NAME, \"listen\");\n+            LOGGER.warn(\"Error listening for workflow system tasks\", ie);\n+        }\n+    }\n+\n+    private void listen(String queueName) {\n+        Executors.newSingleThreadScheduledExecutor()\n+            .scheduleWithFixedDelay(() -> pollAndExecute(queueName), 1000, pollInterval, TimeUnit.MILLISECONDS);\n+        LOGGER.info(\"Started listening for queue: {}\", queueName);\n+    }\n+\n+    private void pollAndExecute(String queueName) {\n+        if (config.disableAsyncWorkers()) {\n+            LOGGER.warn(\"System Task Worker is DISABLED.  Not polling for system task in queue : {}\", queueName);\n+            return;\n+        }\n+        systemTaskExecutor.pollAndExecute(queueName);\n+    }\n+\n+    @VisibleForTesting\n+    boolean isFromCoordinatorExecutionNameSpace(String queueName) {\n+        String queueExecutionNameSpace = QueueUtils.getExecutionNameSpace(queueName);\n+        return StringUtils.equals(queueExecutionNameSpace, executionNameSpace);\n+    }\n+\n+    private boolean shouldListen(String workflowSystemTaskQueueName) {\n+        return isFromCoordinatorExecutionNameSpace(workflowSystemTaskQueueName)\n+            && isAsyncSystemTask(workflowSystemTaskQueueName);\n+    }\n+\n+    @VisibleForTesting\n+    boolean isAsyncSystemTask(String queue) {", "originalCommit": "45cf1f0eafb9da7a31bc0d3e24261dd2e67b2b43", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f5e77f07ada49e1fa8ab0cda988e80bd62a8131f", "url": "https://github.com/Netflix/conductor/commit/f5e77f07ada49e1fa8ab0cda988e80bd62a8131f", "message": "use semaphore instead of inmemory queue for processing system tasks", "committedDate": "2020-04-10T00:52:04Z", "type": "forcePushed"}, {"oid": "6f12138ba173869a5a4a772afd0fffcd4b9b056e", "url": "https://github.com/Netflix/conductor/commit/6f12138ba173869a5a4a772afd0fffcd4b9b056e", "message": "use semaphore instead of inmemory queue for processing system tasks", "committedDate": "2020-04-10T16:12:58Z", "type": "forcePushed"}, {"oid": "f59f5727169d6639c9547f958b3a7fe2a90ab101", "url": "https://github.com/Netflix/conductor/commit/f59f5727169d6639c9547f958b3a7fe2a90ab101", "message": "use semaphore instead of inmemory queue for processing system tasks", "committedDate": "2020-04-10T19:21:06Z", "type": "commit"}, {"oid": "f59f5727169d6639c9547f958b3a7fe2a90ab101", "url": "https://github.com/Netflix/conductor/commit/f59f5727169d6639c9547f958b3a7fe2a90ab101", "message": "use semaphore instead of inmemory queue for processing system tasks", "committedDate": "2020-04-10T19:21:06Z", "type": "forcePushed"}]}