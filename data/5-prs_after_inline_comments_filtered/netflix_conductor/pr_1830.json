{"pr_number": 1830, "pr_title": "Feature: Task resiliency from QueueDAO failures", "pr_createdAt": "2020-08-17T11:04:02Z", "pr_url": "https://github.com/Netflix/conductor/pull/1830", "timeline": [{"oid": "38bd48c5a60f8f30899ec72dba1b6a7968f6b598", "url": "https://github.com/Netflix/conductor/commit/38bd48c5a60f8f30899ec72dba1b6a7968f6b598", "message": "[WIP] Support for task resiliency on persistence features, and tests to verify the same using AOP based failure injection.\n\n[WIP] Support for task resiliency on persistence features, and tests to verify the same using AOP based failure injection.\n\n[WIP] Support for task resiliency on persistence features, and tests to verify the same using AOP based failure injection.\n\n[WIP] Support for task resiliency on persistence features, and tests to verify the same using AOP based failure injection.\n\nClean up.\n\nClean up.", "committedDate": "2020-08-17T11:15:48Z", "type": "forcePushed"}, {"oid": "6410e9167f9e1ed7e7af757bf0215bc10afc1b77", "url": "https://github.com/Netflix/conductor/commit/6410e9167f9e1ed7e7af757bf0215bc10afc1b77", "message": "Support for task resiliency on persistence features, and tests to verify the same using AOP based failure injection.\n\nAdded the configuration to control WorkflowRepairService from the sweeper service.", "committedDate": "2020-09-11T01:54:34Z", "type": "forcePushed"}, {"oid": "114a91d6d1608693e7011275f987a29c4b08a33f", "url": "https://github.com/Netflix/conductor/commit/114a91d6d1608693e7011275f987a29c4b08a33f", "message": "Support for task resiliency on persistence features, and tests to verify the same using AOP based failure injection.\n\nAdded the configuration to control WorkflowRepairService from the sweeper service.", "committedDate": "2020-09-11T07:41:57Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzIzMjU0Mg==", "url": "https://github.com/Netflix/conductor/pull/1830#discussion_r487232542", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (task.getStatus().equals(Task.Status.SCHEDULED)) {\n          \n          \n            \n                    if (task.getStatus() == Task.Status.SCHEDULED)) {\n          \n      \n    \n    \n  \n\nEnums can be compared using the operator and it also helps avoiding a NullPointerException", "author": "aravindanr", "createdAt": "2020-09-11T19:00:26Z", "path": "core/src/main/java/com/netflix/conductor/core/execution/WorkflowRepairService.java", "diffHunk": "@@ -0,0 +1,112 @@\n+package com.netflix.conductor.core.execution;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.netflix.conductor.common.metadata.tasks.Task;\n+import com.netflix.conductor.common.run.Workflow;\n+import com.netflix.conductor.core.config.Configuration;\n+import com.netflix.conductor.core.execution.tasks.WorkflowSystemTask;\n+import com.netflix.conductor.dao.ExecutionDAO;\n+import com.netflix.conductor.dao.QueueDAO;\n+import com.netflix.conductor.metrics.Monitors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.inject.Inject;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Predicate;\n+\n+/**\n+ * A helper service that tries to keep ExecutionDAO and QueueDAO in sync, based on the\n+ * task or workflow state.\n+ *\n+ * This service expects that the underlying Queueing layer implements QueueDAO.containsMessage method. This can be controlled\n+ * with Configuration.isWorkflowRepairServiceEnabled() property.\n+ */\n+public class WorkflowRepairService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(WorkflowRepairService.class);\n+\n+    private final ExecutionDAO executionDAO;\n+    private final QueueDAO queueDAO;\n+    private final Configuration configuration;\n+\n+    private final Predicate<Task> isSystemTask = task -> WorkflowSystemTask.is(task.getTaskType());\n+\n+    @Inject\n+    public WorkflowRepairService(\n+            ExecutionDAO executionDAO,\n+            QueueDAO queueDAO,\n+            Configuration configuration\n+    ) {\n+        this.executionDAO = executionDAO;\n+        this.queueDAO = queueDAO;\n+        this.configuration = configuration;\n+    }\n+\n+    /**\n+     * Verify and repair if the workflowId exists in deciderQueue, and then if each scheduled task has relevant message\n+     * in the queue.\n+     * @param workflowId\n+     * @param includeTasks\n+     * @return\n+     */\n+    public boolean verifyAndRepairWorkflow(String workflowId, boolean includeTasks) {\n+        Workflow workflow = executionDAO.getWorkflow(workflowId, includeTasks);\n+        AtomicBoolean repaired = new AtomicBoolean(false);\n+        repaired.set(verifyAndRepairDeciderQueue(workflow));\n+        if (includeTasks) {\n+            workflow.getTasks().forEach(task -> {\n+                repaired.set(verifyAndRepairTask(task));\n+            });\n+        }\n+        return repaired.get();\n+    }\n+\n+    /**\n+     * Verify and repair tasks in a workflow\n+     * @param workflowId\n+     */\n+    public void verifyAndRepairWorkflowTasks(String workflowId) {\n+        Workflow workflow = executionDAO.getWorkflow(workflowId, true);\n+        workflow.getTasks().forEach(task -> verifyAndRepairTask(task));\n+    }\n+\n+    /**\n+     * Verify and fix if Workflow decider queue contains this workflowId.\n+     * @param workflow\n+     * @return\n+     */\n+    private boolean verifyAndRepairDeciderQueue(Workflow workflow) {\n+        if (!workflow.getStatus().isTerminal()) {\n+            String queueName = WorkflowExecutor.DECIDER_QUEUE;\n+            if (!queueDAO.containsMessage(queueName, workflow.getWorkflowId())) {\n+                queueDAO.push(queueName, workflow.getWorkflowId(), configuration.getSweepFrequency());\n+                Monitors.recordQueueMessageRepushFromRepairService(queueName);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Verify if ExecutionDAO and QueueDAO agree for the provided task.\n+     * @param task\n+     * @return\n+     */\n+    @VisibleForTesting\n+    protected boolean verifyAndRepairTask(Task task) {\n+        WorkflowSystemTask workflowSystemTask = WorkflowSystemTask.get(task.getTaskType());\n+        if (task.getStatus().equals(Task.Status.SCHEDULED)) {", "originalCommit": "114a91d6d1608693e7011275f987a29c4b08a33f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMyMzQ0MA==", "url": "https://github.com/Netflix/conductor/pull/1830#discussion_r488323440", "bodyText": "Please add license header.", "author": "apanicker-nflx", "createdAt": "2020-09-15T01:13:15Z", "path": "common/src/main/java/com/netflix/conductor/common/constraints/FaultInjectionInterceptor.java", "diffHunk": "@@ -0,0 +1,14 @@\n+package com.netflix.conductor.common.constraints;", "originalCommit": "114a91d6d1608693e7011275f987a29c4b08a33f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMyNDMwNg==", "url": "https://github.com/Netflix/conductor/pull/1830#discussion_r488324306", "bodyText": "This should probably be added to the core module.", "author": "apanicker-nflx", "createdAt": "2020-09-15T01:16:27Z", "path": "common/src/main/java/com/netflix/conductor/common/constraints/FaultInjectionInterceptor.java", "diffHunk": "@@ -0,0 +1,14 @@\n+package com.netflix.conductor.common.constraints;\n+\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * Interceptor intended for failure injection during unit / integration testing.\n+ */\n+@Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD)\n+public @interface FaultInjectionInterceptor {", "originalCommit": "114a91d6d1608693e7011275f987a29c4b08a33f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMyNTAxMg==", "url": "https://github.com/Netflix/conductor/pull/1830#discussion_r488325012", "bodyText": "tasks should be removed from queue before status is updated, else tasks to be CANCELED will be polled and processed by the workers.", "author": "apanicker-nflx", "createdAt": "2020-09-15T01:19:06Z", "path": "core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java", "diffHunk": "@@ -785,6 +782,11 @@ public void terminateWorkflow(Workflow workflow, String reason, String failureWo\n             if (workflow.getWorkflowDefinition().isWorkflowStatusListenerEnabled()) {\n                 workflowStatusListener.onWorkflowTerminated(workflow);\n             }\n+\n+            //remove from the sweep queue", "originalCommit": "114a91d6d1608693e7011275f987a29c4b08a33f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMyNTc0NQ==", "url": "https://github.com/Netflix/conductor/pull/1830#discussion_r488325745", "bodyText": "Does this also account for partial failures?", "author": "apanicker-nflx", "createdAt": "2020-09-15T01:21:36Z", "path": "core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java", "diffHunk": "@@ -1447,6 +1446,19 @@ boolean scheduleTask(Workflow workflow, List<Task> tasks) {\n             // rollbackTasks(workflow.getWorkflowId(), createdTasks);\n             throw new TerminateWorkflowException(errorMsg);\n         }\n+\n+        // On addTaskToQueue failures, ignore the exceptions and let WorkflowRepairService take care of republishing the messages to the queue.", "originalCommit": "114a91d6d1608693e7011275f987a29c4b08a33f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTA4MTczOQ==", "url": "https://github.com/Netflix/conductor/pull/1830#discussion_r489081739", "bodyText": "Yes. Partial failures when adding to queue are fine. For eg., if only 2 of 5 messages are added to the queue and the rest failed, the sweeper service would still check if the queue contains each message as long as the task is in scheduled state, and this can be recovered.", "author": "kishorebanala", "createdAt": "2020-09-15T23:54:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMyNTc0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMyNTc5Nw==", "url": "https://github.com/Netflix/conductor/pull/1830#discussion_r488325797", "bodyText": "Please add license header", "author": "apanicker-nflx", "createdAt": "2020-09-15T01:21:47Z", "path": "core/src/main/java/com/netflix/conductor/core/execution/WorkflowRepairService.java", "diffHunk": "@@ -0,0 +1,112 @@\n+package com.netflix.conductor.core.execution;", "originalCommit": "114a91d6d1608693e7011275f987a29c4b08a33f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMyNjAxNg==", "url": "https://github.com/Netflix/conductor/pull/1830#discussion_r488326016", "bodyText": "It would be better to link out to the method from the javadoc.", "author": "apanicker-nflx", "createdAt": "2020-09-15T01:22:39Z", "path": "core/src/main/java/com/netflix/conductor/core/execution/WorkflowRepairService.java", "diffHunk": "@@ -0,0 +1,112 @@\n+package com.netflix.conductor.core.execution;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.netflix.conductor.common.metadata.tasks.Task;\n+import com.netflix.conductor.common.run.Workflow;\n+import com.netflix.conductor.core.config.Configuration;\n+import com.netflix.conductor.core.execution.tasks.WorkflowSystemTask;\n+import com.netflix.conductor.dao.ExecutionDAO;\n+import com.netflix.conductor.dao.QueueDAO;\n+import com.netflix.conductor.metrics.Monitors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.inject.Inject;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Predicate;\n+\n+/**\n+ * A helper service that tries to keep ExecutionDAO and QueueDAO in sync, based on the\n+ * task or workflow state.\n+ *\n+ * This service expects that the underlying Queueing layer implements QueueDAO.containsMessage method. This can be controlled\n+ * with Configuration.isWorkflowRepairServiceEnabled() property.", "originalCommit": "114a91d6d1608693e7011275f987a29c4b08a33f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMyODA4OA==", "url": "https://github.com/Netflix/conductor/pull/1830#discussion_r488328088", "bodyText": "For system tasks, the tasks are enqueued in the task type queues and not by the task def name, does this line need to change?", "author": "apanicker-nflx", "createdAt": "2020-09-15T01:29:31Z", "path": "core/src/main/java/com/netflix/conductor/core/execution/WorkflowRepairService.java", "diffHunk": "@@ -0,0 +1,112 @@\n+package com.netflix.conductor.core.execution;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.netflix.conductor.common.metadata.tasks.Task;\n+import com.netflix.conductor.common.run.Workflow;\n+import com.netflix.conductor.core.config.Configuration;\n+import com.netflix.conductor.core.execution.tasks.WorkflowSystemTask;\n+import com.netflix.conductor.dao.ExecutionDAO;\n+import com.netflix.conductor.dao.QueueDAO;\n+import com.netflix.conductor.metrics.Monitors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.inject.Inject;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Predicate;\n+\n+/**\n+ * A helper service that tries to keep ExecutionDAO and QueueDAO in sync, based on the\n+ * task or workflow state.\n+ *\n+ * This service expects that the underlying Queueing layer implements QueueDAO.containsMessage method. This can be controlled\n+ * with Configuration.isWorkflowRepairServiceEnabled() property.\n+ */\n+public class WorkflowRepairService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(WorkflowRepairService.class);\n+\n+    private final ExecutionDAO executionDAO;\n+    private final QueueDAO queueDAO;\n+    private final Configuration configuration;\n+\n+    private final Predicate<Task> isSystemTask = task -> WorkflowSystemTask.is(task.getTaskType());\n+\n+    @Inject\n+    public WorkflowRepairService(\n+            ExecutionDAO executionDAO,\n+            QueueDAO queueDAO,\n+            Configuration configuration\n+    ) {\n+        this.executionDAO = executionDAO;\n+        this.queueDAO = queueDAO;\n+        this.configuration = configuration;\n+    }\n+\n+    /**\n+     * Verify and repair if the workflowId exists in deciderQueue, and then if each scheduled task has relevant message\n+     * in the queue.\n+     * @param workflowId\n+     * @param includeTasks\n+     * @return\n+     */\n+    public boolean verifyAndRepairWorkflow(String workflowId, boolean includeTasks) {\n+        Workflow workflow = executionDAO.getWorkflow(workflowId, includeTasks);\n+        AtomicBoolean repaired = new AtomicBoolean(false);\n+        repaired.set(verifyAndRepairDeciderQueue(workflow));\n+        if (includeTasks) {\n+            workflow.getTasks().forEach(task -> {\n+                repaired.set(verifyAndRepairTask(task));\n+            });\n+        }\n+        return repaired.get();\n+    }\n+\n+    /**\n+     * Verify and repair tasks in a workflow\n+     * @param workflowId\n+     */\n+    public void verifyAndRepairWorkflowTasks(String workflowId) {\n+        Workflow workflow = executionDAO.getWorkflow(workflowId, true);\n+        workflow.getTasks().forEach(task -> verifyAndRepairTask(task));\n+    }\n+\n+    /**\n+     * Verify and fix if Workflow decider queue contains this workflowId.\n+     * @param workflow\n+     * @return\n+     */\n+    private boolean verifyAndRepairDeciderQueue(Workflow workflow) {\n+        if (!workflow.getStatus().isTerminal()) {\n+            String queueName = WorkflowExecutor.DECIDER_QUEUE;\n+            if (!queueDAO.containsMessage(queueName, workflow.getWorkflowId())) {\n+                queueDAO.push(queueName, workflow.getWorkflowId(), configuration.getSweepFrequency());\n+                Monitors.recordQueueMessageRepushFromRepairService(queueName);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Verify if ExecutionDAO and QueueDAO agree for the provided task.\n+     * @param task\n+     * @return\n+     */\n+    @VisibleForTesting\n+    protected boolean verifyAndRepairTask(Task task) {\n+        WorkflowSystemTask workflowSystemTask = WorkflowSystemTask.get(task.getTaskType());\n+        if (task.getStatus().equals(Task.Status.SCHEDULED)) {\n+            if (isSystemTask.test(task) && !workflowSystemTask.isAsync()) {\n+                return false;\n+            }\n+            // Ensure QueueDAO contains this taskId\n+            if (!queueDAO.containsMessage(task.getTaskDefName(), task.getTaskId())) {", "originalCommit": "114a91d6d1608693e7011275f987a29c4b08a33f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMyODUyNQ==", "url": "https://github.com/Netflix/conductor/pull/1830#discussion_r488328525", "bodyText": "Since this annotation and the interceptor are used only for testing, can this abstracted out from the execution path. Maybe through some combination of Spy and Mock?", "author": "apanicker-nflx", "createdAt": "2020-09-15T01:31:02Z", "path": "redis-persistence/src/main/java/com/netflix/conductor/dao/dynomite/RedisExecutionDAO.java", "diffHunk": "@@ -115,6 +116,7 @@ public RedisExecutionDAO(DynoProxy dynoClient, ObjectMapper objectMapper, Config\n \t\treturn tasks;\n \t}\n \n+\t@FaultInjectionInterceptor", "originalCommit": "114a91d6d1608693e7011275f987a29c4b08a33f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b9a18d1fb6da47188af6a2d5449c01e6565bbf28", "url": "https://github.com/Netflix/conductor/commit/b9a18d1fb6da47188af6a2d5449c01e6565bbf28", "message": "Support for task resiliency on persistence features, and tests to verify the same using AOP based failure injection.\n\nAdded the configuration to control WorkflowRepairService from the sweeper service.", "committedDate": "2020-09-15T23:45:42Z", "type": "forcePushed"}, {"oid": "ff7514d7f08995e2205a85270523de8a6dce42d2", "url": "https://github.com/Netflix/conductor/commit/ff7514d7f08995e2205a85270523de8a6dce42d2", "message": "Support for task resiliency on persistence features, and tests to verify the same using AOP based failure injection.\n\nAdded the configuration to control WorkflowRepairService from the sweeper service.\n\nReplaced AOP based QueueDAO failure tests with Spock Spy's", "committedDate": "2020-09-18T01:05:06Z", "type": "forcePushed"}, {"oid": "d51db575022710c24e1cfb406f9d3544b7b3dccc", "url": "https://github.com/Netflix/conductor/commit/d51db575022710c24e1cfb406f9d3544b7b3dccc", "message": "Support for task resiliency on persistence features, and tests to verify the same using AOP based failure injection.\n\nAdded the configuration to control WorkflowRepairService from the sweeper service.\n\nReplaced AOP based QueueDAO failure tests with Spock Spy's", "committedDate": "2020-09-18T01:21:14Z", "type": "commit"}, {"oid": "d51db575022710c24e1cfb406f9d3544b7b3dccc", "url": "https://github.com/Netflix/conductor/commit/d51db575022710c24e1cfb406f9d3544b7b3dccc", "message": "Support for task resiliency on persistence features, and tests to verify the same using AOP based failure injection.\n\nAdded the configuration to control WorkflowRepairService from the sweeper service.\n\nReplaced AOP based QueueDAO failure tests with Spock Spy's", "committedDate": "2020-09-18T01:21:14Z", "type": "forcePushed"}]}