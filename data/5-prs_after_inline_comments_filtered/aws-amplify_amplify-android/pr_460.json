{"pr_number": 460, "pr_title": "[aws-datastore] three-way merge logic for unconditional mutations", "pr_createdAt": "2020-05-14T06:38:18Z", "pr_url": "https://github.com/aws-amplify/amplify-android/pull/460", "timeline": [{"oid": "c7f597de465acfe85a58243e964a7a02f499d8e4", "url": "https://github.com/aws-amplify/amplify-android/commit/c7f597de465acfe85a58243e964a7a02f499d8e4", "message": "[aws-datastore] three-way merge logic for unconditional mutations\n\nAdd enqueing rules to ensure that there is always at most one mutation\nfor a given model ID, in the outbox, at a time.\n\nWhen there is an already-pending mutation for a given model ID, and\nanother mutation is requested to be enqueued, these rules are applied:\n\nexisting creation incoming creation -> error\nexisting creation incoming update   -> incoming data, existing ID\nexisting creation incoming deletion -> delete exiting\n\nexisting update   incoming creation -> error\nexisting update   incoming update   -> incoming data, existing ID\nexisting update   incoming deletion -> existing ID, type now deletion\n\nexisting delete   incoming creation -> error\nexisting delete   incoming update   -> error\nexisting delete   incoming deletion -> exiting retained\n\nWhen there is no existing mutation, a pending mutation is alwas\nenqueued.\n\nFuture work will address the scenario where the mutations have\nconditional predicates attached to them.", "committedDate": "2020-05-14T05:48:32Z", "type": "commit"}, {"oid": "77cbd48dce137e7c238580af1024726acad9575e", "url": "https://github.com/aws-amplify/amplify-android/commit/77cbd48dce137e7c238580af1024726acad9575e", "message": "Merge remote-tracking branch 'origin/master' into 3way_merge", "committedDate": "2020-05-17T13:23:49Z", "type": "commit"}, {"oid": "dbb4b56188165a021215ffc4d267bae71e7c08f3", "url": "https://github.com/aws-amplify/amplify-android/commit/dbb4b56188165a021215ffc4d267bae71e7c08f3", "message": "Single threaded processing of the mutation outbox", "committedDate": "2020-05-17T15:35:41Z", "type": "commit"}, {"oid": "ca79ceb999d5f62871c0640ba3a4870c101c2da8", "url": "https://github.com/aws-amplify/amplify-android/commit/ca79ceb999d5f62871c0640ba3a4870c101c2da8", "message": "Merge remote-tracking branch 'origin/master' into 3way_merge", "committedDate": "2020-05-17T15:58:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI3Nzc2OA==", "url": "https://github.com/aws-amplify/amplify-android/pull/460#discussion_r426277768", "bodyText": "Given concerns on stability, this comment is alarming. What can we do to get it passing reliably?", "author": "jpignata", "createdAt": "2020-05-17T16:09:53Z", "path": "aws-datastore/src/androidTest/java/com/amplifyframework/datastore/AWSDataStorePluginInstrumentedTest.java", "diffHunk": "@@ -57,19 +61,11 @@\n  * which were defined by the schema in:\n  * testmodels/src/main/java/com/amplifyframework/testmodels/commentsblog/schema.graphql.\n  */\n-@Ignore(\"AWSDataStorePlugin must not refer to Amplify.API - need to update source\")\n+@Ignore(\"This test is not reliably passing right now.\")", "originalCommit": "ca79ceb999d5f62871c0640ba3a4870c101c2da8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMxOTc0OQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/460#discussion_r426319749", "bodyText": "Same. This is a top concern and priority for me.", "author": "jamesonwilliams", "createdAt": "2020-05-17T23:56:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI3Nzc2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI3Nzk3NA==", "url": "https://github.com/aws-amplify/amplify-android/pull/460#discussion_r426277974", "bodyText": "Is this order change meaningful?", "author": "jpignata", "createdAt": "2020-05-17T16:12:05Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/model/SystemModelsProviderFactory.java", "diffHunk": "@@ -43,6 +43,10 @@ public static ModelProvider create() {\n         return SimpleModelProvider.instance(\n             SYSTEM_MODELS_VERSION,\n \n+            // Used to create a persistent queue of mutations that need to be dispatched over\n+            // the network.\n+            PendingMutation.PersistentRecord.class,", "originalCommit": "ca79ceb999d5f62871c0640ba3a4870c101c2da8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMxOTg0MQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/460#discussion_r426319841", "bodyText": "It did fix a SQL foreign key violation for me. But, I haven't thought deeply about it yet to explain why it fixes a foreign key violation. Some other part of the system expects this thing to be around, early on, though.", "author": "jamesonwilliams", "createdAt": "2020-05-17T23:57:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI3Nzk3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI3OTc1MQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/460#discussion_r426279751", "bodyText": "So, in my theoretical situation where next cannot be committed to the store for whatever reason due to a failure that is not transient, this would just continually try in a loop and potentially batter AppSync. Perhaps a later thing, but do we need a backoff here or some other kind of back pressure? Seems like we need some retry-with-backoff-and-jitter sprinkles here. How do the other platforms handle this?", "author": "jpignata", "createdAt": "2020-05-17T16:30:00Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/MutationProcessor.java", "diffHunk": "@@ -71,24 +73,41 @@\n      * it again later, when network conditions become favorable again.\n      */\n     void startDrainingMutationOutbox() {\n-        ongoingOperationsDisposable.add(\n-            mutationOutbox.observe()\n-                .doOnSubscribe(disposable ->\n-                    LOG.info(\n-                        \"Started processing the mutation outbox. \" +\n-                            \"Pending mutations will be published to the cloud.\"\n-                    )\n-                )\n-                .subscribeOn(Schedulers.io())\n-                .observeOn(Schedulers.io())\n-                .flatMapCompletable(this::processOutboxItem)\n-                .subscribe(\n-                    () -> LOG.warn(\"Observation of mutation outbox was completed.\"),\n-                    error -> LOG.warn(\"Error ended observation of mutation outbox: \", error)\n+        ongoingOperationsDisposable.add(mutationOutbox.events()\n+            .doOnSubscribe(disposable ->\n+                LOG.info(\n+                    \"Started processing the mutation outbox. \" +\n+                        \"Pending mutations will be published to the cloud.\"\n                 )\n+            )\n+            .startWith(MutationOutbox.OutboxEvent.CONTENT_AVAILABLE) // To start draining immediately\n+            .subscribeOn(Schedulers.single())\n+            .observeOn(Schedulers.single())\n+            .flatMapCompletable(event -> drainMutationOutbox())\n+            .subscribe(\n+                () -> LOG.warn(\"Observation of mutation outbox was completed.\"),\n+                error -> LOG.warn(\"Error ended observation of mutation outbox: \", error)\n+            )\n         );\n     }\n \n+    private Completable drainMutationOutbox() {\n+        PendingMutation<? extends Model> next;\n+        do {\n+            next = mutationOutbox.peek();\n+            if (next == null) {\n+                return Completable.complete();\n+            }\n+            boolean itemFailedToProcess = !processOutboxItem(next)\n+                .blockingAwait(ITEM_PROCESSING_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+            if (itemFailedToProcess) {\n+                return Completable.error(new DataStoreException(\n+                    \"Failed to process \" + next, \"Check your internet connection.\"\n+                ));\n+            }\n+        } while (true);", "originalCommit": "ca79ceb999d5f62871c0640ba3a4870c101c2da8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI4MTU0NA==", "url": "https://github.com/aws-amplify/amplify-android/pull/460#discussion_r426281544", "bodyText": "Instead of true, should this be a !mutationOutbox.isEmpty() condition? I assume we also need a breaker for reachability, so perhaps this will land in the that work?", "author": "jpignata", "createdAt": "2020-05-17T16:49:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI3OTc1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMyMDQ0Nw==", "url": "https://github.com/aws-amplify/amplify-android/pull/460#discussion_r426320447", "bodyText": "The while (true) looks sketchy. I think its ~okay, though. The interior of the do { } says \"If the queue is empty, return now. It not empty, process the next. If that fails, return now.\" So the loop only proceeds when it was not empty, and the last item was successfully processed.\nAgree we do need some provisions around what happens when a publication fails, though.", "author": "jamesonwilliams", "createdAt": "2020-05-18T00:03:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI3OTc1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI4MzIxNA==", "url": "https://github.com/aws-amplify/amplify-android/pull/460#discussion_r426283214", "bodyText": "I'm not sure I see this branch in the requirements of JS implementation -- why do we ignore mutations and clobber on a network update when it seems like the intent is wait until the last mutation is applied?", "author": "jpignata", "createdAt": "2020-05-17T17:07:29Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/Merger.java", "diffHunk": "@@ -145,4 +155,22 @@\n             }\n         }, failure -> onNotPresent.call());\n     }\n+\n+    /**\n+     * The strategy to use while merging. Whether to consider the contents of the mutation\n+     * outbox before saving data locally, or, to ignore it.\n+     */\n+    enum MergeStrategy {\n+        /**\n+         * When merging, the contents of the mutation outbox will *not* be considered.", "originalCommit": "ca79ceb999d5f62871c0640ba3a4870c101c2da8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMxOTU0Nw==", "url": "https://github.com/aws-amplify/amplify-android/pull/460#discussion_r426319547", "bodyText": "There are four sources of state in this system:\n\nUser's data, received from DataStoreAPI;\nMutation responses, received when user's data is published;\nSubscription responses, received when any data change occurs on the remote system;\nSync responses, received at system startup.\n\n3 and 4 don't have pending mutations, we just get inbound data. 1 generates a pending mutation, but doesn't process it.\n2 is unique. When the mutation processor starts processing a pending mutation, it is guaranteed that it is in the outbox (that's where it came from.) So by the time the merger gets a request to merge it, we expect, just short of demand, that it must (still) be in the outbox. One of the very next steps is to delete it from the outbox.", "author": "jamesonwilliams", "createdAt": "2020-05-17T23:54:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjI4MzIxNA=="}], "type": "inlineReview"}]}