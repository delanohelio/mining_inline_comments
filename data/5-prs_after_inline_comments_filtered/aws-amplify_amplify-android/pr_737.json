{"pr_number": 737, "pr_title": "feat(datastore) add pagination, respecting syncPageSize and syncMaxRecords", "pr_createdAt": "2020-08-18T21:43:33Z", "pr_url": "https://github.com/aws-amplify/amplify-android/pull/737", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzU4NDExOA==", "url": "https://github.com/aws-amplify/amplify-android/pull/737#discussion_r473584118", "bodyText": "I like to use +8 for method params, so that the body is clearly distinguished at +4\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    GraphQLRequest<PaginatedResult<ModelWithMetadata<T>>> request,\n          \n          \n            \n                    SingleEmitter<Iterable<ModelWithMetadata<T>>> singleEmitter,\n          \n          \n            \n                    Set<ModelWithMetadata<T>> emittedValue) {\n          \n          \n            \n                        GraphQLRequest<PaginatedResult<ModelWithMetadata<T>>> request,\n          \n          \n            \n                        SingleEmitter<Iterable<ModelWithMetadata<T>>> singleEmitter,\n          \n          \n            \n                        Set<ModelWithMetadata<T>> emittedValue) {", "author": "jamesonwilliams", "createdAt": "2020-08-20T04:39:58Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/SyncProcessor.java", "diffHunk": "@@ -166,28 +168,41 @@ private SyncTime filterOutOldSyncTimes(SyncTime lastSyncTime) throws DataStoreEx\n      *  2. Make a request to the AppSync endpoint. If the last sync time is within a recent window\n      *     of time, then request a *delta* sync. If the last sync time is outside a recent window of time,\n      *     perform a *base* sync. A base sync is preformed by passing null.\n-     *  3. Update the\n+     *  3. Continue fetching paged results until !hasNextPage() or we have synced the max records.\n      * @param modelClass The model class to sync\n-     * @param <T> The type of model to sync\n+     * @param <T> The type of model to sync.\n      * @return An {@link Single} which emits sync content, on success, {@link DataStoreException} on failure\n      */\n     private <T extends Model> Single<Iterable<ModelWithMetadata<T>>> syncModel(\n             Class<T> modelClass, SyncTime syncTime) {\n         final Long lastSyncTimeAsLong = syncTime.exists() ? syncTime.toLong() : null;\n         return Single.<Iterable<ModelWithMetadata<T>>>create(emitter -> {\n-            final Cancelable cancelable =\n-                appSync.sync(modelClass, lastSyncTimeAsLong, metadataEmitter(emitter), emitter::onError);\n-            emitter.setDisposable(AmplifyDisposables.fromCancelable(cancelable));\n+            final Integer syncPageSize = dataStoreConfigurationProvider.getConfiguration().getSyncPageSize();\n+            GraphQLRequest<PaginatedResult<ModelWithMetadata<T>>> request =\n+                    appSync.buildSyncRequest(modelClass, lastSyncTimeAsLong, syncPageSize);\n+            syncPage(request, emitter, new HashSet<>());\n         }).doOnSuccess(results ->\n             LOG.debug(\"Successfully sync'd down cloud state for model type = \" + modelClass.getSimpleName())\n         ).doOnError(failureToSync ->\n             LOG.warn(\"Failed to sync down cloud state for model type = \" + modelClass.getSimpleName(), failureToSync)\n         );\n     }\n \n-    private static <T extends Model> Consumer<GraphQLResponse<Iterable<ModelWithMetadata<T>>>> metadataEmitter(\n-        SingleEmitter<Iterable<ModelWithMetadata<T>>> singleEmitter) {\n-        return resultFromEndpoint -> {\n+    /**\n+     * Recursively fetches each page for a sync, until there are no more pages available, or we have fetched the maximum\n+     * configured number of records to sync (syncMaxRecords).\n+     * @param request GraphQLRequest object for the sync, obtained from appsync.buildFirstPageSyncRequest, or from\n+     *                response.getData().getRequestForNextResult() for subsequent requests.\n+     * @param singleEmitter A SingleEmitter which emits an Iterable&lt;ModelWithMetadata&gt;, a concatenation of the\n+     *                      results from all pages.\n+     * @param emittedValue a Set&lt;ModelWithMetadata&lt;T&gt;&gt; containing the concatenated results of all requests.\n+     * @param <T> The type of model to sync.\n+     */\n+    private <T extends Model> void syncPage(\n+        GraphQLRequest<PaginatedResult<ModelWithMetadata<T>>> request,\n+        SingleEmitter<Iterable<ModelWithMetadata<T>>> singleEmitter,\n+        Set<ModelWithMetadata<T>> emittedValue) {", "originalCommit": "e207db3055dd918ef460dd11d21bb28b36174316", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAyMjY0Ng==", "url": "https://github.com/aws-amplify/amplify-android/pull/737#discussion_r477022646", "bodyText": "Agreed on the indentation preference!  This method was refactored in my latest push though, so no longer relevant.", "author": "richardmcclellan", "createdAt": "2020-08-26T04:12:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzU4NDExOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzU4NDY3MQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/737#discussion_r473584671", "bodyText": "Is this a realistic scenario?\nIf so, can we handle this in the code which build the configuration object, instead? S.t. the configuration always has some sane value, by the time we get here to access it?", "author": "jamesonwilliams", "createdAt": "2020-08-20T04:41:57Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/SyncProcessor.java", "diffHunk": "@@ -198,13 +213,26 @@ private SyncTime filterOutOldSyncTimes(SyncTime lastSyncTime) throws DataStoreEx\n                     \"Empty response from AppSync.\", \"Report to AWS team.\"\n                 ));\n             } else {\n-                final Set<ModelWithMetadata<T>> emittedValue = new HashSet<>();\n-                for (ModelWithMetadata<T> modelWithMetadata : resultFromEndpoint.getData()) {\n+                for (ModelWithMetadata<T> modelWithMetadata : resultFromEndpoint.getData().getItems()) {\n                     emittedValue.add(modelWithMetadata);\n                 }\n-                singleEmitter.onSuccess(emittedValue);\n+                if (resultFromEndpoint.getData().hasNextResult() && emittedValue.size() < syncMaxRecords()) {\n+                    syncPage(resultFromEndpoint.getData().getRequestForNextResult(), singleEmitter, emittedValue);\n+                } else {\n+                    singleEmitter.onSuccess(emittedValue);\n+                }\n             }\n-        };\n+        }, singleEmitter::onError);\n+        singleEmitter.setDisposable(AmplifyDisposables.fromCancelable(cancelable));\n+    }\n+\n+    private Integer syncMaxRecords() {\n+        try {\n+            return dataStoreConfigurationProvider.getConfiguration().getSyncMaxRecords();\n+        } catch (DataStoreException exception) {\n+            LOG.warn(\"Failed to retrieve datastore configuration, using default syncMaxRecords value.\", exception);\n+            return DEFAULT_SYNC_MAX_RECORDS;\n+        }", "originalCommit": "e207db3055dd918ef460dd11d21bb28b36174316", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzAyMzgyNw==", "url": "https://github.com/aws-amplify/amplify-android/pull/737#discussion_r477023827", "bodyText": "DataStoreConfigurationProvider::getConfiguration() does throw a DataStoreException, if errors are found building the configuration, but I don't think it is actually thrown in practice.  If the configuration.json is not found, then it uses falls back to defaults.\nI've updated this so that if a DataStoreException is actually thrown, it will cause the whole sync to fail, instead of falling back to some default here.  I think this is reasonable, since, as I said, it shouldn't ever be thrown in practice.", "author": "richardmcclellan", "createdAt": "2020-08-26T04:17:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzU4NDY3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzU4NDgzMg==", "url": "https://github.com/aws-amplify/amplify-android/pull/737#discussion_r473584832", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    PaginatedResult<ModelWithMetadata<BlogOwner>> data = new PaginatedResult<>(new ArrayList<>(), null);\n          \n          \n            \n                    mockApiResponse(new GraphQLResponse<>(data, new ArrayList<>()));\n          \n          \n            \n                    PaginatedResult<ModelWithMetadata<BlogOwner>> data = new PaginatedResult<>(Collections.emptyList(), null);\n          \n          \n            \n                    mockApiResponse(new GraphQLResponse<>(data, Collections.emptyList()));", "author": "jamesonwilliams", "createdAt": "2020-08-20T04:42:44Z", "path": "aws-datastore/src/test/java/com/amplifyframework/datastore/appsync/AppSyncClientTest.java", "diffHunk": "@@ -68,7 +69,8 @@ public void setup() {\n \n         // We need it to response with **something** by default.\n         // Use this same method to send more interesting test values back...\n-        mockApiResponse(new GraphQLResponse<>(new ArrayList<>(), new ArrayList<>()));\n+        PaginatedResult<ModelWithMetadata<BlogOwner>> data = new PaginatedResult<>(new ArrayList<>(), null);\n+        mockApiResponse(new GraphQLResponse<>(data, new ArrayList<>()));", "originalCommit": "e207db3055dd918ef460dd11d21bb28b36174316", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzU4NzE3NQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/737#discussion_r473587175", "bodyText": "Method name: matchesRequest? It'll look cool above when you write argThat(matchesRequest(!", "author": "jamesonwilliams", "createdAt": "2020-08-20T04:51:55Z", "path": "aws-datastore/src/test/java/com/amplifyframework/datastore/appsync/AppSyncMocking.java", "diffHunk": "@@ -213,91 +224,159 @@ public static OnDeleteConfigurator onDelete(AppSync mock) {\n         /**\n          * Constructs a new SyncConfigurator.\n          * @param appSync A mock AppSync instance\n+         * @throws DataStoreException if a ModelSchema cannot be created in order to build the sync request.\n          */\n-        SyncConfigurator(AppSync appSync) {\n+        SyncConfigurator(AppSync appSync) throws DataStoreException {\n             this.appSync = appSync;\n+            this.mockBuildSyncRequest();\n             this.mockSuccessResponses();\n         }\n \n+        private <M extends Model> SyncConfigurator mockBuildSyncRequest() throws DataStoreException {\n+            when(appSync.buildSyncRequest(any(), any(), any()))\n+                    .thenAnswer((Answer<GraphQLRequest<PaginatedResult<ModelWithMetadata<M>>>>) invocation -> {\n+                        Class<M> modelClass = invocation.getArgument(0);\n+                        Long lastSync = invocation.getArgument(1);\n+                        Integer syncPageSize = invocation.getArgument(2);\n+                        return AppSyncRequestFactory.buildSyncRequest(modelClass, lastSync, syncPageSize);\n+                    });\n+            return this;\n+        }\n+\n         /**\n          * By default, return an empty list of items when attempting to sync any/all Model classes.\n+         * @param <M> Type of model for which a response is mocked.\n          * @return Configurator instance\n          */\n         @NonNull\n-        public SyncConfigurator mockSuccessResponses() {\n-            doAnswer(invocation -> {\n-                // Get a handle to the response consumer that is passed into the sync() method\n-                // Response consumer is the third param, at index 2 (@0, @1, @2, @3).\n-                final int argumentPositionForResponseConsumer = 2;\n-                final Consumer<GraphQLResponse<Iterable<ModelWithMetadata<? extends Model>>>> consumer =\n-                    invocation.getArgument(argumentPositionForResponseConsumer);\n-\n-                // Call the response consumer, and pass EMPTY items inside of a GraphQLResponse wrapper\n-                consumer.accept(new GraphQLResponse<>(Collections.emptyList(), Collections.emptyList()));\n-\n-                // Return a NoOp cancelable via the sync() method's return.\n-                return new NoOpCancelable();\n-            }).when(appSync).sync(\n-                any(), // Item class to sync\n-                any(), // last sync time\n-                any(), // Consumer<Iterable<ModelWithMetadata<T>>>\n-                any() // Consumer<DataStoreException>\n+        public <M extends Model> SyncConfigurator mockSuccessResponses() {\n+            return mockSuccessResponse(\n+                arg -> true, // Match all GraphQLRequest objects.\n+                new GraphQLResponse<>(\n+                    new PaginatedResult<>(Collections.emptyList(), null),\n+                    Collections.emptyList()\n+                )\n             );\n-            return this;\n         }\n \n         /**\n          * Configures an instance of an {@link AppSync} to provide a fake response when asked to\n-         * to {@link AppSync#sync(Class, Long, Consumer, Consumer)}. The response callback will\n+         * to {@link AppSync#sync(GraphQLRequest, Consumer, Consumer)}. The response callback will\n          * be invoked, and will contain the provided ModelWithMetadata in its response.\n          * @param modelClass Class of models for which the endpoint should respond\n          * @param responseItems The items that should be included in the mocked response, for the model class\n-         * @param <T> Type of models for which a response is mocked\n+         * @param <M> Type of models for which a response is mocked\n          * @return The same Configurator instance, to enable chaining of calls\n          */\n         @SuppressWarnings(\"varargs\")\n         @SafeVarargs\n-        public final <T extends Model> SyncConfigurator mockSuccessResponse(\n-                Class<T> modelClass, ModelWithMetadata<T>... responseItems) {\n+        public final <M extends Model> SyncConfigurator mockSuccessResponse(\n+                Class<M> modelClass, ModelWithMetadata<M>... responseItems) {\n+            return mockSuccessResponse(\n+                    matcherFor(modelClass, null),\n+                    new GraphQLResponse<>(\n+                            new PaginatedResult<>(new HashSet<>(Arrays.asList(responseItems)), null),\n+                            Collections.emptyList()\n+                    )\n+            );\n+        }\n+\n+        /**\n+         * Configures an instance of an {@link AppSync} to invoke the response callback when asked to\n+         * {@link AppSync#sync(GraphQLRequest, Consumer, Consumer)}, with the ability to specify a nextToken to match,\n+         * and a nextToken to return in the response, for testing pagination.\n+         * @param modelClass Class of models for which the endpoint should respond\n+         * @param token nextToken to be expected on the GraphQLRequest for which the endpoint should respond.\n+         * @param nextToken nextToken that should be used to build the requestForNextResult on the GraphQLResponse.\n+         * @param responseItems The items that should be included in the mocked response, for the model class\n+         * @param <M> Type of models for which a response is mocked\n+         * @return The same Configurator instance, to enable chaining of calls\n+         * @throws AmplifyException if a ModelSchema cannot be created in order to build the sync request.\n+         */\n+        @SuppressWarnings(\"varargs\")\n+        @SafeVarargs\n+        public final <M extends Model> SyncConfigurator mockSuccessResponse(\n+                Class<M> modelClass,\n+                String token,\n+                String nextToken,\n+                ModelWithMetadata<M>... responseItems) throws AmplifyException {\n+            final Iterable<ModelWithMetadata<M>> items = new HashSet<>(Arrays.asList(responseItems));\n+            AppSyncGraphQLRequest<PaginatedResult<ModelWithMetadata<M>>> requestForNextResult = null;\n+            if (nextToken != null) {\n+                requestForNextResult = AppSyncRequestFactory.buildSyncRequest(modelClass, null, null)\n+                        .newBuilder()\n+                        .variable(\"nextToken\", \"String\", nextToken)\n+                        .build();\n+            }\n+            return mockSuccessResponse(\n+                    matcherFor(modelClass, token),\n+                    new GraphQLResponse<>(\n+                            new PaginatedResult<>(items, requestForNextResult),\n+                            Collections.emptyList()\n+                    )\n+            );\n+        }\n+\n+        /**\n+         * Configures an instance of an {@link AppSync} to invoke the response callback with the provided mockResponse\n+         * when asked to {@link AppSync#sync(GraphQLRequest, Consumer, Consumer)}.\n+         * @param requestMatcher ArgumentMatcher which returns true if the GraphQLRequest should be mocked.\n+         * @param mockResponse GraphQLResponse to be passed back in the response callback.\n+         * @param <M> Type of models for which a response is mocked\n+         * @return The same Configurator instance, to enable chaining of calls\n+         */\n+        public <M extends Model> SyncConfigurator mockSuccessResponse(\n+                ArgumentMatcher<GraphQLRequest<PaginatedResult<ModelWithMetadata<M>>>> requestMatcher,\n+                GraphQLResponse<PaginatedResult<ModelWithMetadata<M>>> mockResponse) {\n             doAnswer(invocation -> {\n                 // Get a handle to the response consumer that is passed into the sync() method\n-                // Response consumer is the third param, at index 2 (@0, @1, @2, @3).\n-                final int argumentPositionForResponseConsumer = 2;\n-                final Consumer<GraphQLResponse<Iterable<ModelWithMetadata<T>>>> consumer =\n+                // Response consumer is the second param, at index 1 (@0, @1, @2).\n+                final int argumentPositionForResponseConsumer = 1;\n+                final Consumer<GraphQLResponse<PaginatedResult<ModelWithMetadata<M>>>> consumer =\n                     invocation.getArgument(argumentPositionForResponseConsumer);\n \n-                // Call the response consumer, and pass the mocked items\n-                // inside of a GraphQLResponse wrapper\n-                final Iterable<ModelWithMetadata<T>> data = new HashSet<>(Arrays.asList(responseItems));\n-                consumer.accept(new GraphQLResponse<>(data, Collections.emptyList()));\n+                // Call the response consumer, and pass the mocked response\n+                consumer.accept(mockResponse);\n \n                 // Return a NoOp cancelable via the sync() method's return.\n                 return new NoOpCancelable();\n             }).when(appSync).sync(\n-                eq(modelClass), // Item class to sync\n-                any(), // last sync time\n-                any(), // Consumer<Iterable<ModelWithMetadata<T>>>\n-                any() // Consumer<DataStoreException>\n+                argThat(requestMatcher),\n+                any(), // Consumer<GraphQLResponse<PaginatedResult<ModelWithMetadata<M>>>>\n+                any()  // Consumer<DataStoreException>\n             );\n             return SyncConfigurator.this;\n         }\n \n+        private <M extends Model> ArgumentMatcher<GraphQLRequest<PaginatedResult<ModelWithMetadata<M>>>> matcherFor(", "originalCommit": "e207db3055dd918ef460dd11d21bb28b36174316", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzU4NzM4MQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/737#discussion_r473587381", "bodyText": "I really appreciate you taking the time and consideration to update some of this ancillary stuff. This would be easy to overlook, and often is.", "author": "jamesonwilliams", "createdAt": "2020-08-20T04:52:45Z", "path": "aws-datastore/src/test/java/com/amplifyframework/datastore/appsync/AppSyncMocking.java", "diffHunk": "@@ -213,91 +224,159 @@ public static OnDeleteConfigurator onDelete(AppSync mock) {\n         /**\n          * Constructs a new SyncConfigurator.\n          * @param appSync A mock AppSync instance\n+         * @throws DataStoreException if a ModelSchema cannot be created in order to build the sync request.\n          */\n-        SyncConfigurator(AppSync appSync) {\n+        SyncConfigurator(AppSync appSync) throws DataStoreException {\n             this.appSync = appSync;\n+            this.mockBuildSyncRequest();\n             this.mockSuccessResponses();\n         }\n \n+        private <M extends Model> SyncConfigurator mockBuildSyncRequest() throws DataStoreException {\n+            when(appSync.buildSyncRequest(any(), any(), any()))\n+                    .thenAnswer((Answer<GraphQLRequest<PaginatedResult<ModelWithMetadata<M>>>>) invocation -> {\n+                        Class<M> modelClass = invocation.getArgument(0);\n+                        Long lastSync = invocation.getArgument(1);\n+                        Integer syncPageSize = invocation.getArgument(2);\n+                        return AppSyncRequestFactory.buildSyncRequest(modelClass, lastSync, syncPageSize);\n+                    });\n+            return this;\n+        }\n+\n         /**\n          * By default, return an empty list of items when attempting to sync any/all Model classes.\n+         * @param <M> Type of model for which a response is mocked.\n          * @return Configurator instance\n          */\n         @NonNull\n-        public SyncConfigurator mockSuccessResponses() {\n-            doAnswer(invocation -> {\n-                // Get a handle to the response consumer that is passed into the sync() method\n-                // Response consumer is the third param, at index 2 (@0, @1, @2, @3).\n-                final int argumentPositionForResponseConsumer = 2;\n-                final Consumer<GraphQLResponse<Iterable<ModelWithMetadata<? extends Model>>>> consumer =\n-                    invocation.getArgument(argumentPositionForResponseConsumer);\n-\n-                // Call the response consumer, and pass EMPTY items inside of a GraphQLResponse wrapper\n-                consumer.accept(new GraphQLResponse<>(Collections.emptyList(), Collections.emptyList()));\n-\n-                // Return a NoOp cancelable via the sync() method's return.\n-                return new NoOpCancelable();\n-            }).when(appSync).sync(\n-                any(), // Item class to sync\n-                any(), // last sync time\n-                any(), // Consumer<Iterable<ModelWithMetadata<T>>>\n-                any() // Consumer<DataStoreException>\n+        public <M extends Model> SyncConfigurator mockSuccessResponses() {\n+            return mockSuccessResponse(\n+                arg -> true, // Match all GraphQLRequest objects.\n+                new GraphQLResponse<>(\n+                    new PaginatedResult<>(Collections.emptyList(), null),\n+                    Collections.emptyList()\n+                )\n             );\n-            return this;\n         }\n \n         /**\n          * Configures an instance of an {@link AppSync} to provide a fake response when asked to\n-         * to {@link AppSync#sync(Class, Long, Consumer, Consumer)}. The response callback will\n+         * to {@link AppSync#sync(GraphQLRequest, Consumer, Consumer)}. The response callback will\n          * be invoked, and will contain the provided ModelWithMetadata in its response.\n          * @param modelClass Class of models for which the endpoint should respond\n          * @param responseItems The items that should be included in the mocked response, for the model class\n-         * @param <T> Type of models for which a response is mocked\n+         * @param <M> Type of models for which a response is mocked\n          * @return The same Configurator instance, to enable chaining of calls\n          */\n         @SuppressWarnings(\"varargs\")\n         @SafeVarargs\n-        public final <T extends Model> SyncConfigurator mockSuccessResponse(\n-                Class<T> modelClass, ModelWithMetadata<T>... responseItems) {\n+        public final <M extends Model> SyncConfigurator mockSuccessResponse(\n+                Class<M> modelClass, ModelWithMetadata<M>... responseItems) {\n+            return mockSuccessResponse(\n+                    matcherFor(modelClass, null),\n+                    new GraphQLResponse<>(\n+                            new PaginatedResult<>(new HashSet<>(Arrays.asList(responseItems)), null),\n+                            Collections.emptyList()\n+                    )\n+            );\n+        }\n+\n+        /**\n+         * Configures an instance of an {@link AppSync} to invoke the response callback when asked to\n+         * {@link AppSync#sync(GraphQLRequest, Consumer, Consumer)}, with the ability to specify a nextToken to match,\n+         * and a nextToken to return in the response, for testing pagination.\n+         * @param modelClass Class of models for which the endpoint should respond\n+         * @param token nextToken to be expected on the GraphQLRequest for which the endpoint should respond.\n+         * @param nextToken nextToken that should be used to build the requestForNextResult on the GraphQLResponse.\n+         * @param responseItems The items that should be included in the mocked response, for the model class\n+         * @param <M> Type of models for which a response is mocked\n+         * @return The same Configurator instance, to enable chaining of calls\n+         * @throws AmplifyException if a ModelSchema cannot be created in order to build the sync request.\n+         */\n+        @SuppressWarnings(\"varargs\")\n+        @SafeVarargs\n+        public final <M extends Model> SyncConfigurator mockSuccessResponse(\n+                Class<M> modelClass,\n+                String token,\n+                String nextToken,\n+                ModelWithMetadata<M>... responseItems) throws AmplifyException {\n+            final Iterable<ModelWithMetadata<M>> items = new HashSet<>(Arrays.asList(responseItems));\n+            AppSyncGraphQLRequest<PaginatedResult<ModelWithMetadata<M>>> requestForNextResult = null;\n+            if (nextToken != null) {\n+                requestForNextResult = AppSyncRequestFactory.buildSyncRequest(modelClass, null, null)\n+                        .newBuilder()\n+                        .variable(\"nextToken\", \"String\", nextToken)\n+                        .build();\n+            }\n+            return mockSuccessResponse(\n+                    matcherFor(modelClass, token),\n+                    new GraphQLResponse<>(\n+                            new PaginatedResult<>(items, requestForNextResult),\n+                            Collections.emptyList()\n+                    )\n+            );\n+        }\n+\n+        /**\n+         * Configures an instance of an {@link AppSync} to invoke the response callback with the provided mockResponse\n+         * when asked to {@link AppSync#sync(GraphQLRequest, Consumer, Consumer)}.\n+         * @param requestMatcher ArgumentMatcher which returns true if the GraphQLRequest should be mocked.\n+         * @param mockResponse GraphQLResponse to be passed back in the response callback.\n+         * @param <M> Type of models for which a response is mocked\n+         * @return The same Configurator instance, to enable chaining of calls\n+         */\n+        public <M extends Model> SyncConfigurator mockSuccessResponse(\n+                ArgumentMatcher<GraphQLRequest<PaginatedResult<ModelWithMetadata<M>>>> requestMatcher,\n+                GraphQLResponse<PaginatedResult<ModelWithMetadata<M>>> mockResponse) {\n             doAnswer(invocation -> {\n                 // Get a handle to the response consumer that is passed into the sync() method\n-                // Response consumer is the third param, at index 2 (@0, @1, @2, @3).\n-                final int argumentPositionForResponseConsumer = 2;\n-                final Consumer<GraphQLResponse<Iterable<ModelWithMetadata<T>>>> consumer =\n+                // Response consumer is the second param, at index 1 (@0, @1, @2).", "originalCommit": "e207db3055dd918ef460dd11d21bb28b36174316", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f0bd85f723c725ec1566250ff48447ccb9eba8e4", "url": "https://github.com/aws-amplify/amplify-android/commit/f0bd85f723c725ec1566250ff48447ccb9eba8e4", "message": "feat(datastore) add pagination, respecting syncPageSize and syncMaxRecords config params", "committedDate": "2020-08-21T20:34:12Z", "type": "commit"}, {"oid": "f0bd85f723c725ec1566250ff48447ccb9eba8e4", "url": "https://github.com/aws-amplify/amplify-android/commit/f0bd85f723c725ec1566250ff48447ccb9eba8e4", "message": "feat(datastore) add pagination, respecting syncPageSize and syncMaxRecords config params", "committedDate": "2020-08-21T20:34:12Z", "type": "forcePushed"}, {"oid": "f7bbe33910add5be38176a9fe6804744554e9a37", "url": "https://github.com/aws-amplify/amplify-android/commit/f7bbe33910add5be38176a9fe6804744554e9a37", "message": "Merge from main", "committedDate": "2020-08-24T21:50:54Z", "type": "commit"}, {"oid": "de40c5b1c4110b0d1c21fd96a4728704eaa4a905", "url": "https://github.com/aws-amplify/amplify-android/commit/de40c5b1c4110b0d1c21fd96a4728704eaa4a905", "message": "Merge branch 'main' into rm/ds-paging", "committedDate": "2020-08-25T20:41:41Z", "type": "commit"}, {"oid": "da5c1bab96b3a03994512eabe96a314ac17e9d71", "url": "https://github.com/aws-amplify/amplify-android/commit/da5c1bab96b3a03994512eabe96a314ac17e9d71", "message": "Fix stackoverflow error when paginating lots of pages", "committedDate": "2020-08-26T04:21:31Z", "type": "commit"}, {"oid": "da5c1bab96b3a03994512eabe96a314ac17e9d71", "url": "https://github.com/aws-amplify/amplify-android/commit/da5c1bab96b3a03994512eabe96a314ac17e9d71", "message": "Fix stackoverflow error when paginating lots of pages", "committedDate": "2020-08-26T04:21:31Z", "type": "forcePushed"}, {"oid": "a33c6ac950450062a73458c4c2e27527d66dec6d", "url": "https://github.com/aws-amplify/amplify-android/commit/a33c6ac950450062a73458c4c2e27527d66dec6d", "message": "Update aws-datastore/src/test/java/com/amplifyframework/datastore/appsync/AppSyncClientTest.java\n\nCo-authored-by: Jameson Williams <jhwill@amazon.com>", "committedDate": "2020-08-26T14:39:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM1ODIwMQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/737#discussion_r477358201", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Validate the sync can handle 500 of pages.  Even with a recursive, functional algorithm, this should pass.\n          \n          \n            \n                 * Validate the sync can handle 100 of pages.  Even with a recursive, functional algorithm, this should pass.", "author": "richardmcclellan", "createdAt": "2020-08-26T14:45:22Z", "path": "aws-datastore/src/test/java/com/amplifyframework/datastore/syncengine/SyncProcessorTest.java", "diffHunk": "@@ -402,6 +423,138 @@ public void userProvidedErrorCallbackInvokedOnFailure() {\n         assertEquals(1, errorHandlerCallCount);\n     }\n \n+    /**\n+     * Validate that all records are synced, via pagination.\n+     * @throws AmplifyException on error building sync request for next page.\n+     * @throws InterruptedException If interrupted while awaiting terminal result in test observer\n+     */\n+    @Test\n+    public void modelWithMultiplePagesSyncsAllPages() throws AmplifyException, InterruptedException {\n+        syncAndExpect(5, 10);\n+    }\n+\n+    /**\n+     * Validate that sync stops after retrieving syncMaxRecords results, even if there are more pages available.\n+     * @throws AmplifyException on error building sync request for next page.\n+     * @throws InterruptedException If interrupted while awaiting terminal result in test observer\n+     */\n+    @Test\n+    public void syncStopsAfterMaxRecords() throws AmplifyException, InterruptedException {\n+        syncAndExpect(10, 5);\n+    }\n+\n+    /**\n+     * Validate the sync can handle 500 of pages.  Even with a recursive, functional algorithm, this should pass.", "originalCommit": "a33c6ac950450062a73458c4c2e27527d66dec6d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4c335bf41967eb32c264022ef00bf965b213de08", "url": "https://github.com/aws-amplify/amplify-android/commit/4c335bf41967eb32c264022ef00bf965b213de08", "message": "Update aws-datastore/src/test/java/com/amplifyframework/datastore/syncengine/SyncProcessorTest.java", "committedDate": "2020-08-26T14:45:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ4NTAzOQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/737#discussion_r477485039", "bodyText": "Woo-hoo!!", "author": "jamesonwilliams", "createdAt": "2020-08-26T17:57:24Z", "path": "aws-datastore/src/test/java/com/amplifyframework/datastore/syncengine/SyncProcessorTest.java", "diffHunk": "@@ -402,6 +423,138 @@ public void userProvidedErrorCallbackInvokedOnFailure() {\n         assertEquals(1, errorHandlerCallCount);\n     }\n \n+    /**\n+     * Validate that all records are synced, via pagination.\n+     * @throws AmplifyException on error building sync request for next page.\n+     * @throws InterruptedException If interrupted while awaiting terminal result in test observer\n+     */\n+    @Test\n+    public void modelWithMultiplePagesSyncsAllPages() throws AmplifyException, InterruptedException {\n+        syncAndExpect(5, 10);\n+    }\n+\n+    /**\n+     * Validate that sync stops after retrieving syncMaxRecords results, even if there are more pages available.\n+     * @throws AmplifyException on error building sync request for next page.\n+     * @throws InterruptedException If interrupted while awaiting terminal result in test observer\n+     */\n+    @Test\n+    public void syncStopsAfterMaxRecords() throws AmplifyException, InterruptedException {\n+        syncAndExpect(10, 5);\n+    }\n+\n+    /**\n+     * Validate the sync can handle 100 of pages.  Even with a recursive, functional algorithm, this should pass.\n+     * @throws AmplifyException on error building sync request for next page.\n+     * @throws InterruptedException If interrupted while awaiting terminal result in test observer\n+     */\n+    @Test\n+    public void syncCanHandle100Pages() throws AmplifyException, InterruptedException {\n+        syncAndExpect(100, 10000);\n+    }\n+\n+    /**\n+     * Validate that sync can handle 1000 more pages.  This fails with a StackOverflowError if sync is implemented\n+     * recursively, because each call to the sync method is saved on the stack before execution\n+     * begins.  The solution is to use an iterative algorithm.\n+     * @throws AmplifyException on error building sync request for next page.\n+     * @throws InterruptedException If interrupted while awaiting terminal result in test observer\n+     */\n+    @Test\n+    public void syncCanHandle1000Pages() throws AmplifyException, InterruptedException {", "originalCommit": "4c335bf41967eb32c264022ef00bf965b213de08", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ4NzQzNw==", "url": "https://github.com/aws-amplify/amplify-android/pull/737#discussion_r477487437", "bodyText": "189-200 -- some advanced stuff going on here, very cool!", "author": "jamesonwilliams", "createdAt": "2020-08-26T18:01:25Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/SyncProcessor.java", "diffHunk": "@@ -172,45 +169,62 @@ private SyncTime filterOutOldSyncTimes(SyncTime lastSyncTime) throws DataStoreEx\n      *  2. Make a request to the AppSync endpoint. If the last sync time is within a recent window\n      *     of time, then request a *delta* sync. If the last sync time is outside a recent window of time,\n      *     perform a *base* sync. A base sync is preformed by passing null.\n-     *  3. Update the\n+     *  3. Continue fetching paged results until !hasNextResult() or we have synced the max records.\n+     *\n      * @param modelClass The model class to sync\n-     * @param <T> The type of model to sync\n-     * @return An {@link Single} which emits sync content, on success, {@link DataStoreException} on failure\n+     * @param syncTime The time of a last successful sync.\n+     * @param <T> The type of model to sync.\n+     * @return a stream of all ModelWithMetadata&lt;T&gt; objects from all pages for the provided model.\n+     * @throws DataStoreException if dataStoreConfigurationProvider.getConfiguration() fails\n      */\n-    private <T extends Model> Single<Iterable<ModelWithMetadata<T>>> syncModel(\n-            Class<T> modelClass, SyncTime syncTime) {\n+    private <T extends Model> Flowable<ModelWithMetadata<T>> syncModel(Class<T> modelClass, SyncTime syncTime)\n+            throws DataStoreException {\n         final Long lastSyncTimeAsLong = syncTime.exists() ? syncTime.toLong() : null;\n-        return Single.<Iterable<ModelWithMetadata<T>>>create(emitter -> {\n-            final Cancelable cancelable =\n-                appSync.sync(modelClass, lastSyncTimeAsLong, metadataEmitter(emitter), emitter::onError);\n-            emitter.setDisposable(AmplifyDisposables.fromCancelable(cancelable));\n-        }).doOnSuccess(results ->\n-            LOG.debug(\"Successfully sync'd down cloud state for model type = \" + modelClass.getSimpleName())\n-        ).doOnError(failureToSync ->\n-            LOG.warn(\"Failed to sync down cloud state for model type = \" + modelClass.getSimpleName(), failureToSync)\n-        );\n+        final Integer syncPageSize = dataStoreConfigurationProvider.getConfiguration().getSyncPageSize();\n+\n+        // Create a BehaviorProcessor, and set the default value to a GraphQLRequest that fetches the first page.\n+        BehaviorProcessor<GraphQLRequest<PaginatedResult<ModelWithMetadata<T>>>> processor =\n+                BehaviorProcessor.createDefault(appSync.buildSyncRequest(modelClass, lastSyncTimeAsLong, syncPageSize));\n+\n+        return processor.concatMap(request -> syncPage(request).toFlowable())", "originalCommit": "4c335bf41967eb32c264022ef00bf965b213de08", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6fbab39553cf40cda7d594ec690186c4bd38e83f", "url": "https://github.com/aws-amplify/amplify-android/commit/6fbab39553cf40cda7d594ec690186c4bd38e83f", "message": "import Collections", "committedDate": "2020-08-26T20:02:18Z", "type": "commit"}]}