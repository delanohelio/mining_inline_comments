{"pr_number": 498, "pr_title": "Implement conflict resolution rules for existing and incoming mutations for the same model", "pr_createdAt": "2020-05-20T21:59:23Z", "pr_url": "https://github.com/aws-amplify/amplify-android/pull/498", "timeline": [{"oid": "bfbf8d167e8532b387d35ac68f329fee9c20a3a4", "url": "https://github.com/aws-amplify/amplify-android/commit/bfbf8d167e8532b387d35ac68f329fee9c20a3a4", "message": "[aws-datastore] Implement conflict resolution rules to account for predicates", "committedDate": "2020-05-20T21:50:41Z", "type": "commit"}, {"oid": "97d23fd727724d4d64fdfddfb9bbe7131d5b58b2", "url": "https://github.com/aws-amplify/amplify-android/commit/97d23fd727724d4d64fdfddfb9bbe7131d5b58b2", "message": "Checkstyle fixes", "committedDate": "2020-05-20T22:01:47Z", "type": "commit"}, {"oid": "249f19a70a4b8a2f264beb7aaf451aa087b4b2d5", "url": "https://github.com/aws-amplify/amplify-android/commit/249f19a70a4b8a2f264beb7aaf451aa087b4b2d5", "message": "Merge branch 'rjuliano/dspredicate-param' into rjuliano/dspredicate-param-rules", "committedDate": "2020-05-21T01:22:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY1MDQ4OQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/498#discussion_r428650489", "bodyText": "Did you mean to remove the inFlightMutations condition? I thought that was the piece Jameson just added.", "author": "TrekSoft", "createdAt": "2020-05-21T13:28:19Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/PersistentMutationOutbox.java", "diffHunk": "@@ -83,21 +84,21 @@ public boolean hasPendingMutation(@NonNull String modelId) {\n         String modelId = incomingMutation.getMutatedItem().getId();\n         @SuppressWarnings(\"unchecked\")\n         PendingMutation<T> existingMutation = (PendingMutation<T>) nextMutationForModelId(modelId);\n-        if (existingMutation == null || inFlightMutations.contains(existingMutation.getMutationId())) {\n-            return save(incomingMutation).andThen(notifyContentAvailable());\n-        }\n-        switch (incomingMutation.getMutationType()) {\n-            case CREATE:\n-                return handleCreation();\n-            case UPDATE:\n-                return handleUpdate(existingMutation, incomingMutation);\n-            case DELETE:\n-                return handleDeletion(existingMutation, incomingMutation);\n-            default:\n-                return unknownMutationType(incomingMutation.getMutationType());\n+        if (existingMutation == null) {", "originalCommit": "249f19a70a4b8a2f264beb7aaf451aa087b4b2d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY1OTg4NA==", "url": "https://github.com/aws-amplify/amplify-android/pull/498#discussion_r428659884", "bodyText": "I had moved that check down to one of the methods that handles conflicts. However, I think you're correct. It probably makes more sense here.", "author": "rjuliano", "createdAt": "2020-05-21T13:44:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY1MDQ4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY1MTY4Mg==", "url": "https://github.com/aws-amplify/amplify-android/pull/498#discussion_r428651682", "bodyText": "It looks like before, it would always handle the mutation type but now you're only handling it if the existingMutation isn't null so just wanted to check that's intended behavior.", "author": "TrekSoft", "createdAt": "2020-05-21T13:30:23Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/PersistentMutationOutbox.java", "diffHunk": "@@ -83,21 +84,21 @@ public boolean hasPendingMutation(@NonNull String modelId) {\n         String modelId = incomingMutation.getMutatedItem().getId();\n         @SuppressWarnings(\"unchecked\")\n         PendingMutation<T> existingMutation = (PendingMutation<T>) nextMutationForModelId(modelId);\n-        if (existingMutation == null || inFlightMutations.contains(existingMutation.getMutationId())) {\n-            return save(incomingMutation).andThen(notifyContentAvailable());\n-        }\n-        switch (incomingMutation.getMutationType()) {\n-            case CREATE:\n-                return handleCreation();\n-            case UPDATE:\n-                return handleUpdate(existingMutation, incomingMutation);\n-            case DELETE:\n-                return handleDeletion(existingMutation, incomingMutation);\n-            default:\n-                return unknownMutationType(incomingMutation.getMutationType());\n+        if (existingMutation == null) {\n+            return save(incomingMutation)\n+                .andThen(notifyContentAvailable());\n+        } else {\n+            return resolveConflict(existingMutation, incomingMutation);", "originalCommit": "249f19a70a4b8a2f264beb7aaf451aa087b4b2d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY2NDExNA==", "url": "https://github.com/aws-amplify/amplify-android/pull/498#discussion_r428664114", "bodyText": "I encapsulated that logic in the IncomingMutationConflictHandler. That class takes in both the existing and incoming mutation and applies logic similar to how iOS and JS are doing right now...at east that was the goal :)\nThe entry point for that is right here", "author": "rjuliano", "createdAt": "2020-05-21T13:51:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY1MTY4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY1NzE0NA==", "url": "https://github.com/aws-amplify/amplify-android/pull/498#discussion_r428657144", "bodyText": "Nit: Update suggestion to match others with a link - Jameson actually recently added a constant string to Amplify Exception for this type of suggestion you can use.", "author": "TrekSoft", "createdAt": "2020-05-21T13:39:52Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/PersistentMutationOutbox.java", "diffHunk": "@@ -318,4 +264,158 @@ public Completable markInFlight(@NonNull TimeBasedUuid pendingMutationId) {\n         }\n         return null;\n     }\n+\n+    /**\n+     * Encapsulate the logic to determine which actions to take based on incoming and existing\n+     * mutations. Non-static so we can access instance methods of the outer class. Private because\n+     * we don't want this logic called from anywhere else.\n+     * @param <T> the model type\n+     */\n+    private final class IncomingMutationConflictHandler<T extends Model> {\n+        private final PendingMutation<T> existing;\n+        private final PendingMutation<T> incoming;\n+\n+        /**\n+         * Constructor for a IncomingMutationConflictHandler.\n+         * @param existing The existing mutation.\n+         * @param incoming The incoming mutation.\n+         */\n+        private IncomingMutationConflictHandler(@NonNull PendingMutation<T> existing,\n+                                                @NonNull PendingMutation<T> incoming) {\n+            this.existing = existing;\n+            this.incoming = incoming;\n+        }\n+\n+        /**\n+         * Handle the conflict based on the incoming mutation type.\n+         * @return A completable with the actions to resolve the conflict.\n+         */\n+        Completable resolve() {\n+            switch (incoming.getMutationType()) {\n+                case CREATE:\n+                    return handleIncomingCreate();\n+                case UPDATE:\n+                    return handleIncomingUpdate();\n+                case DELETE:\n+                    return handleIncomingDelete();\n+                default:\n+                    return unknownMutationType(existing.getMutationType());\n+            }\n+        }\n+\n+        /**\n+         * Determine which action to take when the incoming mutation type is {@linkplain PendingMutation.Type#CREATE}.\n+         * @return A completable with the actions needed to resolve the conflict\n+         */\n+        private Completable handleIncomingCreate() {\n+            switch (existing.getMutationType()) {\n+                case CREATE:\n+                    // Double create, return an different error than in the default block of the switch\n+                    // statement. This way, we can differentiate between an incoming create being processed\n+                    // multiple times (this case), versus outgoing mutations being processed out of order.\n+                    return conflictingCreationError();\n+                default:\n+                    // A create mutation should never show up after an update or delete for the same modelId.\n+                    return unexpectedMutationScenario();\n+            }\n+        }\n+\n+        /**\n+         * Determine which action to take when the incoming mutation type is {@linkplain PendingMutation.Type#UPDATE}.\n+         * @return A completable with the actions needed to resolve the conflict\n+         */\n+        private Completable handleIncomingUpdate() {\n+            switch (existing.getMutationType()) {\n+                case CREATE:\n+                    // Update after the create -> replace item of the create mutation (and keep it as a create).\n+                    // No condition needs to be provided, because as far as the remote store is concerned,\n+                    // we're simply performing the create (with the updated item item contents)\n+                    return overwriteExistingAndNotify(PendingMutation.Type.CREATE, null);\n+                case UPDATE:\n+                    if (incoming.getPredicate() == null) {\n+                        // If the incoming update does not have a condition, we want to delete any\n+                        // existing mutations for the modelId before saving the incoming one.\n+                        return remove(existing.getMutationId()).andThen(saveIncomingAndNotify());\n+                    } else {\n+                        // If it has a condition, we want to just add it to the queue\n+                        return saveIncomingAndNotify();\n+                    }\n+                case DELETE:\n+                    // Incoming update after a delete -> throw exception\n+                    return modelAlreadyScheduledForDeletion();\n+                default:\n+                    return unexpectedMutationScenario();\n+            }\n+        }\n+\n+        /**\n+         * Determine which action to take when the incoming mutation type is {@linkplain PendingMutation.Type#DELETE}.\n+         * @return A completable with the actions needed to resolve the conflict\n+         */\n+        private Completable handleIncomingDelete() {\n+            switch (existing.getMutationType()) {\n+                case CREATE:\n+                    //\n+                    if (inFlightMutations.contains(existing.getMutationId())) {\n+                        // Existing create is already in flight, then save the delete\n+                        return save(incoming);\n+                    } else {\n+                        // The existing create mutation hasn't made it to the remote store, so we\n+                        // ignore the incoming and remove the existing create mutation from outbox.\n+                        return remove(existing.getMutationId());\n+                    }\n+                case UPDATE:\n+                case DELETE:\n+                    // If there's a pending update OR delete, we want to replace it with the incoming delete.\n+                    return overwriteExistingAndNotify(PendingMutation.Type.DELETE, incoming.getPredicate());\n+                default:\n+                    return unexpectedMutationScenario();\n+            }\n+        }\n+\n+        private Completable overwriteExistingAndNotify(@NonNull PendingMutation.Type type,\n+                                                       @Nullable QueryPredicate predicate) {\n+            // Keep the old mutation ID, but update the contents of that mutation.\n+            // Now, it will have the contents of the incoming update mutation.\n+            TimeBasedUuid id = existing.getMutationId();\n+            T item = incoming.getMutatedItem();\n+            Class<T> clazz = incoming.getClassOfMutatedItem();\n+            return save(PendingMutation.instance(id, item, clazz, type, predicate))\n+                .andThen(notifyContentAvailable());\n+        }\n+\n+        private Completable saveIncomingAndNotify() {\n+            return save(incoming)\n+                .andThen(notifyContentAvailable());\n+        }\n+\n+        private Completable conflictingCreationError() {\n+            return Completable.error(new DataStoreException(\n+                \"Attempted to enqueue a model creation, but there is already a pending creation for that model ID.\",\n+                \"Please report at https://github.com/aws-amplify/amplify-android/issues.\"\n+            ));\n+        }\n+\n+        private Completable modelAlreadyScheduledForDeletion() {\n+            return Completable.error(new DataStoreException(\n+                \"Attempted to enqueue a model mutation, but that model already had a delete mutation pending.\",\n+                \"This should not be possible. Please report on GitHub issues.\"", "originalCommit": "249f19a70a4b8a2f264beb7aaf451aa087b4b2d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk4MTU4Ng==", "url": "https://github.com/aws-amplify/amplify-android/pull/498#discussion_r428981586", "bodyText": "Hm, it wasn't me, actually! I thought it was you. It was @drochetti!", "author": "jamesonwilliams", "createdAt": "2020-05-22T00:21:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODY1NzE0NA=="}], "type": "inlineReview"}, {"oid": "1a83299b786ffb21001e1524c9a33523c9f984be", "url": "https://github.com/aws-amplify/amplify-android/commit/1a83299b786ffb21001e1524c9a33523c9f984be", "message": "Re-introduce the isInFlight check in the enqueue method", "committedDate": "2020-05-21T13:50:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk4MjI4OQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/498#discussion_r428982289", "bodyText": "Should we be creating a new one every time, like this?", "author": "jamesonwilliams", "createdAt": "2020-05-22T00:24:05Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/PersistentMutationOutbox.java", "diffHunk": "@@ -84,20 +85,20 @@ public boolean hasPendingMutation(@NonNull String modelId) {\n         @SuppressWarnings(\"unchecked\")\n         PendingMutation<T> existingMutation = (PendingMutation<T>) nextMutationForModelId(modelId);\n         if (existingMutation == null || inFlightMutations.contains(existingMutation.getMutationId())) {\n-            return save(incomingMutation).andThen(notifyContentAvailable());\n-        }\n-        switch (incomingMutation.getMutationType()) {\n-            case CREATE:\n-                return handleCreation();\n-            case UPDATE:\n-                return handleUpdate(existingMutation, incomingMutation);\n-            case DELETE:\n-                return handleDeletion(existingMutation, incomingMutation);\n-            default:\n-                return unknownMutationType(incomingMutation.getMutationType());\n+            return save(incomingMutation)\n+                .andThen(notifyContentAvailable());\n+        } else {\n+            return resolveConflict(existingMutation, incomingMutation);\n         }\n     }\n \n+    private <T extends Model> Completable resolveConflict(@NonNull PendingMutation<T> existingMutation,\n+                                                          @NonNull PendingMutation<T> incomingMutation) {\n+        IncomingMutationConflictHandler<T> mutationConflictHandler =\n+            new IncomingMutationConflictHandler<>(existingMutation, incomingMutation);", "originalCommit": "1a83299b786ffb21001e1524c9a33523c9f984be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}