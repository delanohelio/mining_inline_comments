{"pr_number": 909, "pr_title": "feat(datastore) Add start and stop, and stop starting on configure and clear", "pr_createdAt": "2020-10-17T03:37:09Z", "pr_url": "https://github.com/aws-amplify/amplify-android/pull/909", "timeline": [{"oid": "9e391fbd9a7ecf3aee90f626aa61d203ea6719e8", "url": "https://github.com/aws-amplify/amplify-android/commit/9e391fbd9a7ecf3aee90f626aa61d203ea6719e8", "message": "feat(datastore) Add start and stop, and stop starting on configure and clear", "committedDate": "2020-10-16T22:31:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzk1MTgxMA==", "url": "https://github.com/aws-amplify/amplify-android/pull/909#discussion_r507951810", "bodyText": "I think the others currently use : instead of -:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final Logger LOG = Amplify.Logging.forNamespace(\"amplify:datastore-test\");\n          \n          \n            \n                private static final Logger LOG = Amplify.Logging.forNamespace(\"amplify:datastore:test\");", "author": "jamesonwilliams", "createdAt": "2020-10-19T17:56:25Z", "path": "aws-datastore/src/test/java/com/amplifyframework/datastore/AWSDataStorePluginTest.java", "diffHunk": "@@ -79,6 +82,8 @@\n @SuppressWarnings(\"SameParameterValue\")\n @RunWith(RobolectricTestRunner.class)\n public final class AWSDataStorePluginTest {\n+    private static final Logger LOG = Amplify.Logging.forNamespace(\"amplify:datastore-test\");", "originalCommit": "9e391fbd9a7ecf3aee90f626aa61d203ea6719e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzk2Mzg4Mg==", "url": "https://github.com/aws-amplify/amplify-android/pull/909#discussion_r507963882", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            //        //Configure DataStore with an empty config (All defaults)\n          \n          \n            \n                    // Configure DataStore with an empty config (All defaults)", "author": "jamesonwilliams", "createdAt": "2020-10-19T18:12:27Z", "path": "aws-datastore/src/test/java/com/amplifyframework/datastore/AWSDataStorePluginTest.java", "diffHunk": "@@ -102,25 +107,37 @@ public void setup() {\n     }\n \n     /**\n-     * Configuring and initializing the plugin succeeds without freezing or\n-     * crashing the calling thread. Basic. \ud83d\ude44\n-     * @throws AmplifyException Not expected; on failure to configure of initialize plugin.\n+     * Configuring and initializing the plugin succeeds without freezing or crashing the calling thread. Basic. \ud83d\ude44\n+     * @throws AmplifyException On failure to configure or initialize plugin.\n      */\n     @Test\n-    public void configureAndInitializeInLocalMode() throws AmplifyException {\n+    public void configureAndInitialize() throws AmplifyException {\n         //Configure DataStore with an empty config (All defaults)\n+        ApiCategory emptyApiCategory = spy(ApiCategory.class);\n+        AWSDataStorePlugin standAloneDataStorePlugin = new AWSDataStorePlugin(modelProvider, emptyApiCategory);\n+        standAloneDataStorePlugin.configure(new JSONObject(), context);\n+        standAloneDataStorePlugin.initialize(context);\n+    }\n+\n+    /**\n+     * Starting the plugin in local mode (no API plugin) works without freezing or crashing the calling thread.\n+     * @throws AmplifyException Not expected; on failure to configure of initialize plugin.\n+     */\n+    @Test\n+    public void startInLocalMode() throws AmplifyException {\n+//        //Configure DataStore with an empty config (All defaults)", "originalCommit": "9e391fbd9a7ecf3aee90f626aa61d203ea6719e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzk3MzgzMQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/909#discussion_r507973831", "bodyText": "Line 223 still says \"synchronization processes are restarted\"; could you update the Javadoc?", "author": "jamesonwilliams", "createdAt": "2020-10-19T18:28:54Z", "path": "aws-datastore/src/test/java/com/amplifyframework/datastore/AWSDataStorePluginTest.java", "diffHunk": "@@ -204,7 +225,7 @@ public void configureAndInitializeInApiModeWithoutApi() throws JSONException, Am\n      * @throws AmplifyException on failure to arrange API plugin via Amplify facade\n      */\n     @Test\n-    public void clearStopsSyncUntilNextInteraction() throws AmplifyException, JSONException {\n+    public void clearStopsSyncAndDeletesDatabase() throws AmplifyException, JSONException {", "originalCommit": "9e391fbd9a7ecf3aee90f626aa61d203ea6719e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzk5NDY3MA==", "url": "https://github.com/aws-amplify/amplify-android/pull/909#discussion_r507994670", "bodyText": "The comment was actually wrong before - the previous implementation restarted synchronization immediately).\nThe new behavior matches the comment now.  clear won't restart synchronization, but the next interaction with DataStore will.", "author": "richardmcclellan", "createdAt": "2020-10-19T19:02:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzk3MzgzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzk3ODU3MQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/909#discussion_r507978571", "bodyText": "This won't actually fail the test. jUnit will only report a test failure if the assertion error is raised on the test runner's thread. This will crash the new Thread, but it won't get reported.\nIf you don't rely on the fail for the test to be useful, I'd suggest changing this fail to a comment, like:\n// This doesn't matter, we'll catch the failure later when we validate (thing you'll validate later).\nIf you are expecting this fail to catch a bad state, you'd have to coalesce it back into control flow on the test runner thread, somehow.", "author": "jamesonwilliams", "createdAt": "2020-10-19T18:36:21Z", "path": "aws-datastore/src/test/java/com/amplifyframework/datastore/syncengine/OrchestratorTest.java", "diffHunk": "@@ -156,7 +158,13 @@ public void preventConcurrentStateTransitions() throws AmplifyException {\n         orchestrator.start();\n \n         // Try to start it in a new thread.\n-        new Thread(() -> orchestrator.start()).start();\n+        new Thread(() -> {\n+            try {\n+                orchestrator.start();\n+            } catch (DataStoreException exception) {\n+                fail(\"Error occurred starting the orchestrator.\" + exception);", "originalCommit": "9e391fbd9a7ecf3aee90f626aa61d203ea6719e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTIyNTg0Ng==", "url": "https://github.com/aws-amplify/amplify-android/pull/909#discussion_r509225846", "bodyText": "The idea behind this test was to check that concurrent calls start the orchestrator would only result in the orchestrator starting once. This is checked by the assertion on line 172 which checks that the query method on the API was called only once.\nSince start now throws a DataStoreException, you may just need to add that exception to the throws statement of the test declaration.\nOr if you want to wait for the orchestrator.start() from the thread to finish (line 163) , you can use a CountdownLatch that gets counted down right after the call completes.", "author": "rjuliano", "createdAt": "2020-10-21T12:12:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzk3ODU3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzk3ODk0Ng==", "url": "https://github.com/aws-amplify/amplify-android/pull/909#discussion_r507978946", "bodyText": "Maybe we should order these nearer to configure(...) and initialize(...) in the document, since they are more lifecycle-oriented?", "author": "jamesonwilliams", "createdAt": "2020-10-19T18:37:04Z", "path": "core/src/main/java/com/amplifyframework/datastore/DataStoreCategory.java", "diffHunk": "@@ -183,6 +183,16 @@ public void observe(\n             onObservationStarted, onDataStoreItemChange, onObservationFailure, onObservationCompleted);\n     }\n \n+    @Override\n+    public void start(@NonNull Action onComplete, @NonNull Consumer<DataStoreException> onError) {\n+        getSelectedPlugin().start(onComplete, onError);\n+    }\n+\n+    @Override\n+    public void stop(@NonNull Action onComplete, @NonNull Consumer<DataStoreException> onError) {\n+        getSelectedPlugin().stop(onComplete, onError);\n+    }\n+", "originalCommit": "9e391fbd9a7ecf3aee90f626aa61d203ea6719e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzk4MjQ5Ng==", "url": "https://github.com/aws-amplify/amplify-android/pull/909#discussion_r507982496", "bodyText": "Suggest a few tweaks to language to:\n\nRemove use of \"it\", which increases cognitive buffering in dense technical writing, and\nTalk explicitly about synchronization with a remote system. Currently, there is not enough differentiation from configure() or initialize().\n\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Starts the DataStore.  This only needs to be called if you wish to start eagerly.  If you don't call it,\n          \n          \n            \n                 * it will be called automatically prior to executing any other operations (#query, #save, #delete, #observe).\n          \n          \n            \n                 * Starts the DataStore's synchronization with a remote system, if DataStore is configured to support\n          \n          \n            \n                 * remote synchronization. This only needs to be called if you wish to start the synchronization eagerly.\n          \n          \n            \n                 * If you don't call start(), the synchronization will start automatically, prior to executing any other\n          \n          \n            \n                 * operations (#query, #save, #delete, #observe).\n          \n      \n    \n    \n  \n\nI might suggest going back and updating configure(), initialize() (well, it's on the category), and clear(), to more explicitly highlight their relationship to the new start() and stop().", "author": "jamesonwilliams", "createdAt": "2020-10-19T18:43:25Z", "path": "core/src/main/java/com/amplifyframework/datastore/DataStoreCategoryBehavior.java", "diffHunk": "@@ -227,7 +227,29 @@ void observe(\n     );\n \n     /**\n-     * Resets the underlying DataStore to its pre-initialized state such that no data remains on the local\n+     * Starts the DataStore.  This only needs to be called if you wish to start eagerly.  If you don't call it,\n+     * it will be called automatically prior to executing any other operations (#query, #save, #delete, #observe).", "originalCommit": "9e391fbd9a7ecf3aee90f626aa61d203ea6719e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzk4NDk2NA==", "url": "https://github.com/aws-amplify/amplify-android/pull/909#discussion_r507984964", "bodyText": "Similar thoughts as above, about the onComplete, here. But also: what's the DX for this callback, why would someone use it? Shouldn't start(...) wait until model synchronization is fully started, to invoke this? Otherwise, why wouldn't I just always use the READY event? And if I should always prefer READY, then couldn't we remove this callback? Lastly, we now have:\n\nConfigured\nInitialized\nStarted\nReady\n\nAll of which mean different things. That might be okay internally to our code, but I wonder if we can eliminate ~2 of these entirely from the user's view.", "author": "jamesonwilliams", "createdAt": "2020-10-19T18:47:29Z", "path": "core/src/main/java/com/amplifyframework/datastore/DataStoreCategoryBehavior.java", "diffHunk": "@@ -227,7 +227,29 @@ void observe(\n     );\n \n     /**\n-     * Resets the underlying DataStore to its pre-initialized state such that no data remains on the local\n+     * Starts the DataStore.  This only needs to be called if you wish to start eagerly.  If you don't call it,\n+     * it will be called automatically prior to executing any other operations (#query, #save, #delete, #observe).\n+     *\n+     * @param onComplete Invoked after DataStore is initialized.  This does not block until subscriptions and\n+     *                  sync are complete.  To block until sync and subscriptions are complete, use\n+     *                   Amplify.Hub.subscribe to listen for the DataStoreChannelEventName.READY event on\n+     *                   HubChannel.DATASTORE.\n+     * @param onError Invoked if an exception occurs.", "originalCommit": "9e391fbd9a7ecf3aee90f626aa61d203ea6719e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTI1ODc5Ng==", "url": "https://github.com/aws-amplify/amplify-android/pull/909#discussion_r509258796", "bodyText": "I've struggled with this one. If the intent is to align with JS (as much as possible), start() really means startSyncEngine(), but the naming is besides the point here. One of the things we discussed is that for the mobile platforms, blocking execution during the entirety of the initialization of sync engine could lead to poor UX.\nIn the past, I've advocated for blocking only until StorageObserver starts since that's the bare minimum we would need to ensure no customer data is lost. That being said, that would give the onComplete callback yet another meaning, so I'm not too sure about that.\nLooking at the plugin code, it looks like the onComplete callback basically lets them know that we've received their request to start the sync engine. I commented under the start method of the plugin as well, but there may be a scenario which both onComplete and onError can fire for the same call, which could lead to confusion.\nMaybe the \"easy\" answer is to have no callbacks on start and stop, and tell devs to listen to sync engine events on the Hub.", "author": "rjuliano", "createdAt": "2020-10-21T13:03:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzk4NDk2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTYyMDA2Mg==", "url": "https://github.com/aws-amplify/amplify-android/pull/909#discussion_r509620062", "bodyText": "I've been scratching my head for a while about this as well :).\nHere's how start() is implemented in this PR:\n\nonComplete is called after:\n\nplugin initialization completes (if needed)\nstorageObserver.startObservingStorageChanges completes.\n\n\nonError is called:\n\nif initialization doesn't complete within 2 seconds\nif orchestrator start stop lock is not acquired within 2 seconds\nif storageObserver.startObservingStorageChanges doesn't complete within 2 seconds\n\n\n\nRealistically, if onError is called, the error is not going to be something clients can handle anyway.  It'll probably only be called because of a bug in the library.\nA basic app built with DataStore should look something like this (start() is not even a critical component):\nprivate void showListOfTodos() {\n    runQuery(); // Show locally cached data (or local synced data if already synced)\n    Amplify.Hub.subscribe(HubChannel.DATASTORE,\n            hubEvent -> DataStoreChannelEventName.READY.toString().equals(hubEvent.getName()),\n            hubEvent -> runQuery()); // Show synced data\n}\n\nprivate void runQuery() {\n    Amplify.DataStore.query(Todo.class,\n            result -> { /* Display results on UI */},\n            error -> { }\n    );\n}\n\nCustomers only need to call start() if they want to pre-cache data before displaying it to the end user.  They would call start(), presumably on app launch, and then call query whenever the end user navigates to a view that requires data.   Based on this, I don't think onComplete / onError make much sense, so I will remove them.\nFor stop(), there are two customer use cases:\n\nClose subscription sockets to save battery when DataStore is not needed, such as on app close.\nForce a re-evaluation of sync query predicates. A customer would immediately call query(...) after stop(). Since we have the startStopSemaphore locking the stop operation, this should work just fine.\n\nCallbacks aren't particularly useful for either of those use cases.   I'll bring this up with iOS/JS in the DataStore sync meeting tomorrow, and if we all agree, we will remove the callbacks.", "author": "richardmcclellan", "createdAt": "2020-10-21T19:43:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzk4NDk2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc5MTQ5OQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/909#discussion_r513791499", "bodyText": "I spoke with the iOS and JS teams about this a few days ago, and they opposed removing these callbacks.\nThe JS version of start() returns a Promise, which will throw an exception if there are any exceptions thrown while evaluating the client provided selection sync query code block (not implemented on Android yet, but coming soon)\nSo, there are reasons for having callbacks, and reasons not to.  Given that adding this new API is a bit of a one-way door, I'd like to keep the callbacks, even if they don't report very meaningful errors, since we will likely need them later (probably for selective sync).\nIf there are no objections to the above, this PR is ready to fly, and I'll merge as soon as I get an approval!", "author": "richardmcclellan", "createdAt": "2020-10-28T22:08:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzk4NDk2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzk4NjIzOA==", "url": "https://github.com/aws-amplify/amplify-android/pull/909#discussion_r507986238", "bodyText": "Nice!! I think there are a few places where I could have used this, around the code base. I can go back and patch them up, now that you've added this.", "author": "jamesonwilliams", "createdAt": "2020-10-19T18:49:42Z", "path": "testutils/src/main/java/com/amplifyframework/testutils/VoidResult.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amplifyframework.testutils;\n+\n+/**\n+ * Result placeholder to be used when there is no value emitted from a task, but we are interested in the completion of\n+ * the task.\n+ */\n+public final class VoidResult {", "originalCommit": "9e391fbd9a7ecf3aee90f626aa61d203ea6719e8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3742a3ed0b9827029fc9d0346e41777e1e7f25a6", "url": "https://github.com/aws-amplify/amplify-android/commit/3742a3ed0b9827029fc9d0346e41777e1e7f25a6", "message": "Apply suggestions from code review\n\nCo-authored-by: Jameson Williams <jhwill@amazon.com>", "committedDate": "2020-10-19T19:50:05Z", "type": "commit"}, {"oid": "456dcf8cc5ff6af75b0d44f2912751ef4d7c3115", "url": "https://github.com/aws-amplify/amplify-android/commit/456dcf8cc5ff6af75b0d44f2912751ef4d7c3115", "message": "method reordering", "committedDate": "2020-10-19T21:09:03Z", "type": "commit"}, {"oid": "eab859fba669d539ba6a2d45e6bfb98f997c6680", "url": "https://github.com/aws-amplify/amplify-android/commit/eab859fba669d539ba6a2d45e6bfb98f997c6680", "message": "spacing", "committedDate": "2020-10-20T19:21:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTI1MjA5Mw==", "url": "https://github.com/aws-amplify/amplify-android/pull/909#discussion_r509252093", "bodyText": "Could both onComplete and onError fire for the same call? I think onComplete will always fire, but if an exception is thrown by orchestrator.start() the onError(...) callback will also be invoked which could lead to devs assuming that if onComplete() fires, they're OK to move on with the rest of their call flow.\nThis is a tough one to sort out. Maybe instead of having two callbacks, we have a onStatus(status) callback that emits different statuses based on where we are in the initialization process of the sync engine?\nOr we just go with no callbacks and tell devs to rely on hub events to track the state of the sync engine.", "author": "rjuliano", "createdAt": "2020-10-21T12:53:31Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/AWSDataStorePlugin.java", "diffHunk": "@@ -238,6 +236,68 @@ private Completable initializeStorageAdapter(Context context) {\n         ));\n     }\n \n+    private void waitForInitialization(@NonNull Action onComplete, @NonNull Consumer<DataStoreException> onError) {\n+        Completable.create(emitter -> {\n+            categoryInitializationsPending.await();\n+            emitter.onComplete();\n+        })\n+                .timeout(LIFECYCLE_TIMEOUT_MS, TimeUnit.MILLISECONDS)\n+                .subscribeOn(Schedulers.io())\n+                .subscribe(\n+                        () -> onComplete.call(),\n+                        throwable -> onError.accept(new DataStoreException(\"Request failed because DataStore is not \" +\n+                                \"initialized.\", throwable, \"Retry your request.\"))\n+                );\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void start(@NonNull Action onComplete, @NonNull Consumer<DataStoreException> onError) {\n+        waitForInitialization(() -> {\n+            try {\n+                orchestrator.start();\n+            } catch (DataStoreException exception) {\n+                onError.accept(exception);\n+                return;\n+            }\n+            onComplete.call();", "originalCommit": "456dcf8cc5ff6af75b0d44f2912751ef4d7c3115", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTYyMjY0OQ==", "url": "https://github.com/aws-amplify/amplify-android/pull/909#discussion_r509622649", "bodyText": "Could both onComplete and onError fire for the same call? I think onComplete will always fire, but if an exception is thrown by orchestrator.start() the onError(...) callback will also be invoked which could lead to devs assuming that if onComplete() fires, they're OK to move on with the rest of their call flow.\n\nHmm, did I mess this up?   I think onComplete will not be called on error, because there's a return on line 263, right?", "author": "richardmcclellan", "createdAt": "2020-10-21T19:46:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTI1MjA5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzEyODQwOA==", "url": "https://github.com/aws-amplify/amplify-android/pull/909#discussion_r513128408", "bodyText": "Nevermind. For whatever reason I thought the onComplete.call() was outside of the curly braces.", "author": "rjuliano", "createdAt": "2020-10-28T01:36:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTI1MjA5Mw=="}], "type": "inlineReview"}, {"oid": "1f682b54ebbc2a5bc21b737bc14be37f159056e8", "url": "https://github.com/aws-amplify/amplify-android/commit/1f682b54ebbc2a5bc21b737bc14be37f159056e8", "message": "Update test to fail if error is thrown in separate thread", "committedDate": "2020-10-22T21:19:23Z", "type": "commit"}, {"oid": "40f7e83a9c77d0eae7621d5720ef2a75c6e556f1", "url": "https://github.com/aws-amplify/amplify-android/commit/40f7e83a9c77d0eae7621d5720ef2a75c6e556f1", "message": "Merge branch 'main' into rm/ds-start", "committedDate": "2020-10-28T22:15:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgwOTM3Mg==", "url": "https://github.com/aws-amplify/amplify-android/pull/909#discussion_r513809372", "bodyText": "How about:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    CountDownLatch startOrchestratorInNewThreadLatch = new CountDownLatch(1);\n          \n          \n            \n                    new Thread(() -> {\n          \n          \n            \n                        try {\n          \n          \n            \n                            orchestrator.start();\n          \n          \n            \n                            startOrchestratorInNewThreadLatch.countDown();\n          \n          \n            \n                        } catch (DataStoreException exception) {\n          \n          \n            \n                            // No need to do anything here.  Test will fail down below when latch times out.\n          \n          \n            \n                        }\n          \n          \n            \n                    }).start();\n          \n          \n            \n            \n          \n          \n            \n                    // Try to start it again on a current thread.\n          \n          \n            \n                    orchestrator.start();\n          \n          \n            \n            \n          \n          \n            \n                    if (!startOrchestratorInNewThreadLatch.await(2, TimeUnit.SECONDS)) {\n          \n          \n            \n                        fail(\"Failed to start orchestrator on a background thread.\");\n          \n          \n            \n                    }\n          \n          \n            \n                    Completable\n          \n          \n            \n                        .create(subscriber -> {\n          \n          \n            \n                            new Thread(() -> {\n          \n          \n            \n                               try {\n          \n          \n            \n                                   orchestrator.start();\n          \n          \n            \n                                   subscriber.onComplete();\n          \n          \n            \n                               } catch (DataStoreException failure) {\n          \n          \n            \n                                   subscriber.onFailure(failure);\n          \n          \n            \n                               }\n          \n          \n            \n                            }).start();\n          \n          \n            \n                        })\n          \n          \n            \n                        .blockingAwait(5, TimeUnit.SECONDS);\n          \n      \n    \n    \n  \n\nOr:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    CountDownLatch startOrchestratorInNewThreadLatch = new CountDownLatch(1);\n          \n          \n            \n                    new Thread(() -> {\n          \n          \n            \n                        try {\n          \n          \n            \n                            orchestrator.start();\n          \n          \n            \n                            startOrchestratorInNewThreadLatch.countDown();\n          \n          \n            \n                        } catch (DataStoreException exception) {\n          \n          \n            \n                            // No need to do anything here.  Test will fail down below when latch times out.\n          \n          \n            \n                        }\n          \n          \n            \n                    }).start();\n          \n          \n            \n            \n          \n          \n            \n                    // Try to start it again on a current thread.\n          \n          \n            \n                    orchestrator.start();\n          \n          \n            \n            \n          \n          \n            \n                    if (!startOrchestratorInNewThreadLatch.await(2, TimeUnit.SECONDS)) {\n          \n          \n            \n                        fail(\"Failed to start orchestrator on a background thread.\");\n          \n          \n            \n                    }\n          \n          \n            \n                    Await\n          \n          \n            \n                        .<VoidResult, DataStoreException>result((onResult, onError) -> {\n          \n          \n            \n                            new Thread(() -> {\n          \n          \n            \n                               try {\n          \n          \n            \n                                   orchestrator.start();\n          \n          \n            \n                                   onResult.accept(VoidResult.instance());\n          \n          \n            \n                               } catch (DataStoreException failure) {\n          \n          \n            \n                                   onError.accept(failure);\n          \n          \n            \n                               }\n          \n          \n            \n                            }).start();\n          \n          \n            \n                        });", "author": "jamesonwilliams", "createdAt": "2020-10-28T22:54:31Z", "path": "aws-datastore/src/test/java/com/amplifyframework/datastore/syncengine/OrchestratorTest.java", "diffHunk": "@@ -146,17 +149,32 @@ public void itemsPlacedInStorageArePublishedToNetwork() throws AmplifyException\n \n     /**\n      * Verify preventing concurrent state transitions from happening.\n+     * @throws AmplifyException Not expected.\n+     * @throws InterruptedException Not expected.\n      */\n     @Test\n-    public void preventConcurrentStateTransitions() {\n+    public void preventConcurrentStateTransitions() throws AmplifyException, InterruptedException {\n         // Arrange: orchestrator is running\n         orchestrator.start();\n \n         // Try to start it in a new thread.\n-        new Thread(() -> orchestrator.start()).start();\n+        CountDownLatch startOrchestratorInNewThreadLatch = new CountDownLatch(1);\n+        new Thread(() -> {\n+            try {\n+                orchestrator.start();\n+                startOrchestratorInNewThreadLatch.countDown();\n+            } catch (DataStoreException exception) {\n+                // No need to do anything here.  Test will fail down below when latch times out.\n+            }\n+        }).start();\n+\n         // Try to start it again on a current thread.\n         orchestrator.start();\n \n+        if (!startOrchestratorInNewThreadLatch.await(2, TimeUnit.SECONDS)) {\n+            fail(\"Failed to start orchestrator on a background thread.\");\n+        }", "originalCommit": "40f7e83a9c77d0eae7621d5720ef2a75c6e556f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzkyMTg3Ng==", "url": "https://github.com/aws-amplify/amplify-android/pull/909#discussion_r513921876", "bodyText": "I like both of these better, thanks for the suggestions.  I'll go with the RxJava approach :).   RxJava feels cleaner than using a CountDownLatch.    I'd like to start using the RxJava timeout operator more too, instead of CountDownLatch, where possible.", "author": "richardmcclellan", "createdAt": "2020-10-29T03:34:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzgwOTM3Mg=="}], "type": "inlineReview"}, {"oid": "dd73248046c5b944400475972365e8c944dac175", "url": "https://github.com/aws-amplify/amplify-android/commit/dd73248046c5b944400475972365e8c944dac175", "message": "Fix merge issues", "committedDate": "2020-10-29T02:47:21Z", "type": "commit"}, {"oid": "37aa39646625c7753094cd6d719f70e64c222938", "url": "https://github.com/aws-amplify/amplify-android/commit/37aa39646625c7753094cd6d719f70e64c222938", "message": "Use RxJava instead of CountdownLatch in test", "committedDate": "2020-10-29T03:40:31Z", "type": "commit"}]}