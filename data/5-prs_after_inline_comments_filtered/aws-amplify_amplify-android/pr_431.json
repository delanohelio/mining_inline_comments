{"pr_number": 431, "pr_title": "StorageAdapter and SyncEngine to use different event bundles", "pr_createdAt": "2020-05-06T08:15:23Z", "pr_url": "https://github.com/aws-amplify/amplify-android/pull/431", "timeline": [{"oid": "7aced16f85efdf80bffc8b1baf7a4617bc409de4", "url": "https://github.com/aws-amplify/amplify-android/commit/7aced16f85efdf80bffc8b1baf7a4617bc409de4", "message": "[aws-datastore] Decompose StorageItemChange into smaller pieces", "committedDate": "2020-05-06T00:54:01Z", "type": "commit"}, {"oid": "7260bf99d339f24c8b3baf70d98ba00805cd8f84", "url": "https://github.com/aws-amplify/amplify-android/commit/7260bf99d339f24c8b3baf70d98ba00805cd8f84", "message": "[aws-datastore] Emit StorageItemChange from LocalStorageAdapter\n\nPreviously, the LocalStorageAdapter would emit StorageItemChangeRecord,\nwhich is the serialization convenience class use to persist the changes.\nFrom the standpoint of a component contract, this is leaking a detail.\n\nA future chnage will consume the higher-level StorageItemChange, and\nconvert it to a _different_ type, not a StorageItemChangeRecord.\n\nAs of this commit, the StorageItemChangeRecord is still used widely\nin test while inspecing a variety of ancillary behaviors.", "committedDate": "2020-05-06T04:28:30Z", "type": "commit"}, {"oid": "efe40d343bb0f44122cdf09e86d4b3ecc7824f5d", "url": "https://github.com/aws-amplify/amplify-android/commit/efe40d343bb0f44122cdf09e86d4b3ecc7824f5d", "message": "[aws-datastore] Spilt StorageItemChange and PendingMutation\n\nNow, the LocalStorageAdapter emits StorageItemChange. This notification\ntype does not get persisted (the storage items do, duh.)\n\nThe StorageObserver is a component of the Sync Engine package. It\nobserves the storage layer. It responds by enqueing PendingMutations\ninto a MutationOutbox. The MutationOutbox is persistent. Internally, it\nsaves its PendingMutations using a LocalStorageAdapter.\n\nThe LocalStorageAdapter has no actual awareness of the PendingMutation\ntype. The PendingMutation is just an Model that holds a couple of\nstrings. The MutationOutbox can later use this information to\nreconstruct a PendingMutation.", "committedDate": "2020-05-06T09:06:40Z", "type": "commit"}, {"oid": "efe40d343bb0f44122cdf09e86d4b3ecc7824f5d", "url": "https://github.com/aws-amplify/amplify-android/commit/efe40d343bb0f44122cdf09e86d4b3ecc7824f5d", "message": "[aws-datastore] Spilt StorageItemChange and PendingMutation\n\nNow, the LocalStorageAdapter emits StorageItemChange. This notification\ntype does not get persisted (the storage items do, duh.)\n\nThe StorageObserver is a component of the Sync Engine package. It\nobserves the storage layer. It responds by enqueing PendingMutations\ninto a MutationOutbox. The MutationOutbox is persistent. Internally, it\nsaves its PendingMutations using a LocalStorageAdapter.\n\nThe LocalStorageAdapter has no actual awareness of the PendingMutation\ntype. The PendingMutation is just an Model that holds a couple of\nstrings. The MutationOutbox can later use this information to\nreconstruct a PendingMutation.", "committedDate": "2020-05-06T09:06:40Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDgxNTc5Nw==", "url": "https://github.com/aws-amplify/amplify-android/pull/431#discussion_r420815797", "bodyText": "Just to make sure I'm understanding the removal here: we're saying that by virtue of SYNC_ENGINE-initiated records not being enqueued by the StorageObserver, this filter was essentially useless, right?", "author": "rjuliano", "createdAt": "2020-05-06T14:01:51Z", "path": "aws-datastore/src/main/java/com/amplifyframework/datastore/syncengine/MutationOutbox.java", "diffHunk": "@@ -38,165 +39,152 @@\n  * for changes that have already occurred in the storage adapter, and need\n  * to be synchronized with a remote GraphQL API, via (a) GraphQL mutation(s).\n  *\n- * This component may also be thought of as an \"offline mutation queue,\" except for\n- * that the implementation doesn't store GraphQL primitives, it stores storage change\n- * primitives. These are consumed and converted to GraphQL mutations, though.\n- *\n- * Items in the mutation outbox are observed, and written out over the network.\n- * When a write completes successfully, it is safe to remove the corresponding item\n- * from the outbox.\n+ * This component is an \"offline mutation queue,\"; items in the mutation outbox are observed,\n+ * and written out over the network. When an item is written out over the network successfully,\n+ * it is safe to remove it from this outbox.\n  */\n-// In this class, some lambdas look more readable w/ blocks\n-// The generics get crazy, so we break convention and use labels MODEL and SIC, not just M, S.\n-@SuppressWarnings({\"CodeBlock2Expr\", \"checkstyle:MethodTypeParameterName\"})\n final class MutationOutbox {\n-    private final LocalStorageAdapter localStorageAdapter;\n-    private final PublishSubject<StorageItemChange<? extends Model>> pendingStorageItemChanges;\n-    private final GsonStorageItemChangeConverter storageItemChangeConverter;\n+    private static final Logger LOG = Amplify.Logging.forNamespace(\"amplify:aws-datastore\");\n+\n+    private final LocalStorageAdapter storage;\n+    private final PublishSubject<PendingMutation<? extends Model>> pendingMutations;\n+    private final PendingMutation.Converter converter;\n \n     MutationOutbox(@NonNull final LocalStorageAdapter localStorageAdapter) {\n-        this.localStorageAdapter = Objects.requireNonNull(localStorageAdapter);\n-        this.pendingStorageItemChanges = PublishSubject.create();\n-        this.storageItemChangeConverter = new GsonStorageItemChangeConverter();\n+        this.storage = Objects.requireNonNull(localStorageAdapter);\n+        this.pendingMutations = PublishSubject.create();\n+        this.converter = new GsonPendingMutationConverter();\n     }\n \n     /**\n      * Checks to see if there is a pending mutation for a model with the given ID.\n-     * @param modelId ID of any model\n+     * @param modelId ID of any model in the system\n      * @return An {@link Single} which emits true if there is a pending mutation for\n-     *         the model id, emits false if not, emits error if it can't tell due to an error\n+     *         the model id, emits false if not, and emits error if not determinable\n      */\n     @NonNull\n-    Single<Boolean> hasPendingMutation(String modelId) {\n-        QueryPredicate hasMatchingId = QueryField.field(\"id\").eq(modelId);\n-        return Single.create(emitter -> {\n-            localStorageAdapter.query(StorageItemChange.Record.class, hasMatchingId,\n+    Single<Boolean> hasPendingMutation(@NonNull String modelId) {\n+        Objects.requireNonNull(modelId);\n+        return Single.create(emitter ->\n+            storage.query(PendingMutation.PersistentRecord.class, QueryField.field(\"id\").eq(modelId),\n                 results -> emitter.onSuccess(results.hasNext()),\n                 emitter::onError\n-            );\n-        });\n+            )\n+        );\n     }\n \n     /**\n-     * Write a new {@link StorageItemChange} into the outbox.\n+     * Write a new {@link PendingMutation} into the outbox.\n+     *\n      * This involves:\n-     *   1. Writing the {@link StorageItemChange.Record} into a persistent store\n-     *      (we use the storage adapter, again, for this). To make our lives easier,\n-     *      we first convert the {@link StorageItemChange} to a {@link StorageItemChange.Record},\n-     *      which is something the storage adapter can handle.\n-     *   2. Notifying the observers of the outbox that there is a new\n-     *      {@link StorageItemChange} that needs to be processed.\n-     * @param storageItemChange Storage item change to be placed into the outbox\n-     * @param <MODEL> Any Java type that extends {@link Model}\n-     * @param <SIC> Any Java type that extends {@link StorageItemChange} with template param of MODEL\n-     * @return A Single that emits the StorageItemChange that was put into the outbox, if successful,\n-     *         or emits error, if not.\n+     *\n+     *   1. Writing a {@link PendingMutation} into a persistent store, by first converting it\n+     *      to and {@link PendingMutation.PersistentRecord}.\n+     *\n+     *   2. Notifying the observers of the outbox that there is a new {@link PendingMutation}\n+     *      that needs to be processed.\n+     *\n+     * @param pendingMutation A mutation to be enqueued into the outbox\n+     * @param <T> The type of model to which the mutation refers; e.g., if the PendingMutation\n+     *            is intending to create Person object, this type could be Person.\n+     * @return A Completable that emits success upon successful enqueue, or failure if it is not\n+     *         possible to enqueue the mutation\n      */\n     @NonNull\n-    <MODEL extends Model, SIC extends StorageItemChange<MODEL>> Single<SIC> enqueue(\n-            @NonNull SIC storageItemChange) {\n-        Objects.requireNonNull(storageItemChange);\n+    <T extends Model> Completable enqueue(@NonNull PendingMutation<T> pendingMutation) {\n+        Objects.requireNonNull(pendingMutation);\n \n-        // defer() the creation of a Single, until someone subscribes enqueue().\n-        // When they do, create() a single that wraps a save() call to LocalStorageAdapter.\n-        return Single.defer(() -> Single.create(subscriber -> {\n-            // Convert the storageItemChange (that we want to store) into a record\n-            StorageItemChange.Record record = storageItemChange.toRecord(storageItemChangeConverter);\n+        // defer() the creation of a Completable, until someone subscribes enqueue().\n+        // When they do, create() a Completable that wraps a save() call to LocalStorageAdapter.\n+        return Completable.defer(() -> Completable.create(subscriber -> {\n+            // Convert the PendingMutation (that we want to store) into a Record\n+            PendingMutation.PersistentRecord record = converter.toRecord(pendingMutation);\n             // Save it.\n-            localStorageAdapter.save(record, StorageItemChange.Initiator.SYNC_ENGINE,\n-                recordOfRecord -> {\n+            storage.save(record, StorageItemChange.Initiator.SYNC_ENGINE,\n+                saved -> {\n                     // The return value is a record that we saved a record.\n                     // So, we would have to \"unwrap\" it, to get the item we saved, out.\n                     // Forget that. We know the save succeeded, so just emit the\n                     // original thing enqueue() got as a param.\n-                    pendingStorageItemChanges.onNext(storageItemChange);\n-                    subscriber.onSuccess(storageItemChange);\n+                    LOG.info(\"Successfully enqueued \" + pendingMutation);\n+                    pendingMutations.onNext(pendingMutation);\n+                    subscriber.onComplete();\n                 },\n                 error -> {\n-                    pendingStorageItemChanges.onError(error);\n+                    pendingMutations.onError(error);\n                     subscriber.onError(error);\n                 }\n             );\n         }));\n     }\n \n     /**\n-     * Observe the {@link MutationOutbox}, for new {@link StorageItemChange}s.\n-     * The Orchestrator may invoke this method to consume items out of the outbox. After\n+     * Observe the {@link MutationOutbox}, for newly enqueued {@link PendingMutation}s.\n+     * The {@link SyncProcessor} may invoke this method to consume items out of the outbox. After\n      * processing an item on this observable, that item should be removed from the\n-     * MutationOutbox.\n+     * MutationOutbox via {@link #remove(PendingMutation)}.\n      * @return An observable stream of items that have yet to be published via the network\n      */\n     @WorkerThread\n     @NonNull\n-    Observable<StorageItemChange<? extends Model>> observe() {\n-        return pendingStorageItemChanges\n+    Observable<PendingMutation<? extends Model>> observe() {\n+        return pendingMutations\n             .observeOn(Schedulers.io())\n             .subscribeOn(Schedulers.io())\n-            .startWith(previouslyUnprocessedChanges())\n-            .filter(storageItemChange -> {\n-                return !StorageItemChange.Initiator.SYNC_ENGINE.equals(storageItemChange.initiator());\n-            });", "originalCommit": "efe40d343bb0f44122cdf09e86d4b3ecc7824f5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDg2Njk0Ng==", "url": "https://github.com/aws-amplify/amplify-android/pull/431#discussion_r420866946", "bodyText": "Yes!\nThe StorageObserver also filters the Initiator right now. So by the time a model gets here, it had dang-sure already have been.\nIt should be possible for user models (Blog) to have the the API Initiator type. But these system models are only ever created internally, so they all have this internal Initiator type.", "author": "jamesonwilliams", "createdAt": "2020-05-06T15:07:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDgxNTc5Nw=="}], "type": "inlineReview"}]}