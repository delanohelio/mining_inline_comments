{"pr_number": 274, "pr_title": "suppport HC detector in profile api", "pr_createdAt": "2020-10-19T07:26:13Z", "pr_url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/274", "timeline": [{"oid": "71e7eb3b7324b04b81c33ccc1c5ddefcdf2f1a2c", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/71e7eb3b7324b04b81c33ccc1c5ddefcdf2f1a2c", "message": "suppport HC detector in profile api", "committedDate": "2020-10-19T07:21:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzkyOTM0Mw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/274#discussion_r507929343", "bodyText": "extra comment.", "author": "yizheliu-amazon", "createdAt": "2020-10-19T17:32:10Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/AnomalyDetectorProfileRunner.java", "diffHunk": "@@ -140,19 +158,67 @@ private void prepareProfile(\n \n                     if (profilesToCollect.contains(ProfileName.ERROR)) {\n                         GetRequest getStateRequest = new GetRequest(DetectorInternalState.DETECTOR_STATE_INDEX, detectorId);\n-                        client.get(getStateRequest, onGetDetectorState(listener, detectorId, enabledTimeMs));\n+                        client.get(getStateRequest, onGetDetectorState(listener, detectorId, enabledTimeMs));// +1", "originalCommit": "71e7eb3b7324b04b81c33ccc1c5ddefcdf2f1a2c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzk0NTQyNg==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/274#discussion_r507945426", "bodyText": "Will remove this", "author": "ylwu-amzn", "createdAt": "2020-10-19T17:50:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzkyOTM0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzkzMDkwMg==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/274#discussion_r507930902", "bodyText": "I guess categoryField.get(0) will throw NPE if categoryField is null", "author": "yizheliu-amazon", "createdAt": "2020-10-19T17:34:50Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/AnomalyDetectorProfileRunner.java", "diffHunk": "@@ -173,6 +239,71 @@ private void prepareProfile(\n         }));\n     }\n \n+    /**\n+     * Get profile info of specific entity.\n+     *\n+     * @param detectorId detector identifier\n+     * @param entityValue entity value\n+     * @param listener action listener to handle exception and process entity profile response\n+     */\n+    public void profileEntity(String detectorId, String entityValue, ActionListener<EntityProfile> listener) {\n+        GetRequest getDetectorRequest = new GetRequest(ANOMALY_DETECTORS_INDEX, detectorId);\n+        client.get(getDetectorRequest, ActionListener.wrap(getResponse -> {\n+            if (getResponse != null && getResponse.isExists()) {\n+                try (\n+                    XContentParser parser = XContentType.JSON\n+                        .xContent()\n+                        .createParser(xContentRegistry, LoggingDeprecationHandler.INSTANCE, getResponse.getSourceAsString())\n+                ) {\n+                    ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+                    AnomalyDetector detector = AnomalyDetector.parse(parser, detectorId);\n+                    List<String> categoryField = detector.getCategoryField();\n+                    if (categoryField == null || categoryField.size() != 1) {\n+                        listener.onResponse(new EntityProfile(categoryField.get(0), entityValue, false));", "originalCommit": "71e7eb3b7324b04b81c33ccc1c5ddefcdf2f1a2c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzk0MTk1MQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/274#discussion_r507941951", "bodyText": "Good catch. will fix.", "author": "ylwu-amzn", "createdAt": "2020-10-19T17:46:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzkzMDkwMg=="}], "type": "inlineReview"}, {"oid": "94b258b3d1eb347bd6d6074caecc7954c930c191", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/94b258b3d1eb347bd6d6074caecc7954c930c191", "message": "address comments", "committedDate": "2020-10-19T20:04:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA3MzE1MQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/274#discussion_r508073151", "bodyText": "do we need also update this name for the FGAC changes? I remember we need have these names in the permission", "author": "weicongs-amazon", "createdAt": "2020-10-19T21:28:20Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/ProfileAction.java", "diffHunk": "@@ -23,7 +23,7 @@\n public class ProfileAction extends ActionType<ProfileResponse> {\n \n     public static final ProfileAction INSTANCE = new ProfileAction();\n-    public static final String NAME = \"cluster:admin/ad/detector/profile\";\n+    public static final String NAME = \"cluster:admin/opendistro/ad/detectors/profile\";", "originalCommit": "94b258b3d1eb347bd6d6074caecc7954c930c191", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE1Mzk1NA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/274#discussion_r508153954", "bodyText": "Good question. Sarat will address all transport action names later. External and internal transport name should follow different pattern. This action should be internal action.", "author": "ylwu-amzn", "createdAt": "2020-10-20T01:26:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA3MzE1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA3NDQxNQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/274#discussion_r508074415", "bodyText": "how about the false result? do we need handle it?", "author": "weicongs-amazon", "createdAt": "2020-10-19T21:30:55Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/util/MultiResponsesDelegateActionListener.java", "diffHunk": "@@ -111,4 +111,8 @@ public void failImmediately(String errMsg, Exception e) {\n     public void respondImmediately(T o) {\n         this.delegate.onResponse(o);\n     }\n+\n+    public void compareAndSetMaxResponseCount(int oldValue, int newValue) {\n+        this.maxResponseCount.compareAndSet(oldValue, newValue);", "originalCommit": "94b258b3d1eb347bd6d6074caecc7954c930c191", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE1NDIzMg==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/274#discussion_r508154232", "bodyText": "The client of this method need to take care of this.", "author": "ylwu-amzn", "createdAt": "2020-10-20T01:27:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA3NDQxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE4NDc3MQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/274#discussion_r508184771", "bodyText": "I dont think this will cause any big issue. but logically, should the result be returned to the client if they need take care of it?", "author": "weicongs-amazon", "createdAt": "2020-10-20T03:19:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA3NDQxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA3OTU3NQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/274#discussion_r508079575", "bodyText": "how is this detector index managed?  Are there one/multi indices for each detector? I have this question because i don't see detector id in the search request.", "author": "weicongs-amazon", "createdAt": "2020-10-19T21:42:04Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/AnomalyDetectorProfileRunner.java", "diffHunk": "@@ -173,6 +240,74 @@ private void prepareProfile(\n         }));\n     }\n \n+    /**\n+     * Get profile info of specific entity.\n+     *\n+     * @param detectorId detector identifier\n+     * @param entityValue entity value\n+     * @param listener action listener to handle exception and process entity profile response\n+     */\n+    public void profileEntity(String detectorId, String entityValue, ActionListener<EntityProfile> listener) {\n+        GetRequest getDetectorRequest = new GetRequest(ANOMALY_DETECTORS_INDEX, detectorId);\n+        client.get(getDetectorRequest, ActionListener.wrap(getResponse -> {\n+            if (getResponse != null && getResponse.isExists()) {\n+                try (\n+                    XContentParser parser = XContentType.JSON\n+                        .xContent()\n+                        .createParser(xContentRegistry, LoggingDeprecationHandler.INSTANCE, getResponse.getSourceAsString())\n+                ) {\n+                    ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+                    AnomalyDetector detector = AnomalyDetector.parse(parser, detectorId);\n+                    List<String> categoryField = detector.getCategoryField();\n+                    if (categoryField == null || categoryField.size() == 0) {\n+                        listener.onFailure(new InvalidParameterException(\"This is not a high cardinality detector\"));\n+                    } else if (categoryField.size() > CATEGORY_FIELD_LIMIT) {\n+                        listener\n+                            .onFailure(new InvalidParameterException(\"We don't support more category fields than \" + CATEGORY_FIELD_LIMIT));\n+                    } else {\n+                        EntityProfileRequest request = new EntityProfileRequest(detectorId, entityValue);\n+                        client\n+                            .execute(\n+                                EntityProfileAction.INSTANCE,\n+                                request,\n+                                ActionListener\n+                                    .wrap(\n+                                        r -> { listener.onResponse(new EntityProfile(categoryField.get(0), entityValue, r.isActive())); },\n+                                        e -> { listener.onFailure(e); }\n+                                    )\n+                            );\n+                    }\n+                } catch (Exception t) {\n+                    listener.onFailure(t);\n+                }\n+            } else {\n+                listener.onFailure(new InvalidParameterException(FAIL_TO_FIND_DETECTOR_MSG + detectorId));\n+            }\n+        }, exception -> { listener.onFailure(exception); }));\n+    }\n+\n+    private void profileEntityStats(MultiResponsesDelegateActionListener<DetectorProfile> listener, AnomalyDetector detector) {\n+        List<String> categoryField = detector.getCategoryField();\n+        if (categoryField == null || categoryField.size() != 1) {\n+            listener.onResponse(new DetectorProfile.Builder().build());\n+        } else {\n+            SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();\n+            CardinalityAggregationBuilder aggBuilder = new CardinalityAggregationBuilder(CommonName.TOTAL_ENTITIES);\n+            aggBuilder.field(categoryField.get(0));\n+            searchSourceBuilder.aggregation(aggBuilder);\n+\n+            SearchRequest request = new SearchRequest(detector.getIndices().toArray(new String[0]), searchSourceBuilder);", "originalCommit": "94b258b3d1eb347bd6d6074caecc7954c930c191", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA4MTYxMg==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/274#discussion_r508081612", "bodyText": "how about cache missing case?", "author": "weicongs-amazon", "createdAt": "2020-10-19T21:46:37Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/EntityProfileTransportAction.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad.transport;\n+\n+import java.io.IOException;\n+import java.util.Optional;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.HandledTransportAction;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportException;\n+import org.elasticsearch.transport.TransportRequestOptions;\n+import org.elasticsearch.transport.TransportResponseHandler;\n+import org.elasticsearch.transport.TransportService;\n+\n+import com.amazon.opendistroforelasticsearch.ad.caching.CacheProvider;\n+import com.amazon.opendistroforelasticsearch.ad.cluster.HashRing;\n+import com.amazon.opendistroforelasticsearch.ad.common.exception.AnomalyDetectionException;\n+import com.amazon.opendistroforelasticsearch.ad.ml.ModelManager;\n+import com.amazon.opendistroforelasticsearch.ad.ml.ModelPartitioner;\n+import com.amazon.opendistroforelasticsearch.ad.settings.AnomalyDetectorSettings;\n+\n+/**\n+ * Transport action to get entity profile.\n+ */\n+public class EntityProfileTransportAction extends HandledTransportAction<EntityProfileRequest, EntityProfileResponse> {\n+\n+    private static final Logger LOG = LogManager.getLogger(EntityProfileTransportAction.class);\n+    public static final String NO_NODE_FOUND_MSG = \"Cannot find model hosting node\";\n+    static final String FAIL_TO_GET_ENTITY_PROFILE_MSG = \"Cannot get entity profile info\";\n+\n+    private final TransportService transportService;\n+    private final ModelManager modelManager;\n+    private final ModelPartitioner modelPartitioner;\n+    private final HashRing hashRing;\n+    private final TransportRequestOptions option;\n+    private final ClusterService clusterService;\n+    private final CacheProvider cacheProvider;\n+\n+    @Inject\n+    public EntityProfileTransportAction(\n+        ActionFilters actionFilters,\n+        TransportService transportService,\n+        Settings settings,\n+        ModelManager modelManager,\n+        ModelPartitioner modelPartitioner,\n+        HashRing hashRing,\n+        ClusterService clusterService,\n+        CacheProvider cacheProvider\n+    ) {\n+        super(EntityProfileAction.NAME, transportService, actionFilters, EntityProfileRequest::new);\n+        this.transportService = transportService;\n+        this.modelManager = modelManager;\n+        this.modelPartitioner = modelPartitioner;\n+        this.hashRing = hashRing;\n+        this.option = TransportRequestOptions\n+            .builder()\n+            .withType(TransportRequestOptions.Type.REG)\n+            .withTimeout(AnomalyDetectorSettings.REQUEST_TIMEOUT.get(settings))\n+            .build();\n+        this.clusterService = clusterService;\n+        this.cacheProvider = cacheProvider;\n+    }\n+\n+    @Override\n+    protected void doExecute(Task task, EntityProfileRequest request, ActionListener<EntityProfileResponse> listener) {\n+\n+        String adID = request.getAdID();\n+        String entityValue = request.getEntityValue();\n+        String modelId = modelManager.getEntityModelId(adID, entityValue);\n+        Optional<DiscoveryNode> node = hashRing.getOwningNode(modelId);\n+        if (!node.isPresent()) {\n+            listener.onFailure(new AnomalyDetectionException(adID, NO_NODE_FOUND_MSG));\n+            return;\n+        }\n+\n+        String nodeId = node.get().getId();\n+        DiscoveryNode localNode = clusterService.localNode();\n+        if (localNode.getId().equals(nodeId)) {\n+            listener.onResponse(new EntityProfileResponse((cacheProvider.get().isActive(adID, modelId))));", "originalCommit": "94b258b3d1eb347bd6d6074caecc7954c930c191", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}