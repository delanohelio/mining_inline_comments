{"pr_number": 164, "pr_title": "Adds initialization progress to profile API", "pr_createdAt": "2020-06-19T21:11:53Z", "pr_url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164", "timeline": [{"oid": "5f353a6665045b0c9bc75c31e00b356cbbf40bdd", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/5f353a6665045b0c9bc75c31e00b356cbbf40bdd", "message": "Adds initialization progress to profile API\n\nThis PR adds init_progress to profile API. init_progress helps users track initialization percentage, needed shingles, and estimated time to go if the future data stream is continuous (no missing data).\n\nInitialization percentage measures how far away we can observe RCF models emitting scores.\u00a0 The implementation fetches the RCF model's total updates while the AD job is running and materializes the value to the newly added index .opendistro-anomaly-info. Total updates record the number of times this RCF model has been updated.\u00a0\n\nInitialization percent is computed as x/128:\u00a0\n* if total updates > 128, x = 128. Otherwise, x is the total updates\u00a0\n* 128 is our output after the number in RCF. After observing 128 samples, RCF starts emitting scores.\n\nNeeded shingles are computed as 128 -x.\u00a0 Estimated minutes to go is computed as needed shingles * detector interval\n\nThis PR also materializes the error message in the most recent run to speed up profile API's error fetching.\n\nDuring each AD execution, we also check if a checkpoint is there (the result is saved and maintained as other AD states), if yes, we cold start immediately.\n\nTesting done:\n1. adds unit tests\n2. run e2e tests to verify init_progress number makes sense.", "committedDate": "2020-06-22T16:14:18Z", "type": "forcePushed"}, {"oid": "e33265c74543911afd775e26607a3b3b3563939b", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/e33265c74543911afd775e26607a3b3b3563939b", "message": "Adds initialization progress to profile API\n\nThis PR adds init_progress to profile API. init_progress helps users track initialization percentage, needed shingles, and estimated time to go if the future data stream is continuous (no missing data).\n\nInitialization percentage measures how far away we can observe RCF models emitting scores.\u00a0 The implementation fetches the RCF model's total updates while the AD job is running and materializes the value to the newly added index .opendistro-anomaly-info. Total updates record the number of times this RCF model has been updated.\u00a0\n\nInitialization percent is computed as x/128:\u00a0\n* if total updates > 128, x = 128. Otherwise, x is the total updates\u00a0\n* 128 is our output after the number in RCF. After observing 128 samples, RCF starts emitting scores.\n\nNeeded shingles are computed as 128 -x.\u00a0 Estimated minutes to go is computed as needed shingles * detector interval\n\nThis PR also materializes the error message in the most recent run to speed up profile API's error fetching.\n\nDuring each AD execution, we also check if a checkpoint is there (the result is saved and maintained as other AD states), if yes, we cold start immediately.\n\nTesting done:\n1. adds unit tests\n2. run e2e tests to verify init_progress number makes sense.", "committedDate": "2020-06-25T00:39:42Z", "type": "forcePushed"}, {"oid": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/429b2e4cfe340f6c7389efdfa83f2c67309c4cfd", "message": "Adds initialization progress to profile API\n\nThis PR adds init_progress to profile API. init_progress helps users track initialization percentage, needed shingles, and estimated time to go if the future data stream is continuous (no missing data).\n\nInitialization percentage measures how far away we can observe RCF models emitting scores.\u00a0 The implementation fetches the RCF model's total updates while the AD job is running and materializes the value to the newly added index .opendistro-anomaly-info. Total updates record the number of times this RCF model has been updated.\u00a0\n\nInitialization percent is computed as x/128:\u00a0\n* if total updates > 128, x = 128. Otherwise, x is the total updates\u00a0\n* 128 is our output after the number in RCF. After observing 128 samples, RCF starts emitting scores.\n\nNeeded shingles are computed as 128 -x.\u00a0 Estimated minutes to go is computed as needed shingles * detector interval\n\nThis PR also materializes the error message in the most recent run to speed up profile API's error fetching.\n\nDuring each AD execution, we also check if a checkpoint is there (the result is saved and maintained as other AD states), if yes, we cold start immediately.\n\nTesting done:\n1. adds unit tests\n2. run e2e tests to verify init_progress number makes sense.", "committedDate": "2020-06-26T16:11:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjM5MDAwOQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r446390009", "bodyText": "remark. the issue of checked exception is clear here. they bubble up from low levels and raise unhelpful concerns/threats to higher-level in the chain, which, in this case, choose to expose unnecessary implementation.\nwhen there is an unlikely checked exception due to lower-level implementation and the caller is unlikely to act or recover, it's likely a good place to wrap the checked exceptions early on.", "author": "wnbts", "createdAt": "2020-06-26T20:16:08Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/indices/AnomalyDetectionIndices.java", "diffHunk": "@@ -229,6 +251,18 @@ public void initAnomalyDetectorJobIndex(ActionListener<CreateIndexResponse> acti\n         adminClient.indices().create(request, actionListener);\n     }\n \n+    /**\n+     * Create an index.\n+     *\n+     * @param actionListener action called after create index\n+     * @throws IOException IOException from {@link AnomalyDetectionIndices#getAnomalyDetectorJobMappings}", "originalCommit": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzE4OTkwOA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447189908", "bodyText": "I did it. See ThrowingConsumerWrapper.throwingConsumerWrapper.", "author": "kaituo", "createdAt": "2020-06-29T19:05:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjM5MDAwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjM5ODk4MA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r446398980", "bodyText": "issue. what happens to a completed but not hosted model (maybe after detector is stopped)?", "author": "wnbts", "createdAt": "2020-06-26T20:38:35Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/ml/ModelManager.java", "diffHunk": "@@ -1039,4 +1039,18 @@ private double computeRcfConfidence(RandomCutForest forest) {\n             .forEach(entry -> { res.put(entry.getKey(), 0L); });\n         return res;\n     }\n+\n+    /**\n+      * Get all RCF partition's size corresponding to a detector.  Thresholding\n+      *  models' size is a constant since they are small in size (KB).\n+      * @param modelId model id\n+      */\n+    public long getTotalUpdates(String modelId) {\n+        ModelState<RandomCutForest> model = forests.get(modelId);", "originalCommit": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzE5MTM1Ng==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447191356", "bodyText": "We return 0 in this case.  Any other better way?", "author": "kaituo", "createdAt": "2020-06-29T19:07:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjM5ODk4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM1NTExNw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447355117", "bodyText": "the code should load the checkpoint and return its count.", "author": "wnbts", "createdAt": "2020-06-30T01:33:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjM5ODk4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg5Nzc3Mg==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447897772", "bodyText": "make sense", "author": "kaituo", "createdAt": "2020-06-30T18:35:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjM5ODk4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk1ODEwNg==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447958106", "bodyText": "I think we only show progress bar when detector started. Once detector starts, will restore model from checkpoint. Then we can read updates from hosted model. Should we pull the checkpoint again?", "author": "ylwu-amzn", "createdAt": "2020-06-30T20:26:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjM5ODk4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk5MzAzNQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447993035", "bodyText": "we pull checkpoint when we cannot get updates from hosted models.  We may not do this if use the state index.", "author": "kaituo", "createdAt": "2020-06-30T21:35:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjM5ODk4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODEwMzA4MQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r448103081", "bodyText": "Should we show progress before restoring model? For example, one detector has 10 minutes interval, when restart detector, we show progress 80% directly as we pull checkpoint (or state index)? Is it possible we fail to restore model and the progress still show as 80%?\nHow about we simplify it to just read progress (updates) from hosted model. If no hosted model, we show 0%.", "author": "ylwu-amzn", "createdAt": "2020-07-01T04:06:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjM5ODk4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ4OTYwNA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r448489604", "bodyText": "What you said is possible. We need to pull checkpoint when shingle is not ready and model is in memory yet.  Sometimes this process is long, sometimes is short.  This is a tradeoff between code simplicity (maintenance/testability/memory cost) vs accuracy.  What you suggested is what I did one week ago.  Now I changed my code to more complex and more accurate side.  There is no absolute right or wrong.  Let's stick to current complex solution.", "author": "kaituo", "createdAt": "2020-07-01T16:44:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjM5ODk4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM2NDQ5NQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r450364495", "bodyText": "I thought about it during the vacation.  I plan to use messaging + checkpoint polling, and remove rcf updates on state index.  Lai's suggested \"so when the count is above 128, the handler just returns it without doing anything extra\".  Messaging + checkpoint polling is equally efficient with getting document from an index, if not faster.  And we save the trouble of maintaining another field on the state index.  Let me know if you guys think differently.", "author": "kaituo", "createdAt": "2020-07-06T17:10:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjM5ODk4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQwMDI2Ng==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r446400266", "bodyText": "minor. unneeded annotation.", "author": "wnbts", "createdAt": "2020-06-26T20:41:49Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/model/InitProgressProfile.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad.model;\n+\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+import java.io.IOException;\n+\n+import org.apache.commons.lang.builder.EqualsBuilder;\n+import org.apache.commons.lang.builder.HashCodeBuilder;\n+import org.apache.commons.lang.builder.ToStringBuilder;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+\n+/**\n+ * Profile output for detector initialization progress.  When the new detector is created, it is possible that\n+ * there hasn\u2019t been enough continuous data in the index.  We need to use live data to initialize.\n+ *   During initialization, we need to tell users progress (using a percentage), how many more\n+ *    shingles to go, and approximately how many minutes before the detector becomes operational\n+ *     if they keep their data stream continuous.\n+ * @author kaituo", "originalCommit": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzE5Mjk1OA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447192958", "bodyText": "removed", "author": "kaituo", "createdAt": "2020-06-29T19:11:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQwMDI2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQwMDQwMg==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r446400402", "bodyText": "minor. indentation is off.", "author": "wnbts", "createdAt": "2020-06-26T20:42:08Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/model/InitProgressProfile.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad.model;\n+\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+import java.io.IOException;\n+\n+import org.apache.commons.lang.builder.EqualsBuilder;\n+import org.apache.commons.lang.builder.HashCodeBuilder;\n+import org.apache.commons.lang.builder.ToStringBuilder;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+\n+/**\n+ * Profile output for detector initialization progress.  When the new detector is created, it is possible that\n+ * there hasn\u2019t been enough continuous data in the index.  We need to use live data to initialize.\n+ *   During initialization, we need to tell users progress (using a percentage), how many more\n+ *    shingles to go, and approximately how many minutes before the detector becomes operational\n+ *     if they keep their data stream continuous.", "originalCommit": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzE5MjkwMw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447192903", "bodyText": "fixed.", "author": "kaituo", "createdAt": "2020-06-29T19:10:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQwMDQwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQzOTIxNA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r446439214", "bodyText": "minor. the comments do not apply to the method.", "author": "wnbts", "createdAt": "2020-06-26T22:36:36Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/ml/ModelManager.java", "diffHunk": "@@ -1039,4 +1039,18 @@ private double computeRcfConfidence(RandomCutForest forest) {\n             .forEach(entry -> { res.put(entry.getKey(), 0L); });\n         return res;\n     }\n+\n+    /**\n+      * Get all RCF partition's size corresponding to a detector.  Thresholding\n+      *  models' size is a constant since they are small in size (KB).", "originalCommit": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzE5MDk4Nw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447190987", "bodyText": "good catch. Fixed.", "author": "kaituo", "createdAt": "2020-06-29T19:07:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQzOTIxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk1NjI0Mg==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447956242", "bodyText": "good catch. Fixed.\n\nSeems new revision not published yet?", "author": "ylwu-amzn", "createdAt": "2020-06-30T20:22:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQzOTIxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk5NDYzNg==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447994636", "bodyText": "yeah, I am waiting to reach an agreement with Lai: whether to use index state or transport + checkpoint pull.  I am ok with both.", "author": "kaituo", "createdAt": "2020-06-30T21:39:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQzOTIxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ1MjUyMw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r446452523", "bodyText": "this case should error out.", "author": "wnbts", "createdAt": "2020-06-26T23:38:55Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/model/DetectorInternalState.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad.model;\n+\n+import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+\n+import com.amazon.opendistroforelasticsearch.ad.annotation.Generated;\n+import com.amazon.opendistroforelasticsearch.ad.util.ParseUtils;\n+import com.google.common.base.Objects;\n+\n+/**\n+ * Include anomaly detector's state\n+ */\n+public class DetectorInternalState implements ToXContentObject, Cloneable {\n+\n+    public static final String PARSE_FIELD_NAME = \"DetectorInternalState\";\n+    public static final NamedXContentRegistry.Entry XCONTENT_REGISTRY = new NamedXContentRegistry.Entry(\n+        DetectorInternalState.class,\n+        new ParseField(PARSE_FIELD_NAME),\n+        it -> parse(it)\n+    );\n+\n+    public static final String DETECTOR_STATE_INDEX = \".opendistro-anomaly-state\";\n+\n+    public static final String RCF_UPDATES_FIELD = \"rcf_updates\";\n+    public static final String LAST_UPDATE_TIME_FIELD = \"last_update_time\";\n+    public static final String ERROR_FIELD = \"error\";\n+\n+    private long rcfUpdates = -1L;\n+    private Instant lastUpdateTime = null;\n+    private String error = null;\n+\n+    private DetectorInternalState() {}\n+\n+    public static class Builder {\n+        private long rcfUpdates = -1;\n+        private Instant lastUpdateTime = null;\n+        private String error = null;\n+\n+        public Builder() {}\n+\n+        public Builder rcfUpdates(long rcfUpdates) {\n+            this.rcfUpdates = rcfUpdates;\n+            return this;\n+        }\n+\n+        public Builder lastUpdateTime(Instant lastUpdateTime) {\n+            this.lastUpdateTime = lastUpdateTime;\n+            return this;\n+        }\n+\n+        public Builder error(String error) {\n+            this.error = error;\n+            return this;\n+        }\n+\n+        public DetectorInternalState build() {\n+            DetectorInternalState state = new DetectorInternalState();\n+            state.rcfUpdates = this.rcfUpdates;\n+            state.lastUpdateTime = this.lastUpdateTime;\n+            state.error = this.error;\n+\n+            return state;\n+        }\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        XContentBuilder xContentBuilder = builder.startObject();\n+\n+        if (rcfUpdates >= 0) {\n+            xContentBuilder.field(RCF_UPDATES_FIELD, rcfUpdates);\n+        }\n+        if (lastUpdateTime != null) {\n+            xContentBuilder.field(LAST_UPDATE_TIME_FIELD, lastUpdateTime.toEpochMilli());\n+        }\n+        if (error != null) {\n+            xContentBuilder.field(ERROR_FIELD, error);\n+        }\n+        return xContentBuilder.endObject();\n+    }\n+\n+    public static DetectorInternalState parse(XContentParser parser) throws IOException {\n+        long rcfUpdates = -1L;\n+        Instant lastUpdateTime = null;\n+        String error = null;\n+\n+        ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.currentToken(), parser::getTokenLocation);\n+        while (parser.nextToken() != XContentParser.Token.END_OBJECT) {\n+            String fieldName = parser.currentName();\n+            parser.nextToken();\n+\n+            switch (fieldName) {\n+                case RCF_UPDATES_FIELD:\n+                    rcfUpdates = parser.longValue();\n+                    break;\n+                case LAST_UPDATE_TIME_FIELD:\n+                    lastUpdateTime = ParseUtils.toInstant(parser);\n+                    break;\n+                case ERROR_FIELD:\n+                    error = parser.text();\n+                    break;\n+                default:\n+                    parser.skipChildren();\n+                    break;\n+            }\n+        }\n+        return new DetectorInternalState.Builder().rcfUpdates(rcfUpdates).lastUpdateTime(lastUpdateTime).error(error).build();\n+    }\n+\n+    @Generated\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o)\n+            return true;\n+        if (o == null || getClass() != o.getClass())\n+            return false;\n+        DetectorInternalState that = (DetectorInternalState) o;\n+        return Objects.equal(getRcfUpdates(), that.getRcfUpdates())\n+            && Objects.equal(getLastUpdateTime(), that.getLastUpdateTime())\n+            && Objects.equal(getError(), that.getError());\n+    }\n+\n+    @Generated\n+    @Override\n+    public int hashCode() {\n+        return Objects.hashCode(rcfUpdates, lastUpdateTime, error);\n+    }\n+\n+    @Override\n+    public Object clone() {\n+        DetectorInternalState state = null;\n+        try {\n+            state = (DetectorInternalState) super.clone();\n+        } catch (CloneNotSupportedException e) {\n+            state = new DetectorInternalState.Builder().rcfUpdates(rcfUpdates).lastUpdateTime(lastUpdateTime).error(error).build();", "originalCommit": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzE5MjU4MQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447192581", "bodyText": "fixed", "author": "kaituo", "createdAt": "2020-06-29T19:10:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ1MjUyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ1NDA2OQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r446454069", "bodyText": "are these maps all keyed by the same detector ids?", "author": "wnbts", "createdAt": "2020-06-26T23:47:57Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/ADStateManager.java", "diffHunk": "@@ -52,6 +53,7 @@\n     private static final Logger LOG = LogManager.getLogger(ADStateManager.class);\n     private ConcurrentHashMap<String, Entry<AnomalyDetector, Instant>> currentDetectors;\n     private ConcurrentHashMap<String, Entry<Integer, Instant>> partitionNumber;\n+    private ConcurrentHashMap<String, Instant> currentCheckpoints;", "originalCommit": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzE5NDA4OQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447194089", "bodyText": "Could you explain your question?\nThis is for starting cold start whenever there is missing checkpoint.  The key is detector id, while the value is the timestamp when we find a checkpoint.", "author": "kaituo", "createdAt": "2020-06-29T19:13:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ1NDA2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM1NTQ2NA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447355464", "bodyText": "there are three maps, if their keys are detector ids, they can be merged into one map sharing the same keys.", "author": "wnbts", "createdAt": "2020-06-30T01:34:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ1NDA2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg5ODE0Mw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447898143", "bodyText": "How do I merge it?  Their values are different.", "author": "kaituo", "createdAt": "2020-06-30T18:35:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ1NDA2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3MDA1MA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447970050", "bodyText": "a manager should manage a set of assigned detectors so for an assigned detector id, there should be one key-vale pair of detector id, run state. the various parts can be put together into one structure rather than requiring separate key-value pairs for each field.", "author": "wnbts", "createdAt": "2020-06-30T20:49:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ1NDA2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3NjY0Nw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447976647", "bodyText": "will create a class ADState then.", "author": "kaituo", "createdAt": "2020-06-30T21:01:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ1NDA2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ1NDcxMg==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r446454712", "bodyText": "doc for this method is missing.", "author": "wnbts", "createdAt": "2020-06-26T23:51:07Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/ADStateManager.java", "diffHunk": "@@ -140,6 +143,30 @@ public void getAnomalyDetector(String adID, ActionListener<Optional<AnomalyDetec\n         }, listener::onFailure);\n     }\n \n+    public void getDetectorCheckpoint(String adID, ActionListener<Boolean> listener) {", "originalCommit": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzE5NTI1Nw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447195257", "bodyText": "doc is deprecated.  We should remove doc in checkpointdao.  Do you want me to do that?", "author": "kaituo", "createdAt": "2020-06-29T19:15:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ1NDcxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM1NjQyOA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447356428", "bodyText": "i mean the doc for this getDetectorCheckpoint method is missing. a client/reader cannot know what this method does without reading through code.", "author": "wnbts", "createdAt": "2020-06-30T01:37:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ1NDcxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkwMjM4Nw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447902387", "bodyText": "added doc", "author": "kaituo", "createdAt": "2020-06-30T18:43:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ1NDcxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ1NDk0Nw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r446454947", "bodyText": "minor. this method should be private", "author": "wnbts", "createdAt": "2020-06-26T23:52:48Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/ADStateManager.java", "diffHunk": "@@ -176,6 +205,27 @@ public void maintenance() {\n         });\n     }\n \n+    /**\n+     * Clean states if it is older than our stateTtl. The input has to be a\n+     * ConcurrentHashMap otherwise we will have\n+     * java.util.ConcurrentModificationException.\n+     *\n+     * @param flags flags to be maintained\n+     */\n+    void maintenanceFlag(ConcurrentHashMap<String, Instant> flags) {", "originalCommit": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzE5NTUxMA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447195510", "bodyText": "I wrote unit tests for it.  That's why I am not using private.", "author": "kaituo", "createdAt": "2020-06-29T19:15:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ1NDk0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM1Njc3NQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447356775", "bodyText": "try to avoid a. leaking implementation in class interface. and b. build brittle implementation-based tests.", "author": "wnbts", "createdAt": "2020-06-30T01:39:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ1NDk0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkwMzI3MA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447903270", "bodyText": "duly noted.  Having package private for tests is not uncommon.  People invented @VisibleForTesting annotation for that.", "author": "kaituo", "createdAt": "2020-06-30T18:44:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ1NDk0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3MDc1OA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447970758", "bodyText": "that's better left for legacy code. for new code, it's better not to start with it.", "author": "wnbts", "createdAt": "2020-06-30T20:50:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ1NDk0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ1NTkxNw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r446455917", "bodyText": "in other cases, such as when feature is present but actions fail due to other reasons than no model, will model training process begin?", "author": "wnbts", "createdAt": "2020-06-26T23:58:54Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "diffHunk": "@@ -287,6 +291,20 @@ protected void doExecute(Task task, ActionRequest actionRequest, ActionListener<\n             }\n \n             if (!featureOptional.getProcessedFeatures().isPresent()) {", "originalCommit": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzIwMDA3OQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447200079", "bodyText": "other reasons could be: circuit breaker is open, cluster is under read/write block, or AD is disabled.  We should not trigger cold start in those cases.", "author": "kaituo", "createdAt": "2020-06-29T19:24:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ1NTkxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM1NzU5OQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447357599", "bodyText": "ok. it might be good to explicitly put in code the conditions where cold start is suppressed so that no one needs to guess why initialization is not done", "author": "wnbts", "createdAt": "2020-06-30T01:41:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ1NTkxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkwNDYzMA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447904630", "bodyText": "added doc", "author": "kaituo", "createdAt": "2020-06-30T18:47:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ1NTkxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ1ODgwNA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r446458804", "bodyText": "remark. if only checked exceptions are not allowed to bubble up in the first place", "author": "wnbts", "createdAt": "2020-06-27T00:17:08Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/util/ThrowingConsumerWrapper.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad.util;\n+\n+import java.util.function.Consumer;\n+\n+public class ThrowingConsumerWrapper {\n+    /**\n+     * Utility method to use a method throwing checked exception inside a function", "originalCommit": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzIwMTEwNw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447201107", "bodyText": "Could you explain your remark?", "author": "kaituo", "createdAt": "2020-06-29T19:26:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ1ODgwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM1ODAxMg==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447358012", "bodyText": "if underlying low-level code doesn't threaten with checked exceptions, this wouldn't be necessary, right?", "author": "wnbts", "createdAt": "2020-06-30T01:43:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ1ODgwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkwNTA5NQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447905095", "bodyText": "yes", "author": "kaituo", "createdAt": "2020-06-30T18:47:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ1ODgwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2MDIzMA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r446460230", "bodyText": "if rcf has 256 updates, updates on this field are no longer necessary so unnecessary document updates can be skipped. it'd be an unnecessary workload for most data points.", "author": "wnbts", "createdAt": "2020-06-27T00:26:43Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/handler/DetectorStateHandler.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad.transport.handler;\n+\n+import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.function.BooleanSupplier;\n+import java.util.function.Consumer;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.indices.create.CreateIndexResponse;\n+import org.elasticsearch.action.get.GetRequest;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.LoggingDeprecationHandler;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import com.amazon.opendistroforelasticsearch.ad.model.DetectorInternalState;\n+import com.amazon.opendistroforelasticsearch.ad.util.ClientUtil;\n+import com.amazon.opendistroforelasticsearch.ad.util.IndexUtils;\n+\n+public class DetectorStateHandler extends AnomalyIndexHandler<DetectorInternalState> {\n+    interface GetStateStrategy {\n+        DetectorInternalState createNewState(DetectorInternalState state);\n+    }\n+\n+    class TotalRcfUpdatesStrategy implements GetStateStrategy {\n+        private long totalRcfUpdates;\n+\n+        TotalRcfUpdatesStrategy(long totalRcfUpdates) {\n+            this.totalRcfUpdates = totalRcfUpdates;\n+        }\n+\n+        @Override\n+        public DetectorInternalState createNewState(DetectorInternalState state) {\n+            DetectorInternalState newState = null;\n+            if (state == null) {\n+                newState = new DetectorInternalState.Builder().rcfUpdates(totalRcfUpdates).lastUpdateTime(Instant.now()).build();\n+            } else {\n+                newState = (DetectorInternalState) state.clone();\n+                newState.setRcfUpdates(totalRcfUpdates);\n+                newState.setLastUpdateTime(Instant.now());\n+            }\n+            return newState;\n+        }\n+    }\n+\n+    class ErrorStrategy implements GetStateStrategy {\n+        private String error;\n+\n+        ErrorStrategy(String error) {\n+            this.error = error;\n+        }\n+\n+        @Override\n+        public DetectorInternalState createNewState(DetectorInternalState state) {\n+            DetectorInternalState newState = null;\n+            if (state == null) {\n+                newState = new DetectorInternalState.Builder().error(error).lastUpdateTime(Instant.now()).build();\n+            } else {\n+                newState = (DetectorInternalState) state.clone();\n+                newState.setError(error);\n+                newState.setLastUpdateTime(Instant.now());\n+            }\n+\n+            return newState;\n+        }\n+    }\n+\n+    private static final Logger LOG = LogManager.getLogger(DetectorStateHandler.class);\n+\n+    public DetectorStateHandler(\n+        Client client,\n+        Settings settings,\n+        ThreadPool threadPool,\n+        Consumer<ActionListener<CreateIndexResponse>> createIndex,\n+        BooleanSupplier indexExists,\n+        ClientUtil clientUtil,\n+        IndexUtils indexUtils,\n+        ClusterService clusterService\n+    ) {\n+        super(\n+            client,\n+            settings,\n+            threadPool,\n+            DetectorInternalState.DETECTOR_STATE_INDEX,\n+            createIndex,\n+            indexExists,\n+            true,\n+            clientUtil,\n+            indexUtils,\n+            clusterService\n+        );\n+    }\n+\n+    public void saveRcfUpdates(long totalRcfUpdates, String detectorId) {", "originalCommit": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzIwMDY3Ng==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447200676", "bodyText": "make sense.  I'll modify when you answered my previous question on whether to continue to use on-demand messaging.  Also, we should use 128, right?", "author": "kaituo", "createdAt": "2020-06-29T19:25:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2MDIzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM1ODE1MA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447358150", "bodyText": "128 is the current number", "author": "wnbts", "createdAt": "2020-06-30T01:43:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2MDIzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2MTU0Nw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r446461547", "bodyText": "is it desirable to update state for every result? doubling the indexing workload\none idea for consideration is to cache the state and only update when there is valuable updates such as model updates before 256, latest error if any.", "author": "wnbts", "createdAt": "2020-06-27T00:35:06Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/AnomalyDetectorJobRunner.java", "diffHunk": "@@ -436,7 +442,8 @@ private void indexAnomalyResult(\n                 Instant.now(),\n                 response.getError()\n             );\n-            anomalyResultHandler.indexAnomalyResult(anomalyResult);\n+            anomalyResultHandler.index(anomalyResult, detectorId);\n+            detectorStateHandler.saveError(response.getError(), detectorId);", "originalCommit": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzE3MDIyMw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447170223", "bodyText": "This is for saving error, not init progress.  We have to call profile API for a detector's error.  Consider dashboard and detector list page, that's a lot of calls for one refresh.  Previously, we search for anomaly result index for each detector's error.  This can cause performance problem, especially after I increased the size of result index.  See #117 for details. Here I materialize the error so we don't need to search.\nCaching error for valuable update does not work as we don't know which error is valuable and when kibana would query for it. So it is desirable to update error for every result.\nAre you saying we should index total rcf updates less than 128?  If so, we don't need messaging you suggested before, right?", "author": "kaituo", "createdAt": "2020-06-29T18:30:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2MTU0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM2MDAxNQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447360015", "bodyText": "same idea applies to error and count, a write only happens if there is an update to the read. if the error is null/the same, it is not needed to update.\nregarding the last question, i suggest writes (due to the count field) only happen when the count is below 128 and new count is different (larger) than the old count. Messaging is one way to obtain the current count but i think loading the checkpoint locally to get the persisted count also suffices.", "author": "wnbts", "createdAt": "2020-06-30T01:50:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2MTU0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkwODEyNQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447908125", "bodyText": "Error needs to be up-to-date.  When a profile request comes in, it won't know this error is up-to-date or not unless the writer side guarantees it.  For example, if there is no error, a profile API's request comes in to ask for error, we would return an error instead of null if we only record non-null error.\nAbout the in-progress number, how about the we always depending on on-demand messaging.  If there is rcf model in memory, we ask for it.  Otherwise, we ask for checkpoint.  We can remove index write for rcf updates.", "author": "kaituo", "createdAt": "2020-06-30T18:52:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2MTU0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3NjMxNA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447976314", "bodyText": "regarding error, the main idea is to update only when it's changed. for example, error to null/non-error, null to error, or error 1 to error 2. if it's null to null, error 1 to error 1, no update is needed.\nfor in-progress number, i would like to see the info is obtained on demand to make sure it's current. two ramifications. first, if the state (count >= 128) is final, a query to index should be better than a transport + a checkpoint pull from index. second, if progress doesn't depend on index, does error alone justify index?", "author": "wnbts", "createdAt": "2020-06-30T21:00:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2MTU0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk4NDU4OQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447984589", "bodyText": "Updating error when it is changed works.  Will change.\nabout your ramifications:\n\nif we update when it is less than 128, why do we still need a transport + a checkpoint pull?\nyes, Yaliang and folks will add things there as needed.", "author": "kaituo", "createdAt": "2020-06-30T21:17:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2MTU0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAyMjg0Nw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r448022847", "bodyText": "when the count in the previously saved state is in [0, 128), in order to get the current count to a. return in response and b. update state with, there is two ways: 1. transport + checkpoint or 2. just checkpoint. (either is ok to me, latter is simpler, more reliable but slower to change, hourly or so).\n\nwhen the count in the saved state is no less than 128, it is returned in response and done. transport or checkpoint query is no longer needed.", "author": "wnbts", "createdAt": "2020-06-30T22:52:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2MTU0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk0NDU2NQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447944565", "bodyText": "minor, can we rename anomalyResultHandler  as anomalyIndexHandler?", "author": "ylwu-amzn", "createdAt": "2020-06-30T20:00:08Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/AnomalyDetectorPlugin.java", "diffHunk": "@@ -170,28 +175,34 @@ public AnomalyDetectorPlugin() {}\n         IndexNameExpressionResolver indexNameExpressionResolver,\n         Supplier<DiscoveryNodes> nodesInCluster\n     ) {\n-        AnomalyResultHandler anomalyResultHandler = new AnomalyResultHandler(\n+\n+        AnomalyIndexHandler<AnomalyResult> anomalyResultHandler;", "originalCommit": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk1NTczNg==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447955736", "bodyText": "anomalyResultHandler seems more appropriate than anomalyIndexHandler since this handler is for anomaly result.", "author": "kaituo", "createdAt": "2020-06-30T20:21:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk0NDU2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAwMDg4NA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r448000884", "bodyText": "How about we name the class as AnomalyResultHandler if it's for anomaly result only?", "author": "ylwu-amzn", "createdAt": "2020-06-30T21:53:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk0NDU2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1MjYwMg==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r448052602", "bodyText": "The class can be inherited by other classes writing to a different index.  We shouldn't do that.", "author": "kaituo", "createdAt": "2020-07-01T00:34:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk0NDU2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk1MDc4OA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447950788", "bodyText": "How about change to .opendistro-anomaly-detection-state?", "author": "ylwu-amzn", "createdAt": "2020-06-30T20:11:53Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/model/DetectorInternalState.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad.model;\n+\n+import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+\n+import com.amazon.opendistroforelasticsearch.ad.annotation.Generated;\n+import com.amazon.opendistroforelasticsearch.ad.util.ParseUtils;\n+import com.google.common.base.Objects;\n+\n+/**\n+ * Include anomaly detector's state\n+ */\n+public class DetectorInternalState implements ToXContentObject, Cloneable {\n+\n+    public static final String PARSE_FIELD_NAME = \"DetectorInternalState\";\n+    public static final NamedXContentRegistry.Entry XCONTENT_REGISTRY = new NamedXContentRegistry.Entry(\n+        DetectorInternalState.class,\n+        new ParseField(PARSE_FIELD_NAME),\n+        it -> parse(it)\n+    );\n+\n+    public static final String DETECTOR_STATE_INDEX = \".opendistro-anomaly-state\";", "originalCommit": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk1Nzg3Ng==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447957876", "bodyText": "changed", "author": "kaituo", "createdAt": "2020-06-30T20:25:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk1MDc4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk1MTgyMw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447951823", "bodyText": "Any special consideration for using -1 as default value?", "author": "ylwu-amzn", "createdAt": "2020-06-30T20:14:07Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/model/DetectorInternalState.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad.model;\n+\n+import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+\n+import com.amazon.opendistroforelasticsearch.ad.annotation.Generated;\n+import com.amazon.opendistroforelasticsearch.ad.util.ParseUtils;\n+import com.google.common.base.Objects;\n+\n+/**\n+ * Include anomaly detector's state\n+ */\n+public class DetectorInternalState implements ToXContentObject, Cloneable {\n+\n+    public static final String PARSE_FIELD_NAME = \"DetectorInternalState\";\n+    public static final NamedXContentRegistry.Entry XCONTENT_REGISTRY = new NamedXContentRegistry.Entry(\n+        DetectorInternalState.class,\n+        new ParseField(PARSE_FIELD_NAME),\n+        it -> parse(it)\n+    );\n+\n+    public static final String DETECTOR_STATE_INDEX = \".opendistro-anomaly-state\";\n+\n+    public static final String RCF_UPDATES_FIELD = \"rcf_updates\";\n+    public static final String LAST_UPDATE_TIME_FIELD = \"last_update_time\";\n+    public static final String ERROR_FIELD = \"error\";\n+\n+    private long rcfUpdates = -1L;", "originalCommit": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk1ODE5Nw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447958197", "bodyText": "want to make it a illegal value. 0 is legal value.", "author": "kaituo", "createdAt": "2020-06-30T20:26:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk1MTgyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3MDQ4OQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447970489", "bodyText": "Why need to periodically maintain the checkpoint flag?", "author": "ylwu-amzn", "createdAt": "2020-06-30T20:50:12Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/ADStateManager.java", "diffHunk": "@@ -148,11 +175,13 @@ public void getAnomalyDetector(String adID, ActionListener<Optional<AnomalyDetec\n     public void clear(String adID) {\n         currentDetectors.remove(adID);\n         partitionNumber.remove(adID);\n+        currentCheckpoints.remove(adID);\n     }\n \n     public void maintenance() {\n         maintenance(currentDetectors);\n         maintenance(partitionNumber);\n+        maintenanceFlag(currentCheckpoints);", "originalCommit": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3ODE3Mg==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447978172", "bodyText": "otherwise, who would maintain the flag?", "author": "kaituo", "createdAt": "2020-06-30T21:04:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3MDQ4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3OTM1Ng==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447979356", "bodyText": "Sorry, din't not explain it clearly. My question is why need \"periodically\" maintain. Can we just maintain it when update/delete happen?", "author": "ylwu-amzn", "createdAt": "2020-06-30T21:06:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3MDQ4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk4NjI4OQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447986289", "bodyText": "make sense.  We both need to remember to do this when we fix checkpoint deletion.", "author": "kaituo", "createdAt": "2020-06-30T21:21:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3MDQ4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk5Nzk1NQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447997955", "bodyText": "I remember why I did it last year: this adds fault tolerance for state cleanup.  For example, what if customers never delete checkpoint and keep the detector stopped.  Then the checkpoint state is kept there in limbo in memory forever.", "author": "kaituo", "createdAt": "2020-06-30T21:46:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3MDQ4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3MTkxMQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447971911", "bodyText": "If not find checkpoint, we should remove it from currentCheckpoints .\nOne case is if user delete checkpoint manually, we should remove it from currentCheckpoints.", "author": "ylwu-amzn", "createdAt": "2020-06-30T20:52:59Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/ADStateManager.java", "diffHunk": "@@ -140,6 +143,30 @@ public void getAnomalyDetector(String adID, ActionListener<Optional<AnomalyDetec\n         }, listener::onFailure);\n     }\n \n+    public void getDetectorCheckpoint(String adID, ActionListener<Boolean> listener) {\n+        Instant timeGettingCheckpoint = currentCheckpoints.get(adID);\n+        if (timeGettingCheckpoint != null) {\n+            currentCheckpoints.put(adID, clock.instant());\n+            listener.onResponse(Boolean.TRUE);\n+            return;\n+        }\n+\n+        GetRequest request = new GetRequest(CommonName.CHECKPOINT_INDEX_NAME, modelManager.getRcfModelId(adID, 0));\n+\n+        clientUtil.<GetRequest, GetResponse>asyncRequest(request, client::get, onGetCheckpointResponse(adID, listener));\n+    }\n+\n+    private ActionListener<GetResponse> onGetCheckpointResponse(String adID, ActionListener<Boolean> listener) {\n+        return ActionListener.wrap(response -> {\n+            if (response == null || !response.isExists()) {\n+                listener.onResponse(Boolean.FALSE);", "originalCommit": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3ODU4MQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447978581", "bodyText": "We wouldn't come to this code path if currentCheckpoints has the flag set in the first place.\nCurrently, we don't delete checkpoint.  I am waiting for you to fix it :)", "author": "kaituo", "createdAt": "2020-06-30T21:05:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3MTkxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk5OTE2MA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447999160", "bodyText": "We wouldn't come to this code path if currentCheckpoints has the flag set in the first place.\nCurrently, we don't delete checkpoint. I am waiting for you to fix it :)\n\nSure, can you add some todo here?", "author": "ylwu-amzn", "createdAt": "2020-06-30T21:49:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3MTkxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1MjMyMQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r448052321", "bodyText": "Created #183", "author": "kaituo", "createdAt": "2020-07-01T00:33:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3MTkxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3Njc0MQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447976741", "bodyText": "For happy case(detector and feature present and circuit breaker not open, no read/write block, AD enabled), will every job run call getDetectorCheckpoint  method?", "author": "ylwu-amzn", "createdAt": "2020-06-30T21:01:52Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "diffHunk": "@@ -287,6 +291,20 @@ protected void doExecute(Task task, ActionRequest actionRequest, ActionListener<\n             }\n \n             if (!featureOptional.getProcessedFeatures().isPresent()) {\n+                stateManager.getDetectorCheckpoint(adID, ActionListener.wrap(checkpointExists -> {", "originalCommit": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3OTA2NA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447979064", "bodyText": "yes.  The method would check a flag in most cases.", "author": "kaituo", "createdAt": "2020-06-30T21:06:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3Njc0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk4NjkyNg==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447986926", "bodyText": "AD will take snapshot of model and save as checkpoint every 1 hour? If one detector has 1 minute interval and no checkpoint when start, is it possible that first 59 detector runs can't get checkpoint and do cold start?", "author": "ylwu-amzn", "createdAt": "2020-06-30T21:22:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3Njc0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk4ODI1MA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447988250", "bodyText": "we also take checkpoint during cold start.  So in your example, we have one checkpoint after the 1st run and the next one is taken on the 61st run.", "author": "kaituo", "createdAt": "2020-06-30T21:25:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3Njc0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk5MjM3Mg==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447992372", "bodyText": "Cool, that makes sense.", "author": "ylwu-amzn", "createdAt": "2020-06-30T21:33:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3Njc0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk5MzA4NA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r447993084", "bodyText": "Add some comment doc for this class?", "author": "ylwu-amzn", "createdAt": "2020-06-30T21:35:29Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/RCFPollingTransportAction.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad.transport;\n+\n+import java.io.IOException;\n+import java.util.Optional;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.HandledTransportAction;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportException;\n+import org.elasticsearch.transport.TransportRequestOptions;\n+import org.elasticsearch.transport.TransportResponseHandler;\n+import org.elasticsearch.transport.TransportService;\n+\n+import com.amazon.opendistroforelasticsearch.ad.cluster.HashRing;\n+import com.amazon.opendistroforelasticsearch.ad.common.exception.AnomalyDetectionException;\n+import com.amazon.opendistroforelasticsearch.ad.ml.ModelManager;\n+import com.amazon.opendistroforelasticsearch.ad.settings.AnomalyDetectorSettings;\n+\n+public class RCFPollingTransportAction extends HandledTransportAction<RCFPollingRequest, RCFPollingResponse> {", "originalCommit": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU5MDc1MA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r448590750", "bodyText": "added", "author": "kaituo", "createdAt": "2020-07-01T20:10:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk5MzA4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAwMzg4OQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r448003889", "bodyText": "We can save some memory for one detection interval if remove detector from currentCheckpoints, but needs another index query to get checkpoint as almost every detector run will try to get checkpoint. Can we just remove it when detector stopped/deleted?", "author": "ylwu-amzn", "createdAt": "2020-06-30T22:00:14Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/ADStateManager.java", "diffHunk": "@@ -176,6 +205,27 @@ public void maintenance() {\n         });\n     }\n \n+    /**\n+     * Clean states if it is older than our stateTtl. The input has to be a\n+     * ConcurrentHashMap otherwise we will have\n+     * java.util.ConcurrentModificationException.\n+     *\n+     * @param flags flags to be maintained\n+     */\n+    void maintenanceFlag(ConcurrentHashMap<String, Instant> flags) {\n+        flags.entrySet().stream().forEach(entry -> {\n+            String detectorId = entry.getKey();\n+            try {\n+                Instant time = entry.getValue();\n+                if (time.plus(stateTtl).isBefore(clock.instant())) {\n+                    flags.remove(detectorId);", "originalCommit": "429b2e4cfe340f6c7389efdfa83f2c67309c4cfd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1MjgxNA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r448052814", "bodyText": "state manitenance would remove it from memory.  We don't have to do it manually.", "author": "kaituo", "createdAt": "2020-07-01T00:35:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAwMzg4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODEwNDczOQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r448104739", "bodyText": "state manitenance would remove it from memory. We don't have to do it manually.\n\nYeah, the question is do we have to add some TTL to checkpoint cache and remove it periodically? Can we simplify the logic to just remove one detector's checkpoint cache when detector stopped/deleted?", "author": "ylwu-amzn", "createdAt": "2020-07-01T04:13:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAwMzg4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ5NzgyNg==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r448497826", "bodyText": "One case this periodic cleanup is useful: job schedule's shard relocate and we don't use the coordinating node anymore.  Before the detector gets deleted/stopped, these memory would be there.", "author": "kaituo", "createdAt": "2020-07-01T16:59:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAwMzg4OQ=="}], "type": "inlineReview"}, {"oid": "0d332bea3b3bf6cebb1c863ac288c7e969e2a3c8", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/0d332bea3b3bf6cebb1c863ac288c7e969e2a3c8", "message": "Adds initialization progress to profile API\n\nThis PR adds init_progress to profile API. init_progress helps users track initialization percentage, needed shingles, and estimated time to go if the future data stream is continuous (no missing data).\n\nInitialization percentage measures how far away we can observe RCF models emitting scores.\u00a0 The implementation fetches the RCF model's total updates while the AD job is running and materializes the value to the newly added index .opendistro-anomaly-info. Total updates record the number of times this RCF model has been updated.\u00a0\n\nInitialization percent is computed as x/128:\u00a0\n* if total updates > 128, x = 128. Otherwise, x is the total updates\u00a0\n* 128 is our output after the number in RCF. After observing 128 samples, RCF starts emitting scores.\n\nNeeded shingles are computed as 128 -x.\u00a0 Estimated minutes to go is computed as needed shingles * detector interval\n\nThis PR also materializes the error message in the most recent run to speed up profile API's error fetching.\n\nDuring each AD execution, we also check if a checkpoint is there (the result is saved and maintained as other AD states), if yes, we cold start immediately.\n\nTesting done:\n1. adds unit tests\n2. run e2e tests to verify init_progress number makes sense.", "committedDate": "2020-06-30T20:38:59Z", "type": "forcePushed"}, {"oid": "ab8c592eb63ca0553f9a5ee21cee635764cf997c", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/ab8c592eb63ca0553f9a5ee21cee635764cf997c", "message": "Adds initialization progress to profile API\n\nThis PR adds init_progress to profile API. init_progress helps users track initialization percentage, needed shingles, and estimated time to go if the future data stream is continuous (no missing data).\n\nInitialization percentage measures how far away we can observe RCF models emitting scores.\u00a0 The implementation fetches the RCF model's total updates while the AD job is running and materializes the value to the newly added index .opendistro-anomaly-info. Total updates record the number of times this RCF model has been updated.\u00a0\n\nInitialization percent is computed as x/128:\u00a0\n* if total updates > 128, x = 128. Otherwise, x is the total updates\u00a0\n* 128 is our output after the number in RCF. After observing 128 samples, RCF starts emitting scores.\n\nNeeded shingles are computed as 128 -x.\u00a0 Estimated minutes to go is computed as needed shingles * detector interval\n\nThis PR also materializes the error message in the most recent run to speed up profile API's error fetching.\n\nDuring each AD execution, we also check if a checkpoint is there (the result is saved and maintained as other AD states), if yes, we cold start immediately.\n\nTesting done:\n1. adds unit tests\n2. run e2e tests to verify init_progress number makes sense.", "committedDate": "2020-07-07T15:58:34Z", "type": "forcePushed"}, {"oid": "9d018b900a75857f6345752429f374f4601f40c8", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/9d018b900a75857f6345752429f374f4601f40c8", "message": "Adds initialization progress to profile API\n\nThis PR adds init_progress to profile API. init_progress helps users track initialization percentage, needed shingles, and estimated time to go if the future data stream is continuous (no missing data).\n\nInitialization percentage measures how far away we can observe RCF models emitting scores.\u00a0 The implementation fetches the RCF model's total updates while the AD job is running and materializes the value to the newly added index .opendistro-anomaly-info. Total updates record the number of times this RCF model has been updated.\u00a0\n\nInitialization percent is computed as x/128:\u00a0\n* if total updates > 128, x = 128. Otherwise, x is the total updates\u00a0\n* 128 is our output after the number in RCF. After observing 128 samples, RCF starts emitting scores.\n\nNeeded shingles are computed as 128 -x.\u00a0 Estimated minutes to go is computed as needed shingles * detector interval\n\nThis PR also materializes the error message in the most recent run to speed up profile API's error fetching.\n\nDuring each AD execution, we also check if a checkpoint is there (the result is saved and maintained as other AD states), if yes, we cold start immediately.\n\nTesting done:\n1. adds unit tests\n2. run e2e tests to verify init_progress number makes sense.", "committedDate": "2020-07-07T16:10:17Z", "type": "forcePushed"}, {"oid": "670d2a96142e0dff4ebe4d7be1ba165971595de4", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/670d2a96142e0dff4ebe4d7be1ba165971595de4", "message": "Adds initialization progress to profile API\n\nThis PR adds init_progress to profile API. init_progress helps users track initialization percentage, needed shingles, and estimated time to go if the future data stream is continuous (no missing data).\n\nInitialization percentage measures how far away we can observe RCF models emitting scores.\u00a0 The implementation fetches the RCF model's total updates while the AD job is running and materializes the value to the newly added index .opendistro-anomaly-info. Total updates record the number of times this RCF model has been updated.\u00a0\n\nInitialization percent is computed as x/128:\u00a0\n* if total updates > 128, x = 128. Otherwise, x is the total updates\u00a0\n* 128 is our output after the number in RCF. After observing 128 samples, RCF starts emitting scores.\n\nNeeded shingles are computed as 128 -x.\u00a0 Estimated minutes to go is computed as needed shingles * detector interval\n\nThis PR also materializes the error message in the most recent run to speed up profile API's error fetching.\n\nDuring each AD execution, we also check if a checkpoint is there (the result is saved and maintained as other AD states), if yes, we cold start immediately.\n\nTesting done:\n1. adds unit tests\n2. run e2e tests to verify init_progress number makes sense.", "committedDate": "2020-07-07T16:24:48Z", "type": "commit"}, {"oid": "670d2a96142e0dff4ebe4d7be1ba165971595de4", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/670d2a96142e0dff4ebe4d7be1ba165971595de4", "message": "Adds initialization progress to profile API\n\nThis PR adds init_progress to profile API. init_progress helps users track initialization percentage, needed shingles, and estimated time to go if the future data stream is continuous (no missing data).\n\nInitialization percentage measures how far away we can observe RCF models emitting scores.\u00a0 The implementation fetches the RCF model's total updates while the AD job is running and materializes the value to the newly added index .opendistro-anomaly-info. Total updates record the number of times this RCF model has been updated.\u00a0\n\nInitialization percent is computed as x/128:\u00a0\n* if total updates > 128, x = 128. Otherwise, x is the total updates\u00a0\n* 128 is our output after the number in RCF. After observing 128 samples, RCF starts emitting scores.\n\nNeeded shingles are computed as 128 -x.\u00a0 Estimated minutes to go is computed as needed shingles * detector interval\n\nThis PR also materializes the error message in the most recent run to speed up profile API's error fetching.\n\nDuring each AD execution, we also check if a checkpoint is there (the result is saved and maintained as other AD states), if yes, we cold start immediately.\n\nTesting done:\n1. adds unit tests\n2. run e2e tests to verify init_progress number makes sense.", "committedDate": "2020-07-07T16:24:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE0MDY2MQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r451140661", "bodyText": "the status will be incorrect for a stopped detector?", "author": "wnbts", "createdAt": "2020-07-07T21:01:08Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/AnomalyDetectorProfileRunner.java", "diffHunk": "@@ -203,242 +190,120 @@ private void prepareProfile(\n     /**\n      * We expect three kinds of states:\n      *  -Disabled: if get ad job api says the job is disabled;\n-     *  -Init: if anomaly score after the last update time of the detector is larger than 0\n+     *  -Init: if rcf model's total updates is less than required\n      *  -Running: if neither of the above applies and no exceptions.\n      * @param detectorId detector id\n-     * @param enabledTime the time when AD job is enabled in milliseconds\n      * @param listener listener to process the returned state or exception\n      * @param enabled whether the detector job is enabled or not\n+     * @param profilesToCollect target profiles to fetch\n      */\n-    private void profileState(\n+    private void profileStateRelated(\n         String detectorId,\n-        long enabledTime,\n         MultiResponsesDelegateActionListener<DetectorProfile> listener,\n-        boolean enabled\n+        boolean enabled,\n+        Set<ProfileName> profilesToCollect\n     ) {\n         if (enabled) {\n-            SearchRequest searchLatestResult = createInittedEverRequest(detectorId, enabledTime);\n-            client.search(searchLatestResult, onInittedEver(listener, detectorId, enabledTime));\n+            RCFPollingRequest request = new RCFPollingRequest(detectorId);\n+            client.execute(RCFPollingAction.INSTANCE, request, onPollRCFUpdates(detectorId, profilesToCollect, listener));\n         } else {\n-            DetectorProfile profile = new DetectorProfile();\n-            profile.setState(DetectorState.DISABLED);\n-            listener.onResponse(profile);\n-        }\n-    }\n-\n-    private ActionListener<SearchResponse> onInittedEver(\n-        MultiResponsesDelegateActionListener<DetectorProfile> listener,\n-        String detectorId,\n-        long lastUpdateTimeMs\n-    ) {\n-        return ActionListener.wrap(searchResponse -> {\n-            SearchHits hits = searchResponse.getHits();\n-            DetectorProfile profile = new DetectorProfile();\n-            if (hits.getHits().length == 0L) {\n-                profile.setState(DetectorState.INIT);\n-            } else {\n-                profile.setState(DetectorState.RUNNING);\n+            if (profilesToCollect.contains(ProfileName.STATE)) {\n+                listener.onResponse(new DetectorProfile.Builder().state(DetectorState.DISABLED).build());\n             }\n-\n-            listener.onResponse(profile);\n-\n-        }, exception -> {\n-            if (exception instanceof IndexNotFoundException) {\n-                DetectorProfile profile = new DetectorProfile();\n-                // anomaly result index is not created yet\n-                profile.setState(DetectorState.INIT);\n-                listener.onResponse(profile);\n-            } else {\n-                logger\n-                    .error(\n-                        \"Fail to find any anomaly result with anomaly score larger than 0 after AD job enabled time for detector {}\",\n-                        detectorId\n-                    );\n-                listener.onFailure(new RuntimeException(\"Fail to find detector state: \" + detectorId, exception));\n+            if (profilesToCollect.contains(ProfileName.INIT_PROGRESS)) {\n+                listener.onResponse(new DetectorProfile.Builder().build());", "originalCommit": "670d2a96142e0dff4ebe4d7be1ba165971595de4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE4MTgwNg==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r451181806", "bodyText": "This means init progress is empty for a stopped detector.", "author": "kaituo", "createdAt": "2020-07-07T22:34:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE0MDY2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc5NjM4Mw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r451796383", "bodyText": "if the status of the model is completed, i would think the profile init status should also be completed to reflect the truth, whether the detector is running or stopped. otherwise, it might cause confusion that stopping a detector deletes the model or uncertainty about the model of a stopped detector.", "author": "wnbts", "createdAt": "2020-07-08T20:07:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE0MDY2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE0NTc5Ng==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r451145796", "bodyText": "minor. i have difficulty in understanding this sentence.", "author": "wnbts", "createdAt": "2020-07-07T21:11:35Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/AnomalyDetectorProfileRunner.java", "diffHunk": "@@ -203,242 +190,120 @@ private void prepareProfile(\n     /**\n      * We expect three kinds of states:\n      *  -Disabled: if get ad job api says the job is disabled;\n-     *  -Init: if anomaly score after the last update time of the detector is larger than 0\n+     *  -Init: if rcf model's total updates is less than required\n      *  -Running: if neither of the above applies and no exceptions.\n      * @param detectorId detector id\n-     * @param enabledTime the time when AD job is enabled in milliseconds\n      * @param listener listener to process the returned state or exception\n      * @param enabled whether the detector job is enabled or not\n+     * @param profilesToCollect target profiles to fetch\n      */\n-    private void profileState(\n+    private void profileStateRelated(\n         String detectorId,\n-        long enabledTime,\n         MultiResponsesDelegateActionListener<DetectorProfile> listener,\n-        boolean enabled\n+        boolean enabled,\n+        Set<ProfileName> profilesToCollect\n     ) {\n         if (enabled) {\n-            SearchRequest searchLatestResult = createInittedEverRequest(detectorId, enabledTime);\n-            client.search(searchLatestResult, onInittedEver(listener, detectorId, enabledTime));\n+            RCFPollingRequest request = new RCFPollingRequest(detectorId);\n+            client.execute(RCFPollingAction.INSTANCE, request, onPollRCFUpdates(detectorId, profilesToCollect, listener));\n         } else {\n-            DetectorProfile profile = new DetectorProfile();\n-            profile.setState(DetectorState.DISABLED);\n-            listener.onResponse(profile);\n-        }\n-    }\n-\n-    private ActionListener<SearchResponse> onInittedEver(\n-        MultiResponsesDelegateActionListener<DetectorProfile> listener,\n-        String detectorId,\n-        long lastUpdateTimeMs\n-    ) {\n-        return ActionListener.wrap(searchResponse -> {\n-            SearchHits hits = searchResponse.getHits();\n-            DetectorProfile profile = new DetectorProfile();\n-            if (hits.getHits().length == 0L) {\n-                profile.setState(DetectorState.INIT);\n-            } else {\n-                profile.setState(DetectorState.RUNNING);\n+            if (profilesToCollect.contains(ProfileName.STATE)) {\n+                listener.onResponse(new DetectorProfile.Builder().state(DetectorState.DISABLED).build());\n             }\n-\n-            listener.onResponse(profile);\n-\n-        }, exception -> {\n-            if (exception instanceof IndexNotFoundException) {\n-                DetectorProfile profile = new DetectorProfile();\n-                // anomaly result index is not created yet\n-                profile.setState(DetectorState.INIT);\n-                listener.onResponse(profile);\n-            } else {\n-                logger\n-                    .error(\n-                        \"Fail to find any anomaly result with anomaly score larger than 0 after AD job enabled time for detector {}\",\n-                        detectorId\n-                    );\n-                listener.onFailure(new RuntimeException(\"Fail to find detector state: \" + detectorId, exception));\n+            if (profilesToCollect.contains(ProfileName.INIT_PROGRESS)) {\n+                listener.onResponse(new DetectorProfile.Builder().build());\n             }\n-        });\n+        }\n     }\n \n     /**\n-     * Precondition:\n-     * 1. Index are rotated with name pattern \".opendistro-anomaly-results-history-{now/d}-1\" and now is using UTC.\n-     * 2. Latest entry with error is recorded within enabled and disabled time.  Note disabled time can be null.\n-     *\n-     * Error is populated if error of the latest anomaly result is not empty.\n-     *\n-     * Two optimization to avoid scanning all anomaly result indices to get a detector's most recent error\n-     *\n-     * First, when a detector is running, we only need to scan the current index, not all of the rolled over ones\n-     *  since we are interested in the latest error.\n-     * Second, when a detector is disabled, we only need to scan the latest anomaly result indices created before the\n-     *  detector's enable time.\n-     *\n+     * Action listener for a detector in running or init state\n+     * @param listener listener to consolidate results and return a final response\n      * @param detectorId detector id\n-     * @param enabledTimeMillis the time when AD job is enabled in milliseconds\n-     * @param listener listener to process the returned error or exception\n+     * @param enabledTimeMs AD job enabled time\n+     * @return the listener for a detector in disabled state\n      */\n-    private void profileError(\n+    private ActionListener<GetResponse> onGetDetectorState(\n+        MultiResponsesDelegateActionListener<DetectorProfile> listener,\n         String detectorId,\n-        long enabledTimeMillis,\n-        Instant disabledTime,\n-        MultiResponsesDelegateActionListener<DetectorProfile> listener\n+        long enabledTimeMs\n     ) {\n-        String[] latestIndex = null;\n-\n-        long disabledTimeMillis = 0;\n-        if (disabledTime != null) {\n-            disabledTimeMillis = disabledTime.toEpochMilli();\n-        }\n-        if (enabledTimeMillis > disabledTimeMillis) {\n-            // detector is still running\n-            latestIndex = new String[1];\n-            latestIndex[0] = AnomalyResult.ANOMALY_RESULT_INDEX;\n-        } else {\n-            String[] concreteIndices = indexNameExpressionResolver\n-                .concreteIndexNames(\n-                    clusterService.state(),\n-                    IndicesOptions.lenientExpandOpen(),\n-                    AnomalyDetectionIndices.ALL_AD_RESULTS_INDEX_PATTERN\n-                );\n-\n-            // find the latest from result indices such as .opendistro-anomaly-results-history-2020.04.06-1 and\n-            // /.opendistro-anomaly-results-history-2020.04.07-000002\n-            long maxTimestamp = -1;\n-            TreeMap<Long, List<String>> candidateIndices = new TreeMap<>();\n-            for (String indexName : concreteIndices) {\n-                Matcher m = Pattern.compile(\"\\\\.opendistro-anomaly-results-history-(\\\\d{4})\\\\.(\\\\d{2})\\\\.(\\\\d{2})-\\\\d+\").matcher(indexName);\n-                if (m.matches()) {\n-                    int year = Integer.parseInt(m.group(1));\n-                    int month = Integer.parseInt(m.group(2));\n-                    int date = Integer.parseInt(m.group(3));\n-                    // month starts with 0\n-                    calendar.clear();\n-                    calendar.set(year, month - 1, date);\n-                    // 2020.05.08 is translated to 1588896000000\n-                    long timestamp = calendar.getTimeInMillis();\n-\n-                    // a candidate index can be created before or after enabled time, but the index is definitely created before disabled\n-                    // time\n-                    if (timestamp <= disabledTimeMillis && maxTimestamp <= timestamp) {\n-                        maxTimestamp = timestamp;\n-                        // we can have two rotations on the same day and we don't know which one has our data, so we keep all\n-                        List<String> indexList = candidateIndices.computeIfAbsent(timestamp, k -> new ArrayList<String>());\n-                        indexList.add(indexName);\n-                    }\n-                }\n-            }\n-            List<String> candidates = new ArrayList<String>();\n-            List<String> latestCandidate = candidateIndices.get(maxTimestamp);\n-\n-            if (latestCandidate != null) {\n-                candidates.addAll(latestCandidate);\n-            }\n-\n-            // look back one more index for an edge case:\n-            // Suppose detector interval is 1 minute. Detector last run is at 2020-05-07, 11:59:50 PM,\n-            // then AD result indices rolled over as .opendistro-anomaly-results-history-2020.05.07-001\n-            // Detector next run will be 2020-05-08, 00:00:50 AM. If a user stop the detector at\n-            // 2020-05-08 00:00:10 AM, detector will not have AD result on 2020-05-08.\n-            // We check AD result indices one day earlier to make sure we can always get AD result.\n-            Map.Entry<Long, List<String>> earlierCandidate = candidateIndices.lowerEntry(maxTimestamp);\n-            if (earlierCandidate != null) {\n-                candidates.addAll(earlierCandidate.getValue());\n-            }\n-            latestIndex = candidates.toArray(new String[0]);\n-        }\n-\n-        if (latestIndex == null || latestIndex.length == 0) {\n-            // no result index found: can be due to anomaly result is not created yet or result indices for the detector have been deleted.\n-            listener.onResponse(new DetectorProfile());\n-            return;\n-        }\n-        SearchRequest searchLatestResult = createLatestAnomalyResultRequest(detectorId, enabledTimeMillis, disabledTimeMillis, latestIndex);\n-        client.search(searchLatestResult, onGetLatestAnomalyResult(listener, detectorId));\n-    }\n-\n-    private ActionListener<SearchResponse> onGetLatestAnomalyResult(ActionListener<DetectorProfile> listener, String detectorId) {\n-        return ActionListener.wrap(searchResponse -> {\n-            SearchHits hits = searchResponse.getHits();\n-            if (hits.getHits().length == 0L) {\n-                listener.onResponse(new DetectorProfile());\n-            } else {\n-                SearchHit hit = hits.getAt(0);\n-\n+        return ActionListener.wrap(getResponse -> {\n+            DetectorProfile.Builder profileBuilder = new DetectorProfile.Builder();\n+            if (getResponse != null && getResponse.isExists()) {\n                 try (\n                     XContentParser parser = XContentType.JSON\n                         .xContent()\n-                        .createParser(xContentRegistry, LoggingDeprecationHandler.INSTANCE, hit.getSourceAsString())\n+                        .createParser(xContentRegistry, LoggingDeprecationHandler.INSTANCE, getResponse.getSourceAsString())\n                 ) {\n                     ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n-                    AnomalyResult result = parser.namedObject(AnomalyResult.class, AnomalyResult.PARSE_FIELD_NAME, null);\n-                    DetectorProfile profile = new DetectorProfile();\n-                    if (result.getError() != null) {\n-                        profile.setError(result.getError());\n+                    DetectorInternalState detectorState = DetectorInternalState.parse(parser);\n+                    long lastUpdateTimeMs = detectorState.getLastUpdateTime().toEpochMilli();\n+\n+                    // if state index hasn't been updated, we should not use the error field\n+                    // For example, before enabled, error is stopped due to, we should not show", "originalCommit": "670d2a96142e0dff4ebe4d7be1ba165971595de4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE5MTU2Mg==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r451191562", "bodyText": "Is the following easier to read?\n                // if state index hasn't been updated, we should not use the error field\n                // For example, before enabled, error is \"stopped due to blah\", we should not show\n                // this when the detector is enabled.", "author": "kaituo", "createdAt": "2020-07-07T23:04:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE0NTc5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc5Nzc0Nw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r451797747", "bodyText": "ok. now i understand it. a more complete sentence will be clearer.\nFor example, before (the detector is) enabled, if the error message contains the phrase \"stopped due to blah\", ....", "author": "wnbts", "createdAt": "2020-07-08T20:10:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE0NTc5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgwMTMwMw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r451801303", "bodyText": "will change.", "author": "kaituo", "createdAt": "2020-07-08T20:18:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE0NTc5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE1NjAzNA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r451156034", "bodyText": "this will retrieve the entire model checkpoints (w/ many data samples that are not used), recompuate all trees from samples, and only read one field. it would be more costly an operation than reading one field from the state. it's worth more consideration if this is scalable for the get profile requests.", "author": "wnbts", "createdAt": "2020-07-07T21:32:41Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/ml/ModelManager.java", "diffHunk": "@@ -1045,4 +1067,24 @@ private double computeRcfConfidence(RandomCutForest forest) {\n             .forEach(entry -> { res.put(entry.getKey(), 0L); });\n         return res;\n     }\n+\n+    /**\n+     * Get a RCF model's total updates.\n+     * @param modelId the RCF model's id\n+     * @param detectorId detector Id\n+     * @param listener listener to return the result\n+     */\n+    public void getTotalUpdates(String modelId, String detectorId, ActionListener<Long> listener) {\n+        ModelState<RandomCutForest> model = forests.get(modelId);\n+        if (model != null) {\n+            listener.onResponse(model.getModel().getTotalUpdates());\n+        } else {\n+            checkpointDao\n+                .getModelCheckpoint(", "originalCommit": "670d2a96142e0dff4ebe4d7be1ba165971595de4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE5MTExMw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r451191113", "bodyText": "yeah, fortunately this is one-time thing and we don't have to do it repeatedly.  Also, when later shingle is ready the model can be used immediately.  Let me know if you have any way to improve this.", "author": "kaituo", "createdAt": "2020-07-07T23:02:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE1NjAzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgwMTM0OA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r451801348", "bodyText": "i am worried about for every get profile call, the model gets pulled, loaded, and hosted.\nsome optimizations\n\nthere is not much to save from getting the checkpoint. but the checkpoint doesn't need to be fully deserialized, i.e., the bulk of the model, the trees are not needed. a lightweight deserialization only involving the forest containing the update count can be added to avoid recomputing trees and discarding them.\nif the model is not hosted before deserialization, it doesn't need to be hosted since it's not being used by active jobs, saves memory space and write back to index again later during maintenance.", "author": "wnbts", "createdAt": "2020-07-08T20:18:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE1NjAzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgyMTU5OA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r451821598", "bodyText": "The model does not need to be pulled, loaded, and hosted for every get profile call.  Only the first profile call if the model hasn't been hosted.", "author": "kaituo", "createdAt": "2020-07-08T20:58:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE1NjAzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE2NDkxNQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r451164915", "bodyText": "minor. ConcurrentHashMap::computeIfAbsent is the api for this case.", "author": "wnbts", "createdAt": "2020-07-07T21:52:09Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/TransportStateManager.java", "diffHunk": "@@ -91,31 +90,35 @@ public ADStateManager(\n      * @throws LimitExceededException when there is no sufficient resource available\n      */\n     public int getPartitionNumber(String adID, AnomalyDetector detector) {\n-        Entry<Integer, Instant> partitonAndTime = partitionNumber.get(adID);\n-        if (partitonAndTime != null) {\n+        if (transportStates.containsKey(adID) && transportStates.get(adID).getPartitonNumber() != null) {\n+            Entry<Integer, Instant> partitonAndTime = transportStates.get(adID).getPartitonNumber();\n             partitonAndTime.setValue(clock.instant());\n             return partitonAndTime.getKey();\n         }\n \n         int partitionNum = modelManager.getPartitionedForestSizes(detector).getKey();\n-        partitionNumber.putIfAbsent(adID, new SimpleEntry<>(partitionNum, clock.instant()));\n+        TransportState state = transportStates.get(adID);\n+        if (state == null) {\n+            state = new TransportState(adID);\n+            transportStates.put(adID, state);\n+        }", "originalCommit": "670d2a96142e0dff4ebe4d7be1ba165971595de4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE4NDAyMg==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r451184022", "bodyText": "changed.", "author": "kaituo", "createdAt": "2020-07-07T22:41:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE2NDkxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE2NjY4OA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r451166688", "bodyText": "which client is using this method?", "author": "wnbts", "createdAt": "2020-07-07T21:56:11Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/TransportStateManager.java", "diffHunk": "@@ -140,35 +149,61 @@ public void getAnomalyDetector(String adID, ActionListener<Optional<AnomalyDetec\n         }, listener::onFailure);\n     }\n \n+    /**\n+     * Get a detector's checkpoint and save a flag if we find any so that next time we don't need to do it again\n+     * @param adID  the detector's ID\n+     * @param listener listener to handle get request\n+     */\n+    public void getDetectorCheckpoint(String adID, ActionListener<Boolean> listener) {", "originalCommit": "670d2a96142e0dff4ebe4d7be1ba165971595de4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE3MzY4Ng==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r451173686", "bodyText": "found it", "author": "wnbts", "createdAt": "2020-07-07T22:13:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE2NjY4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE2ODA3Mw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r451168073", "bodyText": "is it the same as Objects::equals ?", "author": "wnbts", "createdAt": "2020-07-07T21:59:17Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/handler/DetectorStateHandler.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad.transport.handler;\n+\n+import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.function.BooleanSupplier;\n+import java.util.function.Consumer;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.indices.create.CreateIndexResponse;\n+import org.elasticsearch.action.get.GetRequest;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.LoggingDeprecationHandler;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import com.amazon.opendistroforelasticsearch.ad.model.DetectorInternalState;\n+import com.amazon.opendistroforelasticsearch.ad.util.ClientUtil;\n+import com.amazon.opendistroforelasticsearch.ad.util.IndexUtils;\n+\n+public class DetectorStateHandler extends AnomalyIndexHandler<DetectorInternalState> {\n+    interface GetStateStrategy {\n+        /**\n+         * Strategy to create new state to save.  Return null if state does not change and don't need to save.\n+         * @param state old state\n+         * @return new state or null if state does not change\n+         */\n+        DetectorInternalState createNewState(DetectorInternalState state);\n+    }\n+\n+    class ErrorStrategy implements GetStateStrategy {\n+        private String error;\n+\n+        ErrorStrategy(String error) {\n+            this.error = error;\n+        }\n+\n+        @Override\n+        public DetectorInternalState createNewState(DetectorInternalState state) {\n+            DetectorInternalState newState = null;\n+            if (state == null) {\n+                newState = new DetectorInternalState.Builder().error(error).lastUpdateTime(Instant.now()).build();\n+            } else if ((state.getError() == null && error != null) || (state.getError() != null && !state.getError().equals(error))) {", "originalCommit": "670d2a96142e0dff4ebe4d7be1ba165971595de4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE4NTY2Nw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r451185667", "bodyText": "yes, refactored.  Thanks :)", "author": "kaituo", "createdAt": "2020-07-07T22:46:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE2ODA3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE3MTE1Ng==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r451171156", "bodyText": "can error be part of transport state and trigger indexing when updated? so a get can be saved for each run.", "author": "wnbts", "createdAt": "2020-07-07T22:06:49Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/handler/DetectorStateHandler.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad.transport.handler;\n+\n+import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.function.BooleanSupplier;\n+import java.util.function.Consumer;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.indices.create.CreateIndexResponse;\n+import org.elasticsearch.action.get.GetRequest;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.LoggingDeprecationHandler;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import com.amazon.opendistroforelasticsearch.ad.model.DetectorInternalState;\n+import com.amazon.opendistroforelasticsearch.ad.util.ClientUtil;\n+import com.amazon.opendistroforelasticsearch.ad.util.IndexUtils;\n+\n+public class DetectorStateHandler extends AnomalyIndexHandler<DetectorInternalState> {\n+    interface GetStateStrategy {\n+        /**\n+         * Strategy to create new state to save.  Return null if state does not change and don't need to save.\n+         * @param state old state\n+         * @return new state or null if state does not change\n+         */\n+        DetectorInternalState createNewState(DetectorInternalState state);\n+    }\n+\n+    class ErrorStrategy implements GetStateStrategy {\n+        private String error;\n+\n+        ErrorStrategy(String error) {\n+            this.error = error;\n+        }\n+\n+        @Override\n+        public DetectorInternalState createNewState(DetectorInternalState state) {\n+            DetectorInternalState newState = null;\n+            if (state == null) {\n+                newState = new DetectorInternalState.Builder().error(error).lastUpdateTime(Instant.now()).build();\n+            } else if ((state.getError() == null && error != null) || (state.getError() != null && !state.getError().equals(error))) {\n+                newState = (DetectorInternalState) state.clone();\n+                newState.setError(error);\n+                newState.setLastUpdateTime(Instant.now());\n+            }\n+\n+            return newState;\n+        }\n+    }\n+\n+    private static final Logger LOG = LogManager.getLogger(DetectorStateHandler.class);\n+    private NamedXContentRegistry xContentRegistry;\n+\n+    public DetectorStateHandler(\n+        Client client,\n+        Settings settings,\n+        ThreadPool threadPool,\n+        Consumer<ActionListener<CreateIndexResponse>> createIndex,\n+        BooleanSupplier indexExists,\n+        ClientUtil clientUtil,\n+        IndexUtils indexUtils,\n+        ClusterService clusterService,\n+        NamedXContentRegistry xContentRegistry\n+    ) {\n+        super(\n+            client,\n+            settings,\n+            threadPool,\n+            DetectorInternalState.DETECTOR_STATE_INDEX,\n+            createIndex,\n+            indexExists,\n+            true,\n+            clientUtil,\n+            indexUtils,\n+            clusterService\n+        );\n+        this.xContentRegistry = xContentRegistry;\n+    }\n+\n+    public void saveError(String error, String detectorId, Instant jobEnabledTime) {\n+        update(detectorId, new ErrorStrategy(error), jobEnabledTime);\n+    }\n+\n+    /**\n+     * Updates a detector's state according to GetStateHandler\n+     * @param detectorId detector id\n+     * @param handler specify how to convert from existing state object to an object we want to save\n+     */\n+    private void update(String detectorId, GetStateStrategy handler, Instant jobEnabledTime) {\n+        try {\n+            GetRequest getRequest = new GetRequest(this.indexName).id(detectorId);\n+\n+            clientUtil.<GetRequest, GetResponse>asyncRequest(getRequest, client::get, ActionListener.wrap(response -> {\n+                DetectorInternalState newState = null;", "originalCommit": "670d2a96142e0dff4ebe4d7be1ba165971595de4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE5MDI0Mw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r451190243", "bodyText": "Error would be saved on a coordinating node's state.  We have no easy way to find a coordinating node for a detector except broadcasting.  Any way to work around this?", "author": "kaituo", "createdAt": "2020-07-07T22:59:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE3MTE1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgwMjgxOA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r451802818", "bodyText": "On second thought, what you said make sense.  I'll keep the last error in transport state and access it in DetectorStateHandler.", "author": "kaituo", "createdAt": "2020-07-08T20:21:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE3MTE1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgwNDIyMw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r451804223", "bodyText": "if after each run, the detector coordinator itself, holding the anomaly result and error, manages detector error state rather than letting the job scheduler do it, does it still require messaging?", "author": "wnbts", "createdAt": "2020-07-08T20:23:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE3MTE1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgyMjczMg==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r451822732", "bodyText": "You meant does it still require indexing into state index?\nYes, the state can be cleared due to maintenance, or coordinating node can change.  We need a permanent place to host the data.", "author": "kaituo", "createdAt": "2020-07-08T21:01:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE3MTE1Ng=="}], "type": "inlineReview"}, {"oid": "575c9836d0c0639a58976489d1c5faf4741358d3", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/575c9836d0c0639a58976489d1c5faf4741358d3", "message": "refacotring and removing unused fields in state index schema", "committedDate": "2020-07-07T23:11:32Z", "type": "commit"}, {"oid": "c0cf04f5f4470b503bad983ce114685269f93906", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/c0cf04f5f4470b503bad983ce114685269f93906", "message": "Make error be part of transport state and trigger indexing when updated", "committedDate": "2020-07-09T15:59:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ3MDgyOA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r452470828", "bodyText": "are there any reasons not inverse the dependency, i.e., letting detector state handler be a dependency within state manager? there are for two benefits\n\nremoves the unnecessary dependency that state manager and job runner for the same detector are on the same node. if/when the two are run on separate nodes, error information doesn't need to be replicated.\nsince state manager already has the error, directly handing off/delegating to the handler is more natural than giving the info to job runner and let job runner give it to the handler.", "author": "wnbts", "createdAt": "2020-07-09T20:27:37Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/AnomalyDetectorJobRunner.java", "diffHunk": "@@ -436,7 +442,8 @@ private void indexAnomalyResult(\n                 Instant.now(),\n                 response.getError()\n             );\n-            anomalyResultHandler.indexAnomalyResult(anomalyResult);\n+            anomalyResultHandler.index(anomalyResult, detectorId);\n+            detectorStateHandler.saveError(response.getError(), detectorId);", "originalCommit": "c0cf04f5f4470b503bad983ce114685269f93906", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU4MjA1Nw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r452582057", "bodyText": "saveError method needs to be called by a source that runs regularly.  job runner is the source.  Both state manager and detector state handler reacts to job runner.\nAbout the two benefits:\n\nwith or without my changes, state manager and job runner for the same detector are on the same node.\nstate manager has the error because job runner gives the error to state manager.  job runner can give the error to state manager because job runner has access to detectorStateHandler.", "author": "kaituo", "createdAt": "2020-07-10T01:59:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ3MDgyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzEzMjg4OA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r453132888", "bodyText": "if job runner (sender) and state manager (responder) are on separate nodes for better scalability in the future, why let this change add an unnecessary coupling to prevent that?\n\n\nthe state manager is already a dependency of transport action, which generates errors first hand, why not letting the transport action directly update state manager, which updates the handler, (the chain of command is job runner > transport action > state manager > state handler), rather than taking a longer route involving the high-level job runner for more lower level details, which should only be responsible for sending job requests by schedule and have as little business logic as possible?", "author": "wnbts", "createdAt": "2020-07-11T00:42:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ3MDgyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzEzNTE3MQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r453135171", "bodyText": "I don't see it is coming in the near feature.  State manager is saving the state of job runner.  It makes no sense to save it in different node.\ndetectorStateHandler and anomalyResultHandler are both dependency of job runner.  Previously, the logic of anomalyResultHandler is in the transport action, as you suggested.  Yaliang separated it out and moved it to job runner.  It is easier to read and being consistent by keeping the way as it is now.", "author": "kaituo", "createdAt": "2020-07-11T01:00:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ3MDgyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzgwMTUyMw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r453801523", "bodyText": "if job runner (sender) and state manager (responder) are on separate nodes for better scalability in the future, why let this change add an unnecessary coupling to prevent that?\nthe state manager is already a dependency of transport action, which generates errors first hand, why not letting the transport action directly update state manager, which updates the handler, (the chain of command is job runner > transport action > state manager > state handler), rather than taking a longer route involving the high-level job runner for more lower level details, which should only be responsible for sending job requests by schedule and have as little business logic as possible?\n\n\nhi, Lai, good questions, before decoupling, we have no job runner and we handle all business logic and exceptions in transport action as it stands on top of other components. After decoupling, job runner is the top component, split the exception handling to job runner to avoid the exception handling logic scattered into multiple components(transport actions, job runners, etc).  So job runner will catch all exceptions including its own exceptions, then decide the following error handling such as stop detector if no enough resource, and write error in AD result index. Now Kaituo add detectorStateHandler, which will track the latest error. So it's same design logic to do error handling in one place.\nOf course, we may have other options to do this, like create a new error handler, pass it to every component to handle exception and persist in AD result individually. Both options have pros and cons, need to do some tradeoff. How about we keep current design for this PR? We can discuss different options and solve the error handling in another PR if we have better option.", "author": "ylwu-amzn", "createdAt": "2020-07-13T17:11:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ3MDgyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg0Nzg2OA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r453847868", "bodyText": "this is not a blocker, as i have approved the pr.\nit's good to use interface to decouple business logic from work execution dependencies. in another word, consider if the job scheduler code (a work execution dependency) change/migrate to some other dependency for execution, how much needs to re-developed, copy and pasted, re-tested? can/should the work be further reduced? in the ideal case, the interface should serve to protect the business logic.", "author": "wnbts", "createdAt": "2020-07-13T18:29:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ3MDgyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk1OTIzOA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r453959238", "bodyText": "Thanks for the suggestion. Agree to \"use interface to decouple business logic from work execution dependencies\".  I think we can restructure when do AD workbench as it will change a lot of how to schedule detection task/job but not overdesign. Let's discuss more when do AD workbench.", "author": "ylwu-amzn", "createdAt": "2020-07-13T21:56:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ3MDgyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ4NTkzMA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r452485930", "bodyText": "is generic correct?", "author": "wnbts", "createdAt": "2020-07-09T20:57:46Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/RCFPollingTransportAction.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad.transport;\n+\n+import java.io.IOException;\n+import java.util.Optional;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.HandledTransportAction;\n+import org.elasticsearch.cluster.node.DiscoveryNode;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.transport.TransportException;\n+import org.elasticsearch.transport.TransportRequestOptions;\n+import org.elasticsearch.transport.TransportResponseHandler;\n+import org.elasticsearch.transport.TransportService;\n+\n+import com.amazon.opendistroforelasticsearch.ad.cluster.HashRing;\n+import com.amazon.opendistroforelasticsearch.ad.common.exception.AnomalyDetectionException;\n+import com.amazon.opendistroforelasticsearch.ad.ml.ModelManager;\n+import com.amazon.opendistroforelasticsearch.ad.settings.AnomalyDetectorSettings;\n+\n+/**\n+ * Transport action to get total rcf updates from hosted models or checkpoint\n+ *\n+ */\n+public class RCFPollingTransportAction extends HandledTransportAction<RCFPollingRequest, RCFPollingResponse> {\n+\n+    private static final Logger LOG = LogManager.getLogger(RCFPollingTransportAction.class);\n+    static final String NO_NODE_FOUND_MSG = \"Cannot find model hosting node\";\n+    static final String FAIL_TO_GET_RCF_UPDATE_MSG = \"Cannot find hosted model or related checkpoint\";\n+\n+    private final TransportService transportService;\n+    private final ModelManager modelManager;\n+    private final HashRing hashRing;\n+    private final TransportRequestOptions option;\n+    private final ClusterService clusterService;\n+\n+    @Inject\n+    public RCFPollingTransportAction(\n+        ActionFilters actionFilters,\n+        TransportService transportService,\n+        Settings settings,\n+        ModelManager modelManager,\n+        HashRing hashRing,\n+        ClusterService clusterService\n+    ) {\n+        super(RCFPollingAction.NAME, transportService, actionFilters, RCFPollingRequest::new);\n+        this.transportService = transportService;\n+        this.modelManager = modelManager;\n+        this.hashRing = hashRing;\n+        this.option = TransportRequestOptions\n+            .builder()\n+            .withType(TransportRequestOptions.Type.REG)\n+            .withTimeout(AnomalyDetectorSettings.REQUEST_TIMEOUT.get(settings))\n+            .build();\n+        this.clusterService = clusterService;\n+    }\n+\n+    @Override\n+    protected void doExecute(Task task, RCFPollingRequest request, ActionListener<RCFPollingResponse> listener) {\n+\n+        String adID = request.getAdID();\n+\n+        String rcfModelID = modelManager.getRcfModelId(adID, 0);\n+\n+        Optional<DiscoveryNode> rcfNode = hashRing.getOwningNode(rcfModelID.toString());\n+        if (!rcfNode.isPresent()) {\n+            listener.onFailure(new AnomalyDetectionException(adID, NO_NODE_FOUND_MSG));\n+            return;\n+        }\n+\n+        String rcfNodeId = rcfNode.get().getId();\n+\n+        DiscoveryNode localNode = clusterService.localNode();\n+\n+        if (localNode.getId().equals(rcfNodeId)) {\n+            modelManager\n+                .getTotalUpdates(\n+                    rcfModelID,\n+                    adID,\n+                    ActionListener\n+                        .wrap(\n+                            totalUpdates -> listener.onResponse(new RCFPollingResponse(totalUpdates)),\n+                            e -> listener.onFailure(new AnomalyDetectionException(adID, FAIL_TO_GET_RCF_UPDATE_MSG, e))\n+                        )\n+                );\n+        } else {\n+            // redirect\n+            LOG.info(\"Sending RCF polling request to {} for model {}\", rcfNodeId, rcfModelID);\n+\n+            try {\n+                transportService\n+                    .sendRequest(rcfNode.get(), RCFPollingAction.NAME, request, option, new TransportResponseHandler<RCFPollingResponse>() {\n+\n+                        @Override\n+                        public RCFPollingResponse read(StreamInput in) throws IOException {\n+                            return new RCFPollingResponse(in);\n+                        }\n+\n+                        @Override\n+                        public void handleResponse(RCFPollingResponse response) {\n+                            listener.onResponse(response);\n+                        }\n+\n+                        @Override\n+                        public void handleException(TransportException exp) {\n+                            listener.onFailure(exp);\n+                        }\n+\n+                        @Override\n+                        public String executor() {\n+                            return ThreadPool.Names.GENERIC;", "originalCommit": "c0cf04f5f4470b503bad983ce114685269f93906", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYwNjI3NA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r452606274", "bodyText": "ThreadPool.Names.SAME is more appropriate as the operation is lightweight.  Changed.", "author": "kaituo", "createdAt": "2020-07-10T03:43:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ4NTkzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ5MjA5MQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r452492091", "bodyText": "minor. computeIfPresent is more concise", "author": "wnbts", "createdAt": "2020-07-09T21:10:33Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/TransportStateManager.java", "diffHunk": "@@ -91,31 +92,31 @@ public ADStateManager(\n      * @throws LimitExceededException when there is no sufficient resource available\n      */\n     public int getPartitionNumber(String adID, AnomalyDetector detector) {\n-        Entry<Integer, Instant> partitonAndTime = partitionNumber.get(adID);\n-        if (partitonAndTime != null) {\n+        if (transportStates.containsKey(adID) && transportStates.get(adID).getPartitonNumber() != null) {", "originalCommit": "c0cf04f5f4470b503bad983ce114685269f93906", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYwNzIzMw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r452607233", "bodyText": "computeIfPresent is to change the mapping.  Here, the mapping does not change, but the mapping's value's field get changed.", "author": "kaituo", "createdAt": "2020-07-10T03:47:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ5MjA5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ5MjQxMA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r452492410", "bodyText": "minor. computeIfAbsent is more concise.", "author": "wnbts", "createdAt": "2020-07-09T21:11:20Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/TransportStateManager.java", "diffHunk": "@@ -130,7 +131,13 @@ public void getAnomalyDetector(String adID, ActionListener<Optional<AnomalyDetec\n             ) {\n                 ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n                 AnomalyDetector detector = AnomalyDetector.parse(parser, response.getId());\n-                currentDetectors.put(adID, new SimpleEntry<>(detector, clock.instant()));\n+                TransportState state = transportStates.get(adID);", "originalCommit": "c0cf04f5f4470b503bad983ce114685269f93906", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYwNzY2NA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r452607664", "bodyText": "changed", "author": "kaituo", "createdAt": "2020-07-10T03:49:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ5MjQxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ5MzU0NQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r452493545", "bodyText": "minor. this seems more no_error.", "author": "wnbts", "createdAt": "2020-07-09T21:13:37Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/TransportStateManager.java", "diffHunk": "@@ -204,4 +237,29 @@ public void resetBackpressureCounter(String nodeId) {\n     public boolean hasRunningQuery(AnomalyDetector detector) {\n         return clientUtil.hasRunningQuery(detector);\n     }\n+\n+    /**\n+     * Get last error of a detector\n+     * @param adID detector id\n+     * @return last error for the detector\n+     */\n+    public String getLastError(String adID) {\n+        if (transportStates.containsKey(adID) && transportStates.get(adID).getLastError() != null) {\n+            Entry<String, Instant> errorAndTime = transportStates.get(adID).getLastError();\n+            errorAndTime.setValue(clock.instant());\n+            return errorAndTime.getKey();\n+        }\n+\n+        return IMPOSSIBLE_ERROR;", "originalCommit": "c0cf04f5f4470b503bad983ce114685269f93906", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYwNzk0Mg==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r452607942", "bodyText": "changed", "author": "kaituo", "createdAt": "2020-07-10T03:50:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ5MzU0NQ=="}], "type": "inlineReview"}, {"oid": "c56889d5a3982cbb736ebc1658e70e49c6e5d5c3", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/c56889d5a3982cbb736ebc1658e70e49c6e5d5c3", "message": "Use computeIfPresent to refactor code", "committedDate": "2020-07-10T16:49:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA3Mzg5MQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r453073891", "bodyText": "Should we update error to record the latest error time if the error message is the same?", "author": "ylwu-amzn", "createdAt": "2020-07-10T20:57:50Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/handler/DetectorStateHandler.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad.transport.handler;\n+\n+import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.function.BooleanSupplier;\n+import java.util.function.Consumer;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.indices.create.CreateIndexResponse;\n+import org.elasticsearch.action.get.GetRequest;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.LoggingDeprecationHandler;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.index.IndexNotFoundException;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import com.amazon.opendistroforelasticsearch.ad.model.DetectorInternalState;\n+import com.amazon.opendistroforelasticsearch.ad.transport.TransportStateManager;\n+import com.amazon.opendistroforelasticsearch.ad.util.ClientUtil;\n+import com.amazon.opendistroforelasticsearch.ad.util.IndexUtils;\n+import com.google.common.base.Objects;\n+\n+public class DetectorStateHandler extends AnomalyIndexHandler<DetectorInternalState> {\n+    interface GetStateStrategy {\n+        /**\n+         * Strategy to create new state to save.  Return null if state does not change and don't need to save.\n+         * @param state old state\n+         * @return new state or null if state does not change\n+         */\n+        DetectorInternalState createNewState(DetectorInternalState state);\n+    }\n+\n+    class ErrorStrategy implements GetStateStrategy {\n+        private String error;\n+\n+        ErrorStrategy(String error) {\n+            this.error = error;\n+        }\n+\n+        @Override\n+        public DetectorInternalState createNewState(DetectorInternalState state) {\n+            DetectorInternalState newState = null;\n+            if (state == null) {\n+                newState = new DetectorInternalState.Builder().error(error).lastUpdateTime(Instant.now()).build();\n+            } else if (!Objects.equal(state.getError(), error)) {\n+                newState = (DetectorInternalState) state.clone();\n+                newState.setError(error);\n+                newState.setLastUpdateTime(Instant.now());\n+            }\n+\n+            return newState;\n+        }\n+    }\n+\n+    private static final Logger LOG = LogManager.getLogger(DetectorStateHandler.class);\n+    private NamedXContentRegistry xContentRegistry;\n+    private TransportStateManager adStateManager;\n+\n+    public DetectorStateHandler(\n+        Client client,\n+        Settings settings,\n+        ThreadPool threadPool,\n+        Consumer<ActionListener<CreateIndexResponse>> createIndex,\n+        BooleanSupplier indexExists,\n+        ClientUtil clientUtil,\n+        IndexUtils indexUtils,\n+        ClusterService clusterService,\n+        NamedXContentRegistry xContentRegistry,\n+        TransportStateManager adStateManager\n+    ) {\n+        super(\n+            client,\n+            settings,\n+            threadPool,\n+            DetectorInternalState.DETECTOR_STATE_INDEX,\n+            createIndex,\n+            indexExists,\n+            true,\n+            clientUtil,\n+            indexUtils,\n+            clusterService\n+        );\n+        this.xContentRegistry = xContentRegistry;\n+        this.adStateManager = adStateManager;\n+    }\n+\n+    public void saveError(String error, String detectorId) {\n+        // trigger indexing if no error recorded (e.g., this detector got enabled just now)\n+        // or the recorded error is different than this one.", "originalCommit": "c56889d5a3982cbb736ebc1658e70e49c6e5d5c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzEyNjcxNA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r453126714", "bodyText": "We need last update time to know if the error is recorded before or after enabled time.  Current code path can handle that.  So we don't need to record the latest error time if the error message is the same.", "author": "kaituo", "createdAt": "2020-07-11T00:02:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA3Mzg5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzEyODcyNQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r453128725", "bodyText": "Minor, how about rename  the json file as \"anomaly-detection-state.json\"? In AD workbench, we will introduce detection task, plan to put task execution state in this index \".opendistro-anomaly-detection-state\", will add more fields when design done.\nBTW, how about we rename ANOMALY_DETECTOR_STATE_INDEX_MAPPING_FILE as ANOMALY_DETECTION_STATE_INDEX_MAPPING_FILE, similar to ANOMALY_DETECTOR_STATE_INDEX.", "author": "ylwu-amzn", "createdAt": "2020-07-11T00:14:55Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/settings/AnomalyDetectorSettings.java", "diffHunk": "@@ -141,6 +141,7 @@ private AnomalyDetectorSettings() {}\n     public static final String ANOMALY_DETECTORS_INDEX_MAPPING_FILE = \"mappings/anomaly-detectors.json\";\n     public static final String ANOMALY_DETECTOR_JOBS_INDEX_MAPPING_FILE = \"mappings/anomaly-detector-jobs.json\";\n     public static final String ANOMALY_RESULTS_INDEX_MAPPING_FILE = \"mappings/anomaly-results.json\";\n+    public static final String ANOMALY_DETECTOR_STATE_INDEX_MAPPING_FILE = \"mappings/anomaly-state.json\";", "originalCommit": "c56889d5a3982cbb736ebc1658e70e49c6e5d5c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzEzMjcxMA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r453132710", "bodyText": "changed both", "author": "kaituo", "createdAt": "2020-07-11T00:41:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzEyODcyNQ=="}], "type": "inlineReview"}, {"oid": "4d6b5880ede89a998f1834d86ed4d2ec2d39ed13", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/4d6b5880ede89a998f1834d86ed4d2ec2d39ed13", "message": "Rename variables", "committedDate": "2020-07-13T23:34:18Z", "type": "commit"}, {"oid": "9285cd7bf708f2daaff6e072d8542dc3b359abfe", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/9285cd7bf708f2daaff6e072d8542dc3b359abfe", "message": "Reorder import", "committedDate": "2020-07-13T23:54:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDAyMjIwMg==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r454022202", "bodyText": "minor, should we rename setDetectorStateHandler  as setDetectionStateHandler  ? Same question for other ...detectorState...", "author": "ylwu-amzn", "createdAt": "2020-07-14T00:18:56Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/AnomalyDetectorJobRunner.java", "diffHunk": "@@ -119,6 +121,10 @@ public void setSettings(Settings settings) {\n         this.maxRetryForEndRunException = AnomalyDetectorSettings.MAX_RETRY_FOR_END_RUN_EXCEPTION.get(settings);\n     }\n \n+    public void setDetectorStateHandler(DetectorStateHandler detectorStateHandler) {", "originalCommit": "9285cd7bf708f2daaff6e072d8542dc3b359abfe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDAzODE0NQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/164#discussion_r454038145", "bodyText": "renamed", "author": "kaituo", "createdAt": "2020-07-14T01:10:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDAyMjIwMg=="}], "type": "inlineReview"}, {"oid": "66d772f494636e79c0c3bdfa69d25870da37cea1", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/66d772f494636e79c0c3bdfa69d25870da37cea1", "message": "Rename variables", "committedDate": "2020-07-14T01:09:37Z", "type": "commit"}]}