{"pr_number": 298, "pr_title": "Improve profile API", "pr_createdAt": "2020-10-29T19:04:01Z", "pr_url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/298", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDgwMjQ1Mw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/298#discussion_r514802453", "bodyText": "minor: can we combine these 2 if into single one?", "author": "yizheliu-amazon", "createdAt": "2020-10-30T03:53:26Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/AnomalyDetectorProfileRunner.java", "diffHunk": "@@ -70,82 +71,112 @@\n import com.amazon.opendistroforelasticsearch.ad.util.ExceptionUtil;\n import com.amazon.opendistroforelasticsearch.ad.util.MultiResponsesDelegateActionListener;\n \n-public class AnomalyDetectorProfileRunner {\n+public class AnomalyDetectorProfileRunner extends AbstractProfileRunner {\n     private final Logger logger = LogManager.getLogger(AnomalyDetectorProfileRunner.class);\n     private Client client;\n     private NamedXContentRegistry xContentRegistry;\n     private DiscoveryNodeFilterer nodeFilter;\n-    static String FAIL_TO_FIND_DETECTOR_MSG = \"Fail to find detector with id: \";\n-    static String FAIL_TO_GET_PROFILE_MSG = \"Fail to get profile for detector \";\n-    static String FAIL_TO_GET_TOTAL_ENTITIES = \"Failed to get total entities for detector \";\n-    private long requiredSamples;\n \n     public AnomalyDetectorProfileRunner(\n         Client client,\n         NamedXContentRegistry xContentRegistry,\n         DiscoveryNodeFilterer nodeFilter,\n         long requiredSamples\n     ) {\n+        super(requiredSamples);\n         this.client = client;\n         this.xContentRegistry = xContentRegistry;\n         this.nodeFilter = nodeFilter;\n         if (requiredSamples <= 0) {\n             throw new IllegalArgumentException(\"required samples should be a positive number, but was \" + requiredSamples);\n         }\n-        this.requiredSamples = requiredSamples;\n     }\n \n-    public void profile(String detectorId, ActionListener<DetectorProfile> listener, Set<ProfileName> profilesToCollect) {\n+    public void profile(String detectorId, ActionListener<DetectorProfile> listener, Set<DetectorProfileName> profilesToCollect) {\n \n         if (profilesToCollect.isEmpty()) {\n             listener.onFailure(new RuntimeException(\"Unsupported profile types.\"));\n             return;\n         }\n \n-        // total number of listeners we need to define. Needed by MultiResponsesDelegateActionListener to decide when to consolidate results\n-        // and return to users\n-        int totalListener = 0;\n-\n-        if (profilesToCollect.contains(ProfileName.STATE)) {\n-            totalListener++;\n-        }\n-\n-        if (profilesToCollect.contains(ProfileName.ERROR)) {\n-            totalListener++;\n-        }\n+        calculateTotalResponsesToWait(detectorId, profilesToCollect, listener);\n+    }\n \n-        if (profilesToCollect.contains(ProfileName.INIT_PROGRESS)) {\n-            totalListener++;\n-        }\n+    private void calculateTotalResponsesToWait(\n+        String detectorId,\n+        Set<DetectorProfileName> profilesToCollect,\n+        ActionListener<DetectorProfile> listener\n+    ) {\n+        GetRequest getDetectorRequest = new GetRequest(ANOMALY_DETECTORS_INDEX, detectorId);\n+        client.get(getDetectorRequest, ActionListener.wrap(getDetectorResponse -> {\n+            if (getDetectorResponse != null && getDetectorResponse.isExists()) {\n+                try (\n+                    XContentParser xContentParser = XContentType.JSON\n+                        .xContent()\n+                        .createParser(xContentRegistry, LoggingDeprecationHandler.INSTANCE, getDetectorResponse.getSourceAsString())\n+                ) {\n+                    ensureExpectedToken(XContentParser.Token.START_OBJECT, xContentParser.nextToken(), xContentParser::getTokenLocation);\n+                    AnomalyDetector detector = AnomalyDetector.parse(xContentParser, detectorId);\n+                    boolean isMultiEntityDetector = detector.isMultientityDetector();\n \n-        if (profilesToCollect.contains(ProfileName.COORDINATING_NODE)\n-            || profilesToCollect.contains(ProfileName.SHINGLE_SIZE)\n-            || profilesToCollect.contains(ProfileName.TOTAL_SIZE_IN_BYTES)\n-            || profilesToCollect.contains(ProfileName.MODELS)\n-            || profilesToCollect.contains(ProfileName.ACTIVE_ENTITIES)) {\n-            totalListener++;\n-        }\n+                    int totalResponsesToWait = 0;\n \n-        if (profilesToCollect.contains(ProfileName.TOTAL_ENTITIES)) {\n-            totalListener++;\n-        }\n+                    if (profilesToCollect.contains(DetectorProfileName.ERROR)) {\n+                        totalResponsesToWait++;\n+                    }\n \n-        MultiResponsesDelegateActionListener<DetectorProfile> delegateListener = new MultiResponsesDelegateActionListener<DetectorProfile>(\n-            listener,\n-            totalListener,\n-            \"Fail to fetch profile for \" + detectorId,\n-            false\n-        );\n+                    // total number of listeners we need to define. Needed by MultiResponsesDelegateActionListener to decide\n+                    // when to consolidate results and return to users\n+                    if (isMultiEntityDetector) {\n+                        if (profilesToCollect.contains(DetectorProfileName.TOTAL_ENTITIES)) {\n+                            totalResponsesToWait++;\n+                        }\n+                        if (profilesToCollect.contains(DetectorProfileName.COORDINATING_NODE)\n+                            || profilesToCollect.contains(DetectorProfileName.SHINGLE_SIZE)\n+                            || profilesToCollect.contains(DetectorProfileName.TOTAL_SIZE_IN_BYTES)\n+                            || profilesToCollect.contains(DetectorProfileName.MODELS)\n+                            || profilesToCollect.contains(DetectorProfileName.ACTIVE_ENTITIES)\n+                            || profilesToCollect.contains(DetectorProfileName.INIT_PROGRESS)\n+                            || profilesToCollect.contains(DetectorProfileName.STATE)) {\n+                            totalResponsesToWait++;\n+                        }", "originalCommit": "52400f8ed60f6717d4ebcd91d592b51ea8d2eb6d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDgzNzg2MQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/298#discussion_r514837861", "bodyText": "I separate them on purpose.  Each group will cost MultiResponsesDelegateActionListener one response.", "author": "kaituo", "createdAt": "2020-10-30T04:31:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDgwMjQ1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDgxMjMzMw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/298#discussion_r514812333", "bodyText": "just name it getLastActiveModels", "author": "yizheliu-amazon", "createdAt": "2020-10-30T04:03:45Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/caching/EntityCache.java", "diffHunk": "@@ -81,4 +83,19 @@\n      * @return list of modelStates\n      */\n     List<ModelState<?>> getAllModels();\n+\n+    /**\n+     * Return when the last active time of an entity's state.\n+     *\n+     * If the entity's state is active in the cache, the value indicates when the cache\n+     * is lastly accessed (get/put).  If the entity's state is inactive in the cache,\n+     * the value indicates when the cache state is created or when the entity is evicted\n+     * from active entity cache.\n+     *\n+     * @param detectorId The Id of the detector that an entity belongs to\n+     * @param entityModelId Entity's Model Id\n+     * @return if the entity is in the cache, return the timestamp in epoch\n+     * milliseconds when the entity's state is lastly used.  Otherwise, return -1.\n+     */\n+    long getLastActiveMs(String detectorId, String entityModelId);", "originalCommit": "52400f8ed60f6717d4ebcd91d592b51ea8d2eb6d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDgzODkxMQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/298#discussion_r514838911", "bodyText": "For \"Ms\", I meant milliseconds.  Please see https://en.wikipedia.org/wiki/Millisecond.", "author": "kaituo", "createdAt": "2020-10-30T04:32:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDgxMjMzMw=="}], "type": "inlineReview"}, {"oid": "b43af49703df31b4e723a726fdf9744145f47f97", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/b43af49703df31b4e723a726fdf9744145f47f97", "message": "Improve profile API\n\nThis PR did various things to improve profile API:\nFirst, the PR fixed the hang issue. Previously, when users run _profile/state or _profile on the multi-entity detector, the request hangs. The problem is due to incorrect maxResponseCount passed to MultiResponsesDelegateActionListener.\nSecond, the PR fixes the multi-entity detector's wrong state issue. Previously, we can show the init state after an anomaly has shown up. We may have the problem because we read the most active entity's init progress in the cache for a detector's init_progress. But the entity already produced anomaly has been evicted out of the cache. This PR fixes the issue by double-checking the result index's non-zero RCF score for a multi-entity detector before reporting the init state. If there is any non-zero RCF score, we say running state instead of the initing state.\nThird, this PR adds more information to the entity level profile, including last_active_timestamp, last_sample_timestamp, init_progress, model, and state.\nFourth, this PR adds models and total_size_in_bytes to the multi-entity detector level profile.\n\nThis PR also fixes various \"fail to return\" issues in the rest API related transport action. We didn't return after sending channel responses. Later, when we use the channel to send back responses again, we get \" java.lang.IllegalStateException: Channel is already closed.\"\n\nTesting done:\n1. manual testing passes.\n2. actively adding unit tests", "committedDate": "2020-10-30T04:42:46Z", "type": "commit"}, {"oid": "b43af49703df31b4e723a726fdf9744145f47f97", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/b43af49703df31b4e723a726fdf9744145f47f97", "message": "Improve profile API\n\nThis PR did various things to improve profile API:\nFirst, the PR fixed the hang issue. Previously, when users run _profile/state or _profile on the multi-entity detector, the request hangs. The problem is due to incorrect maxResponseCount passed to MultiResponsesDelegateActionListener.\nSecond, the PR fixes the multi-entity detector's wrong state issue. Previously, we can show the init state after an anomaly has shown up. We may have the problem because we read the most active entity's init progress in the cache for a detector's init_progress. But the entity already produced anomaly has been evicted out of the cache. This PR fixes the issue by double-checking the result index's non-zero RCF score for a multi-entity detector before reporting the init state. If there is any non-zero RCF score, we say running state instead of the initing state.\nThird, this PR adds more information to the entity level profile, including last_active_timestamp, last_sample_timestamp, init_progress, model, and state.\nFourth, this PR adds models and total_size_in_bytes to the multi-entity detector level profile.\n\nThis PR also fixes various \"fail to return\" issues in the rest API related transport action. We didn't return after sending channel responses. Later, when we use the channel to send back responses again, we get \" java.lang.IllegalStateException: Channel is already closed.\"\n\nTesting done:\n1. manual testing passes.\n2. actively adding unit tests", "committedDate": "2020-10-30T04:42:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDg4MTg1Mw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/298#discussion_r514881853", "bodyText": "If a running detector stopped, then restart but not pass initialization yet. We can find anomaly results with anomaly score > 0 as the detector was running before. We can't tell the detector is at running status exactly for this case.", "author": "ylwu-amzn", "createdAt": "2020-10-30T05:39:12Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/AnomalyDetectorProfileRunner.java", "diffHunk": "@@ -409,76 +358,126 @@ private void profileStateRelated(\n         });\n     }\n \n-    private InitProgressProfile computeInitProgressProfile(long totalUpdates, long intervalMins) {\n-        float percent = Math.min((100.0f * totalUpdates) / requiredSamples, 100.0f);\n-        int neededPoints = (int) (requiredSamples - totalUpdates);\n-        return new InitProgressProfile(\n-            // rounding: 93.456 => 93%, 93.556 => 94%\n-            String.format(\"%.0f%%\", percent),\n-            intervalMins * neededPoints,\n-            neededPoints\n-        );\n-    }\n-\n     private void profileModels(\n         AnomalyDetector detector,\n-        Set<ProfileName> profiles,\n-        boolean enabled,\n+        Set<DetectorProfileName> profiles,\n+        AnomalyDetectorJob job,\n+        boolean forMultiEntityDetector,\n         MultiResponsesDelegateActionListener<DetectorProfile> listener\n     ) {\n         DiscoveryNode[] dataNodes = nodeFilter.getEligibleDataNodes();\n-        ProfileRequest profileRequest = new ProfileRequest(detector.getDetectorId(), profiles, dataNodes);\n-        client.execute(ProfileAction.INSTANCE, profileRequest, onModelResponse(detector, profiles, enabled, listener));\n-    }\n-\n-    private boolean isHCDetector(AnomalyDetector detector) {\n-        return detector != null && detector.getCategoryField() != null && detector.getCategoryField().size() > 0;\n+        ProfileRequest profileRequest = new ProfileRequest(detector.getDetectorId(), profiles, forMultiEntityDetector, dataNodes);\n+        client.execute(ProfileAction.INSTANCE, profileRequest, onModelResponse(detector, profiles, job, listener));\n     }\n \n     private ActionListener<ProfileResponse> onModelResponse(\n         AnomalyDetector detector,\n-        Set<ProfileName> profiles,\n-        boolean enabled,\n+        Set<DetectorProfileName> profilesToCollect,\n+        AnomalyDetectorJob job,\n         MultiResponsesDelegateActionListener<DetectorProfile> listener\n     ) {\n-        boolean isHCDetector = isHCDetector(detector);\n+        boolean isMultientityDetector = detector.isMultientityDetector();\n         return ActionListener.wrap(profileResponse -> {\n             DetectorProfile.Builder profile = new DetectorProfile.Builder();\n-            if (profiles.contains(ProfileName.COORDINATING_NODE)) {\n+            if (profilesToCollect.contains(DetectorProfileName.COORDINATING_NODE)) {\n                 profile.coordinatingNode(profileResponse.getCoordinatingNode());\n             }\n-            if (profiles.contains(ProfileName.SHINGLE_SIZE)) {\n+            if (profilesToCollect.contains(DetectorProfileName.SHINGLE_SIZE)) {\n                 profile.shingleSize(profileResponse.getShingleSize());\n             }\n-            if (profiles.contains(ProfileName.TOTAL_SIZE_IN_BYTES)) {\n+            if (profilesToCollect.contains(DetectorProfileName.TOTAL_SIZE_IN_BYTES)) {\n                 profile.totalSizeInBytes(profileResponse.getTotalSizeInBytes());\n             }\n-            if (profiles.contains(ProfileName.MODELS)) {\n+            if (profilesToCollect.contains(DetectorProfileName.MODELS)) {\n                 profile.modelProfile(profileResponse.getModelProfile());\n             }\n-            if (isHCDetector && profiles.contains(ProfileName.ACTIVE_ENTITIES)) {\n+            if (isMultientityDetector && profilesToCollect.contains(DetectorProfileName.ACTIVE_ENTITIES)) {\n                 profile.activeEntities(profileResponse.getActiveEntities());\n             }\n-            if (isHCDetector && profiles.contains(ProfileName.INIT_PROGRESS)) {\n-                long totalUpdates = profileResponse.getTotalUpdates();\n-                long intervalMins = totalUpdates == 0\n-                    ? 0\n-                    : ((IntervalTimeConfiguration) detector.getDetectionInterval()).toDuration().toMinutes();\n-                InitProgressProfile initProgress = computeInitProgressProfile(totalUpdates, intervalMins);\n-                profile.initProgress(initProgress);\n+\n+            if (isMultientityDetector\n+                && (profilesToCollect.contains(DetectorProfileName.INIT_PROGRESS)\n+                    || profilesToCollect.contains(DetectorProfileName.STATE))) {\n+                profileMultiEntityDetectorStateRelated(job, profilesToCollect, profileResponse, profile, detector, listener);\n+            } else {\n+                listener.onResponse(profile.build());\n             }\n-            if (isHCDetector && profiles.contains(ProfileName.STATE)) {\n-                DetectorState state;\n-                if (enabled) {\n-                    state = profileResponse.getTotalUpdates() < requiredSamples ? DetectorState.INIT : DetectorState.RUNNING;\n-                } else {\n-                    state = DetectorState.DISABLED;\n-                }\n-                listener.onResponse(new DetectorProfile.Builder().state(state).build());\n+        }, listener::onFailure);\n+    }\n+\n+    private void profileMultiEntityDetectorStateRelated(\n+        AnomalyDetectorJob job,\n+        Set<DetectorProfileName> profilesToCollect,\n+        ProfileResponse profileResponse,\n+        DetectorProfile.Builder profileBuilder,\n+        AnomalyDetector detector,\n+        MultiResponsesDelegateActionListener<DetectorProfile> listener\n+    ) {\n+        if (job.isEnabled()) {\n+            if (profileResponse.getTotalUpdates() < requiredSamples) {\n+                // need to double check since what ProfileResponse returns is the highest priority entity currently in memory, but\n+                // another entity might have already been initialized and sit somewhere else (in memory or on disk).\n+                confirmMultiEntityDetectorInitStatus(\n+                    detector,\n+                    job.getEnabledTime().toEpochMilli(),\n+                    profileBuilder,\n+                    profilesToCollect,\n+                    profileResponse.getTotalUpdates(),\n+                    listener\n+                );\n+            } else {\n+                createRunningStateAndInitProgress(profilesToCollect, profileBuilder);\n+                listener.onResponse(profileBuilder.build());\n+            }\n+        } else {\n+            if (profilesToCollect.contains(DetectorProfileName.STATE)) {\n+                profileBuilder.state(DetectorState.DISABLED);\n             }\n+            listener.onResponse(profileBuilder.build());\n+        }\n+    }\n \n-            listener.onResponse(profile.build());\n-        }, listener::onFailure);\n+    private void confirmMultiEntityDetectorInitStatus(\n+        AnomalyDetector detector,\n+        long enabledTime,\n+        DetectorProfile.Builder profile,\n+        Set<DetectorProfileName> profilesToCollect,\n+        long totalUpdates,\n+        MultiResponsesDelegateActionListener<DetectorProfile> listener\n+    ) {\n+        SearchRequest searchLatestResult = createInittedEverRequest(detector.getDetectorId(), enabledTime);\n+        client.search(searchLatestResult, onInittedEver(enabledTime, profile, profilesToCollect, detector, totalUpdates, listener));\n+    }\n+\n+    private ActionListener<SearchResponse> onInittedEver(\n+        long lastUpdateTimeMs,\n+        DetectorProfile.Builder profileBuilder,\n+        Set<DetectorProfileName> profilesToCollect,\n+        AnomalyDetector detector,\n+        long totalUpdates,\n+        MultiResponsesDelegateActionListener<DetectorProfile> listener\n+    ) {\n+        return ActionListener.wrap(searchResponse -> {\n+            SearchHits hits = searchResponse.getHits();\n+            if (hits.getTotalHits().value == 0L) {\n+                processInitResponse(detector, profilesToCollect, totalUpdates, false, profileBuilder, listener);\n+            } else {\n+                createRunningStateAndInitProgress(profilesToCollect, profileBuilder);", "originalCommit": "b43af49703df31b4e723a726fdf9744145f47f97", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDg4NjAyNw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/298#discussion_r514886027", "bodyText": "I am searching records older than the job's enabled time.  Does that cover the issue you mentioned?", "author": "kaituo", "createdAt": "2020-10-30T05:55:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDg4MTg1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDg5MjA0OQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/298#discussion_r514892049", "bodyText": "Cool, make sense.", "author": "ylwu-amzn", "createdAt": "2020-10-30T06:18:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDg4MTg1Mw=="}], "type": "inlineReview"}]}