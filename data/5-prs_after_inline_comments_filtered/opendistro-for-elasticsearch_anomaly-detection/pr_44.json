{"pr_number": 44, "pr_title": "add AD job on top of JobScheduler", "pr_createdAt": "2020-02-20T06:50:09Z", "pr_url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/44", "timeline": [{"oid": "0a03eeea44c332c3a5337420022b0f372e80ad80", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/0a03eeea44c332c3a5337420022b0f372e80ad80", "message": "add AD job on top of JobScheduler", "committedDate": "2020-02-20T06:41:58Z", "type": "commit"}, {"oid": "0ad539154b87212be6c64d5a9ea80f3f8d95b3ab", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/0ad539154b87212be6c64d5a9ea80f3f8d95b3ab", "message": "release job lock when job finish or fail", "committedDate": "2020-02-20T20:57:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM0OTg4Mg==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/44#discussion_r382349882", "bodyText": "You need to send channel response", "author": "kaituo", "createdAt": "2020-02-21T01:20:23Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/rest/handler/IndexAnomalyDetectorJobActionHandler.java", "diffHunk": "@@ -0,0 +1,332 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad.rest.handler;\n+\n+import com.amazon.opendistroforelasticsearch.ad.AnomalyDetectorPlugin;\n+import com.amazon.opendistroforelasticsearch.ad.indices.AnomalyDetectionIndices;\n+import com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetector;\n+import com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetectorJob;\n+import com.amazon.opendistroforelasticsearch.ad.model.IntervalTimeConfiguration;\n+import com.amazon.opendistroforelasticsearch.ad.transport.StopDetectorAction;\n+import com.amazon.opendistroforelasticsearch.ad.transport.StopDetectorRequest;\n+import com.amazon.opendistroforelasticsearch.ad.transport.StopDetectorResponse;\n+import com.amazon.opendistroforelasticsearch.ad.util.RestHandlerUtils;\n+import com.amazon.opendistroforelasticsearch.jobscheduler.spi.schedule.IntervalSchedule;\n+import com.amazon.opendistroforelasticsearch.jobscheduler.spi.schedule.Schedule;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.indices.create.CreateIndexResponse;\n+import org.elasticsearch.action.delete.DeleteRequest;\n+import org.elasticsearch.action.get.GetRequest;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.index.IndexRequest;\n+import org.elasticsearch.action.index.IndexResponse;\n+import org.elasticsearch.action.support.WriteRequest;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.common.xcontent.LoggingDeprecationHandler;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.rest.BytesRestResponse;\n+import org.elasticsearch.rest.RestChannel;\n+import org.elasticsearch.rest.RestResponse;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.rest.action.RestResponseListener;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Locale;\n+\n+import static com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetector.ANOMALY_DETECTORS_INDEX;\n+import static com.amazon.opendistroforelasticsearch.ad.settings.AnomalyDetectorSettings.MAX_ANOMALY_DETECTORS;\n+import static com.amazon.opendistroforelasticsearch.ad.settings.AnomalyDetectorSettings.MAX_ANOMALY_FEATURES;\n+import static com.amazon.opendistroforelasticsearch.ad.util.RestHandlerUtils.XCONTENT_WITH_TYPE;\n+import static org.elasticsearch.common.xcontent.ToXContent.EMPTY_PARAMS;\n+import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;\n+\n+/**\n+ * Anomaly detector job REST action handler to process POST/PUT request.\n+ */\n+public class IndexAnomalyDetectorJobActionHandler extends AbstractActionHandler {\n+\n+    private final AnomalyDetectionIndices anomalyDetectionIndices;\n+    private final String detectorId;\n+    private final Long seqNo;\n+    private final Long primaryTerm;\n+    private final WriteRequest.RefreshPolicy refreshPolicy;\n+    private final ClusterService clusterService;\n+\n+    private final Logger logger = LogManager.getLogger(IndexAnomalyDetectorJobActionHandler.class);\n+    private final TimeValue requestTimeout;\n+    private volatile Integer maxAnomalyDetectors;\n+    private volatile Integer maxAnomalyFeatures;\n+    private final AnomalyDetectorActionHandler handler = new AnomalyDetectorActionHandler();\n+\n+    /**\n+     * Constructor function.\n+     *\n+     * @param settings                ES settings\n+     * @param clusterService          ClusterService\n+     * @param client                  ES node client that executes actions on the local node\n+     * @param channel                 ES channel used to construct bytes / builder based outputs, and send responses\n+     * @param anomalyDetectionIndices anomaly detector index manager\n+     * @param detectorId              detector identifier\n+     * @param seqNo                   sequence number of last modification\n+     * @param primaryTerm             primary term of last modification\n+     * @param refreshPolicy           refresh policy\n+     * @param requestTimeout          request time out configuration\n+     */\n+    public IndexAnomalyDetectorJobActionHandler(\n+        Settings settings,\n+        ClusterService clusterService,\n+        NodeClient client,\n+        RestChannel channel,\n+        AnomalyDetectionIndices anomalyDetectionIndices,\n+        String detectorId,\n+        Long seqNo,\n+        Long primaryTerm,\n+        WriteRequest.RefreshPolicy refreshPolicy,\n+        TimeValue requestTimeout\n+    ) {\n+        super(client, channel);\n+        this.clusterService = clusterService;\n+        this.anomalyDetectionIndices = anomalyDetectionIndices;\n+        this.detectorId = detectorId;\n+        this.seqNo = seqNo;\n+        this.primaryTerm = primaryTerm;\n+        this.refreshPolicy = refreshPolicy;\n+        this.requestTimeout = requestTimeout;\n+        maxAnomalyDetectors = MAX_ANOMALY_DETECTORS.get(settings);\n+        maxAnomalyFeatures = MAX_ANOMALY_FEATURES.get(settings);\n+        clusterService.getClusterSettings().addSettingsUpdateConsumer(MAX_ANOMALY_DETECTORS, it -> maxAnomalyDetectors = it);\n+        clusterService.getClusterSettings().addSettingsUpdateConsumer(MAX_ANOMALY_FEATURES, it -> maxAnomalyFeatures = it);\n+    }\n+\n+    /**\n+     * Start function to process create/update anomaly detector job request.\n+     * Check if anomaly detector job index exist first, if not, will create first.\n+     *\n+     * @throws IOException IOException from {@link AnomalyDetectionIndices#initAnomalyDetectorIndexIfAbsent(ActionListener)}\n+     */\n+    public void start() throws IOException {\n+        if (!anomalyDetectionIndices.doesAnomalyDetectorJobIndexExist()) {\n+            anomalyDetectionIndices\n+                .initAnomalyDetectorIndex(\n+                    ActionListener.wrap(response -> onCreateMappingsResponse(response), exception -> onFailure(exception))\n+                );\n+        } else {\n+            prepareAnomalyDetectorJobIndexing();\n+        }\n+    }\n+\n+    /**\n+     * Create anomaly detector job.\n+     *\n+     * @throws IOException IOException from {@link AnomalyDetectionIndices#getAnomalyDetectorJobMappings}\n+     */\n+    public void createAnomalyDetectorJob() throws IOException {\n+        if (!anomalyDetectionIndices.doesAnomalyDetectorJobIndexExist()) {\n+            anomalyDetectionIndices\n+                .initAnomalyDetectorJobIndex(\n+                    ActionListener.wrap(response -> onCreateMappingsResponse(response), exception -> onFailure(exception))\n+                );\n+        } else {\n+            prepareAnomalyDetectorJobIndexing();\n+        }\n+    }\n+\n+    private void prepareAnomalyDetectorJobIndexing() {\n+        GetRequest getRequest = new GetRequest(AnomalyDetector.ANOMALY_DETECTORS_INDEX).id(detectorId);\n+        client.get(getRequest, ActionListener.wrap(response -> onGetAnomalyDetectorResponse(response), exception -> onFailure(exception)));\n+    }\n+\n+    private void onGetAnomalyDetectorResponse(GetResponse response) throws IOException {\n+        if (!response.isExists()) {\n+            XContentBuilder builder = channel\n+                .newErrorBuilder()\n+                .startObject()\n+                .field(\"Message\", \"AnomalyDetector is not found with id: \" + detectorId)\n+                .endObject();\n+            channel.sendResponse(new BytesRestResponse(RestStatus.NOT_FOUND, response.toXContent(builder, EMPTY_PARAMS)));\n+            return;\n+        }\n+        XContentParser parser = XContentType.JSON\n+            .xContent()\n+            .createParser(\n+                channel.request().getXContentRegistry(),\n+                LoggingDeprecationHandler.INSTANCE,\n+                response.getSourceAsBytesRef().streamInput()\n+            );\n+\n+        ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+        AnomalyDetector detector = AnomalyDetector.parse(parser, response.getId(), response.getVersion());\n+\n+        IntervalTimeConfiguration interval = (IntervalTimeConfiguration) detector.getDetectionInterval();\n+        Schedule schedule = new IntervalSchedule(Instant.now(), (int) interval.getInterval(), interval.getUnit());\n+        Duration duration = Duration.of(interval.getInterval(), interval.getUnit());\n+        AnomalyDetectorJob job = new AnomalyDetectorJob(\n+            detector.getDetectorId(),\n+            schedule,\n+            true,\n+            Instant.now(),\n+            Instant.now(),\n+            duration.getSeconds()\n+        );\n+\n+        getAnomalyDetectorJob(job);\n+    }\n+\n+    private void getAnomalyDetectorJob(AnomalyDetectorJob job) {\n+        GetRequest getRequest = new GetRequest(AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX).id(detectorId);\n+\n+        client.get(getRequest, ActionListener.wrap(response -> onGetAnomalyDetectorJob(response, job), exception -> onFailure(exception)));\n+    }\n+\n+    private void onGetAnomalyDetectorJob(GetResponse response, AnomalyDetectorJob job) throws IOException {\n+        if (response.isExists()) {\n+            XContentBuilder builder = channel\n+                .newErrorBuilder()\n+                .startObject()\n+                .field(\"Message\", \"AnomalyDetectorJob exists: \" + detectorId)\n+                .endObject();\n+            channel.sendResponse(new BytesRestResponse(RestStatus.NOT_FOUND, response.toXContent(builder, EMPTY_PARAMS)));\n+            return;\n+        }\n+\n+        indexAnomalyDetectorJob(job);\n+    }\n+\n+    private void indexAnomalyDetectorJob(AnomalyDetectorJob job) throws IOException {\n+        IndexRequest indexRequest = new IndexRequest(AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX)\n+            .setRefreshPolicy(refreshPolicy)\n+            .source(job.toXContent(channel.newBuilder(), XCONTENT_WITH_TYPE))\n+            .setIfSeqNo(seqNo)\n+            .setIfPrimaryTerm(primaryTerm)\n+            .timeout(requestTimeout);\n+        if (detectorId != null) {\n+            indexRequest.id(detectorId);\n+        }\n+        client.index(indexRequest, indexAnomalyDetectorJobResponse());\n+    }\n+\n+    private ActionListener<IndexResponse> indexAnomalyDetectorJobResponse() {\n+        return new RestResponseListener<IndexResponse>(channel) {\n+            @Override\n+            public RestResponse buildResponse(IndexResponse response) throws Exception {\n+                if (response.getShardInfo().getSuccessful() < 1) {\n+                    return new BytesRestResponse(response.status(), response.toXContent(channel.newErrorBuilder(), EMPTY_PARAMS));\n+                }\n+\n+                XContentBuilder builder = channel\n+                    .newBuilder()\n+                    .startObject()\n+                    .field(RestHandlerUtils._ID, response.getId())\n+                    .field(RestHandlerUtils._VERSION, response.getVersion())\n+                    .field(RestHandlerUtils._SEQ_NO, response.getSeqNo())\n+                    .field(RestHandlerUtils._PRIMARY_TERM, response.getPrimaryTerm())\n+                    .endObject();\n+\n+                BytesRestResponse restResponse = new BytesRestResponse(response.status(), builder);\n+                if (response.status() == RestStatus.CREATED) {\n+                    String location = String.format(Locale.ROOT, \"%s/%s\", AnomalyDetectorPlugin.AD_BASE_URI, response.getId());\n+                    restResponse.addHeader(\"Location\", location);\n+                }\n+                return restResponse;\n+            }\n+        };\n+    }\n+\n+    private void onCreateMappingsResponse(CreateIndexResponse response) throws IOException {\n+        if (response.isAcknowledged()) {\n+            logger.info(\"Created {} with mappings.\", ANOMALY_DETECTORS_INDEX);\n+            prepareAnomalyDetectorJobIndexing();\n+        } else {\n+            logger.warn(\"Created {} with mappings call not acknowledged.\", ANOMALY_DETECTORS_INDEX);\n+            channel\n+                .sendResponse(\n+                    new BytesRestResponse(RestStatus.INTERNAL_SERVER_ERROR, response.toXContent(channel.newErrorBuilder(), EMPTY_PARAMS))\n+                );\n+        }\n+    }\n+\n+    /**\n+     * Delete anomaly detector job\n+     * @param detectorId detector identifier\n+     */\n+    public void deleteAnomalyDetectorJob(String detectorId) {\n+        GetRequest getRequest = new GetRequest(AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX).id(detectorId);\n+\n+        client\n+            .get(\n+                getRequest,\n+                ActionListener\n+                    .wrap(\n+                        response -> deleteAnomalyDetectorJobDoc(client, detectorId, channel, refreshPolicy),\n+                        exception -> onFailure(exception)\n+                    )\n+            );\n+    }\n+\n+    private void deleteAnomalyDetectorJobDoc(\n+        NodeClient client,\n+        String detectorId,\n+        RestChannel channel,\n+        WriteRequest.RefreshPolicy refreshPolicy\n+    ) {\n+        logger.info(\"Delete anomaly detector job {}\", detectorId);\n+        DeleteRequest deleteRequest = new DeleteRequest(AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX, detectorId)\n+            .setRefreshPolicy(refreshPolicy);\n+        client.delete(deleteRequest, ActionListener.wrap(response -> {\n+            if (\"deleted\".equals(response.getResult().getLowercase())) {\n+                logger.info(\"Stop anomaly detector {}\", detectorId);\n+                StopDetectorRequest stopDetectorRequest = new StopDetectorRequest(detectorId);\n+                client.execute(StopDetectorAction.INSTANCE, stopDetectorRequest, stopAdDetectorListener(channel, detectorId));\n+            } else {\n+                channel.sendResponse(new BytesRestResponse(RestStatus.BAD_REQUEST, \"Failed to stop AD job \" + detectorId));\n+            }\n+        }, exception -> {\n+            logger.error(\"Failed to stop AD job \" + detectorId, exception);\n+            onFailure(exception);\n+        }));\n+\n+    }\n+\n+    private ActionListener<StopDetectorResponse> stopAdDetectorListener(RestChannel channel, String detectorId) {\n+        return new ActionListener<StopDetectorResponse>() {\n+            @Override\n+            public void onResponse(StopDetectorResponse stopDetectorResponse) {\n+                if (stopDetectorResponse.success()) {\n+                    logger.info(\"AD model deleted successfully for detector {}\", detectorId);\n+                    channel.sendResponse(new BytesRestResponse(RestStatus.OK, \"Stopped detector: \" + detectorId));\n+                } else {\n+                    logger.error(\"Failed to delete AD model for detector {}\", detectorId);\n+                    channel.sendResponse(new BytesRestResponse(RestStatus.INTERNAL_SERVER_ERROR, \"Failed to delete AD model\"));\n+                }\n+            }\n+\n+            @Override\n+            public void onFailure(Exception e) {\n+                logger.error(\"Failed to delete AD model for detector \" + detectorId, e);\n+            }", "originalCommit": "0ad539154b87212be6c64d5a9ea80f3f8d95b3ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQzNjE4OQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/44#discussion_r383436189", "bodyText": "Will add it", "author": "ylwu-amzn", "createdAt": "2020-02-24T18:27:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM0OTg4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA3NDUxOQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/44#discussion_r383074519", "bodyText": "put releaseLock in finally clause so that you don't have to do it in all of the exits?", "author": "kaituo", "createdAt": "2020-02-24T03:27:38Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/AnomalyDetectorJobRunner.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad;\n+\n+import com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetectorJob;\n+import com.amazon.opendistroforelasticsearch.ad.transport.AnomalyResultAction;\n+import com.amazon.opendistroforelasticsearch.ad.transport.AnomalyResultRequest;\n+import com.amazon.opendistroforelasticsearch.jobscheduler.spi.JobExecutionContext;\n+import com.amazon.opendistroforelasticsearch.jobscheduler.spi.LockModel;\n+import com.amazon.opendistroforelasticsearch.jobscheduler.spi.ScheduledJobParameter;\n+import com.amazon.opendistroforelasticsearch.jobscheduler.spi.ScheduledJobRunner;\n+import com.amazon.opendistroforelasticsearch.jobscheduler.spi.schedule.IntervalSchedule;\n+import com.amazon.opendistroforelasticsearch.jobscheduler.spi.utils.LockService;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.concurrent.ExecutorService;\n+\n+import static com.amazon.opendistroforelasticsearch.ad.AnomalyDetectorPlugin.AD_JOB_THREAD_POOL_NAME;\n+\n+/**\n+ * JobScheduler will call AD job runner to get anomaly result periodically\n+ */\n+public class AnomalyDetectorJobRunner implements ScheduledJobRunner {\n+    private static final Logger log = LogManager.getLogger(AnomalyDetectorJobRunner.class);\n+\n+    private static AnomalyDetectorJobRunner INSTANCE;\n+\n+    public static AnomalyDetectorJobRunner getJobRunnerInstance() {\n+        if (INSTANCE != null) {\n+            return INSTANCE;\n+        }\n+        synchronized (AnomalyDetectorJobRunner.class) {\n+            if (INSTANCE != null) {\n+                return INSTANCE;\n+            }\n+            INSTANCE = new AnomalyDetectorJobRunner();\n+            return INSTANCE;\n+        }\n+    }\n+\n+    private Client client;\n+    private ThreadPool threadPool;\n+\n+    private AnomalyDetectorJobRunner() {\n+        // Singleton class, use getJobRunnerInstance method instead of constructor\n+    }\n+\n+    public void setClient(Client client) {\n+        this.client = client;\n+    }\n+\n+    public void setThreadPool(ThreadPool threadPool) {\n+        this.threadPool = threadPool;\n+    }\n+\n+    @Override\n+    public void runJob(ScheduledJobParameter jobParameter, JobExecutionContext context) {\n+        log.info(\"Start to run AD job {}\", jobParameter.getName());\n+        if (!(jobParameter instanceof AnomalyDetectorJob)) {\n+            throw new IllegalStateException(\n+                \"Job parameter is not instance of AnomalyDetectorJob, type: \" + jobParameter.getClass().getCanonicalName()\n+            );\n+        }\n+\n+        final LockService lockService = context.getLockService();\n+\n+        Runnable runnable = () -> {\n+            if (jobParameter.getLockDurationSeconds() != null) {\n+                lockService\n+                    .acquireLock(\n+                        jobParameter,\n+                        context,\n+                        ActionListener\n+                            .wrap(\n+                                lock -> runAdJob(jobParameter, lockService, lock),\n+                                exception -> {\n+                                    throw new IllegalStateException(\"Failed to acquire lock for AD job: \" + jobParameter.getName());\n+                                }\n+                            )\n+                    );\n+            } else {\n+                log.warn(\"Can't get lock for AD job: \" + jobParameter.getName());\n+            }\n+        };\n+\n+        ExecutorService executor = threadPool.executor(AD_JOB_THREAD_POOL_NAME);\n+        executor.submit(runnable);\n+    }\n+\n+    protected void runAdJob(ScheduledJobParameter jobParameter, LockService lockService, LockModel lock) {\n+        if (lock == null) {\n+            return;\n+        }\n+\n+        try {\n+            IntervalSchedule schedule = (IntervalSchedule) jobParameter.getSchedule();\n+            Instant endTime = Instant.now();\n+            Duration duration = Duration.of(schedule.getInterval(), schedule.getUnit());\n+            Instant startTime = endTime.minusMillis(duration.toMillis());\n+\n+            AnomalyResultRequest request = new AnomalyResultRequest(\n+                jobParameter.getName(),\n+                startTime.toEpochMilli(),\n+                endTime.toEpochMilli()\n+            );\n+            client.execute(AnomalyResultAction.INSTANCE, request, ActionListener.wrap(response -> {\n+                log.info(\"Anomaly result action ran successfully for \" + jobParameter.getName());\n+                releaseLock(jobParameter, lockService, lock);\n+            }, exception -> {\n+                log.error(\"Failed to execute anomaly result action\", exception);\n+                releaseLock(jobParameter, lockService, lock);", "originalCommit": "0ad539154b87212be6c64d5a9ea80f3f8d95b3ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU0NDkzMQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/44#discussion_r383544931", "bodyText": "Need to keep releaseLock in ActionListener to avoid release lock earlier than task completed.", "author": "ylwu-amzn", "createdAt": "2020-02-24T22:10:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA3NDUxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA3NjAyMQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/44#discussion_r383076021", "bodyText": "This sounds like the time with jitter.  We may need to maintain a lastEndTime.  So every time we get a signal from scheduler, we do [lastEndTime, lastEndTime+interval] and update lastEndTime.  Of course, we need to deal with the case when scheduler misses sending us signals.", "author": "kaituo", "createdAt": "2020-02-24T03:39:05Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/AnomalyDetectorJobRunner.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad;\n+\n+import com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetectorJob;\n+import com.amazon.opendistroforelasticsearch.ad.transport.AnomalyResultAction;\n+import com.amazon.opendistroforelasticsearch.ad.transport.AnomalyResultRequest;\n+import com.amazon.opendistroforelasticsearch.jobscheduler.spi.JobExecutionContext;\n+import com.amazon.opendistroforelasticsearch.jobscheduler.spi.LockModel;\n+import com.amazon.opendistroforelasticsearch.jobscheduler.spi.ScheduledJobParameter;\n+import com.amazon.opendistroforelasticsearch.jobscheduler.spi.ScheduledJobRunner;\n+import com.amazon.opendistroforelasticsearch.jobscheduler.spi.schedule.IntervalSchedule;\n+import com.amazon.opendistroforelasticsearch.jobscheduler.spi.utils.LockService;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.concurrent.ExecutorService;\n+\n+import static com.amazon.opendistroforelasticsearch.ad.AnomalyDetectorPlugin.AD_JOB_THREAD_POOL_NAME;\n+\n+/**\n+ * JobScheduler will call AD job runner to get anomaly result periodically\n+ */\n+public class AnomalyDetectorJobRunner implements ScheduledJobRunner {\n+    private static final Logger log = LogManager.getLogger(AnomalyDetectorJobRunner.class);\n+\n+    private static AnomalyDetectorJobRunner INSTANCE;\n+\n+    public static AnomalyDetectorJobRunner getJobRunnerInstance() {\n+        if (INSTANCE != null) {\n+            return INSTANCE;\n+        }\n+        synchronized (AnomalyDetectorJobRunner.class) {\n+            if (INSTANCE != null) {\n+                return INSTANCE;\n+            }\n+            INSTANCE = new AnomalyDetectorJobRunner();\n+            return INSTANCE;\n+        }\n+    }\n+\n+    private Client client;\n+    private ThreadPool threadPool;\n+\n+    private AnomalyDetectorJobRunner() {\n+        // Singleton class, use getJobRunnerInstance method instead of constructor\n+    }\n+\n+    public void setClient(Client client) {\n+        this.client = client;\n+    }\n+\n+    public void setThreadPool(ThreadPool threadPool) {\n+        this.threadPool = threadPool;\n+    }\n+\n+    @Override\n+    public void runJob(ScheduledJobParameter jobParameter, JobExecutionContext context) {\n+        log.info(\"Start to run AD job {}\", jobParameter.getName());\n+        if (!(jobParameter instanceof AnomalyDetectorJob)) {\n+            throw new IllegalStateException(\n+                \"Job parameter is not instance of AnomalyDetectorJob, type: \" + jobParameter.getClass().getCanonicalName()\n+            );\n+        }\n+\n+        final LockService lockService = context.getLockService();\n+\n+        Runnable runnable = () -> {\n+            if (jobParameter.getLockDurationSeconds() != null) {\n+                lockService\n+                    .acquireLock(\n+                        jobParameter,\n+                        context,\n+                        ActionListener\n+                            .wrap(\n+                                lock -> runAdJob(jobParameter, lockService, lock),\n+                                exception -> {\n+                                    throw new IllegalStateException(\"Failed to acquire lock for AD job: \" + jobParameter.getName());\n+                                }\n+                            )\n+                    );\n+            } else {\n+                log.warn(\"Can't get lock for AD job: \" + jobParameter.getName());\n+            }\n+        };\n+\n+        ExecutorService executor = threadPool.executor(AD_JOB_THREAD_POOL_NAME);\n+        executor.submit(runnable);\n+    }\n+\n+    protected void runAdJob(ScheduledJobParameter jobParameter, LockService lockService, LockModel lock) {\n+        if (lock == null) {\n+            return;\n+        }\n+\n+        try {\n+            IntervalSchedule schedule = (IntervalSchedule) jobParameter.getSchedule();\n+            Instant endTime = Instant.now();", "originalCommit": "0ad539154b87212be6c64d5a9ea80f3f8d95b3ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU3Nzk5Nw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/44#discussion_r383577997", "bodyText": "Jitter is not backported in JobScheduler opensource code yet. Will add a todo here.", "author": "ylwu-amzn", "createdAt": "2020-02-24T23:36:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA3NjAyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY3NjE5OQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/44#discussion_r383676199", "bodyText": "Disabling jitter is ideal for us.  If not possible now, we can just add a todo here.", "author": "kaituo", "createdAt": "2020-02-25T06:11:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA3NjAyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY4MjE4MQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/44#discussion_r384682181", "bodyText": "Will support jitter in JobScheduler with this issue: opendistro-for-elasticsearch/job-scheduler#41. Then every job can set its own jitter. To limit PR size, will publish another change once JobScheduler change done.", "author": "ylwu-amzn", "createdAt": "2020-02-26T18:31:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA3NjAyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA3NzA1OA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/44#discussion_r383077058", "bodyText": "Is this adding AD's own threadpool?  We are doing this for throttling and thus don't want to use all of the processors.  We can use max(1, 1/4 * number of processors).", "author": "kaituo", "createdAt": "2020-02-24T03:46:47Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/AnomalyDetectorPlugin.java", "diffHunk": "@@ -316,6 +342,20 @@ private static Void initGson() {\n             );\n     }\n \n+    @Override\n+    public List<ExecutorBuilder<?>> getExecutorBuilders(Settings settings) {\n+        return Collections\n+            .singletonList(\n+                new FixedExecutorBuilder(\n+                    settings,\n+                    AD_JOB_THREAD_POOL_NAME,\n+                    EsExecutors.numberOfProcessors(settings),", "originalCommit": "0ad539154b87212be6c64d5a9ea80f3f8d95b3ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU0Njc2OQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/44#discussion_r383546769", "bodyText": "This is AD dedicated thread pool. Why we should use 1/4 processors rather than 1/2 or 1/8?", "author": "ylwu-amzn", "createdAt": "2020-02-24T22:15:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA3NzA1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY3NjQzMA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/44#discussion_r383676430", "bodyText": "As long as it is <= 1/2, it is fine.", "author": "kaituo", "createdAt": "2020-02-25T06:12:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA3NzA1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA3NzQzOA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/44#discussion_r383077438", "bodyText": "It should be 2020 now.  This applies to all of your newly added header", "author": "kaituo", "createdAt": "2020-02-24T03:49:36Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/model/AnomalyDetectorJob.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.", "originalCommit": "0ad539154b87212be6c64d5a9ea80f3f8d95b3ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ0NDQ0OQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/44#discussion_r383444449", "bodyText": "Will change it.", "author": "ylwu-amzn", "createdAt": "2020-02-24T18:43:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA3NzQzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA3OTk3NQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/44#discussion_r383079975", "bodyText": "Why do we need this field?  AnomalyDetector is the definition of the detector.  Enabled or not sounds like a state and should belong to ad job index.", "author": "kaituo", "createdAt": "2020-02-24T04:09:52Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/model/AnomalyDetector.java", "diffHunk": "@@ -83,6 +84,7 @@\n     private final Map<String, Object> uiMetadata;\n     private final Integer schemaVersion;\n     private final Instant lastUpdateTime;\n+    private boolean enabled = false;", "originalCommit": "0ad539154b87212be6c64d5a9ea80f3f8d95b3ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ1ODA0MQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/44#discussion_r383458041", "bodyText": "1.For AD Kibana plugin, we need to show AD job enabled or not along with detector detail info. Will save one API call.\n2.It's based on how to understand this, this code will treat job state as detector's property just like monitor.", "author": "ylwu-amzn", "createdAt": "2020-02-24T19:10:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA3OTk3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY3ODUyNA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/44#discussion_r383678524", "bodyText": "Would adding the following in RestGetAnomalyDetectorAction.java achieve the same purpose instead of adding this field in  AnomalyDetector?\n               builder.field(RestHandlerUtils.ANOMALY_DETECTOR, detector);\n                builder.field(RestHandlerUtils.ENABLED, adJobEnabled); <== add this line\n                builder.endObject();", "author": "kaituo", "createdAt": "2020-02-25T06:20:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA3OTk3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA4MTk0Mg==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/44#discussion_r383081942", "bodyText": "How is this related to delete detector?  The method name suggests we are only getting a detector job.", "author": "kaituo", "createdAt": "2020-02-24T04:26:09Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/rest/handler/AnomalyDetectorActionHandler.java", "diffHunk": "@@ -82,21 +59,12 @@ public void getMonitorUsingDetector(\n         }\n     }\n \n-    /**\n-     * Callback method for {@link AnomalyDetectorActionHandler#getMonitorUsingDetector}.\n-     * If search result contains at least one monitor, return error message;\n-     * otherwise, execute {@link AnomalyDetectorFunction}\n-     *\n-     * @param response Response of searching monitor\n-     * @param channel  ES rest channel\n-     * @param function Anomaly detector function\n-     */\n-    private void onSearchResponse(SearchResponse response, RestChannel channel, AnomalyDetectorFunction function) {\n-        if (response.getHits().getTotalHits().value > 0) {\n-            String monitorId = response.getHits().getAt(0).getId();\n-            if (monitorId != null) {\n-                // check if any monitor running on the detector, if yes, we can't delete the detector\n-                channel.sendResponse(new BytesRestResponse(RestStatus.BAD_REQUEST, \"Detector is used by monitor: \" + monitorId));\n+    private void onGetAdJobResponse(GetResponse response, RestChannel channel, AnomalyDetectorFunction function) {", "originalCommit": "0ad539154b87212be6c64d5a9ea80f3f8d95b3ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ0NjI3Ng==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/44#discussion_r383446276", "bodyText": "Not related to delete detector directly. This is just to handle response of get AD job. If AD job exists, will throw exception, otherwise execute the function which can be delete AD or update AD", "author": "ylwu-amzn", "createdAt": "2020-02-24T18:47:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA4MTk0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY4OTE4Ng==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/44#discussion_r383689186", "bodyText": "maybe add a comment and change getDetectorJob to getDetectorJobForWrite or some other name since your getDetectorJob is to get a detector job definition for update or delete?", "author": "kaituo", "createdAt": "2020-02-25T06:57:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA4MTk0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg4MTAwNg==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/44#discussion_r384881006", "bodyText": "Sure, will do it", "author": "ylwu-amzn", "createdAt": "2020-02-27T02:26:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA4MTk0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA4NzQ1Ng==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/44#discussion_r383087456", "bodyText": "Using  deleteResponse.getResult() == DocWriteResponse.Result.DELETED is more robust than comparing string as the string can change and compiler won't detect the change.", "author": "kaituo", "createdAt": "2020-02-24T05:07:30Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/rest/handler/IndexAnomalyDetectorJobActionHandler.java", "diffHunk": "@@ -0,0 +1,332 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad.rest.handler;\n+\n+import com.amazon.opendistroforelasticsearch.ad.AnomalyDetectorPlugin;\n+import com.amazon.opendistroforelasticsearch.ad.indices.AnomalyDetectionIndices;\n+import com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetector;\n+import com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetectorJob;\n+import com.amazon.opendistroforelasticsearch.ad.model.IntervalTimeConfiguration;\n+import com.amazon.opendistroforelasticsearch.ad.transport.StopDetectorAction;\n+import com.amazon.opendistroforelasticsearch.ad.transport.StopDetectorRequest;\n+import com.amazon.opendistroforelasticsearch.ad.transport.StopDetectorResponse;\n+import com.amazon.opendistroforelasticsearch.ad.util.RestHandlerUtils;\n+import com.amazon.opendistroforelasticsearch.jobscheduler.spi.schedule.IntervalSchedule;\n+import com.amazon.opendistroforelasticsearch.jobscheduler.spi.schedule.Schedule;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.indices.create.CreateIndexResponse;\n+import org.elasticsearch.action.delete.DeleteRequest;\n+import org.elasticsearch.action.get.GetRequest;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.index.IndexRequest;\n+import org.elasticsearch.action.index.IndexResponse;\n+import org.elasticsearch.action.support.WriteRequest;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.common.xcontent.LoggingDeprecationHandler;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.rest.BytesRestResponse;\n+import org.elasticsearch.rest.RestChannel;\n+import org.elasticsearch.rest.RestResponse;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.rest.action.RestResponseListener;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Locale;\n+\n+import static com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetector.ANOMALY_DETECTORS_INDEX;\n+import static com.amazon.opendistroforelasticsearch.ad.settings.AnomalyDetectorSettings.MAX_ANOMALY_DETECTORS;\n+import static com.amazon.opendistroforelasticsearch.ad.settings.AnomalyDetectorSettings.MAX_ANOMALY_FEATURES;\n+import static com.amazon.opendistroforelasticsearch.ad.util.RestHandlerUtils.XCONTENT_WITH_TYPE;\n+import static org.elasticsearch.common.xcontent.ToXContent.EMPTY_PARAMS;\n+import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;\n+\n+/**\n+ * Anomaly detector job REST action handler to process POST/PUT request.\n+ */\n+public class IndexAnomalyDetectorJobActionHandler extends AbstractActionHandler {\n+\n+    private final AnomalyDetectionIndices anomalyDetectionIndices;\n+    private final String detectorId;\n+    private final Long seqNo;\n+    private final Long primaryTerm;\n+    private final WriteRequest.RefreshPolicy refreshPolicy;\n+    private final ClusterService clusterService;\n+\n+    private final Logger logger = LogManager.getLogger(IndexAnomalyDetectorJobActionHandler.class);\n+    private final TimeValue requestTimeout;\n+    private volatile Integer maxAnomalyDetectors;\n+    private volatile Integer maxAnomalyFeatures;\n+    private final AnomalyDetectorActionHandler handler = new AnomalyDetectorActionHandler();\n+\n+    /**\n+     * Constructor function.\n+     *\n+     * @param settings                ES settings\n+     * @param clusterService          ClusterService\n+     * @param client                  ES node client that executes actions on the local node\n+     * @param channel                 ES channel used to construct bytes / builder based outputs, and send responses\n+     * @param anomalyDetectionIndices anomaly detector index manager\n+     * @param detectorId              detector identifier\n+     * @param seqNo                   sequence number of last modification\n+     * @param primaryTerm             primary term of last modification\n+     * @param refreshPolicy           refresh policy\n+     * @param requestTimeout          request time out configuration\n+     */\n+    public IndexAnomalyDetectorJobActionHandler(\n+        Settings settings,\n+        ClusterService clusterService,\n+        NodeClient client,\n+        RestChannel channel,\n+        AnomalyDetectionIndices anomalyDetectionIndices,\n+        String detectorId,\n+        Long seqNo,\n+        Long primaryTerm,\n+        WriteRequest.RefreshPolicy refreshPolicy,\n+        TimeValue requestTimeout\n+    ) {\n+        super(client, channel);\n+        this.clusterService = clusterService;\n+        this.anomalyDetectionIndices = anomalyDetectionIndices;\n+        this.detectorId = detectorId;\n+        this.seqNo = seqNo;\n+        this.primaryTerm = primaryTerm;\n+        this.refreshPolicy = refreshPolicy;\n+        this.requestTimeout = requestTimeout;\n+        maxAnomalyDetectors = MAX_ANOMALY_DETECTORS.get(settings);\n+        maxAnomalyFeatures = MAX_ANOMALY_FEATURES.get(settings);\n+        clusterService.getClusterSettings().addSettingsUpdateConsumer(MAX_ANOMALY_DETECTORS, it -> maxAnomalyDetectors = it);\n+        clusterService.getClusterSettings().addSettingsUpdateConsumer(MAX_ANOMALY_FEATURES, it -> maxAnomalyFeatures = it);\n+    }\n+\n+    /**\n+     * Start function to process create/update anomaly detector job request.\n+     * Check if anomaly detector job index exist first, if not, will create first.\n+     *\n+     * @throws IOException IOException from {@link AnomalyDetectionIndices#initAnomalyDetectorIndexIfAbsent(ActionListener)}\n+     */\n+    public void start() throws IOException {\n+        if (!anomalyDetectionIndices.doesAnomalyDetectorJobIndexExist()) {\n+            anomalyDetectionIndices\n+                .initAnomalyDetectorIndex(\n+                    ActionListener.wrap(response -> onCreateMappingsResponse(response), exception -> onFailure(exception))\n+                );\n+        } else {\n+            prepareAnomalyDetectorJobIndexing();\n+        }\n+    }\n+\n+    /**\n+     * Create anomaly detector job.\n+     *\n+     * @throws IOException IOException from {@link AnomalyDetectionIndices#getAnomalyDetectorJobMappings}\n+     */\n+    public void createAnomalyDetectorJob() throws IOException {\n+        if (!anomalyDetectionIndices.doesAnomalyDetectorJobIndexExist()) {\n+            anomalyDetectionIndices\n+                .initAnomalyDetectorJobIndex(\n+                    ActionListener.wrap(response -> onCreateMappingsResponse(response), exception -> onFailure(exception))\n+                );\n+        } else {\n+            prepareAnomalyDetectorJobIndexing();\n+        }\n+    }\n+\n+    private void prepareAnomalyDetectorJobIndexing() {\n+        GetRequest getRequest = new GetRequest(AnomalyDetector.ANOMALY_DETECTORS_INDEX).id(detectorId);\n+        client.get(getRequest, ActionListener.wrap(response -> onGetAnomalyDetectorResponse(response), exception -> onFailure(exception)));\n+    }\n+\n+    private void onGetAnomalyDetectorResponse(GetResponse response) throws IOException {\n+        if (!response.isExists()) {\n+            XContentBuilder builder = channel\n+                .newErrorBuilder()\n+                .startObject()\n+                .field(\"Message\", \"AnomalyDetector is not found with id: \" + detectorId)\n+                .endObject();\n+            channel.sendResponse(new BytesRestResponse(RestStatus.NOT_FOUND, response.toXContent(builder, EMPTY_PARAMS)));\n+            return;\n+        }\n+        XContentParser parser = XContentType.JSON\n+            .xContent()\n+            .createParser(\n+                channel.request().getXContentRegistry(),\n+                LoggingDeprecationHandler.INSTANCE,\n+                response.getSourceAsBytesRef().streamInput()\n+            );\n+\n+        ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+        AnomalyDetector detector = AnomalyDetector.parse(parser, response.getId(), response.getVersion());\n+\n+        IntervalTimeConfiguration interval = (IntervalTimeConfiguration) detector.getDetectionInterval();\n+        Schedule schedule = new IntervalSchedule(Instant.now(), (int) interval.getInterval(), interval.getUnit());\n+        Duration duration = Duration.of(interval.getInterval(), interval.getUnit());\n+        AnomalyDetectorJob job = new AnomalyDetectorJob(\n+            detector.getDetectorId(),\n+            schedule,\n+            true,\n+            Instant.now(),\n+            Instant.now(),\n+            duration.getSeconds()\n+        );\n+\n+        getAnomalyDetectorJob(job);\n+    }\n+\n+    private void getAnomalyDetectorJob(AnomalyDetectorJob job) {\n+        GetRequest getRequest = new GetRequest(AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX).id(detectorId);\n+\n+        client.get(getRequest, ActionListener.wrap(response -> onGetAnomalyDetectorJob(response, job), exception -> onFailure(exception)));\n+    }\n+\n+    private void onGetAnomalyDetectorJob(GetResponse response, AnomalyDetectorJob job) throws IOException {\n+        if (response.isExists()) {\n+            XContentBuilder builder = channel\n+                .newErrorBuilder()\n+                .startObject()\n+                .field(\"Message\", \"AnomalyDetectorJob exists: \" + detectorId)\n+                .endObject();\n+            channel.sendResponse(new BytesRestResponse(RestStatus.NOT_FOUND, response.toXContent(builder, EMPTY_PARAMS)));\n+            return;\n+        }\n+\n+        indexAnomalyDetectorJob(job);\n+    }\n+\n+    private void indexAnomalyDetectorJob(AnomalyDetectorJob job) throws IOException {\n+        IndexRequest indexRequest = new IndexRequest(AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX)\n+            .setRefreshPolicy(refreshPolicy)\n+            .source(job.toXContent(channel.newBuilder(), XCONTENT_WITH_TYPE))\n+            .setIfSeqNo(seqNo)\n+            .setIfPrimaryTerm(primaryTerm)\n+            .timeout(requestTimeout);\n+        if (detectorId != null) {\n+            indexRequest.id(detectorId);\n+        }\n+        client.index(indexRequest, indexAnomalyDetectorJobResponse());\n+    }\n+\n+    private ActionListener<IndexResponse> indexAnomalyDetectorJobResponse() {\n+        return new RestResponseListener<IndexResponse>(channel) {\n+            @Override\n+            public RestResponse buildResponse(IndexResponse response) throws Exception {\n+                if (response.getShardInfo().getSuccessful() < 1) {\n+                    return new BytesRestResponse(response.status(), response.toXContent(channel.newErrorBuilder(), EMPTY_PARAMS));\n+                }\n+\n+                XContentBuilder builder = channel\n+                    .newBuilder()\n+                    .startObject()\n+                    .field(RestHandlerUtils._ID, response.getId())\n+                    .field(RestHandlerUtils._VERSION, response.getVersion())\n+                    .field(RestHandlerUtils._SEQ_NO, response.getSeqNo())\n+                    .field(RestHandlerUtils._PRIMARY_TERM, response.getPrimaryTerm())\n+                    .endObject();\n+\n+                BytesRestResponse restResponse = new BytesRestResponse(response.status(), builder);\n+                if (response.status() == RestStatus.CREATED) {\n+                    String location = String.format(Locale.ROOT, \"%s/%s\", AnomalyDetectorPlugin.AD_BASE_URI, response.getId());\n+                    restResponse.addHeader(\"Location\", location);\n+                }\n+                return restResponse;\n+            }\n+        };\n+    }\n+\n+    private void onCreateMappingsResponse(CreateIndexResponse response) throws IOException {\n+        if (response.isAcknowledged()) {\n+            logger.info(\"Created {} with mappings.\", ANOMALY_DETECTORS_INDEX);\n+            prepareAnomalyDetectorJobIndexing();\n+        } else {\n+            logger.warn(\"Created {} with mappings call not acknowledged.\", ANOMALY_DETECTORS_INDEX);\n+            channel\n+                .sendResponse(\n+                    new BytesRestResponse(RestStatus.INTERNAL_SERVER_ERROR, response.toXContent(channel.newErrorBuilder(), EMPTY_PARAMS))\n+                );\n+        }\n+    }\n+\n+    /**\n+     * Delete anomaly detector job\n+     * @param detectorId detector identifier\n+     */\n+    public void deleteAnomalyDetectorJob(String detectorId) {\n+        GetRequest getRequest = new GetRequest(AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX).id(detectorId);\n+\n+        client\n+            .get(\n+                getRequest,\n+                ActionListener\n+                    .wrap(\n+                        response -> deleteAnomalyDetectorJobDoc(client, detectorId, channel, refreshPolicy),\n+                        exception -> onFailure(exception)\n+                    )\n+            );\n+    }\n+\n+    private void deleteAnomalyDetectorJobDoc(\n+        NodeClient client,\n+        String detectorId,\n+        RestChannel channel,\n+        WriteRequest.RefreshPolicy refreshPolicy\n+    ) {\n+        logger.info(\"Delete anomaly detector job {}\", detectorId);\n+        DeleteRequest deleteRequest = new DeleteRequest(AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX, detectorId)\n+            .setRefreshPolicy(refreshPolicy);\n+        client.delete(deleteRequest, ActionListener.wrap(response -> {\n+            if (\"deleted\".equals(response.getResult().getLowercase())) {", "originalCommit": "0ad539154b87212be6c64d5a9ea80f3f8d95b3ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ0NzE0Ng==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/44#discussion_r383447146", "bodyText": "Will change it", "author": "ylwu-amzn", "createdAt": "2020-02-24T18:49:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA4NzQ1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA4Nzg5NQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/44#discussion_r383087895", "bodyText": "If we deleted AD job but fail to stop AD model, do you allow people to run delete AD job again?  In other words, how do you handle response.getResult() == DocWriteResponse.Result.NOT_FOUND?", "author": "kaituo", "createdAt": "2020-02-24T05:10:40Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/rest/handler/IndexAnomalyDetectorJobActionHandler.java", "diffHunk": "@@ -0,0 +1,332 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad.rest.handler;\n+\n+import com.amazon.opendistroforelasticsearch.ad.AnomalyDetectorPlugin;\n+import com.amazon.opendistroforelasticsearch.ad.indices.AnomalyDetectionIndices;\n+import com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetector;\n+import com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetectorJob;\n+import com.amazon.opendistroforelasticsearch.ad.model.IntervalTimeConfiguration;\n+import com.amazon.opendistroforelasticsearch.ad.transport.StopDetectorAction;\n+import com.amazon.opendistroforelasticsearch.ad.transport.StopDetectorRequest;\n+import com.amazon.opendistroforelasticsearch.ad.transport.StopDetectorResponse;\n+import com.amazon.opendistroforelasticsearch.ad.util.RestHandlerUtils;\n+import com.amazon.opendistroforelasticsearch.jobscheduler.spi.schedule.IntervalSchedule;\n+import com.amazon.opendistroforelasticsearch.jobscheduler.spi.schedule.Schedule;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.admin.indices.create.CreateIndexResponse;\n+import org.elasticsearch.action.delete.DeleteRequest;\n+import org.elasticsearch.action.get.GetRequest;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.index.IndexRequest;\n+import org.elasticsearch.action.index.IndexResponse;\n+import org.elasticsearch.action.support.WriteRequest;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.common.xcontent.LoggingDeprecationHandler;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.rest.BytesRestResponse;\n+import org.elasticsearch.rest.RestChannel;\n+import org.elasticsearch.rest.RestResponse;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.rest.action.RestResponseListener;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Locale;\n+\n+import static com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetector.ANOMALY_DETECTORS_INDEX;\n+import static com.amazon.opendistroforelasticsearch.ad.settings.AnomalyDetectorSettings.MAX_ANOMALY_DETECTORS;\n+import static com.amazon.opendistroforelasticsearch.ad.settings.AnomalyDetectorSettings.MAX_ANOMALY_FEATURES;\n+import static com.amazon.opendistroforelasticsearch.ad.util.RestHandlerUtils.XCONTENT_WITH_TYPE;\n+import static org.elasticsearch.common.xcontent.ToXContent.EMPTY_PARAMS;\n+import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;\n+\n+/**\n+ * Anomaly detector job REST action handler to process POST/PUT request.\n+ */\n+public class IndexAnomalyDetectorJobActionHandler extends AbstractActionHandler {\n+\n+    private final AnomalyDetectionIndices anomalyDetectionIndices;\n+    private final String detectorId;\n+    private final Long seqNo;\n+    private final Long primaryTerm;\n+    private final WriteRequest.RefreshPolicy refreshPolicy;\n+    private final ClusterService clusterService;\n+\n+    private final Logger logger = LogManager.getLogger(IndexAnomalyDetectorJobActionHandler.class);\n+    private final TimeValue requestTimeout;\n+    private volatile Integer maxAnomalyDetectors;\n+    private volatile Integer maxAnomalyFeatures;\n+    private final AnomalyDetectorActionHandler handler = new AnomalyDetectorActionHandler();\n+\n+    /**\n+     * Constructor function.\n+     *\n+     * @param settings                ES settings\n+     * @param clusterService          ClusterService\n+     * @param client                  ES node client that executes actions on the local node\n+     * @param channel                 ES channel used to construct bytes / builder based outputs, and send responses\n+     * @param anomalyDetectionIndices anomaly detector index manager\n+     * @param detectorId              detector identifier\n+     * @param seqNo                   sequence number of last modification\n+     * @param primaryTerm             primary term of last modification\n+     * @param refreshPolicy           refresh policy\n+     * @param requestTimeout          request time out configuration\n+     */\n+    public IndexAnomalyDetectorJobActionHandler(\n+        Settings settings,\n+        ClusterService clusterService,\n+        NodeClient client,\n+        RestChannel channel,\n+        AnomalyDetectionIndices anomalyDetectionIndices,\n+        String detectorId,\n+        Long seqNo,\n+        Long primaryTerm,\n+        WriteRequest.RefreshPolicy refreshPolicy,\n+        TimeValue requestTimeout\n+    ) {\n+        super(client, channel);\n+        this.clusterService = clusterService;\n+        this.anomalyDetectionIndices = anomalyDetectionIndices;\n+        this.detectorId = detectorId;\n+        this.seqNo = seqNo;\n+        this.primaryTerm = primaryTerm;\n+        this.refreshPolicy = refreshPolicy;\n+        this.requestTimeout = requestTimeout;\n+        maxAnomalyDetectors = MAX_ANOMALY_DETECTORS.get(settings);\n+        maxAnomalyFeatures = MAX_ANOMALY_FEATURES.get(settings);\n+        clusterService.getClusterSettings().addSettingsUpdateConsumer(MAX_ANOMALY_DETECTORS, it -> maxAnomalyDetectors = it);\n+        clusterService.getClusterSettings().addSettingsUpdateConsumer(MAX_ANOMALY_FEATURES, it -> maxAnomalyFeatures = it);\n+    }\n+\n+    /**\n+     * Start function to process create/update anomaly detector job request.\n+     * Check if anomaly detector job index exist first, if not, will create first.\n+     *\n+     * @throws IOException IOException from {@link AnomalyDetectionIndices#initAnomalyDetectorIndexIfAbsent(ActionListener)}\n+     */\n+    public void start() throws IOException {\n+        if (!anomalyDetectionIndices.doesAnomalyDetectorJobIndexExist()) {\n+            anomalyDetectionIndices\n+                .initAnomalyDetectorIndex(\n+                    ActionListener.wrap(response -> onCreateMappingsResponse(response), exception -> onFailure(exception))\n+                );\n+        } else {\n+            prepareAnomalyDetectorJobIndexing();\n+        }\n+    }\n+\n+    /**\n+     * Create anomaly detector job.\n+     *\n+     * @throws IOException IOException from {@link AnomalyDetectionIndices#getAnomalyDetectorJobMappings}\n+     */\n+    public void createAnomalyDetectorJob() throws IOException {\n+        if (!anomalyDetectionIndices.doesAnomalyDetectorJobIndexExist()) {\n+            anomalyDetectionIndices\n+                .initAnomalyDetectorJobIndex(\n+                    ActionListener.wrap(response -> onCreateMappingsResponse(response), exception -> onFailure(exception))\n+                );\n+        } else {\n+            prepareAnomalyDetectorJobIndexing();\n+        }\n+    }\n+\n+    private void prepareAnomalyDetectorJobIndexing() {\n+        GetRequest getRequest = new GetRequest(AnomalyDetector.ANOMALY_DETECTORS_INDEX).id(detectorId);\n+        client.get(getRequest, ActionListener.wrap(response -> onGetAnomalyDetectorResponse(response), exception -> onFailure(exception)));\n+    }\n+\n+    private void onGetAnomalyDetectorResponse(GetResponse response) throws IOException {\n+        if (!response.isExists()) {\n+            XContentBuilder builder = channel\n+                .newErrorBuilder()\n+                .startObject()\n+                .field(\"Message\", \"AnomalyDetector is not found with id: \" + detectorId)\n+                .endObject();\n+            channel.sendResponse(new BytesRestResponse(RestStatus.NOT_FOUND, response.toXContent(builder, EMPTY_PARAMS)));\n+            return;\n+        }\n+        XContentParser parser = XContentType.JSON\n+            .xContent()\n+            .createParser(\n+                channel.request().getXContentRegistry(),\n+                LoggingDeprecationHandler.INSTANCE,\n+                response.getSourceAsBytesRef().streamInput()\n+            );\n+\n+        ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+        AnomalyDetector detector = AnomalyDetector.parse(parser, response.getId(), response.getVersion());\n+\n+        IntervalTimeConfiguration interval = (IntervalTimeConfiguration) detector.getDetectionInterval();\n+        Schedule schedule = new IntervalSchedule(Instant.now(), (int) interval.getInterval(), interval.getUnit());\n+        Duration duration = Duration.of(interval.getInterval(), interval.getUnit());\n+        AnomalyDetectorJob job = new AnomalyDetectorJob(\n+            detector.getDetectorId(),\n+            schedule,\n+            true,\n+            Instant.now(),\n+            Instant.now(),\n+            duration.getSeconds()\n+        );\n+\n+        getAnomalyDetectorJob(job);\n+    }\n+\n+    private void getAnomalyDetectorJob(AnomalyDetectorJob job) {\n+        GetRequest getRequest = new GetRequest(AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX).id(detectorId);\n+\n+        client.get(getRequest, ActionListener.wrap(response -> onGetAnomalyDetectorJob(response, job), exception -> onFailure(exception)));\n+    }\n+\n+    private void onGetAnomalyDetectorJob(GetResponse response, AnomalyDetectorJob job) throws IOException {\n+        if (response.isExists()) {\n+            XContentBuilder builder = channel\n+                .newErrorBuilder()\n+                .startObject()\n+                .field(\"Message\", \"AnomalyDetectorJob exists: \" + detectorId)\n+                .endObject();\n+            channel.sendResponse(new BytesRestResponse(RestStatus.NOT_FOUND, response.toXContent(builder, EMPTY_PARAMS)));\n+            return;\n+        }\n+\n+        indexAnomalyDetectorJob(job);\n+    }\n+\n+    private void indexAnomalyDetectorJob(AnomalyDetectorJob job) throws IOException {\n+        IndexRequest indexRequest = new IndexRequest(AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX)\n+            .setRefreshPolicy(refreshPolicy)\n+            .source(job.toXContent(channel.newBuilder(), XCONTENT_WITH_TYPE))\n+            .setIfSeqNo(seqNo)\n+            .setIfPrimaryTerm(primaryTerm)\n+            .timeout(requestTimeout);\n+        if (detectorId != null) {\n+            indexRequest.id(detectorId);\n+        }\n+        client.index(indexRequest, indexAnomalyDetectorJobResponse());\n+    }\n+\n+    private ActionListener<IndexResponse> indexAnomalyDetectorJobResponse() {\n+        return new RestResponseListener<IndexResponse>(channel) {\n+            @Override\n+            public RestResponse buildResponse(IndexResponse response) throws Exception {\n+                if (response.getShardInfo().getSuccessful() < 1) {\n+                    return new BytesRestResponse(response.status(), response.toXContent(channel.newErrorBuilder(), EMPTY_PARAMS));\n+                }\n+\n+                XContentBuilder builder = channel\n+                    .newBuilder()\n+                    .startObject()\n+                    .field(RestHandlerUtils._ID, response.getId())\n+                    .field(RestHandlerUtils._VERSION, response.getVersion())\n+                    .field(RestHandlerUtils._SEQ_NO, response.getSeqNo())\n+                    .field(RestHandlerUtils._PRIMARY_TERM, response.getPrimaryTerm())\n+                    .endObject();\n+\n+                BytesRestResponse restResponse = new BytesRestResponse(response.status(), builder);\n+                if (response.status() == RestStatus.CREATED) {\n+                    String location = String.format(Locale.ROOT, \"%s/%s\", AnomalyDetectorPlugin.AD_BASE_URI, response.getId());\n+                    restResponse.addHeader(\"Location\", location);\n+                }\n+                return restResponse;\n+            }\n+        };\n+    }\n+\n+    private void onCreateMappingsResponse(CreateIndexResponse response) throws IOException {\n+        if (response.isAcknowledged()) {\n+            logger.info(\"Created {} with mappings.\", ANOMALY_DETECTORS_INDEX);\n+            prepareAnomalyDetectorJobIndexing();\n+        } else {\n+            logger.warn(\"Created {} with mappings call not acknowledged.\", ANOMALY_DETECTORS_INDEX);\n+            channel\n+                .sendResponse(\n+                    new BytesRestResponse(RestStatus.INTERNAL_SERVER_ERROR, response.toXContent(channel.newErrorBuilder(), EMPTY_PARAMS))\n+                );\n+        }\n+    }\n+\n+    /**\n+     * Delete anomaly detector job\n+     * @param detectorId detector identifier\n+     */\n+    public void deleteAnomalyDetectorJob(String detectorId) {\n+        GetRequest getRequest = new GetRequest(AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX).id(detectorId);\n+\n+        client\n+            .get(\n+                getRequest,\n+                ActionListener\n+                    .wrap(\n+                        response -> deleteAnomalyDetectorJobDoc(client, detectorId, channel, refreshPolicy),\n+                        exception -> onFailure(exception)\n+                    )\n+            );\n+    }\n+\n+    private void deleteAnomalyDetectorJobDoc(\n+        NodeClient client,\n+        String detectorId,\n+        RestChannel channel,\n+        WriteRequest.RefreshPolicy refreshPolicy\n+    ) {\n+        logger.info(\"Delete anomaly detector job {}\", detectorId);\n+        DeleteRequest deleteRequest = new DeleteRequest(AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX, detectorId)\n+            .setRefreshPolicy(refreshPolicy);\n+        client.delete(deleteRequest, ActionListener.wrap(response -> {\n+            if (\"deleted\".equals(response.getResult().getLowercase())) {\n+                logger.info(\"Stop anomaly detector {}\", detectorId);\n+                StopDetectorRequest stopDetectorRequest = new StopDetectorRequest(detectorId);\n+                client.execute(StopDetectorAction.INSTANCE, stopDetectorRequest, stopAdDetectorListener(channel, detectorId));\n+            } else {\n+                channel.sendResponse(new BytesRestResponse(RestStatus.BAD_REQUEST, \"Failed to stop AD job \" + detectorId));", "originalCommit": "0ad539154b87212be6c64d5a9ea80f3f8d95b3ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYwNTcyNA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/44#discussion_r383605724", "bodyText": "Goot point, will handle not found case.", "author": "ylwu-amzn", "createdAt": "2020-02-25T01:07:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA4Nzg5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA4ODUzMw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/44#discussion_r383088533", "bodyText": "When we delete, it should always be WriteRequest.RefreshPolicy.IMMEDIATE.  We don't need a customization.", "author": "kaituo", "createdAt": "2020-02-24T05:15:56Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/rest/RestDeleteAnomalyDetectorAction.java", "diffHunk": "@@ -117,23 +97,4 @@ private void deleteAnomalyDetectorDoc(\n         client.delete(deleteRequest, new RestStatusToXContentListener<>(channel));", "originalCommit": "0ad539154b87212be6c64d5a9ea80f3f8d95b3ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYwNjU3Mg==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/44#discussion_r383606572", "bodyText": "Check line 72, we have hard code\nWriteRequest.RefreshPolicy refreshPolicy = WriteRequest.RefreshPolicy\n.parse(request.param(REFRESH, WriteRequest.RefreshPolicy.IMMEDIATE.getValue()));", "author": "ylwu-amzn", "createdAt": "2020-02-25T01:10:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA4ODUzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY3OTgyMA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/44#discussion_r383679820", "bodyText": "I meant we don't need refreshPolicy as a parameter since it is always IMMEDIATE.  Your function can be:\nprivate void deleteAnomalyDetectorDoc(\n        NodeClient client,\n        String detectorId,\n        RestChannel channel) {\n\n        DeleteRequest deleteRequest = new DeleteRequest(AnomalyDetector.ANOMALY_DETECTORS_INDEX, detectorId)\n            .setRefreshPolicy(..RefreshPolicy.IMMEDIATE..);\n        ...\n}", "author": "kaituo", "createdAt": "2020-02-25T06:25:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA4ODUzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA4OTI4NA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/44#discussion_r383089284", "bodyText": "What will happen if we delete a detector that has an ad job running?", "author": "kaituo", "createdAt": "2020-02-24T05:21:51Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/rest/RestDeleteAnomalyDetectorAction.java", "diffHunk": "@@ -117,23 +97,4 @@ private void deleteAnomalyDetectorDoc(\n         client.delete(deleteRequest, new RestStatusToXContentListener<>(channel));\n     }\n ", "originalCommit": "0ad539154b87212be6c64d5a9ea80f3f8d95b3ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ0OTc2MQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/44#discussion_r383449761", "bodyText": "will throw exception", "author": "ylwu-amzn", "createdAt": "2020-02-24T18:54:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA4OTI4NA=="}], "type": "inlineReview"}, {"oid": "c89f6617f26b914f00cd2f26ea130c59580a9174", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/c89f6617f26b914f00cd2f26ea130c59580a9174", "message": "fix comments", "committedDate": "2020-02-26T18:27:04Z", "type": "commit"}, {"oid": "468e337182e5e3724db87f4e95bd7936c32e66c5", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/468e337182e5e3724db87f4e95bd7936c32e66c5", "message": "Merge remote-tracking branch 'upstream/development' into development", "committedDate": "2020-02-26T18:40:32Z", "type": "commit"}, {"oid": "de8f27737498c215f680201a14653bfa928daff3", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/de8f27737498c215f680201a14653bfa928daff3", "message": "upgrade jobscheduler to 1.4", "committedDate": "2020-02-26T19:28:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg3OTY5OA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/44#discussion_r384879698", "bodyText": "To limit PR size. Will publish another PR to return both detector and detector job.", "author": "ylwu-amzn", "createdAt": "2020-02-27T02:21:37Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/rest/RestGetAnomalyDetectorAction.java", "diffHunk": "@@ -68,47 +74,62 @@ public String getName() {\n     @Override\n     protected RestChannelConsumer prepareRequest(RestRequest request, NodeClient client) throws IOException {\n         String detectorId = request.param(DETECTOR_ID);\n-        GetRequest getRequest = new GetRequest(ANOMALY_DETECTORS_INDEX, detectorId)\n-            .version(RestActions.parseVersion(request))\n-            .fetchSourceContext(RestHandlerUtils.getSourceContext(request));\n-        return channel -> client.get(getRequest, getDetectorResponse(channel));\n+        MultiGetRequest.Item adItem = new MultiGetRequest.Item(ANOMALY_DETECTORS_INDEX, detectorId)\n+            .version(RestActions.parseVersion(request));\n+        MultiGetRequest.Item adJobItem = new MultiGetRequest.Item(ANOMALY_DETECTOR_JOB_INDEX, detectorId)\n+            .version(RestActions.parseVersion(request));\n+        MultiGetRequest multiGetRequest = new MultiGetRequest().add(adItem).add(adJobItem);\n+        return channel -> client.multiGet(multiGetRequest, onMultiGetResponse(channel));\n     }\n \n-    private RestResponseListener<GetResponse> getDetectorResponse(RestChannel channel) {\n-        return new RestResponseListener<GetResponse>(channel) {\n-\n+    private ActionListener<MultiGetResponse> onMultiGetResponse(RestChannel channel) {\n+        return new RestResponseListener<MultiGetResponse>(channel) {\n             @Override\n-            public RestResponse buildResponse(GetResponse response) throws Exception {\n-                if (!response.isExists()) {\n-                    return new BytesRestResponse(RestStatus.NOT_FOUND, channel.newBuilder());\n-                }\n+            public RestResponse buildResponse(MultiGetResponse multiGetResponse) throws Exception {\n+                MultiGetItemResponse[] responses = multiGetResponse.getResponses();\n+                AnomalyDetector detector = null;\n+                XContentBuilder builder = null;\n+                Boolean adJobEnabled = false;\n+                for (MultiGetItemResponse response : responses) {\n+                    if (ANOMALY_DETECTORS_INDEX.equals(response.getIndex())) {\n+                        if (!response.getResponse().isExists()) {\n+                            return new BytesRestResponse(RestStatus.NOT_FOUND, channel.newBuilder());\n+                        }\n+                        builder = channel\n+                            .newBuilder()\n+                            .startObject()\n+                            .field(RestHandlerUtils._ID, response.getId())\n+                            .field(RestHandlerUtils._VERSION, response.getResponse().getVersion())\n+                            .field(RestHandlerUtils._PRIMARY_TERM, response.getResponse().getPrimaryTerm())\n+                            .field(RestHandlerUtils._SEQ_NO, response.getResponse().getSeqNo());\n+                        if (!response.getResponse().isSourceEmpty()) {\n+                            XContentParser parser = XContentHelper\n+                                .createParser(\n+                                    channel.request().getXContentRegistry(),\n+                                    LoggingDeprecationHandler.INSTANCE,\n+                                    response.getResponse().getSourceAsBytesRef(),\n+                                    XContentType.JSON\n+                                );\n+                            try {\n+                                ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+                                detector = parser.namedObject(AnomalyDetector.class, AnomalyDetector.PARSE_FIELD_NAME, null);\n+                            } catch (Throwable t) {\n+                                logger.error(\"Fail to parse detector\", t);\n+                                throw t;\n+                            } finally {\n+                                parser.close();\n+                            }\n+                        }\n+                    }\n \n-                XContentBuilder builder = channel\n-                    .newBuilder()\n-                    .startObject()\n-                    .field(RestHandlerUtils._ID, response.getId())\n-                    .field(RestHandlerUtils._VERSION, response.getVersion())\n-                    .field(RestHandlerUtils._PRIMARY_TERM, response.getPrimaryTerm())\n-                    .field(RestHandlerUtils._SEQ_NO, response.getSeqNo());\n-                if (!response.isSourceEmpty()) {\n-                    XContentParser parser = XContentHelper\n-                        .createParser(\n-                            channel.request().getXContentRegistry(),\n-                            LoggingDeprecationHandler.INSTANCE,\n-                            response.getSourceAsBytesRef(),\n-                            XContentType.JSON\n-                        );\n-                    try {\n-                        ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n-                        AnomalyDetector detector = parser.namedObject(AnomalyDetector.class, AnomalyDetector.PARSE_FIELD_NAME, null);\n-                        builder.field(RestHandlerUtils.ANOMALY_DETECTOR, detector);\n-                    } catch (Throwable t) {\n-                        logger.error(\"Fail to parse detector\", t);\n-                        throw t;\n-                    } finally {\n-                        parser.close();\n+                    if (ANOMALY_DETECTOR_JOB_INDEX.equals(response.getIndex())) {\n+                        if (!response.isFailed() && response.getResponse().isExists()) {\n+                            adJobEnabled = true;\n+                        }\n                     }\n                 }\n+                ToXContent.Params params = new ToXContent.MapParams(ImmutableMap.of(ENABLED_FIELD, adJobEnabled.toString()));\n+                builder.field(RestHandlerUtils.ANOMALY_DETECTOR, detector, params);", "originalCommit": "de8f27737498c215f680201a14653bfa928daff3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTMwODkwNg==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/44#discussion_r385308906", "bodyText": "IllegalArgumentException?", "author": "yizheliu-amazon", "createdAt": "2020-02-27T19:00:21Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/AnomalyDetectorJobRunner.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad;\n+\n+import com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetectorJob;\n+import com.amazon.opendistroforelasticsearch.ad.transport.AnomalyResultAction;\n+import com.amazon.opendistroforelasticsearch.ad.transport.AnomalyResultRequest;\n+import com.amazon.opendistroforelasticsearch.jobscheduler.spi.JobExecutionContext;\n+import com.amazon.opendistroforelasticsearch.jobscheduler.spi.LockModel;\n+import com.amazon.opendistroforelasticsearch.jobscheduler.spi.ScheduledJobParameter;\n+import com.amazon.opendistroforelasticsearch.jobscheduler.spi.ScheduledJobRunner;\n+import com.amazon.opendistroforelasticsearch.jobscheduler.spi.schedule.IntervalSchedule;\n+import com.amazon.opendistroforelasticsearch.jobscheduler.spi.utils.LockService;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.concurrent.ExecutorService;\n+\n+import static com.amazon.opendistroforelasticsearch.ad.AnomalyDetectorPlugin.AD_JOB_THREAD_POOL_NAME;\n+\n+/**\n+ * JobScheduler will call AD job runner to get anomaly result periodically\n+ */\n+public class AnomalyDetectorJobRunner implements ScheduledJobRunner {\n+    private static final Logger log = LogManager.getLogger(AnomalyDetectorJobRunner.class);\n+\n+    private static AnomalyDetectorJobRunner INSTANCE;\n+\n+    public static AnomalyDetectorJobRunner getJobRunnerInstance() {\n+        if (INSTANCE != null) {\n+            return INSTANCE;\n+        }\n+        synchronized (AnomalyDetectorJobRunner.class) {\n+            if (INSTANCE != null) {\n+                return INSTANCE;\n+            }\n+            INSTANCE = new AnomalyDetectorJobRunner();\n+            return INSTANCE;\n+        }\n+    }\n+\n+    private Client client;\n+    private ThreadPool threadPool;\n+\n+    private AnomalyDetectorJobRunner() {\n+        // Singleton class, use getJobRunnerInstance method instead of constructor\n+    }\n+\n+    public void setClient(Client client) {\n+        this.client = client;\n+    }\n+\n+    public void setThreadPool(ThreadPool threadPool) {\n+        this.threadPool = threadPool;\n+    }\n+\n+    @Override\n+    public void runJob(ScheduledJobParameter jobParameter, JobExecutionContext context) {\n+        log.info(\"Start to run AD job {}\", jobParameter.getName());\n+        if (!(jobParameter instanceof AnomalyDetectorJob)) {\n+            throw new IllegalStateException(", "originalCommit": "de8f27737498c215f680201a14653bfa928daff3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTMzNTI5MA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/44#discussion_r385335290", "bodyText": "will change it", "author": "ylwu-amzn", "createdAt": "2020-02-27T19:50:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTMwODkwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTMxMTYwMA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/44#discussion_r385311600", "bodyText": "nit: group by public/private so that they are in separate group", "author": "yizheliu-amazon", "createdAt": "2020-02-27T19:05:38Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/model/AnomalyDetectorJob.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad.model;\n+\n+import com.amazon.opendistroforelasticsearch.ad.util.ParseUtils;\n+import com.amazon.opendistroforelasticsearch.jobscheduler.spi.ScheduledJobParameter;\n+import com.amazon.opendistroforelasticsearch.jobscheduler.spi.schedule.Schedule;\n+import com.amazon.opendistroforelasticsearch.jobscheduler.spi.schedule.ScheduleParser;\n+import com.google.common.base.Objects;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+\n+import static com.amazon.opendistroforelasticsearch.ad.settings.AnomalyDetectorSettings.DEFAULT_AD_JOB_LOC_DURATION_SECONDS;\n+import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;\n+\n+/**\n+ * Anomaly detector job.\n+ */\n+public class AnomalyDetectorJob implements ToXContentObject, ScheduledJobParameter {\n+\n+    public static final String ANOMALY_DETECTOR_JOB_INDEX = \".opendistro-anomaly-detector-jobs\";\n+\n+    public static final String NAME_FIELD = \"name\";\n+    private static final String SCHEDULE_FIELD = \"schedule\";\n+    private static final String IS_ENABLED_FIELD = \"enabled\";\n+    private static final String ENABLED_TIME_FIELD = \"enabled_time\";\n+    public static final String LAST_UPDATE_TIME_FIELD = \"last_update_time\";\n+    public static final String LOCK_DURATION_SECONDS = \"lock_duration_seconds\";", "originalCommit": "de8f27737498c215f680201a14653bfa928daff3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTMzNTM2MQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/44#discussion_r385335361", "bodyText": "will change it", "author": "ylwu-amzn", "createdAt": "2020-02-27T19:50:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTMxMTYwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTMyMDY4OA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/44#discussion_r385320688", "bodyText": "nit: we may merge them together like this.\nif (response.getResult() == DocWriteResponse.Result.DELETED ||\n    response.getResult() == DocWriteResponse.Result.NOT_FOUND)", "author": "yizheliu-amazon", "createdAt": "2020-02-27T19:22:48Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/rest/handler/IndexAnomalyDetectorJobActionHandler.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad.rest.handler;\n+\n+import com.amazon.opendistroforelasticsearch.ad.AnomalyDetectorPlugin;\n+import com.amazon.opendistroforelasticsearch.ad.indices.AnomalyDetectionIndices;\n+import com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetector;\n+import com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetectorJob;\n+import com.amazon.opendistroforelasticsearch.ad.model.IntervalTimeConfiguration;\n+import com.amazon.opendistroforelasticsearch.ad.transport.StopDetectorAction;\n+import com.amazon.opendistroforelasticsearch.ad.transport.StopDetectorRequest;\n+import com.amazon.opendistroforelasticsearch.ad.transport.StopDetectorResponse;\n+import com.amazon.opendistroforelasticsearch.ad.util.RestHandlerUtils;\n+import com.amazon.opendistroforelasticsearch.jobscheduler.spi.schedule.IntervalSchedule;\n+import com.amazon.opendistroforelasticsearch.jobscheduler.spi.schedule.Schedule;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.DocWriteResponse;\n+import org.elasticsearch.action.admin.indices.create.CreateIndexResponse;\n+import org.elasticsearch.action.delete.DeleteRequest;\n+import org.elasticsearch.action.get.GetRequest;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.index.IndexRequest;\n+import org.elasticsearch.action.index.IndexResponse;\n+import org.elasticsearch.action.support.WriteRequest;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.common.xcontent.LoggingDeprecationHandler;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.rest.BytesRestResponse;\n+import org.elasticsearch.rest.RestChannel;\n+import org.elasticsearch.rest.RestResponse;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.rest.action.RestResponseListener;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Locale;\n+\n+import static com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetector.ANOMALY_DETECTORS_INDEX;\n+import static com.amazon.opendistroforelasticsearch.ad.util.RestHandlerUtils.XCONTENT_WITH_TYPE;\n+import static org.elasticsearch.common.xcontent.ToXContent.EMPTY_PARAMS;\n+import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;\n+\n+/**\n+ * Anomaly detector job REST action handler to process POST/PUT request.\n+ */\n+public class IndexAnomalyDetectorJobActionHandler extends AbstractActionHandler {\n+\n+    private final AnomalyDetectionIndices anomalyDetectionIndices;\n+    private final String detectorId;\n+    private final Long seqNo;\n+    private final Long primaryTerm;\n+    private final WriteRequest.RefreshPolicy refreshPolicy;\n+    private final ClusterService clusterService;\n+\n+    private final Logger logger = LogManager.getLogger(IndexAnomalyDetectorJobActionHandler.class);\n+    private final TimeValue requestTimeout;\n+    private volatile Integer maxAnomalyDetectors;\n+    private volatile Integer maxAnomalyFeatures;\n+    private final AnomalyDetectorActionHandler handler = new AnomalyDetectorActionHandler();\n+\n+    /**\n+     * Constructor function.\n+     *\n+     * @param clusterService          ClusterService\n+     * @param client                  ES node client that executes actions on the local node\n+     * @param channel                 ES channel used to construct bytes / builder based outputs, and send responses\n+     * @param anomalyDetectionIndices anomaly detector index manager\n+     * @param detectorId              detector identifier\n+     * @param seqNo                   sequence number of last modification\n+     * @param primaryTerm             primary term of last modification\n+     * @param refreshPolicy           refresh policy\n+     * @param requestTimeout          request time out configuration\n+     */\n+    public IndexAnomalyDetectorJobActionHandler(\n+        ClusterService clusterService,\n+        NodeClient client,\n+        RestChannel channel,\n+        AnomalyDetectionIndices anomalyDetectionIndices,\n+        String detectorId,\n+        Long seqNo,\n+        Long primaryTerm,\n+        WriteRequest.RefreshPolicy refreshPolicy,\n+        TimeValue requestTimeout\n+    ) {\n+        super(client, channel);\n+        this.clusterService = clusterService;\n+        this.anomalyDetectionIndices = anomalyDetectionIndices;\n+        this.detectorId = detectorId;\n+        this.seqNo = seqNo;\n+        this.primaryTerm = primaryTerm;\n+        this.refreshPolicy = refreshPolicy;\n+        this.requestTimeout = requestTimeout;\n+    }\n+\n+    /**\n+     * Start function to process create/update anomaly detector job request.\n+     * Check if anomaly detector job index exist first, if not, will create first.\n+     *\n+     * @throws IOException IOException from {@link AnomalyDetectionIndices#initAnomalyDetectorIndexIfAbsent(ActionListener)}\n+     */\n+    public void start() throws IOException {\n+        if (!anomalyDetectionIndices.doesAnomalyDetectorJobIndexExist()) {\n+            anomalyDetectionIndices\n+                .initAnomalyDetectorIndex(\n+                    ActionListener.wrap(response -> onCreateMappingsResponse(response), exception -> onFailure(exception))\n+                );\n+        } else {\n+            prepareAnomalyDetectorJobIndexing();\n+        }\n+    }\n+\n+    /**\n+     * Create anomaly detector job.\n+     *\n+     * @throws IOException IOException from {@link AnomalyDetectionIndices#getAnomalyDetectorJobMappings}\n+     */\n+    public void createAnomalyDetectorJob() throws IOException {\n+        if (!anomalyDetectionIndices.doesAnomalyDetectorJobIndexExist()) {\n+            anomalyDetectionIndices\n+                .initAnomalyDetectorJobIndex(\n+                    ActionListener.wrap(response -> onCreateMappingsResponse(response), exception -> onFailure(exception))\n+                );\n+        } else {\n+            prepareAnomalyDetectorJobIndexing();\n+        }\n+    }\n+\n+    private void prepareAnomalyDetectorJobIndexing() {\n+        GetRequest getRequest = new GetRequest(AnomalyDetector.ANOMALY_DETECTORS_INDEX).id(detectorId);\n+        client.get(getRequest, ActionListener.wrap(response -> onGetAnomalyDetectorResponse(response), exception -> onFailure(exception)));\n+    }\n+\n+    private void onGetAnomalyDetectorResponse(GetResponse response) throws IOException {\n+        if (!response.isExists()) {\n+            XContentBuilder builder = channel\n+                .newErrorBuilder()\n+                .startObject()\n+                .field(\"Message\", \"AnomalyDetector is not found with id: \" + detectorId)\n+                .endObject();\n+            channel.sendResponse(new BytesRestResponse(RestStatus.NOT_FOUND, response.toXContent(builder, EMPTY_PARAMS)));\n+            return;\n+        }\n+        XContentParser parser = XContentType.JSON\n+            .xContent()\n+            .createParser(\n+                channel.request().getXContentRegistry(),\n+                LoggingDeprecationHandler.INSTANCE,\n+                response.getSourceAsBytesRef().streamInput()\n+            );\n+\n+        ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+        AnomalyDetector detector = AnomalyDetector.parse(parser, response.getId(), response.getVersion());\n+\n+        IntervalTimeConfiguration interval = (IntervalTimeConfiguration) detector.getDetectionInterval();\n+        Schedule schedule = new IntervalSchedule(Instant.now(), (int) interval.getInterval(), interval.getUnit());\n+        Duration duration = Duration.of(interval.getInterval(), interval.getUnit());\n+        AnomalyDetectorJob job = new AnomalyDetectorJob(\n+            detector.getDetectorId(),\n+            schedule,\n+            true,\n+            Instant.now(),\n+            Instant.now(),\n+            duration.getSeconds()\n+        );\n+\n+        getAnomalyDetectorJob(job);\n+    }\n+\n+    private void getAnomalyDetectorJob(AnomalyDetectorJob job) {\n+        GetRequest getRequest = new GetRequest(AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX).id(detectorId);\n+\n+        client.get(getRequest, ActionListener.wrap(response -> onGetAnomalyDetectorJob(response, job), exception -> onFailure(exception)));\n+    }\n+\n+    private void onGetAnomalyDetectorJob(GetResponse response, AnomalyDetectorJob job) throws IOException {\n+        if (response.isExists()) {\n+            XContentBuilder builder = channel\n+                .newErrorBuilder()\n+                .startObject()\n+                .field(\"Message\", \"AnomalyDetectorJob exists: \" + detectorId)\n+                .endObject();\n+            channel.sendResponse(new BytesRestResponse(RestStatus.NOT_FOUND, response.toXContent(builder, EMPTY_PARAMS)));\n+            return;\n+        }\n+\n+        indexAnomalyDetectorJob(job);\n+    }\n+\n+    private void indexAnomalyDetectorJob(AnomalyDetectorJob job) throws IOException {\n+        IndexRequest indexRequest = new IndexRequest(AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX)\n+            .setRefreshPolicy(refreshPolicy)\n+            .source(job.toXContent(channel.newBuilder(), XCONTENT_WITH_TYPE))\n+            .setIfSeqNo(seqNo)\n+            .setIfPrimaryTerm(primaryTerm)\n+            .timeout(requestTimeout);\n+        if (detectorId != null) {\n+            indexRequest.id(detectorId);\n+        }\n+        client.index(indexRequest, indexAnomalyDetectorJobResponse());\n+    }\n+\n+    private ActionListener<IndexResponse> indexAnomalyDetectorJobResponse() {\n+        return new RestResponseListener<IndexResponse>(channel) {\n+            @Override\n+            public RestResponse buildResponse(IndexResponse response) throws Exception {\n+                if (response.getShardInfo().getSuccessful() < 1) {\n+                    return new BytesRestResponse(response.status(), response.toXContent(channel.newErrorBuilder(), EMPTY_PARAMS));\n+                }\n+\n+                XContentBuilder builder = channel\n+                    .newBuilder()\n+                    .startObject()\n+                    .field(RestHandlerUtils._ID, response.getId())\n+                    .field(RestHandlerUtils._VERSION, response.getVersion())\n+                    .field(RestHandlerUtils._SEQ_NO, response.getSeqNo())\n+                    .field(RestHandlerUtils._PRIMARY_TERM, response.getPrimaryTerm())\n+                    .endObject();\n+\n+                BytesRestResponse restResponse = new BytesRestResponse(response.status(), builder);\n+                if (response.status() == RestStatus.CREATED) {\n+                    String location = String.format(Locale.ROOT, \"%s/%s\", AnomalyDetectorPlugin.AD_BASE_URI, response.getId());\n+                    restResponse.addHeader(\"Location\", location);\n+                }\n+                return restResponse;\n+            }\n+        };\n+    }\n+\n+    private void onCreateMappingsResponse(CreateIndexResponse response) throws IOException {\n+        if (response.isAcknowledged()) {\n+            logger.info(\"Created {} with mappings.\", ANOMALY_DETECTORS_INDEX);\n+            prepareAnomalyDetectorJobIndexing();\n+        } else {\n+            logger.warn(\"Created {} with mappings call not acknowledged.\", ANOMALY_DETECTORS_INDEX);\n+            channel\n+                .sendResponse(\n+                    new BytesRestResponse(RestStatus.INTERNAL_SERVER_ERROR, response.toXContent(channel.newErrorBuilder(), EMPTY_PARAMS))\n+                );\n+        }\n+    }\n+\n+    /**\n+     * Delete anomaly detector job\n+     * @param detectorId detector identifier\n+     */\n+    public void deleteAnomalyDetectorJob(String detectorId) {\n+        GetRequest getRequest = new GetRequest(AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX).id(detectorId);\n+\n+        client\n+            .get(\n+                getRequest,\n+                ActionListener\n+                    .wrap(\n+                        response -> deleteAnomalyDetectorJobDoc(client, detectorId, channel, refreshPolicy),\n+                        exception -> onFailure(exception)\n+                    )\n+            );\n+    }\n+\n+    private void deleteAnomalyDetectorJobDoc(\n+        NodeClient client,\n+        String detectorId,\n+        RestChannel channel,\n+        WriteRequest.RefreshPolicy refreshPolicy\n+    ) {\n+        logger.info(\"Delete anomaly detector job {}\", detectorId);\n+        DeleteRequest deleteRequest = new DeleteRequest(AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX, detectorId)\n+            .setRefreshPolicy(refreshPolicy);\n+        client.delete(deleteRequest, ActionListener.wrap(response -> {\n+            if (response.getResult() == DocWriteResponse.Result.DELETED) {\n+                logger.info(\"Stop anomaly detector {}\", detectorId);\n+                StopDetectorRequest stopDetectorRequest = new StopDetectorRequest(detectorId);\n+                client.execute(StopDetectorAction.INSTANCE, stopDetectorRequest, stopAdDetectorListener(channel, detectorId));\n+            } else if (response.getResult() == DocWriteResponse.Result.NOT_FOUND) {\n+                logger.info(\"Anomaly detector job not found: {}\", detectorId);\n+                StopDetectorRequest stopDetectorRequest = new StopDetectorRequest(detectorId);\n+                client.execute(StopDetectorAction.INSTANCE, stopDetectorRequest, stopAdDetectorListener(channel, detectorId));", "originalCommit": "de8f27737498c215f680201a14653bfa928daff3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTMzODQwOQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/44#discussion_r385338409", "bodyText": "This is to log different message for these two cases", "author": "ylwu-amzn", "createdAt": "2020-02-27T19:56:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTMyMDY4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTM0NDk0MQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/44#discussion_r385344941", "bodyText": "got it.", "author": "yizheliu-amazon", "createdAt": "2020-02-27T20:09:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTMyMDY4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTMyNjc3MA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/44#discussion_r385326770", "bodyText": "nit: DETECT_DATA_ACTION -> EXECUTE_AD_ACTION? EXECUTE_AD_ACTION sounds more reasonable to me.", "author": "yizheliu-amazon", "createdAt": "2020-02-27T19:34:06Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/rest/RestAnomalyDetectorJobAction.java", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad.rest;\n+\n+import com.amazon.opendistroforelasticsearch.ad.AnomalyDetectorPlugin;\n+import com.amazon.opendistroforelasticsearch.ad.indices.AnomalyDetectionIndices;\n+import com.amazon.opendistroforelasticsearch.ad.rest.handler.IndexAnomalyDetectorJobActionHandler;\n+import org.elasticsearch.action.support.WriteRequest;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.index.seqno.SequenceNumbers;\n+import org.elasticsearch.rest.BaseRestHandler;\n+import org.elasticsearch.rest.RestController;\n+import org.elasticsearch.rest.RestRequest;\n+\n+import java.io.IOException;\n+import java.util.Locale;\n+\n+import static com.amazon.opendistroforelasticsearch.ad.settings.AnomalyDetectorSettings.REQUEST_TIMEOUT;\n+import static com.amazon.opendistroforelasticsearch.ad.util.RestHandlerUtils.DETECTOR_ID;\n+import static com.amazon.opendistroforelasticsearch.ad.util.RestHandlerUtils.IF_PRIMARY_TERM;\n+import static com.amazon.opendistroforelasticsearch.ad.util.RestHandlerUtils.IF_SEQ_NO;\n+import static com.amazon.opendistroforelasticsearch.ad.util.RestHandlerUtils.REFRESH;\n+import static com.amazon.opendistroforelasticsearch.ad.util.RestHandlerUtils.START_JOB;\n+import static com.amazon.opendistroforelasticsearch.ad.util.RestHandlerUtils.STOP_JOB;\n+\n+/**\n+ * This class consists of the REST handler to handle request to start/stop AD job.\n+ */\n+public class RestAnomalyDetectorJobAction extends BaseRestHandler {\n+\n+    public static final String DETECT_DATA_ACTION = \"execute_anomaly_detector\";", "originalCommit": "de8f27737498c215f680201a14653bfa928daff3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTMzOTc1OA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/44#discussion_r385339758", "bodyText": "Good catch, actually it should be AD_JOB_ACTION. Will change it", "author": "ylwu-amzn", "createdAt": "2020-02-27T19:59:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTMyNjc3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTMzODM0Nw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/44#discussion_r385338347", "bodyText": "Is this method used anywhere? Looks like we can remove it.", "author": "yizheliu-amazon", "createdAt": "2020-02-27T19:56:23Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/rest/handler/IndexAnomalyDetectorJobActionHandler.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad.rest.handler;\n+\n+import com.amazon.opendistroforelasticsearch.ad.AnomalyDetectorPlugin;\n+import com.amazon.opendistroforelasticsearch.ad.indices.AnomalyDetectionIndices;\n+import com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetector;\n+import com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetectorJob;\n+import com.amazon.opendistroforelasticsearch.ad.model.IntervalTimeConfiguration;\n+import com.amazon.opendistroforelasticsearch.ad.transport.StopDetectorAction;\n+import com.amazon.opendistroforelasticsearch.ad.transport.StopDetectorRequest;\n+import com.amazon.opendistroforelasticsearch.ad.transport.StopDetectorResponse;\n+import com.amazon.opendistroforelasticsearch.ad.util.RestHandlerUtils;\n+import com.amazon.opendistroforelasticsearch.jobscheduler.spi.schedule.IntervalSchedule;\n+import com.amazon.opendistroforelasticsearch.jobscheduler.spi.schedule.Schedule;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.DocWriteResponse;\n+import org.elasticsearch.action.admin.indices.create.CreateIndexResponse;\n+import org.elasticsearch.action.delete.DeleteRequest;\n+import org.elasticsearch.action.get.GetRequest;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.index.IndexRequest;\n+import org.elasticsearch.action.index.IndexResponse;\n+import org.elasticsearch.action.support.WriteRequest;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.common.xcontent.LoggingDeprecationHandler;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.rest.BytesRestResponse;\n+import org.elasticsearch.rest.RestChannel;\n+import org.elasticsearch.rest.RestResponse;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.rest.action.RestResponseListener;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Locale;\n+\n+import static com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetector.ANOMALY_DETECTORS_INDEX;\n+import static com.amazon.opendistroforelasticsearch.ad.util.RestHandlerUtils.XCONTENT_WITH_TYPE;\n+import static org.elasticsearch.common.xcontent.ToXContent.EMPTY_PARAMS;\n+import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;\n+\n+/**\n+ * Anomaly detector job REST action handler to process POST/PUT request.\n+ */\n+public class IndexAnomalyDetectorJobActionHandler extends AbstractActionHandler {\n+\n+    private final AnomalyDetectionIndices anomalyDetectionIndices;\n+    private final String detectorId;\n+    private final Long seqNo;\n+    private final Long primaryTerm;\n+    private final WriteRequest.RefreshPolicy refreshPolicy;\n+    private final ClusterService clusterService;\n+\n+    private final Logger logger = LogManager.getLogger(IndexAnomalyDetectorJobActionHandler.class);\n+    private final TimeValue requestTimeout;\n+    private volatile Integer maxAnomalyDetectors;\n+    private volatile Integer maxAnomalyFeatures;\n+    private final AnomalyDetectorActionHandler handler = new AnomalyDetectorActionHandler();\n+\n+    /**\n+     * Constructor function.\n+     *\n+     * @param clusterService          ClusterService\n+     * @param client                  ES node client that executes actions on the local node\n+     * @param channel                 ES channel used to construct bytes / builder based outputs, and send responses\n+     * @param anomalyDetectionIndices anomaly detector index manager\n+     * @param detectorId              detector identifier\n+     * @param seqNo                   sequence number of last modification\n+     * @param primaryTerm             primary term of last modification\n+     * @param refreshPolicy           refresh policy\n+     * @param requestTimeout          request time out configuration\n+     */\n+    public IndexAnomalyDetectorJobActionHandler(\n+        ClusterService clusterService,\n+        NodeClient client,\n+        RestChannel channel,\n+        AnomalyDetectionIndices anomalyDetectionIndices,\n+        String detectorId,\n+        Long seqNo,\n+        Long primaryTerm,\n+        WriteRequest.RefreshPolicy refreshPolicy,\n+        TimeValue requestTimeout\n+    ) {\n+        super(client, channel);\n+        this.clusterService = clusterService;\n+        this.anomalyDetectionIndices = anomalyDetectionIndices;\n+        this.detectorId = detectorId;\n+        this.seqNo = seqNo;\n+        this.primaryTerm = primaryTerm;\n+        this.refreshPolicy = refreshPolicy;\n+        this.requestTimeout = requestTimeout;\n+    }\n+\n+    /**\n+     * Start function to process create/update anomaly detector job request.\n+     * Check if anomaly detector job index exist first, if not, will create first.\n+     *\n+     * @throws IOException IOException from {@link AnomalyDetectionIndices#initAnomalyDetectorIndexIfAbsent(ActionListener)}\n+     */\n+    public void start() throws IOException {\n+        if (!anomalyDetectionIndices.doesAnomalyDetectorJobIndexExist()) {\n+            anomalyDetectionIndices\n+                .initAnomalyDetectorIndex(\n+                    ActionListener.wrap(response -> onCreateMappingsResponse(response), exception -> onFailure(exception))\n+                );\n+        } else {\n+            prepareAnomalyDetectorJobIndexing();\n+        }\n+    }", "originalCommit": "de8f27737498c215f680201a14653bfa928daff3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTMzOTkyMg==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/44#discussion_r385339922", "bodyText": "Will remove it", "author": "ylwu-amzn", "createdAt": "2020-02-27T19:59:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTMzODM0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTM0Mjc3OA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/44#discussion_r385342778", "bodyText": "question: in what scenario detectoId can be null?\nAs per my understanding, I think we may not need to do this check since detectorId must already be there when we index a new AD job.\nI would suggest removing this null check, and adding detectorId null check at 1st line of prepareRequest() in RestAnomalyDetectorJobAction.java", "author": "yizheliu-amazon", "createdAt": "2020-02-27T20:05:14Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/rest/handler/IndexAnomalyDetectorJobActionHandler.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/*\n+ * Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.ad.rest.handler;\n+\n+import com.amazon.opendistroforelasticsearch.ad.AnomalyDetectorPlugin;\n+import com.amazon.opendistroforelasticsearch.ad.indices.AnomalyDetectionIndices;\n+import com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetector;\n+import com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetectorJob;\n+import com.amazon.opendistroforelasticsearch.ad.model.IntervalTimeConfiguration;\n+import com.amazon.opendistroforelasticsearch.ad.transport.StopDetectorAction;\n+import com.amazon.opendistroforelasticsearch.ad.transport.StopDetectorRequest;\n+import com.amazon.opendistroforelasticsearch.ad.transport.StopDetectorResponse;\n+import com.amazon.opendistroforelasticsearch.ad.util.RestHandlerUtils;\n+import com.amazon.opendistroforelasticsearch.jobscheduler.spi.schedule.IntervalSchedule;\n+import com.amazon.opendistroforelasticsearch.jobscheduler.spi.schedule.Schedule;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.DocWriteResponse;\n+import org.elasticsearch.action.admin.indices.create.CreateIndexResponse;\n+import org.elasticsearch.action.delete.DeleteRequest;\n+import org.elasticsearch.action.get.GetRequest;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.index.IndexRequest;\n+import org.elasticsearch.action.index.IndexResponse;\n+import org.elasticsearch.action.support.WriteRequest;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.common.xcontent.LoggingDeprecationHandler;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.rest.BytesRestResponse;\n+import org.elasticsearch.rest.RestChannel;\n+import org.elasticsearch.rest.RestResponse;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.rest.action.RestResponseListener;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Locale;\n+\n+import static com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetector.ANOMALY_DETECTORS_INDEX;\n+import static com.amazon.opendistroforelasticsearch.ad.util.RestHandlerUtils.XCONTENT_WITH_TYPE;\n+import static org.elasticsearch.common.xcontent.ToXContent.EMPTY_PARAMS;\n+import static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;\n+\n+/**\n+ * Anomaly detector job REST action handler to process POST/PUT request.\n+ */\n+public class IndexAnomalyDetectorJobActionHandler extends AbstractActionHandler {\n+\n+    private final AnomalyDetectionIndices anomalyDetectionIndices;\n+    private final String detectorId;\n+    private final Long seqNo;\n+    private final Long primaryTerm;\n+    private final WriteRequest.RefreshPolicy refreshPolicy;\n+    private final ClusterService clusterService;\n+\n+    private final Logger logger = LogManager.getLogger(IndexAnomalyDetectorJobActionHandler.class);\n+    private final TimeValue requestTimeout;\n+    private volatile Integer maxAnomalyDetectors;\n+    private volatile Integer maxAnomalyFeatures;\n+    private final AnomalyDetectorActionHandler handler = new AnomalyDetectorActionHandler();\n+\n+    /**\n+     * Constructor function.\n+     *\n+     * @param clusterService          ClusterService\n+     * @param client                  ES node client that executes actions on the local node\n+     * @param channel                 ES channel used to construct bytes / builder based outputs, and send responses\n+     * @param anomalyDetectionIndices anomaly detector index manager\n+     * @param detectorId              detector identifier\n+     * @param seqNo                   sequence number of last modification\n+     * @param primaryTerm             primary term of last modification\n+     * @param refreshPolicy           refresh policy\n+     * @param requestTimeout          request time out configuration\n+     */\n+    public IndexAnomalyDetectorJobActionHandler(\n+        ClusterService clusterService,\n+        NodeClient client,\n+        RestChannel channel,\n+        AnomalyDetectionIndices anomalyDetectionIndices,\n+        String detectorId,\n+        Long seqNo,\n+        Long primaryTerm,\n+        WriteRequest.RefreshPolicy refreshPolicy,\n+        TimeValue requestTimeout\n+    ) {\n+        super(client, channel);\n+        this.clusterService = clusterService;\n+        this.anomalyDetectionIndices = anomalyDetectionIndices;\n+        this.detectorId = detectorId;\n+        this.seqNo = seqNo;\n+        this.primaryTerm = primaryTerm;\n+        this.refreshPolicy = refreshPolicy;\n+        this.requestTimeout = requestTimeout;\n+    }\n+\n+    /**\n+     * Start function to process create/update anomaly detector job request.\n+     * Check if anomaly detector job index exist first, if not, will create first.\n+     *\n+     * @throws IOException IOException from {@link AnomalyDetectionIndices#initAnomalyDetectorIndexIfAbsent(ActionListener)}\n+     */\n+    public void start() throws IOException {\n+        if (!anomalyDetectionIndices.doesAnomalyDetectorJobIndexExist()) {\n+            anomalyDetectionIndices\n+                .initAnomalyDetectorIndex(\n+                    ActionListener.wrap(response -> onCreateMappingsResponse(response), exception -> onFailure(exception))\n+                );\n+        } else {\n+            prepareAnomalyDetectorJobIndexing();\n+        }\n+    }\n+\n+    /**\n+     * Create anomaly detector job.\n+     *\n+     * @throws IOException IOException from {@link AnomalyDetectionIndices#getAnomalyDetectorJobMappings}\n+     */\n+    public void createAnomalyDetectorJob() throws IOException {\n+        if (!anomalyDetectionIndices.doesAnomalyDetectorJobIndexExist()) {\n+            anomalyDetectionIndices\n+                .initAnomalyDetectorJobIndex(\n+                    ActionListener.wrap(response -> onCreateMappingsResponse(response), exception -> onFailure(exception))\n+                );\n+        } else {\n+            prepareAnomalyDetectorJobIndexing();\n+        }\n+    }\n+\n+    private void prepareAnomalyDetectorJobIndexing() {\n+        GetRequest getRequest = new GetRequest(AnomalyDetector.ANOMALY_DETECTORS_INDEX).id(detectorId);\n+        client.get(getRequest, ActionListener.wrap(response -> onGetAnomalyDetectorResponse(response), exception -> onFailure(exception)));\n+    }\n+\n+    private void onGetAnomalyDetectorResponse(GetResponse response) throws IOException {\n+        if (!response.isExists()) {\n+            XContentBuilder builder = channel\n+                .newErrorBuilder()\n+                .startObject()\n+                .field(\"Message\", \"AnomalyDetector is not found with id: \" + detectorId)\n+                .endObject();\n+            channel.sendResponse(new BytesRestResponse(RestStatus.NOT_FOUND, response.toXContent(builder, EMPTY_PARAMS)));\n+            return;\n+        }\n+        XContentParser parser = XContentType.JSON\n+            .xContent()\n+            .createParser(\n+                channel.request().getXContentRegistry(),\n+                LoggingDeprecationHandler.INSTANCE,\n+                response.getSourceAsBytesRef().streamInput()\n+            );\n+\n+        ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.nextToken(), parser::getTokenLocation);\n+        AnomalyDetector detector = AnomalyDetector.parse(parser, response.getId(), response.getVersion());\n+\n+        IntervalTimeConfiguration interval = (IntervalTimeConfiguration) detector.getDetectionInterval();\n+        Schedule schedule = new IntervalSchedule(Instant.now(), (int) interval.getInterval(), interval.getUnit());\n+        Duration duration = Duration.of(interval.getInterval(), interval.getUnit());\n+        AnomalyDetectorJob job = new AnomalyDetectorJob(\n+            detector.getDetectorId(),\n+            schedule,\n+            true,\n+            Instant.now(),\n+            Instant.now(),\n+            duration.getSeconds()\n+        );\n+\n+        getAnomalyDetectorJob(job);\n+    }\n+\n+    private void getAnomalyDetectorJob(AnomalyDetectorJob job) {\n+        GetRequest getRequest = new GetRequest(AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX).id(detectorId);\n+\n+        client.get(getRequest, ActionListener.wrap(response -> onGetAnomalyDetectorJob(response, job), exception -> onFailure(exception)));\n+    }\n+\n+    private void onGetAnomalyDetectorJob(GetResponse response, AnomalyDetectorJob job) throws IOException {\n+        if (response.isExists()) {\n+            XContentBuilder builder = channel\n+                .newErrorBuilder()\n+                .startObject()\n+                .field(\"Message\", \"AnomalyDetectorJob exists: \" + detectorId)\n+                .endObject();\n+            channel.sendResponse(new BytesRestResponse(RestStatus.NOT_FOUND, response.toXContent(builder, EMPTY_PARAMS)));\n+            return;\n+        }\n+\n+        indexAnomalyDetectorJob(job);\n+    }\n+\n+    private void indexAnomalyDetectorJob(AnomalyDetectorJob job) throws IOException {\n+        IndexRequest indexRequest = new IndexRequest(AnomalyDetectorJob.ANOMALY_DETECTOR_JOB_INDEX)\n+            .setRefreshPolicy(refreshPolicy)\n+            .source(job.toXContent(channel.newBuilder(), XCONTENT_WITH_TYPE))\n+            .setIfSeqNo(seqNo)\n+            .setIfPrimaryTerm(primaryTerm)\n+            .timeout(requestTimeout);\n+        if (detectorId != null) {\n+            indexRequest.id(detectorId);\n+        }", "originalCommit": "de8f27737498c215f680201a14653bfa928daff3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTM2Nzc0OA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/44#discussion_r385367748", "bodyText": "Some testing code. Will change it. detectorId will never be null.", "author": "ylwu-amzn", "createdAt": "2020-02-27T20:58:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTM0Mjc3OA=="}], "type": "inlineReview"}, {"oid": "509b65e5913f085ca422872be282274fdd3f5cf9", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/509b65e5913f085ca422872be282274fdd3f5cf9", "message": "fix comments", "committedDate": "2020-02-27T21:54:50Z", "type": "commit"}]}