{"pr_number": 208, "pr_title": "Change to use callbacks in cold start", "pr_createdAt": "2020-08-11T01:28:11Z", "pr_url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc2MTE5NA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r468761194", "bodyText": "minor: Shall we add this as last constant? ( constants arranged alphabetically )", "author": "VijayanB", "createdAt": "2020-08-11T17:54:34Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/AnomalyDetectorPlugin.java", "diffHunk": "@@ -142,6 +141,7 @@\n     public static final String AD_BASE_URI = \"/_opendistro/_anomaly_detection\";\n     public static final String AD_BASE_DETECTORS_URI = AD_BASE_URI + \"/detectors\";\n     public static final String AD_THREAD_POOL_NAME = \"ad-threadpool\";\n+    public static final String COLD_START_THREAD_POOL_NAME = \"ad-cold-start-threadpool\";", "originalCommit": "007b5d3a0829f549e60109dafa8dced7ea7ed0b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODgyODEwNA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r468828104", "bodyText": "changed", "author": "kaituo", "createdAt": "2020-08-11T19:54:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc2MTE5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc2NDI3Mg==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r468764272", "bodyText": "Question: Is it possible to have both (lastDetectionError and lastColdStartException) to be not null ?", "author": "VijayanB", "createdAt": "2020-08-11T17:59:42Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/TransportState.java", "diffHunk": "@@ -88,8 +99,11 @@ public boolean expired(Duration stateTtl, Instant now) {\n         if (checkpoint != null) {\n             ans = ans && expired(stateTtl, now, checkpoint);\n         }\n-        if (lastError != null) {\n-            ans = ans && expired(stateTtl, now, lastError.getValue());\n+        if (lastDetectionError != null) {", "originalCommit": "007b5d3a0829f549e60109dafa8dced7ea7ed0b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODgyODYyOQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r468828629", "bodyText": "yes, it is possible.", "author": "kaituo", "createdAt": "2020-08-11T19:55:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc2NDI3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc2ODQ0Mw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r468768443", "bodyText": "Question: Where is this used?", "author": "VijayanB", "createdAt": "2020-08-11T18:07:13Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/TransportStateManager.java", "diffHunk": "@@ -250,12 +250,37 @@ public String getLastError(String adID) {\n     }\n \n     /**\n-     * Set last error of a detector\n+     * Set last detection error of a detector\n      * @param adID detector id\n      * @param error error, can be null\n      */\n-    public void setLastError(String adID, String error) {\n+    public void setLastDetectionError(String adID, String error) {\n         TransportState state = transportStates.computeIfAbsent(adID, id -> new TransportState(id));\n-        state.setLastError(new SimpleEntry<>(error, clock.instant()));\n+        state.setLastDetectionError(new SimpleEntry<>(error, clock.instant()));\n+    }\n+\n+    /**\n+     * Set last cold start error of a detector\n+     * @param adID detector id\n+     * @param exception exception, can be null\n+     */\n+    public void setLastColdStartException(String adID, Exception exception) {\n+        TransportState state = transportStates.computeIfAbsent(adID, id -> new TransportState(id));\n+        state.setLastColdStartException(new SimpleEntry<>(exception, clock.instant()));\n+    }\n+\n+    /**\n+     * Get last cold start exception of a detector\n+     * @param adID detector id\n+     * @return last cold start exception for the detector\n+     */\n+    public Exception fetchColdStartException(String adID) {", "originalCommit": "007b5d3a0829f549e60109dafa8dced7ea7ed0b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODgyOTAyMQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r468829021", "bodyText": "It is used in AnomalyResultTransportAction.", "author": "kaituo", "createdAt": "2020-08-11T19:56:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc2ODQ0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg3OTY2Nw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r468879667", "bodyText": "Got it. For some reason AnomalyResultTransportAction was not loaded .", "author": "VijayanB", "createdAt": "2020-08-11T21:38:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc2ODQ0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg3OTM0NQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r468879345", "bodyText": "since detectorId is already extracted, can we reuse it here and other places like 811, 802 ?", "author": "VijayanB", "createdAt": "2020-08-11T21:37:36Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "diffHunk": "@@ -770,39 +775,122 @@ private boolean shouldStart(\n         return true;\n     }\n \n-    class ColdStartJob implements Callable<Boolean> {\n+    private void coldStart(AnomalyDetector detector) {\n+        String detectorId = detector.getDetectorId();\n+\n+        ActionListener<Optional<double[][]>> listener = ActionListener.wrap(trainingData -> {\n+            if (trainingData.isPresent()) {\n+                double[][] dataPoints = trainingData.get();\n+\n+                ActionListener<Void> trainModelListener = ActionListener\n+                    .wrap(res -> { LOG.info(\"Succeeded in training {}\", detectorId); }, exception -> {\n+                        if (exception instanceof AnomalyDetectionException) {\n+                            // partitioned model exceeds memory limit\n+                            stateManager.setLastColdStartException(detectorId, exception);\n+                        } else if (exception instanceof IllegalArgumentException) {\n+                            // IllegalArgumentException due to invalid training data\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new EndRunException(detector.getDetectorId(), \"Invalid training data\", exception, false)", "originalCommit": "d59b96bfd6d8e80fb8f2cc24e09e254e2f4e7786", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQwNDcxNQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r469404715", "bodyText": "Nice catch.  Changed.", "author": "kaituo", "createdAt": "2020-08-12T16:56:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg3OTM0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg4NDI1Mw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r468884253", "bodyText": "Shall we do short circuit like below?\nif ( exp == null )\nreturn null\nand then...\nif !(exp instanceof  ResourceNotFoundException)\nthrow exp\nString adID = detector.getDetectorID();\n......\nUsually it is hard to read if there is nested scope and else .\nAlso it increases Cyclomatic complexity .", "author": "VijayanB", "createdAt": "2020-08-11T21:49:08Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "diffHunk": "@@ -397,32 +396,44 @@ protected void doExecute(Task task, ActionRequest actionRequest, ActionListener<\n      *\n      * @param failure  object that may contain exceptions thrown\n      * @param detector detector object\n-     * @return whether cold start runs\n+     * @return exception if we get resource not found exception\n      * @throws AnomalyDetectionException List of exceptions we can throw\n      *     1. Exception from cold start:\n      *       1). InternalFailure due to\n      *         a. ElasticsearchTimeoutException thrown by putModelCheckpoint during cold start\n      *       2). EndRunException with endNow equal to false\n      *         a. training data not available\n      *         b. cold start cannot succeed\n+     *         c. invalid training data\n+     *       3) EndRunException with endNow equal to true\n+     *         a. invalid search query\n      *     2. LimitExceededException from one of RCF model node when the total size of the models\n      *      is more than X% of heap memory.\n      *     3. InternalFailure wrapping ElasticsearchTimeoutException inside caused by\n      *      RCF/Threshold model node failing to get checkpoint to restore model before timeout.\n      */\n-    private boolean coldStartIfNoModel(AtomicReference<AnomalyDetectionException> failure, AnomalyDetector detector)\n+    private Exception coldStartIfNoModel(AtomicReference<AnomalyDetectionException> failure, AnomalyDetector detector)\n         throws AnomalyDetectionException {\n         AnomalyDetectionException exp = failure.get();", "originalCommit": "d59b96bfd6d8e80fb8f2cc24e09e254e2f4e7786", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQwNjc1OQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r469406759", "bodyText": "changed.", "author": "kaituo", "createdAt": "2020-08-12T17:00:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg4NDI1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU3NDQ2Ng==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r469574466", "bodyText": "why keep the overhead of an additional thread pool constantly when model training is at best occasional?", "author": "wnbts", "createdAt": "2020-08-12T22:09:02Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/AnomalyDetectorPlugin.java", "diffHunk": "@@ -400,14 +399,21 @@ private static Void initGson() {\n \n     @Override\n     public List<ExecutorBuilder<?>> getExecutorBuilders(Settings settings) {\n-        return Collections\n-            .singletonList(\n+        return Arrays\n+            .asList(\n                 new FixedExecutorBuilder(\n                     settings,\n                     AD_THREAD_POOL_NAME,\n                     Math.max(1, EsExecutors.allocatedProcessors(settings) / 4),\n                     AnomalyDetectorSettings.AD_THEAD_POOL_QUEUE_SIZE,\n                     \"opendistro.ad.\" + AD_THREAD_POOL_NAME\n+                ),\n+                new FixedExecutorBuilder(", "originalCommit": "7e3065fc68a4841f4a3713390ac7acb07721e1c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI3MTcwNg==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r470271706", "bodyText": "removed", "author": "kaituo", "createdAt": "2020-08-13T21:57:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU3NDQ2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU3ODMyNw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r469578327", "bodyText": "why should this query call back be run separately?", "author": "wnbts", "createdAt": "2020-08-12T22:19:04Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/feature/FeatureManager.java", "diffHunk": "@@ -330,22 +336,38 @@ private LongStream getFullShingleEndTimes(long endTime, long intervalMilli) {\n      *                 onFailure is called with EndRunException on feature query creation errors\n      */\n     public void getColdStartData(AnomalyDetector detector, ActionListener<Optional<double[][]>> listener) {\n+        ActionListener<Optional<Long>> latestTimeListener = ActionListener\n+            .wrap(latest -> getColdStartSamples(latest, detector, listener), listener::onFailure);\n         searchFeatureDao\n             .getLatestDataTime(\n                 detector,\n-                ActionListener.wrap(latest -> getColdStartSamples(latest, detector, listener), listener::onFailure)\n+                new ThreadedActionListener<>(", "originalCommit": "7e3065fc68a4841f4a3713390ac7acb07721e1c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI3MTk3Mw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r470271973", "bodyText": "Ideally, all AD code should run inside AD threadpool.  This is long overdue.  I am starting with cold start code.", "author": "kaituo", "createdAt": "2020-08-13T21:58:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU3ODMyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI5NjkwMQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r470296901", "bodyText": "does it mean every callback needs to run this way? can this be simplified at a higher level?", "author": "wnbts", "createdAt": "2020-08-13T23:08:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU3ODMyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg1MTE3Mw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r470851173", "bodyText": "yes. I don't know how to simplify this.  Any suggestion?", "author": "kaituo", "createdAt": "2020-08-14T20:29:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU3ODMyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxNjc4NQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r470916785", "bodyText": "TransportNodesAction seems to take thread pool name.", "author": "wnbts", "createdAt": "2020-08-15T00:49:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU3ODMyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY3MDI2Mw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r471670263", "bodyText": "You meant the threadpool name in TransportResponseHandler?  Our case is not just transport thread.  Also, the threadpool name is good for one callback.  It does not cover nested call backs.", "author": "kaituo", "createdAt": "2020-08-17T18:09:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU3ODMyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU4NjY2Mw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r469586663", "bodyText": "what does a null exception mean? is that an exception or no exception? why not using optional?", "author": "wnbts", "createdAt": "2020-08-12T22:40:49Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/TransportStateManager.java", "diffHunk": "@@ -250,12 +250,37 @@ public String getLastError(String adID) {\n     }\n \n     /**\n-     * Set last error of a detector\n+     * Set last detection error of a detector\n      * @param adID detector id\n      * @param error error, can be null\n      */\n-    public void setLastError(String adID, String error) {\n+    public void setLastDetectionError(String adID, String error) {\n         TransportState state = transportStates.computeIfAbsent(adID, id -> new TransportState(id));\n-        state.setLastError(new SimpleEntry<>(error, clock.instant()));\n+        state.setLastDetectionError(new SimpleEntry<>(error, clock.instant()));\n+    }\n+\n+    /**\n+     * Set last cold start error of a detector\n+     * @param adID detector id\n+     * @param exception exception, can be null", "originalCommit": "7e3065fc68a4841f4a3713390ac7acb07721e1c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI3MzA2Nw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r470273067", "bodyText": "null means there is no error, so no exception.  I know you are passionate about optional.  Here it is unnecessary.", "author": "kaituo", "createdAt": "2020-08-13T22:00:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU4NjY2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI5ODQwNA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r470298404", "bodyText": "if it's no error, would it suffice to leave the entire record to null? <exception, time> is null seems simpler.\noptional question. why optional is unnecessary ? clearly this variable can be present or absent and the need seems to exist.", "author": "wnbts", "createdAt": "2020-08-13T23:13:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU4NjY2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg1MTQ3MA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r470851470", "bodyText": "changed to optional", "author": "kaituo", "createdAt": "2020-08-14T20:30:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU4NjY2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU4ODU5OA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r469588598", "bodyText": "why getting the exception status involves updating the timestamp?", "author": "wnbts", "createdAt": "2020-08-12T22:46:19Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/TransportStateManager.java", "diffHunk": "@@ -250,12 +250,37 @@ public String getLastError(String adID) {\n     }\n \n     /**\n-     * Set last error of a detector\n+     * Set last detection error of a detector\n      * @param adID detector id\n      * @param error error, can be null\n      */\n-    public void setLastError(String adID, String error) {\n+    public void setLastDetectionError(String adID, String error) {\n         TransportState state = transportStates.computeIfAbsent(adID, id -> new TransportState(id));\n-        state.setLastError(new SimpleEntry<>(error, clock.instant()));\n+        state.setLastDetectionError(new SimpleEntry<>(error, clock.instant()));\n+    }\n+\n+    /**\n+     * Set last cold start error of a detector\n+     * @param adID detector id\n+     * @param exception exception, can be null\n+     */\n+    public void setLastColdStartException(String adID, Exception exception) {\n+        TransportState state = transportStates.computeIfAbsent(adID, id -> new TransportState(id));\n+        state.setLastColdStartException(new SimpleEntry<>(exception, clock.instant()));\n+    }\n+\n+    /**\n+     * Get last cold start exception of a detector\n+     * @param adID detector id\n+     * @return last cold start exception for the detector\n+     */\n+    public Exception fetchColdStartException(String adID) {\n+        if (transportStates.containsKey(adID) && transportStates.get(adID).getLastColdStartException() != null) {\n+            Entry<Exception, Instant> errorAndTime = transportStates.get(adID).getLastColdStartException();\n+            errorAndTime.setValue(clock.instant());", "originalCommit": "7e3065fc68a4841f4a3713390ac7acb07721e1c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI3MzU5Mg==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r470273592", "bodyText": "It is the same as other transport state.  We are gonna clear these states if they are not accessed within one hour.", "author": "kaituo", "createdAt": "2020-08-13T22:01:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU4ODU5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDMwMDUzMw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r470300533", "bodyText": "Would one last access time for one entire statue be sufficient? instead of keeping one timestamp for each field and still using the latest one", "author": "wnbts", "createdAt": "2020-08-13T23:20:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU4ODU5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg1MTYzNw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r470851637", "bodyText": "changed", "author": "kaituo", "createdAt": "2020-08-14T20:30:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU4ODU5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU5NDQzNg==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r469594436", "bodyText": "the two cases are different", "author": "wnbts", "createdAt": "2020-08-12T23:03:30Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "diffHunk": "@@ -770,39 +776,115 @@ private boolean shouldStart(\n         return true;\n     }\n \n-    class ColdStartJob implements Callable<Boolean> {\n+    private void coldStart(AnomalyDetector detector) {\n+        String detectorId = detector.getDetectorId();\n+\n+        ActionListener<Optional<double[][]>> listener = ActionListener.wrap(trainingData -> {\n+            if (trainingData.isPresent()) {\n+                double[][] dataPoints = trainingData.get();\n+\n+                ActionListener<Void> trainModelListener = ActionListener\n+                    .wrap(res -> { LOG.info(\"Succeeded in training {}\", detectorId); }, exception -> {\n+                        if (exception instanceof AnomalyDetectionException) {\n+                            // partitioned model exceeds memory limit", "originalCommit": "7e3065fc68a4841f4a3713390ac7acb07721e1c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI3NDQxMw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r470274413", "bodyText": "LimitExceededException is a subtype of AnomalyDetectionException.  I am commenting on one example here.  Updated comment to make it more clear.", "author": "kaituo", "createdAt": "2020-08-13T22:04:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTU5NDQzNg=="}], "type": "inlineReview"}, {"oid": "49f82fe8fc4771c475584e5a185ed922942c9ebb", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/49f82fe8fc4771c475584e5a185ed922942c9ebb", "message": "Change to use callbacks in cold start\n\nThis PR changes the code path of cold start in the transport layer to use callbacks.\n\nPreviously, I created AD\u2019s ExecutorService that has one thread for cold starts in ColdStartRunner. When we need to trigger a cold start, we can submit a task in the ExecutorService, and consult a hash map (keyed by detector Id) that cached the results of recent cold start results. Since I have to invoke the cold start thread in various callbacks, I created a cold start thread pool and put the cold start result in the transport state.\n\nThis PR also handles new exceptions like invalid queries introduced by recent changes on ModelManager and FeatureManager.\n\nThis PR lowers the severity of a couple of log messages in HashRing and RCFPollingTransportAction to avoid overwhelming readers of log files. These log messages are common.\n\nThis PR corrects typos and updates known causes of EndRunException in comments.\n\nTesting done:\n1. Simulated cold start failures: Exceptions of cold starts can be seen by the transport layer.\u00a0 EndRunException can cause AD jobs to be terminated.\n2. Happy case of a cold start still works.", "committedDate": "2020-08-13T22:36:36Z", "type": "commit"}, {"oid": "49f82fe8fc4771c475584e5a185ed922942c9ebb", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/49f82fe8fc4771c475584e5a185ed922942c9ebb", "message": "Change to use callbacks in cold start\n\nThis PR changes the code path of cold start in the transport layer to use callbacks.\n\nPreviously, I created AD\u2019s ExecutorService that has one thread for cold starts in ColdStartRunner. When we need to trigger a cold start, we can submit a task in the ExecutorService, and consult a hash map (keyed by detector Id) that cached the results of recent cold start results. Since I have to invoke the cold start thread in various callbacks, I created a cold start thread pool and put the cold start result in the transport state.\n\nThis PR also handles new exceptions like invalid queries introduced by recent changes on ModelManager and FeatureManager.\n\nThis PR lowers the severity of a couple of log messages in HashRing and RCFPollingTransportAction to avoid overwhelming readers of log files. These log messages are common.\n\nThis PR corrects typos and updates known causes of EndRunException in comments.\n\nTesting done:\n1. Simulated cold start failures: Exceptions of cold starts can be seen by the transport layer.\u00a0 EndRunException can cause AD jobs to be terminated.\n2. Happy case of a cold start still works.", "committedDate": "2020-08-13T22:36:36Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxNTc5OA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r470915798", "bodyText": "Why use () -> detectorId?  detectorId should work.", "author": "ylwu-amzn", "createdAt": "2020-08-15T00:40:39Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "diffHunk": "@@ -770,39 +776,109 @@ private boolean shouldStart(\n         return true;\n     }\n \n-    class ColdStartJob implements Callable<Boolean> {\n+    private void coldStart(AnomalyDetector detector) {\n+        String detectorId = detector.getDetectorId();\n+\n+        ActionListener<Optional<double[][]>> listener = ActionListener.wrap(trainingData -> {\n+            if (trainingData.isPresent()) {\n+                double[][] dataPoints = trainingData.get();\n+\n+                ActionListener<Void> trainModelListener = ActionListener\n+                    .wrap(res -> { LOG.info(\"Succeeded in training {}\", detectorId); }, exception -> {\n+                        if (exception instanceof AnomalyDetectionException) {\n+                            // e.g., partitioned model exceeds memory limit\n+                            stateManager.setLastColdStartException(detectorId, exception);\n+                        } else if (exception instanceof IllegalArgumentException) {\n+                            // IllegalArgumentException due to invalid training data\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new EndRunException(detectorId, \"Invalid training data\", exception, false)\n+                                );\n+                        } else if (exception instanceof ElasticsearchTimeoutException) {\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new InternalFailure(detectorId, \"Time out while indexing cold start checkpoint\", exception)\n+                                );\n+                        } else {\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new EndRunException(detectorId, \"Error while training model\", exception, false)\n+                                );\n+                        }\n+                    });\n+\n+                modelManager\n+                    .trainModel(\n+                        detector,\n+                        dataPoints,\n+                        new ThreadedActionListener<>(LOG, threadPool, AnomalyDetectorPlugin.AD_THREAD_POOL_NAME, trainModelListener, false)\n+                    );\n+            } else {\n+                stateManager.setLastColdStartException(detectorId, new EndRunException(detectorId, \"Cannot get training data\", false));\n+            }\n+        }, exception -> {\n+            if (exception instanceof ElasticsearchTimeoutException) {\n+                stateManager\n+                    .setLastColdStartException(\n+                        detectorId,\n+                        new InternalFailure(detectorId, \"Time out while getting training data\", exception)\n+                    );\n+            } else if (exception instanceof AnomalyDetectionException) {\n+                // e.g., Invalid search query\n+                stateManager.setLastColdStartException(detectorId, exception);\n+            } else {\n+                stateManager\n+                    .setLastColdStartException(detectorId, new EndRunException(detectorId, \"Error while cold start\", exception, false));\n+            }\n+        });\n \n-        private AnomalyDetector detector;\n+        threadPool\n+            .executor(AnomalyDetectorPlugin.AD_THREAD_POOL_NAME)\n+            .execute(\n+                () -> featureManager\n+                    .getColdStartData(\n+                        detector,\n+                        new ThreadedActionListener<>(LOG, threadPool, AnomalyDetectorPlugin.AD_THREAD_POOL_NAME, listener, false)\n+                    )\n+            );\n+    }\n \n-        ColdStartJob(AnomalyDetector detector) {\n-            this.detector = detector;\n-        }\n+    /**\n+     * Check if checkpoint for an detector exists or not.  If not and previous\n+     *  run is not EndRunException whose endNow is true, trigger cold start.\n+     * @param detector detector object\n+     * @return previous cold start exception\n+     */\n+    private Exception coldStartIfNoCheckPoint(AnomalyDetector detector) {\n+        String detectorId = detector.getDetectorId();\n \n-        @Override\n-        public Boolean call() {\n-            String detectorId = detector.getDetectorId();\n-            try {\n-                Optional<double[][]> traingData = featureManager.getColdStartData(detector);\n-                if (traingData.isPresent()) {\n-                    double[][] trainingPoints = traingData.get();\n-                    modelManager.trainModel(detector, trainingPoints);\n-                    return true;\n-                } else {\n-                    throw new EndRunException(detectorId, \"Cannot get training data\", false);\n-                }\n+        Exception previousException = stateManager.fetchColdStartException(detectorId);\n \n-            } catch (ElasticsearchTimeoutException timeoutEx) {\n-                throw new InternalFailure(\n-                    detector.getDetectorId(),\n-                    \"Time out while indexing cold start checkpoint or get training data\",\n-                    timeoutEx\n-                );\n-            } catch (EndRunException endRunEx) {\n-                throw endRunEx;\n-            } catch (Exception ex) {\n-                throw new EndRunException(detector.getDetectorId(), \"Error while cold start\", ex, false);\n+        if (previousException != null) {\n+            LOG.error(\"Previous exception of {}: {}\", () -> detectorId, () -> previousException);", "originalCommit": "49f82fe8fc4771c475584e5a185ed922942c9ebb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY3MTQwMQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r471671401", "bodyText": "See https://www.baeldung.com/log4j-2-lazy-logging", "author": "kaituo", "createdAt": "2020-08-17T18:11:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxNTc5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTc4ODc5OQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r471788799", "bodyText": "From the document you shared ,\n\nThe lambda expression is only evaluated if the corresponding log level is enabled. This is referred to as lazy logging.\n\nI think error log level is always enabled, so the lambda () -> detectorId will always be executed?", "author": "ylwu-amzn", "createdAt": "2020-08-17T21:36:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxNTc5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg0MTQxNQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r471841415", "bodyText": "you are right.  Changed.", "author": "kaituo", "createdAt": "2020-08-18T00:12:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxNTc5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxNjY2Mw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r470916663", "bodyText": "If it's EndRunException  and  isEndNow() is true, JobRunner will stop detector job. Will the previousException be cleaned when stop detector job? Why need to check previous exception ? If user wait for some time and restart detector, cluster state may change, and user may not get previous exception any more.", "author": "ylwu-amzn", "createdAt": "2020-08-15T00:48:15Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "diffHunk": "@@ -770,39 +776,109 @@ private boolean shouldStart(\n         return true;\n     }\n \n-    class ColdStartJob implements Callable<Boolean> {\n+    private void coldStart(AnomalyDetector detector) {\n+        String detectorId = detector.getDetectorId();\n+\n+        ActionListener<Optional<double[][]>> listener = ActionListener.wrap(trainingData -> {\n+            if (trainingData.isPresent()) {\n+                double[][] dataPoints = trainingData.get();\n+\n+                ActionListener<Void> trainModelListener = ActionListener\n+                    .wrap(res -> { LOG.info(\"Succeeded in training {}\", detectorId); }, exception -> {\n+                        if (exception instanceof AnomalyDetectionException) {\n+                            // e.g., partitioned model exceeds memory limit\n+                            stateManager.setLastColdStartException(detectorId, exception);\n+                        } else if (exception instanceof IllegalArgumentException) {\n+                            // IllegalArgumentException due to invalid training data\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new EndRunException(detectorId, \"Invalid training data\", exception, false)\n+                                );\n+                        } else if (exception instanceof ElasticsearchTimeoutException) {\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new InternalFailure(detectorId, \"Time out while indexing cold start checkpoint\", exception)\n+                                );\n+                        } else {\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new EndRunException(detectorId, \"Error while training model\", exception, false)\n+                                );\n+                        }\n+                    });\n+\n+                modelManager\n+                    .trainModel(\n+                        detector,\n+                        dataPoints,\n+                        new ThreadedActionListener<>(LOG, threadPool, AnomalyDetectorPlugin.AD_THREAD_POOL_NAME, trainModelListener, false)\n+                    );\n+            } else {\n+                stateManager.setLastColdStartException(detectorId, new EndRunException(detectorId, \"Cannot get training data\", false));\n+            }\n+        }, exception -> {\n+            if (exception instanceof ElasticsearchTimeoutException) {\n+                stateManager\n+                    .setLastColdStartException(\n+                        detectorId,\n+                        new InternalFailure(detectorId, \"Time out while getting training data\", exception)\n+                    );\n+            } else if (exception instanceof AnomalyDetectionException) {\n+                // e.g., Invalid search query\n+                stateManager.setLastColdStartException(detectorId, exception);\n+            } else {\n+                stateManager\n+                    .setLastColdStartException(detectorId, new EndRunException(detectorId, \"Error while cold start\", exception, false));\n+            }\n+        });\n \n-        private AnomalyDetector detector;\n+        threadPool\n+            .executor(AnomalyDetectorPlugin.AD_THREAD_POOL_NAME)\n+            .execute(\n+                () -> featureManager\n+                    .getColdStartData(\n+                        detector,\n+                        new ThreadedActionListener<>(LOG, threadPool, AnomalyDetectorPlugin.AD_THREAD_POOL_NAME, listener, false)\n+                    )\n+            );\n+    }\n \n-        ColdStartJob(AnomalyDetector detector) {\n-            this.detector = detector;\n-        }\n+    /**\n+     * Check if checkpoint for an detector exists or not.  If not and previous\n+     *  run is not EndRunException whose endNow is true, trigger cold start.\n+     * @param detector detector object\n+     * @return previous cold start exception\n+     */\n+    private Exception coldStartIfNoCheckPoint(AnomalyDetector detector) {\n+        String detectorId = detector.getDetectorId();\n \n-        @Override\n-        public Boolean call() {\n-            String detectorId = detector.getDetectorId();\n-            try {\n-                Optional<double[][]> traingData = featureManager.getColdStartData(detector);\n-                if (traingData.isPresent()) {\n-                    double[][] trainingPoints = traingData.get();\n-                    modelManager.trainModel(detector, trainingPoints);\n-                    return true;\n-                } else {\n-                    throw new EndRunException(detectorId, \"Cannot get training data\", false);\n-                }\n+        Exception previousException = stateManager.fetchColdStartException(detectorId);\n \n-            } catch (ElasticsearchTimeoutException timeoutEx) {\n-                throw new InternalFailure(\n-                    detector.getDetectorId(),\n-                    \"Time out while indexing cold start checkpoint or get training data\",\n-                    timeoutEx\n-                );\n-            } catch (EndRunException endRunEx) {\n-                throw endRunEx;\n-            } catch (Exception ex) {\n-                throw new EndRunException(detector.getDetectorId(), \"Error while cold start\", ex, false);\n+        if (previousException != null) {\n+            LOG.error(\"Previous exception of {}: {}\", () -> detectorId, () -> previousException);\n+            if (previousException instanceof EndRunException && ((EndRunException) previousException).isEndNow()) {", "originalCommit": "49f82fe8fc4771c475584e5a185ed922942c9ebb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY3MjQ4Mg==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r471672482", "bodyText": "Yes, it will be cleared.  We need to check previous exception because cold start is asynchronous.  We don't know cold start error instantly.\nIf transport state gets cleared up, next few runs would trigger the same error.", "author": "kaituo", "createdAt": "2020-08-17T18:13:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxNjY2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxNzA1MQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r470917051", "bodyText": "Should we throw exception ? Why not record this exception as previousException ?", "author": "ylwu-amzn", "createdAt": "2020-08-15T00:51:24Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "diffHunk": "@@ -770,39 +776,109 @@ private boolean shouldStart(\n         return true;\n     }\n \n-    class ColdStartJob implements Callable<Boolean> {\n+    private void coldStart(AnomalyDetector detector) {\n+        String detectorId = detector.getDetectorId();\n+\n+        ActionListener<Optional<double[][]>> listener = ActionListener.wrap(trainingData -> {\n+            if (trainingData.isPresent()) {\n+                double[][] dataPoints = trainingData.get();\n+\n+                ActionListener<Void> trainModelListener = ActionListener\n+                    .wrap(res -> { LOG.info(\"Succeeded in training {}\", detectorId); }, exception -> {\n+                        if (exception instanceof AnomalyDetectionException) {\n+                            // e.g., partitioned model exceeds memory limit\n+                            stateManager.setLastColdStartException(detectorId, exception);\n+                        } else if (exception instanceof IllegalArgumentException) {\n+                            // IllegalArgumentException due to invalid training data\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new EndRunException(detectorId, \"Invalid training data\", exception, false)\n+                                );\n+                        } else if (exception instanceof ElasticsearchTimeoutException) {\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new InternalFailure(detectorId, \"Time out while indexing cold start checkpoint\", exception)\n+                                );\n+                        } else {\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new EndRunException(detectorId, \"Error while training model\", exception, false)\n+                                );\n+                        }\n+                    });\n+\n+                modelManager\n+                    .trainModel(\n+                        detector,\n+                        dataPoints,\n+                        new ThreadedActionListener<>(LOG, threadPool, AnomalyDetectorPlugin.AD_THREAD_POOL_NAME, trainModelListener, false)\n+                    );\n+            } else {\n+                stateManager.setLastColdStartException(detectorId, new EndRunException(detectorId, \"Cannot get training data\", false));\n+            }\n+        }, exception -> {\n+            if (exception instanceof ElasticsearchTimeoutException) {\n+                stateManager\n+                    .setLastColdStartException(\n+                        detectorId,\n+                        new InternalFailure(detectorId, \"Time out while getting training data\", exception)\n+                    );\n+            } else if (exception instanceof AnomalyDetectionException) {\n+                // e.g., Invalid search query\n+                stateManager.setLastColdStartException(detectorId, exception);\n+            } else {\n+                stateManager\n+                    .setLastColdStartException(detectorId, new EndRunException(detectorId, \"Error while cold start\", exception, false));\n+            }\n+        });\n \n-        private AnomalyDetector detector;\n+        threadPool\n+            .executor(AnomalyDetectorPlugin.AD_THREAD_POOL_NAME)\n+            .execute(\n+                () -> featureManager\n+                    .getColdStartData(\n+                        detector,\n+                        new ThreadedActionListener<>(LOG, threadPool, AnomalyDetectorPlugin.AD_THREAD_POOL_NAME, listener, false)\n+                    )\n+            );\n+    }\n \n-        ColdStartJob(AnomalyDetector detector) {\n-            this.detector = detector;\n-        }\n+    /**\n+     * Check if checkpoint for an detector exists or not.  If not and previous\n+     *  run is not EndRunException whose endNow is true, trigger cold start.\n+     * @param detector detector object\n+     * @return previous cold start exception\n+     */\n+    private Exception coldStartIfNoCheckPoint(AnomalyDetector detector) {\n+        String detectorId = detector.getDetectorId();\n \n-        @Override\n-        public Boolean call() {\n-            String detectorId = detector.getDetectorId();\n-            try {\n-                Optional<double[][]> traingData = featureManager.getColdStartData(detector);\n-                if (traingData.isPresent()) {\n-                    double[][] trainingPoints = traingData.get();\n-                    modelManager.trainModel(detector, trainingPoints);\n-                    return true;\n-                } else {\n-                    throw new EndRunException(detectorId, \"Cannot get training data\", false);\n-                }\n+        Exception previousException = stateManager.fetchColdStartException(detectorId);\n \n-            } catch (ElasticsearchTimeoutException timeoutEx) {\n-                throw new InternalFailure(\n-                    detector.getDetectorId(),\n-                    \"Time out while indexing cold start checkpoint or get training data\",\n-                    timeoutEx\n-                );\n-            } catch (EndRunException endRunEx) {\n-                throw endRunEx;\n-            } catch (Exception ex) {\n-                throw new EndRunException(detector.getDetectorId(), \"Error while cold start\", ex, false);\n+        if (previousException != null) {\n+            LOG.error(\"Previous exception of {}: {}\", () -> detectorId, () -> previousException);\n+            if (previousException instanceof EndRunException && ((EndRunException) previousException).isEndNow()) {\n+                return previousException;\n             }\n         }\n \n+        stateManager.getDetectorCheckpoint(detectorId, ActionListener.wrap(checkpointExists -> {\n+            if (!checkpointExists) {\n+                LOG.info(\"Trigger cold start for {}\", detectorId);\n+                coldStart(detector);\n+            }\n+        }, exception -> {\n+            Throwable cause = ExceptionsHelper.unwrapCause(exception);\n+            if (cause instanceof IndexNotFoundException) {\n+                LOG.info(\"Trigger cold start for {}\", detectorId);\n+                coldStart(detector);\n+            } else {\n+                LOG.error(String.format(\"Fail to get checkpoint state for %s\", detectorId), exception);", "originalCommit": "49f82fe8fc4771c475584e5a185ed922942c9ebb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY3NzY2OA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r471677668", "bodyText": "This is in callback.  We cannot throw exception directly as it is asynchronous and won't be caught by AD job.  What do we expect the job runner to do here?  For example, we can reach here if cold start does not happen before and the system is under extreme heavy load and get request gets rejected.  We can log the error and retry later.", "author": "kaituo", "createdAt": "2020-08-17T18:23:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxNzA1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ1ODYyMg==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r472458622", "bodyText": "Job runner will end detector job if getsEndRunException and isEndNow is true.  If isEndNow is false, will still stop detector job if the count of EndRunException exceeds MAX_RETRY_FOR_END_RUN_EXCEPTION(default 6 currently). For other exceptions except for EndRunException, job runner will record it in AD result.\nHow about we return this exception to JobRunner so it can be logged into AD result ?\nIn this change, cold start is put into another thread pool and run asynchronously; will check previousException if no checkpoint or no model.  How about we check EndRunException which isEndNow is false and return it to JobRunner, so JobRunner can stop detector job if find too many EndRunExceptions ? That can avoid endlessly run cold start.", "author": "ylwu-amzn", "createdAt": "2020-08-18T20:15:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxNzA1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjU1MjIwNQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r472552205", "bodyText": "changed as we discussed offline", "author": "kaituo", "createdAt": "2020-08-18T23:39:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxNzA1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxNzUzMQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r470917531", "bodyText": "cold error  means cold start error?", "author": "ylwu-amzn", "createdAt": "2020-08-15T00:55:21Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/TransportState.java", "diffHunk": "@@ -29,16 +29,19 @@\n     private Entry<Integer, Instant> partitonNumber;\n     // checkpoint fetch time\n     private Instant checkpoint;\n-    // last error. Used by DetectorStateHandler to check if the error for a\n+    // last detection error. Used by DetectorStateHandler to check if the error for a\n     // detector has changed or not. If changed, trigger indexing.\n-    private Entry<String, Instant> lastError;\n+    private Entry<String, Instant> lastDetectionError;\n+    // last training error. Used to save cold error by a concurrent cold start thread.", "originalCommit": "49f82fe8fc4771c475584e5a185ed922942c9ebb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY3ODMzNA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r471678334", "bodyText": "Good catch.  Fixed", "author": "kaituo", "createdAt": "2020-08-17T18:24:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxNzUzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxNzkzMQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r470917931", "bodyText": "Why not return this exception ?", "author": "ylwu-amzn", "createdAt": "2020-08-15T00:59:24Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "diffHunk": "@@ -397,32 +396,45 @@ protected void doExecute(Task task, ActionRequest actionRequest, ActionListener<\n      *\n      * @param failure  object that may contain exceptions thrown\n      * @param detector detector object\n-     * @return whether cold start runs\n+     * @return exception if we get resource not found exception\n      * @throws AnomalyDetectionException List of exceptions we can throw\n      *     1. Exception from cold start:\n      *       1). InternalFailure due to\n      *         a. ElasticsearchTimeoutException thrown by putModelCheckpoint during cold start\n      *       2). EndRunException with endNow equal to false\n      *         a. training data not available\n      *         b. cold start cannot succeed\n+     *         c. invalid training data\n+     *       3) EndRunException with endNow equal to true\n+     *         a. invalid search query\n      *     2. LimitExceededException from one of RCF model node when the total size of the models\n      *      is more than X% of heap memory.\n      *     3. InternalFailure wrapping ElasticsearchTimeoutException inside caused by\n      *      RCF/Threshold model node failing to get checkpoint to restore model before timeout.\n      */\n-    private boolean coldStartIfNoModel(AtomicReference<AnomalyDetectionException> failure, AnomalyDetector detector)\n+    private Exception coldStartIfNoModel(AtomicReference<AnomalyDetectionException> failure, AnomalyDetector detector)\n         throws AnomalyDetectionException {\n         AnomalyDetectionException exp = failure.get();\n-        if (exp != null) {\n-            if (exp instanceof ResourceNotFoundException) {\n-                LOG.info(\"Trigger cold start for {}\", detector.getDetectorId());\n-                globalRunner.compute(new ColdStartJob(detector));\n-                return true;\n-            } else {\n-                throw exp;\n+        if (exp == null) {\n+            return null;\n+        }\n+\n+        if (!(exp instanceof ResourceNotFoundException)) {\n+            throw exp;", "originalCommit": "49f82fe8fc4771c475584e5a185ed922942c9ebb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY3MzUxMg==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r471673512", "bodyText": "The returned exception is for cold start related failure only.", "author": "kaituo", "createdAt": "2020-08-17T18:15:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxNzkzMQ=="}], "type": "inlineReview"}, {"oid": "8ec18704741b04e245a2372f349c4853629b5cab", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/8ec18704741b04e245a2372f349c4853629b5cab", "message": "Change error to use Optional and use a common last update time in transport state", "committedDate": "2020-08-17T18:34:11Z", "type": "commit"}, {"oid": "2f63d9e1d7d3525ddfdff80e717eaaf97d4d434f", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/2f63d9e1d7d3525ddfdff80e717eaaf97d4d434f", "message": "Update comment and log", "committedDate": "2020-08-18T00:23:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg1NTkzNw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r471855937", "bodyText": "minor. why not using configured executor name instead of hardcoding it in all places?", "author": "wnbts", "createdAt": "2020-08-18T01:06:50Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/feature/FeatureManager.java", "diffHunk": "@@ -331,10 +338,12 @@ private LongStream getFullShingleEndTimes(long endTime, long intervalMilli, int\n      *                 onFailure is called with EndRunException on feature query creation errors\n      */\n     public void getColdStartData(AnomalyDetector detector, ActionListener<Optional<double[][]>> listener) {\n+        ActionListener<Optional<Long>> latestTimeListener = ActionListener\n+            .wrap(latest -> getColdStartSamples(latest, detector, listener), listener::onFailure);\n         searchFeatureDao\n             .getLatestDataTime(\n                 detector,\n-                ActionListener.wrap(latest -> getColdStartSamples(latest, detector, listener), listener::onFailure)\n+                new ThreadedActionListener<>(logger, threadPool, AnomalyDetectorPlugin.AD_THREAD_POOL_NAME, latestTimeListener, false)", "originalCommit": "2f63d9e1d7d3525ddfdff80e717eaaf97d4d434f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjMzNDY2Mg==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r472334662", "bodyText": "I don't understand.  Could you explain more?", "author": "kaituo", "createdAt": "2020-08-18T16:42:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg1NTkzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM4OTE1NA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r472389154", "bodyText": "AnomalyDetectorPlugin.AD_THREAD_POOL_NAME is the name.\nwhy not using a configured name like threadpool in configuration? instead of hardcoding it.", "author": "wnbts", "createdAt": "2020-08-18T18:12:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg1NTkzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQxNjg5OQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r472416899", "bodyText": "What do you mean by configuration?", "author": "kaituo", "createdAt": "2020-08-18T19:04:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg1NTkzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ0NDA3Ng==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r472444076", "bodyText": "the value is configurable using constructor.", "author": "wnbts", "createdAt": "2020-08-18T19:56:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg1NTkzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ2ODY5Nw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r472468697", "bodyText": "The benefit to make it configurable is to make testing easy.\nMy concern is we may not have just one threadpool to use in this class.  For example, I want to add a dedicated cold start threadpool for high cardinality.  So we should add threadpool_ad, threadpool_coldStart for this?", "author": "kaituo", "createdAt": "2020-08-18T20:26:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg1NTkzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUzMzE0Nw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r472533147", "bodyText": "if there are additional dependency configuration (threadpool and executor names), they can also be passed via constructor and the implementation just needs to pick the corresponding configuration (threadpool and executor name combination)", "author": "wnbts", "createdAt": "2020-08-18T22:41:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg1NTkzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg1NzI4MA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r471857280", "bodyText": "minor. documentation is missing for the interface of this class.", "author": "wnbts", "createdAt": "2020-08-18T01:11:55Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/TransportState.java", "diffHunk": "@@ -15,86 +15,101 @@\n \n package com.amazon.opendistroforelasticsearch.ad.transport;\n \n+import java.time.Clock;\n import java.time.Duration;\n import java.time.Instant;\n-import java.util.Map.Entry;\n+import java.util.Optional;\n \n import com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetector;\n \n public class TransportState {", "originalCommit": "2f63d9e1d7d3525ddfdff80e717eaaf97d4d434f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjMzNjgxMw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r472336813", "bodyText": "added", "author": "kaituo", "createdAt": "2020-08-18T16:46:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg1NzI4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjU2NjI1Mw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r472566253", "bodyText": "also all the public methods (interface)", "author": "wnbts", "createdAt": "2020-08-19T00:29:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg1NzI4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg1NzkxNg==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r471857916", "bodyText": "minor. the input can be simplified to one parameter as the expiration time.", "author": "wnbts", "createdAt": "2020-08-18T01:14:15Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/TransportState.java", "diffHunk": "@@ -15,86 +15,101 @@\n \n package com.amazon.opendistroforelasticsearch.ad.transport;\n \n+import java.time.Clock;\n import java.time.Duration;\n import java.time.Instant;\n-import java.util.Map.Entry;\n+import java.util.Optional;\n \n import com.amazon.opendistroforelasticsearch.ad.model.AnomalyDetector;\n \n public class TransportState {\n     private String detectorId;\n-    // detector definition and the definition fetch time\n-    private Entry<AnomalyDetector, Instant> detectorDef;\n-    // number of partitions and the number's fetch time\n-    private Entry<Integer, Instant> partitonNumber;\n+    // detector definition\n+    private AnomalyDetector detectorDef;\n+    // number of partitions\n+    private int partitonNumber;\n     // checkpoint fetch time\n-    private Instant checkpoint;\n-    // last error. Used by DetectorStateHandler to check if the error for a\n+    private Instant lastAccessTime;\n+    // last detection error. Used by DetectorStateHandler to check if the error for a\n     // detector has changed or not. If changed, trigger indexing.\n-    private Entry<String, Instant> lastError;\n-\n-    public TransportState(String detectorId) {\n+    private Optional<String> lastDetectionError;\n+    // last training error. Used to save cold start error by a concurrent cold start thread.\n+    private Optional<Exception> lastColdStartException;\n+    // flag indicating whether checkpoint for the detector exists\n+    private boolean checkPointExists;\n+    // clock to get current time\n+    private final Clock clock;\n+\n+    public TransportState(String detectorId, Clock clock) {\n         this.detectorId = detectorId;\n-        detectorDef = null;\n-        partitonNumber = null;\n-        checkpoint = null;\n-        lastError = null;\n+        this.detectorDef = null;\n+        this.partitonNumber = -1;\n+        this.lastAccessTime = clock.instant();\n+        this.lastDetectionError = Optional.empty();\n+        this.lastColdStartException = Optional.empty();\n+        this.checkPointExists = false;\n+        this.clock = clock;\n     }\n \n     public String getDetectorId() {\n         return detectorId;\n     }\n \n-    public Entry<AnomalyDetector, Instant> getDetectorDef() {\n+    public AnomalyDetector getDetectorDef() {\n+        refreshLastUpdateTime();\n         return detectorDef;\n     }\n \n-    public void setDetectorDef(Entry<AnomalyDetector, Instant> detectorDef) {\n+    public void setDetectorDef(AnomalyDetector detectorDef) {\n         this.detectorDef = detectorDef;\n+        refreshLastUpdateTime();\n     }\n \n-    public Entry<Integer, Instant> getPartitonNumber() {\n+    public int getPartitonNumber() {\n+        refreshLastUpdateTime();\n         return partitonNumber;\n     }\n \n-    public void setPartitonNumber(Entry<Integer, Instant> partitonNumber) {\n+    public void setPartitonNumber(int partitonNumber) {\n         this.partitonNumber = partitonNumber;\n+        refreshLastUpdateTime();\n     }\n \n-    public Instant getCheckpoint() {\n-        return checkpoint;\n+    public boolean doesCheckpointExists() {\n+        refreshLastUpdateTime();\n+        return checkPointExists;\n     }\n \n-    public void setCheckpoint(Instant checkpoint) {\n-        this.checkpoint = checkpoint;\n+    public void setCheckpointExists(boolean checkpointExists) {\n+        refreshLastUpdateTime();\n+        this.checkPointExists = checkpointExists;\n     };\n \n-    public Entry<String, Instant> getLastError() {\n-        return lastError;\n+    public Optional<String> getLastDetectionError() {\n+        refreshLastUpdateTime();\n+        return lastDetectionError;\n     }\n \n-    public void setLastError(Entry<String, Instant> lastError) {\n-        this.lastError = lastError;\n+    public void setLastDetectionError(String lastError) {\n+        this.lastDetectionError = Optional.ofNullable(lastError);\n+        refreshLastUpdateTime();\n     }\n \n-    public boolean expired(Duration stateTtl, Instant now) {\n-        boolean ans = true;\n-        if (detectorDef != null) {\n-            ans = ans && expired(stateTtl, now, detectorDef.getValue());\n-        }\n-        if (partitonNumber != null) {\n-            ans = ans && expired(stateTtl, now, partitonNumber.getValue());\n-        }\n-        if (checkpoint != null) {\n-            ans = ans && expired(stateTtl, now, checkpoint);\n-        }\n-        if (lastError != null) {\n-            ans = ans && expired(stateTtl, now, lastError.getValue());\n-        }\n-        return ans;\n+    public Optional<Exception> getLastColdStartException() {\n+        refreshLastUpdateTime();\n+        return lastColdStartException;\n+    }\n+\n+    public void setLastColdStartException(Exception lastColdStartError) {\n+        this.lastColdStartException = Optional.ofNullable(lastColdStartError);\n+        refreshLastUpdateTime();\n     }\n \n-    private boolean expired(Duration stateTtl, Instant now, Instant toCheck) {\n-        return toCheck.plus(stateTtl).isBefore(now);\n+    private void refreshLastUpdateTime() {\n+        lastAccessTime = clock.instant();\n+    }\n+\n+    public boolean expired(Duration stateTtl, Instant now) {", "originalCommit": "2f63d9e1d7d3525ddfdff80e717eaaf97d4d434f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjMzNzYzNw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r472337637", "bodyText": "I don't understand.  Could you explain?", "author": "kaituo", "createdAt": "2020-08-18T16:47:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg1NzkxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM4OTgzMQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r472389831", "bodyText": "why using two input parameters for this method when one parameter such as expiration time is sufficient?", "author": "wnbts", "createdAt": "2020-08-18T18:14:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg1NzkxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQzMjczMg==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r472432732", "bodyText": "changed", "author": "kaituo", "createdAt": "2020-08-18T19:33:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg1NzkxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg2MTMyNw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r471861327", "bodyText": "minor.\nwhen resource is not found, what exception does this method return? why the general exception instead of the more specific one? if other exceptions occur, what does this method return?\nalso who is we? does it refer to the reader of the doc? the client of the interface? the developer of the implementation? or the software implementation? please avoid incorrect/ambiguous use of we when the referee is software.", "author": "wnbts", "createdAt": "2020-08-18T01:27:11Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "diffHunk": "@@ -397,32 +396,46 @@ protected void doExecute(Task task, ActionRequest actionRequest, ActionListener<\n      *\n      * @param failure  object that may contain exceptions thrown\n      * @param detector detector object\n-     * @return whether cold start runs\n+     * @return exception if we get resource not found exception", "originalCommit": "2f63d9e1d7d3525ddfdff80e717eaaf97d4d434f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM3MTgxMQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r472371811", "bodyText": "Changed to new AnomalyDetectionException.\nIs there any place saying we cannot use we?", "author": "kaituo", "createdAt": "2020-08-18T17:42:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg2MTMyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ1MzczNg==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r472453736", "bodyText": "it was the question about who we refers to. https://www.oracle.com/technical-resources/articles/java/javadoc-tool.html", "author": "wnbts", "createdAt": "2020-08-18T20:09:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg2MTMyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUyODM3NA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r472528374", "bodyText": "Which part of the doc do you want me to read?  Any particular part related?\nAnyway, I changed to \"AD job execution\".", "author": "kaituo", "createdAt": "2020-08-18T22:27:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg2MTMyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjUzMzI5OQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r472533299", "bodyText": "See Use 3rd person (descriptive) not 2nd person (prescriptive).", "author": "wnbts", "createdAt": "2020-08-18T22:41:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg2MTMyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjU1NDc3OA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r472554778", "bodyText": "good to know", "author": "kaituo", "createdAt": "2020-08-18T23:48:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg2MTMyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg2NTI5MQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r471865291", "bodyText": "question. what should be returned when the checkpoint exists?", "author": "wnbts", "createdAt": "2020-08-18T01:42:07Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "diffHunk": "@@ -770,39 +777,110 @@ private boolean shouldStart(\n         return true;\n     }\n \n-    class ColdStartJob implements Callable<Boolean> {\n+    private void coldStart(AnomalyDetector detector) {\n+        String detectorId = detector.getDetectorId();\n+\n+        ActionListener<Optional<double[][]>> listener = ActionListener.wrap(trainingData -> {\n+            if (trainingData.isPresent()) {\n+                double[][] dataPoints = trainingData.get();\n+\n+                ActionListener<Void> trainModelListener = ActionListener\n+                    .wrap(res -> { LOG.info(\"Succeeded in training {}\", detectorId); }, exception -> {\n+                        if (exception instanceof AnomalyDetectionException) {\n+                            // e.g., partitioned model exceeds memory limit\n+                            stateManager.setLastColdStartException(detectorId, exception);\n+                        } else if (exception instanceof IllegalArgumentException) {\n+                            // IllegalArgumentException due to invalid training data\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new EndRunException(detectorId, \"Invalid training data\", exception, false)\n+                                );\n+                        } else if (exception instanceof ElasticsearchTimeoutException) {\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new InternalFailure(detectorId, \"Time out while indexing cold start checkpoint\", exception)\n+                                );\n+                        } else {\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new EndRunException(detectorId, \"Error while training model\", exception, false)\n+                                );\n+                        }\n+                    });\n+\n+                modelManager\n+                    .trainModel(\n+                        detector,\n+                        dataPoints,\n+                        new ThreadedActionListener<>(LOG, threadPool, AnomalyDetectorPlugin.AD_THREAD_POOL_NAME, trainModelListener, false)\n+                    );\n+            } else {\n+                stateManager.setLastColdStartException(detectorId, new EndRunException(detectorId, \"Cannot get training data\", false));\n+            }\n+        }, exception -> {\n+            if (exception instanceof ElasticsearchTimeoutException) {\n+                stateManager\n+                    .setLastColdStartException(\n+                        detectorId,\n+                        new InternalFailure(detectorId, \"Time out while getting training data\", exception)\n+                    );\n+            } else if (exception instanceof AnomalyDetectionException) {\n+                // e.g., Invalid search query\n+                stateManager.setLastColdStartException(detectorId, exception);\n+            } else {\n+                stateManager\n+                    .setLastColdStartException(detectorId, new EndRunException(detectorId, \"Error while cold start\", exception, false));\n+            }\n+        });\n \n-        private AnomalyDetector detector;\n+        threadPool\n+            .executor(AnomalyDetectorPlugin.AD_THREAD_POOL_NAME)\n+            .execute(\n+                () -> featureManager\n+                    .getColdStartData(\n+                        detector,\n+                        new ThreadedActionListener<>(LOG, threadPool, AnomalyDetectorPlugin.AD_THREAD_POOL_NAME, listener, false)\n+                    )\n+            );\n+    }\n \n-        ColdStartJob(AnomalyDetector detector) {\n-            this.detector = detector;\n-        }\n+    /**\n+     * Check if checkpoint for an detector exists or not.  If not and previous\n+     *  run is not EndRunException whose endNow is true, trigger cold start.\n+     * @param detector detector object\n+     * @return previous cold start exception\n+     */\n+    private Optional<Exception> coldStartIfNoCheckPoint(AnomalyDetector detector) {\n+        String detectorId = detector.getDetectorId();\n \n-        @Override\n-        public Boolean call() {\n-            String detectorId = detector.getDetectorId();\n-            try {\n-                Optional<double[][]> traingData = featureManager.getColdStartData(detector);\n-                if (traingData.isPresent()) {\n-                    double[][] trainingPoints = traingData.get();\n-                    modelManager.trainModel(detector, trainingPoints);\n-                    return true;\n-                } else {\n-                    throw new EndRunException(detectorId, \"Cannot get training data\", false);\n-                }\n+        Optional<Exception> previousException = stateManager.fetchColdStartException(detectorId);\n \n-            } catch (ElasticsearchTimeoutException timeoutEx) {\n-                throw new InternalFailure(\n-                    detector.getDetectorId(),\n-                    \"Time out while indexing cold start checkpoint or get training data\",\n-                    timeoutEx\n-                );\n-            } catch (EndRunException endRunEx) {\n-                throw endRunEx;\n-            } catch (Exception ex) {\n-                throw new EndRunException(detector.getDetectorId(), \"Error while cold start\", ex, false);\n+        if (previousException.isPresent()) {\n+            Exception exception = previousException.get();\n+            LOG.error(\"Previous exception of {}: {}\", detectorId, exception);\n+            if (exception instanceof EndRunException && ((EndRunException) exception).isEndNow()) {\n+                return previousException;\n             }\n         }\n \n+        stateManager.getDetectorCheckpoint(detectorId, ActionListener.wrap(checkpointExists -> {\n+            if (!checkpointExists) {", "originalCommit": "2f63d9e1d7d3525ddfdff80e717eaaf97d4d434f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM3MjM0NQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r472372345", "bodyText": "This is a callback.  We don't need to return anything.", "author": "kaituo", "createdAt": "2020-08-18T17:43:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg2NTI5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg2ODI0OQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r471868249", "bodyText": "question. why should exception be cleared only when data point is missing?", "author": "wnbts", "createdAt": "2020-08-18T01:54:05Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "diffHunk": "@@ -770,39 +777,110 @@ private boolean shouldStart(\n         return true;\n     }\n \n-    class ColdStartJob implements Callable<Boolean> {\n+    private void coldStart(AnomalyDetector detector) {\n+        String detectorId = detector.getDetectorId();\n+\n+        ActionListener<Optional<double[][]>> listener = ActionListener.wrap(trainingData -> {\n+            if (trainingData.isPresent()) {\n+                double[][] dataPoints = trainingData.get();\n+\n+                ActionListener<Void> trainModelListener = ActionListener\n+                    .wrap(res -> { LOG.info(\"Succeeded in training {}\", detectorId); }, exception -> {\n+                        if (exception instanceof AnomalyDetectionException) {\n+                            // e.g., partitioned model exceeds memory limit\n+                            stateManager.setLastColdStartException(detectorId, exception);\n+                        } else if (exception instanceof IllegalArgumentException) {\n+                            // IllegalArgumentException due to invalid training data\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new EndRunException(detectorId, \"Invalid training data\", exception, false)\n+                                );\n+                        } else if (exception instanceof ElasticsearchTimeoutException) {\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new InternalFailure(detectorId, \"Time out while indexing cold start checkpoint\", exception)\n+                                );\n+                        } else {\n+                            stateManager\n+                                .setLastColdStartException(\n+                                    detectorId,\n+                                    new EndRunException(detectorId, \"Error while training model\", exception, false)\n+                                );\n+                        }\n+                    });\n+\n+                modelManager\n+                    .trainModel(\n+                        detector,\n+                        dataPoints,\n+                        new ThreadedActionListener<>(LOG, threadPool, AnomalyDetectorPlugin.AD_THREAD_POOL_NAME, trainModelListener, false)\n+                    );\n+            } else {\n+                stateManager.setLastColdStartException(detectorId, new EndRunException(detectorId, \"Cannot get training data\", false));\n+            }\n+        }, exception -> {\n+            if (exception instanceof ElasticsearchTimeoutException) {\n+                stateManager\n+                    .setLastColdStartException(\n+                        detectorId,\n+                        new InternalFailure(detectorId, \"Time out while getting training data\", exception)\n+                    );\n+            } else if (exception instanceof AnomalyDetectionException) {\n+                // e.g., Invalid search query\n+                stateManager.setLastColdStartException(detectorId, exception);\n+            } else {\n+                stateManager\n+                    .setLastColdStartException(detectorId, new EndRunException(detectorId, \"Error while cold start\", exception, false));\n+            }\n+        });\n \n-        private AnomalyDetector detector;\n+        threadPool\n+            .executor(AnomalyDetectorPlugin.AD_THREAD_POOL_NAME)\n+            .execute(\n+                () -> featureManager\n+                    .getColdStartData(\n+                        detector,\n+                        new ThreadedActionListener<>(LOG, threadPool, AnomalyDetectorPlugin.AD_THREAD_POOL_NAME, listener, false)\n+                    )\n+            );\n+    }\n \n-        ColdStartJob(AnomalyDetector detector) {\n-            this.detector = detector;\n-        }\n+    /**\n+     * Check if checkpoint for an detector exists or not.  If not and previous\n+     *  run is not EndRunException whose endNow is true, trigger cold start.\n+     * @param detector detector object\n+     * @return previous cold start exception\n+     */\n+    private Optional<Exception> coldStartIfNoCheckPoint(AnomalyDetector detector) {\n+        String detectorId = detector.getDetectorId();\n \n-        @Override\n-        public Boolean call() {\n-            String detectorId = detector.getDetectorId();\n-            try {\n-                Optional<double[][]> traingData = featureManager.getColdStartData(detector);\n-                if (traingData.isPresent()) {\n-                    double[][] trainingPoints = traingData.get();\n-                    modelManager.trainModel(detector, trainingPoints);\n-                    return true;\n-                } else {\n-                    throw new EndRunException(detectorId, \"Cannot get training data\", false);\n-                }\n+        Optional<Exception> previousException = stateManager.fetchColdStartException(detectorId);", "originalCommit": "2f63d9e1d7d3525ddfdff80e717eaaf97d4d434f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM3Mjc3OQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r472372779", "bodyText": "What do you mean by \"data point is missing\"?", "author": "kaituo", "createdAt": "2020-08-18T17:44:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg2ODI0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM5MjEyOQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r472392129", "bodyText": "look at when the method coldStartIfNoCheckPoint gets called", "author": "wnbts", "createdAt": "2020-08-18T18:18:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg2ODI0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQzMzI0NA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r472433244", "bodyText": "There is another method calling fetchColdStartException: coldStartIfNoModel", "author": "kaituo", "createdAt": "2020-08-18T19:34:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg2ODI0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ0MTczMQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r472441731", "bodyText": "Is it possible that last cold start still not finished when execute coldStart ? Should we check the state of last cold start ?", "author": "ylwu-amzn", "createdAt": "2020-08-18T19:51:41Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/AnomalyResultTransportAction.java", "diffHunk": "@@ -397,32 +396,46 @@ protected void doExecute(Task task, ActionRequest actionRequest, ActionListener<\n      *\n      * @param failure  object that may contain exceptions thrown\n      * @param detector detector object\n-     * @return whether cold start runs\n+     * @return exception if we get resource not found exception\n      * @throws AnomalyDetectionException List of exceptions we can throw\n      *     1. Exception from cold start:\n      *       1). InternalFailure due to\n      *         a. ElasticsearchTimeoutException thrown by putModelCheckpoint during cold start\n      *       2). EndRunException with endNow equal to false\n      *         a. training data not available\n      *         b. cold start cannot succeed\n+     *         c. invalid training data\n+     *       3) EndRunException with endNow equal to true\n+     *         a. invalid search query\n      *     2. LimitExceededException from one of RCF model node when the total size of the models\n      *      is more than X% of heap memory.\n      *     3. InternalFailure wrapping ElasticsearchTimeoutException inside caused by\n      *      RCF/Threshold model node failing to get checkpoint to restore model before timeout.\n      */\n-    private boolean coldStartIfNoModel(AtomicReference<AnomalyDetectionException> failure, AnomalyDetector detector)\n+    private Exception coldStartIfNoModel(AtomicReference<AnomalyDetectionException> failure, AnomalyDetector detector)\n         throws AnomalyDetectionException {\n         AnomalyDetectionException exp = failure.get();\n-        if (exp != null) {\n-            if (exp instanceof ResourceNotFoundException) {\n-                LOG.info(\"Trigger cold start for {}\", detector.getDetectorId());\n-                globalRunner.compute(new ColdStartJob(detector));\n-                return true;\n-            } else {\n-                throw exp;\n+        if (exp == null) {\n+            return null;\n+        }\n+\n+        if (!(exp instanceof ResourceNotFoundException)) {\n+            throw exp;\n+        }\n+\n+        // fetch previous cold start exception\n+        String adID = detector.getDetectorId();\n+        final Optional<Exception> previousException = stateManager.fetchColdStartException(adID);\n+        if (previousException.isPresent()) {\n+            Exception exception = previousException.get();\n+            LOG.error(\"Previous exception of {}: {}\", () -> adID, () -> exception);\n+            if (exception instanceof EndRunException && ((EndRunException) exception).isEndNow()) {\n+                return exception;\n             }\n         }\n-        return false;\n+        LOG.info(\"Trigger cold start for {}\", detector.getDetectorId());\n+        coldStart(detector);", "originalCommit": "2f63d9e1d7d3525ddfdff80e717eaaf97d4d434f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ3MTYzMA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r472471630", "bodyText": "It is possible.  Let me add a check.", "author": "kaituo", "createdAt": "2020-08-18T20:29:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ0MTczMQ=="}], "type": "inlineReview"}, {"oid": "72dc0e8e31bc6d5fb20ba7ff96a7939564d62d58", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/72dc0e8e31bc6d5fb20ba7ff96a7939564d62d58", "message": "Make threadpool name configurable and add get checkpoint exception to last cold start exception, and more", "committedDate": "2020-08-18T23:55:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjU2NDAxNg==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r472564016", "bodyText": "minor. why not do expired(expirationdate=now-ttl)? ttl is an odd parameter.", "author": "wnbts", "createdAt": "2020-08-19T00:20:52Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/ad/transport/TransportStateManager.java", "diffHunk": "@@ -187,7 +188,7 @@ public void maintenance() {\n             String detectorId = entry.getKey();\n             try {\n                 TransportState state = entry.getValue();\n-                if (state.expired(stateTtl, clock.instant())) {\n+                if (state.expired(stateTtl)) {", "originalCommit": "72dc0e8e31bc6d5fb20ba7ff96a7939564d62d58", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE5NDg3Nw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r473194877", "bodyText": "expirationdate is a date, while ttl is a duration.  ttl means time to leave.", "author": "kaituo", "createdAt": "2020-08-19T17:13:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjU2NDAxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzI4NjEwOA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r473286108", "bodyText": "the method can just take one input parameter as the final expiration time, which can be calculated by the client however they want. in this case, it is now-tll. the method is easier to understand and use and more reusable.", "author": "wnbts", "createdAt": "2020-08-19T20:02:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjU2NDAxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzMwMjA5OQ==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r473302099", "bodyText": "I don't understand.  Expiration date = last access time + ttl.  Why is it now-ttl?", "author": "kaituo", "createdAt": "2020-08-19T20:33:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjU2NDAxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzMwNTExMA==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r473305110", "bodyText": "so this method takes one parameter that is the expiration time. if the last access time is before it, the method returns true, otherwise it returns false.", "author": "wnbts", "createdAt": "2020-08-19T20:39:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjU2NDAxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgxMDkxMw==", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/pull/208#discussion_r474810913", "bodyText": "In that case, all the caller has to compute the expiration time.  Current implementation looks easier that encapsulate the logic inside.", "author": "kaituo", "createdAt": "2020-08-21T16:46:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjU2NDAxNg=="}], "type": "inlineReview"}, {"oid": "bb86d965958039026cf501e8b129cbf4e9ebbb21", "url": "https://github.com/opendistro-for-elasticsearch/anomaly-detection/commit/bb86d965958039026cf501e8b129cbf4e9ebbb21", "message": "Add comments to transport state methods", "committedDate": "2020-08-19T17:50:23Z", "type": "commit"}]}