{"pr_number": 6486, "pr_title": "Fix #6402 - DataTable: cleanup filtering", "pr_createdAt": "2020-11-07T00:19:45Z", "pr_url": "https://github.com/primefaces/primefaces/pull/6486", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTE3MjAxMQ==", "url": "https://github.com/primefaces/primefaces/pull/6486#discussion_r519172011", "bodyText": "I don't understand the variable name intlSM I can't figure out what that is short for should it be intlFM for FilterMeta?", "author": "melloware", "createdAt": "2020-11-07T12:20:42Z", "path": "src/main/java/org/primefaces/component/datatable/DataTable.java", "diffHunk": "@@ -1529,11 +1543,139 @@ public boolean isSortingCurrentlyActive() {\n         return getSortByAsMap().values().stream().anyMatch(SortMeta::isActive);\n     }\n \n+    protected Map<String, FilterMeta> initFilterBy(Object userFilterBy) {\n+        Map<String, FilterMeta> filterBy = new HashMap<>();\n+        AtomicBoolean filtered = new AtomicBoolean();\n+\n+\n+        // build global filterBy\n+        String globalFilter = getGlobalFilter();\n+        Set<SearchExpressionHint> hint = LangUtils.isValueBlank(globalFilter)\n+                ? EnumSet.of(SearchExpressionHint.IGNORE_NO_RESULT)\n+                : Collections.emptySet();\n+        UIComponent globalFilterComponent = SearchExpressionFacade\n+                .resolveComponent(getFacesContext(), this, DataTable.PropertyKeys.globalFilter.toString(), hint);\n+        if (globalFilterComponent != null) {\n+            if (globalFilterComponent instanceof ValueHolder) {\n+                ((ValueHolder) globalFilterComponent).setValue(globalFilter);\n+            }\n+            FilterMeta globalFilterBy = FilterMeta.of(globalFilter, getGlobalFilterFunction());\n+            filterBy.put(globalFilterBy.getColumnKey(), globalFilterBy);\n+        }\n+\n+        // build columns filterBy\n+        char separator = UINamingContainer.getSeparatorChar(getFacesContext());\n+        populateFilterBy(getFacesContext(), separator, this, filterBy, filtered);\n+\n+        // merge internal filterBy with user filterBy\n+        if (userFilterBy != null) {\n+            Collection<FilterMeta> filterByTmp;\n+            if (userFilterBy instanceof SortMeta) {\n+                filterByTmp = Collections.singletonList((FilterMeta) userFilterBy);\n+            }\n+            else if (!(userFilterBy instanceof Collection)) {\n+                throw new FacesException(\"DataTable#filterBy expects a single or a collection of FilterMeta\");\n+            }\n+            else {\n+                filterByTmp = (Collection<FilterMeta>) userFilterBy;\n+            }\n+\n+            updateFilterByWithUserFilterBy(filterBy, filterByTmp, filtered);\n+        }\n+\n+        setDefaultFilter(filtered.get());\n+\n+        return filterBy;\n+    }\n+\n+    protected void populateFilterBy(FacesContext context, char separator, UIComponent root, Map<String, FilterMeta> filterBy, AtomicBoolean defaultFilter) {\n+        for (int i = 0; i < root.getChildCount(); i++) {\n+            UIComponent child = root.getChildren().get(i);\n+            if (child.isRendered()) {\n+                if (child instanceof Columns) {\n+                    Columns columns = (Columns) child;\n+                    String uiColumnsClientId = columns.getClientId(context);\n+\n+                    for (int j = 0; j < columns.getRowCount(); j++) {\n+                        DynamicColumn dynaColumn = new DynamicColumn(j, columns);\n+                        dynaColumn.setColumnKey(uiColumnsClientId + separator + j);\n+                        FilterMeta f = FilterMeta.of(getFacesContext(), getVar(), dynaColumn);\n+                        if (f != null) {\n+                            filterBy.put(f.getColumnKey(), f);\n+                            defaultFilter.set(defaultFilter.get() || f.isActive());\n+                        }\n+                    }\n+                }\n+                else if (child instanceof UIColumn) {\n+                    UIColumn column = (UIColumn) child;\n+                    FilterMeta f = FilterMeta.of(getFacesContext(), getVar(), column);\n+                    if (f != null) {\n+                        filterBy.put(f.getColumnKey(), f);\n+                        defaultFilter.set(defaultFilter.get() || f.isActive());\n+                    }\n+                }\n+                else if (child instanceof Row) {\n+                    populateFilterBy(context, separator, child, filterBy, defaultFilter);\n+                }\n+                else if (child instanceof ColumnGroup) {\n+                    populateFilterBy(context, separator, child, filterBy, defaultFilter);\n+                }\n+            }\n+        }\n+    }\n+\n+    protected void updateFilterByWithTableState(Map<String, FilterMeta> tsSortBy) {\n+        if (tsSortBy != null) {\n+            boolean defaultFilter = isDefaultFilter();\n+            for (Map.Entry<String, FilterMeta> entry : tsSortBy.entrySet()) {\n+                FilterMeta intlSortBy = getFilterByAsMap().get(entry.getKey());\n+                if (intlSortBy != null) {\n+                    FilterMeta tsSortMeta = entry.getValue();\n+                    intlSortBy.setFilterValue(tsSortMeta.getFilterValue());\n+                    defaultFilter |= intlSortBy.isActive();\n+                }\n+            }\n+\n+            setDefaultFilter(defaultFilter);\n+        }\n+    }\n+\n+    protected void updateFilterByWithUserFilterBy(Map<String, FilterMeta> intlFilterBy, Collection<FilterMeta> usrFilterBy, AtomicBoolean filtered) {\n+        for (FilterMeta userFM : usrFilterBy) {\n+            FilterMeta intlSM = intlFilterBy.values().stream()", "originalCommit": "e6f9da2912c8ebebb458cab13cd638498f6fbdf2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTE3NDIyMw==", "url": "https://github.com/primefaces/primefaces/pull/6486#discussion_r519174223", "bodyText": "Yes indeed, I copy/paste from previous PR", "author": "Rapster", "createdAt": "2020-11-07T12:47:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTE3MjAxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTE3MjM2OQ==", "url": "https://github.com/primefaces/primefaces/pull/6486#discussion_r519172369", "bodyText": "Why comment out and not just remove?", "author": "melloware", "createdAt": "2020-11-07T12:24:28Z", "path": "src/main/java/org/primefaces/component/datatable/DataTable.java", "diffHunk": "@@ -305,32 +310,32 @@ public void processUpdates(FacesContext context) {\n             setSelection(null);\n         }\n \n-        Map<String, FilterMeta> filterBy = getFilterBy();\n-        if (!filterBy.isEmpty()) {\n-            ELContext elContext = context.getELContext();\n-            for (FilterMeta filter : filterBy.values()) {\n-                UIColumn column = filter.getColumn();\n-                if (column == null) {\n-                    column = findColumn(filter.getColumnKey());\n-                    filter.setColumn(column);\n-                }\n-\n-                if (column != null) {\n-                    ValueExpression columnFilterValueVE = column.getValueExpression(Column.PropertyKeys.filterValue.toString());\n-                    if (columnFilterValueVE != null) {\n-                        if (column.isDynamic()) {\n-                            DynamicColumn dynamicColumn = (DynamicColumn) column;\n-                            dynamicColumn.applyStatelessModel();\n-                            columnFilterValueVE.setValue(elContext, filter.getFilterValue());\n-                            dynamicColumn.cleanStatelessModel();\n-                        }\n-                        else {\n-                            columnFilterValueVE.setValue(elContext, filter.getFilterValue());\n-                        }\n-                    }\n-                }\n-            }\n-        }\n+//        Map<String, FilterMeta> filterBy = getFilterBy();\n+//        if (!filterBy.isEmpty()) {\n+//            ELContext elContext = context.getELContext();\n+//            for (FilterMeta filter : filterBy.values()) {\n+//                UIColumn column = filter.getColumn();\n+//                if (column == null) {\n+//                    column = findColumn(filter.getColumnKey());\n+//                    filter.setColumn(column);\n+//                }\n+//\n+//                if (column != null) {\n+//                    ValueExpression columnFilterValueVE = column.getValueExpression(Column.PropertyKeys.filterValue.toString());\n+//                    if (columnFilterValueVE != null) {\n+//                        if (column.isDynamic()) {\n+//                            DynamicColumn dynamicColumn = (DynamicColumn) column;\n+//                            dynamicColumn.applyStatelessModel();\n+//                            columnFilterValueVE.setValue(elContext, filter.getFilterValue());\n+//                            dynamicColumn.cleanStatelessModel();\n+//                        }\n+//                        else {\n+//                            columnFilterValueVE.setValue(elContext, filter.getFilterValue());\n+//                        }\n+//                    }\n+//                }\n+//            }\n+//        }", "originalCommit": "e6f9da2912c8ebebb458cab13cd638498f6fbdf2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTE3NDI0Ng==", "url": "https://github.com/primefaces/primefaces/pull/6486#discussion_r519174246", "bodyText": "Because I'm still trying to understand what it's suppose to do", "author": "Rapster", "createdAt": "2020-11-07T12:47:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTE3MjM2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTgwMDg5Ng==", "url": "https://github.com/primefaces/primefaces/pull/6486#discussion_r519800896", "bodyText": "Will this have the same issue you just fixed for sorting regression?", "author": "melloware", "createdAt": "2020-11-09T13:12:04Z", "path": "src/main/java/org/primefaces/component/datatable/DataTable.java", "diffHunk": "@@ -1386,13 +1400,13 @@ public void restoreMultiViewState() {\n             }\n \n             updateSortByWithTableState(ts.getSortBy());\n+            updateFilterByWithTableState(ts.getFilterBy());", "originalCommit": "d89539ac1b015db2f62710eb3baa056d207d6506", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTgwMTU0OA==", "url": "https://github.com/primefaces/primefaces/pull/6486#discussion_r519801548", "bodyText": "Will this have the same regression issue as sorting?", "author": "melloware", "createdAt": "2020-11-09T13:12:41Z", "path": "src/main/java/org/primefaces/component/datatable/DataTable.java", "diffHunk": "@@ -1325,6 +1338,7 @@ public Object saveState(FacesContext context) {\n         }\n \n         setSortByAsMap(null);\n+        setFilterByAsMap(null);", "originalCommit": "d89539ac1b015db2f62710eb3baa056d207d6506", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTgwNjE0Mg==", "url": "https://github.com/primefaces/primefaces/pull/6486#discussion_r519806142", "bodyText": "I don't think so, because each filters have their own input so it will always be submitted to the server (which is not the case for sorting). But since, filterMeta should live over multiple request I'm planning to remove this yes", "author": "Rapster", "createdAt": "2020-11-09T13:16:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTgwMTU0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTgwOTYxNQ==", "url": "https://github.com/primefaces/primefaces/pull/6486#discussion_r519809615", "bodyText": "You might be right actually, I don't have any use case in mind, but even if inputs are passed to the request, you still need the \"encodingFeature\" parameter to enable filtering. Anyway, don't worry I'll remove this \ud83d\ude09", "author": "Rapster", "createdAt": "2020-11-09T13:21:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTgwMTU0OA=="}], "type": "inlineReview"}, {"oid": "15a385e076a1232f0ed89dea23e12a2140c621e0", "url": "https://github.com/primefaces/primefaces/commit/15a385e076a1232f0ed89dea23e12a2140c621e0", "message": "Fix #6402 - DataTable: cleanup filtering", "committedDate": "2020-11-11T18:54:29Z", "type": "forcePushed"}, {"oid": "9cfcb4b4777aa14c602f2dc22cb13968936e50e1", "url": "https://github.com/primefaces/primefaces/commit/9cfcb4b4777aa14c602f2dc22cb13968936e50e1", "message": "Fix #6402 - DataTable: cleanup filtering", "committedDate": "2020-11-17T11:17:03Z", "type": "commit"}, {"oid": "f014695577af0d8813b46555ee533aba5170b084", "url": "https://github.com/primefaces/primefaces/commit/f014695577af0d8813b46555ee533aba5170b084", "message": "Fix #6402 - DataTable: cleanup filtering\n\n* add header", "committedDate": "2020-11-17T11:17:05Z", "type": "commit"}, {"oid": "b37468668c2e923c4a8f395426501190f2418149", "url": "https://github.com/primefaces/primefaces/commit/b37468668c2e923c4a8f395426501190f2418149", "message": "Fix #6402 - DataTable: cleanup filtering\n\n* cosmetics", "committedDate": "2020-11-17T11:17:05Z", "type": "commit"}, {"oid": "c659a82135cd4c8d6b3fd5fe367038861d27de03", "url": "https://github.com/primefaces/primefaces/commit/c659a82135cd4c8d6b3fd5fe367038861d27de03", "message": "Fix #6402 - DataTable: cleanup filtering\n\n* cosmetics", "committedDate": "2020-11-17T11:17:06Z", "type": "commit"}, {"oid": "e8b299ce508a6a0f1b58c9a69b457ba84e452f8b", "url": "https://github.com/primefaces/primefaces/commit/e8b299ce508a6a0f1b58c9a69b457ba84e452f8b", "message": "Fix #6402 - DataTable: cleanup filtering\n\n* cosmetics", "committedDate": "2020-11-17T11:17:07Z", "type": "commit"}, {"oid": "3554f35f8ea0096c15a795b0a2a1e7324a49abf1", "url": "https://github.com/primefaces/primefaces/commit/3554f35f8ea0096c15a795b0a2a1e7324a49abf1", "message": "Fix #6402 - DataTable: cleanup filtering\n\n* cosmetics", "committedDate": "2020-11-17T11:17:09Z", "type": "commit"}, {"oid": "d0ce2acc47bf06da8d56457a70abce8031c1b498", "url": "https://github.com/primefaces/primefaces/commit/d0ce2acc47bf06da8d56457a70abce8031c1b498", "message": "Fix #6402 - DataTable: cleanup filtering\n\n* cosmetics", "committedDate": "2020-11-17T11:17:09Z", "type": "commit"}, {"oid": "9ac80586a356f80348e511b5968a29eec694a6d8", "url": "https://github.com/primefaces/primefaces/commit/9ac80586a356f80348e511b5968a29eec694a6d8", "message": "Fix #6402 - DataTable: cleanup filtering\n\n* cosmetics", "committedDate": "2020-11-17T11:17:10Z", "type": "commit"}, {"oid": "3f898eff6a6f3b85380919cc74126a26c468743e", "url": "https://github.com/primefaces/primefaces/commit/3f898eff6a6f3b85380919cc74126a26c468743e", "message": "Fix #6402 - DataTable: cleanup filtering", "committedDate": "2020-11-17T12:07:06Z", "type": "commit"}, {"oid": "3f898eff6a6f3b85380919cc74126a26c468743e", "url": "https://github.com/primefaces/primefaces/commit/3f898eff6a6f3b85380919cc74126a26c468743e", "message": "Fix #6402 - DataTable: cleanup filtering", "committedDate": "2020-11-17T12:07:06Z", "type": "forcePushed"}, {"oid": "02a26d020c51cb0136ecab2af15aa2b42e5eb201", "url": "https://github.com/primefaces/primefaces/commit/02a26d020c51cb0136ecab2af15aa2b42e5eb201", "message": "Fix #6402 - DataTable: cleanup filtering", "committedDate": "2020-11-17T13:14:32Z", "type": "commit"}, {"oid": "bef9f2121c7276ae64939835ea90e343d2a2cc3c", "url": "https://github.com/primefaces/primefaces/commit/bef9f2121c7276ae64939835ea90e343d2a2cc3c", "message": "Fix #6402 - DataTable: cleanup filtering", "committedDate": "2020-11-17T20:36:36Z", "type": "commit"}, {"oid": "0d9a8e1558c5284240ef9b957debcf3c945e6293", "url": "https://github.com/primefaces/primefaces/commit/0d9a8e1558c5284240ef9b957debcf3c945e6293", "message": "Fix #6402 - DataTable: cleanup filtering", "committedDate": "2020-11-17T20:51:55Z", "type": "commit"}, {"oid": "66dd59cee8b0f1f6b06957ff58b347e2e9f82b80", "url": "https://github.com/primefaces/primefaces/commit/66dd59cee8b0f1f6b06957ff58b347e2e9f82b80", "message": "Fix #6402 - DataTable: cleanup filtering", "committedDate": "2020-11-17T20:54:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUzMTU1Ng==", "url": "https://github.com/primefaces/primefaces/pull/6486#discussion_r525531556", "bodyText": "Typically our imports are java, javax, org, com.  Or at least that is how I have mine set.", "author": "melloware", "createdAt": "2020-11-17T21:20:02Z", "path": "src/main/java/org/primefaces/component/datatable/DataTableBase.java", "diffHunk": "@@ -23,14 +23,13 @@\n  */\n package org.primefaces.component.datatable;\n \n-import java.util.Collections;\n-import java.util.Map;\n+import org.primefaces.component.api.*;\n+import org.primefaces.model.FilterMeta;\n \n import javax.el.MethodExpression;\n import javax.faces.component.behavior.ClientBehaviorHolder;\n-\n-import org.primefaces.component.api.*;\n-import org.primefaces.model.FilterMeta;\n+import java.util.Collections;\n+import java.util.List;", "originalCommit": "66dd59cee8b0f1f6b06957ff58b347e2e9f82b80", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU2NzU4OA==", "url": "https://github.com/primefaces/primefaces/pull/6486#discussion_r525567588", "bodyText": "I think this is a topic that has been discussed in the past but no answer given. I'm using default settings from intellij", "author": "Rapster", "createdAt": "2020-11-17T22:29:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUzMTU1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjA1NzM5OA==", "url": "https://github.com/primefaces/primefaces/pull/6486#discussion_r526057398", "bodyText": "Understood. You are right I am not sure there is a standard but we should proabbly make one.  I know in the past its more than 5 imports becomes java.util.* is the one standard but we should probably document it.  Possibly even use Spotless plugin to correct it.", "author": "melloware", "createdAt": "2020-11-18T12:43:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUzMTU1Ng=="}], "type": "inlineReview"}, {"oid": "71c3237f79072063eaeeab70fa17e2cbeb7811ba", "url": "https://github.com/primefaces/primefaces/commit/71c3237f79072063eaeeab70fa17e2cbeb7811ba", "message": "Fix #6402 - DataTable: cleanup filtering", "committedDate": "2020-11-17T23:43:50Z", "type": "commit"}, {"oid": "d065584fc8f02d4c7c4cdbc96fb47baf4eae4eab", "url": "https://github.com/primefaces/primefaces/commit/d065584fc8f02d4c7c4cdbc96fb47baf4eae4eab", "message": "Fix #6402 - DataTable: cleanup filtering", "committedDate": "2020-11-18T11:09:57Z", "type": "commit"}, {"oid": "bf3a67c3c74e5d7272d69e103950eb6798e5e678", "url": "https://github.com/primefaces/primefaces/commit/bf3a67c3c74e5d7272d69e103950eb6798e5e678", "message": "Fix #6402 - DataTable: cleanup filtering", "committedDate": "2020-11-18T11:12:23Z", "type": "commit"}, {"oid": "166210fdc70e6d46acfac085b466a1268ebc1226", "url": "https://github.com/primefaces/primefaces/commit/166210fdc70e6d46acfac085b466a1268ebc1226", "message": "Fix #6402 - DataTable: cleanup filtering", "committedDate": "2020-11-19T14:50:12Z", "type": "commit"}, {"oid": "b8d9a553116bf1f78ea9254715d166e5ea08a371", "url": "https://github.com/primefaces/primefaces/commit/b8d9a553116bf1f78ea9254715d166e5ea08a371", "message": "Fix #6402 - DataTable: cleanup filtering", "committedDate": "2020-11-19T17:57:41Z", "type": "commit"}, {"oid": "ad6c79a3c750c93f51b5f39a54b791208462a7a9", "url": "https://github.com/primefaces/primefaces/commit/ad6c79a3c750c93f51b5f39a54b791208462a7a9", "message": "Fix #6402 - DataTable: cleanup filtering", "committedDate": "2020-11-21T15:54:00Z", "type": "commit"}, {"oid": "904e399e8aa3b952c20f482c218ddd20481930d8", "url": "https://github.com/primefaces/primefaces/commit/904e399e8aa3b952c20f482c218ddd20481930d8", "message": "Fix #6402 - DataTable: cleanup filtering", "committedDate": "2020-11-21T15:57:33Z", "type": "commit"}, {"oid": "5b911f055b1cd422555e4fe4b954d14aa433c73b", "url": "https://github.com/primefaces/primefaces/commit/5b911f055b1cd422555e4fe4b954d14aa433c73b", "message": "Fix #6402 - DataTable: cleanup filtering", "committedDate": "2020-11-21T16:00:11Z", "type": "commit"}, {"oid": "4d84d93415799283b7719c719ef93ed4ccddd1ed", "url": "https://github.com/primefaces/primefaces/commit/4d84d93415799283b7719c719ef93ed4ccddd1ed", "message": "Fix #6402 - DataTable: cleanup filtering", "committedDate": "2020-11-22T00:54:06Z", "type": "commit"}, {"oid": "ac31ed5d42827a8a6d9b7b41c27f851b6244ecee", "url": "https://github.com/primefaces/primefaces/commit/ac31ed5d42827a8a6d9b7b41c27f851b6244ecee", "message": "Fix #6402 - DataTable: cleanup filtering", "committedDate": "2020-11-22T12:53:31Z", "type": "commit"}, {"oid": "09ef6cadebb03547f86c7d9799561d123ac2c704", "url": "https://github.com/primefaces/primefaces/commit/09ef6cadebb03547f86c7d9799561d123ac2c704", "message": "Fix #6402 - DataTable: cleanup filtering", "committedDate": "2020-11-22T13:03:32Z", "type": "commit"}, {"oid": "5e7e8c2866ecb8f6ed1c4fbbc94e85b923aed663", "url": "https://github.com/primefaces/primefaces/commit/5e7e8c2866ecb8f6ed1c4fbbc94e85b923aed663", "message": "Fix #6402 - DataTable: cleanup filtering", "committedDate": "2020-11-25T21:18:14Z", "type": "commit"}, {"oid": "4308246a2efe77aabbdefe7f23fbe702d2870be5", "url": "https://github.com/primefaces/primefaces/commit/4308246a2efe77aabbdefe7f23fbe702d2870be5", "message": "Fix #6402 - DataTable: cleanup filtering", "committedDate": "2020-11-25T21:50:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTEyNzY4MQ==", "url": "https://github.com/primefaces/primefaces/pull/6486#discussion_r531127681", "bodyText": "Variable names in this whole method still say \"sort\" instead of \"filter\"", "author": "melloware", "createdAt": "2020-11-26T16:14:40Z", "path": "src/main/java/org/primefaces/component/datatable/DataTable.java", "diffHunk": "@@ -1542,11 +1527,152 @@ public boolean isColumnSortable(UIColumn column) {\n         return true;\n     }\n \n+    protected void visitColumns(FacesContext context, char separator, UIComponent root, Consumer<UIColumn> visitor) {\n+        for (int i = 0; i < root.getChildCount(); i++) {\n+            UIComponent child = root.getChildren().get(i);\n+            if (child.isRendered()) {\n+                if (child instanceof Columns) {\n+                    Columns columns = (Columns) child;\n+                    String uiColumnsClientId = columns.getClientId(context);\n+\n+                    for (int j = 0; j < columns.getRowCount(); j++) {\n+                        DynamicColumn dynaColumn = new DynamicColumn(j, columns);\n+                        dynaColumn.setColumnKey(uiColumnsClientId + separator + j);\n+                        visitor.accept(dynaColumn);\n+                    }\n+                }\n+                else if (child instanceof UIColumn) {\n+                    UIColumn column = (UIColumn) child;\n+                    visitor.accept(column);\n+                }\n+                else if (child instanceof ColumnGroup) {\n+                    visitColumns(context, separator, child, visitor);\n+                }\n+            }\n+        }\n+    }\n+\n+    public Map<String, FilterMeta> initFilterBy() {\n+        boolean invalidate = getStateHelper().get(\"_filterBy\") == null;\n+        Map<String, FilterMeta> filterBy = invalidate ? new HashMap<>() : getFilterByAsMap();\n+        AtomicBoolean filtered = invalidate ? new AtomicBoolean() : new AtomicBoolean(isDefaultFilter());\n+\n+        // build columns filterBy\n+        char separator = UINamingContainer.getSeparatorChar(getFacesContext());\n+\n+        visitColumns(getFacesContext(), separator, this, c -> {\n+            FilterMeta f = filterBy.get(c.getColumnKey());\n+            if (f != null && !invalidate) {\n+                f.setColumn(c);\n+            }\n+            else {\n+                f = FilterMeta.of(getFacesContext(), getVar(), c);\n+                if (f != null) {\n+                    filterBy.put(f.getColumnKey(), f);\n+                    filtered.set(filtered.get() || f.isActive());\n+                }\n+            }\n+        });\n+\n+        // merge internal filterBy with user filterBy\n+        Object userfilterBy = getFilterBy();\n+        if (userfilterBy != null) {\n+            updateFilterByWithUserFilterBy(filterBy, userfilterBy, filtered);\n+        }\n+\n+        // build global filterBy\n+        updateFilterByWithGlobalFilter(filterBy, filtered);\n+\n+        // finally set if default filtering is enabled\n+        setDefaultFilter(filtered.get());\n+\n+        setFilterByAsMap(filterBy);\n+\n+        return filterBy;\n+    }\n+\n+    protected void updateFilterByWithTableState(Map<String, FilterMeta> tsSortBy) {\n+        if (tsSortBy != null) {", "originalCommit": "4308246a2efe77aabbdefe7f23fbe702d2870be5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTEyODY4MQ==", "url": "https://github.com/primefaces/primefaces/pull/6486#discussion_r531128681", "bodyText": "This will add an unmodifiable map so the user won't be able to add values to it.  Should new HashMap<> be used here?", "author": "melloware", "createdAt": "2020-11-26T16:16:40Z", "path": "src/main/java/org/primefaces/component/datatable/DataTable.java", "diffHunk": "@@ -1542,11 +1527,152 @@ public boolean isColumnSortable(UIColumn column) {\n         return true;\n     }\n \n+    protected void visitColumns(FacesContext context, char separator, UIComponent root, Consumer<UIColumn> visitor) {\n+        for (int i = 0; i < root.getChildCount(); i++) {\n+            UIComponent child = root.getChildren().get(i);\n+            if (child.isRendered()) {\n+                if (child instanceof Columns) {\n+                    Columns columns = (Columns) child;\n+                    String uiColumnsClientId = columns.getClientId(context);\n+\n+                    for (int j = 0; j < columns.getRowCount(); j++) {\n+                        DynamicColumn dynaColumn = new DynamicColumn(j, columns);\n+                        dynaColumn.setColumnKey(uiColumnsClientId + separator + j);\n+                        visitor.accept(dynaColumn);\n+                    }\n+                }\n+                else if (child instanceof UIColumn) {\n+                    UIColumn column = (UIColumn) child;\n+                    visitor.accept(column);\n+                }\n+                else if (child instanceof ColumnGroup) {\n+                    visitColumns(context, separator, child, visitor);\n+                }\n+            }\n+        }\n+    }\n+\n+    public Map<String, FilterMeta> initFilterBy() {\n+        boolean invalidate = getStateHelper().get(\"_filterBy\") == null;\n+        Map<String, FilterMeta> filterBy = invalidate ? new HashMap<>() : getFilterByAsMap();\n+        AtomicBoolean filtered = invalidate ? new AtomicBoolean() : new AtomicBoolean(isDefaultFilter());\n+\n+        // build columns filterBy\n+        char separator = UINamingContainer.getSeparatorChar(getFacesContext());\n+\n+        visitColumns(getFacesContext(), separator, this, c -> {\n+            FilterMeta f = filterBy.get(c.getColumnKey());\n+            if (f != null && !invalidate) {\n+                f.setColumn(c);\n+            }\n+            else {\n+                f = FilterMeta.of(getFacesContext(), getVar(), c);\n+                if (f != null) {\n+                    filterBy.put(f.getColumnKey(), f);\n+                    filtered.set(filtered.get() || f.isActive());\n+                }\n+            }\n+        });\n+\n+        // merge internal filterBy with user filterBy\n+        Object userfilterBy = getFilterBy();\n+        if (userfilterBy != null) {\n+            updateFilterByWithUserFilterBy(filterBy, userfilterBy, filtered);\n+        }\n+\n+        // build global filterBy\n+        updateFilterByWithGlobalFilter(filterBy, filtered);\n+\n+        // finally set if default filtering is enabled\n+        setDefaultFilter(filtered.get());\n+\n+        setFilterByAsMap(filterBy);\n+\n+        return filterBy;\n+    }\n+\n+    protected void updateFilterByWithTableState(Map<String, FilterMeta> tsSortBy) {\n+        if (tsSortBy != null) {\n+            boolean defaultFilter = isDefaultFilter();\n+            for (Map.Entry<String, FilterMeta> entry : tsSortBy.entrySet()) {\n+                FilterMeta intlSortBy = getFilterByAsMap().get(entry.getKey());\n+                if (intlSortBy != null) {\n+                    FilterMeta tsSortMeta = entry.getValue();\n+                    intlSortBy.setFilterValue(tsSortMeta.getFilterValue());\n+                    defaultFilter |= intlSortBy.isActive();\n+                }\n+            }\n+\n+            setDefaultFilter(defaultFilter);\n+        }\n+    }\n+\n+    protected void updateFilterByWithUserFilterBy(Map<String, FilterMeta> intlFilterBy, Object usrFilterBy, AtomicBoolean filtered) {\n+        Collection<FilterMeta> filterByTmp;\n+        if (usrFilterBy instanceof FilterMeta) {\n+            filterByTmp = Collections.singletonList((FilterMeta) usrFilterBy);\n+        }\n+        else if (!(usrFilterBy instanceof Collection)) {\n+            throw new FacesException(\"DataTable#filterBy expects a single or a collection of FilterMeta\");\n+        }\n+        else {\n+            filterByTmp = (Collection<FilterMeta>) usrFilterBy;\n+        }\n+\n+        for (FilterMeta userFM : filterByTmp) {\n+            FilterMeta intlFM = intlFilterBy.values().stream()\n+                    .filter(o -> o.getField().equals(userFM.getField()))\n+                    .findAny()\n+                    .orElseThrow(() -> new FacesException(\"No column with field '\" + userFM.getField() + \"' has been found\"));\n+\n+            ValueExpression filterByVE = userFM.getFilterBy();\n+            if (filterByVE == null) {\n+                filterByVE = createValueExprFromVarField(getFacesContext(), getVar(), userFM.getField());\n+            }\n+\n+            intlFM.setFilterValue(userFM.getFilterValue());\n+            intlFM.setFilterBy(filterByVE);\n+            intlFM.setConstraint(userFM.getConstraint());\n+            intlFM.setMatchMode(userFM.getMatchMode());\n+            filtered.set(filtered.get() || userFM.isActive());\n+        }\n+    }\n+\n+    protected void updateFilterByWithGlobalFilter(Map<String, FilterMeta> filterBy, AtomicBoolean filtered) {\n+        String globalFilter = getGlobalFilter();\n+        Set<SearchExpressionHint> hint = LangUtils.isValueBlank(globalFilter)\n+                ? EnumSet.of(SearchExpressionHint.IGNORE_NO_RESULT)\n+                : Collections.emptySet();\n+        UIComponent globalFilterComponent = SearchExpressionFacade\n+                .resolveComponent(getFacesContext(), this, DataTable.PropertyKeys.globalFilter.toString(), hint);\n+        if (globalFilterComponent != null) {\n+            if (globalFilterComponent instanceof ValueHolder) {\n+                ((ValueHolder) globalFilterComponent).setValue(globalFilter);\n+            }\n+            FilterMeta globalFilterBy = FilterMeta.of(filterBy.values(), globalFilter, getGlobalFilterFunction());\n+            filterBy.put(globalFilterBy.getColumnKey(), globalFilterBy);\n+            filtered.set(filtered.get() || globalFilterBy.isActive());\n+        }\n+    }\n+\n+    public boolean isColumnFilterable(UIColumn column) {\n+        Map<String, FilterMeta> filterBy = getFilterByAsMap();\n+        return filterBy.containsKey(column.getColumnKey());\n+    }\n+\n     public Map<String, SortMeta> getSortByAsMap() {\n-        return ComponentUtils.computeIfAbsent(getStateHelper(), \"_sortBy\", () -> initSortBy(getSortBy()));\n+        return ComponentUtils.computeIfAbsent(getStateHelper(), \"_sortBy\", this::initSortBy);\n     }\n \n     public void setSortByAsMap(Map<String, SortMeta> sortBy) {\n         getStateHelper().put(\"_sortBy\", sortBy);\n     }\n+\n+    public Map<String, FilterMeta> getFilterByAsMap() {\n+        return ComponentUtils.eval(getStateHelper(), \"_filterBy\", Collections::emptyMap);", "originalCommit": "4308246a2efe77aabbdefe7f23fbe702d2870be5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTE1NzM5MA==", "url": "https://github.com/primefaces/primefaces/pull/6486#discussion_r531157390", "bodyText": "I could have returned null, but I don't like returning null for collections (so I don't have to test for nullity afterwards), also users are not supposed to access/modify this map as it is used internally", "author": "Rapster", "createdAt": "2020-11-26T17:17:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTEyODY4MQ=="}], "type": "inlineReview"}, {"oid": "7028d43f576b9148ed85c3cf4a6c67345b770be5", "url": "https://github.com/primefaces/primefaces/commit/7028d43f576b9148ed85c3cf4a6c67345b770be5", "message": "Fix #6402 - DataTable: cleanup filtering", "committedDate": "2020-11-26T17:19:05Z", "type": "commit"}]}