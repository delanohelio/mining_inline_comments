{"pr_number": 1860, "pr_title": "[cygnus-ngsi][feature][NGSIArcgisFeatureTableSink] new Arcgis sink (refactor + nm stop_on_first_attr_match + jsonPath ...)", "pr_createdAt": "2020-04-20T10:16:53Z", "pr_url": "https://github.com/telefonicaid/fiware-cygnus/pull/1860", "timeline": [{"oid": "cd3d787726f27c6419cdf744d2e319983d6c17f4", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/cd3d787726f27c6419cdf744d2e319983d6c17f4", "message": "Limpieza y a\u00f1adida nueva dependencia", "committedDate": "2020-03-25T16:05:01Z", "type": "commit"}, {"oid": "1c516f7a546759bdce488d50d80cb3dc3ff5a11e", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/1c516f7a546759bdce488d50d80cb3dc3ff5a11e", "message": "Primera versi\u00f3n del Sink sin pasar test a\u00fan", "committedDate": "2020-03-27T10:52:35Z", "type": "commit"}, {"oid": "f7eacd0ea19b4f8782584a1538c5b0d4177b1855", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/f7eacd0ea19b4f8782584a1538c5b0d4177b1855", "message": "peque\u00f1os parches", "committedDate": "2020-03-27T11:58:05Z", "type": "commit"}, {"oid": "a5fa5e8aff84a17124820ecbf1c993ab2fd82e75", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/a5fa5e8aff84a17124820ecbf1c993ab2fd82e75", "message": "Cache concurrente", "committedDate": "2020-04-01T13:35:03Z", "type": "commit"}, {"oid": "7238cce5ff4a6645310831eecde756449eac6af9", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/7238cce5ff4a6645310831eecde756449eac6af9", "message": "Logging y control de errores", "committedDate": "2020-04-02T10:13:35Z", "type": "commit"}, {"oid": "78099b3bc6f2478938dbecbb7313eb41ef57e734", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/78099b3bc6f2478938dbecbb7313eb41ef57e734", "message": "Fix error parseando geo:json", "committedDate": "2020-04-02T11:05:39Z", "type": "commit"}, {"oid": "da4898f169668fd799691fb0b475ab1185ba66a4", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/da4898f169668fd799691fb0b475ab1185ba66a4", "message": "borrar c\u00f3digo in\u00fatil", "committedDate": "2020-04-02T11:06:35Z", "type": "commit"}, {"oid": "d58f30d20acbcfafdece5546d1e75f9cea2ddfb9", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/d58f30d20acbcfafdece5546d1e75f9cea2ddfb9", "message": "Fix problema de limpieza de url", "committedDate": "2020-04-02T14:23:01Z", "type": "commit"}, {"oid": "06f39d7e6a9280cd12ec92339e61f56359cc5b40", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/06f39d7e6a9280cd12ec92339e61f56359cc5b40", "message": "Tratamiento de timeouts a nivel de batch", "committedDate": "2020-04-02T15:52:37Z", "type": "commit"}, {"oid": "947b20c125e55f0b279d10ead8c05f83fcbc89e8", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/947b20c125e55f0b279d10ead8c05f83fcbc89e8", "message": "Comprobaci\u00f3n de timeouts en  m\u00e9todo process", "committedDate": "2020-04-03T08:16:47Z", "type": "commit"}, {"oid": "c0174142d7afc4f27657e19904b683625fdb9ea9", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/c0174142d7afc4f27657e19904b683625fdb9ea9", "message": "Eliminaci\u00f3n de duplicado de logs", "committedDate": "2020-04-03T08:17:17Z", "type": "commit"}, {"oid": "a64aa916b13854a523dfe3295ff9d48b9415831d", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/a64aa916b13854a523dfe3295ff9d48b9415831d", "message": "Comprueba si las features existen antes de a\u00f1adirlas", "committedDate": "2020-04-03T08:42:41Z", "type": "commit"}, {"oid": "74444e281670b954c70060d6afb5aadcfdd7824c", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/74444e281670b954c70060d6afb5aadcfdd7824c", "message": "maxBatchSize parametrizable desde el agente", "committedDate": "2020-04-03T09:21:24Z", "type": "commit"}, {"oid": "6dc647ae9cf0c759e639d878f21a4ebd77f6b412", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/6dc647ae9cf0c759e639d878f21a4ebd77f6b412", "message": "Argis Backend project", "committedDate": "2020-04-03T10:35:02Z", "type": "commit"}, {"oid": "64486108536553097d4fab3cdb7822ed1a25107a", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/64486108536553097d4fab3cdb7822ed1a25107a", "message": "Argis Backend project", "committedDate": "2020-04-03T10:35:02Z", "type": "commit"}, {"oid": "b134a13cdd5c005db297c076151e65f7e168925e", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/b134a13cdd5c005db297c076151e65f7e168925e", "message": "Fix unit tests", "committedDate": "2020-04-03T11:12:20Z", "type": "commit"}, {"oid": "b1b775a78a22cc2c33f2f00d39a63fd0f5a25277", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/b1b775a78a22cc2c33f2f00d39a63fd0f5a25277", "message": "Fix unit tests", "committedDate": "2020-04-03T11:12:20Z", "type": "commit"}, {"oid": "c68dc9c9f0da23807c9af7a8815c7fb1341705ac", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/c68dc9c9f0da23807c9af7a8815c7fb1341705ac", "message": "Telef\u00f3nica Checkstyle", "committedDate": "2020-04-06T08:11:20Z", "type": "commit"}, {"oid": "376095d1dccb6ea412411b422649b74830715e40", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/376095d1dccb6ea412411b422649b74830715e40", "message": "Telef\u00f3nica Checkstyle", "committedDate": "2020-04-06T08:11:20Z", "type": "commit"}, {"oid": "40539214494d63e42e499e91ce748e255da6bc88", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/40539214494d63e42e499e91ce748e255da6bc88", "message": "Telef\u00f3nica Checkstyle", "committedDate": "2020-04-06T08:11:20Z", "type": "commit"}, {"oid": "e88c691827adf9c65fcb2fa5756ece345a2dceba", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/e88c691827adf9c65fcb2fa5756ece345a2dceba", "message": "Eliminando", "committedDate": "2020-04-06T09:07:16Z", "type": "commit"}, {"oid": "ce7886453b31876509b70786f55980a7f9a613b8", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/ce7886453b31876509b70786f55980a7f9a613b8", "message": "Eliminando", "committedDate": "2020-04-06T09:07:16Z", "type": "commit"}, {"oid": "33342c44a768ce68f7ba85782402e9462a0aad3c", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/33342c44a768ce68f7ba85782402e9462a0aad3c", "message": "Merge branch 'ArcgisRest' of https://github.com/Stdri/fiware-cygnus into ArcgisRest", "committedDate": "2020-04-06T09:07:27Z", "type": "commit"}, {"oid": "7b90f75e905b70ab4828fb9c0a4005f3c8a71777", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/7b90f75e905b70ab4828fb9c0a4005f3c8a71777", "message": "Merge branch 'ArcgisRest' of https://github.com/Stdri/fiware-cygnus into ArcgisRest", "committedDate": "2020-04-06T09:07:27Z", "type": "commit"}, {"oid": "27abb46006d2cf6b9ace8d975bc07c2a3a09141c", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/27abb46006d2cf6b9ace8d975bc07c2a3a09141c", "message": "Delete ArcgisBaseTest.java", "committedDate": "2020-04-06T09:13:06Z", "type": "commit"}, {"oid": "15e9b43b29964c25b6982edb1f8426f27cc2b59d", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/15e9b43b29964c25b6982edb1f8426f27cc2b59d", "message": "Delete ArcgisBaseTest.java", "committedDate": "2020-04-06T09:13:06Z", "type": "commit"}, {"oid": "7e9502ef6350d3d2b75dd44de403591eadd88d39", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/7e9502ef6350d3d2b75dd44de403591eadd88d39", "message": "Merge branch 'ArcgisRest' of https://github.com/Stdri/fiware-cygnus into ArcgisRest", "committedDate": "2020-04-06T09:48:26Z", "type": "commit"}, {"oid": "5ca1bfdf04cfaba6cf892f4cb617d648de225624", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/5ca1bfdf04cfaba6cf892f4cb617d648de225624", "message": "Create ArcgisBaseTest.java", "committedDate": "2020-04-06T09:59:19Z", "type": "commit"}, {"oid": "d61290eded7d4a44bf4620b95f276318c3ada0e5", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/d61290eded7d4a44bf4620b95f276318c3ada0e5", "message": "Refactor", "committedDate": "2020-04-06T11:45:21Z", "type": "commit"}, {"oid": "6f594dc4e763428ae9b161688ee0bf0f9a8a2ce9", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/6f594dc4e763428ae9b161688ee0bf0f9a8a2ce9", "message": "Refactorizaci\u00f3n", "committedDate": "2020-04-06T15:24:54Z", "type": "commit"}, {"oid": "d68df32de53db595761aadd20fffb5aef8293e7c", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/d68df32de53db595761aadd20fffb5aef8293e7c", "message": "Formatea valores Booleanos (String, integer.. etc) a su valor entero correspondiente", "committedDate": "2020-04-14T15:09:49Z", "type": "commit"}, {"oid": "1658d5721d8d67d1416b015c42f709b92cdf3dc3", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/1658d5721d8d67d1416b015c42f709b92cdf3dc3", "message": "features Batched", "committedDate": "2020-04-14T15:10:04Z", "type": "commit"}, {"oid": "17ad18037ba413cfff35be71346c8d475b8a9178", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/17ad18037ba413cfff35be71346c8d475b8a9178", "message": "Telef\u00f3nica CheckStyle", "committedDate": "2020-04-15T08:06:45Z", "type": "commit"}, {"oid": "2d89b7a80b6c216d4fee5f1fb396dea3320559aa", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/2d89b7a80b6c216d4fee5f1fb396dea3320559aa", "message": "Telef\u00f3nica CheckStyle", "committedDate": "2020-04-15T08:08:48Z", "type": "commit"}, {"oid": "f78d2fd15d65970c8f3e9de22266d23de5739581", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/f78d2fd15d65970c8f3e9de22266d23de5739581", "message": "Doc's", "committedDate": "2020-04-15T09:29:31Z", "type": "commit"}, {"oid": "96edd8826167a1b29a5cef0d5dcc569a7b630277", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/96edd8826167a1b29a5cef0d5dcc569a7b630277", "message": "Update CHANGES_NEXT_RELEASE", "committedDate": "2020-04-15T09:34:34Z", "type": "commit"}, {"oid": "48b7bbfb76c33f535a615c604d3b27f6aa212a79", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/48b7bbfb76c33f535a615c604d3b27f6aa212a79", "message": "[NameMappingsInterceptor] stopOnFirstAttrMatch", "committedDate": "2020-04-15T12:57:30Z", "type": "commit"}, {"oid": "13f984c3545e3934b83553f513265ce86f6a2f8f", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/13f984c3545e3934b83553f513265ce86f6a2f8f", "message": "[NameMappingInterceptor] Create new attributes if needed.", "committedDate": "2020-04-15T13:38:53Z", "type": "commit"}, {"oid": "bff32558b3d14ba2204d29e4e95aa4f7b1553e44", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/bff32558b3d14ba2204d29e4e95aa4f7b1553e44", "message": "JsonPath attribute value mapping", "committedDate": "2020-04-15T14:52:47Z", "type": "commit"}, {"oid": "9be0681e14dff20cdf12c92d85df80977d3c8643", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/9be0681e14dff20cdf12c92d85df80977d3c8643", "message": "Issue fix", "committedDate": "2020-04-16T08:54:41Z", "type": "commit"}, {"oid": "6cabcff2aed2cc1195b9aad16f1f12b9d79e0d41", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/6cabcff2aed2cc1195b9aad16f1f12b9d79e0d41", "message": "Feature table, decode strings", "committedDate": "2020-04-16T08:55:56Z", "type": "commit"}, {"oid": "25dcb3130d3276d7e1ce8d8632746fadbc81c986", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/25dcb3130d3276d7e1ce8d8632746fadbc81c986", "message": "Fix issues", "committedDate": "2020-04-16T13:58:46Z", "type": "commit"}, {"oid": "5c7f58455ba35394439371eb3cf9e3d7a2f377f6", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/5c7f58455ba35394439371eb3cf9e3d7a2f377f6", "message": "Update NameMappings.java", "committedDate": "2020-04-16T15:25:05Z", "type": "commit"}, {"oid": "87095aec3e44950c4c71b399a72883c59a750987", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/87095aec3e44950c4c71b399a72883c59a750987", "message": "Reset Changes Next Release", "committedDate": "2020-04-17T06:28:57Z", "type": "commit"}, {"oid": "ff685093b3cd39eb6459ddc8f2eca4607ff3362a", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/ff685093b3cd39eb6459ddc8f2eca4607ff3362a", "message": "Merge pull request #3 from telefonicaid/master\n\nUpdate from Telefonica's Master Branch", "committedDate": "2020-04-17T06:29:47Z", "type": "commit"}, {"oid": "42ab607140d8940d789541b0fb1c92a754537d4d", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/42ab607140d8940d789541b0fb1c92a754537d4d", "message": "Update CHANGES_NEXT_RELEASE", "committedDate": "2020-04-17T06:33:06Z", "type": "commit"}, {"oid": "78f79c362ce1cdd2fd0b7303f9189e48588a65ae", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/78f79c362ce1cdd2fd0b7303f9189e48588a65ae", "message": "Update CHANGES_NEXT_RELEASE", "committedDate": "2020-04-17T06:34:36Z", "type": "commit"}, {"oid": "d27833a1ff900d622c202a05f7c93dc31974ee49", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/d27833a1ff900d622c202a05f7c93dc31974ee49", "message": "Merge branch 'JsonPath' of https://github.com/Stdri/fiware-cygnus into JsonPath", "committedDate": "2020-04-17T06:35:03Z", "type": "commit"}, {"oid": "cd25e68f7e925234b29145b236cd483a93c92863", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/cd25e68f7e925234b29145b236cd483a93c92863", "message": "Update CHANGES_NEXT_RELEASE", "committedDate": "2020-04-17T06:35:34Z", "type": "commit"}, {"oid": "ecad0c34f875175fbdc24fd9f8e22241df72c9b1", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/ecad0c34f875175fbdc24fd9f8e22241df72c9b1", "message": "Telefonica CheckStyle", "committedDate": "2020-04-17T06:48:21Z", "type": "commit"}, {"oid": "6451bad5599493aa3238454da95c39f3a48575ac", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/6451bad5599493aa3238454da95c39f3a48575ac", "message": "Docs", "committedDate": "2020-04-17T08:39:10Z", "type": "commit"}, {"oid": "882b971961750e90872509002cfb17c6761294bf", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/882b971961750e90872509002cfb17c6761294bf", "message": "Mapping value fix", "committedDate": "2020-04-17T23:15:37Z", "type": "commit"}, {"oid": "a7314539170dfd74cd1721ca1e69635e72b66a57", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/a7314539170dfd74cd1721ca1e69635e72b66a57", "message": "Checkstyle", "committedDate": "2020-04-20T08:53:34Z", "type": "commit"}, {"oid": "dd949b3362211370233e63a8522691d859dc2222", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/dd949b3362211370233e63a8522691d859dc2222", "message": "Refactorize structure", "committedDate": "2020-04-20T08:54:20Z", "type": "commit"}, {"oid": "fdc7448baa32815d9a9fb000b18d37cf69398109", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/fdc7448baa32815d9a9fb000b18d37cf69398109", "message": "Versi\u00f3n 2.0.0", "committedDate": "2020-04-20T08:54:42Z", "type": "commit"}, {"oid": "515f706fd076db4f353e26c1742ff7854bf6c25b", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/515f706fd076db4f353e26c1742ff7854bf6c25b", "message": "Create README.md", "committedDate": "2020-04-20T09:46:41Z", "type": "commit"}, {"oid": "c90af721dd586b0a540c5794e242a11688d76348", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/c90af721dd586b0a540c5794e242a11688d76348", "message": "Add issue number.", "committedDate": "2020-04-20T09:53:08Z", "type": "commit"}, {"oid": "a322017a039928c29edce071f799e5e6addcd4ea", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/a322017a039928c29edce071f799e5e6addcd4ea", "message": "Clean md", "committedDate": "2020-04-20T09:53:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg5NzgzNw==", "url": "https://github.com/telefonicaid/fiware-cygnus/pull/1860#discussion_r412897837", "bodyText": "All new files should include the standard Cygnus license header\n(General comment, it applies to all the new files addd in this PR)", "author": "fgalan", "createdAt": "2020-04-22T11:25:27Z", "path": "cygnus-arcgis/src/main/java/com/telefonica/iot/cygnus/backends/arcgis/baselogger/BaseLogger.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/**", "originalCommit": "a322017a039928c29edce071f799e5e6addcd4ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU5ODg1Nw==", "url": "https://github.com/telefonicaid/fiware-cygnus/pull/1860#discussion_r415598857", "bodyText": "Done c8d4419", "author": "pmo-sdr", "createdAt": "2020-04-27T08:05:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg5NzgzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcyMjgxMA==", "url": "https://github.com/telefonicaid/fiware-cygnus/pull/1860#discussion_r413722810", "bodyText": "please remove comments.", "author": "IvanHdzC", "createdAt": "2020-04-23T11:05:22Z", "path": "cygnus-arcgis/src/main/java/com/telefonica/iot/cygnus/sinks/NGSIArcgisFeatureTableSink.java", "diffHunk": "@@ -0,0 +1,789 @@\n+/**\n+ * Copyright 2014-2017 Telefonica Investigaci\u00f3n y Desarrollo, S.A.U\n+ *\n+ * This file is part of fiware-cygnus (FIWARE project).\n+ *\n+ * fiware-cygnus is free software: you can redistribute it and/or modify it under the terms of the GNU Affero\n+ * General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your\n+ * option) any later version.\n+ * fiware-cygnus is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the\n+ * implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n+ * for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License along with fiware-cygnus. If not, see\n+ * http://www.gnu.org/licenses/.\n+ *\n+ * For those usages not covered by the GNU Affero General Public License please contact with iot_support at tid dot es\n+ */\n+\n+package com.telefonica.iot.cygnus.sinks;\n+\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.commons.lang.exception.ExceptionUtils;\n+import org.apache.flume.Context;\n+import org.apache.flume.EventDeliveryException;\n+import org.json.JSONException;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Feature;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Point;\n+import com.telefonica.iot.cygnus.backends.arcgis.restutils.ArcgisFeatureTable;\n+import com.telefonica.iot.cygnus.backends.arcgis.restutils.NGSIArcgisFeatureTable;\n+import com.telefonica.iot.cygnus.containers.NotifyContextRequest.ContextAttribute;\n+import com.telefonica.iot.cygnus.containers.NotifyContextRequest.ContextElement;\n+import com.telefonica.iot.cygnus.errors.CygnusBadConfiguration;\n+import com.telefonica.iot.cygnus.errors.CygnusBadContextData;\n+import com.telefonica.iot.cygnus.errors.CygnusCappingError;\n+import com.telefonica.iot.cygnus.errors.CygnusExpiratingError;\n+import com.telefonica.iot.cygnus.errors.CygnusPersistenceError;\n+import com.telefonica.iot.cygnus.errors.CygnusRuntimeError;\n+import com.telefonica.iot.cygnus.interceptors.NGSIEvent;\n+import com.telefonica.iot.cygnus.log.CygnusLogger;\n+import com.telefonica.iot.cygnus.utils.NGSIConstants;\n+\n+import jodd.util.URLDecoder;\n+\n+/**\n+ *\n+ * @author dmartinez\n+ * \n+ *         Detailed documentation can be found at:\n+ *         https://github.com/telefonicaid/fiware-cygnus/blob/master/doc/flume_extensions_catalogue/ngsi_arcgis_sink.md\n+ */\n+public class NGSIArcgisFeatureTableSink extends NGSISink {\n+\n+    private static final String DEFAULT_ARCGIS_SERVICE_URL = \"localhost\";\n+    private static final String DEFAULT_GETTOKEN_URL = \"localhost\";\n+    private static final String DEFAULT_USER_NAME = \"root\";\n+    private static final String DEFAULT_PASSWORD = \"\";\n+    private static final int DEFAULT_MAX_BATCH_SIZE = 10;\n+    private static final int DEFAULT_BATCH_TIMEOUT_SECS = 60;\n+    private static final String ARCGIS_INSTANCE_NAME = \"arcgis\";\n+\n+    private static final CygnusLogger LOGGER = new CygnusLogger(NGSIArcgisFeatureTableSink.class);\n+    private String arcgisServicesUrl;\n+    private String getTokenUrl;\n+    private String userName;\n+    private String password;\n+    private int maxBatchSize;\n+    private long timeoutSecs;\n+    private static volatile Map<String, NGSIArcgisFeatureTable> arcgisPersistenceBackend;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public NGSIArcgisFeatureTableSink() {\n+        super();\n+    } // NGSIArcgisFeatureTableSink\n+\n+    /**\n+     * Gets the Argis services url. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The services url\n+     */\n+    protected String getrAcgisServicesUrl() {\n+        return arcgisServicesUrl;\n+    } // getrAcgisServicesUrl\n+\n+    /**\n+     * Gets getToken's service url.\n+     * \n+     * @return\n+     */\n+    public String getGetTokenUrl() {\n+        return getTokenUrl;\n+    }\n+\n+    /**\n+     * Sets getToken service url.\n+     * \n+     * @param getTokenUrl\n+     */\n+    public void setGetTokenUrl(String getTokenUrl) {\n+        this.getTokenUrl = getTokenUrl;\n+    }\n+\n+    /**\n+     * Gets the username. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The username\n+     */\n+    protected String getUsername() {\n+        return userName;\n+    } // getUsername\n+\n+    /**\n+     * Gets the password. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The password\n+     */\n+    protected String getPassword() {\n+        return password;\n+    } // getPassword\n+\n+    /**\n+     * \n+     */\n+    protected int featuresBatched() {\n+        int total = 0;\n+        for (Map.Entry<String, NGSIArcgisFeatureTable> entry : arcgisPersistenceBackend.entrySet()) {\n+            NGSIArcgisFeatureTable table = entry.getValue();\n+            if (table != null) {\n+                total += table.featuresBatched();\n+            }\n+        }\n+\n+        return total;\n+    }\n+\n+    /**\n+     * Returns the persistence backend. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The persistence backend\n+     * @throws CygnusRuntimeError\n+     */\n+    protected ArcgisFeatureTable getPersistenceBackend(String featureServiceUrl) throws CygnusRuntimeError {\n+\n+        if (arcgisPersistenceBackend.containsKey(featureServiceUrl)) {\n+            return arcgisPersistenceBackend.get(featureServiceUrl);\n+        } else {\n+            LOGGER.debug(\"Creating new persistenceBackend for Feature table: \" + featureServiceUrl);\n+            LOGGER.debug(\"Token url: \" + getGetTokenUrl());\n+            LOGGER.debug(\"User name: \" + getUsername());\n+            LOGGER.debug(\"Passwd: \" + getPassword());\n+            try {\n+                NGSIArcgisFeatureTable newTable = new NGSIArcgisFeatureTable(featureServiceUrl, getUsername(),\n+                        getPassword(), getGetTokenUrl(), timeoutSecs, LOGGER);\n+                newTable.setBatchAction(ArcgisFeatureTable.ADD_UPDATE_ACTION);\n+                newTable.setBatchSize(maxBatchSize);\n+\n+                if (newTable.hasError()) {\n+                    throw new CygnusRuntimeError(\"[\" + this.getName() + \"Error creating Persistence backend: \"\n+                            + newTable.getErrorCode() + \" - \" + newTable.getErrorDesc());\n+                } else {\n+                    arcgisPersistenceBackend.put(featureServiceUrl, newTable);\n+                    return newTable;\n+                }\n+            } catch (Throwable e) {\n+                String stackTrace = ExceptionUtils.getFullStackTrace(e);\n+                LOGGER.debug(stackTrace);\n+                throw new CygnusRuntimeError(\"Error creating new persistence Backend. \", e.getClass().getName(),\n+                        e.getMessage());\n+            }\n+        }\n+    } // getPersistenceBackend\n+\n+    /**\n+     * Sets the persistence backend. It is protected due to it is only required for testing purposes.\n+     * \n+     * @param persistenceBackend\n+     */\n+    protected void setPersistenceBackend(String featureServiceUrl, NGSIArcgisFeatureTable persistenceBackend) {\n+        arcgisPersistenceBackend.put(featureServiceUrl, persistenceBackend);\n+    } // setPersistenceBackend\n+\n+    @Override\n+    public void configure(Context context) {\n+        arcgisServicesUrl = context.getString(\"arcgis_service_url\", DEFAULT_ARCGIS_SERVICE_URL);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_service_url=\" + arcgisServicesUrl + \")\");\n+\n+        getTokenUrl = context.getString(\"arcgis_gettoken_url\", DEFAULT_GETTOKEN_URL);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_fearcgis_gettoken_urlature_table_url=\"\n+                + getTokenUrl + \")\");\n+\n+        userName = context.getString(\"arcgis_username\", DEFAULT_USER_NAME);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_username=\" + userName + \")\");\n+        // FIXME: Password should be read encrypted and decoded here\n+        password = context.getString(\"arcgis_password\", DEFAULT_PASSWORD);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_password=\" + password + \")\");\n+\n+        maxBatchSize = context.getInteger(\"arcgis_maxBatchSize\", DEFAULT_MAX_BATCH_SIZE);\n+        if (maxBatchSize <= 0 || maxBatchSize > 65535) {\n+            invalidConfiguration = true;\n+            LOGGER.error(\"[\" + this.getName() + \"] Invalid configuration (arcgis_maxBatchSize=\" + maxBatchSize + \") \"\n+                    + \"must be an integer between 1 and 65535\");\n+        } else {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_maxBatchSize=\" + maxBatchSize + \")\");\n+        }\n+\n+        timeoutSecs = context.getInteger(\"arcgis_timeoutSecs\", DEFAULT_BATCH_TIMEOUT_SECS);\n+        if (timeoutSecs <= 0 || timeoutSecs > 65535) {\n+            invalidConfiguration = true;\n+            LOGGER.error(\"[\" + this.getName() + \"] Invalid configuration (arcgis_timeoutSecs=\" + timeoutSecs + \") \"\n+                    + \"must be an integer between 1 and 65535\");\n+        } else {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_timeoutSecs=\" + maxBatchSize + \")\");\n+        }\n+\n+        super.configure(context);\n+    } // configure\n+\n+    @Override\n+    public void start() {\n+        try {\n+            createPersistenceBackend();\n+            LOGGER.debug(\"[\" + this.getName() + \"] Arcgis persistence backend created\");\n+        } catch (Exception e) {\n+            LOGGER.error(\"Error while creating the Arcgis persistence backend. Details=\" + e.getMessage());\n+        } // try catch\n+\n+        super.start();\n+    } // start\n+\n+    @Override\n+    public void stop() {\n+        super.stop();\n+        if (arcgisPersistenceBackend != null) {\n+            for (Map.Entry<String, NGSIArcgisFeatureTable> backend : arcgisPersistenceBackend.entrySet()) {\n+                backend.getValue().flushBatch();\n+            }\n+            arcgisPersistenceBackend.clear();\n+        }\n+    } // stop\n+\n+    /**\n+     * Initialices a lazy singleton to share among instances on JVM.\n+     */\n+    private static synchronized void createPersistenceBackend() {\n+        if (arcgisPersistenceBackend == null) {\n+            arcgisPersistenceBackend = new ConcurrentHashMap<String, NGSIArcgisFeatureTable>();\n+        }\n+    }\n+\n+    @Override\n+    void persistBatch(NGSIBatch batch)\n+            throws CygnusBadConfiguration, CygnusPersistenceError, CygnusRuntimeError, CygnusBadContextData {\n+        if (batch == null) {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Null batch, nothing to do\");\n+            return;\n+        } // if\n+\n+        try {\n+            // Iterate on the destinations\n+            batch.startIterator();\n+\n+            while (batch.hasNext()) {\n+                String destination = batch.getNextDestination();\n+                LOGGER.debug(\n+                        \"[\" + this.getName() + \"] Processing sub-batch regarding the \" + destination + \" destination\");\n+\n+                // Get the events within the current sub-batch\n+                ArrayList<NGSIEvent> events = batch.getNextEvents();\n+\n+                // Get an aggregator for this destination and initialize it\n+                NGSIArcgisAggregator aggregator = new NGSIArcgisAggregator(getrAcgisServicesUrl(), enableNameMappings);\n+                // aggregator.setService(events.get(0).getServiceForNaming(enableNameMappings));\n+                // aggregator.setServicePathForData(events.get(0).getServicePathForData());\n+                // aggregator.setServicePathForNaming(events.get(0).getServicePathForNaming(enableGrouping,\n+                // enableNameMappings));\n+                // aggregator.setEntityForNaming(events.get(0).getEntityForNaming(enableGrouping, enableNameMappings,\n+                // enableEncoding));\n+                // aggregator.setEntityType(events.get(0).getEntityTypeForNaming(enableGrouping, enableNameMappings));\n+                // aggregator.setAttribute(events.get(0).getAttributeForNaming(enableNameMappings));\n+                // aggregator.setDbName(buildDbName(aggregator.getService()));\n+                // aggregator.setTableName(buildTableName(aggregator.getServicePathForNaming(),\n+                // aggregator.getEntityForNaming(), aggregator.getEntityType(), aggregator.getAttribute()));\n+                // aggregator.setAttrNativeTypes(attrNativeTypes);\n+                // aggregator.setAttrMetadataStore(false);", "originalCommit": "a322017a039928c29edce071f799e5e6addcd4ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMzMTIzOQ==", "url": "https://github.com/telefonicaid/fiware-cygnus/pull/1860#discussion_r414331239", "bodyText": "Done.", "author": "pmo-sdr", "createdAt": "2020-04-24T06:38:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcyMjgxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQ1NzY5Mw==", "url": "https://github.com/telefonicaid/fiware-cygnus/pull/1860#discussion_r414457693", "bodyText": "Fixed in e531743", "author": "IvanHdzC", "createdAt": "2020-04-24T10:08:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcyMjgxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcyMzkyNg==", "url": "https://github.com/telefonicaid/fiware-cygnus/pull/1860#discussion_r413723926", "bodyText": "Is this call necessary?", "author": "IvanHdzC", "createdAt": "2020-04-23T11:07:10Z", "path": "cygnus-arcgis/src/main/java/com/telefonica/iot/cygnus/sinks/NGSIArcgisFeatureTableSink.java", "diffHunk": "@@ -0,0 +1,789 @@\n+/**\n+ * Copyright 2014-2017 Telefonica Investigaci\u00f3n y Desarrollo, S.A.U\n+ *\n+ * This file is part of fiware-cygnus (FIWARE project).\n+ *\n+ * fiware-cygnus is free software: you can redistribute it and/or modify it under the terms of the GNU Affero\n+ * General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your\n+ * option) any later version.\n+ * fiware-cygnus is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the\n+ * implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n+ * for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License along with fiware-cygnus. If not, see\n+ * http://www.gnu.org/licenses/.\n+ *\n+ * For those usages not covered by the GNU Affero General Public License please contact with iot_support at tid dot es\n+ */\n+\n+package com.telefonica.iot.cygnus.sinks;\n+\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.commons.lang.exception.ExceptionUtils;\n+import org.apache.flume.Context;\n+import org.apache.flume.EventDeliveryException;\n+import org.json.JSONException;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Feature;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Point;\n+import com.telefonica.iot.cygnus.backends.arcgis.restutils.ArcgisFeatureTable;\n+import com.telefonica.iot.cygnus.backends.arcgis.restutils.NGSIArcgisFeatureTable;\n+import com.telefonica.iot.cygnus.containers.NotifyContextRequest.ContextAttribute;\n+import com.telefonica.iot.cygnus.containers.NotifyContextRequest.ContextElement;\n+import com.telefonica.iot.cygnus.errors.CygnusBadConfiguration;\n+import com.telefonica.iot.cygnus.errors.CygnusBadContextData;\n+import com.telefonica.iot.cygnus.errors.CygnusCappingError;\n+import com.telefonica.iot.cygnus.errors.CygnusExpiratingError;\n+import com.telefonica.iot.cygnus.errors.CygnusPersistenceError;\n+import com.telefonica.iot.cygnus.errors.CygnusRuntimeError;\n+import com.telefonica.iot.cygnus.interceptors.NGSIEvent;\n+import com.telefonica.iot.cygnus.log.CygnusLogger;\n+import com.telefonica.iot.cygnus.utils.NGSIConstants;\n+\n+import jodd.util.URLDecoder;\n+\n+/**\n+ *\n+ * @author dmartinez\n+ * \n+ *         Detailed documentation can be found at:\n+ *         https://github.com/telefonicaid/fiware-cygnus/blob/master/doc/flume_extensions_catalogue/ngsi_arcgis_sink.md\n+ */\n+public class NGSIArcgisFeatureTableSink extends NGSISink {\n+\n+    private static final String DEFAULT_ARCGIS_SERVICE_URL = \"localhost\";\n+    private static final String DEFAULT_GETTOKEN_URL = \"localhost\";\n+    private static final String DEFAULT_USER_NAME = \"root\";\n+    private static final String DEFAULT_PASSWORD = \"\";\n+    private static final int DEFAULT_MAX_BATCH_SIZE = 10;\n+    private static final int DEFAULT_BATCH_TIMEOUT_SECS = 60;\n+    private static final String ARCGIS_INSTANCE_NAME = \"arcgis\";\n+\n+    private static final CygnusLogger LOGGER = new CygnusLogger(NGSIArcgisFeatureTableSink.class);\n+    private String arcgisServicesUrl;\n+    private String getTokenUrl;\n+    private String userName;\n+    private String password;\n+    private int maxBatchSize;\n+    private long timeoutSecs;\n+    private static volatile Map<String, NGSIArcgisFeatureTable> arcgisPersistenceBackend;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public NGSIArcgisFeatureTableSink() {\n+        super();\n+    } // NGSIArcgisFeatureTableSink\n+\n+    /**\n+     * Gets the Argis services url. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The services url\n+     */\n+    protected String getrAcgisServicesUrl() {\n+        return arcgisServicesUrl;\n+    } // getrAcgisServicesUrl\n+\n+    /**\n+     * Gets getToken's service url.\n+     * \n+     * @return\n+     */\n+    public String getGetTokenUrl() {\n+        return getTokenUrl;\n+    }\n+\n+    /**\n+     * Sets getToken service url.\n+     * \n+     * @param getTokenUrl\n+     */\n+    public void setGetTokenUrl(String getTokenUrl) {\n+        this.getTokenUrl = getTokenUrl;\n+    }\n+\n+    /**\n+     * Gets the username. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The username\n+     */\n+    protected String getUsername() {\n+        return userName;\n+    } // getUsername\n+\n+    /**\n+     * Gets the password. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The password\n+     */\n+    protected String getPassword() {\n+        return password;\n+    } // getPassword\n+\n+    /**\n+     * \n+     */\n+    protected int featuresBatched() {\n+        int total = 0;\n+        for (Map.Entry<String, NGSIArcgisFeatureTable> entry : arcgisPersistenceBackend.entrySet()) {\n+            NGSIArcgisFeatureTable table = entry.getValue();\n+            if (table != null) {\n+                total += table.featuresBatched();\n+            }\n+        }\n+\n+        return total;\n+    }\n+\n+    /**\n+     * Returns the persistence backend. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The persistence backend\n+     * @throws CygnusRuntimeError\n+     */\n+    protected ArcgisFeatureTable getPersistenceBackend(String featureServiceUrl) throws CygnusRuntimeError {\n+\n+        if (arcgisPersistenceBackend.containsKey(featureServiceUrl)) {\n+            return arcgisPersistenceBackend.get(featureServiceUrl);\n+        } else {\n+            LOGGER.debug(\"Creating new persistenceBackend for Feature table: \" + featureServiceUrl);\n+            LOGGER.debug(\"Token url: \" + getGetTokenUrl());\n+            LOGGER.debug(\"User name: \" + getUsername());\n+            LOGGER.debug(\"Passwd: \" + getPassword());\n+            try {\n+                NGSIArcgisFeatureTable newTable = new NGSIArcgisFeatureTable(featureServiceUrl, getUsername(),\n+                        getPassword(), getGetTokenUrl(), timeoutSecs, LOGGER);\n+                newTable.setBatchAction(ArcgisFeatureTable.ADD_UPDATE_ACTION);\n+                newTable.setBatchSize(maxBatchSize);\n+\n+                if (newTable.hasError()) {\n+                    throw new CygnusRuntimeError(\"[\" + this.getName() + \"Error creating Persistence backend: \"\n+                            + newTable.getErrorCode() + \" - \" + newTable.getErrorDesc());\n+                } else {\n+                    arcgisPersistenceBackend.put(featureServiceUrl, newTable);\n+                    return newTable;\n+                }\n+            } catch (Throwable e) {\n+                String stackTrace = ExceptionUtils.getFullStackTrace(e);\n+                LOGGER.debug(stackTrace);\n+                throw new CygnusRuntimeError(\"Error creating new persistence Backend. \", e.getClass().getName(),\n+                        e.getMessage());\n+            }\n+        }\n+    } // getPersistenceBackend\n+\n+    /**\n+     * Sets the persistence backend. It is protected due to it is only required for testing purposes.\n+     * \n+     * @param persistenceBackend\n+     */\n+    protected void setPersistenceBackend(String featureServiceUrl, NGSIArcgisFeatureTable persistenceBackend) {\n+        arcgisPersistenceBackend.put(featureServiceUrl, persistenceBackend);\n+    } // setPersistenceBackend\n+\n+    @Override\n+    public void configure(Context context) {\n+        arcgisServicesUrl = context.getString(\"arcgis_service_url\", DEFAULT_ARCGIS_SERVICE_URL);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_service_url=\" + arcgisServicesUrl + \")\");\n+\n+        getTokenUrl = context.getString(\"arcgis_gettoken_url\", DEFAULT_GETTOKEN_URL);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_fearcgis_gettoken_urlature_table_url=\"\n+                + getTokenUrl + \")\");\n+\n+        userName = context.getString(\"arcgis_username\", DEFAULT_USER_NAME);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_username=\" + userName + \")\");\n+        // FIXME: Password should be read encrypted and decoded here\n+        password = context.getString(\"arcgis_password\", DEFAULT_PASSWORD);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_password=\" + password + \")\");\n+\n+        maxBatchSize = context.getInteger(\"arcgis_maxBatchSize\", DEFAULT_MAX_BATCH_SIZE);\n+        if (maxBatchSize <= 0 || maxBatchSize > 65535) {\n+            invalidConfiguration = true;\n+            LOGGER.error(\"[\" + this.getName() + \"] Invalid configuration (arcgis_maxBatchSize=\" + maxBatchSize + \") \"\n+                    + \"must be an integer between 1 and 65535\");\n+        } else {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_maxBatchSize=\" + maxBatchSize + \")\");\n+        }\n+\n+        timeoutSecs = context.getInteger(\"arcgis_timeoutSecs\", DEFAULT_BATCH_TIMEOUT_SECS);\n+        if (timeoutSecs <= 0 || timeoutSecs > 65535) {\n+            invalidConfiguration = true;\n+            LOGGER.error(\"[\" + this.getName() + \"] Invalid configuration (arcgis_timeoutSecs=\" + timeoutSecs + \") \"\n+                    + \"must be an integer between 1 and 65535\");\n+        } else {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_timeoutSecs=\" + maxBatchSize + \")\");\n+        }\n+\n+        super.configure(context);\n+    } // configure\n+\n+    @Override\n+    public void start() {\n+        try {\n+            createPersistenceBackend();\n+            LOGGER.debug(\"[\" + this.getName() + \"] Arcgis persistence backend created\");\n+        } catch (Exception e) {\n+            LOGGER.error(\"Error while creating the Arcgis persistence backend. Details=\" + e.getMessage());\n+        } // try catch\n+\n+        super.start();\n+    } // start\n+\n+    @Override\n+    public void stop() {\n+        super.stop();\n+        if (arcgisPersistenceBackend != null) {\n+            for (Map.Entry<String, NGSIArcgisFeatureTable> backend : arcgisPersistenceBackend.entrySet()) {\n+                backend.getValue().flushBatch();\n+            }\n+            arcgisPersistenceBackend.clear();\n+        }\n+    } // stop\n+\n+    /**\n+     * Initialices a lazy singleton to share among instances on JVM.\n+     */\n+    private static synchronized void createPersistenceBackend() {\n+        if (arcgisPersistenceBackend == null) {\n+            arcgisPersistenceBackend = new ConcurrentHashMap<String, NGSIArcgisFeatureTable>();\n+        }\n+    }\n+\n+    @Override\n+    void persistBatch(NGSIBatch batch)\n+            throws CygnusBadConfiguration, CygnusPersistenceError, CygnusRuntimeError, CygnusBadContextData {\n+        if (batch == null) {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Null batch, nothing to do\");\n+            return;\n+        } // if\n+\n+        try {\n+            // Iterate on the destinations\n+            batch.startIterator();\n+\n+            while (batch.hasNext()) {\n+                String destination = batch.getNextDestination();\n+                LOGGER.debug(\n+                        \"[\" + this.getName() + \"] Processing sub-batch regarding the \" + destination + \" destination\");\n+\n+                // Get the events within the current sub-batch\n+                ArrayList<NGSIEvent> events = batch.getNextEvents();\n+\n+                // Get an aggregator for this destination and initialize it\n+                NGSIArcgisAggregator aggregator = new NGSIArcgisAggregator(getrAcgisServicesUrl(), enableNameMappings);\n+                // aggregator.setService(events.get(0).getServiceForNaming(enableNameMappings));\n+                // aggregator.setServicePathForData(events.get(0).getServicePathForData());\n+                // aggregator.setServicePathForNaming(events.get(0).getServicePathForNaming(enableGrouping,\n+                // enableNameMappings));\n+                // aggregator.setEntityForNaming(events.get(0).getEntityForNaming(enableGrouping, enableNameMappings,\n+                // enableEncoding));\n+                // aggregator.setEntityType(events.get(0).getEntityTypeForNaming(enableGrouping, enableNameMappings));\n+                // aggregator.setAttribute(events.get(0).getAttributeForNaming(enableNameMappings));\n+                // aggregator.setDbName(buildDbName(aggregator.getService()));\n+                // aggregator.setTableName(buildTableName(aggregator.getServicePathForNaming(),\n+                // aggregator.getEntityForNaming(), aggregator.getEntityType(), aggregator.getAttribute()));\n+                // aggregator.setAttrNativeTypes(attrNativeTypes);\n+                // aggregator.setAttrMetadataStore(false);\n+                aggregator.initialize(events.get(0));", "originalCommit": "a322017a039928c29edce071f799e5e6addcd4ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjUzOTI2Mw==", "url": "https://github.com/telefonicaid/fiware-cygnus/pull/1860#discussion_r416539263", "bodyText": "Removed\nStdri@1941e81", "author": "pmo-sdr", "createdAt": "2020-04-28T11:31:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcyMzkyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcyNDczMQ==", "url": "https://github.com/telefonicaid/fiware-cygnus/pull/1860#discussion_r413724731", "bodyText": "Is this necessary? The constructor that matches with that signature seems to be empty.", "author": "IvanHdzC", "createdAt": "2020-04-23T11:08:26Z", "path": "cygnus-arcgis/src/main/java/com/telefonica/iot/cygnus/sinks/NGSIArcgisFeatureTableSink.java", "diffHunk": "@@ -0,0 +1,789 @@\n+/**\n+ * Copyright 2014-2017 Telefonica Investigaci\u00f3n y Desarrollo, S.A.U\n+ *\n+ * This file is part of fiware-cygnus (FIWARE project).\n+ *\n+ * fiware-cygnus is free software: you can redistribute it and/or modify it under the terms of the GNU Affero\n+ * General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your\n+ * option) any later version.\n+ * fiware-cygnus is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the\n+ * implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n+ * for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License along with fiware-cygnus. If not, see\n+ * http://www.gnu.org/licenses/.\n+ *\n+ * For those usages not covered by the GNU Affero General Public License please contact with iot_support at tid dot es\n+ */\n+\n+package com.telefonica.iot.cygnus.sinks;\n+\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.commons.lang.exception.ExceptionUtils;\n+import org.apache.flume.Context;\n+import org.apache.flume.EventDeliveryException;\n+import org.json.JSONException;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Feature;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Point;\n+import com.telefonica.iot.cygnus.backends.arcgis.restutils.ArcgisFeatureTable;\n+import com.telefonica.iot.cygnus.backends.arcgis.restutils.NGSIArcgisFeatureTable;\n+import com.telefonica.iot.cygnus.containers.NotifyContextRequest.ContextAttribute;\n+import com.telefonica.iot.cygnus.containers.NotifyContextRequest.ContextElement;\n+import com.telefonica.iot.cygnus.errors.CygnusBadConfiguration;\n+import com.telefonica.iot.cygnus.errors.CygnusBadContextData;\n+import com.telefonica.iot.cygnus.errors.CygnusCappingError;\n+import com.telefonica.iot.cygnus.errors.CygnusExpiratingError;\n+import com.telefonica.iot.cygnus.errors.CygnusPersistenceError;\n+import com.telefonica.iot.cygnus.errors.CygnusRuntimeError;\n+import com.telefonica.iot.cygnus.interceptors.NGSIEvent;\n+import com.telefonica.iot.cygnus.log.CygnusLogger;\n+import com.telefonica.iot.cygnus.utils.NGSIConstants;\n+\n+import jodd.util.URLDecoder;\n+\n+/**\n+ *\n+ * @author dmartinez\n+ * \n+ *         Detailed documentation can be found at:\n+ *         https://github.com/telefonicaid/fiware-cygnus/blob/master/doc/flume_extensions_catalogue/ngsi_arcgis_sink.md\n+ */\n+public class NGSIArcgisFeatureTableSink extends NGSISink {\n+\n+    private static final String DEFAULT_ARCGIS_SERVICE_URL = \"localhost\";\n+    private static final String DEFAULT_GETTOKEN_URL = \"localhost\";\n+    private static final String DEFAULT_USER_NAME = \"root\";\n+    private static final String DEFAULT_PASSWORD = \"\";\n+    private static final int DEFAULT_MAX_BATCH_SIZE = 10;\n+    private static final int DEFAULT_BATCH_TIMEOUT_SECS = 60;\n+    private static final String ARCGIS_INSTANCE_NAME = \"arcgis\";\n+\n+    private static final CygnusLogger LOGGER = new CygnusLogger(NGSIArcgisFeatureTableSink.class);\n+    private String arcgisServicesUrl;\n+    private String getTokenUrl;\n+    private String userName;\n+    private String password;\n+    private int maxBatchSize;\n+    private long timeoutSecs;\n+    private static volatile Map<String, NGSIArcgisFeatureTable> arcgisPersistenceBackend;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public NGSIArcgisFeatureTableSink() {\n+        super();\n+    } // NGSIArcgisFeatureTableSink\n+\n+    /**\n+     * Gets the Argis services url. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The services url\n+     */\n+    protected String getrAcgisServicesUrl() {\n+        return arcgisServicesUrl;\n+    } // getrAcgisServicesUrl\n+\n+    /**\n+     * Gets getToken's service url.\n+     * \n+     * @return\n+     */\n+    public String getGetTokenUrl() {\n+        return getTokenUrl;\n+    }\n+\n+    /**\n+     * Sets getToken service url.\n+     * \n+     * @param getTokenUrl\n+     */\n+    public void setGetTokenUrl(String getTokenUrl) {\n+        this.getTokenUrl = getTokenUrl;\n+    }\n+\n+    /**\n+     * Gets the username. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The username\n+     */\n+    protected String getUsername() {\n+        return userName;\n+    } // getUsername\n+\n+    /**\n+     * Gets the password. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The password\n+     */\n+    protected String getPassword() {\n+        return password;\n+    } // getPassword\n+\n+    /**\n+     * \n+     */\n+    protected int featuresBatched() {\n+        int total = 0;\n+        for (Map.Entry<String, NGSIArcgisFeatureTable> entry : arcgisPersistenceBackend.entrySet()) {\n+            NGSIArcgisFeatureTable table = entry.getValue();\n+            if (table != null) {\n+                total += table.featuresBatched();\n+            }\n+        }\n+\n+        return total;\n+    }\n+\n+    /**\n+     * Returns the persistence backend. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The persistence backend\n+     * @throws CygnusRuntimeError\n+     */\n+    protected ArcgisFeatureTable getPersistenceBackend(String featureServiceUrl) throws CygnusRuntimeError {\n+\n+        if (arcgisPersistenceBackend.containsKey(featureServiceUrl)) {\n+            return arcgisPersistenceBackend.get(featureServiceUrl);\n+        } else {\n+            LOGGER.debug(\"Creating new persistenceBackend for Feature table: \" + featureServiceUrl);\n+            LOGGER.debug(\"Token url: \" + getGetTokenUrl());\n+            LOGGER.debug(\"User name: \" + getUsername());\n+            LOGGER.debug(\"Passwd: \" + getPassword());\n+            try {\n+                NGSIArcgisFeatureTable newTable = new NGSIArcgisFeatureTable(featureServiceUrl, getUsername(),\n+                        getPassword(), getGetTokenUrl(), timeoutSecs, LOGGER);\n+                newTable.setBatchAction(ArcgisFeatureTable.ADD_UPDATE_ACTION);\n+                newTable.setBatchSize(maxBatchSize);\n+\n+                if (newTable.hasError()) {\n+                    throw new CygnusRuntimeError(\"[\" + this.getName() + \"Error creating Persistence backend: \"\n+                            + newTable.getErrorCode() + \" - \" + newTable.getErrorDesc());\n+                } else {\n+                    arcgisPersistenceBackend.put(featureServiceUrl, newTable);\n+                    return newTable;\n+                }\n+            } catch (Throwable e) {\n+                String stackTrace = ExceptionUtils.getFullStackTrace(e);\n+                LOGGER.debug(stackTrace);\n+                throw new CygnusRuntimeError(\"Error creating new persistence Backend. \", e.getClass().getName(),\n+                        e.getMessage());\n+            }\n+        }\n+    } // getPersistenceBackend\n+\n+    /**\n+     * Sets the persistence backend. It is protected due to it is only required for testing purposes.\n+     * \n+     * @param persistenceBackend\n+     */\n+    protected void setPersistenceBackend(String featureServiceUrl, NGSIArcgisFeatureTable persistenceBackend) {\n+        arcgisPersistenceBackend.put(featureServiceUrl, persistenceBackend);\n+    } // setPersistenceBackend\n+\n+    @Override\n+    public void configure(Context context) {\n+        arcgisServicesUrl = context.getString(\"arcgis_service_url\", DEFAULT_ARCGIS_SERVICE_URL);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_service_url=\" + arcgisServicesUrl + \")\");\n+\n+        getTokenUrl = context.getString(\"arcgis_gettoken_url\", DEFAULT_GETTOKEN_URL);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_fearcgis_gettoken_urlature_table_url=\"\n+                + getTokenUrl + \")\");\n+\n+        userName = context.getString(\"arcgis_username\", DEFAULT_USER_NAME);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_username=\" + userName + \")\");\n+        // FIXME: Password should be read encrypted and decoded here\n+        password = context.getString(\"arcgis_password\", DEFAULT_PASSWORD);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_password=\" + password + \")\");\n+\n+        maxBatchSize = context.getInteger(\"arcgis_maxBatchSize\", DEFAULT_MAX_BATCH_SIZE);\n+        if (maxBatchSize <= 0 || maxBatchSize > 65535) {\n+            invalidConfiguration = true;\n+            LOGGER.error(\"[\" + this.getName() + \"] Invalid configuration (arcgis_maxBatchSize=\" + maxBatchSize + \") \"\n+                    + \"must be an integer between 1 and 65535\");\n+        } else {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_maxBatchSize=\" + maxBatchSize + \")\");\n+        }\n+\n+        timeoutSecs = context.getInteger(\"arcgis_timeoutSecs\", DEFAULT_BATCH_TIMEOUT_SECS);\n+        if (timeoutSecs <= 0 || timeoutSecs > 65535) {\n+            invalidConfiguration = true;\n+            LOGGER.error(\"[\" + this.getName() + \"] Invalid configuration (arcgis_timeoutSecs=\" + timeoutSecs + \") \"\n+                    + \"must be an integer between 1 and 65535\");\n+        } else {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_timeoutSecs=\" + maxBatchSize + \")\");\n+        }\n+\n+        super.configure(context);\n+    } // configure\n+\n+    @Override\n+    public void start() {\n+        try {\n+            createPersistenceBackend();\n+            LOGGER.debug(\"[\" + this.getName() + \"] Arcgis persistence backend created\");\n+        } catch (Exception e) {\n+            LOGGER.error(\"Error while creating the Arcgis persistence backend. Details=\" + e.getMessage());\n+        } // try catch\n+\n+        super.start();\n+    } // start\n+\n+    @Override\n+    public void stop() {\n+        super.stop();\n+        if (arcgisPersistenceBackend != null) {\n+            for (Map.Entry<String, NGSIArcgisFeatureTable> backend : arcgisPersistenceBackend.entrySet()) {\n+                backend.getValue().flushBatch();\n+            }\n+            arcgisPersistenceBackend.clear();\n+        }\n+    } // stop\n+\n+    /**\n+     * Initialices a lazy singleton to share among instances on JVM.\n+     */\n+    private static synchronized void createPersistenceBackend() {\n+        if (arcgisPersistenceBackend == null) {\n+            arcgisPersistenceBackend = new ConcurrentHashMap<String, NGSIArcgisFeatureTable>();\n+        }\n+    }\n+\n+    @Override\n+    void persistBatch(NGSIBatch batch)\n+            throws CygnusBadConfiguration, CygnusPersistenceError, CygnusRuntimeError, CygnusBadContextData {\n+        if (batch == null) {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Null batch, nothing to do\");\n+            return;\n+        } // if\n+\n+        try {\n+            // Iterate on the destinations\n+            batch.startIterator();\n+\n+            while (batch.hasNext()) {\n+                String destination = batch.getNextDestination();\n+                LOGGER.debug(\n+                        \"[\" + this.getName() + \"] Processing sub-batch regarding the \" + destination + \" destination\");\n+\n+                // Get the events within the current sub-batch\n+                ArrayList<NGSIEvent> events = batch.getNextEvents();\n+\n+                // Get an aggregator for this destination and initialize it\n+                NGSIArcgisAggregator aggregator = new NGSIArcgisAggregator(getrAcgisServicesUrl(), enableNameMappings);\n+                // aggregator.setService(events.get(0).getServiceForNaming(enableNameMappings));\n+                // aggregator.setServicePathForData(events.get(0).getServicePathForData());\n+                // aggregator.setServicePathForNaming(events.get(0).getServicePathForNaming(enableGrouping,\n+                // enableNameMappings));\n+                // aggregator.setEntityForNaming(events.get(0).getEntityForNaming(enableGrouping, enableNameMappings,\n+                // enableEncoding));\n+                // aggregator.setEntityType(events.get(0).getEntityTypeForNaming(enableGrouping, enableNameMappings));\n+                // aggregator.setAttribute(events.get(0).getAttributeForNaming(enableNameMappings));\n+                // aggregator.setDbName(buildDbName(aggregator.getService()));\n+                // aggregator.setTableName(buildTableName(aggregator.getServicePathForNaming(),\n+                // aggregator.getEntityForNaming(), aggregator.getEntityType(), aggregator.getAttribute()));\n+                // aggregator.setAttrNativeTypes(attrNativeTypes);\n+                // aggregator.setAttrMetadataStore(false);\n+                aggregator.initialize(events.get(0));\n+                for (NGSIEvent event : events) {\n+                    aggregator.aggregate(event);\n+                } // for\n+\n+                // Persist the aggregation\n+                persistAggregation(aggregator);\n+                batch.setNextPersisted(true);\n+\n+            } // while\n+        } catch (Exception e) {\n+            LOGGER.error(\"[\" + this.getName() + \"] Error persisting batch, \" + e.getMessage());\n+            throw new CygnusRuntimeError(e.getMessage());\n+        }\n+    } // persistBatch\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see com.telefonica.iot.cygnus.sinks.NGSISink#process()\n+     */\n+    @Override\n+    public Status process() throws EventDeliveryException {\n+        checkTimeouts();\n+        Status status = null;\n+        try {\n+            status = super.process();\n+        } catch (Throwable e) {\n+            LOGGER.error(e.getMessage() + \"Stack trace: \" + Arrays.toString(e.getStackTrace()));\n+        }\n+        return status;\n+    }\n+\n+    /**\n+     * Flush if timeout.\n+     */\n+    protected void checkTimeouts() {\n+        boolean timeoutFound = false;\n+        for (Map.Entry<String, NGSIArcgisFeatureTable> entry : arcgisPersistenceBackend.entrySet()) {\n+            NGSIArcgisFeatureTable table = entry.getValue();\n+            if (table.hasTimeout()) {\n+                timeoutFound = true;\n+                LOGGER.info(\"[\" + this.getName() + \"] Feature table Timeout, flushing batch. \" + entry.getKey());\n+                table.flushBatch();\n+            }\n+        }\n+        if (!timeoutFound) {\n+            LOGGER.debug(\"[\" + this.getName() + \"] No Feature table Timeouts found. Features in batch: \"\n+                    + featuresBatched());\n+        }\n+    }\n+\n+    @Override\n+    public void capRecords(NGSIBatch batch, long maxRecords) throws CygnusCappingError {\n+        // no capping\n+        LOGGER.warn(\"[\" + this.getName() + \"] Skipping capping records, just persisting it.\");\n+        try {\n+            persistBatch(batch);\n+        } catch (CygnusBadConfiguration | CygnusPersistenceError | CygnusRuntimeError | CygnusBadContextData e) {\n+            LOGGER.error(\"[\" + this.getName() + \"] Error capping Records: \" + e);\n+            throw new CygnusCappingError(e.getMessage());\n+        }\n+    } // capRecords\n+\n+    @Override\n+    public void expirateRecords(long expirationTime) throws CygnusExpiratingError {\n+        LOGGER.debug(\"[\" + this.getName() + \"] Expirating records (time=\" + expirationTime + \")\");\n+\n+    } // expirateRecords\n+\n+    /**\n+     * Persist Aggregation.\n+     * \n+     * @param aggregator\n+     * @throws CygnusRuntimeError\n+     */\n+    public void persistAggregation(NGSIArcgisAggregator aggregator) throws CygnusRuntimeError {\n+        try {\n+            List<ArcgisAggregatorDomain> aggregationList = aggregator.getListArcgisAggregatorDomain();\n+            LOGGER.debug(\"[\" + this.getName() + \"] persisting aggregation, \"\n+                    + aggregator.getListArcgisAggregatorDomain().size() + \" features.\");\n+            for (ArcgisAggregatorDomain aggregation : aggregationList) {\n+                String featureTableUrl = aggregation.getFeatureTableUrl();\n+\n+                boolean isNewFeatureTable = !arcgisPersistenceBackend.containsKey(featureTableUrl);\n+                LOGGER.debug(\"[\" + this.getName() + \"] persistAggregation - Feature table: \" + featureTableUrl\n+                        + \" is new: \" + isNewFeatureTable);\n+                ArcgisFeatureTable featureTable = getPersistenceBackend(featureTableUrl);\n+\n+                // If it's a new one, sets uniqueField value\n+                if (isNewFeatureTable) {\n+                    LOGGER.debug(\"[\" + this.getName() + \"] Created new backend for \" + featureTableUrl\n+                            + \" with uniqueField: \" + aggregation.getUniqueField());\n+                    featureTable.setUniqueField(aggregation.getUniqueField());\n+                }\n+\n+                featureTable.addToBatch(aggregation.getFeature());\n+            }\n+        } catch (CygnusRuntimeError e) {\n+            String stackTrace = ExceptionUtils.getFullStackTrace(e);\n+            LOGGER.debug(\" PersistAggregation Error: \" + stackTrace);\n+            throw (e);\n+        } catch (Exception e) {\n+            LOGGER.error(\"[\" + this.getName() + \"] Error persisting batch, \" + e.getClass().getSimpleName() + \" - \"\n+                    + e.getMessage());\n+            throw new CygnusRuntimeError(e.getMessage());\n+        }\n+    } // persistAggregation\n+\n+    /**\n+     * @author dmartinez\n+     *\n+     */\n+    public class NGSIArcgisAggregator {\n+\n+        private List<ArcgisAggregatorDomain> listArcgisAggregatorDomain = new ArrayList<ArcgisAggregatorDomain>();\n+        private boolean enableNameMappings = true;\n+        private String argisServiceUrl = \"\";\n+\n+        private NGSIArcgisAggregator() {\n+        } // ArcgisAggregator\n+\n+        /**\n+         * Constructor.\n+         * \n+         * @param argisServiceUrl\n+         * @param enableNameMappings\n+         */\n+        public NGSIArcgisAggregator(String argisServiceUrl, boolean enableNameMappings) {\n+            this();", "originalCommit": "a322017a039928c29edce071f799e5e6addcd4ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYwNTA4Mw==", "url": "https://github.com/telefonicaid/fiware-cygnus/pull/1860#discussion_r415605083", "bodyText": "It's no empty anymore.\nhttps://github.com/Stdri/fiware-cygnus/blob/c8d4419a2cf00210fcaf968d5ed96375ce2828cd/cygnus-ngsi/src/main/java/com/telefonica/iot/cygnus/sinks/NGSIArcgisFeatureTableSink.java#L407-L411", "author": "pmo-sdr", "createdAt": "2020-04-27T08:14:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcyNDczMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcyNDk4Ng==", "url": "https://github.com/telefonicaid/fiware-cygnus/pull/1860#discussion_r413724986", "bodyText": "It this constructor used?", "author": "IvanHdzC", "createdAt": "2020-04-23T11:08:55Z", "path": "cygnus-arcgis/src/main/java/com/telefonica/iot/cygnus/sinks/NGSIArcgisFeatureTableSink.java", "diffHunk": "@@ -0,0 +1,789 @@\n+/**\n+ * Copyright 2014-2017 Telefonica Investigaci\u00f3n y Desarrollo, S.A.U\n+ *\n+ * This file is part of fiware-cygnus (FIWARE project).\n+ *\n+ * fiware-cygnus is free software: you can redistribute it and/or modify it under the terms of the GNU Affero\n+ * General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your\n+ * option) any later version.\n+ * fiware-cygnus is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the\n+ * implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n+ * for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License along with fiware-cygnus. If not, see\n+ * http://www.gnu.org/licenses/.\n+ *\n+ * For those usages not covered by the GNU Affero General Public License please contact with iot_support at tid dot es\n+ */\n+\n+package com.telefonica.iot.cygnus.sinks;\n+\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.commons.lang.exception.ExceptionUtils;\n+import org.apache.flume.Context;\n+import org.apache.flume.EventDeliveryException;\n+import org.json.JSONException;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Feature;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Point;\n+import com.telefonica.iot.cygnus.backends.arcgis.restutils.ArcgisFeatureTable;\n+import com.telefonica.iot.cygnus.backends.arcgis.restutils.NGSIArcgisFeatureTable;\n+import com.telefonica.iot.cygnus.containers.NotifyContextRequest.ContextAttribute;\n+import com.telefonica.iot.cygnus.containers.NotifyContextRequest.ContextElement;\n+import com.telefonica.iot.cygnus.errors.CygnusBadConfiguration;\n+import com.telefonica.iot.cygnus.errors.CygnusBadContextData;\n+import com.telefonica.iot.cygnus.errors.CygnusCappingError;\n+import com.telefonica.iot.cygnus.errors.CygnusExpiratingError;\n+import com.telefonica.iot.cygnus.errors.CygnusPersistenceError;\n+import com.telefonica.iot.cygnus.errors.CygnusRuntimeError;\n+import com.telefonica.iot.cygnus.interceptors.NGSIEvent;\n+import com.telefonica.iot.cygnus.log.CygnusLogger;\n+import com.telefonica.iot.cygnus.utils.NGSIConstants;\n+\n+import jodd.util.URLDecoder;\n+\n+/**\n+ *\n+ * @author dmartinez\n+ * \n+ *         Detailed documentation can be found at:\n+ *         https://github.com/telefonicaid/fiware-cygnus/blob/master/doc/flume_extensions_catalogue/ngsi_arcgis_sink.md\n+ */\n+public class NGSIArcgisFeatureTableSink extends NGSISink {\n+\n+    private static final String DEFAULT_ARCGIS_SERVICE_URL = \"localhost\";\n+    private static final String DEFAULT_GETTOKEN_URL = \"localhost\";\n+    private static final String DEFAULT_USER_NAME = \"root\";\n+    private static final String DEFAULT_PASSWORD = \"\";\n+    private static final int DEFAULT_MAX_BATCH_SIZE = 10;\n+    private static final int DEFAULT_BATCH_TIMEOUT_SECS = 60;\n+    private static final String ARCGIS_INSTANCE_NAME = \"arcgis\";\n+\n+    private static final CygnusLogger LOGGER = new CygnusLogger(NGSIArcgisFeatureTableSink.class);\n+    private String arcgisServicesUrl;\n+    private String getTokenUrl;\n+    private String userName;\n+    private String password;\n+    private int maxBatchSize;\n+    private long timeoutSecs;\n+    private static volatile Map<String, NGSIArcgisFeatureTable> arcgisPersistenceBackend;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public NGSIArcgisFeatureTableSink() {\n+        super();\n+    } // NGSIArcgisFeatureTableSink\n+\n+    /**\n+     * Gets the Argis services url. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The services url\n+     */\n+    protected String getrAcgisServicesUrl() {\n+        return arcgisServicesUrl;\n+    } // getrAcgisServicesUrl\n+\n+    /**\n+     * Gets getToken's service url.\n+     * \n+     * @return\n+     */\n+    public String getGetTokenUrl() {\n+        return getTokenUrl;\n+    }\n+\n+    /**\n+     * Sets getToken service url.\n+     * \n+     * @param getTokenUrl\n+     */\n+    public void setGetTokenUrl(String getTokenUrl) {\n+        this.getTokenUrl = getTokenUrl;\n+    }\n+\n+    /**\n+     * Gets the username. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The username\n+     */\n+    protected String getUsername() {\n+        return userName;\n+    } // getUsername\n+\n+    /**\n+     * Gets the password. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The password\n+     */\n+    protected String getPassword() {\n+        return password;\n+    } // getPassword\n+\n+    /**\n+     * \n+     */\n+    protected int featuresBatched() {\n+        int total = 0;\n+        for (Map.Entry<String, NGSIArcgisFeatureTable> entry : arcgisPersistenceBackend.entrySet()) {\n+            NGSIArcgisFeatureTable table = entry.getValue();\n+            if (table != null) {\n+                total += table.featuresBatched();\n+            }\n+        }\n+\n+        return total;\n+    }\n+\n+    /**\n+     * Returns the persistence backend. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The persistence backend\n+     * @throws CygnusRuntimeError\n+     */\n+    protected ArcgisFeatureTable getPersistenceBackend(String featureServiceUrl) throws CygnusRuntimeError {\n+\n+        if (arcgisPersistenceBackend.containsKey(featureServiceUrl)) {\n+            return arcgisPersistenceBackend.get(featureServiceUrl);\n+        } else {\n+            LOGGER.debug(\"Creating new persistenceBackend for Feature table: \" + featureServiceUrl);\n+            LOGGER.debug(\"Token url: \" + getGetTokenUrl());\n+            LOGGER.debug(\"User name: \" + getUsername());\n+            LOGGER.debug(\"Passwd: \" + getPassword());\n+            try {\n+                NGSIArcgisFeatureTable newTable = new NGSIArcgisFeatureTable(featureServiceUrl, getUsername(),\n+                        getPassword(), getGetTokenUrl(), timeoutSecs, LOGGER);\n+                newTable.setBatchAction(ArcgisFeatureTable.ADD_UPDATE_ACTION);\n+                newTable.setBatchSize(maxBatchSize);\n+\n+                if (newTable.hasError()) {\n+                    throw new CygnusRuntimeError(\"[\" + this.getName() + \"Error creating Persistence backend: \"\n+                            + newTable.getErrorCode() + \" - \" + newTable.getErrorDesc());\n+                } else {\n+                    arcgisPersistenceBackend.put(featureServiceUrl, newTable);\n+                    return newTable;\n+                }\n+            } catch (Throwable e) {\n+                String stackTrace = ExceptionUtils.getFullStackTrace(e);\n+                LOGGER.debug(stackTrace);\n+                throw new CygnusRuntimeError(\"Error creating new persistence Backend. \", e.getClass().getName(),\n+                        e.getMessage());\n+            }\n+        }\n+    } // getPersistenceBackend\n+\n+    /**\n+     * Sets the persistence backend. It is protected due to it is only required for testing purposes.\n+     * \n+     * @param persistenceBackend\n+     */\n+    protected void setPersistenceBackend(String featureServiceUrl, NGSIArcgisFeatureTable persistenceBackend) {\n+        arcgisPersistenceBackend.put(featureServiceUrl, persistenceBackend);\n+    } // setPersistenceBackend\n+\n+    @Override\n+    public void configure(Context context) {\n+        arcgisServicesUrl = context.getString(\"arcgis_service_url\", DEFAULT_ARCGIS_SERVICE_URL);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_service_url=\" + arcgisServicesUrl + \")\");\n+\n+        getTokenUrl = context.getString(\"arcgis_gettoken_url\", DEFAULT_GETTOKEN_URL);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_fearcgis_gettoken_urlature_table_url=\"\n+                + getTokenUrl + \")\");\n+\n+        userName = context.getString(\"arcgis_username\", DEFAULT_USER_NAME);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_username=\" + userName + \")\");\n+        // FIXME: Password should be read encrypted and decoded here\n+        password = context.getString(\"arcgis_password\", DEFAULT_PASSWORD);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_password=\" + password + \")\");\n+\n+        maxBatchSize = context.getInteger(\"arcgis_maxBatchSize\", DEFAULT_MAX_BATCH_SIZE);\n+        if (maxBatchSize <= 0 || maxBatchSize > 65535) {\n+            invalidConfiguration = true;\n+            LOGGER.error(\"[\" + this.getName() + \"] Invalid configuration (arcgis_maxBatchSize=\" + maxBatchSize + \") \"\n+                    + \"must be an integer between 1 and 65535\");\n+        } else {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_maxBatchSize=\" + maxBatchSize + \")\");\n+        }\n+\n+        timeoutSecs = context.getInteger(\"arcgis_timeoutSecs\", DEFAULT_BATCH_TIMEOUT_SECS);\n+        if (timeoutSecs <= 0 || timeoutSecs > 65535) {\n+            invalidConfiguration = true;\n+            LOGGER.error(\"[\" + this.getName() + \"] Invalid configuration (arcgis_timeoutSecs=\" + timeoutSecs + \") \"\n+                    + \"must be an integer between 1 and 65535\");\n+        } else {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_timeoutSecs=\" + maxBatchSize + \")\");\n+        }\n+\n+        super.configure(context);\n+    } // configure\n+\n+    @Override\n+    public void start() {\n+        try {\n+            createPersistenceBackend();\n+            LOGGER.debug(\"[\" + this.getName() + \"] Arcgis persistence backend created\");\n+        } catch (Exception e) {\n+            LOGGER.error(\"Error while creating the Arcgis persistence backend. Details=\" + e.getMessage());\n+        } // try catch\n+\n+        super.start();\n+    } // start\n+\n+    @Override\n+    public void stop() {\n+        super.stop();\n+        if (arcgisPersistenceBackend != null) {\n+            for (Map.Entry<String, NGSIArcgisFeatureTable> backend : arcgisPersistenceBackend.entrySet()) {\n+                backend.getValue().flushBatch();\n+            }\n+            arcgisPersistenceBackend.clear();\n+        }\n+    } // stop\n+\n+    /**\n+     * Initialices a lazy singleton to share among instances on JVM.\n+     */\n+    private static synchronized void createPersistenceBackend() {\n+        if (arcgisPersistenceBackend == null) {\n+            arcgisPersistenceBackend = new ConcurrentHashMap<String, NGSIArcgisFeatureTable>();\n+        }\n+    }\n+\n+    @Override\n+    void persistBatch(NGSIBatch batch)\n+            throws CygnusBadConfiguration, CygnusPersistenceError, CygnusRuntimeError, CygnusBadContextData {\n+        if (batch == null) {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Null batch, nothing to do\");\n+            return;\n+        } // if\n+\n+        try {\n+            // Iterate on the destinations\n+            batch.startIterator();\n+\n+            while (batch.hasNext()) {\n+                String destination = batch.getNextDestination();\n+                LOGGER.debug(\n+                        \"[\" + this.getName() + \"] Processing sub-batch regarding the \" + destination + \" destination\");\n+\n+                // Get the events within the current sub-batch\n+                ArrayList<NGSIEvent> events = batch.getNextEvents();\n+\n+                // Get an aggregator for this destination and initialize it\n+                NGSIArcgisAggregator aggregator = new NGSIArcgisAggregator(getrAcgisServicesUrl(), enableNameMappings);\n+                // aggregator.setService(events.get(0).getServiceForNaming(enableNameMappings));\n+                // aggregator.setServicePathForData(events.get(0).getServicePathForData());\n+                // aggregator.setServicePathForNaming(events.get(0).getServicePathForNaming(enableGrouping,\n+                // enableNameMappings));\n+                // aggregator.setEntityForNaming(events.get(0).getEntityForNaming(enableGrouping, enableNameMappings,\n+                // enableEncoding));\n+                // aggregator.setEntityType(events.get(0).getEntityTypeForNaming(enableGrouping, enableNameMappings));\n+                // aggregator.setAttribute(events.get(0).getAttributeForNaming(enableNameMappings));\n+                // aggregator.setDbName(buildDbName(aggregator.getService()));\n+                // aggregator.setTableName(buildTableName(aggregator.getServicePathForNaming(),\n+                // aggregator.getEntityForNaming(), aggregator.getEntityType(), aggregator.getAttribute()));\n+                // aggregator.setAttrNativeTypes(attrNativeTypes);\n+                // aggregator.setAttrMetadataStore(false);\n+                aggregator.initialize(events.get(0));\n+                for (NGSIEvent event : events) {\n+                    aggregator.aggregate(event);\n+                } // for\n+\n+                // Persist the aggregation\n+                persistAggregation(aggregator);\n+                batch.setNextPersisted(true);\n+\n+            } // while\n+        } catch (Exception e) {\n+            LOGGER.error(\"[\" + this.getName() + \"] Error persisting batch, \" + e.getMessage());\n+            throw new CygnusRuntimeError(e.getMessage());\n+        }\n+    } // persistBatch\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see com.telefonica.iot.cygnus.sinks.NGSISink#process()\n+     */\n+    @Override\n+    public Status process() throws EventDeliveryException {\n+        checkTimeouts();\n+        Status status = null;\n+        try {\n+            status = super.process();\n+        } catch (Throwable e) {\n+            LOGGER.error(e.getMessage() + \"Stack trace: \" + Arrays.toString(e.getStackTrace()));\n+        }\n+        return status;\n+    }\n+\n+    /**\n+     * Flush if timeout.\n+     */\n+    protected void checkTimeouts() {\n+        boolean timeoutFound = false;\n+        for (Map.Entry<String, NGSIArcgisFeatureTable> entry : arcgisPersistenceBackend.entrySet()) {\n+            NGSIArcgisFeatureTable table = entry.getValue();\n+            if (table.hasTimeout()) {\n+                timeoutFound = true;\n+                LOGGER.info(\"[\" + this.getName() + \"] Feature table Timeout, flushing batch. \" + entry.getKey());\n+                table.flushBatch();\n+            }\n+        }\n+        if (!timeoutFound) {\n+            LOGGER.debug(\"[\" + this.getName() + \"] No Feature table Timeouts found. Features in batch: \"\n+                    + featuresBatched());\n+        }\n+    }\n+\n+    @Override\n+    public void capRecords(NGSIBatch batch, long maxRecords) throws CygnusCappingError {\n+        // no capping\n+        LOGGER.warn(\"[\" + this.getName() + \"] Skipping capping records, just persisting it.\");\n+        try {\n+            persistBatch(batch);\n+        } catch (CygnusBadConfiguration | CygnusPersistenceError | CygnusRuntimeError | CygnusBadContextData e) {\n+            LOGGER.error(\"[\" + this.getName() + \"] Error capping Records: \" + e);\n+            throw new CygnusCappingError(e.getMessage());\n+        }\n+    } // capRecords\n+\n+    @Override\n+    public void expirateRecords(long expirationTime) throws CygnusExpiratingError {\n+        LOGGER.debug(\"[\" + this.getName() + \"] Expirating records (time=\" + expirationTime + \")\");\n+\n+    } // expirateRecords\n+\n+    /**\n+     * Persist Aggregation.\n+     * \n+     * @param aggregator\n+     * @throws CygnusRuntimeError\n+     */\n+    public void persistAggregation(NGSIArcgisAggregator aggregator) throws CygnusRuntimeError {\n+        try {\n+            List<ArcgisAggregatorDomain> aggregationList = aggregator.getListArcgisAggregatorDomain();\n+            LOGGER.debug(\"[\" + this.getName() + \"] persisting aggregation, \"\n+                    + aggregator.getListArcgisAggregatorDomain().size() + \" features.\");\n+            for (ArcgisAggregatorDomain aggregation : aggregationList) {\n+                String featureTableUrl = aggregation.getFeatureTableUrl();\n+\n+                boolean isNewFeatureTable = !arcgisPersistenceBackend.containsKey(featureTableUrl);\n+                LOGGER.debug(\"[\" + this.getName() + \"] persistAggregation - Feature table: \" + featureTableUrl\n+                        + \" is new: \" + isNewFeatureTable);\n+                ArcgisFeatureTable featureTable = getPersistenceBackend(featureTableUrl);\n+\n+                // If it's a new one, sets uniqueField value\n+                if (isNewFeatureTable) {\n+                    LOGGER.debug(\"[\" + this.getName() + \"] Created new backend for \" + featureTableUrl\n+                            + \" with uniqueField: \" + aggregation.getUniqueField());\n+                    featureTable.setUniqueField(aggregation.getUniqueField());\n+                }\n+\n+                featureTable.addToBatch(aggregation.getFeature());\n+            }\n+        } catch (CygnusRuntimeError e) {\n+            String stackTrace = ExceptionUtils.getFullStackTrace(e);\n+            LOGGER.debug(\" PersistAggregation Error: \" + stackTrace);\n+            throw (e);\n+        } catch (Exception e) {\n+            LOGGER.error(\"[\" + this.getName() + \"] Error persisting batch, \" + e.getClass().getSimpleName() + \" - \"\n+                    + e.getMessage());\n+            throw new CygnusRuntimeError(e.getMessage());\n+        }\n+    } // persistAggregation\n+\n+    /**\n+     * @author dmartinez\n+     *\n+     */\n+    public class NGSIArcgisAggregator {\n+\n+        private List<ArcgisAggregatorDomain> listArcgisAggregatorDomain = new ArrayList<ArcgisAggregatorDomain>();\n+        private boolean enableNameMappings = true;\n+        private String argisServiceUrl = \"\";\n+\n+        private NGSIArcgisAggregator() {", "originalCommit": "a322017a039928c29edce071f799e5e6addcd4ea", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcyNTM5Mw==", "url": "https://github.com/telefonicaid/fiware-cygnus/pull/1860#discussion_r413725393", "bodyText": "This function seems to be empty, is it used?", "author": "IvanHdzC", "createdAt": "2020-04-23T11:09:40Z", "path": "cygnus-arcgis/src/main/java/com/telefonica/iot/cygnus/sinks/NGSIArcgisFeatureTableSink.java", "diffHunk": "@@ -0,0 +1,789 @@\n+/**\n+ * Copyright 2014-2017 Telefonica Investigaci\u00f3n y Desarrollo, S.A.U\n+ *\n+ * This file is part of fiware-cygnus (FIWARE project).\n+ *\n+ * fiware-cygnus is free software: you can redistribute it and/or modify it under the terms of the GNU Affero\n+ * General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your\n+ * option) any later version.\n+ * fiware-cygnus is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the\n+ * implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n+ * for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License along with fiware-cygnus. If not, see\n+ * http://www.gnu.org/licenses/.\n+ *\n+ * For those usages not covered by the GNU Affero General Public License please contact with iot_support at tid dot es\n+ */\n+\n+package com.telefonica.iot.cygnus.sinks;\n+\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.commons.lang.exception.ExceptionUtils;\n+import org.apache.flume.Context;\n+import org.apache.flume.EventDeliveryException;\n+import org.json.JSONException;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Feature;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Point;\n+import com.telefonica.iot.cygnus.backends.arcgis.restutils.ArcgisFeatureTable;\n+import com.telefonica.iot.cygnus.backends.arcgis.restutils.NGSIArcgisFeatureTable;\n+import com.telefonica.iot.cygnus.containers.NotifyContextRequest.ContextAttribute;\n+import com.telefonica.iot.cygnus.containers.NotifyContextRequest.ContextElement;\n+import com.telefonica.iot.cygnus.errors.CygnusBadConfiguration;\n+import com.telefonica.iot.cygnus.errors.CygnusBadContextData;\n+import com.telefonica.iot.cygnus.errors.CygnusCappingError;\n+import com.telefonica.iot.cygnus.errors.CygnusExpiratingError;\n+import com.telefonica.iot.cygnus.errors.CygnusPersistenceError;\n+import com.telefonica.iot.cygnus.errors.CygnusRuntimeError;\n+import com.telefonica.iot.cygnus.interceptors.NGSIEvent;\n+import com.telefonica.iot.cygnus.log.CygnusLogger;\n+import com.telefonica.iot.cygnus.utils.NGSIConstants;\n+\n+import jodd.util.URLDecoder;\n+\n+/**\n+ *\n+ * @author dmartinez\n+ * \n+ *         Detailed documentation can be found at:\n+ *         https://github.com/telefonicaid/fiware-cygnus/blob/master/doc/flume_extensions_catalogue/ngsi_arcgis_sink.md\n+ */\n+public class NGSIArcgisFeatureTableSink extends NGSISink {\n+\n+    private static final String DEFAULT_ARCGIS_SERVICE_URL = \"localhost\";\n+    private static final String DEFAULT_GETTOKEN_URL = \"localhost\";\n+    private static final String DEFAULT_USER_NAME = \"root\";\n+    private static final String DEFAULT_PASSWORD = \"\";\n+    private static final int DEFAULT_MAX_BATCH_SIZE = 10;\n+    private static final int DEFAULT_BATCH_TIMEOUT_SECS = 60;\n+    private static final String ARCGIS_INSTANCE_NAME = \"arcgis\";\n+\n+    private static final CygnusLogger LOGGER = new CygnusLogger(NGSIArcgisFeatureTableSink.class);\n+    private String arcgisServicesUrl;\n+    private String getTokenUrl;\n+    private String userName;\n+    private String password;\n+    private int maxBatchSize;\n+    private long timeoutSecs;\n+    private static volatile Map<String, NGSIArcgisFeatureTable> arcgisPersistenceBackend;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public NGSIArcgisFeatureTableSink() {\n+        super();\n+    } // NGSIArcgisFeatureTableSink\n+\n+    /**\n+     * Gets the Argis services url. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The services url\n+     */\n+    protected String getrAcgisServicesUrl() {\n+        return arcgisServicesUrl;\n+    } // getrAcgisServicesUrl\n+\n+    /**\n+     * Gets getToken's service url.\n+     * \n+     * @return\n+     */\n+    public String getGetTokenUrl() {\n+        return getTokenUrl;\n+    }\n+\n+    /**\n+     * Sets getToken service url.\n+     * \n+     * @param getTokenUrl\n+     */\n+    public void setGetTokenUrl(String getTokenUrl) {\n+        this.getTokenUrl = getTokenUrl;\n+    }\n+\n+    /**\n+     * Gets the username. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The username\n+     */\n+    protected String getUsername() {\n+        return userName;\n+    } // getUsername\n+\n+    /**\n+     * Gets the password. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The password\n+     */\n+    protected String getPassword() {\n+        return password;\n+    } // getPassword\n+\n+    /**\n+     * \n+     */\n+    protected int featuresBatched() {\n+        int total = 0;\n+        for (Map.Entry<String, NGSIArcgisFeatureTable> entry : arcgisPersistenceBackend.entrySet()) {\n+            NGSIArcgisFeatureTable table = entry.getValue();\n+            if (table != null) {\n+                total += table.featuresBatched();\n+            }\n+        }\n+\n+        return total;\n+    }\n+\n+    /**\n+     * Returns the persistence backend. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The persistence backend\n+     * @throws CygnusRuntimeError\n+     */\n+    protected ArcgisFeatureTable getPersistenceBackend(String featureServiceUrl) throws CygnusRuntimeError {\n+\n+        if (arcgisPersistenceBackend.containsKey(featureServiceUrl)) {\n+            return arcgisPersistenceBackend.get(featureServiceUrl);\n+        } else {\n+            LOGGER.debug(\"Creating new persistenceBackend for Feature table: \" + featureServiceUrl);\n+            LOGGER.debug(\"Token url: \" + getGetTokenUrl());\n+            LOGGER.debug(\"User name: \" + getUsername());\n+            LOGGER.debug(\"Passwd: \" + getPassword());\n+            try {\n+                NGSIArcgisFeatureTable newTable = new NGSIArcgisFeatureTable(featureServiceUrl, getUsername(),\n+                        getPassword(), getGetTokenUrl(), timeoutSecs, LOGGER);\n+                newTable.setBatchAction(ArcgisFeatureTable.ADD_UPDATE_ACTION);\n+                newTable.setBatchSize(maxBatchSize);\n+\n+                if (newTable.hasError()) {\n+                    throw new CygnusRuntimeError(\"[\" + this.getName() + \"Error creating Persistence backend: \"\n+                            + newTable.getErrorCode() + \" - \" + newTable.getErrorDesc());\n+                } else {\n+                    arcgisPersistenceBackend.put(featureServiceUrl, newTable);\n+                    return newTable;\n+                }\n+            } catch (Throwable e) {\n+                String stackTrace = ExceptionUtils.getFullStackTrace(e);\n+                LOGGER.debug(stackTrace);\n+                throw new CygnusRuntimeError(\"Error creating new persistence Backend. \", e.getClass().getName(),\n+                        e.getMessage());\n+            }\n+        }\n+    } // getPersistenceBackend\n+\n+    /**\n+     * Sets the persistence backend. It is protected due to it is only required for testing purposes.\n+     * \n+     * @param persistenceBackend\n+     */\n+    protected void setPersistenceBackend(String featureServiceUrl, NGSIArcgisFeatureTable persistenceBackend) {\n+        arcgisPersistenceBackend.put(featureServiceUrl, persistenceBackend);\n+    } // setPersistenceBackend\n+\n+    @Override\n+    public void configure(Context context) {\n+        arcgisServicesUrl = context.getString(\"arcgis_service_url\", DEFAULT_ARCGIS_SERVICE_URL);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_service_url=\" + arcgisServicesUrl + \")\");\n+\n+        getTokenUrl = context.getString(\"arcgis_gettoken_url\", DEFAULT_GETTOKEN_URL);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_fearcgis_gettoken_urlature_table_url=\"\n+                + getTokenUrl + \")\");\n+\n+        userName = context.getString(\"arcgis_username\", DEFAULT_USER_NAME);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_username=\" + userName + \")\");\n+        // FIXME: Password should be read encrypted and decoded here\n+        password = context.getString(\"arcgis_password\", DEFAULT_PASSWORD);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_password=\" + password + \")\");\n+\n+        maxBatchSize = context.getInteger(\"arcgis_maxBatchSize\", DEFAULT_MAX_BATCH_SIZE);\n+        if (maxBatchSize <= 0 || maxBatchSize > 65535) {\n+            invalidConfiguration = true;\n+            LOGGER.error(\"[\" + this.getName() + \"] Invalid configuration (arcgis_maxBatchSize=\" + maxBatchSize + \") \"\n+                    + \"must be an integer between 1 and 65535\");\n+        } else {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_maxBatchSize=\" + maxBatchSize + \")\");\n+        }\n+\n+        timeoutSecs = context.getInteger(\"arcgis_timeoutSecs\", DEFAULT_BATCH_TIMEOUT_SECS);\n+        if (timeoutSecs <= 0 || timeoutSecs > 65535) {\n+            invalidConfiguration = true;\n+            LOGGER.error(\"[\" + this.getName() + \"] Invalid configuration (arcgis_timeoutSecs=\" + timeoutSecs + \") \"\n+                    + \"must be an integer between 1 and 65535\");\n+        } else {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_timeoutSecs=\" + maxBatchSize + \")\");\n+        }\n+\n+        super.configure(context);\n+    } // configure\n+\n+    @Override\n+    public void start() {\n+        try {\n+            createPersistenceBackend();\n+            LOGGER.debug(\"[\" + this.getName() + \"] Arcgis persistence backend created\");\n+        } catch (Exception e) {\n+            LOGGER.error(\"Error while creating the Arcgis persistence backend. Details=\" + e.getMessage());\n+        } // try catch\n+\n+        super.start();\n+    } // start\n+\n+    @Override\n+    public void stop() {\n+        super.stop();\n+        if (arcgisPersistenceBackend != null) {\n+            for (Map.Entry<String, NGSIArcgisFeatureTable> backend : arcgisPersistenceBackend.entrySet()) {\n+                backend.getValue().flushBatch();\n+            }\n+            arcgisPersistenceBackend.clear();\n+        }\n+    } // stop\n+\n+    /**\n+     * Initialices a lazy singleton to share among instances on JVM.\n+     */\n+    private static synchronized void createPersistenceBackend() {\n+        if (arcgisPersistenceBackend == null) {\n+            arcgisPersistenceBackend = new ConcurrentHashMap<String, NGSIArcgisFeatureTable>();\n+        }\n+    }\n+\n+    @Override\n+    void persistBatch(NGSIBatch batch)\n+            throws CygnusBadConfiguration, CygnusPersistenceError, CygnusRuntimeError, CygnusBadContextData {\n+        if (batch == null) {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Null batch, nothing to do\");\n+            return;\n+        } // if\n+\n+        try {\n+            // Iterate on the destinations\n+            batch.startIterator();\n+\n+            while (batch.hasNext()) {\n+                String destination = batch.getNextDestination();\n+                LOGGER.debug(\n+                        \"[\" + this.getName() + \"] Processing sub-batch regarding the \" + destination + \" destination\");\n+\n+                // Get the events within the current sub-batch\n+                ArrayList<NGSIEvent> events = batch.getNextEvents();\n+\n+                // Get an aggregator for this destination and initialize it\n+                NGSIArcgisAggregator aggregator = new NGSIArcgisAggregator(getrAcgisServicesUrl(), enableNameMappings);\n+                // aggregator.setService(events.get(0).getServiceForNaming(enableNameMappings));\n+                // aggregator.setServicePathForData(events.get(0).getServicePathForData());\n+                // aggregator.setServicePathForNaming(events.get(0).getServicePathForNaming(enableGrouping,\n+                // enableNameMappings));\n+                // aggregator.setEntityForNaming(events.get(0).getEntityForNaming(enableGrouping, enableNameMappings,\n+                // enableEncoding));\n+                // aggregator.setEntityType(events.get(0).getEntityTypeForNaming(enableGrouping, enableNameMappings));\n+                // aggregator.setAttribute(events.get(0).getAttributeForNaming(enableNameMappings));\n+                // aggregator.setDbName(buildDbName(aggregator.getService()));\n+                // aggregator.setTableName(buildTableName(aggregator.getServicePathForNaming(),\n+                // aggregator.getEntityForNaming(), aggregator.getEntityType(), aggregator.getAttribute()));\n+                // aggregator.setAttrNativeTypes(attrNativeTypes);\n+                // aggregator.setAttrMetadataStore(false);\n+                aggregator.initialize(events.get(0));\n+                for (NGSIEvent event : events) {\n+                    aggregator.aggregate(event);\n+                } // for\n+\n+                // Persist the aggregation\n+                persistAggregation(aggregator);\n+                batch.setNextPersisted(true);\n+\n+            } // while\n+        } catch (Exception e) {\n+            LOGGER.error(\"[\" + this.getName() + \"] Error persisting batch, \" + e.getMessage());\n+            throw new CygnusRuntimeError(e.getMessage());\n+        }\n+    } // persistBatch\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see com.telefonica.iot.cygnus.sinks.NGSISink#process()\n+     */\n+    @Override\n+    public Status process() throws EventDeliveryException {\n+        checkTimeouts();\n+        Status status = null;\n+        try {\n+            status = super.process();\n+        } catch (Throwable e) {\n+            LOGGER.error(e.getMessage() + \"Stack trace: \" + Arrays.toString(e.getStackTrace()));\n+        }\n+        return status;\n+    }\n+\n+    /**\n+     * Flush if timeout.\n+     */\n+    protected void checkTimeouts() {\n+        boolean timeoutFound = false;\n+        for (Map.Entry<String, NGSIArcgisFeatureTable> entry : arcgisPersistenceBackend.entrySet()) {\n+            NGSIArcgisFeatureTable table = entry.getValue();\n+            if (table.hasTimeout()) {\n+                timeoutFound = true;\n+                LOGGER.info(\"[\" + this.getName() + \"] Feature table Timeout, flushing batch. \" + entry.getKey());\n+                table.flushBatch();\n+            }\n+        }\n+        if (!timeoutFound) {\n+            LOGGER.debug(\"[\" + this.getName() + \"] No Feature table Timeouts found. Features in batch: \"\n+                    + featuresBatched());\n+        }\n+    }\n+\n+    @Override\n+    public void capRecords(NGSIBatch batch, long maxRecords) throws CygnusCappingError {\n+        // no capping\n+        LOGGER.warn(\"[\" + this.getName() + \"] Skipping capping records, just persisting it.\");\n+        try {\n+            persistBatch(batch);\n+        } catch (CygnusBadConfiguration | CygnusPersistenceError | CygnusRuntimeError | CygnusBadContextData e) {\n+            LOGGER.error(\"[\" + this.getName() + \"] Error capping Records: \" + e);\n+            throw new CygnusCappingError(e.getMessage());\n+        }\n+    } // capRecords\n+\n+    @Override\n+    public void expirateRecords(long expirationTime) throws CygnusExpiratingError {\n+        LOGGER.debug(\"[\" + this.getName() + \"] Expirating records (time=\" + expirationTime + \")\");\n+\n+    } // expirateRecords\n+\n+    /**\n+     * Persist Aggregation.\n+     * \n+     * @param aggregator\n+     * @throws CygnusRuntimeError\n+     */\n+    public void persistAggregation(NGSIArcgisAggregator aggregator) throws CygnusRuntimeError {\n+        try {\n+            List<ArcgisAggregatorDomain> aggregationList = aggregator.getListArcgisAggregatorDomain();\n+            LOGGER.debug(\"[\" + this.getName() + \"] persisting aggregation, \"\n+                    + aggregator.getListArcgisAggregatorDomain().size() + \" features.\");\n+            for (ArcgisAggregatorDomain aggregation : aggregationList) {\n+                String featureTableUrl = aggregation.getFeatureTableUrl();\n+\n+                boolean isNewFeatureTable = !arcgisPersistenceBackend.containsKey(featureTableUrl);\n+                LOGGER.debug(\"[\" + this.getName() + \"] persistAggregation - Feature table: \" + featureTableUrl\n+                        + \" is new: \" + isNewFeatureTable);\n+                ArcgisFeatureTable featureTable = getPersistenceBackend(featureTableUrl);\n+\n+                // If it's a new one, sets uniqueField value\n+                if (isNewFeatureTable) {\n+                    LOGGER.debug(\"[\" + this.getName() + \"] Created new backend for \" + featureTableUrl\n+                            + \" with uniqueField: \" + aggregation.getUniqueField());\n+                    featureTable.setUniqueField(aggregation.getUniqueField());\n+                }\n+\n+                featureTable.addToBatch(aggregation.getFeature());\n+            }\n+        } catch (CygnusRuntimeError e) {\n+            String stackTrace = ExceptionUtils.getFullStackTrace(e);\n+            LOGGER.debug(\" PersistAggregation Error: \" + stackTrace);\n+            throw (e);\n+        } catch (Exception e) {\n+            LOGGER.error(\"[\" + this.getName() + \"] Error persisting batch, \" + e.getClass().getSimpleName() + \" - \"\n+                    + e.getMessage());\n+            throw new CygnusRuntimeError(e.getMessage());\n+        }\n+    } // persistAggregation\n+\n+    /**\n+     * @author dmartinez\n+     *\n+     */\n+    public class NGSIArcgisAggregator {\n+\n+        private List<ArcgisAggregatorDomain> listArcgisAggregatorDomain = new ArrayList<ArcgisAggregatorDomain>();\n+        private boolean enableNameMappings = true;\n+        private String argisServiceUrl = \"\";\n+\n+        private NGSIArcgisAggregator() {\n+        } // ArcgisAggregator\n+\n+        /**\n+         * Constructor.\n+         * \n+         * @param argisServiceUrl\n+         * @param enableNameMappings\n+         */\n+        public NGSIArcgisAggregator(String argisServiceUrl, boolean enableNameMappings) {\n+            this();\n+            this.enableNameMappings = enableNameMappings;\n+            this.argisServiceUrl = argisServiceUrl;\n+        } // ArcgisAggregator\n+\n+        /**\n+         * \n+         * @param event\n+         */\n+        public void initialize(NGSIEvent event) {", "originalCommit": "a322017a039928c29edce071f799e5e6addcd4ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjUzOTY1MA==", "url": "https://github.com/telefonicaid/fiware-cygnus/pull/1860#discussion_r416539650", "bodyText": "Removed\nStdri@1941e81", "author": "pmo-sdr", "createdAt": "2020-04-28T11:31:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzcyNTM5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzczMDIyOA==", "url": "https://github.com/telefonicaid/fiware-cygnus/pull/1860#discussion_r413730228", "bodyText": "That \"1\" String is so mysterious. It would be better to add it as a constant on the class", "author": "IvanHdzC", "createdAt": "2020-04-23T11:18:07Z", "path": "cygnus-arcgis/src/main/java/com/telefonica/iot/cygnus/sinks/NGSIArcgisFeatureTableSink.java", "diffHunk": "@@ -0,0 +1,789 @@\n+/**\n+ * Copyright 2014-2017 Telefonica Investigaci\u00f3n y Desarrollo, S.A.U\n+ *\n+ * This file is part of fiware-cygnus (FIWARE project).\n+ *\n+ * fiware-cygnus is free software: you can redistribute it and/or modify it under the terms of the GNU Affero\n+ * General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your\n+ * option) any later version.\n+ * fiware-cygnus is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the\n+ * implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n+ * for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License along with fiware-cygnus. If not, see\n+ * http://www.gnu.org/licenses/.\n+ *\n+ * For those usages not covered by the GNU Affero General Public License please contact with iot_support at tid dot es\n+ */\n+\n+package com.telefonica.iot.cygnus.sinks;\n+\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.commons.lang.exception.ExceptionUtils;\n+import org.apache.flume.Context;\n+import org.apache.flume.EventDeliveryException;\n+import org.json.JSONException;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Feature;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Point;\n+import com.telefonica.iot.cygnus.backends.arcgis.restutils.ArcgisFeatureTable;\n+import com.telefonica.iot.cygnus.backends.arcgis.restutils.NGSIArcgisFeatureTable;\n+import com.telefonica.iot.cygnus.containers.NotifyContextRequest.ContextAttribute;\n+import com.telefonica.iot.cygnus.containers.NotifyContextRequest.ContextElement;\n+import com.telefonica.iot.cygnus.errors.CygnusBadConfiguration;\n+import com.telefonica.iot.cygnus.errors.CygnusBadContextData;\n+import com.telefonica.iot.cygnus.errors.CygnusCappingError;\n+import com.telefonica.iot.cygnus.errors.CygnusExpiratingError;\n+import com.telefonica.iot.cygnus.errors.CygnusPersistenceError;\n+import com.telefonica.iot.cygnus.errors.CygnusRuntimeError;\n+import com.telefonica.iot.cygnus.interceptors.NGSIEvent;\n+import com.telefonica.iot.cygnus.log.CygnusLogger;\n+import com.telefonica.iot.cygnus.utils.NGSIConstants;\n+\n+import jodd.util.URLDecoder;\n+\n+/**\n+ *\n+ * @author dmartinez\n+ * \n+ *         Detailed documentation can be found at:\n+ *         https://github.com/telefonicaid/fiware-cygnus/blob/master/doc/flume_extensions_catalogue/ngsi_arcgis_sink.md\n+ */\n+public class NGSIArcgisFeatureTableSink extends NGSISink {\n+\n+    private static final String DEFAULT_ARCGIS_SERVICE_URL = \"localhost\";\n+    private static final String DEFAULT_GETTOKEN_URL = \"localhost\";\n+    private static final String DEFAULT_USER_NAME = \"root\";\n+    private static final String DEFAULT_PASSWORD = \"\";\n+    private static final int DEFAULT_MAX_BATCH_SIZE = 10;\n+    private static final int DEFAULT_BATCH_TIMEOUT_SECS = 60;\n+    private static final String ARCGIS_INSTANCE_NAME = \"arcgis\";\n+\n+    private static final CygnusLogger LOGGER = new CygnusLogger(NGSIArcgisFeatureTableSink.class);\n+    private String arcgisServicesUrl;\n+    private String getTokenUrl;\n+    private String userName;\n+    private String password;\n+    private int maxBatchSize;\n+    private long timeoutSecs;\n+    private static volatile Map<String, NGSIArcgisFeatureTable> arcgisPersistenceBackend;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public NGSIArcgisFeatureTableSink() {\n+        super();\n+    } // NGSIArcgisFeatureTableSink\n+\n+    /**\n+     * Gets the Argis services url. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The services url\n+     */\n+    protected String getrAcgisServicesUrl() {\n+        return arcgisServicesUrl;\n+    } // getrAcgisServicesUrl\n+\n+    /**\n+     * Gets getToken's service url.\n+     * \n+     * @return\n+     */\n+    public String getGetTokenUrl() {\n+        return getTokenUrl;\n+    }\n+\n+    /**\n+     * Sets getToken service url.\n+     * \n+     * @param getTokenUrl\n+     */\n+    public void setGetTokenUrl(String getTokenUrl) {\n+        this.getTokenUrl = getTokenUrl;\n+    }\n+\n+    /**\n+     * Gets the username. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The username\n+     */\n+    protected String getUsername() {\n+        return userName;\n+    } // getUsername\n+\n+    /**\n+     * Gets the password. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The password\n+     */\n+    protected String getPassword() {\n+        return password;\n+    } // getPassword\n+\n+    /**\n+     * \n+     */\n+    protected int featuresBatched() {\n+        int total = 0;\n+        for (Map.Entry<String, NGSIArcgisFeatureTable> entry : arcgisPersistenceBackend.entrySet()) {\n+            NGSIArcgisFeatureTable table = entry.getValue();\n+            if (table != null) {\n+                total += table.featuresBatched();\n+            }\n+        }\n+\n+        return total;\n+    }\n+\n+    /**\n+     * Returns the persistence backend. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The persistence backend\n+     * @throws CygnusRuntimeError\n+     */\n+    protected ArcgisFeatureTable getPersistenceBackend(String featureServiceUrl) throws CygnusRuntimeError {\n+\n+        if (arcgisPersistenceBackend.containsKey(featureServiceUrl)) {\n+            return arcgisPersistenceBackend.get(featureServiceUrl);\n+        } else {\n+            LOGGER.debug(\"Creating new persistenceBackend for Feature table: \" + featureServiceUrl);\n+            LOGGER.debug(\"Token url: \" + getGetTokenUrl());\n+            LOGGER.debug(\"User name: \" + getUsername());\n+            LOGGER.debug(\"Passwd: \" + getPassword());\n+            try {\n+                NGSIArcgisFeatureTable newTable = new NGSIArcgisFeatureTable(featureServiceUrl, getUsername(),\n+                        getPassword(), getGetTokenUrl(), timeoutSecs, LOGGER);\n+                newTable.setBatchAction(ArcgisFeatureTable.ADD_UPDATE_ACTION);\n+                newTable.setBatchSize(maxBatchSize);\n+\n+                if (newTable.hasError()) {\n+                    throw new CygnusRuntimeError(\"[\" + this.getName() + \"Error creating Persistence backend: \"\n+                            + newTable.getErrorCode() + \" - \" + newTable.getErrorDesc());\n+                } else {\n+                    arcgisPersistenceBackend.put(featureServiceUrl, newTable);\n+                    return newTable;\n+                }\n+            } catch (Throwable e) {\n+                String stackTrace = ExceptionUtils.getFullStackTrace(e);\n+                LOGGER.debug(stackTrace);\n+                throw new CygnusRuntimeError(\"Error creating new persistence Backend. \", e.getClass().getName(),\n+                        e.getMessage());\n+            }\n+        }\n+    } // getPersistenceBackend\n+\n+    /**\n+     * Sets the persistence backend. It is protected due to it is only required for testing purposes.\n+     * \n+     * @param persistenceBackend\n+     */\n+    protected void setPersistenceBackend(String featureServiceUrl, NGSIArcgisFeatureTable persistenceBackend) {\n+        arcgisPersistenceBackend.put(featureServiceUrl, persistenceBackend);\n+    } // setPersistenceBackend\n+\n+    @Override\n+    public void configure(Context context) {\n+        arcgisServicesUrl = context.getString(\"arcgis_service_url\", DEFAULT_ARCGIS_SERVICE_URL);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_service_url=\" + arcgisServicesUrl + \")\");\n+\n+        getTokenUrl = context.getString(\"arcgis_gettoken_url\", DEFAULT_GETTOKEN_URL);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_fearcgis_gettoken_urlature_table_url=\"\n+                + getTokenUrl + \")\");\n+\n+        userName = context.getString(\"arcgis_username\", DEFAULT_USER_NAME);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_username=\" + userName + \")\");\n+        // FIXME: Password should be read encrypted and decoded here\n+        password = context.getString(\"arcgis_password\", DEFAULT_PASSWORD);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_password=\" + password + \")\");\n+\n+        maxBatchSize = context.getInteger(\"arcgis_maxBatchSize\", DEFAULT_MAX_BATCH_SIZE);\n+        if (maxBatchSize <= 0 || maxBatchSize > 65535) {\n+            invalidConfiguration = true;\n+            LOGGER.error(\"[\" + this.getName() + \"] Invalid configuration (arcgis_maxBatchSize=\" + maxBatchSize + \") \"\n+                    + \"must be an integer between 1 and 65535\");\n+        } else {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_maxBatchSize=\" + maxBatchSize + \")\");\n+        }\n+\n+        timeoutSecs = context.getInteger(\"arcgis_timeoutSecs\", DEFAULT_BATCH_TIMEOUT_SECS);\n+        if (timeoutSecs <= 0 || timeoutSecs > 65535) {\n+            invalidConfiguration = true;\n+            LOGGER.error(\"[\" + this.getName() + \"] Invalid configuration (arcgis_timeoutSecs=\" + timeoutSecs + \") \"\n+                    + \"must be an integer between 1 and 65535\");\n+        } else {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_timeoutSecs=\" + maxBatchSize + \")\");\n+        }\n+\n+        super.configure(context);\n+    } // configure\n+\n+    @Override\n+    public void start() {\n+        try {\n+            createPersistenceBackend();\n+            LOGGER.debug(\"[\" + this.getName() + \"] Arcgis persistence backend created\");\n+        } catch (Exception e) {\n+            LOGGER.error(\"Error while creating the Arcgis persistence backend. Details=\" + e.getMessage());\n+        } // try catch\n+\n+        super.start();\n+    } // start\n+\n+    @Override\n+    public void stop() {\n+        super.stop();\n+        if (arcgisPersistenceBackend != null) {\n+            for (Map.Entry<String, NGSIArcgisFeatureTable> backend : arcgisPersistenceBackend.entrySet()) {\n+                backend.getValue().flushBatch();\n+            }\n+            arcgisPersistenceBackend.clear();\n+        }\n+    } // stop\n+\n+    /**\n+     * Initialices a lazy singleton to share among instances on JVM.\n+     */\n+    private static synchronized void createPersistenceBackend() {\n+        if (arcgisPersistenceBackend == null) {\n+            arcgisPersistenceBackend = new ConcurrentHashMap<String, NGSIArcgisFeatureTable>();\n+        }\n+    }\n+\n+    @Override\n+    void persistBatch(NGSIBatch batch)\n+            throws CygnusBadConfiguration, CygnusPersistenceError, CygnusRuntimeError, CygnusBadContextData {\n+        if (batch == null) {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Null batch, nothing to do\");\n+            return;\n+        } // if\n+\n+        try {\n+            // Iterate on the destinations\n+            batch.startIterator();\n+\n+            while (batch.hasNext()) {\n+                String destination = batch.getNextDestination();\n+                LOGGER.debug(\n+                        \"[\" + this.getName() + \"] Processing sub-batch regarding the \" + destination + \" destination\");\n+\n+                // Get the events within the current sub-batch\n+                ArrayList<NGSIEvent> events = batch.getNextEvents();\n+\n+                // Get an aggregator for this destination and initialize it\n+                NGSIArcgisAggregator aggregator = new NGSIArcgisAggregator(getrAcgisServicesUrl(), enableNameMappings);\n+                // aggregator.setService(events.get(0).getServiceForNaming(enableNameMappings));\n+                // aggregator.setServicePathForData(events.get(0).getServicePathForData());\n+                // aggregator.setServicePathForNaming(events.get(0).getServicePathForNaming(enableGrouping,\n+                // enableNameMappings));\n+                // aggregator.setEntityForNaming(events.get(0).getEntityForNaming(enableGrouping, enableNameMappings,\n+                // enableEncoding));\n+                // aggregator.setEntityType(events.get(0).getEntityTypeForNaming(enableGrouping, enableNameMappings));\n+                // aggregator.setAttribute(events.get(0).getAttributeForNaming(enableNameMappings));\n+                // aggregator.setDbName(buildDbName(aggregator.getService()));\n+                // aggregator.setTableName(buildTableName(aggregator.getServicePathForNaming(),\n+                // aggregator.getEntityForNaming(), aggregator.getEntityType(), aggregator.getAttribute()));\n+                // aggregator.setAttrNativeTypes(attrNativeTypes);\n+                // aggregator.setAttrMetadataStore(false);\n+                aggregator.initialize(events.get(0));\n+                for (NGSIEvent event : events) {\n+                    aggregator.aggregate(event);\n+                } // for\n+\n+                // Persist the aggregation\n+                persistAggregation(aggregator);\n+                batch.setNextPersisted(true);\n+\n+            } // while\n+        } catch (Exception e) {\n+            LOGGER.error(\"[\" + this.getName() + \"] Error persisting batch, \" + e.getMessage());\n+            throw new CygnusRuntimeError(e.getMessage());\n+        }\n+    } // persistBatch\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see com.telefonica.iot.cygnus.sinks.NGSISink#process()\n+     */\n+    @Override\n+    public Status process() throws EventDeliveryException {\n+        checkTimeouts();\n+        Status status = null;\n+        try {\n+            status = super.process();\n+        } catch (Throwable e) {\n+            LOGGER.error(e.getMessage() + \"Stack trace: \" + Arrays.toString(e.getStackTrace()));\n+        }\n+        return status;\n+    }\n+\n+    /**\n+     * Flush if timeout.\n+     */\n+    protected void checkTimeouts() {\n+        boolean timeoutFound = false;\n+        for (Map.Entry<String, NGSIArcgisFeatureTable> entry : arcgisPersistenceBackend.entrySet()) {\n+            NGSIArcgisFeatureTable table = entry.getValue();\n+            if (table.hasTimeout()) {\n+                timeoutFound = true;\n+                LOGGER.info(\"[\" + this.getName() + \"] Feature table Timeout, flushing batch. \" + entry.getKey());\n+                table.flushBatch();\n+            }\n+        }\n+        if (!timeoutFound) {\n+            LOGGER.debug(\"[\" + this.getName() + \"] No Feature table Timeouts found. Features in batch: \"\n+                    + featuresBatched());\n+        }\n+    }\n+\n+    @Override\n+    public void capRecords(NGSIBatch batch, long maxRecords) throws CygnusCappingError {\n+        // no capping\n+        LOGGER.warn(\"[\" + this.getName() + \"] Skipping capping records, just persisting it.\");\n+        try {\n+            persistBatch(batch);\n+        } catch (CygnusBadConfiguration | CygnusPersistenceError | CygnusRuntimeError | CygnusBadContextData e) {\n+            LOGGER.error(\"[\" + this.getName() + \"] Error capping Records: \" + e);\n+            throw new CygnusCappingError(e.getMessage());\n+        }\n+    } // capRecords\n+\n+    @Override\n+    public void expirateRecords(long expirationTime) throws CygnusExpiratingError {\n+        LOGGER.debug(\"[\" + this.getName() + \"] Expirating records (time=\" + expirationTime + \")\");\n+\n+    } // expirateRecords\n+\n+    /**\n+     * Persist Aggregation.\n+     * \n+     * @param aggregator\n+     * @throws CygnusRuntimeError\n+     */\n+    public void persistAggregation(NGSIArcgisAggregator aggregator) throws CygnusRuntimeError {\n+        try {\n+            List<ArcgisAggregatorDomain> aggregationList = aggregator.getListArcgisAggregatorDomain();\n+            LOGGER.debug(\"[\" + this.getName() + \"] persisting aggregation, \"\n+                    + aggregator.getListArcgisAggregatorDomain().size() + \" features.\");\n+            for (ArcgisAggregatorDomain aggregation : aggregationList) {\n+                String featureTableUrl = aggregation.getFeatureTableUrl();\n+\n+                boolean isNewFeatureTable = !arcgisPersistenceBackend.containsKey(featureTableUrl);\n+                LOGGER.debug(\"[\" + this.getName() + \"] persistAggregation - Feature table: \" + featureTableUrl\n+                        + \" is new: \" + isNewFeatureTable);\n+                ArcgisFeatureTable featureTable = getPersistenceBackend(featureTableUrl);\n+\n+                // If it's a new one, sets uniqueField value\n+                if (isNewFeatureTable) {\n+                    LOGGER.debug(\"[\" + this.getName() + \"] Created new backend for \" + featureTableUrl\n+                            + \" with uniqueField: \" + aggregation.getUniqueField());\n+                    featureTable.setUniqueField(aggregation.getUniqueField());\n+                }\n+\n+                featureTable.addToBatch(aggregation.getFeature());\n+            }\n+        } catch (CygnusRuntimeError e) {\n+            String stackTrace = ExceptionUtils.getFullStackTrace(e);\n+            LOGGER.debug(\" PersistAggregation Error: \" + stackTrace);\n+            throw (e);\n+        } catch (Exception e) {\n+            LOGGER.error(\"[\" + this.getName() + \"] Error persisting batch, \" + e.getClass().getSimpleName() + \" - \"\n+                    + e.getMessage());\n+            throw new CygnusRuntimeError(e.getMessage());\n+        }\n+    } // persistAggregation\n+\n+    /**\n+     * @author dmartinez\n+     *\n+     */\n+    public class NGSIArcgisAggregator {\n+\n+        private List<ArcgisAggregatorDomain> listArcgisAggregatorDomain = new ArrayList<ArcgisAggregatorDomain>();\n+        private boolean enableNameMappings = true;\n+        private String argisServiceUrl = \"\";\n+\n+        private NGSIArcgisAggregator() {\n+        } // ArcgisAggregator\n+\n+        /**\n+         * Constructor.\n+         * \n+         * @param argisServiceUrl\n+         * @param enableNameMappings\n+         */\n+        public NGSIArcgisAggregator(String argisServiceUrl, boolean enableNameMappings) {\n+            this();\n+            this.enableNameMappings = enableNameMappings;\n+            this.argisServiceUrl = argisServiceUrl;\n+        } // ArcgisAggregator\n+\n+        /**\n+         * \n+         * @param event\n+         */\n+        public void initialize(NGSIEvent event) {\n+        } // initialize\n+\n+        /**\n+         * @return the listArcgisAggregatorDomain\n+         */\n+        public List<ArcgisAggregatorDomain> getListArcgisAggregatorDomain() {\n+            return listArcgisAggregatorDomain;\n+        }\n+\n+        /**\n+         * Determines if input sitring is quoted or not.\n+         * \n+         * @param string\n+         * @return boolean\n+         */\n+\n+        /**\n+         * \n+         * @param event\n+         * @throws CygnusRuntimeError\n+         */\n+        public void aggregate(NGSIEvent event) throws CygnusRuntimeError {\n+            LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - ContextElement ->\" + event.getContextElement());\n+            LOGGER.debug(\"[NGSIArcgisAggregator] aggregate -  MappedCE ->\" + event.getMappedCE());\n+            LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - OriginalCE ->\" + event.getOriginalCE());\n+            LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - enableNameMappings status -> \" + enableNameMappings);\n+\n+            ContextElement contextElement = null;\n+            try {\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - creating new aggregation object.\");\n+                ArcgisAggregatorDomain aggregation = new ArcgisAggregatorDomain(LOGGER);\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - aggregation created\");\n+                Feature feature = aggregation.getFeature();\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - Feature getted\");\n+                String service = \"\";\n+                String subService = \"\";\n+                String featureTableUrl = \"\";\n+\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - Selecting context\");\n+                // get the contextElement\n+                if (!enableNameMappings) {\n+                    LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - no mappings\");\n+                    contextElement = event.getContextElement();\n+                } else {\n+                    LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - mappings\");\n+                    contextElement = event.getMappedCE();\n+                }\n+\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - Selected context ->\" + contextElement);\n+\n+                // get the getRecvTimeTs headers\n+                Map<String, String> headers = event.getHeaders();\n+\n+                for (Entry<String, String> entry : headers.entrySet()) {\n+                    LOGGER.debug(\"Header entry key --> \" + entry.getKey().toString() + \", value --> \"\n+                            + entry.getValue().toString());\n+                    if (entry.getKey() != null\n+                            && NGSIConstants.FLUME_HEADER_MAPPED_SERVICE.equals(entry.getKey().toString())) {\n+                        service = entry.getValue().toString();\n+                    } else if (entry.getKey() != null\n+                            && NGSIConstants.FLUME_HEADER_MAPPED_SERVICE_PATH.equals(entry.getKey().toString())) {\n+                        subService = entry.getValue().toString();\n+                    }\n+                } // for\n+                \n+                // Compose full url\n+                featureTableUrl = argisServiceUrl + \"/\" + service + \"/\" + subService;\n+                featureTableUrl = featureTableUrl.replaceAll(\"([^:])\\\\/\\\\/\", \"$1/\");\n+                aggregation.setFeatureTableUrl(featureTableUrl);\n+\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - featureTableUrl ->\" + featureTableUrl);\n+\n+                // iterate on all this context element attributes, if there are\n+                // attributes\n+                ArrayList<ContextAttribute> contextAttributes = contextElement.getAttributes();\n+\n+                String entityId = contextElement.getId();\n+                String entityType = contextElement.getType();\n+\n+                // Set unique filed and it's value.\n+                aggregation.setUniqueField(entityType);\n+                feature.addAttribute(entityType, entityId);\n+\n+                contextAttrToFeature(feature, contextAttributes);\n+\n+                aggregation.setFeature(feature);\n+                listArcgisAggregatorDomain.add(aggregation);\n+\n+            } catch (JSONException e) {\n+                LOGGER.error(\n+                        \"[NGSIArcgisAggregator] aggregate - Error pharsing JSON BODY \" + contextElement.toString());\n+                throw new CygnusRuntimeError(e.getMessage());\n+            } catch (Exception e) {\n+                LOGGER.error(\"[NGSIArcgisAggregator] aggregate - Unexpected Error\" + e.getMessage()\n+                        + \"\\n contextElement: \" + contextElement.toString());\n+                throw new CygnusRuntimeError(e.getMessage());\n+            }\n+\n+        } // aggregate\n+\n+        /**\n+         * \n+         * @param feature\n+         * @param contextAttributes\n+         */\n+        protected void contextAttrToFeature(Feature feature, ArrayList<ContextAttribute> contextAttributes) {\n+            if (contextAttributes == null || contextAttributes.isEmpty()) {\n+                LOGGER.debug(\n+                        \"[NGSIArcgisAggregator-contextAttrToFeature] contextAttributes NULL or empty, ignoring it. \");\n+            } else {\n+                for (ContextAttribute contextAttribute : contextAttributes) {\n+                    LOGGER.debug(\"[NGSIArcgisAggregator-contextAttrToFeature] Processing Attribute: \"\n+                            + contextAttribute.toString());\n+                    String attrName = contextAttribute.getName();\n+                    String attrType = contextAttribute.getType();\n+                    // get attribute value as is, quoted or not\n+                    JsonElement attrValue = contextAttribute.getValue();\n+\n+                    // TODO crop metadata values\n+                    LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - Atribute (name --> \" + attrName + \", type --> \"\n+                            + attrType + \", value --> \" + attrValue + \", metadata= \" + \"ignored \" + \")\");\n+\n+                    // Get Feature attributes\n+                    LOGGER.debug(\"Proccessing attribute value:  \" + attrName + \" --> \" + attrValue);\n+\n+                    jsonElementToFeatureAttr(attrName, attrType, attrValue, feature);\n+\n+                } // for\n+            } // if else\n+        }\n+    } // NGSIArcgisAggregator\n+\n+    /**\n+     * Extracts Feature attributes from JSON.\n+     * \n+     * @param attrName\n+     * @param attrType\n+     * @param attrValue\n+     * @param feature\n+     */\n+    protected void jsonElementToFeatureAttr(String attrName, String attrType, JsonElement attrValue, Feature feature) {\n+\n+        // Get Feature attributes\n+        LOGGER.debug(\"Proccessing attribute value:  \" + attrName + \" --> \" + attrValue);\n+\n+        attrType = attrType.trim().toLowerCase();\n+\n+        switch (attrType) {\n+\n+            case \"geo:json\":\n+                try {\n+                    JsonObject location = attrValue.getAsJsonObject();\n+                    if (location.get(\"type\").getAsString().equals(\"Point\")) {\n+                        JsonArray coordinates = location.get(\"coordinates\").getAsJsonArray();\n+                        double latitude = coordinates.get(0).getAsDouble();\n+                        double longitude = coordinates.get(1).getAsDouble();\n+\n+                        Point point = new Point(latitude, longitude);\n+                        feature.setGeometry(point);\n+\n+                    } else {\n+                        LOGGER.warn(\"Invalid geo:json type, only points allowed: \" + location.toString());\n+                    }\n+                } catch (Exception e) {\n+                    LOGGER.error(\"Invalid geo:json format, (sikipped): \" + attrValue.toString() + \" - Error: \"\n+                            + e.getMessage());\n+                }\n+                break;\n+            case \"boolean\":\n+                if (attrValue.isJsonPrimitive() && attrValue.getAsJsonPrimitive().isBoolean()) {\n+                    feature.addAttribute(attrName, attrValue.getAsBoolean());\n+                } else {\n+                    String strValue = attrValue.getAsString().toLowerCase().trim();\n+                    boolean result = \"true\".equals(strValue) || \"1\".equals(strValue);", "originalCommit": "a322017a039928c29edce071f799e5e6addcd4ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU0MTA3MA==", "url": "https://github.com/telefonicaid/fiware-cygnus/pull/1860#discussion_r416541070", "bodyText": "Fixed\nhttps://github.com/Stdri/fiware-cygnus/blob/df4b24bbcced902efbd41a66da84356ed8ef6435/cygnus-ngsi/src/main/java/com/telefonica/iot/cygnus/sinks/NGSIArcgisFeatureTableSink.java#L602", "author": "pmo-sdr", "createdAt": "2020-04-28T11:34:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzczMDIyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzczMTczNA==", "url": "https://github.com/telefonicaid/fiware-cygnus/pull/1860#discussion_r413731734", "bodyText": "Is it necesary that this class receives the logger object as a parametter? This inner class seems to be used only by the outer class, so it has acces to the outer class object.\nWould it be possible that this inner class usses the outer Logger object?", "author": "IvanHdzC", "createdAt": "2020-04-23T11:20:39Z", "path": "cygnus-arcgis/src/main/java/com/telefonica/iot/cygnus/sinks/NGSIArcgisFeatureTableSink.java", "diffHunk": "@@ -0,0 +1,789 @@\n+/**\n+ * Copyright 2014-2017 Telefonica Investigaci\u00f3n y Desarrollo, S.A.U\n+ *\n+ * This file is part of fiware-cygnus (FIWARE project).\n+ *\n+ * fiware-cygnus is free software: you can redistribute it and/or modify it under the terms of the GNU Affero\n+ * General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your\n+ * option) any later version.\n+ * fiware-cygnus is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the\n+ * implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n+ * for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License along with fiware-cygnus. If not, see\n+ * http://www.gnu.org/licenses/.\n+ *\n+ * For those usages not covered by the GNU Affero General Public License please contact with iot_support at tid dot es\n+ */\n+\n+package com.telefonica.iot.cygnus.sinks;\n+\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.commons.lang.exception.ExceptionUtils;\n+import org.apache.flume.Context;\n+import org.apache.flume.EventDeliveryException;\n+import org.json.JSONException;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Feature;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Point;\n+import com.telefonica.iot.cygnus.backends.arcgis.restutils.ArcgisFeatureTable;\n+import com.telefonica.iot.cygnus.backends.arcgis.restutils.NGSIArcgisFeatureTable;\n+import com.telefonica.iot.cygnus.containers.NotifyContextRequest.ContextAttribute;\n+import com.telefonica.iot.cygnus.containers.NotifyContextRequest.ContextElement;\n+import com.telefonica.iot.cygnus.errors.CygnusBadConfiguration;\n+import com.telefonica.iot.cygnus.errors.CygnusBadContextData;\n+import com.telefonica.iot.cygnus.errors.CygnusCappingError;\n+import com.telefonica.iot.cygnus.errors.CygnusExpiratingError;\n+import com.telefonica.iot.cygnus.errors.CygnusPersistenceError;\n+import com.telefonica.iot.cygnus.errors.CygnusRuntimeError;\n+import com.telefonica.iot.cygnus.interceptors.NGSIEvent;\n+import com.telefonica.iot.cygnus.log.CygnusLogger;\n+import com.telefonica.iot.cygnus.utils.NGSIConstants;\n+\n+import jodd.util.URLDecoder;\n+\n+/**\n+ *\n+ * @author dmartinez\n+ * \n+ *         Detailed documentation can be found at:\n+ *         https://github.com/telefonicaid/fiware-cygnus/blob/master/doc/flume_extensions_catalogue/ngsi_arcgis_sink.md\n+ */\n+public class NGSIArcgisFeatureTableSink extends NGSISink {\n+\n+    private static final String DEFAULT_ARCGIS_SERVICE_URL = \"localhost\";\n+    private static final String DEFAULT_GETTOKEN_URL = \"localhost\";\n+    private static final String DEFAULT_USER_NAME = \"root\";\n+    private static final String DEFAULT_PASSWORD = \"\";\n+    private static final int DEFAULT_MAX_BATCH_SIZE = 10;\n+    private static final int DEFAULT_BATCH_TIMEOUT_SECS = 60;\n+    private static final String ARCGIS_INSTANCE_NAME = \"arcgis\";\n+\n+    private static final CygnusLogger LOGGER = new CygnusLogger(NGSIArcgisFeatureTableSink.class);\n+    private String arcgisServicesUrl;\n+    private String getTokenUrl;\n+    private String userName;\n+    private String password;\n+    private int maxBatchSize;\n+    private long timeoutSecs;\n+    private static volatile Map<String, NGSIArcgisFeatureTable> arcgisPersistenceBackend;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public NGSIArcgisFeatureTableSink() {\n+        super();\n+    } // NGSIArcgisFeatureTableSink\n+\n+    /**\n+     * Gets the Argis services url. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The services url\n+     */\n+    protected String getrAcgisServicesUrl() {\n+        return arcgisServicesUrl;\n+    } // getrAcgisServicesUrl\n+\n+    /**\n+     * Gets getToken's service url.\n+     * \n+     * @return\n+     */\n+    public String getGetTokenUrl() {\n+        return getTokenUrl;\n+    }\n+\n+    /**\n+     * Sets getToken service url.\n+     * \n+     * @param getTokenUrl\n+     */\n+    public void setGetTokenUrl(String getTokenUrl) {\n+        this.getTokenUrl = getTokenUrl;\n+    }\n+\n+    /**\n+     * Gets the username. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The username\n+     */\n+    protected String getUsername() {\n+        return userName;\n+    } // getUsername\n+\n+    /**\n+     * Gets the password. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The password\n+     */\n+    protected String getPassword() {\n+        return password;\n+    } // getPassword\n+\n+    /**\n+     * \n+     */\n+    protected int featuresBatched() {\n+        int total = 0;\n+        for (Map.Entry<String, NGSIArcgisFeatureTable> entry : arcgisPersistenceBackend.entrySet()) {\n+            NGSIArcgisFeatureTable table = entry.getValue();\n+            if (table != null) {\n+                total += table.featuresBatched();\n+            }\n+        }\n+\n+        return total;\n+    }\n+\n+    /**\n+     * Returns the persistence backend. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The persistence backend\n+     * @throws CygnusRuntimeError\n+     */\n+    protected ArcgisFeatureTable getPersistenceBackend(String featureServiceUrl) throws CygnusRuntimeError {\n+\n+        if (arcgisPersistenceBackend.containsKey(featureServiceUrl)) {\n+            return arcgisPersistenceBackend.get(featureServiceUrl);\n+        } else {\n+            LOGGER.debug(\"Creating new persistenceBackend for Feature table: \" + featureServiceUrl);\n+            LOGGER.debug(\"Token url: \" + getGetTokenUrl());\n+            LOGGER.debug(\"User name: \" + getUsername());\n+            LOGGER.debug(\"Passwd: \" + getPassword());\n+            try {\n+                NGSIArcgisFeatureTable newTable = new NGSIArcgisFeatureTable(featureServiceUrl, getUsername(),\n+                        getPassword(), getGetTokenUrl(), timeoutSecs, LOGGER);\n+                newTable.setBatchAction(ArcgisFeatureTable.ADD_UPDATE_ACTION);\n+                newTable.setBatchSize(maxBatchSize);\n+\n+                if (newTable.hasError()) {\n+                    throw new CygnusRuntimeError(\"[\" + this.getName() + \"Error creating Persistence backend: \"\n+                            + newTable.getErrorCode() + \" - \" + newTable.getErrorDesc());\n+                } else {\n+                    arcgisPersistenceBackend.put(featureServiceUrl, newTable);\n+                    return newTable;\n+                }\n+            } catch (Throwable e) {\n+                String stackTrace = ExceptionUtils.getFullStackTrace(e);\n+                LOGGER.debug(stackTrace);\n+                throw new CygnusRuntimeError(\"Error creating new persistence Backend. \", e.getClass().getName(),\n+                        e.getMessage());\n+            }\n+        }\n+    } // getPersistenceBackend\n+\n+    /**\n+     * Sets the persistence backend. It is protected due to it is only required for testing purposes.\n+     * \n+     * @param persistenceBackend\n+     */\n+    protected void setPersistenceBackend(String featureServiceUrl, NGSIArcgisFeatureTable persistenceBackend) {\n+        arcgisPersistenceBackend.put(featureServiceUrl, persistenceBackend);\n+    } // setPersistenceBackend\n+\n+    @Override\n+    public void configure(Context context) {\n+        arcgisServicesUrl = context.getString(\"arcgis_service_url\", DEFAULT_ARCGIS_SERVICE_URL);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_service_url=\" + arcgisServicesUrl + \")\");\n+\n+        getTokenUrl = context.getString(\"arcgis_gettoken_url\", DEFAULT_GETTOKEN_URL);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_fearcgis_gettoken_urlature_table_url=\"\n+                + getTokenUrl + \")\");\n+\n+        userName = context.getString(\"arcgis_username\", DEFAULT_USER_NAME);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_username=\" + userName + \")\");\n+        // FIXME: Password should be read encrypted and decoded here\n+        password = context.getString(\"arcgis_password\", DEFAULT_PASSWORD);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_password=\" + password + \")\");\n+\n+        maxBatchSize = context.getInteger(\"arcgis_maxBatchSize\", DEFAULT_MAX_BATCH_SIZE);\n+        if (maxBatchSize <= 0 || maxBatchSize > 65535) {\n+            invalidConfiguration = true;\n+            LOGGER.error(\"[\" + this.getName() + \"] Invalid configuration (arcgis_maxBatchSize=\" + maxBatchSize + \") \"\n+                    + \"must be an integer between 1 and 65535\");\n+        } else {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_maxBatchSize=\" + maxBatchSize + \")\");\n+        }\n+\n+        timeoutSecs = context.getInteger(\"arcgis_timeoutSecs\", DEFAULT_BATCH_TIMEOUT_SECS);\n+        if (timeoutSecs <= 0 || timeoutSecs > 65535) {\n+            invalidConfiguration = true;\n+            LOGGER.error(\"[\" + this.getName() + \"] Invalid configuration (arcgis_timeoutSecs=\" + timeoutSecs + \") \"\n+                    + \"must be an integer between 1 and 65535\");\n+        } else {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_timeoutSecs=\" + maxBatchSize + \")\");\n+        }\n+\n+        super.configure(context);\n+    } // configure\n+\n+    @Override\n+    public void start() {\n+        try {\n+            createPersistenceBackend();\n+            LOGGER.debug(\"[\" + this.getName() + \"] Arcgis persistence backend created\");\n+        } catch (Exception e) {\n+            LOGGER.error(\"Error while creating the Arcgis persistence backend. Details=\" + e.getMessage());\n+        } // try catch\n+\n+        super.start();\n+    } // start\n+\n+    @Override\n+    public void stop() {\n+        super.stop();\n+        if (arcgisPersistenceBackend != null) {\n+            for (Map.Entry<String, NGSIArcgisFeatureTable> backend : arcgisPersistenceBackend.entrySet()) {\n+                backend.getValue().flushBatch();\n+            }\n+            arcgisPersistenceBackend.clear();\n+        }\n+    } // stop\n+\n+    /**\n+     * Initialices a lazy singleton to share among instances on JVM.\n+     */\n+    private static synchronized void createPersistenceBackend() {\n+        if (arcgisPersistenceBackend == null) {\n+            arcgisPersistenceBackend = new ConcurrentHashMap<String, NGSIArcgisFeatureTable>();\n+        }\n+    }\n+\n+    @Override\n+    void persistBatch(NGSIBatch batch)\n+            throws CygnusBadConfiguration, CygnusPersistenceError, CygnusRuntimeError, CygnusBadContextData {\n+        if (batch == null) {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Null batch, nothing to do\");\n+            return;\n+        } // if\n+\n+        try {\n+            // Iterate on the destinations\n+            batch.startIterator();\n+\n+            while (batch.hasNext()) {\n+                String destination = batch.getNextDestination();\n+                LOGGER.debug(\n+                        \"[\" + this.getName() + \"] Processing sub-batch regarding the \" + destination + \" destination\");\n+\n+                // Get the events within the current sub-batch\n+                ArrayList<NGSIEvent> events = batch.getNextEvents();\n+\n+                // Get an aggregator for this destination and initialize it\n+                NGSIArcgisAggregator aggregator = new NGSIArcgisAggregator(getrAcgisServicesUrl(), enableNameMappings);\n+                // aggregator.setService(events.get(0).getServiceForNaming(enableNameMappings));\n+                // aggregator.setServicePathForData(events.get(0).getServicePathForData());\n+                // aggregator.setServicePathForNaming(events.get(0).getServicePathForNaming(enableGrouping,\n+                // enableNameMappings));\n+                // aggregator.setEntityForNaming(events.get(0).getEntityForNaming(enableGrouping, enableNameMappings,\n+                // enableEncoding));\n+                // aggregator.setEntityType(events.get(0).getEntityTypeForNaming(enableGrouping, enableNameMappings));\n+                // aggregator.setAttribute(events.get(0).getAttributeForNaming(enableNameMappings));\n+                // aggregator.setDbName(buildDbName(aggregator.getService()));\n+                // aggregator.setTableName(buildTableName(aggregator.getServicePathForNaming(),\n+                // aggregator.getEntityForNaming(), aggregator.getEntityType(), aggregator.getAttribute()));\n+                // aggregator.setAttrNativeTypes(attrNativeTypes);\n+                // aggregator.setAttrMetadataStore(false);\n+                aggregator.initialize(events.get(0));\n+                for (NGSIEvent event : events) {\n+                    aggregator.aggregate(event);\n+                } // for\n+\n+                // Persist the aggregation\n+                persistAggregation(aggregator);\n+                batch.setNextPersisted(true);\n+\n+            } // while\n+        } catch (Exception e) {\n+            LOGGER.error(\"[\" + this.getName() + \"] Error persisting batch, \" + e.getMessage());\n+            throw new CygnusRuntimeError(e.getMessage());\n+        }\n+    } // persistBatch\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see com.telefonica.iot.cygnus.sinks.NGSISink#process()\n+     */\n+    @Override\n+    public Status process() throws EventDeliveryException {\n+        checkTimeouts();\n+        Status status = null;\n+        try {\n+            status = super.process();\n+        } catch (Throwable e) {\n+            LOGGER.error(e.getMessage() + \"Stack trace: \" + Arrays.toString(e.getStackTrace()));\n+        }\n+        return status;\n+    }\n+\n+    /**\n+     * Flush if timeout.\n+     */\n+    protected void checkTimeouts() {\n+        boolean timeoutFound = false;\n+        for (Map.Entry<String, NGSIArcgisFeatureTable> entry : arcgisPersistenceBackend.entrySet()) {\n+            NGSIArcgisFeatureTable table = entry.getValue();\n+            if (table.hasTimeout()) {\n+                timeoutFound = true;\n+                LOGGER.info(\"[\" + this.getName() + \"] Feature table Timeout, flushing batch. \" + entry.getKey());\n+                table.flushBatch();\n+            }\n+        }\n+        if (!timeoutFound) {\n+            LOGGER.debug(\"[\" + this.getName() + \"] No Feature table Timeouts found. Features in batch: \"\n+                    + featuresBatched());\n+        }\n+    }\n+\n+    @Override\n+    public void capRecords(NGSIBatch batch, long maxRecords) throws CygnusCappingError {\n+        // no capping\n+        LOGGER.warn(\"[\" + this.getName() + \"] Skipping capping records, just persisting it.\");\n+        try {\n+            persistBatch(batch);\n+        } catch (CygnusBadConfiguration | CygnusPersistenceError | CygnusRuntimeError | CygnusBadContextData e) {\n+            LOGGER.error(\"[\" + this.getName() + \"] Error capping Records: \" + e);\n+            throw new CygnusCappingError(e.getMessage());\n+        }\n+    } // capRecords\n+\n+    @Override\n+    public void expirateRecords(long expirationTime) throws CygnusExpiratingError {\n+        LOGGER.debug(\"[\" + this.getName() + \"] Expirating records (time=\" + expirationTime + \")\");\n+\n+    } // expirateRecords\n+\n+    /**\n+     * Persist Aggregation.\n+     * \n+     * @param aggregator\n+     * @throws CygnusRuntimeError\n+     */\n+    public void persistAggregation(NGSIArcgisAggregator aggregator) throws CygnusRuntimeError {\n+        try {\n+            List<ArcgisAggregatorDomain> aggregationList = aggregator.getListArcgisAggregatorDomain();\n+            LOGGER.debug(\"[\" + this.getName() + \"] persisting aggregation, \"\n+                    + aggregator.getListArcgisAggregatorDomain().size() + \" features.\");\n+            for (ArcgisAggregatorDomain aggregation : aggregationList) {\n+                String featureTableUrl = aggregation.getFeatureTableUrl();\n+\n+                boolean isNewFeatureTable = !arcgisPersistenceBackend.containsKey(featureTableUrl);\n+                LOGGER.debug(\"[\" + this.getName() + \"] persistAggregation - Feature table: \" + featureTableUrl\n+                        + \" is new: \" + isNewFeatureTable);\n+                ArcgisFeatureTable featureTable = getPersistenceBackend(featureTableUrl);\n+\n+                // If it's a new one, sets uniqueField value\n+                if (isNewFeatureTable) {\n+                    LOGGER.debug(\"[\" + this.getName() + \"] Created new backend for \" + featureTableUrl\n+                            + \" with uniqueField: \" + aggregation.getUniqueField());\n+                    featureTable.setUniqueField(aggregation.getUniqueField());\n+                }\n+\n+                featureTable.addToBatch(aggregation.getFeature());\n+            }\n+        } catch (CygnusRuntimeError e) {\n+            String stackTrace = ExceptionUtils.getFullStackTrace(e);\n+            LOGGER.debug(\" PersistAggregation Error: \" + stackTrace);\n+            throw (e);\n+        } catch (Exception e) {\n+            LOGGER.error(\"[\" + this.getName() + \"] Error persisting batch, \" + e.getClass().getSimpleName() + \" - \"\n+                    + e.getMessage());\n+            throw new CygnusRuntimeError(e.getMessage());\n+        }\n+    } // persistAggregation\n+\n+    /**\n+     * @author dmartinez\n+     *\n+     */\n+    public class NGSIArcgisAggregator {\n+\n+        private List<ArcgisAggregatorDomain> listArcgisAggregatorDomain = new ArrayList<ArcgisAggregatorDomain>();\n+        private boolean enableNameMappings = true;\n+        private String argisServiceUrl = \"\";\n+\n+        private NGSIArcgisAggregator() {\n+        } // ArcgisAggregator\n+\n+        /**\n+         * Constructor.\n+         * \n+         * @param argisServiceUrl\n+         * @param enableNameMappings\n+         */\n+        public NGSIArcgisAggregator(String argisServiceUrl, boolean enableNameMappings) {\n+            this();\n+            this.enableNameMappings = enableNameMappings;\n+            this.argisServiceUrl = argisServiceUrl;\n+        } // ArcgisAggregator\n+\n+        /**\n+         * \n+         * @param event\n+         */\n+        public void initialize(NGSIEvent event) {\n+        } // initialize\n+\n+        /**\n+         * @return the listArcgisAggregatorDomain\n+         */\n+        public List<ArcgisAggregatorDomain> getListArcgisAggregatorDomain() {\n+            return listArcgisAggregatorDomain;\n+        }\n+\n+        /**\n+         * Determines if input sitring is quoted or not.\n+         * \n+         * @param string\n+         * @return boolean\n+         */\n+\n+        /**\n+         * \n+         * @param event\n+         * @throws CygnusRuntimeError\n+         */\n+        public void aggregate(NGSIEvent event) throws CygnusRuntimeError {\n+            LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - ContextElement ->\" + event.getContextElement());\n+            LOGGER.debug(\"[NGSIArcgisAggregator] aggregate -  MappedCE ->\" + event.getMappedCE());\n+            LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - OriginalCE ->\" + event.getOriginalCE());\n+            LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - enableNameMappings status -> \" + enableNameMappings);\n+\n+            ContextElement contextElement = null;\n+            try {\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - creating new aggregation object.\");\n+                ArcgisAggregatorDomain aggregation = new ArcgisAggregatorDomain(LOGGER);\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - aggregation created\");\n+                Feature feature = aggregation.getFeature();\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - Feature getted\");\n+                String service = \"\";\n+                String subService = \"\";\n+                String featureTableUrl = \"\";\n+\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - Selecting context\");\n+                // get the contextElement\n+                if (!enableNameMappings) {\n+                    LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - no mappings\");\n+                    contextElement = event.getContextElement();\n+                } else {\n+                    LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - mappings\");\n+                    contextElement = event.getMappedCE();\n+                }\n+\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - Selected context ->\" + contextElement);\n+\n+                // get the getRecvTimeTs headers\n+                Map<String, String> headers = event.getHeaders();\n+\n+                for (Entry<String, String> entry : headers.entrySet()) {\n+                    LOGGER.debug(\"Header entry key --> \" + entry.getKey().toString() + \", value --> \"\n+                            + entry.getValue().toString());\n+                    if (entry.getKey() != null\n+                            && NGSIConstants.FLUME_HEADER_MAPPED_SERVICE.equals(entry.getKey().toString())) {\n+                        service = entry.getValue().toString();\n+                    } else if (entry.getKey() != null\n+                            && NGSIConstants.FLUME_HEADER_MAPPED_SERVICE_PATH.equals(entry.getKey().toString())) {\n+                        subService = entry.getValue().toString();\n+                    }\n+                } // for\n+                \n+                // Compose full url\n+                featureTableUrl = argisServiceUrl + \"/\" + service + \"/\" + subService;\n+                featureTableUrl = featureTableUrl.replaceAll(\"([^:])\\\\/\\\\/\", \"$1/\");\n+                aggregation.setFeatureTableUrl(featureTableUrl);\n+\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - featureTableUrl ->\" + featureTableUrl);\n+\n+                // iterate on all this context element attributes, if there are\n+                // attributes\n+                ArrayList<ContextAttribute> contextAttributes = contextElement.getAttributes();\n+\n+                String entityId = contextElement.getId();\n+                String entityType = contextElement.getType();\n+\n+                // Set unique filed and it's value.\n+                aggregation.setUniqueField(entityType);\n+                feature.addAttribute(entityType, entityId);\n+\n+                contextAttrToFeature(feature, contextAttributes);\n+\n+                aggregation.setFeature(feature);\n+                listArcgisAggregatorDomain.add(aggregation);\n+\n+            } catch (JSONException e) {\n+                LOGGER.error(\n+                        \"[NGSIArcgisAggregator] aggregate - Error pharsing JSON BODY \" + contextElement.toString());\n+                throw new CygnusRuntimeError(e.getMessage());\n+            } catch (Exception e) {\n+                LOGGER.error(\"[NGSIArcgisAggregator] aggregate - Unexpected Error\" + e.getMessage()\n+                        + \"\\n contextElement: \" + contextElement.toString());\n+                throw new CygnusRuntimeError(e.getMessage());\n+            }\n+\n+        } // aggregate\n+\n+        /**\n+         * \n+         * @param feature\n+         * @param contextAttributes\n+         */\n+        protected void contextAttrToFeature(Feature feature, ArrayList<ContextAttribute> contextAttributes) {\n+            if (contextAttributes == null || contextAttributes.isEmpty()) {\n+                LOGGER.debug(\n+                        \"[NGSIArcgisAggregator-contextAttrToFeature] contextAttributes NULL or empty, ignoring it. \");\n+            } else {\n+                for (ContextAttribute contextAttribute : contextAttributes) {\n+                    LOGGER.debug(\"[NGSIArcgisAggregator-contextAttrToFeature] Processing Attribute: \"\n+                            + contextAttribute.toString());\n+                    String attrName = contextAttribute.getName();\n+                    String attrType = contextAttribute.getType();\n+                    // get attribute value as is, quoted or not\n+                    JsonElement attrValue = contextAttribute.getValue();\n+\n+                    // TODO crop metadata values\n+                    LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - Atribute (name --> \" + attrName + \", type --> \"\n+                            + attrType + \", value --> \" + attrValue + \", metadata= \" + \"ignored \" + \")\");\n+\n+                    // Get Feature attributes\n+                    LOGGER.debug(\"Proccessing attribute value:  \" + attrName + \" --> \" + attrValue);\n+\n+                    jsonElementToFeatureAttr(attrName, attrType, attrValue, feature);\n+\n+                } // for\n+            } // if else\n+        }\n+    } // NGSIArcgisAggregator\n+\n+    /**\n+     * Extracts Feature attributes from JSON.\n+     * \n+     * @param attrName\n+     * @param attrType\n+     * @param attrValue\n+     * @param feature\n+     */\n+    protected void jsonElementToFeatureAttr(String attrName, String attrType, JsonElement attrValue, Feature feature) {\n+\n+        // Get Feature attributes\n+        LOGGER.debug(\"Proccessing attribute value:  \" + attrName + \" --> \" + attrValue);\n+\n+        attrType = attrType.trim().toLowerCase();\n+\n+        switch (attrType) {\n+\n+            case \"geo:json\":\n+                try {\n+                    JsonObject location = attrValue.getAsJsonObject();\n+                    if (location.get(\"type\").getAsString().equals(\"Point\")) {\n+                        JsonArray coordinates = location.get(\"coordinates\").getAsJsonArray();\n+                        double latitude = coordinates.get(0).getAsDouble();\n+                        double longitude = coordinates.get(1).getAsDouble();\n+\n+                        Point point = new Point(latitude, longitude);\n+                        feature.setGeometry(point);\n+\n+                    } else {\n+                        LOGGER.warn(\"Invalid geo:json type, only points allowed: \" + location.toString());\n+                    }\n+                } catch (Exception e) {\n+                    LOGGER.error(\"Invalid geo:json format, (sikipped): \" + attrValue.toString() + \" - Error: \"\n+                            + e.getMessage());\n+                }\n+                break;\n+            case \"boolean\":\n+                if (attrValue.isJsonPrimitive() && attrValue.getAsJsonPrimitive().isBoolean()) {\n+                    feature.addAttribute(attrName, attrValue.getAsBoolean());\n+                } else {\n+                    String strValue = attrValue.getAsString().toLowerCase().trim();\n+                    boolean result = \"true\".equals(strValue) || \"1\".equals(strValue);\n+                    feature.addAttribute(attrName, result);\n+                }\n+                break;\n+            case \"datetime\":\n+                String dateStr = attrValue.toString();\n+                feature.addAttribute(attrName, parseFiwareDate(dateStr));\n+                break;\n+\n+            default:\n+                // Verify if it is a string (it is into quotation marks)\n+                if (isQuoted(attrValue.toString())) {\n+                    // Insert unquoted\n+                    String strValue = URLDecoder.decode(unquote(attrValue.toString()));\n+                    feature.getAttributes().put(attrName, strValue);\n+                } else {\n+                    try {\n+                        // Try to insert as Integer\n+                        feature.addAttribute(attrName, Integer.parseInt(attrValue.toString()));\n+                    } catch (NumberFormatException e2) {\n+                        try {\n+                            // Try to insert as Double\n+                            feature.addAttribute(attrName, Double.parseDouble(attrValue.toString()));\n+                        } catch (NumberFormatException e3) {\n+                            // If all fails, insert as String\n+                            LOGGER.warn(\n+                                    \"[NGSIArcgisAggregator] Unquoted String attribute: \" + attrName + \":\" + attrValue);\n+                            String strValue = URLDecoder.decode(attrValue.toString());\n+                            feature.addAttribute(attrName, strValue);\n+                        }\n+                    }\n+                }\n+\n+        }\n+\n+    }\n+\n+    /**\n+     * Try to convert Fiware DateTime String to Date object, If it can't, input string will be returned.\n+     * \n+     * @param dateStr\n+     * @return Date Object, or String.\n+     */\n+    private Object parseFiwareDate(String dateStr) {\n+\n+        // Normalize String date\n+        dateStr = unquote(dateStr);\n+        dateStr = dateStr.replaceAll(\"Z[\\\\s]*$\", \"+00:00\");\n+        dateStr = dateStr.replaceAll(\"([+-]{1}[0-9]{1,2})[\\\\s\\\\t\\\\r\\\\n]*$\", \"$1:00\");\n+\n+        DateFormat dateFormatter = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss.SSSXXX\");\n+        try {\n+            Date date = dateFormatter.parse(dateStr);\n+            return date;\n+        } catch (ParseException e) {\n+            LOGGER.error(\"[NGSIArcgisAggregator] Unexpected DateTime format: \" + dateStr);\n+            return dateStr;\n+        }\n+    }\n+\n+    /**\n+     * Determines if input sitring is quoted or not.\n+     * \n+     * @param string\n+     * @return boolean\n+     */\n+\n+    private boolean isQuoted(String string) {\n+        return string.matches(\"^[\\\\s]*\\\\\\\"(.*)\\\\\\\"[\\\\s]*$\");\n+    }\n+\n+    /**\n+     * Unquote input string.\n+     * \n+     * @param Unquoted\n+     *            string\n+     * @return\n+     */\n+    private String unquote(String string) {\n+        return string.replaceAll(\"^[\\\\s]*\\\\\\\"(.*)\\\\\\\"[\\\\s]*$\", \"$1\");\n+    }\n+\n+    /**\n+     * \n+     * @author PMO Santander Smart City \u2013 Ayuntamiento de Santander\n+     *\n+     */\n+    public class ArcgisAggregatorDomain {\n+        private CygnusLogger LOGGER = null;\n+\n+        // string containing the data aggregation\n+        private Feature feature;\n+\n+        private String featureTableUrl;\n+\n+        private String uniqueField;\n+\n+        /**\n+           * \n+           */\n+        ArcgisAggregatorDomain(CygnusLogger logger) throws CygnusRuntimeError {", "originalCommit": "a322017a039928c29edce071f799e5e6addcd4ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgyOTY2MA==", "url": "https://github.com/telefonicaid/fiware-cygnus/pull/1860#discussion_r415829660", "bodyText": "Logger parameter removed.", "author": "pmo-sdr", "createdAt": "2020-04-27T13:50:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzczMTczNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzczMjUzMQ==", "url": "https://github.com/telefonicaid/fiware-cygnus/pull/1860#discussion_r413732531", "bodyText": "This would be better as an enum, don't you think?", "author": "IvanHdzC", "createdAt": "2020-04-23T11:21:52Z", "path": "cygnus-arcgis/src/main/java/com/telefonica/iot/cygnus/sinks/NGSIArcgisFeatureTableSink.java", "diffHunk": "@@ -0,0 +1,789 @@\n+/**\n+ * Copyright 2014-2017 Telefonica Investigaci\u00f3n y Desarrollo, S.A.U\n+ *\n+ * This file is part of fiware-cygnus (FIWARE project).\n+ *\n+ * fiware-cygnus is free software: you can redistribute it and/or modify it under the terms of the GNU Affero\n+ * General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your\n+ * option) any later version.\n+ * fiware-cygnus is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the\n+ * implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n+ * for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License along with fiware-cygnus. If not, see\n+ * http://www.gnu.org/licenses/.\n+ *\n+ * For those usages not covered by the GNU Affero General Public License please contact with iot_support at tid dot es\n+ */\n+\n+package com.telefonica.iot.cygnus.sinks;\n+\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.commons.lang.exception.ExceptionUtils;\n+import org.apache.flume.Context;\n+import org.apache.flume.EventDeliveryException;\n+import org.json.JSONException;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Feature;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Point;\n+import com.telefonica.iot.cygnus.backends.arcgis.restutils.ArcgisFeatureTable;\n+import com.telefonica.iot.cygnus.backends.arcgis.restutils.NGSIArcgisFeatureTable;\n+import com.telefonica.iot.cygnus.containers.NotifyContextRequest.ContextAttribute;\n+import com.telefonica.iot.cygnus.containers.NotifyContextRequest.ContextElement;\n+import com.telefonica.iot.cygnus.errors.CygnusBadConfiguration;\n+import com.telefonica.iot.cygnus.errors.CygnusBadContextData;\n+import com.telefonica.iot.cygnus.errors.CygnusCappingError;\n+import com.telefonica.iot.cygnus.errors.CygnusExpiratingError;\n+import com.telefonica.iot.cygnus.errors.CygnusPersistenceError;\n+import com.telefonica.iot.cygnus.errors.CygnusRuntimeError;\n+import com.telefonica.iot.cygnus.interceptors.NGSIEvent;\n+import com.telefonica.iot.cygnus.log.CygnusLogger;\n+import com.telefonica.iot.cygnus.utils.NGSIConstants;\n+\n+import jodd.util.URLDecoder;\n+\n+/**\n+ *\n+ * @author dmartinez\n+ * \n+ *         Detailed documentation can be found at:\n+ *         https://github.com/telefonicaid/fiware-cygnus/blob/master/doc/flume_extensions_catalogue/ngsi_arcgis_sink.md\n+ */\n+public class NGSIArcgisFeatureTableSink extends NGSISink {\n+\n+    private static final String DEFAULT_ARCGIS_SERVICE_URL = \"localhost\";\n+    private static final String DEFAULT_GETTOKEN_URL = \"localhost\";\n+    private static final String DEFAULT_USER_NAME = \"root\";\n+    private static final String DEFAULT_PASSWORD = \"\";\n+    private static final int DEFAULT_MAX_BATCH_SIZE = 10;\n+    private static final int DEFAULT_BATCH_TIMEOUT_SECS = 60;\n+    private static final String ARCGIS_INSTANCE_NAME = \"arcgis\";\n+\n+    private static final CygnusLogger LOGGER = new CygnusLogger(NGSIArcgisFeatureTableSink.class);\n+    private String arcgisServicesUrl;\n+    private String getTokenUrl;\n+    private String userName;\n+    private String password;\n+    private int maxBatchSize;\n+    private long timeoutSecs;\n+    private static volatile Map<String, NGSIArcgisFeatureTable> arcgisPersistenceBackend;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public NGSIArcgisFeatureTableSink() {\n+        super();\n+    } // NGSIArcgisFeatureTableSink\n+\n+    /**\n+     * Gets the Argis services url. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The services url\n+     */\n+    protected String getrAcgisServicesUrl() {\n+        return arcgisServicesUrl;\n+    } // getrAcgisServicesUrl\n+\n+    /**\n+     * Gets getToken's service url.\n+     * \n+     * @return\n+     */\n+    public String getGetTokenUrl() {\n+        return getTokenUrl;\n+    }\n+\n+    /**\n+     * Sets getToken service url.\n+     * \n+     * @param getTokenUrl\n+     */\n+    public void setGetTokenUrl(String getTokenUrl) {\n+        this.getTokenUrl = getTokenUrl;\n+    }\n+\n+    /**\n+     * Gets the username. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The username\n+     */\n+    protected String getUsername() {\n+        return userName;\n+    } // getUsername\n+\n+    /**\n+     * Gets the password. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The password\n+     */\n+    protected String getPassword() {\n+        return password;\n+    } // getPassword\n+\n+    /**\n+     * \n+     */\n+    protected int featuresBatched() {\n+        int total = 0;\n+        for (Map.Entry<String, NGSIArcgisFeatureTable> entry : arcgisPersistenceBackend.entrySet()) {\n+            NGSIArcgisFeatureTable table = entry.getValue();\n+            if (table != null) {\n+                total += table.featuresBatched();\n+            }\n+        }\n+\n+        return total;\n+    }\n+\n+    /**\n+     * Returns the persistence backend. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The persistence backend\n+     * @throws CygnusRuntimeError\n+     */\n+    protected ArcgisFeatureTable getPersistenceBackend(String featureServiceUrl) throws CygnusRuntimeError {\n+\n+        if (arcgisPersistenceBackend.containsKey(featureServiceUrl)) {\n+            return arcgisPersistenceBackend.get(featureServiceUrl);\n+        } else {\n+            LOGGER.debug(\"Creating new persistenceBackend for Feature table: \" + featureServiceUrl);\n+            LOGGER.debug(\"Token url: \" + getGetTokenUrl());\n+            LOGGER.debug(\"User name: \" + getUsername());\n+            LOGGER.debug(\"Passwd: \" + getPassword());\n+            try {\n+                NGSIArcgisFeatureTable newTable = new NGSIArcgisFeatureTable(featureServiceUrl, getUsername(),\n+                        getPassword(), getGetTokenUrl(), timeoutSecs, LOGGER);\n+                newTable.setBatchAction(ArcgisFeatureTable.ADD_UPDATE_ACTION);\n+                newTable.setBatchSize(maxBatchSize);\n+\n+                if (newTable.hasError()) {\n+                    throw new CygnusRuntimeError(\"[\" + this.getName() + \"Error creating Persistence backend: \"\n+                            + newTable.getErrorCode() + \" - \" + newTable.getErrorDesc());\n+                } else {\n+                    arcgisPersistenceBackend.put(featureServiceUrl, newTable);\n+                    return newTable;\n+                }\n+            } catch (Throwable e) {\n+                String stackTrace = ExceptionUtils.getFullStackTrace(e);\n+                LOGGER.debug(stackTrace);\n+                throw new CygnusRuntimeError(\"Error creating new persistence Backend. \", e.getClass().getName(),\n+                        e.getMessage());\n+            }\n+        }\n+    } // getPersistenceBackend\n+\n+    /**\n+     * Sets the persistence backend. It is protected due to it is only required for testing purposes.\n+     * \n+     * @param persistenceBackend\n+     */\n+    protected void setPersistenceBackend(String featureServiceUrl, NGSIArcgisFeatureTable persistenceBackend) {\n+        arcgisPersistenceBackend.put(featureServiceUrl, persistenceBackend);\n+    } // setPersistenceBackend\n+\n+    @Override\n+    public void configure(Context context) {\n+        arcgisServicesUrl = context.getString(\"arcgis_service_url\", DEFAULT_ARCGIS_SERVICE_URL);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_service_url=\" + arcgisServicesUrl + \")\");\n+\n+        getTokenUrl = context.getString(\"arcgis_gettoken_url\", DEFAULT_GETTOKEN_URL);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_fearcgis_gettoken_urlature_table_url=\"\n+                + getTokenUrl + \")\");\n+\n+        userName = context.getString(\"arcgis_username\", DEFAULT_USER_NAME);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_username=\" + userName + \")\");\n+        // FIXME: Password should be read encrypted and decoded here\n+        password = context.getString(\"arcgis_password\", DEFAULT_PASSWORD);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_password=\" + password + \")\");\n+\n+        maxBatchSize = context.getInteger(\"arcgis_maxBatchSize\", DEFAULT_MAX_BATCH_SIZE);\n+        if (maxBatchSize <= 0 || maxBatchSize > 65535) {\n+            invalidConfiguration = true;\n+            LOGGER.error(\"[\" + this.getName() + \"] Invalid configuration (arcgis_maxBatchSize=\" + maxBatchSize + \") \"\n+                    + \"must be an integer between 1 and 65535\");\n+        } else {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_maxBatchSize=\" + maxBatchSize + \")\");\n+        }\n+\n+        timeoutSecs = context.getInteger(\"arcgis_timeoutSecs\", DEFAULT_BATCH_TIMEOUT_SECS);\n+        if (timeoutSecs <= 0 || timeoutSecs > 65535) {\n+            invalidConfiguration = true;\n+            LOGGER.error(\"[\" + this.getName() + \"] Invalid configuration (arcgis_timeoutSecs=\" + timeoutSecs + \") \"\n+                    + \"must be an integer between 1 and 65535\");\n+        } else {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_timeoutSecs=\" + maxBatchSize + \")\");\n+        }\n+\n+        super.configure(context);\n+    } // configure\n+\n+    @Override\n+    public void start() {\n+        try {\n+            createPersistenceBackend();\n+            LOGGER.debug(\"[\" + this.getName() + \"] Arcgis persistence backend created\");\n+        } catch (Exception e) {\n+            LOGGER.error(\"Error while creating the Arcgis persistence backend. Details=\" + e.getMessage());\n+        } // try catch\n+\n+        super.start();\n+    } // start\n+\n+    @Override\n+    public void stop() {\n+        super.stop();\n+        if (arcgisPersistenceBackend != null) {\n+            for (Map.Entry<String, NGSIArcgisFeatureTable> backend : arcgisPersistenceBackend.entrySet()) {\n+                backend.getValue().flushBatch();\n+            }\n+            arcgisPersistenceBackend.clear();\n+        }\n+    } // stop\n+\n+    /**\n+     * Initialices a lazy singleton to share among instances on JVM.\n+     */\n+    private static synchronized void createPersistenceBackend() {\n+        if (arcgisPersistenceBackend == null) {\n+            arcgisPersistenceBackend = new ConcurrentHashMap<String, NGSIArcgisFeatureTable>();\n+        }\n+    }\n+\n+    @Override\n+    void persistBatch(NGSIBatch batch)\n+            throws CygnusBadConfiguration, CygnusPersistenceError, CygnusRuntimeError, CygnusBadContextData {\n+        if (batch == null) {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Null batch, nothing to do\");\n+            return;\n+        } // if\n+\n+        try {\n+            // Iterate on the destinations\n+            batch.startIterator();\n+\n+            while (batch.hasNext()) {\n+                String destination = batch.getNextDestination();\n+                LOGGER.debug(\n+                        \"[\" + this.getName() + \"] Processing sub-batch regarding the \" + destination + \" destination\");\n+\n+                // Get the events within the current sub-batch\n+                ArrayList<NGSIEvent> events = batch.getNextEvents();\n+\n+                // Get an aggregator for this destination and initialize it\n+                NGSIArcgisAggregator aggregator = new NGSIArcgisAggregator(getrAcgisServicesUrl(), enableNameMappings);\n+                // aggregator.setService(events.get(0).getServiceForNaming(enableNameMappings));\n+                // aggregator.setServicePathForData(events.get(0).getServicePathForData());\n+                // aggregator.setServicePathForNaming(events.get(0).getServicePathForNaming(enableGrouping,\n+                // enableNameMappings));\n+                // aggregator.setEntityForNaming(events.get(0).getEntityForNaming(enableGrouping, enableNameMappings,\n+                // enableEncoding));\n+                // aggregator.setEntityType(events.get(0).getEntityTypeForNaming(enableGrouping, enableNameMappings));\n+                // aggregator.setAttribute(events.get(0).getAttributeForNaming(enableNameMappings));\n+                // aggregator.setDbName(buildDbName(aggregator.getService()));\n+                // aggregator.setTableName(buildTableName(aggregator.getServicePathForNaming(),\n+                // aggregator.getEntityForNaming(), aggregator.getEntityType(), aggregator.getAttribute()));\n+                // aggregator.setAttrNativeTypes(attrNativeTypes);\n+                // aggregator.setAttrMetadataStore(false);\n+                aggregator.initialize(events.get(0));\n+                for (NGSIEvent event : events) {\n+                    aggregator.aggregate(event);\n+                } // for\n+\n+                // Persist the aggregation\n+                persistAggregation(aggregator);\n+                batch.setNextPersisted(true);\n+\n+            } // while\n+        } catch (Exception e) {\n+            LOGGER.error(\"[\" + this.getName() + \"] Error persisting batch, \" + e.getMessage());\n+            throw new CygnusRuntimeError(e.getMessage());\n+        }\n+    } // persistBatch\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see com.telefonica.iot.cygnus.sinks.NGSISink#process()\n+     */\n+    @Override\n+    public Status process() throws EventDeliveryException {\n+        checkTimeouts();\n+        Status status = null;\n+        try {\n+            status = super.process();\n+        } catch (Throwable e) {\n+            LOGGER.error(e.getMessage() + \"Stack trace: \" + Arrays.toString(e.getStackTrace()));\n+        }\n+        return status;\n+    }\n+\n+    /**\n+     * Flush if timeout.\n+     */\n+    protected void checkTimeouts() {\n+        boolean timeoutFound = false;\n+        for (Map.Entry<String, NGSIArcgisFeatureTable> entry : arcgisPersistenceBackend.entrySet()) {\n+            NGSIArcgisFeatureTable table = entry.getValue();\n+            if (table.hasTimeout()) {\n+                timeoutFound = true;\n+                LOGGER.info(\"[\" + this.getName() + \"] Feature table Timeout, flushing batch. \" + entry.getKey());\n+                table.flushBatch();\n+            }\n+        }\n+        if (!timeoutFound) {\n+            LOGGER.debug(\"[\" + this.getName() + \"] No Feature table Timeouts found. Features in batch: \"\n+                    + featuresBatched());\n+        }\n+    }\n+\n+    @Override\n+    public void capRecords(NGSIBatch batch, long maxRecords) throws CygnusCappingError {\n+        // no capping\n+        LOGGER.warn(\"[\" + this.getName() + \"] Skipping capping records, just persisting it.\");\n+        try {\n+            persistBatch(batch);\n+        } catch (CygnusBadConfiguration | CygnusPersistenceError | CygnusRuntimeError | CygnusBadContextData e) {\n+            LOGGER.error(\"[\" + this.getName() + \"] Error capping Records: \" + e);\n+            throw new CygnusCappingError(e.getMessage());\n+        }\n+    } // capRecords\n+\n+    @Override\n+    public void expirateRecords(long expirationTime) throws CygnusExpiratingError {\n+        LOGGER.debug(\"[\" + this.getName() + \"] Expirating records (time=\" + expirationTime + \")\");\n+\n+    } // expirateRecords\n+\n+    /**\n+     * Persist Aggregation.\n+     * \n+     * @param aggregator\n+     * @throws CygnusRuntimeError\n+     */\n+    public void persistAggregation(NGSIArcgisAggregator aggregator) throws CygnusRuntimeError {\n+        try {\n+            List<ArcgisAggregatorDomain> aggregationList = aggregator.getListArcgisAggregatorDomain();\n+            LOGGER.debug(\"[\" + this.getName() + \"] persisting aggregation, \"\n+                    + aggregator.getListArcgisAggregatorDomain().size() + \" features.\");\n+            for (ArcgisAggregatorDomain aggregation : aggregationList) {\n+                String featureTableUrl = aggregation.getFeatureTableUrl();\n+\n+                boolean isNewFeatureTable = !arcgisPersistenceBackend.containsKey(featureTableUrl);\n+                LOGGER.debug(\"[\" + this.getName() + \"] persistAggregation - Feature table: \" + featureTableUrl\n+                        + \" is new: \" + isNewFeatureTable);\n+                ArcgisFeatureTable featureTable = getPersistenceBackend(featureTableUrl);\n+\n+                // If it's a new one, sets uniqueField value\n+                if (isNewFeatureTable) {\n+                    LOGGER.debug(\"[\" + this.getName() + \"] Created new backend for \" + featureTableUrl\n+                            + \" with uniqueField: \" + aggregation.getUniqueField());\n+                    featureTable.setUniqueField(aggregation.getUniqueField());\n+                }\n+\n+                featureTable.addToBatch(aggregation.getFeature());\n+            }\n+        } catch (CygnusRuntimeError e) {\n+            String stackTrace = ExceptionUtils.getFullStackTrace(e);\n+            LOGGER.debug(\" PersistAggregation Error: \" + stackTrace);\n+            throw (e);\n+        } catch (Exception e) {\n+            LOGGER.error(\"[\" + this.getName() + \"] Error persisting batch, \" + e.getClass().getSimpleName() + \" - \"\n+                    + e.getMessage());\n+            throw new CygnusRuntimeError(e.getMessage());\n+        }\n+    } // persistAggregation\n+\n+    /**\n+     * @author dmartinez\n+     *\n+     */\n+    public class NGSIArcgisAggregator {\n+\n+        private List<ArcgisAggregatorDomain> listArcgisAggregatorDomain = new ArrayList<ArcgisAggregatorDomain>();\n+        private boolean enableNameMappings = true;\n+        private String argisServiceUrl = \"\";\n+\n+        private NGSIArcgisAggregator() {\n+        } // ArcgisAggregator\n+\n+        /**\n+         * Constructor.\n+         * \n+         * @param argisServiceUrl\n+         * @param enableNameMappings\n+         */\n+        public NGSIArcgisAggregator(String argisServiceUrl, boolean enableNameMappings) {\n+            this();\n+            this.enableNameMappings = enableNameMappings;\n+            this.argisServiceUrl = argisServiceUrl;\n+        } // ArcgisAggregator\n+\n+        /**\n+         * \n+         * @param event\n+         */\n+        public void initialize(NGSIEvent event) {\n+        } // initialize\n+\n+        /**\n+         * @return the listArcgisAggregatorDomain\n+         */\n+        public List<ArcgisAggregatorDomain> getListArcgisAggregatorDomain() {\n+            return listArcgisAggregatorDomain;\n+        }\n+\n+        /**\n+         * Determines if input sitring is quoted or not.\n+         * \n+         * @param string\n+         * @return boolean\n+         */\n+\n+        /**\n+         * \n+         * @param event\n+         * @throws CygnusRuntimeError\n+         */\n+        public void aggregate(NGSIEvent event) throws CygnusRuntimeError {\n+            LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - ContextElement ->\" + event.getContextElement());\n+            LOGGER.debug(\"[NGSIArcgisAggregator] aggregate -  MappedCE ->\" + event.getMappedCE());\n+            LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - OriginalCE ->\" + event.getOriginalCE());\n+            LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - enableNameMappings status -> \" + enableNameMappings);\n+\n+            ContextElement contextElement = null;\n+            try {\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - creating new aggregation object.\");\n+                ArcgisAggregatorDomain aggregation = new ArcgisAggregatorDomain(LOGGER);\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - aggregation created\");\n+                Feature feature = aggregation.getFeature();\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - Feature getted\");\n+                String service = \"\";\n+                String subService = \"\";\n+                String featureTableUrl = \"\";\n+\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - Selecting context\");\n+                // get the contextElement\n+                if (!enableNameMappings) {\n+                    LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - no mappings\");\n+                    contextElement = event.getContextElement();\n+                } else {\n+                    LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - mappings\");\n+                    contextElement = event.getMappedCE();\n+                }\n+\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - Selected context ->\" + contextElement);\n+\n+                // get the getRecvTimeTs headers\n+                Map<String, String> headers = event.getHeaders();\n+\n+                for (Entry<String, String> entry : headers.entrySet()) {\n+                    LOGGER.debug(\"Header entry key --> \" + entry.getKey().toString() + \", value --> \"\n+                            + entry.getValue().toString());\n+                    if (entry.getKey() != null\n+                            && NGSIConstants.FLUME_HEADER_MAPPED_SERVICE.equals(entry.getKey().toString())) {\n+                        service = entry.getValue().toString();\n+                    } else if (entry.getKey() != null\n+                            && NGSIConstants.FLUME_HEADER_MAPPED_SERVICE_PATH.equals(entry.getKey().toString())) {\n+                        subService = entry.getValue().toString();\n+                    }\n+                } // for\n+                \n+                // Compose full url\n+                featureTableUrl = argisServiceUrl + \"/\" + service + \"/\" + subService;\n+                featureTableUrl = featureTableUrl.replaceAll(\"([^:])\\\\/\\\\/\", \"$1/\");\n+                aggregation.setFeatureTableUrl(featureTableUrl);\n+\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - featureTableUrl ->\" + featureTableUrl);\n+\n+                // iterate on all this context element attributes, if there are\n+                // attributes\n+                ArrayList<ContextAttribute> contextAttributes = contextElement.getAttributes();\n+\n+                String entityId = contextElement.getId();\n+                String entityType = contextElement.getType();\n+\n+                // Set unique filed and it's value.\n+                aggregation.setUniqueField(entityType);\n+                feature.addAttribute(entityType, entityId);\n+\n+                contextAttrToFeature(feature, contextAttributes);\n+\n+                aggregation.setFeature(feature);\n+                listArcgisAggregatorDomain.add(aggregation);\n+\n+            } catch (JSONException e) {\n+                LOGGER.error(\n+                        \"[NGSIArcgisAggregator] aggregate - Error pharsing JSON BODY \" + contextElement.toString());\n+                throw new CygnusRuntimeError(e.getMessage());\n+            } catch (Exception e) {\n+                LOGGER.error(\"[NGSIArcgisAggregator] aggregate - Unexpected Error\" + e.getMessage()\n+                        + \"\\n contextElement: \" + contextElement.toString());\n+                throw new CygnusRuntimeError(e.getMessage());\n+            }\n+\n+        } // aggregate\n+\n+        /**\n+         * \n+         * @param feature\n+         * @param contextAttributes\n+         */\n+        protected void contextAttrToFeature(Feature feature, ArrayList<ContextAttribute> contextAttributes) {\n+            if (contextAttributes == null || contextAttributes.isEmpty()) {\n+                LOGGER.debug(\n+                        \"[NGSIArcgisAggregator-contextAttrToFeature] contextAttributes NULL or empty, ignoring it. \");\n+            } else {\n+                for (ContextAttribute contextAttribute : contextAttributes) {\n+                    LOGGER.debug(\"[NGSIArcgisAggregator-contextAttrToFeature] Processing Attribute: \"\n+                            + contextAttribute.toString());\n+                    String attrName = contextAttribute.getName();\n+                    String attrType = contextAttribute.getType();\n+                    // get attribute value as is, quoted or not\n+                    JsonElement attrValue = contextAttribute.getValue();\n+\n+                    // TODO crop metadata values\n+                    LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - Atribute (name --> \" + attrName + \", type --> \"\n+                            + attrType + \", value --> \" + attrValue + \", metadata= \" + \"ignored \" + \")\");\n+\n+                    // Get Feature attributes\n+                    LOGGER.debug(\"Proccessing attribute value:  \" + attrName + \" --> \" + attrValue);\n+\n+                    jsonElementToFeatureAttr(attrName, attrType, attrValue, feature);\n+\n+                } // for\n+            } // if else\n+        }\n+    } // NGSIArcgisAggregator\n+\n+    /**\n+     * Extracts Feature attributes from JSON.\n+     * \n+     * @param attrName\n+     * @param attrType\n+     * @param attrValue\n+     * @param feature\n+     */\n+    protected void jsonElementToFeatureAttr(String attrName, String attrType, JsonElement attrValue, Feature feature) {\n+\n+        // Get Feature attributes\n+        LOGGER.debug(\"Proccessing attribute value:  \" + attrName + \" --> \" + attrValue);\n+\n+        attrType = attrType.trim().toLowerCase();\n+\n+        switch (attrType) {\n+\n+            case \"geo:json\":\n+                try {\n+                    JsonObject location = attrValue.getAsJsonObject();\n+                    if (location.get(\"type\").getAsString().equals(\"Point\")) {\n+                        JsonArray coordinates = location.get(\"coordinates\").getAsJsonArray();\n+                        double latitude = coordinates.get(0).getAsDouble();\n+                        double longitude = coordinates.get(1).getAsDouble();\n+\n+                        Point point = new Point(latitude, longitude);\n+                        feature.setGeometry(point);\n+\n+                    } else {\n+                        LOGGER.warn(\"Invalid geo:json type, only points allowed: \" + location.toString());\n+                    }\n+                } catch (Exception e) {\n+                    LOGGER.error(\"Invalid geo:json format, (sikipped): \" + attrValue.toString() + \" - Error: \"\n+                            + e.getMessage());\n+                }\n+                break;\n+            case \"boolean\":", "originalCommit": "a322017a039928c29edce071f799e5e6addcd4ea", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc0MTI3MQ==", "url": "https://github.com/telefonicaid/fiware-cygnus/pull/1860#discussion_r413741271", "bodyText": "This seems to be kind of tricky. Maybe this will be throwing a lot of exceptions and it would affect the performance.\nThis also applies for Feature class attToMap method.\nCan this be done using native gson validations?\n                if (attrValue.isJsonPrimitive()){\n                    if (attrValue.getAsJsonPrimitive().isNumber()))\n                    try {\n                        feature.addAttribute(attrName, attrValue.getAsInt());\n                    }\n\n                ...", "author": "IvanHdzC", "createdAt": "2020-04-23T11:37:04Z", "path": "cygnus-arcgis/src/main/java/com/telefonica/iot/cygnus/sinks/NGSIArcgisFeatureTableSink.java", "diffHunk": "@@ -0,0 +1,789 @@\n+/**\n+ * Copyright 2014-2017 Telefonica Investigaci\u00f3n y Desarrollo, S.A.U\n+ *\n+ * This file is part of fiware-cygnus (FIWARE project).\n+ *\n+ * fiware-cygnus is free software: you can redistribute it and/or modify it under the terms of the GNU Affero\n+ * General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your\n+ * option) any later version.\n+ * fiware-cygnus is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the\n+ * implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n+ * for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License along with fiware-cygnus. If not, see\n+ * http://www.gnu.org/licenses/.\n+ *\n+ * For those usages not covered by the GNU Affero General Public License please contact with iot_support at tid dot es\n+ */\n+\n+package com.telefonica.iot.cygnus.sinks;\n+\n+import java.text.DateFormat;\n+import java.text.ParseException;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.commons.lang.exception.ExceptionUtils;\n+import org.apache.flume.Context;\n+import org.apache.flume.EventDeliveryException;\n+import org.json.JSONException;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Feature;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Point;\n+import com.telefonica.iot.cygnus.backends.arcgis.restutils.ArcgisFeatureTable;\n+import com.telefonica.iot.cygnus.backends.arcgis.restutils.NGSIArcgisFeatureTable;\n+import com.telefonica.iot.cygnus.containers.NotifyContextRequest.ContextAttribute;\n+import com.telefonica.iot.cygnus.containers.NotifyContextRequest.ContextElement;\n+import com.telefonica.iot.cygnus.errors.CygnusBadConfiguration;\n+import com.telefonica.iot.cygnus.errors.CygnusBadContextData;\n+import com.telefonica.iot.cygnus.errors.CygnusCappingError;\n+import com.telefonica.iot.cygnus.errors.CygnusExpiratingError;\n+import com.telefonica.iot.cygnus.errors.CygnusPersistenceError;\n+import com.telefonica.iot.cygnus.errors.CygnusRuntimeError;\n+import com.telefonica.iot.cygnus.interceptors.NGSIEvent;\n+import com.telefonica.iot.cygnus.log.CygnusLogger;\n+import com.telefonica.iot.cygnus.utils.NGSIConstants;\n+\n+import jodd.util.URLDecoder;\n+\n+/**\n+ *\n+ * @author dmartinez\n+ * \n+ *         Detailed documentation can be found at:\n+ *         https://github.com/telefonicaid/fiware-cygnus/blob/master/doc/flume_extensions_catalogue/ngsi_arcgis_sink.md\n+ */\n+public class NGSIArcgisFeatureTableSink extends NGSISink {\n+\n+    private static final String DEFAULT_ARCGIS_SERVICE_URL = \"localhost\";\n+    private static final String DEFAULT_GETTOKEN_URL = \"localhost\";\n+    private static final String DEFAULT_USER_NAME = \"root\";\n+    private static final String DEFAULT_PASSWORD = \"\";\n+    private static final int DEFAULT_MAX_BATCH_SIZE = 10;\n+    private static final int DEFAULT_BATCH_TIMEOUT_SECS = 60;\n+    private static final String ARCGIS_INSTANCE_NAME = \"arcgis\";\n+\n+    private static final CygnusLogger LOGGER = new CygnusLogger(NGSIArcgisFeatureTableSink.class);\n+    private String arcgisServicesUrl;\n+    private String getTokenUrl;\n+    private String userName;\n+    private String password;\n+    private int maxBatchSize;\n+    private long timeoutSecs;\n+    private static volatile Map<String, NGSIArcgisFeatureTable> arcgisPersistenceBackend;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public NGSIArcgisFeatureTableSink() {\n+        super();\n+    } // NGSIArcgisFeatureTableSink\n+\n+    /**\n+     * Gets the Argis services url. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The services url\n+     */\n+    protected String getrAcgisServicesUrl() {\n+        return arcgisServicesUrl;\n+    } // getrAcgisServicesUrl\n+\n+    /**\n+     * Gets getToken's service url.\n+     * \n+     * @return\n+     */\n+    public String getGetTokenUrl() {\n+        return getTokenUrl;\n+    }\n+\n+    /**\n+     * Sets getToken service url.\n+     * \n+     * @param getTokenUrl\n+     */\n+    public void setGetTokenUrl(String getTokenUrl) {\n+        this.getTokenUrl = getTokenUrl;\n+    }\n+\n+    /**\n+     * Gets the username. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The username\n+     */\n+    protected String getUsername() {\n+        return userName;\n+    } // getUsername\n+\n+    /**\n+     * Gets the password. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The password\n+     */\n+    protected String getPassword() {\n+        return password;\n+    } // getPassword\n+\n+    /**\n+     * \n+     */\n+    protected int featuresBatched() {\n+        int total = 0;\n+        for (Map.Entry<String, NGSIArcgisFeatureTable> entry : arcgisPersistenceBackend.entrySet()) {\n+            NGSIArcgisFeatureTable table = entry.getValue();\n+            if (table != null) {\n+                total += table.featuresBatched();\n+            }\n+        }\n+\n+        return total;\n+    }\n+\n+    /**\n+     * Returns the persistence backend. It is protected due to it is only required for testing purposes.\n+     * \n+     * @return The persistence backend\n+     * @throws CygnusRuntimeError\n+     */\n+    protected ArcgisFeatureTable getPersistenceBackend(String featureServiceUrl) throws CygnusRuntimeError {\n+\n+        if (arcgisPersistenceBackend.containsKey(featureServiceUrl)) {\n+            return arcgisPersistenceBackend.get(featureServiceUrl);\n+        } else {\n+            LOGGER.debug(\"Creating new persistenceBackend for Feature table: \" + featureServiceUrl);\n+            LOGGER.debug(\"Token url: \" + getGetTokenUrl());\n+            LOGGER.debug(\"User name: \" + getUsername());\n+            LOGGER.debug(\"Passwd: \" + getPassword());\n+            try {\n+                NGSIArcgisFeatureTable newTable = new NGSIArcgisFeatureTable(featureServiceUrl, getUsername(),\n+                        getPassword(), getGetTokenUrl(), timeoutSecs, LOGGER);\n+                newTable.setBatchAction(ArcgisFeatureTable.ADD_UPDATE_ACTION);\n+                newTable.setBatchSize(maxBatchSize);\n+\n+                if (newTable.hasError()) {\n+                    throw new CygnusRuntimeError(\"[\" + this.getName() + \"Error creating Persistence backend: \"\n+                            + newTable.getErrorCode() + \" - \" + newTable.getErrorDesc());\n+                } else {\n+                    arcgisPersistenceBackend.put(featureServiceUrl, newTable);\n+                    return newTable;\n+                }\n+            } catch (Throwable e) {\n+                String stackTrace = ExceptionUtils.getFullStackTrace(e);\n+                LOGGER.debug(stackTrace);\n+                throw new CygnusRuntimeError(\"Error creating new persistence Backend. \", e.getClass().getName(),\n+                        e.getMessage());\n+            }\n+        }\n+    } // getPersistenceBackend\n+\n+    /**\n+     * Sets the persistence backend. It is protected due to it is only required for testing purposes.\n+     * \n+     * @param persistenceBackend\n+     */\n+    protected void setPersistenceBackend(String featureServiceUrl, NGSIArcgisFeatureTable persistenceBackend) {\n+        arcgisPersistenceBackend.put(featureServiceUrl, persistenceBackend);\n+    } // setPersistenceBackend\n+\n+    @Override\n+    public void configure(Context context) {\n+        arcgisServicesUrl = context.getString(\"arcgis_service_url\", DEFAULT_ARCGIS_SERVICE_URL);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_service_url=\" + arcgisServicesUrl + \")\");\n+\n+        getTokenUrl = context.getString(\"arcgis_gettoken_url\", DEFAULT_GETTOKEN_URL);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_fearcgis_gettoken_urlature_table_url=\"\n+                + getTokenUrl + \")\");\n+\n+        userName = context.getString(\"arcgis_username\", DEFAULT_USER_NAME);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_username=\" + userName + \")\");\n+        // FIXME: Password should be read encrypted and decoded here\n+        password = context.getString(\"arcgis_password\", DEFAULT_PASSWORD);\n+        LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_password=\" + password + \")\");\n+\n+        maxBatchSize = context.getInteger(\"arcgis_maxBatchSize\", DEFAULT_MAX_BATCH_SIZE);\n+        if (maxBatchSize <= 0 || maxBatchSize > 65535) {\n+            invalidConfiguration = true;\n+            LOGGER.error(\"[\" + this.getName() + \"] Invalid configuration (arcgis_maxBatchSize=\" + maxBatchSize + \") \"\n+                    + \"must be an integer between 1 and 65535\");\n+        } else {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_maxBatchSize=\" + maxBatchSize + \")\");\n+        }\n+\n+        timeoutSecs = context.getInteger(\"arcgis_timeoutSecs\", DEFAULT_BATCH_TIMEOUT_SECS);\n+        if (timeoutSecs <= 0 || timeoutSecs > 65535) {\n+            invalidConfiguration = true;\n+            LOGGER.error(\"[\" + this.getName() + \"] Invalid configuration (arcgis_timeoutSecs=\" + timeoutSecs + \") \"\n+                    + \"must be an integer between 1 and 65535\");\n+        } else {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Reading configuration (arcgis_timeoutSecs=\" + maxBatchSize + \")\");\n+        }\n+\n+        super.configure(context);\n+    } // configure\n+\n+    @Override\n+    public void start() {\n+        try {\n+            createPersistenceBackend();\n+            LOGGER.debug(\"[\" + this.getName() + \"] Arcgis persistence backend created\");\n+        } catch (Exception e) {\n+            LOGGER.error(\"Error while creating the Arcgis persistence backend. Details=\" + e.getMessage());\n+        } // try catch\n+\n+        super.start();\n+    } // start\n+\n+    @Override\n+    public void stop() {\n+        super.stop();\n+        if (arcgisPersistenceBackend != null) {\n+            for (Map.Entry<String, NGSIArcgisFeatureTable> backend : arcgisPersistenceBackend.entrySet()) {\n+                backend.getValue().flushBatch();\n+            }\n+            arcgisPersistenceBackend.clear();\n+        }\n+    } // stop\n+\n+    /**\n+     * Initialices a lazy singleton to share among instances on JVM.\n+     */\n+    private static synchronized void createPersistenceBackend() {\n+        if (arcgisPersistenceBackend == null) {\n+            arcgisPersistenceBackend = new ConcurrentHashMap<String, NGSIArcgisFeatureTable>();\n+        }\n+    }\n+\n+    @Override\n+    void persistBatch(NGSIBatch batch)\n+            throws CygnusBadConfiguration, CygnusPersistenceError, CygnusRuntimeError, CygnusBadContextData {\n+        if (batch == null) {\n+            LOGGER.debug(\"[\" + this.getName() + \"] Null batch, nothing to do\");\n+            return;\n+        } // if\n+\n+        try {\n+            // Iterate on the destinations\n+            batch.startIterator();\n+\n+            while (batch.hasNext()) {\n+                String destination = batch.getNextDestination();\n+                LOGGER.debug(\n+                        \"[\" + this.getName() + \"] Processing sub-batch regarding the \" + destination + \" destination\");\n+\n+                // Get the events within the current sub-batch\n+                ArrayList<NGSIEvent> events = batch.getNextEvents();\n+\n+                // Get an aggregator for this destination and initialize it\n+                NGSIArcgisAggregator aggregator = new NGSIArcgisAggregator(getrAcgisServicesUrl(), enableNameMappings);\n+                // aggregator.setService(events.get(0).getServiceForNaming(enableNameMappings));\n+                // aggregator.setServicePathForData(events.get(0).getServicePathForData());\n+                // aggregator.setServicePathForNaming(events.get(0).getServicePathForNaming(enableGrouping,\n+                // enableNameMappings));\n+                // aggregator.setEntityForNaming(events.get(0).getEntityForNaming(enableGrouping, enableNameMappings,\n+                // enableEncoding));\n+                // aggregator.setEntityType(events.get(0).getEntityTypeForNaming(enableGrouping, enableNameMappings));\n+                // aggregator.setAttribute(events.get(0).getAttributeForNaming(enableNameMappings));\n+                // aggregator.setDbName(buildDbName(aggregator.getService()));\n+                // aggregator.setTableName(buildTableName(aggregator.getServicePathForNaming(),\n+                // aggregator.getEntityForNaming(), aggregator.getEntityType(), aggregator.getAttribute()));\n+                // aggregator.setAttrNativeTypes(attrNativeTypes);\n+                // aggregator.setAttrMetadataStore(false);\n+                aggregator.initialize(events.get(0));\n+                for (NGSIEvent event : events) {\n+                    aggregator.aggregate(event);\n+                } // for\n+\n+                // Persist the aggregation\n+                persistAggregation(aggregator);\n+                batch.setNextPersisted(true);\n+\n+            } // while\n+        } catch (Exception e) {\n+            LOGGER.error(\"[\" + this.getName() + \"] Error persisting batch, \" + e.getMessage());\n+            throw new CygnusRuntimeError(e.getMessage());\n+        }\n+    } // persistBatch\n+\n+    /*\n+     * (non-Javadoc)\n+     * \n+     * @see com.telefonica.iot.cygnus.sinks.NGSISink#process()\n+     */\n+    @Override\n+    public Status process() throws EventDeliveryException {\n+        checkTimeouts();\n+        Status status = null;\n+        try {\n+            status = super.process();\n+        } catch (Throwable e) {\n+            LOGGER.error(e.getMessage() + \"Stack trace: \" + Arrays.toString(e.getStackTrace()));\n+        }\n+        return status;\n+    }\n+\n+    /**\n+     * Flush if timeout.\n+     */\n+    protected void checkTimeouts() {\n+        boolean timeoutFound = false;\n+        for (Map.Entry<String, NGSIArcgisFeatureTable> entry : arcgisPersistenceBackend.entrySet()) {\n+            NGSIArcgisFeatureTable table = entry.getValue();\n+            if (table.hasTimeout()) {\n+                timeoutFound = true;\n+                LOGGER.info(\"[\" + this.getName() + \"] Feature table Timeout, flushing batch. \" + entry.getKey());\n+                table.flushBatch();\n+            }\n+        }\n+        if (!timeoutFound) {\n+            LOGGER.debug(\"[\" + this.getName() + \"] No Feature table Timeouts found. Features in batch: \"\n+                    + featuresBatched());\n+        }\n+    }\n+\n+    @Override\n+    public void capRecords(NGSIBatch batch, long maxRecords) throws CygnusCappingError {\n+        // no capping\n+        LOGGER.warn(\"[\" + this.getName() + \"] Skipping capping records, just persisting it.\");\n+        try {\n+            persistBatch(batch);\n+        } catch (CygnusBadConfiguration | CygnusPersistenceError | CygnusRuntimeError | CygnusBadContextData e) {\n+            LOGGER.error(\"[\" + this.getName() + \"] Error capping Records: \" + e);\n+            throw new CygnusCappingError(e.getMessage());\n+        }\n+    } // capRecords\n+\n+    @Override\n+    public void expirateRecords(long expirationTime) throws CygnusExpiratingError {\n+        LOGGER.debug(\"[\" + this.getName() + \"] Expirating records (time=\" + expirationTime + \")\");\n+\n+    } // expirateRecords\n+\n+    /**\n+     * Persist Aggregation.\n+     * \n+     * @param aggregator\n+     * @throws CygnusRuntimeError\n+     */\n+    public void persistAggregation(NGSIArcgisAggregator aggregator) throws CygnusRuntimeError {\n+        try {\n+            List<ArcgisAggregatorDomain> aggregationList = aggregator.getListArcgisAggregatorDomain();\n+            LOGGER.debug(\"[\" + this.getName() + \"] persisting aggregation, \"\n+                    + aggregator.getListArcgisAggregatorDomain().size() + \" features.\");\n+            for (ArcgisAggregatorDomain aggregation : aggregationList) {\n+                String featureTableUrl = aggregation.getFeatureTableUrl();\n+\n+                boolean isNewFeatureTable = !arcgisPersistenceBackend.containsKey(featureTableUrl);\n+                LOGGER.debug(\"[\" + this.getName() + \"] persistAggregation - Feature table: \" + featureTableUrl\n+                        + \" is new: \" + isNewFeatureTable);\n+                ArcgisFeatureTable featureTable = getPersistenceBackend(featureTableUrl);\n+\n+                // If it's a new one, sets uniqueField value\n+                if (isNewFeatureTable) {\n+                    LOGGER.debug(\"[\" + this.getName() + \"] Created new backend for \" + featureTableUrl\n+                            + \" with uniqueField: \" + aggregation.getUniqueField());\n+                    featureTable.setUniqueField(aggregation.getUniqueField());\n+                }\n+\n+                featureTable.addToBatch(aggregation.getFeature());\n+            }\n+        } catch (CygnusRuntimeError e) {\n+            String stackTrace = ExceptionUtils.getFullStackTrace(e);\n+            LOGGER.debug(\" PersistAggregation Error: \" + stackTrace);\n+            throw (e);\n+        } catch (Exception e) {\n+            LOGGER.error(\"[\" + this.getName() + \"] Error persisting batch, \" + e.getClass().getSimpleName() + \" - \"\n+                    + e.getMessage());\n+            throw new CygnusRuntimeError(e.getMessage());\n+        }\n+    } // persistAggregation\n+\n+    /**\n+     * @author dmartinez\n+     *\n+     */\n+    public class NGSIArcgisAggregator {\n+\n+        private List<ArcgisAggregatorDomain> listArcgisAggregatorDomain = new ArrayList<ArcgisAggregatorDomain>();\n+        private boolean enableNameMappings = true;\n+        private String argisServiceUrl = \"\";\n+\n+        private NGSIArcgisAggregator() {\n+        } // ArcgisAggregator\n+\n+        /**\n+         * Constructor.\n+         * \n+         * @param argisServiceUrl\n+         * @param enableNameMappings\n+         */\n+        public NGSIArcgisAggregator(String argisServiceUrl, boolean enableNameMappings) {\n+            this();\n+            this.enableNameMappings = enableNameMappings;\n+            this.argisServiceUrl = argisServiceUrl;\n+        } // ArcgisAggregator\n+\n+        /**\n+         * \n+         * @param event\n+         */\n+        public void initialize(NGSIEvent event) {\n+        } // initialize\n+\n+        /**\n+         * @return the listArcgisAggregatorDomain\n+         */\n+        public List<ArcgisAggregatorDomain> getListArcgisAggregatorDomain() {\n+            return listArcgisAggregatorDomain;\n+        }\n+\n+        /**\n+         * Determines if input sitring is quoted or not.\n+         * \n+         * @param string\n+         * @return boolean\n+         */\n+\n+        /**\n+         * \n+         * @param event\n+         * @throws CygnusRuntimeError\n+         */\n+        public void aggregate(NGSIEvent event) throws CygnusRuntimeError {\n+            LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - ContextElement ->\" + event.getContextElement());\n+            LOGGER.debug(\"[NGSIArcgisAggregator] aggregate -  MappedCE ->\" + event.getMappedCE());\n+            LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - OriginalCE ->\" + event.getOriginalCE());\n+            LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - enableNameMappings status -> \" + enableNameMappings);\n+\n+            ContextElement contextElement = null;\n+            try {\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - creating new aggregation object.\");\n+                ArcgisAggregatorDomain aggregation = new ArcgisAggregatorDomain(LOGGER);\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - aggregation created\");\n+                Feature feature = aggregation.getFeature();\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - Feature getted\");\n+                String service = \"\";\n+                String subService = \"\";\n+                String featureTableUrl = \"\";\n+\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - Selecting context\");\n+                // get the contextElement\n+                if (!enableNameMappings) {\n+                    LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - no mappings\");\n+                    contextElement = event.getContextElement();\n+                } else {\n+                    LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - mappings\");\n+                    contextElement = event.getMappedCE();\n+                }\n+\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - Selected context ->\" + contextElement);\n+\n+                // get the getRecvTimeTs headers\n+                Map<String, String> headers = event.getHeaders();\n+\n+                for (Entry<String, String> entry : headers.entrySet()) {\n+                    LOGGER.debug(\"Header entry key --> \" + entry.getKey().toString() + \", value --> \"\n+                            + entry.getValue().toString());\n+                    if (entry.getKey() != null\n+                            && NGSIConstants.FLUME_HEADER_MAPPED_SERVICE.equals(entry.getKey().toString())) {\n+                        service = entry.getValue().toString();\n+                    } else if (entry.getKey() != null\n+                            && NGSIConstants.FLUME_HEADER_MAPPED_SERVICE_PATH.equals(entry.getKey().toString())) {\n+                        subService = entry.getValue().toString();\n+                    }\n+                } // for\n+                \n+                // Compose full url\n+                featureTableUrl = argisServiceUrl + \"/\" + service + \"/\" + subService;\n+                featureTableUrl = featureTableUrl.replaceAll(\"([^:])\\\\/\\\\/\", \"$1/\");\n+                aggregation.setFeatureTableUrl(featureTableUrl);\n+\n+                LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - featureTableUrl ->\" + featureTableUrl);\n+\n+                // iterate on all this context element attributes, if there are\n+                // attributes\n+                ArrayList<ContextAttribute> contextAttributes = contextElement.getAttributes();\n+\n+                String entityId = contextElement.getId();\n+                String entityType = contextElement.getType();\n+\n+                // Set unique filed and it's value.\n+                aggregation.setUniqueField(entityType);\n+                feature.addAttribute(entityType, entityId);\n+\n+                contextAttrToFeature(feature, contextAttributes);\n+\n+                aggregation.setFeature(feature);\n+                listArcgisAggregatorDomain.add(aggregation);\n+\n+            } catch (JSONException e) {\n+                LOGGER.error(\n+                        \"[NGSIArcgisAggregator] aggregate - Error pharsing JSON BODY \" + contextElement.toString());\n+                throw new CygnusRuntimeError(e.getMessage());\n+            } catch (Exception e) {\n+                LOGGER.error(\"[NGSIArcgisAggregator] aggregate - Unexpected Error\" + e.getMessage()\n+                        + \"\\n contextElement: \" + contextElement.toString());\n+                throw new CygnusRuntimeError(e.getMessage());\n+            }\n+\n+        } // aggregate\n+\n+        /**\n+         * \n+         * @param feature\n+         * @param contextAttributes\n+         */\n+        protected void contextAttrToFeature(Feature feature, ArrayList<ContextAttribute> contextAttributes) {\n+            if (contextAttributes == null || contextAttributes.isEmpty()) {\n+                LOGGER.debug(\n+                        \"[NGSIArcgisAggregator-contextAttrToFeature] contextAttributes NULL or empty, ignoring it. \");\n+            } else {\n+                for (ContextAttribute contextAttribute : contextAttributes) {\n+                    LOGGER.debug(\"[NGSIArcgisAggregator-contextAttrToFeature] Processing Attribute: \"\n+                            + contextAttribute.toString());\n+                    String attrName = contextAttribute.getName();\n+                    String attrType = contextAttribute.getType();\n+                    // get attribute value as is, quoted or not\n+                    JsonElement attrValue = contextAttribute.getValue();\n+\n+                    // TODO crop metadata values\n+                    LOGGER.debug(\"[NGSIArcgisAggregator] aggregate - Atribute (name --> \" + attrName + \", type --> \"\n+                            + attrType + \", value --> \" + attrValue + \", metadata= \" + \"ignored \" + \")\");\n+\n+                    // Get Feature attributes\n+                    LOGGER.debug(\"Proccessing attribute value:  \" + attrName + \" --> \" + attrValue);\n+\n+                    jsonElementToFeatureAttr(attrName, attrType, attrValue, feature);\n+\n+                } // for\n+            } // if else\n+        }\n+    } // NGSIArcgisAggregator\n+\n+    /**\n+     * Extracts Feature attributes from JSON.\n+     * \n+     * @param attrName\n+     * @param attrType\n+     * @param attrValue\n+     * @param feature\n+     */\n+    protected void jsonElementToFeatureAttr(String attrName, String attrType, JsonElement attrValue, Feature feature) {\n+\n+        // Get Feature attributes\n+        LOGGER.debug(\"Proccessing attribute value:  \" + attrName + \" --> \" + attrValue);\n+\n+        attrType = attrType.trim().toLowerCase();\n+\n+        switch (attrType) {\n+\n+            case \"geo:json\":\n+                try {\n+                    JsonObject location = attrValue.getAsJsonObject();\n+                    if (location.get(\"type\").getAsString().equals(\"Point\")) {\n+                        JsonArray coordinates = location.get(\"coordinates\").getAsJsonArray();\n+                        double latitude = coordinates.get(0).getAsDouble();\n+                        double longitude = coordinates.get(1).getAsDouble();\n+\n+                        Point point = new Point(latitude, longitude);\n+                        feature.setGeometry(point);\n+\n+                    } else {\n+                        LOGGER.warn(\"Invalid geo:json type, only points allowed: \" + location.toString());\n+                    }\n+                } catch (Exception e) {\n+                    LOGGER.error(\"Invalid geo:json format, (sikipped): \" + attrValue.toString() + \" - Error: \"\n+                            + e.getMessage());\n+                }\n+                break;\n+            case \"boolean\":\n+                if (attrValue.isJsonPrimitive() && attrValue.getAsJsonPrimitive().isBoolean()) {\n+                    feature.addAttribute(attrName, attrValue.getAsBoolean());\n+                } else {\n+                    String strValue = attrValue.getAsString().toLowerCase().trim();\n+                    boolean result = \"true\".equals(strValue) || \"1\".equals(strValue);\n+                    feature.addAttribute(attrName, result);\n+                }\n+                break;\n+            case \"datetime\":\n+                String dateStr = attrValue.toString();\n+                feature.addAttribute(attrName, parseFiwareDate(dateStr));\n+                break;\n+\n+            default:\n+                // Verify if it is a string (it is into quotation marks)\n+                if (isQuoted(attrValue.toString())) {\n+                    // Insert unquoted\n+                    String strValue = URLDecoder.decode(unquote(attrValue.toString()));\n+                    feature.getAttributes().put(attrName, strValue);\n+                } else {\n+                    try {\n+                        // Try to insert as Integer\n+                        feature.addAttribute(attrName, Integer.parseInt(attrValue.toString()));\n+                    } catch (NumberFormatException e2) {\n+                        try {\n+                            // Try to insert as Double\n+                            feature.addAttribute(attrName, Double.parseDouble(attrValue.toString()));\n+                        } catch (NumberFormatException e3) {\n+                            // If all fails, insert as String\n+                            LOGGER.warn(\n+                                    \"[NGSIArcgisAggregator] Unquoted String attribute: \" + attrName + \":\" + attrValue);\n+                            String strValue = URLDecoder.decode(attrValue.toString());\n+                            feature.addAttribute(attrName, strValue);", "originalCommit": "a322017a039928c29edce071f799e5e6addcd4ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQzMTI3Mw==", "url": "https://github.com/telefonicaid/fiware-cygnus/pull/1860#discussion_r414431273", "bodyText": "You still need the second try/catch block to control errors while parsing Double values.\nThe point is that JsonElement.isNumber() doesn't distinguish between integer and double values.\nisJsonPrimitive and isNumber were removed for performance reasons since they make any difference.", "author": "pmo-sdr", "createdAt": "2020-04-24T09:27:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc0MTI3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgxMjIzOA==", "url": "https://github.com/telefonicaid/fiware-cygnus/pull/1860#discussion_r413812238", "bodyText": "It would be better to declare this Strings as constants. This applies to a lot of Strings on this class. At least the ones that are added into the collection.", "author": "IvanHdzC", "createdAt": "2020-04-23T13:51:37Z", "path": "cygnus-arcgis/src/main/java/com/telefonica/iot/cygnus/backends/arcgis/restutils/RestFeatureTable.java", "diffHunk": "@@ -0,0 +1,590 @@\n+/**\n+ * \n+ */\n+package com.telefonica.iot.cygnus.backends.arcgis.restutils;\n+\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.log4j.Logger;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+import com.telefonica.iot.cygnus.backends.arcgis.baselogger.BaseLoggerInterface;\n+import com.telefonica.iot.cygnus.backends.arcgis.exceptions.ArcgisException;\n+import com.telefonica.iot.cygnus.backends.arcgis.http.HttpResponse;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Credential;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Feature;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Field;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.pagination.ResultPage;\n+\n+import com.telefonica.iot.cygnus.backends.arcgis.restutils.CredentialRestApi;\n+import com.telefonica.iot.cygnus.backends.arcgis.restutils.RestFeatureTable;\n+\n+/**\n+ * @author dmartinez\n+ *\n+ */\n+public class RestFeatureTable extends CredentialRestApi {\n+\n+    static final Logger LOGGER = Logger.getLogger(RestFeatureTable.class);\n+\n+    protected URL serviceUrl;\n+\n+    // Table info\n+    private String uniqueIdField = \"\";\n+    private Map<String, Field> tableAttributes = new HashMap<String, Field>();\n+    private Map<String, Boolean> uniqueAttributes = new HashMap<String, Boolean>();\n+\n+    /**\n+     * \n+     * @param serviceUrl\n+     * @param credential\n+     * @param referer\n+     * @param expirationMins\n+     */\n+    private RestFeatureTable(URL serviceUrl, Credential credential) {\n+        super((URL) null, credential, serviceUrl.toString());\n+        this.serviceUrl = serviceUrl;\n+    }\n+\n+    private RestFeatureTable(URL serviceUrl, Credential credential,\n+            BaseLoggerInterface parentLogger) {\n+        this(serviceUrl, credential);\n+        this.parentLogger = parentLogger;\n+    }\n+\n+    /**\n+     * Constructor.\n+     * \n+     * @param url\n+     * @param credential\n+     * @throws MalformedURLException\n+     */\n+    public RestFeatureTable(String url, Credential credential, String tokenGenUrl)\n+            throws ArcgisException {\n+        super(tokenGenUrl, credential, url);\n+\n+        try {\n+            this.serviceUrl = new URL(url);\n+        } catch (MalformedURLException e) {\n+            logDebug(\"Error parsing url \" + url);\n+            throw new ArcgisException(\"Error parsing url \" + url);\n+        }\n+    }\n+\n+    /**\n+     * \n+     * @param url\n+     * @param credential\n+     * @param tokenGenUrl\n+     * @param parentLogger\n+     * @throws ArcgisException\n+     */\n+    public RestFeatureTable(String url, Credential credential, String tokenGenUrl,\n+            BaseLoggerInterface parentLogger) throws ArcgisException {\n+        this(url, credential, tokenGenUrl);\n+        this.parentLogger = parentLogger;\n+    }\n+\n+    /**\n+     * Constructor\n+     * \n+     * @param url\n+     * @param credential\n+     * @throws MalformedURLException\n+     */\n+    // public RestFeatureTable (URL url, Credential credential, URL tokenGenUrl){\n+    // super(tokenGenUrl, credential, url.toString());\n+    // this.serviceUrl = url;\n+    // }\n+\n+    /**\n+     * @return the tableAttributes\n+     */\n+    public Map<String, Field> getTableAttributes() {\n+        return tableAttributes;\n+    }\n+\n+    /**\n+     * @param tableAttributes\n+     *            the tableAttributes to set\n+     */\n+    public void setTableAttributes(Map<String, Field> tableAttributes) {\n+        this.tableAttributes = tableAttributes;\n+    }\n+\n+    /**\n+     * @return the uniqueAttributes\n+     */\n+    public Map<String, Boolean> getUniqueAttributes() {\n+        return uniqueAttributes;\n+    }\n+\n+    /**\n+     * @param uniqueAttributes\n+     *            the uniqueAttributes to set\n+     */\n+    public void setUniqueAttributes(Map<String, Boolean> uniqueAttributes) {\n+        this.uniqueAttributes = uniqueAttributes;\n+    }\n+\n+    /**\n+     * @return the uniqueIdField\n+     */\n+    public String getUniqueIdField() {\n+        return uniqueIdField;\n+    }\n+\n+    /**\n+     * @return the uniqueIdField\n+     */\n+    public boolean hasUniqueIdField() {\n+        return this.tableAttributes.containsKey(uniqueIdField);\n+    }\n+\n+    /**\n+     * \n+     * @param whereClause\n+     * @return\n+     * @throws ArcgisException\n+     */\n+    public List<Feature> getFeatureList(String whereClause) throws ArcgisException {\n+        List<Feature> resultList = new ArrayList<Feature>();\n+        ResultPage<Feature> page;\n+        int pageOffset = 0;\n+\n+        do {\n+            page = getFeatureList(whereClause, pageOffset, getCredential().getToken());\n+            pageOffset += page.getItemsSize();\n+            resultList.addAll(page.asItemsList());\n+        } while (page.hasNext());\n+\n+        return resultList;\n+    }\n+\n+    /**\n+     * \n+     * @param whereClause\n+     * @param token\n+     * @return\n+     * @throws ArcgisException\n+     */\n+    public ResultPage<Feature> getFeatureList(String whereClause, int pageOffset, String token)\n+            throws ArcgisException {\n+\n+        logDebug(\"getFeatureList - Connecting Feature table: \" + serviceUrl);\n+\n+        String responseJSON = null;\n+\n+        Map<String, String> params = new LinkedHashMap<String, String>();\n+        params.put(\"outSR\", \"{\\\"wkid\\\":4326}\");\n+        params.put(\"outFields\", \"*\");", "originalCommit": "a322017a039928c29edce071f799e5e6addcd4ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgyODY5OQ==", "url": "https://github.com/telefonicaid/fiware-cygnus/pull/1860#discussion_r415828699", "bodyText": "Fixed Stdri@042bbab", "author": "pmo-sdr", "createdAt": "2020-04-27T13:49:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgxMjIzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgxNTk3OA==", "url": "https://github.com/telefonicaid/fiware-cygnus/pull/1860#discussion_r413815978", "bodyText": "It would be better to declare this Strings as constants.", "author": "IvanHdzC", "createdAt": "2020-04-23T13:56:22Z", "path": "cygnus-arcgis/src/main/java/com/telefonica/iot/cygnus/backends/arcgis/restutils/RestAuthentication.java", "diffHunk": "@@ -0,0 +1,200 @@\n+package com.telefonica.iot.cygnus.backends.arcgis.restutils;\n+\n+import java.net.URL;\n+import java.time.Instant;\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+import com.telefonica.iot.cygnus.backends.arcgis.exceptions.ArcgisException;\n+import com.telefonica.iot.cygnus.backends.arcgis.http.HttpResponse;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Credential;\n+import com.telefonica.iot.cygnus.backends.arcgis.model.UserCredential;\n+\n+import com.telefonica.iot.cygnus.backends.arcgis.restutils.RestApi;\n+\n+/**\n+ * \n+ * @author dmartinez\n+ *\n+ */\n+public class RestAuthentication extends RestApi {\n+\n+    private static final String REQUEST_FORMAT_PARAMETER = \"pjson\";\n+    private static final String APP_RESPONSE_EXPIRES_TAG = \"expires_in\";\n+    private static final String ONLINE_RESPONSE_EXPIRES_TAG = \"expires\";\n+    private static final String ONLINE_RESPONSE_TOKEN_TAG = \"token\";\n+    private static final String APP_RESPONSE_TOKEN_TAG = \"access_token\";\n+\n+    /**\n+     * Extracts token from Json response.\n+     * \n+     * @param tokenJson\n+     * @return\n+     * @throws ArcGisException\n+     */\n+    public static String tokenFromJson(String tokenJson, String tokenTag) throws ArcgisException {\n+        String result = null;\n+        if (\"\".equals(tokenTag)) {\n+            tokenTag = ONLINE_RESPONSE_TOKEN_TAG;\n+        }\n+\n+        JsonParser parser = new JsonParser();\n+        JsonObject json = parser.parse(tokenJson).getAsJsonObject();\n+        JsonElement node = json.get(tokenTag);\n+\n+        if (node != null) {\n+            result = node.getAsString();\n+            JsonElement expirationElement = json.get(ONLINE_RESPONSE_EXPIRES_TAG);\n+\n+            if (expirationElement == null) {\n+                expirationElement = json.get(APP_RESPONSE_EXPIRES_TAG);\n+                System.out.println(\"Expiration: \" + expirationElement.getAsLong());\n+            } else {\n+                long expiration = expirationElement.getAsLong();\n+                Instant expirationInstant = Instant.ofEpochMilli(expiration);\n+                if (expirationInstant.isBefore(Instant.now())) {\n+                    // token is expired.\n+                    System.out.println(\"Token expired at \" + expirationInstant);\n+                    return null;\n+                }\n+            }\n+        } else {\n+            String errorDesc = \"Invalid token response format.\";\n+            if (json.get(\"error\") != null) {\n+                errorDesc = json.get(\"error\").toString();\n+            }\n+            throw new ArcgisException(errorDesc);\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * \n+     * @param tokenJson\n+     * @param expirationTag\n+     * @return\n+     * @throws ArcgisException\n+     */\n+    public static LocalDateTime expirationFromJson(String tokenJson, String expirationTag)\n+            throws ArcgisException {\n+        LocalDateTime result = null;\n+        if (\"\".equals(expirationTag)) {\n+            expirationTag = ONLINE_RESPONSE_EXPIRES_TAG;\n+        }\n+\n+        JsonParser parser = new JsonParser();\n+        JsonObject json = parser.parse(tokenJson).getAsJsonObject();\n+        JsonElement node = json.get(expirationTag);\n+\n+        if (node != null) {\n+            JsonElement expirationElement = json.get(ONLINE_RESPONSE_EXPIRES_TAG);\n+\n+            if (expirationElement == null) {\n+                expirationElement = json.get(APP_RESPONSE_EXPIRES_TAG);\n+            }\n+\n+            long expiration = expirationElement.getAsLong();\n+\n+            result = LocalDateTime.ofInstant(Instant.ofEpochMilli(expiration),\n+                    ZoneId.systemDefault());\n+        } else {\n+            String errorDesc = \"Invalid token response format.\";\n+            if (json.get(\"error\") != null) {\n+                errorDesc = json.get(\"error\").toString();\n+            }\n+            throw new ArcgisException(errorDesc);\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Request a token for a non OAuth token authentication.\n+     * \n+     * @param cred\n+     * @param tokenGenUrl\n+     * @param referer\n+     * @param expirationMins\n+     * @return token\n+     * @throws ArcGisException\n+     */\n+    public static Credential createUserToken(String user, String password, URL tokenGenUrl,\n+            String referer, Integer expirationMins) throws ArcgisException {\n+        String tokenJSON = null;\n+        try {\n+            Map<String, String> bodyParams = new LinkedHashMap<String, String>();\n+            bodyParams.put(\"username\", user);\n+            bodyParams.put(\"password\", password);\n+            bodyParams.put(\"referer\", referer);\n+            bodyParams.put(\"username\", user);", "originalCommit": "a322017a039928c29edce071f799e5e6addcd4ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQyNzQzOQ==", "url": "https://github.com/telefonicaid/fiware-cygnus/pull/1860#discussion_r414427439", "bodyText": "We agree. It's done.", "author": "pmo-sdr", "createdAt": "2020-04-24T09:21:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgxNTk3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgyNDA4OQ==", "url": "https://github.com/telefonicaid/fiware-cygnus/pull/1860#discussion_r413824089", "bodyText": "Is there any particular reason for you not to use the singleton logger on the project?", "author": "IvanHdzC", "createdAt": "2020-04-23T14:05:38Z", "path": "cygnus-arcgis/src/main/java/com/telefonica/iot/cygnus/backends/arcgis/restutils/NGSIArcgisFeatureTable.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/**\n+ * Copyright 2015-2017 Telefonica Investigaci\u00f3n y Desarrollo, S.A.U\n+ *\n+ * This file is part of fiware-cygnus (FIWARE project).\n+ *\n+ * fiware-cygnus is free software: you can redistribute it and/or modify it under the terms of the GNU Affero\n+ * General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your\n+ * option) any later version.\n+ * fiware-cygnus is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the\n+ * implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License\n+ * for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License along with fiware-cygnus. If not, see\n+ * http://www.gnu.org/licenses/.\n+ *\n+ * For those usages not covered by the GNU Affero General Public License please contact with iot_support at tid dot es\n+ */\n+package com.telefonica.iot.cygnus.backends.arcgis.restutils;\n+\n+import java.util.Date;\n+\n+import com.telefonica.iot.cygnus.backends.arcgis.model.Feature;\n+import com.telefonica.iot.cygnus.log.CygnusLogger;\n+\n+/**\n+ * \n+ * @author PMO Santander Smart City \u2013 Ayuntamiento de Santander\n+ *\n+ */\n+public class NGSIArcgisFeatureTable extends ArcgisFeatureTable {\n+\n+    private static final String CLASS_NAME = \"NGSIArcgisFeatureTable\";\n+    private CygnusLogger cygnusLogger;", "originalCommit": "a322017a039928c29edce071f799e5e6addcd4ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYyMDM3Nw==", "url": "https://github.com/telefonicaid/fiware-cygnus/pull/1860#discussion_r415620377", "bodyText": "This model was designed to be a PDI (kettle) plugin, and BasseLogger was the way to make logs work both Cygnus and PDI. Finally we make an specific project for cygnus, and changed logs to work Cygnus-like.", "author": "pmo-sdr", "createdAt": "2020-04-27T08:36:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgyNDA4OQ=="}], "type": "inlineReview"}, {"oid": "e5317436d0087f9869ddf1ec086871c0fa29bf76", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/e5317436d0087f9869ddf1ec086871c0fa29bf76", "message": "Remove comments", "committedDate": "2020-04-24T06:39:55Z", "type": "commit"}, {"oid": "cba2ea1a9480348e96b224fdc288479c6f15298b", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/cba2ea1a9480348e96b224fdc288479c6f15298b", "message": "Refactor Constructor", "committedDate": "2020-04-24T06:43:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQ1MTQyOA==", "url": "https://github.com/telefonicaid/fiware-cygnus/pull/1860#discussion_r414451428", "bodyText": "@dmartinezgomez can you elaborate a little bit more about your BaseLgger class. Sorry, I'm confused, about this. I understood that you modiffied the way Cygnus logs, but this is a completely new logger.", "author": "IvanHdzC", "createdAt": "2020-04-24T09:58:50Z", "path": "cygnus-arcgis/src/main/java/com/telefonica/iot/cygnus/backends/arcgis/baselogger/BaseLogger.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/**\n+ * \n+ */\n+package com.telefonica.iot.cygnus.backends.arcgis.baselogger;\n+\n+import org.apache.log4j.Logger;\n+\n+/**\n+ * @author dmartinez\n+ *\n+ */\n+public class BaseLogger implements BaseLoggerInterface {\n+\n+    static final Logger LOGGER = Logger.getLogger(BaseLogger.class);", "originalCommit": "e5317436d0087f9869ddf1ec086871c0fa29bf76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYwNzg0Mg==", "url": "https://github.com/telefonicaid/fiware-cygnus/pull/1860#discussion_r415607842", "bodyText": "This model was designed to be a PDI (kettle) plugin, and BasseLogger was the way to make logs work both Cygnus and PDI.  Finally we make an specific project for cygnus, and changed logs to work Cygnus-like.", "author": "pmo-sdr", "createdAt": "2020-04-27T08:18:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQ1MTQyOA=="}], "type": "inlineReview"}, {"oid": "c8d4419a2cf00210fcaf968d5ed96375ce2828cd", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/c8d4419a2cf00210fcaf968d5ed96375ce2828cd", "message": "Proyect Structure change", "committedDate": "2020-04-27T07:34:34Z", "type": "commit"}, {"oid": "7b77d6717d128d3a5ecaa7c6ba6f26d236321e82", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/7b77d6717d128d3a5ecaa7c6ba6f26d236321e82", "message": "Fixing Tests and logs", "committedDate": "2020-04-27T11:26:34Z", "type": "commit"}, {"oid": "62b23807ae47e94a3251975a449b245e789f6774", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/62b23807ae47e94a3251975a449b245e789f6774", "message": "Fix compile problems", "committedDate": "2020-04-27T13:25:57Z", "type": "commit"}, {"oid": "042bbabcf92945d2fd086d5bf08b1f3370182e84", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/042bbabcf92945d2fd086d5bf08b1f3370182e84", "message": "Strings to Constants", "committedDate": "2020-04-27T13:48:02Z", "type": "commit"}, {"oid": "3dc730b2de021cea6c995b54deedc528100bc74c", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/3dc730b2de021cea6c995b54deedc528100bc74c", "message": "Remove cygnus-arcgis folder", "committedDate": "2020-04-28T06:21:30Z", "type": "commit"}, {"oid": "1941e81055e2d76d0b345879d0e68e244f0d241b", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/1941e81055e2d76d0b345879d0e68e244f0d241b", "message": "New checkstyle removed", "committedDate": "2020-04-28T11:20:48Z", "type": "commit"}, {"oid": "df4b24bbcced902efbd41a66da84356ed8ef6435", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/df4b24bbcced902efbd41a66da84356ed8ef6435", "message": "initialize method removed", "committedDate": "2020-04-28T11:30:28Z", "type": "commit"}, {"oid": "fe5fcb3f02d99d5606e5d541dd3cd833f3651e49", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/fe5fcb3f02d99d5606e5d541dd3cd833f3651e49", "message": "String to constants", "committedDate": "2020-04-28T13:48:08Z", "type": "commit"}, {"oid": "575feb80050e5834efda5b1adf4f7a02f144f3e1", "url": "https://github.com/telefonicaid/fiware-cygnus/commit/575feb80050e5834efda5b1adf4f7a02f144f3e1", "message": "Clean imports", "committedDate": "2020-04-30T06:11:55Z", "type": "commit"}]}