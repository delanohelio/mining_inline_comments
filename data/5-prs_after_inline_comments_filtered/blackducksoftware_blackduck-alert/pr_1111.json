{"pr_number": 1111, "pr_title": "Initial oauth support", "pr_createdAt": "2020-08-12T18:06:02Z", "pr_url": "https://github.com/blackducksoftware/blackduck-alert/pull/1111", "timeline": [{"oid": "de738fac94fd4fd176a7a49895ed9adf77688f64", "url": "https://github.com/blackducksoftware/blackduck-alert/commit/de738fac94fd4fd176a7a49895ed9adf77688f64", "message": "feat: Initial implementation for OAuth with Azure.", "committedDate": "2020-08-10T15:35:00Z", "type": "commit"}, {"oid": "add2005bfceb2cf4e363379fb779d78af4e57f1e", "url": "https://github.com/blackducksoftware/blackduck-alert/commit/add2005bfceb2cf4e363379fb779d78af4e57f1e", "message": "feat: Implement the changes to redirect to Azure.", "committedDate": "2020-08-10T19:56:41Z", "type": "commit"}, {"oid": "360e10dd1a6709057c2c7bc34d9070c3ab8fcaa2", "url": "https://github.com/blackducksoftware/blackduck-alert/commit/360e10dd1a6709057c2c7bc34d9070c3ab8fcaa2", "message": "chore: Add debug statements and a TODO.", "committedDate": "2020-08-11T13:08:47Z", "type": "commit"}, {"oid": "b08ae0add3cd3b712137bdec4d61ff2a7cc8563d", "url": "https://github.com/blackducksoftware/blackduck-alert/commit/b08ae0add3cd3b712137bdec4d61ff2a7cc8563d", "message": "Merge remote-tracking branch 'origin/master' into ps_oauth_support", "committedDate": "2020-08-11T13:09:07Z", "type": "commit"}, {"oid": "dae3a9ddbe2efa2648408a665de8f2d825768d86", "url": "https://github.com/blackducksoftware/blackduck-alert/commit/dae3a9ddbe2efa2648408a665de8f2d825768d86", "message": "refactor: Generate a unique key for the state.", "committedDate": "2020-08-11T13:53:05Z", "type": "commit"}, {"oid": "cec0e9b2635aff2835415d8fca7ae1177e0ba04e", "url": "https://github.com/blackducksoftware/blackduck-alert/commit/cec0e9b2635aff2835415d8fca7ae1177e0ba04e", "message": "Merge remote-tracking branch 'origin/master' into ps_oauth_support", "committedDate": "2020-08-11T14:32:16Z", "type": "commit"}, {"oid": "3f3ef1cba22c91e5547e83f3ac42212567cadbad", "url": "https://github.com/blackducksoftware/blackduck-alert/commit/3f3ef1cba22c91e5547e83f3ac42212567cadbad", "message": "Merge remote-tracking branch 'origin/6.2.0' into ps_oauth_support", "committedDate": "2020-08-11T17:15:20Z", "type": "commit"}, {"oid": "9b08631a49842810479649d60621f9a0bb4191a9", "url": "https://github.com/blackducksoftware/blackduck-alert/commit/9b08631a49842810479649d60621f9a0bb4191a9", "message": "refactor: Update versioning and remove redirect code.", "committedDate": "2020-08-11T17:18:50Z", "type": "commit"}, {"oid": "96b88e74bee819adb73ff54cb51152b370395f34", "url": "https://github.com/blackducksoftware/blackduck-alert/commit/96b88e74bee819adb73ff54cb51152b370395f34", "message": "Merge remote-tracking branch 'origin/6.2.0' into ps_oauth_support", "committedDate": "2020-08-11T17:58:29Z", "type": "commit"}, {"oid": "4aedc95ece6674ed78fe5af613bedd3deb37593d", "url": "https://github.com/blackducksoftware/blackduck-alert/commit/4aedc95ece6674ed78fe5af613bedd3deb37593d", "message": "feat: Add components to create a customer oauth button.", "committedDate": "2020-08-11T19:18:35Z", "type": "commit"}, {"oid": "9722efdad968427d76d0f260c4eedc22f7b90f23", "url": "https://github.com/blackducksoftware/blackduck-alert/commit/9722efdad968427d76d0f260c4eedc22f7b90f23", "message": "feat: Implement endpoint behavior", "committedDate": "2020-08-11T19:45:25Z", "type": "commit"}, {"oid": "60ebe36f927e77343933bacc7825f18d7289e2ff", "url": "https://github.com/blackducksoftware/blackduck-alert/commit/60ebe36f927e77343933bacc7825f18d7289e2ff", "message": "feat: have the UI redirect to the Azure login.", "committedDate": "2020-08-11T20:01:07Z", "type": "commit"}, {"oid": "f17af628ae19709bee231c0abe464422d93fc4f9", "url": "https://github.com/blackducksoftware/blackduck-alert/commit/f17af628ae19709bee231c0abe464422d93fc4f9", "message": "refactor: add todos and redirect to the azure channel UI config.", "committedDate": "2020-08-12T14:43:48Z", "type": "commit"}, {"oid": "a2feeee2bb7f3500137f75b735d9bd7baa9ada32", "url": "https://github.com/blackducksoftware/blackduck-alert/commit/a2feeee2bb7f3500137f75b735d9bd7baa9ada32", "message": "refactor: Update the endpoint fields to display field errors.", "committedDate": "2020-08-12T16:52:13Z", "type": "commit"}, {"oid": "e0f70b926e2292d00631c02c59e9c4c73fc1c217", "url": "https://github.com/blackducksoftware/blackduck-alert/commit/e0f70b926e2292d00631c02c59e9c4c73fc1c217", "message": "refactor: Add a checkmark if OAuth is authenticated.", "committedDate": "2020-08-12T17:55:21Z", "type": "commit"}, {"oid": "a62b397d8fb5f419dcfc7c1ed74c4112fe654bca", "url": "https://github.com/blackducksoftware/blackduck-alert/commit/a62b397d8fb5f419dcfc7c1ed74c4112fe654bca", "message": "Merge remote-tracking branch 'origin/6.2.0' into ps_oauth_support", "committedDate": "2020-08-12T18:03:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ0OTYwMg==", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1111#discussion_r469449602", "bodyText": "I think it might be best if we make this extend CustomEndpoint so that we aren't bound to return a String later. We should start moving away from ResponseEntity<String> IMO. If we do that, we can just return a OAuthEndpointResponse rather than wrapping and manually serializing with Gson.", "author": "gkillough", "createdAt": "2020-08-12T18:14:02Z", "path": "alert-common/src/main/java/com/synopsys/integration/alert/common/descriptor/config/field/endpoint/oauth/OAuthCustomEndpoint.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/**\n+ * alert-common\n+ *\n+ * Copyright (c) 2020 Synopsys, Inc.\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.synopsys.integration.alert.common.descriptor.config.field.endpoint.oauth;\n+\n+import org.springframework.http.ResponseEntity;\n+\n+import com.google.gson.Gson;\n+import com.synopsys.integration.alert.common.action.CustomEndpointManager;\n+import com.synopsys.integration.alert.common.descriptor.config.field.endpoint.ButtonCustomEndpoint;\n+import com.synopsys.integration.alert.common.exception.AlertException;\n+import com.synopsys.integration.alert.common.rest.HttpServletContentWrapper;\n+import com.synopsys.integration.alert.common.rest.ResponseFactory;\n+import com.synopsys.integration.alert.common.rest.model.FieldModel;\n+\n+public abstract class OAuthCustomEndpoint extends ButtonCustomEndpoint {", "originalCommit": "a62b397d8fb5f419dcfc7c1ed74c4112fe654bca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ1NzAyOA==", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1111#discussion_r469457028", "bodyText": "We will need to refactor the CustomEndpointManager and CustomEndpoint.  Although CustomEndpoint uses a generic R the method always returns a Response", "author": "psantos1113", "createdAt": "2020-08-12T18:27:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ0OTYwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ1MjI2Mw==", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1111#discussion_r469452263", "bodyText": "Why not isEmpty()? SonarCloud?", "author": "gkillough", "createdAt": "2020-08-12T18:18:47Z", "path": "alert-common/src/main/java/com/synopsys/integration/alert/common/rest/ProxyManager.java", "diffHunk": "@@ -113,4 +115,16 @@ public ProxyInfo createProxyInfo() throws IllegalArgumentException {\n         return settingsConfiguration.flatMap(configurationModel -> configurationModel.getField(key)).flatMap(ConfigurationFieldModel::getFieldValue);\n     }\n \n+    public Proxy createProxy() {\n+        if (!getProxyHost().isPresent()) {", "originalCommit": "a62b397d8fb5f419dcfc7c1ed74c4112fe654bca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ1MjY2Ng==", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1111#discussion_r469452666", "bodyText": "Yeah not sure if the SonarCloud issues has been updated yet.", "author": "psantos1113", "createdAt": "2020-08-12T18:19:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ1MjI2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ1OTEyNw==", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1111#discussion_r469459127", "bodyText": "This should probably be logged at DEBUG.", "author": "gkillough", "createdAt": "2020-08-12T18:30:51Z", "path": "src/main/java/com/synopsys/integration/alert/channel/azure/boards/web/AzureBoardsCustomEndpoint.java", "diffHunk": "@@ -22,37 +22,118 @@\n  */\n package com.synopsys.integration.alert.channel.azure.boards.web;\n \n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+import org.apache.commons.lang.StringUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.http.ResponseEntity;\n+import org.springframework.http.HttpStatus;\n import org.springframework.stereotype.Component;\n \n-import com.synopsys.integration.alert.channel.azure.boards.AzureBoardsChannelKey;\n+import com.google.gson.Gson;\n import com.synopsys.integration.alert.channel.azure.boards.descriptor.AzureBoardsDescriptor;\n+import com.synopsys.integration.alert.common.AlertProperties;\n import com.synopsys.integration.alert.common.action.CustomEndpointManager;\n-import com.synopsys.integration.alert.common.descriptor.config.field.endpoint.ButtonCustomEndpoint;\n+import com.synopsys.integration.alert.common.descriptor.config.field.endpoint.oauth.OAuthCustomEndpoint;\n+import com.synopsys.integration.alert.common.descriptor.config.field.endpoint.oauth.OAuthEndpointResponse;\n+import com.synopsys.integration.alert.common.exception.AlertDatabaseConstraintException;\n+import com.synopsys.integration.alert.common.exception.AlertException;\n+import com.synopsys.integration.alert.common.persistence.accessor.ConfigurationAccessor;\n+import com.synopsys.integration.alert.common.persistence.accessor.FieldAccessor;\n+import com.synopsys.integration.alert.common.persistence.model.ConfigurationFieldModel;\n+import com.synopsys.integration.alert.common.persistence.model.ConfigurationModel;\n+import com.synopsys.integration.alert.common.persistence.util.ConfigurationFieldModelConverter;\n import com.synopsys.integration.alert.common.rest.HttpServletContentWrapper;\n import com.synopsys.integration.alert.common.rest.ResponseFactory;\n import com.synopsys.integration.alert.common.rest.model.FieldModel;\n+import com.synopsys.integration.azure.boards.common.http.AzureHttpServiceFactory;\n \n @Component\n-public class AzureBoardsCustomEndpoint extends ButtonCustomEndpoint {\n+public class AzureBoardsCustomEndpoint extends OAuthCustomEndpoint {\n     private final Logger logger = LoggerFactory.getLogger(AzureBoardsCustomEndpoint.class);\n \n-    private final AzureBoardsChannelKey azureBoardsChannelKey;\n-    private final ResponseFactory responseFactory;\n+    private final AlertProperties alertProperties;\n+    private final ConfigurationAccessor configurationAccessor;\n+    private final ConfigurationFieldModelConverter modelConverter;\n \n-    @Autowired\n-    public AzureBoardsCustomEndpoint(AzureBoardsChannelKey azureBoardsChannelKey, CustomEndpointManager customEndpointManager, ResponseFactory responseFactory) throws Exception {\n-        super(AzureBoardsDescriptor.KEY_OAUTH, customEndpointManager);\n-        this.azureBoardsChannelKey = azureBoardsChannelKey;\n-        this.responseFactory = responseFactory;\n+    public AzureBoardsCustomEndpoint(CustomEndpointManager customEndpointManager, ResponseFactory responseFactory, Gson gson, AlertProperties alertProperties, ConfigurationAccessor configurationAccessor,\n+        ConfigurationFieldModelConverter modelConverter)\n+        throws AlertException {\n+        super(AzureBoardsDescriptor.KEY_OAUTH, customEndpointManager, responseFactory, gson);\n+        this.alertProperties = alertProperties;\n+        this.configurationAccessor = configurationAccessor;\n+        this.modelConverter = modelConverter;\n     }\n \n     @Override\n-    public ResponseEntity<String> createResponse(FieldModel fieldModel, HttpServletContentWrapper servletContentWrapper) {\n-        return responseFactory.createOkResponse(\"\", \"Placeholder Message\"); //FIXME this message should fixed once the Oauth is implemented.\n+    protected OAuthEndpointResponse createOAuthResponse(FieldModel fieldModel, HttpServletContentWrapper servletContentWrapper) {\n+        try {\n+            FieldAccessor fieldAccessor = createFieldAccessor(fieldModel);\n+            Optional<String> clientId = fieldAccessor.getString(AzureBoardsDescriptor.KEY_CLIENT_ID);\n+            if (!clientId.isPresent()) {\n+                return new OAuthEndpointResponse(HttpStatus.BAD_REQUEST.value(), false, \"\", \"client id not found.\");\n+            }\n+            Optional<String> alertServerUrl = alertProperties.getServerUrl();\n+\n+            if (!alertServerUrl.isPresent()) {\n+                return new OAuthEndpointResponse(HttpStatus.BAD_REQUEST.value(), false, \"\", \"Could not determine the alert server url for the callback.\");\n+            }\n+            String authUrl = createAuthURL(clientId.get(), alertServerUrl.get());\n+            logger.info(\"Authenticating Azure OAuth URL: \" + authUrl);", "originalCommit": "a62b397d8fb5f419dcfc7c1ed74c4112fe654bca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ2Mjc4MQ==", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1111#discussion_r469462781", "bodyText": "Could we do something like this?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            Optional<ConfigurationModel> configurationFieldModel = configurationAccessor.getConfigurationById(Long.valueOf(fieldModel.getId()));\n          \n          \n            \n                            configurationFieldModel.ifPresent(model -> fields.putAll(model.getCopyOfKeyToFieldMap()));\n          \n          \n            \n                            configurationAccessor.getConfigurationById(Long.valueOf(fieldModel.getId()))\n          \n          \n            \n                            .map(ConfigurationModel::getCopyOfKeyToFieldMap)\n          \n          \n            \n                            .ifPresent(fields::putAll);", "author": "gkillough", "createdAt": "2020-08-12T18:37:20Z", "path": "src/main/java/com/synopsys/integration/alert/channel/azure/boards/web/AzureBoardsCustomEndpoint.java", "diffHunk": "@@ -22,37 +22,118 @@\n  */\n package com.synopsys.integration.alert.channel.azure.boards.web;\n \n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+import org.apache.commons.lang.StringUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.http.ResponseEntity;\n+import org.springframework.http.HttpStatus;\n import org.springframework.stereotype.Component;\n \n-import com.synopsys.integration.alert.channel.azure.boards.AzureBoardsChannelKey;\n+import com.google.gson.Gson;\n import com.synopsys.integration.alert.channel.azure.boards.descriptor.AzureBoardsDescriptor;\n+import com.synopsys.integration.alert.common.AlertProperties;\n import com.synopsys.integration.alert.common.action.CustomEndpointManager;\n-import com.synopsys.integration.alert.common.descriptor.config.field.endpoint.ButtonCustomEndpoint;\n+import com.synopsys.integration.alert.common.descriptor.config.field.endpoint.oauth.OAuthCustomEndpoint;\n+import com.synopsys.integration.alert.common.descriptor.config.field.endpoint.oauth.OAuthEndpointResponse;\n+import com.synopsys.integration.alert.common.exception.AlertDatabaseConstraintException;\n+import com.synopsys.integration.alert.common.exception.AlertException;\n+import com.synopsys.integration.alert.common.persistence.accessor.ConfigurationAccessor;\n+import com.synopsys.integration.alert.common.persistence.accessor.FieldAccessor;\n+import com.synopsys.integration.alert.common.persistence.model.ConfigurationFieldModel;\n+import com.synopsys.integration.alert.common.persistence.model.ConfigurationModel;\n+import com.synopsys.integration.alert.common.persistence.util.ConfigurationFieldModelConverter;\n import com.synopsys.integration.alert.common.rest.HttpServletContentWrapper;\n import com.synopsys.integration.alert.common.rest.ResponseFactory;\n import com.synopsys.integration.alert.common.rest.model.FieldModel;\n+import com.synopsys.integration.azure.boards.common.http.AzureHttpServiceFactory;\n \n @Component\n-public class AzureBoardsCustomEndpoint extends ButtonCustomEndpoint {\n+public class AzureBoardsCustomEndpoint extends OAuthCustomEndpoint {\n     private final Logger logger = LoggerFactory.getLogger(AzureBoardsCustomEndpoint.class);\n \n-    private final AzureBoardsChannelKey azureBoardsChannelKey;\n-    private final ResponseFactory responseFactory;\n+    private final AlertProperties alertProperties;\n+    private final ConfigurationAccessor configurationAccessor;\n+    private final ConfigurationFieldModelConverter modelConverter;\n \n-    @Autowired\n-    public AzureBoardsCustomEndpoint(AzureBoardsChannelKey azureBoardsChannelKey, CustomEndpointManager customEndpointManager, ResponseFactory responseFactory) throws Exception {\n-        super(AzureBoardsDescriptor.KEY_OAUTH, customEndpointManager);\n-        this.azureBoardsChannelKey = azureBoardsChannelKey;\n-        this.responseFactory = responseFactory;\n+    public AzureBoardsCustomEndpoint(CustomEndpointManager customEndpointManager, ResponseFactory responseFactory, Gson gson, AlertProperties alertProperties, ConfigurationAccessor configurationAccessor,\n+        ConfigurationFieldModelConverter modelConverter)\n+        throws AlertException {\n+        super(AzureBoardsDescriptor.KEY_OAUTH, customEndpointManager, responseFactory, gson);\n+        this.alertProperties = alertProperties;\n+        this.configurationAccessor = configurationAccessor;\n+        this.modelConverter = modelConverter;\n     }\n \n     @Override\n-    public ResponseEntity<String> createResponse(FieldModel fieldModel, HttpServletContentWrapper servletContentWrapper) {\n-        return responseFactory.createOkResponse(\"\", \"Placeholder Message\"); //FIXME this message should fixed once the Oauth is implemented.\n+    protected OAuthEndpointResponse createOAuthResponse(FieldModel fieldModel, HttpServletContentWrapper servletContentWrapper) {\n+        try {\n+            FieldAccessor fieldAccessor = createFieldAccessor(fieldModel);\n+            Optional<String> clientId = fieldAccessor.getString(AzureBoardsDescriptor.KEY_CLIENT_ID);\n+            if (!clientId.isPresent()) {\n+                return new OAuthEndpointResponse(HttpStatus.BAD_REQUEST.value(), false, \"\", \"client id not found.\");\n+            }\n+            Optional<String> alertServerUrl = alertProperties.getServerUrl();\n+\n+            if (!alertServerUrl.isPresent()) {\n+                return new OAuthEndpointResponse(HttpStatus.BAD_REQUEST.value(), false, \"\", \"Could not determine the alert server url for the callback.\");\n+            }\n+            String authUrl = createAuthURL(clientId.get(), alertServerUrl.get());\n+            logger.info(\"Authenticating Azure OAuth URL: \" + authUrl);\n+            //TODO add code to check if Alert has already been authorized to set the authenticated flag.\n+\n+            return new OAuthEndpointResponse(HttpStatus.OK.value(), false, authUrl, \"\");\n+\n+        } catch (Exception ex) {\n+            logger.error(\"Error activating Azure Boards\", ex);\n+            return new OAuthEndpointResponse(HttpStatus.INTERNAL_SERVER_ERROR.value(), false, \"\", \"Error activating azure oauth.\");\n+        }\n+    }\n+\n+    private FieldAccessor createFieldAccessor(FieldModel fieldModel) {\n+        Map<String, ConfigurationFieldModel> fields = new HashMap<>();\n+        try {\n+            fields.putAll(modelConverter.convertToConfigurationFieldModelMap(fieldModel));\n+            // check if a configuration exists because the client id is a sensitive field and won't have a value in the field model if updating.\n+            if (StringUtils.isNotBlank(fieldModel.getId())) {\n+                Optional<ConfigurationModel> configurationFieldModel = configurationAccessor.getConfigurationById(Long.valueOf(fieldModel.getId()));\n+                configurationFieldModel.ifPresent(model -> fields.putAll(model.getCopyOfKeyToFieldMap()));", "originalCommit": "a62b397d8fb5f419dcfc7c1ed74c4112fe654bca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ2NDQzMA==", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1111#discussion_r469464430", "bodyText": "Is the 300 here the max length? We should probably throw an exception if we violate that constraint if it's required by Microsoft.", "author": "gkillough", "createdAt": "2020-08-12T18:40:16Z", "path": "src/main/java/com/synopsys/integration/alert/channel/azure/boards/web/AzureBoardsCustomEndpoint.java", "diffHunk": "@@ -22,37 +22,118 @@\n  */\n package com.synopsys.integration.alert.channel.azure.boards.web;\n \n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+import org.apache.commons.lang.StringUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.http.ResponseEntity;\n+import org.springframework.http.HttpStatus;\n import org.springframework.stereotype.Component;\n \n-import com.synopsys.integration.alert.channel.azure.boards.AzureBoardsChannelKey;\n+import com.google.gson.Gson;\n import com.synopsys.integration.alert.channel.azure.boards.descriptor.AzureBoardsDescriptor;\n+import com.synopsys.integration.alert.common.AlertProperties;\n import com.synopsys.integration.alert.common.action.CustomEndpointManager;\n-import com.synopsys.integration.alert.common.descriptor.config.field.endpoint.ButtonCustomEndpoint;\n+import com.synopsys.integration.alert.common.descriptor.config.field.endpoint.oauth.OAuthCustomEndpoint;\n+import com.synopsys.integration.alert.common.descriptor.config.field.endpoint.oauth.OAuthEndpointResponse;\n+import com.synopsys.integration.alert.common.exception.AlertDatabaseConstraintException;\n+import com.synopsys.integration.alert.common.exception.AlertException;\n+import com.synopsys.integration.alert.common.persistence.accessor.ConfigurationAccessor;\n+import com.synopsys.integration.alert.common.persistence.accessor.FieldAccessor;\n+import com.synopsys.integration.alert.common.persistence.model.ConfigurationFieldModel;\n+import com.synopsys.integration.alert.common.persistence.model.ConfigurationModel;\n+import com.synopsys.integration.alert.common.persistence.util.ConfigurationFieldModelConverter;\n import com.synopsys.integration.alert.common.rest.HttpServletContentWrapper;\n import com.synopsys.integration.alert.common.rest.ResponseFactory;\n import com.synopsys.integration.alert.common.rest.model.FieldModel;\n+import com.synopsys.integration.azure.boards.common.http.AzureHttpServiceFactory;\n \n @Component\n-public class AzureBoardsCustomEndpoint extends ButtonCustomEndpoint {\n+public class AzureBoardsCustomEndpoint extends OAuthCustomEndpoint {\n     private final Logger logger = LoggerFactory.getLogger(AzureBoardsCustomEndpoint.class);\n \n-    private final AzureBoardsChannelKey azureBoardsChannelKey;\n-    private final ResponseFactory responseFactory;\n+    private final AlertProperties alertProperties;\n+    private final ConfigurationAccessor configurationAccessor;\n+    private final ConfigurationFieldModelConverter modelConverter;\n \n-    @Autowired\n-    public AzureBoardsCustomEndpoint(AzureBoardsChannelKey azureBoardsChannelKey, CustomEndpointManager customEndpointManager, ResponseFactory responseFactory) throws Exception {\n-        super(AzureBoardsDescriptor.KEY_OAUTH, customEndpointManager);\n-        this.azureBoardsChannelKey = azureBoardsChannelKey;\n-        this.responseFactory = responseFactory;\n+    public AzureBoardsCustomEndpoint(CustomEndpointManager customEndpointManager, ResponseFactory responseFactory, Gson gson, AlertProperties alertProperties, ConfigurationAccessor configurationAccessor,\n+        ConfigurationFieldModelConverter modelConverter)\n+        throws AlertException {\n+        super(AzureBoardsDescriptor.KEY_OAUTH, customEndpointManager, responseFactory, gson);\n+        this.alertProperties = alertProperties;\n+        this.configurationAccessor = configurationAccessor;\n+        this.modelConverter = modelConverter;\n     }\n \n     @Override\n-    public ResponseEntity<String> createResponse(FieldModel fieldModel, HttpServletContentWrapper servletContentWrapper) {\n-        return responseFactory.createOkResponse(\"\", \"Placeholder Message\"); //FIXME this message should fixed once the Oauth is implemented.\n+    protected OAuthEndpointResponse createOAuthResponse(FieldModel fieldModel, HttpServletContentWrapper servletContentWrapper) {\n+        try {\n+            FieldAccessor fieldAccessor = createFieldAccessor(fieldModel);\n+            Optional<String> clientId = fieldAccessor.getString(AzureBoardsDescriptor.KEY_CLIENT_ID);\n+            if (!clientId.isPresent()) {\n+                return new OAuthEndpointResponse(HttpStatus.BAD_REQUEST.value(), false, \"\", \"client id not found.\");\n+            }\n+            Optional<String> alertServerUrl = alertProperties.getServerUrl();\n+\n+            if (!alertServerUrl.isPresent()) {\n+                return new OAuthEndpointResponse(HttpStatus.BAD_REQUEST.value(), false, \"\", \"Could not determine the alert server url for the callback.\");\n+            }\n+            String authUrl = createAuthURL(clientId.get(), alertServerUrl.get());\n+            logger.info(\"Authenticating Azure OAuth URL: \" + authUrl);\n+            //TODO add code to check if Alert has already been authorized to set the authenticated flag.\n+\n+            return new OAuthEndpointResponse(HttpStatus.OK.value(), false, authUrl, \"\");\n+\n+        } catch (Exception ex) {\n+            logger.error(\"Error activating Azure Boards\", ex);\n+            return new OAuthEndpointResponse(HttpStatus.INTERNAL_SERVER_ERROR.value(), false, \"\", \"Error activating azure oauth.\");\n+        }\n+    }\n+\n+    private FieldAccessor createFieldAccessor(FieldModel fieldModel) {\n+        Map<String, ConfigurationFieldModel> fields = new HashMap<>();\n+        try {\n+            fields.putAll(modelConverter.convertToConfigurationFieldModelMap(fieldModel));\n+            // check if a configuration exists because the client id is a sensitive field and won't have a value in the field model if updating.\n+            if (StringUtils.isNotBlank(fieldModel.getId())) {\n+                Optional<ConfigurationModel> configurationFieldModel = configurationAccessor.getConfigurationById(Long.valueOf(fieldModel.getId()));\n+                configurationFieldModel.ifPresent(model -> fields.putAll(model.getCopyOfKeyToFieldMap()));\n+            }\n+        } catch (AlertDatabaseConstraintException ex) {\n+            logger.error(\"Error creating field acessor for Azure authentication\", ex);\n+        }\n+        return new FieldAccessor(fields);\n     }\n \n+    private String createAuthURL(String clientId, String alertServerUrl) {\n+        StringBuilder authUrlBuilder = new StringBuilder(300);", "originalCommit": "a62b397d8fb5f419dcfc7c1ed74c4112fe654bca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ3MjUxOA==", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1111#discussion_r469472518", "bodyText": "The 300 isn't a max length.  It's a best guess for initial capacity.  My test URL was 237 characters long. This is so the StringBuilder allocates a string with enough capacity initially instead of resizing more than once with the append calls.  it will resize dynamically like an ArrayList.  So this just makes it perform a little better. The string underneath is backed by a character array. So the character array will be created with a good enough size to avoid resizing during the append calls.", "author": "psantos1113", "createdAt": "2020-08-12T18:54:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ2NDQzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ2NTkyMw==", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1111#discussion_r469465923", "bodyText": "Same thought here. If this is the length requirement, we should be more explicit about it.", "author": "gkillough", "createdAt": "2020-08-12T18:42:59Z", "path": "src/main/java/com/synopsys/integration/alert/channel/azure/boards/web/AzureBoardsCustomEndpoint.java", "diffHunk": "@@ -22,37 +22,118 @@\n  */\n package com.synopsys.integration.alert.channel.azure.boards.web;\n \n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+import org.apache.commons.lang.StringUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.http.ResponseEntity;\n+import org.springframework.http.HttpStatus;\n import org.springframework.stereotype.Component;\n \n-import com.synopsys.integration.alert.channel.azure.boards.AzureBoardsChannelKey;\n+import com.google.gson.Gson;\n import com.synopsys.integration.alert.channel.azure.boards.descriptor.AzureBoardsDescriptor;\n+import com.synopsys.integration.alert.common.AlertProperties;\n import com.synopsys.integration.alert.common.action.CustomEndpointManager;\n-import com.synopsys.integration.alert.common.descriptor.config.field.endpoint.ButtonCustomEndpoint;\n+import com.synopsys.integration.alert.common.descriptor.config.field.endpoint.oauth.OAuthCustomEndpoint;\n+import com.synopsys.integration.alert.common.descriptor.config.field.endpoint.oauth.OAuthEndpointResponse;\n+import com.synopsys.integration.alert.common.exception.AlertDatabaseConstraintException;\n+import com.synopsys.integration.alert.common.exception.AlertException;\n+import com.synopsys.integration.alert.common.persistence.accessor.ConfigurationAccessor;\n+import com.synopsys.integration.alert.common.persistence.accessor.FieldAccessor;\n+import com.synopsys.integration.alert.common.persistence.model.ConfigurationFieldModel;\n+import com.synopsys.integration.alert.common.persistence.model.ConfigurationModel;\n+import com.synopsys.integration.alert.common.persistence.util.ConfigurationFieldModelConverter;\n import com.synopsys.integration.alert.common.rest.HttpServletContentWrapper;\n import com.synopsys.integration.alert.common.rest.ResponseFactory;\n import com.synopsys.integration.alert.common.rest.model.FieldModel;\n+import com.synopsys.integration.azure.boards.common.http.AzureHttpServiceFactory;\n \n @Component\n-public class AzureBoardsCustomEndpoint extends ButtonCustomEndpoint {\n+public class AzureBoardsCustomEndpoint extends OAuthCustomEndpoint {\n     private final Logger logger = LoggerFactory.getLogger(AzureBoardsCustomEndpoint.class);\n \n-    private final AzureBoardsChannelKey azureBoardsChannelKey;\n-    private final ResponseFactory responseFactory;\n+    private final AlertProperties alertProperties;\n+    private final ConfigurationAccessor configurationAccessor;\n+    private final ConfigurationFieldModelConverter modelConverter;\n \n-    @Autowired\n-    public AzureBoardsCustomEndpoint(AzureBoardsChannelKey azureBoardsChannelKey, CustomEndpointManager customEndpointManager, ResponseFactory responseFactory) throws Exception {\n-        super(AzureBoardsDescriptor.KEY_OAUTH, customEndpointManager);\n-        this.azureBoardsChannelKey = azureBoardsChannelKey;\n-        this.responseFactory = responseFactory;\n+    public AzureBoardsCustomEndpoint(CustomEndpointManager customEndpointManager, ResponseFactory responseFactory, Gson gson, AlertProperties alertProperties, ConfigurationAccessor configurationAccessor,\n+        ConfigurationFieldModelConverter modelConverter)\n+        throws AlertException {\n+        super(AzureBoardsDescriptor.KEY_OAUTH, customEndpointManager, responseFactory, gson);\n+        this.alertProperties = alertProperties;\n+        this.configurationAccessor = configurationAccessor;\n+        this.modelConverter = modelConverter;\n     }\n \n     @Override\n-    public ResponseEntity<String> createResponse(FieldModel fieldModel, HttpServletContentWrapper servletContentWrapper) {\n-        return responseFactory.createOkResponse(\"\", \"Placeholder Message\"); //FIXME this message should fixed once the Oauth is implemented.\n+    protected OAuthEndpointResponse createOAuthResponse(FieldModel fieldModel, HttpServletContentWrapper servletContentWrapper) {\n+        try {\n+            FieldAccessor fieldAccessor = createFieldAccessor(fieldModel);\n+            Optional<String> clientId = fieldAccessor.getString(AzureBoardsDescriptor.KEY_CLIENT_ID);\n+            if (!clientId.isPresent()) {\n+                return new OAuthEndpointResponse(HttpStatus.BAD_REQUEST.value(), false, \"\", \"client id not found.\");\n+            }\n+            Optional<String> alertServerUrl = alertProperties.getServerUrl();\n+\n+            if (!alertServerUrl.isPresent()) {\n+                return new OAuthEndpointResponse(HttpStatus.BAD_REQUEST.value(), false, \"\", \"Could not determine the alert server url for the callback.\");\n+            }\n+            String authUrl = createAuthURL(clientId.get(), alertServerUrl.get());\n+            logger.info(\"Authenticating Azure OAuth URL: \" + authUrl);\n+            //TODO add code to check if Alert has already been authorized to set the authenticated flag.\n+\n+            return new OAuthEndpointResponse(HttpStatus.OK.value(), false, authUrl, \"\");\n+\n+        } catch (Exception ex) {\n+            logger.error(\"Error activating Azure Boards\", ex);\n+            return new OAuthEndpointResponse(HttpStatus.INTERNAL_SERVER_ERROR.value(), false, \"\", \"Error activating azure oauth.\");\n+        }\n+    }\n+\n+    private FieldAccessor createFieldAccessor(FieldModel fieldModel) {\n+        Map<String, ConfigurationFieldModel> fields = new HashMap<>();\n+        try {\n+            fields.putAll(modelConverter.convertToConfigurationFieldModelMap(fieldModel));\n+            // check if a configuration exists because the client id is a sensitive field and won't have a value in the field model if updating.\n+            if (StringUtils.isNotBlank(fieldModel.getId())) {\n+                Optional<ConfigurationModel> configurationFieldModel = configurationAccessor.getConfigurationById(Long.valueOf(fieldModel.getId()));\n+                configurationFieldModel.ifPresent(model -> fields.putAll(model.getCopyOfKeyToFieldMap()));\n+            }\n+        } catch (AlertDatabaseConstraintException ex) {\n+            logger.error(\"Error creating field acessor for Azure authentication\", ex);\n+        }\n+        return new FieldAccessor(fields);\n     }\n \n+    private String createAuthURL(String clientId, String alertServerUrl) {\n+        StringBuilder authUrlBuilder = new StringBuilder(300);\n+        authUrlBuilder.append(AzureHttpServiceFactory.DEFAULT_AUTHORIZATION_URL);\n+        authUrlBuilder.append(createQueryString(clientId, alertServerUrl));\n+        return authUrlBuilder.toString();\n+    }\n+\n+    private String createQueryString(String clientId, String alertServerUrl) {\n+        String authorizationUrl = String.format(\"%s%s\", alertServerUrl, AzureOauthCallbackController.AZURE_OAUTH_CALLBACK_PATH);\n+        StringBuilder queryBuilder = new StringBuilder(250);", "originalCommit": "a62b397d8fb5f419dcfc7c1ed74c4112fe654bca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ3MDE4NQ==", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1111#discussion_r469470185", "bodyText": "The 250 isn't a max length.  It's a best guess for initial capacity.  My test URL was 237 characters long. This is so the StringBuilder allocates a string with enough capacity initially instead of resizing more than once with the append calls.  it will resize dynamically like an ArrayList.  So this just makes it perform a little better.  The string underneath is backed by a character array.  So the character array will be created with a good enough size to avoid resizing during the append calls.", "author": "psantos1113", "createdAt": "2020-08-12T18:50:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ2NTkyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ2NjQwNQ==", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1111#discussion_r469466405", "bodyText": "Should this first string start with '?', or is that from a previous constant?", "author": "gkillough", "createdAt": "2020-08-12T18:43:51Z", "path": "src/main/java/com/synopsys/integration/alert/channel/azure/boards/web/AzureBoardsCustomEndpoint.java", "diffHunk": "@@ -22,37 +22,118 @@\n  */\n package com.synopsys.integration.alert.channel.azure.boards.web;\n \n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+import org.apache.commons.lang.StringUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.http.ResponseEntity;\n+import org.springframework.http.HttpStatus;\n import org.springframework.stereotype.Component;\n \n-import com.synopsys.integration.alert.channel.azure.boards.AzureBoardsChannelKey;\n+import com.google.gson.Gson;\n import com.synopsys.integration.alert.channel.azure.boards.descriptor.AzureBoardsDescriptor;\n+import com.synopsys.integration.alert.common.AlertProperties;\n import com.synopsys.integration.alert.common.action.CustomEndpointManager;\n-import com.synopsys.integration.alert.common.descriptor.config.field.endpoint.ButtonCustomEndpoint;\n+import com.synopsys.integration.alert.common.descriptor.config.field.endpoint.oauth.OAuthCustomEndpoint;\n+import com.synopsys.integration.alert.common.descriptor.config.field.endpoint.oauth.OAuthEndpointResponse;\n+import com.synopsys.integration.alert.common.exception.AlertDatabaseConstraintException;\n+import com.synopsys.integration.alert.common.exception.AlertException;\n+import com.synopsys.integration.alert.common.persistence.accessor.ConfigurationAccessor;\n+import com.synopsys.integration.alert.common.persistence.accessor.FieldAccessor;\n+import com.synopsys.integration.alert.common.persistence.model.ConfigurationFieldModel;\n+import com.synopsys.integration.alert.common.persistence.model.ConfigurationModel;\n+import com.synopsys.integration.alert.common.persistence.util.ConfigurationFieldModelConverter;\n import com.synopsys.integration.alert.common.rest.HttpServletContentWrapper;\n import com.synopsys.integration.alert.common.rest.ResponseFactory;\n import com.synopsys.integration.alert.common.rest.model.FieldModel;\n+import com.synopsys.integration.azure.boards.common.http.AzureHttpServiceFactory;\n \n @Component\n-public class AzureBoardsCustomEndpoint extends ButtonCustomEndpoint {\n+public class AzureBoardsCustomEndpoint extends OAuthCustomEndpoint {\n     private final Logger logger = LoggerFactory.getLogger(AzureBoardsCustomEndpoint.class);\n \n-    private final AzureBoardsChannelKey azureBoardsChannelKey;\n-    private final ResponseFactory responseFactory;\n+    private final AlertProperties alertProperties;\n+    private final ConfigurationAccessor configurationAccessor;\n+    private final ConfigurationFieldModelConverter modelConverter;\n \n-    @Autowired\n-    public AzureBoardsCustomEndpoint(AzureBoardsChannelKey azureBoardsChannelKey, CustomEndpointManager customEndpointManager, ResponseFactory responseFactory) throws Exception {\n-        super(AzureBoardsDescriptor.KEY_OAUTH, customEndpointManager);\n-        this.azureBoardsChannelKey = azureBoardsChannelKey;\n-        this.responseFactory = responseFactory;\n+    public AzureBoardsCustomEndpoint(CustomEndpointManager customEndpointManager, ResponseFactory responseFactory, Gson gson, AlertProperties alertProperties, ConfigurationAccessor configurationAccessor,\n+        ConfigurationFieldModelConverter modelConverter)\n+        throws AlertException {\n+        super(AzureBoardsDescriptor.KEY_OAUTH, customEndpointManager, responseFactory, gson);\n+        this.alertProperties = alertProperties;\n+        this.configurationAccessor = configurationAccessor;\n+        this.modelConverter = modelConverter;\n     }\n \n     @Override\n-    public ResponseEntity<String> createResponse(FieldModel fieldModel, HttpServletContentWrapper servletContentWrapper) {\n-        return responseFactory.createOkResponse(\"\", \"Placeholder Message\"); //FIXME this message should fixed once the Oauth is implemented.\n+    protected OAuthEndpointResponse createOAuthResponse(FieldModel fieldModel, HttpServletContentWrapper servletContentWrapper) {\n+        try {\n+            FieldAccessor fieldAccessor = createFieldAccessor(fieldModel);\n+            Optional<String> clientId = fieldAccessor.getString(AzureBoardsDescriptor.KEY_CLIENT_ID);\n+            if (!clientId.isPresent()) {\n+                return new OAuthEndpointResponse(HttpStatus.BAD_REQUEST.value(), false, \"\", \"client id not found.\");\n+            }\n+            Optional<String> alertServerUrl = alertProperties.getServerUrl();\n+\n+            if (!alertServerUrl.isPresent()) {\n+                return new OAuthEndpointResponse(HttpStatus.BAD_REQUEST.value(), false, \"\", \"Could not determine the alert server url for the callback.\");\n+            }\n+            String authUrl = createAuthURL(clientId.get(), alertServerUrl.get());\n+            logger.info(\"Authenticating Azure OAuth URL: \" + authUrl);\n+            //TODO add code to check if Alert has already been authorized to set the authenticated flag.\n+\n+            return new OAuthEndpointResponse(HttpStatus.OK.value(), false, authUrl, \"\");\n+\n+        } catch (Exception ex) {\n+            logger.error(\"Error activating Azure Boards\", ex);\n+            return new OAuthEndpointResponse(HttpStatus.INTERNAL_SERVER_ERROR.value(), false, \"\", \"Error activating azure oauth.\");\n+        }\n+    }\n+\n+    private FieldAccessor createFieldAccessor(FieldModel fieldModel) {\n+        Map<String, ConfigurationFieldModel> fields = new HashMap<>();\n+        try {\n+            fields.putAll(modelConverter.convertToConfigurationFieldModelMap(fieldModel));\n+            // check if a configuration exists because the client id is a sensitive field and won't have a value in the field model if updating.\n+            if (StringUtils.isNotBlank(fieldModel.getId())) {\n+                Optional<ConfigurationModel> configurationFieldModel = configurationAccessor.getConfigurationById(Long.valueOf(fieldModel.getId()));\n+                configurationFieldModel.ifPresent(model -> fields.putAll(model.getCopyOfKeyToFieldMap()));\n+            }\n+        } catch (AlertDatabaseConstraintException ex) {\n+            logger.error(\"Error creating field acessor for Azure authentication\", ex);\n+        }\n+        return new FieldAccessor(fields);\n     }\n \n+    private String createAuthURL(String clientId, String alertServerUrl) {\n+        StringBuilder authUrlBuilder = new StringBuilder(300);\n+        authUrlBuilder.append(AzureHttpServiceFactory.DEFAULT_AUTHORIZATION_URL);\n+        authUrlBuilder.append(createQueryString(clientId, alertServerUrl));\n+        return authUrlBuilder.toString();\n+    }\n+\n+    private String createQueryString(String clientId, String alertServerUrl) {\n+        String authorizationUrl = String.format(\"%s%s\", alertServerUrl, AzureOauthCallbackController.AZURE_OAUTH_CALLBACK_PATH);\n+        StringBuilder queryBuilder = new StringBuilder(250);\n+        queryBuilder.append(\"&client_id=\");", "originalCommit": "a62b397d8fb5f419dcfc7c1ed74c4112fe654bca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ3MTIxNQ==", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1111#discussion_r469471215", "bodyText": "The URL for authorization appends the assertion query parameter and I had to fix the URL constant to change it from '&' to '?'  See line 116 'AzureHttpServiceFactory.DEFAULT_AUTHORIZATION_URL'", "author": "psantos1113", "createdAt": "2020-08-12T18:52:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ2NjQwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ2Njc4NQ==", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1111#discussion_r469466785", "bodyText": "I believe we need to request more scopes than this. They are listed on the confluence design page.", "author": "gkillough", "createdAt": "2020-08-12T18:44:31Z", "path": "src/main/java/com/synopsys/integration/alert/channel/azure/boards/web/AzureBoardsCustomEndpoint.java", "diffHunk": "@@ -22,37 +22,118 @@\n  */\n package com.synopsys.integration.alert.channel.azure.boards.web;\n \n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+import org.apache.commons.lang.StringUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.http.ResponseEntity;\n+import org.springframework.http.HttpStatus;\n import org.springframework.stereotype.Component;\n \n-import com.synopsys.integration.alert.channel.azure.boards.AzureBoardsChannelKey;\n+import com.google.gson.Gson;\n import com.synopsys.integration.alert.channel.azure.boards.descriptor.AzureBoardsDescriptor;\n+import com.synopsys.integration.alert.common.AlertProperties;\n import com.synopsys.integration.alert.common.action.CustomEndpointManager;\n-import com.synopsys.integration.alert.common.descriptor.config.field.endpoint.ButtonCustomEndpoint;\n+import com.synopsys.integration.alert.common.descriptor.config.field.endpoint.oauth.OAuthCustomEndpoint;\n+import com.synopsys.integration.alert.common.descriptor.config.field.endpoint.oauth.OAuthEndpointResponse;\n+import com.synopsys.integration.alert.common.exception.AlertDatabaseConstraintException;\n+import com.synopsys.integration.alert.common.exception.AlertException;\n+import com.synopsys.integration.alert.common.persistence.accessor.ConfigurationAccessor;\n+import com.synopsys.integration.alert.common.persistence.accessor.FieldAccessor;\n+import com.synopsys.integration.alert.common.persistence.model.ConfigurationFieldModel;\n+import com.synopsys.integration.alert.common.persistence.model.ConfigurationModel;\n+import com.synopsys.integration.alert.common.persistence.util.ConfigurationFieldModelConverter;\n import com.synopsys.integration.alert.common.rest.HttpServletContentWrapper;\n import com.synopsys.integration.alert.common.rest.ResponseFactory;\n import com.synopsys.integration.alert.common.rest.model.FieldModel;\n+import com.synopsys.integration.azure.boards.common.http.AzureHttpServiceFactory;\n \n @Component\n-public class AzureBoardsCustomEndpoint extends ButtonCustomEndpoint {\n+public class AzureBoardsCustomEndpoint extends OAuthCustomEndpoint {\n     private final Logger logger = LoggerFactory.getLogger(AzureBoardsCustomEndpoint.class);\n \n-    private final AzureBoardsChannelKey azureBoardsChannelKey;\n-    private final ResponseFactory responseFactory;\n+    private final AlertProperties alertProperties;\n+    private final ConfigurationAccessor configurationAccessor;\n+    private final ConfigurationFieldModelConverter modelConverter;\n \n-    @Autowired\n-    public AzureBoardsCustomEndpoint(AzureBoardsChannelKey azureBoardsChannelKey, CustomEndpointManager customEndpointManager, ResponseFactory responseFactory) throws Exception {\n-        super(AzureBoardsDescriptor.KEY_OAUTH, customEndpointManager);\n-        this.azureBoardsChannelKey = azureBoardsChannelKey;\n-        this.responseFactory = responseFactory;\n+    public AzureBoardsCustomEndpoint(CustomEndpointManager customEndpointManager, ResponseFactory responseFactory, Gson gson, AlertProperties alertProperties, ConfigurationAccessor configurationAccessor,\n+        ConfigurationFieldModelConverter modelConverter)\n+        throws AlertException {\n+        super(AzureBoardsDescriptor.KEY_OAUTH, customEndpointManager, responseFactory, gson);\n+        this.alertProperties = alertProperties;\n+        this.configurationAccessor = configurationAccessor;\n+        this.modelConverter = modelConverter;\n     }\n \n     @Override\n-    public ResponseEntity<String> createResponse(FieldModel fieldModel, HttpServletContentWrapper servletContentWrapper) {\n-        return responseFactory.createOkResponse(\"\", \"Placeholder Message\"); //FIXME this message should fixed once the Oauth is implemented.\n+    protected OAuthEndpointResponse createOAuthResponse(FieldModel fieldModel, HttpServletContentWrapper servletContentWrapper) {\n+        try {\n+            FieldAccessor fieldAccessor = createFieldAccessor(fieldModel);\n+            Optional<String> clientId = fieldAccessor.getString(AzureBoardsDescriptor.KEY_CLIENT_ID);\n+            if (!clientId.isPresent()) {\n+                return new OAuthEndpointResponse(HttpStatus.BAD_REQUEST.value(), false, \"\", \"client id not found.\");\n+            }\n+            Optional<String> alertServerUrl = alertProperties.getServerUrl();\n+\n+            if (!alertServerUrl.isPresent()) {\n+                return new OAuthEndpointResponse(HttpStatus.BAD_REQUEST.value(), false, \"\", \"Could not determine the alert server url for the callback.\");\n+            }\n+            String authUrl = createAuthURL(clientId.get(), alertServerUrl.get());\n+            logger.info(\"Authenticating Azure OAuth URL: \" + authUrl);\n+            //TODO add code to check if Alert has already been authorized to set the authenticated flag.\n+\n+            return new OAuthEndpointResponse(HttpStatus.OK.value(), false, authUrl, \"\");\n+\n+        } catch (Exception ex) {\n+            logger.error(\"Error activating Azure Boards\", ex);\n+            return new OAuthEndpointResponse(HttpStatus.INTERNAL_SERVER_ERROR.value(), false, \"\", \"Error activating azure oauth.\");\n+        }\n+    }\n+\n+    private FieldAccessor createFieldAccessor(FieldModel fieldModel) {\n+        Map<String, ConfigurationFieldModel> fields = new HashMap<>();\n+        try {\n+            fields.putAll(modelConverter.convertToConfigurationFieldModelMap(fieldModel));\n+            // check if a configuration exists because the client id is a sensitive field and won't have a value in the field model if updating.\n+            if (StringUtils.isNotBlank(fieldModel.getId())) {\n+                Optional<ConfigurationModel> configurationFieldModel = configurationAccessor.getConfigurationById(Long.valueOf(fieldModel.getId()));\n+                configurationFieldModel.ifPresent(model -> fields.putAll(model.getCopyOfKeyToFieldMap()));\n+            }\n+        } catch (AlertDatabaseConstraintException ex) {\n+            logger.error(\"Error creating field acessor for Azure authentication\", ex);\n+        }\n+        return new FieldAccessor(fields);\n     }\n \n+    private String createAuthURL(String clientId, String alertServerUrl) {\n+        StringBuilder authUrlBuilder = new StringBuilder(300);\n+        authUrlBuilder.append(AzureHttpServiceFactory.DEFAULT_AUTHORIZATION_URL);\n+        authUrlBuilder.append(createQueryString(clientId, alertServerUrl));\n+        return authUrlBuilder.toString();\n+    }\n+\n+    private String createQueryString(String clientId, String alertServerUrl) {\n+        String authorizationUrl = String.format(\"%s%s\", alertServerUrl, AzureOauthCallbackController.AZURE_OAUTH_CALLBACK_PATH);\n+        StringBuilder queryBuilder = new StringBuilder(250);\n+        queryBuilder.append(\"&client_id=\");\n+        queryBuilder.append(clientId);\n+        //TODO have an object that stores the request keys and purges them after some amount of time.\n+        //TODO also store a redirect URL if possible\n+        queryBuilder.append(\"&state=\");\n+        queryBuilder.append(createRequestKey());\n+        queryBuilder.append(\"&scope=vso.work%20vso.code_write\");", "originalCommit": "a62b397d8fb5f419dcfc7c1ed74c4112fe654bca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ3MTYwOQ==", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1111#discussion_r469471609", "bodyText": "yeah it makes sense because the callback is failing to return tokens. the URL returned lists invalid scopes", "author": "psantos1113", "createdAt": "2020-08-12T18:53:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ2Njc4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ4MTY0NQ==", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1111#discussion_r469481645", "bodyText": "This looks like it was added for testing, we may want to log something similar at DEBUG.", "author": "gkillough", "createdAt": "2020-08-12T19:11:52Z", "path": "src/main/java/com/synopsys/integration/alert/channel/azure/boards/web/AzureOauthCallbackController.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/**\n+ * blackduck-alert\n+ *\n+ * Copyright (c) 2020 Synopsys, Inc.\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.synopsys.integration.alert.channel.azure.boards.web;\n+\n+import java.net.Proxy;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.http.ResponseEntity;\n+import org.springframework.web.bind.annotation.GetMapping;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RestController;\n+\n+import com.google.gson.Gson;\n+import com.synopsys.integration.alert.channel.azure.boards.AzureBoardsChannelKey;\n+import com.synopsys.integration.alert.channel.azure.boards.descriptor.AzureBoardsDescriptor;\n+import com.synopsys.integration.alert.channel.azure.boards.service.AzureBoardsProperties;\n+import com.synopsys.integration.alert.channel.azure.boards.storage.AzureBoardsCredentialDataStoreFactory;\n+import com.synopsys.integration.alert.common.enumeration.ConfigContextEnum;\n+import com.synopsys.integration.alert.common.exception.AlertException;\n+import com.synopsys.integration.alert.common.persistence.accessor.ConfigurationAccessor;\n+import com.synopsys.integration.alert.common.persistence.accessor.FieldAccessor;\n+import com.synopsys.integration.alert.common.persistence.model.ConfigurationModel;\n+import com.synopsys.integration.alert.common.persistence.util.ConfigurationFieldModelConverter;\n+import com.synopsys.integration.alert.common.rest.ProxyManager;\n+import com.synopsys.integration.alert.common.rest.ResponseFactory;\n+import com.synopsys.integration.alert.web.controller.BaseController;\n+import com.synopsys.integration.azure.boards.common.http.AzureHttpService;\n+\n+@RestController\n+@RequestMapping(AzureOauthCallbackController.AZURE_OAUTH_CALLBACK_PATH)\n+public class AzureOauthCallbackController {\n+    public static final String AZURE_OAUTH_CALLBACK_PATH = BaseController.OAUTH_CALLBACK_PATH + \"/azure\";\n+    private Logger logger = LoggerFactory.getLogger(AzureOauthCallbackController.class);\n+    private ResponseFactory responseFactory;\n+    private final Gson gson;\n+    private final AzureBoardsChannelKey azureBoardsChannelKey;\n+    private final AzureBoardsCredentialDataStoreFactory azureBoardsCredentialDataStoreFactory;\n+    private final ProxyManager proxyManager;\n+    private final ConfigurationAccessor configurationAccessor;\n+    private final ConfigurationFieldModelConverter configFieldModelConverter;\n+\n+    @Autowired\n+    public AzureOauthCallbackController(ResponseFactory responseFactory, Gson gson, AzureBoardsChannelKey azureBoardsChannelKey,\n+        AzureBoardsCredentialDataStoreFactory azureBoardsCredentialDataStoreFactory, ProxyManager proxyManager, ConfigurationAccessor configurationAccessor,\n+        ConfigurationFieldModelConverter configFieldModelConverter) {\n+        this.responseFactory = responseFactory;\n+        this.gson = gson;\n+        this.azureBoardsChannelKey = azureBoardsChannelKey;\n+        this.azureBoardsCredentialDataStoreFactory = azureBoardsCredentialDataStoreFactory;\n+        this.proxyManager = proxyManager;\n+        this.configurationAccessor = configurationAccessor;\n+        this.configFieldModelConverter = configFieldModelConverter;\n+    }\n+\n+    @GetMapping\n+    public ResponseEntity<String> oauthCallback() {\n+        try {\n+            logger.info(\"callback method called\");", "originalCommit": "a62b397d8fb5f419dcfc7c1ed74c4112fe654bca", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b1a93d65844ab90f7084627280db87c4d62181e6", "url": "https://github.com/blackducksoftware/blackduck-alert/commit/b1a93d65844ab90f7084627280db87c4d62181e6", "message": "refactor: Implement some of the PR feedback.", "committedDate": "2020-08-12T19:19:08Z", "type": "commit"}, {"oid": "617cdbd685c34da45f4c86837203e38fff207542", "url": "https://github.com/blackducksoftware/blackduck-alert/commit/617cdbd685c34da45f4c86837203e38fff207542", "message": "refactor: use CustomEndpoint for the OAuthCustomEndpoint.", "committedDate": "2020-08-12T19:27:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUwMDU5OQ==", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1111#discussion_r469500599", "bodyText": "Don't we want this to extend CustomEndpoint<OAuthEndpointResponse>?", "author": "gkillough", "createdAt": "2020-08-12T19:48:52Z", "path": "alert-common/src/main/java/com/synopsys/integration/alert/common/descriptor/config/field/endpoint/oauth/OAuthCustomEndpoint.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/**\n+ * alert-common\n+ *\n+ * Copyright (c) 2020 Synopsys, Inc.\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.synopsys.integration.alert.common.descriptor.config.field.endpoint.oauth;\n+\n+import org.springframework.http.ResponseEntity;\n+\n+import com.google.gson.Gson;\n+import com.synopsys.integration.alert.common.action.CustomEndpointManager;\n+import com.synopsys.integration.alert.common.descriptor.config.field.endpoint.CustomEndpoint;\n+import com.synopsys.integration.alert.common.exception.AlertException;\n+import com.synopsys.integration.alert.common.rest.HttpServletContentWrapper;\n+import com.synopsys.integration.alert.common.rest.ResponseFactory;\n+import com.synopsys.integration.alert.common.rest.model.FieldModel;\n+\n+public abstract class OAuthCustomEndpoint extends CustomEndpoint<String> {", "originalCommit": "617cdbd685c34da45f4c86837203e38fff207542", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUwMjg1Mw==", "url": "https://github.com/blackducksoftware/blackduck-alert/pull/1111#discussion_r469502853", "bodyText": "We would need to refactor CustomEndpoint and CustomEndpointManager which may cause bugs elsewhere.", "author": "psantos1113", "createdAt": "2020-08-12T19:53:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTUwMDU5OQ=="}], "type": "inlineReview"}, {"oid": "d3643c0555e0975e19e85c9a587523d8e2410381", "url": "https://github.com/blackducksoftware/blackduck-alert/commit/d3643c0555e0975e19e85c9a587523d8e2410381", "message": "refactor: Fix a spelling typo.", "committedDate": "2020-08-13T10:00:40Z", "type": "commit"}]}