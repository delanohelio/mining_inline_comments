{"pr_number": 919, "pr_title": "add 5 TP algorithm", "pr_createdAt": "2020-03-30T13:54:09Z", "pr_url": "https://github.com/hugegraph/hugegraph/pull/919", "timeline": [{"oid": "87662b11cae64348b0d7713abe988369c52e6390", "url": "https://github.com/hugegraph/hugegraph/commit/87662b11cae64348b0d7713abe988369c52e6390", "message": "add 5 TP algorithm\n\n1. same neighbors\n2. jaccard similarity\n3. all shortest paths\n4. weighted shortest path\n5. single source shortest paths\n\nChange-Id: I13a04267c6c91cc8bb00ca2aed1ef54c8e6eeeb6", "committedDate": "2020-03-30T13:50:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDgzNjIxMQ==", "url": "https://github.com/hugegraph/hugegraph/pull/919#discussion_r400836211", "bodyText": "improve var name", "author": "javeme", "createdAt": "2020-03-31T11:24:41Z", "path": "hugegraph-api/src/main/java/com/baidu/hugegraph/api/traversers/JaccardSimilarityAPI.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Copyright 2017 HugeGraph Authors\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.baidu.hugegraph.api.traversers;\n+\n+import javax.inject.Singleton;\n+import javax.ws.rs.DefaultValue;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.QueryParam;\n+import javax.ws.rs.core.Context;\n+\n+import org.slf4j.Logger;\n+\n+import com.baidu.hugegraph.HugeGraph;\n+import com.baidu.hugegraph.api.API;\n+import com.baidu.hugegraph.api.graph.EdgeAPI;\n+import com.baidu.hugegraph.api.graph.VertexAPI;\n+import com.baidu.hugegraph.backend.id.Id;\n+import com.baidu.hugegraph.core.GraphManager;\n+import com.baidu.hugegraph.server.RestServer;\n+import com.baidu.hugegraph.traversal.algorithm.HugeTraverser;\n+import com.baidu.hugegraph.type.define.Directions;\n+import com.baidu.hugegraph.util.JsonUtil;\n+import com.baidu.hugegraph.util.Log;\n+import com.codahale.metrics.annotation.Timed;\n+import com.google.common.collect.ImmutableMap;\n+\n+import static com.baidu.hugegraph.traversal.algorithm.HugeTraverser.DEFAULT_DEGREE;\n+\n+@Path(\"graphs/{graph}/traversers/jaccardsimilarity\")\n+@Singleton\n+public class JaccardSimilarityAPI extends API {\n+\n+    private static final Logger LOG = Log.logger(RestServer.class);\n+\n+    @GET\n+    @Timed\n+    @Produces(APPLICATION_JSON_WITH_CHARSET)\n+    public String get(@Context GraphManager manager,\n+                      @PathParam(\"graph\") String graph,\n+                      @QueryParam(\"v1\") String v1,\n+                      @QueryParam(\"v2\") String v2,", "originalCommit": "87662b11cae64348b0d7713abe988369c52e6390", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDgzNzIwOQ==", "url": "https://github.com/hugegraph/hugegraph/pull/919#discussion_r400837209", "bodyText": "ditto", "author": "javeme", "createdAt": "2020-03-31T11:26:32Z", "path": "hugegraph-api/src/main/java/com/baidu/hugegraph/api/traversers/SameNeighborsAPI.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright 2017 HugeGraph Authors\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.baidu.hugegraph.api.traversers;\n+\n+import java.util.Set;\n+\n+import javax.inject.Singleton;\n+import javax.ws.rs.DefaultValue;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.QueryParam;\n+import javax.ws.rs.core.Context;\n+\n+import org.slf4j.Logger;\n+\n+import com.baidu.hugegraph.HugeGraph;\n+import com.baidu.hugegraph.api.API;\n+import com.baidu.hugegraph.api.graph.EdgeAPI;\n+import com.baidu.hugegraph.api.graph.VertexAPI;\n+import com.baidu.hugegraph.backend.id.Id;\n+import com.baidu.hugegraph.core.GraphManager;\n+import com.baidu.hugegraph.server.RestServer;\n+import com.baidu.hugegraph.traversal.algorithm.HugeTraverser;\n+import com.baidu.hugegraph.type.define.Directions;\n+import com.baidu.hugegraph.util.Log;\n+import com.codahale.metrics.annotation.Timed;\n+\n+import static com.baidu.hugegraph.traversal.algorithm.HugeTraverser.DEFAULT_DEGREE;\n+import static com.baidu.hugegraph.traversal.algorithm.HugeTraverser.DEFAULT_PATHS_LIMIT;\n+\n+@Path(\"graphs/{graph}/traversers/sameneighbors\")\n+@Singleton\n+public class SameNeighborsAPI extends API {\n+\n+    private static final Logger LOG = Log.logger(RestServer.class);\n+\n+    @GET\n+    @Timed\n+    @Produces(APPLICATION_JSON_WITH_CHARSET)\n+    public String get(@Context GraphManager manager,\n+                      @PathParam(\"graph\") String graph,\n+                      @QueryParam(\"v1\") String v1,\n+                      @QueryParam(\"v2\") String v2,\n+                      @QueryParam(\"direction\") String direction,\n+                      @QueryParam(\"label\") String edgeLabel,\n+                      @QueryParam(\"max_degree\")\n+                      @DefaultValue(DEFAULT_DEGREE) long degree,\n+                      @QueryParam(\"limit\")\n+                      @DefaultValue(DEFAULT_PATHS_LIMIT) long limit) {\n+        LOG.debug(\"Graph [{}] get same neighbors between '{}' and '{}' with \" +\n+                  \"direction {}, edge label {}, max degree '{}' and limit '{}'\",\n+                  graph, v1, v2, direction, edgeLabel, degree, limit);\n+\n+        Id sourceId = VertexAPI.checkAndParseVertexId(v1);\n+        Id targetId = VertexAPI.checkAndParseVertexId(v2);", "originalCommit": "87662b11cae64348b0d7713abe988369c52e6390", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDgzNzc1Nw==", "url": "https://github.com/hugegraph/hugegraph/pull/919#discussion_r400837757", "bodyText": "toSet", "author": "javeme", "createdAt": "2020-03-31T11:27:31Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java", "diffHunk": "@@ -171,6 +172,52 @@ public HugeGraph graph() {\n         return all;\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n+    public Set<Id> sameNeighbors(Id v1, Id v2, Directions direction,\n+                                 String label, long degree, long limit) {\n+        E.checkNotNull(v1, \"vertex id\");\n+        E.checkNotNull(v2, \"vertex id\");\n+        E.checkNotNull(direction, \"direction\");\n+        checkDegree(degree);\n+        checkLimit(limit);\n+\n+        Id labelId = this.getEdgeLabelId(label);\n+\n+        List<Id> sourceNeighbors = IteratorUtils.toList(this.adjacentVertices(", "originalCommit": "87662b11cae64348b0d7713abe988369c52e6390", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDgzODAzNA==", "url": "https://github.com/hugegraph/hugegraph/pull/919#discussion_r400838034", "bodyText": "ditto", "author": "javeme", "createdAt": "2020-03-31T11:28:00Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java", "diffHunk": "@@ -171,6 +172,52 @@ public HugeGraph graph() {\n         return all;\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n+    public Set<Id> sameNeighbors(Id v1, Id v2, Directions direction,\n+                                 String label, long degree, long limit) {\n+        E.checkNotNull(v1, \"vertex id\");\n+        E.checkNotNull(v2, \"vertex id\");\n+        E.checkNotNull(direction, \"direction\");\n+        checkDegree(degree);\n+        checkLimit(limit);\n+\n+        Id labelId = this.getEdgeLabelId(label);\n+\n+        List<Id> sourceNeighbors = IteratorUtils.toList(this.adjacentVertices(\n+                                   v1, direction, labelId, degree));\n+        List<Id> targetNeighbors = IteratorUtils.toList(this.adjacentVertices(", "originalCommit": "87662b11cae64348b0d7713abe988369c52e6390", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDgzODM2OQ==", "url": "https://github.com/hugegraph/hugegraph/pull/919#discussion_r400838369", "bodyText": "convert via \"(Set)\"", "author": "javeme", "createdAt": "2020-03-31T11:28:39Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java", "diffHunk": "@@ -171,6 +172,52 @@ public HugeGraph graph() {\n         return all;\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n+    public Set<Id> sameNeighbors(Id v1, Id v2, Directions direction,\n+                                 String label, long degree, long limit) {\n+        E.checkNotNull(v1, \"vertex id\");\n+        E.checkNotNull(v2, \"vertex id\");\n+        E.checkNotNull(direction, \"direction\");\n+        checkDegree(degree);\n+        checkLimit(limit);\n+\n+        Id labelId = this.getEdgeLabelId(label);\n+\n+        List<Id> sourceNeighbors = IteratorUtils.toList(this.adjacentVertices(\n+                                   v1, direction, labelId, degree));\n+        List<Id> targetNeighbors = IteratorUtils.toList(this.adjacentVertices(\n+                                   v2, direction, labelId, degree));\n+        Set<Id> sameNeighbors = new HashSet<>(CollectionUtils.intersection(", "originalCommit": "87662b11cae64348b0d7713abe988369c52e6390", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg0MDI1Mw==", "url": "https://github.com/hugegraph/hugegraph/pull/919#discussion_r400840253", "bodyText": "1.0", "author": "javeme", "createdAt": "2020-03-31T11:32:17Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/SingleSourceShortestPathTraverser.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/*\n+ * Copyright 2017 HugeGraph Authors\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.baidu.hugegraph.traversal.algorithm;\n+\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.apache.tinkerpop.gremlin.structure.Edge;\n+\n+import com.baidu.hugegraph.HugeGraph;\n+import com.baidu.hugegraph.backend.id.Id;\n+import com.baidu.hugegraph.backend.query.QueryResults;\n+import com.baidu.hugegraph.structure.HugeEdge;\n+import com.baidu.hugegraph.type.define.Directions;\n+import com.baidu.hugegraph.util.E;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+public class SingleSourceShortestPathTraverser extends HugeTraverser {\n+\n+    public SingleSourceShortestPathTraverser(HugeGraph graph) {\n+        super(graph);\n+    }\n+\n+    public ShortestPaths singleSourceShortestPaths(Id sourceV, Directions dir,\n+                                                   String label, String weight,\n+                                                   long degree, long skipDegree,\n+                                                   long capacity, long limit) {\n+        E.checkNotNull(sourceV, \"source vertex id\");\n+        E.checkNotNull(dir, \"direction\");\n+        checkDegree(degree);\n+        checkCapacity(capacity);\n+        checkSkipDegree(skipDegree, degree, capacity);\n+        checkLimit(limit);\n+\n+        Id labelId = this.getEdgeLabelId(label);\n+        Traverser traverser = new Traverser(sourceV, dir, labelId, weight,\n+                                            degree, skipDegree, capacity,\n+                                            limit);\n+        while (true) {\n+            // Found, reach max depth or reach capacity, stop searching\n+            traverser.forward();\n+            if (traverser.done()) {\n+                return traverser.shortestPaths();\n+            }\n+            checkCapacity(traverser.capacity, traverser.size, \"shortest path\");\n+        }\n+    }\n+\n+    public NodeWithWeight weightedShortestPath(Id sourceV, Id targetV,\n+                                               Directions dir, String label,\n+                                               String weight, long degree,\n+                                               long skipDegree, long capacity) {\n+        E.checkNotNull(sourceV, \"source vertex id\");\n+        E.checkNotNull(dir, \"direction\");\n+        checkDegree(degree);\n+        checkCapacity(capacity);\n+        checkSkipDegree(skipDegree, degree, capacity);\n+\n+        Id labelId = this.getEdgeLabelId(label);\n+        Traverser traverser = new Traverser(sourceV, dir, labelId, weight,\n+                                            degree, skipDegree, capacity,\n+                                            NO_LIMIT);\n+        while (true) {\n+            traverser.forward();\n+            Map<Id, NodeWithWeight> results = traverser.shortestPaths();\n+            if (results.containsKey(targetV) || traverser.done()) {\n+                return results.get(targetV);\n+            }\n+            checkCapacity(traverser.capacity, traverser.size, \"shortest path\");\n+        }\n+    }\n+\n+    private static void checkSkipDegree(long skipDegree, long degree,\n+                                        long capacity) {\n+        E.checkArgument(skipDegree >= 0L,\n+                        \"The skipped degree must be >= 0, but got '%s'\",\n+                        skipDegree);\n+        if (capacity != NO_LIMIT) {\n+            E.checkArgument(degree != NO_LIMIT && degree < capacity,\n+                            \"The degree must be < capacity\");\n+            E.checkArgument(skipDegree < capacity,\n+                            \"The skipped degree must be < capacity\");\n+        }\n+        if (skipDegree > 0L) {\n+            E.checkArgument(degree != NO_LIMIT && skipDegree >= degree,\n+                            \"The skipped degree must be >= degree, \" +\n+                                    \"but got skipped degree '%s' and degree '%s'\",\n+                            skipDegree, degree);\n+        }\n+    }\n+\n+    private class Traverser {\n+\n+        private ShortestPaths findingNodes = new ShortestPaths();\n+        private ShortestPaths foundNodes = new ShortestPaths();\n+        private Set<NodeWithWeight> sources;\n+        private Id source;\n+        private final Directions direction;\n+        private final Id label;\n+        private final String weight;\n+        private final long degree;\n+        private final long skipDegree;\n+        private final long capacity;\n+        private final long limit;\n+        private long size;\n+        private boolean done = false;\n+\n+        public Traverser(Id sourceV, Directions dir, Id label, String weight,\n+                         long degree, long skipDegree, long capacity,\n+                         long limit) {\n+            this.source = sourceV;\n+            this.sources = ImmutableSet.of(new NodeWithWeight(\n+                           0D, new Node(sourceV, null)));\n+            this.direction = dir;\n+            this.label = label;\n+            this.weight = weight;\n+            this.degree = degree;\n+            this.skipDegree = skipDegree;\n+            this.capacity = capacity;\n+            this.limit = limit;\n+            this.size = 0L;\n+        }\n+\n+        /**\n+         * Search forward from source\n+         */\n+        public void forward() {\n+            long degree = this.skipDegree > 0L ? this.skipDegree : this.degree;\n+            for (NodeWithWeight node : this.sources) {\n+                Iterator<Edge> edges = edgesOfVertex(node.node().id(),\n+                                                     this.direction,\n+                                                     this.label, degree);\n+                edges = this.skipSuperNodeIfNeeded(edges);\n+                while (edges.hasNext()) {\n+                    HugeEdge edge = (HugeEdge) edges.next();\n+                    Id target = edge.id().otherVertexId();\n+\n+                    if (this.foundNodes.containsKey(target) ||\n+                        this.source.equals(target)) {\n+                        // Already find shortest path for target, skip\n+                        continue;\n+                    }\n+\n+                    double currentWeight = this.edgeWeight(edge);\n+                    double weight = currentWeight + node.weight();\n+                    NodeWithWeight nw = new NodeWithWeight(weight, target, node);\n+                    if (!this.findingNodes.containsKey(target) ||\n+                        weight < this.findingNodes.get(target).weight()) {\n+                        /*\n+                         * There are 2 scenarios to update finding nodes:\n+                         * 1. The 'target' found first time, add current path\n+                         * 2. Already exist path for 'target' and current\n+                         *    path is shorter, update path for 'target'\n+                         */\n+                        this.findingNodes.put(target, nw);\n+                    }\n+                }\n+            }\n+\n+            List<NodeWithWeight> sorted = this.findingNodes.values().stream()\n+                                          .sorted(Comparator.comparing\n+                                          (NodeWithWeight::weight))\n+                                          .collect(Collectors.toList());\n+            double minWeight = 0;\n+            Set<NodeWithWeight> newSources = new HashSet<>();\n+            for (NodeWithWeight nw : sorted) {\n+                if (minWeight == 0) {\n+                    minWeight = nw.weight();\n+                } else if (nw.weight() > minWeight) {\n+                    break;\n+                }\n+                Id id = nw.node().id();\n+                // Move shortest paths from 'findingNodes' to 'foundNodes'\n+                this.foundNodes.put(id, nw);\n+                if (this.limit != NO_LIMIT &&\n+                    this.foundNodes.size() >= this.limit) {\n+                    this.done = true;\n+                    return;\n+                }\n+                this.findingNodes.remove(id);\n+                // Re-init 'sources'\n+                newSources.add(nw);\n+            }\n+            this.sources = newSources;\n+            if (this.sources.isEmpty()) {\n+                this.done = true;\n+            }\n+        }\n+\n+        public boolean done() {\n+            return this.done;\n+        }\n+\n+        public ShortestPaths shortestPaths() {\n+            return this.foundNodes;\n+        }\n+\n+        private double edgeWeight(HugeEdge edge) {\n+            double edgeWeight;\n+            if (this.weight == null ||\n+                !edge.property(this.weight).isPresent()) {\n+                edgeWeight = 1;", "originalCommit": "87662b11cae64348b0d7713abe988369c52e6390", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg0MDgzNA==", "url": "https://github.com/hugegraph/hugegraph/pull/919#discussion_r400840834", "bodyText": "ditto", "author": "javeme", "createdAt": "2020-03-31T11:33:26Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java", "diffHunk": "@@ -171,6 +172,52 @@ public HugeGraph graph() {\n         return all;\n     }\n \n+    @SuppressWarnings(\"unchecked\")\n+    public Set<Id> sameNeighbors(Id v1, Id v2, Directions direction,\n+                                 String label, long degree, long limit) {\n+        E.checkNotNull(v1, \"vertex id\");\n+        E.checkNotNull(v2, \"vertex id\");\n+        E.checkNotNull(direction, \"direction\");\n+        checkDegree(degree);\n+        checkLimit(limit);\n+\n+        Id labelId = this.getEdgeLabelId(label);\n+\n+        List<Id> sourceNeighbors = IteratorUtils.toList(this.adjacentVertices(\n+                                   v1, direction, labelId, degree));\n+        List<Id> targetNeighbors = IteratorUtils.toList(this.adjacentVertices(\n+                                   v2, direction, labelId, degree));\n+        Set<Id> sameNeighbors = new HashSet<>(CollectionUtils.intersection(\n+                                sourceNeighbors, targetNeighbors));\n+        if (limit != NO_LIMIT) {\n+            int end = Math.min(sameNeighbors.size(), (int) limit);\n+            sameNeighbors = CollectionUtil.subSet(sameNeighbors, 0, end);\n+        }\n+        return sameNeighbors;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public double jaccardSimilarity(Id v1, Id v2, Directions dir,\n+                                    String label, long degree) {\n+        E.checkNotNull(v1, \"source vertex id\");\n+        E.checkNotNull(v2, \"target vertex id\");\n+        E.checkNotNull(dir, \"direction\");\n+        checkDegree(degree);\n+\n+        Id labelId = this.getEdgeLabelId(label);\n+\n+        List<Id> sourceNeighbors = IteratorUtils.toList(this.adjacentVertices(", "originalCommit": "87662b11cae64348b0d7713abe988369c52e6390", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg0MjIyOA==", "url": "https://github.com/hugegraph/hugegraph/pull/919#discussion_r400842228", "bodyText": "call method HugeTraverser.topN or CollectionUtil.sortByValue", "author": "javeme", "createdAt": "2020-03-31T11:36:09Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/SingleSourceShortestPathTraverser.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/*\n+ * Copyright 2017 HugeGraph Authors\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.baidu.hugegraph.traversal.algorithm;\n+\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.apache.tinkerpop.gremlin.structure.Edge;\n+\n+import com.baidu.hugegraph.HugeGraph;\n+import com.baidu.hugegraph.backend.id.Id;\n+import com.baidu.hugegraph.backend.query.QueryResults;\n+import com.baidu.hugegraph.structure.HugeEdge;\n+import com.baidu.hugegraph.type.define.Directions;\n+import com.baidu.hugegraph.util.E;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+public class SingleSourceShortestPathTraverser extends HugeTraverser {\n+\n+    public SingleSourceShortestPathTraverser(HugeGraph graph) {\n+        super(graph);\n+    }\n+\n+    public ShortestPaths singleSourceShortestPaths(Id sourceV, Directions dir,\n+                                                   String label, String weight,\n+                                                   long degree, long skipDegree,\n+                                                   long capacity, long limit) {\n+        E.checkNotNull(sourceV, \"source vertex id\");\n+        E.checkNotNull(dir, \"direction\");\n+        checkDegree(degree);\n+        checkCapacity(capacity);\n+        checkSkipDegree(skipDegree, degree, capacity);\n+        checkLimit(limit);\n+\n+        Id labelId = this.getEdgeLabelId(label);\n+        Traverser traverser = new Traverser(sourceV, dir, labelId, weight,\n+                                            degree, skipDegree, capacity,\n+                                            limit);\n+        while (true) {\n+            // Found, reach max depth or reach capacity, stop searching\n+            traverser.forward();\n+            if (traverser.done()) {\n+                return traverser.shortestPaths();\n+            }\n+            checkCapacity(traverser.capacity, traverser.size, \"shortest path\");\n+        }\n+    }\n+\n+    public NodeWithWeight weightedShortestPath(Id sourceV, Id targetV,\n+                                               Directions dir, String label,\n+                                               String weight, long degree,\n+                                               long skipDegree, long capacity) {\n+        E.checkNotNull(sourceV, \"source vertex id\");\n+        E.checkNotNull(dir, \"direction\");\n+        checkDegree(degree);\n+        checkCapacity(capacity);\n+        checkSkipDegree(skipDegree, degree, capacity);\n+\n+        Id labelId = this.getEdgeLabelId(label);\n+        Traverser traverser = new Traverser(sourceV, dir, labelId, weight,\n+                                            degree, skipDegree, capacity,\n+                                            NO_LIMIT);\n+        while (true) {\n+            traverser.forward();\n+            Map<Id, NodeWithWeight> results = traverser.shortestPaths();\n+            if (results.containsKey(targetV) || traverser.done()) {\n+                return results.get(targetV);\n+            }\n+            checkCapacity(traverser.capacity, traverser.size, \"shortest path\");\n+        }\n+    }\n+\n+    private static void checkSkipDegree(long skipDegree, long degree,\n+                                        long capacity) {\n+        E.checkArgument(skipDegree >= 0L,\n+                        \"The skipped degree must be >= 0, but got '%s'\",\n+                        skipDegree);\n+        if (capacity != NO_LIMIT) {\n+            E.checkArgument(degree != NO_LIMIT && degree < capacity,\n+                            \"The degree must be < capacity\");\n+            E.checkArgument(skipDegree < capacity,\n+                            \"The skipped degree must be < capacity\");\n+        }\n+        if (skipDegree > 0L) {\n+            E.checkArgument(degree != NO_LIMIT && skipDegree >= degree,\n+                            \"The skipped degree must be >= degree, \" +\n+                                    \"but got skipped degree '%s' and degree '%s'\",\n+                            skipDegree, degree);\n+        }\n+    }\n+\n+    private class Traverser {\n+\n+        private ShortestPaths findingNodes = new ShortestPaths();\n+        private ShortestPaths foundNodes = new ShortestPaths();\n+        private Set<NodeWithWeight> sources;\n+        private Id source;\n+        private final Directions direction;\n+        private final Id label;\n+        private final String weight;\n+        private final long degree;\n+        private final long skipDegree;\n+        private final long capacity;\n+        private final long limit;\n+        private long size;\n+        private boolean done = false;\n+\n+        public Traverser(Id sourceV, Directions dir, Id label, String weight,\n+                         long degree, long skipDegree, long capacity,\n+                         long limit) {\n+            this.source = sourceV;\n+            this.sources = ImmutableSet.of(new NodeWithWeight(\n+                           0D, new Node(sourceV, null)));\n+            this.direction = dir;\n+            this.label = label;\n+            this.weight = weight;\n+            this.degree = degree;\n+            this.skipDegree = skipDegree;\n+            this.capacity = capacity;\n+            this.limit = limit;\n+            this.size = 0L;\n+        }\n+\n+        /**\n+         * Search forward from source\n+         */\n+        public void forward() {\n+            long degree = this.skipDegree > 0L ? this.skipDegree : this.degree;\n+            for (NodeWithWeight node : this.sources) {\n+                Iterator<Edge> edges = edgesOfVertex(node.node().id(),\n+                                                     this.direction,\n+                                                     this.label, degree);\n+                edges = this.skipSuperNodeIfNeeded(edges);\n+                while (edges.hasNext()) {\n+                    HugeEdge edge = (HugeEdge) edges.next();\n+                    Id target = edge.id().otherVertexId();\n+\n+                    if (this.foundNodes.containsKey(target) ||\n+                        this.source.equals(target)) {\n+                        // Already find shortest path for target, skip\n+                        continue;\n+                    }\n+\n+                    double currentWeight = this.edgeWeight(edge);\n+                    double weight = currentWeight + node.weight();\n+                    NodeWithWeight nw = new NodeWithWeight(weight, target, node);\n+                    if (!this.findingNodes.containsKey(target) ||\n+                        weight < this.findingNodes.get(target).weight()) {\n+                        /*\n+                         * There are 2 scenarios to update finding nodes:\n+                         * 1. The 'target' found first time, add current path\n+                         * 2. Already exist path for 'target' and current\n+                         *    path is shorter, update path for 'target'\n+                         */\n+                        this.findingNodes.put(target, nw);\n+                    }\n+                }\n+            }\n+\n+            List<NodeWithWeight> sorted = this.findingNodes.values().stream()\n+                                          .sorted(Comparator.comparing", "originalCommit": "87662b11cae64348b0d7713abe988369c52e6390", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f075c39b107d2003d1d8a06a57316260d1888a49", "url": "https://github.com/hugegraph/hugegraph/commit/f075c39b107d2003d1d8a06a57316260d1888a49", "message": "improve\n\nChange-Id: I25709ed8af68fba565f1c6d3d3ed16376644b48e", "committedDate": "2020-04-01T05:47:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIxOTk3OA==", "url": "https://github.com/hugegraph/hugegraph/pull/919#discussion_r403219978", "bodyText": "check weight must be set", "author": "javeme", "createdAt": "2020-04-03T18:23:11Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/SingleSourceShortestPathTraverser.java", "diffHunk": "@@ -0,0 +1,304 @@\n+/*\n+ * Copyright 2017 HugeGraph Authors\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.baidu.hugegraph.traversal.algorithm;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.tinkerpop.gremlin.structure.Edge;\n+\n+import com.baidu.hugegraph.HugeGraph;\n+import com.baidu.hugegraph.backend.id.Id;\n+import com.baidu.hugegraph.backend.query.QueryResults;\n+import com.baidu.hugegraph.structure.HugeEdge;\n+import com.baidu.hugegraph.type.define.Directions;\n+import com.baidu.hugegraph.util.CollectionUtil;\n+import com.baidu.hugegraph.util.E;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+public class SingleSourceShortestPathTraverser extends HugeTraverser {\n+\n+    public SingleSourceShortestPathTraverser(HugeGraph graph) {\n+        super(graph);\n+    }\n+\n+    public ShortestPaths singleSourceShortestPaths(Id sourceV, Directions dir,\n+                                                   String label, String weight,\n+                                                   long degree, long skipDegree,\n+                                                   long capacity, long limit) {\n+        E.checkNotNull(sourceV, \"source vertex id\");\n+        E.checkNotNull(dir, \"direction\");\n+        checkDegree(degree);\n+        checkCapacity(capacity);\n+        checkSkipDegree(skipDegree, degree, capacity);\n+        checkLimit(limit);\n+\n+        Id labelId = this.getEdgeLabelId(label);\n+        Traverser traverser = new Traverser(sourceV, dir, labelId, weight,\n+                                            degree, skipDegree, capacity,\n+                                            limit);\n+        while (true) {\n+            // Found, reach max depth or reach capacity, stop searching\n+            traverser.forward();\n+            if (traverser.done()) {\n+                return traverser.shortestPaths();\n+            }\n+            checkCapacity(traverser.capacity, traverser.size, \"shortest path\");\n+        }\n+    }\n+\n+    public NodeWithWeight weightedShortestPath(Id sourceV, Id targetV,\n+                                               Directions dir, String label,\n+                                               String weight, long degree,\n+                                               long skipDegree, long capacity) {\n+        E.checkNotNull(sourceV, \"source vertex id\");\n+        E.checkNotNull(dir, \"direction\");", "originalCommit": "f075c39b107d2003d1d8a06a57316260d1888a49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIyMjMzMg==", "url": "https://github.com/hugegraph/hugegraph/pull/919#discussion_r403222332", "bodyText": "other", "author": "javeme", "createdAt": "2020-04-03T18:25:53Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/SingleSourceShortestPathTraverser.java", "diffHunk": "@@ -0,0 +1,304 @@\n+/*\n+ * Copyright 2017 HugeGraph Authors\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.baidu.hugegraph.traversal.algorithm;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.tinkerpop.gremlin.structure.Edge;\n+\n+import com.baidu.hugegraph.HugeGraph;\n+import com.baidu.hugegraph.backend.id.Id;\n+import com.baidu.hugegraph.backend.query.QueryResults;\n+import com.baidu.hugegraph.structure.HugeEdge;\n+import com.baidu.hugegraph.type.define.Directions;\n+import com.baidu.hugegraph.util.CollectionUtil;\n+import com.baidu.hugegraph.util.E;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+public class SingleSourceShortestPathTraverser extends HugeTraverser {\n+\n+    public SingleSourceShortestPathTraverser(HugeGraph graph) {\n+        super(graph);\n+    }\n+\n+    public ShortestPaths singleSourceShortestPaths(Id sourceV, Directions dir,\n+                                                   String label, String weight,\n+                                                   long degree, long skipDegree,\n+                                                   long capacity, long limit) {\n+        E.checkNotNull(sourceV, \"source vertex id\");\n+        E.checkNotNull(dir, \"direction\");\n+        checkDegree(degree);\n+        checkCapacity(capacity);\n+        checkSkipDegree(skipDegree, degree, capacity);\n+        checkLimit(limit);\n+\n+        Id labelId = this.getEdgeLabelId(label);\n+        Traverser traverser = new Traverser(sourceV, dir, labelId, weight,\n+                                            degree, skipDegree, capacity,\n+                                            limit);\n+        while (true) {\n+            // Found, reach max depth or reach capacity, stop searching\n+            traverser.forward();\n+            if (traverser.done()) {\n+                return traverser.shortestPaths();\n+            }\n+            checkCapacity(traverser.capacity, traverser.size, \"shortest path\");\n+        }\n+    }\n+\n+    public NodeWithWeight weightedShortestPath(Id sourceV, Id targetV,\n+                                               Directions dir, String label,\n+                                               String weight, long degree,\n+                                               long skipDegree, long capacity) {\n+        E.checkNotNull(sourceV, \"source vertex id\");\n+        E.checkNotNull(dir, \"direction\");\n+        checkDegree(degree);\n+        checkCapacity(capacity);\n+        checkSkipDegree(skipDegree, degree, capacity);\n+\n+        Id labelId = this.getEdgeLabelId(label);\n+        Traverser traverser = new Traverser(sourceV, dir, labelId, weight,\n+                                            degree, skipDegree, capacity,\n+                                            NO_LIMIT);\n+        while (true) {\n+            traverser.forward();\n+            Map<Id, NodeWithWeight> results = traverser.shortestPaths();\n+            if (results.containsKey(targetV) || traverser.done()) {\n+                return results.get(targetV);\n+            }\n+            checkCapacity(traverser.capacity, traverser.size, \"shortest path\");\n+        }\n+    }\n+\n+    private static void checkSkipDegree(long skipDegree, long degree,\n+                                        long capacity) {\n+        E.checkArgument(skipDegree >= 0L,\n+                        \"The skipped degree must be >= 0, but got '%s'\",\n+                        skipDegree);\n+        if (capacity != NO_LIMIT) {\n+            E.checkArgument(degree != NO_LIMIT && degree < capacity,\n+                            \"The degree must be < capacity\");\n+            E.checkArgument(skipDegree < capacity,\n+                            \"The skipped degree must be < capacity\");\n+        }\n+        if (skipDegree > 0L) {\n+            E.checkArgument(degree != NO_LIMIT && skipDegree >= degree,\n+                            \"The skipped degree must be >= degree, \" +\n+                                    \"but got skipped degree '%s' and degree '%s'\",\n+                            skipDegree, degree);\n+        }\n+    }\n+\n+    private class Traverser {\n+\n+        private ShortestPaths findingNodes = new ShortestPaths();\n+        private ShortestPaths foundNodes = new ShortestPaths();\n+        private Set<NodeWithWeight> sources;\n+        private Id source;\n+        private final Directions direction;\n+        private final Id label;\n+        private final String weight;\n+        private final long degree;\n+        private final long skipDegree;\n+        private final long capacity;\n+        private final long limit;\n+        private long size;\n+        private boolean done = false;\n+\n+        public Traverser(Id sourceV, Directions dir, Id label, String weight,\n+                         long degree, long skipDegree, long capacity,\n+                         long limit) {\n+            this.source = sourceV;\n+            this.sources = ImmutableSet.of(new NodeWithWeight(\n+                           0D, new Node(sourceV, null)));\n+            this.direction = dir;\n+            this.label = label;\n+            this.weight = weight;\n+            this.degree = degree;\n+            this.skipDegree = skipDegree;\n+            this.capacity = capacity;\n+            this.limit = limit;\n+            this.size = 0L;\n+        }\n+\n+        /**\n+         * Search forward from source\n+         */\n+        public void forward() {\n+            long degree = this.skipDegree > 0L ? this.skipDegree : this.degree;\n+            for (NodeWithWeight node : this.sources) {\n+                Iterator<Edge> edges = edgesOfVertex(node.node().id(),\n+                                                     this.direction,\n+                                                     this.label, degree);\n+                edges = this.skipSuperNodeIfNeeded(edges);\n+                while (edges.hasNext()) {\n+                    HugeEdge edge = (HugeEdge) edges.next();\n+                    Id target = edge.id().otherVertexId();\n+\n+                    if (this.foundNodes.containsKey(target) ||\n+                        this.source.equals(target)) {\n+                        // Already find shortest path for target, skip\n+                        continue;\n+                    }\n+\n+                    double currentWeight = this.edgeWeight(edge);\n+                    double weight = currentWeight + node.weight();\n+                    NodeWithWeight nw = new NodeWithWeight(weight, target, node);\n+                    if (!this.findingNodes.containsKey(target) ||\n+                        weight < this.findingNodes.get(target).weight()) {\n+                        /*\n+                         * There are 2 scenarios to update finding nodes:\n+                         * 1. The 'target' found first time, add current path\n+                         * 2. Already exist path for 'target' and current\n+                         *    path is shorter, update path for 'target'\n+                         */\n+                        this.findingNodes.put(target, nw);\n+                    }\n+                }\n+            }\n+\n+            Map<Id, NodeWithWeight> sorted = CollectionUtil.sortByValue(\n+                                             this.findingNodes, true);\n+            double minWeight = 0;\n+            Set<NodeWithWeight> newSources = new HashSet<>();\n+            for (Map.Entry<Id, NodeWithWeight> entry : sorted.entrySet()) {\n+                Id id = entry.getKey();\n+                NodeWithWeight nw = entry.getValue();\n+                if (minWeight == 0) {\n+                    minWeight = nw.weight();\n+                } else if (nw.weight() > minWeight) {\n+                    break;\n+                }\n+                // Move shortest paths from 'findingNodes' to 'foundNodes'\n+                this.foundNodes.put(id, nw);\n+                if (this.limit != NO_LIMIT &&\n+                    this.foundNodes.size() >= this.limit) {\n+                    this.done = true;\n+                    return;\n+                }\n+                this.findingNodes.remove(id);\n+                // Re-init 'sources'\n+                newSources.add(nw);\n+            }\n+            this.sources = newSources;\n+            if (this.sources.isEmpty()) {\n+                this.done = true;\n+            }\n+        }\n+\n+        public boolean done() {\n+            return this.done;\n+        }\n+\n+        public ShortestPaths shortestPaths() {\n+            return this.foundNodes;\n+        }\n+\n+        private double edgeWeight(HugeEdge edge) {\n+            double edgeWeight;\n+            if (this.weight == null ||\n+                !edge.property(this.weight).isPresent()) {\n+                edgeWeight = 1.0;\n+            } else {\n+                edgeWeight = edge.value(this.weight);\n+            }\n+            return edgeWeight;\n+        }\n+\n+        private Iterator<Edge> skipSuperNodeIfNeeded(Iterator<Edge> edges) {\n+            if (this.skipDegree <= 0L) {\n+                return edges;\n+            }\n+            List<Edge> edgeList = new ArrayList<>();\n+            for (int i = 1; edges.hasNext(); i++) {\n+                if (i <= this.degree) {\n+                    edgeList.add(edges.next());\n+                }\n+                if (i >= this.skipDegree) {\n+                    return QueryResults.emptyIterator();\n+                }\n+            }\n+            return edgeList.iterator();\n+        }\n+    }\n+\n+    public static class NodeWithWeight implements Comparable<NodeWithWeight> {\n+\n+        private final double weight;\n+        private final Node node;\n+\n+        public NodeWithWeight(double weight, Node node) {\n+            this.weight = weight;\n+            this.node = node;\n+        }\n+\n+        public NodeWithWeight(double weight, Id id, NodeWithWeight prio) {\n+            this(weight, new Node(id, prio.node()));\n+        }\n+\n+        public double weight() {\n+            return weight;\n+        }\n+\n+        public Node node() {\n+            return this.node;\n+        }\n+\n+        public Map<String, Object> toMap() {\n+            return ImmutableMap.of(\"weight\", this.weight,\n+                                   \"path\", this.node().path());\n+        }\n+\n+        @Override\n+        public int compareTo(NodeWithWeight o) {", "originalCommit": "f075c39b107d2003d1d8a06a57316260d1888a49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIyNTc1MA==", "url": "https://github.com/hugegraph/hugegraph/pull/919#discussion_r403225750", "bodyText": "don't new HashSet in hashCode(), prefer use for-loop: elem1 hash ^ elem2 hash ^ ...", "author": "javeme", "createdAt": "2020-04-03T18:29:45Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/SubGraphTraverser.java", "diffHunk": "@@ -245,4 +246,35 @@ private boolean finished() {\n             return this.sources.isEmpty();\n         }\n     }\n+\n+    private static class RingPath extends Path {\n+\n+        public RingPath(Id crosspoint, List<Id> vertices) {\n+            super(crosspoint, vertices);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return new HashSet<>(this.vertices()).hashCode();", "originalCommit": "f075c39b107d2003d1d8a06a57316260d1888a49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIyOTc0NA==", "url": "https://github.com/hugegraph/hugegraph/pull/919#discussion_r403229744", "bodyText": "don't copy and reverse, use for-loop instead", "author": "javeme", "createdAt": "2020-04-03T18:34:39Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/SubGraphTraverser.java", "diffHunk": "@@ -245,4 +246,35 @@ private boolean finished() {\n             return this.sources.isEmpty();\n         }\n     }\n+\n+    private static class RingPath extends Path {\n+\n+        public RingPath(Id crosspoint, List<Id> vertices) {\n+            super(crosspoint, vertices);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return new HashSet<>(this.vertices()).hashCode();\n+        }\n+\n+        /**\n+         * Compares the specified object with this path for equality.\n+         * Returns <tt>true</tt> if other path is equal to or\n+         * reversed of this path.\n+         * @param other the object to be compared\n+         * @return <tt>true</tt> if the specified object is equal to or\n+         * reversed of this path\n+         */\n+        @Override\n+        public boolean equals(Object other) {\n+            if (other == null || !(other instanceof RingPath)) {\n+                return false;\n+            }\n+            List<Id> reverse = new ArrayList<>(this.vertices());\n+            Collections.reverse(reverse);", "originalCommit": "f075c39b107d2003d1d8a06a57316260d1888a49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIzMTU4Nw==", "url": "https://github.com/hugegraph/hugegraph/pull/919#discussion_r403231587", "bodyText": "define PathSet class, let it extends HashSet, and add vertices() method to PathSet", "author": "javeme", "createdAt": "2020-04-03T18:36:50Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/SubGraphTraverser.java", "diffHunk": "@@ -43,23 +44,23 @@ public SubGraphTraverser(HugeGraph graph) {\n         super(graph);\n     }\n \n-    public List<Path> rays(Id sourceV, Directions dir, String label,\n-                           int depth, long degree, long capacity, long limit) {\n+    public Set<Path> rays(Id sourceV, Directions dir, String label,\n+                          int depth, long degree, long capacity, long limit) {\n         return this.subGraphPaths(sourceV, dir, label, depth, degree,\n                                   capacity, limit, false, false);\n     }\n \n-    public List<Path> rings(Id sourceV, Directions dir, String label, int depth,\n-                            boolean sourceInRing, long degree, long capacity,\n-                            long limit) {\n+    public Set<Path> rings(Id sourceV, Directions dir, String label, int depth,", "originalCommit": "f075c39b107d2003d1d8a06a57316260d1888a49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIzMzcxOQ==", "url": "https://github.com/hugegraph/hugegraph/pull/919#discussion_r403233719", "bodyText": "why from start from 1", "author": "javeme", "createdAt": "2020-04-03T18:39:18Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/SingleSourceShortestPathTraverser.java", "diffHunk": "@@ -0,0 +1,304 @@\n+/*\n+ * Copyright 2017 HugeGraph Authors\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.baidu.hugegraph.traversal.algorithm;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.tinkerpop.gremlin.structure.Edge;\n+\n+import com.baidu.hugegraph.HugeGraph;\n+import com.baidu.hugegraph.backend.id.Id;\n+import com.baidu.hugegraph.backend.query.QueryResults;\n+import com.baidu.hugegraph.structure.HugeEdge;\n+import com.baidu.hugegraph.type.define.Directions;\n+import com.baidu.hugegraph.util.CollectionUtil;\n+import com.baidu.hugegraph.util.E;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+public class SingleSourceShortestPathTraverser extends HugeTraverser {\n+\n+    public SingleSourceShortestPathTraverser(HugeGraph graph) {\n+        super(graph);\n+    }\n+\n+    public ShortestPaths singleSourceShortestPaths(Id sourceV, Directions dir,\n+                                                   String label, String weight,\n+                                                   long degree, long skipDegree,\n+                                                   long capacity, long limit) {\n+        E.checkNotNull(sourceV, \"source vertex id\");\n+        E.checkNotNull(dir, \"direction\");\n+        checkDegree(degree);\n+        checkCapacity(capacity);\n+        checkSkipDegree(skipDegree, degree, capacity);\n+        checkLimit(limit);\n+\n+        Id labelId = this.getEdgeLabelId(label);\n+        Traverser traverser = new Traverser(sourceV, dir, labelId, weight,\n+                                            degree, skipDegree, capacity,\n+                                            limit);\n+        while (true) {\n+            // Found, reach max depth or reach capacity, stop searching\n+            traverser.forward();\n+            if (traverser.done()) {\n+                return traverser.shortestPaths();\n+            }\n+            checkCapacity(traverser.capacity, traverser.size, \"shortest path\");\n+        }\n+    }\n+\n+    public NodeWithWeight weightedShortestPath(Id sourceV, Id targetV,\n+                                               Directions dir, String label,\n+                                               String weight, long degree,\n+                                               long skipDegree, long capacity) {\n+        E.checkNotNull(sourceV, \"source vertex id\");\n+        E.checkNotNull(dir, \"direction\");\n+        checkDegree(degree);\n+        checkCapacity(capacity);\n+        checkSkipDegree(skipDegree, degree, capacity);\n+\n+        Id labelId = this.getEdgeLabelId(label);\n+        Traverser traverser = new Traverser(sourceV, dir, labelId, weight,\n+                                            degree, skipDegree, capacity,\n+                                            NO_LIMIT);\n+        while (true) {\n+            traverser.forward();\n+            Map<Id, NodeWithWeight> results = traverser.shortestPaths();\n+            if (results.containsKey(targetV) || traverser.done()) {\n+                return results.get(targetV);\n+            }\n+            checkCapacity(traverser.capacity, traverser.size, \"shortest path\");\n+        }\n+    }\n+\n+    private static void checkSkipDegree(long skipDegree, long degree,\n+                                        long capacity) {\n+        E.checkArgument(skipDegree >= 0L,\n+                        \"The skipped degree must be >= 0, but got '%s'\",\n+                        skipDegree);\n+        if (capacity != NO_LIMIT) {\n+            E.checkArgument(degree != NO_LIMIT && degree < capacity,\n+                            \"The degree must be < capacity\");\n+            E.checkArgument(skipDegree < capacity,\n+                            \"The skipped degree must be < capacity\");\n+        }\n+        if (skipDegree > 0L) {\n+            E.checkArgument(degree != NO_LIMIT && skipDegree >= degree,\n+                            \"The skipped degree must be >= degree, \" +\n+                                    \"but got skipped degree '%s' and degree '%s'\",\n+                            skipDegree, degree);\n+        }\n+    }\n+\n+    private class Traverser {\n+\n+        private ShortestPaths findingNodes = new ShortestPaths();\n+        private ShortestPaths foundNodes = new ShortestPaths();\n+        private Set<NodeWithWeight> sources;\n+        private Id source;\n+        private final Directions direction;\n+        private final Id label;\n+        private final String weight;\n+        private final long degree;\n+        private final long skipDegree;\n+        private final long capacity;\n+        private final long limit;\n+        private long size;\n+        private boolean done = false;\n+\n+        public Traverser(Id sourceV, Directions dir, Id label, String weight,\n+                         long degree, long skipDegree, long capacity,\n+                         long limit) {\n+            this.source = sourceV;\n+            this.sources = ImmutableSet.of(new NodeWithWeight(\n+                           0D, new Node(sourceV, null)));\n+            this.direction = dir;\n+            this.label = label;\n+            this.weight = weight;\n+            this.degree = degree;\n+            this.skipDegree = skipDegree;\n+            this.capacity = capacity;\n+            this.limit = limit;\n+            this.size = 0L;\n+        }\n+\n+        /**\n+         * Search forward from source\n+         */\n+        public void forward() {\n+            long degree = this.skipDegree > 0L ? this.skipDegree : this.degree;\n+            for (NodeWithWeight node : this.sources) {\n+                Iterator<Edge> edges = edgesOfVertex(node.node().id(),\n+                                                     this.direction,\n+                                                     this.label, degree);\n+                edges = this.skipSuperNodeIfNeeded(edges);\n+                while (edges.hasNext()) {\n+                    HugeEdge edge = (HugeEdge) edges.next();\n+                    Id target = edge.id().otherVertexId();\n+\n+                    if (this.foundNodes.containsKey(target) ||\n+                        this.source.equals(target)) {\n+                        // Already find shortest path for target, skip\n+                        continue;\n+                    }\n+\n+                    double currentWeight = this.edgeWeight(edge);\n+                    double weight = currentWeight + node.weight();\n+                    NodeWithWeight nw = new NodeWithWeight(weight, target, node);\n+                    if (!this.findingNodes.containsKey(target) ||\n+                        weight < this.findingNodes.get(target).weight()) {\n+                        /*\n+                         * There are 2 scenarios to update finding nodes:\n+                         * 1. The 'target' found first time, add current path\n+                         * 2. Already exist path for 'target' and current\n+                         *    path is shorter, update path for 'target'\n+                         */\n+                        this.findingNodes.put(target, nw);\n+                    }\n+                }\n+            }\n+\n+            Map<Id, NodeWithWeight> sorted = CollectionUtil.sortByValue(\n+                                             this.findingNodes, true);\n+            double minWeight = 0;\n+            Set<NodeWithWeight> newSources = new HashSet<>();\n+            for (Map.Entry<Id, NodeWithWeight> entry : sorted.entrySet()) {\n+                Id id = entry.getKey();\n+                NodeWithWeight nw = entry.getValue();\n+                if (minWeight == 0) {\n+                    minWeight = nw.weight();\n+                } else if (nw.weight() > minWeight) {\n+                    break;\n+                }\n+                // Move shortest paths from 'findingNodes' to 'foundNodes'\n+                this.foundNodes.put(id, nw);\n+                if (this.limit != NO_LIMIT &&\n+                    this.foundNodes.size() >= this.limit) {\n+                    this.done = true;\n+                    return;\n+                }\n+                this.findingNodes.remove(id);\n+                // Re-init 'sources'\n+                newSources.add(nw);\n+            }\n+            this.sources = newSources;\n+            if (this.sources.isEmpty()) {\n+                this.done = true;\n+            }\n+        }\n+\n+        public boolean done() {\n+            return this.done;\n+        }\n+\n+        public ShortestPaths shortestPaths() {\n+            return this.foundNodes;\n+        }\n+\n+        private double edgeWeight(HugeEdge edge) {\n+            double edgeWeight;\n+            if (this.weight == null ||\n+                !edge.property(this.weight).isPresent()) {\n+                edgeWeight = 1.0;\n+            } else {\n+                edgeWeight = edge.value(this.weight);\n+            }\n+            return edgeWeight;\n+        }\n+\n+        private Iterator<Edge> skipSuperNodeIfNeeded(Iterator<Edge> edges) {\n+            if (this.skipDegree <= 0L) {\n+                return edges;\n+            }\n+            List<Edge> edgeList = new ArrayList<>();\n+            for (int i = 1; edges.hasNext(); i++) {", "originalCommit": "f075c39b107d2003d1d8a06a57316260d1888a49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIzNDY0Nw==", "url": "https://github.com/hugegraph/hugegraph/pull/919#discussion_r403234647", "bodyText": "rename to node or wn", "author": "javeme", "createdAt": "2020-04-03T18:40:28Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/SingleSourceShortestPathTraverser.java", "diffHunk": "@@ -0,0 +1,304 @@\n+/*\n+ * Copyright 2017 HugeGraph Authors\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.baidu.hugegraph.traversal.algorithm;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.tinkerpop.gremlin.structure.Edge;\n+\n+import com.baidu.hugegraph.HugeGraph;\n+import com.baidu.hugegraph.backend.id.Id;\n+import com.baidu.hugegraph.backend.query.QueryResults;\n+import com.baidu.hugegraph.structure.HugeEdge;\n+import com.baidu.hugegraph.type.define.Directions;\n+import com.baidu.hugegraph.util.CollectionUtil;\n+import com.baidu.hugegraph.util.E;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+public class SingleSourceShortestPathTraverser extends HugeTraverser {\n+\n+    public SingleSourceShortestPathTraverser(HugeGraph graph) {\n+        super(graph);\n+    }\n+\n+    public ShortestPaths singleSourceShortestPaths(Id sourceV, Directions dir,\n+                                                   String label, String weight,\n+                                                   long degree, long skipDegree,\n+                                                   long capacity, long limit) {\n+        E.checkNotNull(sourceV, \"source vertex id\");\n+        E.checkNotNull(dir, \"direction\");\n+        checkDegree(degree);\n+        checkCapacity(capacity);\n+        checkSkipDegree(skipDegree, degree, capacity);\n+        checkLimit(limit);\n+\n+        Id labelId = this.getEdgeLabelId(label);\n+        Traverser traverser = new Traverser(sourceV, dir, labelId, weight,\n+                                            degree, skipDegree, capacity,\n+                                            limit);\n+        while (true) {\n+            // Found, reach max depth or reach capacity, stop searching\n+            traverser.forward();\n+            if (traverser.done()) {\n+                return traverser.shortestPaths();\n+            }\n+            checkCapacity(traverser.capacity, traverser.size, \"shortest path\");\n+        }\n+    }\n+\n+    public NodeWithWeight weightedShortestPath(Id sourceV, Id targetV,\n+                                               Directions dir, String label,\n+                                               String weight, long degree,\n+                                               long skipDegree, long capacity) {\n+        E.checkNotNull(sourceV, \"source vertex id\");\n+        E.checkNotNull(dir, \"direction\");\n+        checkDegree(degree);\n+        checkCapacity(capacity);\n+        checkSkipDegree(skipDegree, degree, capacity);\n+\n+        Id labelId = this.getEdgeLabelId(label);\n+        Traverser traverser = new Traverser(sourceV, dir, labelId, weight,\n+                                            degree, skipDegree, capacity,\n+                                            NO_LIMIT);\n+        while (true) {\n+            traverser.forward();\n+            Map<Id, NodeWithWeight> results = traverser.shortestPaths();\n+            if (results.containsKey(targetV) || traverser.done()) {\n+                return results.get(targetV);\n+            }\n+            checkCapacity(traverser.capacity, traverser.size, \"shortest path\");\n+        }\n+    }\n+\n+    private static void checkSkipDegree(long skipDegree, long degree,\n+                                        long capacity) {\n+        E.checkArgument(skipDegree >= 0L,\n+                        \"The skipped degree must be >= 0, but got '%s'\",\n+                        skipDegree);\n+        if (capacity != NO_LIMIT) {\n+            E.checkArgument(degree != NO_LIMIT && degree < capacity,\n+                            \"The degree must be < capacity\");\n+            E.checkArgument(skipDegree < capacity,\n+                            \"The skipped degree must be < capacity\");\n+        }\n+        if (skipDegree > 0L) {\n+            E.checkArgument(degree != NO_LIMIT && skipDegree >= degree,\n+                            \"The skipped degree must be >= degree, \" +\n+                                    \"but got skipped degree '%s' and degree '%s'\",\n+                            skipDegree, degree);\n+        }\n+    }\n+\n+    private class Traverser {\n+\n+        private ShortestPaths findingNodes = new ShortestPaths();\n+        private ShortestPaths foundNodes = new ShortestPaths();\n+        private Set<NodeWithWeight> sources;\n+        private Id source;\n+        private final Directions direction;\n+        private final Id label;\n+        private final String weight;\n+        private final long degree;\n+        private final long skipDegree;\n+        private final long capacity;\n+        private final long limit;\n+        private long size;\n+        private boolean done = false;\n+\n+        public Traverser(Id sourceV, Directions dir, Id label, String weight,\n+                         long degree, long skipDegree, long capacity,\n+                         long limit) {\n+            this.source = sourceV;\n+            this.sources = ImmutableSet.of(new NodeWithWeight(\n+                           0D, new Node(sourceV, null)));\n+            this.direction = dir;\n+            this.label = label;\n+            this.weight = weight;\n+            this.degree = degree;\n+            this.skipDegree = skipDegree;\n+            this.capacity = capacity;\n+            this.limit = limit;\n+            this.size = 0L;\n+        }\n+\n+        /**\n+         * Search forward from source\n+         */\n+        public void forward() {\n+            long degree = this.skipDegree > 0L ? this.skipDegree : this.degree;\n+            for (NodeWithWeight node : this.sources) {\n+                Iterator<Edge> edges = edgesOfVertex(node.node().id(),\n+                                                     this.direction,\n+                                                     this.label, degree);\n+                edges = this.skipSuperNodeIfNeeded(edges);\n+                while (edges.hasNext()) {\n+                    HugeEdge edge = (HugeEdge) edges.next();\n+                    Id target = edge.id().otherVertexId();\n+\n+                    if (this.foundNodes.containsKey(target) ||\n+                        this.source.equals(target)) {\n+                        // Already find shortest path for target, skip\n+                        continue;\n+                    }\n+\n+                    double currentWeight = this.edgeWeight(edge);\n+                    double weight = currentWeight + node.weight();\n+                    NodeWithWeight nw = new NodeWithWeight(weight, target, node);\n+                    if (!this.findingNodes.containsKey(target) ||\n+                        weight < this.findingNodes.get(target).weight()) {\n+                        /*\n+                         * There are 2 scenarios to update finding nodes:\n+                         * 1. The 'target' found first time, add current path\n+                         * 2. Already exist path for 'target' and current\n+                         *    path is shorter, update path for 'target'\n+                         */\n+                        this.findingNodes.put(target, nw);\n+                    }\n+                }\n+            }\n+\n+            Map<Id, NodeWithWeight> sorted = CollectionUtil.sortByValue(\n+                                             this.findingNodes, true);\n+            double minWeight = 0;\n+            Set<NodeWithWeight> newSources = new HashSet<>();\n+            for (Map.Entry<Id, NodeWithWeight> entry : sorted.entrySet()) {\n+                Id id = entry.getKey();\n+                NodeWithWeight nw = entry.getValue();", "originalCommit": "f075c39b107d2003d1d8a06a57316260d1888a49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIzNTYxMw==", "url": "https://github.com/hugegraph/hugegraph/pull/919#discussion_r403235613", "bodyText": "node = this.findingNodes.get(target);\nnode == null || weight < node.weight()", "author": "javeme", "createdAt": "2020-04-03T18:41:45Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/SingleSourceShortestPathTraverser.java", "diffHunk": "@@ -0,0 +1,304 @@\n+/*\n+ * Copyright 2017 HugeGraph Authors\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.baidu.hugegraph.traversal.algorithm;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.tinkerpop.gremlin.structure.Edge;\n+\n+import com.baidu.hugegraph.HugeGraph;\n+import com.baidu.hugegraph.backend.id.Id;\n+import com.baidu.hugegraph.backend.query.QueryResults;\n+import com.baidu.hugegraph.structure.HugeEdge;\n+import com.baidu.hugegraph.type.define.Directions;\n+import com.baidu.hugegraph.util.CollectionUtil;\n+import com.baidu.hugegraph.util.E;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+public class SingleSourceShortestPathTraverser extends HugeTraverser {\n+\n+    public SingleSourceShortestPathTraverser(HugeGraph graph) {\n+        super(graph);\n+    }\n+\n+    public ShortestPaths singleSourceShortestPaths(Id sourceV, Directions dir,\n+                                                   String label, String weight,\n+                                                   long degree, long skipDegree,\n+                                                   long capacity, long limit) {\n+        E.checkNotNull(sourceV, \"source vertex id\");\n+        E.checkNotNull(dir, \"direction\");\n+        checkDegree(degree);\n+        checkCapacity(capacity);\n+        checkSkipDegree(skipDegree, degree, capacity);\n+        checkLimit(limit);\n+\n+        Id labelId = this.getEdgeLabelId(label);\n+        Traverser traverser = new Traverser(sourceV, dir, labelId, weight,\n+                                            degree, skipDegree, capacity,\n+                                            limit);\n+        while (true) {\n+            // Found, reach max depth or reach capacity, stop searching\n+            traverser.forward();\n+            if (traverser.done()) {\n+                return traverser.shortestPaths();\n+            }\n+            checkCapacity(traverser.capacity, traverser.size, \"shortest path\");\n+        }\n+    }\n+\n+    public NodeWithWeight weightedShortestPath(Id sourceV, Id targetV,\n+                                               Directions dir, String label,\n+                                               String weight, long degree,\n+                                               long skipDegree, long capacity) {\n+        E.checkNotNull(sourceV, \"source vertex id\");\n+        E.checkNotNull(dir, \"direction\");\n+        checkDegree(degree);\n+        checkCapacity(capacity);\n+        checkSkipDegree(skipDegree, degree, capacity);\n+\n+        Id labelId = this.getEdgeLabelId(label);\n+        Traverser traverser = new Traverser(sourceV, dir, labelId, weight,\n+                                            degree, skipDegree, capacity,\n+                                            NO_LIMIT);\n+        while (true) {\n+            traverser.forward();\n+            Map<Id, NodeWithWeight> results = traverser.shortestPaths();\n+            if (results.containsKey(targetV) || traverser.done()) {\n+                return results.get(targetV);\n+            }\n+            checkCapacity(traverser.capacity, traverser.size, \"shortest path\");\n+        }\n+    }\n+\n+    private static void checkSkipDegree(long skipDegree, long degree,\n+                                        long capacity) {\n+        E.checkArgument(skipDegree >= 0L,\n+                        \"The skipped degree must be >= 0, but got '%s'\",\n+                        skipDegree);\n+        if (capacity != NO_LIMIT) {\n+            E.checkArgument(degree != NO_LIMIT && degree < capacity,\n+                            \"The degree must be < capacity\");\n+            E.checkArgument(skipDegree < capacity,\n+                            \"The skipped degree must be < capacity\");\n+        }\n+        if (skipDegree > 0L) {\n+            E.checkArgument(degree != NO_LIMIT && skipDegree >= degree,\n+                            \"The skipped degree must be >= degree, \" +\n+                                    \"but got skipped degree '%s' and degree '%s'\",\n+                            skipDegree, degree);\n+        }\n+    }\n+\n+    private class Traverser {\n+\n+        private ShortestPaths findingNodes = new ShortestPaths();\n+        private ShortestPaths foundNodes = new ShortestPaths();\n+        private Set<NodeWithWeight> sources;\n+        private Id source;\n+        private final Directions direction;\n+        private final Id label;\n+        private final String weight;\n+        private final long degree;\n+        private final long skipDegree;\n+        private final long capacity;\n+        private final long limit;\n+        private long size;\n+        private boolean done = false;\n+\n+        public Traverser(Id sourceV, Directions dir, Id label, String weight,\n+                         long degree, long skipDegree, long capacity,\n+                         long limit) {\n+            this.source = sourceV;\n+            this.sources = ImmutableSet.of(new NodeWithWeight(\n+                           0D, new Node(sourceV, null)));\n+            this.direction = dir;\n+            this.label = label;\n+            this.weight = weight;\n+            this.degree = degree;\n+            this.skipDegree = skipDegree;\n+            this.capacity = capacity;\n+            this.limit = limit;\n+            this.size = 0L;\n+        }\n+\n+        /**\n+         * Search forward from source\n+         */\n+        public void forward() {\n+            long degree = this.skipDegree > 0L ? this.skipDegree : this.degree;\n+            for (NodeWithWeight node : this.sources) {\n+                Iterator<Edge> edges = edgesOfVertex(node.node().id(),\n+                                                     this.direction,\n+                                                     this.label, degree);\n+                edges = this.skipSuperNodeIfNeeded(edges);\n+                while (edges.hasNext()) {\n+                    HugeEdge edge = (HugeEdge) edges.next();\n+                    Id target = edge.id().otherVertexId();\n+\n+                    if (this.foundNodes.containsKey(target) ||\n+                        this.source.equals(target)) {\n+                        // Already find shortest path for target, skip\n+                        continue;\n+                    }\n+\n+                    double currentWeight = this.edgeWeight(edge);\n+                    double weight = currentWeight + node.weight();\n+                    NodeWithWeight nw = new NodeWithWeight(weight, target, node);\n+                    if (!this.findingNodes.containsKey(target) ||\n+                        weight < this.findingNodes.get(target).weight()) {\n+                        /*", "originalCommit": "f075c39b107d2003d1d8a06a57316260d1888a49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIzNjU4Mw==", "url": "https://github.com/hugegraph/hugegraph/pull/919#discussion_r403236583", "bodyText": "align", "author": "javeme", "createdAt": "2020-04-03T18:42:56Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/SingleSourceShortestPathTraverser.java", "diffHunk": "@@ -0,0 +1,304 @@\n+/*\n+ * Copyright 2017 HugeGraph Authors\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.baidu.hugegraph.traversal.algorithm;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.tinkerpop.gremlin.structure.Edge;\n+\n+import com.baidu.hugegraph.HugeGraph;\n+import com.baidu.hugegraph.backend.id.Id;\n+import com.baidu.hugegraph.backend.query.QueryResults;\n+import com.baidu.hugegraph.structure.HugeEdge;\n+import com.baidu.hugegraph.type.define.Directions;\n+import com.baidu.hugegraph.util.CollectionUtil;\n+import com.baidu.hugegraph.util.E;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+public class SingleSourceShortestPathTraverser extends HugeTraverser {\n+\n+    public SingleSourceShortestPathTraverser(HugeGraph graph) {\n+        super(graph);\n+    }\n+\n+    public ShortestPaths singleSourceShortestPaths(Id sourceV, Directions dir,\n+                                                   String label, String weight,\n+                                                   long degree, long skipDegree,\n+                                                   long capacity, long limit) {\n+        E.checkNotNull(sourceV, \"source vertex id\");\n+        E.checkNotNull(dir, \"direction\");\n+        checkDegree(degree);\n+        checkCapacity(capacity);\n+        checkSkipDegree(skipDegree, degree, capacity);\n+        checkLimit(limit);\n+\n+        Id labelId = this.getEdgeLabelId(label);\n+        Traverser traverser = new Traverser(sourceV, dir, labelId, weight,\n+                                            degree, skipDegree, capacity,\n+                                            limit);\n+        while (true) {\n+            // Found, reach max depth or reach capacity, stop searching\n+            traverser.forward();\n+            if (traverser.done()) {\n+                return traverser.shortestPaths();\n+            }\n+            checkCapacity(traverser.capacity, traverser.size, \"shortest path\");\n+        }\n+    }\n+\n+    public NodeWithWeight weightedShortestPath(Id sourceV, Id targetV,\n+                                               Directions dir, String label,\n+                                               String weight, long degree,\n+                                               long skipDegree, long capacity) {\n+        E.checkNotNull(sourceV, \"source vertex id\");\n+        E.checkNotNull(dir, \"direction\");\n+        checkDegree(degree);\n+        checkCapacity(capacity);\n+        checkSkipDegree(skipDegree, degree, capacity);\n+\n+        Id labelId = this.getEdgeLabelId(label);\n+        Traverser traverser = new Traverser(sourceV, dir, labelId, weight,\n+                                            degree, skipDegree, capacity,\n+                                            NO_LIMIT);\n+        while (true) {\n+            traverser.forward();\n+            Map<Id, NodeWithWeight> results = traverser.shortestPaths();\n+            if (results.containsKey(targetV) || traverser.done()) {\n+                return results.get(targetV);\n+            }\n+            checkCapacity(traverser.capacity, traverser.size, \"shortest path\");\n+        }\n+    }\n+\n+    private static void checkSkipDegree(long skipDegree, long degree,\n+                                        long capacity) {\n+        E.checkArgument(skipDegree >= 0L,\n+                        \"The skipped degree must be >= 0, but got '%s'\",\n+                        skipDegree);\n+        if (capacity != NO_LIMIT) {\n+            E.checkArgument(degree != NO_LIMIT && degree < capacity,\n+                            \"The degree must be < capacity\");\n+            E.checkArgument(skipDegree < capacity,\n+                            \"The skipped degree must be < capacity\");\n+        }\n+        if (skipDegree > 0L) {\n+            E.checkArgument(degree != NO_LIMIT && skipDegree >= degree,\n+                            \"The skipped degree must be >= degree, \" +\n+                                    \"but got skipped degree '%s' and degree '%s'\",", "originalCommit": "f075c39b107d2003d1d8a06a57316260d1888a49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzIzOTQ0Mw==", "url": "https://github.com/hugegraph/hugegraph/pull/919#discussion_r403239443", "bodyText": "add var for paths.iterator().next()", "author": "javeme", "createdAt": "2020-04-03T18:46:18Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/ShortestPathTraverser.java", "diffHunk": "@@ -60,21 +65,63 @@ public ShortestPathTraverser(HugeGraph graph) {\n         Id labelId = this.getEdgeLabelId(label);\n         Traverser traverser = new Traverser(sourceV, targetV, dir, labelId,\n                                             degree, skipDegree, capacity);\n-        List<Id> path;\n+        Set<List<Id>> paths;\n+        while (true) {\n+            // Found, reach max depth or reach capacity, stop searching\n+            if (!(paths = traverser.forward(false)).isEmpty() ||\n+                --depth <= 0) {\n+                break;\n+            }\n+            checkCapacity(traverser.capacity, traverser.size, \"shortest path\");\n+\n+            if (!(paths = traverser.backward(false)).isEmpty() ||\n+                --depth <= 0) {\n+                Collections.reverse(paths.iterator().next());", "originalCommit": "f075c39b107d2003d1d8a06a57316260d1888a49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI0MTY3OA==", "url": "https://github.com/hugegraph/hugegraph/pull/919#discussion_r403241678", "bodyText": "don't convert to set at line 207, we support CollectionUtils.intersect(list,list):\nintersect(Collection<T> first, Collection<T> second)", "author": "javeme", "createdAt": "2020-04-03T18:50:02Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java", "diffHunk": "@@ -171,6 +172,50 @@ public HugeGraph graph() {\n         return all;\n     }\n \n+    public Set<Id> sameNeighbors(Id vertex, Id other, Directions direction,\n+                                 String label, long degree, long limit) {\n+        E.checkNotNull(vertex, \"vertex id\");\n+        E.checkNotNull(other, \"the other vertex id\");\n+        E.checkNotNull(direction, \"direction\");\n+        checkDegree(degree);\n+        checkLimit(limit);\n+\n+        Id labelId = this.getEdgeLabelId(label);\n+\n+        Set<Id> sourceNeighbors = IteratorUtils.set(this.adjacentVertices(\n+                                  vertex, direction, labelId, degree));\n+        Set<Id> targetNeighbors = IteratorUtils.set(this.adjacentVertices(\n+                                  other, direction, labelId, degree));\n+        Set<Id> sameNeighbors = (Set<Id>) CollectionUtil.intersect(\n+                                sourceNeighbors, targetNeighbors);\n+        if (limit != NO_LIMIT) {\n+            int end = Math.min(sameNeighbors.size(), (int) limit);\n+            sameNeighbors = CollectionUtil.subSet(sameNeighbors, 0, end);\n+        }\n+        return sameNeighbors;\n+    }\n+\n+    public double jaccardSimilarity(Id vertex, Id other, Directions dir,\n+                                    String label, long degree) {\n+        E.checkNotNull(vertex, \"vertex id\");\n+        E.checkNotNull(other, \"the other vertex id\");\n+        E.checkNotNull(dir, \"direction\");\n+        checkDegree(degree);\n+\n+        Id labelId = this.getEdgeLabelId(label);\n+\n+        Set<Id> sourceNeighbors = IteratorUtils.set(this.adjacentVertices(\n+                                  vertex, dir, labelId, degree));\n+        Set<Id> targetNeighbors = IteratorUtils.set(this.adjacentVertices(\n+                                  other, dir, labelId, degree));\n+        int interNum = CollectionUtils.intersection(sourceNeighbors,", "originalCommit": "f075c39b107d2003d1d8a06a57316260d1888a49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ1ODU0Ng==", "url": "https://github.com/hugegraph/hugegraph/pull/919#discussion_r403458546", "bodyText": "adjacentVertices() returns Iterator. Convert to list or set is necessary", "author": "zhoney", "createdAt": "2020-04-04T11:19:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzI0MTY3OA=="}], "type": "inlineReview"}, {"oid": "de9231198392dc798405148746dfa2449d50f759", "url": "https://github.com/hugegraph/hugegraph/commit/de9231198392dc798405148746dfa2449d50f759", "message": "improve\n\nChange-Id: Ib232cedf775eca8b7dee333c1db5c4cfa8912e12", "committedDate": "2020-04-04T13:19:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzUwNjUxNQ==", "url": "https://github.com/hugegraph/hugegraph/pull/919#discussion_r403506515", "bodyText": "seems it's not checked at upper layer", "author": "javeme", "createdAt": "2020-04-04T19:20:32Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/SingleSourceShortestPathTraverser.java", "diffHunk": "@@ -76,6 +76,7 @@ public NodeWithWeight weightedShortestPath(Id sourceV, Id targetV,\n                                                long skipDegree, long capacity) {\n         E.checkNotNull(sourceV, \"source vertex id\");\n         E.checkNotNull(dir, \"direction\");\n+        E.checkNotNull(weight, \"weight property\");", "originalCommit": "de9231198392dc798405148746dfa2449d50f759", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzUwNjgwMw==", "url": "https://github.com/hugegraph/hugegraph/pull/919#discussion_r403506803", "bodyText": "check weight", "author": "javeme", "createdAt": "2020-04-04T19:23:46Z", "path": "hugegraph-api/src/main/java/com/baidu/hugegraph/api/traversers/WeightedShortestPathAPI.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2017 HugeGraph Authors\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.baidu.hugegraph.api.traversers;\n+\n+import java.util.Iterator;\n+\n+import javax.inject.Singleton;\n+import javax.ws.rs.DefaultValue;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.QueryParam;\n+import javax.ws.rs.core.Context;\n+\n+import org.apache.tinkerpop.gremlin.structure.Vertex;\n+import org.slf4j.Logger;\n+\n+import com.baidu.hugegraph.HugeGraph;\n+import com.baidu.hugegraph.api.API;\n+import com.baidu.hugegraph.api.graph.EdgeAPI;\n+import com.baidu.hugegraph.api.graph.VertexAPI;\n+import com.baidu.hugegraph.backend.id.Id;\n+import com.baidu.hugegraph.backend.query.QueryResults;\n+import com.baidu.hugegraph.core.GraphManager;\n+import com.baidu.hugegraph.server.RestServer;\n+import com.baidu.hugegraph.traversal.algorithm.SingleSourceShortestPathTraverser;\n+import com.baidu.hugegraph.traversal.algorithm.SingleSourceShortestPathTraverser.NodeWithWeight;\n+import com.baidu.hugegraph.type.define.Directions;\n+import com.baidu.hugegraph.util.Log;\n+import com.codahale.metrics.annotation.Timed;\n+\n+import static com.baidu.hugegraph.traversal.algorithm.HugeTraverser.DEFAULT_CAPACITY;\n+import static com.baidu.hugegraph.traversal.algorithm.HugeTraverser.DEFAULT_DEGREE;\n+\n+@Path(\"graphs/{graph}/traversers/weightedshortestpath\")\n+@Singleton\n+public class WeightedShortestPathAPI extends API {\n+\n+    private static final Logger LOG = Log.logger(RestServer.class);\n+\n+    @GET\n+    @Timed\n+    @Produces(APPLICATION_JSON_WITH_CHARSET)\n+    public String get(@Context GraphManager manager,\n+                      @PathParam(\"graph\") String graph,\n+                      @QueryParam(\"source\") String source,\n+                      @QueryParam(\"target\") String target,\n+                      @QueryParam(\"direction\") String direction,\n+                      @QueryParam(\"label\") String edgeLabel,\n+                      @QueryParam(\"weight\") String weight,\n+                      @QueryParam(\"max_degree\")\n+                      @DefaultValue(DEFAULT_DEGREE) long degree,\n+                      @QueryParam(\"skip_degree\")\n+                      @DefaultValue(\"0\") long skipDegree,\n+                      @QueryParam(\"capacity\")\n+                      @DefaultValue(DEFAULT_CAPACITY) long capacity,\n+                      @QueryParam(\"with_vertex\") boolean withVertex) {\n+        LOG.debug(\"Graph [{}] get weighted shortest path between '{}' and \" +\n+                  \"'{}' with direction {}, edge label {}, weight property {}, \" +\n+                  \"max degree '{}', skip degree '{}', capacity '{}', \" +\n+                  \"and with vertex '{}'\",\n+                  graph, source, target, direction, edgeLabel, weight, degree,\n+                  skipDegree, capacity, withVertex);\n+\n+        Id sourceId = VertexAPI.checkAndParseVertexId(source);\n+        Id targetId = VertexAPI.checkAndParseVertexId(target);\n+        Directions dir = Directions.convert(EdgeAPI.parseDirection(direction));", "originalCommit": "de9231198392dc798405148746dfa2449d50f759", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzUwNjkwNQ==", "url": "https://github.com/hugegraph/hugegraph/pull/919#discussion_r403506905", "bodyText": "prefer move to HugeTraverser.java", "author": "javeme", "createdAt": "2020-04-04T19:24:30Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/SubGraphTraverser.java", "diffHunk": "@@ -245,4 +244,62 @@ private boolean finished() {\n             return this.sources.isEmpty();\n         }\n     }\n+\n+    private static class RingPath extends Path {\n+\n+        public RingPath(Id crosspoint, List<Id> vertices) {\n+            super(crosspoint, vertices);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            int hashCode = 0;\n+            for (Id id : this.vertices()) {\n+                hashCode ^= id.hashCode();\n+            }\n+            return hashCode;\n+        }\n+\n+        /**\n+         * Compares the specified object with this path for equality.\n+         * Returns <tt>true</tt> if other path is equal to or\n+         * reversed of this path.\n+         * @param other the object to be compared\n+         * @return <tt>true</tt> if the specified object is equal to or\n+         * reversed of this path\n+         */\n+        @Override\n+        public boolean equals(Object other) {\n+            if (other == null || !(other instanceof RingPath)) {\n+                return false;\n+            }\n+            List<Id> otherVertices = ((Path) other).vertices();\n+            if (this.vertices().equals(otherVertices)) {\n+                return true;\n+            }\n+            if (this.vertices().size() != otherVertices.size()) {\n+                return false;\n+            }\n+            assert this.vertices().size() != otherVertices.size();\n+            int size = this.vertices().size();\n+            for (int i = 0; i < size; i++) {\n+                if (!this.vertices().get(i).equals(\n+                     otherVertices.get(size - i - 1))) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+    }\n+\n+    public static class PathSet extends HashSet<Path> {", "originalCommit": "de9231198392dc798405148746dfa2449d50f759", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0a8c81df8fd994bb7c846b347e14d9e6982531de", "url": "https://github.com/hugegraph/hugegraph/commit/0a8c81df8fd994bb7c846b347e14d9e6982531de", "message": "tiny improve\n\nChange-Id: I84788b5145fadb91b8b0d97c66c2f62e12c8294e", "committedDate": "2020-04-05T04:55:26Z", "type": "commit"}]}