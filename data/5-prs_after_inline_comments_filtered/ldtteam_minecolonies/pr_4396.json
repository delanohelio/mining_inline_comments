{"pr_number": 4396, "pr_title": "Feature/hospital", "pr_createdAt": "2020-03-07T15:49:55Z", "pr_url": "https://github.com/ldtteam/minecolonies/pull/4396", "timeline": [{"oid": "f0b94ceec2d00aa4051c82480783121af612772b", "url": "https://github.com/ldtteam/minecolonies/commit/f0b94ceec2d00aa4051c82480783121af612772b", "message": "Add hospital setup", "committedDate": "2020-02-23T18:05:34Z", "type": "commit"}, {"oid": "40f7e671843b292b6f6f42b4c3ff5d0ec6bbc05f", "url": "https://github.com/ldtteam/minecolonies/commit/40f7e671843b292b6f6f42b4c3ff5d0ec6bbc05f", "message": "Add some logging", "committedDate": "2020-02-24T11:11:47Z", "type": "commit"}, {"oid": "bdbc56979eda15a9823af091749719ade790b1e9", "url": "https://github.com/ldtteam/minecolonies/commit/bdbc56979eda15a9823af091749719ade790b1e9", "message": "Add healer job and models", "committedDate": "2020-02-25T13:49:55Z", "type": "commit"}, {"oid": "cfe121aedf99844795cb420e7fa318854cadc6b5", "url": "https://github.com/ldtteam/minecolonies/commit/cfe121aedf99844795cb420e7fa318854cadc6b5", "message": "Initital disease setup", "committedDate": "2020-02-25T20:58:41Z", "type": "commit"}, {"oid": "1adfeb16c5ddcaa82d0cae21d715fbf737f6f5af", "url": "https://github.com/ldtteam/minecolonies/commit/1adfeb16c5ddcaa82d0cae21d715fbf737f6f5af", "message": "Fix rack/chest placement", "committedDate": "2020-03-01T09:33:13Z", "type": "commit"}, {"oid": "8f74d65ea8c6a4d1aaec8b8ff7b68cb6a60fd75d", "url": "https://github.com/ldtteam/minecolonies/commit/8f74d65ea8c6a4d1aaec8b8ff7b68cb6a60fd75d", "message": "add some todos", "committedDate": "2020-03-01T09:33:22Z", "type": "commit"}, {"oid": "800e71ab635c007f1a1f130890f5a1f4decafbd7", "url": "https://github.com/ldtteam/minecolonies/commit/800e71ab635c007f1a1f130890f5a1f4decafbd7", "message": "Start AI setup", "committedDate": "2020-03-01T22:49:28Z", "type": "commit"}, {"oid": "472f6ff9207a849259192bbc9e3fd4c834a59adc", "url": "https://github.com/ldtteam/minecolonies/commit/472f6ff9207a849259192bbc9e3fd4c834a59adc", "message": "some", "committedDate": "2020-03-02T20:12:30Z", "type": "commit"}, {"oid": "c4aef3b9caf67a2c2db39486c3c2e0b379bbb38d", "url": "https://github.com/ldtteam/minecolonies/commit/c4aef3b9caf67a2c2db39486c3c2e0b379bbb38d", "message": "Merge branch 'version/1.15' into feature/hospital", "committedDate": "2020-03-02T20:15:51Z", "type": "commit"}, {"oid": "5ccf5ff64572ee092d670bd1f4e907306fe1d417", "url": "https://github.com/ldtteam/minecolonies/commit/5ccf5ff64572ee092d670bd1f4e907306fe1d417", "message": "fix port", "committedDate": "2020-03-04T15:49:54Z", "type": "commit"}, {"oid": "4c17d27f93cb1b9e95685b3e37316090ac47b404", "url": "https://github.com/ldtteam/minecolonies/commit/4c17d27f93cb1b9e95685b3e37316090ac47b404", "message": "Finish 90% of the AI code", "committedDate": "2020-03-05T21:34:42Z", "type": "commit"}, {"oid": "8049273707b77a00b1bd99bb738a26dd84da0700", "url": "https://github.com/ldtteam/minecolonies/commit/8049273707b77a00b1bd99bb738a26dd84da0700", "message": "finish healer AI", "committedDate": "2020-03-06T15:21:54Z", "type": "commit"}, {"oid": "faacbaa8732bf74189125e503a23fc28a9036f60", "url": "https://github.com/ldtteam/minecolonies/commit/faacbaa8732bf74189125e503a23fc28a9036f60", "message": "Fix handling", "committedDate": "2020-03-06T21:31:20Z", "type": "commit"}, {"oid": "490fc5815cc477dc02fddd113ca5ef416875811b", "url": "https://github.com/ldtteam/minecolonies/commit/490fc5815cc477dc02fddd113ca5ef416875811b", "message": "fix wakeup and cure transfer", "committedDate": "2020-03-06T21:44:58Z", "type": "commit"}, {"oid": "620202a3bd96708b222af2d5f696e5e2f9f1d99d", "url": "https://github.com/ldtteam/minecolonies/commit/620202a3bd96708b222af2d5f696e5e2f9f1d99d", "message": "Merge remote-tracking branch 'origin/version/1.15' into feature/hospital", "committedDate": "2020-03-07T09:02:48Z", "type": "commit"}, {"oid": "02e3c410ee1bceb06ec7b0c8d8f582134ec7fec1", "url": "https://github.com/ldtteam/minecolonies/commit/02e3c410ee1bceb06ec7b0c8d8f582134ec7fec1", "message": "fix task prio and some AI issues", "committedDate": "2020-03-07T10:35:48Z", "type": "commit"}, {"oid": "d52f3dab8e6f64f5356b5fd9ff4af2a7926817a8", "url": "https://github.com/ldtteam/minecolonies/commit/d52f3dab8e6f64f5356b5fd9ff4af2a7926817a8", "message": "re-request correctly", "committedDate": "2020-03-07T15:41:00Z", "type": "commit"}, {"oid": "d6e93ff666666cd2a85e1ba7b07c9d9485493478", "url": "https://github.com/ldtteam/minecolonies/commit/d6e93ff666666cd2a85e1ba7b07c9d9485493478", "message": "reenable random cure", "committedDate": "2020-03-07T15:47:55Z", "type": "commit"}, {"oid": "0c85c63781ba3b91bbe54a44eae918424dbda332", "url": "https://github.com/ldtteam/minecolonies/commit/0c85c63781ba3b91bbe54a44eae918424dbda332", "message": "make them go to bed at night when there is no free bed at a hospital", "committedDate": "2020-03-07T16:05:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTI2NDY1OQ==", "url": "https://github.com/ldtteam/minecolonies/pull/4396#discussion_r389264659", "bodyText": "few unnecessary semicolony after healer and researcher", "author": "someaddons", "createdAt": "2020-03-07T16:07:42Z", "path": "src/api/java/com/minecolonies/api/colony/jobs/ModJobs.java", "diffHunk": "@@ -36,6 +36,7 @@\n     public static final ResourceLocation FLORIST_ID        = new ResourceLocation(Constants.MOD_ID,\"florist\");\n     public static final ResourceLocation ENCHANTER_ID      = new ResourceLocation(Constants.MOD_ID,\"enchanter\");\n     public static final ResourceLocation RESEARCHER_ID     = new ResourceLocation(Constants.MOD_ID,\"researcher\");;\n+    public static final ResourceLocation HEALER_ID         = new ResourceLocation(Constants.MOD_ID,\"healer\");;", "originalCommit": "0c85c63781ba3b91bbe54a44eae918424dbda332", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "62507d0f36a5e81d8810f4f62a9dd240f7f3ac60", "url": "https://github.com/ldtteam/minecolonies/commit/62507d0f36a5e81d8810f4f62a9dd240f7f3ac60", "message": "fix up formatting, fix some small things", "committedDate": "2020-03-07T17:13:34Z", "type": "commit"}, {"oid": "5ee57853df91fe18dcd8a47e0b80e595377b9fc6", "url": "https://github.com/ldtteam/minecolonies/commit/5ee57853df91fe18dcd8a47e0b80e595377b9fc6", "message": "some config cleanup", "committedDate": "2020-03-07T18:18:44Z", "type": "commit"}, {"oid": "d9a9914699bff94ecb97f6c1c2ea8f2272b1f3e7", "url": "https://github.com/ldtteam/minecolonies/commit/d9a9914699bff94ecb97f6c1c2ea8f2272b1f3e7", "message": "fix namings", "committedDate": "2020-03-07T18:46:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTI2NDc0Ng==", "url": "https://github.com/ldtteam/minecolonies/pull/4396#discussion_r389264746", "bodyText": "old javadoc", "author": "someaddons", "createdAt": "2020-03-07T16:09:02Z", "path": "src/api/java/com/minecolonies/api/compatibility/CompatibilityManager.java", "diffHunk": "@@ -611,6 +638,57 @@ private void discoverLuckyOres()\n         Log.getLogger().info(\"Finished discovering lucky oreBlocks\");\n     }\n \n+    /**\n+     * Run through all blocks and check if they match one of our lucky oreBlocks.\n+     */\n+    private void discoverDiseases()", "originalCommit": "0c85c63781ba3b91bbe54a44eae918424dbda332", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMwNDUzOQ==", "url": "https://github.com/ldtteam/minecolonies/pull/4396#discussion_r389304539", "bodyText": "fixed", "author": "Raycoms", "createdAt": "2020-03-07T19:04:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTI2NDc0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTI2NDc3NQ==", "url": "https://github.com/ldtteam/minecolonies/pull/4396#discussion_r389264775", "bodyText": "bad log message", "author": "someaddons", "createdAt": "2020-03-07T16:09:53Z", "path": "src/api/java/com/minecolonies/api/compatibility/CompatibilityManager.java", "diffHunk": "@@ -611,6 +638,57 @@ private void discoverLuckyOres()\n         Log.getLogger().info(\"Finished discovering lucky oreBlocks\");\n     }\n \n+    /**\n+     * Run through all blocks and check if they match one of our lucky oreBlocks.\n+     */\n+    private void discoverDiseases()\n+    {\n+        if (diseases.isEmpty())\n+        {\n+            for (final String ore : MinecoloniesAPIProxy.getInstance().getConfig().getCommon().diseases.get())\n+            {\n+                final String[] split = ore.split(\",\");\n+                if (split.length < 3)\n+                {\n+                    Log.getLogger().warn(\"Wrongly configured disease: \" + ore);\n+                    continue;\n+                }\n+\n+                try\n+                {\n+                    final String name = split[0];\n+                    final int rarity = Integer.parseInt(split[1]);\n+\n+                    final List<ItemStack> cure = new ArrayList<>();\n+\n+                    for (int i = 2; i < split.length; i++)\n+                    {\n+                        final String[] theItem = split[i].split(\":\");\n+                        final Item item = ForgeRegistries.ITEMS.getValue(new ResourceLocation(theItem[0], theItem[1]));\n+                        if (item == null || item == Items.AIR)\n+                        {\n+                            Log.getLogger().warn(\"Invalid lucky block: \" + ore);", "originalCommit": "0c85c63781ba3b91bbe54a44eae918424dbda332", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMwNDU0MQ==", "url": "https://github.com/ldtteam/minecolonies/pull/4396#discussion_r389304541", "bodyText": "fixed", "author": "Raycoms", "createdAt": "2020-03-07T19:04:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTI2NDc3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTI2NzU4Ng==", "url": "https://github.com/ldtteam/minecolonies/pull/4396#discussion_r389267586", "bodyText": "did you forget to add the new happiness value here?", "author": "someaddons", "createdAt": "2020-03-07T16:53:10Z", "path": "src/main/java/com/minecolonies/coremod/client/gui/WindowCitizen.java", "diffHunk": "@@ -493,7 +493,7 @@ public static void updateHappiness(final ICitizenDataView citizen, final Abstrac\n         final double[] levels =\n           new double[] {citizen.getFoodModifier(), citizen.getHouseModifier(), citizen.getDamageModifier(), citizen.getJobModifier(), citizen.getFieldsModifier(),", "originalCommit": "0c85c63781ba3b91bbe54a44eae918424dbda332", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMwNDY4MA==", "url": "https://github.com/ldtteam/minecolonies/pull/4396#discussion_r389304680", "bodyText": "good catch", "author": "Raycoms", "createdAt": "2020-03-07T19:06:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTI2NzU4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTI3NzE1OA==", "url": "https://github.com/ldtteam/minecolonies/pull/4396#discussion_r389277158", "bodyText": "don't think you need a new arraylist of the entryset?", "author": "someaddons", "createdAt": "2020-03-07T17:06:20Z", "path": "src/main/java/com/minecolonies/coremod/colony/buildings/workerbuildings/BuildingHospital.java", "diffHunk": "@@ -0,0 +1,365 @@\n+package com.minecolonies.coremod.colony.buildings.workerbuildings;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.ldtteam.blockout.views.Window;\n+import com.minecolonies.api.colony.ICitizenData;\n+import com.minecolonies.api.colony.IColony;\n+import com.minecolonies.api.colony.IColonyManager;\n+import com.minecolonies.api.colony.IColonyView;\n+import com.minecolonies.api.colony.buildings.ModBuildings;\n+import com.minecolonies.api.colony.buildings.registry.BuildingEntry;\n+import com.minecolonies.api.colony.jobs.IJob;\n+import com.minecolonies.api.util.BlockPosUtil;\n+import com.minecolonies.api.util.Disease;\n+import com.minecolonies.api.util.constant.NbtTagConstants;\n+import com.minecolonies.coremod.client.gui.WindowHutWorkerPlaceholder;\n+import com.minecolonies.coremod.colony.buildings.AbstractBuildingFurnaceUser;\n+import com.minecolonies.coremod.colony.buildings.AbstractBuildingWorker;\n+import com.minecolonies.coremod.colony.jobs.JobHealer;\n+import com.minecolonies.coremod.entity.ai.citizen.healer.Patient;\n+import net.minecraft.block.BedBlock;\n+import net.minecraft.block.BlockState;\n+import net.minecraft.item.ItemStack;\n+import net.minecraft.nbt.CompoundNBT;\n+import net.minecraft.nbt.ListNBT;\n+import net.minecraft.state.properties.BedPart;\n+import net.minecraft.tags.BlockTags;\n+import net.minecraft.util.Tuple;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.world.World;\n+import net.minecraftforge.common.util.Constants;\n+import org.jetbrains.annotations.NotNull;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+\n+import static com.minecolonies.api.util.constant.NbtTagConstants.*;\n+import static com.minecolonies.api.util.constant.Suppression.OVERRIDE_EQUALS;\n+\n+/**\n+ * Class of the hospital building.\n+ */\n+@SuppressWarnings(OVERRIDE_EQUALS)\n+public class BuildingHospital extends AbstractBuildingFurnaceUser\n+{\n+    /**\n+     * The hospital string.\n+     */\n+    private static final String HOSPITAL_DESC = \"hospital\";\n+\n+    /**\n+     * Max building level of the hospital.\n+     */\n+    private static final int MAX_BUILDING_LEVEL = 5;\n+\n+    /**\n+     * Map from beds to patients, 0 is empty.\n+     */\n+    @NotNull\n+    private final Map<BlockPos, Integer> bedMap = new HashMap<>();\n+\n+    /**\n+     * Map of patients of this hospital.\n+     */\n+    private final Map<Integer, Patient> patients = new HashMap<>();\n+\n+    /**\n+     * Instantiates a new hospital building.\n+     *\n+     * @param c the colony.\n+     * @param l the location\n+     */\n+    public BuildingHospital(final IColony c, final BlockPos l)\n+    {\n+        super(c, l);\n+    }\n+\n+    @NotNull\n+    @Override\n+    public String getSchematicName()\n+    {\n+        return HOSPITAL_DESC;\n+    }\n+\n+    @Override\n+    public int getMaxBuildingLevel()\n+    {\n+        return MAX_BUILDING_LEVEL;\n+    }\n+\n+    @NotNull\n+    @Override\n+    public IJob createJob(final ICitizenData citizen)\n+    {\n+        return new JobHealer(citizen);\n+    }\n+\n+    @NotNull\n+    @Override\n+    public String getJobName()\n+    {\n+        return HOSPITAL_DESC;\n+    }\n+\n+    @Override\n+    public boolean canCraftComplexRecipes()\n+    {\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean canWorkDuringTheRain()\n+    {\n+        return true;\n+    }\n+\n+    @Override\n+    public BuildingEntry getBuildingRegistryEntry()\n+    {\n+        return ModBuildings.hospital;\n+    }\n+\n+    @Override\n+    public void deserializeNBT(final CompoundNBT compound)\n+    {\n+        super.deserializeNBT(compound);\n+        final ListNBT bedTagList = compound.getList(TAG_BEDS, Constants.NBT.TAG_COMPOUND);\n+        for (int i = 0; i < bedTagList.size(); ++i)\n+        {\n+            final CompoundNBT bedCompound = bedTagList.getCompound(i);\n+            final BlockPos bedPos = BlockPosUtil.read(bedCompound, TAG_POS);\n+            if (!bedMap.containsKey(bedPos))\n+            {\n+                bedMap.put(bedPos, bedCompound.getInt(TAG_ID));\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public CompoundNBT serializeNBT()\n+    {\n+        final CompoundNBT compound = super.serializeNBT();\n+        if (!bedMap.isEmpty())\n+        {\n+            @NotNull final ListNBT bedTagList = new ListNBT();\n+            for (@NotNull final Map.Entry<BlockPos, Integer> entry : bedMap.entrySet())\n+            {\n+                final CompoundNBT bedCompound = new CompoundNBT();\n+                BlockPosUtil.write(bedCompound, NbtTagConstants.TAG_POS, entry.getKey());\n+                bedCompound.putInt(TAG_ID, entry.getValue());\n+                bedTagList.add(bedCompound);\n+            }\n+            compound.put(TAG_BEDS, bedTagList);\n+        }\n+\n+        return compound;\n+    }\n+\n+    @Override\n+    public void registerBlockPosition(@NotNull final BlockState blockState, @NotNull final BlockPos pos, @NotNull final World world)\n+    {\n+        super.registerBlockPosition(blockState, pos, world);\n+\n+        BlockPos registrationPosition = pos;\n+        if (blockState.getBlock() instanceof BedBlock)\n+        {\n+            if (blockState.get(BedBlock.PART) == BedPart.FOOT)\n+            {\n+                registrationPosition = registrationPosition.offset(blockState.get(BedBlock.HORIZONTAL_FACING));\n+            }\n+\n+            if (!bedMap.containsKey(registrationPosition))\n+            {\n+                bedMap.put(registrationPosition, 0);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get the list of beds.\n+     * @return immutable copy\n+     */\n+    @NotNull\n+    public List<BlockPos> getBedList()\n+    {\n+        return ImmutableList.copyOf(bedMap.keySet());\n+    }\n+\n+    /**\n+     * Get the list of patient files.\n+     * @return immutable copy.\n+     */\n+    public List<Patient> getPatients()\n+    {\n+        return ImmutableList.copyOf(patients.values());\n+    }\n+\n+    /**\n+     * Remove a patient from the list.\n+     * @param patient the patient to remove.\n+     */\n+    public void removePatientFile(final Patient patient)\n+    {\n+        patients.remove(patient.getId());\n+    }\n+\n+    @Override\n+    public Map<Predicate<ItemStack>, Tuple<Integer, Boolean>> getRequiredItemsAndAmount()\n+    {\n+        final Map<Predicate<ItemStack>, Tuple<Integer, Boolean>> map = super.getRequiredItemsAndAmount();\n+        map.put(this::doesAnyPatientRequireStack, new Tuple<>(10, false));\n+        return map;\n+    }\n+\n+    /**\n+     * Check if any patient requires this.\n+     * @param stack the stack to test.\n+     * @return true if so.\n+     */\n+    private boolean doesAnyPatientRequireStack(final ItemStack stack)\n+    {\n+        for (final Patient patient : patients.values())\n+        {\n+            final ICitizenData data = colony.getCitizenManager().getCitizen(patient.getId());\n+            if (data != null && data.getCitizenEntity().isPresent() && data.getCitizenEntity().get().getCitizenDiseaseHandler().isSick())\n+            {\n+                final String diseaseName = data.getCitizenEntity().get().getCitizenDiseaseHandler().getDisease();\n+                if (!diseaseName.isEmpty())\n+                {\n+                    final Disease disease = IColonyManager.getInstance().getCompatibilityManager().getDisease(diseaseName);\n+                    for (final ItemStack cure : disease.getCure())\n+                    {\n+                        if (cure.isItemEqual(stack))\n+                        {\n+                            return true;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Add a new patient to the list.\n+     * @param citizenId patient to add.\n+     */\n+    public void checkOrCreatePatientFile(final int citizenId)\n+    {\n+        if (!patients.containsKey(citizenId))\n+        {\n+            patients.put(citizenId, new Patient(citizenId));\n+        }\n+    }\n+\n+    /**\n+     * Register a citizen.\n+     * @param bedPos the pos.\n+     * @param citizenId the citizen id.\n+     */\n+    public void registerPatient(final BlockPos bedPos, final int citizenId)\n+    {\n+        bedMap.put(bedPos, citizenId);\n+        setBedOccupation(bedPos, citizenId != 0);\n+    }\n+\n+    /**\n+     * Helper method to set bed occupation.\n+     * @param bedPos the position of the bed.\n+     * @param occupied if occupied.\n+     */\n+    private void setBedOccupation(final BlockPos bedPos, final boolean occupied)\n+    {\n+        final BlockState state = colony.getWorld().getBlockState(bedPos);\n+        if (state.getBlock().isIn(BlockTags.BEDS))\n+        {\n+            colony.getWorld().setBlockState(bedPos, state.with(BedBlock.OCCUPIED, occupied), 0x03);\n+\n+            final BlockPos feetPos = bedPos.offset(state.get(BedBlock.HORIZONTAL_FACING).getOpposite());\n+            final BlockState feetState = colony.getWorld().getBlockState(feetPos);\n+\n+            if (feetState.getBlock().isIn(BlockTags.BEDS))\n+            {\n+                colony.getWorld().setBlockState(feetPos, feetState.with(BedBlock.OCCUPIED, occupied), 0x03);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onWakeUp()\n+    {\n+        for (final Map.Entry<BlockPos, Integer> entry : new ArrayList<>(bedMap.entrySet()))", "originalCommit": "0c85c63781ba3b91bbe54a44eae918424dbda332", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMwNDgyMQ==", "url": "https://github.com/ldtteam/minecolonies/pull/4396#discussion_r389304821", "bodyText": "the entryset is funnily connected to the map, so if I alter the map the set also changes afaik", "author": "Raycoms", "createdAt": "2020-03-07T19:08:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTI3NzE1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMwNDkzOQ==", "url": "https://github.com/ldtteam/minecolonies/pull/4396#discussion_r389304939", "bodyText": "you're right you can't remove it then", "author": "someaddons", "createdAt": "2020-03-07T19:10:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTI3NzE1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTI3OTI1MA==", "url": "https://github.com/ldtteam/minecolonies/pull/4396#discussion_r389279250", "bodyText": "since we aren't saving patients either, should we save whether the bed is occupied? think you could just do edMap.put(bedPos, 0);", "author": "someaddons", "createdAt": "2020-03-07T17:09:29Z", "path": "src/main/java/com/minecolonies/coremod/colony/buildings/workerbuildings/BuildingHospital.java", "diffHunk": "@@ -0,0 +1,365 @@\n+package com.minecolonies.coremod.colony.buildings.workerbuildings;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.ldtteam.blockout.views.Window;\n+import com.minecolonies.api.colony.ICitizenData;\n+import com.minecolonies.api.colony.IColony;\n+import com.minecolonies.api.colony.IColonyManager;\n+import com.minecolonies.api.colony.IColonyView;\n+import com.minecolonies.api.colony.buildings.ModBuildings;\n+import com.minecolonies.api.colony.buildings.registry.BuildingEntry;\n+import com.minecolonies.api.colony.jobs.IJob;\n+import com.minecolonies.api.util.BlockPosUtil;\n+import com.minecolonies.api.util.Disease;\n+import com.minecolonies.api.util.constant.NbtTagConstants;\n+import com.minecolonies.coremod.client.gui.WindowHutWorkerPlaceholder;\n+import com.minecolonies.coremod.colony.buildings.AbstractBuildingFurnaceUser;\n+import com.minecolonies.coremod.colony.buildings.AbstractBuildingWorker;\n+import com.minecolonies.coremod.colony.jobs.JobHealer;\n+import com.minecolonies.coremod.entity.ai.citizen.healer.Patient;\n+import net.minecraft.block.BedBlock;\n+import net.minecraft.block.BlockState;\n+import net.minecraft.item.ItemStack;\n+import net.minecraft.nbt.CompoundNBT;\n+import net.minecraft.nbt.ListNBT;\n+import net.minecraft.state.properties.BedPart;\n+import net.minecraft.tags.BlockTags;\n+import net.minecraft.util.Tuple;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.world.World;\n+import net.minecraftforge.common.util.Constants;\n+import org.jetbrains.annotations.NotNull;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+\n+import static com.minecolonies.api.util.constant.NbtTagConstants.*;\n+import static com.minecolonies.api.util.constant.Suppression.OVERRIDE_EQUALS;\n+\n+/**\n+ * Class of the hospital building.\n+ */\n+@SuppressWarnings(OVERRIDE_EQUALS)\n+public class BuildingHospital extends AbstractBuildingFurnaceUser\n+{\n+    /**\n+     * The hospital string.\n+     */\n+    private static final String HOSPITAL_DESC = \"hospital\";\n+\n+    /**\n+     * Max building level of the hospital.\n+     */\n+    private static final int MAX_BUILDING_LEVEL = 5;\n+\n+    /**\n+     * Map from beds to patients, 0 is empty.\n+     */\n+    @NotNull\n+    private final Map<BlockPos, Integer> bedMap = new HashMap<>();\n+\n+    /**\n+     * Map of patients of this hospital.\n+     */\n+    private final Map<Integer, Patient> patients = new HashMap<>();\n+\n+    /**\n+     * Instantiates a new hospital building.\n+     *\n+     * @param c the colony.\n+     * @param l the location\n+     */\n+    public BuildingHospital(final IColony c, final BlockPos l)\n+    {\n+        super(c, l);\n+    }\n+\n+    @NotNull\n+    @Override\n+    public String getSchematicName()\n+    {\n+        return HOSPITAL_DESC;\n+    }\n+\n+    @Override\n+    public int getMaxBuildingLevel()\n+    {\n+        return MAX_BUILDING_LEVEL;\n+    }\n+\n+    @NotNull\n+    @Override\n+    public IJob createJob(final ICitizenData citizen)\n+    {\n+        return new JobHealer(citizen);\n+    }\n+\n+    @NotNull\n+    @Override\n+    public String getJobName()\n+    {\n+        return HOSPITAL_DESC;\n+    }\n+\n+    @Override\n+    public boolean canCraftComplexRecipes()\n+    {\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean canWorkDuringTheRain()\n+    {\n+        return true;\n+    }\n+\n+    @Override\n+    public BuildingEntry getBuildingRegistryEntry()\n+    {\n+        return ModBuildings.hospital;\n+    }\n+\n+    @Override\n+    public void deserializeNBT(final CompoundNBT compound)\n+    {\n+        super.deserializeNBT(compound);\n+        final ListNBT bedTagList = compound.getList(TAG_BEDS, Constants.NBT.TAG_COMPOUND);\n+        for (int i = 0; i < bedTagList.size(); ++i)\n+        {\n+            final CompoundNBT bedCompound = bedTagList.getCompound(i);\n+            final BlockPos bedPos = BlockPosUtil.read(bedCompound, TAG_POS);\n+            if (!bedMap.containsKey(bedPos))\n+            {\n+                bedMap.put(bedPos, bedCompound.getInt(TAG_ID));", "originalCommit": "0c85c63781ba3b91bbe54a44eae918424dbda332", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMwNDczMA==", "url": "https://github.com/ldtteam/minecolonies/pull/4396#discussion_r389304730", "bodyText": "oops, I forgot to save the patients!", "author": "Raycoms", "createdAt": "2020-03-07T19:07:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTI3OTI1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMwNDg2Mg==", "url": "https://github.com/ldtteam/minecolonies/pull/4396#discussion_r389304862", "bodyText": "we could also skip saving patients and let the AI re-add them?", "author": "someaddons", "createdAt": "2020-03-07T19:09:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTI3OTI1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMwNTUxNw==", "url": "https://github.com/ldtteam/minecolonies/pull/4396#discussion_r389305517", "bodyText": "Nah, rerunning is not so wise", "author": "Raycoms", "createdAt": "2020-03-07T19:19:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTI3OTI1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTI4MjE0NA==", "url": "https://github.com/ldtteam/minecolonies/pull/4396#discussion_r389282144", "bodyText": "could add the description from the PR here aswell, think Job is a fine place to give an overview", "author": "someaddons", "createdAt": "2020-03-07T17:13:37Z", "path": "src/main/java/com/minecolonies/coremod/colony/jobs/JobHealer.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package com.minecolonies.coremod.colony.jobs;\n+\n+import com.minecolonies.api.client.render.modeltype.BipedModelType;\n+import com.minecolonies.api.colony.ICitizenData;\n+import com.minecolonies.api.colony.jobs.ModJobs;\n+import com.minecolonies.api.colony.jobs.registry.JobEntry;\n+import com.minecolonies.coremod.entity.ai.basic.AbstractAISkeleton;\n+import com.minecolonies.coremod.entity.ai.citizen.healer.EntityAIWorkHealer;\n+import org.jetbrains.annotations.NotNull;\n+\n+/**\n+ * The healer job class.", "originalCommit": "0c85c63781ba3b91bbe54a44eae918424dbda332", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTI4MzE5OQ==", "url": "https://github.com/ldtteam/minecolonies/pull/4396#discussion_r389283199", "bodyText": "I'd probably rename it to getDiseaseChance(), modifier sounds a bit like altering the disease itself and makes it harder to understand that its about likelyhood", "author": "someaddons", "createdAt": "2020-03-07T17:15:12Z", "path": "src/main/java/com/minecolonies/coremod/colony/jobs/JobComposter.java", "diffHunk": "@@ -51,4 +51,10 @@ public BipedModelType getModel()\n     {\n         return new EntityAIWorkComposter(this);\n     }\n+\n+    @Override\n+    public int getDiseaseModifier()", "originalCommit": "0c85c63781ba3b91bbe54a44eae918424dbda332", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTI4NDU5NA==", "url": "https://github.com/ldtteam/minecolonies/pull/4396#discussion_r389284594", "bodyText": "how about we combine this with getBestRestaurant and make a getClosestBuilding(Class, Citizen) for it?", "author": "someaddons", "createdAt": "2020-03-07T17:17:07Z", "path": "src/main/java/com/minecolonies/coremod/colony/managers/BuildingManager.java", "diffHunk": "@@ -471,6 +471,26 @@ public BlockPos getBestRestaurant(final AbstractEntityCitizen citizen)\n         return goodCook;\n     }\n \n+    @Override\n+    public BlockPos getBestHospital(final AbstractEntityCitizen citizen)", "originalCommit": "0c85c63781ba3b91bbe54a44eae918424dbda332", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTI5OTE5MQ==", "url": "https://github.com/ldtteam/minecolonies/pull/4396#discussion_r389299191", "bodyText": "do multiple hospitals near each other disrupt themselves?", "author": "someaddons", "createdAt": "2020-03-07T17:41:23Z", "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/healer/EntityAIWorkHealer.java", "diffHunk": "@@ -0,0 +1,527 @@\n+package com.minecolonies.coremod.entity.ai.citizen.healer;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.reflect.TypeToken;\n+import com.minecolonies.api.colony.ICitizenData;\n+import com.minecolonies.api.colony.IColonyManager;\n+import com.minecolonies.api.colony.interactionhandling.ChatPriority;\n+import com.minecolonies.api.colony.requestsystem.request.IRequest;\n+import com.minecolonies.api.colony.requestsystem.requestable.Stack;\n+import com.minecolonies.api.entity.ModEntities;\n+import com.minecolonies.api.entity.ai.statemachine.AITarget;\n+import com.minecolonies.api.entity.ai.statemachine.states.IAIState;\n+import com.minecolonies.api.entity.citizen.AbstractEntityCitizen;\n+import com.minecolonies.api.util.BlockPosUtil;\n+import com.minecolonies.api.util.Disease;\n+import com.minecolonies.api.util.InventoryUtils;\n+import com.minecolonies.coremod.Network;\n+import com.minecolonies.coremod.colony.buildings.workerbuildings.BuildingHospital;\n+import com.minecolonies.coremod.colony.interactionhandling.StandardInteractionResponseHandler;\n+import com.minecolonies.coremod.colony.jobs.JobHealer;\n+import com.minecolonies.coremod.entity.ai.basic.AbstractEntityAIInteract;\n+import com.minecolonies.coremod.entity.citizen.EntityCitizen;\n+import com.minecolonies.coremod.network.messages.CircleParticleEffectMessage;\n+import com.minecolonies.coremod.network.messages.StreamParticleEffectMessage;\n+import net.minecraft.entity.EntityType;\n+import net.minecraft.entity.player.PlayerEntity;\n+import net.minecraft.item.ItemStack;\n+import net.minecraft.particles.ParticleTypes;\n+import net.minecraft.util.math.AxisAlignedBB;\n+import net.minecraft.util.text.TranslationTextComponent;\n+import net.minecraftforge.items.CapabilityItemHandler;\n+import net.minecraftforge.items.IItemHandler;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+import static com.minecolonies.api.entity.ai.statemachine.states.AIWorkerState.*;\n+import static com.minecolonies.api.util.constant.TranslationConstants.PATIENT_FULL_INVENTORY;\n+\n+/**\n+ * Healer AI class.\n+ */\n+public class EntityAIWorkHealer extends AbstractEntityAIInteract<JobHealer>\n+{\n+    /**\n+     * Base xp gain for the smelter.\n+     */\n+    private static final double BASE_XP_GAIN = 5;\n+\n+    /**\n+     * How often should charisma factor into the cook's skill modifier.\n+     */\n+    private static final int CHARISMA_MULTIPLIER = 1;\n+\n+    /**\n+     * How often should intelligence factor into the cook's skill modifier.\n+     */\n+    private static final int INTELLIGENCE_MULTIPLIER = 2;\n+\n+    /**\n+     * Area the worker targets.\n+     */\n+    private AxisAlignedBB targetArea = null;\n+\n+    /**\n+     * The current patient.\n+     */\n+    private Patient currentPatient = null;\n+\n+    /**\n+     * Variable to check if the draining is in progress.\n+     * And at which tick it is.\n+     */\n+    private int progressTicks = 0;\n+\n+    /**\n+     * Max progress ticks until drainage is complete (per Level).\n+     */\n+    private static final int MAX_PROGRESS_TICKS = 30;\n+\n+    /**\n+     * Remote patient to treat.\n+     */\n+    private ICitizenData remotePatient;\n+\n+    /**\n+     * Player to heal.\n+     */\n+    private PlayerEntity playerToHeal;\n+\n+    /**\n+     * Constructor for the Cook.\n+     * Defines the tasks the cook executes.\n+     *\n+     * @param job a cook job to use.\n+     */\n+    public EntityAIWorkHealer(@NotNull final JobHealer job)\n+    {\n+        super(job);\n+        super.registerTargets(\n+          new AITarget(IDLE, START_WORKING, 1),\n+          new AITarget(START_WORKING, DECIDE, 1),\n+          new AITarget(DECIDE, this::decide, 20),\n+          new AITarget(CURE, this::cure, 20),\n+          new AITarget(FREE_CURE, this::freeCure, 20),\n+          new AITarget(CURE_PLAYER, this::curePlayer, 20),\n+          new AITarget(REQUEST_CURE, this::requestCure, 20),\n+          new AITarget(WANDER, this::wander, 20)\n+\n+        );\n+        //super.registerTargets(new AITarget(COOK_SERVE_FOOD_TO_CITIZEN, this::serveFoodToCitizen, SERVE_DELAY));\n+        worker.getCitizenExperienceHandler().setSkillModifier(CHARISMA_MULTIPLIER * worker.getCitizenData().getCharisma()\n+                + INTELLIGENCE_MULTIPLIER * worker.getCitizenData().getIntelligence());\n+        worker.setCanPickUpLoot(true);\n+    }\n+\n+    /**\n+     * Decide what to do next.\n+     * Check if all patients are up date, else update their states.\n+     * Then check if there is any patient we can cure or request things for.\n+     *\n+     * @return the next state to go to.\n+     */\n+    private IAIState decide()\n+    {\n+        if ( walkToBuilding() )\n+        {\n+            return DECIDE;\n+        }\n+\n+        final BuildingHospital hospital = getOwnBuilding(BuildingHospital.class);\n+        for (final AbstractEntityCitizen citizen : world.getEntitiesWithinAABB(ModEntities.CITIZEN, getTargetableArea(), cit -> cit.getCitizenDiseaseHandler().isSick()))\n+        {\n+            hospital.checkOrCreatePatientFile(citizen.getCitizenId());", "originalCommit": "0c85c63781ba3b91bbe54a44eae918424dbda332", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTI5OTU3OQ==", "url": "https://github.com/ldtteam/minecolonies/pull/4396#discussion_r389299579", "bodyText": "we cure him when the disease is null?", "author": "someaddons", "createdAt": "2020-03-07T17:47:13Z", "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/healer/EntityAIWorkHealer.java", "diffHunk": "@@ -0,0 +1,527 @@\n+package com.minecolonies.coremod.entity.ai.citizen.healer;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.reflect.TypeToken;\n+import com.minecolonies.api.colony.ICitizenData;\n+import com.minecolonies.api.colony.IColonyManager;\n+import com.minecolonies.api.colony.interactionhandling.ChatPriority;\n+import com.minecolonies.api.colony.requestsystem.request.IRequest;\n+import com.minecolonies.api.colony.requestsystem.requestable.Stack;\n+import com.minecolonies.api.entity.ModEntities;\n+import com.minecolonies.api.entity.ai.statemachine.AITarget;\n+import com.minecolonies.api.entity.ai.statemachine.states.IAIState;\n+import com.minecolonies.api.entity.citizen.AbstractEntityCitizen;\n+import com.minecolonies.api.util.BlockPosUtil;\n+import com.minecolonies.api.util.Disease;\n+import com.minecolonies.api.util.InventoryUtils;\n+import com.minecolonies.coremod.Network;\n+import com.minecolonies.coremod.colony.buildings.workerbuildings.BuildingHospital;\n+import com.minecolonies.coremod.colony.interactionhandling.StandardInteractionResponseHandler;\n+import com.minecolonies.coremod.colony.jobs.JobHealer;\n+import com.minecolonies.coremod.entity.ai.basic.AbstractEntityAIInteract;\n+import com.minecolonies.coremod.entity.citizen.EntityCitizen;\n+import com.minecolonies.coremod.network.messages.CircleParticleEffectMessage;\n+import com.minecolonies.coremod.network.messages.StreamParticleEffectMessage;\n+import net.minecraft.entity.EntityType;\n+import net.minecraft.entity.player.PlayerEntity;\n+import net.minecraft.item.ItemStack;\n+import net.minecraft.particles.ParticleTypes;\n+import net.minecraft.util.math.AxisAlignedBB;\n+import net.minecraft.util.text.TranslationTextComponent;\n+import net.minecraftforge.items.CapabilityItemHandler;\n+import net.minecraftforge.items.IItemHandler;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+import static com.minecolonies.api.entity.ai.statemachine.states.AIWorkerState.*;\n+import static com.minecolonies.api.util.constant.TranslationConstants.PATIENT_FULL_INVENTORY;\n+\n+/**\n+ * Healer AI class.\n+ */\n+public class EntityAIWorkHealer extends AbstractEntityAIInteract<JobHealer>\n+{\n+    /**\n+     * Base xp gain for the smelter.\n+     */\n+    private static final double BASE_XP_GAIN = 5;\n+\n+    /**\n+     * How often should charisma factor into the cook's skill modifier.\n+     */\n+    private static final int CHARISMA_MULTIPLIER = 1;\n+\n+    /**\n+     * How often should intelligence factor into the cook's skill modifier.\n+     */\n+    private static final int INTELLIGENCE_MULTIPLIER = 2;\n+\n+    /**\n+     * Area the worker targets.\n+     */\n+    private AxisAlignedBB targetArea = null;\n+\n+    /**\n+     * The current patient.\n+     */\n+    private Patient currentPatient = null;\n+\n+    /**\n+     * Variable to check if the draining is in progress.\n+     * And at which tick it is.\n+     */\n+    private int progressTicks = 0;\n+\n+    /**\n+     * Max progress ticks until drainage is complete (per Level).\n+     */\n+    private static final int MAX_PROGRESS_TICKS = 30;\n+\n+    /**\n+     * Remote patient to treat.\n+     */\n+    private ICitizenData remotePatient;\n+\n+    /**\n+     * Player to heal.\n+     */\n+    private PlayerEntity playerToHeal;\n+\n+    /**\n+     * Constructor for the Cook.\n+     * Defines the tasks the cook executes.\n+     *\n+     * @param job a cook job to use.\n+     */\n+    public EntityAIWorkHealer(@NotNull final JobHealer job)\n+    {\n+        super(job);\n+        super.registerTargets(\n+          new AITarget(IDLE, START_WORKING, 1),\n+          new AITarget(START_WORKING, DECIDE, 1),\n+          new AITarget(DECIDE, this::decide, 20),\n+          new AITarget(CURE, this::cure, 20),\n+          new AITarget(FREE_CURE, this::freeCure, 20),\n+          new AITarget(CURE_PLAYER, this::curePlayer, 20),\n+          new AITarget(REQUEST_CURE, this::requestCure, 20),\n+          new AITarget(WANDER, this::wander, 20)\n+\n+        );\n+        //super.registerTargets(new AITarget(COOK_SERVE_FOOD_TO_CITIZEN, this::serveFoodToCitizen, SERVE_DELAY));\n+        worker.getCitizenExperienceHandler().setSkillModifier(CHARISMA_MULTIPLIER * worker.getCitizenData().getCharisma()\n+                + INTELLIGENCE_MULTIPLIER * worker.getCitizenData().getIntelligence());\n+        worker.setCanPickUpLoot(true);\n+    }\n+\n+    /**\n+     * Decide what to do next.\n+     * Check if all patients are up date, else update their states.\n+     * Then check if there is any patient we can cure or request things for.\n+     *\n+     * @return the next state to go to.\n+     */\n+    private IAIState decide()\n+    {\n+        if ( walkToBuilding() )\n+        {\n+            return DECIDE;\n+        }\n+\n+        final BuildingHospital hospital = getOwnBuilding(BuildingHospital.class);\n+        for (final AbstractEntityCitizen citizen : world.getEntitiesWithinAABB(ModEntities.CITIZEN, getTargetableArea(), cit -> cit.getCitizenDiseaseHandler().isSick()))\n+        {\n+            hospital.checkOrCreatePatientFile(citizen.getCitizenId());\n+        }\n+\n+        for (final Patient patient : hospital.getPatients())\n+        {\n+            final ICitizenData data = hospital.getColony().getCitizenManager().getCitizen(patient.getId());\n+            if (data == null || (data.getCitizenEntity().isPresent() && !data.getCitizenEntity().get().getCitizenDiseaseHandler().isSick()))\n+            {\n+                hospital.removePatientFile(patient);\n+                continue;\n+            }\n+            final EntityCitizen citizen = (EntityCitizen) data.getCitizenEntity().get();\n+            final String diseaseName = citizen.getCitizenDiseaseHandler().getDisease();\n+            @Nullable final Disease disease = diseaseName.isEmpty() ? null : IColonyManager.getInstance().getCompatibilityManager().getDisease(diseaseName);\n+\n+            if (patient.getState() == Patient.PatientState.NEW)\n+            {\n+                this.currentPatient = patient;\n+                return REQUEST_CURE;\n+            }\n+\n+            if (patient.getState() == Patient.PatientState.REQUESTED)\n+            {\n+                if (disease == null)", "originalCommit": "0c85c63781ba3b91bbe54a44eae918424dbda332", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTI5OTc4Nw==", "url": "https://github.com/ldtteam/minecolonies/pull/4396#discussion_r389299787", "bodyText": "think this could cause issues when cures have overlapping itemstacks", "author": "someaddons", "createdAt": "2020-03-07T17:50:19Z", "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/healer/EntityAIWorkHealer.java", "diffHunk": "@@ -0,0 +1,527 @@\n+package com.minecolonies.coremod.entity.ai.citizen.healer;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.reflect.TypeToken;\n+import com.minecolonies.api.colony.ICitizenData;\n+import com.minecolonies.api.colony.IColonyManager;\n+import com.minecolonies.api.colony.interactionhandling.ChatPriority;\n+import com.minecolonies.api.colony.requestsystem.request.IRequest;\n+import com.minecolonies.api.colony.requestsystem.requestable.Stack;\n+import com.minecolonies.api.entity.ModEntities;\n+import com.minecolonies.api.entity.ai.statemachine.AITarget;\n+import com.minecolonies.api.entity.ai.statemachine.states.IAIState;\n+import com.minecolonies.api.entity.citizen.AbstractEntityCitizen;\n+import com.minecolonies.api.util.BlockPosUtil;\n+import com.minecolonies.api.util.Disease;\n+import com.minecolonies.api.util.InventoryUtils;\n+import com.minecolonies.coremod.Network;\n+import com.minecolonies.coremod.colony.buildings.workerbuildings.BuildingHospital;\n+import com.minecolonies.coremod.colony.interactionhandling.StandardInteractionResponseHandler;\n+import com.minecolonies.coremod.colony.jobs.JobHealer;\n+import com.minecolonies.coremod.entity.ai.basic.AbstractEntityAIInteract;\n+import com.minecolonies.coremod.entity.citizen.EntityCitizen;\n+import com.minecolonies.coremod.network.messages.CircleParticleEffectMessage;\n+import com.minecolonies.coremod.network.messages.StreamParticleEffectMessage;\n+import net.minecraft.entity.EntityType;\n+import net.minecraft.entity.player.PlayerEntity;\n+import net.minecraft.item.ItemStack;\n+import net.minecraft.particles.ParticleTypes;\n+import net.minecraft.util.math.AxisAlignedBB;\n+import net.minecraft.util.text.TranslationTextComponent;\n+import net.minecraftforge.items.CapabilityItemHandler;\n+import net.minecraftforge.items.IItemHandler;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+import static com.minecolonies.api.entity.ai.statemachine.states.AIWorkerState.*;\n+import static com.minecolonies.api.util.constant.TranslationConstants.PATIENT_FULL_INVENTORY;\n+\n+/**\n+ * Healer AI class.\n+ */\n+public class EntityAIWorkHealer extends AbstractEntityAIInteract<JobHealer>\n+{\n+    /**\n+     * Base xp gain for the smelter.\n+     */\n+    private static final double BASE_XP_GAIN = 5;\n+\n+    /**\n+     * How often should charisma factor into the cook's skill modifier.\n+     */\n+    private static final int CHARISMA_MULTIPLIER = 1;\n+\n+    /**\n+     * How often should intelligence factor into the cook's skill modifier.\n+     */\n+    private static final int INTELLIGENCE_MULTIPLIER = 2;\n+\n+    /**\n+     * Area the worker targets.\n+     */\n+    private AxisAlignedBB targetArea = null;\n+\n+    /**\n+     * The current patient.\n+     */\n+    private Patient currentPatient = null;\n+\n+    /**\n+     * Variable to check if the draining is in progress.\n+     * And at which tick it is.\n+     */\n+    private int progressTicks = 0;\n+\n+    /**\n+     * Max progress ticks until drainage is complete (per Level).\n+     */\n+    private static final int MAX_PROGRESS_TICKS = 30;\n+\n+    /**\n+     * Remote patient to treat.\n+     */\n+    private ICitizenData remotePatient;\n+\n+    /**\n+     * Player to heal.\n+     */\n+    private PlayerEntity playerToHeal;\n+\n+    /**\n+     * Constructor for the Cook.\n+     * Defines the tasks the cook executes.\n+     *\n+     * @param job a cook job to use.\n+     */\n+    public EntityAIWorkHealer(@NotNull final JobHealer job)\n+    {\n+        super(job);\n+        super.registerTargets(\n+          new AITarget(IDLE, START_WORKING, 1),\n+          new AITarget(START_WORKING, DECIDE, 1),\n+          new AITarget(DECIDE, this::decide, 20),\n+          new AITarget(CURE, this::cure, 20),\n+          new AITarget(FREE_CURE, this::freeCure, 20),\n+          new AITarget(CURE_PLAYER, this::curePlayer, 20),\n+          new AITarget(REQUEST_CURE, this::requestCure, 20),\n+          new AITarget(WANDER, this::wander, 20)\n+\n+        );\n+        //super.registerTargets(new AITarget(COOK_SERVE_FOOD_TO_CITIZEN, this::serveFoodToCitizen, SERVE_DELAY));\n+        worker.getCitizenExperienceHandler().setSkillModifier(CHARISMA_MULTIPLIER * worker.getCitizenData().getCharisma()\n+                + INTELLIGENCE_MULTIPLIER * worker.getCitizenData().getIntelligence());\n+        worker.setCanPickUpLoot(true);\n+    }\n+\n+    /**\n+     * Decide what to do next.\n+     * Check if all patients are up date, else update their states.\n+     * Then check if there is any patient we can cure or request things for.\n+     *\n+     * @return the next state to go to.\n+     */\n+    private IAIState decide()\n+    {\n+        if ( walkToBuilding() )\n+        {\n+            return DECIDE;\n+        }\n+\n+        final BuildingHospital hospital = getOwnBuilding(BuildingHospital.class);\n+        for (final AbstractEntityCitizen citizen : world.getEntitiesWithinAABB(ModEntities.CITIZEN, getTargetableArea(), cit -> cit.getCitizenDiseaseHandler().isSick()))\n+        {\n+            hospital.checkOrCreatePatientFile(citizen.getCitizenId());\n+        }\n+\n+        for (final Patient patient : hospital.getPatients())\n+        {\n+            final ICitizenData data = hospital.getColony().getCitizenManager().getCitizen(patient.getId());\n+            if (data == null || (data.getCitizenEntity().isPresent() && !data.getCitizenEntity().get().getCitizenDiseaseHandler().isSick()))\n+            {\n+                hospital.removePatientFile(patient);\n+                continue;\n+            }\n+            final EntityCitizen citizen = (EntityCitizen) data.getCitizenEntity().get();\n+            final String diseaseName = citizen.getCitizenDiseaseHandler().getDisease();\n+            @Nullable final Disease disease = diseaseName.isEmpty() ? null : IColonyManager.getInstance().getCompatibilityManager().getDisease(diseaseName);\n+\n+            if (patient.getState() == Patient.PatientState.NEW)\n+            {\n+                this.currentPatient = patient;\n+                return REQUEST_CURE;\n+            }\n+\n+            if (patient.getState() == Patient.PatientState.REQUESTED)\n+            {\n+                if (disease == null)\n+                {\n+                    this.currentPatient = patient;\n+                    return CURE;\n+                }\n+\n+                if (testRandomCureChance())\n+                {\n+                    this.currentPatient = patient;\n+                    return FREE_CURE;\n+                }\n+\n+                if (!InventoryUtils.isItemHandlerFull(citizen.getInventoryCitizen()))\n+                {\n+                    if (hasCureInInventory(disease, worker.getInventoryCitizen()) ||\n+                          hasCureInInventory(disease, getOwnBuilding().getCapability(CapabilityItemHandler.ITEM_HANDLER_CAPABILITY).orElseGet(null)))\n+                    {\n+                        this.currentPatient = patient;\n+                        return CURE;\n+                    }\n+\n+                    final ImmutableList<IRequest<? extends Stack>> list = getOwnBuilding().getOpenRequestsOfType(worker.getCitizenData(), TypeToken.of(Stack.class));\n+                    for (final ItemStack cure : IColonyManager.getInstance().getCompatibilityManager().getDisease(diseaseName).getCure())\n+                    {\n+                        boolean hasCureRequested = false;\n+                        for (final IRequest<? extends Stack> request : list)\n+                        {\n+                            if (request.getRequest().getStack().isItemEqual(cure))\n+                            {\n+                                hasCureRequested = true;", "originalCommit": "0c85c63781ba3b91bbe54a44eae918424dbda332", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMwMDEzMg==", "url": "https://github.com/ldtteam/minecolonies/pull/4396#discussion_r389300132", "bodyText": "whatfor are we using the citizen(patient) inventory? since we do the cure requests to the healer/his building we probably do not need to check the citizen inventory for full right?", "author": "someaddons", "createdAt": "2020-03-07T17:55:35Z", "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/healer/EntityAIWorkHealer.java", "diffHunk": "@@ -0,0 +1,527 @@\n+package com.minecolonies.coremod.entity.ai.citizen.healer;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.reflect.TypeToken;\n+import com.minecolonies.api.colony.ICitizenData;\n+import com.minecolonies.api.colony.IColonyManager;\n+import com.minecolonies.api.colony.interactionhandling.ChatPriority;\n+import com.minecolonies.api.colony.requestsystem.request.IRequest;\n+import com.minecolonies.api.colony.requestsystem.requestable.Stack;\n+import com.minecolonies.api.entity.ModEntities;\n+import com.minecolonies.api.entity.ai.statemachine.AITarget;\n+import com.minecolonies.api.entity.ai.statemachine.states.IAIState;\n+import com.minecolonies.api.entity.citizen.AbstractEntityCitizen;\n+import com.minecolonies.api.util.BlockPosUtil;\n+import com.minecolonies.api.util.Disease;\n+import com.minecolonies.api.util.InventoryUtils;\n+import com.minecolonies.coremod.Network;\n+import com.minecolonies.coremod.colony.buildings.workerbuildings.BuildingHospital;\n+import com.minecolonies.coremod.colony.interactionhandling.StandardInteractionResponseHandler;\n+import com.minecolonies.coremod.colony.jobs.JobHealer;\n+import com.minecolonies.coremod.entity.ai.basic.AbstractEntityAIInteract;\n+import com.minecolonies.coremod.entity.citizen.EntityCitizen;\n+import com.minecolonies.coremod.network.messages.CircleParticleEffectMessage;\n+import com.minecolonies.coremod.network.messages.StreamParticleEffectMessage;\n+import net.minecraft.entity.EntityType;\n+import net.minecraft.entity.player.PlayerEntity;\n+import net.minecraft.item.ItemStack;\n+import net.minecraft.particles.ParticleTypes;\n+import net.minecraft.util.math.AxisAlignedBB;\n+import net.minecraft.util.text.TranslationTextComponent;\n+import net.minecraftforge.items.CapabilityItemHandler;\n+import net.minecraftforge.items.IItemHandler;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+import static com.minecolonies.api.entity.ai.statemachine.states.AIWorkerState.*;\n+import static com.minecolonies.api.util.constant.TranslationConstants.PATIENT_FULL_INVENTORY;\n+\n+/**\n+ * Healer AI class.\n+ */\n+public class EntityAIWorkHealer extends AbstractEntityAIInteract<JobHealer>\n+{\n+    /**\n+     * Base xp gain for the smelter.\n+     */\n+    private static final double BASE_XP_GAIN = 5;\n+\n+    /**\n+     * How often should charisma factor into the cook's skill modifier.\n+     */\n+    private static final int CHARISMA_MULTIPLIER = 1;\n+\n+    /**\n+     * How often should intelligence factor into the cook's skill modifier.\n+     */\n+    private static final int INTELLIGENCE_MULTIPLIER = 2;\n+\n+    /**\n+     * Area the worker targets.\n+     */\n+    private AxisAlignedBB targetArea = null;\n+\n+    /**\n+     * The current patient.\n+     */\n+    private Patient currentPatient = null;\n+\n+    /**\n+     * Variable to check if the draining is in progress.\n+     * And at which tick it is.\n+     */\n+    private int progressTicks = 0;\n+\n+    /**\n+     * Max progress ticks until drainage is complete (per Level).\n+     */\n+    private static final int MAX_PROGRESS_TICKS = 30;\n+\n+    /**\n+     * Remote patient to treat.\n+     */\n+    private ICitizenData remotePatient;\n+\n+    /**\n+     * Player to heal.\n+     */\n+    private PlayerEntity playerToHeal;\n+\n+    /**\n+     * Constructor for the Cook.\n+     * Defines the tasks the cook executes.\n+     *\n+     * @param job a cook job to use.\n+     */\n+    public EntityAIWorkHealer(@NotNull final JobHealer job)\n+    {\n+        super(job);\n+        super.registerTargets(\n+          new AITarget(IDLE, START_WORKING, 1),\n+          new AITarget(START_WORKING, DECIDE, 1),\n+          new AITarget(DECIDE, this::decide, 20),\n+          new AITarget(CURE, this::cure, 20),\n+          new AITarget(FREE_CURE, this::freeCure, 20),\n+          new AITarget(CURE_PLAYER, this::curePlayer, 20),\n+          new AITarget(REQUEST_CURE, this::requestCure, 20),\n+          new AITarget(WANDER, this::wander, 20)\n+\n+        );\n+        //super.registerTargets(new AITarget(COOK_SERVE_FOOD_TO_CITIZEN, this::serveFoodToCitizen, SERVE_DELAY));\n+        worker.getCitizenExperienceHandler().setSkillModifier(CHARISMA_MULTIPLIER * worker.getCitizenData().getCharisma()\n+                + INTELLIGENCE_MULTIPLIER * worker.getCitizenData().getIntelligence());\n+        worker.setCanPickUpLoot(true);\n+    }\n+\n+    /**\n+     * Decide what to do next.\n+     * Check if all patients are up date, else update their states.\n+     * Then check if there is any patient we can cure or request things for.\n+     *\n+     * @return the next state to go to.\n+     */\n+    private IAIState decide()\n+    {\n+        if ( walkToBuilding() )\n+        {\n+            return DECIDE;\n+        }\n+\n+        final BuildingHospital hospital = getOwnBuilding(BuildingHospital.class);\n+        for (final AbstractEntityCitizen citizen : world.getEntitiesWithinAABB(ModEntities.CITIZEN, getTargetableArea(), cit -> cit.getCitizenDiseaseHandler().isSick()))\n+        {\n+            hospital.checkOrCreatePatientFile(citizen.getCitizenId());\n+        }\n+\n+        for (final Patient patient : hospital.getPatients())\n+        {\n+            final ICitizenData data = hospital.getColony().getCitizenManager().getCitizen(patient.getId());\n+            if (data == null || (data.getCitizenEntity().isPresent() && !data.getCitizenEntity().get().getCitizenDiseaseHandler().isSick()))\n+            {\n+                hospital.removePatientFile(patient);\n+                continue;\n+            }\n+            final EntityCitizen citizen = (EntityCitizen) data.getCitizenEntity().get();\n+            final String diseaseName = citizen.getCitizenDiseaseHandler().getDisease();\n+            @Nullable final Disease disease = diseaseName.isEmpty() ? null : IColonyManager.getInstance().getCompatibilityManager().getDisease(diseaseName);\n+\n+            if (patient.getState() == Patient.PatientState.NEW)\n+            {\n+                this.currentPatient = patient;\n+                return REQUEST_CURE;\n+            }\n+\n+            if (patient.getState() == Patient.PatientState.REQUESTED)\n+            {\n+                if (disease == null)\n+                {\n+                    this.currentPatient = patient;\n+                    return CURE;\n+                }\n+\n+                if (testRandomCureChance())\n+                {\n+                    this.currentPatient = patient;\n+                    return FREE_CURE;\n+                }\n+\n+                if (!InventoryUtils.isItemHandlerFull(citizen.getInventoryCitizen()))\n+                {", "originalCommit": "0c85c63781ba3b91bbe54a44eae918424dbda332", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMwMTU4MQ==", "url": "https://github.com/ldtteam/minecolonies/pull/4396#discussion_r389301581", "bodyText": "I think overall it'd be much easier to have the healer have the cure items in his stock and apply them to the citizens, would make all the inventory handling a lot easier aswell. And requesting items to the healer's/buildings inventory to put them then into the citizen seems a bit weird. To me it seems more logical that the healer/building has a stock of medicine, which he uses up when applying it to a citizen.", "author": "someaddons", "createdAt": "2020-03-07T18:18:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMwMDEzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMwNTY5Mg==", "url": "https://github.com/ldtteam/minecolonies/pull/4396#discussion_r389305692", "bodyText": "We give the citizen the cure and the citizen applies the cure to itself then basically (this way the player can also heal the citizen if no hospital is in the colony yet.", "author": "Raycoms", "createdAt": "2020-03-07T19:22:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMwMDEzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMwNTk0Ng==", "url": "https://github.com/ldtteam/minecolonies/pull/4396#discussion_r389305946", "bodyText": "ah so they can heal themselves with the items then, where does that happen though, since this AI doesnt exist then, didnt find it :D", "author": "someaddons", "createdAt": "2020-03-07T19:27:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMwMDEzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMwNjIwNg==", "url": "https://github.com/ldtteam/minecolonies/pull/4396#discussion_r389306206", "bodyText": "https://github.com/ldtteam/minecolonies/pull/4396/files#diff-097b4695b8936006a3858bd22eeb93b2", "author": "Raycoms", "createdAt": "2020-03-07T19:32:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMwMDEzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMwMDc2OA==", "url": "https://github.com/ldtteam/minecolonies/pull/4396#discussion_r389300768", "bodyText": "same as above, this probably doesnt work for requesting the same cure twice", "author": "someaddons", "createdAt": "2020-03-07T18:05:35Z", "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/healer/EntityAIWorkHealer.java", "diffHunk": "@@ -0,0 +1,527 @@\n+package com.minecolonies.coremod.entity.ai.citizen.healer;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.reflect.TypeToken;\n+import com.minecolonies.api.colony.ICitizenData;\n+import com.minecolonies.api.colony.IColonyManager;\n+import com.minecolonies.api.colony.interactionhandling.ChatPriority;\n+import com.minecolonies.api.colony.requestsystem.request.IRequest;\n+import com.minecolonies.api.colony.requestsystem.requestable.Stack;\n+import com.minecolonies.api.entity.ModEntities;\n+import com.minecolonies.api.entity.ai.statemachine.AITarget;\n+import com.minecolonies.api.entity.ai.statemachine.states.IAIState;\n+import com.minecolonies.api.entity.citizen.AbstractEntityCitizen;\n+import com.minecolonies.api.util.BlockPosUtil;\n+import com.minecolonies.api.util.Disease;\n+import com.minecolonies.api.util.InventoryUtils;\n+import com.minecolonies.coremod.Network;\n+import com.minecolonies.coremod.colony.buildings.workerbuildings.BuildingHospital;\n+import com.minecolonies.coremod.colony.interactionhandling.StandardInteractionResponseHandler;\n+import com.minecolonies.coremod.colony.jobs.JobHealer;\n+import com.minecolonies.coremod.entity.ai.basic.AbstractEntityAIInteract;\n+import com.minecolonies.coremod.entity.citizen.EntityCitizen;\n+import com.minecolonies.coremod.network.messages.CircleParticleEffectMessage;\n+import com.minecolonies.coremod.network.messages.StreamParticleEffectMessage;\n+import net.minecraft.entity.EntityType;\n+import net.minecraft.entity.player.PlayerEntity;\n+import net.minecraft.item.ItemStack;\n+import net.minecraft.particles.ParticleTypes;\n+import net.minecraft.util.math.AxisAlignedBB;\n+import net.minecraft.util.text.TranslationTextComponent;\n+import net.minecraftforge.items.CapabilityItemHandler;\n+import net.minecraftforge.items.IItemHandler;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+import static com.minecolonies.api.entity.ai.statemachine.states.AIWorkerState.*;\n+import static com.minecolonies.api.util.constant.TranslationConstants.PATIENT_FULL_INVENTORY;\n+\n+/**\n+ * Healer AI class.\n+ */\n+public class EntityAIWorkHealer extends AbstractEntityAIInteract<JobHealer>\n+{\n+    /**\n+     * Base xp gain for the smelter.\n+     */\n+    private static final double BASE_XP_GAIN = 5;\n+\n+    /**\n+     * How often should charisma factor into the cook's skill modifier.\n+     */\n+    private static final int CHARISMA_MULTIPLIER = 1;\n+\n+    /**\n+     * How often should intelligence factor into the cook's skill modifier.\n+     */\n+    private static final int INTELLIGENCE_MULTIPLIER = 2;\n+\n+    /**\n+     * Area the worker targets.\n+     */\n+    private AxisAlignedBB targetArea = null;\n+\n+    /**\n+     * The current patient.\n+     */\n+    private Patient currentPatient = null;\n+\n+    /**\n+     * Variable to check if the draining is in progress.\n+     * And at which tick it is.\n+     */\n+    private int progressTicks = 0;\n+\n+    /**\n+     * Max progress ticks until drainage is complete (per Level).\n+     */\n+    private static final int MAX_PROGRESS_TICKS = 30;\n+\n+    /**\n+     * Remote patient to treat.\n+     */\n+    private ICitizenData remotePatient;\n+\n+    /**\n+     * Player to heal.\n+     */\n+    private PlayerEntity playerToHeal;\n+\n+    /**\n+     * Constructor for the Cook.\n+     * Defines the tasks the cook executes.\n+     *\n+     * @param job a cook job to use.\n+     */\n+    public EntityAIWorkHealer(@NotNull final JobHealer job)\n+    {\n+        super(job);\n+        super.registerTargets(\n+          new AITarget(IDLE, START_WORKING, 1),\n+          new AITarget(START_WORKING, DECIDE, 1),\n+          new AITarget(DECIDE, this::decide, 20),\n+          new AITarget(CURE, this::cure, 20),\n+          new AITarget(FREE_CURE, this::freeCure, 20),\n+          new AITarget(CURE_PLAYER, this::curePlayer, 20),\n+          new AITarget(REQUEST_CURE, this::requestCure, 20),\n+          new AITarget(WANDER, this::wander, 20)\n+\n+        );\n+        //super.registerTargets(new AITarget(COOK_SERVE_FOOD_TO_CITIZEN, this::serveFoodToCitizen, SERVE_DELAY));\n+        worker.getCitizenExperienceHandler().setSkillModifier(CHARISMA_MULTIPLIER * worker.getCitizenData().getCharisma()\n+                + INTELLIGENCE_MULTIPLIER * worker.getCitizenData().getIntelligence());\n+        worker.setCanPickUpLoot(true);\n+    }\n+\n+    /**\n+     * Decide what to do next.\n+     * Check if all patients are up date, else update their states.\n+     * Then check if there is any patient we can cure or request things for.\n+     *\n+     * @return the next state to go to.\n+     */\n+    private IAIState decide()\n+    {\n+        if ( walkToBuilding() )\n+        {\n+            return DECIDE;\n+        }\n+\n+        final BuildingHospital hospital = getOwnBuilding(BuildingHospital.class);\n+        for (final AbstractEntityCitizen citizen : world.getEntitiesWithinAABB(ModEntities.CITIZEN, getTargetableArea(), cit -> cit.getCitizenDiseaseHandler().isSick()))\n+        {\n+            hospital.checkOrCreatePatientFile(citizen.getCitizenId());\n+        }\n+\n+        for (final Patient patient : hospital.getPatients())\n+        {\n+            final ICitizenData data = hospital.getColony().getCitizenManager().getCitizen(patient.getId());\n+            if (data == null || (data.getCitizenEntity().isPresent() && !data.getCitizenEntity().get().getCitizenDiseaseHandler().isSick()))\n+            {\n+                hospital.removePatientFile(patient);\n+                continue;\n+            }\n+            final EntityCitizen citizen = (EntityCitizen) data.getCitizenEntity().get();\n+            final String diseaseName = citizen.getCitizenDiseaseHandler().getDisease();\n+            @Nullable final Disease disease = diseaseName.isEmpty() ? null : IColonyManager.getInstance().getCompatibilityManager().getDisease(diseaseName);\n+\n+            if (patient.getState() == Patient.PatientState.NEW)\n+            {\n+                this.currentPatient = patient;\n+                return REQUEST_CURE;\n+            }\n+\n+            if (patient.getState() == Patient.PatientState.REQUESTED)\n+            {\n+                if (disease == null)\n+                {\n+                    this.currentPatient = patient;\n+                    return CURE;\n+                }\n+\n+                if (testRandomCureChance())\n+                {\n+                    this.currentPatient = patient;\n+                    return FREE_CURE;\n+                }\n+\n+                if (!InventoryUtils.isItemHandlerFull(citizen.getInventoryCitizen()))\n+                {\n+                    if (hasCureInInventory(disease, worker.getInventoryCitizen()) ||\n+                          hasCureInInventory(disease, getOwnBuilding().getCapability(CapabilityItemHandler.ITEM_HANDLER_CAPABILITY).orElseGet(null)))\n+                    {\n+                        this.currentPatient = patient;\n+                        return CURE;\n+                    }\n+\n+                    final ImmutableList<IRequest<? extends Stack>> list = getOwnBuilding().getOpenRequestsOfType(worker.getCitizenData(), TypeToken.of(Stack.class));\n+                    for (final ItemStack cure : IColonyManager.getInstance().getCompatibilityManager().getDisease(diseaseName).getCure())\n+                    {\n+                        boolean hasCureRequested = false;\n+                        for (final IRequest<? extends Stack> request : list)\n+                        {\n+                            if (request.getRequest().getStack().isItemEqual(cure))\n+                            {\n+                                hasCureRequested = true;\n+                            }\n+                        }\n+                        if (!hasCureRequested)\n+                        {\n+                            patient.setState(Patient.PatientState.NEW);\n+                            break;\n+                        }\n+                    }\n+                }\n+                else\n+                {\n+                    data.triggerInteraction(new StandardInteractionResponseHandler(new TranslationTextComponent(PATIENT_FULL_INVENTORY), ChatPriority.BLOCKING));\n+                }\n+            }\n+\n+            if (patient.getState() == Patient.PatientState.TREATED)\n+            {\n+                if (disease == null)\n+                {\n+                    this.currentPatient = patient;\n+                    return CURE;\n+                }\n+\n+                if (!hasCureInInventory(disease, citizen.getInventoryCitizen()))\n+                {\n+                    patient.setState(Patient.PatientState.NEW);\n+                    return DECIDE;\n+                }\n+            }\n+        }\n+\n+        for (final PlayerEntity player : world.getEntitiesWithinAABB(EntityType.PLAYER, getTargetableArea(), player -> player.getHealth() < player.getMaxHealth() - 10 -  (2 * getOwnBuilding().getBuildingLevel())))\n+        {\n+            playerToHeal = player;\n+            return CURE_PLAYER;\n+        }\n+\n+        final ICitizenData data = getOwnBuilding().getColony().getCitizenManager().getRandomCitizen();\n+        if (data.getCitizenEntity().isPresent() && data.getCitizenEntity().get().getHealth() < 10.0 && BlockPosUtil.getDistance2D(data.getCitizenEntity().get().getPosition(), getOwnBuilding().getPosition()) < getOwnBuilding().getBuildingLevel() * 40)\n+        {\n+            remotePatient = data;\n+            return WANDER;\n+        }\n+        return DECIDE;\n+    }\n+\n+\n+    /**\n+     * Request the cure for a given patient.\n+     * @return the next state to go to.\n+     */\n+    private IAIState requestCure()\n+    {\n+        if (currentPatient == null)\n+        {\n+            return DECIDE;\n+        }\n+\n+        final ICitizenData data = getOwnBuilding().getColony().getCitizenManager().getCitizen(currentPatient.getId());\n+        if (data == null || !data.getCitizenEntity().isPresent() || !data.getCitizenEntity().get().getCitizenDiseaseHandler().isSick())\n+        {\n+            currentPatient = null;\n+            return DECIDE;\n+        }\n+\n+        final EntityCitizen citizen = (EntityCitizen) data.getCitizenEntity().get();\n+        if (walkToBlock(citizen.getPosition()))\n+        {\n+            return REQUEST_CURE;\n+        }\n+\n+        final String diseaseName = citizen.getCitizenDiseaseHandler().getDisease();\n+        if (diseaseName.isEmpty())\n+        {\n+            currentPatient.setState(Patient.PatientState.REQUESTED);\n+            currentPatient = null;\n+            return DECIDE;\n+        }\n+\n+        final ImmutableList<IRequest<? extends Stack>> list = getOwnBuilding().getOpenRequestsOfType(worker.getCitizenData(), TypeToken.of(Stack.class));\n+        for (final ItemStack cure : IColonyManager.getInstance().getCompatibilityManager().getDisease(diseaseName).getCure())\n+        {\n+            boolean hasRequest = false;\n+            for (final IRequest<? extends Stack> request : list)\n+            {\n+                if (request.getRequest().getStack().isItemEqual(cure))\n+                {", "originalCommit": "0c85c63781ba3b91bbe54a44eae918424dbda332", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMwNTc4Nw==", "url": "https://github.com/ldtteam/minecolonies/pull/4396#discussion_r389305787", "bodyText": "In this regard, it doesn't matter much. The healer will re-request it then later on. After he notices he is missing a cure for another citizen.", "author": "Raycoms", "createdAt": "2020-03-07T19:24:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMwMDc2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMwMjMzNg==", "url": "https://github.com/ldtteam/minecolonies/pull/4396#discussion_r389302336", "bodyText": "could just do == 20 here :D", "author": "someaddons", "createdAt": "2020-03-07T18:31:07Z", "path": "src/main/java/com/minecolonies/coremod/entity/ai/minimal/EntityAIEatTask.java", "diffHunk": "@@ -157,6 +161,12 @@ public boolean shouldExecute()\n     @Override\n     public void tick()\n     {\n+        if (++delayTicks % TICKS_SECOND != 0)", "originalCommit": "0c85c63781ba3b91bbe54a44eae918424dbda332", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMwNTM4NA==", "url": "https://github.com/ldtteam/minecolonies/pull/4396#discussion_r389305384", "bodyText": "yeah ==, true", "author": "Raycoms", "createdAt": "2020-03-07T19:17:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMwMjMzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMwMzgyOA==", "url": "https://github.com/ldtteam/minecolonies/pull/4396#discussion_r389303828", "bodyText": "I think this AI could be quite a bit easier with all its states/timers by using a statemachine, like the Child minimal AI does", "author": "someaddons", "createdAt": "2020-03-07T18:53:43Z", "path": "src/main/java/com/minecolonies/coremod/entity/ai/minimal/EntityAISickTask.java", "diffHunk": "@@ -0,0 +1,498 @@\n+package com.minecolonies.coremod.entity.ai.minimal;\n+\n+import com.minecolonies.api.colony.ICitizenData;\n+import com.minecolonies.api.colony.IColony;\n+import com.minecolonies.api.colony.IColonyManager;\n+import com.minecolonies.api.colony.buildings.IBuilding;\n+import com.minecolonies.api.colony.buildings.IBuildingWorker;\n+import com.minecolonies.api.colony.interactionhandling.ChatPriority;\n+import com.minecolonies.api.entity.ai.DesiredActivity;\n+import com.minecolonies.api.util.BlockPosUtil;\n+import com.minecolonies.api.util.Disease;\n+import com.minecolonies.api.util.InventoryUtils;\n+import com.minecolonies.api.util.SoundUtils;\n+import com.minecolonies.coremod.Network;\n+import com.minecolonies.coremod.colony.buildings.workerbuildings.BuildingHospital;\n+import com.minecolonies.coremod.colony.interactionhandling.StandardInteractionResponseHandler;\n+import com.minecolonies.coremod.entity.citizen.EntityCitizen;\n+import com.minecolonies.coremod.network.messages.CircleParticleEffectMessage;\n+import net.minecraft.block.BedBlock;\n+import net.minecraft.block.BlockState;\n+import net.minecraft.entity.ai.goal.Goal;\n+import net.minecraft.item.ItemStack;\n+import net.minecraft.particles.ParticleTypes;\n+import net.minecraft.potion.EffectInstance;\n+import net.minecraft.potion.Effects;\n+import net.minecraft.state.properties.BedPart;\n+import net.minecraft.tags.BlockTags;\n+import net.minecraft.util.Hand;\n+import net.minecraft.util.SoundEvents;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.util.text.TranslationTextComponent;\n+import net.minecraft.world.World;\n+\n+import java.util.EnumSet;\n+import java.util.List;\n+\n+import static com.minecolonies.api.util.constant.Constants.TICKS_SECOND;\n+import static com.minecolonies.api.util.constant.GuardConstants.BASIC_VOLUME;\n+import static com.minecolonies.api.util.constant.TranslationConstants.NO_HOSPITAL;\n+import static com.minecolonies.coremod.entity.ai.minimal.EntityAISickTask.DiseaseState.*;\n+import static com.minecolonies.coremod.entity.citizen.citizenhandlers.CitizenDiseaseHandler.SEEK_DOCTOR_HEALTH;\n+\n+/**\n+ * The AI task for citizens to execute when they are supposed to eat.\n+ */\n+public class EntityAISickTask extends Goal\n+{\n+    /**\n+     * Min distance to hut before pathing to hospital.\n+     */\n+    private static final int MIN_DIST_TO_HUT = 5;\n+\n+    /**\n+     * Min distance to hospital before trying to find a bed.\n+     */\n+    private static final int MIN_DIST_TO_HOSPITAL = 3;\n+\n+    /**\n+     * Min distance to the hospital in general.\n+     */\n+    private static final long MINIMUM_DISTANCE_TO_HOSPITAL = 10;\n+\n+    /**\n+     * Required time to cure.\n+     */\n+    private static final int REQUIRED_TIME_TO_CURE = 60;\n+\n+    /**\n+     * Chance for a random cure to happen.\n+     */\n+    private static final int CHANCE_FOR_RANDOM_CURE = 10;\n+\n+    /**\n+     * Attempts to position right in the bed.\n+     */\n+    private static final int GOING_TO_BED_ATTEMPTS = 20;\n+\n+    /**\n+     * The waiting ticks.\n+     */\n+    private int waitingTicks = 0;\n+\n+    /**\n+     * The bed the citizen is sleeping in.\n+     */\n+    private BlockPos usedBed;\n+\n+    /**\n+     * The different types of AIStates related to eating.\n+     */\n+    public enum DiseaseState\n+    {\n+        IDLE,\n+        CHECK_FOR_CURE,\n+        GO_TO_HUT,\n+        SEARCH_HOSPITAL,\n+        GO_TO_HOSPITAL,\n+        WAIT_FOR_CURE,\n+        FIND_EMPTY_BED,\n+        APPLY_CURE\n+    }\n+\n+    /**\n+     * The citizen assigned to this task.\n+     */\n+    private final EntityCitizen citizen;\n+\n+    /**\n+     * The state the task is in currently.\n+     */\n+    private DiseaseState currentState = IDLE;\n+\n+    /**\n+     * Restaurant to which the citizen should path.\n+     */\n+    private BlockPos placeToPath;\n+\n+    /**\n+     * Delay ticks.\n+     */\n+    private int delayTicks = 0;\n+\n+    /**\n+     * Instantiates this task.\n+     *\n+     * @param citizen the citizen.\n+     */\n+    public EntityAISickTask(final EntityCitizen citizen)\n+    {\n+        super();\n+        this.citizen = citizen;\n+        this.setMutexFlags(EnumSet.of(Flag.MOVE));\n+    }\n+\n+    @Override\n+    public boolean shouldExecute()\n+    {", "originalCommit": "0c85c63781ba3b91bbe54a44eae918424dbda332", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMwNTU5OA==", "url": "https://github.com/ldtteam/minecolonies/pull/4396#discussion_r389305598", "bodyText": "I don't think we should add a new state machine to each individual minimal task. Else we'd setup a state machine all these can use somehow (avoid duplicate code)", "author": "Raycoms", "createdAt": "2020-03-07T19:21:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMwMzgyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMwNTY3Mw==", "url": "https://github.com/ldtteam/minecolonies/pull/4396#discussion_r389305673", "bodyText": "ye using a statemachine is a little bit overkill(though they're cheap) but lateron when we combine the AI's nicely we got AITargets to use already", "author": "someaddons", "createdAt": "2020-03-07T19:22:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMwMzgyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMwNTc1OQ==", "url": "https://github.com/ldtteam/minecolonies/pull/4396#discussion_r389305759", "bodyText": "ye", "author": "Raycoms", "createdAt": "2020-03-07T19:23:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMwMzgyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMwMzg5MA==", "url": "https://github.com/ldtteam/minecolonies/pull/4396#discussion_r389303890", "bodyText": "javadoc :)", "author": "someaddons", "createdAt": "2020-03-07T18:54:50Z", "path": "src/main/java/com/minecolonies/coremod/entity/citizen/EntityCitizen.java", "diffHunk": "@@ -654,6 +663,17 @@ public ICitizenStuckHandler getCitizenStuckHandler()\n         return citizenStuckHandler;\n     }\n \n+    /**\n+     * The Handler to check if a citizen is stuck.", "originalCommit": "0c85c63781ba3b91bbe54a44eae918424dbda332", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0dcdd02d7218a42ff817f9e118d9b251e823165c", "url": "https://github.com/ldtteam/minecolonies/commit/0dcdd02d7218a42ff817f9e118d9b251e823165c", "message": "Fix a bunch of the review comments", "committedDate": "2020-03-07T19:18:09Z", "type": "commit"}, {"oid": "011467c83bb8ba82f2e7897475ddd2840262c061", "url": "https://github.com/ldtteam/minecolonies/commit/011467c83bb8ba82f2e7897475ddd2840262c061", "message": "Merge branch 'version/1.15' into feature/hospital", "committedDate": "2020-03-07T20:26:02Z", "type": "commit"}, {"oid": "32e892bba6b2b1bbee7c13924a5f7fbb864b7833", "url": "https://github.com/ldtteam/minecolonies/commit/32e892bba6b2b1bbee7c13924a5f7fbb864b7833", "message": "Merge branch 'version/1.15' into feature/hospital", "committedDate": "2020-03-07T20:43:36Z", "type": "commit"}, {"oid": "a58e66202837bcd2ad5e1678d56d949607620383", "url": "https://github.com/ldtteam/minecolonies/commit/a58e66202837bcd2ad5e1678d56d949607620383", "message": "fix compile", "committedDate": "2020-03-07T22:11:43Z", "type": "commit"}, {"oid": "5308c5501ed1a7b987a2e4c1a3f167f0e60a2ac8", "url": "https://github.com/ldtteam/minecolonies/commit/5308c5501ed1a7b987a2e4c1a3f167f0e60a2ac8", "message": "Merge remote-tracking branch 'origin/feature/hospital' into feature/hospital", "committedDate": "2020-03-07T22:11:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM0NDIxMQ==", "url": "https://github.com/ldtteam/minecolonies/pull/4396#discussion_r389344211", "bodyText": "might crash when the hospital doesnt exist", "author": "someaddons", "createdAt": "2020-03-08T07:42:29Z", "path": "src/main/java/com/minecolonies/coremod/entity/citizen/citizenhandlers/CitizenDiseaseHandler.java", "diffHunk": "@@ -0,0 +1,105 @@\n+package com.minecolonies.coremod.entity.citizen.citizenhandlers;\n+\n+import com.minecolonies.api.colony.IColony;\n+import com.minecolonies.api.colony.IColonyManager;\n+import com.minecolonies.api.colony.buildings.IBuilding;\n+import com.minecolonies.api.entity.citizen.AbstractEntityCitizen;\n+import com.minecolonies.api.entity.citizen.citizenhandlers.ICitizenDiseaseHandler;\n+import com.minecolonies.coremod.MineColonies;\n+import com.minecolonies.coremod.colony.jobs.AbstractJobGuard;\n+import com.minecolonies.coremod.colony.jobs.JobHealer;\n+import com.minecolonies.coremod.entity.citizen.EntityCitizen;\n+import net.minecraft.nbt.CompoundNBT;\n+import net.minecraft.util.math.BlockPos;\n+\n+import static com.minecolonies.api.util.constant.CitizenConstants.*;\n+\n+/**\n+ * Handler taking care of citizens getting stuck.\n+ */\n+public class CitizenDiseaseHandler implements ICitizenDiseaseHandler\n+{\n+    /**\n+     * Health at which citizens seek a doctor.\n+     */\n+    public static final double SEEK_DOCTOR_HEALTH = 4.0;\n+\n+    /**\n+     * Base likelihood of a citizen getting a disease.\n+     */\n+    private static final int DISEASE_FACTOR = 100000;\n+\n+    /**\n+     * The citizen assigned to this manager.\n+     */\n+    private final AbstractEntityCitizen citizen;\n+\n+    /**\n+     * The disease the citizen has, empty if none.\n+     */\n+    private String disease = \"\";\n+\n+    /**\n+     * Constructor for the experience handler.\n+     * @param citizen the citizen owning the handler.\n+     */\n+    public CitizenDiseaseHandler(final EntityCitizen citizen)\n+    {\n+        this.citizen = citizen;\n+    }\n+\n+    /**\n+     * Called in the citizen every few ticks to check if stuck.\n+     */\n+    @Override\n+    public void tick()\n+    {\n+        if (citizen.getTicksExisted() % TICKS_20 == 0 && !(citizen.getCitizenJobHandler().getColonyJob() instanceof JobHealer))\n+        {\n+            final int citizenModifier = citizen.getCitizenJobHandler().getColonyJob() == null ? 1 : citizen.getCitizenJobHandler().getColonyJob().getDiseaseModifier();\n+            final int configModifier = MineColonies.getConfig().getCommon().diseaseModifier.get();\n+            if (citizen.getRandom().nextInt(configModifier * DISEASE_FACTOR / citizen.getCitizenColonyHandler().getColony().getCitizenManager().getCurrentCitizenCount()) < citizenModifier)\n+            {\n+                this.disease = IColonyManager.getInstance().getCompatibilityManager().getRandomDisease();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public boolean isSick()\n+    {\n+        return !disease.isEmpty() || ( !(citizen.getCitizenJobHandler() instanceof AbstractJobGuard) && citizen.getHealth() <= SEEK_DOCTOR_HEALTH);\n+    }\n+\n+    @Override\n+    public void write(final CompoundNBT compound)\n+    {\n+        compound.putString(TAG_DISEASE, disease);\n+    }\n+\n+    @Override\n+    public void read(final CompoundNBT compound)\n+    {\n+        this.disease = compound.getString(TAG_DISEASE);\n+    }\n+\n+    @Override\n+    public String getDisease()\n+    {\n+        return this.disease;\n+    }\n+\n+    @Override\n+    public void cure()\n+    {\n+        this.disease = \"\";\n+        if (citizen.getCitizenSleepHandler().isAsleep())\n+        {\n+            citizen.wakeUp();\n+            final BlockPos hospitalPos = citizen.getCitizenColonyHandler().getColony().getBuildingManager().getBestHospital(citizen);\n+            final IColony colony = citizen.getCitizenColonyHandler().getColony();\n+            final IBuilding hospital = colony.getBuildingManager().getBuilding(hospitalPos);\n+            hospital.onWakeUp();", "originalCommit": "5308c5501ed1a7b987a2e4c1a3f167f0e60a2ac8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM1MDQ1NQ==", "url": "https://github.com/ldtteam/minecolonies/pull/4396#discussion_r389350455", "bodyText": "true", "author": "Raycoms", "createdAt": "2020-03-08T09:13:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM0NDIxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM0ODU5Mw==", "url": "https://github.com/ldtteam/minecolonies/pull/4396#discussion_r389348593", "bodyText": "isnt/shouldnt be he cured if the disease is empty and go back to idle/reset?", "author": "someaddons", "createdAt": "2020-03-08T08:46:24Z", "path": "src/main/java/com/minecolonies/coremod/entity/ai/minimal/EntityAISickTask.java", "diffHunk": "@@ -0,0 +1,498 @@\n+package com.minecolonies.coremod.entity.ai.minimal;\n+\n+import com.minecolonies.api.colony.ICitizenData;\n+import com.minecolonies.api.colony.IColony;\n+import com.minecolonies.api.colony.IColonyManager;\n+import com.minecolonies.api.colony.buildings.IBuilding;\n+import com.minecolonies.api.colony.buildings.IBuildingWorker;\n+import com.minecolonies.api.colony.interactionhandling.ChatPriority;\n+import com.minecolonies.api.entity.ai.DesiredActivity;\n+import com.minecolonies.api.util.BlockPosUtil;\n+import com.minecolonies.api.util.Disease;\n+import com.minecolonies.api.util.InventoryUtils;\n+import com.minecolonies.api.util.SoundUtils;\n+import com.minecolonies.coremod.Network;\n+import com.minecolonies.coremod.colony.buildings.workerbuildings.BuildingHospital;\n+import com.minecolonies.coremod.colony.interactionhandling.StandardInteractionResponseHandler;\n+import com.minecolonies.coremod.entity.citizen.EntityCitizen;\n+import com.minecolonies.coremod.network.messages.CircleParticleEffectMessage;\n+import net.minecraft.block.BedBlock;\n+import net.minecraft.block.BlockState;\n+import net.minecraft.entity.ai.goal.Goal;\n+import net.minecraft.item.ItemStack;\n+import net.minecraft.particles.ParticleTypes;\n+import net.minecraft.potion.EffectInstance;\n+import net.minecraft.potion.Effects;\n+import net.minecraft.state.properties.BedPart;\n+import net.minecraft.tags.BlockTags;\n+import net.minecraft.util.Hand;\n+import net.minecraft.util.SoundEvents;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.util.text.TranslationTextComponent;\n+import net.minecraft.world.World;\n+\n+import java.util.EnumSet;\n+import java.util.List;\n+\n+import static com.minecolonies.api.util.constant.Constants.TICKS_SECOND;\n+import static com.minecolonies.api.util.constant.GuardConstants.BASIC_VOLUME;\n+import static com.minecolonies.api.util.constant.TranslationConstants.NO_HOSPITAL;\n+import static com.minecolonies.coremod.entity.ai.minimal.EntityAISickTask.DiseaseState.*;\n+import static com.minecolonies.coremod.entity.citizen.citizenhandlers.CitizenDiseaseHandler.SEEK_DOCTOR_HEALTH;\n+\n+/**\n+ * The AI task for citizens to execute when they are supposed to eat.\n+ */\n+public class EntityAISickTask extends Goal\n+{\n+    /**\n+     * Min distance to hut before pathing to hospital.\n+     */\n+    private static final int MIN_DIST_TO_HUT = 5;\n+\n+    /**\n+     * Min distance to hospital before trying to find a bed.\n+     */\n+    private static final int MIN_DIST_TO_HOSPITAL = 3;\n+\n+    /**\n+     * Min distance to the hospital in general.\n+     */\n+    private static final long MINIMUM_DISTANCE_TO_HOSPITAL = 10;\n+\n+    /**\n+     * Required time to cure.\n+     */\n+    private static final int REQUIRED_TIME_TO_CURE = 60;\n+\n+    /**\n+     * Chance for a random cure to happen.\n+     */\n+    private static final int CHANCE_FOR_RANDOM_CURE = 10;\n+\n+    /**\n+     * Attempts to position right in the bed.\n+     */\n+    private static final int GOING_TO_BED_ATTEMPTS = 20;\n+\n+    /**\n+     * The waiting ticks.\n+     */\n+    private int waitingTicks = 0;\n+\n+    /**\n+     * The bed the citizen is sleeping in.\n+     */\n+    private BlockPos usedBed;\n+\n+    /**\n+     * The different types of AIStates related to eating.\n+     */\n+    public enum DiseaseState\n+    {\n+        IDLE,\n+        CHECK_FOR_CURE,\n+        GO_TO_HUT,\n+        SEARCH_HOSPITAL,\n+        GO_TO_HOSPITAL,\n+        WAIT_FOR_CURE,\n+        FIND_EMPTY_BED,\n+        APPLY_CURE\n+    }\n+\n+    /**\n+     * The citizen assigned to this task.\n+     */\n+    private final EntityCitizen citizen;\n+\n+    /**\n+     * The state the task is in currently.\n+     */\n+    private DiseaseState currentState = IDLE;\n+\n+    /**\n+     * Restaurant to which the citizen should path.\n+     */\n+    private BlockPos placeToPath;\n+\n+    /**\n+     * Delay ticks.\n+     */\n+    private int delayTicks = 0;\n+\n+    /**\n+     * Instantiates this task.\n+     *\n+     * @param citizen the citizen.\n+     */\n+    public EntityAISickTask(final EntityCitizen citizen)\n+    {\n+        super();\n+        this.citizen = citizen;\n+        this.setMutexFlags(EnumSet.of(Flag.MOVE));\n+    }\n+\n+    @Override\n+    public boolean shouldExecute()\n+    {\n+        if (citizen.getDesiredActivity() == DesiredActivity.SLEEP && !citizen.isSleeping())\n+        {\n+            return false;\n+        }\n+\n+        if (currentState != IDLE)\n+        {\n+            return true;\n+        }\n+\n+        return citizen.getCitizenDiseaseHandler().isSick();\n+    }\n+\n+    @Override\n+    public void tick()\n+    {\n+        if (++delayTicks == TICKS_SECOND)\n+        {\n+            return;\n+        }\n+        delayTicks = 0;\n+\n+        final ICitizenData citizenData = citizen.getCitizenData();\n+        if (citizenData == null)\n+        {\n+            return;\n+        }\n+\n+        citizen.addPotionEffect(new EffectInstance(Effects.SLOWNESS, TICKS_SECOND * 30));\n+        switch (currentState)\n+        {\n+            case CHECK_FOR_CURE:\n+                currentState = checkForCure(citizenData);\n+                return;\n+            case GO_TO_HUT:\n+                currentState = goToHut(citizenData);\n+                return;\n+            case SEARCH_HOSPITAL:\n+                currentState = searchHospital(citizenData);\n+                return;\n+            case GO_TO_HOSPITAL:\n+                currentState = goToHospital();\n+                return;\n+            case WAIT_FOR_CURE:\n+                currentState = waitForCure(citizenData);\n+                return;\n+            case APPLY_CURE:\n+                currentState = applyCure(citizenData);\n+                return;\n+            case FIND_EMPTY_BED:\n+                currentState = findEmptyBed();\n+                return;\n+            default:\n+                reset();\n+                break;\n+        }\n+    }\n+\n+    /**\n+     * Find an empty bed to ly in.\n+     *\n+     * @return the next state to go to.\n+     */\n+    private DiseaseState findEmptyBed()\n+    {\n+        // Finding bed\n+        if (usedBed == null && citizen.getCitizenData() != null)\n+        {\n+            this.usedBed = citizen.getCitizenData().getBedPos();\n+            if (citizen.getCitizenData().getBedPos().equals(BlockPos.ZERO))\n+            {\n+                this.usedBed = null;\n+            }\n+        }\n+\n+        final BlockPos hospitalPos = citizen.getCitizenColonyHandler().getColony().getBuildingManager().getBestHospital(citizen);\n+        final IColony colony = citizen.getCitizenColonyHandler().getColony();\n+        final IBuilding hospital = colony.getBuildingManager().getBuilding(hospitalPos);\n+\n+        if (hospital instanceof BuildingHospital)\n+        {\n+            if (usedBed == null)\n+            {\n+                for (final BlockPos pos : ((BuildingHospital) hospital).getBedList())\n+                {\n+                    final World world = citizen.world;\n+                    BlockState state = world.getBlockState(pos);\n+                    state = state.getBlock().getExtendedState(state, world, pos);\n+                    if (state.getBlock().isIn(BlockTags.BEDS)\n+                          && !state.get(BedBlock.OCCUPIED)\n+                          && state.get(BedBlock.PART).equals(BedPart.HEAD)\n+                          && world.isAirBlock(pos.up()))\n+                    {\n+                        usedBed = pos;\n+                        ((BuildingHospital) hospital).registerPatient(usedBed, citizen.getCitizenId());\n+                        return FIND_EMPTY_BED;\n+                    }\n+                }\n+\n+                if (usedBed == null)\n+                {\n+                    return WAIT_FOR_CURE;\n+                }\n+            }\n+\n+            if (citizen.isWorkerAtSiteWithMove(usedBed, 3))\n+            {\n+                waitingTicks++;\n+                if (!citizen.getCitizenSleepHandler().trySleep(usedBed))\n+                {\n+                    ((BuildingHospital) hospital).registerPatient(usedBed, 0);\n+                    citizen.getCitizenData().setBedPos(BlockPos.ZERO);\n+                    usedBed = null;\n+                }\n+            }\n+        }\n+\n+        if (waitingTicks > GOING_TO_BED_ATTEMPTS)\n+        {\n+            waitingTicks = 0;\n+            return WAIT_FOR_CURE;\n+        }\n+        return FIND_EMPTY_BED;\n+    }\n+\n+    /**\n+     * Actual action of eating.\n+     *\n+     * @param citizenData the citizen.\n+     * @return the next state to go to, if successful idle.\n+     */\n+    private DiseaseState applyCure(final ICitizenData citizenData)\n+    {\n+        if (checkForCure(citizenData) != APPLY_CURE)\n+        {\n+            return CHECK_FOR_CURE;\n+        }\n+\n+        final List<ItemStack> list = IColonyManager.getInstance().getCompatibilityManager().getDisease(citizen.getCitizenDiseaseHandler().getDisease()).getCure();\n+        citizen.setHeldItem(Hand.MAIN_HAND, list.get(citizen.getRandom().nextInt(list.size())));\n+\n+\n+        citizen.swingArm(Hand.MAIN_HAND);\n+        citizen.playSound(SoundEvents.BLOCK_NOTE_BLOCK_HARP, (float) BASIC_VOLUME, (float) SoundUtils.getRandomPitch(citizen.getRandom()));\n+            Network.getNetwork().sendToTrackingEntity(\n+              new CircleParticleEffectMessage(\n+                citizen.getPositionVec().add(0, 2, 0),\n+                ParticleTypes.HAPPY_VILLAGER,\n+                waitingTicks), citizen);\n+\n+\n+        waitingTicks++;\n+        if (waitingTicks < REQUIRED_TIME_TO_CURE)\n+        {\n+            return APPLY_CURE;\n+        }\n+\n+        cure(citizenData);\n+        return IDLE;\n+    }\n+\n+    /**\n+     * Cure the citizen.\n+     */\n+    private void cure(final ICitizenData citizenData)\n+    {\n+        final Disease disease = IColonyManager.getInstance().getCompatibilityManager().getDisease(citizen.getCitizenDiseaseHandler().getDisease());\n+        for (final ItemStack cure : disease.getCure())\n+        {\n+            final int slot = InventoryUtils.findFirstSlotInProviderNotEmptyWith(citizen, stack -> stack.isItemEqual(cure));\n+            if (slot != -1)\n+            {\n+                citizenData.getInventory().extractItem(slot, 1, false);\n+            }\n+        }\n+\n+        if (usedBed != null)\n+        {\n+            final BlockPos hospitalPos = citizen.getCitizenColonyHandler().getColony().getBuildingManager().getBestHospital(citizen);\n+            final IColony colony = citizen.getCitizenColonyHandler().getColony();\n+            final IBuilding hospital = colony.getBuildingManager().getBuilding(hospitalPos);\n+            ((BuildingHospital) hospital).registerPatient(usedBed, 0);\n+            usedBed = null;\n+            citizen.getCitizenData().setBedPos(BlockPos.ZERO);\n+        }\n+        citizen.setHeldItem(Hand.MAIN_HAND, ItemStack.EMPTY);\n+        citizenData.getCitizenHappinessHandler().setHealthModifier(true);\n+        citizenData.markDirty();\n+        citizen.getCitizenDiseaseHandler().cure();\n+        citizen.setHealth((float) citizenData.getMaxHealth());\n+        reset();\n+    }\n+\n+    /**\n+     * Stay in bed while waiting to be cured.\n+     *\n+     * @param citizenData the citizen to check.\n+     * @return the next state to go to.\n+     */\n+    private DiseaseState waitForCure(final ICitizenData citizenData)\n+    {\n+        final IColony colony = citizenData.getColony();\n+        placeToPath = colony.getBuildingManager().getBestHospital(citizen);\n+\n+        if (placeToPath == null)\n+        {\n+            return SEARCH_HOSPITAL;\n+        }\n+\n+        final DiseaseState state = checkForCure(citizenData);\n+        if (state == APPLY_CURE)\n+        {\n+            return APPLY_CURE;\n+        }\n+        else if (state == IDLE)\n+        {\n+            reset();\n+            return IDLE;\n+        }\n+\n+        if (citizen.getRandom().nextInt(10000) < CHANCE_FOR_RANDOM_CURE)\n+        {\n+            cure(citizenData);\n+        }\n+\n+        if (!citizen.getCitizenSleepHandler().isAsleep() && BlockPosUtil.getDistance2D(placeToPath, citizen.getPosition()) > MINIMUM_DISTANCE_TO_HOSPITAL)\n+        {\n+            return GO_TO_HOSPITAL;\n+        }\n+\n+        if (!citizen.getCitizenSleepHandler().isAsleep())\n+        {\n+            return FIND_EMPTY_BED;\n+        }\n+\n+        return WAIT_FOR_CURE;\n+    }\n+\n+    /**\n+     * Go to the hut to try to get food there first.\n+     *\n+     * @return the next state to go to.\n+     */\n+    private DiseaseState goToHut(final ICitizenData data)\n+    {\n+        final IBuildingWorker buildingWorker = data.getWorkBuilding();\n+        if (buildingWorker == null)\n+        {\n+            return SEARCH_HOSPITAL;\n+        }\n+\n+        if (citizen.getCitizenSleepHandler().isAsleep() || citizen.isWorkerAtSiteWithMove(buildingWorker.getPosition(), MIN_DIST_TO_HUT))\n+        {\n+            return SEARCH_HOSPITAL;\n+        }\n+        return GO_TO_HUT;\n+    }\n+\n+    /**\n+     * Go to the previously found placeToPath to get cure.\n+     *\n+     * @return the next state to go to.\n+     */\n+    private DiseaseState goToHospital()\n+    {\n+        if (placeToPath == null)\n+        {\n+            return SEARCH_HOSPITAL;\n+        }\n+\n+        if (citizen.getCitizenSleepHandler().isAsleep() || citizen.isWorkerAtSiteWithMove(placeToPath, MIN_DIST_TO_HOSPITAL))\n+        {\n+            return WAIT_FOR_CURE;\n+        }\n+        return SEARCH_HOSPITAL;\n+    }\n+\n+    /**\n+     * Search for a placeToPath within the colony of the citizen.\n+     *\n+     * @param citizenData the citizen.\n+     * @return the next state to go to.\n+     */\n+    private DiseaseState searchHospital(final ICitizenData citizenData)\n+    {\n+        final IColony colony = citizenData.getColony();\n+        placeToPath = colony.getBuildingManager().getBestHospital(citizen);\n+\n+        if (placeToPath == null)\n+        {\n+            final String id = citizen.getCitizenDiseaseHandler().getDisease();\n+            if (id.isEmpty())\n+            {\n+                return IDLE;\n+            }\n+            final Disease disease = IColonyManager.getInstance().getCompatibilityManager().getDisease(id);\n+            citizenData.triggerInteraction(new StandardInteractionResponseHandler(new TranslationTextComponent(NO_HOSPITAL, disease.getName(), disease.getCureString()), new TranslationTextComponent(NO_HOSPITAL),\n+              ChatPriority.BLOCKING));\n+            return IDLE;\n+        }\n+\n+        // Reset AI when starting to go to the hospital.\n+        if (citizen.getCitizenJobHandler().getColonyJob() != null)\n+        {\n+            citizen.getCitizenJobHandler().getColonyJob().resetAI();\n+        }\n+        return GO_TO_HOSPITAL;\n+    }\n+\n+    /**\n+     * Checks if the citizen has the cure in the inventory and makes a decision based on that.\n+     *\n+     * @param citizenData the citizen to check.\n+     * @return the next state to go to.\n+     */\n+    private DiseaseState checkForCure(final ICitizenData citizenData)\n+    {\n+        final String id = citizen.getCitizenDiseaseHandler().getDisease();\n+        if (id.isEmpty())\n+        {\n+            if (citizen.getHealth() > SEEK_DOCTOR_HEALTH)\n+            {\n+                reset();\n+                currentState = IDLE;\n+                return IDLE;\n+            }\n+            return GO_TO_HUT;", "originalCommit": "5308c5501ed1a7b987a2e4c1a3f167f0e60a2ac8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM1MDU1Mw==", "url": "https://github.com/ldtteam/minecolonies/pull/4396#discussion_r389350553", "bodyText": "If disease is empty the only way for him to get there is if the health was too low. So in this case we check if he recovered health (then reset) and else he will try his way to his hut and then to the hospital.", "author": "Raycoms", "createdAt": "2020-03-08T09:14:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM0ODU5Mw=="}], "type": "inlineReview"}, {"oid": "314691fee5746b2fe8a960e8cf624b4a712b7826", "url": "https://github.com/ldtteam/minecolonies/commit/314691fee5746b2fe8a960e8cf624b4a712b7826", "message": "add null check", "committedDate": "2020-03-08T09:14:40Z", "type": "commit"}, {"oid": "1ab42e94c6f59a726de408fe2195880ed807653d", "url": "https://github.com/ldtteam/minecolonies/commit/1ab42e94c6f59a726de408fe2195880ed807653d", "message": "go", "committedDate": "2020-03-08T11:42:00Z", "type": "commit"}, {"oid": "31bf2007ee43a4c7bd16497e67bb65fa1d5a20b5", "url": "https://github.com/ldtteam/minecolonies/commit/31bf2007ee43a4c7bd16497e67bb65fa1d5a20b5", "message": "stage", "committedDate": "2020-03-08T11:42:03Z", "type": "commit"}, {"oid": "13df10e48f147cb572823bfc4a281e9af0e0c40e", "url": "https://github.com/ldtteam/minecolonies/commit/13df10e48f147cb572823bfc4a281e9af0e0c40e", "message": "Revert \"stage\"\n\nThis reverts commit 31bf2007ee43a4c7bd16497e67bb65fa1d5a20b5.", "committedDate": "2020-03-08T11:42:08Z", "type": "commit"}, {"oid": "f7a0b9ea318fb4f3b8c96ec57a63cf71aea45a4b", "url": "https://github.com/ldtteam/minecolonies/commit/f7a0b9ea318fb4f3b8c96ec57a63cf71aea45a4b", "message": "fix namings for townhall list", "committedDate": "2020-03-08T16:40:30Z", "type": "commit"}]}