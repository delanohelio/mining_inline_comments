{"pr_number": 4586, "pr_title": "Reduce initial data request", "pr_createdAt": "2020-10-01T20:26:27Z", "pr_url": "https://github.com/bisq-network/bisq/pull/4586", "timeline": [{"oid": "2e50e4c5d7e96790c4812c825b386761e01d48a7", "url": "https://github.com/bisq-network/bisq/commit/2e50e4c5d7e96790c4812c825b386761e01d48a7", "message": "Add PersistableNetworkPayloadStore", "committedDate": "2020-10-01T19:55:01Z", "type": "commit"}, {"oid": "240f0b903c81c559f55fa186badf107fb5c05a97", "url": "https://github.com/bisq-network/bisq/commit/240f0b903c81c559f55fa186badf107fb5c05a97", "message": "Use PersistableNetworkPayloadStore as base class for stores which had a map with PersistableNetworkPayloads", "committedDate": "2020-10-01T19:57:48Z", "type": "commit"}, {"oid": "431debe05e757f2e5da0294462f521aa897a749e", "url": "https://github.com/bisq-network/bisq/commit/431debe05e757f2e5da0294462f521aa897a749e", "message": "Unrelated to PR topic fix: Only log warnings if banned object is not isEmpty", "committedDate": "2020-10-01T19:59:27Z", "type": "commit"}, {"oid": "b90fd3968d3e21da912cdc7743fc607053fa806f", "url": "https://github.com/bisq-network/bisq/commit/b90fd3968d3e21da912cdc7743fc607053fa806f", "message": "Unrelated to PR topic: Improve logs for windows: \\n is not recognized and reading logs from windows users makes it harder without line breaks.", "committedDate": "2020-10-01T20:00:32Z", "type": "commit"}, {"oid": "7122ef0356add96a11c533880f76ee6f248d329d", "url": "https://github.com/bisq-network/bisq/commit/7122ef0356add96a11c533880f76ee6f248d329d", "message": "Refactoring: Rename variables", "committedDate": "2020-10-01T20:01:33Z", "type": "commit"}, {"oid": "df90b2440ad525191e865258cd6603fbc88db92f", "url": "https://github.com/bisq-network/bisq/commit/df90b2440ad525191e865258cd6603fbc88db92f", "message": "Add new methods and refactor APIs. Needed later for new classes....", "committedDate": "2020-10-01T20:02:44Z", "type": "commit"}, {"oid": "9446f2807d0d55297e0f60e5909d2a3447ec9154", "url": "https://github.com/bisq-network/bisq/commit/9446f2807d0d55297e0f60e5909d2a3447ec9154", "message": "Split read store and get store so it can be reused from new class (future commit)\nChange API", "committedDate": "2020-10-01T20:04:08Z", "type": "commit"}, {"oid": "384152fb6be8917c92dc825030b7355063964f18", "url": "https://github.com/bisq-network/bisq/commit/384152fb6be8917c92dc825030b7355063964f18", "message": "Add version field to data requests classes", "committedDate": "2020-10-01T20:05:31Z", "type": "commit"}, {"oid": "c79504c8410db24cef4912f9eb7212c5987e86a4", "url": "https://github.com/bisq-network/bisq/commit/c79504c8410db24cef4912f9eb7212c5987e86a4", "message": "Add getter (needed later)", "committedDate": "2020-10-01T20:05:46Z", "type": "commit"}, {"oid": "3fb73ac0a3e8722c7d215f56dde32f6a12b04944", "url": "https://github.com/bisq-network/bisq/commit/3fb73ac0a3e8722c7d215f56dde32f6a12b04944", "message": "Add HistoricalDataStoreService", "committedDate": "2020-10-01T20:06:04Z", "type": "commit"}, {"oid": "3df2f7e177edcafb437ee10ffcd84c7a5152edd6", "url": "https://github.com/bisq-network/bisq/commit/3df2f7e177edcafb437ee10ffcd84c7a5152edd6", "message": "Add HISTORY field. Make isNewVersion public", "committedDate": "2020-10-01T20:06:34Z", "type": "commit"}, {"oid": "e44fdbdea247bb30143c22904e2cdabafdef4be7", "url": "https://github.com/bisq-network/bisq/commit/e44fdbdea247bb30143c22904e2cdabafdef4be7", "message": "Refactoring: Rename variable", "committedDate": "2020-10-01T20:06:57Z", "type": "commit"}, {"oid": "62836d79f5e6b15c14546069106abaf57e813abf", "url": "https://github.com/bisq-network/bisq/commit/62836d79f5e6b15c14546069106abaf57e813abf", "message": "Add support for HistoricalDataStoreService", "committedDate": "2020-10-01T20:08:43Z", "type": "commit"}, {"oid": "58efb62b84b25e000c5a54383f105b9f518b72a3", "url": "https://github.com/bisq-network/bisq/commit/58efb62b84b25e000c5a54383f105b9f518b72a3", "message": "Refactoring: Rearrange method (moved method)", "committedDate": "2020-10-01T20:12:15Z", "type": "commit"}, {"oid": "65de106df057ecd17689099c13392b044a1c2a8a", "url": "https://github.com/bisq-network/bisq/commit/65de106df057ecd17689099c13392b044a1c2a8a", "message": "Use HistoricalDataStoreService for TradeStatistics2StorageService", "committedDate": "2020-10-01T20:13:11Z", "type": "commit"}, {"oid": "8ea6da01da1623c67b863df1f32e8881d377e56d", "url": "https://github.com/bisq-network/bisq/commit/8ea6da01da1623c67b863df1f32e8881d377e56d", "message": "Apply changes to test classes", "committedDate": "2020-10-01T20:13:31Z", "type": "commit"}, {"oid": "6f5bfde92fd2904dda9566bb2f73a97263c10327", "url": "https://github.com/bisq-network/bisq/commit/6f5bfde92fd2904dda9566bb2f73a97263c10327", "message": "Deactivate usage of HistoricalDataStoreService for now.\n\nThis is intended to be able to merge the code base before https://github.com/bisq-network/bisq/pull/4577 is merged.\nWe can add the code base but not using the feature yet. Once we are ready for deployment we can revert this commit and have the feature activated.", "committedDate": "2020-10-01T20:20:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUxNTgxNA==", "url": "https://github.com/bisq-network/bisq/pull/4586#discussion_r498515814", "bodyText": "log.info(\"No resource file has been copied. {} exists already.\", fileName);\nOR\nlog.info(\"No resource file was copied. {} exists already.\", fileName);\n(grammar)", "author": "ghubstan", "createdAt": "2020-10-01T21:12:19Z", "path": "p2p/src/main/java/bisq/network/p2p/storage/persistence/StoreService.java", "diffHunk": "@@ -116,21 +116,25 @@ protected void makeFileFromResourceFile(String postFix) {\n                 e.printStackTrace();\n             }\n         } else {\n-            log.debug(fileName + \" file exists already.\");\n+            log.info(\"No resource file have been copied. {} exists already.\", fileName);", "originalCommit": "9446f2807d0d55297e0f60e5909d2a3447ec9154", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUyMzkzMA==", "url": "https://github.com/bisq-network/bisq/pull/4586#discussion_r498523930", "bodyText": "Will fix.", "author": "chimp1984", "createdAt": "2020-10-01T21:32:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUxNTgxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUyMTI3Ng==", "url": "https://github.com/bisq-network/bisq/pull/4586#discussion_r498521276", "bodyText": "Needs license info comment?", "author": "ghubstan", "createdAt": "2020-10-01T21:25:58Z", "path": "p2p/src/main/java/bisq/network/p2p/storage/persistence/HistoricalDataStoreService.java", "diffHunk": "@@ -0,0 +1,187 @@\n+package bisq.network.p2p.storage.persistence;", "originalCommit": "3fb73ac0a3e8722c7d215f56dde32f6a12b04944", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUyNTEzMg==", "url": "https://github.com/bisq-network/bisq/pull/4586#discussion_r498525132", "bodyText": "will add", "author": "chimp1984", "createdAt": "2020-10-01T21:35:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUyMTI3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUyMTMzMA==", "url": "https://github.com/bisq-network/bisq/pull/4586#discussion_r498521330", "bodyText": "Needs license info comment?", "author": "ghubstan", "createdAt": "2020-10-01T21:26:05Z", "path": "p2p/src/main/java/bisq/network/p2p/storage/persistence/PersistableNetworkPayloadStore.java", "diffHunk": "@@ -0,0 +1,20 @@\n+package bisq.network.p2p.storage.persistence;", "originalCommit": "2e50e4c5d7e96790c4812c825b386761e01d48a7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUyNTMzNg==", "url": "https://github.com/bisq-network/bisq/pull/4586#discussion_r498525336", "bodyText": "will add", "author": "chimp1984", "createdAt": "2020-10-01T21:36:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUyMTMzMA=="}], "type": "inlineReview"}, {"oid": "a1debd807087f47152c4f7588dbba459cbd15eb9", "url": "https://github.com/bisq-network/bisq/commit/a1debd807087f47152c4f7588dbba459cbd15eb9", "message": "Fix grammar", "committedDate": "2020-10-01T21:33:21Z", "type": "commit"}, {"oid": "5027c861e3558014cfea5ed28e93c6de1d375e01", "url": "https://github.com/bisq-network/bisq/commit/5027c861e3558014cfea5ed28e93c6de1d375e01", "message": "Fix proto field index", "committedDate": "2020-10-01T21:33:33Z", "type": "commit"}, {"oid": "3ee60d5cdcf71ff893709de305f64c67e967aee4", "url": "https://github.com/bisq-network/bisq/commit/3ee60d5cdcf71ff893709de305f64c67e967aee4", "message": "Add license", "committedDate": "2020-10-01T21:35:41Z", "type": "commit"}, {"oid": "c308791321827a2cebc19b04e5582d0197a887f9", "url": "https://github.com/bisq-network/bisq/commit/c308791321827a2cebc19b04e5582d0197a887f9", "message": "Add license", "committedDate": "2020-10-01T21:36:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODcxNzcxNA==", "url": "https://github.com/bisq-network/bisq/pull/4586#discussion_r498717714", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                // Otherwise we only add data if the requesters version is older then\n          \n          \n            \n                                // Otherwise we only add data if the requesters version is older than", "author": "sqrrm", "createdAt": "2020-10-02T09:35:33Z", "path": "p2p/src/main/java/bisq/network/p2p/storage/persistence/HistoricalDataStoreService.java", "diffHunk": "@@ -0,0 +1,187 @@\n+package bisq.network.p2p.storage.persistence;\n+\n+import bisq.network.p2p.storage.P2PDataStorage;\n+import bisq.network.p2p.storage.payload.PersistableNetworkPayload;\n+\n+import bisq.common.app.Version;\n+import bisq.common.storage.Storage;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+import java.io.File;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Manages historical data stores tagged with the release versions.\n+ * New data is added to the default map in the store (live data). Historical data is created from resource files.\n+ * For initial data requests we only use the live data as the users version is sent with the\n+ * request so the responding (seed)node can figure out if we miss any of the historical data.\n+ */\n+@Slf4j\n+public abstract class HistoricalDataStoreService<T extends PersistableNetworkPayloadStore> extends MapStoreService<T, PersistableNetworkPayload> {\n+    private ImmutableMap<String, PersistableNetworkPayloadStore> storesByVersion;\n+    // Cache to avoid that we have to recreate the historical data at each request\n+    private ImmutableMap<P2PDataStorage.ByteArray, PersistableNetworkPayload> allHistoricalPayloads;\n+\n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // Constructor\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    public HistoricalDataStoreService(File storageDir, Storage<T> storage) {\n+        super(storageDir, storage);\n+    }\n+\n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // API\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    // We give back a map of our live map and all historical maps newer than the requested version.\n+    // If requestersVersion is null we return all historical data.\n+    public Map<P2PDataStorage.ByteArray, PersistableNetworkPayload> getMapSinceVersion(String requestersVersion) {\n+        // We add all our live data\n+        Map<P2PDataStorage.ByteArray, PersistableNetworkPayload> result = new HashMap<>(store.getMap());\n+\n+        // If we have a store with a newer version than the requesters version we will add those as well.\n+        storesByVersion.entrySet().stream()\n+                .filter(entry -> {\n+                    // Old nodes not sending the version will get delivered all data\n+                    if (requestersVersion == null) {\n+                        log.info(\"The requester did not send a version. This is expected for not updated nodes.\");\n+                        return true;\n+                    }\n+\n+                    // Otherwise we only add data if the requesters version is older then", "originalCommit": "3fb73ac0a3e8722c7d215f56dde32f6a12b04944", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODcxODU4Mw==", "url": "https://github.com/bisq-network/bisq/pull/4586#discussion_r498718583", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        \"As the requester version is not older as our historical store we do not \" +\n          \n          \n            \n                                        \"As the requester version is not older than our historical store we do not \" +", "author": "sqrrm", "createdAt": "2020-10-02T09:37:31Z", "path": "p2p/src/main/java/bisq/network/p2p/storage/persistence/HistoricalDataStoreService.java", "diffHunk": "@@ -0,0 +1,187 @@\n+package bisq.network.p2p.storage.persistence;\n+\n+import bisq.network.p2p.storage.P2PDataStorage;\n+import bisq.network.p2p.storage.payload.PersistableNetworkPayload;\n+\n+import bisq.common.app.Version;\n+import bisq.common.storage.Storage;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+import java.io.File;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Manages historical data stores tagged with the release versions.\n+ * New data is added to the default map in the store (live data). Historical data is created from resource files.\n+ * For initial data requests we only use the live data as the users version is sent with the\n+ * request so the responding (seed)node can figure out if we miss any of the historical data.\n+ */\n+@Slf4j\n+public abstract class HistoricalDataStoreService<T extends PersistableNetworkPayloadStore> extends MapStoreService<T, PersistableNetworkPayload> {\n+    private ImmutableMap<String, PersistableNetworkPayloadStore> storesByVersion;\n+    // Cache to avoid that we have to recreate the historical data at each request\n+    private ImmutableMap<P2PDataStorage.ByteArray, PersistableNetworkPayload> allHistoricalPayloads;\n+\n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // Constructor\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    public HistoricalDataStoreService(File storageDir, Storage<T> storage) {\n+        super(storageDir, storage);\n+    }\n+\n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // API\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    // We give back a map of our live map and all historical maps newer than the requested version.\n+    // If requestersVersion is null we return all historical data.\n+    public Map<P2PDataStorage.ByteArray, PersistableNetworkPayload> getMapSinceVersion(String requestersVersion) {\n+        // We add all our live data\n+        Map<P2PDataStorage.ByteArray, PersistableNetworkPayload> result = new HashMap<>(store.getMap());\n+\n+        // If we have a store with a newer version than the requesters version we will add those as well.\n+        storesByVersion.entrySet().stream()\n+                .filter(entry -> {\n+                    // Old nodes not sending the version will get delivered all data\n+                    if (requestersVersion == null) {\n+                        log.info(\"The requester did not send a version. This is expected for not updated nodes.\");\n+                        return true;\n+                    }\n+\n+                    // Otherwise we only add data if the requesters version is older then\n+                    // the version of the particular store.\n+                    String storeVersion = entry.getKey();\n+                    boolean newVersion = Version.isNewVersion(storeVersion, requestersVersion);\n+                    String details = newVersion ?\n+                            \"As our historical store is a newer version we add the data to our result map.\" :\n+                            \"As the requester version is not older as our historical store we do not \" +", "originalCommit": "3fb73ac0a3e8722c7d215f56dde32f6a12b04944", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODcyNjQzNA==", "url": "https://github.com/bisq-network/bisq/pull/4586#discussion_r498726434", "bodyText": "I don't understand why this is done. First there is a check if the key exists in any map, then if if doesn't we add it and return what was there. Nothing should be there since we checked nothing was there.\nOnly thing I can think of is some handling some concurrency issue. I think a comment would be helpful here.", "author": "sqrrm", "createdAt": "2020-10-02T09:54:15Z", "path": "p2p/src/main/java/bisq/network/p2p/storage/persistence/HistoricalDataStoreService.java", "diffHunk": "@@ -0,0 +1,187 @@\n+package bisq.network.p2p.storage.persistence;\n+\n+import bisq.network.p2p.storage.P2PDataStorage;\n+import bisq.network.p2p.storage.payload.PersistableNetworkPayload;\n+\n+import bisq.common.app.Version;\n+import bisq.common.storage.Storage;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+import java.io.File;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Manages historical data stores tagged with the release versions.\n+ * New data is added to the default map in the store (live data). Historical data is created from resource files.\n+ * For initial data requests we only use the live data as the users version is sent with the\n+ * request so the responding (seed)node can figure out if we miss any of the historical data.\n+ */\n+@Slf4j\n+public abstract class HistoricalDataStoreService<T extends PersistableNetworkPayloadStore> extends MapStoreService<T, PersistableNetworkPayload> {\n+    private ImmutableMap<String, PersistableNetworkPayloadStore> storesByVersion;\n+    // Cache to avoid that we have to recreate the historical data at each request\n+    private ImmutableMap<P2PDataStorage.ByteArray, PersistableNetworkPayload> allHistoricalPayloads;\n+\n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // Constructor\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    public HistoricalDataStoreService(File storageDir, Storage<T> storage) {\n+        super(storageDir, storage);\n+    }\n+\n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // API\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    // We give back a map of our live map and all historical maps newer than the requested version.\n+    // If requestersVersion is null we return all historical data.\n+    public Map<P2PDataStorage.ByteArray, PersistableNetworkPayload> getMapSinceVersion(String requestersVersion) {\n+        // We add all our live data\n+        Map<P2PDataStorage.ByteArray, PersistableNetworkPayload> result = new HashMap<>(store.getMap());\n+\n+        // If we have a store with a newer version than the requesters version we will add those as well.\n+        storesByVersion.entrySet().stream()\n+                .filter(entry -> {\n+                    // Old nodes not sending the version will get delivered all data\n+                    if (requestersVersion == null) {\n+                        log.info(\"The requester did not send a version. This is expected for not updated nodes.\");\n+                        return true;\n+                    }\n+\n+                    // Otherwise we only add data if the requesters version is older then\n+                    // the version of the particular store.\n+                    String storeVersion = entry.getKey();\n+                    boolean newVersion = Version.isNewVersion(storeVersion, requestersVersion);\n+                    String details = newVersion ?\n+                            \"As our historical store is a newer version we add the data to our result map.\" :\n+                            \"As the requester version is not older as our historical store we do not \" +\n+                                    \"add the data to the result map.\";\n+                    log.info(\"The requester had version {}. Our historical data store has version {}.\\n{}\",\n+                            requestersVersion, storeVersion, details);\n+                    return newVersion;\n+                })\n+                .map(e -> e.getValue().getMap())\n+                .forEach(result::putAll);\n+\n+        log.info(\"We found {} entries since requesters version {}\",\n+                result.size(), requestersVersion);\n+        return result;\n+    }\n+\n+    public Map<P2PDataStorage.ByteArray, PersistableNetworkPayload> getMapOfLiveData() {\n+        return store.getMap();\n+    }\n+\n+    public Map<P2PDataStorage.ByteArray, PersistableNetworkPayload> getMapOfAllData() {\n+        Map<P2PDataStorage.ByteArray, PersistableNetworkPayload> result = new HashMap<>(getMapOfLiveData());\n+        result.putAll(allHistoricalPayloads);\n+        return result;\n+    }\n+\n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // MapStoreService\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    // TODO optimize so that callers to AppendOnlyDataStoreService are not invoking that often getMap\n+    // ProposalService is one of the main callers and could avoid it by using the ProposalStoreService directly\n+    // instead of AppendOnlyDataStoreService\n+\n+    // By default we return the live data only. This method should not be used by domain clients but rather the\n+    // custom methods getMapOfAllData, getMapOfLiveData or getMapSinceVersion\n+    @Override\n+    public Map<P2PDataStorage.ByteArray, PersistableNetworkPayload> getMap() {\n+        return store.getMap();\n+    }\n+\n+    @Override\n+    protected void put(P2PDataStorage.ByteArray hash, PersistableNetworkPayload payload) {\n+        if (anyMapContainsKey(hash)) {\n+            return;\n+        }\n+\n+        getMapOfLiveData().put(hash, payload);\n+        persist();\n+    }\n+\n+    @Override\n+    protected PersistableNetworkPayload putIfAbsent(P2PDataStorage.ByteArray hash, PersistableNetworkPayload payload) {\n+        if (anyMapContainsKey(hash)) {\n+            return null;\n+        }\n+\n+        PersistableNetworkPayload previous = getMapOfLiveData().put(hash, payload);", "originalCommit": "3fb73ac0a3e8722c7d215f56dde32f6a12b04944", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk3OTgwOQ==", "url": "https://github.com/bisq-network/bisq/pull/4586#discussion_r498979809", "bodyText": "Yes it will be always null, but we override the method signature from MapStoreService and follow the putIfAbsent signature from Map. In our special case it wil be always null. I can change it to make it more clear and add a comment.", "author": "chimp1984", "createdAt": "2020-10-02T18:19:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODcyNjQzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODczMDc4MA==", "url": "https://github.com/bisq-network/bisq/pull/4586#discussion_r498730780", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    int preLive = getMapOfLiveData().keySet().size();\n          \n          \n            \n                    int preLive = getMapOfLiveData().size();", "author": "sqrrm", "createdAt": "2020-10-02T10:03:57Z", "path": "p2p/src/main/java/bisq/network/p2p/storage/persistence/HistoricalDataStoreService.java", "diffHunk": "@@ -0,0 +1,187 @@\n+package bisq.network.p2p.storage.persistence;\n+\n+import bisq.network.p2p.storage.P2PDataStorage;\n+import bisq.network.p2p.storage.payload.PersistableNetworkPayload;\n+\n+import bisq.common.app.Version;\n+import bisq.common.storage.Storage;\n+\n+import com.google.common.collect.ImmutableMap;\n+\n+import java.io.File;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import lombok.extern.slf4j.Slf4j;\n+\n+/**\n+ * Manages historical data stores tagged with the release versions.\n+ * New data is added to the default map in the store (live data). Historical data is created from resource files.\n+ * For initial data requests we only use the live data as the users version is sent with the\n+ * request so the responding (seed)node can figure out if we miss any of the historical data.\n+ */\n+@Slf4j\n+public abstract class HistoricalDataStoreService<T extends PersistableNetworkPayloadStore> extends MapStoreService<T, PersistableNetworkPayload> {\n+    private ImmutableMap<String, PersistableNetworkPayloadStore> storesByVersion;\n+    // Cache to avoid that we have to recreate the historical data at each request\n+    private ImmutableMap<P2PDataStorage.ByteArray, PersistableNetworkPayload> allHistoricalPayloads;\n+\n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // Constructor\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    public HistoricalDataStoreService(File storageDir, Storage<T> storage) {\n+        super(storageDir, storage);\n+    }\n+\n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // API\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    // We give back a map of our live map and all historical maps newer than the requested version.\n+    // If requestersVersion is null we return all historical data.\n+    public Map<P2PDataStorage.ByteArray, PersistableNetworkPayload> getMapSinceVersion(String requestersVersion) {\n+        // We add all our live data\n+        Map<P2PDataStorage.ByteArray, PersistableNetworkPayload> result = new HashMap<>(store.getMap());\n+\n+        // If we have a store with a newer version than the requesters version we will add those as well.\n+        storesByVersion.entrySet().stream()\n+                .filter(entry -> {\n+                    // Old nodes not sending the version will get delivered all data\n+                    if (requestersVersion == null) {\n+                        log.info(\"The requester did not send a version. This is expected for not updated nodes.\");\n+                        return true;\n+                    }\n+\n+                    // Otherwise we only add data if the requesters version is older then\n+                    // the version of the particular store.\n+                    String storeVersion = entry.getKey();\n+                    boolean newVersion = Version.isNewVersion(storeVersion, requestersVersion);\n+                    String details = newVersion ?\n+                            \"As our historical store is a newer version we add the data to our result map.\" :\n+                            \"As the requester version is not older as our historical store we do not \" +\n+                                    \"add the data to the result map.\";\n+                    log.info(\"The requester had version {}. Our historical data store has version {}.\\n{}\",\n+                            requestersVersion, storeVersion, details);\n+                    return newVersion;\n+                })\n+                .map(e -> e.getValue().getMap())\n+                .forEach(result::putAll);\n+\n+        log.info(\"We found {} entries since requesters version {}\",\n+                result.size(), requestersVersion);\n+        return result;\n+    }\n+\n+    public Map<P2PDataStorage.ByteArray, PersistableNetworkPayload> getMapOfLiveData() {\n+        return store.getMap();\n+    }\n+\n+    public Map<P2PDataStorage.ByteArray, PersistableNetworkPayload> getMapOfAllData() {\n+        Map<P2PDataStorage.ByteArray, PersistableNetworkPayload> result = new HashMap<>(getMapOfLiveData());\n+        result.putAll(allHistoricalPayloads);\n+        return result;\n+    }\n+\n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // MapStoreService\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    // TODO optimize so that callers to AppendOnlyDataStoreService are not invoking that often getMap\n+    // ProposalService is one of the main callers and could avoid it by using the ProposalStoreService directly\n+    // instead of AppendOnlyDataStoreService\n+\n+    // By default we return the live data only. This method should not be used by domain clients but rather the\n+    // custom methods getMapOfAllData, getMapOfLiveData or getMapSinceVersion\n+    @Override\n+    public Map<P2PDataStorage.ByteArray, PersistableNetworkPayload> getMap() {\n+        return store.getMap();\n+    }\n+\n+    @Override\n+    protected void put(P2PDataStorage.ByteArray hash, PersistableNetworkPayload payload) {\n+        if (anyMapContainsKey(hash)) {\n+            return;\n+        }\n+\n+        getMapOfLiveData().put(hash, payload);\n+        persist();\n+    }\n+\n+    @Override\n+    protected PersistableNetworkPayload putIfAbsent(P2PDataStorage.ByteArray hash, PersistableNetworkPayload payload) {\n+        if (anyMapContainsKey(hash)) {\n+            return null;\n+        }\n+\n+        PersistableNetworkPayload previous = getMapOfLiveData().put(hash, payload);\n+        persist();\n+        return previous;\n+    }\n+\n+\n+    @Override\n+    protected void readFromResources(String postFix) {\n+        readStore();\n+        log.info(\"We have created the {} store for the live data and filled it with {} entries from the persisted data.\",\n+                getFileName(), getMapOfLiveData().size());\n+\n+        // Now we add our historical data stores. As they are immutable after created we use an ImmutableMap\n+        ImmutableMap.Builder<P2PDataStorage.ByteArray, PersistableNetworkPayload> allHistoricalPayloadsBuilder = ImmutableMap.builder();\n+        ImmutableMap.Builder<String, PersistableNetworkPayloadStore> storesByVersionBuilder = ImmutableMap.builder();\n+\n+        Version.HISTORY.forEach(version -> readHistoricalStoreFromResources(version, postFix, allHistoricalPayloadsBuilder, storesByVersionBuilder));\n+\n+        allHistoricalPayloads = allHistoricalPayloadsBuilder.build();\n+        storesByVersion = storesByVersionBuilder.build();\n+    }\n+\n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // Private\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    private void readHistoricalStoreFromResources(String version,\n+                                                  String postFix,\n+                                                  ImmutableMap.Builder<P2PDataStorage.ByteArray, PersistableNetworkPayload> allHistoricalDataBuilder,\n+                                                  ImmutableMap.Builder<String, PersistableNetworkPayloadStore> storesByVersionBuilder) {\n+        String fileName = getFileName() + \"_\" + version;\n+        boolean wasCreatedFromResources = makeFileFromResourceFile(fileName, postFix);\n+\n+        // If resource file does not exist we return null. We do not create a new store as it would never get filled.\n+        PersistableNetworkPayloadStore historicalStore = storage.getPersisted(fileName);\n+        if (historicalStore == null) {\n+            log.warn(\"Resource file with file name {} does not exits.\", fileName);\n+            return;\n+        }\n+\n+        storesByVersionBuilder.put(version, historicalStore);\n+        allHistoricalDataBuilder.putAll(historicalStore.getMap());\n+\n+        if (wasCreatedFromResources) {\n+            pruneStore(historicalStore, version);\n+        }\n+    }\n+\n+    private void pruneStore(PersistableNetworkPayloadStore historicalStore, String version) {\n+        int preLive = getMapOfLiveData().keySet().size();", "originalCommit": "3fb73ac0a3e8722c7d215f56dde32f6a12b04944", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODczNDY0Mw==", "url": "https://github.com/bisq-network/bisq/pull/4586#discussion_r498734643", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    map.putAll(serviceMap);\n          \n          \n            \n                                } else {\n          \n          \n            \n                                    serviceMap = service.getMap();\n          \n          \n            \n                                    map.putAll(serviceMap);\n          \n          \n            \n                                }\n          \n          \n            \n                                } else {\n          \n          \n            \n                                    serviceMap = service.getMap();\n          \n          \n            \n                                }\n          \n          \n            \n                                map.putAll(serviceMap);", "author": "sqrrm", "createdAt": "2020-10-02T10:12:44Z", "path": "p2p/src/main/java/bisq/network/p2p/storage/P2PDataStorage.java", "diffHunk": "@@ -293,6 +300,57 @@ public GetDataResponse buildGetDataResponse(\n                 getDataRequest instanceof GetUpdatedDataRequest);\n     }\n \n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // Utils for collecting the exclude hashes\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    private Map<ByteArray, PersistableNetworkPayload> getMapForDataRequest() {\n+        Map<ByteArray, PersistableNetworkPayload> map = new HashMap<>();\n+        appendOnlyDataStoreService.getServices()\n+                .forEach(service -> {\n+                    Map<ByteArray, PersistableNetworkPayload> serviceMap;\n+                    if (service instanceof HistoricalDataStoreService) {\n+                        var historicalDataStoreService = (HistoricalDataStoreService<? extends PersistableNetworkPayloadStore>) service;\n+                        // As we add the version to our request we only use the live data. Eventually missing data will be\n+                        // derived from the version.\n+                        serviceMap = historicalDataStoreService.getMapOfLiveData();\n+                        map.putAll(serviceMap);\n+                    } else {\n+                        serviceMap = service.getMap();\n+                        map.putAll(serviceMap);\n+                    }", "originalCommit": "62836d79f5e6b15c14546069106abaf57e813abf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODczNTAzNA==", "url": "https://github.com/bisq-network/bisq/pull/4586#discussion_r498735034", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    map.putAll(serviceMap);\n          \n          \n            \n                                } else {\n          \n          \n            \n                                    serviceMap = service.getMap();\n          \n          \n            \n                                    map.putAll(serviceMap);\n          \n          \n            \n                                }\n          \n          \n            \n                                } else {\n          \n          \n            \n                                    serviceMap = service.getMap();\n          \n          \n            \n                                }\n          \n          \n            \n                                map.putAll(serviceMap);", "author": "sqrrm", "createdAt": "2020-10-02T10:13:33Z", "path": "p2p/src/main/java/bisq/network/p2p/storage/P2PDataStorage.java", "diffHunk": "@@ -293,6 +300,57 @@ public GetDataResponse buildGetDataResponse(\n                 getDataRequest instanceof GetUpdatedDataRequest);\n     }\n \n+\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+    // Utils for collecting the exclude hashes\n+    ///////////////////////////////////////////////////////////////////////////////////////////\n+\n+    private Map<ByteArray, PersistableNetworkPayload> getMapForDataRequest() {\n+        Map<ByteArray, PersistableNetworkPayload> map = new HashMap<>();\n+        appendOnlyDataStoreService.getServices()\n+                .forEach(service -> {\n+                    Map<ByteArray, PersistableNetworkPayload> serviceMap;\n+                    if (service instanceof HistoricalDataStoreService) {\n+                        var historicalDataStoreService = (HistoricalDataStoreService<? extends PersistableNetworkPayloadStore>) service;\n+                        // As we add the version to our request we only use the live data. Eventually missing data will be\n+                        // derived from the version.\n+                        serviceMap = historicalDataStoreService.getMapOfLiveData();\n+                        map.putAll(serviceMap);\n+                    } else {\n+                        serviceMap = service.getMap();\n+                        map.putAll(serviceMap);\n+                    }\n+                    log.info(\"We added {} entries from {} to the excluded key set of our request\",\n+                            serviceMap.size(), service.getClass().getSimpleName());\n+                });\n+        return map;\n+    }\n+\n+    private Map<ByteArray, PersistableNetworkPayload> getMapForDataResponse(String requestersVersion) {\n+        Map<ByteArray, PersistableNetworkPayload> map = new HashMap<>();\n+        appendOnlyDataStoreService.getServices()\n+                .forEach(service -> {\n+                    Map<ByteArray, PersistableNetworkPayload> serviceMap;\n+                    if (service instanceof HistoricalDataStoreService) {\n+                        var historicalDataStoreService = (HistoricalDataStoreService<? extends PersistableNetworkPayloadStore>) service;\n+                        serviceMap = historicalDataStoreService.getMapSinceVersion(requestersVersion);\n+                        map.putAll(serviceMap);\n+                    } else {\n+                        serviceMap = service.getMap();\n+                        map.putAll(serviceMap);\n+                    }", "originalCommit": "62836d79f5e6b15c14546069106abaf57e813abf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "25a7979b027415502debcb32e7a1cc88cce87fef", "url": "https://github.com/bisq-network/bisq/commit/25a7979b027415502debcb32e7a1cc88cce87fef", "message": "Merge branch 'master_upstream' into reduce-initial-date-request", "committedDate": "2020-10-02T18:05:56Z", "type": "commit"}, {"oid": "ef7f5a7f635445519b8ef85fcd5de7a0efc73738", "url": "https://github.com/bisq-network/bisq/commit/ef7f5a7f635445519b8ef85fcd5de7a0efc73738", "message": "Revert nonce index at PreliminaryGetDataRequest protobuf entry to 21 as it was the version used in master as well. We cannot change that without breaking compatibility.", "committedDate": "2020-10-02T18:13:45Z", "type": "commit"}, {"oid": "d3384e66e5f92fffb50218503d27357884239417", "url": "https://github.com/bisq-network/bisq/commit/d3384e66e5f92fffb50218503d27357884239417", "message": "Update p2p/src/main/java/bisq/network/p2p/storage/persistence/HistoricalDataStoreService.java\n\nCo-authored-by: sqrrm <sqrrm@users.noreply.github.com>", "committedDate": "2020-10-02T18:15:51Z", "type": "commit"}, {"oid": "9d517140b28606cc212052521e26c6f5753fc249", "url": "https://github.com/bisq-network/bisq/commit/9d517140b28606cc212052521e26c6f5753fc249", "message": "Update p2p/src/main/java/bisq/network/p2p/storage/persistence/HistoricalDataStoreService.java\n\nCo-authored-by: sqrrm <sqrrm@users.noreply.github.com>", "committedDate": "2020-10-02T18:16:04Z", "type": "commit"}, {"oid": "35d13fb018f0652d184b387b6eab32b1076f87ba", "url": "https://github.com/bisq-network/bisq/commit/35d13fb018f0652d184b387b6eab32b1076f87ba", "message": "Make putIfAbsent method more clear", "committedDate": "2020-10-02T18:22:25Z", "type": "commit"}, {"oid": "611bcef46111fba823c5226aebed97bb0216ec52", "url": "https://github.com/bisq-network/bisq/commit/611bcef46111fba823c5226aebed97bb0216ec52", "message": "Update p2p/src/main/java/bisq/network/p2p/storage/persistence/HistoricalDataStoreService.java\n\nCo-authored-by: sqrrm <sqrrm@users.noreply.github.com>", "committedDate": "2020-10-02T18:23:12Z", "type": "commit"}, {"oid": "e9c57b1a4b4ac34c203f8860f23269dd138da835", "url": "https://github.com/bisq-network/bisq/commit/e9c57b1a4b4ac34c203f8860f23269dd138da835", "message": "Update p2p/src/main/java/bisq/network/p2p/storage/P2PDataStorage.java\n\nCo-authored-by: sqrrm <sqrrm@users.noreply.github.com>", "committedDate": "2020-10-02T18:25:51Z", "type": "commit"}, {"oid": "308aa162e8e652502843308a75a37a08d1c8cc6d", "url": "https://github.com/bisq-network/bisq/commit/308aa162e8e652502843308a75a37a08d1c8cc6d", "message": "Update p2p/src/main/java/bisq/network/p2p/storage/P2PDataStorage.java\n\nCo-authored-by: sqrrm <sqrrm@users.noreply.github.com>", "committedDate": "2020-10-02T18:26:11Z", "type": "commit"}, {"oid": "807b9fc5be2c6ed852534f35fec86c3e3a7c18c0", "url": "https://github.com/bisq-network/bisq/commit/807b9fc5be2c6ed852534f35fec86c3e3a7c18c0", "message": "Remove unused method, fix typo, remove unneeded annotations", "committedDate": "2020-10-02T18:29:35Z", "type": "commit"}]}