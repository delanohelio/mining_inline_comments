{"pr_number": 254, "pr_title": "HTTP API changes to support recording options", "pr_createdAt": "2020-08-27T15:27:54Z", "pr_url": "https://github.com/cryostatio/cryostat/pull/254", "timeline": [{"oid": "2ef43c60b717b248056e89d1707ff305c0bf7beb", "url": "https://github.com/cryostatio/cryostat/commit/2ef43c60b717b248056e89d1707ff305c0bf7beb", "message": "Create RecordingOptionsPutHandler, not fully functional", "committedDate": "2020-09-03T18:18:23Z", "type": "commit"}, {"oid": "b71cf20a44e2ed32b61aca84c16fe883fb422bea", "url": "https://github.com/cryostatio/cryostat/commit/b71cf20a44e2ed32b61aca84c16fe883fb422bea", "message": "Initial changes to TargetRecordingsPostHandler.java", "committedDate": "2020-09-03T18:18:23Z", "type": "commit"}, {"oid": "929f5033963fd7fe1d289b9a16c65e25f241352b", "url": "https://github.com/cryostatio/cryostat/commit/929f5033963fd7fe1d289b9a16c65e25f241352b", "message": "Create TargetRecordingPostHandler", "committedDate": "2020-09-03T18:18:23Z", "type": "commit"}, {"oid": "6a2050f36f8498826887a3da37f1da7ec5d0291b", "url": "https://github.com/cryostatio/cryostat/commit/6a2050f36f8498826887a3da37f1da7ec5d0291b", "message": "Add new handlers to RequestHandlerModule", "committedDate": "2020-09-03T18:25:01Z", "type": "commit"}, {"oid": "72e2a28f0f0fbb15ced8e6c3b553081a94993820", "url": "https://github.com/cryostatio/cryostat/commit/72e2a28f0f0fbb15ced8e6c3b553081a94993820", "message": "Fix formatting", "committedDate": "2020-09-03T18:25:01Z", "type": "commit"}, {"oid": "af2465875d8efd3323e75dd64d0d6b83e50317ad", "url": "https://github.com/cryostatio/cryostat/commit/af2465875d8efd3323e75dd64d0d6b83e50317ad", "message": "Create unit tests for recordingOptionsGetHandler (still needs more tests)", "committedDate": "2020-09-03T18:25:01Z", "type": "commit"}, {"oid": "1f11f3c8f618e82cc6fb39a48032d50da47ed56b", "url": "https://github.com/cryostatio/cryostat/commit/1f11f3c8f618e82cc6fb39a48032d50da47ed56b", "message": "Add more tests for RecordingOptionsGetHandler", "committedDate": "2020-09-03T18:25:01Z", "type": "commit"}, {"oid": "fe17350f18da75b4b494f606b75ef2cf495fbfc8", "url": "https://github.com/cryostatio/cryostat/commit/fe17350f18da75b4b494f606b75ef2cf495fbfc8", "message": "Add unit tests for RecordingOptionsPutHandler", "committedDate": "2020-09-03T18:25:01Z", "type": "commit"}, {"oid": "988f15b5eceb6c59b5236e1447c6afde532b6636", "url": "https://github.com/cryostatio/cryostat/commit/988f15b5eceb6c59b5236e1447c6afde532b6636", "message": "Initial changes to TargetRecordingsPostHadlerTest", "committedDate": "2020-09-03T18:25:01Z", "type": "commit"}, {"oid": "dafe4acddbbfe5464c83b6f60c52218ec4619219", "url": "https://github.com/cryostatio/cryostat/commit/dafe4acddbbfe5464c83b6f60c52218ec4619219", "message": "Finish changes to unit test for targetRecordingsPostHandler", "committedDate": "2020-09-03T18:25:01Z", "type": "commit"}, {"oid": "6d544d4616ab3808d84146e3530bacc51638d1b3", "url": "https://github.com/cryostatio/cryostat/commit/6d544d4616ab3808d84146e3530bacc51638d1b3", "message": "RecordingOptionsGetHandler first checks if there are system wide RecordingOptions, if not gets target JVM specific defaults", "committedDate": "2020-09-03T18:25:01Z", "type": "commit"}, {"oid": "6c185a54f4f8de54fd00415a76f8306b0c918c4a", "url": "https://github.com/cryostatio/cryostat/commit/6c185a54f4f8de54fd00415a76f8306b0c918c4a", "message": "Allow RecordingOptionsPutHandler to accept incomplete options list", "committedDate": "2020-09-03T18:25:01Z", "type": "commit"}, {"oid": "d1d83d265175e1857a5f6f2d6b3b4d0a840cacc3", "url": "https://github.com/cryostatio/cryostat/commit/d1d83d265175e1857a5f6f2d6b3b4d0a840cacc3", "message": "Rebase and fix errors", "committedDate": "2020-09-03T18:40:23Z", "type": "commit"}, {"oid": "d1d83d265175e1857a5f6f2d6b3b4d0a840cacc3", "url": "https://github.com/cryostatio/cryostat/commit/d1d83d265175e1857a5f6f2d6b3b4d0a840cacc3", "message": "Rebase and fix errors", "committedDate": "2020-09-03T18:40:23Z", "type": "forcePushed"}, {"oid": "08c84a50cd5434140257cb40309266b1bfd89ef9", "url": "https://github.com/cryostatio/cryostat/commit/08c84a50cd5434140257cb40309266b1bfd89ef9", "message": "Remove debugging statements", "committedDate": "2020-09-03T18:54:18Z", "type": "commit"}, {"oid": "b8bc0f27346068deb36a3ad8b4c2a22d25f853a4", "url": "https://github.com/cryostatio/cryostat/commit/b8bc0f27346068deb36a3ad8b4c2a22d25f853a4", "message": "Fix formatting and milisecond conversion error", "committedDate": "2020-09-03T20:01:31Z", "type": "commit"}, {"oid": "76d35c49794efae6d4f77daf6d1c49e8bbe5df5a", "url": "https://github.com/cryostatio/cryostat/commit/76d35c49794efae6d4f77daf6d1c49e8bbe5df5a", "message": "Change recordingOptions to Patch, add body handler", "committedDate": "2020-09-04T15:06:15Z", "type": "commit"}, {"oid": "0fe5f1126a51561a297d4e30f420561621089521", "url": "https://github.com/cryostatio/cryostat/commit/0fe5f1126a51561a297d4e30f420561621089521", "message": "Modify patch test and other small fixes", "committedDate": "2020-09-04T16:51:15Z", "type": "commit"}, {"oid": "7eb021723ba2fbafa00c8dbaf0a59f1c918c4ab1", "url": "https://github.com/cryostatio/cryostat/commit/7eb021723ba2fbafa00c8dbaf0a59f1c918c4ab1", "message": "Remove units when retrieving recordingOptions in getHandler", "committedDate": "2020-09-04T16:52:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc1NDE3Mw==", "url": "https://github.com/cryostatio/cryostat/pull/254#discussion_r483754173", "bodyText": "Can these three if/elses be refactored into a loop over a set of keys? And rather than using constant strings like toDisk, could these use the RecordingOptionsCustomizer.OptionKeys?", "author": "andrewazores", "createdAt": "2020-09-04T17:13:58Z", "path": "src/main/java/com/redhat/rhjmc/containerjfr/net/web/handlers/RecordingOptionsGetHandler.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*-\n+ * #%L\n+ * Container JFR\n+ * %%\n+ * Copyright (C) 2020 Red Hat, Inc.\n+ * %%\n+ * The Universal Permissive License (UPL), Version 1.0\n+ *\n+ * Subject to the condition set forth below, permission is hereby granted to any\n+ * person obtaining a copy of this software, associated documentation and/or data\n+ * (collectively the \"Software\"), free of charge and under any and all copyright\n+ * rights in the Software, and any and all patent rights owned or freely\n+ * licensable by each licensor hereunder covering either (i) the unmodified\n+ * Software as contributed to or provided by such licensor, or (ii) the Larger\n+ * Works (as defined below), to deal in both\n+ *\n+ * (a) the Software, and\n+ * (b) any piece of software and/or hardware listed in the lrgrwrks.txt file if\n+ * one is included with the Software (each a \"Larger Work\" to which the Software\n+ * is contributed by such licensors),\n+ *\n+ * without restriction, including without limitation the rights to copy, create\n+ * derivative works of, display, perform, and distribute the Software and make,\n+ * use, sell, offer for sale, import, export, have made, and have sold the\n+ * Software and the Larger Work(s), and to sublicense the foregoing rights on\n+ * either these or other terms.\n+ *\n+ * This license is subject to the following condition:\n+ * The above copyright notice and either this complete permission notice or at\n+ * a minimum a reference to the UPL must be included in all copies or\n+ * substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ * #L%\n+ */\n+package com.redhat.rhjmc.containerjfr.net.web.handlers;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.inject.Inject;\n+\n+import org.openjdk.jmc.common.unit.IConstrainedMap;\n+import org.openjdk.jmc.common.unit.IOptionDescriptor;\n+import org.openjdk.jmc.flightrecorder.configuration.recording.RecordingOptionsBuilder;\n+\n+import com.google.gson.Gson;\n+\n+import com.redhat.rhjmc.containerjfr.commands.internal.RecordingOptionsBuilderFactory;\n+import com.redhat.rhjmc.containerjfr.net.AuthManager;\n+import com.redhat.rhjmc.containerjfr.net.TargetConnectionManager;\n+\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.ext.web.RoutingContext;\n+\n+public class RecordingOptionsGetHandler extends AbstractAuthenticatedRequestHandler {\n+\n+    static final String PATH = \"/api/v1/targets/:targetId/recordingOptions\";\n+    protected final TargetConnectionManager connectionManager;\n+    private final RecordingOptionsBuilderFactory recordingOptionsBuilderFactory;\n+    private final Gson gson;\n+    private static final Pattern NUMBER_PATTERN = Pattern.compile(\"\\\\d+\");\n+\n+    @Inject\n+    RecordingOptionsGetHandler(\n+            AuthManager auth,\n+            TargetConnectionManager connectionManager,\n+            RecordingOptionsBuilderFactory recordingOptionsBuilderFactory,\n+            Gson gson) {\n+        super(auth);\n+        this.connectionManager = connectionManager;\n+        this.recordingOptionsBuilderFactory = recordingOptionsBuilderFactory;\n+        this.gson = gson;\n+    }\n+\n+    @Override\n+    public HttpMethod httpMethod() {\n+        return HttpMethod.GET;\n+    }\n+\n+    @Override\n+    public String path() {\n+        return PATH;\n+    }\n+\n+    @Override\n+    public boolean isAsync() {\n+        return false;\n+    }\n+\n+    @Override\n+    void handleAuthenticated(RoutingContext ctx) throws Exception {\n+        Map<String, String> optionMap =\n+                connectionManager.executeConnectedTask(\n+                        getConnectionDescriptorFromContext(ctx),\n+                        connection -> {\n+                            RecordingOptionsBuilder builder =\n+                                    recordingOptionsBuilderFactory.create(connection.getService());\n+                            IConstrainedMap<String> recordingOptions = builder.build();\n+\n+                            Map<String, IOptionDescriptor<?>> TargetRecordingOptions =\n+                                    connection.getService().getAvailableRecordingOptions();\n+\n+                            Map<String, String> map = new HashMap<String, String>();\n+\n+                            if (recordingOptions.get(\"toDisk\") != null) {", "originalCommit": "7eb021723ba2fbafa00c8dbaf0a59f1c918c4ab1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg0MjkwOQ==", "url": "https://github.com/cryostatio/cryostat/pull/254#discussion_r483842909", "bodyText": "I made a similar loop in the PATCH handler, but this one makes less sense because toDisk has to be handled differently than the other two. It would have to be a loop for just two of the options.", "author": "Alexjsenn", "createdAt": "2020-09-04T21:03:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc1NDE3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg0MzU0OA==", "url": "https://github.com/cryostatio/cryostat/pull/254#discussion_r483843548", "bodyText": "How about extracting utility methods for handling plain textual values like toDisk and numeric values like the other two?\nAlthough - the other two have a regex to check that they are numeric, but toDisk doesn't seem to have any check that its text encodes a boolean value. So that should be implemented too, IMO.", "author": "andrewazores", "createdAt": "2020-09-04T21:05:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc1NDE3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg0NDkxMw==", "url": "https://github.com/cryostatio/cryostat/pull/254#discussion_r483844913", "bodyText": "How would that work, how would the utility method know which type it need to check? woudl this still be in a loop?", "author": "Alexjsenn", "createdAt": "2020-09-04T21:09:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc1NDE3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg0NTY0NQ==", "url": "https://github.com/cryostatio/cryostat/pull/254#discussion_r483845645", "bodyText": "No loop. Make a utility method like getNumericOption and another like getBooleanOption.", "author": "andrewazores", "createdAt": "2020-09-04T21:11:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc1NDE3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAxODA1Mg==", "url": "https://github.com/cryostatio/cryostat/pull/254#discussion_r485018052", "bodyText": "I created a helper function for the numeric ones, I don't know if it makes sense for the boolean one because for some reason the name of the option is different between recordingOptionsCustomizer and the target recordingOptions default", "author": "Alexjsenn", "createdAt": "2020-09-08T15:40:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc1NDE3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc1Njk1Mg==", "url": "https://github.com/cryostatio/cryostat/pull/254#discussion_r483756952", "bodyText": "Does the recordingOptions have a method like .containsKey()? If so, it would be better to use that than .get() != null.", "author": "andrewazores", "createdAt": "2020-09-04T17:20:28Z", "path": "src/main/java/com/redhat/rhjmc/containerjfr/net/web/handlers/RecordingOptionsGetHandler.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*-\n+ * #%L\n+ * Container JFR\n+ * %%\n+ * Copyright (C) 2020 Red Hat, Inc.\n+ * %%\n+ * The Universal Permissive License (UPL), Version 1.0\n+ *\n+ * Subject to the condition set forth below, permission is hereby granted to any\n+ * person obtaining a copy of this software, associated documentation and/or data\n+ * (collectively the \"Software\"), free of charge and under any and all copyright\n+ * rights in the Software, and any and all patent rights owned or freely\n+ * licensable by each licensor hereunder covering either (i) the unmodified\n+ * Software as contributed to or provided by such licensor, or (ii) the Larger\n+ * Works (as defined below), to deal in both\n+ *\n+ * (a) the Software, and\n+ * (b) any piece of software and/or hardware listed in the lrgrwrks.txt file if\n+ * one is included with the Software (each a \"Larger Work\" to which the Software\n+ * is contributed by such licensors),\n+ *\n+ * without restriction, including without limitation the rights to copy, create\n+ * derivative works of, display, perform, and distribute the Software and make,\n+ * use, sell, offer for sale, import, export, have made, and have sold the\n+ * Software and the Larger Work(s), and to sublicense the foregoing rights on\n+ * either these or other terms.\n+ *\n+ * This license is subject to the following condition:\n+ * The above copyright notice and either this complete permission notice or at\n+ * a minimum a reference to the UPL must be included in all copies or\n+ * substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ * #L%\n+ */\n+package com.redhat.rhjmc.containerjfr.net.web.handlers;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.inject.Inject;\n+\n+import org.openjdk.jmc.common.unit.IConstrainedMap;\n+import org.openjdk.jmc.common.unit.IOptionDescriptor;\n+import org.openjdk.jmc.flightrecorder.configuration.recording.RecordingOptionsBuilder;\n+\n+import com.google.gson.Gson;\n+\n+import com.redhat.rhjmc.containerjfr.commands.internal.RecordingOptionsBuilderFactory;\n+import com.redhat.rhjmc.containerjfr.net.AuthManager;\n+import com.redhat.rhjmc.containerjfr.net.TargetConnectionManager;\n+\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.ext.web.RoutingContext;\n+\n+public class RecordingOptionsGetHandler extends AbstractAuthenticatedRequestHandler {\n+\n+    static final String PATH = \"/api/v1/targets/:targetId/recordingOptions\";\n+    protected final TargetConnectionManager connectionManager;\n+    private final RecordingOptionsBuilderFactory recordingOptionsBuilderFactory;\n+    private final Gson gson;\n+    private static final Pattern NUMBER_PATTERN = Pattern.compile(\"\\\\d+\");\n+\n+    @Inject\n+    RecordingOptionsGetHandler(\n+            AuthManager auth,\n+            TargetConnectionManager connectionManager,\n+            RecordingOptionsBuilderFactory recordingOptionsBuilderFactory,\n+            Gson gson) {\n+        super(auth);\n+        this.connectionManager = connectionManager;\n+        this.recordingOptionsBuilderFactory = recordingOptionsBuilderFactory;\n+        this.gson = gson;\n+    }\n+\n+    @Override\n+    public HttpMethod httpMethod() {\n+        return HttpMethod.GET;\n+    }\n+\n+    @Override\n+    public String path() {\n+        return PATH;\n+    }\n+\n+    @Override\n+    public boolean isAsync() {\n+        return false;\n+    }\n+\n+    @Override\n+    void handleAuthenticated(RoutingContext ctx) throws Exception {\n+        Map<String, String> optionMap =\n+                connectionManager.executeConnectedTask(\n+                        getConnectionDescriptorFromContext(ctx),\n+                        connection -> {\n+                            RecordingOptionsBuilder builder =\n+                                    recordingOptionsBuilderFactory.create(connection.getService());\n+                            IConstrainedMap<String> recordingOptions = builder.build();\n+\n+                            Map<String, IOptionDescriptor<?>> TargetRecordingOptions =\n+                                    connection.getService().getAvailableRecordingOptions();\n+\n+                            Map<String, String> map = new HashMap<String, String>();\n+\n+                            if (recordingOptions.get(\"toDisk\") != null) {\n+                                map.put(\"toDisk\", recordingOptions.get(\"toDisk\").toString());\n+                            } else {\n+                                map.put(\n+                                        \"toDisk\",\n+                                        TargetRecordingOptions.get(\"disk\").getDefault().toString());\n+                            }\n+\n+                            String maxAge;\n+                            if (recordingOptions.get(\"maxAge\") != null) {", "originalCommit": "7eb021723ba2fbafa00c8dbaf0a59f1c918c4ab1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc5MTcxNA==", "url": "https://github.com/cryostatio/cryostat/pull/254#discussion_r483791714", "bodyText": "the IConstrainedMap does not seem to have that method, the only method that I can tell that serves the purpose is .get", "author": "Alexjsenn", "createdAt": "2020-09-04T18:42:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc1Njk1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc5MjI3OQ==", "url": "https://github.com/cryostatio/cryostat/pull/254#discussion_r483792279", "bodyText": "What about a .keySet().contains()?", "author": "andrewazores", "createdAt": "2020-09-04T18:44:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc1Njk1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc5NDMzMw==", "url": "https://github.com/cryostatio/cryostat/pull/254#discussion_r483794333", "bodyText": "Hmm.\n\t/**\n\t * @return A {@link Set set} of keys which are known to be valid. That is, those that currently\n\t *         are known to have a {@link IConstraint constraint}. This includes all keys which\n\t *         currently have a value, but additional keys may be included. In other words,\n\t *         {@link #get(Object)} may return {@code null} for some keys included in this set.\n\t */\n\tSet<K> keySet();\n\nWell, nevermind. Just keep using .get() != null then.", "author": "andrewazores", "createdAt": "2020-09-04T18:49:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc1Njk1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc1NzQ0Nw==", "url": "https://github.com/cryostatio/cryostat/pull/254#discussion_r483757447", "bodyText": "This should be renamed targetRecordingOptions (camelCase, not PascalCase)", "author": "andrewazores", "createdAt": "2020-09-04T17:21:42Z", "path": "src/main/java/com/redhat/rhjmc/containerjfr/net/web/handlers/RecordingOptionsGetHandler.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*-\n+ * #%L\n+ * Container JFR\n+ * %%\n+ * Copyright (C) 2020 Red Hat, Inc.\n+ * %%\n+ * The Universal Permissive License (UPL), Version 1.0\n+ *\n+ * Subject to the condition set forth below, permission is hereby granted to any\n+ * person obtaining a copy of this software, associated documentation and/or data\n+ * (collectively the \"Software\"), free of charge and under any and all copyright\n+ * rights in the Software, and any and all patent rights owned or freely\n+ * licensable by each licensor hereunder covering either (i) the unmodified\n+ * Software as contributed to or provided by such licensor, or (ii) the Larger\n+ * Works (as defined below), to deal in both\n+ *\n+ * (a) the Software, and\n+ * (b) any piece of software and/or hardware listed in the lrgrwrks.txt file if\n+ * one is included with the Software (each a \"Larger Work\" to which the Software\n+ * is contributed by such licensors),\n+ *\n+ * without restriction, including without limitation the rights to copy, create\n+ * derivative works of, display, perform, and distribute the Software and make,\n+ * use, sell, offer for sale, import, export, have made, and have sold the\n+ * Software and the Larger Work(s), and to sublicense the foregoing rights on\n+ * either these or other terms.\n+ *\n+ * This license is subject to the following condition:\n+ * The above copyright notice and either this complete permission notice or at\n+ * a minimum a reference to the UPL must be included in all copies or\n+ * substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ * #L%\n+ */\n+package com.redhat.rhjmc.containerjfr.net.web.handlers;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.inject.Inject;\n+\n+import org.openjdk.jmc.common.unit.IConstrainedMap;\n+import org.openjdk.jmc.common.unit.IOptionDescriptor;\n+import org.openjdk.jmc.flightrecorder.configuration.recording.RecordingOptionsBuilder;\n+\n+import com.google.gson.Gson;\n+\n+import com.redhat.rhjmc.containerjfr.commands.internal.RecordingOptionsBuilderFactory;\n+import com.redhat.rhjmc.containerjfr.net.AuthManager;\n+import com.redhat.rhjmc.containerjfr.net.TargetConnectionManager;\n+\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.ext.web.RoutingContext;\n+\n+public class RecordingOptionsGetHandler extends AbstractAuthenticatedRequestHandler {\n+\n+    static final String PATH = \"/api/v1/targets/:targetId/recordingOptions\";\n+    protected final TargetConnectionManager connectionManager;\n+    private final RecordingOptionsBuilderFactory recordingOptionsBuilderFactory;\n+    private final Gson gson;\n+    private static final Pattern NUMBER_PATTERN = Pattern.compile(\"\\\\d+\");\n+\n+    @Inject\n+    RecordingOptionsGetHandler(\n+            AuthManager auth,\n+            TargetConnectionManager connectionManager,\n+            RecordingOptionsBuilderFactory recordingOptionsBuilderFactory,\n+            Gson gson) {\n+        super(auth);\n+        this.connectionManager = connectionManager;\n+        this.recordingOptionsBuilderFactory = recordingOptionsBuilderFactory;\n+        this.gson = gson;\n+    }\n+\n+    @Override\n+    public HttpMethod httpMethod() {\n+        return HttpMethod.GET;\n+    }\n+\n+    @Override\n+    public String path() {\n+        return PATH;\n+    }\n+\n+    @Override\n+    public boolean isAsync() {\n+        return false;\n+    }\n+\n+    @Override\n+    void handleAuthenticated(RoutingContext ctx) throws Exception {\n+        Map<String, String> optionMap =\n+                connectionManager.executeConnectedTask(\n+                        getConnectionDescriptorFromContext(ctx),\n+                        connection -> {\n+                            RecordingOptionsBuilder builder =\n+                                    recordingOptionsBuilderFactory.create(connection.getService());\n+                            IConstrainedMap<String> recordingOptions = builder.build();\n+\n+                            Map<String, IOptionDescriptor<?>> TargetRecordingOptions =", "originalCommit": "7eb021723ba2fbafa00c8dbaf0a59f1c918c4ab1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc1Nzk4MQ==", "url": "https://github.com/cryostatio/cryostat/pull/254#discussion_r483757981", "bodyText": "This is duplicated from the GET handler, isn't it? One of them should probably reference the other's path here.", "author": "andrewazores", "createdAt": "2020-09-04T17:22:58Z", "path": "src/main/java/com/redhat/rhjmc/containerjfr/net/web/handlers/RecordingOptionsPatchHandler.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*-\n+ * #%L\n+ * Container JFR\n+ * %%\n+ * Copyright (C) 2020 Red Hat, Inc.\n+ * %%\n+ * The Universal Permissive License (UPL), Version 1.0\n+ *\n+ * Subject to the condition set forth below, permission is hereby granted to any\n+ * person obtaining a copy of this software, associated documentation and/or data\n+ * (collectively the \"Software\"), free of charge and under any and all copyright\n+ * rights in the Software, and any and all patent rights owned or freely\n+ * licensable by each licensor hereunder covering either (i) the unmodified\n+ * Software as contributed to or provided by such licensor, or (ii) the Larger\n+ * Works (as defined below), to deal in both\n+ *\n+ * (a) the Software, and\n+ * (b) any piece of software and/or hardware listed in the lrgrwrks.txt file if\n+ * one is included with the Software (each a \"Larger Work\" to which the Software\n+ * is contributed by such licensors),\n+ *\n+ * without restriction, including without limitation the rights to copy, create\n+ * derivative works of, display, perform, and distribute the Software and make,\n+ * use, sell, offer for sale, import, export, have made, and have sold the\n+ * Software and the Larger Work(s), and to sublicense the foregoing rights on\n+ * either these or other terms.\n+ *\n+ * This license is subject to the following condition:\n+ * The above copyright notice and either this complete permission notice or at\n+ * a minimum a reference to the UPL must be included in all copies or\n+ * substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ * #L%\n+ */\n+package com.redhat.rhjmc.containerjfr.net.web.handlers;\n+\n+import javax.inject.Inject;\n+\n+import com.redhat.rhjmc.containerjfr.core.RecordingOptionsCustomizer;\n+import com.redhat.rhjmc.containerjfr.core.RecordingOptionsCustomizer.OptionKey;\n+import com.redhat.rhjmc.containerjfr.net.AuthManager;\n+\n+import io.vertx.core.MultiMap;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.ext.web.RoutingContext;\n+\n+class RecordingOptionsPatchHandler extends AbstractAuthenticatedRequestHandler {\n+\n+    static final String PATH = \"/api/v1/targets/:targetId/recordingOptions\";", "originalCommit": "7eb021723ba2fbafa00c8dbaf0a59f1c918c4ab1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc1ODEyNQ==", "url": "https://github.com/cryostatio/cryostat/pull/254#discussion_r483758125", "bodyText": "The handleAuthenticated here is non-blocking so I think this can be omitted.", "author": "andrewazores", "createdAt": "2020-09-04T17:23:18Z", "path": "src/main/java/com/redhat/rhjmc/containerjfr/net/web/handlers/RecordingOptionsPatchHandler.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*-\n+ * #%L\n+ * Container JFR\n+ * %%\n+ * Copyright (C) 2020 Red Hat, Inc.\n+ * %%\n+ * The Universal Permissive License (UPL), Version 1.0\n+ *\n+ * Subject to the condition set forth below, permission is hereby granted to any\n+ * person obtaining a copy of this software, associated documentation and/or data\n+ * (collectively the \"Software\"), free of charge and under any and all copyright\n+ * rights in the Software, and any and all patent rights owned or freely\n+ * licensable by each licensor hereunder covering either (i) the unmodified\n+ * Software as contributed to or provided by such licensor, or (ii) the Larger\n+ * Works (as defined below), to deal in both\n+ *\n+ * (a) the Software, and\n+ * (b) any piece of software and/or hardware listed in the lrgrwrks.txt file if\n+ * one is included with the Software (each a \"Larger Work\" to which the Software\n+ * is contributed by such licensors),\n+ *\n+ * without restriction, including without limitation the rights to copy, create\n+ * derivative works of, display, perform, and distribute the Software and make,\n+ * use, sell, offer for sale, import, export, have made, and have sold the\n+ * Software and the Larger Work(s), and to sublicense the foregoing rights on\n+ * either these or other terms.\n+ *\n+ * This license is subject to the following condition:\n+ * The above copyright notice and either this complete permission notice or at\n+ * a minimum a reference to the UPL must be included in all copies or\n+ * substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ * #L%\n+ */\n+package com.redhat.rhjmc.containerjfr.net.web.handlers;\n+\n+import javax.inject.Inject;\n+\n+import com.redhat.rhjmc.containerjfr.core.RecordingOptionsCustomizer;\n+import com.redhat.rhjmc.containerjfr.core.RecordingOptionsCustomizer.OptionKey;\n+import com.redhat.rhjmc.containerjfr.net.AuthManager;\n+\n+import io.vertx.core.MultiMap;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.ext.web.RoutingContext;\n+\n+class RecordingOptionsPatchHandler extends AbstractAuthenticatedRequestHandler {\n+\n+    static final String PATH = \"/api/v1/targets/:targetId/recordingOptions\";\n+    private final RecordingOptionsCustomizer customizer;\n+\n+    @Inject\n+    RecordingOptionsPatchHandler(AuthManager auth, RecordingOptionsCustomizer customizer) {\n+        super(auth);\n+        this.customizer = customizer;\n+    }\n+\n+    @Override\n+    public HttpMethod httpMethod() {\n+        return HttpMethod.PATCH;\n+    }\n+\n+    @Override\n+    public String path() {\n+        return PATH;\n+    }\n+\n+    @Override\n+    public boolean isAsync() {\n+        return false;", "originalCommit": "7eb021723ba2fbafa00c8dbaf0a59f1c918c4ab1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc1ODU1Mw==", "url": "https://github.com/cryostatio/cryostat/pull/254#discussion_r483758553", "bodyText": "I wonder if it would make sense to respond with 200 and then send back the updated map, or respond 204 and no response body? If the client doesn't care about the updated value then they can simply ignore it.", "author": "andrewazores", "createdAt": "2020-09-04T17:24:21Z", "path": "src/main/java/com/redhat/rhjmc/containerjfr/net/web/handlers/RecordingOptionsPatchHandler.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*-\n+ * #%L\n+ * Container JFR\n+ * %%\n+ * Copyright (C) 2020 Red Hat, Inc.\n+ * %%\n+ * The Universal Permissive License (UPL), Version 1.0\n+ *\n+ * Subject to the condition set forth below, permission is hereby granted to any\n+ * person obtaining a copy of this software, associated documentation and/or data\n+ * (collectively the \"Software\"), free of charge and under any and all copyright\n+ * rights in the Software, and any and all patent rights owned or freely\n+ * licensable by each licensor hereunder covering either (i) the unmodified\n+ * Software as contributed to or provided by such licensor, or (ii) the Larger\n+ * Works (as defined below), to deal in both\n+ *\n+ * (a) the Software, and\n+ * (b) any piece of software and/or hardware listed in the lrgrwrks.txt file if\n+ * one is included with the Software (each a \"Larger Work\" to which the Software\n+ * is contributed by such licensors),\n+ *\n+ * without restriction, including without limitation the rights to copy, create\n+ * derivative works of, display, perform, and distribute the Software and make,\n+ * use, sell, offer for sale, import, export, have made, and have sold the\n+ * Software and the Larger Work(s), and to sublicense the foregoing rights on\n+ * either these or other terms.\n+ *\n+ * This license is subject to the following condition:\n+ * The above copyright notice and either this complete permission notice or at\n+ * a minimum a reference to the UPL must be included in all copies or\n+ * substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ * #L%\n+ */\n+package com.redhat.rhjmc.containerjfr.net.web.handlers;\n+\n+import javax.inject.Inject;\n+\n+import com.redhat.rhjmc.containerjfr.core.RecordingOptionsCustomizer;\n+import com.redhat.rhjmc.containerjfr.core.RecordingOptionsCustomizer.OptionKey;\n+import com.redhat.rhjmc.containerjfr.net.AuthManager;\n+\n+import io.vertx.core.MultiMap;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.ext.web.RoutingContext;\n+\n+class RecordingOptionsPatchHandler extends AbstractAuthenticatedRequestHandler {\n+\n+    static final String PATH = \"/api/v1/targets/:targetId/recordingOptions\";\n+    private final RecordingOptionsCustomizer customizer;\n+\n+    @Inject\n+    RecordingOptionsPatchHandler(AuthManager auth, RecordingOptionsCustomizer customizer) {\n+        super(auth);\n+        this.customizer = customizer;\n+    }\n+\n+    @Override\n+    public HttpMethod httpMethod() {\n+        return HttpMethod.PATCH;\n+    }\n+\n+    @Override\n+    public String path() {\n+        return PATH;\n+    }\n+\n+    @Override\n+    public boolean isAsync() {\n+        return false;\n+    }\n+\n+    @Override\n+    void handleAuthenticated(RoutingContext ctx) throws Exception {\n+        MultiMap attrs = ctx.request().formAttributes();\n+\n+        if (attrs.contains(\"toDisk\")) {\n+            OptionKey.fromOptionName(\"toDisk\")\n+                    .ifPresent(key -> customizer.set(key, attrs.get(\"toDisk\")));\n+        }\n+        if (attrs.contains(\"maxAge\")) {\n+            OptionKey.fromOptionName(\"maxAge\")\n+                    .ifPresent(key -> customizer.set(key, attrs.get(\"maxAge\")));\n+        }\n+        if (attrs.contains(\"maxSize\")) {\n+            OptionKey.fromOptionName(\"maxSize\")\n+                    .ifPresent(key -> customizer.set(key, attrs.get(\"maxSize\")));\n+        }\n+        ctx.response().setStatusCode(200);", "originalCommit": "7eb021723ba2fbafa00c8dbaf0a59f1c918c4ab1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc4MzgwOA==", "url": "https://github.com/cryostatio/cryostat/pull/254#discussion_r483783808", "bodyText": "Yes, returning the updated map is good, do I need to convert it to json when sending it back?", "author": "Alexjsenn", "createdAt": "2020-09-04T18:23:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc1ODU1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc4NDA4Nw==", "url": "https://github.com/cryostatio/cryostat/pull/254#discussion_r483784087", "bodyText": "Yes.", "author": "andrewazores", "createdAt": "2020-09-04T18:24:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc1ODU1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzgzMjk4OQ==", "url": "https://github.com/cryostatio/cryostat/pull/254#discussion_r483832989", "bodyText": "Should work now!", "author": "Alexjsenn", "createdAt": "2020-09-04T20:33:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc1ODU1Mw=="}], "type": "inlineReview"}, {"oid": "0b0f279ec809e7f6e2f0d19ec2839e90c21b3e76", "url": "https://github.com/cryostatio/cryostat/commit/0b0f279ec809e7f6e2f0d19ec2839e90c21b3e76", "message": "Patch endpoint returns map with updated values", "committedDate": "2020-09-04T20:25:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzgzMzg2NQ==", "url": "https://github.com/cryostatio/cryostat/pull/254#discussion_r483833865", "bodyText": "I think this can be private, too.", "author": "andrewazores", "createdAt": "2020-09-04T20:35:54Z", "path": "src/main/java/com/redhat/rhjmc/containerjfr/net/web/handlers/RecordingOptionsGetHandler.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*-\n+ * #%L\n+ * Container JFR\n+ * %%\n+ * Copyright (C) 2020 Red Hat, Inc.\n+ * %%\n+ * The Universal Permissive License (UPL), Version 1.0\n+ *\n+ * Subject to the condition set forth below, permission is hereby granted to any\n+ * person obtaining a copy of this software, associated documentation and/or data\n+ * (collectively the \"Software\"), free of charge and under any and all copyright\n+ * rights in the Software, and any and all patent rights owned or freely\n+ * licensable by each licensor hereunder covering either (i) the unmodified\n+ * Software as contributed to or provided by such licensor, or (ii) the Larger\n+ * Works (as defined below), to deal in both\n+ *\n+ * (a) the Software, and\n+ * (b) any piece of software and/or hardware listed in the lrgrwrks.txt file if\n+ * one is included with the Software (each a \"Larger Work\" to which the Software\n+ * is contributed by such licensors),\n+ *\n+ * without restriction, including without limitation the rights to copy, create\n+ * derivative works of, display, perform, and distribute the Software and make,\n+ * use, sell, offer for sale, import, export, have made, and have sold the\n+ * Software and the Larger Work(s), and to sublicense the foregoing rights on\n+ * either these or other terms.\n+ *\n+ * This license is subject to the following condition:\n+ * The above copyright notice and either this complete permission notice or at\n+ * a minimum a reference to the UPL must be included in all copies or\n+ * substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ * #L%\n+ */\n+package com.redhat.rhjmc.containerjfr.net.web.handlers;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.inject.Inject;\n+\n+import org.openjdk.jmc.common.unit.IConstrainedMap;\n+import org.openjdk.jmc.common.unit.IOptionDescriptor;\n+import org.openjdk.jmc.flightrecorder.configuration.recording.RecordingOptionsBuilder;\n+import org.openjdk.jmc.rjmx.services.jfr.IFlightRecorderService;\n+\n+import com.google.gson.Gson;\n+\n+import com.redhat.rhjmc.containerjfr.commands.internal.RecordingOptionsBuilderFactory;\n+import com.redhat.rhjmc.containerjfr.net.AuthManager;\n+import com.redhat.rhjmc.containerjfr.net.TargetConnectionManager;\n+\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.ext.web.RoutingContext;\n+\n+public class RecordingOptionsGetHandler extends AbstractAuthenticatedRequestHandler {\n+\n+    static final String PATH = \"/api/v1/targets/:targetId/recordingOptions\";\n+    protected final TargetConnectionManager connectionManager;", "originalCommit": "0b0f279ec809e7f6e2f0d19ec2839e90c21b3e76", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzgzNDU1NA==", "url": "https://github.com/cryostatio/cryostat/pull/254#discussion_r483834554", "bodyText": "private here too", "author": "andrewazores", "createdAt": "2020-09-04T20:37:59Z", "path": "src/main/java/com/redhat/rhjmc/containerjfr/net/web/handlers/RecordingOptionsPatchHandler.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*-\n+ * #%L\n+ * Container JFR\n+ * %%\n+ * Copyright (C) 2020 Red Hat, Inc.\n+ * %%\n+ * The Universal Permissive License (UPL), Version 1.0\n+ *\n+ * Subject to the condition set forth below, permission is hereby granted to any\n+ * person obtaining a copy of this software, associated documentation and/or data\n+ * (collectively the \"Software\"), free of charge and under any and all copyright\n+ * rights in the Software, and any and all patent rights owned or freely\n+ * licensable by each licensor hereunder covering either (i) the unmodified\n+ * Software as contributed to or provided by such licensor, or (ii) the Larger\n+ * Works (as defined below), to deal in both\n+ *\n+ * (a) the Software, and\n+ * (b) any piece of software and/or hardware listed in the lrgrwrks.txt file if\n+ * one is included with the Software (each a \"Larger Work\" to which the Software\n+ * is contributed by such licensors),\n+ *\n+ * without restriction, including without limitation the rights to copy, create\n+ * derivative works of, display, perform, and distribute the Software and make,\n+ * use, sell, offer for sale, import, export, have made, and have sold the\n+ * Software and the Larger Work(s), and to sublicense the foregoing rights on\n+ * either these or other terms.\n+ *\n+ * This license is subject to the following condition:\n+ * The above copyright notice and either this complete permission notice or at\n+ * a minimum a reference to the UPL must be included in all copies or\n+ * substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ * #L%\n+ */\n+package com.redhat.rhjmc.containerjfr.net.web.handlers;\n+\n+import java.util.Map;\n+\n+import javax.inject.Inject;\n+\n+import org.openjdk.jmc.flightrecorder.configuration.recording.RecordingOptionsBuilder;\n+\n+import com.google.gson.Gson;\n+\n+import com.redhat.rhjmc.containerjfr.commands.internal.RecordingOptionsBuilderFactory;\n+import com.redhat.rhjmc.containerjfr.core.RecordingOptionsCustomizer;\n+import com.redhat.rhjmc.containerjfr.core.RecordingOptionsCustomizer.OptionKey;\n+import com.redhat.rhjmc.containerjfr.net.AuthManager;\n+import com.redhat.rhjmc.containerjfr.net.TargetConnectionManager;\n+\n+import io.vertx.core.MultiMap;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.ext.web.RoutingContext;\n+\n+class RecordingOptionsPatchHandler extends AbstractAuthenticatedRequestHandler {\n+\n+    static final String PATH = RecordingOptionsGetHandler.PATH;\n+    private final RecordingOptionsCustomizer customizer;\n+    protected final TargetConnectionManager connectionManager;", "originalCommit": "0b0f279ec809e7f6e2f0d19ec2839e90c21b3e76", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzgzNTQ5MQ==", "url": "https://github.com/cryostatio/cryostat/pull/254#discussion_r483835491", "bodyText": "should be requestAttrs", "author": "andrewazores", "createdAt": "2020-09-04T20:40:59Z", "path": "src/test/java/com/redhat/rhjmc/containerjfr/net/web/handlers/RecordingOptionsPatchHandlerTest.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*-\n+ * #%L\n+ * Container JFR\n+ * %%\n+ * Copyright (C) 2020 Red Hat, Inc.\n+ * %%\n+ * The Universal Permissive License (UPL), Version 1.0\n+ *\n+ * Subject to the condition set forth below, permission is hereby granted to any\n+ * person obtaining a copy of this software, associated documentation and/or data\n+ * (collectively the \"Software\"), free of charge and under any and all copyright\n+ * rights in the Software, and any and all patent rights owned or freely\n+ * licensable by each licensor hereunder covering either (i) the unmodified\n+ * Software as contributed to or provided by such licensor, or (ii) the Larger\n+ * Works (as defined below), to deal in both\n+ *\n+ * (a) the Software, and\n+ * (b) any piece of software and/or hardware listed in the lrgrwrks.txt file if\n+ * one is included with the Software (each a \"Larger Work\" to which the Software\n+ * is contributed by such licensors),\n+ *\n+ * without restriction, including without limitation the rights to copy, create\n+ * derivative works of, display, perform, and distribute the Software and make,\n+ * use, sell, offer for sale, import, export, have made, and have sold the\n+ * Software and the Larger Work(s), and to sublicense the foregoing rights on\n+ * either these or other terms.\n+ *\n+ * This license is subject to the following condition:\n+ * The above copyright notice and either this complete permission notice or at\n+ * a minimum a reference to the UPL must be included in all copies or\n+ * substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ * #L%\n+ */\n+package com.redhat.rhjmc.containerjfr.net.web.handlers;\n+\n+import java.util.Map;\n+\n+import org.hamcrest.MatcherAssert;\n+import org.hamcrest.Matchers;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.mockito.stubbing.Answer;\n+\n+import org.openjdk.jmc.common.unit.IConstrainedMap;\n+import org.openjdk.jmc.flightrecorder.configuration.recording.RecordingOptionsBuilder;\n+import org.openjdk.jmc.rjmx.services.jfr.IFlightRecorderService;\n+\n+import com.google.gson.Gson;\n+\n+import com.redhat.rhjmc.containerjfr.commands.internal.RecordingOptionsBuilderFactory;\n+import com.redhat.rhjmc.containerjfr.core.RecordingOptionsCustomizer;\n+import com.redhat.rhjmc.containerjfr.core.RecordingOptionsCustomizer.OptionKey;\n+import com.redhat.rhjmc.containerjfr.core.net.JFRConnection;\n+import com.redhat.rhjmc.containerjfr.net.AuthManager;\n+import com.redhat.rhjmc.containerjfr.net.ConnectionDescriptor;\n+import com.redhat.rhjmc.containerjfr.net.TargetConnectionManager;\n+import com.redhat.rhjmc.containerjfr.net.TargetConnectionManager.ConnectedTask;\n+\n+import io.vertx.core.MultiMap;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.core.http.HttpServerRequest;\n+import io.vertx.core.http.HttpServerResponse;\n+import io.vertx.ext.web.RoutingContext;\n+\n+@ExtendWith(MockitoExtension.class)\n+class RecordingOptionsPatchHandlerTest {\n+\n+    RecordingOptionsPatchHandler handler;\n+    @Mock AuthManager auth;\n+    @Mock RecordingOptionsCustomizer customizer;\n+    @Mock TargetConnectionManager connectionManager;\n+    @Mock RecordingOptionsBuilderFactory recordingOptionsBuilderFactory;\n+    @Mock RecordingOptionsBuilder builder;\n+    @Mock IConstrainedMap<String> recordingOptions;\n+    @Mock JFRConnection jfrConnection;\n+    @Mock Gson gson;\n+\n+    @BeforeEach\n+    void setup() {\n+        this.handler =\n+                new RecordingOptionsPatchHandler(\n+                        auth, customizer, connectionManager, recordingOptionsBuilderFactory, gson);\n+    }\n+\n+    @Test\n+    void shouldHandleGETRequest() {\n+        MatcherAssert.assertThat(handler.httpMethod(), Matchers.equalTo(HttpMethod.PATCH));\n+    }\n+\n+    @Test\n+    void shouldHandleCorrectPath() {\n+        MatcherAssert.assertThat(\n+                handler.path(), Matchers.equalTo(\"/api/v1/targets/:targetId/recordingOptions\"));\n+    }\n+\n+    @Test\n+    void shouldSetRecordingOptions() throws Exception {\n+        Map<String, String> defaultValues =\n+                Map.of(\"toDisk\", \"true\", \"maxAge\", \"50\", \"maxSize\", \"32\");\n+        Mockito.when(recordingOptionsBuilderFactory.create(Mockito.any())).thenReturn(builder);\n+        Mockito.when(builder.build()).thenReturn(recordingOptions);\n+        Mockito.when(recordingOptions.get(\"toDisk\")).thenReturn(defaultValues.get(\"toDisk\"));\n+        Mockito.when(recordingOptions.get(\"maxAge\")).thenReturn(defaultValues.get(\"maxAge\"));\n+        Mockito.when(recordingOptions.get(\"maxSize\")).thenReturn(defaultValues.get(\"maxSize\"));\n+\n+        MultiMap RequestAttrs = MultiMap.caseInsensitiveMultiMap();", "originalCommit": "0b0f279ec809e7f6e2f0d19ec2839e90c21b3e76", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9eb12c41a0cbb10bd5c17a1ff01127d66a9b80ef", "url": "https://github.com/cryostatio/cryostat/commit/9eb12c41a0cbb10bd5c17a1ff01127d66a9b80ef", "message": "Formatting changes", "committedDate": "2020-09-04T21:06:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg0NTQ3Ng==", "url": "https://github.com/cryostatio/cryostat/pull/254#discussion_r483845476", "bodyText": "keys can be inlined since it isn't used anywhere lower down in the scope. Or, to be extra fancy, you could do:\nArrays.asList(\"toDisk\", \"maxAge\", \"maxSize\").forEach(key -> {\n  if (attrs.contains(key)) {\n  ...\n  }\n...\n});", "author": "andrewazores", "createdAt": "2020-09-04T21:11:20Z", "path": "src/main/java/com/redhat/rhjmc/containerjfr/net/web/handlers/RecordingOptionsPatchHandler.java", "diffHunk": "@@ -98,19 +98,17 @@ void handleAuthenticated(RoutingContext ctx) throws Exception {\n                         getConnectionDescriptorFromContext(ctx),\n                         connection -> {\n                             MultiMap attrs = ctx.request().formAttributes();\n-                            if (attrs.contains(\"toDisk\")) {\n-                                OptionKey.fromOptionName(\"toDisk\")\n-                                        .ifPresent(key -> customizer.set(key, attrs.get(\"toDisk\")));\n-                            }\n-                            if (attrs.contains(\"maxAge\")) {\n-                                OptionKey.fromOptionName(\"maxAge\")\n-                                        .ifPresent(key -> customizer.set(key, attrs.get(\"maxAge\")));\n-                            }\n-                            if (attrs.contains(\"maxSize\")) {\n-                                OptionKey.fromOptionName(\"maxSize\")\n-                                        .ifPresent(\n-                                                key -> customizer.set(key, attrs.get(\"maxSize\")));\n+                            String[] keys = {\"toDisk\", \"maxAge\", \"maxSize\"};\n+                            for (String key : keys) {", "originalCommit": "9eb12c41a0cbb10bd5c17a1ff01127d66a9b80ef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAxNzE0MQ==", "url": "https://github.com/cryostatio/cryostat/pull/254#discussion_r485017141", "bodyText": "Ok, that's definitely better!", "author": "Alexjsenn", "createdAt": "2020-09-08T15:38:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg0NTQ3Ng=="}], "type": "inlineReview"}, {"oid": "33b5ddb8a1f190a167c782373775274de7168151", "url": "https://github.com/cryostatio/cryostat/commit/33b5ddb8a1f190a167c782373775274de7168151", "message": "Create helper function", "committedDate": "2020-09-08T15:38:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA0MjU1OA==", "url": "https://github.com/cryostatio/cryostat/pull/254#discussion_r485042558", "bodyText": "Ah, now that the path includes the targetId portion, these handlers should be renamed like TargetRecordingOptionsVerbHandler.", "author": "andrewazores", "createdAt": "2020-09-08T16:17:20Z", "path": "src/main/java/com/redhat/rhjmc/containerjfr/net/web/handlers/RecordingOptionsGetHandler.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*-\n+ * #%L\n+ * Container JFR\n+ * %%\n+ * Copyright (C) 2020 Red Hat, Inc.\n+ * %%\n+ * The Universal Permissive License (UPL), Version 1.0\n+ *\n+ * Subject to the condition set forth below, permission is hereby granted to any\n+ * person obtaining a copy of this software, associated documentation and/or data\n+ * (collectively the \"Software\"), free of charge and under any and all copyright\n+ * rights in the Software, and any and all patent rights owned or freely\n+ * licensable by each licensor hereunder covering either (i) the unmodified\n+ * Software as contributed to or provided by such licensor, or (ii) the Larger\n+ * Works (as defined below), to deal in both\n+ *\n+ * (a) the Software, and\n+ * (b) any piece of software and/or hardware listed in the lrgrwrks.txt file if\n+ * one is included with the Software (each a \"Larger Work\" to which the Software\n+ * is contributed by such licensors),\n+ *\n+ * without restriction, including without limitation the rights to copy, create\n+ * derivative works of, display, perform, and distribute the Software and make,\n+ * use, sell, offer for sale, import, export, have made, and have sold the\n+ * Software and the Larger Work(s), and to sublicense the foregoing rights on\n+ * either these or other terms.\n+ *\n+ * This license is subject to the following condition:\n+ * The above copyright notice and either this complete permission notice or at\n+ * a minimum a reference to the UPL must be included in all copies or\n+ * substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ * #L%\n+ */\n+package com.redhat.rhjmc.containerjfr.net.web.handlers;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.inject.Inject;\n+\n+import org.openjdk.jmc.common.unit.IConstrainedMap;\n+import org.openjdk.jmc.common.unit.IOptionDescriptor;\n+import org.openjdk.jmc.flightrecorder.configuration.recording.RecordingOptionsBuilder;\n+import org.openjdk.jmc.rjmx.services.jfr.IFlightRecorderService;\n+\n+import com.google.gson.Gson;\n+\n+import com.redhat.rhjmc.containerjfr.commands.internal.RecordingOptionsBuilderFactory;\n+import com.redhat.rhjmc.containerjfr.net.AuthManager;\n+import com.redhat.rhjmc.containerjfr.net.TargetConnectionManager;\n+\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.ext.web.RoutingContext;\n+\n+class RecordingOptionsGetHandler extends AbstractAuthenticatedRequestHandler {", "originalCommit": "33b5ddb8a1f190a167c782373775274de7168151", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "11d891efe3e7752e58d050b275b894f030874a82", "url": "https://github.com/cryostatio/cryostat/commit/11d891efe3e7752e58d050b275b894f030874a82", "message": "rename APIs with Target prefix", "committedDate": "2020-09-08T16:41:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTc1NjU2NQ==", "url": "https://github.com/cryostatio/cryostat/pull/254#discussion_r485756565", "bodyText": "Last thing:\n$ curl -vk -X PATCH -d \"maxAge=no&toDisk=123\" -H \"X-JMX-Authorization: Basic $(echo -n user:pass | base64)\" https://0.0.0.0:8181/api/v1/targets/localhost/recordingOptions\n*   Trying 0.0.0.0:8181...\n* TCP_NODELAY set\n* Connected to 0.0.0.0 (127.0.0.1) port 8181 (#0)\n* ALPN, offering h2\n* ALPN, offering http/1.1\n* successfully set certificate verify locations:\n*   CAfile: /etc/pki/tls/certs/ca-bundle.crt\n  CApath: none\n* TLSv1.3 (OUT), TLS handshake, Client hello (1):\n* TLSv1.3 (IN), TLS handshake, Server hello (2):\n* TLSv1.2 (IN), TLS handshake, Certificate (11):\n* TLSv1.2 (IN), TLS handshake, Server key exchange (12):\n* TLSv1.2 (IN), TLS handshake, Server finished (14):\n* TLSv1.2 (OUT), TLS handshake, Client key exchange (16):\n* TLSv1.2 (OUT), TLS change cipher, Change cipher spec (1):\n* TLSv1.2 (OUT), TLS handshake, Finished (20):\n* TLSv1.2 (IN), TLS handshake, Finished (20):\n* SSL connection using TLSv1.2 / ECDHE-RSA-AES256-GCM-SHA384\n* ALPN, server did not agree to a protocol\n* Server certificate:\n*  subject: C=US; O=Red Hat; CN=container-jfr\n*  start date: Sep  9 16:27:38 2020 GMT\n*  expire date: Mar  8 16:27:38 2021 GMT\n*  issuer: C=US; O=Red Hat; CN=container-jfr\n*  SSL certificate verify result: self signed certificate (18), continuing anyway.\n> PATCH /api/v1/targets/localhost/recordingOptions HTTP/1.1\n> Host: 0.0.0.0:8181\n> User-Agent: curl/7.66.0\n> Accept: */*\n> X-JMX-Authorization: Basic dXNlcjpwYXNz\n> Content-Length: 20\n> Content-Type: application/x-www-form-urlencoded\n> \n* upload completely sent off: 20 out of 20 bytes\n* Mark bundle as not supporting multiuse\n< HTTP/1.1 200 OK\n< content-length: 45\n< \n* Connection #0 to host 0.0.0.0 left intact\n{\"maxAge\":\"0\",\"toDisk\":\"false\",\"maxSize\":\"0\"}\n\nThe options I set are invalid, and the ContainerJFR logs do reflect that, but the response sent is still a 200 OK. The Customizer needs refactoring to throw exceptions when its validations fail instead of simply logging them, however, that refactor should probably wait until the Command equivalent to this handler is removed so that the Customizer doesn't need to support both cases.\nSo, for now, please add some basic validations for these three attributes, and if the validation fails respond with some 4xx status code.", "author": "andrewazores", "createdAt": "2020-09-09T16:34:36Z", "path": "src/main/java/com/redhat/rhjmc/containerjfr/net/web/handlers/TargetRecordingOptionsPatchHandler.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*-\n+ * #%L\n+ * Container JFR\n+ * %%\n+ * Copyright (C) 2020 Red Hat, Inc.\n+ * %%\n+ * The Universal Permissive License (UPL), Version 1.0\n+ *\n+ * Subject to the condition set forth below, permission is hereby granted to any\n+ * person obtaining a copy of this software, associated documentation and/or data\n+ * (collectively the \"Software\"), free of charge and under any and all copyright\n+ * rights in the Software, and any and all patent rights owned or freely\n+ * licensable by each licensor hereunder covering either (i) the unmodified\n+ * Software as contributed to or provided by such licensor, or (ii) the Larger\n+ * Works (as defined below), to deal in both\n+ *\n+ * (a) the Software, and\n+ * (b) any piece of software and/or hardware listed in the lrgrwrks.txt file if\n+ * one is included with the Software (each a \"Larger Work\" to which the Software\n+ * is contributed by such licensors),\n+ *\n+ * without restriction, including without limitation the rights to copy, create\n+ * derivative works of, display, perform, and distribute the Software and make,\n+ * use, sell, offer for sale, import, export, have made, and have sold the\n+ * Software and the Larger Work(s), and to sublicense the foregoing rights on\n+ * either these or other terms.\n+ *\n+ * This license is subject to the following condition:\n+ * The above copyright notice and either this complete permission notice or at\n+ * a minimum a reference to the UPL must be included in all copies or\n+ * substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ * #L%\n+ */\n+package com.redhat.rhjmc.containerjfr.net.web.handlers;\n+\n+import java.util.Arrays;\n+import java.util.Map;\n+\n+import javax.inject.Inject;\n+\n+import org.openjdk.jmc.flightrecorder.configuration.recording.RecordingOptionsBuilder;\n+\n+import com.google.gson.Gson;\n+\n+import com.redhat.rhjmc.containerjfr.commands.internal.RecordingOptionsBuilderFactory;\n+import com.redhat.rhjmc.containerjfr.core.RecordingOptionsCustomizer;\n+import com.redhat.rhjmc.containerjfr.core.RecordingOptionsCustomizer.OptionKey;\n+import com.redhat.rhjmc.containerjfr.net.AuthManager;\n+import com.redhat.rhjmc.containerjfr.net.TargetConnectionManager;\n+\n+import io.vertx.core.MultiMap;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.ext.web.RoutingContext;\n+\n+class TargetRecordingOptionsPatchHandler extends AbstractAuthenticatedRequestHandler {\n+\n+    static final String PATH = TargetRecordingOptionsGetHandler.PATH;\n+    private final RecordingOptionsCustomizer customizer;\n+    private final TargetConnectionManager connectionManager;\n+    private final RecordingOptionsBuilderFactory recordingOptionsBuilderFactory;\n+    private final Gson gson;\n+\n+    @Inject\n+    TargetRecordingOptionsPatchHandler(\n+            AuthManager auth,\n+            RecordingOptionsCustomizer customizer,\n+            TargetConnectionManager connectionManager,\n+            RecordingOptionsBuilderFactory recordingOptionsBuilderFactory,\n+            Gson gson) {\n+        super(auth);\n+        this.customizer = customizer;\n+        this.connectionManager = connectionManager;\n+        this.recordingOptionsBuilderFactory = recordingOptionsBuilderFactory;\n+        this.gson = gson;\n+    }\n+\n+    @Override\n+    public HttpMethod httpMethod() {\n+        return HttpMethod.PATCH;\n+    }\n+\n+    @Override\n+    public String path() {\n+        return PATH;\n+    }\n+\n+    @Override\n+    void handleAuthenticated(RoutingContext ctx) throws Exception {\n+        Map<String, String> updatedMap =\n+                connectionManager.executeConnectedTask(\n+                        getConnectionDescriptorFromContext(ctx),\n+                        connection -> {\n+                            MultiMap attrs = ctx.request().formAttributes();\n+                            Arrays.asList(\"toDisk\", \"maxAge\", \"maxSize\")\n+                                    .forEach(\n+                                            key -> {\n+                                                if (attrs.contains(key)) {\n+                                                    OptionKey.fromOptionName(key)\n+                                                            .ifPresent(\n+                                                                    optionKey ->\n+                                                                            customizer.set(\n+                                                                                    optionKey,\n+                                                                                    attrs.get(", "originalCommit": "11d891efe3e7752e58d050b275b894f030874a82", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTc1NzE4Mw==", "url": "https://github.com/cryostatio/cryostat/pull/254#discussion_r485757183", "bodyText": "Here's the backend log snippet from the invalid request above:\n[WARN] java.lang.NumberFormatException: For input string: \"no\"\n\tat java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)\n\tat java.base/java.lang.Long.parseLong(Long.java:692)\n\tat java.base/java.lang.Long.parseLong(Long.java:817)\n\tat com.redhat.rhjmc.containerjfr.core.RecordingOptionsCustomizer$OptionKey$1.acceptThrows(RecordingOptionsCustomizer.java:88)\n\tat com.redhat.rhjmc.containerjfr.core.RecordingOptionsCustomizer$OptionKey$1.acceptThrows(RecordingOptionsCustomizer.java:85)\n\tat com.redhat.rhjmc.containerjfr.core.util.CheckedConsumer.accept(CheckedConsumer.java:49)\n\tat com.redhat.rhjmc.containerjfr.core.RecordingOptionsCustomizer.lambda$apply$0(RecordingOptionsCustomizer.java:67)\n\tat java.base/java.util.HashMap$Values.forEach(HashMap.java:976)\n\tat com.redhat.rhjmc.containerjfr.core.RecordingOptionsCustomizer.apply(RecordingOptionsCustomizer.java:67)\n\tat com.redhat.rhjmc.containerjfr.commands.internal.CommandsInternalModule.lambda$provideRecordingOptionsBuilderFactory$0(CommandsInternalModule.java:172)\n\tat com.redhat.rhjmc.containerjfr.net.web.handlers.TargetRecordingOptionsPatchHandler.lambda$handleAuthenticated$2(TargetRecordingOptionsPatchHandler.java:117)\n\tat com.redhat.rhjmc.containerjfr.net.TargetConnectionManager.executeConnectedTask(TargetConnectionManager.java:86)\n\tat com.redhat.rhjmc.containerjfr.net.web.handlers.TargetRecordingOptionsPatchHandler.handleAuthenticated(TargetRecordingOptionsPatchHandler.java:98)\n\tat com.redhat.rhjmc.containerjfr.net.web.handlers.AbstractAuthenticatedRequestHandler.handle(AbstractAuthenticatedRequestHandler.java:82)\n\tat com.redhat.rhjmc.containerjfr.net.web.handlers.AbstractAuthenticatedRequestHandler.handle(AbstractAuthenticatedRequestHandler.java:61)\n\tat io.vertx.ext.web.impl.RouteState.handleContext(RouteState.java:1034)\n\tat io.vertx.ext.web.impl.RoutingContextImplBase.iterateNext(RoutingContextImplBase.java:131)\n\tat io.vertx.ext.web.impl.RoutingContextImpl.next(RoutingContextImpl.java:133)\n\tat io.vertx.ext.web.handler.impl.BodyHandlerImpl$BHandler.doEnd(BodyHandlerImpl.java:296)\n\tat io.vertx.ext.web.handler.impl.BodyHandlerImpl$BHandler.end(BodyHandlerImpl.java:276)\n\tat io.vertx.ext.web.handler.impl.BodyHandlerImpl.lambda$handle$0(BodyHandlerImpl.java:87)\n\tat io.vertx.core.http.impl.HttpServerRequestImpl.onEnd(HttpServerRequestImpl.java:521)\n\tat io.vertx.core.http.impl.HttpServerRequestImpl.handleEnd(HttpServerRequestImpl.java:507)\n\tat io.vertx.core.http.impl.Http1xServerConnection.handleEnd(Http1xServerConnection.java:176)\n\tat io.vertx.core.http.impl.Http1xServerConnection.handleContent(Http1xServerConnection.java:163)\n\tat io.vertx.core.http.impl.Http1xServerConnection.handleMessage(Http1xServerConnection.java:140)\n\tat io.vertx.core.impl.ContextImpl.executeTask(ContextImpl.java:366)\n\tat io.vertx.core.impl.EventLoopContext.execute(EventLoopContext.java:43)\n\tat io.vertx.core.impl.ContextImpl.executeFromIO(ContextImpl.java:229)\n\tat io.vertx.core.net.impl.VertxHandler.channelRead(VertxHandler.java:173)\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)\n\tat io.netty.channel.ChannelInboundHandlerAdapter.channelRead(ChannelInboundHandlerAdapter.java:93)\n\tat io.netty.handler.codec.http.websocketx.extensions.WebSocketServerExtensionHandler.channelRead(WebSocketServerExtensionHandler.java:101)\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)\n\tat io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:103)\n\tat io.netty.handler.codec.MessageToMessageCodec.channelRead(MessageToMessageCodec.java:111)\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)\n\tat io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:324)\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:296)\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)\n\tat io.netty.handler.logging.LoggingHandler.channelRead(LoggingHandler.java:271)\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)\n\tat io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1518)\n\tat io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1267)\n\tat io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1314)\n\tat io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:501)\n\tat io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:440)\n\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:276)\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\n\tat io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:357)\n\tat io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1410)\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:379)\n\tat io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:365)\n\tat io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:919)\n\tat io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:163)\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:714)\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:650)\n\tat io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:576)\n\tat io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:493)\n\tat io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:989)\n\tat io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)\n\tat io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)\n\tat java.base/java.lang.Thread.run(Thread.java:834)", "author": "andrewazores", "createdAt": "2020-09-09T16:35:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTc1NjU2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTc2Nzk3NQ==", "url": "https://github.com/cryostatio/cryostat/pull/254#discussion_r485767975", "bodyText": "Should none of the options be set if any of them are invalid?", "author": "Alexjsenn", "createdAt": "2020-09-09T16:48:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTc1NjU2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTc2OTk3OA==", "url": "https://github.com/cryostatio/cryostat/pull/254#discussion_r485769978", "bodyText": "Yea, that's probably best. Otherwise it will be difficult to communicate to a client that their request has been only partially accepted.", "author": "andrewazores", "createdAt": "2020-09-09T16:50:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTc1NjU2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTc3MDM0Nw==", "url": "https://github.com/cryostatio/cryostat/pull/254#discussion_r485770347", "bodyText": "Ok!", "author": "Alexjsenn", "createdAt": "2020-09-09T16:51:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTc1NjU2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg1MTM2Ng==", "url": "https://github.com/cryostatio/cryostat/pull/254#discussion_r485851366", "bodyText": "My solution was very unelegant, if you can think of a more compact way I can redo it!", "author": "Alexjsenn", "createdAt": "2020-09-09T19:12:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTc1NjU2NQ=="}], "type": "inlineReview"}, {"oid": "b8f08571acdc719401cb79d6ca74ae6772fb9a5d", "url": "https://github.com/cryostatio/cryostat/commit/b8f08571acdc719401cb79d6ca74ae6772fb9a5d", "message": "check for invalid PATCH attributes", "committedDate": "2020-09-09T19:11:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg2NTAxMw==", "url": "https://github.com/cryostatio/cryostat/pull/254#discussion_r485865013", "bodyText": "This doesn't quite work as intended - parseBoolean is true if the input string is \"true\", case insensitive, and false for all other inputs. It doesn't throw.\nOn a related note, it would be good to exercise these validations with unit tests.", "author": "andrewazores", "createdAt": "2020-09-09T19:34:30Z", "path": "src/main/java/com/redhat/rhjmc/containerjfr/net/web/handlers/TargetRecordingOptionsPatchHandler.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*-\n+ * #%L\n+ * Container JFR\n+ * %%\n+ * Copyright (C) 2020 Red Hat, Inc.\n+ * %%\n+ * The Universal Permissive License (UPL), Version 1.0\n+ *\n+ * Subject to the condition set forth below, permission is hereby granted to any\n+ * person obtaining a copy of this software, associated documentation and/or data\n+ * (collectively the \"Software\"), free of charge and under any and all copyright\n+ * rights in the Software, and any and all patent rights owned or freely\n+ * licensable by each licensor hereunder covering either (i) the unmodified\n+ * Software as contributed to or provided by such licensor, or (ii) the Larger\n+ * Works (as defined below), to deal in both\n+ *\n+ * (a) the Software, and\n+ * (b) any piece of software and/or hardware listed in the lrgrwrks.txt file if\n+ * one is included with the Software (each a \"Larger Work\" to which the Software\n+ * is contributed by such licensors),\n+ *\n+ * without restriction, including without limitation the rights to copy, create\n+ * derivative works of, display, perform, and distribute the Software and make,\n+ * use, sell, offer for sale, import, export, have made, and have sold the\n+ * Software and the Larger Work(s), and to sublicense the foregoing rights on\n+ * either these or other terms.\n+ *\n+ * This license is subject to the following condition:\n+ * The above copyright notice and either this complete permission notice or at\n+ * a minimum a reference to the UPL must be included in all copies or\n+ * substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ * #L%\n+ */\n+package com.redhat.rhjmc.containerjfr.net.web.handlers;\n+\n+import java.util.Arrays;\n+import java.util.Map;\n+\n+import javax.inject.Inject;\n+\n+import org.openjdk.jmc.flightrecorder.configuration.recording.RecordingOptionsBuilder;\n+\n+import com.google.gson.Gson;\n+\n+import com.redhat.rhjmc.containerjfr.commands.internal.RecordingOptionsBuilderFactory;\n+import com.redhat.rhjmc.containerjfr.core.RecordingOptionsCustomizer;\n+import com.redhat.rhjmc.containerjfr.core.RecordingOptionsCustomizer.OptionKey;\n+import com.redhat.rhjmc.containerjfr.net.AuthManager;\n+import com.redhat.rhjmc.containerjfr.net.TargetConnectionManager;\n+\n+import io.vertx.core.MultiMap;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.ext.web.RoutingContext;\n+import io.vertx.ext.web.handler.impl.HttpStatusException;\n+\n+class TargetRecordingOptionsPatchHandler extends AbstractAuthenticatedRequestHandler {\n+\n+    static final String PATH = TargetRecordingOptionsGetHandler.PATH;\n+    private final RecordingOptionsCustomizer customizer;\n+    private final TargetConnectionManager connectionManager;\n+    private final RecordingOptionsBuilderFactory recordingOptionsBuilderFactory;\n+    private final Gson gson;\n+\n+    @Inject\n+    TargetRecordingOptionsPatchHandler(\n+            AuthManager auth,\n+            RecordingOptionsCustomizer customizer,\n+            TargetConnectionManager connectionManager,\n+            RecordingOptionsBuilderFactory recordingOptionsBuilderFactory,\n+            Gson gson) {\n+        super(auth);\n+        this.customizer = customizer;\n+        this.connectionManager = connectionManager;\n+        this.recordingOptionsBuilderFactory = recordingOptionsBuilderFactory;\n+        this.gson = gson;\n+    }\n+\n+    @Override\n+    public HttpMethod httpMethod() {\n+        return HttpMethod.PATCH;\n+    }\n+\n+    @Override\n+    public String path() {\n+        return PATH;\n+    }\n+\n+    @Override\n+    void handleAuthenticated(RoutingContext ctx) throws Exception {\n+        MultiMap attrs = ctx.request().formAttributes();\n+        if (attrs.contains(\"toDisk\")) {\n+            try {\n+                Boolean.parseBoolean(attrs.get(\"toDisk\"));", "originalCommit": "b8f08571acdc719401cb79d6ca74ae6772fb9a5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkxMDg0Mw==", "url": "https://github.com/cryostatio/cryostat/pull/254#discussion_r485910843", "bodyText": "I just realized that the POST handler should probably also do validation right?", "author": "Alexjsenn", "createdAt": "2020-09-09T20:44:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg2NTAxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk0NzYwMA==", "url": "https://github.com/cryostatio/cryostat/pull/254#discussion_r485947600", "bodyText": "Yes, it probably should", "author": "andrewazores", "createdAt": "2020-09-09T22:04:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg2NTAxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQyMTgwNA==", "url": "https://github.com/cryostatio/cryostat/pull/254#discussion_r486421804", "bodyText": "Ok, there are now tests for the validations I added. I also added validation for the boolean value in TargetRecordingPostHandler, I throw a NumberFormatException when the boolean can't be parsed to handle it together with the other exceptions, but I realize this is probably not the best way, Im just not sure what exception I should use.", "author": "Alexjsenn", "createdAt": "2020-09-10T15:10:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg2NTAxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ1MTU1OA==", "url": "https://github.com/cryostatio/cryostat/pull/254#discussion_r486451558", "bodyText": "I agree that NumberFormatException seems like not quite the right fit here, although I don't think it's too important anyway - in any case, this will be an uncaught exception that is then later on caught by the AbstractAuthenticatedRequestHandler and turned into a response with status 500, so all the exception type (and message) does is become part of the response status message. That will probably be displayed to end users in the end, but clients (as in, the web-client, operator, etc. - other automated clients) should only really care about the status code.\nMaybe just IllegalArgumentException is fine, unless you want to create a custom one like BooleanValueException or BooleanFormatException. That would be nice, but it's probably overkill here.", "author": "andrewazores", "createdAt": "2020-09-10T15:51:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg2NTAxMw=="}], "type": "inlineReview"}, {"oid": "bb13f57ef191baac3ebb30a054b0b925f594e3cd", "url": "https://github.com/cryostatio/cryostat/commit/bb13f57ef191baac3ebb30a054b0b925f594e3cd", "message": "fix boolean check", "committedDate": "2020-09-09T20:04:55Z", "type": "commit"}, {"oid": "0e8b05fccb77d20ba37a91105fcd4a407417df94", "url": "https://github.com/cryostatio/cryostat/commit/0e8b05fccb77d20ba37a91105fcd4a407417df94", "message": "add unit test for invalid arguments to PATCH request", "committedDate": "2020-09-10T15:07:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ1NDY5Mg==", "url": "https://github.com/cryostatio/cryostat/pull/254#discussion_r486454692", "bodyText": "I'd like to see a few more cases covered here - toDisk: '', maxAge: '', toDisk: null, toDisk: T, maxAge: 0.5, maxAge: 1e3 for example. And since both this handler and the TargetRecordingsPostHandler share similar validation implementations, that handler should also have tests similar to this one.", "author": "andrewazores", "createdAt": "2020-09-10T15:55:58Z", "path": "src/test/java/com/redhat/rhjmc/containerjfr/net/web/handlers/TargetRecordingOptionsPatchHandlerTest.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*-\n+ * #%L\n+ * Container JFR\n+ * %%\n+ * Copyright (C) 2020 Red Hat, Inc.\n+ * %%\n+ * The Universal Permissive License (UPL), Version 1.0\n+ *\n+ * Subject to the condition set forth below, permission is hereby granted to any\n+ * person obtaining a copy of this software, associated documentation and/or data\n+ * (collectively the \"Software\"), free of charge and under any and all copyright\n+ * rights in the Software, and any and all patent rights owned or freely\n+ * licensable by each licensor hereunder covering either (i) the unmodified\n+ * Software as contributed to or provided by such licensor, or (ii) the Larger\n+ * Works (as defined below), to deal in both\n+ *\n+ * (a) the Software, and\n+ * (b) any piece of software and/or hardware listed in the lrgrwrks.txt file if\n+ * one is included with the Software (each a \"Larger Work\" to which the Software\n+ * is contributed by such licensors),\n+ *\n+ * without restriction, including without limitation the rights to copy, create\n+ * derivative works of, display, perform, and distribute the Software and make,\n+ * use, sell, offer for sale, import, export, have made, and have sold the\n+ * Software and the Larger Work(s), and to sublicense the foregoing rights on\n+ * either these or other terms.\n+ *\n+ * This license is subject to the following condition:\n+ * The above copyright notice and either this complete permission notice or at\n+ * a minimum a reference to the UPL must be included in all copies or\n+ * substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ * #L%\n+ */\n+package com.redhat.rhjmc.containerjfr.net.web.handlers;\n+\n+import java.util.Map;\n+import java.util.stream.Stream;\n+\n+import org.hamcrest.MatcherAssert;\n+import org.hamcrest.Matchers;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.mockito.stubbing.Answer;\n+\n+import org.openjdk.jmc.common.unit.IConstrainedMap;\n+import org.openjdk.jmc.flightrecorder.configuration.recording.RecordingOptionsBuilder;\n+import org.openjdk.jmc.rjmx.services.jfr.IFlightRecorderService;\n+\n+import com.google.gson.Gson;\n+\n+import com.redhat.rhjmc.containerjfr.commands.internal.RecordingOptionsBuilderFactory;\n+import com.redhat.rhjmc.containerjfr.core.RecordingOptionsCustomizer;\n+import com.redhat.rhjmc.containerjfr.core.RecordingOptionsCustomizer.OptionKey;\n+import com.redhat.rhjmc.containerjfr.core.net.JFRConnection;\n+import com.redhat.rhjmc.containerjfr.net.AuthManager;\n+import com.redhat.rhjmc.containerjfr.net.ConnectionDescriptor;\n+import com.redhat.rhjmc.containerjfr.net.TargetConnectionManager;\n+import com.redhat.rhjmc.containerjfr.net.TargetConnectionManager.ConnectedTask;\n+\n+import io.vertx.core.MultiMap;\n+import io.vertx.core.http.HttpMethod;\n+import io.vertx.core.http.HttpServerRequest;\n+import io.vertx.core.http.HttpServerResponse;\n+import io.vertx.ext.web.RoutingContext;\n+import io.vertx.ext.web.handler.impl.HttpStatusException;\n+\n+@ExtendWith(MockitoExtension.class)\n+class TargetRecordingOptionsPatchHandlerTest {\n+\n+    TargetRecordingOptionsPatchHandler handler;\n+    @Mock AuthManager auth;\n+    @Mock RecordingOptionsCustomizer customizer;\n+    @Mock TargetConnectionManager connectionManager;\n+    @Mock RecordingOptionsBuilderFactory recordingOptionsBuilderFactory;\n+    @Mock RecordingOptionsBuilder builder;\n+    @Mock IConstrainedMap<String> recordingOptions;\n+    @Mock JFRConnection jfrConnection;\n+    @Mock Gson gson;\n+\n+    @BeforeEach\n+    void setup() {\n+        this.handler =\n+                new TargetRecordingOptionsPatchHandler(\n+                        auth, customizer, connectionManager, recordingOptionsBuilderFactory, gson);\n+    }\n+\n+    @Test\n+    void shouldHandleGETRequest() {\n+        MatcherAssert.assertThat(handler.httpMethod(), Matchers.equalTo(HttpMethod.PATCH));\n+    }\n+\n+    @Test\n+    void shouldHandleCorrectPath() {\n+        MatcherAssert.assertThat(\n+                handler.path(), Matchers.equalTo(\"/api/v1/targets/:targetId/recordingOptions\"));\n+    }\n+\n+    @Test\n+    void shouldSetRecordingOptions() throws Exception {\n+        Map<String, String> defaultValues =\n+                Map.of(\"toDisk\", \"true\", \"maxAge\", \"50\", \"maxSize\", \"32\");\n+        Mockito.when(recordingOptionsBuilderFactory.create(Mockito.any())).thenReturn(builder);\n+        Mockito.when(builder.build()).thenReturn(recordingOptions);\n+        Mockito.when(recordingOptions.get(\"toDisk\")).thenReturn(defaultValues.get(\"toDisk\"));\n+        Mockito.when(recordingOptions.get(\"maxAge\")).thenReturn(defaultValues.get(\"maxAge\"));\n+        Mockito.when(recordingOptions.get(\"maxSize\")).thenReturn(defaultValues.get(\"maxSize\"));\n+\n+        MultiMap requestAttrs = MultiMap.caseInsensitiveMultiMap();\n+        requestAttrs.addAll(defaultValues);\n+\n+        Mockito.when(\n+                        connectionManager.executeConnectedTask(\n+                                Mockito.any(ConnectionDescriptor.class), Mockito.any()))\n+                .thenAnswer(\n+                        new Answer<>() {\n+                            @Override\n+                            public Map answer(InvocationOnMock args) throws Throwable {\n+                                ConnectedTask ct = (ConnectedTask) args.getArguments()[1];\n+                                return (Map) ct.execute(jfrConnection);\n+                            }\n+                        });\n+\n+        RoutingContext ctx = Mockito.mock(RoutingContext.class);\n+        Mockito.when(ctx.pathParam(\"targetId\")).thenReturn(\"foo:9091\");\n+        HttpServerRequest req = Mockito.mock(HttpServerRequest.class);\n+        Mockito.when(ctx.request()).thenReturn(req);\n+        Mockito.when(req.headers()).thenReturn(MultiMap.caseInsensitiveMultiMap());\n+        Mockito.when(req.formAttributes()).thenReturn(requestAttrs);\n+        HttpServerResponse resp = Mockito.mock(HttpServerResponse.class);\n+        Mockito.when(ctx.response()).thenReturn(resp);\n+        IFlightRecorderService service = Mockito.mock(IFlightRecorderService.class);\n+        Mockito.when(jfrConnection.getService()).thenReturn(service);\n+\n+        handler.handleAuthenticated(ctx);\n+\n+        for (var entry : requestAttrs.entries()) {\n+            var key = OptionKey.fromOptionName(entry.getKey());\n+            Mockito.verify(customizer).set(key.get(), entry.getValue());\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"getRequestMaps\")\n+    void shouldThrowInvalidOptionException(Map<String, String> defaultValues) throws Exception {\n+        MultiMap requestAttrs = MultiMap.caseInsensitiveMultiMap();\n+        requestAttrs.addAll(defaultValues);\n+\n+        RoutingContext ctx = Mockito.mock(RoutingContext.class);\n+        HttpServerRequest req = Mockito.mock(HttpServerRequest.class);\n+        Mockito.when(ctx.request()).thenReturn(req);\n+        Mockito.when(req.formAttributes()).thenReturn(requestAttrs);\n+        HttpStatusException ex =\n+                Assertions.assertThrows(\n+                        HttpStatusException.class, () -> handler.handleAuthenticated(ctx));\n+        MatcherAssert.assertThat(ex.getStatusCode(), Matchers.equalTo(400));\n+    }\n+\n+    private static Stream<Map<String, String>> getRequestMaps() {\n+        return Stream.of(\n+                Map.of(\"toDisk\", \"5\"), Map.of(\"maxAge\", \"true\"), Map.of(\"maxSize\", \"false\"));", "originalCommit": "0e8b05fccb77d20ba37a91105fcd4a407417df94", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjUyMTg5Ng==", "url": "https://github.com/cryostatio/cryostat/pull/254#discussion_r486521896", "bodyText": "Ok, there are more cases for both handlers.", "author": "Alexjsenn", "createdAt": "2020-09-10T17:43:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ1NDY5Mg=="}], "type": "inlineReview"}, {"oid": "98767d8cb0f728017b31e1b9d235ce1607269577", "url": "https://github.com/cryostatio/cryostat/commit/98767d8cb0f728017b31e1b9d235ce1607269577", "message": "add test cases for invalid recording options", "committedDate": "2020-09-10T17:41:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU1MDcyNA==", "url": "https://github.com/cryostatio/cryostat/pull/254#discussion_r486550724", "bodyText": "The other handler looks like it directly throws an HttpStatusException, but this one is still a NumberFormatException - they should probably be consistent with each other", "author": "andrewazores", "createdAt": "2020-09-10T18:28:31Z", "path": "src/main/java/com/redhat/rhjmc/containerjfr/net/web/handlers/TargetRecordingsPostHandler.java", "diffHunk": "@@ -162,6 +162,22 @@ void handleAuthenticated(RoutingContext ctx) throws Exception {\n                                                     TimeUnit.SECONDS.toMillis(\n                                                             Long.parseLong(attrs.get(\"duration\"))));\n                                 }\n+                                if (attrs.contains(\"toDisk\")) {\n+                                    Pattern bool = Pattern.compile(\"true|false\");\n+                                    Matcher m = bool.matcher(attrs.get(\"toDisk\"));\n+                                    if (!m.find())\n+                                        throw new NumberFormatException(", "originalCommit": "98767d8cb0f728017b31e1b9d235ce1607269577", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU4MjM0Mw==", "url": "https://github.com/cryostatio/cryostat/pull/254#discussion_r486582343", "bodyText": "I had issues throwing HttpStatusExceptions inside executeConnectedTask, so I changed the PATCH handler to match this one.", "author": "Alexjsenn", "createdAt": "2020-09-10T19:25:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU1MDcyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU4NDY3MA==", "url": "https://github.com/cryostatio/cryostat/pull/254#discussion_r486584670", "bodyText": "What kind of issues?\nI still think the NumberFormatException is out of place when parsing a boolean.", "author": "andrewazores", "createdAt": "2020-09-10T19:29:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU1MDcyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYwNTAxNA==", "url": "https://github.com/cryostatio/cryostat/pull/254#discussion_r486605014", "bodyText": "Ok, I went back to the old format, and throw a HttpStatusException for the boolean instead of the NumberFormatException", "author": "Alexjsenn", "createdAt": "2020-09-10T20:10:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU1MDcyNA=="}], "type": "inlineReview"}, {"oid": "715491a8a859bacecc760fcdd6dea1db8af63717", "url": "https://github.com/cryostatio/cryostat/commit/715491a8a859bacecc760fcdd6dea1db8af63717", "message": "add exception catch block in patch handler", "committedDate": "2020-09-10T19:24:33Z", "type": "commit"}, {"oid": "cfcc1033938af17610ce5a6907307797aeeb983f", "url": "https://github.com/cryostatio/cryostat/commit/cfcc1033938af17610ce5a6907307797aeeb983f", "message": "modify exeption format", "committedDate": "2020-09-10T20:09:08Z", "type": "commit"}]}