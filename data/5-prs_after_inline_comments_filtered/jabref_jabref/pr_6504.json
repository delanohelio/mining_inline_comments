{"pr_number": 6504, "pr_title": "Enable users to simultaneously search all SearchBasedFetchers", "pr_createdAt": "2020-05-20T13:56:34Z", "pr_url": "https://github.com/JabRef/jabref/pull/6504", "timeline": [{"oid": "703d0002c844d03332031dd237aba8e7dbfa7ac2", "url": "https://github.com/JabRef/jabref/commit/703d0002c844d03332031dd237aba8e7dbfa7ac2", "message": "Add CompositeSearchBasedFetcher to offer the option to query all libraries together in the Web Search Pane.\n\nSigned-off-by: DominikVoigt <dominik.ingo.voigt@gmail.com>", "committedDate": "2020-05-19T17:41:25Z", "type": "commit"}, {"oid": "3045da14e7eabfe720dbf5e7b7c5cfde7277d4d5", "url": "https://github.com/JabRef/jabref/commit/3045da14e7eabfe720dbf5e7b7c5cfde7277d4d5", "message": "Add Test for CompositeSearchBasedFetcher.\n\nSigned-off-by: DominikVoigt <dominik.ingo.voigt@gmail.com>", "committedDate": "2020-05-19T18:24:56Z", "type": "commit"}, {"oid": "c6838a562c7ed1fd7b5d28de8013606f03834254", "url": "https://github.com/JabRef/jabref/commit/c6838a562c7ed1fd7b5d28de8013606f03834254", "message": "Reformat stream to increase readability.\n\nSigned-off-by: DominikVoigt <dominik.ingo.voigt@gmail.com>", "committedDate": "2020-05-20T09:40:19Z", "type": "commit"}, {"oid": "81c4d817d7626183c734825a3d29e45e7234f62b", "url": "https://github.com/JabRef/jabref/commit/81c4d817d7626183c734825a3d29e45e7234f62b", "message": "Add CHANGELOG entry under Added.\nAdd linebreak for checkstyle.\nModify Testcase.\n\nSigned-off-by: DominikVoigt <dominik.ingo.voigt@gmail.com>", "committedDate": "2020-05-20T13:56:11Z", "type": "commit"}, {"oid": "a6cf33add066b40f18b65264ee41dcc9d224bf09", "url": "https://github.com/JabRef/jabref/commit/a6cf33add066b40f18b65264ee41dcc9d224bf09", "message": "Add Linebreak to CHANGELOG.\n\nSigned-off-by: DominikVoigt <dominik.ingo.voigt@gmail.com>", "committedDate": "2020-05-20T13:59:40Z", "type": "commit"}, {"oid": "abf47018b0cdf1500b103fe1f5286834267edd7f", "url": "https://github.com/JabRef/jabref/commit/abf47018b0cdf1500b103fe1f5286834267edd7f", "message": "Add Linebreak to CompositeSearchBasedFetcherTest to fix checkstyle issue.\n\nSigned-off-by: DominikVoigt <dominik.ingo.voigt@gmail.com>", "committedDate": "2020-05-21T19:21:06Z", "type": "commit"}, {"oid": "51ec0204188541f51b61700502674bf00ab1a758", "url": "https://github.com/JabRef/jabref/commit/51ec0204188541f51b61700502674bf00ab1a758", "message": "Update CHANGELOG.md\n\nCo-authored-by: Christoph <cschwentker@gmail.com>", "committedDate": "2020-05-22T17:14:08Z", "type": "commit"}, {"oid": "55ac9be703628c668bef0554b755c03c2347a493", "url": "https://github.com/JabRef/jabref/commit/55ac9be703628c668bef0554b755c03c2347a493", "message": "Add parameterized tests for CompositeSearchBasedFetcher.\n\nSigned-off-by: DominikVoigt <dominik.ingo.voigt@gmail.com>", "committedDate": "2020-05-23T18:35:24Z", "type": "commit"}, {"oid": "c3c0b65f44a39eecf6a39ee1dac8dddf1f978cc1", "url": "https://github.com/JabRef/jabref/commit/c3c0b65f44a39eecf6a39ee1dac8dddf1f978cc1", "message": "Add better parameterized test naming.\nAdd test case: empty set of fetchers\n\nSigned-off-by: DominikVoigt <dominik.ingo.voigt@gmail.com>", "committedDate": "2020-05-23T19:28:52Z", "type": "commit"}, {"oid": "7fa24e48d63a50a5b4551baf20fd1926411fc6ea", "url": "https://github.com/JabRef/jabref/commit/7fa24e48d63a50a5b4551baf20fd1926411fc6ea", "message": "Implement requested change.\n\nSigned-off-by: DominikVoigt <dominik.ingo.voigt@gmail.com>", "committedDate": "2020-05-24T10:23:09Z", "type": "commit"}, {"oid": "1947b1ff057b3b7fa74d6662e43ddca4277766b0", "url": "https://github.com/JabRef/jabref/commit/1947b1ff057b3b7fa74d6662e43ddca4277766b0", "message": "Merge branch 'feature/add-option-to-fetch-from-all-sources' of https://github.com/DominikVoigt/jabref into feature/add-option-to-fetch-from-all-sources", "committedDate": "2020-05-24T10:24:41Z", "type": "commit"}, {"oid": "836fc31da990b370a871f1927949bf71b62499fe", "url": "https://github.com/JabRef/jabref/commit/836fc31da990b370a871f1927949bf71b62499fe", "message": "Merge branch 'master' into feature/add-option-to-fetch-from-all-sources", "committedDate": "2020-05-25T12:01:51Z", "type": "commit"}, {"oid": "1acd5aa0bfd310c8fda79fecde126200c3bfa046", "url": "https://github.com/JabRef/jabref/commit/1acd5aa0bfd310c8fda79fecde126200c3bfa046", "message": "Remove GrobidCitationFetcher from test set as it was removed from set in the Webfetcher.\n\nSigned-off-by: DominikVoigt <dominik.ingo.voigt@gmail.com>", "committedDate": "2020-05-25T12:06:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk5MTc3Mg==", "url": "https://github.com/JabRef/jabref/pull/6504#discussion_r429991772", "bodyText": "Maybe, debug would be more appropriate then?", "author": "koppor", "createdAt": "2020-05-25T15:31:21Z", "path": "src/test/java/org/jabref/logic/importer/fetcher/CompositeSearchBasedFetcherTest.java", "diffHunk": "@@ -0,0 +1,110 @@\n+package org.jabref.logic.importer.fetcher;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Stream;\n+\n+import org.jabref.logic.bibtex.FieldContentFormatterPreferences;\n+import org.jabref.logic.importer.FetcherException;\n+import org.jabref.logic.importer.ImportFormatPreferences;\n+import org.jabref.logic.importer.SearchBasedFetcher;\n+import org.jabref.model.entry.BibEntry;\n+import org.jabref.testutils.category.FetcherTest;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+@FetcherTest\n+public class CompositeSearchBasedFetcherTest {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(CompositeSearchBasedFetcherTest.class);\n+\n+    @Test\n+    public void performSearchWithoutFetchers() {\n+        Set<SearchBasedFetcher> empty = new HashSet<>();\n+        CompositeSearchBasedFetcher fetcher = new CompositeSearchBasedFetcher(empty);\n+\n+        List<BibEntry> result = fetcher.performSearch(\"quantum\");\n+\n+        Assertions.assertTrue(result.isEmpty());\n+    }\n+\n+    @ParameterizedTest(name = \"Perform Search on empty query.\")\n+    @MethodSource(\"performSearchParameters\")\n+    public void performSearchOnEmptyQuery(Set<SearchBasedFetcher> fetchers) {\n+        CompositeSearchBasedFetcher compositeFetcher = new CompositeSearchBasedFetcher(fetchers);\n+\n+        List<BibEntry> queryResult = compositeFetcher.performSearch(\"\");\n+\n+        Assertions.assertTrue(queryResult.isEmpty());\n+    }\n+\n+    @ParameterizedTest(name = \"Perform search on query \\\"quantum\\\". Using the CompositeFetcher of the following \" +\n+            \"Fetchers: {arguments}\")\n+    @MethodSource(\"performSearchParameters\")\n+    public void performSearchOnNonEmptyQuery(Set<SearchBasedFetcher> fetchers) {\n+        CompositeSearchBasedFetcher compositeFetcher = new CompositeSearchBasedFetcher(fetchers);\n+\n+        List<BibEntry> compositeResult = compositeFetcher.performSearch(\"quantum\");\n+\n+        for (SearchBasedFetcher fetcher : fetchers) {\n+            try {\n+                Assertions.assertTrue(compositeResult.containsAll(fetcher.performSearch(\"quantum\")));\n+            } catch (FetcherException e) {\n+                /* We catch the Fetcher exception here, since the failing fetcher also fails in the CompositeFetcher\n+                 * and just leads to no additional results in the returned list. Therefor the test should not fail\n+                 * due to the fetcher exception\n+                 */\n+                LOGGER.warn(String.format(\"Fetcher %s failed \", fetcher.getName()), e);", "originalCommit": "1acd5aa0bfd310c8fda79fecde126200c3bfa046", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk5MTg2MQ==", "url": "https://github.com/JabRef/jabref/pull/6504#discussion_r429991861", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                             * and just leads to no additional results in the returned list. Therefor the test should not fail\n          \n          \n            \n                             * and just leads to no additional results in the returned list. Therefore the test should not fail", "author": "koppor", "createdAt": "2020-05-25T15:31:34Z", "path": "src/test/java/org/jabref/logic/importer/fetcher/CompositeSearchBasedFetcherTest.java", "diffHunk": "@@ -0,0 +1,110 @@\n+package org.jabref.logic.importer.fetcher;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Stream;\n+\n+import org.jabref.logic.bibtex.FieldContentFormatterPreferences;\n+import org.jabref.logic.importer.FetcherException;\n+import org.jabref.logic.importer.ImportFormatPreferences;\n+import org.jabref.logic.importer.SearchBasedFetcher;\n+import org.jabref.model.entry.BibEntry;\n+import org.jabref.testutils.category.FetcherTest;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+@FetcherTest\n+public class CompositeSearchBasedFetcherTest {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(CompositeSearchBasedFetcherTest.class);\n+\n+    @Test\n+    public void performSearchWithoutFetchers() {\n+        Set<SearchBasedFetcher> empty = new HashSet<>();\n+        CompositeSearchBasedFetcher fetcher = new CompositeSearchBasedFetcher(empty);\n+\n+        List<BibEntry> result = fetcher.performSearch(\"quantum\");\n+\n+        Assertions.assertTrue(result.isEmpty());\n+    }\n+\n+    @ParameterizedTest(name = \"Perform Search on empty query.\")\n+    @MethodSource(\"performSearchParameters\")\n+    public void performSearchOnEmptyQuery(Set<SearchBasedFetcher> fetchers) {\n+        CompositeSearchBasedFetcher compositeFetcher = new CompositeSearchBasedFetcher(fetchers);\n+\n+        List<BibEntry> queryResult = compositeFetcher.performSearch(\"\");\n+\n+        Assertions.assertTrue(queryResult.isEmpty());\n+    }\n+\n+    @ParameterizedTest(name = \"Perform search on query \\\"quantum\\\". Using the CompositeFetcher of the following \" +\n+            \"Fetchers: {arguments}\")\n+    @MethodSource(\"performSearchParameters\")\n+    public void performSearchOnNonEmptyQuery(Set<SearchBasedFetcher> fetchers) {\n+        CompositeSearchBasedFetcher compositeFetcher = new CompositeSearchBasedFetcher(fetchers);\n+\n+        List<BibEntry> compositeResult = compositeFetcher.performSearch(\"quantum\");\n+\n+        for (SearchBasedFetcher fetcher : fetchers) {\n+            try {\n+                Assertions.assertTrue(compositeResult.containsAll(fetcher.performSearch(\"quantum\")));\n+            } catch (FetcherException e) {\n+                /* We catch the Fetcher exception here, since the failing fetcher also fails in the CompositeFetcher\n+                 * and just leads to no additional results in the returned list. Therefor the test should not fail", "originalCommit": "1acd5aa0bfd310c8fda79fecde126200c3bfa046", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk5MjAwOA==", "url": "https://github.com/JabRef/jabref/pull/6504#discussion_r429992008", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * This method provides other methods with different sized sets of Searchbased fetchers wrapped in Arguments.\n          \n          \n            \n                 * This method provides other methods with different sized sets of search-based fetchers wrapped in arguments.", "author": "koppor", "createdAt": "2020-05-25T15:32:01Z", "path": "src/test/java/org/jabref/logic/importer/fetcher/CompositeSearchBasedFetcherTest.java", "diffHunk": "@@ -0,0 +1,110 @@\n+package org.jabref.logic.importer.fetcher;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Stream;\n+\n+import org.jabref.logic.bibtex.FieldContentFormatterPreferences;\n+import org.jabref.logic.importer.FetcherException;\n+import org.jabref.logic.importer.ImportFormatPreferences;\n+import org.jabref.logic.importer.SearchBasedFetcher;\n+import org.jabref.model.entry.BibEntry;\n+import org.jabref.testutils.category.FetcherTest;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+@FetcherTest\n+public class CompositeSearchBasedFetcherTest {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(CompositeSearchBasedFetcherTest.class);\n+\n+    @Test\n+    public void performSearchWithoutFetchers() {\n+        Set<SearchBasedFetcher> empty = new HashSet<>();\n+        CompositeSearchBasedFetcher fetcher = new CompositeSearchBasedFetcher(empty);\n+\n+        List<BibEntry> result = fetcher.performSearch(\"quantum\");\n+\n+        Assertions.assertTrue(result.isEmpty());\n+    }\n+\n+    @ParameterizedTest(name = \"Perform Search on empty query.\")\n+    @MethodSource(\"performSearchParameters\")\n+    public void performSearchOnEmptyQuery(Set<SearchBasedFetcher> fetchers) {\n+        CompositeSearchBasedFetcher compositeFetcher = new CompositeSearchBasedFetcher(fetchers);\n+\n+        List<BibEntry> queryResult = compositeFetcher.performSearch(\"\");\n+\n+        Assertions.assertTrue(queryResult.isEmpty());\n+    }\n+\n+    @ParameterizedTest(name = \"Perform search on query \\\"quantum\\\". Using the CompositeFetcher of the following \" +\n+            \"Fetchers: {arguments}\")\n+    @MethodSource(\"performSearchParameters\")\n+    public void performSearchOnNonEmptyQuery(Set<SearchBasedFetcher> fetchers) {\n+        CompositeSearchBasedFetcher compositeFetcher = new CompositeSearchBasedFetcher(fetchers);\n+\n+        List<BibEntry> compositeResult = compositeFetcher.performSearch(\"quantum\");\n+\n+        for (SearchBasedFetcher fetcher : fetchers) {\n+            try {\n+                Assertions.assertTrue(compositeResult.containsAll(fetcher.performSearch(\"quantum\")));\n+            } catch (FetcherException e) {\n+                /* We catch the Fetcher exception here, since the failing fetcher also fails in the CompositeFetcher\n+                 * and just leads to no additional results in the returned list. Therefor the test should not fail\n+                 * due to the fetcher exception\n+                 */\n+                LOGGER.warn(String.format(\"Fetcher %s failed \", fetcher.getName()), e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This method provides other methods with different sized sets of Searchbased fetchers wrapped in Arguments.", "originalCommit": "1acd5aa0bfd310c8fda79fecde126200c3bfa046", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk5MjEwMg==", "url": "https://github.com/JabRef/jabref/pull/6504#discussion_r429992102", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @return A stream of Arguments wrapping the sets.\n          \n          \n            \n                 * @return A stream of Arguments wrapping sets of fetchers.", "author": "koppor", "createdAt": "2020-05-25T15:32:15Z", "path": "src/test/java/org/jabref/logic/importer/fetcher/CompositeSearchBasedFetcherTest.java", "diffHunk": "@@ -0,0 +1,110 @@\n+package org.jabref.logic.importer.fetcher;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Stream;\n+\n+import org.jabref.logic.bibtex.FieldContentFormatterPreferences;\n+import org.jabref.logic.importer.FetcherException;\n+import org.jabref.logic.importer.ImportFormatPreferences;\n+import org.jabref.logic.importer.SearchBasedFetcher;\n+import org.jabref.model.entry.BibEntry;\n+import org.jabref.testutils.category.FetcherTest;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+@FetcherTest\n+public class CompositeSearchBasedFetcherTest {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(CompositeSearchBasedFetcherTest.class);\n+\n+    @Test\n+    public void performSearchWithoutFetchers() {\n+        Set<SearchBasedFetcher> empty = new HashSet<>();\n+        CompositeSearchBasedFetcher fetcher = new CompositeSearchBasedFetcher(empty);\n+\n+        List<BibEntry> result = fetcher.performSearch(\"quantum\");\n+\n+        Assertions.assertTrue(result.isEmpty());\n+    }\n+\n+    @ParameterizedTest(name = \"Perform Search on empty query.\")\n+    @MethodSource(\"performSearchParameters\")\n+    public void performSearchOnEmptyQuery(Set<SearchBasedFetcher> fetchers) {\n+        CompositeSearchBasedFetcher compositeFetcher = new CompositeSearchBasedFetcher(fetchers);\n+\n+        List<BibEntry> queryResult = compositeFetcher.performSearch(\"\");\n+\n+        Assertions.assertTrue(queryResult.isEmpty());\n+    }\n+\n+    @ParameterizedTest(name = \"Perform search on query \\\"quantum\\\". Using the CompositeFetcher of the following \" +\n+            \"Fetchers: {arguments}\")\n+    @MethodSource(\"performSearchParameters\")\n+    public void performSearchOnNonEmptyQuery(Set<SearchBasedFetcher> fetchers) {\n+        CompositeSearchBasedFetcher compositeFetcher = new CompositeSearchBasedFetcher(fetchers);\n+\n+        List<BibEntry> compositeResult = compositeFetcher.performSearch(\"quantum\");\n+\n+        for (SearchBasedFetcher fetcher : fetchers) {\n+            try {\n+                Assertions.assertTrue(compositeResult.containsAll(fetcher.performSearch(\"quantum\")));\n+            } catch (FetcherException e) {\n+                /* We catch the Fetcher exception here, since the failing fetcher also fails in the CompositeFetcher\n+                 * and just leads to no additional results in the returned list. Therefor the test should not fail\n+                 * due to the fetcher exception\n+                 */\n+                LOGGER.warn(String.format(\"Fetcher %s failed \", fetcher.getName()), e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This method provides other methods with different sized sets of Searchbased fetchers wrapped in Arguments.\n+     *\n+     * @return A stream of Arguments wrapping the sets.", "originalCommit": "1acd5aa0bfd310c8fda79fecde126200c3bfa046", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk5MjY1NQ==", "url": "https://github.com/JabRef/jabref/pull/6504#discussion_r429992655", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    /* Disabled due to issue regarding Comparison: Title fields of the entries that otherwise are equivalent differ\n          \n          \n            \n                    /* Disabled due to an issue regarding comparison: Title fields of the entries that otherwise are equivalent differ", "author": "koppor", "createdAt": "2020-05-25T15:33:42Z", "path": "src/test/java/org/jabref/logic/importer/fetcher/CompositeSearchBasedFetcherTest.java", "diffHunk": "@@ -0,0 +1,110 @@\n+package org.jabref.logic.importer.fetcher;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Stream;\n+\n+import org.jabref.logic.bibtex.FieldContentFormatterPreferences;\n+import org.jabref.logic.importer.FetcherException;\n+import org.jabref.logic.importer.ImportFormatPreferences;\n+import org.jabref.logic.importer.SearchBasedFetcher;\n+import org.jabref.model.entry.BibEntry;\n+import org.jabref.testutils.category.FetcherTest;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+@FetcherTest\n+public class CompositeSearchBasedFetcherTest {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(CompositeSearchBasedFetcherTest.class);\n+\n+    @Test\n+    public void performSearchWithoutFetchers() {\n+        Set<SearchBasedFetcher> empty = new HashSet<>();\n+        CompositeSearchBasedFetcher fetcher = new CompositeSearchBasedFetcher(empty);\n+\n+        List<BibEntry> result = fetcher.performSearch(\"quantum\");\n+\n+        Assertions.assertTrue(result.isEmpty());\n+    }\n+\n+    @ParameterizedTest(name = \"Perform Search on empty query.\")\n+    @MethodSource(\"performSearchParameters\")\n+    public void performSearchOnEmptyQuery(Set<SearchBasedFetcher> fetchers) {\n+        CompositeSearchBasedFetcher compositeFetcher = new CompositeSearchBasedFetcher(fetchers);\n+\n+        List<BibEntry> queryResult = compositeFetcher.performSearch(\"\");\n+\n+        Assertions.assertTrue(queryResult.isEmpty());\n+    }\n+\n+    @ParameterizedTest(name = \"Perform search on query \\\"quantum\\\". Using the CompositeFetcher of the following \" +\n+            \"Fetchers: {arguments}\")\n+    @MethodSource(\"performSearchParameters\")\n+    public void performSearchOnNonEmptyQuery(Set<SearchBasedFetcher> fetchers) {\n+        CompositeSearchBasedFetcher compositeFetcher = new CompositeSearchBasedFetcher(fetchers);\n+\n+        List<BibEntry> compositeResult = compositeFetcher.performSearch(\"quantum\");\n+\n+        for (SearchBasedFetcher fetcher : fetchers) {\n+            try {\n+                Assertions.assertTrue(compositeResult.containsAll(fetcher.performSearch(\"quantum\")));\n+            } catch (FetcherException e) {\n+                /* We catch the Fetcher exception here, since the failing fetcher also fails in the CompositeFetcher\n+                 * and just leads to no additional results in the returned list. Therefor the test should not fail\n+                 * due to the fetcher exception\n+                 */\n+                LOGGER.warn(String.format(\"Fetcher %s failed \", fetcher.getName()), e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This method provides other methods with different sized sets of Searchbased fetchers wrapped in Arguments.\n+     *\n+     * @return A stream of Arguments wrapping the sets.\n+     */\n+    static Stream<Arguments> performSearchParameters() {\n+        ImportFormatPreferences importFormatPreferences = mock(ImportFormatPreferences.class);\n+        when(importFormatPreferences.getFieldContentFormatterPreferences())\n+                .thenReturn(mock(FieldContentFormatterPreferences.class));\n+        List<Set<SearchBasedFetcher>> fetcherParameters = new ArrayList<>();\n+        List<SearchBasedFetcher> list = new ArrayList<>();\n+\n+        list.add(new ArXiv(importFormatPreferences));\n+        list.add(new INSPIREFetcher(importFormatPreferences));\n+        list.add(new GvkFetcher());\n+        list.add(new AstrophysicsDataSystem(importFormatPreferences));\n+        list.add(new MathSciNet(importFormatPreferences));\n+        list.add(new ZbMATH(importFormatPreferences));\n+        list.add(new GoogleScholar(importFormatPreferences));\n+        list.add(new DBLPFetcher(importFormatPreferences));\n+        list.add(new SpringerFetcher());\n+        list.add(new CrossRef());\n+        list.add(new CiteSeer());\n+        list.add(new DOAJFetcher(importFormatPreferences));\n+        list.add(new IEEE(importFormatPreferences));\n+        /* Disabled due to issue regarding Comparison: Title fields of the entries that otherwise are equivalent differ", "originalCommit": "1acd5aa0bfd310c8fda79fecde126200c3bfa046", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk5MjgwNg==", "url": "https://github.com/JabRef/jabref/pull/6504#discussion_r429992806", "bodyText": "Can you provide me the concreete example? Maybe, we need to fix the MedlineFetcher?", "author": "koppor", "createdAt": "2020-05-25T15:34:09Z", "path": "src/test/java/org/jabref/logic/importer/fetcher/CompositeSearchBasedFetcherTest.java", "diffHunk": "@@ -0,0 +1,110 @@\n+package org.jabref.logic.importer.fetcher;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Stream;\n+\n+import org.jabref.logic.bibtex.FieldContentFormatterPreferences;\n+import org.jabref.logic.importer.FetcherException;\n+import org.jabref.logic.importer.ImportFormatPreferences;\n+import org.jabref.logic.importer.SearchBasedFetcher;\n+import org.jabref.model.entry.BibEntry;\n+import org.jabref.testutils.category.FetcherTest;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+@FetcherTest\n+public class CompositeSearchBasedFetcherTest {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(CompositeSearchBasedFetcherTest.class);\n+\n+    @Test\n+    public void performSearchWithoutFetchers() {\n+        Set<SearchBasedFetcher> empty = new HashSet<>();\n+        CompositeSearchBasedFetcher fetcher = new CompositeSearchBasedFetcher(empty);\n+\n+        List<BibEntry> result = fetcher.performSearch(\"quantum\");\n+\n+        Assertions.assertTrue(result.isEmpty());\n+    }\n+\n+    @ParameterizedTest(name = \"Perform Search on empty query.\")\n+    @MethodSource(\"performSearchParameters\")\n+    public void performSearchOnEmptyQuery(Set<SearchBasedFetcher> fetchers) {\n+        CompositeSearchBasedFetcher compositeFetcher = new CompositeSearchBasedFetcher(fetchers);\n+\n+        List<BibEntry> queryResult = compositeFetcher.performSearch(\"\");\n+\n+        Assertions.assertTrue(queryResult.isEmpty());\n+    }\n+\n+    @ParameterizedTest(name = \"Perform search on query \\\"quantum\\\". Using the CompositeFetcher of the following \" +\n+            \"Fetchers: {arguments}\")\n+    @MethodSource(\"performSearchParameters\")\n+    public void performSearchOnNonEmptyQuery(Set<SearchBasedFetcher> fetchers) {\n+        CompositeSearchBasedFetcher compositeFetcher = new CompositeSearchBasedFetcher(fetchers);\n+\n+        List<BibEntry> compositeResult = compositeFetcher.performSearch(\"quantum\");\n+\n+        for (SearchBasedFetcher fetcher : fetchers) {\n+            try {\n+                Assertions.assertTrue(compositeResult.containsAll(fetcher.performSearch(\"quantum\")));\n+            } catch (FetcherException e) {\n+                /* We catch the Fetcher exception here, since the failing fetcher also fails in the CompositeFetcher\n+                 * and just leads to no additional results in the returned list. Therefor the test should not fail\n+                 * due to the fetcher exception\n+                 */\n+                LOGGER.warn(String.format(\"Fetcher %s failed \", fetcher.getName()), e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This method provides other methods with different sized sets of Searchbased fetchers wrapped in Arguments.\n+     *\n+     * @return A stream of Arguments wrapping the sets.\n+     */\n+    static Stream<Arguments> performSearchParameters() {\n+        ImportFormatPreferences importFormatPreferences = mock(ImportFormatPreferences.class);\n+        when(importFormatPreferences.getFieldContentFormatterPreferences())\n+                .thenReturn(mock(FieldContentFormatterPreferences.class));\n+        List<Set<SearchBasedFetcher>> fetcherParameters = new ArrayList<>();\n+        List<SearchBasedFetcher> list = new ArrayList<>();\n+\n+        list.add(new ArXiv(importFormatPreferences));\n+        list.add(new INSPIREFetcher(importFormatPreferences));\n+        list.add(new GvkFetcher());\n+        list.add(new AstrophysicsDataSystem(importFormatPreferences));\n+        list.add(new MathSciNet(importFormatPreferences));\n+        list.add(new ZbMATH(importFormatPreferences));\n+        list.add(new GoogleScholar(importFormatPreferences));\n+        list.add(new DBLPFetcher(importFormatPreferences));\n+        list.add(new SpringerFetcher());\n+        list.add(new CrossRef());\n+        list.add(new CiteSeer());\n+        list.add(new DOAJFetcher(importFormatPreferences));\n+        list.add(new IEEE(importFormatPreferences));\n+        /* Disabled due to issue regarding Comparison: Title fields of the entries that otherwise are equivalent differ\n+         * due to different JAXBElements.", "originalCommit": "1acd5aa0bfd310c8fda79fecde126200c3bfa046", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA4NjIyOA==", "url": "https://github.com/JabRef/jabref/pull/6504#discussion_r430086228", "bodyText": "AFAIK:\nWhen using the same instance of MedlineFetcher to fetch results directly or as part of the CompositeFetcher, certain BibEntries have differing titles due to something related to JAXBElements.\nWhen searching for \"Indistinguishable Photons from Deterministically\" the direct use of the MedLine Fetcher returns a BibEntry with the title:\n\ntitle = {Indistinguishable Photons from Deterministically Integrated Single Quantum Dots in Heterogeneous GaAs/Si, javax.xml.bind.JAXBElement@31b82e0f, N, javax.xml.bind.JAXBElement@27a09971, Quantum Photonic Circuits.}\n\nThe CompositeFetcher, on the other hand, returns a BibEntry with the title:\n\ntitle = {Indistinguishable Photons from Deterministically Integrated Single Quantum Dots in Heterogeneous GaAs/Si, javax.xml.bind.JAXBElement@3289079a, N, javax.xml.bind.JAXBElement@32fa809f, Quantum Photonic Circuits.}\n\nBoth would be the same only differing by the JAXBElement Instance.", "author": "DominikVoigt", "createdAt": "2020-05-25T22:15:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk5MjgwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk5MzM0NQ==", "url": "https://github.com/JabRef/jabref/pull/6504#discussion_r429993345", "bodyText": "Can we do some different sub sets? Not always include the first one, but something like: Always +3 and then use the subsets matched by the respective bits?\n6543210\n0110001 --> list entry 5,4,0 are used\n\n(Not sure what the others think of it)", "author": "koppor", "createdAt": "2020-05-25T15:35:36Z", "path": "src/test/java/org/jabref/logic/importer/fetcher/CompositeSearchBasedFetcherTest.java", "diffHunk": "@@ -0,0 +1,110 @@\n+package org.jabref.logic.importer.fetcher;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Stream;\n+\n+import org.jabref.logic.bibtex.FieldContentFormatterPreferences;\n+import org.jabref.logic.importer.FetcherException;\n+import org.jabref.logic.importer.ImportFormatPreferences;\n+import org.jabref.logic.importer.SearchBasedFetcher;\n+import org.jabref.model.entry.BibEntry;\n+import org.jabref.testutils.category.FetcherTest;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+@FetcherTest\n+public class CompositeSearchBasedFetcherTest {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(CompositeSearchBasedFetcherTest.class);\n+\n+    @Test\n+    public void performSearchWithoutFetchers() {\n+        Set<SearchBasedFetcher> empty = new HashSet<>();\n+        CompositeSearchBasedFetcher fetcher = new CompositeSearchBasedFetcher(empty);\n+\n+        List<BibEntry> result = fetcher.performSearch(\"quantum\");\n+\n+        Assertions.assertTrue(result.isEmpty());\n+    }\n+\n+    @ParameterizedTest(name = \"Perform Search on empty query.\")\n+    @MethodSource(\"performSearchParameters\")\n+    public void performSearchOnEmptyQuery(Set<SearchBasedFetcher> fetchers) {\n+        CompositeSearchBasedFetcher compositeFetcher = new CompositeSearchBasedFetcher(fetchers);\n+\n+        List<BibEntry> queryResult = compositeFetcher.performSearch(\"\");\n+\n+        Assertions.assertTrue(queryResult.isEmpty());\n+    }\n+\n+    @ParameterizedTest(name = \"Perform search on query \\\"quantum\\\". Using the CompositeFetcher of the following \" +\n+            \"Fetchers: {arguments}\")\n+    @MethodSource(\"performSearchParameters\")\n+    public void performSearchOnNonEmptyQuery(Set<SearchBasedFetcher> fetchers) {\n+        CompositeSearchBasedFetcher compositeFetcher = new CompositeSearchBasedFetcher(fetchers);\n+\n+        List<BibEntry> compositeResult = compositeFetcher.performSearch(\"quantum\");\n+\n+        for (SearchBasedFetcher fetcher : fetchers) {\n+            try {\n+                Assertions.assertTrue(compositeResult.containsAll(fetcher.performSearch(\"quantum\")));\n+            } catch (FetcherException e) {\n+                /* We catch the Fetcher exception here, since the failing fetcher also fails in the CompositeFetcher\n+                 * and just leads to no additional results in the returned list. Therefor the test should not fail\n+                 * due to the fetcher exception\n+                 */\n+                LOGGER.warn(String.format(\"Fetcher %s failed \", fetcher.getName()), e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This method provides other methods with different sized sets of Searchbased fetchers wrapped in Arguments.\n+     *\n+     * @return A stream of Arguments wrapping the sets.\n+     */\n+    static Stream<Arguments> performSearchParameters() {\n+        ImportFormatPreferences importFormatPreferences = mock(ImportFormatPreferences.class);\n+        when(importFormatPreferences.getFieldContentFormatterPreferences())\n+                .thenReturn(mock(FieldContentFormatterPreferences.class));\n+        List<Set<SearchBasedFetcher>> fetcherParameters = new ArrayList<>();\n+        List<SearchBasedFetcher> list = new ArrayList<>();\n+\n+        list.add(new ArXiv(importFormatPreferences));\n+        list.add(new INSPIREFetcher(importFormatPreferences));\n+        list.add(new GvkFetcher());\n+        list.add(new AstrophysicsDataSystem(importFormatPreferences));\n+        list.add(new MathSciNet(importFormatPreferences));\n+        list.add(new ZbMATH(importFormatPreferences));\n+        list.add(new GoogleScholar(importFormatPreferences));\n+        list.add(new DBLPFetcher(importFormatPreferences));\n+        list.add(new SpringerFetcher());\n+        list.add(new CrossRef());\n+        list.add(new CiteSeer());\n+        list.add(new DOAJFetcher(importFormatPreferences));\n+        list.add(new IEEE(importFormatPreferences));\n+        /* Disabled due to issue regarding Comparison: Title fields of the entries that otherwise are equivalent differ\n+         * due to different JAXBElements.\n+         */\n+        // list.add(new MedlineFetcher());\n+\n+        // Create different sized sets of fetchers to use in the composite fetcher.\n+        for (int i = 1; i < list.size(); i++) {", "originalCommit": "1acd5aa0bfd310c8fda79fecde126200c3bfa046", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAyMDc1Mg==", "url": "https://github.com/JabRef/jabref/pull/6504#discussion_r430020752", "bodyText": "I think we should add a limit(...) of say 30 items here, at least unless paged fetcher are implemented.", "author": "tobiasdiez", "createdAt": "2020-05-25T17:03:04Z", "path": "src/main/java/org/jabref/logic/importer/fetcher/CompositeSearchBasedFetcher.java", "diffHunk": "@@ -0,0 +1,51 @@\n+package org.jabref.logic.importer.fetcher;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.jabref.logic.help.HelpFile;\n+import org.jabref.logic.importer.FetcherException;\n+import org.jabref.logic.importer.SearchBasedFetcher;\n+import org.jabref.model.entry.BibEntry;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class CompositeSearchBasedFetcher implements SearchBasedFetcher {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(CompositeSearchBasedFetcher.class);\n+\n+    private final Set<SearchBasedFetcher> fetchers;\n+\n+    public CompositeSearchBasedFetcher(Set<SearchBasedFetcher> searchBasedFetchers) {\n+        // Remove the Composite Fetcher instance from its own fetcher set to prevent a StackOverflow\n+        this.fetchers = searchBasedFetchers.stream()\n+                .filter(searchBasedFetcher -> searchBasedFetcher != this)\n+                .collect(Collectors.toSet());\n+    }\n+\n+    @Override\n+    public List<BibEntry> performSearch(String query) {\n+        return fetchers.stream().flatMap(searchBasedFetcher -> {\n+            try {\n+                return searchBasedFetcher.performSearch(query).stream();\n+            } catch (FetcherException e) {\n+                LOGGER.warn(String.format(\"%s API request failed\", searchBasedFetcher.getName()), e);\n+                return Stream.empty();\n+            }\n+        }).parallel().collect(Collectors.toList());", "originalCommit": "1acd5aa0bfd310c8fda79fecde126200c3bfa046", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAyMTYxMQ==", "url": "https://github.com/JabRef/jabref/pull/6504#discussion_r430021611", "bodyText": "please don't use assertTrue(empty) but assertEquals(..., emptyList) since this gives a better error message", "author": "tobiasdiez", "createdAt": "2020-05-25T17:06:25Z", "path": "src/test/java/org/jabref/logic/importer/fetcher/CompositeSearchBasedFetcherTest.java", "diffHunk": "@@ -0,0 +1,110 @@\n+package org.jabref.logic.importer.fetcher;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Stream;\n+\n+import org.jabref.logic.bibtex.FieldContentFormatterPreferences;\n+import org.jabref.logic.importer.FetcherException;\n+import org.jabref.logic.importer.ImportFormatPreferences;\n+import org.jabref.logic.importer.SearchBasedFetcher;\n+import org.jabref.model.entry.BibEntry;\n+import org.jabref.testutils.category.FetcherTest;\n+\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+@FetcherTest\n+public class CompositeSearchBasedFetcherTest {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(CompositeSearchBasedFetcherTest.class);\n+\n+    @Test\n+    public void performSearchWithoutFetchers() {\n+        Set<SearchBasedFetcher> empty = new HashSet<>();\n+        CompositeSearchBasedFetcher fetcher = new CompositeSearchBasedFetcher(empty);\n+\n+        List<BibEntry> result = fetcher.performSearch(\"quantum\");\n+\n+        Assertions.assertTrue(result.isEmpty());", "originalCommit": "1acd5aa0bfd310c8fda79fecde126200c3bfa046", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "da09f97d9b46e2f0f9e193c18e03be4aae19dbdf", "url": "https://github.com/JabRef/jabref/commit/da09f97d9b46e2f0f9e193c18e03be4aae19dbdf", "message": "Add null check for CompositeSearchBasedFetcher.\nAdd null test for CompositeSearchBasedFetcher.\nAdapt most change requests\n\nSigned-off-by: DominikVoigt <dominik.ingo.voigt@gmail.com>", "committedDate": "2020-05-25T22:41:51Z", "type": "commit"}, {"oid": "f07fa3390043511b276b31a678b7c98b93e7f823", "url": "https://github.com/JabRef/jabref/commit/f07fa3390043511b276b31a678b7c98b93e7f823", "message": "Modify Stream of Arguments according to recommendation.\n\nSigned-off-by: DominikVoigt <dominik.ingo.voigt@gmail.com>", "committedDate": "2020-05-27T13:31:12Z", "type": "commit"}, {"oid": "2c70b3f81b6feff5c5a02433aff3b9e7fe4b3c49", "url": "https://github.com/JabRef/jabref/commit/2c70b3f81b6feff5c5a02433aff3b9e7fe4b3c49", "message": "Change size of inkrement from 3 to 273 due to too many test arguments getting created otherwise.\n\nSigned-off-by: DominikVoigt <dominik.ingo.voigt@gmail.com>", "committedDate": "2020-05-27T19:04:05Z", "type": "commit"}, {"oid": "2c70b3f81b6feff5c5a02433aff3b9e7fe4b3c49", "url": "https://github.com/JabRef/jabref/commit/2c70b3f81b6feff5c5a02433aff3b9e7fe4b3c49", "message": "Change size of inkrement from 3 to 273 due to too many test arguments getting created otherwise.\n\nSigned-off-by: DominikVoigt <dominik.ingo.voigt@gmail.com>", "committedDate": "2020-05-27T19:04:05Z", "type": "forcePushed"}, {"oid": "7d2b006a775a2d9dbad1570c7645623610fadb42", "url": "https://github.com/JabRef/jabref/commit/7d2b006a775a2d9dbad1570c7645623610fadb42", "message": "Merge branch 'master' into feature/add-option-to-fetch-from-all-sources", "committedDate": "2020-05-27T22:04:04Z", "type": "commit"}, {"oid": "5f446c15efd72613079d8ce3095b6435adefa03a", "url": "https://github.com/JabRef/jabref/commit/5f446c15efd72613079d8ce3095b6435adefa03a", "message": "Reformat steam operators.\nRemove Annotation from IEEETest.\n\nSigned-off-by: DominikVoigt <dominik.ingo.voigt@gmail.com>", "committedDate": "2020-05-27T22:13:05Z", "type": "commit"}, {"oid": "d9454c5380db2a677e4de387e1808091af966a5f", "url": "https://github.com/JabRef/jabref/commit/d9454c5380db2a677e4de387e1808091af966a5f", "message": "Merge branch 'master' into feature/add-option-to-fetch-from-all-sources", "committedDate": "2020-05-27T22:14:53Z", "type": "commit"}]}