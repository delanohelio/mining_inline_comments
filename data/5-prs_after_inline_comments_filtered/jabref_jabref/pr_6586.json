{"pr_number": 6586, "pr_title": "Validates the file path of a TexGroup and fixes Texgroup's \"Library has been modified by another program\"", "pr_createdAt": "2020-06-04T21:51:35Z", "pr_url": "https://github.com/JabRef/jabref/pull/6586", "timeline": [{"oid": "23557f938f4ef47822b4815e15f422d1bf6a86ce", "url": "https://github.com/JabRef/jabref/commit/23557f938f4ef47822b4815e15f422d1bf6a86ce", "message": "process GROUPSTREE and GROUPSTREE_LEGACY at the very end", "committedDate": "2020-06-04T11:47:58Z", "type": "commit"}, {"oid": "2eac6494de00948e218c29bd22d7eb689c663a58", "url": "https://github.com/JabRef/jabref/commit/2eac6494de00948e218c29bd22d7eb689c663a58", "message": "changelog", "committedDate": "2020-06-04T12:04:44Z", "type": "commit"}, {"oid": "01c36a310ba5a606ed9d59a7a5c5caf044637f18", "url": "https://github.com/JabRef/jabref/commit/01c36a310ba5a606ed9d59a7a5c5caf044637f18", "message": "refactoring (part 1)", "committedDate": "2020-06-04T14:35:16Z", "type": "commit"}, {"oid": "44b88961ca07a7e575e5ae14937236701a5a2db9", "url": "https://github.com/JabRef/jabref/commit/44b88961ca07a7e575e5ae14937236701a5a2db9", "message": "refactoring (part 2)", "committedDate": "2020-06-04T17:24:34Z", "type": "commit"}, {"oid": "f36ece614a4e70310830b2f60c3c91d2ad7d719c", "url": "https://github.com/JabRef/jabref/commit/f36ece614a4e70310830b2f60c3c91d2ad7d719c", "message": "validator for aux file added, checking for empty field and using the validationVisualizer", "committedDate": "2020-06-04T21:48:02Z", "type": "commit"}, {"oid": "f554c950621860d78c9b8a1260e089c64e804e4e", "url": "https://github.com/JabRef/jabref/commit/f554c950621860d78c9b8a1260e089c64e804e4e", "message": "changelog", "committedDate": "2020-06-04T21:55:51Z", "type": "commit"}, {"oid": "53cd9adcc2b3773ae89195e1bde7ea687da06a8d", "url": "https://github.com/JabRef/jabref/commit/53cd9adcc2b3773ae89195e1bde7ea687da06a8d", "message": "extension", "committedDate": "2020-06-04T22:25:23Z", "type": "commit"}, {"oid": "ad11243bb1e29bcaae6caa8fdd41b728844f1282", "url": "https://github.com/JabRef/jabref/commit/ad11243bb1e29bcaae6caa8fdd41b728844f1282", "message": "formatting file according to JabRef's formatter for Eclipse", "committedDate": "2020-06-05T08:39:17Z", "type": "commit"}, {"oid": "d20388fd374ea2632472c1c3891c9559b1da51d2", "url": "https://github.com/JabRef/jabref/commit/d20388fd374ea2632472c1c3891c9559b1da51d2", "message": "Revert \"formatting file according to JabRef's formatter for Eclipse\"\n\nThis reverts commit ad11243bb1e29bcaae6caa8fdd41b728844f1282.", "committedDate": "2020-06-05T09:03:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgxMjQyMA==", "url": "https://github.com/JabRef/jabref/pull/6586#discussion_r435812420", "bodyText": "Please avoid abbreviations.", "author": "calixtus", "createdAt": "2020-06-05T09:47:12Z", "path": "src/main/java/org/jabref/logic/importer/util/MetaDataParser.java", "diffHunk": "@@ -49,61 +51,55 @@ public MetaData parse(MetaData metaData, Map<String, String> data, Character key\n         List<String> defaultCiteKeyPattern = new ArrayList<>();\n         Map<EntryType, List<String>> nonDefaultCiteKeyPatterns = new HashMap<>();\n \n-        for (Map.Entry<String, String> entry : data.entrySet()) {\n+        // process GROUPSTREE and GROUPSTREE_LEGACY at the very end (otherwise it can happen that not all dependent data are set)\n+        Stream<Map.Entry<String, String>> stream = data.entrySet().stream().filter(entry -> !entry.getKey().equals(MetaData.GROUPSTREE) && !entry.getKey().equals(MetaData.GROUPSTREE_LEGACY));\n+        Stream<Map.Entry<String, String>> streamTail = data.entrySet().stream().filter(entry -> entry.getKey().equals(MetaData.GROUPSTREE) || entry.getKey().equals(MetaData.GROUPSTREE_LEGACY));\n+        stream = Stream.concat(stream, streamTail);\n+\n+        Iterator<Map.Entry<String, String>> it = stream.iterator();", "originalCommit": "ad11243bb1e29bcaae6caa8fdd41b728844f1282", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgxNTM4NQ==", "url": "https://github.com/JabRef/jabref/pull/6586#discussion_r435815385", "bodyText": "Please avoid simple whitespace changes. Eclipse tends to push lines beyond 80 characters just to line method arguments with the brackets. But this makes it hard to read on smaller screens as well as in code reviews.\nAlso we want to avoid an 'IDE war' in JabRef, since autoformat in IntelliJ would then put a tabspace there instead again with the next refactor. We try to keep a consistent codestyle in JabRef and common practice is now to use the IntelliJ-style, as it keeps the code more compact.", "author": "calixtus", "createdAt": "2020-06-05T09:52:56Z", "path": "src/main/java/org/jabref/gui/groups/GroupDialogViewModel.java", "diffHunk": "@@ -117,103 +119,113 @@ public GroupDialogViewModel(DialogService dialogService, BibDatabaseContext curr\n \n     private void setupValidation() {\n         nameValidator = new FunctionBasedValidator<>(\n-                nameProperty,\n-                StringUtil::isNotBlank,\n-                ValidationMessage.error(Localization.lang(\"Please enter a name for the group.\")));\n+                                                     nameProperty,", "originalCommit": "ad11243bb1e29bcaae6caa8fdd41b728844f1282", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgxNjM1MQ==", "url": "https://github.com/JabRef/jabref/pull/6586#discussion_r435816351", "bodyText": "Please omit the underscore in variable names.", "author": "calixtus", "createdAt": "2020-06-05T09:54:40Z", "path": "src/main/java/org/jabref/gui/groups/GroupDialogViewModel.java", "diffHunk": "@@ -232,6 +244,14 @@ private void setupValidation() {\n                 validator.removeValidators(keywordFieldEmptyValidator, keywordRegexValidator, keywordSearchTermEmptyValidator);\n             }\n         });\n+\n+        typeTexProperty.addListener((obs, _oldValue, isSelected) -> {", "originalCommit": "ad11243bb1e29bcaae6caa8fdd41b728844f1282", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgyMDAzNg==", "url": "https://github.com/JabRef/jabref/pull/6586#discussion_r435820036", "bodyText": "I think this check can be reduced to StringUtil.isBlank().", "author": "calixtus", "createdAt": "2020-06-05T10:01:03Z", "path": "src/main/java/org/jabref/gui/groups/GroupDialogViewModel.java", "diffHunk": "@@ -117,103 +119,113 @@ public GroupDialogViewModel(DialogService dialogService, BibDatabaseContext curr\n \n     private void setupValidation() {\n         nameValidator = new FunctionBasedValidator<>(\n-                nameProperty,\n-                StringUtil::isNotBlank,\n-                ValidationMessage.error(Localization.lang(\"Please enter a name for the group.\")));\n+                                                     nameProperty,\n+                                                     StringUtil::isNotBlank,\n+                                                     ValidationMessage.error(Localization.lang(\"Please enter a name for the group.\")));\n \n         nameContainsDelimiterValidator = new FunctionBasedValidator<>(\n-                nameProperty,\n-                name -> !name.contains(Character.toString(preferencesService.getKeywordDelimiter())),\n-                ValidationMessage.warning(\n-                        Localization.lang(\n-                                \"The group name contains the keyword separator \\\"%0\\\" and thus probably does not work as expected.\",\n-                                Character.toString(preferencesService.getKeywordDelimiter())\n-                        )));\n+                                                                      nameProperty,\n+                                                                      name -> !name.contains(Character.toString(preferencesService.getKeywordDelimiter())),\n+                                                                      ValidationMessage.warning(\n+                                                                                                Localization.lang(\n+                                                                                                                  \"The group name contains the keyword separator \\\"%0\\\" and thus probably does not work as expected.\",\n+                                                                                                                  Character.toString(preferencesService.getKeywordDelimiter()))));\n \n         sameNameValidator = new FunctionBasedValidator<>(\n-                nameProperty,\n-                name -> {\n-                    Optional<GroupTreeNode> rootGroup = currentDatabase.getMetaData().getGroups();\n-                    if (rootGroup.isPresent()) {\n-                        int groupsWithSameName = rootGroup.get().findChildrenSatisfying(group -> group.getName().equals(name)).size();\n-                        if ((editedGroup == null) && (groupsWithSameName > 0)) {\n-                            // New group but there is already one group with the same name\n-                            return false;\n-                        }\n-\n-                        // Edit group, changed name to something that is already present\n-                        return (editedGroup == null) || editedGroup.getName().equals(name) || (groupsWithSameName <= 0);\n-                    }\n-                    return true;\n-                },\n-                ValidationMessage.error(Localization.lang(\"There exists already a group with the same name.\")));\n+                                                         nameProperty,\n+                                                         name -> {\n+                                                             Optional<GroupTreeNode> rootGroup = currentDatabase.getMetaData().getGroups();\n+                                                             if (rootGroup.isPresent()) {\n+                                                                 int groupsWithSameName = rootGroup.get().findChildrenSatisfying(group -> group.getName().equals(name)).size();\n+                                                                 if ((editedGroup == null) && (groupsWithSameName > 0)) {\n+                                                                     // New group but there is already one group with the same name\n+                                                                     return false;\n+                                                                 }\n+\n+                                                                 // Edit group, changed name to something that is already present\n+                                                                 return (editedGroup == null) || editedGroup.getName().equals(name) || (groupsWithSameName <= 0);\n+                                                             }\n+                                                             return true;\n+                                                         },\n+                                                         ValidationMessage.error(Localization.lang(\"There exists already a group with the same name.\")));\n \n         keywordRegexValidator = new FunctionBasedValidator<>(\n-                keywordGroupSearchTermProperty,\n-                input -> {\n-                    if (!keywordGroupRegexProperty.getValue()) {\n-                        return true;\n-                    }\n-\n-                    if (StringUtil.isNullOrEmpty(input)) {\n-                        return false;\n-                    }\n-\n-                    try {\n-                        Pattern.compile(input);\n-                        return true;\n-                    } catch (PatternSyntaxException ignored) {\n-                        return false;\n-                    }\n-                },\n-                ValidationMessage.error(String.format(\"%s > %n %s %n %n %s\",\n-                        Localization.lang(\"Searching for keywords\"),\n-                        Localization.lang(\"Keywords\"),\n-                        Localization.lang(\"Invalid regular expression.\"))));\n+                                                             keywordGroupSearchTermProperty,\n+                                                             input -> {\n+                                                                 if (!keywordGroupRegexProperty.getValue()) {\n+                                                                     return true;\n+                                                                 }\n+\n+                                                                 if (StringUtil.isNullOrEmpty(input)) {\n+                                                                     return false;\n+                                                                 }\n+\n+                                                                 try {\n+                                                                     Pattern.compile(input);\n+                                                                     return true;\n+                                                                 } catch (PatternSyntaxException ignored) {\n+                                                                     return false;\n+                                                                 }\n+                                                             },\n+                                                             ValidationMessage.error(String.format(\"%s > %n %s %n %n %s\",\n+                                                                                                   Localization.lang(\"Searching for keywords\"),\n+                                                                                                   Localization.lang(\"Keywords\"),\n+                                                                                                   Localization.lang(\"Invalid regular expression.\"))));\n \n         keywordFieldEmptyValidator = new FunctionBasedValidator<>(\n-                keywordGroupSearchFieldProperty,\n-                StringUtil::isNotBlank,\n-                ValidationMessage.error(Localization.lang(\"Please enter a field name to search for keywords.\")));\n+                                                                  keywordGroupSearchFieldProperty,\n+                                                                  StringUtil::isNotBlank,\n+                                                                  ValidationMessage.error(Localization.lang(\"Please enter a field name to search for keywords.\")));\n \n         keywordSearchTermEmptyValidator = new FunctionBasedValidator<>(\n-                keywordGroupSearchTermProperty,\n-                input -> !StringUtil.isNullOrEmpty(input),\n-                ValidationMessage.error(String.format(\"%s > %n %s %n %n %s\",\n-                        Localization.lang(\"Searching for keywords\"),\n-                        Localization.lang(\"Keywords\"),\n-                        Localization.lang(\"Search term is empty.\")\n-                )));\n+                                                                       keywordGroupSearchTermProperty,\n+                                                                       input -> !StringUtil.isNullOrEmpty(input),\n+                                                                       ValidationMessage.error(String.format(\"%s > %n %s %n %n %s\",\n+                                                                                                             Localization.lang(\"Searching for keywords\"),\n+                                                                                                             Localization.lang(\"Keywords\"),\n+                                                                                                             Localization.lang(\"Search term is empty.\"))));\n \n         searchRegexValidator = new FunctionBasedValidator<>(\n-                searchGroupSearchTermProperty,\n-                input -> {\n-                    if (!searchGroupRegexProperty.getValue()) {\n-                        return true;\n-                    }\n-\n-                    if (StringUtil.isNullOrEmpty(input)) {\n-                        return false;\n-                    }\n-\n-                    try {\n-                        Pattern.compile(input);\n-                        return true;\n-                    } catch (PatternSyntaxException ignored) {\n-                        return false;\n-                    }\n-                },\n-                ValidationMessage.error(String.format(\"%s > %n %s\",\n-                        Localization.lang(\"Free search expression\"),\n-                        Localization.lang(\"Invalid regular expression.\"))));\n+                                                            searchGroupSearchTermProperty,\n+                                                            input -> {\n+                                                                if (!searchGroupRegexProperty.getValue()) {\n+                                                                    return true;\n+                                                                }\n+\n+                                                                if (StringUtil.isNullOrEmpty(input)) {\n+                                                                    return false;\n+                                                                }\n+\n+                                                                try {\n+                                                                    Pattern.compile(input);\n+                                                                    return true;\n+                                                                } catch (PatternSyntaxException ignored) {\n+                                                                    return false;\n+                                                                }\n+                                                            },\n+                                                            ValidationMessage.error(String.format(\"%s > %n %s\",\n+                                                                                                  Localization.lang(\"Free search expression\"),\n+                                                                                                  Localization.lang(\"Invalid regular expression.\"))));\n \n         searchSearchTermEmptyValidator = new FunctionBasedValidator<>(\n-                searchGroupSearchTermProperty,\n-                input -> !StringUtil.isNullOrEmpty(input),\n-                ValidationMessage.error(String.format(\"%s > %n %s\",\n-                        Localization.lang(\"Free search expression\"),\n-                        Localization.lang(\"Search term is empty.\")\n-                )));\n+                                                                      searchGroupSearchTermProperty,\n+                                                                      input -> !StringUtil.isNullOrEmpty(input),\n+                                                                      ValidationMessage.error(String.format(\"%s > %n %s\",\n+                                                                                                            Localization.lang(\"Free search expression\"),\n+                                                                                                            Localization.lang(\"Search term is empty.\"))));\n+\n+        texGroupFilePathValidator = new FunctionBasedValidator<>(\n+                                                                 texGroupFilePathProperty,\n+                                                                 input -> {\n+                                                                     if (StringUtil.isNullOrEmpty(input)) {\n+                                                                         return false;\n+                                                                     } else if (input.trim().length() == 0) {\n+                                                                         return false;\n+                                                                     }", "originalCommit": "ad11243bb1e29bcaae6caa8fdd41b728844f1282", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgyMjY2NA==", "url": "https://github.com/JabRef/jabref/pull/6586#discussion_r435822664", "bodyText": "Can you please use more meaningful variable names? Like entrySetStream and groupsTreeStream or similar.", "author": "calixtus", "createdAt": "2020-06-05T10:06:05Z", "path": "src/main/java/org/jabref/logic/importer/util/MetaDataParser.java", "diffHunk": "@@ -49,61 +51,55 @@ public MetaData parse(MetaData metaData, Map<String, String> data, Character key\n         List<String> defaultCiteKeyPattern = new ArrayList<>();\n         Map<EntryType, List<String>> nonDefaultCiteKeyPatterns = new HashMap<>();\n \n-        for (Map.Entry<String, String> entry : data.entrySet()) {\n+        // process GROUPSTREE and GROUPSTREE_LEGACY at the very end (otherwise it can happen that not all dependent data are set)\n+        Stream<Map.Entry<String, String>> stream = data.entrySet().stream().filter(entry -> !entry.getKey().equals(MetaData.GROUPSTREE) && !entry.getKey().equals(MetaData.GROUPSTREE_LEGACY));\n+        Stream<Map.Entry<String, String>> streamTail = data.entrySet().stream().filter(entry -> entry.getKey().equals(MetaData.GROUPSTREE) || entry.getKey().equals(MetaData.GROUPSTREE_LEGACY));\n+        stream = Stream.concat(stream, streamTail);", "originalCommit": "ad11243bb1e29bcaae6caa8fdd41b728844f1282", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8b7063d91d81f94112a779b8d9df620d031aa822", "url": "https://github.com/JabRef/jabref/commit/8b7063d91d81f94112a779b8d9df620d031aa822", "message": "more checks added + checkstyle improved", "committedDate": "2020-06-05T10:47:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg0NDc3OQ==", "url": "https://github.com/JabRef/jabref/pull/6586#discussion_r435844779", "bodyText": "StringUtil.isBlank()can be used here too.", "author": "calixtus", "createdAt": "2020-06-05T10:53:53Z", "path": "src/main/java/org/jabref/gui/groups/GroupDialogViewModel.java", "diffHunk": "@@ -212,8 +214,27 @@ private void setupValidation() {\n                 input -> !StringUtil.isNullOrEmpty(input),\n                 ValidationMessage.error(String.format(\"%s > %n %s\",\n                         Localization.lang(\"Free search expression\"),\n-                        Localization.lang(\"Search term is empty.\")\n-                )));\n+                        Localization.lang(\"Search term is empty.\"))));\n+\n+        texGroupFilePathValidator = new FunctionBasedValidator<>(\n+                texGroupFilePathProperty,\n+                input -> {\n+                    if (StringUtil.isNullOrEmpty(input)) {\n+                        return false;\n+                    } else if (input.trim().length() == 0) {\n+                        return false;", "originalCommit": "8b7063d91d81f94112a779b8d9df620d031aa822", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg0Nzg5NQ==", "url": "https://github.com/JabRef/jabref/pull/6586#discussion_r435847895", "bodyText": "Have you tried FileUtil.find() here?", "author": "calixtus", "createdAt": "2020-06-05T11:00:40Z", "path": "src/main/java/org/jabref/gui/groups/GroupDialogViewModel.java", "diffHunk": "@@ -212,8 +214,27 @@ private void setupValidation() {\n                 input -> !StringUtil.isNullOrEmpty(input),\n                 ValidationMessage.error(String.format(\"%s > %n %s\",\n                         Localization.lang(\"Free search expression\"),\n-                        Localization.lang(\"Search term is empty.\")\n-                )));\n+                        Localization.lang(\"Search term is empty.\"))));\n+\n+        texGroupFilePathValidator = new FunctionBasedValidator<>(\n+                texGroupFilePathProperty,\n+                input -> {\n+                    if (StringUtil.isNullOrEmpty(input)) {\n+                        return false;\n+                    } else if (input.trim().length() == 0) {\n+                        return false;\n+                    } else if ((input.length() < 4) || !input.substring(input.length() - 4).toLowerCase().equals(\".aux\")) {\n+                        return false;\n+                    } else {\n+                        Path path = preferencesService.getWorkingDir();\n+                        File texFile = new File(path.toString(), input);\n+                        if (!texFile.exists() || !texFile.isFile()) {\n+                            return false;\n+                        }\n+                        return true;", "originalCommit": "8b7063d91d81f94112a779b8d9df620d031aa822", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg2MTEwMg==", "url": "https://github.com/JabRef/jabref/pull/6586#discussion_r435861102", "bodyText": "I'm not sure, whether this is a good idea. I intended to explicitly check the provided file, without searching other locations. \ud83e\udd14", "author": "systemoperator", "createdAt": "2020-06-05T11:31:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg0Nzg5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTkwMDYyMQ==", "url": "https://github.com/JabRef/jabref/pull/6586#discussion_r435900621", "bodyText": "I see, maybe this can provide a solution using only the more modern nio files package:\nPath resolved = preferencesService.getWorkingDir().resolve(input);\nreturn Files.exist(resolved);", "author": "calixtus", "createdAt": "2020-06-05T12:52:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg0Nzg5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTkxNzk4MQ==", "url": "https://github.com/JabRef/jabref/pull/6586#discussion_r435917981", "bodyText": "I have adapted it.", "author": "systemoperator", "createdAt": "2020-06-05T13:24:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg0Nzg5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg0OTI1Ng==", "url": "https://github.com/JabRef/jabref/pull/6586#discussion_r435849256", "bodyText": "This can probably abbreviated with FileUtil.getFileExtension()", "author": "calixtus", "createdAt": "2020-06-05T11:03:39Z", "path": "src/main/java/org/jabref/gui/groups/GroupDialogViewModel.java", "diffHunk": "@@ -212,8 +214,27 @@ private void setupValidation() {\n                 input -> !StringUtil.isNullOrEmpty(input),\n                 ValidationMessage.error(String.format(\"%s > %n %s\",\n                         Localization.lang(\"Free search expression\"),\n-                        Localization.lang(\"Search term is empty.\")\n-                )));\n+                        Localization.lang(\"Search term is empty.\"))));\n+\n+        texGroupFilePathValidator = new FunctionBasedValidator<>(\n+                texGroupFilePathProperty,\n+                input -> {\n+                    if (StringUtil.isNullOrEmpty(input)) {\n+                        return false;\n+                    } else if (input.trim().length() == 0) {\n+                        return false;\n+                    } else if ((input.length() < 4) || !input.substring(input.length() - 4).toLowerCase().equals(\".aux\")) {", "originalCommit": "8b7063d91d81f94112a779b8d9df620d031aa822", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7b65150c1d4d98af490d62a846947d4f01e97102", "url": "https://github.com/JabRef/jabref/commit/7b65150c1d4d98af490d62a846947d4f01e97102", "message": "refactoring", "committedDate": "2020-06-05T11:15:21Z", "type": "commit"}, {"oid": "5b7d80e3616cc8e729f87ea8955c4ac1a70de810", "url": "https://github.com/JabRef/jabref/commit/5b7d80e3616cc8e729f87ea8955c4ac1a70de810", "message": "Merge branch 'systemoperator-texgroup' into systemoperator-texgroup-validation", "committedDate": "2020-06-05T11:15:57Z", "type": "commit"}, {"oid": "fe895cf3df7c1255914e7c9b0f3e759f3f00a9e7", "url": "https://github.com/JabRef/jabref/commit/fe895cf3df7c1255914e7c9b0f3e759f3f00a9e7", "message": "update", "committedDate": "2020-06-05T11:17:55Z", "type": "commit"}, {"oid": "db60939e64ab10e5359e67c687c167d425ab6310", "url": "https://github.com/JabRef/jabref/commit/db60939e64ab10e5359e67c687c167d425ab6310", "message": "refactoring", "committedDate": "2020-06-05T11:29:39Z", "type": "commit"}, {"oid": "f593b13c398ad23dfaa7622758ade7155da0948e", "url": "https://github.com/JabRef/jabref/commit/f593b13c398ad23dfaa7622758ade7155da0948e", "message": "refactoring", "committedDate": "2020-06-05T11:42:24Z", "type": "commit"}, {"oid": "586d55b855e6ba5335fbb615e956a5d00fad8387", "url": "https://github.com/JabRef/jabref/commit/586d55b855e6ba5335fbb615e956a5d00fad8387", "message": "l10n", "committedDate": "2020-06-05T11:53:01Z", "type": "commit"}, {"oid": "6a82156c2ea172350719dae915d513910a890ddc", "url": "https://github.com/JabRef/jabref/commit/6a82156c2ea172350719dae915d513910a890ddc", "message": "update", "committedDate": "2020-06-05T12:25:38Z", "type": "commit"}, {"oid": "f092108123ad187046a9d627503bebcc9a49d8fa", "url": "https://github.com/JabRef/jabref/commit/f092108123ad187046a9d627503bebcc9a49d8fa", "message": "refactoring", "committedDate": "2020-06-05T13:23:11Z", "type": "commit"}, {"oid": "74f05ea31d7cb1208a1ed5babc76b59b497e65d6", "url": "https://github.com/JabRef/jabref/commit/74f05ea31d7cb1208a1ed5babc76b59b497e65d6", "message": "cleanup (checkstyle)", "committedDate": "2020-06-05T13:43:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk5MTQ3Mg==", "url": "https://github.com/JabRef/jabref/pull/6586#discussion_r435991472", "bodyText": "I think sorting the entries as described here https://stackoverflow.com/a/30286728/873661 is a bit more readable.", "author": "tobiasdiez", "createdAt": "2020-06-05T15:19:13Z", "path": "src/main/java/org/jabref/logic/importer/util/MetaDataParser.java", "diffHunk": "@@ -49,61 +51,55 @@ public MetaData parse(MetaData metaData, Map<String, String> data, Character key\n         List<String> defaultCiteKeyPattern = new ArrayList<>();\n         Map<EntryType, List<String>> nonDefaultCiteKeyPatterns = new HashMap<>();\n \n-        for (Map.Entry<String, String> entry : data.entrySet()) {\n+        // process GROUPSTREE and GROUPSTREE_LEGACY at the very end (otherwise it can happen that not all dependent data are set)\n+        Stream<Map.Entry<String, String>> entrySetStream = data.entrySet().stream().filter(entry -> !entry.getKey().equals(MetaData.GROUPSTREE) && !entry.getKey().equals(MetaData.GROUPSTREE_LEGACY));", "originalCommit": "74f05ea31d7cb1208a1ed5babc76b59b497e65d6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk5MTc2NQ==", "url": "https://github.com/JabRef/jabref/pull/6586#discussion_r435991765", "bodyText": "A more \"streamy\" way is using the stream.foreach(...) method.", "author": "tobiasdiez", "createdAt": "2020-06-05T15:19:42Z", "path": "src/main/java/org/jabref/logic/importer/util/MetaDataParser.java", "diffHunk": "@@ -49,61 +51,55 @@ public MetaData parse(MetaData metaData, Map<String, String> data, Character key\n         List<String> defaultCiteKeyPattern = new ArrayList<>();\n         Map<EntryType, List<String>> nonDefaultCiteKeyPatterns = new HashMap<>();\n \n-        for (Map.Entry<String, String> entry : data.entrySet()) {\n+        // process GROUPSTREE and GROUPSTREE_LEGACY at the very end (otherwise it can happen that not all dependent data are set)\n+        Stream<Map.Entry<String, String>> entrySetStream = data.entrySet().stream().filter(entry -> !entry.getKey().equals(MetaData.GROUPSTREE) && !entry.getKey().equals(MetaData.GROUPSTREE_LEGACY));\n+        Stream<Map.Entry<String, String>> entrySetStreamTail = data.entrySet().stream().filter(entry -> entry.getKey().equals(MetaData.GROUPSTREE) || entry.getKey().equals(MetaData.GROUPSTREE_LEGACY));\n+        entrySetStream = Stream.concat(entrySetStream, entrySetStreamTail);\n+\n+        Iterator<Map.Entry<String, String>> entryIterator = entrySetStream.iterator();\n+\n+        while (entryIterator.hasNext()) {", "originalCommit": "74f05ea31d7cb1208a1ed5babc76b59b497e65d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAzNzE1MA==", "url": "https://github.com/JabRef/jabref/pull/6586#discussion_r436037150", "bodyText": "In the loop exceptions may be thrown. It's slightly complicated to throw them back within a lambda expression (at least for me).", "author": "systemoperator", "createdAt": "2020-06-05T16:39:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk5MTc2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA0MTU3Nw==", "url": "https://github.com/JabRef/jabref/pull/6586#discussion_r436041577", "bodyText": "ok, good argument. I think first using collect to get an ordinary list and then using foreach is still slightly better.", "author": "tobiasdiez", "createdAt": "2020-06-05T16:48:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk5MTc2NQ=="}], "type": "inlineReview"}, {"oid": "ba367adf152e0b26ebeaf28fc4e662ddef782f9a", "url": "https://github.com/JabRef/jabref/commit/ba367adf152e0b26ebeaf28fc4e662ddef782f9a", "message": "refactor", "committedDate": "2020-06-05T16:56:15Z", "type": "commit"}, {"oid": "c120c457c662ddedf3804c1747f066fc77261fea", "url": "https://github.com/JabRef/jabref/commit/c120c457c662ddedf3804c1747f066fc77261fea", "message": "refactor to sorting mechanism", "committedDate": "2020-06-05T17:18:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA2NDYxNQ==", "url": "https://github.com/JabRef/jabref/pull/6586#discussion_r436064615", "bodyText": "Just an idea: Can creating streams theoretically be omitted by using List.copyof(data.entrySet()).sort(groupsLast()) ?", "author": "calixtus", "createdAt": "2020-06-05T17:33:41Z", "path": "src/main/java/org/jabref/logic/importer/util/MetaDataParser.java", "diffHunk": "@@ -49,68 +52,62 @@ public MetaData parse(MetaData metaData, Map<String, String> data, Character key\n         List<String> defaultCiteKeyPattern = new ArrayList<>();\n         Map<EntryType, List<String>> nonDefaultCiteKeyPatterns = new HashMap<>();\n \n-        for (Map.Entry<String, String> entry : data.entrySet()) {\n+        // process groups (GROUPSTREE and GROUPSTREE_LEGACY) at the very end (otherwise it can happen that not all dependent data are set)\n+        Stream<Map.Entry<String, String>> entrySetStream = data.entrySet().stream().sorted(groupsLast());", "originalCommit": "c120c457c662ddedf3804c1747f066fc77261fea", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ec8933e342a944132cc9d07ec4346a785a213260", "url": "https://github.com/JabRef/jabref/commit/ec8933e342a944132cc9d07ec4346a785a213260", "message": "refactor (without stream)", "committedDate": "2020-06-05T17:54:33Z", "type": "commit"}, {"oid": "01cdb4464f33ac2cb5ee7e9feec5fbd954131e0c", "url": "https://github.com/JabRef/jabref/commit/01cdb4464f33ac2cb5ee7e9feec5fbd954131e0c", "message": "remove brackets", "committedDate": "2020-06-05T19:26:55Z", "type": "commit"}, {"oid": "e7a3c3f4c8e2fe4e28a5b6112588919ee035527d", "url": "https://github.com/JabRef/jabref/commit/e7a3c3f4c8e2fe4e28a5b6112588919ee035527d", "message": "test created", "committedDate": "2020-06-05T21:07:03Z", "type": "commit"}, {"oid": "49c3a2bc31f314bda97f4b72104dbdbeca8edb3b", "url": "https://github.com/JabRef/jabref/commit/49c3a2bc31f314bda97f4b72104dbdbeca8edb3b", "message": "finalize test", "committedDate": "2020-06-05T21:14:11Z", "type": "commit"}, {"oid": "26342abc39f2d2c859e6c19948ad11b8498ceb53", "url": "https://github.com/JabRef/jabref/commit/26342abc39f2d2c859e6c19948ad11b8498ceb53", "message": "formatting", "committedDate": "2020-06-05T21:21:14Z", "type": "commit"}, {"oid": "aac9ffc71089f285bca1970395459cf49a7934ae", "url": "https://github.com/JabRef/jabref/commit/aac9ffc71089f285bca1970395459cf49a7934ae", "message": "formatting", "committedDate": "2020-06-05T21:23:30Z", "type": "commit"}, {"oid": "f98466a764e93ec513627a15c6a8f26bb44ee13a", "url": "https://github.com/JabRef/jabref/commit/f98466a764e93ec513627a15c6a8f26bb44ee13a", "message": "checkstyle", "committedDate": "2020-06-05T21:37:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDkwODU1MQ==", "url": "https://github.com/JabRef/jabref/pull/6586#discussion_r440908551", "bodyText": "I would suggest removing empty @throws annotations.", "author": "koppor", "createdAt": "2020-06-16T14:46:01Z", "path": "src/test/java/org/jabref/logic/importer/fileformat/BibtexParserTest.java", "diffHunk": "@@ -1388,6 +1390,36 @@ void integrationTestGroupTree() throws IOException, ParseException {\n                 ((ExplicitGroup) root.getChildren().get(2).getGroup()).getLegacyEntryKeys());\n     }\n \n+    /**\n+     * Checks that a TexGroup finally gets the required data, after parsing the library.\n+     * @throws IOException", "originalCommit": "f98466a764e93ec513627a15c6a8f26bb44ee13a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDkwODk1OQ==", "url": "https://github.com/JabRef/jabref/pull/6586#discussion_r440908959", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                void integrationTestTexGroup() throws IOException, ParseException {\n          \n          \n            \n                void integrationTestTexGroup() throws Exception {\n          \n      \n    \n    \n  \n\nWe have the convention that always Exception is thrown at tests.", "author": "koppor", "createdAt": "2020-06-16T14:46:34Z", "path": "src/test/java/org/jabref/logic/importer/fileformat/BibtexParserTest.java", "diffHunk": "@@ -1388,6 +1390,36 @@ void integrationTestGroupTree() throws IOException, ParseException {\n                 ((ExplicitGroup) root.getChildren().get(2).getGroup()).getLegacyEntryKeys());\n     }\n \n+    /**\n+     * Checks that a TexGroup finally gets the required data, after parsing the library.\n+     * @throws IOException\n+     * @throws ParseException\n+     */\n+    @Test\n+    void integrationTestTexGroup() throws IOException, ParseException {", "originalCommit": "f98466a764e93ec513627a15c6a8f26bb44ee13a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDkxMjAyNg==", "url": "https://github.com/JabRef/jabref/pull/6586#discussion_r440912026", "bodyText": "Can we keep the switch (entry.getKey) somehow? Maybe nested in an else branch?\nYou can use the new Java14 switch: https://openjdk.java.net/jeps/361\n(File needs to be added to \n  \n    \n      jabref/config/checkstyle/checkstyle.xml\n    \n    \n         Line 15\n      in\n      ca06b71\n    \n    \n    \n    \n\n        \n          \n           <property name=\"fileNamePattern\" value=\"AuthorAndsReplacer.java|Ordinal.java|EntryTypeView.java\" /> \n        \n    \n  \n\n then)", "author": "koppor", "createdAt": "2020-06-16T14:50:34Z", "path": "src/main/java/org/jabref/logic/importer/util/MetaDataParser.java", "diffHunk": "@@ -49,68 +50,63 @@ public MetaData parse(MetaData metaData, Map<String, String> data, Character key\n         List<String> defaultCiteKeyPattern = new ArrayList<>();\n         Map<EntryType, List<String>> nonDefaultCiteKeyPatterns = new HashMap<>();\n \n-        for (Map.Entry<String, String> entry : data.entrySet()) {\n+        // process groups (GROUPSTREE and GROUPSTREE_LEGACY) at the very end (otherwise it can happen that not all dependent data are set)\n+        List<Map.Entry<String, String>> entryList = new ArrayList<>(data.entrySet());\n+        entryList.sort(groupsLast());\n+\n+        for (Map.Entry<String, String> entry : entryList) {\n             List<String> value = getAsList(entry.getValue());\n \n             if (entry.getKey().startsWith(MetaData.PREFIX_KEYPATTERN)) {\n                 EntryType entryType = EntryTypeFactory.parse(entry.getKey().substring(MetaData.PREFIX_KEYPATTERN.length()));\n                 nonDefaultCiteKeyPatterns.put(entryType, Collections.singletonList(getSingleItem(value)));\n-                continue;\n             } else if (entry.getKey().startsWith(MetaData.FILE_DIRECTORY + '-')) {\n                 // The user name comes directly after \"FILE_DIRECTORY-\"\n                 String user = entry.getKey().substring(MetaData.FILE_DIRECTORY.length() + 1);\n                 metaData.setUserFileDirectory(user, getSingleItem(value));\n-                continue;\n             } else if (entry.getKey().startsWith(MetaData.SELECTOR_META_PREFIX)) {\n                 metaData.addContentSelector(ContentSelectors.parse(FieldFactory.parseField(entry.getKey().substring(MetaData.SELECTOR_META_PREFIX.length())), StringUtil.unquote(entry.getValue(), MetaData.ESCAPE_CHARACTER)));\n-                continue;\n             } else if (entry.getKey().startsWith(MetaData.FILE_DIRECTORY + \"Latex-\")) {\n                 // The user name comes directly after \"FILE_DIRECTORYLatex-\"\n                 String user = entry.getKey().substring(MetaData.FILE_DIRECTORY.length() + 6);\n                 Path path = Path.of(getSingleItem(value)).normalize();\n                 metaData.setLatexFileDirectory(user, path);\n-                continue;\n-            }\n-\n-            switch (entry.getKey()) {\n-                case MetaData.GROUPSTREE:\n-                case MetaData.GROUPSTREE_LEGACY:\n-                    metaData.setGroups(GroupsParser.importGroups(value, keywordSeparator, fileMonitor, metaData));\n-                    break;\n-                case MetaData.SAVE_ACTIONS:\n-                    metaData.setSaveActions(Cleanups.parse(value));\n-                    break;\n-                case MetaData.DATABASE_TYPE:\n-                    metaData.setMode(BibDatabaseMode.parse(getSingleItem(value)));\n-                    break;\n-                case MetaData.KEYPATTERNDEFAULT:\n-                    defaultCiteKeyPattern = Collections.singletonList(getSingleItem(value));\n-                    break;\n-                case MetaData.PROTECTED_FLAG_META:\n-                    if (Boolean.parseBoolean(getSingleItem(value))) {\n-                        metaData.markAsProtected();\n-                    } else {\n-                        metaData.markAsNotProtected();\n-                    }\n-                    break;\n-                case MetaData.FILE_DIRECTORY:\n-                    metaData.setDefaultFileDirectory(getSingleItem(value));\n-                    break;\n-                case MetaData.SAVE_ORDER_CONFIG:\n-                    metaData.setSaveOrderConfig(SaveOrderConfig.parse(value));\n-                    break;\n-                default:\n-                    // Keep meta data items that we do not know in the file\n-                    metaData.putUnknownMetaDataItem(entry.getKey(), value);\n+            } else if (entry.getKey().equals(MetaData.SAVE_ACTIONS)) {", "originalCommit": "f98466a764e93ec513627a15c6a8f26bb44ee13a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDk0ODMzNw==", "url": "https://github.com/JabRef/jabref/pull/6586#discussion_r440948337", "bodyText": "This is still a huge p.i.t.a.\nCheckstyle really needs to keep up, people start getting tired of these workarounds.\nSome background information, if you are interested: checkstyle/checkstyle#6615", "author": "calixtus", "createdAt": "2020-06-16T15:36:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDkxMjAyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDk1NDk0OQ==", "url": "https://github.com/JabRef/jabref/pull/6586#discussion_r440954949", "bodyText": "The key problem is here that switch cases are not executed in order. That's the reason for the if else", "author": "Siedlerchr", "createdAt": "2020-06-16T15:45:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDkxMjAyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDk1NzQ1Ng==", "url": "https://github.com/JabRef/jabref/pull/6586#discussion_r440957456", "bodyText": "In the concrete case here, it is always checked for entry.getKey(). Please check the diff:\n\nThe wrong order was at that diff - completely unrelated to my proposal!", "author": "koppor", "createdAt": "2020-06-16T15:48:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDkxMjAyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTU2OTgxNw==", "url": "https://github.com/JabRef/jabref/pull/6586#discussion_r441569817", "bodyText": "Yes, the switch statement could be reintroduced (and simplified). Before this fix, the code was structured really confusing and looked error-prone. So I decided to create this consistent and simplified version, which I find quite acceptable.", "author": "systemoperator", "createdAt": "2020-06-17T14:02:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDkxMjAyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc4NDQ1Nw==", "url": "https://github.com/JabRef/jabref/pull/6586#discussion_r441784457", "bodyText": "I meant only for the lower part; not with the xxxx continue statements. Just for the endless chain of else if (entry.getKey().equeals(MetaData.X)) chains, where only X is different from the checks.\nThere is ALWAYS entry.getKey() compared from line 75 to line 92 (or did I see something wrong?).\nThis is just a matter of taste. Maybe, I'll just do it and open another PR to have the discussions there. Should not be a show stopper for us now.", "author": "koppor", "createdAt": "2020-06-17T19:31:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDkxMjAyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDkxODYyMg==", "url": "https://github.com/JabRef/jabref/pull/6586#discussion_r440918622", "bodyText": "Can we put this directly after line 225?\nI simplified it. Furthermore calling .isEmpty in an Optional felles wrong. I propose following code:\nPath texFilePath = preferencesService.getWorkingDir().resolve(input);\nif (!Files.isRegularFile(texFilePath)) {\n  return false;\n}\nreturn FileUtil.getFileExtension(input)\n  .map(extension -> extension.toLowerCase().equals(\"aux\"))\n  .orElse(false);", "author": "koppor", "createdAt": "2020-06-16T14:58:37Z", "path": "src/main/java/org/jabref/gui/groups/GroupDialogViewModel.java", "diffHunk": "@@ -212,8 +214,25 @@ private void setupValidation() {\n                 input -> !StringUtil.isNullOrEmpty(input),\n                 ValidationMessage.error(String.format(\"%s > %n %s\",\n                         Localization.lang(\"Free search expression\"),\n-                        Localization.lang(\"Search term is empty.\")\n-                )));\n+                        Localization.lang(\"Search term is empty.\"))));\n+\n+        texGroupFilePathValidator = new FunctionBasedValidator<>(\n+                texGroupFilePathProperty,\n+                input -> {\n+                    if (StringUtil.isBlank(input)) {\n+                        return false;\n+                    } else {\n+                        Path texFilePath = preferencesService.getWorkingDir().resolve(input);\n+                        Optional<String> fileExtension = FileUtil.getFileExtension(input);\n+                        if (fileExtension.isEmpty() || !fileExtension.get().toLowerCase().equals(\"aux\")) {\n+                            return false;\n+                        } else if (!Files.isRegularFile(texFilePath)) {", "originalCommit": "f98466a764e93ec513627a15c6a8f26bb44ee13a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3f2f46fd7c876f3d124b62bbbae5822d168df39c", "url": "https://github.com/JabRef/jabref/commit/3f2f46fd7c876f3d124b62bbbae5822d168df39c", "message": "refactoring", "committedDate": "2020-06-17T14:05:24Z", "type": "commit"}, {"oid": "5a3548a1a4e8fce657681336108a6035a767ee68", "url": "https://github.com/JabRef/jabref/commit/5a3548a1a4e8fce657681336108a6035a767ee68", "message": "Merge branch 'master' into systemoperator-texgroup-validation", "committedDate": "2020-06-17T14:10:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc4NTU1NQ==", "url": "https://github.com/JabRef/jabref/pull/6586#discussion_r441785555", "bodyText": "@stefan-kolb Would review here: \"Fail fast\". Not endless nested if/else statements, but just exit early.\nTherefore, I proposed:\nif (StringUtil.isBlank(input)) {\n  return false;\n}\nThink, I will start another PR with this and the other code style thing and we can have the discussion there --> we need to get this fix in soon.", "author": "koppor", "createdAt": "2020-06-17T19:33:11Z", "path": "src/main/java/org/jabref/gui/groups/GroupDialogViewModel.java", "diffHunk": "@@ -212,8 +214,24 @@ private void setupValidation() {\n                 input -> !StringUtil.isNullOrEmpty(input),\n                 ValidationMessage.error(String.format(\"%s > %n %s\",\n                         Localization.lang(\"Free search expression\"),\n-                        Localization.lang(\"Search term is empty.\")\n-                )));\n+                        Localization.lang(\"Search term is empty.\"))));\n+\n+        texGroupFilePathValidator = new FunctionBasedValidator<>(\n+                texGroupFilePathProperty,\n+                input -> {\n+                    if (StringUtil.isBlank(input)) {\n+                        return false;\n+                    } else {", "originalCommit": "5a3548a1a4e8fce657681336108a6035a767ee68", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}