{"pr_number": 2144, "pr_title": "AtB - StratCon implementation", "pr_createdAt": "2020-10-16T03:43:42Z", "pr_url": "https://github.com/MegaMek/mekhq/pull/2144", "timeline": [{"oid": "ae5731c76c06e039f3f542e54205e02ddc698c45", "url": "https://github.com/MegaMek/mekhq/commit/ae5731c76c06e039f3f542e54205e02ddc698c45", "message": "last code review change; minor faq update", "committedDate": "2021-04-20T18:45:13Z", "type": "commit"}, {"oid": "ffaea50bdf69e6d41b4c9e3a200648f13291688b", "url": "https://github.com/MegaMek/mekhq/commit/ffaea50bdf69e6d41b4c9e3a200648f13291688b", "message": "revert ContractMarket", "committedDate": "2020-12-22T22:18:39Z", "type": "commit"}, {"oid": "d69c0121a94474264821a25df299ecf667dfefdf", "url": "https://github.com/MegaMek/mekhq/commit/d69c0121a94474264821a25df299ecf667dfefdf", "message": "merge from upstream", "committedDate": "2021-02-13T03:37:21Z", "type": "commit"}, {"oid": "3f294419814215e362a1dd3db6b203e6ed84305a", "url": "https://github.com/MegaMek/mekhq/commit/3f294419814215e362a1dd3db6b203e6ed84305a", "message": "fix NPE", "committedDate": "2021-02-13T04:14:06Z", "type": "commit"}, {"oid": "7f59899475e511f98ed9f64a1c10efab11737c43", "url": "https://github.com/MegaMek/mekhq/commit/7f59899475e511f98ed9f64a1c10efab11737c43", "message": "merge from upstream", "committedDate": "2021-03-06T02:50:52Z", "type": "commit"}, {"oid": "b19752176bb0619f7ccda9f75d551b050521a106", "url": "https://github.com/MegaMek/mekhq/commit/b19752176bb0619f7ccda9f75d551b050521a106", "message": "merge from upstream", "committedDate": "2021-03-09T04:25:41Z", "type": "commit"}, {"oid": "c04f51a981c0536c09377e28e397b5dfaef69218", "url": "https://github.com/MegaMek/mekhq/commit/c04f51a981c0536c09377e28e397b5dfaef69218", "message": "render deployed forces; part of support point costs;", "committedDate": "2021-03-10T04:31:23Z", "type": "commit"}, {"oid": "f32def02a67d9150e646b1b38db20fad6b3e0c18", "url": "https://github.com/MegaMek/mekhq/commit/f32def02a67d9150e646b1b38db20fad6b3e0c18", "message": "reinforcement deployment mechanics; facility visibility issue", "committedDate": "2021-03-11T03:46:10Z", "type": "commit"}, {"oid": "9f9de190227f34a974a69540ab1cab048a50792a", "url": "https://github.com/MegaMek/mekhq/commit/9f9de190227f34a974a69540ab1cab048a50792a", "message": "preferences; tokens", "committedDate": "2021-03-12T03:21:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzM4MzA1NA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593383054", "bodyText": "Lets hoist this out into its own method just to reduce the complexity of this method.\nBonus points if it goes into its own class (for testability).", "author": "sixlettervariables", "createdAt": "2021-03-12T18:59:37Z", "path": "MekHQ/src/mekhq/campaign/Campaign.java", "diffHunk": "@@ -875,6 +892,27 @@ public void importMission(Mission m) {\n         }\n \n         addMissionWithoutId(m);\n+        \n+        if(m instanceof AtBContract) {\n+            // having loaded scenarios and such, we now need to go through any stratcon scenarios for this contract\n+            // and set their backing scenario pointers to the existing scenarios stored in the campaign for this contract\n+            AtBContract atbContract = (AtBContract) m;\n+            if(atbContract.getStratconCampaignState() != null) {\n+                for(StratconTrackState track : atbContract.getStratconCampaignState().getTracks()) {\n+                    for(StratconScenario scenario : track.getScenarios().values()) {\n+                        Scenario campaignScenario = getScenario(scenario.getBackingScenarioID());\n+                        \n+                        if(campaignScenario != null && campaignScenario instanceof AtBDynamicScenario) {\n+                            scenario.setBackingScenario((AtBDynamicScenario) campaignScenario);\n+                        } else {\n+                            MekHQ.getLogger().warning(Campaign.class, \"importMission\", \n+                                    String.format(\"Unable to set backing scenario for stratcon scenario in track %s ID %d\", \n+                                            track.getDisplayableName(), scenario.getBackingScenarioID()));\n+                        }\n+                    }\n+                }\n+            }\n+        }", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzM4NTEzMA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593385130", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        unitTypeBuckets.putIfAbsent(unitType, 0);\n          \n          \n            \n                        unitTypeBuckets.put(unitType, unitTypeBuckets.get(unitType) + 1);\n          \n          \n            \n                        \n          \n          \n            \n                        if(unitTypeBuckets.get(unitType) > biggestBucketCount) {\n          \n          \n            \n                            biggestBucketCount = unitTypeBuckets.get(unitType);\n          \n          \n            \n                        int count = unitTypeBuckets.merge(unitType, 1, (oldCount, value) -> oldCount + value);\n          \n          \n            \n                        \n          \n          \n            \n                        if (count > biggestBucketCount) {\n          \n          \n            \n                            biggestBucketCount = count;", "author": "sixlettervariables", "createdAt": "2021-03-12T19:03:23Z", "path": "MekHQ/src/mekhq/campaign/force/Force.java", "diffHunk": "@@ -591,4 +601,30 @@ public int getTotalBV(Campaign c) {\n \n         return bvTotal;\n     }\n+    \n+    /**\n+     * Calculates the unit type most represented in this force\n+     * and all subforces.\n+     * @param c Working campaign\n+     * @return Majority unit type.\n+     */\n+    public int getPrimaryUnitType(Campaign c) {\n+        Map<Integer, Integer> unitTypeBuckets = new TreeMap<>();\n+        int biggestBucketID = -1;\n+        int biggestBucketCount = 0;\n+        \n+        for(UUID id : getUnits()) {\n+            int unitType = c.getUnit(id).getEntity().getUnitType();\n+\n+            unitTypeBuckets.putIfAbsent(unitType, 0);\n+            unitTypeBuckets.put(unitType, unitTypeBuckets.get(unitType) + 1);\n+            \n+            if(unitTypeBuckets.get(unitType) > biggestBucketCount) {\n+                biggestBucketCount = unitTypeBuckets.get(unitType);", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzM4NTg3MQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593385871", "bodyText": "The isEmpty check is superfluous, contains below will return immediately (unless of course getTemplate() is expensive and you'd like to avoid that call (but I don't think it is).", "author": "sixlettervariables", "createdAt": "2021-03-12T19:04:41Z", "path": "MekHQ/src/mekhq/campaign/mission/AtBDynamicScenario.java", "diffHunk": "@@ -294,8 +311,45 @@ public void setScenarioModifiers(List<AtBScenarioModifier> scenarioModifiers) {\n         return scenarioModifiers;\n     }\n \n+    /**\n+     * Adds a scenario modifier and any linked modifiers to this scenario,\n+     * provided that the modifier exists and can be applied to the scenario (e.g. ground units on air map)\n+     */\n     public void addScenarioModifier(AtBScenarioModifier modifier) {\n+        if (modifier == null) {\n+            return;\n+        }\n+        \n+        if ((modifier.getAllowedMapLocations() != null) && !modifier.getAllowedMapLocations().isEmpty() &&", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzM4NjM5OA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593386398", "bodyText": "Is this a bug fix?", "author": "sixlettervariables", "createdAt": "2021-03-12T19:05:38Z", "path": "MekHQ/src/mekhq/campaign/mission/AtBDynamicScenarioFactory.java", "diffHunk": "@@ -2263,7 +2270,7 @@ public static int getAeroLanceSize(int unitTypeCode, boolean isPlanetOwner, Stri\n      * @param entityList\n      */\n     private static void deployArtilleryOffBoard(List<Entity> entityList) {\n-        OffBoardDirection direction = OffBoardDirection.getDirection(Compute.randomInt(4) + 1);\n+        OffBoardDirection direction = OffBoardDirection.getDirection(Compute.randomInt(4));", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzgzMTMwMQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593831301", "bodyText": "Yeah, I kept getting \"invalid off board direction crashes\" because 4 is not a valid off board direction (it's 0-3).\nWhich I guess answers my earlier question if \"does randomInt()\" include the upper bound number.", "author": "NickAragua", "createdAt": "2021-03-14T02:43:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzM4NjM5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzM4NjgyNg==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593386826", "bodyText": "I thought we had a routine to SerDe simple dictionaries?", "author": "sixlettervariables", "createdAt": "2021-03-12T19:06:24Z", "path": "MekHQ/src/mekhq/campaign/mission/AtBScenario.java", "diffHunk": "@@ -1635,6 +1638,19 @@ protected void writeToXmlEnd(PrintWriter pw1, int indent) {\n \n             pw1.println(MekHqXmlUtil.indentStr(indent+1) + \"</transportLinkages>\");\n         }\n+        \n+        if (numPlayerMinefields.size() > 0) {\n+            pw1.println(MekHqXmlUtil.indentStr(indent+1) + \"<numPlayerMinefields>\");\n+\n+            for (int key : numPlayerMinefields.keySet()) {\n+                pw1.println(MekHqXmlUtil.indentStr(indent+2) + \"<numPlayerMinefield>\");\n+                MekHqXmlUtil.writeSimpleXmlTag(pw1, indent + 3, \"minefieldType\", key);\n+                MekHqXmlUtil.writeSimpleXmlTag(pw1, indent + 3, \"minefieldCount\", numPlayerMinefields.get(key).toString());\n+                pw1.println(MekHqXmlUtil.indentStr(indent+2) + \"</numPlayerMinefield>\");\n+            }\n+\n+            pw1.println(MekHqXmlUtil.indentStr(indent+1) + \"</numPlayerMinefields>\");\n+        }", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzU0ODEzMg==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593548132", "bodyText": "Yeah, I think we do, I just can't for the life of me remember where the hell it is.", "author": "NickAragua", "createdAt": "2021-03-13T02:50:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzM4NjgyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzM4NzA4Mw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593387083", "bodyText": "Suggested change", "author": "sixlettervariables", "createdAt": "2021-03-12T19:06:49Z", "path": "MekHQ/src/mekhq/campaign/mission/Mission.java", "diffHunk": "@@ -313,7 +313,7 @@ public static Mission generateInstanceFromXML(Node wn, Campaign c, Version versi\n             // Doh!\n             MekHQ.getLogger().error(Mission.class, ex);\n         }\n-\n+        ", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzM4NzE2NA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593387164", "bodyText": "Suggested change", "author": "sixlettervariables", "createdAt": "2021-03-12T19:06:58Z", "path": "MekHQ/src/mekhq/campaign/mission/CrewSkillUpgrader.java", "diffHunk": "@@ -254,6 +254,7 @@ private String pickRandomWeapon(Entity entity, boolean clusterOnly) {\n     private String pickRandomGunnerySpecialization(Entity entity) {\n         // if you've got no weapons, tough\n         if (entity.getIndividualWeaponList().size() <= 0) {\n+", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzM4NzgzMQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593387831", "bodyText": "I think you should be able to make this return ScenarioMapParameters, as that is a more derived type.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public Object clone() {\n          \n          \n            \n                @Override\n          \n          \n            \n                public ScenarioMapParameters clone() {", "author": "sixlettervariables", "createdAt": "2021-03-12T19:08:07Z", "path": "MekHQ/src/mekhq/campaign/mission/ScenarioMapParameters.java", "diffHunk": "@@ -11,14 +11,28 @@\n  * @author NickAragua\n  *\n  */\n-public class ScenarioMapParameters {\n+public class ScenarioMapParameters implements Cloneable {\n     public enum MapLocation {\n         AllGroundTerrain,\n         SpecificGroundTerrain,\n         Space,\n         LowAtmosphere\n     }\n     \n+    public Object clone() {", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzM4ODA1Mw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593388053", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public ScenarioTemplate clone() {\n          \n          \n            \n                @Override\n          \n          \n            \n                public ScenarioTemplate clone() {", "author": "sixlettervariables", "createdAt": "2021-03-12T19:08:33Z", "path": "MekHQ/src/mekhq/campaign/mission/ScenarioTemplate.java", "diffHunk": "@@ -51,6 +54,29 @@\n     @XmlElement(name=\"scenarioObjective\")\n     public List<ScenarioObjective> scenarioObjectives = new ArrayList<>();\n     \n+    public ScenarioTemplate clone() {", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzM4OTA3MA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593389070", "bodyText": "?", "author": "sixlettervariables", "createdAt": "2021-03-12T19:10:14Z", "path": "MekHQ/src/mekhq/campaign/mission/atb/AtBScenarioModifier.java", "diffHunk": "@@ -75,12 +89,17 @@\n     private List<MapLocation> allowedMapLocations = null;\n     private Boolean useAmbushLogic = null; \n     private Boolean switchSides = null;\n+    private Integer numExtraEvents = null;\n     private List<ScenarioObjective> objectives = new ArrayList<>();\n     \n+    private Map<String, String> linkedModifiers = new HashMap<>(); \n+    \n     public static AtBScenarioModifier generateTestModifier() {\n         AtBScenarioModifier sm = new AtBScenarioModifier();\n         sm.objectives = new ArrayList<>();\n-        sm.objectives.add(new ScenarioObjective());\n+        ScenarioObjective sob = new ScenarioObjective();\n+        sob.addDetail(\"BARFO\");\n+        sm.objectives.add(sob);", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzU1MTYyMA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593551620", "bodyText": "lol", "author": "NickAragua", "createdAt": "2021-03-13T03:24:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzM4OTA3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzM4OTM4NA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593389384", "bodyText": "Why not int if null and 0 are treated the same in the code?", "author": "sixlettervariables", "createdAt": "2021-03-12T19:10:52Z", "path": "MekHQ/src/mekhq/campaign/mission/atb/AtBScenarioModifier.java", "diffHunk": "@@ -75,12 +89,17 @@\n     private List<MapLocation> allowedMapLocations = null;\n     private Boolean useAmbushLogic = null; \n     private Boolean switchSides = null;\n+    private Integer numExtraEvents = null;", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzU1MjA3Mw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593552073", "bodyText": "I probably followed the pattern for the other booleans.", "author": "NickAragua", "createdAt": "2021-03-13T03:28:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzM4OTM4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzM5MDQ1MQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593390451", "bodyText": "Isn't this just scenarioModifiers::keySet ?", "author": "sixlettervariables", "createdAt": "2021-03-12T19:12:46Z", "path": "MekHQ/src/mekhq/campaign/mission/atb/AtBScenarioModifier.java", "diffHunk": "@@ -147,7 +171,17 @@ public void processModifier(AtBDynamicScenario scenario, Campaign campaign, Even\n     }\n     \n     private static Map<String, AtBScenarioModifier> scenarioModifiers;\n-    private static List<String> scenarioModifierKeys;\n+    private static List<String> scenarioModifierKeys = new ArrayList<>();", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzU1MTc2NQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593551765", "bodyText": "Yeah, but I sort it once on load for display purposes (rather than sorting it every time a combo box or whatever gets populated)", "author": "NickAragua", "createdAt": "2021-03-13T03:26:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzM5MDQ1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzM5MDc2NA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593390764", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public Object clone() {\n          \n          \n            \n                public AtBScenarioModifier clone() {", "author": "sixlettervariables", "createdAt": "2021-03-12T19:13:19Z", "path": "MekHQ/src/mekhq/campaign/mission/atb/AtBScenarioModifier.java", "diffHunk": "@@ -272,15 +421,38 @@ public void Serialize(File outputFile) {\n             m.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);\n             m.marshal(templateElement, outputFile);\n         } catch(Exception e) {\n-            MekHQ.getLogger().error(AtBScenarioModifier.class, \"Serialize\", e.getMessage());\n+            MekHQ.getLogger().error(e);\n         }\n     }\n     \n     @Override\n     public String toString() {\n         return getModifierName();\n     }\n-\n+    \n+    @Override\n+    public Object clone() {", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzM5MTEwNA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593391104", "bodyText": "headerify", "author": "sixlettervariables", "createdAt": "2021-03-12T19:13:56Z", "path": "MekHQ/src/mekhq/campaign/stratcon/IStratconDisplayable.java", "diffHunk": "@@ -0,0 +1,11 @@\n+package mekhq.campaign.stratcon;", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzM5MTEyOQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593391129", "bodyText": "headerify", "author": "sixlettervariables", "createdAt": "2021-03-12T19:13:59Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconCampaignState.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package mekhq.campaign.stratcon;", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzM5MTc4Mg==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593391782", "bodyText": "Should this ensure victoryPoints > 0?", "author": "sixlettervariables", "createdAt": "2021-03-12T19:15:12Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconCampaignState.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package mekhq.campaign.stratcon;\n+\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBElement;\n+import javax.xml.bind.Marshaller;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlTransient;\n+import javax.xml.namespace.QName;\n+\n+import org.w3c.dom.Node;\n+\n+import mekhq.MekHQ;\n+import mekhq.campaign.mission.AtBContract;\n+\n+/**\n+ * Contract-level state object for a stratcon campaign.\n+ * @author NickAragua\n+ *\n+ */\n+@XmlRootElement(name=\"StratconCampaignState\")\n+public class StratconCampaignState {\n+    public static final String ROOT_XML_ELEMENT_NAME = \"StratconCampaignState\";\n+    \n+    @XmlTransient\n+    private AtBContract contract;\n+\n+    // these are all state variables that affect the current Stratcon Campaign\n+    private double globalOpforBVMultiplier;\n+    private int supportPoints;\n+    private int victoryPoints;\n+    private int pendingStrategicObjectiveCount;\n+    private int completedStrategicObjectiveCount;\n+    private String briefingText; \n+    private boolean strategicObjectivesBehaveAsVPs;\n+    \n+    // these are applied to any scenario generated in the campaign; use sparingly\n+    private List<String> globalScenarioModifiers = new ArrayList<>(); \n+    \n+    @XmlElementWrapper(name=\"campaignTracks\")\n+    @XmlElement(name=\"campaignTrack\")\n+    private List<StratconTrackState> tracks;\n+\n+    @XmlTransient\n+    public AtBContract getContract() {\n+        return contract;\n+    }\n+\n+    public void setContract(AtBContract contract) {\n+        this.contract = contract;\n+    }\n+\n+    public StratconCampaignState() {\n+        tracks = new ArrayList<>();\n+    }\n+    \n+    public StratconCampaignState(AtBContract contract) {\n+        tracks = new ArrayList<>();\n+        this.setContract(contract);\n+    }\n+\n+    /**\n+     * The opfor BV multiplier. Intended to be additive.\n+     * @return The additive opfor BV multiplier.\n+     */\n+    public double getGlobalOpforBVMultiplier() {\n+        return globalOpforBVMultiplier;\n+    }\n+    \n+    public StratconTrackState getTrack(int index) {\n+        return tracks.get(index);\n+    }\n+    \n+    public List<StratconTrackState> getTracks() {\n+        return tracks;\n+    }\n+    \n+    public void addTrack(StratconTrackState track) {\n+        tracks.add(track);\n+    }\n+    \n+    public int getSupportPoints() {\n+        return supportPoints;\n+    }\n+    \n+    public void addSupportPoints(int number) {\n+        supportPoints += number;\n+    }\n+    \n+    public void setSupportPoints(int supportPoints) {\n+        this.supportPoints = supportPoints;\n+    }\n+\n+    public int getVictoryPoints() {\n+        return victoryPoints;\n+    }\n+\n+    public void setVictoryPoints(int victoryPoints) {\n+        this.victoryPoints = victoryPoints;\n+    }\n+    \n+    public void updateVictoryPoints(int increment) {\n+        victoryPoints += increment;\n+    }\n+\n+    public String getBriefingText() {\n+        return briefingText;\n+    }\n+\n+    public void setBriefingText(String briefingText) {\n+        this.briefingText = briefingText;\n+    }\n+\n+    public boolean strategicObjectivesBehaveAsVPs() {\n+        return strategicObjectivesBehaveAsVPs;\n+    }\n+\n+    public void setStrategicObjectivesBehaveAsVPs(boolean strategicObjectivesBehaveAsVPs) {\n+        this.strategicObjectivesBehaveAsVPs = strategicObjectivesBehaveAsVPs;\n+    }\n+\n+    public List<String> getGlobalScenarioModifiers() {\n+        return globalScenarioModifiers;\n+    }\n+\n+    public void setGlobalScenarioModifiers(List<String> globalScenarioModifiers) {\n+        this.globalScenarioModifiers = globalScenarioModifiers;\n+    }\n+\n+    public int getPendingStrategicObjectiveCount() {\n+        return pendingStrategicObjectiveCount;\n+    }\n+\n+    public void setPendingStrategicObjectiveCount(int pendingStrategicObjectiveCount) {\n+        this.pendingStrategicObjectiveCount = pendingStrategicObjectiveCount;\n+    }\n+    \n+    public void incrementPendingStrategicObjectiveCount(int increment) {\n+        this.pendingStrategicObjectiveCount += increment;\n+    }\n+    \n+    public void incrementPendingStrategicObjectiveCount() {\n+        pendingStrategicObjectiveCount++;\n+    }\n+    \n+    public int getStrategicObjectiveCompletedCount() {\n+        return completedStrategicObjectiveCount;\n+    }\n+    \n+    public void incrementStrategicObjectiveCompletedCount() {\n+        completedStrategicObjectiveCount++;\n+    }\n+    \n+    public void decrementStrategicObjectiveCompletedCount() {\n+        completedStrategicObjectiveCount--;\n+    }\n+    \n+    public void useSupportPoint() {\n+        supportPoints--;\n+    }\n+    \n+    public void convertVictoryToSupportPoint() {\n+        victoryPoints--;\n+        supportPoints++;\n+    }", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzgzMTc4MA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593831780", "bodyText": "I'd prefer for this class to be pretty dumb and for most of the rules logic to reside in the RulesManager class.", "author": "NickAragua", "createdAt": "2021-03-14T02:49:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzM5MTc4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzM5MTkwNw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593391907", "bodyText": "Should this ensure supportPoints > 0?", "author": "sixlettervariables", "createdAt": "2021-03-12T19:15:23Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconCampaignState.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package mekhq.campaign.stratcon;\n+\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBElement;\n+import javax.xml.bind.Marshaller;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlTransient;\n+import javax.xml.namespace.QName;\n+\n+import org.w3c.dom.Node;\n+\n+import mekhq.MekHQ;\n+import mekhq.campaign.mission.AtBContract;\n+\n+/**\n+ * Contract-level state object for a stratcon campaign.\n+ * @author NickAragua\n+ *\n+ */\n+@XmlRootElement(name=\"StratconCampaignState\")\n+public class StratconCampaignState {\n+    public static final String ROOT_XML_ELEMENT_NAME = \"StratconCampaignState\";\n+    \n+    @XmlTransient\n+    private AtBContract contract;\n+\n+    // these are all state variables that affect the current Stratcon Campaign\n+    private double globalOpforBVMultiplier;\n+    private int supportPoints;\n+    private int victoryPoints;\n+    private int pendingStrategicObjectiveCount;\n+    private int completedStrategicObjectiveCount;\n+    private String briefingText; \n+    private boolean strategicObjectivesBehaveAsVPs;\n+    \n+    // these are applied to any scenario generated in the campaign; use sparingly\n+    private List<String> globalScenarioModifiers = new ArrayList<>(); \n+    \n+    @XmlElementWrapper(name=\"campaignTracks\")\n+    @XmlElement(name=\"campaignTrack\")\n+    private List<StratconTrackState> tracks;\n+\n+    @XmlTransient\n+    public AtBContract getContract() {\n+        return contract;\n+    }\n+\n+    public void setContract(AtBContract contract) {\n+        this.contract = contract;\n+    }\n+\n+    public StratconCampaignState() {\n+        tracks = new ArrayList<>();\n+    }\n+    \n+    public StratconCampaignState(AtBContract contract) {\n+        tracks = new ArrayList<>();\n+        this.setContract(contract);\n+    }\n+\n+    /**\n+     * The opfor BV multiplier. Intended to be additive.\n+     * @return The additive opfor BV multiplier.\n+     */\n+    public double getGlobalOpforBVMultiplier() {\n+        return globalOpforBVMultiplier;\n+    }\n+    \n+    public StratconTrackState getTrack(int index) {\n+        return tracks.get(index);\n+    }\n+    \n+    public List<StratconTrackState> getTracks() {\n+        return tracks;\n+    }\n+    \n+    public void addTrack(StratconTrackState track) {\n+        tracks.add(track);\n+    }\n+    \n+    public int getSupportPoints() {\n+        return supportPoints;\n+    }\n+    \n+    public void addSupportPoints(int number) {\n+        supportPoints += number;\n+    }\n+    \n+    public void setSupportPoints(int supportPoints) {\n+        this.supportPoints = supportPoints;\n+    }\n+\n+    public int getVictoryPoints() {\n+        return victoryPoints;\n+    }\n+\n+    public void setVictoryPoints(int victoryPoints) {\n+        this.victoryPoints = victoryPoints;\n+    }\n+    \n+    public void updateVictoryPoints(int increment) {\n+        victoryPoints += increment;\n+    }\n+\n+    public String getBriefingText() {\n+        return briefingText;\n+    }\n+\n+    public void setBriefingText(String briefingText) {\n+        this.briefingText = briefingText;\n+    }\n+\n+    public boolean strategicObjectivesBehaveAsVPs() {\n+        return strategicObjectivesBehaveAsVPs;\n+    }\n+\n+    public void setStrategicObjectivesBehaveAsVPs(boolean strategicObjectivesBehaveAsVPs) {\n+        this.strategicObjectivesBehaveAsVPs = strategicObjectivesBehaveAsVPs;\n+    }\n+\n+    public List<String> getGlobalScenarioModifiers() {\n+        return globalScenarioModifiers;\n+    }\n+\n+    public void setGlobalScenarioModifiers(List<String> globalScenarioModifiers) {\n+        this.globalScenarioModifiers = globalScenarioModifiers;\n+    }\n+\n+    public int getPendingStrategicObjectiveCount() {\n+        return pendingStrategicObjectiveCount;\n+    }\n+\n+    public void setPendingStrategicObjectiveCount(int pendingStrategicObjectiveCount) {\n+        this.pendingStrategicObjectiveCount = pendingStrategicObjectiveCount;\n+    }\n+    \n+    public void incrementPendingStrategicObjectiveCount(int increment) {\n+        this.pendingStrategicObjectiveCount += increment;\n+    }\n+    \n+    public void incrementPendingStrategicObjectiveCount() {\n+        pendingStrategicObjectiveCount++;\n+    }\n+    \n+    public int getStrategicObjectiveCompletedCount() {\n+        return completedStrategicObjectiveCount;\n+    }\n+    \n+    public void incrementStrategicObjectiveCompletedCount() {\n+        completedStrategicObjectiveCount++;\n+    }\n+    \n+    public void decrementStrategicObjectiveCompletedCount() {\n+        completedStrategicObjectiveCount--;\n+    }\n+    \n+    public void useSupportPoint() {\n+        supportPoints--;\n+    }", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzM5MjA2MA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593392060", "bodyText": "should this ensure completedStrategicObjectiveCount > 0?", "author": "sixlettervariables", "createdAt": "2021-03-12T19:15:36Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconCampaignState.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package mekhq.campaign.stratcon;\n+\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBElement;\n+import javax.xml.bind.Marshaller;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlTransient;\n+import javax.xml.namespace.QName;\n+\n+import org.w3c.dom.Node;\n+\n+import mekhq.MekHQ;\n+import mekhq.campaign.mission.AtBContract;\n+\n+/**\n+ * Contract-level state object for a stratcon campaign.\n+ * @author NickAragua\n+ *\n+ */\n+@XmlRootElement(name=\"StratconCampaignState\")\n+public class StratconCampaignState {\n+    public static final String ROOT_XML_ELEMENT_NAME = \"StratconCampaignState\";\n+    \n+    @XmlTransient\n+    private AtBContract contract;\n+\n+    // these are all state variables that affect the current Stratcon Campaign\n+    private double globalOpforBVMultiplier;\n+    private int supportPoints;\n+    private int victoryPoints;\n+    private int pendingStrategicObjectiveCount;\n+    private int completedStrategicObjectiveCount;\n+    private String briefingText; \n+    private boolean strategicObjectivesBehaveAsVPs;\n+    \n+    // these are applied to any scenario generated in the campaign; use sparingly\n+    private List<String> globalScenarioModifiers = new ArrayList<>(); \n+    \n+    @XmlElementWrapper(name=\"campaignTracks\")\n+    @XmlElement(name=\"campaignTrack\")\n+    private List<StratconTrackState> tracks;\n+\n+    @XmlTransient\n+    public AtBContract getContract() {\n+        return contract;\n+    }\n+\n+    public void setContract(AtBContract contract) {\n+        this.contract = contract;\n+    }\n+\n+    public StratconCampaignState() {\n+        tracks = new ArrayList<>();\n+    }\n+    \n+    public StratconCampaignState(AtBContract contract) {\n+        tracks = new ArrayList<>();\n+        this.setContract(contract);\n+    }\n+\n+    /**\n+     * The opfor BV multiplier. Intended to be additive.\n+     * @return The additive opfor BV multiplier.\n+     */\n+    public double getGlobalOpforBVMultiplier() {\n+        return globalOpforBVMultiplier;\n+    }\n+    \n+    public StratconTrackState getTrack(int index) {\n+        return tracks.get(index);\n+    }\n+    \n+    public List<StratconTrackState> getTracks() {\n+        return tracks;\n+    }\n+    \n+    public void addTrack(StratconTrackState track) {\n+        tracks.add(track);\n+    }\n+    \n+    public int getSupportPoints() {\n+        return supportPoints;\n+    }\n+    \n+    public void addSupportPoints(int number) {\n+        supportPoints += number;\n+    }\n+    \n+    public void setSupportPoints(int supportPoints) {\n+        this.supportPoints = supportPoints;\n+    }\n+\n+    public int getVictoryPoints() {\n+        return victoryPoints;\n+    }\n+\n+    public void setVictoryPoints(int victoryPoints) {\n+        this.victoryPoints = victoryPoints;\n+    }\n+    \n+    public void updateVictoryPoints(int increment) {\n+        victoryPoints += increment;\n+    }\n+\n+    public String getBriefingText() {\n+        return briefingText;\n+    }\n+\n+    public void setBriefingText(String briefingText) {\n+        this.briefingText = briefingText;\n+    }\n+\n+    public boolean strategicObjectivesBehaveAsVPs() {\n+        return strategicObjectivesBehaveAsVPs;\n+    }\n+\n+    public void setStrategicObjectivesBehaveAsVPs(boolean strategicObjectivesBehaveAsVPs) {\n+        this.strategicObjectivesBehaveAsVPs = strategicObjectivesBehaveAsVPs;\n+    }\n+\n+    public List<String> getGlobalScenarioModifiers() {\n+        return globalScenarioModifiers;\n+    }\n+\n+    public void setGlobalScenarioModifiers(List<String> globalScenarioModifiers) {\n+        this.globalScenarioModifiers = globalScenarioModifiers;\n+    }\n+\n+    public int getPendingStrategicObjectiveCount() {\n+        return pendingStrategicObjectiveCount;\n+    }\n+\n+    public void setPendingStrategicObjectiveCount(int pendingStrategicObjectiveCount) {\n+        this.pendingStrategicObjectiveCount = pendingStrategicObjectiveCount;\n+    }\n+    \n+    public void incrementPendingStrategicObjectiveCount(int increment) {\n+        this.pendingStrategicObjectiveCount += increment;\n+    }\n+    \n+    public void incrementPendingStrategicObjectiveCount() {\n+        pendingStrategicObjectiveCount++;\n+    }\n+    \n+    public int getStrategicObjectiveCompletedCount() {\n+        return completedStrategicObjectiveCount;\n+    }\n+    \n+    public void incrementStrategicObjectiveCompletedCount() {\n+        completedStrategicObjectiveCount++;\n+    }\n+    \n+    public void decrementStrategicObjectiveCompletedCount() {\n+        completedStrategicObjectiveCount--;\n+    }", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzM5Mjc0Mw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593392743", "bodyText": "headerify", "author": "sixlettervariables", "createdAt": "2021-03-12T19:16:44Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconContractDefinition.java", "diffHunk": "@@ -0,0 +1,420 @@\n+package mekhq.campaign.stratcon;", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzM5MzEzMQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593393131", "bodyText": "We should find a way to avoid these actions within a static constructor.", "author": "sixlettervariables", "createdAt": "2021-03-12T19:17:20Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconContractDefinition.java", "diffHunk": "@@ -0,0 +1,420 @@\n+package mekhq.campaign.stratcon;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBElement;\n+import javax.xml.bind.Marshaller;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.namespace.QName;\n+import javax.xml.transform.Source;\n+\n+import mekhq.MekHQ;\n+import mekhq.MekHqXmlUtil;\n+\n+/**\n+ * This class holds data relevant to the various types of contract\n+ * that can occur in the StratCon campaign system.\n+ * @author NickAragua\n+ *\n+ */\n+@XmlRootElement(name=\"StratconContractDefinition\")\n+public class StratconContractDefinition {\n+    public static final String ROOT_XML_ELEMENT_NAME = \"ScenarioTemplate\";\n+    public static final int COUNT_SCALED = -1;\n+    \n+    private static ContractDefinitionManifest definitionManifest;\n+    private static Map<Integer, StratconContractDefinition> loadedDefinitions = new HashMap<>();\n+    \n+    static {\n+        definitionManifest = ContractDefinitionManifest.Deserialize(\"./data/stratconcontractdefinitions/ContractDefinitionManifest.xml\");\n+        \n+        // load user-specified modifier list\n+        ContractDefinitionManifest userDefinitionList = ContractDefinitionManifest.Deserialize(\"./data/scenariomodifiers/UserContractDefinitionManifest.xml\");\n+        if(userDefinitionList != null) {\n+            definitionManifest.definitionFileNames.putAll(userDefinitionList.definitionFileNames);\n+        }\n+    }", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzM5MzY4OA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593393688", "bodyText": "This should likely be moved to an initialization method.\nAlso, it appears that it will always reload the specific contract type because of that clear statement.", "author": "sixlettervariables", "createdAt": "2021-03-12T19:18:09Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconContractDefinition.java", "diffHunk": "@@ -0,0 +1,420 @@\n+package mekhq.campaign.stratcon;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBElement;\n+import javax.xml.bind.Marshaller;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.namespace.QName;\n+import javax.xml.transform.Source;\n+\n+import mekhq.MekHQ;\n+import mekhq.MekHqXmlUtil;\n+\n+/**\n+ * This class holds data relevant to the various types of contract\n+ * that can occur in the StratCon campaign system.\n+ * @author NickAragua\n+ *\n+ */\n+@XmlRootElement(name=\"StratconContractDefinition\")\n+public class StratconContractDefinition {\n+    public static final String ROOT_XML_ELEMENT_NAME = \"ScenarioTemplate\";\n+    public static final int COUNT_SCALED = -1;\n+    \n+    private static ContractDefinitionManifest definitionManifest;\n+    private static Map<Integer, StratconContractDefinition> loadedDefinitions = new HashMap<>();\n+    \n+    static {\n+        definitionManifest = ContractDefinitionManifest.Deserialize(\"./data/stratconcontractdefinitions/ContractDefinitionManifest.xml\");\n+        \n+        // load user-specified modifier list\n+        ContractDefinitionManifest userDefinitionList = ContractDefinitionManifest.Deserialize(\"./data/scenariomodifiers/UserContractDefinitionManifest.xml\");\n+        if(userDefinitionList != null) {\n+            definitionManifest.definitionFileNames.putAll(userDefinitionList.definitionFileNames);\n+        }\n+    }\n+    \n+    /**\n+     * Returns the stratcon contract definition for the given AtB Contract Type \n+     * as defined in AtBContract.java\n+     */\n+    public static StratconContractDefinition getContractDefinition(int atbContractType) {\n+        definitionManifest = ContractDefinitionManifest.Deserialize(\"./data/stratconcontractdefinitions/ContractDefinitionManifest.xml\");\n+        loadedDefinitions.clear();", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzM5Mzg5OQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593393899", "bodyText": "This should be removed.", "author": "sixlettervariables", "createdAt": "2021-03-12T19:18:33Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconContractDefinition.java", "diffHunk": "@@ -0,0 +1,420 @@\n+package mekhq.campaign.stratcon;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBElement;\n+import javax.xml.bind.Marshaller;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.namespace.QName;\n+import javax.xml.transform.Source;\n+\n+import mekhq.MekHQ;\n+import mekhq.MekHqXmlUtil;\n+\n+/**\n+ * This class holds data relevant to the various types of contract\n+ * that can occur in the StratCon campaign system.\n+ * @author NickAragua\n+ *\n+ */\n+@XmlRootElement(name=\"StratconContractDefinition\")\n+public class StratconContractDefinition {\n+    public static final String ROOT_XML_ELEMENT_NAME = \"ScenarioTemplate\";\n+    public static final int COUNT_SCALED = -1;\n+    \n+    private static ContractDefinitionManifest definitionManifest;\n+    private static Map<Integer, StratconContractDefinition> loadedDefinitions = new HashMap<>();\n+    \n+    static {\n+        definitionManifest = ContractDefinitionManifest.Deserialize(\"./data/stratconcontractdefinitions/ContractDefinitionManifest.xml\");\n+        \n+        // load user-specified modifier list\n+        ContractDefinitionManifest userDefinitionList = ContractDefinitionManifest.Deserialize(\"./data/scenariomodifiers/UserContractDefinitionManifest.xml\");\n+        if(userDefinitionList != null) {\n+            definitionManifest.definitionFileNames.putAll(userDefinitionList.definitionFileNames);\n+        }\n+    }\n+    \n+    /**\n+     * Returns the stratcon contract definition for the given AtB Contract Type \n+     * as defined in AtBContract.java\n+     */\n+    public static StratconContractDefinition getContractDefinition(int atbContractType) {\n+        definitionManifest = ContractDefinitionManifest.Deserialize(\"./data/stratconcontractdefinitions/ContractDefinitionManifest.xml\");\n+        loadedDefinitions.clear();\n+        \n+        if (!loadedDefinitions.containsKey(atbContractType)) {\n+            String filePath = String.format(\"./data/stratconcontractdefinitions/%s\", \n+                    definitionManifest.definitionFileNames.get(atbContractType));\n+            StratconContractDefinition def = Deserialize(new File(filePath));\n+            \n+            if (def == null) {\n+                MekHQ.getLogger().error(String.format(\"Unable to load contract definition %s\", filePath));\n+                return null;\n+            }\n+            \n+            loadedDefinitions.put(atbContractType, def);\n+        }\n+        \n+        return loadedDefinitions.get(atbContractType);\n+    }\n+    \n+    /**\n+     * The kind of actions that the player needs to undertake to complete\n+     * strategic objectives for this contract.\n+     *\n+     */\n+    public enum StrategicObjectiveType {\n+        /**\n+         * Victory in any scenario\n+         */\n+        AnyScenarioVictory,\n+        \n+        /**\n+         * Victory in scenarios - designated by the \"objectiveScenarios\" collection.\n+         * These are one-off scenarios that stick around on tracks - when revealed, \n+         * they get a deploy/action/return date as usual, and the player gets one shot to complete them\n+         */\n+        SpecificScenarioVictory,\n+        \n+        /**\n+         * Control of allied facilities generated at contract start time\n+         * Each track will be seeded with some number of allied facilities\n+         * They must not be destroyed and the player must have control of them at the end-of-contract date \n+         */\n+        AlliedFacilityControl,\n+        \n+        /**\n+         * Control of hostile facilities generated at contract start time\n+         * Each track will be seeded with some number of hostile facilities\n+         * They must not be destroyed and the player must have control of them at the end-of-contract date\n+         */\n+        HostileFacilityControl,\n+        \n+        /**\n+         * Destruction of hostile facilities generated at contract start time\n+         * Each track will be seeded with some number of hostile facilities\n+         * They may either be destroyed or the player must have control of them at the end-of-contract date\n+         */\n+        FacilityDestruction\n+    }\n+    \n+    public static StratconContractDefinition createTestContract() {\n+        /*StratconContractDefinition retVal = new StratconContractDefinition();\n+        \n+        retVal.contractTypeName = \"Test Contract Type\";\n+        retVal.briefing = \"Test Contract Briefing.\";\n+        retVal.alliedFacilityCount = 1;\n+        retVal.hostileFacilityCount = COUNT_SCALED;\n+        retVal.objectiveParameters = new ArrayList<>();\n+        \n+        ObjectiveParameters objective = new ObjectiveParameters();\n+        objective.objectiveType = StrategicObjectiveType.SpecificScenarioVictory;\n+        objective.objectiveCount = COUNT_SCALED;\n+        objective.objectiveScenarios = Arrays.asList(\"Capture.xml\", \"Assassinate.xml\");\n+        objective.objectiveScenarioModifiers = Arrays.asList(\"AlliedTankGarrison.xml\", \"HostileAirGarrison.xml\");\n+        \n+        retVal.objectiveParameters.add(objective);\n+        \n+        retVal.allowedScenarios = Arrays.asList(\"TestAllowScenario.xml\", \"TestAllowScenario.xml\");\n+        retVal.forbiddenScenarios = Arrays.asList(\"TestForbidScenario.xml\", \"TestForbidScenario.xml\");\n+        \n+        retVal.Serialize(new File(\"d:\\\\projects\\\\mekhq\\\\mekhq\\\\data\\\\stratconcontractdefinitions\\\\testcontract.xml\"));\n+        \n+        return retVal;*/\n+        StratconContractDefinition retVal = Deserialize(new File(\"d:\\\\projects\\\\mekhq\\\\mekhq\\\\data\\\\stratconcontractdefinitions\\\\ObjectiveRaid.xml\"));\n+        return retVal;\n+    }", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzM5NDIyMA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593394220", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        MekHQ.getLogger().error(\"Erorr deserializing \" + outputFile.getPath(), e);\n          \n          \n            \n                        MekHQ.getLogger().error(\"Erorr serializing \" + outputFile.getPath(), e);", "author": "sixlettervariables", "createdAt": "2021-03-12T19:19:02Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconContractDefinition.java", "diffHunk": "@@ -0,0 +1,420 @@\n+package mekhq.campaign.stratcon;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBElement;\n+import javax.xml.bind.Marshaller;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.namespace.QName;\n+import javax.xml.transform.Source;\n+\n+import mekhq.MekHQ;\n+import mekhq.MekHqXmlUtil;\n+\n+/**\n+ * This class holds data relevant to the various types of contract\n+ * that can occur in the StratCon campaign system.\n+ * @author NickAragua\n+ *\n+ */\n+@XmlRootElement(name=\"StratconContractDefinition\")\n+public class StratconContractDefinition {\n+    public static final String ROOT_XML_ELEMENT_NAME = \"ScenarioTemplate\";\n+    public static final int COUNT_SCALED = -1;\n+    \n+    private static ContractDefinitionManifest definitionManifest;\n+    private static Map<Integer, StratconContractDefinition> loadedDefinitions = new HashMap<>();\n+    \n+    static {\n+        definitionManifest = ContractDefinitionManifest.Deserialize(\"./data/stratconcontractdefinitions/ContractDefinitionManifest.xml\");\n+        \n+        // load user-specified modifier list\n+        ContractDefinitionManifest userDefinitionList = ContractDefinitionManifest.Deserialize(\"./data/scenariomodifiers/UserContractDefinitionManifest.xml\");\n+        if(userDefinitionList != null) {\n+            definitionManifest.definitionFileNames.putAll(userDefinitionList.definitionFileNames);\n+        }\n+    }\n+    \n+    /**\n+     * Returns the stratcon contract definition for the given AtB Contract Type \n+     * as defined in AtBContract.java\n+     */\n+    public static StratconContractDefinition getContractDefinition(int atbContractType) {\n+        definitionManifest = ContractDefinitionManifest.Deserialize(\"./data/stratconcontractdefinitions/ContractDefinitionManifest.xml\");\n+        loadedDefinitions.clear();\n+        \n+        if (!loadedDefinitions.containsKey(atbContractType)) {\n+            String filePath = String.format(\"./data/stratconcontractdefinitions/%s\", \n+                    definitionManifest.definitionFileNames.get(atbContractType));\n+            StratconContractDefinition def = Deserialize(new File(filePath));\n+            \n+            if (def == null) {\n+                MekHQ.getLogger().error(String.format(\"Unable to load contract definition %s\", filePath));\n+                return null;\n+            }\n+            \n+            loadedDefinitions.put(atbContractType, def);\n+        }\n+        \n+        return loadedDefinitions.get(atbContractType);\n+    }\n+    \n+    /**\n+     * The kind of actions that the player needs to undertake to complete\n+     * strategic objectives for this contract.\n+     *\n+     */\n+    public enum StrategicObjectiveType {\n+        /**\n+         * Victory in any scenario\n+         */\n+        AnyScenarioVictory,\n+        \n+        /**\n+         * Victory in scenarios - designated by the \"objectiveScenarios\" collection.\n+         * These are one-off scenarios that stick around on tracks - when revealed, \n+         * they get a deploy/action/return date as usual, and the player gets one shot to complete them\n+         */\n+        SpecificScenarioVictory,\n+        \n+        /**\n+         * Control of allied facilities generated at contract start time\n+         * Each track will be seeded with some number of allied facilities\n+         * They must not be destroyed and the player must have control of them at the end-of-contract date \n+         */\n+        AlliedFacilityControl,\n+        \n+        /**\n+         * Control of hostile facilities generated at contract start time\n+         * Each track will be seeded with some number of hostile facilities\n+         * They must not be destroyed and the player must have control of them at the end-of-contract date\n+         */\n+        HostileFacilityControl,\n+        \n+        /**\n+         * Destruction of hostile facilities generated at contract start time\n+         * Each track will be seeded with some number of hostile facilities\n+         * They may either be destroyed or the player must have control of them at the end-of-contract date\n+         */\n+        FacilityDestruction\n+    }\n+    \n+    public static StratconContractDefinition createTestContract() {\n+        /*StratconContractDefinition retVal = new StratconContractDefinition();\n+        \n+        retVal.contractTypeName = \"Test Contract Type\";\n+        retVal.briefing = \"Test Contract Briefing.\";\n+        retVal.alliedFacilityCount = 1;\n+        retVal.hostileFacilityCount = COUNT_SCALED;\n+        retVal.objectiveParameters = new ArrayList<>();\n+        \n+        ObjectiveParameters objective = new ObjectiveParameters();\n+        objective.objectiveType = StrategicObjectiveType.SpecificScenarioVictory;\n+        objective.objectiveCount = COUNT_SCALED;\n+        objective.objectiveScenarios = Arrays.asList(\"Capture.xml\", \"Assassinate.xml\");\n+        objective.objectiveScenarioModifiers = Arrays.asList(\"AlliedTankGarrison.xml\", \"HostileAirGarrison.xml\");\n+        \n+        retVal.objectiveParameters.add(objective);\n+        \n+        retVal.allowedScenarios = Arrays.asList(\"TestAllowScenario.xml\", \"TestAllowScenario.xml\");\n+        retVal.forbiddenScenarios = Arrays.asList(\"TestForbidScenario.xml\", \"TestForbidScenario.xml\");\n+        \n+        retVal.Serialize(new File(\"d:\\\\projects\\\\mekhq\\\\mekhq\\\\data\\\\stratconcontractdefinitions\\\\testcontract.xml\"));\n+        \n+        return retVal;*/\n+        StratconContractDefinition retVal = Deserialize(new File(\"d:\\\\projects\\\\mekhq\\\\mekhq\\\\data\\\\stratconcontractdefinitions\\\\ObjectiveRaid.xml\"));\n+        return retVal;\n+    }\n+    \n+    private String contractTypeName;\n+    private String briefing;\n+    \n+    /**\n+     * How many allied facilities to generate for the contract, \n+     * in addition to any facilities placed by objectives.\n+     * < 0 indicates that the number of facilities should be scaled to the number of \n+     * lances required by the contract. 0 indicates no additional allied facilities.\n+     */\n+    private double alliedFacilityCount;\n+    \n+    /**\n+     * How many hostile facilities to generate for the contract, \n+     * in addition to any facilities placed by objectives.\n+     * -1 indicates that the number of facilities should be scaled to the number of \n+     * lances required by the contract. 0 indicates no additional hostile facilities.\n+     */\n+    private double hostileFacilityCount;\n+    \n+    /**\n+     * List of scenario IDs (file names) that are allowed for this contract type\n+     */\n+    private List<String> allowedScenarios;\n+    \n+    /**\n+     * List of scenario IDs (file names) that are not allowed for this contract type\n+     */\n+    private List<String> forbiddenScenarios;\n+    \n+    /**\n+     * Strategic objectives for this contract.\n+     */\n+    private List<ObjectiveParameters> objectiveParameters;\n+    \n+    /**\n+     * If true, strategic objective scenarios contribute to the VP count\n+     */\n+    private boolean objectivesBehaveAsVPs;\n+    \n+    private List<Integer> scenarioOdds;\n+    \n+    private List<Integer> deploymentTimes;\n+\n+    public String getContractTypeName() {\n+        return contractTypeName;\n+    }\n+\n+    public void setContractTypeName(String contractTypeName) {\n+        this.contractTypeName = contractTypeName;\n+    }\n+\n+    /**\n+     * @return the briefing\n+     */\n+    public String getBriefing() {\n+        return briefing;\n+    }\n+\n+    /**\n+     * @param briefing the briefing to set\n+     */\n+    public void setBriefing(String briefing) {\n+        this.briefing = briefing;\n+    }\n+\n+    /**\n+     * @return the alliedFacilityCount\n+     */\n+    public double getAlliedFacilityCount() {\n+        return alliedFacilityCount;\n+    }\n+\n+    /**\n+     * @param alliedFacilityCount the alliedFacilityCount to set\n+     */\n+    public void setAlliedFacilityCount(double alliedFacilityCount) {\n+        this.alliedFacilityCount = alliedFacilityCount;\n+    }\n+\n+    /**\n+     * @return the hostileFacilityCount\n+     */\n+    public double getHostileFacilityCount() {\n+        return hostileFacilityCount;\n+    }\n+\n+    /**\n+     * @param hostileFacilityCount the hostileFacilityCount to set\n+     */\n+    public void setHostileFacilityCount(double hostileFacilityCount) {\n+        this.hostileFacilityCount = hostileFacilityCount;\n+    }\n+\n+    @XmlElementWrapper(name=\"allowedScenarios\")\n+    @XmlElement(name=\"allowedScenario\")\n+    public List<String> getAllowedScenarios() {\n+        return allowedScenarios;\n+    }\n+\n+    public void setAllowedScenarios(List<String> allowedScenarios) {\n+        this.allowedScenarios = allowedScenarios;\n+    }\n+\n+    @XmlElementWrapper(name=\"forbiddenScenarios\")\n+    @XmlElement(name=\"forbiddenScenario\")\n+    public List<String> getForbiddenScenarios() {\n+        return forbiddenScenarios;\n+    }\n+\n+    public void setForbiddenScenarios(List<String> forbiddenScenarios) {\n+        this.forbiddenScenarios = forbiddenScenarios;\n+    }\n+    \n+    @XmlElementWrapper(name=\"objectiveParameters\")\n+    @XmlElement(name=\"objectiveParameter\")\n+    public List<ObjectiveParameters> getObjectiveParameters() {\n+        return objectiveParameters;\n+    }\n+\n+    public void setObjectiveParameters(List<ObjectiveParameters> objectiveParameters) {\n+        this.objectiveParameters = objectiveParameters;\n+    }\n+\n+    public boolean objectivesBehaveAsVPs() {\n+        return objectivesBehaveAsVPs;\n+    }\n+\n+    public void setObjectivesBehaveAsVPs(boolean objectivesBehaveAsVPs) {\n+        this.objectivesBehaveAsVPs = objectivesBehaveAsVPs;\n+    }\n+\n+    @XmlElementWrapper(name=\"scenarioOdds\")\n+    @XmlElement(name=\"scenarioOdds\")\n+    public List<Integer> getScenarioOdds() {\n+        return scenarioOdds;\n+    }\n+\n+    public void setScenarioOdds(List<Integer> scenarioOdds) {\n+        this.scenarioOdds = scenarioOdds;\n+    }\n+\n+    @XmlElementWrapper(name=\"deploymentTimes\")\n+    @XmlElement(name=\"deploymentTimes\")\n+    public List<Integer> getDeploymentTimes() {\n+        return deploymentTimes;\n+    }\n+\n+    public void setDeploymentTimes(List<Integer> deploymentTimes) {\n+        this.deploymentTimes = deploymentTimes;\n+    }\n+\n+    public static class ObjectiveParameters {\n+        /**\n+         * The type of objective this is; \n+         */\n+        @XmlElement(name=\"objectiveType\")\n+        StrategicObjectiveType objectiveType;\n+        \n+        /**\n+         * How many strategic objectives will be placed for this contract.\n+         * 0 means none. A number less than zero indicates that the number of strategic objectives \n+         * should be scaled to the number of lances required by the contract, and multiplied by that factor. \n+         */\n+        @XmlElement(name=\"objectiveCount\")\n+        double objectiveCount;\n+        \n+        /**\n+         * List of IDs (file names) of specific scenarios to use for this objective.\n+         * Ignored for AnyScenarioVictory or AlliedFacilityControl objective types\n+         */\n+        @XmlElementWrapper(name=\"objectiveScenarios\")\n+        @XmlElement(name=\"objectiveScenario\")\n+        List<String> objectiveScenarios;\n+        \n+        /**\n+         * If a particular scenario being generated is a strategic objective, it will have\n+         * these modifiers applied to it\n+         */\n+        @XmlElementWrapper(name=\"objectiveScenarioModifiers\")\n+        @XmlElement(name=\"objectiveScenarioModifier\")\n+        List<String> objectiveScenarioModifiers;\n+    }\n+    \n+    // Garrison Duty: Defend X facilities\n+    // Cadre Duty: Victory in X Training Exercise scenarios\n+    // Security Duty: Defend X facilities\n+    // Riot Duty: Defend X facilities, Riot Suppression scenarios\n+    // Planetary Assault: Destroy or Capture and Hold X facilities\n+    // Relief Duty: Hold X facilities (on hostile world!)\n+    // Guerilla Warfare: Victory in X scenarios, soft time limit (reinforcements) on all scenarios\n+    // Pirate Hunting: Victory in X scenarios \n+    // Diversionary Warfare: Victory in X scenarios\n+    // Objective Raid: Destroy X facilities\n+    // Extraction Raid: Extract from X facilities, victory in X capture scenarios\n+    // Recon Raid: Recon on X facilities\n+    // \n+    // future expansion:\n+    // Assassination: Victory in X Assassination scenarios\n+    // Terrorism: Victory in X \"Riot Suppression\" scenarios\n+    // Bounty Hunt: Victory in X Assassination, X Capture scenarios\n+    // Mole Hunting: ?\n+    // Espionage: ?\n+    // Sabotage: ?\n+    // Observation Raid: ?\n+    \n+    /**\n+     * Serialize this instance of a scenario template to a File\n+     * Please pass in a non-null file.\n+     * @param outputFile The destination file.\n+     */\n+    public void Serialize(File outputFile) {\n+        try {\n+            JAXBContext context = JAXBContext.newInstance(StratconContractDefinition.class);\n+            JAXBElement<StratconContractDefinition> templateElement = new JAXBElement<>(new QName(ROOT_XML_ELEMENT_NAME), StratconContractDefinition.class, this);\n+            Marshaller m = context.createMarshaller();\n+            m.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);\n+            m.marshal(templateElement, outputFile);\n+        } catch(Exception e) {\n+            MekHQ.getLogger().error(\"Erorr deserializing \" + outputFile.getPath(), e);", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzM5NDY0Nw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593394647", "bodyText": "This should either be nested and static or hoisted out into its own file.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            class ContractDefinitionManifest {\n          \n          \n            \n            private class ContractDefinitionManifest {", "author": "sixlettervariables", "createdAt": "2021-03-12T19:19:46Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconContractDefinition.java", "diffHunk": "@@ -0,0 +1,420 @@\n+package mekhq.campaign.stratcon;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBElement;\n+import javax.xml.bind.Marshaller;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.namespace.QName;\n+import javax.xml.transform.Source;\n+\n+import mekhq.MekHQ;\n+import mekhq.MekHqXmlUtil;\n+\n+/**\n+ * This class holds data relevant to the various types of contract\n+ * that can occur in the StratCon campaign system.\n+ * @author NickAragua\n+ *\n+ */\n+@XmlRootElement(name=\"StratconContractDefinition\")\n+public class StratconContractDefinition {\n+    public static final String ROOT_XML_ELEMENT_NAME = \"ScenarioTemplate\";\n+    public static final int COUNT_SCALED = -1;\n+    \n+    private static ContractDefinitionManifest definitionManifest;\n+    private static Map<Integer, StratconContractDefinition> loadedDefinitions = new HashMap<>();\n+    \n+    static {\n+        definitionManifest = ContractDefinitionManifest.Deserialize(\"./data/stratconcontractdefinitions/ContractDefinitionManifest.xml\");\n+        \n+        // load user-specified modifier list\n+        ContractDefinitionManifest userDefinitionList = ContractDefinitionManifest.Deserialize(\"./data/scenariomodifiers/UserContractDefinitionManifest.xml\");\n+        if(userDefinitionList != null) {\n+            definitionManifest.definitionFileNames.putAll(userDefinitionList.definitionFileNames);\n+        }\n+    }\n+    \n+    /**\n+     * Returns the stratcon contract definition for the given AtB Contract Type \n+     * as defined in AtBContract.java\n+     */\n+    public static StratconContractDefinition getContractDefinition(int atbContractType) {\n+        definitionManifest = ContractDefinitionManifest.Deserialize(\"./data/stratconcontractdefinitions/ContractDefinitionManifest.xml\");\n+        loadedDefinitions.clear();\n+        \n+        if (!loadedDefinitions.containsKey(atbContractType)) {\n+            String filePath = String.format(\"./data/stratconcontractdefinitions/%s\", \n+                    definitionManifest.definitionFileNames.get(atbContractType));\n+            StratconContractDefinition def = Deserialize(new File(filePath));\n+            \n+            if (def == null) {\n+                MekHQ.getLogger().error(String.format(\"Unable to load contract definition %s\", filePath));\n+                return null;\n+            }\n+            \n+            loadedDefinitions.put(atbContractType, def);\n+        }\n+        \n+        return loadedDefinitions.get(atbContractType);\n+    }\n+    \n+    /**\n+     * The kind of actions that the player needs to undertake to complete\n+     * strategic objectives for this contract.\n+     *\n+     */\n+    public enum StrategicObjectiveType {\n+        /**\n+         * Victory in any scenario\n+         */\n+        AnyScenarioVictory,\n+        \n+        /**\n+         * Victory in scenarios - designated by the \"objectiveScenarios\" collection.\n+         * These are one-off scenarios that stick around on tracks - when revealed, \n+         * they get a deploy/action/return date as usual, and the player gets one shot to complete them\n+         */\n+        SpecificScenarioVictory,\n+        \n+        /**\n+         * Control of allied facilities generated at contract start time\n+         * Each track will be seeded with some number of allied facilities\n+         * They must not be destroyed and the player must have control of them at the end-of-contract date \n+         */\n+        AlliedFacilityControl,\n+        \n+        /**\n+         * Control of hostile facilities generated at contract start time\n+         * Each track will be seeded with some number of hostile facilities\n+         * They must not be destroyed and the player must have control of them at the end-of-contract date\n+         */\n+        HostileFacilityControl,\n+        \n+        /**\n+         * Destruction of hostile facilities generated at contract start time\n+         * Each track will be seeded with some number of hostile facilities\n+         * They may either be destroyed or the player must have control of them at the end-of-contract date\n+         */\n+        FacilityDestruction\n+    }\n+    \n+    public static StratconContractDefinition createTestContract() {\n+        /*StratconContractDefinition retVal = new StratconContractDefinition();\n+        \n+        retVal.contractTypeName = \"Test Contract Type\";\n+        retVal.briefing = \"Test Contract Briefing.\";\n+        retVal.alliedFacilityCount = 1;\n+        retVal.hostileFacilityCount = COUNT_SCALED;\n+        retVal.objectiveParameters = new ArrayList<>();\n+        \n+        ObjectiveParameters objective = new ObjectiveParameters();\n+        objective.objectiveType = StrategicObjectiveType.SpecificScenarioVictory;\n+        objective.objectiveCount = COUNT_SCALED;\n+        objective.objectiveScenarios = Arrays.asList(\"Capture.xml\", \"Assassinate.xml\");\n+        objective.objectiveScenarioModifiers = Arrays.asList(\"AlliedTankGarrison.xml\", \"HostileAirGarrison.xml\");\n+        \n+        retVal.objectiveParameters.add(objective);\n+        \n+        retVal.allowedScenarios = Arrays.asList(\"TestAllowScenario.xml\", \"TestAllowScenario.xml\");\n+        retVal.forbiddenScenarios = Arrays.asList(\"TestForbidScenario.xml\", \"TestForbidScenario.xml\");\n+        \n+        retVal.Serialize(new File(\"d:\\\\projects\\\\mekhq\\\\mekhq\\\\data\\\\stratconcontractdefinitions\\\\testcontract.xml\"));\n+        \n+        return retVal;*/\n+        StratconContractDefinition retVal = Deserialize(new File(\"d:\\\\projects\\\\mekhq\\\\mekhq\\\\data\\\\stratconcontractdefinitions\\\\ObjectiveRaid.xml\"));\n+        return retVal;\n+    }\n+    \n+    private String contractTypeName;\n+    private String briefing;\n+    \n+    /**\n+     * How many allied facilities to generate for the contract, \n+     * in addition to any facilities placed by objectives.\n+     * < 0 indicates that the number of facilities should be scaled to the number of \n+     * lances required by the contract. 0 indicates no additional allied facilities.\n+     */\n+    private double alliedFacilityCount;\n+    \n+    /**\n+     * How many hostile facilities to generate for the contract, \n+     * in addition to any facilities placed by objectives.\n+     * -1 indicates that the number of facilities should be scaled to the number of \n+     * lances required by the contract. 0 indicates no additional hostile facilities.\n+     */\n+    private double hostileFacilityCount;\n+    \n+    /**\n+     * List of scenario IDs (file names) that are allowed for this contract type\n+     */\n+    private List<String> allowedScenarios;\n+    \n+    /**\n+     * List of scenario IDs (file names) that are not allowed for this contract type\n+     */\n+    private List<String> forbiddenScenarios;\n+    \n+    /**\n+     * Strategic objectives for this contract.\n+     */\n+    private List<ObjectiveParameters> objectiveParameters;\n+    \n+    /**\n+     * If true, strategic objective scenarios contribute to the VP count\n+     */\n+    private boolean objectivesBehaveAsVPs;\n+    \n+    private List<Integer> scenarioOdds;\n+    \n+    private List<Integer> deploymentTimes;\n+\n+    public String getContractTypeName() {\n+        return contractTypeName;\n+    }\n+\n+    public void setContractTypeName(String contractTypeName) {\n+        this.contractTypeName = contractTypeName;\n+    }\n+\n+    /**\n+     * @return the briefing\n+     */\n+    public String getBriefing() {\n+        return briefing;\n+    }\n+\n+    /**\n+     * @param briefing the briefing to set\n+     */\n+    public void setBriefing(String briefing) {\n+        this.briefing = briefing;\n+    }\n+\n+    /**\n+     * @return the alliedFacilityCount\n+     */\n+    public double getAlliedFacilityCount() {\n+        return alliedFacilityCount;\n+    }\n+\n+    /**\n+     * @param alliedFacilityCount the alliedFacilityCount to set\n+     */\n+    public void setAlliedFacilityCount(double alliedFacilityCount) {\n+        this.alliedFacilityCount = alliedFacilityCount;\n+    }\n+\n+    /**\n+     * @return the hostileFacilityCount\n+     */\n+    public double getHostileFacilityCount() {\n+        return hostileFacilityCount;\n+    }\n+\n+    /**\n+     * @param hostileFacilityCount the hostileFacilityCount to set\n+     */\n+    public void setHostileFacilityCount(double hostileFacilityCount) {\n+        this.hostileFacilityCount = hostileFacilityCount;\n+    }\n+\n+    @XmlElementWrapper(name=\"allowedScenarios\")\n+    @XmlElement(name=\"allowedScenario\")\n+    public List<String> getAllowedScenarios() {\n+        return allowedScenarios;\n+    }\n+\n+    public void setAllowedScenarios(List<String> allowedScenarios) {\n+        this.allowedScenarios = allowedScenarios;\n+    }\n+\n+    @XmlElementWrapper(name=\"forbiddenScenarios\")\n+    @XmlElement(name=\"forbiddenScenario\")\n+    public List<String> getForbiddenScenarios() {\n+        return forbiddenScenarios;\n+    }\n+\n+    public void setForbiddenScenarios(List<String> forbiddenScenarios) {\n+        this.forbiddenScenarios = forbiddenScenarios;\n+    }\n+    \n+    @XmlElementWrapper(name=\"objectiveParameters\")\n+    @XmlElement(name=\"objectiveParameter\")\n+    public List<ObjectiveParameters> getObjectiveParameters() {\n+        return objectiveParameters;\n+    }\n+\n+    public void setObjectiveParameters(List<ObjectiveParameters> objectiveParameters) {\n+        this.objectiveParameters = objectiveParameters;\n+    }\n+\n+    public boolean objectivesBehaveAsVPs() {\n+        return objectivesBehaveAsVPs;\n+    }\n+\n+    public void setObjectivesBehaveAsVPs(boolean objectivesBehaveAsVPs) {\n+        this.objectivesBehaveAsVPs = objectivesBehaveAsVPs;\n+    }\n+\n+    @XmlElementWrapper(name=\"scenarioOdds\")\n+    @XmlElement(name=\"scenarioOdds\")\n+    public List<Integer> getScenarioOdds() {\n+        return scenarioOdds;\n+    }\n+\n+    public void setScenarioOdds(List<Integer> scenarioOdds) {\n+        this.scenarioOdds = scenarioOdds;\n+    }\n+\n+    @XmlElementWrapper(name=\"deploymentTimes\")\n+    @XmlElement(name=\"deploymentTimes\")\n+    public List<Integer> getDeploymentTimes() {\n+        return deploymentTimes;\n+    }\n+\n+    public void setDeploymentTimes(List<Integer> deploymentTimes) {\n+        this.deploymentTimes = deploymentTimes;\n+    }\n+\n+    public static class ObjectiveParameters {\n+        /**\n+         * The type of objective this is; \n+         */\n+        @XmlElement(name=\"objectiveType\")\n+        StrategicObjectiveType objectiveType;\n+        \n+        /**\n+         * How many strategic objectives will be placed for this contract.\n+         * 0 means none. A number less than zero indicates that the number of strategic objectives \n+         * should be scaled to the number of lances required by the contract, and multiplied by that factor. \n+         */\n+        @XmlElement(name=\"objectiveCount\")\n+        double objectiveCount;\n+        \n+        /**\n+         * List of IDs (file names) of specific scenarios to use for this objective.\n+         * Ignored for AnyScenarioVictory or AlliedFacilityControl objective types\n+         */\n+        @XmlElementWrapper(name=\"objectiveScenarios\")\n+        @XmlElement(name=\"objectiveScenario\")\n+        List<String> objectiveScenarios;\n+        \n+        /**\n+         * If a particular scenario being generated is a strategic objective, it will have\n+         * these modifiers applied to it\n+         */\n+        @XmlElementWrapper(name=\"objectiveScenarioModifiers\")\n+        @XmlElement(name=\"objectiveScenarioModifier\")\n+        List<String> objectiveScenarioModifiers;\n+    }\n+    \n+    // Garrison Duty: Defend X facilities\n+    // Cadre Duty: Victory in X Training Exercise scenarios\n+    // Security Duty: Defend X facilities\n+    // Riot Duty: Defend X facilities, Riot Suppression scenarios\n+    // Planetary Assault: Destroy or Capture and Hold X facilities\n+    // Relief Duty: Hold X facilities (on hostile world!)\n+    // Guerilla Warfare: Victory in X scenarios, soft time limit (reinforcements) on all scenarios\n+    // Pirate Hunting: Victory in X scenarios \n+    // Diversionary Warfare: Victory in X scenarios\n+    // Objective Raid: Destroy X facilities\n+    // Extraction Raid: Extract from X facilities, victory in X capture scenarios\n+    // Recon Raid: Recon on X facilities\n+    // \n+    // future expansion:\n+    // Assassination: Victory in X Assassination scenarios\n+    // Terrorism: Victory in X \"Riot Suppression\" scenarios\n+    // Bounty Hunt: Victory in X Assassination, X Capture scenarios\n+    // Mole Hunting: ?\n+    // Espionage: ?\n+    // Sabotage: ?\n+    // Observation Raid: ?\n+    \n+    /**\n+     * Serialize this instance of a scenario template to a File\n+     * Please pass in a non-null file.\n+     * @param outputFile The destination file.\n+     */\n+    public void Serialize(File outputFile) {\n+        try {\n+            JAXBContext context = JAXBContext.newInstance(StratconContractDefinition.class);\n+            JAXBElement<StratconContractDefinition> templateElement = new JAXBElement<>(new QName(ROOT_XML_ELEMENT_NAME), StratconContractDefinition.class, this);\n+            Marshaller m = context.createMarshaller();\n+            m.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);\n+            m.marshal(templateElement, outputFile);\n+        } catch(Exception e) {\n+            MekHQ.getLogger().error(\"Erorr deserializing \" + outputFile.getPath(), e);\n+        }\n+    }\n+    \n+    /**\n+     * Attempt to deserialize an instance of a ScenarioTemplate from the passed-in file \n+     * @param inputFile The source file\n+     * @return Possibly an instance of a ScenarioTemplate\n+     */\n+    public static StratconContractDefinition Deserialize(File inputFile) {\n+        StratconContractDefinition resultingDefinition = null;\n+\n+        try {\n+            JAXBContext context = JAXBContext.newInstance(StratconContractDefinition.class);\n+            Unmarshaller um = context.createUnmarshaller();\n+            try (FileInputStream fileStream = new FileInputStream(inputFile)) {\n+                Source inputSource = MekHqXmlUtil.createSafeXmlSource(fileStream);\n+                JAXBElement<StratconContractDefinition> definitionElement = um.unmarshal(inputSource, StratconContractDefinition.class);\n+                resultingDefinition = definitionElement.getValue();\n+            }\n+        } catch(Exception e) {\n+            MekHQ.getLogger().error(\"Error Deserializing Contract Definition \" + inputFile.getPath(), e);\n+        }\n+\n+        return resultingDefinition;\n+    }\n+}\n+\n+/**\n+ * A manifest containing IDs and file names of scenario template definitions\n+ * @author NickAragua\n+ *\n+ */\n+@XmlRootElement(name=\"contractDefinitionManifest\")\n+class ContractDefinitionManifest {", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzM5NDcyNA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593394724", "bodyText": "headerify", "author": "sixlettervariables", "createdAt": "2021-03-12T19:19:53Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconContractInitializer.java", "diffHunk": "@@ -0,0 +1,288 @@\n+package mekhq.campaign.stratcon;", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzM5NDkyOA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593394928", "bodyText": "Should be initializeCampaignState:\n    public static void InitializeCampaignState(AtBContract contract, Campaign campaign, StratconContractDefinition contractDefinition) {", "author": "sixlettervariables", "createdAt": "2021-03-12T19:20:13Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconContractInitializer.java", "diffHunk": "@@ -0,0 +1,288 @@\n+package mekhq.campaign.stratcon;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import megamek.common.Compute;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.stratcon.StratconContractDefinition.ObjectiveParameters;\n+\n+public class StratconContractInitializer {\n+    public static final int NUM_LANCES_PER_TRACK = 3;\n+\n+    /**\n+     * Initializes the campaign state given a contract, campaign and contract definition\n+     */\n+    public static void InitializeCampaignState(AtBContract contract, Campaign campaign, StratconContractDefinition contractDefinition) {", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzM5NTUzMw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593395533", "bodyText": "This likely needs a test preventing negative numbers.", "author": "sixlettervariables", "createdAt": "2021-03-12T19:21:15Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconCampaignState.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package mekhq.campaign.stratcon;\n+\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBElement;\n+import javax.xml.bind.Marshaller;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlTransient;\n+import javax.xml.namespace.QName;\n+\n+import org.w3c.dom.Node;\n+\n+import mekhq.MekHQ;\n+import mekhq.campaign.mission.AtBContract;\n+\n+/**\n+ * Contract-level state object for a stratcon campaign.\n+ * @author NickAragua\n+ *\n+ */\n+@XmlRootElement(name=\"StratconCampaignState\")\n+public class StratconCampaignState {\n+    public static final String ROOT_XML_ELEMENT_NAME = \"StratconCampaignState\";\n+    \n+    @XmlTransient\n+    private AtBContract contract;\n+\n+    // these are all state variables that affect the current Stratcon Campaign\n+    private double globalOpforBVMultiplier;\n+    private int supportPoints;\n+    private int victoryPoints;\n+    private int pendingStrategicObjectiveCount;\n+    private int completedStrategicObjectiveCount;\n+    private String briefingText; \n+    private boolean strategicObjectivesBehaveAsVPs;\n+    \n+    // these are applied to any scenario generated in the campaign; use sparingly\n+    private List<String> globalScenarioModifiers = new ArrayList<>(); \n+    \n+    @XmlElementWrapper(name=\"campaignTracks\")\n+    @XmlElement(name=\"campaignTrack\")\n+    private List<StratconTrackState> tracks;\n+\n+    @XmlTransient\n+    public AtBContract getContract() {\n+        return contract;\n+    }\n+\n+    public void setContract(AtBContract contract) {\n+        this.contract = contract;\n+    }\n+\n+    public StratconCampaignState() {\n+        tracks = new ArrayList<>();\n+    }\n+    \n+    public StratconCampaignState(AtBContract contract) {\n+        tracks = new ArrayList<>();\n+        this.setContract(contract);\n+    }\n+\n+    /**\n+     * The opfor BV multiplier. Intended to be additive.\n+     * @return The additive opfor BV multiplier.\n+     */\n+    public double getGlobalOpforBVMultiplier() {\n+        return globalOpforBVMultiplier;\n+    }\n+    \n+    public StratconTrackState getTrack(int index) {\n+        return tracks.get(index);\n+    }\n+    \n+    public List<StratconTrackState> getTracks() {\n+        return tracks;\n+    }\n+    \n+    public void addTrack(StratconTrackState track) {\n+        tracks.add(track);\n+    }\n+    \n+    public int getSupportPoints() {\n+        return supportPoints;\n+    }\n+    \n+    public void addSupportPoints(int number) {\n+        supportPoints += number;\n+    }\n+    \n+    public void setSupportPoints(int supportPoints) {\n+        this.supportPoints = supportPoints;\n+    }\n+\n+    public int getVictoryPoints() {\n+        return victoryPoints;\n+    }\n+\n+    public void setVictoryPoints(int victoryPoints) {\n+        this.victoryPoints = victoryPoints;\n+    }\n+    \n+    public void updateVictoryPoints(int increment) {\n+        victoryPoints += increment;\n+    }\n+\n+    public String getBriefingText() {\n+        return briefingText;\n+    }\n+\n+    public void setBriefingText(String briefingText) {\n+        this.briefingText = briefingText;\n+    }\n+\n+    public boolean strategicObjectivesBehaveAsVPs() {\n+        return strategicObjectivesBehaveAsVPs;\n+    }\n+\n+    public void setStrategicObjectivesBehaveAsVPs(boolean strategicObjectivesBehaveAsVPs) {\n+        this.strategicObjectivesBehaveAsVPs = strategicObjectivesBehaveAsVPs;\n+    }\n+\n+    public List<String> getGlobalScenarioModifiers() {\n+        return globalScenarioModifiers;\n+    }\n+\n+    public void setGlobalScenarioModifiers(List<String> globalScenarioModifiers) {\n+        this.globalScenarioModifiers = globalScenarioModifiers;\n+    }\n+\n+    public int getPendingStrategicObjectiveCount() {\n+        return pendingStrategicObjectiveCount;\n+    }\n+\n+    public void setPendingStrategicObjectiveCount(int pendingStrategicObjectiveCount) {\n+        this.pendingStrategicObjectiveCount = pendingStrategicObjectiveCount;\n+    }\n+    \n+    public void incrementPendingStrategicObjectiveCount(int increment) {\n+        this.pendingStrategicObjectiveCount += increment;\n+    }", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzU1MjU4Mg==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593552582", "bodyText": "I'm kind of intending for this to be a pretty dumb data structure, with the most of the semantic logic in the RulesManager and other such classes.", "author": "NickAragua", "createdAt": "2021-03-13T03:33:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzM5NTUzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzM5NjIyNQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593396225", "bodyText": "headerify", "author": "sixlettervariables", "createdAt": "2021-03-12T19:22:24Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconCoords.java", "diffHunk": "@@ -0,0 +1,53 @@\n+package mekhq.campaign.stratcon;", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzM5NjQzNQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593396435", "bodyText": "?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public StratconCoords translate(int direction) {\n          \n          \n            \n                    @Override\n          \n          \n            \n                    public StratconCoords translate(int direction) {", "author": "sixlettervariables", "createdAt": "2021-03-12T19:22:49Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconCoords.java", "diffHunk": "@@ -0,0 +1,53 @@\n+package mekhq.campaign.stratcon;\n+\n+import megamek.common.Coords;\n+import megamek.common.util.HashCodeUtil;\n+\n+public class StratconCoords extends Coords {\n+    private static final long serialVersionUID = 2660132431077309812L;\n+\n+    public StratconCoords(int x, int y) {\n+        super(x, y);\n+    }\n+    \n+    public StratconCoords() {\n+        super(0, 0);\n+    }\n+\n+    public StratconCoords translate(int direction) {", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzU1NDIxNw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593554217", "bodyText": "Parent class doesn't have a method with this signature. I think it's because the hexes wind up rendered slightly differently here from MegaMek.", "author": "NickAragua", "createdAt": "2021-03-13T03:48:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzM5NjQzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzM5NzE3Ng==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593397176", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return (HashCodeUtil.hash1(getX() + 1337) ^ HashCodeUtil.hash1(getY() + 97331)) & 0x7FFFFFFF;\n          \n          \n            \n                    return Objects.hash(getX(), getY());", "author": "sixlettervariables", "createdAt": "2021-03-12T19:23:55Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconCoords.java", "diffHunk": "@@ -0,0 +1,53 @@\n+package mekhq.campaign.stratcon;\n+\n+import megamek.common.Coords;\n+import megamek.common.util.HashCodeUtil;\n+\n+public class StratconCoords extends Coords {\n+    private static final long serialVersionUID = 2660132431077309812L;\n+\n+    public StratconCoords(int x, int y) {\n+        super(x, y);\n+    }\n+    \n+    public StratconCoords() {\n+        super(0, 0);\n+    }\n+\n+    public StratconCoords translate(int direction) {\n+        Coords coords = translated(direction);\n+        int y = coords.getY();\n+        \n+        if(isXOdd() && coords.getX() != getX()) {\n+            y--;\n+        } else if (!isXOdd() && coords.getX() != getX()) {\n+            y++;\n+        }\n+        \n+        return new StratconCoords(coords.getX(), y);\n+    }\n+    \n+    /**\n+     * Get the hash code for these coords.\n+     * \n+     * @return The <code>int</code> hash code for these coords.\n+     */\n+    @Override\n+    public int hashCode() {\n+        return (HashCodeUtil.hash1(getX() + 1337) ^ HashCodeUtil.hash1(getY() + 97331)) & 0x7FFFFFFF;", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzM5NzM5Mg==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593397392", "bodyText": "Remove or move to some unit test utility.", "author": "sixlettervariables", "createdAt": "2021-03-12T19:24:21Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconFacility.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBElement;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.transform.Source;\n+\n+import mekhq.MekHQ;\n+import mekhq.MekHqXmlUtil;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+\n+/**\n+ * This represents a facility in the StratCon context\n+ * @author NickAragua\n+ *\n+ */\n+@XmlRootElement(name=\"StratconFacility\")\n+public class StratconFacility implements Cloneable {\n+    public enum FacilityType {\n+        MekBase,\n+        TankBase,\n+        AirBase,\n+        ArtilleryBase,\n+        SupplyDepot,\n+        DataCenter,\n+        IndustrialFacility,\n+        CommandCenter,\n+        EarlyWarningSystem,\n+        OrbitalDefense,\n+        BaseOfOperations\n+    }\n+    \n+    private ForceAlignment owner;\n+    private String displayableName;\n+    private FacilityType facilityType;\n+    private boolean visible;\n+    private int aggroRating;\n+    private List<String> sharedModifiers = new ArrayList<>();\n+    private List<String> localModifiers = new ArrayList<>();\n+    private Map<String, Integer> fixedGarrisonUnitStates = new HashMap<>();\n+    private boolean isStrategicObjective;\n+    \n+    /**\n+     * A temporary variable used to track situations where changing the ownership of this facility\n+     * hinges upon multiple objectives\n+     */\n+    private transient int ownershipChangeScore;\n+    \n+    public static StratconFacility createTestFacility() {\n+        StratconFacility test = new StratconFacility();\n+        test.displayableName = \"test facility\";\n+        test.facilityType = FacilityType.TankBase;\n+        test.sharedModifiers.add(\"AlliedTankGarrison.xml\");\n+        test.localModifiers.add(\"AlliedTankGarrison.xml\");\n+        test.localModifiers.add(\"AlliedTankGarrison.xml\");\n+        test.fixedGarrisonUnitStates.put(\"Griffin GRF-1N\", 0);\n+        test.owner = ForceAlignment.Opposing;\n+        return test;\n+    }", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzM5NzUyNg==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593397526", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public Object clone() {\n          \n          \n            \n                @Override\n          \n          \n            \n                public StratconFacility clone() {", "author": "sixlettervariables", "createdAt": "2021-03-12T19:24:37Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconFacility.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBElement;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.transform.Source;\n+\n+import mekhq.MekHQ;\n+import mekhq.MekHqXmlUtil;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+\n+/**\n+ * This represents a facility in the StratCon context\n+ * @author NickAragua\n+ *\n+ */\n+@XmlRootElement(name=\"StratconFacility\")\n+public class StratconFacility implements Cloneable {\n+    public enum FacilityType {\n+        MekBase,\n+        TankBase,\n+        AirBase,\n+        ArtilleryBase,\n+        SupplyDepot,\n+        DataCenter,\n+        IndustrialFacility,\n+        CommandCenter,\n+        EarlyWarningSystem,\n+        OrbitalDefense,\n+        BaseOfOperations\n+    }\n+    \n+    private ForceAlignment owner;\n+    private String displayableName;\n+    private FacilityType facilityType;\n+    private boolean visible;\n+    private int aggroRating;\n+    private List<String> sharedModifiers = new ArrayList<>();\n+    private List<String> localModifiers = new ArrayList<>();\n+    private Map<String, Integer> fixedGarrisonUnitStates = new HashMap<>();\n+    private boolean isStrategicObjective;\n+    \n+    /**\n+     * A temporary variable used to track situations where changing the ownership of this facility\n+     * hinges upon multiple objectives\n+     */\n+    private transient int ownershipChangeScore;\n+    \n+    public static StratconFacility createTestFacility() {\n+        StratconFacility test = new StratconFacility();\n+        test.displayableName = \"test facility\";\n+        test.facilityType = FacilityType.TankBase;\n+        test.sharedModifiers.add(\"AlliedTankGarrison.xml\");\n+        test.localModifiers.add(\"AlliedTankGarrison.xml\");\n+        test.localModifiers.add(\"AlliedTankGarrison.xml\");\n+        test.fixedGarrisonUnitStates.put(\"Griffin GRF-1N\", 0);\n+        test.owner = ForceAlignment.Opposing;\n+        return test;\n+    }\n+    \n+    public Object clone() {", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzM5OTEzMA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593399130", "bodyText": "General comment: these paths should be hoisted somewhere.\nSpecific comment: should be using something like Paths.get(getFacilitiesPath(), fileName.trim())", "author": "sixlettervariables", "createdAt": "2021-03-12T19:27:18Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconFacilityFactory.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import megamek.common.Compute;\n+import mekhq.MekHQ;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+\n+/**\n+ * This class handles functionality related to loading and stratcon facility definitions.\n+ * @author NickAragua\n+ *\n+ */\n+public class StratconFacilityFactory {\n+    // loaded facility definitions\n+    \n+    // map of filename -> facility definition, for specific facility retrieval\n+    private static Map<String, StratconFacility> stratconFacilityMap = new HashMap<>();\n+    \n+    // list of all loaded facility definitions\n+    private static List<StratconFacility> stratconFacilityList = new ArrayList<>();\n+    \n+    // list of all hostile facility defs for convenience\n+    private static List<StratconFacility> hostileFacilities = new ArrayList<>();\n+    \n+    // list of all allied facility defs for convenience\n+    private static List<StratconFacility> alliedFacilities = new ArrayList<>();\n+    \n+    static {\n+        reloadFacilities();\n+    }\n+    \n+    public static void reloadFacilities() {\n+        stratconFacilityList.clear();\n+        hostileFacilities.clear();\n+        alliedFacilities.clear();\n+        stratconFacilityMap.clear();\n+        \n+        // load dynamic scenarios\n+        StratconFacilityManifest facilityManifest = StratconFacilityManifest.Deserialize(\"./data/stratconfacilities/facilitymanifest.xml\");\n+        \n+        // load user-specified scenario list\n+        StratconFacilityManifest userManifest = StratconFacilityManifest.Deserialize(\"./data/stratconfacilities/userfacilitymanifest.xml\");\n+        \n+        if(facilityManifest != null) {\n+            loadFacilitiesFromManifest(facilityManifest);\n+        }\n+        \n+        if(userManifest != null) {\n+            loadFacilitiesFromManifest(userManifest);\n+        }\n+    }\n+    \n+    /**\n+     * Helper function that loads scenario templates from the given manifest.\n+     * @param manifest The manifest to process\n+     */\n+    private static void loadFacilitiesFromManifest(StratconFacilityManifest manifest) {\n+        if(manifest == null) {\n+            return;\n+        }\n+        \n+        for(String fileName : manifest.facilityFileNames) {\n+            String filePath = String.format(\"./data/stratconfacilities/%s\", fileName.trim());", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzM5OTQ0OQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593399449", "bodyText": "headerify", "author": "sixlettervariables", "createdAt": "2021-03-12T19:27:46Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1080 @@\n+package mekhq.campaign.stratcon;", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzM5OTYzMw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593399633", "bodyText": "Just realized a lot of these are capital-D Deserialize instead of deserialize.", "author": "sixlettervariables", "createdAt": "2021-03-12T19:28:03Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconFacilityManifest.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.util.List;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBElement;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.transform.Source;\n+\n+import mekhq.MekHQ;\n+import mekhq.MekHqXmlUtil;\n+\n+/**\n+ * A manifest containing IDs and file names of stratcon facility definitions\n+ * @author NickAragua\n+ */\n+@XmlRootElement(name=\"facilityManifest\")\n+public class StratconFacilityManifest {\n+    @XmlElementWrapper(name=\"facilityFileNames\")\n+    @XmlElement(name=\"facilityFileName\")\n+    public List<String> facilityFileNames;\n+    \n+    /**\n+     * Attempt to deserialize an instance of a StratconFacilityManifest from the passed-in file path\n+     * @return Possibly an instance of a StratconFacilityManifest\n+     */\n+    public static StratconFacilityManifest Deserialize(String fileName) {", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQwMDUwNQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593400505", "bodyText": "Why -1? Is the last scenario not going to have liaison units?", "author": "sixlettervariables", "createdAt": "2021-03-12T19:29:37Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1080 @@\n+package mekhq.campaign.stratcon;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import megamek.common.Compute;\n+import megamek.common.Minefield;\n+import megamek.common.UnitType;\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.ResolveScenarioTracker;\n+import mekhq.campaign.againstTheBot.enums.AtBLanceRole;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.force.Lance;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier.EventTiming;\n+import mekhq.campaign.mission.atb.AtBScenarioModifierApplicator;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.unit.Unit;\n+\n+/**\n+ * This class contains \"rules\" logic for the AtB-Stratcon state\n+ * @author NickAragua\n+ *\n+ */\n+public class StratconRulesManager {\n+    public enum ReinforcementEligibilityType {\n+        None,\n+        ChainedScenario,\n+        SupportPoint,\n+        FightLance\n+    }\n+    \n+    /**\n+     * This function potentially generates non-player-initiated scenarios for the given track.\n+     * @param campaign\n+     * @param contract\n+     * @param track\n+     */\n+    public static void generateScenariosForTrack(Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // maps scenarios to force IDs\n+        List<StratconScenario> generatedScenarios = new ArrayList<>(); \n+        boolean autoAssignLances = contract.getCommandRights() == AtBContract.COM_INTEGRATED;\n+        \n+        // get this list just so we have it available\n+        List<Integer> availableForceIDs = getAvailableForceIDs(campaign);\n+        Map<MapLocation, List<Integer>> sortedAvailableForceIDs = sortForcesByMapType(availableForceIDs, campaign);\n+        \n+        // make X rolls, where X is the number of required lances for the track\n+        // that's the chance to spawn a scenario.\n+        // if a scenario occurs, then we pick a random non-deployed lance and use it to drive the opfor generation later\n+        // once we've determined that scenarios occur, we loop through the ones that we generated\n+        // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all \n+        for(int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            // if we haven't already used all the player forces and are required to randomly generate a scenario\n+            if((availableForceIDs.size() > 0) &&\n+                    (Compute.randomInt(100) <= track.getScenarioOdds())) {\n+                // pick random coordinates and force to drive the scenario\n+                int x = Compute.randomInt(track.getWidth());\n+                int y = Compute.randomInt(track.getHeight());                \n+                \n+                StratconCoords scenarioCoords = new StratconCoords(x, y);\n+                \n+                int randomForceIndex = Compute.randomInt(availableForceIDs.size());\n+                int randomForceID = availableForceIDs.get(randomForceIndex);\n+                \n+                // remove the force from the available lists so we don't designate it as primary twice\n+                availableForceIDs.remove(randomForceIndex); \n+                \n+                // we want to remove the actual int with the value, not the value at the index\n+                sortedAvailableForceIDs.get(MapLocation.AllGroundTerrain).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.LowAtmosphere).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.Space).remove((Integer) randomForceID);\n+                \n+                // two scenarios on the same coordinates wind up increasing in size\n+                if(track.getScenarios().containsKey(scenarioCoords)) {\n+                    track.getScenarios().get(scenarioCoords).incrementRequiredPlayerLances();\n+                    assignAppropriateExtraForceToScenario(track.getScenarios().get(scenarioCoords), sortedAvailableForceIDs, campaign);\n+                    continue;\n+                }\n+                \n+                StratconScenario scenario = setupScenario(scenarioCoords, randomForceID, campaign, contract, track);\n+                generatedScenarios.add(scenario);\n+                \n+                // if we're auto-assigning lances, deploy the force to the track as well\n+                if(autoAssignLances) {\n+                    processForceDeployment(scenarioCoords, randomForceID, campaign, track);\n+                }\n+            }\n+        }\n+        \n+        // if under liaison command, pick a random scenario from the ones generated\n+        // to set as required and attach liaison\n+        if(contract.getCommandRights() == AtBContract.COM_LIAISON) {\n+            int scenarioIndex = Compute.randomInt(generatedScenarios.size() - 1);", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzU1NTU5Mg==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593555592", "bodyText": "I was under the impression that Compute.randomInt generates a number between 0 and #, inclusive. If that's the case, # gets me an out of bounds error.", "author": "NickAragua", "createdAt": "2021-03-13T04:01:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQwMDUwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTcxNzg1Nw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r595717857", "bodyText": "Replaced with Utilities.getRandomItem()", "author": "NickAragua", "createdAt": "2021-03-17T05:13:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQwMDUwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQwMTA2MQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593401061", "bodyText": "So my IDE will highlight these :)\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // todo: these are \"weekly\"? effects that a stratcon facility has on the campaign/track state\n          \n          \n            \n                    // TODO: these are \"weekly\"? effects that a stratcon facility has on the campaign/track state", "author": "sixlettervariables", "createdAt": "2021-03-12T19:30:31Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1080 @@\n+package mekhq.campaign.stratcon;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import megamek.common.Compute;\n+import megamek.common.Minefield;\n+import megamek.common.UnitType;\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.ResolveScenarioTracker;\n+import mekhq.campaign.againstTheBot.enums.AtBLanceRole;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.force.Lance;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier.EventTiming;\n+import mekhq.campaign.mission.atb.AtBScenarioModifierApplicator;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.unit.Unit;\n+\n+/**\n+ * This class contains \"rules\" logic for the AtB-Stratcon state\n+ * @author NickAragua\n+ *\n+ */\n+public class StratconRulesManager {\n+    public enum ReinforcementEligibilityType {\n+        None,\n+        ChainedScenario,\n+        SupportPoint,\n+        FightLance\n+    }\n+    \n+    /**\n+     * This function potentially generates non-player-initiated scenarios for the given track.\n+     * @param campaign\n+     * @param contract\n+     * @param track\n+     */\n+    public static void generateScenariosForTrack(Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // maps scenarios to force IDs\n+        List<StratconScenario> generatedScenarios = new ArrayList<>(); \n+        boolean autoAssignLances = contract.getCommandRights() == AtBContract.COM_INTEGRATED;\n+        \n+        // get this list just so we have it available\n+        List<Integer> availableForceIDs = getAvailableForceIDs(campaign);\n+        Map<MapLocation, List<Integer>> sortedAvailableForceIDs = sortForcesByMapType(availableForceIDs, campaign);\n+        \n+        // make X rolls, where X is the number of required lances for the track\n+        // that's the chance to spawn a scenario.\n+        // if a scenario occurs, then we pick a random non-deployed lance and use it to drive the opfor generation later\n+        // once we've determined that scenarios occur, we loop through the ones that we generated\n+        // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all \n+        for(int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            // if we haven't already used all the player forces and are required to randomly generate a scenario\n+            if((availableForceIDs.size() > 0) &&\n+                    (Compute.randomInt(100) <= track.getScenarioOdds())) {\n+                // pick random coordinates and force to drive the scenario\n+                int x = Compute.randomInt(track.getWidth());\n+                int y = Compute.randomInt(track.getHeight());                \n+                \n+                StratconCoords scenarioCoords = new StratconCoords(x, y);\n+                \n+                int randomForceIndex = Compute.randomInt(availableForceIDs.size());\n+                int randomForceID = availableForceIDs.get(randomForceIndex);\n+                \n+                // remove the force from the available lists so we don't designate it as primary twice\n+                availableForceIDs.remove(randomForceIndex); \n+                \n+                // we want to remove the actual int with the value, not the value at the index\n+                sortedAvailableForceIDs.get(MapLocation.AllGroundTerrain).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.LowAtmosphere).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.Space).remove((Integer) randomForceID);\n+                \n+                // two scenarios on the same coordinates wind up increasing in size\n+                if(track.getScenarios().containsKey(scenarioCoords)) {\n+                    track.getScenarios().get(scenarioCoords).incrementRequiredPlayerLances();\n+                    assignAppropriateExtraForceToScenario(track.getScenarios().get(scenarioCoords), sortedAvailableForceIDs, campaign);\n+                    continue;\n+                }\n+                \n+                StratconScenario scenario = setupScenario(scenarioCoords, randomForceID, campaign, contract, track);\n+                generatedScenarios.add(scenario);\n+                \n+                // if we're auto-assigning lances, deploy the force to the track as well\n+                if(autoAssignLances) {\n+                    processForceDeployment(scenarioCoords, randomForceID, campaign, track);\n+                }\n+            }\n+        }\n+        \n+        // if under liaison command, pick a random scenario from the ones generated\n+        // to set as required and attach liaison\n+        if(contract.getCommandRights() == AtBContract.COM_LIAISON) {\n+            int scenarioIndex = Compute.randomInt(generatedScenarios.size() - 1);\n+            generatedScenarios.get(scenarioIndex).setRequiredScenario(true);\n+            setAttachedUnitsModifier(generatedScenarios.get(scenarioIndex), contract);\n+        }\n+        \n+        // now, we loop through all the scenarios we set up\n+        // and generate the opfors / events / etc\n+        // if not auto-assigning lances, we then back out the lance assignments.\n+        for(StratconScenario scenario : generatedScenarios) {\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            \n+            if(!autoAssignLances) {\n+                for(int forceID : scenario.getPrimaryPlayerForceIDs()) {\n+                    scenario.getBackingScenario().removeForce(forceID);\n+                }\n+                \n+                scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                track.addScenario(scenario);\n+            } else {\n+                commitPrimaryForces(campaign, contract, scenario, track);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Deploys a force to the given coordinates on the given track as a result of explicit player action.\n+     */\n+    public static void deployForceToCoords(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // the following things should happen:\n+        // 1. call to \"process force deployment\", which reveals fog of war in or around the coords, depending on force role\n+        // 2. if coords are a hostile facility, we get a facility mission\n+        // 3. if coords are empty, we *may* get a mission\n+        \n+        processForceDeployment(coords, forceID, campaign, track);\n+        \n+        // don't create a scenario on top of allied facilities\n+        StratconFacility facility = track.getFacility(coords);\n+        boolean isNonAlliedFacility = (facility != null) && (facility.getOwner() != ForceAlignment.Allied);\n+        boolean spawnScenario = (facility == null) && (Compute.randomInt(100) <= track.getScenarioOdds());\n+\n+        if(isNonAlliedFacility || spawnScenario) {\n+            StratconScenario scenario = setupScenario(coords, forceID, campaign, contract, track);\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            commitPrimaryForces(campaign, contract, scenario, track);\n+        }\n+    }\n+    \n+    /**\n+     * Logic to set up a scenario\n+     */\n+    private static StratconScenario setupScenario(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        StratconScenario scenario = null;\n+        \n+        if(track.getFacilities().containsKey(coords)) {\n+            StratconFacility facility = track.getFacility(coords);\n+            boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+            ScenarioTemplate template = StratconScenarioFactory.getFacilityScenario(alliedFacility);\n+            scenario = generateScenario(campaign, contract, track, forceID, coords, template);\n+            setupFacilityScenario(scenario, track, coords, facility);\n+        } else {\n+            scenario = generateScenario(campaign, contract, track, forceID, coords);\n+            \n+            // we may generate a facility scenario randomly - if so, do the facility-related stuff\n+            // and add a new facility to the track\n+            if(scenario.getBackingScenario().getTemplate().isFacilityScenario()) {\n+                StratconFacility facility = scenario.getBackingScenario().getTemplate().isHostileFacility() ?\n+                        StratconFacilityFactory.getRandomHostileFacility() : StratconFacilityFactory.getRandomAlliedFacility();\n+                facility.setVisible(true);\n+                track.addFacility(coords, facility);\n+                setupFacilityScenario(scenario, track, coords, facility);\n+            }\n+        }\n+        \n+        return scenario;\n+    }\n+    \n+    /**\n+     * carries out tasks relevant to facility scenarios\n+     */\n+    private static void setupFacilityScenario(StratconScenario scenario, StratconTrackState track, StratconCoords coords, StratconFacility facility) {\n+        // this includes:\n+        // for hostile facilities\n+        // - add a destroy objective (always the option to level the facility)\n+        // - add a capture objective (always the option to capture the facility)\n+        // - if so indicated by parameter, roll a random hostile facility objective and add it if not capture/destroy\n+        // for allied facilities\n+        // - add a defend objective (always the option to defend the facility)\n+        // - if so indicated by parameter, roll a random allied facility objective and add it if not defend\n+        AtBScenarioModifier objectiveModifier = null;\n+        boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+        \n+        if(alliedFacility) {\n+            objectiveModifier = AtBScenarioModifier.getRandomAlliedFacilityModifier();\n+        } else {            \n+            objectiveModifier = AtBScenarioModifier.getRandomHostileFacilityModifier();\n+        }\n+        \n+        if(objectiveModifier != null) {\n+            scenario.getBackingScenario().addScenarioModifier(objectiveModifier);\n+            scenario.getBackingScenario().setName(String.format(\"%s - %s - %s\", \n+                    facility.getFacilityType(), alliedFacility ? \"Allied\" : \"Hostile\", objectiveModifier.getModifierName()));\n+        }\n+        \n+        // add the \"fixed\" hostile facility modifiers after the primary ones\n+        if(!alliedFacility) {\n+            for(AtBScenarioModifier modifier : AtBScenarioModifier.getRequiredHostileFacilityModifiers()) {\n+                if(!scenario.getBackingScenario().alreadyHasModifier(modifier)) {\n+                    scenario.getBackingScenario().addScenarioModifier(modifier);\n+                }\n+            }\n+        }\n+    }\n+    \n+    private static void processFacilityEffects(StratconTrackState track) {\n+        // todo: these are \"weekly\"? effects that a stratcon facility has on the campaign/track state", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQwMjIzMg==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593402232", "bodyText": "If you changed useSupportPoint and useVictoryPoint you could make this simpler:\n    public boolean useSupportPoint() {\n        if (supportPoints > 0) {\n            supportPoints--;\n            return true;\n        }\n        return false;\n    }\nUsed here like:\n    if (campaignState.useSupportPoint() || campaignState.useVictoryPoint()) {\n       return true;\n    }", "author": "sixlettervariables", "createdAt": "2021-03-12T19:32:55Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1080 @@\n+package mekhq.campaign.stratcon;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import megamek.common.Compute;\n+import megamek.common.Minefield;\n+import megamek.common.UnitType;\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.ResolveScenarioTracker;\n+import mekhq.campaign.againstTheBot.enums.AtBLanceRole;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.force.Lance;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier.EventTiming;\n+import mekhq.campaign.mission.atb.AtBScenarioModifierApplicator;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.unit.Unit;\n+\n+/**\n+ * This class contains \"rules\" logic for the AtB-Stratcon state\n+ * @author NickAragua\n+ *\n+ */\n+public class StratconRulesManager {\n+    public enum ReinforcementEligibilityType {\n+        None,\n+        ChainedScenario,\n+        SupportPoint,\n+        FightLance\n+    }\n+    \n+    /**\n+     * This function potentially generates non-player-initiated scenarios for the given track.\n+     * @param campaign\n+     * @param contract\n+     * @param track\n+     */\n+    public static void generateScenariosForTrack(Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // maps scenarios to force IDs\n+        List<StratconScenario> generatedScenarios = new ArrayList<>(); \n+        boolean autoAssignLances = contract.getCommandRights() == AtBContract.COM_INTEGRATED;\n+        \n+        // get this list just so we have it available\n+        List<Integer> availableForceIDs = getAvailableForceIDs(campaign);\n+        Map<MapLocation, List<Integer>> sortedAvailableForceIDs = sortForcesByMapType(availableForceIDs, campaign);\n+        \n+        // make X rolls, where X is the number of required lances for the track\n+        // that's the chance to spawn a scenario.\n+        // if a scenario occurs, then we pick a random non-deployed lance and use it to drive the opfor generation later\n+        // once we've determined that scenarios occur, we loop through the ones that we generated\n+        // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all \n+        for(int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            // if we haven't already used all the player forces and are required to randomly generate a scenario\n+            if((availableForceIDs.size() > 0) &&\n+                    (Compute.randomInt(100) <= track.getScenarioOdds())) {\n+                // pick random coordinates and force to drive the scenario\n+                int x = Compute.randomInt(track.getWidth());\n+                int y = Compute.randomInt(track.getHeight());                \n+                \n+                StratconCoords scenarioCoords = new StratconCoords(x, y);\n+                \n+                int randomForceIndex = Compute.randomInt(availableForceIDs.size());\n+                int randomForceID = availableForceIDs.get(randomForceIndex);\n+                \n+                // remove the force from the available lists so we don't designate it as primary twice\n+                availableForceIDs.remove(randomForceIndex); \n+                \n+                // we want to remove the actual int with the value, not the value at the index\n+                sortedAvailableForceIDs.get(MapLocation.AllGroundTerrain).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.LowAtmosphere).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.Space).remove((Integer) randomForceID);\n+                \n+                // two scenarios on the same coordinates wind up increasing in size\n+                if(track.getScenarios().containsKey(scenarioCoords)) {\n+                    track.getScenarios().get(scenarioCoords).incrementRequiredPlayerLances();\n+                    assignAppropriateExtraForceToScenario(track.getScenarios().get(scenarioCoords), sortedAvailableForceIDs, campaign);\n+                    continue;\n+                }\n+                \n+                StratconScenario scenario = setupScenario(scenarioCoords, randomForceID, campaign, contract, track);\n+                generatedScenarios.add(scenario);\n+                \n+                // if we're auto-assigning lances, deploy the force to the track as well\n+                if(autoAssignLances) {\n+                    processForceDeployment(scenarioCoords, randomForceID, campaign, track);\n+                }\n+            }\n+        }\n+        \n+        // if under liaison command, pick a random scenario from the ones generated\n+        // to set as required and attach liaison\n+        if(contract.getCommandRights() == AtBContract.COM_LIAISON) {\n+            int scenarioIndex = Compute.randomInt(generatedScenarios.size() - 1);\n+            generatedScenarios.get(scenarioIndex).setRequiredScenario(true);\n+            setAttachedUnitsModifier(generatedScenarios.get(scenarioIndex), contract);\n+        }\n+        \n+        // now, we loop through all the scenarios we set up\n+        // and generate the opfors / events / etc\n+        // if not auto-assigning lances, we then back out the lance assignments.\n+        for(StratconScenario scenario : generatedScenarios) {\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            \n+            if(!autoAssignLances) {\n+                for(int forceID : scenario.getPrimaryPlayerForceIDs()) {\n+                    scenario.getBackingScenario().removeForce(forceID);\n+                }\n+                \n+                scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                track.addScenario(scenario);\n+            } else {\n+                commitPrimaryForces(campaign, contract, scenario, track);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Deploys a force to the given coordinates on the given track as a result of explicit player action.\n+     */\n+    public static void deployForceToCoords(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // the following things should happen:\n+        // 1. call to \"process force deployment\", which reveals fog of war in or around the coords, depending on force role\n+        // 2. if coords are a hostile facility, we get a facility mission\n+        // 3. if coords are empty, we *may* get a mission\n+        \n+        processForceDeployment(coords, forceID, campaign, track);\n+        \n+        // don't create a scenario on top of allied facilities\n+        StratconFacility facility = track.getFacility(coords);\n+        boolean isNonAlliedFacility = (facility != null) && (facility.getOwner() != ForceAlignment.Allied);\n+        boolean spawnScenario = (facility == null) && (Compute.randomInt(100) <= track.getScenarioOdds());\n+\n+        if(isNonAlliedFacility || spawnScenario) {\n+            StratconScenario scenario = setupScenario(coords, forceID, campaign, contract, track);\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            commitPrimaryForces(campaign, contract, scenario, track);\n+        }\n+    }\n+    \n+    /**\n+     * Logic to set up a scenario\n+     */\n+    private static StratconScenario setupScenario(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        StratconScenario scenario = null;\n+        \n+        if(track.getFacilities().containsKey(coords)) {\n+            StratconFacility facility = track.getFacility(coords);\n+            boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+            ScenarioTemplate template = StratconScenarioFactory.getFacilityScenario(alliedFacility);\n+            scenario = generateScenario(campaign, contract, track, forceID, coords, template);\n+            setupFacilityScenario(scenario, track, coords, facility);\n+        } else {\n+            scenario = generateScenario(campaign, contract, track, forceID, coords);\n+            \n+            // we may generate a facility scenario randomly - if so, do the facility-related stuff\n+            // and add a new facility to the track\n+            if(scenario.getBackingScenario().getTemplate().isFacilityScenario()) {\n+                StratconFacility facility = scenario.getBackingScenario().getTemplate().isHostileFacility() ?\n+                        StratconFacilityFactory.getRandomHostileFacility() : StratconFacilityFactory.getRandomAlliedFacility();\n+                facility.setVisible(true);\n+                track.addFacility(coords, facility);\n+                setupFacilityScenario(scenario, track, coords, facility);\n+            }\n+        }\n+        \n+        return scenario;\n+    }\n+    \n+    /**\n+     * carries out tasks relevant to facility scenarios\n+     */\n+    private static void setupFacilityScenario(StratconScenario scenario, StratconTrackState track, StratconCoords coords, StratconFacility facility) {\n+        // this includes:\n+        // for hostile facilities\n+        // - add a destroy objective (always the option to level the facility)\n+        // - add a capture objective (always the option to capture the facility)\n+        // - if so indicated by parameter, roll a random hostile facility objective and add it if not capture/destroy\n+        // for allied facilities\n+        // - add a defend objective (always the option to defend the facility)\n+        // - if so indicated by parameter, roll a random allied facility objective and add it if not defend\n+        AtBScenarioModifier objectiveModifier = null;\n+        boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+        \n+        if(alliedFacility) {\n+            objectiveModifier = AtBScenarioModifier.getRandomAlliedFacilityModifier();\n+        } else {            \n+            objectiveModifier = AtBScenarioModifier.getRandomHostileFacilityModifier();\n+        }\n+        \n+        if(objectiveModifier != null) {\n+            scenario.getBackingScenario().addScenarioModifier(objectiveModifier);\n+            scenario.getBackingScenario().setName(String.format(\"%s - %s - %s\", \n+                    facility.getFacilityType(), alliedFacility ? \"Allied\" : \"Hostile\", objectiveModifier.getModifierName()));\n+        }\n+        \n+        // add the \"fixed\" hostile facility modifiers after the primary ones\n+        if(!alliedFacility) {\n+            for(AtBScenarioModifier modifier : AtBScenarioModifier.getRequiredHostileFacilityModifiers()) {\n+                if(!scenario.getBackingScenario().alreadyHasModifier(modifier)) {\n+                    scenario.getBackingScenario().addScenarioModifier(modifier);\n+                }\n+            }\n+        }\n+    }\n+    \n+    private static void processFacilityEffects(StratconTrackState track) {\n+        // todo: these are \"weekly\"? effects that a stratcon facility has on the campaign/track state\n+        // currrently, that's \n+        // supply depot - allied - +1 sp\n+        // supply depot - hostile - +5% BV budget to all scenarios on track (shared modifier, so should be implemented there)\n+        // data center - allied - +1% star league cache contract (don't implement yet, but...)\n+        // data center - hostile - +5% scenario odds in track\n+        // industrial center - allied - all scenarios here have THIS IS COMING OUT OF YOUR PAYCHECK modifier\n+        // orbital defense - allied - sets 'no hostile aircraft' flag for track\n+        // orbital defense - hostile - sets 'no allied aircraft' flag for track\n+        // early warning system - allied - sets 'intercept allied base attacks' flag for track\n+        // early warning system - hostile - sets 'intercept hostile base attacks' flag for track\n+    }\n+    \n+    /**\n+     * Process the deployment of a force to the given coordinates on the given track.\n+     */\n+    public static void processForceDeployment(StratconCoords coords, int forceID, Campaign campaign, StratconTrackState track) {\n+        track.getRevealedCoords().add(coords);\n+        StratconFacility facility = track.getFacility(coords);\n+        if(facility != null) {\n+            facility.setVisible(true);\n+        }\n+        \n+        if(campaign.getLances().get(forceID).getRole() == AtBLanceRole.SCOUTING) {\n+            for(int direction = 0; direction < 6; direction++) {\n+                StratconCoords checkCoords = coords.translate(direction);\n+                \n+                facility = track.getFacility(checkCoords);\n+                if(facility != null) {\n+                    facility.setVisible(true);\n+                }\n+                \n+                track.getRevealedCoords().add(coords.translate(direction));\n+            }\n+        }\n+        \n+        // the force may be located in other places on the track - clear it out\n+        track.unassignForce(forceID);\n+        track.assignForce(forceID, coords, campaign.getLocalDate());\n+    }\n+    \n+    /**\n+     * Worker function that processes the effects of deploying a reinforcement force to a scenario\n+     */\n+    public static boolean processReinforcementDeployment(ReinforcementEligibilityType reinforcementType, \n+            StratconCampaignState campaignState, StratconScenario scenario, Campaign campaign) {\n+        // if the force is already deployed to the track, we're done\n+        // if the force is a fight lance or we're using a support point\n+        // if there is an SP to burn, burn it and we're done\n+        // if there is a VP to burn, burn it and we're done\n+        // now, roll 2d6 + lance commander tactics\n+        // 9+ = deploy\n+        // 6+ = deploy, if lance != fight, track scenario odds up\n+        // 2+ = apply negative modifier to scenario\n+        \n+        if ((reinforcementType == ReinforcementEligibilityType.FightLance) ||\n+                (reinforcementType == ReinforcementEligibilityType.SupportPoint)) {\n+            \n+            if (campaignState.getSupportPoints() > 0) {\n+                campaignState.useSupportPoint();\n+                return true;\n+            } else if (campaignState.getVictoryPoints() > 0) {\n+                campaignState.updateVictoryPoints(-1);\n+                return true;\n+            }", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQwMjQyNQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593402425", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        int roll = 7;//Compute.d6(2);\n          \n          \n            \n                        int roll = Compute.d6(2);", "author": "sixlettervariables", "createdAt": "2021-03-12T19:33:15Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1080 @@\n+package mekhq.campaign.stratcon;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import megamek.common.Compute;\n+import megamek.common.Minefield;\n+import megamek.common.UnitType;\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.ResolveScenarioTracker;\n+import mekhq.campaign.againstTheBot.enums.AtBLanceRole;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.force.Lance;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier.EventTiming;\n+import mekhq.campaign.mission.atb.AtBScenarioModifierApplicator;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.unit.Unit;\n+\n+/**\n+ * This class contains \"rules\" logic for the AtB-Stratcon state\n+ * @author NickAragua\n+ *\n+ */\n+public class StratconRulesManager {\n+    public enum ReinforcementEligibilityType {\n+        None,\n+        ChainedScenario,\n+        SupportPoint,\n+        FightLance\n+    }\n+    \n+    /**\n+     * This function potentially generates non-player-initiated scenarios for the given track.\n+     * @param campaign\n+     * @param contract\n+     * @param track\n+     */\n+    public static void generateScenariosForTrack(Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // maps scenarios to force IDs\n+        List<StratconScenario> generatedScenarios = new ArrayList<>(); \n+        boolean autoAssignLances = contract.getCommandRights() == AtBContract.COM_INTEGRATED;\n+        \n+        // get this list just so we have it available\n+        List<Integer> availableForceIDs = getAvailableForceIDs(campaign);\n+        Map<MapLocation, List<Integer>> sortedAvailableForceIDs = sortForcesByMapType(availableForceIDs, campaign);\n+        \n+        // make X rolls, where X is the number of required lances for the track\n+        // that's the chance to spawn a scenario.\n+        // if a scenario occurs, then we pick a random non-deployed lance and use it to drive the opfor generation later\n+        // once we've determined that scenarios occur, we loop through the ones that we generated\n+        // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all \n+        for(int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            // if we haven't already used all the player forces and are required to randomly generate a scenario\n+            if((availableForceIDs.size() > 0) &&\n+                    (Compute.randomInt(100) <= track.getScenarioOdds())) {\n+                // pick random coordinates and force to drive the scenario\n+                int x = Compute.randomInt(track.getWidth());\n+                int y = Compute.randomInt(track.getHeight());                \n+                \n+                StratconCoords scenarioCoords = new StratconCoords(x, y);\n+                \n+                int randomForceIndex = Compute.randomInt(availableForceIDs.size());\n+                int randomForceID = availableForceIDs.get(randomForceIndex);\n+                \n+                // remove the force from the available lists so we don't designate it as primary twice\n+                availableForceIDs.remove(randomForceIndex); \n+                \n+                // we want to remove the actual int with the value, not the value at the index\n+                sortedAvailableForceIDs.get(MapLocation.AllGroundTerrain).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.LowAtmosphere).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.Space).remove((Integer) randomForceID);\n+                \n+                // two scenarios on the same coordinates wind up increasing in size\n+                if(track.getScenarios().containsKey(scenarioCoords)) {\n+                    track.getScenarios().get(scenarioCoords).incrementRequiredPlayerLances();\n+                    assignAppropriateExtraForceToScenario(track.getScenarios().get(scenarioCoords), sortedAvailableForceIDs, campaign);\n+                    continue;\n+                }\n+                \n+                StratconScenario scenario = setupScenario(scenarioCoords, randomForceID, campaign, contract, track);\n+                generatedScenarios.add(scenario);\n+                \n+                // if we're auto-assigning lances, deploy the force to the track as well\n+                if(autoAssignLances) {\n+                    processForceDeployment(scenarioCoords, randomForceID, campaign, track);\n+                }\n+            }\n+        }\n+        \n+        // if under liaison command, pick a random scenario from the ones generated\n+        // to set as required and attach liaison\n+        if(contract.getCommandRights() == AtBContract.COM_LIAISON) {\n+            int scenarioIndex = Compute.randomInt(generatedScenarios.size() - 1);\n+            generatedScenarios.get(scenarioIndex).setRequiredScenario(true);\n+            setAttachedUnitsModifier(generatedScenarios.get(scenarioIndex), contract);\n+        }\n+        \n+        // now, we loop through all the scenarios we set up\n+        // and generate the opfors / events / etc\n+        // if not auto-assigning lances, we then back out the lance assignments.\n+        for(StratconScenario scenario : generatedScenarios) {\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            \n+            if(!autoAssignLances) {\n+                for(int forceID : scenario.getPrimaryPlayerForceIDs()) {\n+                    scenario.getBackingScenario().removeForce(forceID);\n+                }\n+                \n+                scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                track.addScenario(scenario);\n+            } else {\n+                commitPrimaryForces(campaign, contract, scenario, track);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Deploys a force to the given coordinates on the given track as a result of explicit player action.\n+     */\n+    public static void deployForceToCoords(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // the following things should happen:\n+        // 1. call to \"process force deployment\", which reveals fog of war in or around the coords, depending on force role\n+        // 2. if coords are a hostile facility, we get a facility mission\n+        // 3. if coords are empty, we *may* get a mission\n+        \n+        processForceDeployment(coords, forceID, campaign, track);\n+        \n+        // don't create a scenario on top of allied facilities\n+        StratconFacility facility = track.getFacility(coords);\n+        boolean isNonAlliedFacility = (facility != null) && (facility.getOwner() != ForceAlignment.Allied);\n+        boolean spawnScenario = (facility == null) && (Compute.randomInt(100) <= track.getScenarioOdds());\n+\n+        if(isNonAlliedFacility || spawnScenario) {\n+            StratconScenario scenario = setupScenario(coords, forceID, campaign, contract, track);\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            commitPrimaryForces(campaign, contract, scenario, track);\n+        }\n+    }\n+    \n+    /**\n+     * Logic to set up a scenario\n+     */\n+    private static StratconScenario setupScenario(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        StratconScenario scenario = null;\n+        \n+        if(track.getFacilities().containsKey(coords)) {\n+            StratconFacility facility = track.getFacility(coords);\n+            boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+            ScenarioTemplate template = StratconScenarioFactory.getFacilityScenario(alliedFacility);\n+            scenario = generateScenario(campaign, contract, track, forceID, coords, template);\n+            setupFacilityScenario(scenario, track, coords, facility);\n+        } else {\n+            scenario = generateScenario(campaign, contract, track, forceID, coords);\n+            \n+            // we may generate a facility scenario randomly - if so, do the facility-related stuff\n+            // and add a new facility to the track\n+            if(scenario.getBackingScenario().getTemplate().isFacilityScenario()) {\n+                StratconFacility facility = scenario.getBackingScenario().getTemplate().isHostileFacility() ?\n+                        StratconFacilityFactory.getRandomHostileFacility() : StratconFacilityFactory.getRandomAlliedFacility();\n+                facility.setVisible(true);\n+                track.addFacility(coords, facility);\n+                setupFacilityScenario(scenario, track, coords, facility);\n+            }\n+        }\n+        \n+        return scenario;\n+    }\n+    \n+    /**\n+     * carries out tasks relevant to facility scenarios\n+     */\n+    private static void setupFacilityScenario(StratconScenario scenario, StratconTrackState track, StratconCoords coords, StratconFacility facility) {\n+        // this includes:\n+        // for hostile facilities\n+        // - add a destroy objective (always the option to level the facility)\n+        // - add a capture objective (always the option to capture the facility)\n+        // - if so indicated by parameter, roll a random hostile facility objective and add it if not capture/destroy\n+        // for allied facilities\n+        // - add a defend objective (always the option to defend the facility)\n+        // - if so indicated by parameter, roll a random allied facility objective and add it if not defend\n+        AtBScenarioModifier objectiveModifier = null;\n+        boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+        \n+        if(alliedFacility) {\n+            objectiveModifier = AtBScenarioModifier.getRandomAlliedFacilityModifier();\n+        } else {            \n+            objectiveModifier = AtBScenarioModifier.getRandomHostileFacilityModifier();\n+        }\n+        \n+        if(objectiveModifier != null) {\n+            scenario.getBackingScenario().addScenarioModifier(objectiveModifier);\n+            scenario.getBackingScenario().setName(String.format(\"%s - %s - %s\", \n+                    facility.getFacilityType(), alliedFacility ? \"Allied\" : \"Hostile\", objectiveModifier.getModifierName()));\n+        }\n+        \n+        // add the \"fixed\" hostile facility modifiers after the primary ones\n+        if(!alliedFacility) {\n+            for(AtBScenarioModifier modifier : AtBScenarioModifier.getRequiredHostileFacilityModifiers()) {\n+                if(!scenario.getBackingScenario().alreadyHasModifier(modifier)) {\n+                    scenario.getBackingScenario().addScenarioModifier(modifier);\n+                }\n+            }\n+        }\n+    }\n+    \n+    private static void processFacilityEffects(StratconTrackState track) {\n+        // todo: these are \"weekly\"? effects that a stratcon facility has on the campaign/track state\n+        // currrently, that's \n+        // supply depot - allied - +1 sp\n+        // supply depot - hostile - +5% BV budget to all scenarios on track (shared modifier, so should be implemented there)\n+        // data center - allied - +1% star league cache contract (don't implement yet, but...)\n+        // data center - hostile - +5% scenario odds in track\n+        // industrial center - allied - all scenarios here have THIS IS COMING OUT OF YOUR PAYCHECK modifier\n+        // orbital defense - allied - sets 'no hostile aircraft' flag for track\n+        // orbital defense - hostile - sets 'no allied aircraft' flag for track\n+        // early warning system - allied - sets 'intercept allied base attacks' flag for track\n+        // early warning system - hostile - sets 'intercept hostile base attacks' flag for track\n+    }\n+    \n+    /**\n+     * Process the deployment of a force to the given coordinates on the given track.\n+     */\n+    public static void processForceDeployment(StratconCoords coords, int forceID, Campaign campaign, StratconTrackState track) {\n+        track.getRevealedCoords().add(coords);\n+        StratconFacility facility = track.getFacility(coords);\n+        if(facility != null) {\n+            facility.setVisible(true);\n+        }\n+        \n+        if(campaign.getLances().get(forceID).getRole() == AtBLanceRole.SCOUTING) {\n+            for(int direction = 0; direction < 6; direction++) {\n+                StratconCoords checkCoords = coords.translate(direction);\n+                \n+                facility = track.getFacility(checkCoords);\n+                if(facility != null) {\n+                    facility.setVisible(true);\n+                }\n+                \n+                track.getRevealedCoords().add(coords.translate(direction));\n+            }\n+        }\n+        \n+        // the force may be located in other places on the track - clear it out\n+        track.unassignForce(forceID);\n+        track.assignForce(forceID, coords, campaign.getLocalDate());\n+    }\n+    \n+    /**\n+     * Worker function that processes the effects of deploying a reinforcement force to a scenario\n+     */\n+    public static boolean processReinforcementDeployment(ReinforcementEligibilityType reinforcementType, \n+            StratconCampaignState campaignState, StratconScenario scenario, Campaign campaign) {\n+        // if the force is already deployed to the track, we're done\n+        // if the force is a fight lance or we're using a support point\n+        // if there is an SP to burn, burn it and we're done\n+        // if there is a VP to burn, burn it and we're done\n+        // now, roll 2d6 + lance commander tactics\n+        // 9+ = deploy\n+        // 6+ = deploy, if lance != fight, track scenario odds up\n+        // 2+ = apply negative modifier to scenario\n+        \n+        if ((reinforcementType == ReinforcementEligibilityType.FightLance) ||\n+                (reinforcementType == ReinforcementEligibilityType.SupportPoint)) {\n+            \n+            if (campaignState.getSupportPoints() > 0) {\n+                campaignState.useSupportPoint();\n+                return true;\n+            } else if (campaignState.getVictoryPoints() > 0) {\n+                campaignState.updateVictoryPoints(-1);\n+                return true;\n+            }\n+            \n+            int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+            int roll = 7;//Compute.d6(2);", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQwMjU5NQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593402595", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            // todo: have the AtBScenarioModifier sort these out instead for performance?\n          \n          \n            \n                            // TODO: have the AtBScenarioModifier sort these out instead for performance?", "author": "sixlettervariables", "createdAt": "2021-03-12T19:33:35Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1080 @@\n+package mekhq.campaign.stratcon;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import megamek.common.Compute;\n+import megamek.common.Minefield;\n+import megamek.common.UnitType;\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.ResolveScenarioTracker;\n+import mekhq.campaign.againstTheBot.enums.AtBLanceRole;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.force.Lance;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier.EventTiming;\n+import mekhq.campaign.mission.atb.AtBScenarioModifierApplicator;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.unit.Unit;\n+\n+/**\n+ * This class contains \"rules\" logic for the AtB-Stratcon state\n+ * @author NickAragua\n+ *\n+ */\n+public class StratconRulesManager {\n+    public enum ReinforcementEligibilityType {\n+        None,\n+        ChainedScenario,\n+        SupportPoint,\n+        FightLance\n+    }\n+    \n+    /**\n+     * This function potentially generates non-player-initiated scenarios for the given track.\n+     * @param campaign\n+     * @param contract\n+     * @param track\n+     */\n+    public static void generateScenariosForTrack(Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // maps scenarios to force IDs\n+        List<StratconScenario> generatedScenarios = new ArrayList<>(); \n+        boolean autoAssignLances = contract.getCommandRights() == AtBContract.COM_INTEGRATED;\n+        \n+        // get this list just so we have it available\n+        List<Integer> availableForceIDs = getAvailableForceIDs(campaign);\n+        Map<MapLocation, List<Integer>> sortedAvailableForceIDs = sortForcesByMapType(availableForceIDs, campaign);\n+        \n+        // make X rolls, where X is the number of required lances for the track\n+        // that's the chance to spawn a scenario.\n+        // if a scenario occurs, then we pick a random non-deployed lance and use it to drive the opfor generation later\n+        // once we've determined that scenarios occur, we loop through the ones that we generated\n+        // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all \n+        for(int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            // if we haven't already used all the player forces and are required to randomly generate a scenario\n+            if((availableForceIDs.size() > 0) &&\n+                    (Compute.randomInt(100) <= track.getScenarioOdds())) {\n+                // pick random coordinates and force to drive the scenario\n+                int x = Compute.randomInt(track.getWidth());\n+                int y = Compute.randomInt(track.getHeight());                \n+                \n+                StratconCoords scenarioCoords = new StratconCoords(x, y);\n+                \n+                int randomForceIndex = Compute.randomInt(availableForceIDs.size());\n+                int randomForceID = availableForceIDs.get(randomForceIndex);\n+                \n+                // remove the force from the available lists so we don't designate it as primary twice\n+                availableForceIDs.remove(randomForceIndex); \n+                \n+                // we want to remove the actual int with the value, not the value at the index\n+                sortedAvailableForceIDs.get(MapLocation.AllGroundTerrain).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.LowAtmosphere).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.Space).remove((Integer) randomForceID);\n+                \n+                // two scenarios on the same coordinates wind up increasing in size\n+                if(track.getScenarios().containsKey(scenarioCoords)) {\n+                    track.getScenarios().get(scenarioCoords).incrementRequiredPlayerLances();\n+                    assignAppropriateExtraForceToScenario(track.getScenarios().get(scenarioCoords), sortedAvailableForceIDs, campaign);\n+                    continue;\n+                }\n+                \n+                StratconScenario scenario = setupScenario(scenarioCoords, randomForceID, campaign, contract, track);\n+                generatedScenarios.add(scenario);\n+                \n+                // if we're auto-assigning lances, deploy the force to the track as well\n+                if(autoAssignLances) {\n+                    processForceDeployment(scenarioCoords, randomForceID, campaign, track);\n+                }\n+            }\n+        }\n+        \n+        // if under liaison command, pick a random scenario from the ones generated\n+        // to set as required and attach liaison\n+        if(contract.getCommandRights() == AtBContract.COM_LIAISON) {\n+            int scenarioIndex = Compute.randomInt(generatedScenarios.size() - 1);\n+            generatedScenarios.get(scenarioIndex).setRequiredScenario(true);\n+            setAttachedUnitsModifier(generatedScenarios.get(scenarioIndex), contract);\n+        }\n+        \n+        // now, we loop through all the scenarios we set up\n+        // and generate the opfors / events / etc\n+        // if not auto-assigning lances, we then back out the lance assignments.\n+        for(StratconScenario scenario : generatedScenarios) {\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            \n+            if(!autoAssignLances) {\n+                for(int forceID : scenario.getPrimaryPlayerForceIDs()) {\n+                    scenario.getBackingScenario().removeForce(forceID);\n+                }\n+                \n+                scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                track.addScenario(scenario);\n+            } else {\n+                commitPrimaryForces(campaign, contract, scenario, track);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Deploys a force to the given coordinates on the given track as a result of explicit player action.\n+     */\n+    public static void deployForceToCoords(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // the following things should happen:\n+        // 1. call to \"process force deployment\", which reveals fog of war in or around the coords, depending on force role\n+        // 2. if coords are a hostile facility, we get a facility mission\n+        // 3. if coords are empty, we *may* get a mission\n+        \n+        processForceDeployment(coords, forceID, campaign, track);\n+        \n+        // don't create a scenario on top of allied facilities\n+        StratconFacility facility = track.getFacility(coords);\n+        boolean isNonAlliedFacility = (facility != null) && (facility.getOwner() != ForceAlignment.Allied);\n+        boolean spawnScenario = (facility == null) && (Compute.randomInt(100) <= track.getScenarioOdds());\n+\n+        if(isNonAlliedFacility || spawnScenario) {\n+            StratconScenario scenario = setupScenario(coords, forceID, campaign, contract, track);\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            commitPrimaryForces(campaign, contract, scenario, track);\n+        }\n+    }\n+    \n+    /**\n+     * Logic to set up a scenario\n+     */\n+    private static StratconScenario setupScenario(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        StratconScenario scenario = null;\n+        \n+        if(track.getFacilities().containsKey(coords)) {\n+            StratconFacility facility = track.getFacility(coords);\n+            boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+            ScenarioTemplate template = StratconScenarioFactory.getFacilityScenario(alliedFacility);\n+            scenario = generateScenario(campaign, contract, track, forceID, coords, template);\n+            setupFacilityScenario(scenario, track, coords, facility);\n+        } else {\n+            scenario = generateScenario(campaign, contract, track, forceID, coords);\n+            \n+            // we may generate a facility scenario randomly - if so, do the facility-related stuff\n+            // and add a new facility to the track\n+            if(scenario.getBackingScenario().getTemplate().isFacilityScenario()) {\n+                StratconFacility facility = scenario.getBackingScenario().getTemplate().isHostileFacility() ?\n+                        StratconFacilityFactory.getRandomHostileFacility() : StratconFacilityFactory.getRandomAlliedFacility();\n+                facility.setVisible(true);\n+                track.addFacility(coords, facility);\n+                setupFacilityScenario(scenario, track, coords, facility);\n+            }\n+        }\n+        \n+        return scenario;\n+    }\n+    \n+    /**\n+     * carries out tasks relevant to facility scenarios\n+     */\n+    private static void setupFacilityScenario(StratconScenario scenario, StratconTrackState track, StratconCoords coords, StratconFacility facility) {\n+        // this includes:\n+        // for hostile facilities\n+        // - add a destroy objective (always the option to level the facility)\n+        // - add a capture objective (always the option to capture the facility)\n+        // - if so indicated by parameter, roll a random hostile facility objective and add it if not capture/destroy\n+        // for allied facilities\n+        // - add a defend objective (always the option to defend the facility)\n+        // - if so indicated by parameter, roll a random allied facility objective and add it if not defend\n+        AtBScenarioModifier objectiveModifier = null;\n+        boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+        \n+        if(alliedFacility) {\n+            objectiveModifier = AtBScenarioModifier.getRandomAlliedFacilityModifier();\n+        } else {            \n+            objectiveModifier = AtBScenarioModifier.getRandomHostileFacilityModifier();\n+        }\n+        \n+        if(objectiveModifier != null) {\n+            scenario.getBackingScenario().addScenarioModifier(objectiveModifier);\n+            scenario.getBackingScenario().setName(String.format(\"%s - %s - %s\", \n+                    facility.getFacilityType(), alliedFacility ? \"Allied\" : \"Hostile\", objectiveModifier.getModifierName()));\n+        }\n+        \n+        // add the \"fixed\" hostile facility modifiers after the primary ones\n+        if(!alliedFacility) {\n+            for(AtBScenarioModifier modifier : AtBScenarioModifier.getRequiredHostileFacilityModifiers()) {\n+                if(!scenario.getBackingScenario().alreadyHasModifier(modifier)) {\n+                    scenario.getBackingScenario().addScenarioModifier(modifier);\n+                }\n+            }\n+        }\n+    }\n+    \n+    private static void processFacilityEffects(StratconTrackState track) {\n+        // todo: these are \"weekly\"? effects that a stratcon facility has on the campaign/track state\n+        // currrently, that's \n+        // supply depot - allied - +1 sp\n+        // supply depot - hostile - +5% BV budget to all scenarios on track (shared modifier, so should be implemented there)\n+        // data center - allied - +1% star league cache contract (don't implement yet, but...)\n+        // data center - hostile - +5% scenario odds in track\n+        // industrial center - allied - all scenarios here have THIS IS COMING OUT OF YOUR PAYCHECK modifier\n+        // orbital defense - allied - sets 'no hostile aircraft' flag for track\n+        // orbital defense - hostile - sets 'no allied aircraft' flag for track\n+        // early warning system - allied - sets 'intercept allied base attacks' flag for track\n+        // early warning system - hostile - sets 'intercept hostile base attacks' flag for track\n+    }\n+    \n+    /**\n+     * Process the deployment of a force to the given coordinates on the given track.\n+     */\n+    public static void processForceDeployment(StratconCoords coords, int forceID, Campaign campaign, StratconTrackState track) {\n+        track.getRevealedCoords().add(coords);\n+        StratconFacility facility = track.getFacility(coords);\n+        if(facility != null) {\n+            facility.setVisible(true);\n+        }\n+        \n+        if(campaign.getLances().get(forceID).getRole() == AtBLanceRole.SCOUTING) {\n+            for(int direction = 0; direction < 6; direction++) {\n+                StratconCoords checkCoords = coords.translate(direction);\n+                \n+                facility = track.getFacility(checkCoords);\n+                if(facility != null) {\n+                    facility.setVisible(true);\n+                }\n+                \n+                track.getRevealedCoords().add(coords.translate(direction));\n+            }\n+        }\n+        \n+        // the force may be located in other places on the track - clear it out\n+        track.unassignForce(forceID);\n+        track.assignForce(forceID, coords, campaign.getLocalDate());\n+    }\n+    \n+    /**\n+     * Worker function that processes the effects of deploying a reinforcement force to a scenario\n+     */\n+    public static boolean processReinforcementDeployment(ReinforcementEligibilityType reinforcementType, \n+            StratconCampaignState campaignState, StratconScenario scenario, Campaign campaign) {\n+        // if the force is already deployed to the track, we're done\n+        // if the force is a fight lance or we're using a support point\n+        // if there is an SP to burn, burn it and we're done\n+        // if there is a VP to burn, burn it and we're done\n+        // now, roll 2d6 + lance commander tactics\n+        // 9+ = deploy\n+        // 6+ = deploy, if lance != fight, track scenario odds up\n+        // 2+ = apply negative modifier to scenario\n+        \n+        if ((reinforcementType == ReinforcementEligibilityType.FightLance) ||\n+                (reinforcementType == ReinforcementEligibilityType.SupportPoint)) {\n+            \n+            if (campaignState.getSupportPoints() > 0) {\n+                campaignState.useSupportPoint();\n+                return true;\n+            } else if (campaignState.getVictoryPoints() > 0) {\n+                campaignState.updateVictoryPoints(-1);\n+                return true;\n+            }\n+            \n+            int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+            int roll = 7;//Compute.d6(2);\n+            int result = roll + tactics;\n+\n+            String reportStatus = String.format(\"Attempting to reinforce scenario %s without SP/VP, roll 2d6 + %d: %d\",\n+                    scenario.getName(), tactics, result);\n+            \n+            // fail to reinforce\n+            if (result < 6) {\n+                reportStatus += \" - reinforcement attempt failed.\";\n+                campaign.addReport(reportStatus);\n+                return false;\n+            // succeed but get an extra negative event added to the scenario\n+            } else if ((result < 9) && (reinforcementType != ReinforcementEligibilityType.FightLance)) {\n+                MapLocation mapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+                AtBScenarioModifier scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+                \n+                // keep rolling until we get an applicable one\n+                // todo: have the AtBScenarioModifier sort these out instead for performance?", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQwMjcxOA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593402718", "bodyText": "Prefer a StringBuilder, but not required (this isn't on the hot path at all).", "author": "sixlettervariables", "createdAt": "2021-03-12T19:33:49Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1080 @@\n+package mekhq.campaign.stratcon;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import megamek.common.Compute;\n+import megamek.common.Minefield;\n+import megamek.common.UnitType;\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.ResolveScenarioTracker;\n+import mekhq.campaign.againstTheBot.enums.AtBLanceRole;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.force.Lance;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier.EventTiming;\n+import mekhq.campaign.mission.atb.AtBScenarioModifierApplicator;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.unit.Unit;\n+\n+/**\n+ * This class contains \"rules\" logic for the AtB-Stratcon state\n+ * @author NickAragua\n+ *\n+ */\n+public class StratconRulesManager {\n+    public enum ReinforcementEligibilityType {\n+        None,\n+        ChainedScenario,\n+        SupportPoint,\n+        FightLance\n+    }\n+    \n+    /**\n+     * This function potentially generates non-player-initiated scenarios for the given track.\n+     * @param campaign\n+     * @param contract\n+     * @param track\n+     */\n+    public static void generateScenariosForTrack(Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // maps scenarios to force IDs\n+        List<StratconScenario> generatedScenarios = new ArrayList<>(); \n+        boolean autoAssignLances = contract.getCommandRights() == AtBContract.COM_INTEGRATED;\n+        \n+        // get this list just so we have it available\n+        List<Integer> availableForceIDs = getAvailableForceIDs(campaign);\n+        Map<MapLocation, List<Integer>> sortedAvailableForceIDs = sortForcesByMapType(availableForceIDs, campaign);\n+        \n+        // make X rolls, where X is the number of required lances for the track\n+        // that's the chance to spawn a scenario.\n+        // if a scenario occurs, then we pick a random non-deployed lance and use it to drive the opfor generation later\n+        // once we've determined that scenarios occur, we loop through the ones that we generated\n+        // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all \n+        for(int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            // if we haven't already used all the player forces and are required to randomly generate a scenario\n+            if((availableForceIDs.size() > 0) &&\n+                    (Compute.randomInt(100) <= track.getScenarioOdds())) {\n+                // pick random coordinates and force to drive the scenario\n+                int x = Compute.randomInt(track.getWidth());\n+                int y = Compute.randomInt(track.getHeight());                \n+                \n+                StratconCoords scenarioCoords = new StratconCoords(x, y);\n+                \n+                int randomForceIndex = Compute.randomInt(availableForceIDs.size());\n+                int randomForceID = availableForceIDs.get(randomForceIndex);\n+                \n+                // remove the force from the available lists so we don't designate it as primary twice\n+                availableForceIDs.remove(randomForceIndex); \n+                \n+                // we want to remove the actual int with the value, not the value at the index\n+                sortedAvailableForceIDs.get(MapLocation.AllGroundTerrain).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.LowAtmosphere).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.Space).remove((Integer) randomForceID);\n+                \n+                // two scenarios on the same coordinates wind up increasing in size\n+                if(track.getScenarios().containsKey(scenarioCoords)) {\n+                    track.getScenarios().get(scenarioCoords).incrementRequiredPlayerLances();\n+                    assignAppropriateExtraForceToScenario(track.getScenarios().get(scenarioCoords), sortedAvailableForceIDs, campaign);\n+                    continue;\n+                }\n+                \n+                StratconScenario scenario = setupScenario(scenarioCoords, randomForceID, campaign, contract, track);\n+                generatedScenarios.add(scenario);\n+                \n+                // if we're auto-assigning lances, deploy the force to the track as well\n+                if(autoAssignLances) {\n+                    processForceDeployment(scenarioCoords, randomForceID, campaign, track);\n+                }\n+            }\n+        }\n+        \n+        // if under liaison command, pick a random scenario from the ones generated\n+        // to set as required and attach liaison\n+        if(contract.getCommandRights() == AtBContract.COM_LIAISON) {\n+            int scenarioIndex = Compute.randomInt(generatedScenarios.size() - 1);\n+            generatedScenarios.get(scenarioIndex).setRequiredScenario(true);\n+            setAttachedUnitsModifier(generatedScenarios.get(scenarioIndex), contract);\n+        }\n+        \n+        // now, we loop through all the scenarios we set up\n+        // and generate the opfors / events / etc\n+        // if not auto-assigning lances, we then back out the lance assignments.\n+        for(StratconScenario scenario : generatedScenarios) {\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            \n+            if(!autoAssignLances) {\n+                for(int forceID : scenario.getPrimaryPlayerForceIDs()) {\n+                    scenario.getBackingScenario().removeForce(forceID);\n+                }\n+                \n+                scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                track.addScenario(scenario);\n+            } else {\n+                commitPrimaryForces(campaign, contract, scenario, track);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Deploys a force to the given coordinates on the given track as a result of explicit player action.\n+     */\n+    public static void deployForceToCoords(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // the following things should happen:\n+        // 1. call to \"process force deployment\", which reveals fog of war in or around the coords, depending on force role\n+        // 2. if coords are a hostile facility, we get a facility mission\n+        // 3. if coords are empty, we *may* get a mission\n+        \n+        processForceDeployment(coords, forceID, campaign, track);\n+        \n+        // don't create a scenario on top of allied facilities\n+        StratconFacility facility = track.getFacility(coords);\n+        boolean isNonAlliedFacility = (facility != null) && (facility.getOwner() != ForceAlignment.Allied);\n+        boolean spawnScenario = (facility == null) && (Compute.randomInt(100) <= track.getScenarioOdds());\n+\n+        if(isNonAlliedFacility || spawnScenario) {\n+            StratconScenario scenario = setupScenario(coords, forceID, campaign, contract, track);\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            commitPrimaryForces(campaign, contract, scenario, track);\n+        }\n+    }\n+    \n+    /**\n+     * Logic to set up a scenario\n+     */\n+    private static StratconScenario setupScenario(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        StratconScenario scenario = null;\n+        \n+        if(track.getFacilities().containsKey(coords)) {\n+            StratconFacility facility = track.getFacility(coords);\n+            boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+            ScenarioTemplate template = StratconScenarioFactory.getFacilityScenario(alliedFacility);\n+            scenario = generateScenario(campaign, contract, track, forceID, coords, template);\n+            setupFacilityScenario(scenario, track, coords, facility);\n+        } else {\n+            scenario = generateScenario(campaign, contract, track, forceID, coords);\n+            \n+            // we may generate a facility scenario randomly - if so, do the facility-related stuff\n+            // and add a new facility to the track\n+            if(scenario.getBackingScenario().getTemplate().isFacilityScenario()) {\n+                StratconFacility facility = scenario.getBackingScenario().getTemplate().isHostileFacility() ?\n+                        StratconFacilityFactory.getRandomHostileFacility() : StratconFacilityFactory.getRandomAlliedFacility();\n+                facility.setVisible(true);\n+                track.addFacility(coords, facility);\n+                setupFacilityScenario(scenario, track, coords, facility);\n+            }\n+        }\n+        \n+        return scenario;\n+    }\n+    \n+    /**\n+     * carries out tasks relevant to facility scenarios\n+     */\n+    private static void setupFacilityScenario(StratconScenario scenario, StratconTrackState track, StratconCoords coords, StratconFacility facility) {\n+        // this includes:\n+        // for hostile facilities\n+        // - add a destroy objective (always the option to level the facility)\n+        // - add a capture objective (always the option to capture the facility)\n+        // - if so indicated by parameter, roll a random hostile facility objective and add it if not capture/destroy\n+        // for allied facilities\n+        // - add a defend objective (always the option to defend the facility)\n+        // - if so indicated by parameter, roll a random allied facility objective and add it if not defend\n+        AtBScenarioModifier objectiveModifier = null;\n+        boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+        \n+        if(alliedFacility) {\n+            objectiveModifier = AtBScenarioModifier.getRandomAlliedFacilityModifier();\n+        } else {            \n+            objectiveModifier = AtBScenarioModifier.getRandomHostileFacilityModifier();\n+        }\n+        \n+        if(objectiveModifier != null) {\n+            scenario.getBackingScenario().addScenarioModifier(objectiveModifier);\n+            scenario.getBackingScenario().setName(String.format(\"%s - %s - %s\", \n+                    facility.getFacilityType(), alliedFacility ? \"Allied\" : \"Hostile\", objectiveModifier.getModifierName()));\n+        }\n+        \n+        // add the \"fixed\" hostile facility modifiers after the primary ones\n+        if(!alliedFacility) {\n+            for(AtBScenarioModifier modifier : AtBScenarioModifier.getRequiredHostileFacilityModifiers()) {\n+                if(!scenario.getBackingScenario().alreadyHasModifier(modifier)) {\n+                    scenario.getBackingScenario().addScenarioModifier(modifier);\n+                }\n+            }\n+        }\n+    }\n+    \n+    private static void processFacilityEffects(StratconTrackState track) {\n+        // todo: these are \"weekly\"? effects that a stratcon facility has on the campaign/track state\n+        // currrently, that's \n+        // supply depot - allied - +1 sp\n+        // supply depot - hostile - +5% BV budget to all scenarios on track (shared modifier, so should be implemented there)\n+        // data center - allied - +1% star league cache contract (don't implement yet, but...)\n+        // data center - hostile - +5% scenario odds in track\n+        // industrial center - allied - all scenarios here have THIS IS COMING OUT OF YOUR PAYCHECK modifier\n+        // orbital defense - allied - sets 'no hostile aircraft' flag for track\n+        // orbital defense - hostile - sets 'no allied aircraft' flag for track\n+        // early warning system - allied - sets 'intercept allied base attacks' flag for track\n+        // early warning system - hostile - sets 'intercept hostile base attacks' flag for track\n+    }\n+    \n+    /**\n+     * Process the deployment of a force to the given coordinates on the given track.\n+     */\n+    public static void processForceDeployment(StratconCoords coords, int forceID, Campaign campaign, StratconTrackState track) {\n+        track.getRevealedCoords().add(coords);\n+        StratconFacility facility = track.getFacility(coords);\n+        if(facility != null) {\n+            facility.setVisible(true);\n+        }\n+        \n+        if(campaign.getLances().get(forceID).getRole() == AtBLanceRole.SCOUTING) {\n+            for(int direction = 0; direction < 6; direction++) {\n+                StratconCoords checkCoords = coords.translate(direction);\n+                \n+                facility = track.getFacility(checkCoords);\n+                if(facility != null) {\n+                    facility.setVisible(true);\n+                }\n+                \n+                track.getRevealedCoords().add(coords.translate(direction));\n+            }\n+        }\n+        \n+        // the force may be located in other places on the track - clear it out\n+        track.unassignForce(forceID);\n+        track.assignForce(forceID, coords, campaign.getLocalDate());\n+    }\n+    \n+    /**\n+     * Worker function that processes the effects of deploying a reinforcement force to a scenario\n+     */\n+    public static boolean processReinforcementDeployment(ReinforcementEligibilityType reinforcementType, \n+            StratconCampaignState campaignState, StratconScenario scenario, Campaign campaign) {\n+        // if the force is already deployed to the track, we're done\n+        // if the force is a fight lance or we're using a support point\n+        // if there is an SP to burn, burn it and we're done\n+        // if there is a VP to burn, burn it and we're done\n+        // now, roll 2d6 + lance commander tactics\n+        // 9+ = deploy\n+        // 6+ = deploy, if lance != fight, track scenario odds up\n+        // 2+ = apply negative modifier to scenario\n+        \n+        if ((reinforcementType == ReinforcementEligibilityType.FightLance) ||\n+                (reinforcementType == ReinforcementEligibilityType.SupportPoint)) {\n+            \n+            if (campaignState.getSupportPoints() > 0) {\n+                campaignState.useSupportPoint();\n+                return true;\n+            } else if (campaignState.getVictoryPoints() > 0) {\n+                campaignState.updateVictoryPoints(-1);\n+                return true;\n+            }\n+            \n+            int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+            int roll = 7;//Compute.d6(2);\n+            int result = roll + tactics;\n+\n+            String reportStatus = String.format(\"Attempting to reinforce scenario %s without SP/VP, roll 2d6 + %d: %d\",", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQwNTc3OA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593405778", "bodyText": "It looks like everywhere else uses <=, why just a plain < here?", "author": "sixlettervariables", "createdAt": "2021-03-12T19:39:18Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1080 @@\n+package mekhq.campaign.stratcon;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import megamek.common.Compute;\n+import megamek.common.Minefield;\n+import megamek.common.UnitType;\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.ResolveScenarioTracker;\n+import mekhq.campaign.againstTheBot.enums.AtBLanceRole;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.force.Lance;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier.EventTiming;\n+import mekhq.campaign.mission.atb.AtBScenarioModifierApplicator;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.unit.Unit;\n+\n+/**\n+ * This class contains \"rules\" logic for the AtB-Stratcon state\n+ * @author NickAragua\n+ *\n+ */\n+public class StratconRulesManager {\n+    public enum ReinforcementEligibilityType {\n+        None,\n+        ChainedScenario,\n+        SupportPoint,\n+        FightLance\n+    }\n+    \n+    /**\n+     * This function potentially generates non-player-initiated scenarios for the given track.\n+     * @param campaign\n+     * @param contract\n+     * @param track\n+     */\n+    public static void generateScenariosForTrack(Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // maps scenarios to force IDs\n+        List<StratconScenario> generatedScenarios = new ArrayList<>(); \n+        boolean autoAssignLances = contract.getCommandRights() == AtBContract.COM_INTEGRATED;\n+        \n+        // get this list just so we have it available\n+        List<Integer> availableForceIDs = getAvailableForceIDs(campaign);\n+        Map<MapLocation, List<Integer>> sortedAvailableForceIDs = sortForcesByMapType(availableForceIDs, campaign);\n+        \n+        // make X rolls, where X is the number of required lances for the track\n+        // that's the chance to spawn a scenario.\n+        // if a scenario occurs, then we pick a random non-deployed lance and use it to drive the opfor generation later\n+        // once we've determined that scenarios occur, we loop through the ones that we generated\n+        // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all \n+        for(int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            // if we haven't already used all the player forces and are required to randomly generate a scenario\n+            if((availableForceIDs.size() > 0) &&\n+                    (Compute.randomInt(100) <= track.getScenarioOdds())) {\n+                // pick random coordinates and force to drive the scenario\n+                int x = Compute.randomInt(track.getWidth());\n+                int y = Compute.randomInt(track.getHeight());                \n+                \n+                StratconCoords scenarioCoords = new StratconCoords(x, y);\n+                \n+                int randomForceIndex = Compute.randomInt(availableForceIDs.size());\n+                int randomForceID = availableForceIDs.get(randomForceIndex);\n+                \n+                // remove the force from the available lists so we don't designate it as primary twice\n+                availableForceIDs.remove(randomForceIndex); \n+                \n+                // we want to remove the actual int with the value, not the value at the index\n+                sortedAvailableForceIDs.get(MapLocation.AllGroundTerrain).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.LowAtmosphere).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.Space).remove((Integer) randomForceID);\n+                \n+                // two scenarios on the same coordinates wind up increasing in size\n+                if(track.getScenarios().containsKey(scenarioCoords)) {\n+                    track.getScenarios().get(scenarioCoords).incrementRequiredPlayerLances();\n+                    assignAppropriateExtraForceToScenario(track.getScenarios().get(scenarioCoords), sortedAvailableForceIDs, campaign);\n+                    continue;\n+                }\n+                \n+                StratconScenario scenario = setupScenario(scenarioCoords, randomForceID, campaign, contract, track);\n+                generatedScenarios.add(scenario);\n+                \n+                // if we're auto-assigning lances, deploy the force to the track as well\n+                if(autoAssignLances) {\n+                    processForceDeployment(scenarioCoords, randomForceID, campaign, track);\n+                }\n+            }\n+        }\n+        \n+        // if under liaison command, pick a random scenario from the ones generated\n+        // to set as required and attach liaison\n+        if(contract.getCommandRights() == AtBContract.COM_LIAISON) {\n+            int scenarioIndex = Compute.randomInt(generatedScenarios.size() - 1);\n+            generatedScenarios.get(scenarioIndex).setRequiredScenario(true);\n+            setAttachedUnitsModifier(generatedScenarios.get(scenarioIndex), contract);\n+        }\n+        \n+        // now, we loop through all the scenarios we set up\n+        // and generate the opfors / events / etc\n+        // if not auto-assigning lances, we then back out the lance assignments.\n+        for(StratconScenario scenario : generatedScenarios) {\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            \n+            if(!autoAssignLances) {\n+                for(int forceID : scenario.getPrimaryPlayerForceIDs()) {\n+                    scenario.getBackingScenario().removeForce(forceID);\n+                }\n+                \n+                scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                track.addScenario(scenario);\n+            } else {\n+                commitPrimaryForces(campaign, contract, scenario, track);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Deploys a force to the given coordinates on the given track as a result of explicit player action.\n+     */\n+    public static void deployForceToCoords(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // the following things should happen:\n+        // 1. call to \"process force deployment\", which reveals fog of war in or around the coords, depending on force role\n+        // 2. if coords are a hostile facility, we get a facility mission\n+        // 3. if coords are empty, we *may* get a mission\n+        \n+        processForceDeployment(coords, forceID, campaign, track);\n+        \n+        // don't create a scenario on top of allied facilities\n+        StratconFacility facility = track.getFacility(coords);\n+        boolean isNonAlliedFacility = (facility != null) && (facility.getOwner() != ForceAlignment.Allied);\n+        boolean spawnScenario = (facility == null) && (Compute.randomInt(100) <= track.getScenarioOdds());\n+\n+        if(isNonAlliedFacility || spawnScenario) {\n+            StratconScenario scenario = setupScenario(coords, forceID, campaign, contract, track);\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            commitPrimaryForces(campaign, contract, scenario, track);\n+        }\n+    }\n+    \n+    /**\n+     * Logic to set up a scenario\n+     */\n+    private static StratconScenario setupScenario(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        StratconScenario scenario = null;\n+        \n+        if(track.getFacilities().containsKey(coords)) {\n+            StratconFacility facility = track.getFacility(coords);\n+            boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+            ScenarioTemplate template = StratconScenarioFactory.getFacilityScenario(alliedFacility);\n+            scenario = generateScenario(campaign, contract, track, forceID, coords, template);\n+            setupFacilityScenario(scenario, track, coords, facility);\n+        } else {\n+            scenario = generateScenario(campaign, contract, track, forceID, coords);\n+            \n+            // we may generate a facility scenario randomly - if so, do the facility-related stuff\n+            // and add a new facility to the track\n+            if(scenario.getBackingScenario().getTemplate().isFacilityScenario()) {\n+                StratconFacility facility = scenario.getBackingScenario().getTemplate().isHostileFacility() ?\n+                        StratconFacilityFactory.getRandomHostileFacility() : StratconFacilityFactory.getRandomAlliedFacility();\n+                facility.setVisible(true);\n+                track.addFacility(coords, facility);\n+                setupFacilityScenario(scenario, track, coords, facility);\n+            }\n+        }\n+        \n+        return scenario;\n+    }\n+    \n+    /**\n+     * carries out tasks relevant to facility scenarios\n+     */\n+    private static void setupFacilityScenario(StratconScenario scenario, StratconTrackState track, StratconCoords coords, StratconFacility facility) {\n+        // this includes:\n+        // for hostile facilities\n+        // - add a destroy objective (always the option to level the facility)\n+        // - add a capture objective (always the option to capture the facility)\n+        // - if so indicated by parameter, roll a random hostile facility objective and add it if not capture/destroy\n+        // for allied facilities\n+        // - add a defend objective (always the option to defend the facility)\n+        // - if so indicated by parameter, roll a random allied facility objective and add it if not defend\n+        AtBScenarioModifier objectiveModifier = null;\n+        boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+        \n+        if(alliedFacility) {\n+            objectiveModifier = AtBScenarioModifier.getRandomAlliedFacilityModifier();\n+        } else {            \n+            objectiveModifier = AtBScenarioModifier.getRandomHostileFacilityModifier();\n+        }\n+        \n+        if(objectiveModifier != null) {\n+            scenario.getBackingScenario().addScenarioModifier(objectiveModifier);\n+            scenario.getBackingScenario().setName(String.format(\"%s - %s - %s\", \n+                    facility.getFacilityType(), alliedFacility ? \"Allied\" : \"Hostile\", objectiveModifier.getModifierName()));\n+        }\n+        \n+        // add the \"fixed\" hostile facility modifiers after the primary ones\n+        if(!alliedFacility) {\n+            for(AtBScenarioModifier modifier : AtBScenarioModifier.getRequiredHostileFacilityModifiers()) {\n+                if(!scenario.getBackingScenario().alreadyHasModifier(modifier)) {\n+                    scenario.getBackingScenario().addScenarioModifier(modifier);\n+                }\n+            }\n+        }\n+    }\n+    \n+    private static void processFacilityEffects(StratconTrackState track) {\n+        // todo: these are \"weekly\"? effects that a stratcon facility has on the campaign/track state\n+        // currrently, that's \n+        // supply depot - allied - +1 sp\n+        // supply depot - hostile - +5% BV budget to all scenarios on track (shared modifier, so should be implemented there)\n+        // data center - allied - +1% star league cache contract (don't implement yet, but...)\n+        // data center - hostile - +5% scenario odds in track\n+        // industrial center - allied - all scenarios here have THIS IS COMING OUT OF YOUR PAYCHECK modifier\n+        // orbital defense - allied - sets 'no hostile aircraft' flag for track\n+        // orbital defense - hostile - sets 'no allied aircraft' flag for track\n+        // early warning system - allied - sets 'intercept allied base attacks' flag for track\n+        // early warning system - hostile - sets 'intercept hostile base attacks' flag for track\n+    }\n+    \n+    /**\n+     * Process the deployment of a force to the given coordinates on the given track.\n+     */\n+    public static void processForceDeployment(StratconCoords coords, int forceID, Campaign campaign, StratconTrackState track) {\n+        track.getRevealedCoords().add(coords);\n+        StratconFacility facility = track.getFacility(coords);\n+        if(facility != null) {\n+            facility.setVisible(true);\n+        }\n+        \n+        if(campaign.getLances().get(forceID).getRole() == AtBLanceRole.SCOUTING) {\n+            for(int direction = 0; direction < 6; direction++) {\n+                StratconCoords checkCoords = coords.translate(direction);\n+                \n+                facility = track.getFacility(checkCoords);\n+                if(facility != null) {\n+                    facility.setVisible(true);\n+                }\n+                \n+                track.getRevealedCoords().add(coords.translate(direction));\n+            }\n+        }\n+        \n+        // the force may be located in other places on the track - clear it out\n+        track.unassignForce(forceID);\n+        track.assignForce(forceID, coords, campaign.getLocalDate());\n+    }\n+    \n+    /**\n+     * Worker function that processes the effects of deploying a reinforcement force to a scenario\n+     */\n+    public static boolean processReinforcementDeployment(ReinforcementEligibilityType reinforcementType, \n+            StratconCampaignState campaignState, StratconScenario scenario, Campaign campaign) {\n+        // if the force is already deployed to the track, we're done\n+        // if the force is a fight lance or we're using a support point\n+        // if there is an SP to burn, burn it and we're done\n+        // if there is a VP to burn, burn it and we're done\n+        // now, roll 2d6 + lance commander tactics\n+        // 9+ = deploy\n+        // 6+ = deploy, if lance != fight, track scenario odds up\n+        // 2+ = apply negative modifier to scenario\n+        \n+        if ((reinforcementType == ReinforcementEligibilityType.FightLance) ||\n+                (reinforcementType == ReinforcementEligibilityType.SupportPoint)) {\n+            \n+            if (campaignState.getSupportPoints() > 0) {\n+                campaignState.useSupportPoint();\n+                return true;\n+            } else if (campaignState.getVictoryPoints() > 0) {\n+                campaignState.updateVictoryPoints(-1);\n+                return true;\n+            }\n+            \n+            int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+            int roll = 7;//Compute.d6(2);\n+            int result = roll + tactics;\n+\n+            String reportStatus = String.format(\"Attempting to reinforce scenario %s without SP/VP, roll 2d6 + %d: %d\",\n+                    scenario.getName(), tactics, result);\n+            \n+            // fail to reinforce\n+            if (result < 6) {\n+                reportStatus += \" - reinforcement attempt failed.\";\n+                campaign.addReport(reportStatus);\n+                return false;\n+            // succeed but get an extra negative event added to the scenario\n+            } else if ((result < 9) && (reinforcementType != ReinforcementEligibilityType.FightLance)) {\n+                MapLocation mapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+                AtBScenarioModifier scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+                \n+                // keep rolling until we get an applicable one\n+                // todo: have the AtBScenarioModifier sort these out instead for performance?\n+                while (scenarioModifier.getEventTiming() != EventTiming.PostForceGeneration) {\n+                    scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+                }\n+                \n+                scenarioModifier.processModifier(scenario.getBackingScenario(), campaign, EventTiming.PostForceGeneration);\n+                \n+                reportStatus += String.format(\" - reinforcement attempt succeeded; extra negative modifier (%s) applied to scenario.\",\n+                        scenarioModifier.getModifierName());\n+                campaign.addReport(reportStatus);\n+                return true;\n+            // succeed without reservation\n+            } else {\n+                reportStatus += \" - reinforcement attempt succeeded;\";\n+                campaign.addReport(reportStatus);\n+                return true;\n+            }\n+        } else if (reinforcementType == ReinforcementEligibilityType.None) {\n+            return false;\n+        }\n+        \n+        return true;\n+    }\n+    \n+    /**\n+     * Assigns a force to the scenario such that the majority of the force can be deployed\n+     * @param scenario\n+     * @param sortedAvailableForceIDs\n+     */\n+    private static void assignAppropriateExtraForceToScenario(StratconScenario scenario, \n+            Map<MapLocation, List<Integer>> sortedAvailableForceIDs, Campaign campaign) {\n+        // the goal of this function is to avoid assigning ground units to air battles\n+        // and ground units/conventional fighters to space battle\n+        \n+        List<MapLocation> mapLocations = new ArrayList<>();\n+        mapLocations.add(MapLocation.Space); // can always add ASFs\n+        \n+        MapLocation scenarioMapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+        \n+        if(scenarioMapLocation == MapLocation.LowAtmosphere) {\n+            mapLocations.add(MapLocation.LowAtmosphere); // can add conventional fighters to ground or low atmo battles\n+        }\n+        \n+        if((scenarioMapLocation == MapLocation.AllGroundTerrain) || \n+                (scenarioMapLocation == MapLocation.SpecificGroundTerrain)) {\n+            mapLocations.add(MapLocation.AllGroundTerrain); // can only add ground units to ground battles\n+        }\n+        \n+        MapLocation selectedLocation = mapLocations.get(Compute.randomInt(mapLocations.size()));\n+        List<Integer> forceIDs = sortedAvailableForceIDs.get(selectedLocation);\n+        int forceIndex = Compute.randomInt(forceIDs.size());\n+        int forceID = forceIDs.get(forceIndex);\n+        forceIDs.remove(forceIndex);\n+        \n+        scenario.addPrimaryForce(forceID);\n+    }\n+    \n+    /**\n+     * Worker function that \"locks in\" a scenario - \n+     * Adds it to the campaign so it's visible in the briefing room,\n+     * adds it to the track\n+     * \n+     */\n+    public static void commitPrimaryForces(Campaign campaign, AtBContract contract, StratconScenario scenario, StratconTrackState trackState) {\n+        // order of operations is important here, we need a valid scenario ID prior to adding the scenario to the track.\n+        campaign.addScenario(scenario.getBackingScenario(), contract);\n+        scenario.setBackingScenarioID(scenario.getBackingScenario().getId());\n+        trackState.addScenario(scenario);\n+        \n+        // set up dates for the scenario if doesn't have them already\n+        if(scenario.getDeploymentDate() == null) {\n+            scenario.setDeploymentDate(campaign.getLocalDate());\n+        }\n+        \n+        if(scenario.getActionDate() == null) {\n+            scenario.setActionDate(campaign.getLocalDate());\n+        }\n+        \n+        if(scenario.getReturnDate() == null) {\n+            scenario.setReturnDate(campaign.getLocalDate().plusDays(trackState.getDeploymentTime()));\n+        }\n+        \n+        // set the # of rerolls based on the actual lance assigned.\n+        int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+        scenario.getBackingScenario().setRerolls(tactics);\n+        // The number of defensive points available to a force entering a scenario is\n+        // 2 x tactics. By default, those points are spent on conventional minefields.\n+        if (commanderLanceHasDefensiveAssignment(scenario.getBackingScenario(), campaign)) {\n+            scenario.setNumDefensivePoints(tactics * 2);\n+            scenario.updateMinefieldCount(Minefield.TYPE_CONVENTIONAL, tactics * 2);\n+        }\n+        \n+        for (int forceID : scenario.getPrimaryPlayerForceIDs()) {\n+            Force force = campaign.getForce(forceID);\n+            force.clearScenarioIds(campaign, true);\n+            force.setScenarioId(scenario.getBackingScenarioID());\n+        }\n+        \n+        scenario.commitPrimaryForces(campaign, contract);\n+    }\n+    \n+    /**\n+     * Utility method to determine if the current scenario's force commander\n+     * is on defence \n+     */\n+    private static boolean commanderLanceHasDefensiveAssignment(AtBDynamicScenario scenario, Campaign campaign) {\n+        Unit commanderUnit = scenario.getLanceCommander(campaign).getUnit();\n+        Lance lance = campaign.getLances().get(commanderUnit.getForceId());\n+        \n+        if ((lance != null) && (lance.getRole() == AtBLanceRole.DEFENCE)) {\n+            return true;\n+        }\n+        \n+        return false;\n+    }\n+    \n+    /**\n+     * A hackish worker function that takes the given list of force IDs and\n+     * separates it into three sets;\n+     * one of forces that can be \"primary\" on a ground map\n+     * one of forces that can be \"primary\" on an atmospheric map\n+     * one of forces that can be \"primary\" in a space map\n+     * @param forceIDs List of force IDs to check\n+     * @return Sorted hash map\n+     */\n+    private static Map<MapLocation, List<Integer>> sortForcesByMapType(List<Integer> forceIDs, Campaign campaign) {\n+        Map<MapLocation, List<Integer>> retVal = new HashMap<>();\n+        \n+        retVal.put(MapLocation.AllGroundTerrain, new ArrayList<>());\n+        retVal.put(MapLocation.LowAtmosphere, new ArrayList<>());\n+        retVal.put(MapLocation.Space, new ArrayList<>());\n+        \n+        for(int forceID : forceIDs) {\n+            switch(campaign.getForce(forceID).getPrimaryUnitType(campaign)) {\n+            case UnitType.BATTLE_ARMOR:\n+            case UnitType.INFANTRY:\n+            case UnitType.MEK:\n+            case UnitType.TANK:\n+            case UnitType.PROTOMEK:\n+            case UnitType.VTOL:\n+                retVal.get(MapLocation.AllGroundTerrain).add(forceID);\n+                break;\n+            case UnitType.AERO:\n+                retVal.get(MapLocation.Space).add(forceID);\n+                // intentional fallthrough here, ASFs can go to atmospheric maps too\n+            case UnitType.CONV_FIGHTER:\n+                retVal.get(MapLocation.LowAtmosphere).add(forceID);\n+                break;\n+            }\n+        }\n+        \n+        \n+        return retVal;\n+    }\n+    \n+    /**\n+     * Determine whether the user should be nagged about unresolved scenarios on AtB Stratcon tracks.\n+     * @param campaign Campaign to check.\n+     * @return An informative string containing the reasons the user was nagged.\n+     */\n+    public static String nagUnresolvedContacts(Campaign campaign) {\n+        StringBuilder sb = new StringBuilder();\n+        \n+        // check every track attached to an active contract for unresolved scenarios\n+        // to which the player must deploy forces today\n+        for(Contract contract : campaign.getActiveContracts()) {\n+            if(contract instanceof AtBContract) {\n+                for(StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    for(StratconScenario scenario : track.getScenarios().values()) {\n+                        if(scenario.getCurrentState() == ScenarioState.UNRESOLVED &&\n+                                campaign.getLocalDate().equals(scenario.getDeploymentDate())) {\n+                            // \"scenario name, track name\"\n+                            sb.append(String.format(\"%s, %s\\n\", scenario.getName(), track.getDisplayableName()));\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        \n+        return sb.toString();\n+    }\n+    \n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track.\n+     * Also registers it with the track and campaign.\n+     */\n+    private static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track, \n+            int forceID, StratconCoords coords) {\n+        int unitType = campaign.getForce(forceID).getPrimaryUnitType(campaign);\n+        ScenarioTemplate template = StratconScenarioFactory.getRandomScenario(unitType);\n+        // useful for debugging specific scenario types\n+        //ScenarioTemplate template = StratconScenarioFactory.getSpecificScenario(\"Hostile Facility.xml\");\n+        \n+        return generateScenario(campaign, contract, track, forceID, coords, template);\n+    }\n+    \n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track,\n+     * using the given template. Also registers it with the track and campaign.\n+     */\n+    static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track, \n+            int forceID, StratconCoords coords, ScenarioTemplate template) {\n+        StratconScenario scenario = new StratconScenario();\n+        scenario.setBackingScenario(AtBDynamicScenarioFactory.initializeScenarioFromTemplate(template, contract, campaign));\n+        scenario.setCoords(coords);\n+        \n+        // do an appropriate allied force if the contract calls for it\n+        // do any attached or integrated units\n+        setAlliedForceModifier(scenario, contract);\n+        setAttachedUnitsModifier(scenario, contract);\n+        applyFacilityModifiers(scenario, track, coords);\n+        applyGlobalModifiers(scenario, contract.getStratconCampaignState());\n+        \n+        if((contract.getCommandRights() == AtBContract.COM_HOUSE) ||\n+                (contract.getCommandRights() == AtBContract.COM_INTEGRATED)) {\n+            scenario.setRequiredScenario(true);\n+        }\n+        \n+        AtBDynamicScenarioFactory.setScenarioModifiers(scenario.getBackingScenario());\n+        scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+        setScenarioDates(track, campaign, scenario);\n+        \n+        // register the scenario with the campaign and the track it's generated on\n+        if (forceID > Force.FORCE_NONE) {\n+            scenario.addPrimaryForce(forceID);\n+        }\n+        \n+        return scenario;\n+    }\n+    \n+    /**\n+     * Apply global scenario modifiers from campaign state to given scenario.\n+     */\n+    private static void applyGlobalModifiers(StratconScenario scenario, StratconCampaignState campaignState) {\n+        for (String modifierName : campaignState.getGlobalScenarioModifiers()) {\n+            AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierName);\n+            \n+            if (modifier == null) {\n+                MekHQ.getLogger().error(String.format(\"Modifier %s not found; ignoring\", modifierName));\n+                continue;\n+            }\n+            \n+            scenario.getBackingScenario().addScenarioModifier(modifier);\n+        }\n+    }\n+    \n+    /**\n+     * Applies scenario modifiers from the current track to the given scenario.\n+     * @param scenario\n+     * @param track\n+     */\n+    private static void applyFacilityModifiers(StratconScenario scenario, StratconTrackState track, StratconCoords coords) {\n+        // loop through all the facilities on the track\n+        // if a facility has been revealed, then it has a 100% chance to apply its effect\n+        // if a facility has not been revealed, then it has a x% chance to apply its effect\n+        // if a facility is on the the scenario coordinates the it applies the local effects\n+        for (StratconCoords facilityCoords : track.getFacilities().keySet()) {\n+            boolean scenarioAtFacility = facilityCoords.equals(coords);\n+            StratconFacility facility = track.getFacilities().get(facilityCoords);\n+            List<String> modifierIDs = new ArrayList<>();\n+            \n+            if (scenarioAtFacility) {\n+                modifierIDs = facility.getLocalModifiers();\n+            } else if (facility.isVisible() || (Compute.randomInt(100) < facility.getAggroRating())) {", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQwNjU1MQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593406551", "bodyText": "Usually I think ternaries impair readability, but in this case with how long these lines are, consider making these ternaries on airBattle ? X : Y", "author": "sixlettervariables", "createdAt": "2021-03-12T19:40:39Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1080 @@\n+package mekhq.campaign.stratcon;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import megamek.common.Compute;\n+import megamek.common.Minefield;\n+import megamek.common.UnitType;\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.ResolveScenarioTracker;\n+import mekhq.campaign.againstTheBot.enums.AtBLanceRole;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.force.Lance;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier.EventTiming;\n+import mekhq.campaign.mission.atb.AtBScenarioModifierApplicator;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.unit.Unit;\n+\n+/**\n+ * This class contains \"rules\" logic for the AtB-Stratcon state\n+ * @author NickAragua\n+ *\n+ */\n+public class StratconRulesManager {\n+    public enum ReinforcementEligibilityType {\n+        None,\n+        ChainedScenario,\n+        SupportPoint,\n+        FightLance\n+    }\n+    \n+    /**\n+     * This function potentially generates non-player-initiated scenarios for the given track.\n+     * @param campaign\n+     * @param contract\n+     * @param track\n+     */\n+    public static void generateScenariosForTrack(Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // maps scenarios to force IDs\n+        List<StratconScenario> generatedScenarios = new ArrayList<>(); \n+        boolean autoAssignLances = contract.getCommandRights() == AtBContract.COM_INTEGRATED;\n+        \n+        // get this list just so we have it available\n+        List<Integer> availableForceIDs = getAvailableForceIDs(campaign);\n+        Map<MapLocation, List<Integer>> sortedAvailableForceIDs = sortForcesByMapType(availableForceIDs, campaign);\n+        \n+        // make X rolls, where X is the number of required lances for the track\n+        // that's the chance to spawn a scenario.\n+        // if a scenario occurs, then we pick a random non-deployed lance and use it to drive the opfor generation later\n+        // once we've determined that scenarios occur, we loop through the ones that we generated\n+        // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all \n+        for(int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            // if we haven't already used all the player forces and are required to randomly generate a scenario\n+            if((availableForceIDs.size() > 0) &&\n+                    (Compute.randomInt(100) <= track.getScenarioOdds())) {\n+                // pick random coordinates and force to drive the scenario\n+                int x = Compute.randomInt(track.getWidth());\n+                int y = Compute.randomInt(track.getHeight());                \n+                \n+                StratconCoords scenarioCoords = new StratconCoords(x, y);\n+                \n+                int randomForceIndex = Compute.randomInt(availableForceIDs.size());\n+                int randomForceID = availableForceIDs.get(randomForceIndex);\n+                \n+                // remove the force from the available lists so we don't designate it as primary twice\n+                availableForceIDs.remove(randomForceIndex); \n+                \n+                // we want to remove the actual int with the value, not the value at the index\n+                sortedAvailableForceIDs.get(MapLocation.AllGroundTerrain).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.LowAtmosphere).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.Space).remove((Integer) randomForceID);\n+                \n+                // two scenarios on the same coordinates wind up increasing in size\n+                if(track.getScenarios().containsKey(scenarioCoords)) {\n+                    track.getScenarios().get(scenarioCoords).incrementRequiredPlayerLances();\n+                    assignAppropriateExtraForceToScenario(track.getScenarios().get(scenarioCoords), sortedAvailableForceIDs, campaign);\n+                    continue;\n+                }\n+                \n+                StratconScenario scenario = setupScenario(scenarioCoords, randomForceID, campaign, contract, track);\n+                generatedScenarios.add(scenario);\n+                \n+                // if we're auto-assigning lances, deploy the force to the track as well\n+                if(autoAssignLances) {\n+                    processForceDeployment(scenarioCoords, randomForceID, campaign, track);\n+                }\n+            }\n+        }\n+        \n+        // if under liaison command, pick a random scenario from the ones generated\n+        // to set as required and attach liaison\n+        if(contract.getCommandRights() == AtBContract.COM_LIAISON) {\n+            int scenarioIndex = Compute.randomInt(generatedScenarios.size() - 1);\n+            generatedScenarios.get(scenarioIndex).setRequiredScenario(true);\n+            setAttachedUnitsModifier(generatedScenarios.get(scenarioIndex), contract);\n+        }\n+        \n+        // now, we loop through all the scenarios we set up\n+        // and generate the opfors / events / etc\n+        // if not auto-assigning lances, we then back out the lance assignments.\n+        for(StratconScenario scenario : generatedScenarios) {\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            \n+            if(!autoAssignLances) {\n+                for(int forceID : scenario.getPrimaryPlayerForceIDs()) {\n+                    scenario.getBackingScenario().removeForce(forceID);\n+                }\n+                \n+                scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                track.addScenario(scenario);\n+            } else {\n+                commitPrimaryForces(campaign, contract, scenario, track);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Deploys a force to the given coordinates on the given track as a result of explicit player action.\n+     */\n+    public static void deployForceToCoords(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // the following things should happen:\n+        // 1. call to \"process force deployment\", which reveals fog of war in or around the coords, depending on force role\n+        // 2. if coords are a hostile facility, we get a facility mission\n+        // 3. if coords are empty, we *may* get a mission\n+        \n+        processForceDeployment(coords, forceID, campaign, track);\n+        \n+        // don't create a scenario on top of allied facilities\n+        StratconFacility facility = track.getFacility(coords);\n+        boolean isNonAlliedFacility = (facility != null) && (facility.getOwner() != ForceAlignment.Allied);\n+        boolean spawnScenario = (facility == null) && (Compute.randomInt(100) <= track.getScenarioOdds());\n+\n+        if(isNonAlliedFacility || spawnScenario) {\n+            StratconScenario scenario = setupScenario(coords, forceID, campaign, contract, track);\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            commitPrimaryForces(campaign, contract, scenario, track);\n+        }\n+    }\n+    \n+    /**\n+     * Logic to set up a scenario\n+     */\n+    private static StratconScenario setupScenario(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        StratconScenario scenario = null;\n+        \n+        if(track.getFacilities().containsKey(coords)) {\n+            StratconFacility facility = track.getFacility(coords);\n+            boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+            ScenarioTemplate template = StratconScenarioFactory.getFacilityScenario(alliedFacility);\n+            scenario = generateScenario(campaign, contract, track, forceID, coords, template);\n+            setupFacilityScenario(scenario, track, coords, facility);\n+        } else {\n+            scenario = generateScenario(campaign, contract, track, forceID, coords);\n+            \n+            // we may generate a facility scenario randomly - if so, do the facility-related stuff\n+            // and add a new facility to the track\n+            if(scenario.getBackingScenario().getTemplate().isFacilityScenario()) {\n+                StratconFacility facility = scenario.getBackingScenario().getTemplate().isHostileFacility() ?\n+                        StratconFacilityFactory.getRandomHostileFacility() : StratconFacilityFactory.getRandomAlliedFacility();\n+                facility.setVisible(true);\n+                track.addFacility(coords, facility);\n+                setupFacilityScenario(scenario, track, coords, facility);\n+            }\n+        }\n+        \n+        return scenario;\n+    }\n+    \n+    /**\n+     * carries out tasks relevant to facility scenarios\n+     */\n+    private static void setupFacilityScenario(StratconScenario scenario, StratconTrackState track, StratconCoords coords, StratconFacility facility) {\n+        // this includes:\n+        // for hostile facilities\n+        // - add a destroy objective (always the option to level the facility)\n+        // - add a capture objective (always the option to capture the facility)\n+        // - if so indicated by parameter, roll a random hostile facility objective and add it if not capture/destroy\n+        // for allied facilities\n+        // - add a defend objective (always the option to defend the facility)\n+        // - if so indicated by parameter, roll a random allied facility objective and add it if not defend\n+        AtBScenarioModifier objectiveModifier = null;\n+        boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+        \n+        if(alliedFacility) {\n+            objectiveModifier = AtBScenarioModifier.getRandomAlliedFacilityModifier();\n+        } else {            \n+            objectiveModifier = AtBScenarioModifier.getRandomHostileFacilityModifier();\n+        }\n+        \n+        if(objectiveModifier != null) {\n+            scenario.getBackingScenario().addScenarioModifier(objectiveModifier);\n+            scenario.getBackingScenario().setName(String.format(\"%s - %s - %s\", \n+                    facility.getFacilityType(), alliedFacility ? \"Allied\" : \"Hostile\", objectiveModifier.getModifierName()));\n+        }\n+        \n+        // add the \"fixed\" hostile facility modifiers after the primary ones\n+        if(!alliedFacility) {\n+            for(AtBScenarioModifier modifier : AtBScenarioModifier.getRequiredHostileFacilityModifiers()) {\n+                if(!scenario.getBackingScenario().alreadyHasModifier(modifier)) {\n+                    scenario.getBackingScenario().addScenarioModifier(modifier);\n+                }\n+            }\n+        }\n+    }\n+    \n+    private static void processFacilityEffects(StratconTrackState track) {\n+        // todo: these are \"weekly\"? effects that a stratcon facility has on the campaign/track state\n+        // currrently, that's \n+        // supply depot - allied - +1 sp\n+        // supply depot - hostile - +5% BV budget to all scenarios on track (shared modifier, so should be implemented there)\n+        // data center - allied - +1% star league cache contract (don't implement yet, but...)\n+        // data center - hostile - +5% scenario odds in track\n+        // industrial center - allied - all scenarios here have THIS IS COMING OUT OF YOUR PAYCHECK modifier\n+        // orbital defense - allied - sets 'no hostile aircraft' flag for track\n+        // orbital defense - hostile - sets 'no allied aircraft' flag for track\n+        // early warning system - allied - sets 'intercept allied base attacks' flag for track\n+        // early warning system - hostile - sets 'intercept hostile base attacks' flag for track\n+    }\n+    \n+    /**\n+     * Process the deployment of a force to the given coordinates on the given track.\n+     */\n+    public static void processForceDeployment(StratconCoords coords, int forceID, Campaign campaign, StratconTrackState track) {\n+        track.getRevealedCoords().add(coords);\n+        StratconFacility facility = track.getFacility(coords);\n+        if(facility != null) {\n+            facility.setVisible(true);\n+        }\n+        \n+        if(campaign.getLances().get(forceID).getRole() == AtBLanceRole.SCOUTING) {\n+            for(int direction = 0; direction < 6; direction++) {\n+                StratconCoords checkCoords = coords.translate(direction);\n+                \n+                facility = track.getFacility(checkCoords);\n+                if(facility != null) {\n+                    facility.setVisible(true);\n+                }\n+                \n+                track.getRevealedCoords().add(coords.translate(direction));\n+            }\n+        }\n+        \n+        // the force may be located in other places on the track - clear it out\n+        track.unassignForce(forceID);\n+        track.assignForce(forceID, coords, campaign.getLocalDate());\n+    }\n+    \n+    /**\n+     * Worker function that processes the effects of deploying a reinforcement force to a scenario\n+     */\n+    public static boolean processReinforcementDeployment(ReinforcementEligibilityType reinforcementType, \n+            StratconCampaignState campaignState, StratconScenario scenario, Campaign campaign) {\n+        // if the force is already deployed to the track, we're done\n+        // if the force is a fight lance or we're using a support point\n+        // if there is an SP to burn, burn it and we're done\n+        // if there is a VP to burn, burn it and we're done\n+        // now, roll 2d6 + lance commander tactics\n+        // 9+ = deploy\n+        // 6+ = deploy, if lance != fight, track scenario odds up\n+        // 2+ = apply negative modifier to scenario\n+        \n+        if ((reinforcementType == ReinforcementEligibilityType.FightLance) ||\n+                (reinforcementType == ReinforcementEligibilityType.SupportPoint)) {\n+            \n+            if (campaignState.getSupportPoints() > 0) {\n+                campaignState.useSupportPoint();\n+                return true;\n+            } else if (campaignState.getVictoryPoints() > 0) {\n+                campaignState.updateVictoryPoints(-1);\n+                return true;\n+            }\n+            \n+            int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+            int roll = 7;//Compute.d6(2);\n+            int result = roll + tactics;\n+\n+            String reportStatus = String.format(\"Attempting to reinforce scenario %s without SP/VP, roll 2d6 + %d: %d\",\n+                    scenario.getName(), tactics, result);\n+            \n+            // fail to reinforce\n+            if (result < 6) {\n+                reportStatus += \" - reinforcement attempt failed.\";\n+                campaign.addReport(reportStatus);\n+                return false;\n+            // succeed but get an extra negative event added to the scenario\n+            } else if ((result < 9) && (reinforcementType != ReinforcementEligibilityType.FightLance)) {\n+                MapLocation mapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+                AtBScenarioModifier scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+                \n+                // keep rolling until we get an applicable one\n+                // todo: have the AtBScenarioModifier sort these out instead for performance?\n+                while (scenarioModifier.getEventTiming() != EventTiming.PostForceGeneration) {\n+                    scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+                }\n+                \n+                scenarioModifier.processModifier(scenario.getBackingScenario(), campaign, EventTiming.PostForceGeneration);\n+                \n+                reportStatus += String.format(\" - reinforcement attempt succeeded; extra negative modifier (%s) applied to scenario.\",\n+                        scenarioModifier.getModifierName());\n+                campaign.addReport(reportStatus);\n+                return true;\n+            // succeed without reservation\n+            } else {\n+                reportStatus += \" - reinforcement attempt succeeded;\";\n+                campaign.addReport(reportStatus);\n+                return true;\n+            }\n+        } else if (reinforcementType == ReinforcementEligibilityType.None) {\n+            return false;\n+        }\n+        \n+        return true;\n+    }\n+    \n+    /**\n+     * Assigns a force to the scenario such that the majority of the force can be deployed\n+     * @param scenario\n+     * @param sortedAvailableForceIDs\n+     */\n+    private static void assignAppropriateExtraForceToScenario(StratconScenario scenario, \n+            Map<MapLocation, List<Integer>> sortedAvailableForceIDs, Campaign campaign) {\n+        // the goal of this function is to avoid assigning ground units to air battles\n+        // and ground units/conventional fighters to space battle\n+        \n+        List<MapLocation> mapLocations = new ArrayList<>();\n+        mapLocations.add(MapLocation.Space); // can always add ASFs\n+        \n+        MapLocation scenarioMapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+        \n+        if(scenarioMapLocation == MapLocation.LowAtmosphere) {\n+            mapLocations.add(MapLocation.LowAtmosphere); // can add conventional fighters to ground or low atmo battles\n+        }\n+        \n+        if((scenarioMapLocation == MapLocation.AllGroundTerrain) || \n+                (scenarioMapLocation == MapLocation.SpecificGroundTerrain)) {\n+            mapLocations.add(MapLocation.AllGroundTerrain); // can only add ground units to ground battles\n+        }\n+        \n+        MapLocation selectedLocation = mapLocations.get(Compute.randomInt(mapLocations.size()));\n+        List<Integer> forceIDs = sortedAvailableForceIDs.get(selectedLocation);\n+        int forceIndex = Compute.randomInt(forceIDs.size());\n+        int forceID = forceIDs.get(forceIndex);\n+        forceIDs.remove(forceIndex);\n+        \n+        scenario.addPrimaryForce(forceID);\n+    }\n+    \n+    /**\n+     * Worker function that \"locks in\" a scenario - \n+     * Adds it to the campaign so it's visible in the briefing room,\n+     * adds it to the track\n+     * \n+     */\n+    public static void commitPrimaryForces(Campaign campaign, AtBContract contract, StratconScenario scenario, StratconTrackState trackState) {\n+        // order of operations is important here, we need a valid scenario ID prior to adding the scenario to the track.\n+        campaign.addScenario(scenario.getBackingScenario(), contract);\n+        scenario.setBackingScenarioID(scenario.getBackingScenario().getId());\n+        trackState.addScenario(scenario);\n+        \n+        // set up dates for the scenario if doesn't have them already\n+        if(scenario.getDeploymentDate() == null) {\n+            scenario.setDeploymentDate(campaign.getLocalDate());\n+        }\n+        \n+        if(scenario.getActionDate() == null) {\n+            scenario.setActionDate(campaign.getLocalDate());\n+        }\n+        \n+        if(scenario.getReturnDate() == null) {\n+            scenario.setReturnDate(campaign.getLocalDate().plusDays(trackState.getDeploymentTime()));\n+        }\n+        \n+        // set the # of rerolls based on the actual lance assigned.\n+        int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+        scenario.getBackingScenario().setRerolls(tactics);\n+        // The number of defensive points available to a force entering a scenario is\n+        // 2 x tactics. By default, those points are spent on conventional minefields.\n+        if (commanderLanceHasDefensiveAssignment(scenario.getBackingScenario(), campaign)) {\n+            scenario.setNumDefensivePoints(tactics * 2);\n+            scenario.updateMinefieldCount(Minefield.TYPE_CONVENTIONAL, tactics * 2);\n+        }\n+        \n+        for (int forceID : scenario.getPrimaryPlayerForceIDs()) {\n+            Force force = campaign.getForce(forceID);\n+            force.clearScenarioIds(campaign, true);\n+            force.setScenarioId(scenario.getBackingScenarioID());\n+        }\n+        \n+        scenario.commitPrimaryForces(campaign, contract);\n+    }\n+    \n+    /**\n+     * Utility method to determine if the current scenario's force commander\n+     * is on defence \n+     */\n+    private static boolean commanderLanceHasDefensiveAssignment(AtBDynamicScenario scenario, Campaign campaign) {\n+        Unit commanderUnit = scenario.getLanceCommander(campaign).getUnit();\n+        Lance lance = campaign.getLances().get(commanderUnit.getForceId());\n+        \n+        if ((lance != null) && (lance.getRole() == AtBLanceRole.DEFENCE)) {\n+            return true;\n+        }\n+        \n+        return false;\n+    }\n+    \n+    /**\n+     * A hackish worker function that takes the given list of force IDs and\n+     * separates it into three sets;\n+     * one of forces that can be \"primary\" on a ground map\n+     * one of forces that can be \"primary\" on an atmospheric map\n+     * one of forces that can be \"primary\" in a space map\n+     * @param forceIDs List of force IDs to check\n+     * @return Sorted hash map\n+     */\n+    private static Map<MapLocation, List<Integer>> sortForcesByMapType(List<Integer> forceIDs, Campaign campaign) {\n+        Map<MapLocation, List<Integer>> retVal = new HashMap<>();\n+        \n+        retVal.put(MapLocation.AllGroundTerrain, new ArrayList<>());\n+        retVal.put(MapLocation.LowAtmosphere, new ArrayList<>());\n+        retVal.put(MapLocation.Space, new ArrayList<>());\n+        \n+        for(int forceID : forceIDs) {\n+            switch(campaign.getForce(forceID).getPrimaryUnitType(campaign)) {\n+            case UnitType.BATTLE_ARMOR:\n+            case UnitType.INFANTRY:\n+            case UnitType.MEK:\n+            case UnitType.TANK:\n+            case UnitType.PROTOMEK:\n+            case UnitType.VTOL:\n+                retVal.get(MapLocation.AllGroundTerrain).add(forceID);\n+                break;\n+            case UnitType.AERO:\n+                retVal.get(MapLocation.Space).add(forceID);\n+                // intentional fallthrough here, ASFs can go to atmospheric maps too\n+            case UnitType.CONV_FIGHTER:\n+                retVal.get(MapLocation.LowAtmosphere).add(forceID);\n+                break;\n+            }\n+        }\n+        \n+        \n+        return retVal;\n+    }\n+    \n+    /**\n+     * Determine whether the user should be nagged about unresolved scenarios on AtB Stratcon tracks.\n+     * @param campaign Campaign to check.\n+     * @return An informative string containing the reasons the user was nagged.\n+     */\n+    public static String nagUnresolvedContacts(Campaign campaign) {\n+        StringBuilder sb = new StringBuilder();\n+        \n+        // check every track attached to an active contract for unresolved scenarios\n+        // to which the player must deploy forces today\n+        for(Contract contract : campaign.getActiveContracts()) {\n+            if(contract instanceof AtBContract) {\n+                for(StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    for(StratconScenario scenario : track.getScenarios().values()) {\n+                        if(scenario.getCurrentState() == ScenarioState.UNRESOLVED &&\n+                                campaign.getLocalDate().equals(scenario.getDeploymentDate())) {\n+                            // \"scenario name, track name\"\n+                            sb.append(String.format(\"%s, %s\\n\", scenario.getName(), track.getDisplayableName()));\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        \n+        return sb.toString();\n+    }\n+    \n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track.\n+     * Also registers it with the track and campaign.\n+     */\n+    private static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track, \n+            int forceID, StratconCoords coords) {\n+        int unitType = campaign.getForce(forceID).getPrimaryUnitType(campaign);\n+        ScenarioTemplate template = StratconScenarioFactory.getRandomScenario(unitType);\n+        // useful for debugging specific scenario types\n+        //ScenarioTemplate template = StratconScenarioFactory.getSpecificScenario(\"Hostile Facility.xml\");\n+        \n+        return generateScenario(campaign, contract, track, forceID, coords, template);\n+    }\n+    \n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track,\n+     * using the given template. Also registers it with the track and campaign.\n+     */\n+    static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track, \n+            int forceID, StratconCoords coords, ScenarioTemplate template) {\n+        StratconScenario scenario = new StratconScenario();\n+        scenario.setBackingScenario(AtBDynamicScenarioFactory.initializeScenarioFromTemplate(template, contract, campaign));\n+        scenario.setCoords(coords);\n+        \n+        // do an appropriate allied force if the contract calls for it\n+        // do any attached or integrated units\n+        setAlliedForceModifier(scenario, contract);\n+        setAttachedUnitsModifier(scenario, contract);\n+        applyFacilityModifiers(scenario, track, coords);\n+        applyGlobalModifiers(scenario, contract.getStratconCampaignState());\n+        \n+        if((contract.getCommandRights() == AtBContract.COM_HOUSE) ||\n+                (contract.getCommandRights() == AtBContract.COM_INTEGRATED)) {\n+            scenario.setRequiredScenario(true);\n+        }\n+        \n+        AtBDynamicScenarioFactory.setScenarioModifiers(scenario.getBackingScenario());\n+        scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+        setScenarioDates(track, campaign, scenario);\n+        \n+        // register the scenario with the campaign and the track it's generated on\n+        if (forceID > Force.FORCE_NONE) {\n+            scenario.addPrimaryForce(forceID);\n+        }\n+        \n+        return scenario;\n+    }\n+    \n+    /**\n+     * Apply global scenario modifiers from campaign state to given scenario.\n+     */\n+    private static void applyGlobalModifiers(StratconScenario scenario, StratconCampaignState campaignState) {\n+        for (String modifierName : campaignState.getGlobalScenarioModifiers()) {\n+            AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierName);\n+            \n+            if (modifier == null) {\n+                MekHQ.getLogger().error(String.format(\"Modifier %s not found; ignoring\", modifierName));\n+                continue;\n+            }\n+            \n+            scenario.getBackingScenario().addScenarioModifier(modifier);\n+        }\n+    }\n+    \n+    /**\n+     * Applies scenario modifiers from the current track to the given scenario.\n+     * @param scenario\n+     * @param track\n+     */\n+    private static void applyFacilityModifiers(StratconScenario scenario, StratconTrackState track, StratconCoords coords) {\n+        // loop through all the facilities on the track\n+        // if a facility has been revealed, then it has a 100% chance to apply its effect\n+        // if a facility has not been revealed, then it has a x% chance to apply its effect\n+        // if a facility is on the the scenario coordinates the it applies the local effects\n+        for (StratconCoords facilityCoords : track.getFacilities().keySet()) {\n+            boolean scenarioAtFacility = facilityCoords.equals(coords);\n+            StratconFacility facility = track.getFacilities().get(facilityCoords);\n+            List<String> modifierIDs = new ArrayList<>();\n+            \n+            if (scenarioAtFacility) {\n+                modifierIDs = facility.getLocalModifiers();\n+            } else if (facility.isVisible() || (Compute.randomInt(100) < facility.getAggroRating())) {\n+                modifierIDs = facility.getSharedModifiers();\n+            }\n+            \n+            for (String modifierID : modifierIDs) {\n+                AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierID);\n+                if(modifier == null) {\n+                    MekHQ.getLogger().error(String.format(\"Modifier %s not found for facility %s\", modifierID, facility.getFormattedDisplayableName()));\n+                    continue;\n+                }\n+                \n+                scenario.getBackingScenario().addScenarioModifier(modifier);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Set up the appropriate primary allied force modifier, if any \n+     * @param contract The scenario's contract.\n+     */\n+    private static void setAlliedForceModifier(StratconScenario scenario, AtBContract contract) {\n+        int alliedUnitOdds = 0;\n+        \n+        // first, we determine the odds of having an allied unit present\n+        // TODO: move this override out to the contract definition\n+        if (contract.getMissionType() == AtBContract.MT_RELIEFDUTY) {\n+            alliedUnitOdds = 50;\n+        } else {\n+            switch(contract.getCommandRights()) {\n+            case AtBContract.COM_INTEGRATED:\n+                alliedUnitOdds = 50;\n+                break;\n+            case AtBContract.COM_HOUSE:\n+                alliedUnitOdds = 30;\n+                break;\n+            case AtBContract.COM_LIAISON:\n+                alliedUnitOdds = 10;\n+                break;\n+            }\n+        }\n+        \n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+        \n+        // if an allied unit is present, then we want to make sure that it's ground units\n+        // for ground battles\n+        if (Compute.randomInt(100) <= alliedUnitOdds) {\n+            if((backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+               (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space)) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_ALLIED_AIR_UNITS));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_ALLIED_GROUND_UNITS));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set the 'attached' units modifier for the current scenario (integrated, house, liaison),\n+     * and make sure we're not deploying ground units to an air scenario\n+     * @param contract The scenario's contract\n+     */\n+    public static void setAttachedUnitsModifier(StratconScenario scenario, AtBContract contract) {\n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+        boolean airBattle = (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+                (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space);\n+        \n+        // if we're on cadre duty, we're getting three trainees, period\n+        if(contract.getMissionType() == AtBContract.MT_CADREDUTY) {\n+            if(airBattle) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_TRAINEES_AIR));                \n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_TRAINEES_GROUND));\n+            }\n+            return;\n+        }\n+        \n+        // if we're under non-independent command rights, a supervisor may come along\n+        switch(contract.getCommandRights()) {\n+        case AtBContract.COM_INTEGRATED:\n+            if(airBattle) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_INTEGRATED_UNITS_AIR));                \n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_INTEGRATED_UNITS_GROUND));\n+            }\n+            break;\n+        case AtBContract.COM_HOUSE:\n+            if(airBattle) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_HOUSE_CO_AIR));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_HOUSE_CO_GROUND));\n+            }            \n+            break;\n+        case AtBContract.COM_LIAISON:\n+            if(scenario.isRequiredScenario()) {\n+                if(airBattle) {\n+                    backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_LIAISON_AIR));\n+                } else {\n+                    backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_LIAISON_GROUND));\n+                } \n+            }\n+            break;\n+        }", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzU1NjA5MQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593556091", "bodyText": "Don't think that works without having an assignment on the left hand side.", "author": "NickAragua", "createdAt": "2021-03-13T04:06:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQwNjU1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQwNzMxMQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593407311", "bodyText": "Why would they be un-deployed but have a non-negative scenarioId?", "author": "sixlettervariables", "createdAt": "2021-03-12T19:42:06Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1080 @@\n+package mekhq.campaign.stratcon;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import megamek.common.Compute;\n+import megamek.common.Minefield;\n+import megamek.common.UnitType;\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.ResolveScenarioTracker;\n+import mekhq.campaign.againstTheBot.enums.AtBLanceRole;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.force.Lance;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier.EventTiming;\n+import mekhq.campaign.mission.atb.AtBScenarioModifierApplicator;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.unit.Unit;\n+\n+/**\n+ * This class contains \"rules\" logic for the AtB-Stratcon state\n+ * @author NickAragua\n+ *\n+ */\n+public class StratconRulesManager {\n+    public enum ReinforcementEligibilityType {\n+        None,\n+        ChainedScenario,\n+        SupportPoint,\n+        FightLance\n+    }\n+    \n+    /**\n+     * This function potentially generates non-player-initiated scenarios for the given track.\n+     * @param campaign\n+     * @param contract\n+     * @param track\n+     */\n+    public static void generateScenariosForTrack(Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // maps scenarios to force IDs\n+        List<StratconScenario> generatedScenarios = new ArrayList<>(); \n+        boolean autoAssignLances = contract.getCommandRights() == AtBContract.COM_INTEGRATED;\n+        \n+        // get this list just so we have it available\n+        List<Integer> availableForceIDs = getAvailableForceIDs(campaign);\n+        Map<MapLocation, List<Integer>> sortedAvailableForceIDs = sortForcesByMapType(availableForceIDs, campaign);\n+        \n+        // make X rolls, where X is the number of required lances for the track\n+        // that's the chance to spawn a scenario.\n+        // if a scenario occurs, then we pick a random non-deployed lance and use it to drive the opfor generation later\n+        // once we've determined that scenarios occur, we loop through the ones that we generated\n+        // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all \n+        for(int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            // if we haven't already used all the player forces and are required to randomly generate a scenario\n+            if((availableForceIDs.size() > 0) &&\n+                    (Compute.randomInt(100) <= track.getScenarioOdds())) {\n+                // pick random coordinates and force to drive the scenario\n+                int x = Compute.randomInt(track.getWidth());\n+                int y = Compute.randomInt(track.getHeight());                \n+                \n+                StratconCoords scenarioCoords = new StratconCoords(x, y);\n+                \n+                int randomForceIndex = Compute.randomInt(availableForceIDs.size());\n+                int randomForceID = availableForceIDs.get(randomForceIndex);\n+                \n+                // remove the force from the available lists so we don't designate it as primary twice\n+                availableForceIDs.remove(randomForceIndex); \n+                \n+                // we want to remove the actual int with the value, not the value at the index\n+                sortedAvailableForceIDs.get(MapLocation.AllGroundTerrain).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.LowAtmosphere).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.Space).remove((Integer) randomForceID);\n+                \n+                // two scenarios on the same coordinates wind up increasing in size\n+                if(track.getScenarios().containsKey(scenarioCoords)) {\n+                    track.getScenarios().get(scenarioCoords).incrementRequiredPlayerLances();\n+                    assignAppropriateExtraForceToScenario(track.getScenarios().get(scenarioCoords), sortedAvailableForceIDs, campaign);\n+                    continue;\n+                }\n+                \n+                StratconScenario scenario = setupScenario(scenarioCoords, randomForceID, campaign, contract, track);\n+                generatedScenarios.add(scenario);\n+                \n+                // if we're auto-assigning lances, deploy the force to the track as well\n+                if(autoAssignLances) {\n+                    processForceDeployment(scenarioCoords, randomForceID, campaign, track);\n+                }\n+            }\n+        }\n+        \n+        // if under liaison command, pick a random scenario from the ones generated\n+        // to set as required and attach liaison\n+        if(contract.getCommandRights() == AtBContract.COM_LIAISON) {\n+            int scenarioIndex = Compute.randomInt(generatedScenarios.size() - 1);\n+            generatedScenarios.get(scenarioIndex).setRequiredScenario(true);\n+            setAttachedUnitsModifier(generatedScenarios.get(scenarioIndex), contract);\n+        }\n+        \n+        // now, we loop through all the scenarios we set up\n+        // and generate the opfors / events / etc\n+        // if not auto-assigning lances, we then back out the lance assignments.\n+        for(StratconScenario scenario : generatedScenarios) {\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            \n+            if(!autoAssignLances) {\n+                for(int forceID : scenario.getPrimaryPlayerForceIDs()) {\n+                    scenario.getBackingScenario().removeForce(forceID);\n+                }\n+                \n+                scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                track.addScenario(scenario);\n+            } else {\n+                commitPrimaryForces(campaign, contract, scenario, track);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Deploys a force to the given coordinates on the given track as a result of explicit player action.\n+     */\n+    public static void deployForceToCoords(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // the following things should happen:\n+        // 1. call to \"process force deployment\", which reveals fog of war in or around the coords, depending on force role\n+        // 2. if coords are a hostile facility, we get a facility mission\n+        // 3. if coords are empty, we *may* get a mission\n+        \n+        processForceDeployment(coords, forceID, campaign, track);\n+        \n+        // don't create a scenario on top of allied facilities\n+        StratconFacility facility = track.getFacility(coords);\n+        boolean isNonAlliedFacility = (facility != null) && (facility.getOwner() != ForceAlignment.Allied);\n+        boolean spawnScenario = (facility == null) && (Compute.randomInt(100) <= track.getScenarioOdds());\n+\n+        if(isNonAlliedFacility || spawnScenario) {\n+            StratconScenario scenario = setupScenario(coords, forceID, campaign, contract, track);\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            commitPrimaryForces(campaign, contract, scenario, track);\n+        }\n+    }\n+    \n+    /**\n+     * Logic to set up a scenario\n+     */\n+    private static StratconScenario setupScenario(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        StratconScenario scenario = null;\n+        \n+        if(track.getFacilities().containsKey(coords)) {\n+            StratconFacility facility = track.getFacility(coords);\n+            boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+            ScenarioTemplate template = StratconScenarioFactory.getFacilityScenario(alliedFacility);\n+            scenario = generateScenario(campaign, contract, track, forceID, coords, template);\n+            setupFacilityScenario(scenario, track, coords, facility);\n+        } else {\n+            scenario = generateScenario(campaign, contract, track, forceID, coords);\n+            \n+            // we may generate a facility scenario randomly - if so, do the facility-related stuff\n+            // and add a new facility to the track\n+            if(scenario.getBackingScenario().getTemplate().isFacilityScenario()) {\n+                StratconFacility facility = scenario.getBackingScenario().getTemplate().isHostileFacility() ?\n+                        StratconFacilityFactory.getRandomHostileFacility() : StratconFacilityFactory.getRandomAlliedFacility();\n+                facility.setVisible(true);\n+                track.addFacility(coords, facility);\n+                setupFacilityScenario(scenario, track, coords, facility);\n+            }\n+        }\n+        \n+        return scenario;\n+    }\n+    \n+    /**\n+     * carries out tasks relevant to facility scenarios\n+     */\n+    private static void setupFacilityScenario(StratconScenario scenario, StratconTrackState track, StratconCoords coords, StratconFacility facility) {\n+        // this includes:\n+        // for hostile facilities\n+        // - add a destroy objective (always the option to level the facility)\n+        // - add a capture objective (always the option to capture the facility)\n+        // - if so indicated by parameter, roll a random hostile facility objective and add it if not capture/destroy\n+        // for allied facilities\n+        // - add a defend objective (always the option to defend the facility)\n+        // - if so indicated by parameter, roll a random allied facility objective and add it if not defend\n+        AtBScenarioModifier objectiveModifier = null;\n+        boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+        \n+        if(alliedFacility) {\n+            objectiveModifier = AtBScenarioModifier.getRandomAlliedFacilityModifier();\n+        } else {            \n+            objectiveModifier = AtBScenarioModifier.getRandomHostileFacilityModifier();\n+        }\n+        \n+        if(objectiveModifier != null) {\n+            scenario.getBackingScenario().addScenarioModifier(objectiveModifier);\n+            scenario.getBackingScenario().setName(String.format(\"%s - %s - %s\", \n+                    facility.getFacilityType(), alliedFacility ? \"Allied\" : \"Hostile\", objectiveModifier.getModifierName()));\n+        }\n+        \n+        // add the \"fixed\" hostile facility modifiers after the primary ones\n+        if(!alliedFacility) {\n+            for(AtBScenarioModifier modifier : AtBScenarioModifier.getRequiredHostileFacilityModifiers()) {\n+                if(!scenario.getBackingScenario().alreadyHasModifier(modifier)) {\n+                    scenario.getBackingScenario().addScenarioModifier(modifier);\n+                }\n+            }\n+        }\n+    }\n+    \n+    private static void processFacilityEffects(StratconTrackState track) {\n+        // todo: these are \"weekly\"? effects that a stratcon facility has on the campaign/track state\n+        // currrently, that's \n+        // supply depot - allied - +1 sp\n+        // supply depot - hostile - +5% BV budget to all scenarios on track (shared modifier, so should be implemented there)\n+        // data center - allied - +1% star league cache contract (don't implement yet, but...)\n+        // data center - hostile - +5% scenario odds in track\n+        // industrial center - allied - all scenarios here have THIS IS COMING OUT OF YOUR PAYCHECK modifier\n+        // orbital defense - allied - sets 'no hostile aircraft' flag for track\n+        // orbital defense - hostile - sets 'no allied aircraft' flag for track\n+        // early warning system - allied - sets 'intercept allied base attacks' flag for track\n+        // early warning system - hostile - sets 'intercept hostile base attacks' flag for track\n+    }\n+    \n+    /**\n+     * Process the deployment of a force to the given coordinates on the given track.\n+     */\n+    public static void processForceDeployment(StratconCoords coords, int forceID, Campaign campaign, StratconTrackState track) {\n+        track.getRevealedCoords().add(coords);\n+        StratconFacility facility = track.getFacility(coords);\n+        if(facility != null) {\n+            facility.setVisible(true);\n+        }\n+        \n+        if(campaign.getLances().get(forceID).getRole() == AtBLanceRole.SCOUTING) {\n+            for(int direction = 0; direction < 6; direction++) {\n+                StratconCoords checkCoords = coords.translate(direction);\n+                \n+                facility = track.getFacility(checkCoords);\n+                if(facility != null) {\n+                    facility.setVisible(true);\n+                }\n+                \n+                track.getRevealedCoords().add(coords.translate(direction));\n+            }\n+        }\n+        \n+        // the force may be located in other places on the track - clear it out\n+        track.unassignForce(forceID);\n+        track.assignForce(forceID, coords, campaign.getLocalDate());\n+    }\n+    \n+    /**\n+     * Worker function that processes the effects of deploying a reinforcement force to a scenario\n+     */\n+    public static boolean processReinforcementDeployment(ReinforcementEligibilityType reinforcementType, \n+            StratconCampaignState campaignState, StratconScenario scenario, Campaign campaign) {\n+        // if the force is already deployed to the track, we're done\n+        // if the force is a fight lance or we're using a support point\n+        // if there is an SP to burn, burn it and we're done\n+        // if there is a VP to burn, burn it and we're done\n+        // now, roll 2d6 + lance commander tactics\n+        // 9+ = deploy\n+        // 6+ = deploy, if lance != fight, track scenario odds up\n+        // 2+ = apply negative modifier to scenario\n+        \n+        if ((reinforcementType == ReinforcementEligibilityType.FightLance) ||\n+                (reinforcementType == ReinforcementEligibilityType.SupportPoint)) {\n+            \n+            if (campaignState.getSupportPoints() > 0) {\n+                campaignState.useSupportPoint();\n+                return true;\n+            } else if (campaignState.getVictoryPoints() > 0) {\n+                campaignState.updateVictoryPoints(-1);\n+                return true;\n+            }\n+            \n+            int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+            int roll = 7;//Compute.d6(2);\n+            int result = roll + tactics;\n+\n+            String reportStatus = String.format(\"Attempting to reinforce scenario %s without SP/VP, roll 2d6 + %d: %d\",\n+                    scenario.getName(), tactics, result);\n+            \n+            // fail to reinforce\n+            if (result < 6) {\n+                reportStatus += \" - reinforcement attempt failed.\";\n+                campaign.addReport(reportStatus);\n+                return false;\n+            // succeed but get an extra negative event added to the scenario\n+            } else if ((result < 9) && (reinforcementType != ReinforcementEligibilityType.FightLance)) {\n+                MapLocation mapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+                AtBScenarioModifier scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+                \n+                // keep rolling until we get an applicable one\n+                // todo: have the AtBScenarioModifier sort these out instead for performance?\n+                while (scenarioModifier.getEventTiming() != EventTiming.PostForceGeneration) {\n+                    scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+                }\n+                \n+                scenarioModifier.processModifier(scenario.getBackingScenario(), campaign, EventTiming.PostForceGeneration);\n+                \n+                reportStatus += String.format(\" - reinforcement attempt succeeded; extra negative modifier (%s) applied to scenario.\",\n+                        scenarioModifier.getModifierName());\n+                campaign.addReport(reportStatus);\n+                return true;\n+            // succeed without reservation\n+            } else {\n+                reportStatus += \" - reinforcement attempt succeeded;\";\n+                campaign.addReport(reportStatus);\n+                return true;\n+            }\n+        } else if (reinforcementType == ReinforcementEligibilityType.None) {\n+            return false;\n+        }\n+        \n+        return true;\n+    }\n+    \n+    /**\n+     * Assigns a force to the scenario such that the majority of the force can be deployed\n+     * @param scenario\n+     * @param sortedAvailableForceIDs\n+     */\n+    private static void assignAppropriateExtraForceToScenario(StratconScenario scenario, \n+            Map<MapLocation, List<Integer>> sortedAvailableForceIDs, Campaign campaign) {\n+        // the goal of this function is to avoid assigning ground units to air battles\n+        // and ground units/conventional fighters to space battle\n+        \n+        List<MapLocation> mapLocations = new ArrayList<>();\n+        mapLocations.add(MapLocation.Space); // can always add ASFs\n+        \n+        MapLocation scenarioMapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+        \n+        if(scenarioMapLocation == MapLocation.LowAtmosphere) {\n+            mapLocations.add(MapLocation.LowAtmosphere); // can add conventional fighters to ground or low atmo battles\n+        }\n+        \n+        if((scenarioMapLocation == MapLocation.AllGroundTerrain) || \n+                (scenarioMapLocation == MapLocation.SpecificGroundTerrain)) {\n+            mapLocations.add(MapLocation.AllGroundTerrain); // can only add ground units to ground battles\n+        }\n+        \n+        MapLocation selectedLocation = mapLocations.get(Compute.randomInt(mapLocations.size()));\n+        List<Integer> forceIDs = sortedAvailableForceIDs.get(selectedLocation);\n+        int forceIndex = Compute.randomInt(forceIDs.size());\n+        int forceID = forceIDs.get(forceIndex);\n+        forceIDs.remove(forceIndex);\n+        \n+        scenario.addPrimaryForce(forceID);\n+    }\n+    \n+    /**\n+     * Worker function that \"locks in\" a scenario - \n+     * Adds it to the campaign so it's visible in the briefing room,\n+     * adds it to the track\n+     * \n+     */\n+    public static void commitPrimaryForces(Campaign campaign, AtBContract contract, StratconScenario scenario, StratconTrackState trackState) {\n+        // order of operations is important here, we need a valid scenario ID prior to adding the scenario to the track.\n+        campaign.addScenario(scenario.getBackingScenario(), contract);\n+        scenario.setBackingScenarioID(scenario.getBackingScenario().getId());\n+        trackState.addScenario(scenario);\n+        \n+        // set up dates for the scenario if doesn't have them already\n+        if(scenario.getDeploymentDate() == null) {\n+            scenario.setDeploymentDate(campaign.getLocalDate());\n+        }\n+        \n+        if(scenario.getActionDate() == null) {\n+            scenario.setActionDate(campaign.getLocalDate());\n+        }\n+        \n+        if(scenario.getReturnDate() == null) {\n+            scenario.setReturnDate(campaign.getLocalDate().plusDays(trackState.getDeploymentTime()));\n+        }\n+        \n+        // set the # of rerolls based on the actual lance assigned.\n+        int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+        scenario.getBackingScenario().setRerolls(tactics);\n+        // The number of defensive points available to a force entering a scenario is\n+        // 2 x tactics. By default, those points are spent on conventional minefields.\n+        if (commanderLanceHasDefensiveAssignment(scenario.getBackingScenario(), campaign)) {\n+            scenario.setNumDefensivePoints(tactics * 2);\n+            scenario.updateMinefieldCount(Minefield.TYPE_CONVENTIONAL, tactics * 2);\n+        }\n+        \n+        for (int forceID : scenario.getPrimaryPlayerForceIDs()) {\n+            Force force = campaign.getForce(forceID);\n+            force.clearScenarioIds(campaign, true);\n+            force.setScenarioId(scenario.getBackingScenarioID());\n+        }\n+        \n+        scenario.commitPrimaryForces(campaign, contract);\n+    }\n+    \n+    /**\n+     * Utility method to determine if the current scenario's force commander\n+     * is on defence \n+     */\n+    private static boolean commanderLanceHasDefensiveAssignment(AtBDynamicScenario scenario, Campaign campaign) {\n+        Unit commanderUnit = scenario.getLanceCommander(campaign).getUnit();\n+        Lance lance = campaign.getLances().get(commanderUnit.getForceId());\n+        \n+        if ((lance != null) && (lance.getRole() == AtBLanceRole.DEFENCE)) {\n+            return true;\n+        }\n+        \n+        return false;\n+    }\n+    \n+    /**\n+     * A hackish worker function that takes the given list of force IDs and\n+     * separates it into three sets;\n+     * one of forces that can be \"primary\" on a ground map\n+     * one of forces that can be \"primary\" on an atmospheric map\n+     * one of forces that can be \"primary\" in a space map\n+     * @param forceIDs List of force IDs to check\n+     * @return Sorted hash map\n+     */\n+    private static Map<MapLocation, List<Integer>> sortForcesByMapType(List<Integer> forceIDs, Campaign campaign) {\n+        Map<MapLocation, List<Integer>> retVal = new HashMap<>();\n+        \n+        retVal.put(MapLocation.AllGroundTerrain, new ArrayList<>());\n+        retVal.put(MapLocation.LowAtmosphere, new ArrayList<>());\n+        retVal.put(MapLocation.Space, new ArrayList<>());\n+        \n+        for(int forceID : forceIDs) {\n+            switch(campaign.getForce(forceID).getPrimaryUnitType(campaign)) {\n+            case UnitType.BATTLE_ARMOR:\n+            case UnitType.INFANTRY:\n+            case UnitType.MEK:\n+            case UnitType.TANK:\n+            case UnitType.PROTOMEK:\n+            case UnitType.VTOL:\n+                retVal.get(MapLocation.AllGroundTerrain).add(forceID);\n+                break;\n+            case UnitType.AERO:\n+                retVal.get(MapLocation.Space).add(forceID);\n+                // intentional fallthrough here, ASFs can go to atmospheric maps too\n+            case UnitType.CONV_FIGHTER:\n+                retVal.get(MapLocation.LowAtmosphere).add(forceID);\n+                break;\n+            }\n+        }\n+        \n+        \n+        return retVal;\n+    }\n+    \n+    /**\n+     * Determine whether the user should be nagged about unresolved scenarios on AtB Stratcon tracks.\n+     * @param campaign Campaign to check.\n+     * @return An informative string containing the reasons the user was nagged.\n+     */\n+    public static String nagUnresolvedContacts(Campaign campaign) {\n+        StringBuilder sb = new StringBuilder();\n+        \n+        // check every track attached to an active contract for unresolved scenarios\n+        // to which the player must deploy forces today\n+        for(Contract contract : campaign.getActiveContracts()) {\n+            if(contract instanceof AtBContract) {\n+                for(StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    for(StratconScenario scenario : track.getScenarios().values()) {\n+                        if(scenario.getCurrentState() == ScenarioState.UNRESOLVED &&\n+                                campaign.getLocalDate().equals(scenario.getDeploymentDate())) {\n+                            // \"scenario name, track name\"\n+                            sb.append(String.format(\"%s, %s\\n\", scenario.getName(), track.getDisplayableName()));\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        \n+        return sb.toString();\n+    }\n+    \n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track.\n+     * Also registers it with the track and campaign.\n+     */\n+    private static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track, \n+            int forceID, StratconCoords coords) {\n+        int unitType = campaign.getForce(forceID).getPrimaryUnitType(campaign);\n+        ScenarioTemplate template = StratconScenarioFactory.getRandomScenario(unitType);\n+        // useful for debugging specific scenario types\n+        //ScenarioTemplate template = StratconScenarioFactory.getSpecificScenario(\"Hostile Facility.xml\");\n+        \n+        return generateScenario(campaign, contract, track, forceID, coords, template);\n+    }\n+    \n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track,\n+     * using the given template. Also registers it with the track and campaign.\n+     */\n+    static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track, \n+            int forceID, StratconCoords coords, ScenarioTemplate template) {\n+        StratconScenario scenario = new StratconScenario();\n+        scenario.setBackingScenario(AtBDynamicScenarioFactory.initializeScenarioFromTemplate(template, contract, campaign));\n+        scenario.setCoords(coords);\n+        \n+        // do an appropriate allied force if the contract calls for it\n+        // do any attached or integrated units\n+        setAlliedForceModifier(scenario, contract);\n+        setAttachedUnitsModifier(scenario, contract);\n+        applyFacilityModifiers(scenario, track, coords);\n+        applyGlobalModifiers(scenario, contract.getStratconCampaignState());\n+        \n+        if((contract.getCommandRights() == AtBContract.COM_HOUSE) ||\n+                (contract.getCommandRights() == AtBContract.COM_INTEGRATED)) {\n+            scenario.setRequiredScenario(true);\n+        }\n+        \n+        AtBDynamicScenarioFactory.setScenarioModifiers(scenario.getBackingScenario());\n+        scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+        setScenarioDates(track, campaign, scenario);\n+        \n+        // register the scenario with the campaign and the track it's generated on\n+        if (forceID > Force.FORCE_NONE) {\n+            scenario.addPrimaryForce(forceID);\n+        }\n+        \n+        return scenario;\n+    }\n+    \n+    /**\n+     * Apply global scenario modifiers from campaign state to given scenario.\n+     */\n+    private static void applyGlobalModifiers(StratconScenario scenario, StratconCampaignState campaignState) {\n+        for (String modifierName : campaignState.getGlobalScenarioModifiers()) {\n+            AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierName);\n+            \n+            if (modifier == null) {\n+                MekHQ.getLogger().error(String.format(\"Modifier %s not found; ignoring\", modifierName));\n+                continue;\n+            }\n+            \n+            scenario.getBackingScenario().addScenarioModifier(modifier);\n+        }\n+    }\n+    \n+    /**\n+     * Applies scenario modifiers from the current track to the given scenario.\n+     * @param scenario\n+     * @param track\n+     */\n+    private static void applyFacilityModifiers(StratconScenario scenario, StratconTrackState track, StratconCoords coords) {\n+        // loop through all the facilities on the track\n+        // if a facility has been revealed, then it has a 100% chance to apply its effect\n+        // if a facility has not been revealed, then it has a x% chance to apply its effect\n+        // if a facility is on the the scenario coordinates the it applies the local effects\n+        for (StratconCoords facilityCoords : track.getFacilities().keySet()) {\n+            boolean scenarioAtFacility = facilityCoords.equals(coords);\n+            StratconFacility facility = track.getFacilities().get(facilityCoords);\n+            List<String> modifierIDs = new ArrayList<>();\n+            \n+            if (scenarioAtFacility) {\n+                modifierIDs = facility.getLocalModifiers();\n+            } else if (facility.isVisible() || (Compute.randomInt(100) < facility.getAggroRating())) {\n+                modifierIDs = facility.getSharedModifiers();\n+            }\n+            \n+            for (String modifierID : modifierIDs) {\n+                AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierID);\n+                if(modifier == null) {\n+                    MekHQ.getLogger().error(String.format(\"Modifier %s not found for facility %s\", modifierID, facility.getFormattedDisplayableName()));\n+                    continue;\n+                }\n+                \n+                scenario.getBackingScenario().addScenarioModifier(modifier);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Set up the appropriate primary allied force modifier, if any \n+     * @param contract The scenario's contract.\n+     */\n+    private static void setAlliedForceModifier(StratconScenario scenario, AtBContract contract) {\n+        int alliedUnitOdds = 0;\n+        \n+        // first, we determine the odds of having an allied unit present\n+        // TODO: move this override out to the contract definition\n+        if (contract.getMissionType() == AtBContract.MT_RELIEFDUTY) {\n+            alliedUnitOdds = 50;\n+        } else {\n+            switch(contract.getCommandRights()) {\n+            case AtBContract.COM_INTEGRATED:\n+                alliedUnitOdds = 50;\n+                break;\n+            case AtBContract.COM_HOUSE:\n+                alliedUnitOdds = 30;\n+                break;\n+            case AtBContract.COM_LIAISON:\n+                alliedUnitOdds = 10;\n+                break;\n+            }\n+        }\n+        \n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+        \n+        // if an allied unit is present, then we want to make sure that it's ground units\n+        // for ground battles\n+        if (Compute.randomInt(100) <= alliedUnitOdds) {\n+            if((backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+               (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space)) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_ALLIED_AIR_UNITS));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_ALLIED_GROUND_UNITS));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set the 'attached' units modifier for the current scenario (integrated, house, liaison),\n+     * and make sure we're not deploying ground units to an air scenario\n+     * @param contract The scenario's contract\n+     */\n+    public static void setAttachedUnitsModifier(StratconScenario scenario, AtBContract contract) {\n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+        boolean airBattle = (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+                (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space);\n+        \n+        // if we're on cadre duty, we're getting three trainees, period\n+        if(contract.getMissionType() == AtBContract.MT_CADREDUTY) {\n+            if(airBattle) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_TRAINEES_AIR));                \n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_TRAINEES_GROUND));\n+            }\n+            return;\n+        }\n+        \n+        // if we're under non-independent command rights, a supervisor may come along\n+        switch(contract.getCommandRights()) {\n+        case AtBContract.COM_INTEGRATED:\n+            if(airBattle) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_INTEGRATED_UNITS_AIR));                \n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_INTEGRATED_UNITS_GROUND));\n+            }\n+            break;\n+        case AtBContract.COM_HOUSE:\n+            if(airBattle) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_HOUSE_CO_AIR));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_HOUSE_CO_GROUND));\n+            }            \n+            break;\n+        case AtBContract.COM_LIAISON:\n+            if(scenario.isRequiredScenario()) {\n+                if(airBattle) {\n+                    backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_LIAISON_AIR));\n+                } else {\n+                    backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_LIAISON_GROUND));\n+                } \n+            }\n+            break;\n+        }\n+    }\n+    \n+    /**\n+     * Worker function that sets scenario deploy/battle/return dates based on the track's properties and current campaign date\n+     * @param track\n+     * @param campaign\n+     * @param scenario\n+     */\n+    private static void setScenarioDates(StratconTrackState track, Campaign campaign, StratconScenario scenario) {\n+     // set up deployment day, battle day, return day here\n+        // safety code to prevent attempts to generate random int with upper bound of 0 which is apparently illegal\n+        int deploymentDay = track.getDeploymentTime() < 7 ? Compute.randomInt(7 - track.getDeploymentTime()) : 0;\n+        int battleDay = deploymentDay + (track.getDeploymentTime() > 0 ? Compute.randomInt(track.getDeploymentTime()) : 0);\n+        int returnDay = deploymentDay + track.getDeploymentTime();\n+        \n+        LocalDate deploymentDate = campaign.getLocalDate();\n+        deploymentDate.plusDays(deploymentDay);\n+        LocalDate battleDate = campaign.getLocalDate();\n+        deploymentDate.plusDays(battleDay);\n+        LocalDate returnDate = campaign.getLocalDate();\n+        returnDate.plusDays(returnDay);\n+        \n+        scenario.setDeploymentDate(deploymentDate);\n+        scenario.setActionDate(battleDate);\n+        scenario.setReturnDate(returnDate);\n+    }\n+    \n+    /**\n+     * Helper function that determines if the unit type specified in the given scenario force template\n+     * would start out airborne on a ground map (hot dropped units aside)\n+     * @param template\n+     * @return\n+     */\n+    private static boolean unitTypeIsAirborne(ScenarioForceTemplate template) {\n+        int unitType = template.getAllowedUnitType();\n+        \n+        return (unitType == UnitType.AERO ||\n+                unitType == UnitType.CONV_FIGHTER ||\n+                unitType == UnitType.DROPSHIP ||\n+                unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_MIX) &&\n+                template.getStartingAltitude() > 0;\n+    }\n+    \n+    /**\n+     * Determines whether the force in question has the same primary unit type as the force template.\n+     * @return Whether or not the unit types match.\n+     */\n+    public static boolean forceCompositionMatchesDeclaredUnitType(int primaryUnitType, int unitType, boolean reinforcements) {        \n+        // special cases are \"ATB_MIX\" and \"ATB_AERO_MIX\", which encompass multiple unit types\n+        if(unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_MIX) {\n+            // \"AtB mix\" is usually ground units, but air units can sub in\n+            return primaryUnitType == UnitType.MEK ||\n+                    primaryUnitType == UnitType.TANK ||\n+                    primaryUnitType == UnitType.INFANTRY ||\n+                    primaryUnitType == UnitType.BATTLE_ARMOR ||\n+                    primaryUnitType == UnitType.PROTOMEK || \n+                    primaryUnitType == UnitType.VTOL ||\n+                    (primaryUnitType == UnitType.AERO) && reinforcements ||\n+                    (primaryUnitType == UnitType.CONV_FIGHTER) && reinforcements;\n+        } else if (unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_AERO_MIX) {\n+            return primaryUnitType == UnitType.AERO ||\n+                    primaryUnitType == UnitType.CONV_FIGHTER;\n+        } else {\n+            return primaryUnitType == unitType;\n+        }\n+    }\n+    \n+    /**\n+     * This is a set of all force IDs for forces that can be deployed to a scenario.\n+     * @param campaign Current campaign\n+     * @return Set of available force IDs.\n+     */\n+    public static List<Integer> getAvailableForceIDs(Campaign campaign) {\n+        List<Integer> retVal = new ArrayList<>();\n+        \n+        // first, we gather a set of all forces that are already deployed to a track so we eliminate those later\n+        Set<Integer> forcesInTracks = new HashSet<>();\n+        for(Contract contract : campaign.getActiveContracts()) {\n+            if(contract instanceof AtBContract) {\n+                for(StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    forcesInTracks.addAll(track.getAssignedForceCoords().keySet());\n+                }\n+            }\n+        }\n+        \n+        // now, we get all the forces that qualify as \"lances\", and filter out those that are\n+        // deployed to a scenario and not in a track already\n+        for(int key : campaign.getLances().keySet()) {\n+            Force force = campaign.getForce(key);\n+            if(force != null && \n+                    !force.isDeployed() && \n+                    (force.getScenarioId() <= 0) &&", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzU1NjI0MQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593556241", "bodyText": "Hell if I know.", "author": "NickAragua", "createdAt": "2021-03-13T04:07:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQwNzMxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQwOTQxMg==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593409412", "bodyText": "This should probably filter on mothballed units and units without a commander or something like that.\nMaybe add something to Hangar:\n    public void forEachActiveUnit(Consumer<Unit> consumer) {\n        units.forEach((id, unit) -> {\n            if (!unit.isMothballed() && !unit.isUnmanned()) {\n                consumer.accept(unit));\n            }\n        });\n    }", "author": "sixlettervariables", "createdAt": "2021-03-12T19:46:01Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1080 @@\n+package mekhq.campaign.stratcon;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import megamek.common.Compute;\n+import megamek.common.Minefield;\n+import megamek.common.UnitType;\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.ResolveScenarioTracker;\n+import mekhq.campaign.againstTheBot.enums.AtBLanceRole;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.force.Lance;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier.EventTiming;\n+import mekhq.campaign.mission.atb.AtBScenarioModifierApplicator;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.unit.Unit;\n+\n+/**\n+ * This class contains \"rules\" logic for the AtB-Stratcon state\n+ * @author NickAragua\n+ *\n+ */\n+public class StratconRulesManager {\n+    public enum ReinforcementEligibilityType {\n+        None,\n+        ChainedScenario,\n+        SupportPoint,\n+        FightLance\n+    }\n+    \n+    /**\n+     * This function potentially generates non-player-initiated scenarios for the given track.\n+     * @param campaign\n+     * @param contract\n+     * @param track\n+     */\n+    public static void generateScenariosForTrack(Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // maps scenarios to force IDs\n+        List<StratconScenario> generatedScenarios = new ArrayList<>(); \n+        boolean autoAssignLances = contract.getCommandRights() == AtBContract.COM_INTEGRATED;\n+        \n+        // get this list just so we have it available\n+        List<Integer> availableForceIDs = getAvailableForceIDs(campaign);\n+        Map<MapLocation, List<Integer>> sortedAvailableForceIDs = sortForcesByMapType(availableForceIDs, campaign);\n+        \n+        // make X rolls, where X is the number of required lances for the track\n+        // that's the chance to spawn a scenario.\n+        // if a scenario occurs, then we pick a random non-deployed lance and use it to drive the opfor generation later\n+        // once we've determined that scenarios occur, we loop through the ones that we generated\n+        // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all \n+        for(int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            // if we haven't already used all the player forces and are required to randomly generate a scenario\n+            if((availableForceIDs.size() > 0) &&\n+                    (Compute.randomInt(100) <= track.getScenarioOdds())) {\n+                // pick random coordinates and force to drive the scenario\n+                int x = Compute.randomInt(track.getWidth());\n+                int y = Compute.randomInt(track.getHeight());                \n+                \n+                StratconCoords scenarioCoords = new StratconCoords(x, y);\n+                \n+                int randomForceIndex = Compute.randomInt(availableForceIDs.size());\n+                int randomForceID = availableForceIDs.get(randomForceIndex);\n+                \n+                // remove the force from the available lists so we don't designate it as primary twice\n+                availableForceIDs.remove(randomForceIndex); \n+                \n+                // we want to remove the actual int with the value, not the value at the index\n+                sortedAvailableForceIDs.get(MapLocation.AllGroundTerrain).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.LowAtmosphere).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.Space).remove((Integer) randomForceID);\n+                \n+                // two scenarios on the same coordinates wind up increasing in size\n+                if(track.getScenarios().containsKey(scenarioCoords)) {\n+                    track.getScenarios().get(scenarioCoords).incrementRequiredPlayerLances();\n+                    assignAppropriateExtraForceToScenario(track.getScenarios().get(scenarioCoords), sortedAvailableForceIDs, campaign);\n+                    continue;\n+                }\n+                \n+                StratconScenario scenario = setupScenario(scenarioCoords, randomForceID, campaign, contract, track);\n+                generatedScenarios.add(scenario);\n+                \n+                // if we're auto-assigning lances, deploy the force to the track as well\n+                if(autoAssignLances) {\n+                    processForceDeployment(scenarioCoords, randomForceID, campaign, track);\n+                }\n+            }\n+        }\n+        \n+        // if under liaison command, pick a random scenario from the ones generated\n+        // to set as required and attach liaison\n+        if(contract.getCommandRights() == AtBContract.COM_LIAISON) {\n+            int scenarioIndex = Compute.randomInt(generatedScenarios.size() - 1);\n+            generatedScenarios.get(scenarioIndex).setRequiredScenario(true);\n+            setAttachedUnitsModifier(generatedScenarios.get(scenarioIndex), contract);\n+        }\n+        \n+        // now, we loop through all the scenarios we set up\n+        // and generate the opfors / events / etc\n+        // if not auto-assigning lances, we then back out the lance assignments.\n+        for(StratconScenario scenario : generatedScenarios) {\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            \n+            if(!autoAssignLances) {\n+                for(int forceID : scenario.getPrimaryPlayerForceIDs()) {\n+                    scenario.getBackingScenario().removeForce(forceID);\n+                }\n+                \n+                scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                track.addScenario(scenario);\n+            } else {\n+                commitPrimaryForces(campaign, contract, scenario, track);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Deploys a force to the given coordinates on the given track as a result of explicit player action.\n+     */\n+    public static void deployForceToCoords(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // the following things should happen:\n+        // 1. call to \"process force deployment\", which reveals fog of war in or around the coords, depending on force role\n+        // 2. if coords are a hostile facility, we get a facility mission\n+        // 3. if coords are empty, we *may* get a mission\n+        \n+        processForceDeployment(coords, forceID, campaign, track);\n+        \n+        // don't create a scenario on top of allied facilities\n+        StratconFacility facility = track.getFacility(coords);\n+        boolean isNonAlliedFacility = (facility != null) && (facility.getOwner() != ForceAlignment.Allied);\n+        boolean spawnScenario = (facility == null) && (Compute.randomInt(100) <= track.getScenarioOdds());\n+\n+        if(isNonAlliedFacility || spawnScenario) {\n+            StratconScenario scenario = setupScenario(coords, forceID, campaign, contract, track);\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            commitPrimaryForces(campaign, contract, scenario, track);\n+        }\n+    }\n+    \n+    /**\n+     * Logic to set up a scenario\n+     */\n+    private static StratconScenario setupScenario(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        StratconScenario scenario = null;\n+        \n+        if(track.getFacilities().containsKey(coords)) {\n+            StratconFacility facility = track.getFacility(coords);\n+            boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+            ScenarioTemplate template = StratconScenarioFactory.getFacilityScenario(alliedFacility);\n+            scenario = generateScenario(campaign, contract, track, forceID, coords, template);\n+            setupFacilityScenario(scenario, track, coords, facility);\n+        } else {\n+            scenario = generateScenario(campaign, contract, track, forceID, coords);\n+            \n+            // we may generate a facility scenario randomly - if so, do the facility-related stuff\n+            // and add a new facility to the track\n+            if(scenario.getBackingScenario().getTemplate().isFacilityScenario()) {\n+                StratconFacility facility = scenario.getBackingScenario().getTemplate().isHostileFacility() ?\n+                        StratconFacilityFactory.getRandomHostileFacility() : StratconFacilityFactory.getRandomAlliedFacility();\n+                facility.setVisible(true);\n+                track.addFacility(coords, facility);\n+                setupFacilityScenario(scenario, track, coords, facility);\n+            }\n+        }\n+        \n+        return scenario;\n+    }\n+    \n+    /**\n+     * carries out tasks relevant to facility scenarios\n+     */\n+    private static void setupFacilityScenario(StratconScenario scenario, StratconTrackState track, StratconCoords coords, StratconFacility facility) {\n+        // this includes:\n+        // for hostile facilities\n+        // - add a destroy objective (always the option to level the facility)\n+        // - add a capture objective (always the option to capture the facility)\n+        // - if so indicated by parameter, roll a random hostile facility objective and add it if not capture/destroy\n+        // for allied facilities\n+        // - add a defend objective (always the option to defend the facility)\n+        // - if so indicated by parameter, roll a random allied facility objective and add it if not defend\n+        AtBScenarioModifier objectiveModifier = null;\n+        boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+        \n+        if(alliedFacility) {\n+            objectiveModifier = AtBScenarioModifier.getRandomAlliedFacilityModifier();\n+        } else {            \n+            objectiveModifier = AtBScenarioModifier.getRandomHostileFacilityModifier();\n+        }\n+        \n+        if(objectiveModifier != null) {\n+            scenario.getBackingScenario().addScenarioModifier(objectiveModifier);\n+            scenario.getBackingScenario().setName(String.format(\"%s - %s - %s\", \n+                    facility.getFacilityType(), alliedFacility ? \"Allied\" : \"Hostile\", objectiveModifier.getModifierName()));\n+        }\n+        \n+        // add the \"fixed\" hostile facility modifiers after the primary ones\n+        if(!alliedFacility) {\n+            for(AtBScenarioModifier modifier : AtBScenarioModifier.getRequiredHostileFacilityModifiers()) {\n+                if(!scenario.getBackingScenario().alreadyHasModifier(modifier)) {\n+                    scenario.getBackingScenario().addScenarioModifier(modifier);\n+                }\n+            }\n+        }\n+    }\n+    \n+    private static void processFacilityEffects(StratconTrackState track) {\n+        // todo: these are \"weekly\"? effects that a stratcon facility has on the campaign/track state\n+        // currrently, that's \n+        // supply depot - allied - +1 sp\n+        // supply depot - hostile - +5% BV budget to all scenarios on track (shared modifier, so should be implemented there)\n+        // data center - allied - +1% star league cache contract (don't implement yet, but...)\n+        // data center - hostile - +5% scenario odds in track\n+        // industrial center - allied - all scenarios here have THIS IS COMING OUT OF YOUR PAYCHECK modifier\n+        // orbital defense - allied - sets 'no hostile aircraft' flag for track\n+        // orbital defense - hostile - sets 'no allied aircraft' flag for track\n+        // early warning system - allied - sets 'intercept allied base attacks' flag for track\n+        // early warning system - hostile - sets 'intercept hostile base attacks' flag for track\n+    }\n+    \n+    /**\n+     * Process the deployment of a force to the given coordinates on the given track.\n+     */\n+    public static void processForceDeployment(StratconCoords coords, int forceID, Campaign campaign, StratconTrackState track) {\n+        track.getRevealedCoords().add(coords);\n+        StratconFacility facility = track.getFacility(coords);\n+        if(facility != null) {\n+            facility.setVisible(true);\n+        }\n+        \n+        if(campaign.getLances().get(forceID).getRole() == AtBLanceRole.SCOUTING) {\n+            for(int direction = 0; direction < 6; direction++) {\n+                StratconCoords checkCoords = coords.translate(direction);\n+                \n+                facility = track.getFacility(checkCoords);\n+                if(facility != null) {\n+                    facility.setVisible(true);\n+                }\n+                \n+                track.getRevealedCoords().add(coords.translate(direction));\n+            }\n+        }\n+        \n+        // the force may be located in other places on the track - clear it out\n+        track.unassignForce(forceID);\n+        track.assignForce(forceID, coords, campaign.getLocalDate());\n+    }\n+    \n+    /**\n+     * Worker function that processes the effects of deploying a reinforcement force to a scenario\n+     */\n+    public static boolean processReinforcementDeployment(ReinforcementEligibilityType reinforcementType, \n+            StratconCampaignState campaignState, StratconScenario scenario, Campaign campaign) {\n+        // if the force is already deployed to the track, we're done\n+        // if the force is a fight lance or we're using a support point\n+        // if there is an SP to burn, burn it and we're done\n+        // if there is a VP to burn, burn it and we're done\n+        // now, roll 2d6 + lance commander tactics\n+        // 9+ = deploy\n+        // 6+ = deploy, if lance != fight, track scenario odds up\n+        // 2+ = apply negative modifier to scenario\n+        \n+        if ((reinforcementType == ReinforcementEligibilityType.FightLance) ||\n+                (reinforcementType == ReinforcementEligibilityType.SupportPoint)) {\n+            \n+            if (campaignState.getSupportPoints() > 0) {\n+                campaignState.useSupportPoint();\n+                return true;\n+            } else if (campaignState.getVictoryPoints() > 0) {\n+                campaignState.updateVictoryPoints(-1);\n+                return true;\n+            }\n+            \n+            int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+            int roll = 7;//Compute.d6(2);\n+            int result = roll + tactics;\n+\n+            String reportStatus = String.format(\"Attempting to reinforce scenario %s without SP/VP, roll 2d6 + %d: %d\",\n+                    scenario.getName(), tactics, result);\n+            \n+            // fail to reinforce\n+            if (result < 6) {\n+                reportStatus += \" - reinforcement attempt failed.\";\n+                campaign.addReport(reportStatus);\n+                return false;\n+            // succeed but get an extra negative event added to the scenario\n+            } else if ((result < 9) && (reinforcementType != ReinforcementEligibilityType.FightLance)) {\n+                MapLocation mapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+                AtBScenarioModifier scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+                \n+                // keep rolling until we get an applicable one\n+                // todo: have the AtBScenarioModifier sort these out instead for performance?\n+                while (scenarioModifier.getEventTiming() != EventTiming.PostForceGeneration) {\n+                    scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+                }\n+                \n+                scenarioModifier.processModifier(scenario.getBackingScenario(), campaign, EventTiming.PostForceGeneration);\n+                \n+                reportStatus += String.format(\" - reinforcement attempt succeeded; extra negative modifier (%s) applied to scenario.\",\n+                        scenarioModifier.getModifierName());\n+                campaign.addReport(reportStatus);\n+                return true;\n+            // succeed without reservation\n+            } else {\n+                reportStatus += \" - reinforcement attempt succeeded;\";\n+                campaign.addReport(reportStatus);\n+                return true;\n+            }\n+        } else if (reinforcementType == ReinforcementEligibilityType.None) {\n+            return false;\n+        }\n+        \n+        return true;\n+    }\n+    \n+    /**\n+     * Assigns a force to the scenario such that the majority of the force can be deployed\n+     * @param scenario\n+     * @param sortedAvailableForceIDs\n+     */\n+    private static void assignAppropriateExtraForceToScenario(StratconScenario scenario, \n+            Map<MapLocation, List<Integer>> sortedAvailableForceIDs, Campaign campaign) {\n+        // the goal of this function is to avoid assigning ground units to air battles\n+        // and ground units/conventional fighters to space battle\n+        \n+        List<MapLocation> mapLocations = new ArrayList<>();\n+        mapLocations.add(MapLocation.Space); // can always add ASFs\n+        \n+        MapLocation scenarioMapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+        \n+        if(scenarioMapLocation == MapLocation.LowAtmosphere) {\n+            mapLocations.add(MapLocation.LowAtmosphere); // can add conventional fighters to ground or low atmo battles\n+        }\n+        \n+        if((scenarioMapLocation == MapLocation.AllGroundTerrain) || \n+                (scenarioMapLocation == MapLocation.SpecificGroundTerrain)) {\n+            mapLocations.add(MapLocation.AllGroundTerrain); // can only add ground units to ground battles\n+        }\n+        \n+        MapLocation selectedLocation = mapLocations.get(Compute.randomInt(mapLocations.size()));\n+        List<Integer> forceIDs = sortedAvailableForceIDs.get(selectedLocation);\n+        int forceIndex = Compute.randomInt(forceIDs.size());\n+        int forceID = forceIDs.get(forceIndex);\n+        forceIDs.remove(forceIndex);\n+        \n+        scenario.addPrimaryForce(forceID);\n+    }\n+    \n+    /**\n+     * Worker function that \"locks in\" a scenario - \n+     * Adds it to the campaign so it's visible in the briefing room,\n+     * adds it to the track\n+     * \n+     */\n+    public static void commitPrimaryForces(Campaign campaign, AtBContract contract, StratconScenario scenario, StratconTrackState trackState) {\n+        // order of operations is important here, we need a valid scenario ID prior to adding the scenario to the track.\n+        campaign.addScenario(scenario.getBackingScenario(), contract);\n+        scenario.setBackingScenarioID(scenario.getBackingScenario().getId());\n+        trackState.addScenario(scenario);\n+        \n+        // set up dates for the scenario if doesn't have them already\n+        if(scenario.getDeploymentDate() == null) {\n+            scenario.setDeploymentDate(campaign.getLocalDate());\n+        }\n+        \n+        if(scenario.getActionDate() == null) {\n+            scenario.setActionDate(campaign.getLocalDate());\n+        }\n+        \n+        if(scenario.getReturnDate() == null) {\n+            scenario.setReturnDate(campaign.getLocalDate().plusDays(trackState.getDeploymentTime()));\n+        }\n+        \n+        // set the # of rerolls based on the actual lance assigned.\n+        int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+        scenario.getBackingScenario().setRerolls(tactics);\n+        // The number of defensive points available to a force entering a scenario is\n+        // 2 x tactics. By default, those points are spent on conventional minefields.\n+        if (commanderLanceHasDefensiveAssignment(scenario.getBackingScenario(), campaign)) {\n+            scenario.setNumDefensivePoints(tactics * 2);\n+            scenario.updateMinefieldCount(Minefield.TYPE_CONVENTIONAL, tactics * 2);\n+        }\n+        \n+        for (int forceID : scenario.getPrimaryPlayerForceIDs()) {\n+            Force force = campaign.getForce(forceID);\n+            force.clearScenarioIds(campaign, true);\n+            force.setScenarioId(scenario.getBackingScenarioID());\n+        }\n+        \n+        scenario.commitPrimaryForces(campaign, contract);\n+    }\n+    \n+    /**\n+     * Utility method to determine if the current scenario's force commander\n+     * is on defence \n+     */\n+    private static boolean commanderLanceHasDefensiveAssignment(AtBDynamicScenario scenario, Campaign campaign) {\n+        Unit commanderUnit = scenario.getLanceCommander(campaign).getUnit();\n+        Lance lance = campaign.getLances().get(commanderUnit.getForceId());\n+        \n+        if ((lance != null) && (lance.getRole() == AtBLanceRole.DEFENCE)) {\n+            return true;\n+        }\n+        \n+        return false;\n+    }\n+    \n+    /**\n+     * A hackish worker function that takes the given list of force IDs and\n+     * separates it into three sets;\n+     * one of forces that can be \"primary\" on a ground map\n+     * one of forces that can be \"primary\" on an atmospheric map\n+     * one of forces that can be \"primary\" in a space map\n+     * @param forceIDs List of force IDs to check\n+     * @return Sorted hash map\n+     */\n+    private static Map<MapLocation, List<Integer>> sortForcesByMapType(List<Integer> forceIDs, Campaign campaign) {\n+        Map<MapLocation, List<Integer>> retVal = new HashMap<>();\n+        \n+        retVal.put(MapLocation.AllGroundTerrain, new ArrayList<>());\n+        retVal.put(MapLocation.LowAtmosphere, new ArrayList<>());\n+        retVal.put(MapLocation.Space, new ArrayList<>());\n+        \n+        for(int forceID : forceIDs) {\n+            switch(campaign.getForce(forceID).getPrimaryUnitType(campaign)) {\n+            case UnitType.BATTLE_ARMOR:\n+            case UnitType.INFANTRY:\n+            case UnitType.MEK:\n+            case UnitType.TANK:\n+            case UnitType.PROTOMEK:\n+            case UnitType.VTOL:\n+                retVal.get(MapLocation.AllGroundTerrain).add(forceID);\n+                break;\n+            case UnitType.AERO:\n+                retVal.get(MapLocation.Space).add(forceID);\n+                // intentional fallthrough here, ASFs can go to atmospheric maps too\n+            case UnitType.CONV_FIGHTER:\n+                retVal.get(MapLocation.LowAtmosphere).add(forceID);\n+                break;\n+            }\n+        }\n+        \n+        \n+        return retVal;\n+    }\n+    \n+    /**\n+     * Determine whether the user should be nagged about unresolved scenarios on AtB Stratcon tracks.\n+     * @param campaign Campaign to check.\n+     * @return An informative string containing the reasons the user was nagged.\n+     */\n+    public static String nagUnresolvedContacts(Campaign campaign) {\n+        StringBuilder sb = new StringBuilder();\n+        \n+        // check every track attached to an active contract for unresolved scenarios\n+        // to which the player must deploy forces today\n+        for(Contract contract : campaign.getActiveContracts()) {\n+            if(contract instanceof AtBContract) {\n+                for(StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    for(StratconScenario scenario : track.getScenarios().values()) {\n+                        if(scenario.getCurrentState() == ScenarioState.UNRESOLVED &&\n+                                campaign.getLocalDate().equals(scenario.getDeploymentDate())) {\n+                            // \"scenario name, track name\"\n+                            sb.append(String.format(\"%s, %s\\n\", scenario.getName(), track.getDisplayableName()));\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        \n+        return sb.toString();\n+    }\n+    \n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track.\n+     * Also registers it with the track and campaign.\n+     */\n+    private static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track, \n+            int forceID, StratconCoords coords) {\n+        int unitType = campaign.getForce(forceID).getPrimaryUnitType(campaign);\n+        ScenarioTemplate template = StratconScenarioFactory.getRandomScenario(unitType);\n+        // useful for debugging specific scenario types\n+        //ScenarioTemplate template = StratconScenarioFactory.getSpecificScenario(\"Hostile Facility.xml\");\n+        \n+        return generateScenario(campaign, contract, track, forceID, coords, template);\n+    }\n+    \n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track,\n+     * using the given template. Also registers it with the track and campaign.\n+     */\n+    static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track, \n+            int forceID, StratconCoords coords, ScenarioTemplate template) {\n+        StratconScenario scenario = new StratconScenario();\n+        scenario.setBackingScenario(AtBDynamicScenarioFactory.initializeScenarioFromTemplate(template, contract, campaign));\n+        scenario.setCoords(coords);\n+        \n+        // do an appropriate allied force if the contract calls for it\n+        // do any attached or integrated units\n+        setAlliedForceModifier(scenario, contract);\n+        setAttachedUnitsModifier(scenario, contract);\n+        applyFacilityModifiers(scenario, track, coords);\n+        applyGlobalModifiers(scenario, contract.getStratconCampaignState());\n+        \n+        if((contract.getCommandRights() == AtBContract.COM_HOUSE) ||\n+                (contract.getCommandRights() == AtBContract.COM_INTEGRATED)) {\n+            scenario.setRequiredScenario(true);\n+        }\n+        \n+        AtBDynamicScenarioFactory.setScenarioModifiers(scenario.getBackingScenario());\n+        scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+        setScenarioDates(track, campaign, scenario);\n+        \n+        // register the scenario with the campaign and the track it's generated on\n+        if (forceID > Force.FORCE_NONE) {\n+            scenario.addPrimaryForce(forceID);\n+        }\n+        \n+        return scenario;\n+    }\n+    \n+    /**\n+     * Apply global scenario modifiers from campaign state to given scenario.\n+     */\n+    private static void applyGlobalModifiers(StratconScenario scenario, StratconCampaignState campaignState) {\n+        for (String modifierName : campaignState.getGlobalScenarioModifiers()) {\n+            AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierName);\n+            \n+            if (modifier == null) {\n+                MekHQ.getLogger().error(String.format(\"Modifier %s not found; ignoring\", modifierName));\n+                continue;\n+            }\n+            \n+            scenario.getBackingScenario().addScenarioModifier(modifier);\n+        }\n+    }\n+    \n+    /**\n+     * Applies scenario modifiers from the current track to the given scenario.\n+     * @param scenario\n+     * @param track\n+     */\n+    private static void applyFacilityModifiers(StratconScenario scenario, StratconTrackState track, StratconCoords coords) {\n+        // loop through all the facilities on the track\n+        // if a facility has been revealed, then it has a 100% chance to apply its effect\n+        // if a facility has not been revealed, then it has a x% chance to apply its effect\n+        // if a facility is on the the scenario coordinates the it applies the local effects\n+        for (StratconCoords facilityCoords : track.getFacilities().keySet()) {\n+            boolean scenarioAtFacility = facilityCoords.equals(coords);\n+            StratconFacility facility = track.getFacilities().get(facilityCoords);\n+            List<String> modifierIDs = new ArrayList<>();\n+            \n+            if (scenarioAtFacility) {\n+                modifierIDs = facility.getLocalModifiers();\n+            } else if (facility.isVisible() || (Compute.randomInt(100) < facility.getAggroRating())) {\n+                modifierIDs = facility.getSharedModifiers();\n+            }\n+            \n+            for (String modifierID : modifierIDs) {\n+                AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierID);\n+                if(modifier == null) {\n+                    MekHQ.getLogger().error(String.format(\"Modifier %s not found for facility %s\", modifierID, facility.getFormattedDisplayableName()));\n+                    continue;\n+                }\n+                \n+                scenario.getBackingScenario().addScenarioModifier(modifier);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Set up the appropriate primary allied force modifier, if any \n+     * @param contract The scenario's contract.\n+     */\n+    private static void setAlliedForceModifier(StratconScenario scenario, AtBContract contract) {\n+        int alliedUnitOdds = 0;\n+        \n+        // first, we determine the odds of having an allied unit present\n+        // TODO: move this override out to the contract definition\n+        if (contract.getMissionType() == AtBContract.MT_RELIEFDUTY) {\n+            alliedUnitOdds = 50;\n+        } else {\n+            switch(contract.getCommandRights()) {\n+            case AtBContract.COM_INTEGRATED:\n+                alliedUnitOdds = 50;\n+                break;\n+            case AtBContract.COM_HOUSE:\n+                alliedUnitOdds = 30;\n+                break;\n+            case AtBContract.COM_LIAISON:\n+                alliedUnitOdds = 10;\n+                break;\n+            }\n+        }\n+        \n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+        \n+        // if an allied unit is present, then we want to make sure that it's ground units\n+        // for ground battles\n+        if (Compute.randomInt(100) <= alliedUnitOdds) {\n+            if((backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+               (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space)) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_ALLIED_AIR_UNITS));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_ALLIED_GROUND_UNITS));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set the 'attached' units modifier for the current scenario (integrated, house, liaison),\n+     * and make sure we're not deploying ground units to an air scenario\n+     * @param contract The scenario's contract\n+     */\n+    public static void setAttachedUnitsModifier(StratconScenario scenario, AtBContract contract) {\n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+        boolean airBattle = (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+                (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space);\n+        \n+        // if we're on cadre duty, we're getting three trainees, period\n+        if(contract.getMissionType() == AtBContract.MT_CADREDUTY) {\n+            if(airBattle) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_TRAINEES_AIR));                \n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_TRAINEES_GROUND));\n+            }\n+            return;\n+        }\n+        \n+        // if we're under non-independent command rights, a supervisor may come along\n+        switch(contract.getCommandRights()) {\n+        case AtBContract.COM_INTEGRATED:\n+            if(airBattle) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_INTEGRATED_UNITS_AIR));                \n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_INTEGRATED_UNITS_GROUND));\n+            }\n+            break;\n+        case AtBContract.COM_HOUSE:\n+            if(airBattle) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_HOUSE_CO_AIR));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_HOUSE_CO_GROUND));\n+            }            \n+            break;\n+        case AtBContract.COM_LIAISON:\n+            if(scenario.isRequiredScenario()) {\n+                if(airBattle) {\n+                    backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_LIAISON_AIR));\n+                } else {\n+                    backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_LIAISON_GROUND));\n+                } \n+            }\n+            break;\n+        }\n+    }\n+    \n+    /**\n+     * Worker function that sets scenario deploy/battle/return dates based on the track's properties and current campaign date\n+     * @param track\n+     * @param campaign\n+     * @param scenario\n+     */\n+    private static void setScenarioDates(StratconTrackState track, Campaign campaign, StratconScenario scenario) {\n+     // set up deployment day, battle day, return day here\n+        // safety code to prevent attempts to generate random int with upper bound of 0 which is apparently illegal\n+        int deploymentDay = track.getDeploymentTime() < 7 ? Compute.randomInt(7 - track.getDeploymentTime()) : 0;\n+        int battleDay = deploymentDay + (track.getDeploymentTime() > 0 ? Compute.randomInt(track.getDeploymentTime()) : 0);\n+        int returnDay = deploymentDay + track.getDeploymentTime();\n+        \n+        LocalDate deploymentDate = campaign.getLocalDate();\n+        deploymentDate.plusDays(deploymentDay);\n+        LocalDate battleDate = campaign.getLocalDate();\n+        deploymentDate.plusDays(battleDay);\n+        LocalDate returnDate = campaign.getLocalDate();\n+        returnDate.plusDays(returnDay);\n+        \n+        scenario.setDeploymentDate(deploymentDate);\n+        scenario.setActionDate(battleDate);\n+        scenario.setReturnDate(returnDate);\n+    }\n+    \n+    /**\n+     * Helper function that determines if the unit type specified in the given scenario force template\n+     * would start out airborne on a ground map (hot dropped units aside)\n+     * @param template\n+     * @return\n+     */\n+    private static boolean unitTypeIsAirborne(ScenarioForceTemplate template) {\n+        int unitType = template.getAllowedUnitType();\n+        \n+        return (unitType == UnitType.AERO ||\n+                unitType == UnitType.CONV_FIGHTER ||\n+                unitType == UnitType.DROPSHIP ||\n+                unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_MIX) &&\n+                template.getStartingAltitude() > 0;\n+    }\n+    \n+    /**\n+     * Determines whether the force in question has the same primary unit type as the force template.\n+     * @return Whether or not the unit types match.\n+     */\n+    public static boolean forceCompositionMatchesDeclaredUnitType(int primaryUnitType, int unitType, boolean reinforcements) {        \n+        // special cases are \"ATB_MIX\" and \"ATB_AERO_MIX\", which encompass multiple unit types\n+        if(unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_MIX) {\n+            // \"AtB mix\" is usually ground units, but air units can sub in\n+            return primaryUnitType == UnitType.MEK ||\n+                    primaryUnitType == UnitType.TANK ||\n+                    primaryUnitType == UnitType.INFANTRY ||\n+                    primaryUnitType == UnitType.BATTLE_ARMOR ||\n+                    primaryUnitType == UnitType.PROTOMEK || \n+                    primaryUnitType == UnitType.VTOL ||\n+                    (primaryUnitType == UnitType.AERO) && reinforcements ||\n+                    (primaryUnitType == UnitType.CONV_FIGHTER) && reinforcements;\n+        } else if (unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_AERO_MIX) {\n+            return primaryUnitType == UnitType.AERO ||\n+                    primaryUnitType == UnitType.CONV_FIGHTER;\n+        } else {\n+            return primaryUnitType == unitType;\n+        }\n+    }\n+    \n+    /**\n+     * This is a set of all force IDs for forces that can be deployed to a scenario.\n+     * @param campaign Current campaign\n+     * @return Set of available force IDs.\n+     */\n+    public static List<Integer> getAvailableForceIDs(Campaign campaign) {\n+        List<Integer> retVal = new ArrayList<>();\n+        \n+        // first, we gather a set of all forces that are already deployed to a track so we eliminate those later\n+        Set<Integer> forcesInTracks = new HashSet<>();\n+        for(Contract contract : campaign.getActiveContracts()) {\n+            if(contract instanceof AtBContract) {\n+                for(StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    forcesInTracks.addAll(track.getAssignedForceCoords().keySet());\n+                }\n+            }\n+        }\n+        \n+        // now, we get all the forces that qualify as \"lances\", and filter out those that are\n+        // deployed to a scenario and not in a track already\n+        for(int key : campaign.getLances().keySet()) {\n+            Force force = campaign.getForce(key);\n+            if(force != null && \n+                    !force.isDeployed() && \n+                    (force.getScenarioId() <= 0) &&\n+                    !forcesInTracks.contains(force.getId())) {\n+                retVal.add(force.getId());\n+            }\n+        }\n+        \n+        return retVal;\n+    }\n+    \n+    /**\n+     * This is a list of all force IDs for forces that can be deployed to a scenario in the given force template\n+     * a) have not been assigned to a track\n+     * b) are combat-capable\n+     * c) are not deployed to a scenario\n+     */\n+    public static List<Integer> getAvailableForceIDs(int unitType, Campaign campaign, StratconTrackState currentTrack, \n+            boolean reinforcements) {\n+        List<Integer> retVal = new ArrayList<>();\n+        \n+        Set<Integer> forcesInTracks = new HashSet<>();\n+        // assemble a set of all force IDs that are currently assigned to tracks that are not this one\n+        for (Contract contract : campaign.getActiveContracts()) {\n+            if (contract instanceof AtBContract) {\n+                for (StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    if ((track != currentTrack) || !reinforcements) {\n+                        forcesInTracks.addAll(track.getAssignedForceCoords().keySet());\n+                    }\n+                }\n+            }\n+        }\n+        \n+        for (int key : campaign.getLances().keySet()) {\n+            Force force = campaign.getForce(key);\n+            \n+            if (force == null) {\n+                continue;\n+            }\n+            \n+            int primaryUnitType = force.getPrimaryUnitType(campaign);\n+            if (!force.isDeployed() && \n+                    (force.getScenarioId() <= 0) &&\n+                    !force.getUnits().isEmpty() &&\n+                    !forcesInTracks.contains(force.getId()) &&\n+                    forceCompositionMatchesDeclaredUnitType(primaryUnitType, unitType, reinforcements)) {\n+                retVal.add(force.getId());\n+            }\n+        }\n+        \n+        return retVal;\n+    }\n+    \n+    /**\n+     * Returns a list of individual units eligible for deployment in scenarios run by \"Defend\" lances\n+     * @param campaign\n+     * @return List of unit IDs.\n+     */\n+    public static List<Unit> getEligibleDefensiveUnits(Campaign campaign) {\n+        List<Unit> retVal = new ArrayList<>();\n+        \n+        for(Unit u : campaign.getUnits()) {\n+            // \"defensive\" units are infantry, battle armor and (Weisman help you) gun emplacements\n+            if(((u.getEntity().getUnitType() == UnitType.INFANTRY) || ", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTcwMDIwOA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r595700208", "bodyText": "I'm not trying to do anything to the units, so I'm not sure why I'd use this particular pattern. But point taken about mothballed/uncrewed units (although gun emplacements are weird and sometimes can be deployed without crew in a MekHQ context - \"as autoturrets\")", "author": "NickAragua", "createdAt": "2021-03-17T04:14:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQwOTQxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQwOTc0OA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593409748", "bodyText": "This should use isDeployed instead.", "author": "sixlettervariables", "createdAt": "2021-03-12T19:46:39Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1080 @@\n+package mekhq.campaign.stratcon;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import megamek.common.Compute;\n+import megamek.common.Minefield;\n+import megamek.common.UnitType;\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.ResolveScenarioTracker;\n+import mekhq.campaign.againstTheBot.enums.AtBLanceRole;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.force.Lance;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier.EventTiming;\n+import mekhq.campaign.mission.atb.AtBScenarioModifierApplicator;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.unit.Unit;\n+\n+/**\n+ * This class contains \"rules\" logic for the AtB-Stratcon state\n+ * @author NickAragua\n+ *\n+ */\n+public class StratconRulesManager {\n+    public enum ReinforcementEligibilityType {\n+        None,\n+        ChainedScenario,\n+        SupportPoint,\n+        FightLance\n+    }\n+    \n+    /**\n+     * This function potentially generates non-player-initiated scenarios for the given track.\n+     * @param campaign\n+     * @param contract\n+     * @param track\n+     */\n+    public static void generateScenariosForTrack(Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // maps scenarios to force IDs\n+        List<StratconScenario> generatedScenarios = new ArrayList<>(); \n+        boolean autoAssignLances = contract.getCommandRights() == AtBContract.COM_INTEGRATED;\n+        \n+        // get this list just so we have it available\n+        List<Integer> availableForceIDs = getAvailableForceIDs(campaign);\n+        Map<MapLocation, List<Integer>> sortedAvailableForceIDs = sortForcesByMapType(availableForceIDs, campaign);\n+        \n+        // make X rolls, where X is the number of required lances for the track\n+        // that's the chance to spawn a scenario.\n+        // if a scenario occurs, then we pick a random non-deployed lance and use it to drive the opfor generation later\n+        // once we've determined that scenarios occur, we loop through the ones that we generated\n+        // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all \n+        for(int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            // if we haven't already used all the player forces and are required to randomly generate a scenario\n+            if((availableForceIDs.size() > 0) &&\n+                    (Compute.randomInt(100) <= track.getScenarioOdds())) {\n+                // pick random coordinates and force to drive the scenario\n+                int x = Compute.randomInt(track.getWidth());\n+                int y = Compute.randomInt(track.getHeight());                \n+                \n+                StratconCoords scenarioCoords = new StratconCoords(x, y);\n+                \n+                int randomForceIndex = Compute.randomInt(availableForceIDs.size());\n+                int randomForceID = availableForceIDs.get(randomForceIndex);\n+                \n+                // remove the force from the available lists so we don't designate it as primary twice\n+                availableForceIDs.remove(randomForceIndex); \n+                \n+                // we want to remove the actual int with the value, not the value at the index\n+                sortedAvailableForceIDs.get(MapLocation.AllGroundTerrain).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.LowAtmosphere).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.Space).remove((Integer) randomForceID);\n+                \n+                // two scenarios on the same coordinates wind up increasing in size\n+                if(track.getScenarios().containsKey(scenarioCoords)) {\n+                    track.getScenarios().get(scenarioCoords).incrementRequiredPlayerLances();\n+                    assignAppropriateExtraForceToScenario(track.getScenarios().get(scenarioCoords), sortedAvailableForceIDs, campaign);\n+                    continue;\n+                }\n+                \n+                StratconScenario scenario = setupScenario(scenarioCoords, randomForceID, campaign, contract, track);\n+                generatedScenarios.add(scenario);\n+                \n+                // if we're auto-assigning lances, deploy the force to the track as well\n+                if(autoAssignLances) {\n+                    processForceDeployment(scenarioCoords, randomForceID, campaign, track);\n+                }\n+            }\n+        }\n+        \n+        // if under liaison command, pick a random scenario from the ones generated\n+        // to set as required and attach liaison\n+        if(contract.getCommandRights() == AtBContract.COM_LIAISON) {\n+            int scenarioIndex = Compute.randomInt(generatedScenarios.size() - 1);\n+            generatedScenarios.get(scenarioIndex).setRequiredScenario(true);\n+            setAttachedUnitsModifier(generatedScenarios.get(scenarioIndex), contract);\n+        }\n+        \n+        // now, we loop through all the scenarios we set up\n+        // and generate the opfors / events / etc\n+        // if not auto-assigning lances, we then back out the lance assignments.\n+        for(StratconScenario scenario : generatedScenarios) {\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            \n+            if(!autoAssignLances) {\n+                for(int forceID : scenario.getPrimaryPlayerForceIDs()) {\n+                    scenario.getBackingScenario().removeForce(forceID);\n+                }\n+                \n+                scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                track.addScenario(scenario);\n+            } else {\n+                commitPrimaryForces(campaign, contract, scenario, track);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Deploys a force to the given coordinates on the given track as a result of explicit player action.\n+     */\n+    public static void deployForceToCoords(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // the following things should happen:\n+        // 1. call to \"process force deployment\", which reveals fog of war in or around the coords, depending on force role\n+        // 2. if coords are a hostile facility, we get a facility mission\n+        // 3. if coords are empty, we *may* get a mission\n+        \n+        processForceDeployment(coords, forceID, campaign, track);\n+        \n+        // don't create a scenario on top of allied facilities\n+        StratconFacility facility = track.getFacility(coords);\n+        boolean isNonAlliedFacility = (facility != null) && (facility.getOwner() != ForceAlignment.Allied);\n+        boolean spawnScenario = (facility == null) && (Compute.randomInt(100) <= track.getScenarioOdds());\n+\n+        if(isNonAlliedFacility || spawnScenario) {\n+            StratconScenario scenario = setupScenario(coords, forceID, campaign, contract, track);\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            commitPrimaryForces(campaign, contract, scenario, track);\n+        }\n+    }\n+    \n+    /**\n+     * Logic to set up a scenario\n+     */\n+    private static StratconScenario setupScenario(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        StratconScenario scenario = null;\n+        \n+        if(track.getFacilities().containsKey(coords)) {\n+            StratconFacility facility = track.getFacility(coords);\n+            boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+            ScenarioTemplate template = StratconScenarioFactory.getFacilityScenario(alliedFacility);\n+            scenario = generateScenario(campaign, contract, track, forceID, coords, template);\n+            setupFacilityScenario(scenario, track, coords, facility);\n+        } else {\n+            scenario = generateScenario(campaign, contract, track, forceID, coords);\n+            \n+            // we may generate a facility scenario randomly - if so, do the facility-related stuff\n+            // and add a new facility to the track\n+            if(scenario.getBackingScenario().getTemplate().isFacilityScenario()) {\n+                StratconFacility facility = scenario.getBackingScenario().getTemplate().isHostileFacility() ?\n+                        StratconFacilityFactory.getRandomHostileFacility() : StratconFacilityFactory.getRandomAlliedFacility();\n+                facility.setVisible(true);\n+                track.addFacility(coords, facility);\n+                setupFacilityScenario(scenario, track, coords, facility);\n+            }\n+        }\n+        \n+        return scenario;\n+    }\n+    \n+    /**\n+     * carries out tasks relevant to facility scenarios\n+     */\n+    private static void setupFacilityScenario(StratconScenario scenario, StratconTrackState track, StratconCoords coords, StratconFacility facility) {\n+        // this includes:\n+        // for hostile facilities\n+        // - add a destroy objective (always the option to level the facility)\n+        // - add a capture objective (always the option to capture the facility)\n+        // - if so indicated by parameter, roll a random hostile facility objective and add it if not capture/destroy\n+        // for allied facilities\n+        // - add a defend objective (always the option to defend the facility)\n+        // - if so indicated by parameter, roll a random allied facility objective and add it if not defend\n+        AtBScenarioModifier objectiveModifier = null;\n+        boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+        \n+        if(alliedFacility) {\n+            objectiveModifier = AtBScenarioModifier.getRandomAlliedFacilityModifier();\n+        } else {            \n+            objectiveModifier = AtBScenarioModifier.getRandomHostileFacilityModifier();\n+        }\n+        \n+        if(objectiveModifier != null) {\n+            scenario.getBackingScenario().addScenarioModifier(objectiveModifier);\n+            scenario.getBackingScenario().setName(String.format(\"%s - %s - %s\", \n+                    facility.getFacilityType(), alliedFacility ? \"Allied\" : \"Hostile\", objectiveModifier.getModifierName()));\n+        }\n+        \n+        // add the \"fixed\" hostile facility modifiers after the primary ones\n+        if(!alliedFacility) {\n+            for(AtBScenarioModifier modifier : AtBScenarioModifier.getRequiredHostileFacilityModifiers()) {\n+                if(!scenario.getBackingScenario().alreadyHasModifier(modifier)) {\n+                    scenario.getBackingScenario().addScenarioModifier(modifier);\n+                }\n+            }\n+        }\n+    }\n+    \n+    private static void processFacilityEffects(StratconTrackState track) {\n+        // todo: these are \"weekly\"? effects that a stratcon facility has on the campaign/track state\n+        // currrently, that's \n+        // supply depot - allied - +1 sp\n+        // supply depot - hostile - +5% BV budget to all scenarios on track (shared modifier, so should be implemented there)\n+        // data center - allied - +1% star league cache contract (don't implement yet, but...)\n+        // data center - hostile - +5% scenario odds in track\n+        // industrial center - allied - all scenarios here have THIS IS COMING OUT OF YOUR PAYCHECK modifier\n+        // orbital defense - allied - sets 'no hostile aircraft' flag for track\n+        // orbital defense - hostile - sets 'no allied aircraft' flag for track\n+        // early warning system - allied - sets 'intercept allied base attacks' flag for track\n+        // early warning system - hostile - sets 'intercept hostile base attacks' flag for track\n+    }\n+    \n+    /**\n+     * Process the deployment of a force to the given coordinates on the given track.\n+     */\n+    public static void processForceDeployment(StratconCoords coords, int forceID, Campaign campaign, StratconTrackState track) {\n+        track.getRevealedCoords().add(coords);\n+        StratconFacility facility = track.getFacility(coords);\n+        if(facility != null) {\n+            facility.setVisible(true);\n+        }\n+        \n+        if(campaign.getLances().get(forceID).getRole() == AtBLanceRole.SCOUTING) {\n+            for(int direction = 0; direction < 6; direction++) {\n+                StratconCoords checkCoords = coords.translate(direction);\n+                \n+                facility = track.getFacility(checkCoords);\n+                if(facility != null) {\n+                    facility.setVisible(true);\n+                }\n+                \n+                track.getRevealedCoords().add(coords.translate(direction));\n+            }\n+        }\n+        \n+        // the force may be located in other places on the track - clear it out\n+        track.unassignForce(forceID);\n+        track.assignForce(forceID, coords, campaign.getLocalDate());\n+    }\n+    \n+    /**\n+     * Worker function that processes the effects of deploying a reinforcement force to a scenario\n+     */\n+    public static boolean processReinforcementDeployment(ReinforcementEligibilityType reinforcementType, \n+            StratconCampaignState campaignState, StratconScenario scenario, Campaign campaign) {\n+        // if the force is already deployed to the track, we're done\n+        // if the force is a fight lance or we're using a support point\n+        // if there is an SP to burn, burn it and we're done\n+        // if there is a VP to burn, burn it and we're done\n+        // now, roll 2d6 + lance commander tactics\n+        // 9+ = deploy\n+        // 6+ = deploy, if lance != fight, track scenario odds up\n+        // 2+ = apply negative modifier to scenario\n+        \n+        if ((reinforcementType == ReinforcementEligibilityType.FightLance) ||\n+                (reinforcementType == ReinforcementEligibilityType.SupportPoint)) {\n+            \n+            if (campaignState.getSupportPoints() > 0) {\n+                campaignState.useSupportPoint();\n+                return true;\n+            } else if (campaignState.getVictoryPoints() > 0) {\n+                campaignState.updateVictoryPoints(-1);\n+                return true;\n+            }\n+            \n+            int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+            int roll = 7;//Compute.d6(2);\n+            int result = roll + tactics;\n+\n+            String reportStatus = String.format(\"Attempting to reinforce scenario %s without SP/VP, roll 2d6 + %d: %d\",\n+                    scenario.getName(), tactics, result);\n+            \n+            // fail to reinforce\n+            if (result < 6) {\n+                reportStatus += \" - reinforcement attempt failed.\";\n+                campaign.addReport(reportStatus);\n+                return false;\n+            // succeed but get an extra negative event added to the scenario\n+            } else if ((result < 9) && (reinforcementType != ReinforcementEligibilityType.FightLance)) {\n+                MapLocation mapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+                AtBScenarioModifier scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+                \n+                // keep rolling until we get an applicable one\n+                // todo: have the AtBScenarioModifier sort these out instead for performance?\n+                while (scenarioModifier.getEventTiming() != EventTiming.PostForceGeneration) {\n+                    scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+                }\n+                \n+                scenarioModifier.processModifier(scenario.getBackingScenario(), campaign, EventTiming.PostForceGeneration);\n+                \n+                reportStatus += String.format(\" - reinforcement attempt succeeded; extra negative modifier (%s) applied to scenario.\",\n+                        scenarioModifier.getModifierName());\n+                campaign.addReport(reportStatus);\n+                return true;\n+            // succeed without reservation\n+            } else {\n+                reportStatus += \" - reinforcement attempt succeeded;\";\n+                campaign.addReport(reportStatus);\n+                return true;\n+            }\n+        } else if (reinforcementType == ReinforcementEligibilityType.None) {\n+            return false;\n+        }\n+        \n+        return true;\n+    }\n+    \n+    /**\n+     * Assigns a force to the scenario such that the majority of the force can be deployed\n+     * @param scenario\n+     * @param sortedAvailableForceIDs\n+     */\n+    private static void assignAppropriateExtraForceToScenario(StratconScenario scenario, \n+            Map<MapLocation, List<Integer>> sortedAvailableForceIDs, Campaign campaign) {\n+        // the goal of this function is to avoid assigning ground units to air battles\n+        // and ground units/conventional fighters to space battle\n+        \n+        List<MapLocation> mapLocations = new ArrayList<>();\n+        mapLocations.add(MapLocation.Space); // can always add ASFs\n+        \n+        MapLocation scenarioMapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+        \n+        if(scenarioMapLocation == MapLocation.LowAtmosphere) {\n+            mapLocations.add(MapLocation.LowAtmosphere); // can add conventional fighters to ground or low atmo battles\n+        }\n+        \n+        if((scenarioMapLocation == MapLocation.AllGroundTerrain) || \n+                (scenarioMapLocation == MapLocation.SpecificGroundTerrain)) {\n+            mapLocations.add(MapLocation.AllGroundTerrain); // can only add ground units to ground battles\n+        }\n+        \n+        MapLocation selectedLocation = mapLocations.get(Compute.randomInt(mapLocations.size()));\n+        List<Integer> forceIDs = sortedAvailableForceIDs.get(selectedLocation);\n+        int forceIndex = Compute.randomInt(forceIDs.size());\n+        int forceID = forceIDs.get(forceIndex);\n+        forceIDs.remove(forceIndex);\n+        \n+        scenario.addPrimaryForce(forceID);\n+    }\n+    \n+    /**\n+     * Worker function that \"locks in\" a scenario - \n+     * Adds it to the campaign so it's visible in the briefing room,\n+     * adds it to the track\n+     * \n+     */\n+    public static void commitPrimaryForces(Campaign campaign, AtBContract contract, StratconScenario scenario, StratconTrackState trackState) {\n+        // order of operations is important here, we need a valid scenario ID prior to adding the scenario to the track.\n+        campaign.addScenario(scenario.getBackingScenario(), contract);\n+        scenario.setBackingScenarioID(scenario.getBackingScenario().getId());\n+        trackState.addScenario(scenario);\n+        \n+        // set up dates for the scenario if doesn't have them already\n+        if(scenario.getDeploymentDate() == null) {\n+            scenario.setDeploymentDate(campaign.getLocalDate());\n+        }\n+        \n+        if(scenario.getActionDate() == null) {\n+            scenario.setActionDate(campaign.getLocalDate());\n+        }\n+        \n+        if(scenario.getReturnDate() == null) {\n+            scenario.setReturnDate(campaign.getLocalDate().plusDays(trackState.getDeploymentTime()));\n+        }\n+        \n+        // set the # of rerolls based on the actual lance assigned.\n+        int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+        scenario.getBackingScenario().setRerolls(tactics);\n+        // The number of defensive points available to a force entering a scenario is\n+        // 2 x tactics. By default, those points are spent on conventional minefields.\n+        if (commanderLanceHasDefensiveAssignment(scenario.getBackingScenario(), campaign)) {\n+            scenario.setNumDefensivePoints(tactics * 2);\n+            scenario.updateMinefieldCount(Minefield.TYPE_CONVENTIONAL, tactics * 2);\n+        }\n+        \n+        for (int forceID : scenario.getPrimaryPlayerForceIDs()) {\n+            Force force = campaign.getForce(forceID);\n+            force.clearScenarioIds(campaign, true);\n+            force.setScenarioId(scenario.getBackingScenarioID());\n+        }\n+        \n+        scenario.commitPrimaryForces(campaign, contract);\n+    }\n+    \n+    /**\n+     * Utility method to determine if the current scenario's force commander\n+     * is on defence \n+     */\n+    private static boolean commanderLanceHasDefensiveAssignment(AtBDynamicScenario scenario, Campaign campaign) {\n+        Unit commanderUnit = scenario.getLanceCommander(campaign).getUnit();\n+        Lance lance = campaign.getLances().get(commanderUnit.getForceId());\n+        \n+        if ((lance != null) && (lance.getRole() == AtBLanceRole.DEFENCE)) {\n+            return true;\n+        }\n+        \n+        return false;\n+    }\n+    \n+    /**\n+     * A hackish worker function that takes the given list of force IDs and\n+     * separates it into three sets;\n+     * one of forces that can be \"primary\" on a ground map\n+     * one of forces that can be \"primary\" on an atmospheric map\n+     * one of forces that can be \"primary\" in a space map\n+     * @param forceIDs List of force IDs to check\n+     * @return Sorted hash map\n+     */\n+    private static Map<MapLocation, List<Integer>> sortForcesByMapType(List<Integer> forceIDs, Campaign campaign) {\n+        Map<MapLocation, List<Integer>> retVal = new HashMap<>();\n+        \n+        retVal.put(MapLocation.AllGroundTerrain, new ArrayList<>());\n+        retVal.put(MapLocation.LowAtmosphere, new ArrayList<>());\n+        retVal.put(MapLocation.Space, new ArrayList<>());\n+        \n+        for(int forceID : forceIDs) {\n+            switch(campaign.getForce(forceID).getPrimaryUnitType(campaign)) {\n+            case UnitType.BATTLE_ARMOR:\n+            case UnitType.INFANTRY:\n+            case UnitType.MEK:\n+            case UnitType.TANK:\n+            case UnitType.PROTOMEK:\n+            case UnitType.VTOL:\n+                retVal.get(MapLocation.AllGroundTerrain).add(forceID);\n+                break;\n+            case UnitType.AERO:\n+                retVal.get(MapLocation.Space).add(forceID);\n+                // intentional fallthrough here, ASFs can go to atmospheric maps too\n+            case UnitType.CONV_FIGHTER:\n+                retVal.get(MapLocation.LowAtmosphere).add(forceID);\n+                break;\n+            }\n+        }\n+        \n+        \n+        return retVal;\n+    }\n+    \n+    /**\n+     * Determine whether the user should be nagged about unresolved scenarios on AtB Stratcon tracks.\n+     * @param campaign Campaign to check.\n+     * @return An informative string containing the reasons the user was nagged.\n+     */\n+    public static String nagUnresolvedContacts(Campaign campaign) {\n+        StringBuilder sb = new StringBuilder();\n+        \n+        // check every track attached to an active contract for unresolved scenarios\n+        // to which the player must deploy forces today\n+        for(Contract contract : campaign.getActiveContracts()) {\n+            if(contract instanceof AtBContract) {\n+                for(StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    for(StratconScenario scenario : track.getScenarios().values()) {\n+                        if(scenario.getCurrentState() == ScenarioState.UNRESOLVED &&\n+                                campaign.getLocalDate().equals(scenario.getDeploymentDate())) {\n+                            // \"scenario name, track name\"\n+                            sb.append(String.format(\"%s, %s\\n\", scenario.getName(), track.getDisplayableName()));\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        \n+        return sb.toString();\n+    }\n+    \n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track.\n+     * Also registers it with the track and campaign.\n+     */\n+    private static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track, \n+            int forceID, StratconCoords coords) {\n+        int unitType = campaign.getForce(forceID).getPrimaryUnitType(campaign);\n+        ScenarioTemplate template = StratconScenarioFactory.getRandomScenario(unitType);\n+        // useful for debugging specific scenario types\n+        //ScenarioTemplate template = StratconScenarioFactory.getSpecificScenario(\"Hostile Facility.xml\");\n+        \n+        return generateScenario(campaign, contract, track, forceID, coords, template);\n+    }\n+    \n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track,\n+     * using the given template. Also registers it with the track and campaign.\n+     */\n+    static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track, \n+            int forceID, StratconCoords coords, ScenarioTemplate template) {\n+        StratconScenario scenario = new StratconScenario();\n+        scenario.setBackingScenario(AtBDynamicScenarioFactory.initializeScenarioFromTemplate(template, contract, campaign));\n+        scenario.setCoords(coords);\n+        \n+        // do an appropriate allied force if the contract calls for it\n+        // do any attached or integrated units\n+        setAlliedForceModifier(scenario, contract);\n+        setAttachedUnitsModifier(scenario, contract);\n+        applyFacilityModifiers(scenario, track, coords);\n+        applyGlobalModifiers(scenario, contract.getStratconCampaignState());\n+        \n+        if((contract.getCommandRights() == AtBContract.COM_HOUSE) ||\n+                (contract.getCommandRights() == AtBContract.COM_INTEGRATED)) {\n+            scenario.setRequiredScenario(true);\n+        }\n+        \n+        AtBDynamicScenarioFactory.setScenarioModifiers(scenario.getBackingScenario());\n+        scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+        setScenarioDates(track, campaign, scenario);\n+        \n+        // register the scenario with the campaign and the track it's generated on\n+        if (forceID > Force.FORCE_NONE) {\n+            scenario.addPrimaryForce(forceID);\n+        }\n+        \n+        return scenario;\n+    }\n+    \n+    /**\n+     * Apply global scenario modifiers from campaign state to given scenario.\n+     */\n+    private static void applyGlobalModifiers(StratconScenario scenario, StratconCampaignState campaignState) {\n+        for (String modifierName : campaignState.getGlobalScenarioModifiers()) {\n+            AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierName);\n+            \n+            if (modifier == null) {\n+                MekHQ.getLogger().error(String.format(\"Modifier %s not found; ignoring\", modifierName));\n+                continue;\n+            }\n+            \n+            scenario.getBackingScenario().addScenarioModifier(modifier);\n+        }\n+    }\n+    \n+    /**\n+     * Applies scenario modifiers from the current track to the given scenario.\n+     * @param scenario\n+     * @param track\n+     */\n+    private static void applyFacilityModifiers(StratconScenario scenario, StratconTrackState track, StratconCoords coords) {\n+        // loop through all the facilities on the track\n+        // if a facility has been revealed, then it has a 100% chance to apply its effect\n+        // if a facility has not been revealed, then it has a x% chance to apply its effect\n+        // if a facility is on the the scenario coordinates the it applies the local effects\n+        for (StratconCoords facilityCoords : track.getFacilities().keySet()) {\n+            boolean scenarioAtFacility = facilityCoords.equals(coords);\n+            StratconFacility facility = track.getFacilities().get(facilityCoords);\n+            List<String> modifierIDs = new ArrayList<>();\n+            \n+            if (scenarioAtFacility) {\n+                modifierIDs = facility.getLocalModifiers();\n+            } else if (facility.isVisible() || (Compute.randomInt(100) < facility.getAggroRating())) {\n+                modifierIDs = facility.getSharedModifiers();\n+            }\n+            \n+            for (String modifierID : modifierIDs) {\n+                AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierID);\n+                if(modifier == null) {\n+                    MekHQ.getLogger().error(String.format(\"Modifier %s not found for facility %s\", modifierID, facility.getFormattedDisplayableName()));\n+                    continue;\n+                }\n+                \n+                scenario.getBackingScenario().addScenarioModifier(modifier);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Set up the appropriate primary allied force modifier, if any \n+     * @param contract The scenario's contract.\n+     */\n+    private static void setAlliedForceModifier(StratconScenario scenario, AtBContract contract) {\n+        int alliedUnitOdds = 0;\n+        \n+        // first, we determine the odds of having an allied unit present\n+        // TODO: move this override out to the contract definition\n+        if (contract.getMissionType() == AtBContract.MT_RELIEFDUTY) {\n+            alliedUnitOdds = 50;\n+        } else {\n+            switch(contract.getCommandRights()) {\n+            case AtBContract.COM_INTEGRATED:\n+                alliedUnitOdds = 50;\n+                break;\n+            case AtBContract.COM_HOUSE:\n+                alliedUnitOdds = 30;\n+                break;\n+            case AtBContract.COM_LIAISON:\n+                alliedUnitOdds = 10;\n+                break;\n+            }\n+        }\n+        \n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+        \n+        // if an allied unit is present, then we want to make sure that it's ground units\n+        // for ground battles\n+        if (Compute.randomInt(100) <= alliedUnitOdds) {\n+            if((backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+               (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space)) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_ALLIED_AIR_UNITS));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_ALLIED_GROUND_UNITS));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set the 'attached' units modifier for the current scenario (integrated, house, liaison),\n+     * and make sure we're not deploying ground units to an air scenario\n+     * @param contract The scenario's contract\n+     */\n+    public static void setAttachedUnitsModifier(StratconScenario scenario, AtBContract contract) {\n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+        boolean airBattle = (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+                (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space);\n+        \n+        // if we're on cadre duty, we're getting three trainees, period\n+        if(contract.getMissionType() == AtBContract.MT_CADREDUTY) {\n+            if(airBattle) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_TRAINEES_AIR));                \n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_TRAINEES_GROUND));\n+            }\n+            return;\n+        }\n+        \n+        // if we're under non-independent command rights, a supervisor may come along\n+        switch(contract.getCommandRights()) {\n+        case AtBContract.COM_INTEGRATED:\n+            if(airBattle) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_INTEGRATED_UNITS_AIR));                \n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_INTEGRATED_UNITS_GROUND));\n+            }\n+            break;\n+        case AtBContract.COM_HOUSE:\n+            if(airBattle) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_HOUSE_CO_AIR));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_HOUSE_CO_GROUND));\n+            }            \n+            break;\n+        case AtBContract.COM_LIAISON:\n+            if(scenario.isRequiredScenario()) {\n+                if(airBattle) {\n+                    backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_LIAISON_AIR));\n+                } else {\n+                    backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_LIAISON_GROUND));\n+                } \n+            }\n+            break;\n+        }\n+    }\n+    \n+    /**\n+     * Worker function that sets scenario deploy/battle/return dates based on the track's properties and current campaign date\n+     * @param track\n+     * @param campaign\n+     * @param scenario\n+     */\n+    private static void setScenarioDates(StratconTrackState track, Campaign campaign, StratconScenario scenario) {\n+     // set up deployment day, battle day, return day here\n+        // safety code to prevent attempts to generate random int with upper bound of 0 which is apparently illegal\n+        int deploymentDay = track.getDeploymentTime() < 7 ? Compute.randomInt(7 - track.getDeploymentTime()) : 0;\n+        int battleDay = deploymentDay + (track.getDeploymentTime() > 0 ? Compute.randomInt(track.getDeploymentTime()) : 0);\n+        int returnDay = deploymentDay + track.getDeploymentTime();\n+        \n+        LocalDate deploymentDate = campaign.getLocalDate();\n+        deploymentDate.plusDays(deploymentDay);\n+        LocalDate battleDate = campaign.getLocalDate();\n+        deploymentDate.plusDays(battleDay);\n+        LocalDate returnDate = campaign.getLocalDate();\n+        returnDate.plusDays(returnDay);\n+        \n+        scenario.setDeploymentDate(deploymentDate);\n+        scenario.setActionDate(battleDate);\n+        scenario.setReturnDate(returnDate);\n+    }\n+    \n+    /**\n+     * Helper function that determines if the unit type specified in the given scenario force template\n+     * would start out airborne on a ground map (hot dropped units aside)\n+     * @param template\n+     * @return\n+     */\n+    private static boolean unitTypeIsAirborne(ScenarioForceTemplate template) {\n+        int unitType = template.getAllowedUnitType();\n+        \n+        return (unitType == UnitType.AERO ||\n+                unitType == UnitType.CONV_FIGHTER ||\n+                unitType == UnitType.DROPSHIP ||\n+                unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_MIX) &&\n+                template.getStartingAltitude() > 0;\n+    }\n+    \n+    /**\n+     * Determines whether the force in question has the same primary unit type as the force template.\n+     * @return Whether or not the unit types match.\n+     */\n+    public static boolean forceCompositionMatchesDeclaredUnitType(int primaryUnitType, int unitType, boolean reinforcements) {        \n+        // special cases are \"ATB_MIX\" and \"ATB_AERO_MIX\", which encompass multiple unit types\n+        if(unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_MIX) {\n+            // \"AtB mix\" is usually ground units, but air units can sub in\n+            return primaryUnitType == UnitType.MEK ||\n+                    primaryUnitType == UnitType.TANK ||\n+                    primaryUnitType == UnitType.INFANTRY ||\n+                    primaryUnitType == UnitType.BATTLE_ARMOR ||\n+                    primaryUnitType == UnitType.PROTOMEK || \n+                    primaryUnitType == UnitType.VTOL ||\n+                    (primaryUnitType == UnitType.AERO) && reinforcements ||\n+                    (primaryUnitType == UnitType.CONV_FIGHTER) && reinforcements;\n+        } else if (unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_AERO_MIX) {\n+            return primaryUnitType == UnitType.AERO ||\n+                    primaryUnitType == UnitType.CONV_FIGHTER;\n+        } else {\n+            return primaryUnitType == unitType;\n+        }\n+    }\n+    \n+    /**\n+     * This is a set of all force IDs for forces that can be deployed to a scenario.\n+     * @param campaign Current campaign\n+     * @return Set of available force IDs.\n+     */\n+    public static List<Integer> getAvailableForceIDs(Campaign campaign) {\n+        List<Integer> retVal = new ArrayList<>();\n+        \n+        // first, we gather a set of all forces that are already deployed to a track so we eliminate those later\n+        Set<Integer> forcesInTracks = new HashSet<>();\n+        for(Contract contract : campaign.getActiveContracts()) {\n+            if(contract instanceof AtBContract) {\n+                for(StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    forcesInTracks.addAll(track.getAssignedForceCoords().keySet());\n+                }\n+            }\n+        }\n+        \n+        // now, we get all the forces that qualify as \"lances\", and filter out those that are\n+        // deployed to a scenario and not in a track already\n+        for(int key : campaign.getLances().keySet()) {\n+            Force force = campaign.getForce(key);\n+            if(force != null && \n+                    !force.isDeployed() && \n+                    (force.getScenarioId() <= 0) &&\n+                    !forcesInTracks.contains(force.getId())) {\n+                retVal.add(force.getId());\n+            }\n+        }\n+        \n+        return retVal;\n+    }\n+    \n+    /**\n+     * This is a list of all force IDs for forces that can be deployed to a scenario in the given force template\n+     * a) have not been assigned to a track\n+     * b) are combat-capable\n+     * c) are not deployed to a scenario\n+     */\n+    public static List<Integer> getAvailableForceIDs(int unitType, Campaign campaign, StratconTrackState currentTrack, \n+            boolean reinforcements) {\n+        List<Integer> retVal = new ArrayList<>();\n+        \n+        Set<Integer> forcesInTracks = new HashSet<>();\n+        // assemble a set of all force IDs that are currently assigned to tracks that are not this one\n+        for (Contract contract : campaign.getActiveContracts()) {\n+            if (contract instanceof AtBContract) {\n+                for (StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    if ((track != currentTrack) || !reinforcements) {\n+                        forcesInTracks.addAll(track.getAssignedForceCoords().keySet());\n+                    }\n+                }\n+            }\n+        }\n+        \n+        for (int key : campaign.getLances().keySet()) {\n+            Force force = campaign.getForce(key);\n+            \n+            if (force == null) {\n+                continue;\n+            }\n+            \n+            int primaryUnitType = force.getPrimaryUnitType(campaign);\n+            if (!force.isDeployed() && \n+                    (force.getScenarioId() <= 0) &&\n+                    !force.getUnits().isEmpty() &&\n+                    !forcesInTracks.contains(force.getId()) &&\n+                    forceCompositionMatchesDeclaredUnitType(primaryUnitType, unitType, reinforcements)) {\n+                retVal.add(force.getId());\n+            }\n+        }\n+        \n+        return retVal;\n+    }\n+    \n+    /**\n+     * Returns a list of individual units eligible for deployment in scenarios run by \"Defend\" lances\n+     * @param campaign\n+     * @return List of unit IDs.\n+     */\n+    public static List<Unit> getEligibleDefensiveUnits(Campaign campaign) {\n+        List<Unit> retVal = new ArrayList<>();\n+        \n+        for(Unit u : campaign.getUnits()) {\n+            // \"defensive\" units are infantry, battle armor and (Weisman help you) gun emplacements\n+            if(((u.getEntity().getUnitType() == UnitType.INFANTRY) || \n+                    (u.getEntity().getUnitType() == UnitType.BATTLE_ARMOR) ||\n+                    (u.getEntity().getUnitType() == UnitType.GUN_EMPLACEMENT)) &&\n+                    (u.getScenarioId() <= 0)) {", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQxMDU5Nw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593410597", "bodyText": "I think this registration should be moved elsewhere rather than the constructor. Its an odd side effect to have here.", "author": "sixlettervariables", "createdAt": "2021-03-12T19:48:07Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1080 @@\n+package mekhq.campaign.stratcon;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import megamek.common.Compute;\n+import megamek.common.Minefield;\n+import megamek.common.UnitType;\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.ResolveScenarioTracker;\n+import mekhq.campaign.againstTheBot.enums.AtBLanceRole;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.force.Lance;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier.EventTiming;\n+import mekhq.campaign.mission.atb.AtBScenarioModifierApplicator;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.unit.Unit;\n+\n+/**\n+ * This class contains \"rules\" logic for the AtB-Stratcon state\n+ * @author NickAragua\n+ *\n+ */\n+public class StratconRulesManager {\n+    public enum ReinforcementEligibilityType {\n+        None,\n+        ChainedScenario,\n+        SupportPoint,\n+        FightLance\n+    }\n+    \n+    /**\n+     * This function potentially generates non-player-initiated scenarios for the given track.\n+     * @param campaign\n+     * @param contract\n+     * @param track\n+     */\n+    public static void generateScenariosForTrack(Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // maps scenarios to force IDs\n+        List<StratconScenario> generatedScenarios = new ArrayList<>(); \n+        boolean autoAssignLances = contract.getCommandRights() == AtBContract.COM_INTEGRATED;\n+        \n+        // get this list just so we have it available\n+        List<Integer> availableForceIDs = getAvailableForceIDs(campaign);\n+        Map<MapLocation, List<Integer>> sortedAvailableForceIDs = sortForcesByMapType(availableForceIDs, campaign);\n+        \n+        // make X rolls, where X is the number of required lances for the track\n+        // that's the chance to spawn a scenario.\n+        // if a scenario occurs, then we pick a random non-deployed lance and use it to drive the opfor generation later\n+        // once we've determined that scenarios occur, we loop through the ones that we generated\n+        // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all \n+        for(int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            // if we haven't already used all the player forces and are required to randomly generate a scenario\n+            if((availableForceIDs.size() > 0) &&\n+                    (Compute.randomInt(100) <= track.getScenarioOdds())) {\n+                // pick random coordinates and force to drive the scenario\n+                int x = Compute.randomInt(track.getWidth());\n+                int y = Compute.randomInt(track.getHeight());                \n+                \n+                StratconCoords scenarioCoords = new StratconCoords(x, y);\n+                \n+                int randomForceIndex = Compute.randomInt(availableForceIDs.size());\n+                int randomForceID = availableForceIDs.get(randomForceIndex);\n+                \n+                // remove the force from the available lists so we don't designate it as primary twice\n+                availableForceIDs.remove(randomForceIndex); \n+                \n+                // we want to remove the actual int with the value, not the value at the index\n+                sortedAvailableForceIDs.get(MapLocation.AllGroundTerrain).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.LowAtmosphere).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.Space).remove((Integer) randomForceID);\n+                \n+                // two scenarios on the same coordinates wind up increasing in size\n+                if(track.getScenarios().containsKey(scenarioCoords)) {\n+                    track.getScenarios().get(scenarioCoords).incrementRequiredPlayerLances();\n+                    assignAppropriateExtraForceToScenario(track.getScenarios().get(scenarioCoords), sortedAvailableForceIDs, campaign);\n+                    continue;\n+                }\n+                \n+                StratconScenario scenario = setupScenario(scenarioCoords, randomForceID, campaign, contract, track);\n+                generatedScenarios.add(scenario);\n+                \n+                // if we're auto-assigning lances, deploy the force to the track as well\n+                if(autoAssignLances) {\n+                    processForceDeployment(scenarioCoords, randomForceID, campaign, track);\n+                }\n+            }\n+        }\n+        \n+        // if under liaison command, pick a random scenario from the ones generated\n+        // to set as required and attach liaison\n+        if(contract.getCommandRights() == AtBContract.COM_LIAISON) {\n+            int scenarioIndex = Compute.randomInt(generatedScenarios.size() - 1);\n+            generatedScenarios.get(scenarioIndex).setRequiredScenario(true);\n+            setAttachedUnitsModifier(generatedScenarios.get(scenarioIndex), contract);\n+        }\n+        \n+        // now, we loop through all the scenarios we set up\n+        // and generate the opfors / events / etc\n+        // if not auto-assigning lances, we then back out the lance assignments.\n+        for(StratconScenario scenario : generatedScenarios) {\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            \n+            if(!autoAssignLances) {\n+                for(int forceID : scenario.getPrimaryPlayerForceIDs()) {\n+                    scenario.getBackingScenario().removeForce(forceID);\n+                }\n+                \n+                scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                track.addScenario(scenario);\n+            } else {\n+                commitPrimaryForces(campaign, contract, scenario, track);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Deploys a force to the given coordinates on the given track as a result of explicit player action.\n+     */\n+    public static void deployForceToCoords(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // the following things should happen:\n+        // 1. call to \"process force deployment\", which reveals fog of war in or around the coords, depending on force role\n+        // 2. if coords are a hostile facility, we get a facility mission\n+        // 3. if coords are empty, we *may* get a mission\n+        \n+        processForceDeployment(coords, forceID, campaign, track);\n+        \n+        // don't create a scenario on top of allied facilities\n+        StratconFacility facility = track.getFacility(coords);\n+        boolean isNonAlliedFacility = (facility != null) && (facility.getOwner() != ForceAlignment.Allied);\n+        boolean spawnScenario = (facility == null) && (Compute.randomInt(100) <= track.getScenarioOdds());\n+\n+        if(isNonAlliedFacility || spawnScenario) {\n+            StratconScenario scenario = setupScenario(coords, forceID, campaign, contract, track);\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            commitPrimaryForces(campaign, contract, scenario, track);\n+        }\n+    }\n+    \n+    /**\n+     * Logic to set up a scenario\n+     */\n+    private static StratconScenario setupScenario(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        StratconScenario scenario = null;\n+        \n+        if(track.getFacilities().containsKey(coords)) {\n+            StratconFacility facility = track.getFacility(coords);\n+            boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+            ScenarioTemplate template = StratconScenarioFactory.getFacilityScenario(alliedFacility);\n+            scenario = generateScenario(campaign, contract, track, forceID, coords, template);\n+            setupFacilityScenario(scenario, track, coords, facility);\n+        } else {\n+            scenario = generateScenario(campaign, contract, track, forceID, coords);\n+            \n+            // we may generate a facility scenario randomly - if so, do the facility-related stuff\n+            // and add a new facility to the track\n+            if(scenario.getBackingScenario().getTemplate().isFacilityScenario()) {\n+                StratconFacility facility = scenario.getBackingScenario().getTemplate().isHostileFacility() ?\n+                        StratconFacilityFactory.getRandomHostileFacility() : StratconFacilityFactory.getRandomAlliedFacility();\n+                facility.setVisible(true);\n+                track.addFacility(coords, facility);\n+                setupFacilityScenario(scenario, track, coords, facility);\n+            }\n+        }\n+        \n+        return scenario;\n+    }\n+    \n+    /**\n+     * carries out tasks relevant to facility scenarios\n+     */\n+    private static void setupFacilityScenario(StratconScenario scenario, StratconTrackState track, StratconCoords coords, StratconFacility facility) {\n+        // this includes:\n+        // for hostile facilities\n+        // - add a destroy objective (always the option to level the facility)\n+        // - add a capture objective (always the option to capture the facility)\n+        // - if so indicated by parameter, roll a random hostile facility objective and add it if not capture/destroy\n+        // for allied facilities\n+        // - add a defend objective (always the option to defend the facility)\n+        // - if so indicated by parameter, roll a random allied facility objective and add it if not defend\n+        AtBScenarioModifier objectiveModifier = null;\n+        boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+        \n+        if(alliedFacility) {\n+            objectiveModifier = AtBScenarioModifier.getRandomAlliedFacilityModifier();\n+        } else {            \n+            objectiveModifier = AtBScenarioModifier.getRandomHostileFacilityModifier();\n+        }\n+        \n+        if(objectiveModifier != null) {\n+            scenario.getBackingScenario().addScenarioModifier(objectiveModifier);\n+            scenario.getBackingScenario().setName(String.format(\"%s - %s - %s\", \n+                    facility.getFacilityType(), alliedFacility ? \"Allied\" : \"Hostile\", objectiveModifier.getModifierName()));\n+        }\n+        \n+        // add the \"fixed\" hostile facility modifiers after the primary ones\n+        if(!alliedFacility) {\n+            for(AtBScenarioModifier modifier : AtBScenarioModifier.getRequiredHostileFacilityModifiers()) {\n+                if(!scenario.getBackingScenario().alreadyHasModifier(modifier)) {\n+                    scenario.getBackingScenario().addScenarioModifier(modifier);\n+                }\n+            }\n+        }\n+    }\n+    \n+    private static void processFacilityEffects(StratconTrackState track) {\n+        // todo: these are \"weekly\"? effects that a stratcon facility has on the campaign/track state\n+        // currrently, that's \n+        // supply depot - allied - +1 sp\n+        // supply depot - hostile - +5% BV budget to all scenarios on track (shared modifier, so should be implemented there)\n+        // data center - allied - +1% star league cache contract (don't implement yet, but...)\n+        // data center - hostile - +5% scenario odds in track\n+        // industrial center - allied - all scenarios here have THIS IS COMING OUT OF YOUR PAYCHECK modifier\n+        // orbital defense - allied - sets 'no hostile aircraft' flag for track\n+        // orbital defense - hostile - sets 'no allied aircraft' flag for track\n+        // early warning system - allied - sets 'intercept allied base attacks' flag for track\n+        // early warning system - hostile - sets 'intercept hostile base attacks' flag for track\n+    }\n+    \n+    /**\n+     * Process the deployment of a force to the given coordinates on the given track.\n+     */\n+    public static void processForceDeployment(StratconCoords coords, int forceID, Campaign campaign, StratconTrackState track) {\n+        track.getRevealedCoords().add(coords);\n+        StratconFacility facility = track.getFacility(coords);\n+        if(facility != null) {\n+            facility.setVisible(true);\n+        }\n+        \n+        if(campaign.getLances().get(forceID).getRole() == AtBLanceRole.SCOUTING) {\n+            for(int direction = 0; direction < 6; direction++) {\n+                StratconCoords checkCoords = coords.translate(direction);\n+                \n+                facility = track.getFacility(checkCoords);\n+                if(facility != null) {\n+                    facility.setVisible(true);\n+                }\n+                \n+                track.getRevealedCoords().add(coords.translate(direction));\n+            }\n+        }\n+        \n+        // the force may be located in other places on the track - clear it out\n+        track.unassignForce(forceID);\n+        track.assignForce(forceID, coords, campaign.getLocalDate());\n+    }\n+    \n+    /**\n+     * Worker function that processes the effects of deploying a reinforcement force to a scenario\n+     */\n+    public static boolean processReinforcementDeployment(ReinforcementEligibilityType reinforcementType, \n+            StratconCampaignState campaignState, StratconScenario scenario, Campaign campaign) {\n+        // if the force is already deployed to the track, we're done\n+        // if the force is a fight lance or we're using a support point\n+        // if there is an SP to burn, burn it and we're done\n+        // if there is a VP to burn, burn it and we're done\n+        // now, roll 2d6 + lance commander tactics\n+        // 9+ = deploy\n+        // 6+ = deploy, if lance != fight, track scenario odds up\n+        // 2+ = apply negative modifier to scenario\n+        \n+        if ((reinforcementType == ReinforcementEligibilityType.FightLance) ||\n+                (reinforcementType == ReinforcementEligibilityType.SupportPoint)) {\n+            \n+            if (campaignState.getSupportPoints() > 0) {\n+                campaignState.useSupportPoint();\n+                return true;\n+            } else if (campaignState.getVictoryPoints() > 0) {\n+                campaignState.updateVictoryPoints(-1);\n+                return true;\n+            }\n+            \n+            int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+            int roll = 7;//Compute.d6(2);\n+            int result = roll + tactics;\n+\n+            String reportStatus = String.format(\"Attempting to reinforce scenario %s without SP/VP, roll 2d6 + %d: %d\",\n+                    scenario.getName(), tactics, result);\n+            \n+            // fail to reinforce\n+            if (result < 6) {\n+                reportStatus += \" - reinforcement attempt failed.\";\n+                campaign.addReport(reportStatus);\n+                return false;\n+            // succeed but get an extra negative event added to the scenario\n+            } else if ((result < 9) && (reinforcementType != ReinforcementEligibilityType.FightLance)) {\n+                MapLocation mapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+                AtBScenarioModifier scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+                \n+                // keep rolling until we get an applicable one\n+                // todo: have the AtBScenarioModifier sort these out instead for performance?\n+                while (scenarioModifier.getEventTiming() != EventTiming.PostForceGeneration) {\n+                    scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+                }\n+                \n+                scenarioModifier.processModifier(scenario.getBackingScenario(), campaign, EventTiming.PostForceGeneration);\n+                \n+                reportStatus += String.format(\" - reinforcement attempt succeeded; extra negative modifier (%s) applied to scenario.\",\n+                        scenarioModifier.getModifierName());\n+                campaign.addReport(reportStatus);\n+                return true;\n+            // succeed without reservation\n+            } else {\n+                reportStatus += \" - reinforcement attempt succeeded;\";\n+                campaign.addReport(reportStatus);\n+                return true;\n+            }\n+        } else if (reinforcementType == ReinforcementEligibilityType.None) {\n+            return false;\n+        }\n+        \n+        return true;\n+    }\n+    \n+    /**\n+     * Assigns a force to the scenario such that the majority of the force can be deployed\n+     * @param scenario\n+     * @param sortedAvailableForceIDs\n+     */\n+    private static void assignAppropriateExtraForceToScenario(StratconScenario scenario, \n+            Map<MapLocation, List<Integer>> sortedAvailableForceIDs, Campaign campaign) {\n+        // the goal of this function is to avoid assigning ground units to air battles\n+        // and ground units/conventional fighters to space battle\n+        \n+        List<MapLocation> mapLocations = new ArrayList<>();\n+        mapLocations.add(MapLocation.Space); // can always add ASFs\n+        \n+        MapLocation scenarioMapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+        \n+        if(scenarioMapLocation == MapLocation.LowAtmosphere) {\n+            mapLocations.add(MapLocation.LowAtmosphere); // can add conventional fighters to ground or low atmo battles\n+        }\n+        \n+        if((scenarioMapLocation == MapLocation.AllGroundTerrain) || \n+                (scenarioMapLocation == MapLocation.SpecificGroundTerrain)) {\n+            mapLocations.add(MapLocation.AllGroundTerrain); // can only add ground units to ground battles\n+        }\n+        \n+        MapLocation selectedLocation = mapLocations.get(Compute.randomInt(mapLocations.size()));\n+        List<Integer> forceIDs = sortedAvailableForceIDs.get(selectedLocation);\n+        int forceIndex = Compute.randomInt(forceIDs.size());\n+        int forceID = forceIDs.get(forceIndex);\n+        forceIDs.remove(forceIndex);\n+        \n+        scenario.addPrimaryForce(forceID);\n+    }\n+    \n+    /**\n+     * Worker function that \"locks in\" a scenario - \n+     * Adds it to the campaign so it's visible in the briefing room,\n+     * adds it to the track\n+     * \n+     */\n+    public static void commitPrimaryForces(Campaign campaign, AtBContract contract, StratconScenario scenario, StratconTrackState trackState) {\n+        // order of operations is important here, we need a valid scenario ID prior to adding the scenario to the track.\n+        campaign.addScenario(scenario.getBackingScenario(), contract);\n+        scenario.setBackingScenarioID(scenario.getBackingScenario().getId());\n+        trackState.addScenario(scenario);\n+        \n+        // set up dates for the scenario if doesn't have them already\n+        if(scenario.getDeploymentDate() == null) {\n+            scenario.setDeploymentDate(campaign.getLocalDate());\n+        }\n+        \n+        if(scenario.getActionDate() == null) {\n+            scenario.setActionDate(campaign.getLocalDate());\n+        }\n+        \n+        if(scenario.getReturnDate() == null) {\n+            scenario.setReturnDate(campaign.getLocalDate().plusDays(trackState.getDeploymentTime()));\n+        }\n+        \n+        // set the # of rerolls based on the actual lance assigned.\n+        int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+        scenario.getBackingScenario().setRerolls(tactics);\n+        // The number of defensive points available to a force entering a scenario is\n+        // 2 x tactics. By default, those points are spent on conventional minefields.\n+        if (commanderLanceHasDefensiveAssignment(scenario.getBackingScenario(), campaign)) {\n+            scenario.setNumDefensivePoints(tactics * 2);\n+            scenario.updateMinefieldCount(Minefield.TYPE_CONVENTIONAL, tactics * 2);\n+        }\n+        \n+        for (int forceID : scenario.getPrimaryPlayerForceIDs()) {\n+            Force force = campaign.getForce(forceID);\n+            force.clearScenarioIds(campaign, true);\n+            force.setScenarioId(scenario.getBackingScenarioID());\n+        }\n+        \n+        scenario.commitPrimaryForces(campaign, contract);\n+    }\n+    \n+    /**\n+     * Utility method to determine if the current scenario's force commander\n+     * is on defence \n+     */\n+    private static boolean commanderLanceHasDefensiveAssignment(AtBDynamicScenario scenario, Campaign campaign) {\n+        Unit commanderUnit = scenario.getLanceCommander(campaign).getUnit();\n+        Lance lance = campaign.getLances().get(commanderUnit.getForceId());\n+        \n+        if ((lance != null) && (lance.getRole() == AtBLanceRole.DEFENCE)) {\n+            return true;\n+        }\n+        \n+        return false;\n+    }\n+    \n+    /**\n+     * A hackish worker function that takes the given list of force IDs and\n+     * separates it into three sets;\n+     * one of forces that can be \"primary\" on a ground map\n+     * one of forces that can be \"primary\" on an atmospheric map\n+     * one of forces that can be \"primary\" in a space map\n+     * @param forceIDs List of force IDs to check\n+     * @return Sorted hash map\n+     */\n+    private static Map<MapLocation, List<Integer>> sortForcesByMapType(List<Integer> forceIDs, Campaign campaign) {\n+        Map<MapLocation, List<Integer>> retVal = new HashMap<>();\n+        \n+        retVal.put(MapLocation.AllGroundTerrain, new ArrayList<>());\n+        retVal.put(MapLocation.LowAtmosphere, new ArrayList<>());\n+        retVal.put(MapLocation.Space, new ArrayList<>());\n+        \n+        for(int forceID : forceIDs) {\n+            switch(campaign.getForce(forceID).getPrimaryUnitType(campaign)) {\n+            case UnitType.BATTLE_ARMOR:\n+            case UnitType.INFANTRY:\n+            case UnitType.MEK:\n+            case UnitType.TANK:\n+            case UnitType.PROTOMEK:\n+            case UnitType.VTOL:\n+                retVal.get(MapLocation.AllGroundTerrain).add(forceID);\n+                break;\n+            case UnitType.AERO:\n+                retVal.get(MapLocation.Space).add(forceID);\n+                // intentional fallthrough here, ASFs can go to atmospheric maps too\n+            case UnitType.CONV_FIGHTER:\n+                retVal.get(MapLocation.LowAtmosphere).add(forceID);\n+                break;\n+            }\n+        }\n+        \n+        \n+        return retVal;\n+    }\n+    \n+    /**\n+     * Determine whether the user should be nagged about unresolved scenarios on AtB Stratcon tracks.\n+     * @param campaign Campaign to check.\n+     * @return An informative string containing the reasons the user was nagged.\n+     */\n+    public static String nagUnresolvedContacts(Campaign campaign) {\n+        StringBuilder sb = new StringBuilder();\n+        \n+        // check every track attached to an active contract for unresolved scenarios\n+        // to which the player must deploy forces today\n+        for(Contract contract : campaign.getActiveContracts()) {\n+            if(contract instanceof AtBContract) {\n+                for(StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    for(StratconScenario scenario : track.getScenarios().values()) {\n+                        if(scenario.getCurrentState() == ScenarioState.UNRESOLVED &&\n+                                campaign.getLocalDate().equals(scenario.getDeploymentDate())) {\n+                            // \"scenario name, track name\"\n+                            sb.append(String.format(\"%s, %s\\n\", scenario.getName(), track.getDisplayableName()));\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        \n+        return sb.toString();\n+    }\n+    \n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track.\n+     * Also registers it with the track and campaign.\n+     */\n+    private static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track, \n+            int forceID, StratconCoords coords) {\n+        int unitType = campaign.getForce(forceID).getPrimaryUnitType(campaign);\n+        ScenarioTemplate template = StratconScenarioFactory.getRandomScenario(unitType);\n+        // useful for debugging specific scenario types\n+        //ScenarioTemplate template = StratconScenarioFactory.getSpecificScenario(\"Hostile Facility.xml\");\n+        \n+        return generateScenario(campaign, contract, track, forceID, coords, template);\n+    }\n+    \n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track,\n+     * using the given template. Also registers it with the track and campaign.\n+     */\n+    static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track, \n+            int forceID, StratconCoords coords, ScenarioTemplate template) {\n+        StratconScenario scenario = new StratconScenario();\n+        scenario.setBackingScenario(AtBDynamicScenarioFactory.initializeScenarioFromTemplate(template, contract, campaign));\n+        scenario.setCoords(coords);\n+        \n+        // do an appropriate allied force if the contract calls for it\n+        // do any attached or integrated units\n+        setAlliedForceModifier(scenario, contract);\n+        setAttachedUnitsModifier(scenario, contract);\n+        applyFacilityModifiers(scenario, track, coords);\n+        applyGlobalModifiers(scenario, contract.getStratconCampaignState());\n+        \n+        if((contract.getCommandRights() == AtBContract.COM_HOUSE) ||\n+                (contract.getCommandRights() == AtBContract.COM_INTEGRATED)) {\n+            scenario.setRequiredScenario(true);\n+        }\n+        \n+        AtBDynamicScenarioFactory.setScenarioModifiers(scenario.getBackingScenario());\n+        scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+        setScenarioDates(track, campaign, scenario);\n+        \n+        // register the scenario with the campaign and the track it's generated on\n+        if (forceID > Force.FORCE_NONE) {\n+            scenario.addPrimaryForce(forceID);\n+        }\n+        \n+        return scenario;\n+    }\n+    \n+    /**\n+     * Apply global scenario modifiers from campaign state to given scenario.\n+     */\n+    private static void applyGlobalModifiers(StratconScenario scenario, StratconCampaignState campaignState) {\n+        for (String modifierName : campaignState.getGlobalScenarioModifiers()) {\n+            AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierName);\n+            \n+            if (modifier == null) {\n+                MekHQ.getLogger().error(String.format(\"Modifier %s not found; ignoring\", modifierName));\n+                continue;\n+            }\n+            \n+            scenario.getBackingScenario().addScenarioModifier(modifier);\n+        }\n+    }\n+    \n+    /**\n+     * Applies scenario modifiers from the current track to the given scenario.\n+     * @param scenario\n+     * @param track\n+     */\n+    private static void applyFacilityModifiers(StratconScenario scenario, StratconTrackState track, StratconCoords coords) {\n+        // loop through all the facilities on the track\n+        // if a facility has been revealed, then it has a 100% chance to apply its effect\n+        // if a facility has not been revealed, then it has a x% chance to apply its effect\n+        // if a facility is on the the scenario coordinates the it applies the local effects\n+        for (StratconCoords facilityCoords : track.getFacilities().keySet()) {\n+            boolean scenarioAtFacility = facilityCoords.equals(coords);\n+            StratconFacility facility = track.getFacilities().get(facilityCoords);\n+            List<String> modifierIDs = new ArrayList<>();\n+            \n+            if (scenarioAtFacility) {\n+                modifierIDs = facility.getLocalModifiers();\n+            } else if (facility.isVisible() || (Compute.randomInt(100) < facility.getAggroRating())) {\n+                modifierIDs = facility.getSharedModifiers();\n+            }\n+            \n+            for (String modifierID : modifierIDs) {\n+                AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierID);\n+                if(modifier == null) {\n+                    MekHQ.getLogger().error(String.format(\"Modifier %s not found for facility %s\", modifierID, facility.getFormattedDisplayableName()));\n+                    continue;\n+                }\n+                \n+                scenario.getBackingScenario().addScenarioModifier(modifier);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Set up the appropriate primary allied force modifier, if any \n+     * @param contract The scenario's contract.\n+     */\n+    private static void setAlliedForceModifier(StratconScenario scenario, AtBContract contract) {\n+        int alliedUnitOdds = 0;\n+        \n+        // first, we determine the odds of having an allied unit present\n+        // TODO: move this override out to the contract definition\n+        if (contract.getMissionType() == AtBContract.MT_RELIEFDUTY) {\n+            alliedUnitOdds = 50;\n+        } else {\n+            switch(contract.getCommandRights()) {\n+            case AtBContract.COM_INTEGRATED:\n+                alliedUnitOdds = 50;\n+                break;\n+            case AtBContract.COM_HOUSE:\n+                alliedUnitOdds = 30;\n+                break;\n+            case AtBContract.COM_LIAISON:\n+                alliedUnitOdds = 10;\n+                break;\n+            }\n+        }\n+        \n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+        \n+        // if an allied unit is present, then we want to make sure that it's ground units\n+        // for ground battles\n+        if (Compute.randomInt(100) <= alliedUnitOdds) {\n+            if((backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+               (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space)) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_ALLIED_AIR_UNITS));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_ALLIED_GROUND_UNITS));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set the 'attached' units modifier for the current scenario (integrated, house, liaison),\n+     * and make sure we're not deploying ground units to an air scenario\n+     * @param contract The scenario's contract\n+     */\n+    public static void setAttachedUnitsModifier(StratconScenario scenario, AtBContract contract) {\n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+        boolean airBattle = (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+                (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space);\n+        \n+        // if we're on cadre duty, we're getting three trainees, period\n+        if(contract.getMissionType() == AtBContract.MT_CADREDUTY) {\n+            if(airBattle) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_TRAINEES_AIR));                \n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_TRAINEES_GROUND));\n+            }\n+            return;\n+        }\n+        \n+        // if we're under non-independent command rights, a supervisor may come along\n+        switch(contract.getCommandRights()) {\n+        case AtBContract.COM_INTEGRATED:\n+            if(airBattle) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_INTEGRATED_UNITS_AIR));                \n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_INTEGRATED_UNITS_GROUND));\n+            }\n+            break;\n+        case AtBContract.COM_HOUSE:\n+            if(airBattle) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_HOUSE_CO_AIR));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_HOUSE_CO_GROUND));\n+            }            \n+            break;\n+        case AtBContract.COM_LIAISON:\n+            if(scenario.isRequiredScenario()) {\n+                if(airBattle) {\n+                    backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_LIAISON_AIR));\n+                } else {\n+                    backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_LIAISON_GROUND));\n+                } \n+            }\n+            break;\n+        }\n+    }\n+    \n+    /**\n+     * Worker function that sets scenario deploy/battle/return dates based on the track's properties and current campaign date\n+     * @param track\n+     * @param campaign\n+     * @param scenario\n+     */\n+    private static void setScenarioDates(StratconTrackState track, Campaign campaign, StratconScenario scenario) {\n+     // set up deployment day, battle day, return day here\n+        // safety code to prevent attempts to generate random int with upper bound of 0 which is apparently illegal\n+        int deploymentDay = track.getDeploymentTime() < 7 ? Compute.randomInt(7 - track.getDeploymentTime()) : 0;\n+        int battleDay = deploymentDay + (track.getDeploymentTime() > 0 ? Compute.randomInt(track.getDeploymentTime()) : 0);\n+        int returnDay = deploymentDay + track.getDeploymentTime();\n+        \n+        LocalDate deploymentDate = campaign.getLocalDate();\n+        deploymentDate.plusDays(deploymentDay);\n+        LocalDate battleDate = campaign.getLocalDate();\n+        deploymentDate.plusDays(battleDay);\n+        LocalDate returnDate = campaign.getLocalDate();\n+        returnDate.plusDays(returnDay);\n+        \n+        scenario.setDeploymentDate(deploymentDate);\n+        scenario.setActionDate(battleDate);\n+        scenario.setReturnDate(returnDate);\n+    }\n+    \n+    /**\n+     * Helper function that determines if the unit type specified in the given scenario force template\n+     * would start out airborne on a ground map (hot dropped units aside)\n+     * @param template\n+     * @return\n+     */\n+    private static boolean unitTypeIsAirborne(ScenarioForceTemplate template) {\n+        int unitType = template.getAllowedUnitType();\n+        \n+        return (unitType == UnitType.AERO ||\n+                unitType == UnitType.CONV_FIGHTER ||\n+                unitType == UnitType.DROPSHIP ||\n+                unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_MIX) &&\n+                template.getStartingAltitude() > 0;\n+    }\n+    \n+    /**\n+     * Determines whether the force in question has the same primary unit type as the force template.\n+     * @return Whether or not the unit types match.\n+     */\n+    public static boolean forceCompositionMatchesDeclaredUnitType(int primaryUnitType, int unitType, boolean reinforcements) {        \n+        // special cases are \"ATB_MIX\" and \"ATB_AERO_MIX\", which encompass multiple unit types\n+        if(unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_MIX) {\n+            // \"AtB mix\" is usually ground units, but air units can sub in\n+            return primaryUnitType == UnitType.MEK ||\n+                    primaryUnitType == UnitType.TANK ||\n+                    primaryUnitType == UnitType.INFANTRY ||\n+                    primaryUnitType == UnitType.BATTLE_ARMOR ||\n+                    primaryUnitType == UnitType.PROTOMEK || \n+                    primaryUnitType == UnitType.VTOL ||\n+                    (primaryUnitType == UnitType.AERO) && reinforcements ||\n+                    (primaryUnitType == UnitType.CONV_FIGHTER) && reinforcements;\n+        } else if (unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_AERO_MIX) {\n+            return primaryUnitType == UnitType.AERO ||\n+                    primaryUnitType == UnitType.CONV_FIGHTER;\n+        } else {\n+            return primaryUnitType == unitType;\n+        }\n+    }\n+    \n+    /**\n+     * This is a set of all force IDs for forces that can be deployed to a scenario.\n+     * @param campaign Current campaign\n+     * @return Set of available force IDs.\n+     */\n+    public static List<Integer> getAvailableForceIDs(Campaign campaign) {\n+        List<Integer> retVal = new ArrayList<>();\n+        \n+        // first, we gather a set of all forces that are already deployed to a track so we eliminate those later\n+        Set<Integer> forcesInTracks = new HashSet<>();\n+        for(Contract contract : campaign.getActiveContracts()) {\n+            if(contract instanceof AtBContract) {\n+                for(StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    forcesInTracks.addAll(track.getAssignedForceCoords().keySet());\n+                }\n+            }\n+        }\n+        \n+        // now, we get all the forces that qualify as \"lances\", and filter out those that are\n+        // deployed to a scenario and not in a track already\n+        for(int key : campaign.getLances().keySet()) {\n+            Force force = campaign.getForce(key);\n+            if(force != null && \n+                    !force.isDeployed() && \n+                    (force.getScenarioId() <= 0) &&\n+                    !forcesInTracks.contains(force.getId())) {\n+                retVal.add(force.getId());\n+            }\n+        }\n+        \n+        return retVal;\n+    }\n+    \n+    /**\n+     * This is a list of all force IDs for forces that can be deployed to a scenario in the given force template\n+     * a) have not been assigned to a track\n+     * b) are combat-capable\n+     * c) are not deployed to a scenario\n+     */\n+    public static List<Integer> getAvailableForceIDs(int unitType, Campaign campaign, StratconTrackState currentTrack, \n+            boolean reinforcements) {\n+        List<Integer> retVal = new ArrayList<>();\n+        \n+        Set<Integer> forcesInTracks = new HashSet<>();\n+        // assemble a set of all force IDs that are currently assigned to tracks that are not this one\n+        for (Contract contract : campaign.getActiveContracts()) {\n+            if (contract instanceof AtBContract) {\n+                for (StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    if ((track != currentTrack) || !reinforcements) {\n+                        forcesInTracks.addAll(track.getAssignedForceCoords().keySet());\n+                    }\n+                }\n+            }\n+        }\n+        \n+        for (int key : campaign.getLances().keySet()) {\n+            Force force = campaign.getForce(key);\n+            \n+            if (force == null) {\n+                continue;\n+            }\n+            \n+            int primaryUnitType = force.getPrimaryUnitType(campaign);\n+            if (!force.isDeployed() && \n+                    (force.getScenarioId() <= 0) &&\n+                    !force.getUnits().isEmpty() &&\n+                    !forcesInTracks.contains(force.getId()) &&\n+                    forceCompositionMatchesDeclaredUnitType(primaryUnitType, unitType, reinforcements)) {\n+                retVal.add(force.getId());\n+            }\n+        }\n+        \n+        return retVal;\n+    }\n+    \n+    /**\n+     * Returns a list of individual units eligible for deployment in scenarios run by \"Defend\" lances\n+     * @param campaign\n+     * @return List of unit IDs.\n+     */\n+    public static List<Unit> getEligibleDefensiveUnits(Campaign campaign) {\n+        List<Unit> retVal = new ArrayList<>();\n+        \n+        for(Unit u : campaign.getUnits()) {\n+            // \"defensive\" units are infantry, battle armor and (Weisman help you) gun emplacements\n+            if(((u.getEntity().getUnitType() == UnitType.INFANTRY) || \n+                    (u.getEntity().getUnitType() == UnitType.BATTLE_ARMOR) ||\n+                    (u.getEntity().getUnitType() == UnitType.GUN_EMPLACEMENT)) &&\n+                    (u.getScenarioId() <= 0)) {\n+                \n+                // this is a little inefficient, but probably there aren't too many active AtB contracts at a time\n+                for(Contract contract : campaign.getActiveContracts()) {\n+                    if((contract instanceof AtBContract) &&\n+                            ((AtBContract) contract).getStratconCampaignState().isForceDeployedHere(u.getForceId())) {\n+                        continue;\n+                    }\n+                }\n+                \n+                retVal.add(u);\n+            }\n+        }\n+        \n+        return retVal;\n+    }\n+    \n+    /**\n+     * Determines what rules to use when deploying a force for reinforcements to the given track.\n+     */\n+    public static ReinforcementEligibilityType getReinforcementType(int forceID, \n+            StratconTrackState trackState, Campaign campaign) {\n+        // if the force is currently deployed to the track, it'll be able to deploy \"for free\"\n+        if (trackState.isForceDeployed(forceID)) {\n+            return ReinforcementEligibilityType.ChainedScenario;\n+        }\n+        \n+        // if the force is in 'fight' stance, it'll be able to deploy using 'fight lance' rules\n+        if (campaign.getLances().containsKey(forceID) &&\n+                campaign.getLances().get(forceID).getRole() == AtBLanceRole.FIGHTING) {\n+            return ReinforcementEligibilityType.FightLance;\n+        }\n+        \n+        // if the force is deployed elsewhere, it cannot be deployed as reinforcements\n+        for(Contract contract : campaign.getActiveContracts()) {\n+            if(contract instanceof AtBContract) {\n+                for(StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    if(track != trackState && track.getAssignedForceCoords().containsKey(forceID)) {\n+                        return ReinforcementEligibilityType.None;\n+                    }\n+                }\n+            }\n+        }\n+        \n+        // otherwise, the force requires support points / vps to deploy\n+        return ReinforcementEligibilityType.SupportPoint;\n+    }\n+    \n+    /**\n+     * Removes the facility associated with the given scenario from the relevant track/\n+     */\n+    public static void updateFacilityForScenario(AtBScenario scenario, AtBContract contract, boolean destroy, boolean capture) {\n+        if(contract.getStratconCampaignState() == null) {\n+            return;\n+        }\n+        \n+        // this is kind of kludgy, but there's currently no way to link a scenario back to its backing scenario\n+        // TODO: introduce mapping in contract or at least trackstate\n+        // basically, we're looping through all scenarios on all the contract's tracks\n+        // if we find one with the same ID as the one being resolved, that's our facility: get rid of it.\n+        for(StratconTrackState trackState : contract.getStratconCampaignState().getTracks()) {\n+            for(StratconCoords coords : trackState.getScenarios().keySet()) {\n+                StratconScenario potentialScenario = trackState.getScenario(coords);\n+                if(potentialScenario.getBackingScenarioID() == scenario.getId()) {\n+                    \n+                    if(destroy) {\n+                        trackState.removeFacility(coords);\n+                    } else {\n+                        StratconFacility facility = trackState.getFacility(coords);\n+                        \n+                        if (facility == null) {\n+                            continue;\n+                        }\n+                        \n+                        if(capture) {\n+                            facility.incrementOwnershipChangeScore();\n+                        } else {\n+                            facility.decrementOwnershipChangeScore();\n+                        }\n+                    }\n+                    \n+                    break;\n+                }\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Processes completion of a Stratcon scenario, if the given tracker is associated\n+     * with a stratcon-enabled mission. Intended to be called after ResolveScenarioTracker.finish() has been invoked.\n+     */\n+    public static void processScenarioCompletion(ResolveScenarioTracker rst) {\n+        if (rst.getMission() instanceof AtBContract) {\n+            StratconCampaignState campaignState = ((AtBContract) rst.getMission()).getStratconCampaignState();\n+            if (campaignState == null) {\n+                return;\n+            }\n+            \n+            for (StratconTrackState track : campaignState.getTracks()) {\n+                if (track.getBackingScenariosMap().containsKey(rst.getScenario().getId())) {\n+                    // things that may potentially happen:\n+                    // scenario is removed from track - implemented\n+                    // track gets remaining forces added to reinforcement pool\n+                    // facility gets remaining forces stored in reinforcement pool\n+                    // process VP and SO\n+                    \n+                    StratconScenario scenario = track.getBackingScenariosMap().get(rst.getScenario().getId());\n+                    \n+                    \n+                    StratconFacility facility = track.getFacility(scenario.getCoords());\n+                    \n+                    if ((facility != null) && (facility.getOwnershipChangeScore() > 0)) {\n+                        if(facility.getOwner() == ForceAlignment.Allied) {\n+                            facility.setOwner(ForceAlignment.Opposing);\n+                        } else {\n+                            facility.setOwner(ForceAlignment.Allied);\n+                        }\n+                    }\n+                    \n+                    boolean victory = rst.getScenario().getStatus() == Scenario.S_VICTORY ||\n+                            rst.getScenario().getStatus() == Scenario.S_MVICTORY;\n+                    \n+                    if (scenario.isRequiredScenario()) {                        \n+                        campaignState.updateVictoryPoints(victory ? 1 : -1);\n+                    }\n+                    \n+                    if (scenario.isStrategicObjective()) {\n+                        if (campaignState.strategicObjectivesBehaveAsVPs()) {\n+                            campaignState.updateVictoryPoints(victory ? 1 : -1);\n+                        } else {\n+                            campaignState.incrementStrategicObjectiveCompletedCount();\n+                        }\n+                    }\n+                    \n+                    processTrackForceReturnDates(track, rst.getCampaign().getLocalDate());\n+                    \n+                    track.removeScenario(scenario);                    \n+                    break;\n+                }\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Worker function that goes through a track and undeploys any forces where the\n+     * return date is on or before the given date.\n+     */\n+    public static void processTrackForceReturnDates(StratconTrackState track, LocalDate date) {\n+        List<Integer> forcesToUndeploy = new ArrayList<>();\n+        \n+        for(int forceID : track.getAssignedForceReturnDates().keySet()) {\n+            if(track.getAssignedForceReturnDates().get(forceID).equals(date) ||\n+                    track.getAssignedForceReturnDates().get(forceID).isBefore(date)) {\n+                forcesToUndeploy.add(forceID);\n+            }\n+        }\n+        \n+        for(int forceID : forcesToUndeploy) {\n+            track.unassignForce(forceID);\n+        }\n+    }\n+    \n+    /**\n+     * Processes an ignored Stratcon scenario\n+     */\n+    public static void processIgnoredScenario(StratconScenario scenario, StratconCampaignState campaignState) {\n+        for(StratconTrackState track : campaignState.getTracks()) {\n+            if(track.getScenarios().containsKey(scenario.getCoords())) {                \n+                // subtract VP if scenario is 'required'\n+                if(scenario.isRequiredScenario()) {\n+                    campaignState.updateVictoryPoints(-1);\n+                }\n+                \n+                StratconFacility localFacility = track.getFacility(scenario.getCoords());\n+                if(localFacility != null) {\n+                    // if the ignored scenario was on top of an allied facility\n+                    // then it'll get captured, and the player will possibly lose a SO\n+                    if(localFacility.getOwner() == ForceAlignment.Allied) {\n+                        localFacility.setOwner(ForceAlignment.Opposing);\n+                        \n+                        if(localFacility.isStrategicObjective()) {\n+                            campaignState.decrementStrategicObjectiveCompletedCount();\n+                        }\n+                    }\n+                } else {\n+                    // if it's an open-field\n+                    // move scenario towards nearest allied facility\n+                    StratconCoords closestAlliedFacilityCoords = track.findClosestAlliedFacilityCoords(scenario.getCoords());\n+                    \n+                    if(closestAlliedFacilityCoords != null) {\n+                        StratconCoords newCoords = scenario.getCoords().translate(scenario.getCoords().direction(closestAlliedFacilityCoords));\n+                        scenario.setCoords(newCoords);\n+                        //scenario.setDeploymentDate(scenario.getDeploymentDate().plusDays(daysToAdd));\n+                        \n+                        // TODO: if the allied facility is in the new coords, replace this scenario\n+                        // with a facility defense, with the opfor coming directly from all hostiles assigned to this scenario\n+                        \n+                        scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                    } else {\n+                        // TODO: if there's no allied facilities here, add its forces to track reinforcement pool\n+                        \n+                    }\n+                }\n+                \n+                // either way, it's gone\n+                track.removeScenario(scenario);\n+            }\n+        }\n+    }\n+    \n+    public StratconRulesManager() {\n+        MekHQ.registerHandler(this);\n+    }", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQxMDY4NQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593410685", "bodyText": "headerify", "author": "sixlettervariables", "createdAt": "2021-03-12T19:48:18Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconScenario.java", "diffHunk": "@@ -0,0 +1,292 @@\n+package mekhq.campaign.stratcon;", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQxODg2MQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593418861", "bodyText": "Tab spacing", "author": "Windchild292", "createdAt": "2021-03-12T20:03:52Z", "path": "MekHQ/src/mekhq/MekHQ.java", "diffHunk": "@@ -683,10 +684,11 @@ static public void unregisterHandler(Object handler) {\n         EVENT_BUS.unregister(handler);\n     }\n \n-    // TODO: This needs to be way more flexible, but it will do for now.\n-    private void initEventHandlers() {\n-        EVENT_BUS.register(new XPHandler());\n-    }\n+\t// TODO: This needs to be way more flexible, but it will do for now.\n+\tprivate void initEventHandlers() {\n+\t    EVENT_BUS.register(new XPHandler());\n+\t    EVENT_BUS.register(new StratconRulesManager());\t    \n+\t}", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQxOTI5NA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593419294", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if(m instanceof AtBContract) {\n          \n          \n            \n                    if (m instanceof AtBContract) {", "author": "Windchild292", "createdAt": "2021-03-12T20:04:50Z", "path": "MekHQ/src/mekhq/campaign/Campaign.java", "diffHunk": "@@ -875,6 +892,27 @@ public void importMission(Mission m) {\n         }\n \n         addMissionWithoutId(m);\n+        \n+        if(m instanceof AtBContract) {", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQxOTQ0Nw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593419447", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if(atbContract.getStratconCampaignState() != null) {\n          \n          \n            \n                            for(StratconTrackState track : atbContract.getStratconCampaignState().getTracks()) {\n          \n          \n            \n                                for(StratconScenario scenario : track.getScenarios().values()) {\n          \n          \n            \n                        if (atbContract.getStratconCampaignState() != null) {\n          \n          \n            \n                            for (StratconTrackState track : atbContract.getStratconCampaignState().getTracks()) {\n          \n          \n            \n                                for (StratconScenario scenario : track.getScenarios().values()) {", "author": "Windchild292", "createdAt": "2021-03-12T20:05:08Z", "path": "MekHQ/src/mekhq/campaign/Campaign.java", "diffHunk": "@@ -875,6 +892,27 @@ public void importMission(Mission m) {\n         }\n \n         addMissionWithoutId(m);\n+        \n+        if(m instanceof AtBContract) {\n+            // having loaded scenarios and such, we now need to go through any stratcon scenarios for this contract\n+            // and set their backing scenario pointers to the existing scenarios stored in the campaign for this contract\n+            AtBContract atbContract = (AtBContract) m;\n+            if(atbContract.getStratconCampaignState() != null) {\n+                for(StratconTrackState track : atbContract.getStratconCampaignState().getTracks()) {\n+                    for(StratconScenario scenario : track.getScenarios().values()) {", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQxOTU3MQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593419571", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        // having loaded scenarios and such, we now need to go through any stratcon scenarios for this contract\n          \n          \n            \n                        // Having loaded scenarios and such, we now need to go through any StratCon scenarios for this contract", "author": "Windchild292", "createdAt": "2021-03-12T20:05:23Z", "path": "MekHQ/src/mekhq/campaign/Campaign.java", "diffHunk": "@@ -875,6 +892,27 @@ public void importMission(Mission m) {\n         }\n \n         addMissionWithoutId(m);\n+        \n+        if(m instanceof AtBContract) {\n+            // having loaded scenarios and such, we now need to go through any stratcon scenarios for this contract", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQxOTc2OA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593419768", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    if(campaignScenario != null && campaignScenario instanceof AtBDynamicScenario) {\n          \n          \n            \n                                    if ((campaignScenario != null) && (campaignScenario instanceof AtBDynamicScenario)) {", "author": "Windchild292", "createdAt": "2021-03-12T20:05:44Z", "path": "MekHQ/src/mekhq/campaign/Campaign.java", "diffHunk": "@@ -875,6 +892,27 @@ public void importMission(Mission m) {\n         }\n \n         addMissionWithoutId(m);\n+        \n+        if(m instanceof AtBContract) {\n+            // having loaded scenarios and such, we now need to go through any stratcon scenarios for this contract\n+            // and set their backing scenario pointers to the existing scenarios stored in the campaign for this contract\n+            AtBContract atbContract = (AtBContract) m;\n+            if(atbContract.getStratconCampaignState() != null) {\n+                for(StratconTrackState track : atbContract.getStratconCampaignState().getTracks()) {\n+                    for(StratconScenario scenario : track.getScenarios().values()) {\n+                        Scenario campaignScenario = getScenario(scenario.getBackingScenarioID());\n+                        \n+                        if(campaignScenario != null && campaignScenario instanceof AtBDynamicScenario) {", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQxOTk3Ng==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593419976", "bodyText": "Can be cleaned up with the logger changes", "author": "Windchild292", "createdAt": "2021-03-12T20:06:10Z", "path": "MekHQ/src/mekhq/campaign/Campaign.java", "diffHunk": "@@ -875,6 +892,27 @@ public void importMission(Mission m) {\n         }\n \n         addMissionWithoutId(m);\n+        \n+        if(m instanceof AtBContract) {\n+            // having loaded scenarios and such, we now need to go through any stratcon scenarios for this contract\n+            // and set their backing scenario pointers to the existing scenarios stored in the campaign for this contract\n+            AtBContract atbContract = (AtBContract) m;\n+            if(atbContract.getStratconCampaignState() != null) {\n+                for(StratconTrackState track : atbContract.getStratconCampaignState().getTracks()) {\n+                    for(StratconScenario scenario : track.getScenarios().values()) {\n+                        Scenario campaignScenario = getScenario(scenario.getBackingScenarioID());\n+                        \n+                        if(campaignScenario != null && campaignScenario instanceof AtBDynamicScenario) {\n+                            scenario.setBackingScenario((AtBDynamicScenario) campaignScenario);\n+                        } else {\n+                            MekHQ.getLogger().warning(Campaign.class, \"importMission\", \n+                                    String.format(\"Unable to set backing scenario for stratcon scenario in track %s ID %d\", ", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQyMDE3MQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593420171", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    MekHqXmlUtil.writeSimpleXmlTag(pw1, indent + 1, \"useStratCon\", useStratCon);\n          \n          \n            \n                    MekHqXmlUtil.writeSimpleXMLTag(pw1, indent + 1, \"useStratCon\", useStratCon);", "author": "Windchild292", "createdAt": "2021-03-12T20:06:35Z", "path": "MekHQ/src/mekhq/campaign/CampaignOptions.java", "diffHunk": "@@ -3222,6 +3233,7 @@ public void writeToXml(PrintWriter pw1, int indent) {\n                 + \"</phenotypeProbabilities>\");\n         MekHqXmlUtil.writeSimpleXmlTag(pw1, indent + 1, \"tougherHealing\", tougherHealing);\n         MekHqXmlUtil.writeSimpleXmlTag(pw1, indent + 1, \"useAtB\", useAtB);\n+        MekHqXmlUtil.writeSimpleXmlTag(pw1, indent + 1, \"useStratCon\", useStratCon);", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzgzMjk1OA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593832958", "bodyText": "It's a single boolean, not a collection of booleans, so I don't really see the point. All the surrounding ones use the same syntax.", "author": "NickAragua", "createdAt": "2021-03-14T03:03:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQyMDE3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjkwMzk4NQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r602903985", "bodyText": "The point is that all XML writers will be moving to this as part of standardizing our writers. I've not yet gotten to the rest of them here, as not all work without MegaMek/megamek#2581", "author": "Windchild292", "createdAt": "2021-03-28T17:04:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQyMDE3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQyMDk5Nw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593420997", "bodyText": "Superfluous null check", "author": "Windchild292", "createdAt": "2021-03-12T20:08:09Z", "path": "MekHQ/src/mekhq/campaign/force/Force.java", "diffHunk": "@@ -388,7 +390,10 @@ public void writeToXml(PrintWriter pw1, int indent) {\n \n         MekHqXmlUtil.writeSimpleXmlTag(pw1, indent, \"iconFileName\", iconFileName);\n         MekHqXmlUtil.writeSimpleXmlTag(pw1, indent, \"scenarioId\", scenarioId);\n-        MekHqXmlUtil.writeSimpleXmlTag(pw1, indent, \"techId\", techId);\n+        \n+        if(techId != null) {\n+            MekHqXmlUtil.writeSimpleXmlTag(pw1, indent, \"techId\", techId);\n+        }", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQyMTE2MA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593421160", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for(UUID id : getUnits()) {\n          \n          \n            \n                    for (UUID id : getUnits()) {", "author": "Windchild292", "createdAt": "2021-03-12T20:08:34Z", "path": "MekHQ/src/mekhq/campaign/force/Force.java", "diffHunk": "@@ -591,4 +601,30 @@ public int getTotalBV(Campaign c) {\n \n         return bvTotal;\n     }\n+    \n+    /**\n+     * Calculates the unit type most represented in this force\n+     * and all subforces.\n+     * @param c Working campaign\n+     * @return Majority unit type.\n+     */\n+    public int getPrimaryUnitType(Campaign c) {\n+        Map<Integer, Integer> unitTypeBuckets = new TreeMap<>();\n+        int biggestBucketID = -1;\n+        int biggestBucketCount = 0;\n+        \n+        for(UUID id : getUnits()) {", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQyMTM5NQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593421395", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if(stratconCampaignState != null) {\n          \n          \n            \n                    if (stratconCampaignState != null) {", "author": "Windchild292", "createdAt": "2021-03-12T20:09:02Z", "path": "MekHQ/src/mekhq/campaign/mission/AtBContract.java", "diffHunk": "@@ -1198,6 +1204,10 @@ protected void writeToXmlBegin(PrintWriter pw1, int indent) {\n                     MekHqXmlUtil.saveFormattedDate(specialEventScenarioDate));\n             MekHqXmlUtil.writeSimpleXmlTag(pw1, indent + 1, \"specialEventScenarioType\", specialEventScenarioType);\n         }\n+        \n+        if(stratconCampaignState != null) {", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQyMTU4NA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593421584", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            this.setStratconCampaignState(stratconCampaignState);\n          \n          \n            \n                            setStratconCampaignState(stratconCampaignState);", "author": "Windchild292", "createdAt": "2021-03-12T20:09:22Z", "path": "MekHQ/src/mekhq/campaign/mission/AtBContract.java", "diffHunk": "@@ -1280,6 +1290,10 @@ public void loadFieldsFromXmlNode(Node wn) throws ParseException {\n                 specialEventScenarioDate = MekHqXmlUtil.parseDate(wn2.getTextContent().trim());\n             } else if (wn2.getNodeName().equalsIgnoreCase(\"specialEventScenarioType\")) {\n                 specialEventScenarioType = Integer.parseInt(wn2.getTextContent());\n+            } else if (wn2.getNodeName().equalsIgnoreCase(StratconCampaignState.ROOT_XML_ELEMENT_NAME)) {\n+                stratconCampaignState = StratconCampaignState.Deserialize(wn2);\n+                stratconCampaignState.setContract(this);\n+                this.setStratconCampaignState(stratconCampaignState);", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQyMTk1NQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593421955", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for(Entity entity : botForce.getEntityList()) {\n          \n          \n            \n                    for (Entity entity : botForce.getEntityList()) {", "author": "Windchild292", "createdAt": "2021-03-12T20:10:06Z", "path": "MekHQ/src/mekhq/campaign/mission/AtBDynamicScenario.java", "diffHunk": "@@ -158,6 +162,11 @@ public int getMapY() {\n     public void addBotForce(BotForce botForce, ScenarioForceTemplate forceTemplate) {\n         super.addBotForce(botForce);\n         botForceTemplates.put(botForce, forceTemplate);\n+        \n+        // put all bot units into the external ID lookup.\n+        for(Entity entity : botForce.getEntityList()) {", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQyMjM3MQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593422371", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for(String modifierKey : modifier.getLinkedModifiers().keySet()) {\n          \n          \n            \n                    for (String modifierKey : modifier.getLinkedModifiers().keySet()) {", "author": "Windchild292", "createdAt": "2021-03-12T20:10:54Z", "path": "MekHQ/src/mekhq/campaign/mission/AtBDynamicScenario.java", "diffHunk": "@@ -294,8 +311,45 @@ public void setScenarioModifiers(List<AtBScenarioModifier> scenarioModifiers) {\n         return scenarioModifiers;\n     }\n \n+    /**\n+     * Adds a scenario modifier and any linked modifiers to this scenario,\n+     * provided that the modifier exists and can be applied to the scenario (e.g. ground units on air map)\n+     */\n     public void addScenarioModifier(AtBScenarioModifier modifier) {\n+        if (modifier == null) {\n+            return;\n+        }\n+        \n+        if ((modifier.getAllowedMapLocations() != null) && !modifier.getAllowedMapLocations().isEmpty() &&\n+                !modifier.getAllowedMapLocations().contains(getTemplate().mapParameters.getMapLocation())) {\n+            return;\n+        }\n+        \n         scenarioModifiers.add(modifier);\n+        \n+        for(String modifierKey : modifier.getLinkedModifiers().keySet()) {", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQyMjUzMQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593422531", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void addScenarioModifier(AtBScenarioModifier modifier) {\n          \n          \n            \n                public void addScenarioModifier(@Nullable AtBScenarioModifier modifier) {", "author": "Windchild292", "createdAt": "2021-03-12T20:11:16Z", "path": "MekHQ/src/mekhq/campaign/mission/AtBDynamicScenario.java", "diffHunk": "@@ -294,8 +311,45 @@ public void setScenarioModifiers(List<AtBScenarioModifier> scenarioModifiers) {\n         return scenarioModifiers;\n     }\n \n+    /**\n+     * Adds a scenario modifier and any linked modifiers to this scenario,\n+     * provided that the modifier exists and can be applied to the scenario (e.g. ground units on air map)\n+     */\n     public void addScenarioModifier(AtBScenarioModifier modifier) {", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQyMjY0MQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593422641", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if((subMod != null) && !alreadyHasModifier(subMod)) {\n          \n          \n            \n                        if ((subMod != null) && !alreadyHasModifier(subMod)) {", "author": "Windchild292", "createdAt": "2021-03-12T20:11:31Z", "path": "MekHQ/src/mekhq/campaign/mission/AtBDynamicScenario.java", "diffHunk": "@@ -294,8 +311,45 @@ public void setScenarioModifiers(List<AtBScenarioModifier> scenarioModifiers) {\n         return scenarioModifiers;\n     }\n \n+    /**\n+     * Adds a scenario modifier and any linked modifiers to this scenario,\n+     * provided that the modifier exists and can be applied to the scenario (e.g. ground units on air map)\n+     */\n     public void addScenarioModifier(AtBScenarioModifier modifier) {\n+        if (modifier == null) {\n+            return;\n+        }\n+        \n+        if ((modifier.getAllowedMapLocations() != null) && !modifier.getAllowedMapLocations().isEmpty() &&\n+                !modifier.getAllowedMapLocations().contains(getTemplate().mapParameters.getMapLocation())) {\n+            return;\n+        }\n+        \n         scenarioModifiers.add(modifier);\n+        \n+        for(String modifierKey : modifier.getLinkedModifiers().keySet()) {\n+            AtBScenarioModifier subMod = AtBScenarioModifier.getScenarioModifier(modifierKey);\n+            \n+            // if the modifier exists and has not already been added (to avoid infinite loops, as it's possible to define those in data)\n+            if((subMod != null) && !alreadyHasModifier(subMod)) {", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQyMjgzNw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593422837", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for(AtBScenarioModifier existingModifier : scenarioModifiers) {\n          \n          \n            \n                        if(existingModifier.getModifierName().equals(modifier.getModifierName())) {\n          \n          \n            \n                    for (AtBScenarioModifier existingModifier : scenarioModifiers) {\n          \n          \n            \n                        if (existingModifier.getModifierName().equals(modifier.getModifierName())) {", "author": "Windchild292", "createdAt": "2021-03-12T20:11:54Z", "path": "MekHQ/src/mekhq/campaign/mission/AtBDynamicScenario.java", "diffHunk": "@@ -294,8 +311,45 @@ public void setScenarioModifiers(List<AtBScenarioModifier> scenarioModifiers) {\n         return scenarioModifiers;\n     }\n \n+    /**\n+     * Adds a scenario modifier and any linked modifiers to this scenario,\n+     * provided that the modifier exists and can be applied to the scenario (e.g. ground units on air map)\n+     */\n     public void addScenarioModifier(AtBScenarioModifier modifier) {\n+        if (modifier == null) {\n+            return;\n+        }\n+        \n+        if ((modifier.getAllowedMapLocations() != null) && !modifier.getAllowedMapLocations().isEmpty() &&\n+                !modifier.getAllowedMapLocations().contains(getTemplate().mapParameters.getMapLocation())) {\n+            return;\n+        }\n+        \n         scenarioModifiers.add(modifier);\n+        \n+        for(String modifierKey : modifier.getLinkedModifiers().keySet()) {\n+            AtBScenarioModifier subMod = AtBScenarioModifier.getScenarioModifier(modifierKey);\n+            \n+            // if the modifier exists and has not already been added (to avoid infinite loops, as it's possible to define those in data)\n+            if((subMod != null) && !alreadyHasModifier(subMod)) {\n+                // set the briefing text of the alternate modifier to the 'alternate' text supplied here\n+                subMod.setAdditionalBriefingText(modifier.getLinkedModifiers().get(modifierKey));\n+                addScenarioModifier(subMod);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Check if the modifier list already has a modifier with the given modifier's name.\n+     */\n+    public boolean alreadyHasModifier(AtBScenarioModifier modifier) {\n+        for(AtBScenarioModifier existingModifier : scenarioModifiers) {\n+            if(existingModifier.getModifierName().equals(modifier.getModifierName())) {", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQyMzYzMw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593423633", "bodyText": "Swap to writeSimpleXMLOpenIndentedLine", "author": "Windchild292", "createdAt": "2021-03-12T20:13:37Z", "path": "MekHQ/src/mekhq/campaign/mission/AtBScenario.java", "diffHunk": "@@ -1635,6 +1638,19 @@ protected void writeToXmlEnd(PrintWriter pw1, int indent) {\n \n             pw1.println(MekHqXmlUtil.indentStr(indent+1) + \"</transportLinkages>\");\n         }\n+        \n+        if (numPlayerMinefields.size() > 0) {\n+            pw1.println(MekHqXmlUtil.indentStr(indent+1) + \"<numPlayerMinefields>\");", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQyMzY5Mg==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593423692", "bodyText": "Swap to writeSimpleXMLOpenIndentedLine", "author": "Windchild292", "createdAt": "2021-03-12T20:13:45Z", "path": "MekHQ/src/mekhq/campaign/mission/AtBScenario.java", "diffHunk": "@@ -1635,6 +1638,19 @@ protected void writeToXmlEnd(PrintWriter pw1, int indent) {\n \n             pw1.println(MekHqXmlUtil.indentStr(indent+1) + \"</transportLinkages>\");\n         }\n+        \n+        if (numPlayerMinefields.size() > 0) {\n+            pw1.println(MekHqXmlUtil.indentStr(indent+1) + \"<numPlayerMinefields>\");\n+\n+            for (int key : numPlayerMinefields.keySet()) {\n+                pw1.println(MekHqXmlUtil.indentStr(indent+2) + \"<numPlayerMinefield>\");", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQyMzc3Mg==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593423772", "bodyText": "Swap to writeSimpleXMLCloseIndentedLine", "author": "Windchild292", "createdAt": "2021-03-12T20:13:57Z", "path": "MekHQ/src/mekhq/campaign/mission/AtBScenario.java", "diffHunk": "@@ -1635,6 +1638,19 @@ protected void writeToXmlEnd(PrintWriter pw1, int indent) {\n \n             pw1.println(MekHqXmlUtil.indentStr(indent+1) + \"</transportLinkages>\");\n         }\n+        \n+        if (numPlayerMinefields.size() > 0) {\n+            pw1.println(MekHqXmlUtil.indentStr(indent+1) + \"<numPlayerMinefields>\");\n+\n+            for (int key : numPlayerMinefields.keySet()) {\n+                pw1.println(MekHqXmlUtil.indentStr(indent+2) + \"<numPlayerMinefield>\");\n+                MekHqXmlUtil.writeSimpleXmlTag(pw1, indent + 3, \"minefieldType\", key);\n+                MekHqXmlUtil.writeSimpleXmlTag(pw1, indent + 3, \"minefieldCount\", numPlayerMinefields.get(key).toString());\n+                pw1.println(MekHqXmlUtil.indentStr(indent+2) + \"</numPlayerMinefield>\");", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQyMzgwMQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593423801", "bodyText": "Swap to writeSimpleXMLCloseIndentedLine", "author": "Windchild292", "createdAt": "2021-03-12T20:14:02Z", "path": "MekHQ/src/mekhq/campaign/mission/AtBScenario.java", "diffHunk": "@@ -1635,6 +1638,19 @@ protected void writeToXmlEnd(PrintWriter pw1, int indent) {\n \n             pw1.println(MekHqXmlUtil.indentStr(indent+1) + \"</transportLinkages>\");\n         }\n+        \n+        if (numPlayerMinefields.size() > 0) {\n+            pw1.println(MekHqXmlUtil.indentStr(indent+1) + \"<numPlayerMinefields>\");\n+\n+            for (int key : numPlayerMinefields.keySet()) {\n+                pw1.println(MekHqXmlUtil.indentStr(indent+2) + \"<numPlayerMinefield>\");\n+                MekHqXmlUtil.writeSimpleXmlTag(pw1, indent + 3, \"minefieldType\", key);\n+                MekHqXmlUtil.writeSimpleXmlTag(pw1, indent + 3, \"minefieldCount\", numPlayerMinefields.get(key).toString());\n+                pw1.println(MekHqXmlUtil.indentStr(indent+2) + \"</numPlayerMinefield>\");\n+            }\n+\n+            pw1.println(MekHqXmlUtil.indentStr(indent+1) + \"</numPlayerMinefields>\");", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQyMzk5NQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593423995", "bodyText": "Still a TODO, so unfinished?", "author": "Windchild292", "createdAt": "2021-03-12T20:14:27Z", "path": "MekHQ/src/mekhq/campaign/mission/AtBScenario.java", "diffHunk": "@@ -1881,6 +1903,20 @@ private static void loadTransportLinkage(Node wn, Map<String, List<String>> tran\n             transportLinkages.put(transportID, transportedUnitIDs);\n         }\n     }\n+    \n+    private void loadMinefieldCounts(Node wn) {\n+        // TODO: Fix this to load minefields without XPath\n+        /*XPath xp = MekHqXmlUtil.getXPathInstance();\n+        NodeList minefieldTypes = (NodeList) xp.evaluate(\"numPlayerMinefields/minefieldType\", wn, XPathConstants.NODESET);\n+        NodeList minefieldCounts = (NodeList) xp.evaluate(\"numPlayerMinefields/minefieldCount\", wn, XPathConstants.NODESET);\n+\n+        for (int x = 0; x < minefieldTypes.getLength(); x++) {\n+            int minefieldType = Integer.parseInt(minefieldTypes.item(x).getTextContent());\n+            int minefieldCount = Integer.parseInt(minefieldCounts.item(x).getTextContent());\n+            \n+            numPlayerMinefields.put(minefieldType, minefieldCount);\n+        }*/\n+    }", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzU1MTE3Mg==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593551172", "bodyText": "Whoops, that one fell through the cracks.", "author": "NickAragua", "createdAt": "2021-03-13T03:19:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQyMzk5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQyNDg2MA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593424860", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for(int zone : forceDefinition.deploymentZones) {\n          \n          \n            \n                    for (int zone : forceDefinition.deploymentZones) {", "author": "Windchild292", "createdAt": "2021-03-12T20:16:06Z", "path": "MekHQ/src/mekhq/campaign/mission/ScenarioForceTemplate.java", "diffHunk": "@@ -298,6 +304,42 @@ public ScenarioForceTemplate(int forceAlignment, int generationMethod, double fo\n         this.deploymentZones = deploymentZones == null ? new ArrayList<>() : new ArrayList<>(deploymentZones);\n         this.objectiveLinkedForces = new ArrayList<>();\n     }\n+    \n+    public ScenarioForceTemplate(ScenarioForceTemplate forceDefinition) {\n+        forceAlignment = forceDefinition.forceAlignment;\n+        generationMethod = forceDefinition.generationMethod;\n+        forceMultiplier = forceDefinition.forceMultiplier;\n+        deploymentZones = new ArrayList<>();\n+        for(int zone : forceDefinition.deploymentZones) {", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQyNTI5OQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593425299", "bodyText": "These are a code accessibility issue on my end... the words blur together into forint, which is the Hungarian currency...", "author": "Windchild292", "createdAt": "2021-03-12T20:17:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQyNDg2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQyNjM5Ng==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593426396", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for(String force : forceDefinition.objectiveLinkedForces) {\n          \n          \n            \n                    for (String force : forceDefinition.objectiveLinkedForces) {", "author": "Windchild292", "createdAt": "2021-03-12T20:19:04Z", "path": "MekHQ/src/mekhq/campaign/mission/ScenarioForceTemplate.java", "diffHunk": "@@ -298,6 +304,42 @@ public ScenarioForceTemplate(int forceAlignment, int generationMethod, double fo\n         this.deploymentZones = deploymentZones == null ? new ArrayList<>() : new ArrayList<>(deploymentZones);\n         this.objectiveLinkedForces = new ArrayList<>();\n     }\n+    \n+    public ScenarioForceTemplate(ScenarioForceTemplate forceDefinition) {\n+        forceAlignment = forceDefinition.forceAlignment;\n+        generationMethod = forceDefinition.generationMethod;\n+        forceMultiplier = forceDefinition.forceMultiplier;\n+        deploymentZones = new ArrayList<>();\n+        for(int zone : forceDefinition.deploymentZones) {\n+            deploymentZones.add(zone);\n+        }\n+        \n+        destinationZone = forceDefinition.destinationZone;\n+        retreatThreshold = forceDefinition.retreatThreshold;\n+        allowedUnitType = forceDefinition.allowedUnitType;\n+        canReinforceLinked = forceDefinition.canReinforceLinked;\n+        contributesToBV = forceDefinition.contributesToBV;\n+        contributesToUnitCount = forceDefinition.contributesToUnitCount;\n+        forceName = forceDefinition.forceName;\n+        syncedForceName = forceDefinition.syncedForceName;\n+        syncDeploymentType = forceDefinition.syncDeploymentType;\n+        syncRetreatThreshold = forceDefinition.syncRetreatThreshold;\n+        arrivalTurn = forceDefinition.arrivalTurn;\n+        maxWeightClass = forceDefinition.maxWeightClass;\n+        minWeightClass = forceDefinition.minWeightClass;\n+        contributesToMapSize = forceDefinition.contributesToMapSize;\n+        actualDeploymentZone =  forceDefinition.actualDeploymentZone;\n+        fixedUnitCount = forceDefinition.fixedUnitCount;\n+        generationOrder = forceDefinition.generationOrder;\n+        allowAeroBombs = forceDefinition.allowAeroBombs;\n+        startingAltitude = forceDefinition.startingAltitude;\n+        useArtillery = forceDefinition.useArtillery;\n+        deployOffBoard = forceDefinition.deployOffBoard;\n+        objectiveLinkedForces = new ArrayList<String>();\n+        for(String force : forceDefinition.objectiveLinkedForces) {", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjkwMzM2NQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r602903365", "bodyText": "This is an issue that has not been resolved. This is both a readability and accessibility issue.", "author": "Windchild292", "createdAt": "2021-03-28T16:58:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQyNjM5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQyNjYwOQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593426609", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                if(contract.getStratconCampaignState() != null) {\n          \n          \n            \n                                if (contract.getStratconCampaignState() != null) {", "author": "Windchild292", "createdAt": "2021-03-12T20:19:30Z", "path": "MekHQ/src/mekhq/campaign/mission/ScenarioObjectiveProcessor.java", "diffHunk": "@@ -367,6 +368,19 @@ private String processObjectiveEffect(ObjectiveEffect effect, int scaleFactor,\n                 }\n                 break;\n             case SupportPointUpdate:\n+                if (tracker.getMission() instanceof AtBContract) {\n+                    AtBContract contract = (AtBContract) tracker.getMission();\n+                    \n+                    if(contract.getStratconCampaignState() != null) {", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQyNjgyOQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593426829", "bodyText": "Could these be put on the same line without going over in length?", "author": "Windchild292", "createdAt": "2021-03-12T20:19:56Z", "path": "MekHQ/src/mekhq/campaign/mission/ScenarioObjectiveProcessor.java", "diffHunk": "@@ -402,6 +416,34 @@ private String processObjectiveEffect(ObjectiveEffect effect, int scaleFactor,\n                         }\n                     }\n                 }\n+            case FacilityRemains:\n+                if ((tracker.getMission() instanceof AtBContract) &&\n+                        (tracker.getScenario() instanceof AtBScenario)) {", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQyNjkzMQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593426931", "bodyText": "(and same below)", "author": "Windchild292", "createdAt": "2021-03-12T20:20:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQyNjgyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQyNzA0Mg==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593427042", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for(ScenarioForceTemplate sft : scenarioForces.values()) {\n          \n          \n            \n                    for (ScenarioForceTemplate sft : scenarioForces.values()) {", "author": "Windchild292", "createdAt": "2021-03-12T20:20:23Z", "path": "MekHQ/src/mekhq/campaign/mission/ScenarioTemplate.java", "diffHunk": "@@ -51,6 +54,29 @@\n     @XmlElement(name=\"scenarioObjective\")\n     public List<ScenarioObjective> scenarioObjectives = new ArrayList<>();\n     \n+    public ScenarioTemplate clone() {\n+        ScenarioTemplate st = new ScenarioTemplate();\n+        st.name = this.name;\n+        st.shortBriefing = this.shortBriefing;\n+        st.detailedBriefing = this.detailedBriefing;\n+        for(ScenarioForceTemplate sft : scenarioForces.values()) {", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQyNzEwNw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593427107", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for(String mod : scenarioModifiers) {\n          \n          \n            \n                    for (String mod : scenarioModifiers) {", "author": "Windchild292", "createdAt": "2021-03-12T20:20:31Z", "path": "MekHQ/src/mekhq/campaign/mission/ScenarioTemplate.java", "diffHunk": "@@ -51,6 +54,29 @@\n     @XmlElement(name=\"scenarioObjective\")\n     public List<ScenarioObjective> scenarioObjectives = new ArrayList<>();\n     \n+    public ScenarioTemplate clone() {\n+        ScenarioTemplate st = new ScenarioTemplate();\n+        st.name = this.name;\n+        st.shortBriefing = this.shortBriefing;\n+        st.detailedBriefing = this.detailedBriefing;\n+        for(ScenarioForceTemplate sft : scenarioForces.values()) {\n+            st.scenarioForces.put(sft.getForceName(), sft.clone());\n+        }\n+        \n+        for(String mod : scenarioModifiers) {", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQyNzE4OA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593427188", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for(ScenarioObjective obj : scenarioObjectives) {\n          \n          \n            \n                    for (ScenarioObjective obj : scenarioObjectives) {", "author": "Windchild292", "createdAt": "2021-03-12T20:20:41Z", "path": "MekHQ/src/mekhq/campaign/mission/ScenarioTemplate.java", "diffHunk": "@@ -51,6 +54,29 @@\n     @XmlElement(name=\"scenarioObjective\")\n     public List<ScenarioObjective> scenarioObjectives = new ArrayList<>();\n     \n+    public ScenarioTemplate clone() {\n+        ScenarioTemplate st = new ScenarioTemplate();\n+        st.name = this.name;\n+        st.shortBriefing = this.shortBriefing;\n+        st.detailedBriefing = this.detailedBriefing;\n+        for(ScenarioForceTemplate sft : scenarioForces.values()) {\n+            st.scenarioForces.put(sft.getForceName(), sft.clone());\n+        }\n+        \n+        for(String mod : scenarioModifiers) {\n+            st.scenarioModifiers.add(mod);\n+        }\n+        \n+        for(ScenarioObjective obj : scenarioObjectives) {", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQyNzQ1Mw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593427453", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             *", "author": "Windchild292", "createdAt": "2021-03-12T20:21:17Z", "path": "MekHQ/src/mekhq/campaign/mission/atb/AtBScenarioManifest.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.mission.atb;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.util.Map;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBElement;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.transform.Source;\n+\n+import mekhq.MekHQ;\n+import mekhq.MekHqXmlUtil;\n+\n+/**\n+ * A manifest containing IDs and file names of scenario template definitions\n+ * @author NickAragua\n+ *", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQyNzYzMg==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593427632", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if(!inputFile.exists()) {\n          \n          \n            \n                    if (!inputFile.exists()) {", "author": "Windchild292", "createdAt": "2021-03-12T20:21:38Z", "path": "MekHQ/src/mekhq/campaign/mission/atb/AtBScenarioManifest.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.mission.atb;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.util.Map;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBElement;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.transform.Source;\n+\n+import mekhq.MekHQ;\n+import mekhq.MekHqXmlUtil;\n+\n+/**\n+ * A manifest containing IDs and file names of scenario template definitions\n+ * @author NickAragua\n+ *\n+ */\n+@XmlRootElement(name=\"scenarioManifest\")\n+public class AtBScenarioManifest {\n+    @XmlElementWrapper(name=\"scenarioFileNames\")\n+    @XmlElement(name=\"scenarioFileName\")\n+    public Map<Integer, String> scenarioFileNames;\n+    \n+    /**\n+     * Attempt to deserialize an instance of an AtBScenarioManifest from the passed-in file path\n+     * @return Possibly an instance of a ScenarioManifest\n+     */\n+    public static AtBScenarioManifest Deserialize(String fileName) {\n+        AtBScenarioManifest resultingManifest = null;\n+        File inputFile = new File(fileName);\n+        if(!inputFile.exists()) {", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQyNzg1MA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593427850", "bodyText": "Try without a catch is odd... normally it is try {} catch (Exception ignored) {}", "author": "Windchild292", "createdAt": "2021-03-12T20:22:07Z", "path": "MekHQ/src/mekhq/campaign/mission/atb/AtBScenarioManifest.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.mission.atb;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.util.Map;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBElement;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.transform.Source;\n+\n+import mekhq.MekHQ;\n+import mekhq.MekHqXmlUtil;\n+\n+/**\n+ * A manifest containing IDs and file names of scenario template definitions\n+ * @author NickAragua\n+ *\n+ */\n+@XmlRootElement(name=\"scenarioManifest\")\n+public class AtBScenarioManifest {\n+    @XmlElementWrapper(name=\"scenarioFileNames\")\n+    @XmlElement(name=\"scenarioFileName\")\n+    public Map<Integer, String> scenarioFileNames;\n+    \n+    /**\n+     * Attempt to deserialize an instance of an AtBScenarioManifest from the passed-in file path\n+     * @return Possibly an instance of a ScenarioManifest\n+     */\n+    public static AtBScenarioManifest Deserialize(String fileName) {\n+        AtBScenarioManifest resultingManifest = null;\n+        File inputFile = new File(fileName);\n+        if(!inputFile.exists()) {\n+            MekHQ.getLogger().warning(String.format(\"Specified file %s does not exist\", fileName));\n+            return null;\n+        }\n+\n+        try {\n+            JAXBContext context = JAXBContext.newInstance(AtBScenarioManifest.class);\n+            Unmarshaller um = context.createUnmarshaller();\n+            try (FileInputStream fileStream = new FileInputStream(inputFile)) {\n+                Source inputSource = MekHqXmlUtil.createSafeXmlSource(fileStream);\n+                JAXBElement<AtBScenarioManifest> manifestElement = um.unmarshal(inputSource, AtBScenarioManifest.class);\n+                resultingManifest = manifestElement.getValue();\n+            }", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQ0Mjk4Mw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593442983", "bodyText": "And that holds for most of these", "author": "Windchild292", "createdAt": "2021-03-12T20:51:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQyNzg1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzU1MTM0OA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593551348", "bodyText": "It's caught by the outer try/catch statement - the point of it is to ensure that the file stream falls out of context in case an exception is thrown.", "author": "NickAragua", "createdAt": "2021-03-13T03:21:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQyNzg1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQyNzkwNQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593427905", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    } catch(Exception e) {\n          \n          \n            \n                    } catch (Exception e) {", "author": "Windchild292", "createdAt": "2021-03-12T20:22:14Z", "path": "MekHQ/src/mekhq/campaign/mission/atb/AtBScenarioManifest.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.mission.atb;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.util.Map;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBElement;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.transform.Source;\n+\n+import mekhq.MekHQ;\n+import mekhq.MekHqXmlUtil;\n+\n+/**\n+ * A manifest containing IDs and file names of scenario template definitions\n+ * @author NickAragua\n+ *\n+ */\n+@XmlRootElement(name=\"scenarioManifest\")\n+public class AtBScenarioManifest {\n+    @XmlElementWrapper(name=\"scenarioFileNames\")\n+    @XmlElement(name=\"scenarioFileName\")\n+    public Map<Integer, String> scenarioFileNames;\n+    \n+    /**\n+     * Attempt to deserialize an instance of an AtBScenarioManifest from the passed-in file path\n+     * @return Possibly an instance of a ScenarioManifest\n+     */\n+    public static AtBScenarioManifest Deserialize(String fileName) {\n+        AtBScenarioManifest resultingManifest = null;\n+        File inputFile = new File(fileName);\n+        if(!inputFile.exists()) {\n+            MekHQ.getLogger().warning(String.format(\"Specified file %s does not exist\", fileName));\n+            return null;\n+        }\n+\n+        try {\n+            JAXBContext context = JAXBContext.newInstance(AtBScenarioManifest.class);\n+            Unmarshaller um = context.createUnmarshaller();\n+            try (FileInputStream fileStream = new FileInputStream(inputFile)) {\n+                Source inputSource = MekHqXmlUtil.createSafeXmlSource(fileStream);\n+                JAXBElement<AtBScenarioManifest> manifestElement = um.unmarshal(inputSource, AtBScenarioManifest.class);\n+                resultingManifest = manifestElement.getValue();\n+            }\n+        } catch(Exception e) {", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzM5NjI5OA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603396298", "bodyText": "Still valid", "author": "Windchild292", "createdAt": "2021-03-29T15:33:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQyNzkwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQyODA5Nw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593428097", "bodyText": "Is the boxing here actually required?", "author": "Windchild292", "createdAt": "2021-03-12T20:22:37Z", "path": "MekHQ/src/mekhq/campaign/mission/atb/AtBScenarioModifierApplicator.java", "diffHunk": "@@ -344,4 +344,12 @@ public static void applyObjective(AtBDynamicScenario scenario, Campaign campaign\n             scenario.getScenarioObjectives().add(actualObjective);\n         }\n     }\n+    \n+    /**\n+     * Applies an additional event, selected from only modifiers that benefit the player or do not benefit the player\n+     */\n+    public static void applyExtraEvent(AtBDynamicScenario scenario, Campaign campaign, boolean goodEvent) {\n+        scenario.addScenarioModifier(AtBScenarioModifier.getRandomBattleModifier(scenario.getTemplate().mapParameters.getMapLocation(), \n+                (Boolean) goodEvent));", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzgzNDEyMQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593834121", "bodyText": "Yes, it may be null, in which case we take from the pool of all possible modifiers.", "author": "NickAragua", "createdAt": "2021-03-14T03:17:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQyODA5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQyODIyMA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593428220", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             *\n          \n          \n            \n             */\n          \n          \n            \n             */", "author": "Windchild292", "createdAt": "2021-03-12T20:22:53Z", "path": "MekHQ/src/mekhq/campaign/stratcon/IStratconDisplayable.java", "diffHunk": "@@ -0,0 +1,11 @@\n+package mekhq.campaign.stratcon;\n+\n+/**\n+ * This interface defines a stratcon element (a facility or a scenario currently)\n+ * that is able to provide various kinds of information for display in some UI elements.\n+ * @author NickAragua\n+ *\n+ */", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQyODMyNQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593428325", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             *", "author": "Windchild292", "createdAt": "2021-03-12T20:23:04Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconCampaignState.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package mekhq.campaign.stratcon;\n+\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBElement;\n+import javax.xml.bind.Marshaller;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlTransient;\n+import javax.xml.namespace.QName;\n+\n+import org.w3c.dom.Node;\n+\n+import mekhq.MekHQ;\n+import mekhq.campaign.mission.AtBContract;\n+\n+/**\n+ * Contract-level state object for a stratcon campaign.\n+ * @author NickAragua\n+ *", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQyOTA5NQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593429095", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for(StratconTrackState trackState : tracks) {\n          \n          \n            \n                        if(trackState.getAssignedForceCoords().containsKey(forceID)) {\n          \n          \n            \n                    for (StratconTrackState trackState : tracks) {\n          \n          \n            \n                        if (trackState.getAssignedForceCoords().containsKey(forceID)) {", "author": "Windchild292", "createdAt": "2021-03-12T20:24:41Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconCampaignState.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package mekhq.campaign.stratcon;\n+\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBElement;\n+import javax.xml.bind.Marshaller;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlTransient;\n+import javax.xml.namespace.QName;\n+\n+import org.w3c.dom.Node;\n+\n+import mekhq.MekHQ;\n+import mekhq.campaign.mission.AtBContract;\n+\n+/**\n+ * Contract-level state object for a stratcon campaign.\n+ * @author NickAragua\n+ *\n+ */\n+@XmlRootElement(name=\"StratconCampaignState\")\n+public class StratconCampaignState {\n+    public static final String ROOT_XML_ELEMENT_NAME = \"StratconCampaignState\";\n+    \n+    @XmlTransient\n+    private AtBContract contract;\n+\n+    // these are all state variables that affect the current Stratcon Campaign\n+    private double globalOpforBVMultiplier;\n+    private int supportPoints;\n+    private int victoryPoints;\n+    private int pendingStrategicObjectiveCount;\n+    private int completedStrategicObjectiveCount;\n+    private String briefingText; \n+    private boolean strategicObjectivesBehaveAsVPs;\n+    \n+    // these are applied to any scenario generated in the campaign; use sparingly\n+    private List<String> globalScenarioModifiers = new ArrayList<>(); \n+    \n+    @XmlElementWrapper(name=\"campaignTracks\")\n+    @XmlElement(name=\"campaignTrack\")\n+    private List<StratconTrackState> tracks;\n+\n+    @XmlTransient\n+    public AtBContract getContract() {\n+        return contract;\n+    }\n+\n+    public void setContract(AtBContract contract) {\n+        this.contract = contract;\n+    }\n+\n+    public StratconCampaignState() {\n+        tracks = new ArrayList<>();\n+    }\n+    \n+    public StratconCampaignState(AtBContract contract) {\n+        tracks = new ArrayList<>();\n+        this.setContract(contract);\n+    }\n+\n+    /**\n+     * The opfor BV multiplier. Intended to be additive.\n+     * @return The additive opfor BV multiplier.\n+     */\n+    public double getGlobalOpforBVMultiplier() {\n+        return globalOpforBVMultiplier;\n+    }\n+    \n+    public StratconTrackState getTrack(int index) {\n+        return tracks.get(index);\n+    }\n+    \n+    public List<StratconTrackState> getTracks() {\n+        return tracks;\n+    }\n+    \n+    public void addTrack(StratconTrackState track) {\n+        tracks.add(track);\n+    }\n+    \n+    public int getSupportPoints() {\n+        return supportPoints;\n+    }\n+    \n+    public void addSupportPoints(int number) {\n+        supportPoints += number;\n+    }\n+    \n+    public void setSupportPoints(int supportPoints) {\n+        this.supportPoints = supportPoints;\n+    }\n+\n+    public int getVictoryPoints() {\n+        return victoryPoints;\n+    }\n+\n+    public void setVictoryPoints(int victoryPoints) {\n+        this.victoryPoints = victoryPoints;\n+    }\n+    \n+    public void updateVictoryPoints(int increment) {\n+        victoryPoints += increment;\n+    }\n+\n+    public String getBriefingText() {\n+        return briefingText;\n+    }\n+\n+    public void setBriefingText(String briefingText) {\n+        this.briefingText = briefingText;\n+    }\n+\n+    public boolean strategicObjectivesBehaveAsVPs() {\n+        return strategicObjectivesBehaveAsVPs;\n+    }\n+\n+    public void setStrategicObjectivesBehaveAsVPs(boolean strategicObjectivesBehaveAsVPs) {\n+        this.strategicObjectivesBehaveAsVPs = strategicObjectivesBehaveAsVPs;\n+    }\n+\n+    public List<String> getGlobalScenarioModifiers() {\n+        return globalScenarioModifiers;\n+    }\n+\n+    public void setGlobalScenarioModifiers(List<String> globalScenarioModifiers) {\n+        this.globalScenarioModifiers = globalScenarioModifiers;\n+    }\n+\n+    public int getPendingStrategicObjectiveCount() {\n+        return pendingStrategicObjectiveCount;\n+    }\n+\n+    public void setPendingStrategicObjectiveCount(int pendingStrategicObjectiveCount) {\n+        this.pendingStrategicObjectiveCount = pendingStrategicObjectiveCount;\n+    }\n+    \n+    public void incrementPendingStrategicObjectiveCount(int increment) {\n+        this.pendingStrategicObjectiveCount += increment;\n+    }\n+    \n+    public void incrementPendingStrategicObjectiveCount() {\n+        pendingStrategicObjectiveCount++;\n+    }\n+    \n+    public int getStrategicObjectiveCompletedCount() {\n+        return completedStrategicObjectiveCount;\n+    }\n+    \n+    public void incrementStrategicObjectiveCompletedCount() {\n+        completedStrategicObjectiveCount++;\n+    }\n+    \n+    public void decrementStrategicObjectiveCompletedCount() {\n+        completedStrategicObjectiveCount--;\n+    }\n+    \n+    public void useSupportPoint() {\n+        supportPoints--;\n+    }\n+    \n+    public void convertVictoryToSupportPoint() {\n+        victoryPoints--;\n+        supportPoints++;\n+    }\n+    \n+    /**\n+     * Convenience/speed method of determining whether or not a force with the given ID has been deployed to a track in this campaign.\n+     * @param forceID the force ID to check\n+     * @return Deployed or not.\n+     */\n+    public boolean isForceDeployedHere(int forceID) {\n+        for(StratconTrackState trackState : tracks) {\n+            if(trackState.getAssignedForceCoords().containsKey(forceID)) {", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQyOTE2Ng==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593429166", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    } catch(Exception e) {\n          \n          \n            \n                    } catch (Exception e) {", "author": "Windchild292", "createdAt": "2021-03-12T20:24:50Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconCampaignState.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package mekhq.campaign.stratcon;\n+\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBElement;\n+import javax.xml.bind.Marshaller;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlTransient;\n+import javax.xml.namespace.QName;\n+\n+import org.w3c.dom.Node;\n+\n+import mekhq.MekHQ;\n+import mekhq.campaign.mission.AtBContract;\n+\n+/**\n+ * Contract-level state object for a stratcon campaign.\n+ * @author NickAragua\n+ *\n+ */\n+@XmlRootElement(name=\"StratconCampaignState\")\n+public class StratconCampaignState {\n+    public static final String ROOT_XML_ELEMENT_NAME = \"StratconCampaignState\";\n+    \n+    @XmlTransient\n+    private AtBContract contract;\n+\n+    // these are all state variables that affect the current Stratcon Campaign\n+    private double globalOpforBVMultiplier;\n+    private int supportPoints;\n+    private int victoryPoints;\n+    private int pendingStrategicObjectiveCount;\n+    private int completedStrategicObjectiveCount;\n+    private String briefingText; \n+    private boolean strategicObjectivesBehaveAsVPs;\n+    \n+    // these are applied to any scenario generated in the campaign; use sparingly\n+    private List<String> globalScenarioModifiers = new ArrayList<>(); \n+    \n+    @XmlElementWrapper(name=\"campaignTracks\")\n+    @XmlElement(name=\"campaignTrack\")\n+    private List<StratconTrackState> tracks;\n+\n+    @XmlTransient\n+    public AtBContract getContract() {\n+        return contract;\n+    }\n+\n+    public void setContract(AtBContract contract) {\n+        this.contract = contract;\n+    }\n+\n+    public StratconCampaignState() {\n+        tracks = new ArrayList<>();\n+    }\n+    \n+    public StratconCampaignState(AtBContract contract) {\n+        tracks = new ArrayList<>();\n+        this.setContract(contract);\n+    }\n+\n+    /**\n+     * The opfor BV multiplier. Intended to be additive.\n+     * @return The additive opfor BV multiplier.\n+     */\n+    public double getGlobalOpforBVMultiplier() {\n+        return globalOpforBVMultiplier;\n+    }\n+    \n+    public StratconTrackState getTrack(int index) {\n+        return tracks.get(index);\n+    }\n+    \n+    public List<StratconTrackState> getTracks() {\n+        return tracks;\n+    }\n+    \n+    public void addTrack(StratconTrackState track) {\n+        tracks.add(track);\n+    }\n+    \n+    public int getSupportPoints() {\n+        return supportPoints;\n+    }\n+    \n+    public void addSupportPoints(int number) {\n+        supportPoints += number;\n+    }\n+    \n+    public void setSupportPoints(int supportPoints) {\n+        this.supportPoints = supportPoints;\n+    }\n+\n+    public int getVictoryPoints() {\n+        return victoryPoints;\n+    }\n+\n+    public void setVictoryPoints(int victoryPoints) {\n+        this.victoryPoints = victoryPoints;\n+    }\n+    \n+    public void updateVictoryPoints(int increment) {\n+        victoryPoints += increment;\n+    }\n+\n+    public String getBriefingText() {\n+        return briefingText;\n+    }\n+\n+    public void setBriefingText(String briefingText) {\n+        this.briefingText = briefingText;\n+    }\n+\n+    public boolean strategicObjectivesBehaveAsVPs() {\n+        return strategicObjectivesBehaveAsVPs;\n+    }\n+\n+    public void setStrategicObjectivesBehaveAsVPs(boolean strategicObjectivesBehaveAsVPs) {\n+        this.strategicObjectivesBehaveAsVPs = strategicObjectivesBehaveAsVPs;\n+    }\n+\n+    public List<String> getGlobalScenarioModifiers() {\n+        return globalScenarioModifiers;\n+    }\n+\n+    public void setGlobalScenarioModifiers(List<String> globalScenarioModifiers) {\n+        this.globalScenarioModifiers = globalScenarioModifiers;\n+    }\n+\n+    public int getPendingStrategicObjectiveCount() {\n+        return pendingStrategicObjectiveCount;\n+    }\n+\n+    public void setPendingStrategicObjectiveCount(int pendingStrategicObjectiveCount) {\n+        this.pendingStrategicObjectiveCount = pendingStrategicObjectiveCount;\n+    }\n+    \n+    public void incrementPendingStrategicObjectiveCount(int increment) {\n+        this.pendingStrategicObjectiveCount += increment;\n+    }\n+    \n+    public void incrementPendingStrategicObjectiveCount() {\n+        pendingStrategicObjectiveCount++;\n+    }\n+    \n+    public int getStrategicObjectiveCompletedCount() {\n+        return completedStrategicObjectiveCount;\n+    }\n+    \n+    public void incrementStrategicObjectiveCompletedCount() {\n+        completedStrategicObjectiveCount++;\n+    }\n+    \n+    public void decrementStrategicObjectiveCompletedCount() {\n+        completedStrategicObjectiveCount--;\n+    }\n+    \n+    public void useSupportPoint() {\n+        supportPoints--;\n+    }\n+    \n+    public void convertVictoryToSupportPoint() {\n+        victoryPoints--;\n+        supportPoints++;\n+    }\n+    \n+    /**\n+     * Convenience/speed method of determining whether or not a force with the given ID has been deployed to a track in this campaign.\n+     * @param forceID the force ID to check\n+     * @return Deployed or not.\n+     */\n+    public boolean isForceDeployedHere(int forceID) {\n+        for(StratconTrackState trackState : tracks) {\n+            if(trackState.getAssignedForceCoords().containsKey(forceID)) {\n+                return true;\n+            }\n+        }\n+        \n+        return false;\n+    }\n+    \n+    /**\n+     * Serialize this instance of a campaign state to a PrintWriter\n+     * Omits initial xml declaration\n+     * @param pw The destination print writer\n+     */\n+    public void Serialize(PrintWriter pw) {\n+        try {\n+            JAXBContext context = JAXBContext.newInstance(StratconCampaignState.class);\n+            JAXBElement<StratconCampaignState> stateElement = new JAXBElement<>(new QName(ROOT_XML_ELEMENT_NAME), StratconCampaignState.class, this);\n+            Marshaller m = context.createMarshaller();\n+            m.setProperty(Marshaller.JAXB_FRAGMENT, true);\n+            m.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);\n+            m.marshal(stateElement, pw);\n+        } catch(Exception e) {", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQyOTg1NQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593429855", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // hack: localdate doesn't serialize/deserialize nicely within a map, so we store it as a int-string map instead\n          \n          \n            \n                    // Hack: LocalDate doesn't serialize/deserialize nicely within a map, so we store it as a int-string map instead", "author": "Windchild292", "createdAt": "2021-03-12T20:26:06Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconCampaignState.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package mekhq.campaign.stratcon;\n+\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBElement;\n+import javax.xml.bind.Marshaller;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlTransient;\n+import javax.xml.namespace.QName;\n+\n+import org.w3c.dom.Node;\n+\n+import mekhq.MekHQ;\n+import mekhq.campaign.mission.AtBContract;\n+\n+/**\n+ * Contract-level state object for a stratcon campaign.\n+ * @author NickAragua\n+ *\n+ */\n+@XmlRootElement(name=\"StratconCampaignState\")\n+public class StratconCampaignState {\n+    public static final String ROOT_XML_ELEMENT_NAME = \"StratconCampaignState\";\n+    \n+    @XmlTransient\n+    private AtBContract contract;\n+\n+    // these are all state variables that affect the current Stratcon Campaign\n+    private double globalOpforBVMultiplier;\n+    private int supportPoints;\n+    private int victoryPoints;\n+    private int pendingStrategicObjectiveCount;\n+    private int completedStrategicObjectiveCount;\n+    private String briefingText; \n+    private boolean strategicObjectivesBehaveAsVPs;\n+    \n+    // these are applied to any scenario generated in the campaign; use sparingly\n+    private List<String> globalScenarioModifiers = new ArrayList<>(); \n+    \n+    @XmlElementWrapper(name=\"campaignTracks\")\n+    @XmlElement(name=\"campaignTrack\")\n+    private List<StratconTrackState> tracks;\n+\n+    @XmlTransient\n+    public AtBContract getContract() {\n+        return contract;\n+    }\n+\n+    public void setContract(AtBContract contract) {\n+        this.contract = contract;\n+    }\n+\n+    public StratconCampaignState() {\n+        tracks = new ArrayList<>();\n+    }\n+    \n+    public StratconCampaignState(AtBContract contract) {\n+        tracks = new ArrayList<>();\n+        this.setContract(contract);\n+    }\n+\n+    /**\n+     * The opfor BV multiplier. Intended to be additive.\n+     * @return The additive opfor BV multiplier.\n+     */\n+    public double getGlobalOpforBVMultiplier() {\n+        return globalOpforBVMultiplier;\n+    }\n+    \n+    public StratconTrackState getTrack(int index) {\n+        return tracks.get(index);\n+    }\n+    \n+    public List<StratconTrackState> getTracks() {\n+        return tracks;\n+    }\n+    \n+    public void addTrack(StratconTrackState track) {\n+        tracks.add(track);\n+    }\n+    \n+    public int getSupportPoints() {\n+        return supportPoints;\n+    }\n+    \n+    public void addSupportPoints(int number) {\n+        supportPoints += number;\n+    }\n+    \n+    public void setSupportPoints(int supportPoints) {\n+        this.supportPoints = supportPoints;\n+    }\n+\n+    public int getVictoryPoints() {\n+        return victoryPoints;\n+    }\n+\n+    public void setVictoryPoints(int victoryPoints) {\n+        this.victoryPoints = victoryPoints;\n+    }\n+    \n+    public void updateVictoryPoints(int increment) {\n+        victoryPoints += increment;\n+    }\n+\n+    public String getBriefingText() {\n+        return briefingText;\n+    }\n+\n+    public void setBriefingText(String briefingText) {\n+        this.briefingText = briefingText;\n+    }\n+\n+    public boolean strategicObjectivesBehaveAsVPs() {\n+        return strategicObjectivesBehaveAsVPs;\n+    }\n+\n+    public void setStrategicObjectivesBehaveAsVPs(boolean strategicObjectivesBehaveAsVPs) {\n+        this.strategicObjectivesBehaveAsVPs = strategicObjectivesBehaveAsVPs;\n+    }\n+\n+    public List<String> getGlobalScenarioModifiers() {\n+        return globalScenarioModifiers;\n+    }\n+\n+    public void setGlobalScenarioModifiers(List<String> globalScenarioModifiers) {\n+        this.globalScenarioModifiers = globalScenarioModifiers;\n+    }\n+\n+    public int getPendingStrategicObjectiveCount() {\n+        return pendingStrategicObjectiveCount;\n+    }\n+\n+    public void setPendingStrategicObjectiveCount(int pendingStrategicObjectiveCount) {\n+        this.pendingStrategicObjectiveCount = pendingStrategicObjectiveCount;\n+    }\n+    \n+    public void incrementPendingStrategicObjectiveCount(int increment) {\n+        this.pendingStrategicObjectiveCount += increment;\n+    }\n+    \n+    public void incrementPendingStrategicObjectiveCount() {\n+        pendingStrategicObjectiveCount++;\n+    }\n+    \n+    public int getStrategicObjectiveCompletedCount() {\n+        return completedStrategicObjectiveCount;\n+    }\n+    \n+    public void incrementStrategicObjectiveCompletedCount() {\n+        completedStrategicObjectiveCount++;\n+    }\n+    \n+    public void decrementStrategicObjectiveCompletedCount() {\n+        completedStrategicObjectiveCount--;\n+    }\n+    \n+    public void useSupportPoint() {\n+        supportPoints--;\n+    }\n+    \n+    public void convertVictoryToSupportPoint() {\n+        victoryPoints--;\n+        supportPoints++;\n+    }\n+    \n+    /**\n+     * Convenience/speed method of determining whether or not a force with the given ID has been deployed to a track in this campaign.\n+     * @param forceID the force ID to check\n+     * @return Deployed or not.\n+     */\n+    public boolean isForceDeployedHere(int forceID) {\n+        for(StratconTrackState trackState : tracks) {\n+            if(trackState.getAssignedForceCoords().containsKey(forceID)) {\n+                return true;\n+            }\n+        }\n+        \n+        return false;\n+    }\n+    \n+    /**\n+     * Serialize this instance of a campaign state to a PrintWriter\n+     * Omits initial xml declaration\n+     * @param pw The destination print writer\n+     */\n+    public void Serialize(PrintWriter pw) {\n+        try {\n+            JAXBContext context = JAXBContext.newInstance(StratconCampaignState.class);\n+            JAXBElement<StratconCampaignState> stateElement = new JAXBElement<>(new QName(ROOT_XML_ELEMENT_NAME), StratconCampaignState.class, this);\n+            Marshaller m = context.createMarshaller();\n+            m.setProperty(Marshaller.JAXB_FRAGMENT, true);\n+            m.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);\n+            m.marshal(stateElement, pw);\n+        } catch(Exception e) {\n+            MekHQ.getLogger().error(e);\n+        }\n+    }\n+    \n+    /**\n+     * Attempt to deserialize an instance of a Campaign State from the passed-in XML Node\n+     * @param xmlNode The node with the campaign state\n+     * @return Possibly an instance of a StratconCampaignState\n+     */\n+    public static StratconCampaignState Deserialize(Node xmlNode) {        \n+        StratconCampaignState resultingCampaignState = null;\n+        \n+        try {\n+            JAXBContext context = JAXBContext.newInstance(StratconCampaignState.class);\n+            Unmarshaller um = context.createUnmarshaller();\n+            JAXBElement<StratconCampaignState> templateElement = um.unmarshal(xmlNode, StratconCampaignState.class);\n+            resultingCampaignState = templateElement.getValue();\n+        } catch (Exception e) {\n+            MekHQ.getLogger().error(\"Error Deserializing Campaign State\", e);\n+        }\n+        \n+        // hack: localdate doesn't serialize/deserialize nicely within a map, so we store it as a int-string map instead", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQzMDAwNw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593430007", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if(userDefinitionList != null) {\n          \n          \n            \n                    if (userDefinitionList != null) {", "author": "Windchild292", "createdAt": "2021-03-12T20:26:23Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconContractDefinition.java", "diffHunk": "@@ -0,0 +1,420 @@\n+package mekhq.campaign.stratcon;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBElement;\n+import javax.xml.bind.Marshaller;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.namespace.QName;\n+import javax.xml.transform.Source;\n+\n+import mekhq.MekHQ;\n+import mekhq.MekHqXmlUtil;\n+\n+/**\n+ * This class holds data relevant to the various types of contract\n+ * that can occur in the StratCon campaign system.\n+ * @author NickAragua\n+ *\n+ */\n+@XmlRootElement(name=\"StratconContractDefinition\")\n+public class StratconContractDefinition {\n+    public static final String ROOT_XML_ELEMENT_NAME = \"ScenarioTemplate\";\n+    public static final int COUNT_SCALED = -1;\n+    \n+    private static ContractDefinitionManifest definitionManifest;\n+    private static Map<Integer, StratconContractDefinition> loadedDefinitions = new HashMap<>();\n+    \n+    static {\n+        definitionManifest = ContractDefinitionManifest.Deserialize(\"./data/stratconcontractdefinitions/ContractDefinitionManifest.xml\");\n+        \n+        // load user-specified modifier list\n+        ContractDefinitionManifest userDefinitionList = ContractDefinitionManifest.Deserialize(\"./data/scenariomodifiers/UserContractDefinitionManifest.xml\");\n+        if(userDefinitionList != null) {", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQzMDk1MQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593430951", "bodyText": "Filenames should probably not be inline, but rather located within a file. I've been moving a few to MekHQ Options, although I'm not sure that's the best place for them either.", "author": "Windchild292", "createdAt": "2021-03-12T20:28:00Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconContractDefinition.java", "diffHunk": "@@ -0,0 +1,420 @@\n+package mekhq.campaign.stratcon;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBElement;\n+import javax.xml.bind.Marshaller;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.namespace.QName;\n+import javax.xml.transform.Source;\n+\n+import mekhq.MekHQ;\n+import mekhq.MekHqXmlUtil;\n+\n+/**\n+ * This class holds data relevant to the various types of contract\n+ * that can occur in the StratCon campaign system.\n+ * @author NickAragua\n+ *\n+ */\n+@XmlRootElement(name=\"StratconContractDefinition\")\n+public class StratconContractDefinition {\n+    public static final String ROOT_XML_ELEMENT_NAME = \"ScenarioTemplate\";\n+    public static final int COUNT_SCALED = -1;\n+    \n+    private static ContractDefinitionManifest definitionManifest;\n+    private static Map<Integer, StratconContractDefinition> loadedDefinitions = new HashMap<>();\n+    \n+    static {\n+        definitionManifest = ContractDefinitionManifest.Deserialize(\"./data/stratconcontractdefinitions/ContractDefinitionManifest.xml\");\n+        \n+        // load user-specified modifier list\n+        ContractDefinitionManifest userDefinitionList = ContractDefinitionManifest.Deserialize(\"./data/scenariomodifiers/UserContractDefinitionManifest.xml\");\n+        if(userDefinitionList != null) {\n+            definitionManifest.definitionFileNames.putAll(userDefinitionList.definitionFileNames);\n+        }\n+    }\n+    \n+    /**\n+     * Returns the stratcon contract definition for the given AtB Contract Type \n+     * as defined in AtBContract.java\n+     */\n+    public static StratconContractDefinition getContractDefinition(int atbContractType) {\n+        definitionManifest = ContractDefinitionManifest.Deserialize(\"./data/stratconcontractdefinitions/ContractDefinitionManifest.xml\");\n+        loadedDefinitions.clear();\n+        \n+        if (!loadedDefinitions.containsKey(atbContractType)) {\n+            String filePath = String.format(\"./data/stratconcontractdefinitions/%s\", ", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQzMTA2MA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593431060", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *\n          \n          \n            \n                 */\n          \n          \n            \n                 */", "author": "Windchild292", "createdAt": "2021-03-12T20:28:12Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconContractDefinition.java", "diffHunk": "@@ -0,0 +1,420 @@\n+package mekhq.campaign.stratcon;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBElement;\n+import javax.xml.bind.Marshaller;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.namespace.QName;\n+import javax.xml.transform.Source;\n+\n+import mekhq.MekHQ;\n+import mekhq.MekHqXmlUtil;\n+\n+/**\n+ * This class holds data relevant to the various types of contract\n+ * that can occur in the StratCon campaign system.\n+ * @author NickAragua\n+ *\n+ */\n+@XmlRootElement(name=\"StratconContractDefinition\")\n+public class StratconContractDefinition {\n+    public static final String ROOT_XML_ELEMENT_NAME = \"ScenarioTemplate\";\n+    public static final int COUNT_SCALED = -1;\n+    \n+    private static ContractDefinitionManifest definitionManifest;\n+    private static Map<Integer, StratconContractDefinition> loadedDefinitions = new HashMap<>();\n+    \n+    static {\n+        definitionManifest = ContractDefinitionManifest.Deserialize(\"./data/stratconcontractdefinitions/ContractDefinitionManifest.xml\");\n+        \n+        // load user-specified modifier list\n+        ContractDefinitionManifest userDefinitionList = ContractDefinitionManifest.Deserialize(\"./data/scenariomodifiers/UserContractDefinitionManifest.xml\");\n+        if(userDefinitionList != null) {\n+            definitionManifest.definitionFileNames.putAll(userDefinitionList.definitionFileNames);\n+        }\n+    }\n+    \n+    /**\n+     * Returns the stratcon contract definition for the given AtB Contract Type \n+     * as defined in AtBContract.java\n+     */\n+    public static StratconContractDefinition getContractDefinition(int atbContractType) {\n+        definitionManifest = ContractDefinitionManifest.Deserialize(\"./data/stratconcontractdefinitions/ContractDefinitionManifest.xml\");\n+        loadedDefinitions.clear();\n+        \n+        if (!loadedDefinitions.containsKey(atbContractType)) {\n+            String filePath = String.format(\"./data/stratconcontractdefinitions/%s\", \n+                    definitionManifest.definitionFileNames.get(atbContractType));\n+            StratconContractDefinition def = Deserialize(new File(filePath));\n+            \n+            if (def == null) {\n+                MekHQ.getLogger().error(String.format(\"Unable to load contract definition %s\", filePath));\n+                return null;\n+            }\n+            \n+            loadedDefinitions.put(atbContractType, def);\n+        }\n+        \n+        return loadedDefinitions.get(atbContractType);\n+    }\n+    \n+    /**\n+     * The kind of actions that the player needs to undertake to complete\n+     * strategic objectives for this contract.\n+     *\n+     */", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQzMzA4OA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593433088", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    } catch(Exception e) {\n          \n          \n            \n                    } catch (Exception e) {", "author": "Windchild292", "createdAt": "2021-03-12T20:32:10Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconContractDefinition.java", "diffHunk": "@@ -0,0 +1,420 @@\n+package mekhq.campaign.stratcon;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBElement;\n+import javax.xml.bind.Marshaller;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.namespace.QName;\n+import javax.xml.transform.Source;\n+\n+import mekhq.MekHQ;\n+import mekhq.MekHqXmlUtil;\n+\n+/**\n+ * This class holds data relevant to the various types of contract\n+ * that can occur in the StratCon campaign system.\n+ * @author NickAragua\n+ *\n+ */\n+@XmlRootElement(name=\"StratconContractDefinition\")\n+public class StratconContractDefinition {\n+    public static final String ROOT_XML_ELEMENT_NAME = \"ScenarioTemplate\";\n+    public static final int COUNT_SCALED = -1;\n+    \n+    private static ContractDefinitionManifest definitionManifest;\n+    private static Map<Integer, StratconContractDefinition> loadedDefinitions = new HashMap<>();\n+    \n+    static {\n+        definitionManifest = ContractDefinitionManifest.Deserialize(\"./data/stratconcontractdefinitions/ContractDefinitionManifest.xml\");\n+        \n+        // load user-specified modifier list\n+        ContractDefinitionManifest userDefinitionList = ContractDefinitionManifest.Deserialize(\"./data/scenariomodifiers/UserContractDefinitionManifest.xml\");\n+        if(userDefinitionList != null) {\n+            definitionManifest.definitionFileNames.putAll(userDefinitionList.definitionFileNames);\n+        }\n+    }\n+    \n+    /**\n+     * Returns the stratcon contract definition for the given AtB Contract Type \n+     * as defined in AtBContract.java\n+     */\n+    public static StratconContractDefinition getContractDefinition(int atbContractType) {\n+        definitionManifest = ContractDefinitionManifest.Deserialize(\"./data/stratconcontractdefinitions/ContractDefinitionManifest.xml\");\n+        loadedDefinitions.clear();\n+        \n+        if (!loadedDefinitions.containsKey(atbContractType)) {\n+            String filePath = String.format(\"./data/stratconcontractdefinitions/%s\", \n+                    definitionManifest.definitionFileNames.get(atbContractType));\n+            StratconContractDefinition def = Deserialize(new File(filePath));\n+            \n+            if (def == null) {\n+                MekHQ.getLogger().error(String.format(\"Unable to load contract definition %s\", filePath));\n+                return null;\n+            }\n+            \n+            loadedDefinitions.put(atbContractType, def);\n+        }\n+        \n+        return loadedDefinitions.get(atbContractType);\n+    }\n+    \n+    /**\n+     * The kind of actions that the player needs to undertake to complete\n+     * strategic objectives for this contract.\n+     *\n+     */\n+    public enum StrategicObjectiveType {\n+        /**\n+         * Victory in any scenario\n+         */\n+        AnyScenarioVictory,\n+        \n+        /**\n+         * Victory in scenarios - designated by the \"objectiveScenarios\" collection.\n+         * These are one-off scenarios that stick around on tracks - when revealed, \n+         * they get a deploy/action/return date as usual, and the player gets one shot to complete them\n+         */\n+        SpecificScenarioVictory,\n+        \n+        /**\n+         * Control of allied facilities generated at contract start time\n+         * Each track will be seeded with some number of allied facilities\n+         * They must not be destroyed and the player must have control of them at the end-of-contract date \n+         */\n+        AlliedFacilityControl,\n+        \n+        /**\n+         * Control of hostile facilities generated at contract start time\n+         * Each track will be seeded with some number of hostile facilities\n+         * They must not be destroyed and the player must have control of them at the end-of-contract date\n+         */\n+        HostileFacilityControl,\n+        \n+        /**\n+         * Destruction of hostile facilities generated at contract start time\n+         * Each track will be seeded with some number of hostile facilities\n+         * They may either be destroyed or the player must have control of them at the end-of-contract date\n+         */\n+        FacilityDestruction\n+    }\n+    \n+    public static StratconContractDefinition createTestContract() {\n+        /*StratconContractDefinition retVal = new StratconContractDefinition();\n+        \n+        retVal.contractTypeName = \"Test Contract Type\";\n+        retVal.briefing = \"Test Contract Briefing.\";\n+        retVal.alliedFacilityCount = 1;\n+        retVal.hostileFacilityCount = COUNT_SCALED;\n+        retVal.objectiveParameters = new ArrayList<>();\n+        \n+        ObjectiveParameters objective = new ObjectiveParameters();\n+        objective.objectiveType = StrategicObjectiveType.SpecificScenarioVictory;\n+        objective.objectiveCount = COUNT_SCALED;\n+        objective.objectiveScenarios = Arrays.asList(\"Capture.xml\", \"Assassinate.xml\");\n+        objective.objectiveScenarioModifiers = Arrays.asList(\"AlliedTankGarrison.xml\", \"HostileAirGarrison.xml\");\n+        \n+        retVal.objectiveParameters.add(objective);\n+        \n+        retVal.allowedScenarios = Arrays.asList(\"TestAllowScenario.xml\", \"TestAllowScenario.xml\");\n+        retVal.forbiddenScenarios = Arrays.asList(\"TestForbidScenario.xml\", \"TestForbidScenario.xml\");\n+        \n+        retVal.Serialize(new File(\"d:\\\\projects\\\\mekhq\\\\mekhq\\\\data\\\\stratconcontractdefinitions\\\\testcontract.xml\"));\n+        \n+        return retVal;*/\n+        StratconContractDefinition retVal = Deserialize(new File(\"d:\\\\projects\\\\mekhq\\\\mekhq\\\\data\\\\stratconcontractdefinitions\\\\ObjectiveRaid.xml\"));\n+        return retVal;\n+    }\n+    \n+    private String contractTypeName;\n+    private String briefing;\n+    \n+    /**\n+     * How many allied facilities to generate for the contract, \n+     * in addition to any facilities placed by objectives.\n+     * < 0 indicates that the number of facilities should be scaled to the number of \n+     * lances required by the contract. 0 indicates no additional allied facilities.\n+     */\n+    private double alliedFacilityCount;\n+    \n+    /**\n+     * How many hostile facilities to generate for the contract, \n+     * in addition to any facilities placed by objectives.\n+     * -1 indicates that the number of facilities should be scaled to the number of \n+     * lances required by the contract. 0 indicates no additional hostile facilities.\n+     */\n+    private double hostileFacilityCount;\n+    \n+    /**\n+     * List of scenario IDs (file names) that are allowed for this contract type\n+     */\n+    private List<String> allowedScenarios;\n+    \n+    /**\n+     * List of scenario IDs (file names) that are not allowed for this contract type\n+     */\n+    private List<String> forbiddenScenarios;\n+    \n+    /**\n+     * Strategic objectives for this contract.\n+     */\n+    private List<ObjectiveParameters> objectiveParameters;\n+    \n+    /**\n+     * If true, strategic objective scenarios contribute to the VP count\n+     */\n+    private boolean objectivesBehaveAsVPs;\n+    \n+    private List<Integer> scenarioOdds;\n+    \n+    private List<Integer> deploymentTimes;\n+\n+    public String getContractTypeName() {\n+        return contractTypeName;\n+    }\n+\n+    public void setContractTypeName(String contractTypeName) {\n+        this.contractTypeName = contractTypeName;\n+    }\n+\n+    /**\n+     * @return the briefing\n+     */\n+    public String getBriefing() {\n+        return briefing;\n+    }\n+\n+    /**\n+     * @param briefing the briefing to set\n+     */\n+    public void setBriefing(String briefing) {\n+        this.briefing = briefing;\n+    }\n+\n+    /**\n+     * @return the alliedFacilityCount\n+     */\n+    public double getAlliedFacilityCount() {\n+        return alliedFacilityCount;\n+    }\n+\n+    /**\n+     * @param alliedFacilityCount the alliedFacilityCount to set\n+     */\n+    public void setAlliedFacilityCount(double alliedFacilityCount) {\n+        this.alliedFacilityCount = alliedFacilityCount;\n+    }\n+\n+    /**\n+     * @return the hostileFacilityCount\n+     */\n+    public double getHostileFacilityCount() {\n+        return hostileFacilityCount;\n+    }\n+\n+    /**\n+     * @param hostileFacilityCount the hostileFacilityCount to set\n+     */\n+    public void setHostileFacilityCount(double hostileFacilityCount) {\n+        this.hostileFacilityCount = hostileFacilityCount;\n+    }\n+\n+    @XmlElementWrapper(name=\"allowedScenarios\")\n+    @XmlElement(name=\"allowedScenario\")\n+    public List<String> getAllowedScenarios() {\n+        return allowedScenarios;\n+    }\n+\n+    public void setAllowedScenarios(List<String> allowedScenarios) {\n+        this.allowedScenarios = allowedScenarios;\n+    }\n+\n+    @XmlElementWrapper(name=\"forbiddenScenarios\")\n+    @XmlElement(name=\"forbiddenScenario\")\n+    public List<String> getForbiddenScenarios() {\n+        return forbiddenScenarios;\n+    }\n+\n+    public void setForbiddenScenarios(List<String> forbiddenScenarios) {\n+        this.forbiddenScenarios = forbiddenScenarios;\n+    }\n+    \n+    @XmlElementWrapper(name=\"objectiveParameters\")\n+    @XmlElement(name=\"objectiveParameter\")\n+    public List<ObjectiveParameters> getObjectiveParameters() {\n+        return objectiveParameters;\n+    }\n+\n+    public void setObjectiveParameters(List<ObjectiveParameters> objectiveParameters) {\n+        this.objectiveParameters = objectiveParameters;\n+    }\n+\n+    public boolean objectivesBehaveAsVPs() {\n+        return objectivesBehaveAsVPs;\n+    }\n+\n+    public void setObjectivesBehaveAsVPs(boolean objectivesBehaveAsVPs) {\n+        this.objectivesBehaveAsVPs = objectivesBehaveAsVPs;\n+    }\n+\n+    @XmlElementWrapper(name=\"scenarioOdds\")\n+    @XmlElement(name=\"scenarioOdds\")\n+    public List<Integer> getScenarioOdds() {\n+        return scenarioOdds;\n+    }\n+\n+    public void setScenarioOdds(List<Integer> scenarioOdds) {\n+        this.scenarioOdds = scenarioOdds;\n+    }\n+\n+    @XmlElementWrapper(name=\"deploymentTimes\")\n+    @XmlElement(name=\"deploymentTimes\")\n+    public List<Integer> getDeploymentTimes() {\n+        return deploymentTimes;\n+    }\n+\n+    public void setDeploymentTimes(List<Integer> deploymentTimes) {\n+        this.deploymentTimes = deploymentTimes;\n+    }\n+\n+    public static class ObjectiveParameters {\n+        /**\n+         * The type of objective this is; \n+         */\n+        @XmlElement(name=\"objectiveType\")\n+        StrategicObjectiveType objectiveType;\n+        \n+        /**\n+         * How many strategic objectives will be placed for this contract.\n+         * 0 means none. A number less than zero indicates that the number of strategic objectives \n+         * should be scaled to the number of lances required by the contract, and multiplied by that factor. \n+         */\n+        @XmlElement(name=\"objectiveCount\")\n+        double objectiveCount;\n+        \n+        /**\n+         * List of IDs (file names) of specific scenarios to use for this objective.\n+         * Ignored for AnyScenarioVictory or AlliedFacilityControl objective types\n+         */\n+        @XmlElementWrapper(name=\"objectiveScenarios\")\n+        @XmlElement(name=\"objectiveScenario\")\n+        List<String> objectiveScenarios;\n+        \n+        /**\n+         * If a particular scenario being generated is a strategic objective, it will have\n+         * these modifiers applied to it\n+         */\n+        @XmlElementWrapper(name=\"objectiveScenarioModifiers\")\n+        @XmlElement(name=\"objectiveScenarioModifier\")\n+        List<String> objectiveScenarioModifiers;\n+    }\n+    \n+    // Garrison Duty: Defend X facilities\n+    // Cadre Duty: Victory in X Training Exercise scenarios\n+    // Security Duty: Defend X facilities\n+    // Riot Duty: Defend X facilities, Riot Suppression scenarios\n+    // Planetary Assault: Destroy or Capture and Hold X facilities\n+    // Relief Duty: Hold X facilities (on hostile world!)\n+    // Guerilla Warfare: Victory in X scenarios, soft time limit (reinforcements) on all scenarios\n+    // Pirate Hunting: Victory in X scenarios \n+    // Diversionary Warfare: Victory in X scenarios\n+    // Objective Raid: Destroy X facilities\n+    // Extraction Raid: Extract from X facilities, victory in X capture scenarios\n+    // Recon Raid: Recon on X facilities\n+    // \n+    // future expansion:\n+    // Assassination: Victory in X Assassination scenarios\n+    // Terrorism: Victory in X \"Riot Suppression\" scenarios\n+    // Bounty Hunt: Victory in X Assassination, X Capture scenarios\n+    // Mole Hunting: ?\n+    // Espionage: ?\n+    // Sabotage: ?\n+    // Observation Raid: ?\n+    \n+    /**\n+     * Serialize this instance of a scenario template to a File\n+     * Please pass in a non-null file.\n+     * @param outputFile The destination file.\n+     */\n+    public void Serialize(File outputFile) {\n+        try {\n+            JAXBContext context = JAXBContext.newInstance(StratconContractDefinition.class);\n+            JAXBElement<StratconContractDefinition> templateElement = new JAXBElement<>(new QName(ROOT_XML_ELEMENT_NAME), StratconContractDefinition.class, this);\n+            Marshaller m = context.createMarshaller();\n+            m.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);\n+            m.marshal(templateElement, outputFile);\n+        } catch(Exception e) {", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQzMzE3NA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593433174", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    } catch(Exception e) {\n          \n          \n            \n                    } catch (Exception e) {", "author": "Windchild292", "createdAt": "2021-03-12T20:32:19Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconContractDefinition.java", "diffHunk": "@@ -0,0 +1,420 @@\n+package mekhq.campaign.stratcon;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBElement;\n+import javax.xml.bind.Marshaller;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.namespace.QName;\n+import javax.xml.transform.Source;\n+\n+import mekhq.MekHQ;\n+import mekhq.MekHqXmlUtil;\n+\n+/**\n+ * This class holds data relevant to the various types of contract\n+ * that can occur in the StratCon campaign system.\n+ * @author NickAragua\n+ *\n+ */\n+@XmlRootElement(name=\"StratconContractDefinition\")\n+public class StratconContractDefinition {\n+    public static final String ROOT_XML_ELEMENT_NAME = \"ScenarioTemplate\";\n+    public static final int COUNT_SCALED = -1;\n+    \n+    private static ContractDefinitionManifest definitionManifest;\n+    private static Map<Integer, StratconContractDefinition> loadedDefinitions = new HashMap<>();\n+    \n+    static {\n+        definitionManifest = ContractDefinitionManifest.Deserialize(\"./data/stratconcontractdefinitions/ContractDefinitionManifest.xml\");\n+        \n+        // load user-specified modifier list\n+        ContractDefinitionManifest userDefinitionList = ContractDefinitionManifest.Deserialize(\"./data/scenariomodifiers/UserContractDefinitionManifest.xml\");\n+        if(userDefinitionList != null) {\n+            definitionManifest.definitionFileNames.putAll(userDefinitionList.definitionFileNames);\n+        }\n+    }\n+    \n+    /**\n+     * Returns the stratcon contract definition for the given AtB Contract Type \n+     * as defined in AtBContract.java\n+     */\n+    public static StratconContractDefinition getContractDefinition(int atbContractType) {\n+        definitionManifest = ContractDefinitionManifest.Deserialize(\"./data/stratconcontractdefinitions/ContractDefinitionManifest.xml\");\n+        loadedDefinitions.clear();\n+        \n+        if (!loadedDefinitions.containsKey(atbContractType)) {\n+            String filePath = String.format(\"./data/stratconcontractdefinitions/%s\", \n+                    definitionManifest.definitionFileNames.get(atbContractType));\n+            StratconContractDefinition def = Deserialize(new File(filePath));\n+            \n+            if (def == null) {\n+                MekHQ.getLogger().error(String.format(\"Unable to load contract definition %s\", filePath));\n+                return null;\n+            }\n+            \n+            loadedDefinitions.put(atbContractType, def);\n+        }\n+        \n+        return loadedDefinitions.get(atbContractType);\n+    }\n+    \n+    /**\n+     * The kind of actions that the player needs to undertake to complete\n+     * strategic objectives for this contract.\n+     *\n+     */\n+    public enum StrategicObjectiveType {\n+        /**\n+         * Victory in any scenario\n+         */\n+        AnyScenarioVictory,\n+        \n+        /**\n+         * Victory in scenarios - designated by the \"objectiveScenarios\" collection.\n+         * These are one-off scenarios that stick around on tracks - when revealed, \n+         * they get a deploy/action/return date as usual, and the player gets one shot to complete them\n+         */\n+        SpecificScenarioVictory,\n+        \n+        /**\n+         * Control of allied facilities generated at contract start time\n+         * Each track will be seeded with some number of allied facilities\n+         * They must not be destroyed and the player must have control of them at the end-of-contract date \n+         */\n+        AlliedFacilityControl,\n+        \n+        /**\n+         * Control of hostile facilities generated at contract start time\n+         * Each track will be seeded with some number of hostile facilities\n+         * They must not be destroyed and the player must have control of them at the end-of-contract date\n+         */\n+        HostileFacilityControl,\n+        \n+        /**\n+         * Destruction of hostile facilities generated at contract start time\n+         * Each track will be seeded with some number of hostile facilities\n+         * They may either be destroyed or the player must have control of them at the end-of-contract date\n+         */\n+        FacilityDestruction\n+    }\n+    \n+    public static StratconContractDefinition createTestContract() {\n+        /*StratconContractDefinition retVal = new StratconContractDefinition();\n+        \n+        retVal.contractTypeName = \"Test Contract Type\";\n+        retVal.briefing = \"Test Contract Briefing.\";\n+        retVal.alliedFacilityCount = 1;\n+        retVal.hostileFacilityCount = COUNT_SCALED;\n+        retVal.objectiveParameters = new ArrayList<>();\n+        \n+        ObjectiveParameters objective = new ObjectiveParameters();\n+        objective.objectiveType = StrategicObjectiveType.SpecificScenarioVictory;\n+        objective.objectiveCount = COUNT_SCALED;\n+        objective.objectiveScenarios = Arrays.asList(\"Capture.xml\", \"Assassinate.xml\");\n+        objective.objectiveScenarioModifiers = Arrays.asList(\"AlliedTankGarrison.xml\", \"HostileAirGarrison.xml\");\n+        \n+        retVal.objectiveParameters.add(objective);\n+        \n+        retVal.allowedScenarios = Arrays.asList(\"TestAllowScenario.xml\", \"TestAllowScenario.xml\");\n+        retVal.forbiddenScenarios = Arrays.asList(\"TestForbidScenario.xml\", \"TestForbidScenario.xml\");\n+        \n+        retVal.Serialize(new File(\"d:\\\\projects\\\\mekhq\\\\mekhq\\\\data\\\\stratconcontractdefinitions\\\\testcontract.xml\"));\n+        \n+        return retVal;*/\n+        StratconContractDefinition retVal = Deserialize(new File(\"d:\\\\projects\\\\mekhq\\\\mekhq\\\\data\\\\stratconcontractdefinitions\\\\ObjectiveRaid.xml\"));\n+        return retVal;\n+    }\n+    \n+    private String contractTypeName;\n+    private String briefing;\n+    \n+    /**\n+     * How many allied facilities to generate for the contract, \n+     * in addition to any facilities placed by objectives.\n+     * < 0 indicates that the number of facilities should be scaled to the number of \n+     * lances required by the contract. 0 indicates no additional allied facilities.\n+     */\n+    private double alliedFacilityCount;\n+    \n+    /**\n+     * How many hostile facilities to generate for the contract, \n+     * in addition to any facilities placed by objectives.\n+     * -1 indicates that the number of facilities should be scaled to the number of \n+     * lances required by the contract. 0 indicates no additional hostile facilities.\n+     */\n+    private double hostileFacilityCount;\n+    \n+    /**\n+     * List of scenario IDs (file names) that are allowed for this contract type\n+     */\n+    private List<String> allowedScenarios;\n+    \n+    /**\n+     * List of scenario IDs (file names) that are not allowed for this contract type\n+     */\n+    private List<String> forbiddenScenarios;\n+    \n+    /**\n+     * Strategic objectives for this contract.\n+     */\n+    private List<ObjectiveParameters> objectiveParameters;\n+    \n+    /**\n+     * If true, strategic objective scenarios contribute to the VP count\n+     */\n+    private boolean objectivesBehaveAsVPs;\n+    \n+    private List<Integer> scenarioOdds;\n+    \n+    private List<Integer> deploymentTimes;\n+\n+    public String getContractTypeName() {\n+        return contractTypeName;\n+    }\n+\n+    public void setContractTypeName(String contractTypeName) {\n+        this.contractTypeName = contractTypeName;\n+    }\n+\n+    /**\n+     * @return the briefing\n+     */\n+    public String getBriefing() {\n+        return briefing;\n+    }\n+\n+    /**\n+     * @param briefing the briefing to set\n+     */\n+    public void setBriefing(String briefing) {\n+        this.briefing = briefing;\n+    }\n+\n+    /**\n+     * @return the alliedFacilityCount\n+     */\n+    public double getAlliedFacilityCount() {\n+        return alliedFacilityCount;\n+    }\n+\n+    /**\n+     * @param alliedFacilityCount the alliedFacilityCount to set\n+     */\n+    public void setAlliedFacilityCount(double alliedFacilityCount) {\n+        this.alliedFacilityCount = alliedFacilityCount;\n+    }\n+\n+    /**\n+     * @return the hostileFacilityCount\n+     */\n+    public double getHostileFacilityCount() {\n+        return hostileFacilityCount;\n+    }\n+\n+    /**\n+     * @param hostileFacilityCount the hostileFacilityCount to set\n+     */\n+    public void setHostileFacilityCount(double hostileFacilityCount) {\n+        this.hostileFacilityCount = hostileFacilityCount;\n+    }\n+\n+    @XmlElementWrapper(name=\"allowedScenarios\")\n+    @XmlElement(name=\"allowedScenario\")\n+    public List<String> getAllowedScenarios() {\n+        return allowedScenarios;\n+    }\n+\n+    public void setAllowedScenarios(List<String> allowedScenarios) {\n+        this.allowedScenarios = allowedScenarios;\n+    }\n+\n+    @XmlElementWrapper(name=\"forbiddenScenarios\")\n+    @XmlElement(name=\"forbiddenScenario\")\n+    public List<String> getForbiddenScenarios() {\n+        return forbiddenScenarios;\n+    }\n+\n+    public void setForbiddenScenarios(List<String> forbiddenScenarios) {\n+        this.forbiddenScenarios = forbiddenScenarios;\n+    }\n+    \n+    @XmlElementWrapper(name=\"objectiveParameters\")\n+    @XmlElement(name=\"objectiveParameter\")\n+    public List<ObjectiveParameters> getObjectiveParameters() {\n+        return objectiveParameters;\n+    }\n+\n+    public void setObjectiveParameters(List<ObjectiveParameters> objectiveParameters) {\n+        this.objectiveParameters = objectiveParameters;\n+    }\n+\n+    public boolean objectivesBehaveAsVPs() {\n+        return objectivesBehaveAsVPs;\n+    }\n+\n+    public void setObjectivesBehaveAsVPs(boolean objectivesBehaveAsVPs) {\n+        this.objectivesBehaveAsVPs = objectivesBehaveAsVPs;\n+    }\n+\n+    @XmlElementWrapper(name=\"scenarioOdds\")\n+    @XmlElement(name=\"scenarioOdds\")\n+    public List<Integer> getScenarioOdds() {\n+        return scenarioOdds;\n+    }\n+\n+    public void setScenarioOdds(List<Integer> scenarioOdds) {\n+        this.scenarioOdds = scenarioOdds;\n+    }\n+\n+    @XmlElementWrapper(name=\"deploymentTimes\")\n+    @XmlElement(name=\"deploymentTimes\")\n+    public List<Integer> getDeploymentTimes() {\n+        return deploymentTimes;\n+    }\n+\n+    public void setDeploymentTimes(List<Integer> deploymentTimes) {\n+        this.deploymentTimes = deploymentTimes;\n+    }\n+\n+    public static class ObjectiveParameters {\n+        /**\n+         * The type of objective this is; \n+         */\n+        @XmlElement(name=\"objectiveType\")\n+        StrategicObjectiveType objectiveType;\n+        \n+        /**\n+         * How many strategic objectives will be placed for this contract.\n+         * 0 means none. A number less than zero indicates that the number of strategic objectives \n+         * should be scaled to the number of lances required by the contract, and multiplied by that factor. \n+         */\n+        @XmlElement(name=\"objectiveCount\")\n+        double objectiveCount;\n+        \n+        /**\n+         * List of IDs (file names) of specific scenarios to use for this objective.\n+         * Ignored for AnyScenarioVictory or AlliedFacilityControl objective types\n+         */\n+        @XmlElementWrapper(name=\"objectiveScenarios\")\n+        @XmlElement(name=\"objectiveScenario\")\n+        List<String> objectiveScenarios;\n+        \n+        /**\n+         * If a particular scenario being generated is a strategic objective, it will have\n+         * these modifiers applied to it\n+         */\n+        @XmlElementWrapper(name=\"objectiveScenarioModifiers\")\n+        @XmlElement(name=\"objectiveScenarioModifier\")\n+        List<String> objectiveScenarioModifiers;\n+    }\n+    \n+    // Garrison Duty: Defend X facilities\n+    // Cadre Duty: Victory in X Training Exercise scenarios\n+    // Security Duty: Defend X facilities\n+    // Riot Duty: Defend X facilities, Riot Suppression scenarios\n+    // Planetary Assault: Destroy or Capture and Hold X facilities\n+    // Relief Duty: Hold X facilities (on hostile world!)\n+    // Guerilla Warfare: Victory in X scenarios, soft time limit (reinforcements) on all scenarios\n+    // Pirate Hunting: Victory in X scenarios \n+    // Diversionary Warfare: Victory in X scenarios\n+    // Objective Raid: Destroy X facilities\n+    // Extraction Raid: Extract from X facilities, victory in X capture scenarios\n+    // Recon Raid: Recon on X facilities\n+    // \n+    // future expansion:\n+    // Assassination: Victory in X Assassination scenarios\n+    // Terrorism: Victory in X \"Riot Suppression\" scenarios\n+    // Bounty Hunt: Victory in X Assassination, X Capture scenarios\n+    // Mole Hunting: ?\n+    // Espionage: ?\n+    // Sabotage: ?\n+    // Observation Raid: ?\n+    \n+    /**\n+     * Serialize this instance of a scenario template to a File\n+     * Please pass in a non-null file.\n+     * @param outputFile The destination file.\n+     */\n+    public void Serialize(File outputFile) {\n+        try {\n+            JAXBContext context = JAXBContext.newInstance(StratconContractDefinition.class);\n+            JAXBElement<StratconContractDefinition> templateElement = new JAXBElement<>(new QName(ROOT_XML_ELEMENT_NAME), StratconContractDefinition.class, this);\n+            Marshaller m = context.createMarshaller();\n+            m.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);\n+            m.marshal(templateElement, outputFile);\n+        } catch(Exception e) {\n+            MekHQ.getLogger().error(\"Erorr deserializing \" + outputFile.getPath(), e);\n+        }\n+    }\n+    \n+    /**\n+     * Attempt to deserialize an instance of a ScenarioTemplate from the passed-in file \n+     * @param inputFile The source file\n+     * @return Possibly an instance of a ScenarioTemplate\n+     */\n+    public static StratconContractDefinition Deserialize(File inputFile) {\n+        StratconContractDefinition resultingDefinition = null;\n+\n+        try {\n+            JAXBContext context = JAXBContext.newInstance(StratconContractDefinition.class);\n+            Unmarshaller um = context.createUnmarshaller();\n+            try (FileInputStream fileStream = new FileInputStream(inputFile)) {\n+                Source inputSource = MekHqXmlUtil.createSafeXmlSource(fileStream);\n+                JAXBElement<StratconContractDefinition> definitionElement = um.unmarshal(inputSource, StratconContractDefinition.class);\n+                resultingDefinition = definitionElement.getValue();\n+            }\n+        } catch(Exception e) {", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQzMzMyOQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593433329", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             *\n          \n          \n            \n             */\n          \n          \n            \n             */", "author": "Windchild292", "createdAt": "2021-03-12T20:32:44Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconContractDefinition.java", "diffHunk": "@@ -0,0 +1,420 @@\n+package mekhq.campaign.stratcon;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBElement;\n+import javax.xml.bind.Marshaller;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.namespace.QName;\n+import javax.xml.transform.Source;\n+\n+import mekhq.MekHQ;\n+import mekhq.MekHqXmlUtil;\n+\n+/**\n+ * This class holds data relevant to the various types of contract\n+ * that can occur in the StratCon campaign system.\n+ * @author NickAragua\n+ *\n+ */\n+@XmlRootElement(name=\"StratconContractDefinition\")\n+public class StratconContractDefinition {\n+    public static final String ROOT_XML_ELEMENT_NAME = \"ScenarioTemplate\";\n+    public static final int COUNT_SCALED = -1;\n+    \n+    private static ContractDefinitionManifest definitionManifest;\n+    private static Map<Integer, StratconContractDefinition> loadedDefinitions = new HashMap<>();\n+    \n+    static {\n+        definitionManifest = ContractDefinitionManifest.Deserialize(\"./data/stratconcontractdefinitions/ContractDefinitionManifest.xml\");\n+        \n+        // load user-specified modifier list\n+        ContractDefinitionManifest userDefinitionList = ContractDefinitionManifest.Deserialize(\"./data/scenariomodifiers/UserContractDefinitionManifest.xml\");\n+        if(userDefinitionList != null) {\n+            definitionManifest.definitionFileNames.putAll(userDefinitionList.definitionFileNames);\n+        }\n+    }\n+    \n+    /**\n+     * Returns the stratcon contract definition for the given AtB Contract Type \n+     * as defined in AtBContract.java\n+     */\n+    public static StratconContractDefinition getContractDefinition(int atbContractType) {\n+        definitionManifest = ContractDefinitionManifest.Deserialize(\"./data/stratconcontractdefinitions/ContractDefinitionManifest.xml\");\n+        loadedDefinitions.clear();\n+        \n+        if (!loadedDefinitions.containsKey(atbContractType)) {\n+            String filePath = String.format(\"./data/stratconcontractdefinitions/%s\", \n+                    definitionManifest.definitionFileNames.get(atbContractType));\n+            StratconContractDefinition def = Deserialize(new File(filePath));\n+            \n+            if (def == null) {\n+                MekHQ.getLogger().error(String.format(\"Unable to load contract definition %s\", filePath));\n+                return null;\n+            }\n+            \n+            loadedDefinitions.put(atbContractType, def);\n+        }\n+        \n+        return loadedDefinitions.get(atbContractType);\n+    }\n+    \n+    /**\n+     * The kind of actions that the player needs to undertake to complete\n+     * strategic objectives for this contract.\n+     *\n+     */\n+    public enum StrategicObjectiveType {\n+        /**\n+         * Victory in any scenario\n+         */\n+        AnyScenarioVictory,\n+        \n+        /**\n+         * Victory in scenarios - designated by the \"objectiveScenarios\" collection.\n+         * These are one-off scenarios that stick around on tracks - when revealed, \n+         * they get a deploy/action/return date as usual, and the player gets one shot to complete them\n+         */\n+        SpecificScenarioVictory,\n+        \n+        /**\n+         * Control of allied facilities generated at contract start time\n+         * Each track will be seeded with some number of allied facilities\n+         * They must not be destroyed and the player must have control of them at the end-of-contract date \n+         */\n+        AlliedFacilityControl,\n+        \n+        /**\n+         * Control of hostile facilities generated at contract start time\n+         * Each track will be seeded with some number of hostile facilities\n+         * They must not be destroyed and the player must have control of them at the end-of-contract date\n+         */\n+        HostileFacilityControl,\n+        \n+        /**\n+         * Destruction of hostile facilities generated at contract start time\n+         * Each track will be seeded with some number of hostile facilities\n+         * They may either be destroyed or the player must have control of them at the end-of-contract date\n+         */\n+        FacilityDestruction\n+    }\n+    \n+    public static StratconContractDefinition createTestContract() {\n+        /*StratconContractDefinition retVal = new StratconContractDefinition();\n+        \n+        retVal.contractTypeName = \"Test Contract Type\";\n+        retVal.briefing = \"Test Contract Briefing.\";\n+        retVal.alliedFacilityCount = 1;\n+        retVal.hostileFacilityCount = COUNT_SCALED;\n+        retVal.objectiveParameters = new ArrayList<>();\n+        \n+        ObjectiveParameters objective = new ObjectiveParameters();\n+        objective.objectiveType = StrategicObjectiveType.SpecificScenarioVictory;\n+        objective.objectiveCount = COUNT_SCALED;\n+        objective.objectiveScenarios = Arrays.asList(\"Capture.xml\", \"Assassinate.xml\");\n+        objective.objectiveScenarioModifiers = Arrays.asList(\"AlliedTankGarrison.xml\", \"HostileAirGarrison.xml\");\n+        \n+        retVal.objectiveParameters.add(objective);\n+        \n+        retVal.allowedScenarios = Arrays.asList(\"TestAllowScenario.xml\", \"TestAllowScenario.xml\");\n+        retVal.forbiddenScenarios = Arrays.asList(\"TestForbidScenario.xml\", \"TestForbidScenario.xml\");\n+        \n+        retVal.Serialize(new File(\"d:\\\\projects\\\\mekhq\\\\mekhq\\\\data\\\\stratconcontractdefinitions\\\\testcontract.xml\"));\n+        \n+        return retVal;*/\n+        StratconContractDefinition retVal = Deserialize(new File(\"d:\\\\projects\\\\mekhq\\\\mekhq\\\\data\\\\stratconcontractdefinitions\\\\ObjectiveRaid.xml\"));\n+        return retVal;\n+    }\n+    \n+    private String contractTypeName;\n+    private String briefing;\n+    \n+    /**\n+     * How many allied facilities to generate for the contract, \n+     * in addition to any facilities placed by objectives.\n+     * < 0 indicates that the number of facilities should be scaled to the number of \n+     * lances required by the contract. 0 indicates no additional allied facilities.\n+     */\n+    private double alliedFacilityCount;\n+    \n+    /**\n+     * How many hostile facilities to generate for the contract, \n+     * in addition to any facilities placed by objectives.\n+     * -1 indicates that the number of facilities should be scaled to the number of \n+     * lances required by the contract. 0 indicates no additional hostile facilities.\n+     */\n+    private double hostileFacilityCount;\n+    \n+    /**\n+     * List of scenario IDs (file names) that are allowed for this contract type\n+     */\n+    private List<String> allowedScenarios;\n+    \n+    /**\n+     * List of scenario IDs (file names) that are not allowed for this contract type\n+     */\n+    private List<String> forbiddenScenarios;\n+    \n+    /**\n+     * Strategic objectives for this contract.\n+     */\n+    private List<ObjectiveParameters> objectiveParameters;\n+    \n+    /**\n+     * If true, strategic objective scenarios contribute to the VP count\n+     */\n+    private boolean objectivesBehaveAsVPs;\n+    \n+    private List<Integer> scenarioOdds;\n+    \n+    private List<Integer> deploymentTimes;\n+\n+    public String getContractTypeName() {\n+        return contractTypeName;\n+    }\n+\n+    public void setContractTypeName(String contractTypeName) {\n+        this.contractTypeName = contractTypeName;\n+    }\n+\n+    /**\n+     * @return the briefing\n+     */\n+    public String getBriefing() {\n+        return briefing;\n+    }\n+\n+    /**\n+     * @param briefing the briefing to set\n+     */\n+    public void setBriefing(String briefing) {\n+        this.briefing = briefing;\n+    }\n+\n+    /**\n+     * @return the alliedFacilityCount\n+     */\n+    public double getAlliedFacilityCount() {\n+        return alliedFacilityCount;\n+    }\n+\n+    /**\n+     * @param alliedFacilityCount the alliedFacilityCount to set\n+     */\n+    public void setAlliedFacilityCount(double alliedFacilityCount) {\n+        this.alliedFacilityCount = alliedFacilityCount;\n+    }\n+\n+    /**\n+     * @return the hostileFacilityCount\n+     */\n+    public double getHostileFacilityCount() {\n+        return hostileFacilityCount;\n+    }\n+\n+    /**\n+     * @param hostileFacilityCount the hostileFacilityCount to set\n+     */\n+    public void setHostileFacilityCount(double hostileFacilityCount) {\n+        this.hostileFacilityCount = hostileFacilityCount;\n+    }\n+\n+    @XmlElementWrapper(name=\"allowedScenarios\")\n+    @XmlElement(name=\"allowedScenario\")\n+    public List<String> getAllowedScenarios() {\n+        return allowedScenarios;\n+    }\n+\n+    public void setAllowedScenarios(List<String> allowedScenarios) {\n+        this.allowedScenarios = allowedScenarios;\n+    }\n+\n+    @XmlElementWrapper(name=\"forbiddenScenarios\")\n+    @XmlElement(name=\"forbiddenScenario\")\n+    public List<String> getForbiddenScenarios() {\n+        return forbiddenScenarios;\n+    }\n+\n+    public void setForbiddenScenarios(List<String> forbiddenScenarios) {\n+        this.forbiddenScenarios = forbiddenScenarios;\n+    }\n+    \n+    @XmlElementWrapper(name=\"objectiveParameters\")\n+    @XmlElement(name=\"objectiveParameter\")\n+    public List<ObjectiveParameters> getObjectiveParameters() {\n+        return objectiveParameters;\n+    }\n+\n+    public void setObjectiveParameters(List<ObjectiveParameters> objectiveParameters) {\n+        this.objectiveParameters = objectiveParameters;\n+    }\n+\n+    public boolean objectivesBehaveAsVPs() {\n+        return objectivesBehaveAsVPs;\n+    }\n+\n+    public void setObjectivesBehaveAsVPs(boolean objectivesBehaveAsVPs) {\n+        this.objectivesBehaveAsVPs = objectivesBehaveAsVPs;\n+    }\n+\n+    @XmlElementWrapper(name=\"scenarioOdds\")\n+    @XmlElement(name=\"scenarioOdds\")\n+    public List<Integer> getScenarioOdds() {\n+        return scenarioOdds;\n+    }\n+\n+    public void setScenarioOdds(List<Integer> scenarioOdds) {\n+        this.scenarioOdds = scenarioOdds;\n+    }\n+\n+    @XmlElementWrapper(name=\"deploymentTimes\")\n+    @XmlElement(name=\"deploymentTimes\")\n+    public List<Integer> getDeploymentTimes() {\n+        return deploymentTimes;\n+    }\n+\n+    public void setDeploymentTimes(List<Integer> deploymentTimes) {\n+        this.deploymentTimes = deploymentTimes;\n+    }\n+\n+    public static class ObjectiveParameters {\n+        /**\n+         * The type of objective this is; \n+         */\n+        @XmlElement(name=\"objectiveType\")\n+        StrategicObjectiveType objectiveType;\n+        \n+        /**\n+         * How many strategic objectives will be placed for this contract.\n+         * 0 means none. A number less than zero indicates that the number of strategic objectives \n+         * should be scaled to the number of lances required by the contract, and multiplied by that factor. \n+         */\n+        @XmlElement(name=\"objectiveCount\")\n+        double objectiveCount;\n+        \n+        /**\n+         * List of IDs (file names) of specific scenarios to use for this objective.\n+         * Ignored for AnyScenarioVictory or AlliedFacilityControl objective types\n+         */\n+        @XmlElementWrapper(name=\"objectiveScenarios\")\n+        @XmlElement(name=\"objectiveScenario\")\n+        List<String> objectiveScenarios;\n+        \n+        /**\n+         * If a particular scenario being generated is a strategic objective, it will have\n+         * these modifiers applied to it\n+         */\n+        @XmlElementWrapper(name=\"objectiveScenarioModifiers\")\n+        @XmlElement(name=\"objectiveScenarioModifier\")\n+        List<String> objectiveScenarioModifiers;\n+    }\n+    \n+    // Garrison Duty: Defend X facilities\n+    // Cadre Duty: Victory in X Training Exercise scenarios\n+    // Security Duty: Defend X facilities\n+    // Riot Duty: Defend X facilities, Riot Suppression scenarios\n+    // Planetary Assault: Destroy or Capture and Hold X facilities\n+    // Relief Duty: Hold X facilities (on hostile world!)\n+    // Guerilla Warfare: Victory in X scenarios, soft time limit (reinforcements) on all scenarios\n+    // Pirate Hunting: Victory in X scenarios \n+    // Diversionary Warfare: Victory in X scenarios\n+    // Objective Raid: Destroy X facilities\n+    // Extraction Raid: Extract from X facilities, victory in X capture scenarios\n+    // Recon Raid: Recon on X facilities\n+    // \n+    // future expansion:\n+    // Assassination: Victory in X Assassination scenarios\n+    // Terrorism: Victory in X \"Riot Suppression\" scenarios\n+    // Bounty Hunt: Victory in X Assassination, X Capture scenarios\n+    // Mole Hunting: ?\n+    // Espionage: ?\n+    // Sabotage: ?\n+    // Observation Raid: ?\n+    \n+    /**\n+     * Serialize this instance of a scenario template to a File\n+     * Please pass in a non-null file.\n+     * @param outputFile The destination file.\n+     */\n+    public void Serialize(File outputFile) {\n+        try {\n+            JAXBContext context = JAXBContext.newInstance(StratconContractDefinition.class);\n+            JAXBElement<StratconContractDefinition> templateElement = new JAXBElement<>(new QName(ROOT_XML_ELEMENT_NAME), StratconContractDefinition.class, this);\n+            Marshaller m = context.createMarshaller();\n+            m.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);\n+            m.marshal(templateElement, outputFile);\n+        } catch(Exception e) {\n+            MekHQ.getLogger().error(\"Erorr deserializing \" + outputFile.getPath(), e);\n+        }\n+    }\n+    \n+    /**\n+     * Attempt to deserialize an instance of a ScenarioTemplate from the passed-in file \n+     * @param inputFile The source file\n+     * @return Possibly an instance of a ScenarioTemplate\n+     */\n+    public static StratconContractDefinition Deserialize(File inputFile) {\n+        StratconContractDefinition resultingDefinition = null;\n+\n+        try {\n+            JAXBContext context = JAXBContext.newInstance(StratconContractDefinition.class);\n+            Unmarshaller um = context.createUnmarshaller();\n+            try (FileInputStream fileStream = new FileInputStream(inputFile)) {\n+                Source inputSource = MekHqXmlUtil.createSafeXmlSource(fileStream);\n+                JAXBElement<StratconContractDefinition> definitionElement = um.unmarshal(inputSource, StratconContractDefinition.class);\n+                resultingDefinition = definitionElement.getValue();\n+            }\n+        } catch(Exception e) {\n+            MekHQ.getLogger().error(\"Error Deserializing Contract Definition \" + inputFile.getPath(), e);\n+        }\n+\n+        return resultingDefinition;\n+    }\n+}\n+\n+/**\n+ * A manifest containing IDs and file names of scenario template definitions\n+ * @author NickAragua\n+ *\n+ */", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQzMzQyOA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593433428", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if(!inputFile.exists()) {\n          \n          \n            \n                    if (!inputFile.exists()) {", "author": "Windchild292", "createdAt": "2021-03-12T20:32:58Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconContractDefinition.java", "diffHunk": "@@ -0,0 +1,420 @@\n+package mekhq.campaign.stratcon;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBElement;\n+import javax.xml.bind.Marshaller;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.namespace.QName;\n+import javax.xml.transform.Source;\n+\n+import mekhq.MekHQ;\n+import mekhq.MekHqXmlUtil;\n+\n+/**\n+ * This class holds data relevant to the various types of contract\n+ * that can occur in the StratCon campaign system.\n+ * @author NickAragua\n+ *\n+ */\n+@XmlRootElement(name=\"StratconContractDefinition\")\n+public class StratconContractDefinition {\n+    public static final String ROOT_XML_ELEMENT_NAME = \"ScenarioTemplate\";\n+    public static final int COUNT_SCALED = -1;\n+    \n+    private static ContractDefinitionManifest definitionManifest;\n+    private static Map<Integer, StratconContractDefinition> loadedDefinitions = new HashMap<>();\n+    \n+    static {\n+        definitionManifest = ContractDefinitionManifest.Deserialize(\"./data/stratconcontractdefinitions/ContractDefinitionManifest.xml\");\n+        \n+        // load user-specified modifier list\n+        ContractDefinitionManifest userDefinitionList = ContractDefinitionManifest.Deserialize(\"./data/scenariomodifiers/UserContractDefinitionManifest.xml\");\n+        if(userDefinitionList != null) {\n+            definitionManifest.definitionFileNames.putAll(userDefinitionList.definitionFileNames);\n+        }\n+    }\n+    \n+    /**\n+     * Returns the stratcon contract definition for the given AtB Contract Type \n+     * as defined in AtBContract.java\n+     */\n+    public static StratconContractDefinition getContractDefinition(int atbContractType) {\n+        definitionManifest = ContractDefinitionManifest.Deserialize(\"./data/stratconcontractdefinitions/ContractDefinitionManifest.xml\");\n+        loadedDefinitions.clear();\n+        \n+        if (!loadedDefinitions.containsKey(atbContractType)) {\n+            String filePath = String.format(\"./data/stratconcontractdefinitions/%s\", \n+                    definitionManifest.definitionFileNames.get(atbContractType));\n+            StratconContractDefinition def = Deserialize(new File(filePath));\n+            \n+            if (def == null) {\n+                MekHQ.getLogger().error(String.format(\"Unable to load contract definition %s\", filePath));\n+                return null;\n+            }\n+            \n+            loadedDefinitions.put(atbContractType, def);\n+        }\n+        \n+        return loadedDefinitions.get(atbContractType);\n+    }\n+    \n+    /**\n+     * The kind of actions that the player needs to undertake to complete\n+     * strategic objectives for this contract.\n+     *\n+     */\n+    public enum StrategicObjectiveType {\n+        /**\n+         * Victory in any scenario\n+         */\n+        AnyScenarioVictory,\n+        \n+        /**\n+         * Victory in scenarios - designated by the \"objectiveScenarios\" collection.\n+         * These are one-off scenarios that stick around on tracks - when revealed, \n+         * they get a deploy/action/return date as usual, and the player gets one shot to complete them\n+         */\n+        SpecificScenarioVictory,\n+        \n+        /**\n+         * Control of allied facilities generated at contract start time\n+         * Each track will be seeded with some number of allied facilities\n+         * They must not be destroyed and the player must have control of them at the end-of-contract date \n+         */\n+        AlliedFacilityControl,\n+        \n+        /**\n+         * Control of hostile facilities generated at contract start time\n+         * Each track will be seeded with some number of hostile facilities\n+         * They must not be destroyed and the player must have control of them at the end-of-contract date\n+         */\n+        HostileFacilityControl,\n+        \n+        /**\n+         * Destruction of hostile facilities generated at contract start time\n+         * Each track will be seeded with some number of hostile facilities\n+         * They may either be destroyed or the player must have control of them at the end-of-contract date\n+         */\n+        FacilityDestruction\n+    }\n+    \n+    public static StratconContractDefinition createTestContract() {\n+        /*StratconContractDefinition retVal = new StratconContractDefinition();\n+        \n+        retVal.contractTypeName = \"Test Contract Type\";\n+        retVal.briefing = \"Test Contract Briefing.\";\n+        retVal.alliedFacilityCount = 1;\n+        retVal.hostileFacilityCount = COUNT_SCALED;\n+        retVal.objectiveParameters = new ArrayList<>();\n+        \n+        ObjectiveParameters objective = new ObjectiveParameters();\n+        objective.objectiveType = StrategicObjectiveType.SpecificScenarioVictory;\n+        objective.objectiveCount = COUNT_SCALED;\n+        objective.objectiveScenarios = Arrays.asList(\"Capture.xml\", \"Assassinate.xml\");\n+        objective.objectiveScenarioModifiers = Arrays.asList(\"AlliedTankGarrison.xml\", \"HostileAirGarrison.xml\");\n+        \n+        retVal.objectiveParameters.add(objective);\n+        \n+        retVal.allowedScenarios = Arrays.asList(\"TestAllowScenario.xml\", \"TestAllowScenario.xml\");\n+        retVal.forbiddenScenarios = Arrays.asList(\"TestForbidScenario.xml\", \"TestForbidScenario.xml\");\n+        \n+        retVal.Serialize(new File(\"d:\\\\projects\\\\mekhq\\\\mekhq\\\\data\\\\stratconcontractdefinitions\\\\testcontract.xml\"));\n+        \n+        return retVal;*/\n+        StratconContractDefinition retVal = Deserialize(new File(\"d:\\\\projects\\\\mekhq\\\\mekhq\\\\data\\\\stratconcontractdefinitions\\\\ObjectiveRaid.xml\"));\n+        return retVal;\n+    }\n+    \n+    private String contractTypeName;\n+    private String briefing;\n+    \n+    /**\n+     * How many allied facilities to generate for the contract, \n+     * in addition to any facilities placed by objectives.\n+     * < 0 indicates that the number of facilities should be scaled to the number of \n+     * lances required by the contract. 0 indicates no additional allied facilities.\n+     */\n+    private double alliedFacilityCount;\n+    \n+    /**\n+     * How many hostile facilities to generate for the contract, \n+     * in addition to any facilities placed by objectives.\n+     * -1 indicates that the number of facilities should be scaled to the number of \n+     * lances required by the contract. 0 indicates no additional hostile facilities.\n+     */\n+    private double hostileFacilityCount;\n+    \n+    /**\n+     * List of scenario IDs (file names) that are allowed for this contract type\n+     */\n+    private List<String> allowedScenarios;\n+    \n+    /**\n+     * List of scenario IDs (file names) that are not allowed for this contract type\n+     */\n+    private List<String> forbiddenScenarios;\n+    \n+    /**\n+     * Strategic objectives for this contract.\n+     */\n+    private List<ObjectiveParameters> objectiveParameters;\n+    \n+    /**\n+     * If true, strategic objective scenarios contribute to the VP count\n+     */\n+    private boolean objectivesBehaveAsVPs;\n+    \n+    private List<Integer> scenarioOdds;\n+    \n+    private List<Integer> deploymentTimes;\n+\n+    public String getContractTypeName() {\n+        return contractTypeName;\n+    }\n+\n+    public void setContractTypeName(String contractTypeName) {\n+        this.contractTypeName = contractTypeName;\n+    }\n+\n+    /**\n+     * @return the briefing\n+     */\n+    public String getBriefing() {\n+        return briefing;\n+    }\n+\n+    /**\n+     * @param briefing the briefing to set\n+     */\n+    public void setBriefing(String briefing) {\n+        this.briefing = briefing;\n+    }\n+\n+    /**\n+     * @return the alliedFacilityCount\n+     */\n+    public double getAlliedFacilityCount() {\n+        return alliedFacilityCount;\n+    }\n+\n+    /**\n+     * @param alliedFacilityCount the alliedFacilityCount to set\n+     */\n+    public void setAlliedFacilityCount(double alliedFacilityCount) {\n+        this.alliedFacilityCount = alliedFacilityCount;\n+    }\n+\n+    /**\n+     * @return the hostileFacilityCount\n+     */\n+    public double getHostileFacilityCount() {\n+        return hostileFacilityCount;\n+    }\n+\n+    /**\n+     * @param hostileFacilityCount the hostileFacilityCount to set\n+     */\n+    public void setHostileFacilityCount(double hostileFacilityCount) {\n+        this.hostileFacilityCount = hostileFacilityCount;\n+    }\n+\n+    @XmlElementWrapper(name=\"allowedScenarios\")\n+    @XmlElement(name=\"allowedScenario\")\n+    public List<String> getAllowedScenarios() {\n+        return allowedScenarios;\n+    }\n+\n+    public void setAllowedScenarios(List<String> allowedScenarios) {\n+        this.allowedScenarios = allowedScenarios;\n+    }\n+\n+    @XmlElementWrapper(name=\"forbiddenScenarios\")\n+    @XmlElement(name=\"forbiddenScenario\")\n+    public List<String> getForbiddenScenarios() {\n+        return forbiddenScenarios;\n+    }\n+\n+    public void setForbiddenScenarios(List<String> forbiddenScenarios) {\n+        this.forbiddenScenarios = forbiddenScenarios;\n+    }\n+    \n+    @XmlElementWrapper(name=\"objectiveParameters\")\n+    @XmlElement(name=\"objectiveParameter\")\n+    public List<ObjectiveParameters> getObjectiveParameters() {\n+        return objectiveParameters;\n+    }\n+\n+    public void setObjectiveParameters(List<ObjectiveParameters> objectiveParameters) {\n+        this.objectiveParameters = objectiveParameters;\n+    }\n+\n+    public boolean objectivesBehaveAsVPs() {\n+        return objectivesBehaveAsVPs;\n+    }\n+\n+    public void setObjectivesBehaveAsVPs(boolean objectivesBehaveAsVPs) {\n+        this.objectivesBehaveAsVPs = objectivesBehaveAsVPs;\n+    }\n+\n+    @XmlElementWrapper(name=\"scenarioOdds\")\n+    @XmlElement(name=\"scenarioOdds\")\n+    public List<Integer> getScenarioOdds() {\n+        return scenarioOdds;\n+    }\n+\n+    public void setScenarioOdds(List<Integer> scenarioOdds) {\n+        this.scenarioOdds = scenarioOdds;\n+    }\n+\n+    @XmlElementWrapper(name=\"deploymentTimes\")\n+    @XmlElement(name=\"deploymentTimes\")\n+    public List<Integer> getDeploymentTimes() {\n+        return deploymentTimes;\n+    }\n+\n+    public void setDeploymentTimes(List<Integer> deploymentTimes) {\n+        this.deploymentTimes = deploymentTimes;\n+    }\n+\n+    public static class ObjectiveParameters {\n+        /**\n+         * The type of objective this is; \n+         */\n+        @XmlElement(name=\"objectiveType\")\n+        StrategicObjectiveType objectiveType;\n+        \n+        /**\n+         * How many strategic objectives will be placed for this contract.\n+         * 0 means none. A number less than zero indicates that the number of strategic objectives \n+         * should be scaled to the number of lances required by the contract, and multiplied by that factor. \n+         */\n+        @XmlElement(name=\"objectiveCount\")\n+        double objectiveCount;\n+        \n+        /**\n+         * List of IDs (file names) of specific scenarios to use for this objective.\n+         * Ignored for AnyScenarioVictory or AlliedFacilityControl objective types\n+         */\n+        @XmlElementWrapper(name=\"objectiveScenarios\")\n+        @XmlElement(name=\"objectiveScenario\")\n+        List<String> objectiveScenarios;\n+        \n+        /**\n+         * If a particular scenario being generated is a strategic objective, it will have\n+         * these modifiers applied to it\n+         */\n+        @XmlElementWrapper(name=\"objectiveScenarioModifiers\")\n+        @XmlElement(name=\"objectiveScenarioModifier\")\n+        List<String> objectiveScenarioModifiers;\n+    }\n+    \n+    // Garrison Duty: Defend X facilities\n+    // Cadre Duty: Victory in X Training Exercise scenarios\n+    // Security Duty: Defend X facilities\n+    // Riot Duty: Defend X facilities, Riot Suppression scenarios\n+    // Planetary Assault: Destroy or Capture and Hold X facilities\n+    // Relief Duty: Hold X facilities (on hostile world!)\n+    // Guerilla Warfare: Victory in X scenarios, soft time limit (reinforcements) on all scenarios\n+    // Pirate Hunting: Victory in X scenarios \n+    // Diversionary Warfare: Victory in X scenarios\n+    // Objective Raid: Destroy X facilities\n+    // Extraction Raid: Extract from X facilities, victory in X capture scenarios\n+    // Recon Raid: Recon on X facilities\n+    // \n+    // future expansion:\n+    // Assassination: Victory in X Assassination scenarios\n+    // Terrorism: Victory in X \"Riot Suppression\" scenarios\n+    // Bounty Hunt: Victory in X Assassination, X Capture scenarios\n+    // Mole Hunting: ?\n+    // Espionage: ?\n+    // Sabotage: ?\n+    // Observation Raid: ?\n+    \n+    /**\n+     * Serialize this instance of a scenario template to a File\n+     * Please pass in a non-null file.\n+     * @param outputFile The destination file.\n+     */\n+    public void Serialize(File outputFile) {\n+        try {\n+            JAXBContext context = JAXBContext.newInstance(StratconContractDefinition.class);\n+            JAXBElement<StratconContractDefinition> templateElement = new JAXBElement<>(new QName(ROOT_XML_ELEMENT_NAME), StratconContractDefinition.class, this);\n+            Marshaller m = context.createMarshaller();\n+            m.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);\n+            m.marshal(templateElement, outputFile);\n+        } catch(Exception e) {\n+            MekHQ.getLogger().error(\"Erorr deserializing \" + outputFile.getPath(), e);\n+        }\n+    }\n+    \n+    /**\n+     * Attempt to deserialize an instance of a ScenarioTemplate from the passed-in file \n+     * @param inputFile The source file\n+     * @return Possibly an instance of a ScenarioTemplate\n+     */\n+    public static StratconContractDefinition Deserialize(File inputFile) {\n+        StratconContractDefinition resultingDefinition = null;\n+\n+        try {\n+            JAXBContext context = JAXBContext.newInstance(StratconContractDefinition.class);\n+            Unmarshaller um = context.createUnmarshaller();\n+            try (FileInputStream fileStream = new FileInputStream(inputFile)) {\n+                Source inputSource = MekHqXmlUtil.createSafeXmlSource(fileStream);\n+                JAXBElement<StratconContractDefinition> definitionElement = um.unmarshal(inputSource, StratconContractDefinition.class);\n+                resultingDefinition = definitionElement.getValue();\n+            }\n+        } catch(Exception e) {\n+            MekHQ.getLogger().error(\"Error Deserializing Contract Definition \" + inputFile.getPath(), e);\n+        }\n+\n+        return resultingDefinition;\n+    }\n+}\n+\n+/**\n+ * A manifest containing IDs and file names of scenario template definitions\n+ * @author NickAragua\n+ *\n+ */\n+@XmlRootElement(name=\"contractDefinitionManifest\")\n+class ContractDefinitionManifest {\n+    @XmlElementWrapper(name=\"contractDefinitions\")\n+    @XmlElement(name=\"contractDefinition\")\n+    public Map<Integer, String> definitionFileNames;\n+    \n+    /**\n+     * Attempt to deserialize an instance of an contract definition manifest from the passed-in file path\n+     * @return Possibly an instance of a contract definition Manifest\n+     */\n+    public static ContractDefinitionManifest Deserialize(String fileName) {\n+        ContractDefinitionManifest resultingManifest = null;\n+        File inputFile = new File(fileName);\n+        if(!inputFile.exists()) {", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQzMzQ4Nw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593433487", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    } catch(Exception e) {\n          \n          \n            \n                    } catch (Exception e) {", "author": "Windchild292", "createdAt": "2021-03-12T20:33:07Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconContractDefinition.java", "diffHunk": "@@ -0,0 +1,420 @@\n+package mekhq.campaign.stratcon;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBElement;\n+import javax.xml.bind.Marshaller;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.namespace.QName;\n+import javax.xml.transform.Source;\n+\n+import mekhq.MekHQ;\n+import mekhq.MekHqXmlUtil;\n+\n+/**\n+ * This class holds data relevant to the various types of contract\n+ * that can occur in the StratCon campaign system.\n+ * @author NickAragua\n+ *\n+ */\n+@XmlRootElement(name=\"StratconContractDefinition\")\n+public class StratconContractDefinition {\n+    public static final String ROOT_XML_ELEMENT_NAME = \"ScenarioTemplate\";\n+    public static final int COUNT_SCALED = -1;\n+    \n+    private static ContractDefinitionManifest definitionManifest;\n+    private static Map<Integer, StratconContractDefinition> loadedDefinitions = new HashMap<>();\n+    \n+    static {\n+        definitionManifest = ContractDefinitionManifest.Deserialize(\"./data/stratconcontractdefinitions/ContractDefinitionManifest.xml\");\n+        \n+        // load user-specified modifier list\n+        ContractDefinitionManifest userDefinitionList = ContractDefinitionManifest.Deserialize(\"./data/scenariomodifiers/UserContractDefinitionManifest.xml\");\n+        if(userDefinitionList != null) {\n+            definitionManifest.definitionFileNames.putAll(userDefinitionList.definitionFileNames);\n+        }\n+    }\n+    \n+    /**\n+     * Returns the stratcon contract definition for the given AtB Contract Type \n+     * as defined in AtBContract.java\n+     */\n+    public static StratconContractDefinition getContractDefinition(int atbContractType) {\n+        definitionManifest = ContractDefinitionManifest.Deserialize(\"./data/stratconcontractdefinitions/ContractDefinitionManifest.xml\");\n+        loadedDefinitions.clear();\n+        \n+        if (!loadedDefinitions.containsKey(atbContractType)) {\n+            String filePath = String.format(\"./data/stratconcontractdefinitions/%s\", \n+                    definitionManifest.definitionFileNames.get(atbContractType));\n+            StratconContractDefinition def = Deserialize(new File(filePath));\n+            \n+            if (def == null) {\n+                MekHQ.getLogger().error(String.format(\"Unable to load contract definition %s\", filePath));\n+                return null;\n+            }\n+            \n+            loadedDefinitions.put(atbContractType, def);\n+        }\n+        \n+        return loadedDefinitions.get(atbContractType);\n+    }\n+    \n+    /**\n+     * The kind of actions that the player needs to undertake to complete\n+     * strategic objectives for this contract.\n+     *\n+     */\n+    public enum StrategicObjectiveType {\n+        /**\n+         * Victory in any scenario\n+         */\n+        AnyScenarioVictory,\n+        \n+        /**\n+         * Victory in scenarios - designated by the \"objectiveScenarios\" collection.\n+         * These are one-off scenarios that stick around on tracks - when revealed, \n+         * they get a deploy/action/return date as usual, and the player gets one shot to complete them\n+         */\n+        SpecificScenarioVictory,\n+        \n+        /**\n+         * Control of allied facilities generated at contract start time\n+         * Each track will be seeded with some number of allied facilities\n+         * They must not be destroyed and the player must have control of them at the end-of-contract date \n+         */\n+        AlliedFacilityControl,\n+        \n+        /**\n+         * Control of hostile facilities generated at contract start time\n+         * Each track will be seeded with some number of hostile facilities\n+         * They must not be destroyed and the player must have control of them at the end-of-contract date\n+         */\n+        HostileFacilityControl,\n+        \n+        /**\n+         * Destruction of hostile facilities generated at contract start time\n+         * Each track will be seeded with some number of hostile facilities\n+         * They may either be destroyed or the player must have control of them at the end-of-contract date\n+         */\n+        FacilityDestruction\n+    }\n+    \n+    public static StratconContractDefinition createTestContract() {\n+        /*StratconContractDefinition retVal = new StratconContractDefinition();\n+        \n+        retVal.contractTypeName = \"Test Contract Type\";\n+        retVal.briefing = \"Test Contract Briefing.\";\n+        retVal.alliedFacilityCount = 1;\n+        retVal.hostileFacilityCount = COUNT_SCALED;\n+        retVal.objectiveParameters = new ArrayList<>();\n+        \n+        ObjectiveParameters objective = new ObjectiveParameters();\n+        objective.objectiveType = StrategicObjectiveType.SpecificScenarioVictory;\n+        objective.objectiveCount = COUNT_SCALED;\n+        objective.objectiveScenarios = Arrays.asList(\"Capture.xml\", \"Assassinate.xml\");\n+        objective.objectiveScenarioModifiers = Arrays.asList(\"AlliedTankGarrison.xml\", \"HostileAirGarrison.xml\");\n+        \n+        retVal.objectiveParameters.add(objective);\n+        \n+        retVal.allowedScenarios = Arrays.asList(\"TestAllowScenario.xml\", \"TestAllowScenario.xml\");\n+        retVal.forbiddenScenarios = Arrays.asList(\"TestForbidScenario.xml\", \"TestForbidScenario.xml\");\n+        \n+        retVal.Serialize(new File(\"d:\\\\projects\\\\mekhq\\\\mekhq\\\\data\\\\stratconcontractdefinitions\\\\testcontract.xml\"));\n+        \n+        return retVal;*/\n+        StratconContractDefinition retVal = Deserialize(new File(\"d:\\\\projects\\\\mekhq\\\\mekhq\\\\data\\\\stratconcontractdefinitions\\\\ObjectiveRaid.xml\"));\n+        return retVal;\n+    }\n+    \n+    private String contractTypeName;\n+    private String briefing;\n+    \n+    /**\n+     * How many allied facilities to generate for the contract, \n+     * in addition to any facilities placed by objectives.\n+     * < 0 indicates that the number of facilities should be scaled to the number of \n+     * lances required by the contract. 0 indicates no additional allied facilities.\n+     */\n+    private double alliedFacilityCount;\n+    \n+    /**\n+     * How many hostile facilities to generate for the contract, \n+     * in addition to any facilities placed by objectives.\n+     * -1 indicates that the number of facilities should be scaled to the number of \n+     * lances required by the contract. 0 indicates no additional hostile facilities.\n+     */\n+    private double hostileFacilityCount;\n+    \n+    /**\n+     * List of scenario IDs (file names) that are allowed for this contract type\n+     */\n+    private List<String> allowedScenarios;\n+    \n+    /**\n+     * List of scenario IDs (file names) that are not allowed for this contract type\n+     */\n+    private List<String> forbiddenScenarios;\n+    \n+    /**\n+     * Strategic objectives for this contract.\n+     */\n+    private List<ObjectiveParameters> objectiveParameters;\n+    \n+    /**\n+     * If true, strategic objective scenarios contribute to the VP count\n+     */\n+    private boolean objectivesBehaveAsVPs;\n+    \n+    private List<Integer> scenarioOdds;\n+    \n+    private List<Integer> deploymentTimes;\n+\n+    public String getContractTypeName() {\n+        return contractTypeName;\n+    }\n+\n+    public void setContractTypeName(String contractTypeName) {\n+        this.contractTypeName = contractTypeName;\n+    }\n+\n+    /**\n+     * @return the briefing\n+     */\n+    public String getBriefing() {\n+        return briefing;\n+    }\n+\n+    /**\n+     * @param briefing the briefing to set\n+     */\n+    public void setBriefing(String briefing) {\n+        this.briefing = briefing;\n+    }\n+\n+    /**\n+     * @return the alliedFacilityCount\n+     */\n+    public double getAlliedFacilityCount() {\n+        return alliedFacilityCount;\n+    }\n+\n+    /**\n+     * @param alliedFacilityCount the alliedFacilityCount to set\n+     */\n+    public void setAlliedFacilityCount(double alliedFacilityCount) {\n+        this.alliedFacilityCount = alliedFacilityCount;\n+    }\n+\n+    /**\n+     * @return the hostileFacilityCount\n+     */\n+    public double getHostileFacilityCount() {\n+        return hostileFacilityCount;\n+    }\n+\n+    /**\n+     * @param hostileFacilityCount the hostileFacilityCount to set\n+     */\n+    public void setHostileFacilityCount(double hostileFacilityCount) {\n+        this.hostileFacilityCount = hostileFacilityCount;\n+    }\n+\n+    @XmlElementWrapper(name=\"allowedScenarios\")\n+    @XmlElement(name=\"allowedScenario\")\n+    public List<String> getAllowedScenarios() {\n+        return allowedScenarios;\n+    }\n+\n+    public void setAllowedScenarios(List<String> allowedScenarios) {\n+        this.allowedScenarios = allowedScenarios;\n+    }\n+\n+    @XmlElementWrapper(name=\"forbiddenScenarios\")\n+    @XmlElement(name=\"forbiddenScenario\")\n+    public List<String> getForbiddenScenarios() {\n+        return forbiddenScenarios;\n+    }\n+\n+    public void setForbiddenScenarios(List<String> forbiddenScenarios) {\n+        this.forbiddenScenarios = forbiddenScenarios;\n+    }\n+    \n+    @XmlElementWrapper(name=\"objectiveParameters\")\n+    @XmlElement(name=\"objectiveParameter\")\n+    public List<ObjectiveParameters> getObjectiveParameters() {\n+        return objectiveParameters;\n+    }\n+\n+    public void setObjectiveParameters(List<ObjectiveParameters> objectiveParameters) {\n+        this.objectiveParameters = objectiveParameters;\n+    }\n+\n+    public boolean objectivesBehaveAsVPs() {\n+        return objectivesBehaveAsVPs;\n+    }\n+\n+    public void setObjectivesBehaveAsVPs(boolean objectivesBehaveAsVPs) {\n+        this.objectivesBehaveAsVPs = objectivesBehaveAsVPs;\n+    }\n+\n+    @XmlElementWrapper(name=\"scenarioOdds\")\n+    @XmlElement(name=\"scenarioOdds\")\n+    public List<Integer> getScenarioOdds() {\n+        return scenarioOdds;\n+    }\n+\n+    public void setScenarioOdds(List<Integer> scenarioOdds) {\n+        this.scenarioOdds = scenarioOdds;\n+    }\n+\n+    @XmlElementWrapper(name=\"deploymentTimes\")\n+    @XmlElement(name=\"deploymentTimes\")\n+    public List<Integer> getDeploymentTimes() {\n+        return deploymentTimes;\n+    }\n+\n+    public void setDeploymentTimes(List<Integer> deploymentTimes) {\n+        this.deploymentTimes = deploymentTimes;\n+    }\n+\n+    public static class ObjectiveParameters {\n+        /**\n+         * The type of objective this is; \n+         */\n+        @XmlElement(name=\"objectiveType\")\n+        StrategicObjectiveType objectiveType;\n+        \n+        /**\n+         * How many strategic objectives will be placed for this contract.\n+         * 0 means none. A number less than zero indicates that the number of strategic objectives \n+         * should be scaled to the number of lances required by the contract, and multiplied by that factor. \n+         */\n+        @XmlElement(name=\"objectiveCount\")\n+        double objectiveCount;\n+        \n+        /**\n+         * List of IDs (file names) of specific scenarios to use for this objective.\n+         * Ignored for AnyScenarioVictory or AlliedFacilityControl objective types\n+         */\n+        @XmlElementWrapper(name=\"objectiveScenarios\")\n+        @XmlElement(name=\"objectiveScenario\")\n+        List<String> objectiveScenarios;\n+        \n+        /**\n+         * If a particular scenario being generated is a strategic objective, it will have\n+         * these modifiers applied to it\n+         */\n+        @XmlElementWrapper(name=\"objectiveScenarioModifiers\")\n+        @XmlElement(name=\"objectiveScenarioModifier\")\n+        List<String> objectiveScenarioModifiers;\n+    }\n+    \n+    // Garrison Duty: Defend X facilities\n+    // Cadre Duty: Victory in X Training Exercise scenarios\n+    // Security Duty: Defend X facilities\n+    // Riot Duty: Defend X facilities, Riot Suppression scenarios\n+    // Planetary Assault: Destroy or Capture and Hold X facilities\n+    // Relief Duty: Hold X facilities (on hostile world!)\n+    // Guerilla Warfare: Victory in X scenarios, soft time limit (reinforcements) on all scenarios\n+    // Pirate Hunting: Victory in X scenarios \n+    // Diversionary Warfare: Victory in X scenarios\n+    // Objective Raid: Destroy X facilities\n+    // Extraction Raid: Extract from X facilities, victory in X capture scenarios\n+    // Recon Raid: Recon on X facilities\n+    // \n+    // future expansion:\n+    // Assassination: Victory in X Assassination scenarios\n+    // Terrorism: Victory in X \"Riot Suppression\" scenarios\n+    // Bounty Hunt: Victory in X Assassination, X Capture scenarios\n+    // Mole Hunting: ?\n+    // Espionage: ?\n+    // Sabotage: ?\n+    // Observation Raid: ?\n+    \n+    /**\n+     * Serialize this instance of a scenario template to a File\n+     * Please pass in a non-null file.\n+     * @param outputFile The destination file.\n+     */\n+    public void Serialize(File outputFile) {\n+        try {\n+            JAXBContext context = JAXBContext.newInstance(StratconContractDefinition.class);\n+            JAXBElement<StratconContractDefinition> templateElement = new JAXBElement<>(new QName(ROOT_XML_ELEMENT_NAME), StratconContractDefinition.class, this);\n+            Marshaller m = context.createMarshaller();\n+            m.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);\n+            m.marshal(templateElement, outputFile);\n+        } catch(Exception e) {\n+            MekHQ.getLogger().error(\"Erorr deserializing \" + outputFile.getPath(), e);\n+        }\n+    }\n+    \n+    /**\n+     * Attempt to deserialize an instance of a ScenarioTemplate from the passed-in file \n+     * @param inputFile The source file\n+     * @return Possibly an instance of a ScenarioTemplate\n+     */\n+    public static StratconContractDefinition Deserialize(File inputFile) {\n+        StratconContractDefinition resultingDefinition = null;\n+\n+        try {\n+            JAXBContext context = JAXBContext.newInstance(StratconContractDefinition.class);\n+            Unmarshaller um = context.createUnmarshaller();\n+            try (FileInputStream fileStream = new FileInputStream(inputFile)) {\n+                Source inputSource = MekHqXmlUtil.createSafeXmlSource(fileStream);\n+                JAXBElement<StratconContractDefinition> definitionElement = um.unmarshal(inputSource, StratconContractDefinition.class);\n+                resultingDefinition = definitionElement.getValue();\n+            }\n+        } catch(Exception e) {\n+            MekHQ.getLogger().error(\"Error Deserializing Contract Definition \" + inputFile.getPath(), e);\n+        }\n+\n+        return resultingDefinition;\n+    }\n+}\n+\n+/**\n+ * A manifest containing IDs and file names of scenario template definitions\n+ * @author NickAragua\n+ *\n+ */\n+@XmlRootElement(name=\"contractDefinitionManifest\")\n+class ContractDefinitionManifest {\n+    @XmlElementWrapper(name=\"contractDefinitions\")\n+    @XmlElement(name=\"contractDefinition\")\n+    public Map<Integer, String> definitionFileNames;\n+    \n+    /**\n+     * Attempt to deserialize an instance of an contract definition manifest from the passed-in file path\n+     * @return Possibly an instance of a contract definition Manifest\n+     */\n+    public static ContractDefinitionManifest Deserialize(String fileName) {\n+        ContractDefinitionManifest resultingManifest = null;\n+        File inputFile = new File(fileName);\n+        if(!inputFile.exists()) {\n+            MekHQ.getLogger().warning(String.format(\"Specified file %s does not exist\", fileName));\n+            return null;\n+        }\n+\n+        try {\n+            JAXBContext context = JAXBContext.newInstance(ContractDefinitionManifest.class);\n+            Unmarshaller um = context.createUnmarshaller();\n+            try (FileInputStream fileStream = new FileInputStream(inputFile)) {\n+                Source inputSource = MekHqXmlUtil.createSafeXmlSource(fileStream);\n+                JAXBElement<ContractDefinitionManifest> manifestElement = um.unmarshal(inputSource, ContractDefinitionManifest.class);\n+                resultingManifest = manifestElement.getValue();\n+            }\n+        } catch(Exception e) {", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQzMzkyNg==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593433926", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for(int x = 0; x < numTracks; x++) {\n          \n          \n            \n                    for (int x = 0; x < numTracks; x++) {", "author": "Windchild292", "createdAt": "2021-03-12T20:34:00Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconContractInitializer.java", "diffHunk": "@@ -0,0 +1,288 @@\n+package mekhq.campaign.stratcon;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import megamek.common.Compute;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.stratcon.StratconContractDefinition.ObjectiveParameters;\n+\n+public class StratconContractInitializer {\n+    public static final int NUM_LANCES_PER_TRACK = 3;\n+\n+    /**\n+     * Initializes the campaign state given a contract, campaign and contract definition\n+     */\n+    public static void InitializeCampaignState(AtBContract contract, Campaign campaign, StratconContractDefinition contractDefinition) {\n+        StratconCampaignState campaignState = new StratconCampaignState(contract);\n+        campaignState.setBriefingText(contractDefinition.getBriefing() + \"<br/>\" + generateCommandLevelText(contract));\n+        campaignState.setStrategicObjectivesBehaveAsVPs(contractDefinition.objectivesBehaveAsVPs());\n+        \n+        // dependency: this is required here in order for scenario initialization to work properly\n+        contract.setStratconCampaignState(campaignState);\n+        \n+        // First, initialize the proper number of tracks. Then:\n+        // for each objective: \n+        //  step 1: calculate objective count\n+        //          if scaled, multiply # required lances by factor, round up, otherwise just fixed #\n+        //  step 2: evenly distribute objectives through tracks\n+        //          if uneven number remaining, distribute randomly \n+        //          when objective is specific scenario victory, place specially flagged scenarios\n+        //          when objective is allied/hostile facility, place those facilities\n+\n+        int numTracks = contract.getRequiredLances() / NUM_LANCES_PER_TRACK;\n+        \n+        for(int x = 0; x < numTracks; x++) {", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQzNDM5NQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593434395", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if(oddLanceCount > 0) {\n          \n          \n            \n                    if (oddLanceCount > 0) {", "author": "Windchild292", "createdAt": "2021-03-12T20:35:00Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconContractInitializer.java", "diffHunk": "@@ -0,0 +1,288 @@\n+package mekhq.campaign.stratcon;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import megamek.common.Compute;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.stratcon.StratconContractDefinition.ObjectiveParameters;\n+\n+public class StratconContractInitializer {\n+    public static final int NUM_LANCES_PER_TRACK = 3;\n+\n+    /**\n+     * Initializes the campaign state given a contract, campaign and contract definition\n+     */\n+    public static void InitializeCampaignState(AtBContract contract, Campaign campaign, StratconContractDefinition contractDefinition) {\n+        StratconCampaignState campaignState = new StratconCampaignState(contract);\n+        campaignState.setBriefingText(contractDefinition.getBriefing() + \"<br/>\" + generateCommandLevelText(contract));\n+        campaignState.setStrategicObjectivesBehaveAsVPs(contractDefinition.objectivesBehaveAsVPs());\n+        \n+        // dependency: this is required here in order for scenario initialization to work properly\n+        contract.setStratconCampaignState(campaignState);\n+        \n+        // First, initialize the proper number of tracks. Then:\n+        // for each objective: \n+        //  step 1: calculate objective count\n+        //          if scaled, multiply # required lances by factor, round up, otherwise just fixed #\n+        //  step 2: evenly distribute objectives through tracks\n+        //          if uneven number remaining, distribute randomly \n+        //          when objective is specific scenario victory, place specially flagged scenarios\n+        //          when objective is allied/hostile facility, place those facilities\n+\n+        int numTracks = contract.getRequiredLances() / NUM_LANCES_PER_TRACK;\n+        \n+        for(int x = 0; x < numTracks; x++) {\n+            int scenarioOdds = contractDefinition.getScenarioOdds().get(Compute.randomInt(contractDefinition.getScenarioOdds().size()));\n+            int deploymentTime = contractDefinition.getDeploymentTimes().get(Compute.randomInt(contractDefinition.getDeploymentTimes().size()));\n+            \n+            StratconTrackState track = initializeTrackState(NUM_LANCES_PER_TRACK, scenarioOdds, deploymentTime);\n+            track.setDisplayableName(String.format(\"Track %d\", x));\n+            campaignState.addTrack(track);\n+        }\n+        \n+        // a campaign will have X tracks going at a time, where\n+        // X = # required lances / 3, rounded up. The last track will have fewer required lances.\n+        int oddLanceCount = contract.getRequiredLances() % NUM_LANCES_PER_TRACK;\n+        if(oddLanceCount > 0) {", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQzNDQ5OQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593434499", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for(ObjectiveParameters objectiveParams : contractDefinition.getObjectiveParameters()) {\n          \n          \n            \n                    for (ObjectiveParameters objectiveParams : contractDefinition.getObjectiveParameters()) {", "author": "Windchild292", "createdAt": "2021-03-12T20:35:12Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconContractInitializer.java", "diffHunk": "@@ -0,0 +1,288 @@\n+package mekhq.campaign.stratcon;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import megamek.common.Compute;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.stratcon.StratconContractDefinition.ObjectiveParameters;\n+\n+public class StratconContractInitializer {\n+    public static final int NUM_LANCES_PER_TRACK = 3;\n+\n+    /**\n+     * Initializes the campaign state given a contract, campaign and contract definition\n+     */\n+    public static void InitializeCampaignState(AtBContract contract, Campaign campaign, StratconContractDefinition contractDefinition) {\n+        StratconCampaignState campaignState = new StratconCampaignState(contract);\n+        campaignState.setBriefingText(contractDefinition.getBriefing() + \"<br/>\" + generateCommandLevelText(contract));\n+        campaignState.setStrategicObjectivesBehaveAsVPs(contractDefinition.objectivesBehaveAsVPs());\n+        \n+        // dependency: this is required here in order for scenario initialization to work properly\n+        contract.setStratconCampaignState(campaignState);\n+        \n+        // First, initialize the proper number of tracks. Then:\n+        // for each objective: \n+        //  step 1: calculate objective count\n+        //          if scaled, multiply # required lances by factor, round up, otherwise just fixed #\n+        //  step 2: evenly distribute objectives through tracks\n+        //          if uneven number remaining, distribute randomly \n+        //          when objective is specific scenario victory, place specially flagged scenarios\n+        //          when objective is allied/hostile facility, place those facilities\n+\n+        int numTracks = contract.getRequiredLances() / NUM_LANCES_PER_TRACK;\n+        \n+        for(int x = 0; x < numTracks; x++) {\n+            int scenarioOdds = contractDefinition.getScenarioOdds().get(Compute.randomInt(contractDefinition.getScenarioOdds().size()));\n+            int deploymentTime = contractDefinition.getDeploymentTimes().get(Compute.randomInt(contractDefinition.getDeploymentTimes().size()));\n+            \n+            StratconTrackState track = initializeTrackState(NUM_LANCES_PER_TRACK, scenarioOdds, deploymentTime);\n+            track.setDisplayableName(String.format(\"Track %d\", x));\n+            campaignState.addTrack(track);\n+        }\n+        \n+        // a campaign will have X tracks going at a time, where\n+        // X = # required lances / 3, rounded up. The last track will have fewer required lances.\n+        int oddLanceCount = contract.getRequiredLances() % NUM_LANCES_PER_TRACK;\n+        if(oddLanceCount > 0) {\n+            int scenarioOdds = contractDefinition.getScenarioOdds().get(Compute.randomInt(contractDefinition.getScenarioOdds().size()));\n+            int deploymentTime = contractDefinition.getDeploymentTimes().get(Compute.randomInt(contractDefinition.getDeploymentTimes().size()));\n+            \n+            StratconTrackState track = initializeTrackState(oddLanceCount, scenarioOdds, deploymentTime);\n+            track.setDisplayableName(String.format(\"Track %d\", campaignState.getTracks().size()));\n+            campaignState.addTrack(track);\n+        }\n+        \n+        // now seed the tracks with objectives and facilities\n+        for(ObjectiveParameters objectiveParams : contractDefinition.getObjectiveParameters()) {", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQzNDU2MQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593434561", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        for(int x = 0; x < trackObjects.size(); x++) {\n          \n          \n            \n                        for (int x = 0; x < trackObjects.size(); x++) {", "author": "Windchild292", "createdAt": "2021-03-12T20:35:19Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconContractInitializer.java", "diffHunk": "@@ -0,0 +1,288 @@\n+package mekhq.campaign.stratcon;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import megamek.common.Compute;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.stratcon.StratconContractDefinition.ObjectiveParameters;\n+\n+public class StratconContractInitializer {\n+    public static final int NUM_LANCES_PER_TRACK = 3;\n+\n+    /**\n+     * Initializes the campaign state given a contract, campaign and contract definition\n+     */\n+    public static void InitializeCampaignState(AtBContract contract, Campaign campaign, StratconContractDefinition contractDefinition) {\n+        StratconCampaignState campaignState = new StratconCampaignState(contract);\n+        campaignState.setBriefingText(contractDefinition.getBriefing() + \"<br/>\" + generateCommandLevelText(contract));\n+        campaignState.setStrategicObjectivesBehaveAsVPs(contractDefinition.objectivesBehaveAsVPs());\n+        \n+        // dependency: this is required here in order for scenario initialization to work properly\n+        contract.setStratconCampaignState(campaignState);\n+        \n+        // First, initialize the proper number of tracks. Then:\n+        // for each objective: \n+        //  step 1: calculate objective count\n+        //          if scaled, multiply # required lances by factor, round up, otherwise just fixed #\n+        //  step 2: evenly distribute objectives through tracks\n+        //          if uneven number remaining, distribute randomly \n+        //          when objective is specific scenario victory, place specially flagged scenarios\n+        //          when objective is allied/hostile facility, place those facilities\n+\n+        int numTracks = contract.getRequiredLances() / NUM_LANCES_PER_TRACK;\n+        \n+        for(int x = 0; x < numTracks; x++) {\n+            int scenarioOdds = contractDefinition.getScenarioOdds().get(Compute.randomInt(contractDefinition.getScenarioOdds().size()));\n+            int deploymentTime = contractDefinition.getDeploymentTimes().get(Compute.randomInt(contractDefinition.getDeploymentTimes().size()));\n+            \n+            StratconTrackState track = initializeTrackState(NUM_LANCES_PER_TRACK, scenarioOdds, deploymentTime);\n+            track.setDisplayableName(String.format(\"Track %d\", x));\n+            campaignState.addTrack(track);\n+        }\n+        \n+        // a campaign will have X tracks going at a time, where\n+        // X = # required lances / 3, rounded up. The last track will have fewer required lances.\n+        int oddLanceCount = contract.getRequiredLances() % NUM_LANCES_PER_TRACK;\n+        if(oddLanceCount > 0) {\n+            int scenarioOdds = contractDefinition.getScenarioOdds().get(Compute.randomInt(contractDefinition.getScenarioOdds().size()));\n+            int deploymentTime = contractDefinition.getDeploymentTimes().get(Compute.randomInt(contractDefinition.getDeploymentTimes().size()));\n+            \n+            StratconTrackState track = initializeTrackState(oddLanceCount, scenarioOdds, deploymentTime);\n+            track.setDisplayableName(String.format(\"Track %d\", campaignState.getTracks().size()));\n+            campaignState.addTrack(track);\n+        }\n+        \n+        // now seed the tracks with objectives and facilities\n+        for(ObjectiveParameters objectiveParams : contractDefinition.getObjectiveParameters()) {\n+            int objectiveCount = objectiveParams.objectiveCount > 0 ?\n+                    (int) objectiveParams.objectiveCount :\n+                    (int) (-objectiveParams.objectiveCount * contract.getRequiredLances());\n+                    \n+            campaignState.incrementPendingStrategicObjectiveCount(objectiveCount);\n+                    \n+            List<Integer> trackObjects = trackObjectDistribution(objectiveCount, campaignState.getTracks().size()); \n+                   \n+            for(int x = 0; x < trackObjects.size(); x++) {", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQzNDYzNw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593434637", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            switch(objectiveParams.objectiveType) {\n          \n          \n            \n                            switch (objectiveParams.objectiveType) {", "author": "Windchild292", "createdAt": "2021-03-12T20:35:27Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconContractInitializer.java", "diffHunk": "@@ -0,0 +1,288 @@\n+package mekhq.campaign.stratcon;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import megamek.common.Compute;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.stratcon.StratconContractDefinition.ObjectiveParameters;\n+\n+public class StratconContractInitializer {\n+    public static final int NUM_LANCES_PER_TRACK = 3;\n+\n+    /**\n+     * Initializes the campaign state given a contract, campaign and contract definition\n+     */\n+    public static void InitializeCampaignState(AtBContract contract, Campaign campaign, StratconContractDefinition contractDefinition) {\n+        StratconCampaignState campaignState = new StratconCampaignState(contract);\n+        campaignState.setBriefingText(contractDefinition.getBriefing() + \"<br/>\" + generateCommandLevelText(contract));\n+        campaignState.setStrategicObjectivesBehaveAsVPs(contractDefinition.objectivesBehaveAsVPs());\n+        \n+        // dependency: this is required here in order for scenario initialization to work properly\n+        contract.setStratconCampaignState(campaignState);\n+        \n+        // First, initialize the proper number of tracks. Then:\n+        // for each objective: \n+        //  step 1: calculate objective count\n+        //          if scaled, multiply # required lances by factor, round up, otherwise just fixed #\n+        //  step 2: evenly distribute objectives through tracks\n+        //          if uneven number remaining, distribute randomly \n+        //          when objective is specific scenario victory, place specially flagged scenarios\n+        //          when objective is allied/hostile facility, place those facilities\n+\n+        int numTracks = contract.getRequiredLances() / NUM_LANCES_PER_TRACK;\n+        \n+        for(int x = 0; x < numTracks; x++) {\n+            int scenarioOdds = contractDefinition.getScenarioOdds().get(Compute.randomInt(contractDefinition.getScenarioOdds().size()));\n+            int deploymentTime = contractDefinition.getDeploymentTimes().get(Compute.randomInt(contractDefinition.getDeploymentTimes().size()));\n+            \n+            StratconTrackState track = initializeTrackState(NUM_LANCES_PER_TRACK, scenarioOdds, deploymentTime);\n+            track.setDisplayableName(String.format(\"Track %d\", x));\n+            campaignState.addTrack(track);\n+        }\n+        \n+        // a campaign will have X tracks going at a time, where\n+        // X = # required lances / 3, rounded up. The last track will have fewer required lances.\n+        int oddLanceCount = contract.getRequiredLances() % NUM_LANCES_PER_TRACK;\n+        if(oddLanceCount > 0) {\n+            int scenarioOdds = contractDefinition.getScenarioOdds().get(Compute.randomInt(contractDefinition.getScenarioOdds().size()));\n+            int deploymentTime = contractDefinition.getDeploymentTimes().get(Compute.randomInt(contractDefinition.getDeploymentTimes().size()));\n+            \n+            StratconTrackState track = initializeTrackState(oddLanceCount, scenarioOdds, deploymentTime);\n+            track.setDisplayableName(String.format(\"Track %d\", campaignState.getTracks().size()));\n+            campaignState.addTrack(track);\n+        }\n+        \n+        // now seed the tracks with objectives and facilities\n+        for(ObjectiveParameters objectiveParams : contractDefinition.getObjectiveParameters()) {\n+            int objectiveCount = objectiveParams.objectiveCount > 0 ?\n+                    (int) objectiveParams.objectiveCount :\n+                    (int) (-objectiveParams.objectiveCount * contract.getRequiredLances());\n+                    \n+            campaignState.incrementPendingStrategicObjectiveCount(objectiveCount);\n+                    \n+            List<Integer> trackObjects = trackObjectDistribution(objectiveCount, campaignState.getTracks().size()); \n+                   \n+            for(int x = 0; x < trackObjects.size(); x++) {\n+                int numObjects = trackObjects.get(x);\n+                \n+                switch(objectiveParams.objectiveType) {", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQzNDc5NQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593434795", "bodyText": "indent switch cases", "author": "Windchild292", "createdAt": "2021-03-12T20:35:45Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconContractInitializer.java", "diffHunk": "@@ -0,0 +1,288 @@\n+package mekhq.campaign.stratcon;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import megamek.common.Compute;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.stratcon.StratconContractDefinition.ObjectiveParameters;\n+\n+public class StratconContractInitializer {\n+    public static final int NUM_LANCES_PER_TRACK = 3;\n+\n+    /**\n+     * Initializes the campaign state given a contract, campaign and contract definition\n+     */\n+    public static void InitializeCampaignState(AtBContract contract, Campaign campaign, StratconContractDefinition contractDefinition) {\n+        StratconCampaignState campaignState = new StratconCampaignState(contract);\n+        campaignState.setBriefingText(contractDefinition.getBriefing() + \"<br/>\" + generateCommandLevelText(contract));\n+        campaignState.setStrategicObjectivesBehaveAsVPs(contractDefinition.objectivesBehaveAsVPs());\n+        \n+        // dependency: this is required here in order for scenario initialization to work properly\n+        contract.setStratconCampaignState(campaignState);\n+        \n+        // First, initialize the proper number of tracks. Then:\n+        // for each objective: \n+        //  step 1: calculate objective count\n+        //          if scaled, multiply # required lances by factor, round up, otherwise just fixed #\n+        //  step 2: evenly distribute objectives through tracks\n+        //          if uneven number remaining, distribute randomly \n+        //          when objective is specific scenario victory, place specially flagged scenarios\n+        //          when objective is allied/hostile facility, place those facilities\n+\n+        int numTracks = contract.getRequiredLances() / NUM_LANCES_PER_TRACK;\n+        \n+        for(int x = 0; x < numTracks; x++) {\n+            int scenarioOdds = contractDefinition.getScenarioOdds().get(Compute.randomInt(contractDefinition.getScenarioOdds().size()));\n+            int deploymentTime = contractDefinition.getDeploymentTimes().get(Compute.randomInt(contractDefinition.getDeploymentTimes().size()));\n+            \n+            StratconTrackState track = initializeTrackState(NUM_LANCES_PER_TRACK, scenarioOdds, deploymentTime);\n+            track.setDisplayableName(String.format(\"Track %d\", x));\n+            campaignState.addTrack(track);\n+        }\n+        \n+        // a campaign will have X tracks going at a time, where\n+        // X = # required lances / 3, rounded up. The last track will have fewer required lances.\n+        int oddLanceCount = contract.getRequiredLances() % NUM_LANCES_PER_TRACK;\n+        if(oddLanceCount > 0) {\n+            int scenarioOdds = contractDefinition.getScenarioOdds().get(Compute.randomInt(contractDefinition.getScenarioOdds().size()));\n+            int deploymentTime = contractDefinition.getDeploymentTimes().get(Compute.randomInt(contractDefinition.getDeploymentTimes().size()));\n+            \n+            StratconTrackState track = initializeTrackState(oddLanceCount, scenarioOdds, deploymentTime);\n+            track.setDisplayableName(String.format(\"Track %d\", campaignState.getTracks().size()));\n+            campaignState.addTrack(track);\n+        }\n+        \n+        // now seed the tracks with objectives and facilities\n+        for(ObjectiveParameters objectiveParams : contractDefinition.getObjectiveParameters()) {\n+            int objectiveCount = objectiveParams.objectiveCount > 0 ?\n+                    (int) objectiveParams.objectiveCount :\n+                    (int) (-objectiveParams.objectiveCount * contract.getRequiredLances());\n+                    \n+            campaignState.incrementPendingStrategicObjectiveCount(objectiveCount);\n+                    \n+            List<Integer> trackObjects = trackObjectDistribution(objectiveCount, campaignState.getTracks().size()); \n+                   \n+            for(int x = 0; x < trackObjects.size(); x++) {\n+                int numObjects = trackObjects.get(x);\n+                \n+                switch(objectiveParams.objectiveType) {\n+                case SpecificScenarioVictory:\n+                    initializeObjectiveScenarios(campaign, contract, campaignState.getTrack(x), numObjects,\n+                            objectiveParams.objectiveScenarios, objectiveParams.objectiveScenarioModifiers);\n+                    break;\n+                case AlliedFacilityControl:\n+                    initializeTrackFacilities(campaignState.getTrack(x), numObjects, ForceAlignment.Allied, null, true);\n+                    break;\n+                case HostileFacilityControl:\n+                case FacilityDestruction:\n+                    initializeTrackFacilities(campaignState.getTrack(x), numObjects, ForceAlignment.Opposing, null, true);\n+                    break;\n+                case AnyScenarioVictory:\n+                    if (objectiveParams.objectiveScenarioModifiers != null) {\n+                        campaignState.getGlobalScenarioModifiers().addAll(objectiveParams.objectiveScenarioModifiers);\n+                    }\n+                    break;", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQzNTk3Mw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593435973", "bodyText": "header", "author": "Windchild292", "createdAt": "2021-03-12T20:37:53Z", "path": "MekHQ/unittests/mekhq/campaign/mission/DynamicScenarioFactoryTest.java", "diffHunk": "@@ -0,0 +1,68 @@\n+package mekhq.campaign.mission;", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQzNjE0Mg==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593436142", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for(int x = 0; x < 40; x++) {\n          \n          \n            \n                    for (int x = 0; x < 40; x++) {", "author": "Windchild292", "createdAt": "2021-03-12T20:38:12Z", "path": "MekHQ/unittests/mekhq/campaign/mission/DynamicScenarioFactoryTest.java", "diffHunk": "@@ -0,0 +1,68 @@\n+package mekhq.campaign.mission;\n+\n+import megamek.common.Board;\n+import megamek.common.UnitType;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+\n+public class DynamicScenarioFactoryTest {\n+    @Test\n+    public void testGetOppositeEdge() {\n+        int startingEdge = Board.START_EDGE;\n+        Assert.assertEquals(Board.START_CENTER, AtBDynamicScenarioFactory.getOppositeEdge(startingEdge));\n+        \n+        startingEdge = Board.START_CENTER;\n+        Assert.assertEquals(Board.START_EDGE, AtBDynamicScenarioFactory.getOppositeEdge(startingEdge));\n+        \n+        startingEdge = Board.START_ANY;\n+        Assert.assertEquals(Board.START_ANY, AtBDynamicScenarioFactory.getOppositeEdge(startingEdge));\n+        \n+        startingEdge = Board.START_N;\n+        Assert.assertEquals(Board.START_S, AtBDynamicScenarioFactory.getOppositeEdge(startingEdge));\n+        \n+        startingEdge = Board.START_E;\n+        Assert.assertEquals(Board.START_W, AtBDynamicScenarioFactory.getOppositeEdge(startingEdge));\n+        \n+        startingEdge = Board.START_S;\n+        Assert.assertEquals(Board.START_N, AtBDynamicScenarioFactory.getOppositeEdge(startingEdge));\n+        \n+        startingEdge = Board.START_W;\n+        Assert.assertEquals(Board.START_E, AtBDynamicScenarioFactory.getOppositeEdge(startingEdge));\n+        \n+        startingEdge = Board.START_NW;\n+        Assert.assertEquals(Board.START_SE, AtBDynamicScenarioFactory.getOppositeEdge(startingEdge));\n+    }\n+    \n+    @Test\n+    public void testAeroLanceSize() {\n+        Assert.assertEquals(2, AtBDynamicScenarioFactory.getAeroLanceSize(UnitType.AERO, true, \"FC\"));\n+        Assert.assertEquals(3, AtBDynamicScenarioFactory.getAeroLanceSize(UnitType.AERO, true, \"CC\"));\n+        Assert.assertEquals(2, \n+                AtBDynamicScenarioFactory.getAeroLanceSize(ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_AERO_MIX, false, \"FC\"));\n+        Assert.assertEquals(3, \n+                AtBDynamicScenarioFactory.getAeroLanceSize(ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_AERO_MIX, false, \"CC\"));\n+        \n+        // the number of conv fighters is randomly generated, but should be between 2 and 6, inclusively\n+        // we run it a bunch of times, all but guaranteeing that we hit the extremes\n+        for(int x = 0; x < 40; x++) {", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQzNjI5NA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593436294", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                numConvFighters >= 2 && numConvFighters <= 6);\n          \n          \n            \n                                (numConvFighters >= 2) && (numConvFighters <= 6));", "author": "Windchild292", "createdAt": "2021-03-12T20:38:25Z", "path": "MekHQ/unittests/mekhq/campaign/mission/DynamicScenarioFactoryTest.java", "diffHunk": "@@ -0,0 +1,68 @@\n+package mekhq.campaign.mission;\n+\n+import megamek.common.Board;\n+import megamek.common.UnitType;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+\n+public class DynamicScenarioFactoryTest {\n+    @Test\n+    public void testGetOppositeEdge() {\n+        int startingEdge = Board.START_EDGE;\n+        Assert.assertEquals(Board.START_CENTER, AtBDynamicScenarioFactory.getOppositeEdge(startingEdge));\n+        \n+        startingEdge = Board.START_CENTER;\n+        Assert.assertEquals(Board.START_EDGE, AtBDynamicScenarioFactory.getOppositeEdge(startingEdge));\n+        \n+        startingEdge = Board.START_ANY;\n+        Assert.assertEquals(Board.START_ANY, AtBDynamicScenarioFactory.getOppositeEdge(startingEdge));\n+        \n+        startingEdge = Board.START_N;\n+        Assert.assertEquals(Board.START_S, AtBDynamicScenarioFactory.getOppositeEdge(startingEdge));\n+        \n+        startingEdge = Board.START_E;\n+        Assert.assertEquals(Board.START_W, AtBDynamicScenarioFactory.getOppositeEdge(startingEdge));\n+        \n+        startingEdge = Board.START_S;\n+        Assert.assertEquals(Board.START_N, AtBDynamicScenarioFactory.getOppositeEdge(startingEdge));\n+        \n+        startingEdge = Board.START_W;\n+        Assert.assertEquals(Board.START_E, AtBDynamicScenarioFactory.getOppositeEdge(startingEdge));\n+        \n+        startingEdge = Board.START_NW;\n+        Assert.assertEquals(Board.START_SE, AtBDynamicScenarioFactory.getOppositeEdge(startingEdge));\n+    }\n+    \n+    @Test\n+    public void testAeroLanceSize() {\n+        Assert.assertEquals(2, AtBDynamicScenarioFactory.getAeroLanceSize(UnitType.AERO, true, \"FC\"));\n+        Assert.assertEquals(3, AtBDynamicScenarioFactory.getAeroLanceSize(UnitType.AERO, true, \"CC\"));\n+        Assert.assertEquals(2, \n+                AtBDynamicScenarioFactory.getAeroLanceSize(ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_AERO_MIX, false, \"FC\"));\n+        Assert.assertEquals(3, \n+                AtBDynamicScenarioFactory.getAeroLanceSize(ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_AERO_MIX, false, \"CC\"));\n+        \n+        // the number of conv fighters is randomly generated, but should be between 2 and 6, inclusively\n+        // we run it a bunch of times, all but guaranteeing that we hit the extremes\n+        for(int x = 0; x < 40; x++) {\n+            int numConvFighters = AtBDynamicScenarioFactory.getAeroLanceSize(UnitType.CONV_FIGHTER, true, \"FC\");\n+            Assert.assertTrue(String.format(\"Conv Fighter count: %d for FC faction not between 2 and 6 inclusive\", numConvFighters), \n+                    numConvFighters >= 2 && numConvFighters <= 6);", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQzNjM4OA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593436388", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                numConvFighters >= 3 && numConvFighters <= 9);\n          \n          \n            \n                                (numConvFighters >= 3) && (numConvFighters <= 9));", "author": "Windchild292", "createdAt": "2021-03-12T20:38:36Z", "path": "MekHQ/unittests/mekhq/campaign/mission/DynamicScenarioFactoryTest.java", "diffHunk": "@@ -0,0 +1,68 @@\n+package mekhq.campaign.mission;\n+\n+import megamek.common.Board;\n+import megamek.common.UnitType;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+\n+public class DynamicScenarioFactoryTest {\n+    @Test\n+    public void testGetOppositeEdge() {\n+        int startingEdge = Board.START_EDGE;\n+        Assert.assertEquals(Board.START_CENTER, AtBDynamicScenarioFactory.getOppositeEdge(startingEdge));\n+        \n+        startingEdge = Board.START_CENTER;\n+        Assert.assertEquals(Board.START_EDGE, AtBDynamicScenarioFactory.getOppositeEdge(startingEdge));\n+        \n+        startingEdge = Board.START_ANY;\n+        Assert.assertEquals(Board.START_ANY, AtBDynamicScenarioFactory.getOppositeEdge(startingEdge));\n+        \n+        startingEdge = Board.START_N;\n+        Assert.assertEquals(Board.START_S, AtBDynamicScenarioFactory.getOppositeEdge(startingEdge));\n+        \n+        startingEdge = Board.START_E;\n+        Assert.assertEquals(Board.START_W, AtBDynamicScenarioFactory.getOppositeEdge(startingEdge));\n+        \n+        startingEdge = Board.START_S;\n+        Assert.assertEquals(Board.START_N, AtBDynamicScenarioFactory.getOppositeEdge(startingEdge));\n+        \n+        startingEdge = Board.START_W;\n+        Assert.assertEquals(Board.START_E, AtBDynamicScenarioFactory.getOppositeEdge(startingEdge));\n+        \n+        startingEdge = Board.START_NW;\n+        Assert.assertEquals(Board.START_SE, AtBDynamicScenarioFactory.getOppositeEdge(startingEdge));\n+    }\n+    \n+    @Test\n+    public void testAeroLanceSize() {\n+        Assert.assertEquals(2, AtBDynamicScenarioFactory.getAeroLanceSize(UnitType.AERO, true, \"FC\"));\n+        Assert.assertEquals(3, AtBDynamicScenarioFactory.getAeroLanceSize(UnitType.AERO, true, \"CC\"));\n+        Assert.assertEquals(2, \n+                AtBDynamicScenarioFactory.getAeroLanceSize(ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_AERO_MIX, false, \"FC\"));\n+        Assert.assertEquals(3, \n+                AtBDynamicScenarioFactory.getAeroLanceSize(ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_AERO_MIX, false, \"CC\"));\n+        \n+        // the number of conv fighters is randomly generated, but should be between 2 and 6, inclusively\n+        // we run it a bunch of times, all but guaranteeing that we hit the extremes\n+        for(int x = 0; x < 40; x++) {\n+            int numConvFighters = AtBDynamicScenarioFactory.getAeroLanceSize(UnitType.CONV_FIGHTER, true, \"FC\");\n+            Assert.assertTrue(String.format(\"Conv Fighter count: %d for FC faction not between 2 and 6 inclusive\", numConvFighters), \n+                    numConvFighters >= 2 && numConvFighters <= 6);\n+            \n+            // for capellans, between 3 and 9\n+            numConvFighters = AtBDynamicScenarioFactory.getAeroLanceSize(UnitType.CONV_FIGHTER, true, \"CC\");\n+            Assert.assertTrue(String.format(\"Conv Fighter count: %d for CC faction not between 3 and 9 inclusive\", numConvFighters),\n+                    numConvFighters >= 3 && numConvFighters <= 9);\n+            \n+            numConvFighters = AtBDynamicScenarioFactory.getAeroLanceSize(ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_AERO_MIX, true, \"FC\");\n+            Assert.assertTrue(String.format(\"Conv Fighter count: %d for FC faction not between 2 and 6 inclusive\", numConvFighters),\n+                    numConvFighters >= 2 && numConvFighters <= 6);\n+            \n+            numConvFighters = AtBDynamicScenarioFactory.getAeroLanceSize(ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_AERO_MIX, true, \"CC\");\n+            Assert.assertTrue(String.format(\"Conv Fighter count: %d for CC faction not between 3 and 9 inclusive\", numConvFighters),\n+                    numConvFighters >= 3 && numConvFighters <= 9);", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQzNjQ4Mw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593436483", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                numConvFighters >= 2 && numConvFighters <= 6);\n          \n          \n            \n                                (numConvFighters >= 2) && (numConvFighters <= 6));", "author": "Windchild292", "createdAt": "2021-03-12T20:38:48Z", "path": "MekHQ/unittests/mekhq/campaign/mission/DynamicScenarioFactoryTest.java", "diffHunk": "@@ -0,0 +1,68 @@\n+package mekhq.campaign.mission;\n+\n+import megamek.common.Board;\n+import megamek.common.UnitType;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+\n+public class DynamicScenarioFactoryTest {\n+    @Test\n+    public void testGetOppositeEdge() {\n+        int startingEdge = Board.START_EDGE;\n+        Assert.assertEquals(Board.START_CENTER, AtBDynamicScenarioFactory.getOppositeEdge(startingEdge));\n+        \n+        startingEdge = Board.START_CENTER;\n+        Assert.assertEquals(Board.START_EDGE, AtBDynamicScenarioFactory.getOppositeEdge(startingEdge));\n+        \n+        startingEdge = Board.START_ANY;\n+        Assert.assertEquals(Board.START_ANY, AtBDynamicScenarioFactory.getOppositeEdge(startingEdge));\n+        \n+        startingEdge = Board.START_N;\n+        Assert.assertEquals(Board.START_S, AtBDynamicScenarioFactory.getOppositeEdge(startingEdge));\n+        \n+        startingEdge = Board.START_E;\n+        Assert.assertEquals(Board.START_W, AtBDynamicScenarioFactory.getOppositeEdge(startingEdge));\n+        \n+        startingEdge = Board.START_S;\n+        Assert.assertEquals(Board.START_N, AtBDynamicScenarioFactory.getOppositeEdge(startingEdge));\n+        \n+        startingEdge = Board.START_W;\n+        Assert.assertEquals(Board.START_E, AtBDynamicScenarioFactory.getOppositeEdge(startingEdge));\n+        \n+        startingEdge = Board.START_NW;\n+        Assert.assertEquals(Board.START_SE, AtBDynamicScenarioFactory.getOppositeEdge(startingEdge));\n+    }\n+    \n+    @Test\n+    public void testAeroLanceSize() {\n+        Assert.assertEquals(2, AtBDynamicScenarioFactory.getAeroLanceSize(UnitType.AERO, true, \"FC\"));\n+        Assert.assertEquals(3, AtBDynamicScenarioFactory.getAeroLanceSize(UnitType.AERO, true, \"CC\"));\n+        Assert.assertEquals(2, \n+                AtBDynamicScenarioFactory.getAeroLanceSize(ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_AERO_MIX, false, \"FC\"));\n+        Assert.assertEquals(3, \n+                AtBDynamicScenarioFactory.getAeroLanceSize(ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_AERO_MIX, false, \"CC\"));\n+        \n+        // the number of conv fighters is randomly generated, but should be between 2 and 6, inclusively\n+        // we run it a bunch of times, all but guaranteeing that we hit the extremes\n+        for(int x = 0; x < 40; x++) {\n+            int numConvFighters = AtBDynamicScenarioFactory.getAeroLanceSize(UnitType.CONV_FIGHTER, true, \"FC\");\n+            Assert.assertTrue(String.format(\"Conv Fighter count: %d for FC faction not between 2 and 6 inclusive\", numConvFighters), \n+                    numConvFighters >= 2 && numConvFighters <= 6);\n+            \n+            // for capellans, between 3 and 9\n+            numConvFighters = AtBDynamicScenarioFactory.getAeroLanceSize(UnitType.CONV_FIGHTER, true, \"CC\");\n+            Assert.assertTrue(String.format(\"Conv Fighter count: %d for CC faction not between 3 and 9 inclusive\", numConvFighters),\n+                    numConvFighters >= 3 && numConvFighters <= 9);\n+            \n+            numConvFighters = AtBDynamicScenarioFactory.getAeroLanceSize(ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_AERO_MIX, true, \"FC\");\n+            Assert.assertTrue(String.format(\"Conv Fighter count: %d for FC faction not between 2 and 6 inclusive\", numConvFighters),\n+                    numConvFighters >= 2 && numConvFighters <= 6);", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQzNjU3Ng==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593436576", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                numConvFighters >= 3 && numConvFighters <= 9);\n          \n          \n            \n                                (numConvFighters >= 3) && (numConvFighters <= 9));", "author": "Windchild292", "createdAt": "2021-03-12T20:38:59Z", "path": "MekHQ/unittests/mekhq/campaign/mission/DynamicScenarioFactoryTest.java", "diffHunk": "@@ -0,0 +1,68 @@\n+package mekhq.campaign.mission;\n+\n+import megamek.common.Board;\n+import megamek.common.UnitType;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+\n+public class DynamicScenarioFactoryTest {\n+    @Test\n+    public void testGetOppositeEdge() {\n+        int startingEdge = Board.START_EDGE;\n+        Assert.assertEquals(Board.START_CENTER, AtBDynamicScenarioFactory.getOppositeEdge(startingEdge));\n+        \n+        startingEdge = Board.START_CENTER;\n+        Assert.assertEquals(Board.START_EDGE, AtBDynamicScenarioFactory.getOppositeEdge(startingEdge));\n+        \n+        startingEdge = Board.START_ANY;\n+        Assert.assertEquals(Board.START_ANY, AtBDynamicScenarioFactory.getOppositeEdge(startingEdge));\n+        \n+        startingEdge = Board.START_N;\n+        Assert.assertEquals(Board.START_S, AtBDynamicScenarioFactory.getOppositeEdge(startingEdge));\n+        \n+        startingEdge = Board.START_E;\n+        Assert.assertEquals(Board.START_W, AtBDynamicScenarioFactory.getOppositeEdge(startingEdge));\n+        \n+        startingEdge = Board.START_S;\n+        Assert.assertEquals(Board.START_N, AtBDynamicScenarioFactory.getOppositeEdge(startingEdge));\n+        \n+        startingEdge = Board.START_W;\n+        Assert.assertEquals(Board.START_E, AtBDynamicScenarioFactory.getOppositeEdge(startingEdge));\n+        \n+        startingEdge = Board.START_NW;\n+        Assert.assertEquals(Board.START_SE, AtBDynamicScenarioFactory.getOppositeEdge(startingEdge));\n+    }\n+    \n+    @Test\n+    public void testAeroLanceSize() {\n+        Assert.assertEquals(2, AtBDynamicScenarioFactory.getAeroLanceSize(UnitType.AERO, true, \"FC\"));\n+        Assert.assertEquals(3, AtBDynamicScenarioFactory.getAeroLanceSize(UnitType.AERO, true, \"CC\"));\n+        Assert.assertEquals(2, \n+                AtBDynamicScenarioFactory.getAeroLanceSize(ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_AERO_MIX, false, \"FC\"));\n+        Assert.assertEquals(3, \n+                AtBDynamicScenarioFactory.getAeroLanceSize(ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_AERO_MIX, false, \"CC\"));\n+        \n+        // the number of conv fighters is randomly generated, but should be between 2 and 6, inclusively\n+        // we run it a bunch of times, all but guaranteeing that we hit the extremes\n+        for(int x = 0; x < 40; x++) {\n+            int numConvFighters = AtBDynamicScenarioFactory.getAeroLanceSize(UnitType.CONV_FIGHTER, true, \"FC\");\n+            Assert.assertTrue(String.format(\"Conv Fighter count: %d for FC faction not between 2 and 6 inclusive\", numConvFighters), \n+                    numConvFighters >= 2 && numConvFighters <= 6);\n+            \n+            // for capellans, between 3 and 9\n+            numConvFighters = AtBDynamicScenarioFactory.getAeroLanceSize(UnitType.CONV_FIGHTER, true, \"CC\");\n+            Assert.assertTrue(String.format(\"Conv Fighter count: %d for CC faction not between 3 and 9 inclusive\", numConvFighters),\n+                    numConvFighters >= 3 && numConvFighters <= 9);", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQzNjcwMA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593436700", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    switch(e.getActionCommand()) {\n          \n          \n            \n                    switch (e.getActionCommand()) {", "author": "Windchild292", "createdAt": "2021-03-12T20:39:14Z", "path": "MekHQ/src/mekhq/gui/stratcon/TrackForceAssignmentUI.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package mekhq.gui.stratcon;\n+\n+import java.awt.GridBagConstraints;\n+import java.awt.GridBagLayout;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import javax.swing.JButton;\n+import javax.swing.JDialog;\n+import javax.swing.JLabel;\n+import javax.swing.JList;\n+import javax.swing.JScrollPane;\n+\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.stratcon.StratconCampaignState;\n+import mekhq.campaign.stratcon.StratconCoords;\n+import mekhq.campaign.stratcon.StratconRulesManager;\n+import mekhq.gui.StratconPanel;\n+\n+/**\n+ * This class handles the \"assign force to track\" interaction, \n+ * where a user may assign a force to a track directly, either to a facility or \n+ * @author NickAragua\n+ *\n+ */\n+public class TrackForceAssignmentUI extends JDialog implements ActionListener {\n+    private final static String CMD_CONFIRM = \"CMD_TRACK_FORCE_CONFIRM\";\n+    \n+    Campaign campaign;\n+    StratconCampaignState currentCampaignState;\n+    int currentTrackIndex;\n+    StratconCoords selectedCoords;\n+    private JList<Force> availableForceList = new JList<>();\n+    private JButton btnConfirm = new JButton();\n+    private StratconPanel ownerPanel;\n+    \n+    public TrackForceAssignmentUI(StratconPanel parent) {\n+        ownerPanel = parent;\n+        btnConfirm = new JButton(\"Confirm\");\n+        btnConfirm.setActionCommand(CMD_CONFIRM);\n+        btnConfirm.addActionListener(this);\n+    }\n+    \n+    private void initializeUI() {\n+        getContentPane().removeAll();\n+        getContentPane().setLayout(new GridBagLayout());\n+        \n+        GridBagConstraints gbc = new GridBagConstraints();\n+        gbc.gridx = 0; \n+        gbc.gridy = 0;\n+        gbc.anchor = GridBagConstraints.CENTER;\n+        gbc.fill = GridBagConstraints.BOTH;\n+        \n+        JLabel forceAssignmentInstructions = new JLabel(\"Select force to assign to this track.\");\n+        getContentPane().add(forceAssignmentInstructions, gbc);\n+        gbc.gridy++;\n+\n+        JScrollPane forceListContainer = new JScrollPane();\n+\n+        ScenarioWizardLanceModel lanceModel;\n+        \n+        // if we're waiting to assign primary forces, we can only do so from the current track \n+        lanceModel = new ScenarioWizardLanceModel(campaign, \n+                StratconRulesManager.getAvailableForceIDs(ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_MIX, \n+                        campaign, currentCampaignState.getTrack(currentTrackIndex), false));\n+        \n+        availableForceList.setModel(lanceModel);\n+        availableForceList.setCellRenderer(new ScenarioWizardLanceRenderer(campaign));\n+        \n+        forceListContainer.setViewportView(availableForceList);\n+\n+        getContentPane().add(forceListContainer, gbc);\n+        \n+\n+        gbc.gridy++;\n+        \n+        getContentPane().add(btnConfirm, gbc);\n+        btnConfirm.setEnabled(true);\n+        \n+        pack();\n+        repaint();\n+    }\n+    \n+    /**\n+     * Display the track force assignment UI.\n+     * @param campaign\n+     * @param campaignState\n+     * @param currentTrackIndex\n+     */\n+    public void display(Campaign campaign, StratconCampaignState campaignState, int currentTrackIndex, StratconCoords coords) {\n+        this.campaign = campaign;\n+        this.currentCampaignState = campaignState;\n+        this.currentTrackIndex = currentTrackIndex;\n+        this.selectedCoords = coords;\n+        \n+        initializeUI();\n+    }\n+\n+    \n+    @Override\n+    public void actionPerformed(ActionEvent e) {\n+        switch(e.getActionCommand()) {", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQzNjc2OA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593436768", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            for(Force force : availableForceList.getSelectedValuesList()) {\n          \n          \n            \n                            for (Force force : availableForceList.getSelectedValuesList()) {", "author": "Windchild292", "createdAt": "2021-03-12T20:39:22Z", "path": "MekHQ/src/mekhq/gui/stratcon/TrackForceAssignmentUI.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package mekhq.gui.stratcon;\n+\n+import java.awt.GridBagConstraints;\n+import java.awt.GridBagLayout;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import javax.swing.JButton;\n+import javax.swing.JDialog;\n+import javax.swing.JLabel;\n+import javax.swing.JList;\n+import javax.swing.JScrollPane;\n+\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.stratcon.StratconCampaignState;\n+import mekhq.campaign.stratcon.StratconCoords;\n+import mekhq.campaign.stratcon.StratconRulesManager;\n+import mekhq.gui.StratconPanel;\n+\n+/**\n+ * This class handles the \"assign force to track\" interaction, \n+ * where a user may assign a force to a track directly, either to a facility or \n+ * @author NickAragua\n+ *\n+ */\n+public class TrackForceAssignmentUI extends JDialog implements ActionListener {\n+    private final static String CMD_CONFIRM = \"CMD_TRACK_FORCE_CONFIRM\";\n+    \n+    Campaign campaign;\n+    StratconCampaignState currentCampaignState;\n+    int currentTrackIndex;\n+    StratconCoords selectedCoords;\n+    private JList<Force> availableForceList = new JList<>();\n+    private JButton btnConfirm = new JButton();\n+    private StratconPanel ownerPanel;\n+    \n+    public TrackForceAssignmentUI(StratconPanel parent) {\n+        ownerPanel = parent;\n+        btnConfirm = new JButton(\"Confirm\");\n+        btnConfirm.setActionCommand(CMD_CONFIRM);\n+        btnConfirm.addActionListener(this);\n+    }\n+    \n+    private void initializeUI() {\n+        getContentPane().removeAll();\n+        getContentPane().setLayout(new GridBagLayout());\n+        \n+        GridBagConstraints gbc = new GridBagConstraints();\n+        gbc.gridx = 0; \n+        gbc.gridy = 0;\n+        gbc.anchor = GridBagConstraints.CENTER;\n+        gbc.fill = GridBagConstraints.BOTH;\n+        \n+        JLabel forceAssignmentInstructions = new JLabel(\"Select force to assign to this track.\");\n+        getContentPane().add(forceAssignmentInstructions, gbc);\n+        gbc.gridy++;\n+\n+        JScrollPane forceListContainer = new JScrollPane();\n+\n+        ScenarioWizardLanceModel lanceModel;\n+        \n+        // if we're waiting to assign primary forces, we can only do so from the current track \n+        lanceModel = new ScenarioWizardLanceModel(campaign, \n+                StratconRulesManager.getAvailableForceIDs(ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_MIX, \n+                        campaign, currentCampaignState.getTrack(currentTrackIndex), false));\n+        \n+        availableForceList.setModel(lanceModel);\n+        availableForceList.setCellRenderer(new ScenarioWizardLanceRenderer(campaign));\n+        \n+        forceListContainer.setViewportView(availableForceList);\n+\n+        getContentPane().add(forceListContainer, gbc);\n+        \n+\n+        gbc.gridy++;\n+        \n+        getContentPane().add(btnConfirm, gbc);\n+        btnConfirm.setEnabled(true);\n+        \n+        pack();\n+        repaint();\n+    }\n+    \n+    /**\n+     * Display the track force assignment UI.\n+     * @param campaign\n+     * @param campaignState\n+     * @param currentTrackIndex\n+     */\n+    public void display(Campaign campaign, StratconCampaignState campaignState, int currentTrackIndex, StratconCoords coords) {\n+        this.campaign = campaign;\n+        this.currentCampaignState = campaignState;\n+        this.currentTrackIndex = currentTrackIndex;\n+        this.selectedCoords = coords;\n+        \n+        initializeUI();\n+    }\n+\n+    \n+    @Override\n+    public void actionPerformed(ActionEvent e) {\n+        switch(e.getActionCommand()) {\n+            case CMD_CONFIRM:\n+                // sometimes the scenario templates take a little while to load, we don't want the user\n+                // clicking the button fifty times and getting a bunch of scenarios.\n+                btnConfirm.setEnabled(false);                \n+                for(Force force : availableForceList.getSelectedValuesList()) {", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQzNjk0OQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593436949", "bodyText": "header", "author": "Windchild292", "createdAt": "2021-03-12T20:39:43Z", "path": "MekHQ/src/mekhq/gui/stratcon/TrackForceAssignmentUI.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package mekhq.gui.stratcon;", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQzNzA1OQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593437059", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             *\n          \n          \n            \n             */\n          \n          \n            \n             */", "author": "Windchild292", "createdAt": "2021-03-12T20:39:55Z", "path": "MekHQ/src/mekhq/gui/stratcon/TrackForceAssignmentUI.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package mekhq.gui.stratcon;\n+\n+import java.awt.GridBagConstraints;\n+import java.awt.GridBagLayout;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import javax.swing.JButton;\n+import javax.swing.JDialog;\n+import javax.swing.JLabel;\n+import javax.swing.JList;\n+import javax.swing.JScrollPane;\n+\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.stratcon.StratconCampaignState;\n+import mekhq.campaign.stratcon.StratconCoords;\n+import mekhq.campaign.stratcon.StratconRulesManager;\n+import mekhq.gui.StratconPanel;\n+\n+/**\n+ * This class handles the \"assign force to track\" interaction, \n+ * where a user may assign a force to a track directly, either to a facility or \n+ * @author NickAragua\n+ *\n+ */", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQzNzEyMA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593437120", "bodyText": "Facility or???", "author": "Windchild292", "createdAt": "2021-03-12T20:40:02Z", "path": "MekHQ/src/mekhq/gui/stratcon/TrackForceAssignmentUI.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package mekhq.gui.stratcon;\n+\n+import java.awt.GridBagConstraints;\n+import java.awt.GridBagLayout;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import javax.swing.JButton;\n+import javax.swing.JDialog;\n+import javax.swing.JLabel;\n+import javax.swing.JList;\n+import javax.swing.JScrollPane;\n+\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.stratcon.StratconCampaignState;\n+import mekhq.campaign.stratcon.StratconCoords;\n+import mekhq.campaign.stratcon.StratconRulesManager;\n+import mekhq.gui.StratconPanel;\n+\n+/**\n+ * This class handles the \"assign force to track\" interaction, \n+ * where a user may assign a force to a track directly, either to a facility or ", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQzNzI3Ng==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593437276", "bodyText": "Private, use a getter/setter", "author": "Windchild292", "createdAt": "2021-03-12T20:40:20Z", "path": "MekHQ/src/mekhq/gui/stratcon/TrackForceAssignmentUI.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package mekhq.gui.stratcon;\n+\n+import java.awt.GridBagConstraints;\n+import java.awt.GridBagLayout;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import javax.swing.JButton;\n+import javax.swing.JDialog;\n+import javax.swing.JLabel;\n+import javax.swing.JList;\n+import javax.swing.JScrollPane;\n+\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.stratcon.StratconCampaignState;\n+import mekhq.campaign.stratcon.StratconCoords;\n+import mekhq.campaign.stratcon.StratconRulesManager;\n+import mekhq.gui.StratconPanel;\n+\n+/**\n+ * This class handles the \"assign force to track\" interaction, \n+ * where a user may assign a force to a track directly, either to a facility or \n+ * @author NickAragua\n+ *\n+ */\n+public class TrackForceAssignmentUI extends JDialog implements ActionListener {\n+    private final static String CMD_CONFIRM = \"CMD_TRACK_FORCE_CONFIRM\";\n+    \n+    Campaign campaign;\n+    StratconCampaignState currentCampaignState;\n+    int currentTrackIndex;\n+    StratconCoords selectedCoords;", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzU4NDEzMw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593584133", "bodyText": "Private sure, it's purely internal though.", "author": "NickAragua", "createdAt": "2021-03-13T04:47:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQzNzI3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQzNzUzMA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593437530", "bodyText": "Suggested change", "author": "Windchild292", "createdAt": "2021-03-12T20:40:49Z", "path": "MekHQ/src/mekhq/gui/stratcon/TrackForceAssignmentUI.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package mekhq.gui.stratcon;\n+\n+import java.awt.GridBagConstraints;\n+import java.awt.GridBagLayout;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import javax.swing.JButton;\n+import javax.swing.JDialog;\n+import javax.swing.JLabel;\n+import javax.swing.JList;\n+import javax.swing.JScrollPane;\n+\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.stratcon.StratconCampaignState;\n+import mekhq.campaign.stratcon.StratconCoords;\n+import mekhq.campaign.stratcon.StratconRulesManager;\n+import mekhq.gui.StratconPanel;\n+\n+/**\n+ * This class handles the \"assign force to track\" interaction, \n+ * where a user may assign a force to a track directly, either to a facility or \n+ * @author NickAragua\n+ *\n+ */\n+public class TrackForceAssignmentUI extends JDialog implements ActionListener {\n+    private final static String CMD_CONFIRM = \"CMD_TRACK_FORCE_CONFIRM\";\n+    \n+    Campaign campaign;\n+    StratconCampaignState currentCampaignState;\n+    int currentTrackIndex;\n+    StratconCoords selectedCoords;\n+    private JList<Force> availableForceList = new JList<>();\n+    private JButton btnConfirm = new JButton();\n+    private StratconPanel ownerPanel;\n+    \n+    public TrackForceAssignmentUI(StratconPanel parent) {\n+        ownerPanel = parent;\n+        btnConfirm = new JButton(\"Confirm\");\n+        btnConfirm.setActionCommand(CMD_CONFIRM);\n+        btnConfirm.addActionListener(this);\n+    }\n+    \n+    private void initializeUI() {\n+        getContentPane().removeAll();\n+        getContentPane().setLayout(new GridBagLayout());\n+        \n+        GridBagConstraints gbc = new GridBagConstraints();\n+        gbc.gridx = 0; \n+        gbc.gridy = 0;\n+        gbc.anchor = GridBagConstraints.CENTER;\n+        gbc.fill = GridBagConstraints.BOTH;\n+        \n+        JLabel forceAssignmentInstructions = new JLabel(\"Select force to assign to this track.\");\n+        getContentPane().add(forceAssignmentInstructions, gbc);\n+        gbc.gridy++;\n+\n+        JScrollPane forceListContainer = new JScrollPane();\n+\n+        ScenarioWizardLanceModel lanceModel;\n+        \n+        // if we're waiting to assign primary forces, we can only do so from the current track \n+        lanceModel = new ScenarioWizardLanceModel(campaign, \n+                StratconRulesManager.getAvailableForceIDs(ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_MIX, \n+                        campaign, currentCampaignState.getTrack(currentTrackIndex), false));\n+        \n+        availableForceList.setModel(lanceModel);\n+        availableForceList.setCellRenderer(new ScenarioWizardLanceRenderer(campaign));\n+        \n+        forceListContainer.setViewportView(availableForceList);\n+\n+        getContentPane().add(forceListContainer, gbc);\n+        ", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQzODA0OA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593438048", "bodyText": "We should really flip these", "author": "Windchild292", "createdAt": "2021-03-12T20:41:57Z", "path": "MekHQ/src/mekhq/gui/GuiTabType.java", "diffHunk": "@@ -44,7 +44,8 @@\n     INFIRMARY(8, \"panInfirmary.TabConstraints.tabTitle\", KeyEvent.VK_I),\n     MEKLAB(9, \"panMekLab.TabConstraints.tabTitle\", KeyEvent.VK_L),\n     FINANCES(10, \"panFinances.TabConstraints.tabTitle\", KeyEvent.VK_N),\n-    CUSTOM(11, \"panCustom.TabConstraints.tabTitle\", KeyEvent.VK_UNDEFINED);\n+    CUSTOM(11, \"panCustom.TabConstraints.tabTitle\", KeyEvent.VK_UNDEFINED),\n+    STRATCON(12, \"panStratcon.TabConstraints.tabTitle\", KeyEvent.VK_C);", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQzODI2MA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593438260", "bodyText": "Should probably be calling these StratConTab", "author": "Windchild292", "createdAt": "2021-03-12T20:42:23Z", "path": "MekHQ/src/mekhq/gui/GuiTabType.java", "diffHunk": "@@ -100,6 +101,8 @@ public CampaignGuiTab createTab(CampaignGUI gui) {\n                 return new MekLabTab(gui, name);\n             case FINANCES:\n                 return new FinancesTab(gui, name);\n+            case STRATCON:\n+                return new StratconTab(gui, name);", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzU2MDMzNA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593560334", "bodyText": "Unfortunately, all the other StratCon classes are actually called Stratcon, so I'm going to pass on that.", "author": "NickAragua", "createdAt": "2021-03-13T04:16:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQzODI2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQzODM0OQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593438349", "bodyText": "Suggested change", "author": "Windchild292", "createdAt": "2021-03-12T20:42:37Z", "path": "MekHQ/src/mekhq/gui/dialog/CampaignOptionsDialog.java", "diffHunk": "@@ -3566,7 +3567,7 @@ public Component getListCellRendererComponent(JList<?> list, Object value, int i\n             enableAtBComponents(panSubAtBRat,\n                     chkUseAtB.isSelected() && btnStaticRATs.isSelected());\n         });\n-\n+        ", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQzODk2NA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593438964", "bodyText": "are these two new ones needed? Doesn't seem to be used", "author": "Windchild292", "createdAt": "2021-03-12T20:43:50Z", "path": "MekHQ/src/mekhq/gui/dialog/NewContractDialog.java", "diffHunk": "@@ -35,10 +35,12 @@\n import mekhq.MekHQ;\n import mekhq.campaign.Campaign;\n import mekhq.campaign.finances.Transaction;\n+import mekhq.campaign.mission.AtBContract;\n import mekhq.campaign.mission.Contract;\n import mekhq.campaign.mission.Mission;\n import mekhq.campaign.personnel.Person;\n import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconRulesManager;", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQzOTA5Nw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593439097", "bodyText": "header", "author": "Windchild292", "createdAt": "2021-03-12T20:44:09Z", "path": "MekHQ/src/mekhq/gui/stratcon/InfoFrame.java", "diffHunk": "@@ -0,0 +1,31 @@\n+package mekhq.gui.stratcon;", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQzOTIyMg==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593439222", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    /**\n          \n          \n            \n                 * \n          \n          \n            \n                 */", "author": "Windchild292", "createdAt": "2021-03-12T20:44:25Z", "path": "MekHQ/src/mekhq/gui/stratcon/InfoFrame.java", "diffHunk": "@@ -0,0 +1,31 @@\n+package mekhq.gui.stratcon;\n+\n+import javax.swing.JInternalFrame;\n+import javax.swing.JLabel;\n+\n+public class InfoFrame extends JInternalFrame {\n+        /**\n+     * \n+     */", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQzOTQ4MQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593439481", "bodyText": "What does the last mean?", "author": "Windchild292", "createdAt": "2021-03-12T20:45:00Z", "path": "MekHQ/src/mekhq/gui/stratcon/InfoFrame.java", "diffHunk": "@@ -0,0 +1,31 @@\n+package mekhq.gui.stratcon;\n+\n+import javax.swing.JInternalFrame;\n+import javax.swing.JLabel;\n+\n+public class InfoFrame extends JInternalFrame {\n+        /**\n+     * \n+     */\n+    private static final long serialVersionUID = 5314122796511795555L;\n+    private JLabel infoLabel = new JLabel();\n+\n+    /**\n+     * Constructor. Sets up a JInternalFrame that's resizable and closable but can't be mini/maximized or turned into an icon (?).", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzU3MjM2MA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593572360", "bodyText": "I wish I knew, it's the last parameter of the super constructor.", "author": "NickAragua", "createdAt": "2021-03-13T04:32:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQzOTQ4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQzOTU3OQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593439579", "bodyText": "Hide on close? Why keep it around?", "author": "Windchild292", "createdAt": "2021-03-12T20:45:11Z", "path": "MekHQ/src/mekhq/gui/stratcon/InfoFrame.java", "diffHunk": "@@ -0,0 +1,31 @@\n+package mekhq.gui.stratcon;\n+\n+import javax.swing.JInternalFrame;\n+import javax.swing.JLabel;\n+\n+public class InfoFrame extends JInternalFrame {\n+        /**\n+     * \n+     */\n+    private static final long serialVersionUID = 5314122796511795555L;\n+    private JLabel infoLabel = new JLabel();\n+\n+    /**\n+     * Constructor. Sets up a JInternalFrame that's resizable and closable but can't be mini/maximized or turned into an icon (?).\n+     */\n+    public InfoFrame() {\n+        super(\"Detailed Info\", true, true, false, false);\n+\n+        this.add(infoLabel);\n+        this.setDefaultCloseOperation(HIDE_ON_CLOSE);", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzU3MzM2NA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593573364", "bodyText": "Turns out this file is unused anyway.", "author": "NickAragua", "createdAt": "2021-03-13T04:34:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQzOTU3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQzOTY5Nw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593439697", "bodyText": "The this. calls are unneccessary", "author": "Windchild292", "createdAt": "2021-03-12T20:45:24Z", "path": "MekHQ/src/mekhq/gui/stratcon/InfoFrame.java", "diffHunk": "@@ -0,0 +1,31 @@\n+package mekhq.gui.stratcon;\n+\n+import javax.swing.JInternalFrame;\n+import javax.swing.JLabel;\n+\n+public class InfoFrame extends JInternalFrame {\n+        /**\n+     * \n+     */\n+    private static final long serialVersionUID = 5314122796511795555L;\n+    private JLabel infoLabel = new JLabel();\n+\n+    /**\n+     * Constructor. Sets up a JInternalFrame that's resizable and closable but can't be mini/maximized or turned into an icon (?).\n+     */\n+    public InfoFrame() {\n+        super(\"Detailed Info\", true, true, false, false);\n+\n+        this.add(infoLabel);", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQzOTgyMQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593439821", "bodyText": "header", "author": "Windchild292", "createdAt": "2021-03-12T20:45:37Z", "path": "MekHQ/src/mekhq/gui/stratcon/ScenarioWizardLanceModel.java", "diffHunk": "@@ -0,0 +1,25 @@\n+package mekhq.gui.stratcon;", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQzOTkxNA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593439914", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for(int forceID : forceIDs) {\n          \n          \n            \n                    for (int forceID : forceIDs) {", "author": "Windchild292", "createdAt": "2021-03-12T20:45:48Z", "path": "MekHQ/src/mekhq/gui/stratcon/ScenarioWizardLanceModel.java", "diffHunk": "@@ -0,0 +1,25 @@\n+package mekhq.gui.stratcon;\n+\n+import java.util.List;\n+import java.util.Set;\n+\n+import javax.swing.DefaultListModel;\n+\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.force.Force;\n+\n+public class ScenarioWizardLanceModel extends DefaultListModel<Force> {\n+    public ScenarioWizardLanceModel(Campaign campaign, List<Integer> forceIDs) {\n+        super();\n+        for(int forceID : forceIDs) {", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQzOTk5Nw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593439997", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for(int forceID : forceIDs) {\n          \n          \n            \n                    for (int forceID : forceIDs) {", "author": "Windchild292", "createdAt": "2021-03-12T20:45:59Z", "path": "MekHQ/src/mekhq/gui/stratcon/ScenarioWizardLanceModel.java", "diffHunk": "@@ -0,0 +1,25 @@\n+package mekhq.gui.stratcon;\n+\n+import java.util.List;\n+import java.util.Set;\n+\n+import javax.swing.DefaultListModel;\n+\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.force.Force;\n+\n+public class ScenarioWizardLanceModel extends DefaultListModel<Force> {\n+    public ScenarioWizardLanceModel(Campaign campaign, List<Integer> forceIDs) {\n+        super();\n+        for(int forceID : forceIDs) {\n+            super.addElement(campaign.getForce(forceID));\n+        }\n+    }\n+    \n+    public ScenarioWizardLanceModel(Campaign campaign, Set<Integer> forceIDs) {\n+        super();\n+        for(int forceID : forceIDs) {", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQ0MDA3NQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593440075", "bodyText": "header", "author": "Windchild292", "createdAt": "2021-03-12T20:46:07Z", "path": "MekHQ/src/mekhq/gui/stratcon/ScenarioWizardLanceRenderer.java", "diffHunk": "@@ -0,0 +1,37 @@\n+package mekhq.gui.stratcon;", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQ0MDIxMQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593440211", "bodyText": "can this be made final?", "author": "Windchild292", "createdAt": "2021-03-12T20:46:22Z", "path": "MekHQ/src/mekhq/gui/stratcon/ScenarioWizardLanceRenderer.java", "diffHunk": "@@ -0,0 +1,37 @@\n+package mekhq.gui.stratcon;\n+\n+import java.awt.Component;\n+\n+import javax.swing.JLabel;\n+import javax.swing.JList;\n+import javax.swing.ListCellRenderer;\n+\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.force.Force;\n+\n+public class ScenarioWizardLanceRenderer extends JLabel implements ListCellRenderer<Force> {\n+    private Campaign campaign;", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQ0MDI4OA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593440288", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n                    setText(String.format(\"%s (BV: %d)\", value.getName(), value.getTotalBV(campaign)));\n          \n          \n            \n                    setText(String.format(\"%s (BV: %d)\", value.getName(), value.getTotalBV(campaign)));", "author": "Windchild292", "createdAt": "2021-03-12T20:46:32Z", "path": "MekHQ/src/mekhq/gui/stratcon/ScenarioWizardLanceRenderer.java", "diffHunk": "@@ -0,0 +1,37 @@\n+package mekhq.gui.stratcon;\n+\n+import java.awt.Component;\n+\n+import javax.swing.JLabel;\n+import javax.swing.JList;\n+import javax.swing.ListCellRenderer;\n+\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.force.Force;\n+\n+public class ScenarioWizardLanceRenderer extends JLabel implements ListCellRenderer<Force> {\n+    private Campaign campaign;\n+\n+    public ScenarioWizardLanceRenderer(Campaign campaign) {\n+        this.campaign = campaign;\n+        setOpaque(true);\n+    }\n+\n+    @Override\n+    public Component getListCellRendererComponent(JList<? extends Force> list, Force value, int index,\n+            boolean isSelected, boolean cellHasFocus) {\n+\n+        setText(String.format(\"%s (BV: %d)\", value.getName(), value.getTotalBV(campaign)));", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQ0MDQ2Ng==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593440466", "bodyText": "header", "author": "Windchild292", "createdAt": "2021-03-12T20:46:52Z", "path": "MekHQ/src/mekhq/gui/stratcon/ScenarioWizardUnitRenderer.java", "diffHunk": "@@ -0,0 +1,37 @@\n+package mekhq.gui.stratcon;", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQ0MDU1Mg==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593440552", "bodyText": "Can this be final?", "author": "Windchild292", "createdAt": "2021-03-12T20:47:03Z", "path": "MekHQ/src/mekhq/gui/stratcon/ScenarioWizardUnitRenderer.java", "diffHunk": "@@ -0,0 +1,37 @@\n+package mekhq.gui.stratcon;\n+\n+import java.awt.Component;\n+\n+import javax.swing.JLabel;\n+import javax.swing.JList;\n+import javax.swing.ListCellRenderer;\n+\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.unit.Unit;\n+\n+public class ScenarioWizardUnitRenderer extends JLabel implements ListCellRenderer<Unit> {\n+    private Campaign campaign;", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzU3ODEyNQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593578125", "bodyText": "Or, even better, eliminated, since it's unused.", "author": "NickAragua", "createdAt": "2021-03-13T04:40:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQ0MDU1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQ0MDc0OQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593440749", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if(this.getCampaign().getCampaignOptions().getUseStratCon()) {\n          \n          \n            \n                    if (getCampaign().getCampaignOptions().getUseStratCon()) {", "author": "Windchild292", "createdAt": "2021-03-12T20:47:25Z", "path": "MekHQ/src/mekhq/gui/CampaignGUI.java", "diffHunk": "@@ -247,6 +248,9 @@ private void initComponents() {\n         addStandardTab(GuiTabType.COMMAND);\n         addStandardTab(GuiTabType.TOE);\n         addStandardTab(GuiTabType.BRIEFING);\n+        if(this.getCampaign().getCampaignOptions().getUseStratCon()) {", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQ0MDg2OA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593440868", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if(!nagText.isEmpty()) {\n          \n          \n            \n                    if (!nagText.isEmpty()) {", "author": "Windchild292", "createdAt": "2021-03-12T20:47:36Z", "path": "MekHQ/src/mekhq/gui/CampaignGUI.java", "diffHunk": "@@ -1242,6 +1248,30 @@ public boolean nagOutstandingScenarios() {\n         return false;\n     }\n \n+    public boolean nagUnresolvedStratconContacts() {\n+        String nagText = StratconRulesManager.nagUnresolvedContacts(getCampaign());\n+        \n+        if(!nagText.isEmpty()) {", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQ0MTAwMw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593441003", "bodyText": "Why is this commented out?", "author": "Windchild292", "createdAt": "2021-03-12T20:47:53Z", "path": "MekHQ/src/mekhq/gui/CampaignGUI.java", "diffHunk": "@@ -1242,6 +1248,30 @@ public boolean nagOutstandingScenarios() {\n         return false;\n     }\n \n+    public boolean nagUnresolvedStratconContacts() {\n+        String nagText = StratconRulesManager.nagUnresolvedContacts(getCampaign());\n+        \n+        if(!nagText.isEmpty()) {\n+            return 0 != JOptionPane.showConfirmDialog(null, \n+                    String.format(\"You have unresolved contacts on the StratCon interface:\\n%s\\nAdvance day anyway?\", nagText), \n+                    \"Unresolved Stratcon Contacts\", JOptionPane.YES_NO_OPTION);\n+        }\n+        \n+        return false;\n+    }\n+    \n+    public boolean nagInsufficientStratconAssignments() {\n+        /*String nagText = StratconRulesManager.nagInsufficientTrackForces(getCampaign());\n+        \n+        if(!nagText.isEmpty()) {\n+            return 0 != JOptionPane.showConfirmDialog(null, \n+                    String.format(\"You have insufficient forces assigned on the StratCon interface:\\n%s\\nAdvance day anyway?\", nagText), \n+                    \"Unresolved Stratcon Contacts\", JOptionPane.YES_NO_OPTION);\n+        }*/", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzU1OTczOQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593559739", "bodyText": "Think I cut this feature from the MVP, and don't really remember what the point was.", "author": "NickAragua", "createdAt": "2021-03-13T04:15:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQ0MTAwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQ0MTM3OQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593441379", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if(isXOdd() && coords.getX() != getX()) {\n          \n          \n            \n                    if (isXOdd() && (coords.getX() != getX())) {", "author": "Windchild292", "createdAt": "2021-03-12T20:48:39Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconCoords.java", "diffHunk": "@@ -0,0 +1,53 @@\n+package mekhq.campaign.stratcon;\n+\n+import megamek.common.Coords;\n+import megamek.common.util.HashCodeUtil;\n+\n+public class StratconCoords extends Coords {\n+    private static final long serialVersionUID = 2660132431077309812L;\n+\n+    public StratconCoords(int x, int y) {\n+        super(x, y);\n+    }\n+    \n+    public StratconCoords() {\n+        super(0, 0);\n+    }\n+\n+    public StratconCoords translate(int direction) {\n+        Coords coords = translated(direction);\n+        int y = coords.getY();\n+        \n+        if(isXOdd() && coords.getX() != getX()) {", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQ0MTQ2MA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593441460", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    } else if (!isXOdd() && coords.getX() != getX()) {\n          \n          \n            \n                    } else if (!isXOdd() && (coords.getX() != getX())) {", "author": "Windchild292", "createdAt": "2021-03-12T20:48:48Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconCoords.java", "diffHunk": "@@ -0,0 +1,53 @@\n+package mekhq.campaign.stratcon;\n+\n+import megamek.common.Coords;\n+import megamek.common.util.HashCodeUtil;\n+\n+public class StratconCoords extends Coords {\n+    private static final long serialVersionUID = 2660132431077309812L;\n+\n+    public StratconCoords(int x, int y) {\n+        super(x, y);\n+    }\n+    \n+    public StratconCoords() {\n+        super(0, 0);\n+    }\n+\n+    public StratconCoords translate(int direction) {\n+        Coords coords = translated(direction);\n+        int y = coords.getY();\n+        \n+        if(isXOdd() && coords.getX() != getX()) {\n+            y--;\n+        } else if (!isXOdd() && coords.getX() != getX()) {", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzQwMDg3Ng==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603400876", "bodyText": "This is still applicable", "author": "Windchild292", "createdAt": "2021-03-29T15:38:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQ0MTQ2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQ0MTYxNQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593441615", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    } else if (object == null || getClass() != object.getClass()) {\n          \n          \n            \n                    } else if ((object == null) || (getClass() != object.getClass())) {", "author": "Windchild292", "createdAt": "2021-03-12T20:49:08Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconCoords.java", "diffHunk": "@@ -0,0 +1,53 @@\n+package mekhq.campaign.stratcon;\n+\n+import megamek.common.Coords;\n+import megamek.common.util.HashCodeUtil;\n+\n+public class StratconCoords extends Coords {\n+    private static final long serialVersionUID = 2660132431077309812L;\n+\n+    public StratconCoords(int x, int y) {\n+        super(x, y);\n+    }\n+    \n+    public StratconCoords() {\n+        super(0, 0);\n+    }\n+\n+    public StratconCoords translate(int direction) {\n+        Coords coords = translated(direction);\n+        int y = coords.getY();\n+        \n+        if(isXOdd() && coords.getX() != getX()) {\n+            y--;\n+        } else if (!isXOdd() && coords.getX() != getX()) {\n+            y++;\n+        }\n+        \n+        return new StratconCoords(coords.getX(), y);\n+    }\n+    \n+    /**\n+     * Get the hash code for these coords.\n+     * \n+     * @return The <code>int</code> hash code for these coords.\n+     */\n+    @Override\n+    public int hashCode() {\n+        return (HashCodeUtil.hash1(getX() + 1337) ^ HashCodeUtil.hash1(getY() + 97331)) & 0x7FFFFFFF;\n+    }\n+    \n+    /**\n+     * Coords are equal if their x and y components are equal\n+     */\n+    @Override\n+    public boolean equals(Object object) {\n+        if (this == object) {\n+            return true;\n+        } else if (object == null || getClass() != object.getClass()) {", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQ0MTc2MQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593441761", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return other.getX() == this.getX() && other.getY() == this.getY();\n          \n          \n            \n                    return (other.getX() == this.getX()) && (other.getY() == this.getY());", "author": "Windchild292", "createdAt": "2021-03-12T20:49:22Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconCoords.java", "diffHunk": "@@ -0,0 +1,53 @@\n+package mekhq.campaign.stratcon;\n+\n+import megamek.common.Coords;\n+import megamek.common.util.HashCodeUtil;\n+\n+public class StratconCoords extends Coords {\n+    private static final long serialVersionUID = 2660132431077309812L;\n+\n+    public StratconCoords(int x, int y) {\n+        super(x, y);\n+    }\n+    \n+    public StratconCoords() {\n+        super(0, 0);\n+    }\n+\n+    public StratconCoords translate(int direction) {\n+        Coords coords = translated(direction);\n+        int y = coords.getY();\n+        \n+        if(isXOdd() && coords.getX() != getX()) {\n+            y--;\n+        } else if (!isXOdd() && coords.getX() != getX()) {\n+            y++;\n+        }\n+        \n+        return new StratconCoords(coords.getX(), y);\n+    }\n+    \n+    /**\n+     * Get the hash code for these coords.\n+     * \n+     * @return The <code>int</code> hash code for these coords.\n+     */\n+    @Override\n+    public int hashCode() {\n+        return (HashCodeUtil.hash1(getX() + 1337) ^ HashCodeUtil.hash1(getY() + 97331)) & 0x7FFFFFFF;\n+    }\n+    \n+    /**\n+     * Coords are equal if their x and y components are equal\n+     */\n+    @Override\n+    public boolean equals(Object object) {\n+        if (this == object) {\n+            return true;\n+        } else if (object == null || getClass() != object.getClass()) {\n+            return false;\n+        }\n+        StratconCoords other = (StratconCoords) object;\n+        return other.getX() == this.getX() && other.getY() == this.getY();", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQ0MTkzNA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593441934", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if(!inputFile.exists()) {\n          \n          \n            \n                    if (!inputFile.exists()) {", "author": "Windchild292", "createdAt": "2021-03-12T20:49:43Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconFacilityManifest.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.util.List;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBElement;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.transform.Source;\n+\n+import mekhq.MekHQ;\n+import mekhq.MekHqXmlUtil;\n+\n+/**\n+ * A manifest containing IDs and file names of stratcon facility definitions\n+ * @author NickAragua\n+ */\n+@XmlRootElement(name=\"facilityManifest\")\n+public class StratconFacilityManifest {\n+    @XmlElementWrapper(name=\"facilityFileNames\")\n+    @XmlElement(name=\"facilityFileName\")\n+    public List<String> facilityFileNames;\n+    \n+    /**\n+     * Attempt to deserialize an instance of a StratconFacilityManifest from the passed-in file path\n+     * @return Possibly an instance of a StratconFacilityManifest\n+     */\n+    public static StratconFacilityManifest Deserialize(String fileName) {\n+        StratconFacilityManifest resultingManifest = null;\n+        File inputFile = new File(fileName);\n+        if(!inputFile.exists()) {", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzQ0MjAwNA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593442004", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    } catch(Exception e) {\n          \n          \n            \n                    } catch (Exception e) {", "author": "Windchild292", "createdAt": "2021-03-12T20:49:50Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconFacilityManifest.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.util.List;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBElement;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.transform.Source;\n+\n+import mekhq.MekHQ;\n+import mekhq.MekHqXmlUtil;\n+\n+/**\n+ * A manifest containing IDs and file names of stratcon facility definitions\n+ * @author NickAragua\n+ */\n+@XmlRootElement(name=\"facilityManifest\")\n+public class StratconFacilityManifest {\n+    @XmlElementWrapper(name=\"facilityFileNames\")\n+    @XmlElement(name=\"facilityFileName\")\n+    public List<String> facilityFileNames;\n+    \n+    /**\n+     * Attempt to deserialize an instance of a StratconFacilityManifest from the passed-in file path\n+     * @return Possibly an instance of a StratconFacilityManifest\n+     */\n+    public static StratconFacilityManifest Deserialize(String fileName) {\n+        StratconFacilityManifest resultingManifest = null;\n+        File inputFile = new File(fileName);\n+        if(!inputFile.exists()) {\n+            MekHQ.getLogger().warning(String.format(\"Specified file %s does not exist\", fileName));\n+            return null;\n+        }\n+\n+        try {\n+            JAXBContext context = JAXBContext.newInstance(StratconFacilityManifest.class);\n+            Unmarshaller um = context.createUnmarshaller();\n+            try (FileInputStream fileStream = new FileInputStream(inputFile)) {\n+                Source inputSource = MekHqXmlUtil.createSafeXmlSource(fileStream);\n+                JAXBElement<StratconFacilityManifest> manifestElement = um.unmarshal(inputSource, StratconFacilityManifest.class);\n+                resultingManifest = manifestElement.getValue();\n+            }\n+        } catch(Exception e) {", "originalCommit": "9f9de190227f34a974a69540ab1cab048a50792a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "929e8519f926f5cc4181dacac4d6244e2d5f8854", "url": "https://github.com/MegaMek/mekhq/commit/929e8519f926f5cc4181dacac4d6244e2d5f8854", "message": "minefield serialization; cosmetic updates", "committedDate": "2021-03-13T04:50:27Z", "type": "commit"}, {"oid": "8cd257a4c37b1712967b0864ca478dc8ffebc3de", "url": "https://github.com/MegaMek/mekhq/commit/8cd257a4c37b1712967b0864ca478dc8ffebc3de", "message": "legacy AtB scenario definition formatting", "committedDate": "2021-03-13T04:56:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5MzgwMjg4OA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r593802888", "bodyText": "Switch and { on separate lines", "author": "Windchild292", "createdAt": "2021-03-13T21:22:09Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconScenarioFactory.java", "diffHunk": "@@ -165,7 +164,7 @@ public static ScenarioTemplate getFacilityScenario(boolean allied) {\n      * @return Generic unit type.\n      */\n     private static int convertSpecificUnitTypeToGeneral(int unitType) {\n-        switch(unitType)\n+        switch (unitType)\n         {", "originalCommit": "929e8519f926f5cc4181dacac4d6244e2d5f8854", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a5382b0386cb0354a4b3c870fdd8fee5e2f5330a", "url": "https://github.com/MegaMek/mekhq/commit/a5382b0386cb0354a4b3c870fdd8fee5e2f5330a", "message": "additional code review changes", "committedDate": "2021-03-14T03:22:50Z", "type": "commit"}, {"oid": "69a98c0630d106a3f06e2fcf840512be9ce8ab68", "url": "https://github.com/MegaMek/mekhq/commit/69a98c0630d106a3f06e2fcf840512be9ce8ab68", "message": "static constructor replacement", "committedDate": "2021-03-14T03:34:05Z", "type": "commit"}, {"oid": "fe6e045bb8acb2700cc38bd6a25ec62011977264", "url": "https://github.com/MegaMek/mekhq/commit/fe6e045bb8acb2700cc38bd6a25ec62011977264", "message": "merge from upstream", "committedDate": "2021-03-14T06:21:48Z", "type": "commit"}, {"oid": "49aa475162d714386425b82aa730a0a6d742f5cf", "url": "https://github.com/MegaMek/mekhq/commit/49aa475162d714386425b82aa730a0a6d742f5cf", "message": "fix compilation errors", "committedDate": "2021-03-15T04:20:15Z", "type": "commit"}, {"oid": "3712585db4433d9b3580c4f6bc07d29386ab1019", "url": "https://github.com/MegaMek/mekhq/commit/3712585db4433d9b3580c4f6bc07d29386ab1019", "message": "path constants; filter on inactive units; refresh campaign state properly", "committedDate": "2021-03-17T04:55:53Z", "type": "commit"}, {"oid": "df692e17f0e1375982f2a0012ab384e9fc1dae63", "url": "https://github.com/MegaMek/mekhq/commit/df692e17f0e1375982f2a0012ab384e9fc1dae63", "message": "additional unit eligibility checks", "committedDate": "2021-03-17T05:10:47Z", "type": "commit"}, {"oid": "558d52310b465f1182371b233362fbf805f31f96", "url": "https://github.com/MegaMek/mekhq/commit/558d52310b465f1182371b233362fbf805f31f96", "message": "use util funciton instead of hand-rolled mess", "committedDate": "2021-03-17T05:13:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NjE1MTE4Mg==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r596151182", "bodyText": "Don't forget:\npublic int hashCode() {\n    return Objects.hash(this.contract, this.track);\n}", "author": "sixlettervariables", "createdAt": "2021-03-17T15:49:21Z", "path": "MekHQ/src/mekhq/gui/StratconTab.java", "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+\n+package mekhq.gui;\n+\n+import java.awt.GridBagConstraints;\n+import java.awt.GridBagLayout;\n+import java.awt.event.ItemEvent;\n+import java.awt.event.ItemListener;\n+\n+import javax.swing.JComboBox;\n+import javax.swing.JLabel;\n+import javax.swing.JPanel;\n+import javax.swing.JScrollPane;\n+\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.campaign.event.MissionCompletedEvent;\n+import mekhq.campaign.event.MissionRemovedEvent;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.stratcon.StratconCampaignState;\n+import mekhq.campaign.stratcon.StratconTrackState;\n+\n+public class StratconTab extends CampaignGuiTab {\n+    /**\n+     * \n+     */\n+    private static final long serialVersionUID = 8179754409939346465L;\n+    \n+    private StratconPanel stratconPanel;\n+    private JPanel infoPanel;\n+    private JComboBox<TrackDropdownItem> cboCurrentTrack;\n+    private JLabel infoPanelText;\n+    private JLabel campaignStatusText;\n+\n+    /**\n+     * Creates an instance of the StratconTab.\n+     */\n+    StratconTab(CampaignGUI gui, String tabName) {\n+        super(gui, tabName);\n+    }\n+\n+    /**\n+     * Override of the base initTab method. Populates the tab.\n+     */\n+    @Override\n+    public void initTab() { \n+        removeAll();\n+        \n+        infoPanelText = new JLabel();\n+        campaignStatusText = new JLabel();\n+        \n+        setLayout(new GridBagLayout());\n+        GridBagConstraints gbc = new GridBagConstraints();\n+        gbc.gridx = 0;\n+        gbc.gridy = 0;\n+        gbc.gridwidth = 4;\n+        gbc.fill = GridBagConstraints.BOTH;\n+        stratconPanel = new StratconPanel(getCampaignGui(), infoPanelText);\n+        JScrollPane scrollPane = new JScrollPane(stratconPanel);\n+        scrollPane.getHorizontalScrollBar().setUnitIncrement(StratconPanel.HEX_X_RADIUS);\n+        scrollPane.getVerticalScrollBar().setUnitIncrement(StratconPanel.HEX_Y_RADIUS);\n+        this.add(scrollPane, gbc);\n+        \n+        initializeInfoPanel();\n+        gbc.gridx = 4;\n+        gbc.gridwidth = 1;\n+        this.add(infoPanel, gbc);\n+        \n+        MekHQ.registerHandler(this);\n+    }\n+\n+    /**\n+     * Worker function that sets up the layout of the right-side info panel.\n+     */\n+    private void initializeInfoPanel() {\n+        infoPanel = new JPanel();        \n+        infoPanel.setLayout(new GridBagLayout()); \n+        GridBagConstraints gbc = new GridBagConstraints();\n+        gbc.gridx = 0;\n+        gbc.gridy = 0;\n+        gbc.gridwidth = 2;\n+        \n+        infoPanel.add(new JLabel(\"Current Campaign Status:\"), gbc);\n+        \n+        gbc.gridwidth = 1;\n+        gbc.gridy++;\n+        \n+        infoPanel.add(campaignStatusText, gbc);        \n+        gbc.gridy++;\n+        \n+        JLabel lblCurrentTrack = new JLabel(\"Current Track:\");\n+        infoPanel.add(lblCurrentTrack, gbc);\n+        gbc.gridx = 1;\n+        \n+        cboCurrentTrack = new JComboBox<>();\n+        repopulateTrackList();\n+        cboCurrentTrack.addItemListener(new ItemListener() {\n+            @Override\n+            public void itemStateChanged(ItemEvent e) {\n+            \ttrackSelectionHandler();\n+            }\n+        });\n+\n+        infoPanel.add(cboCurrentTrack, gbc);\n+        \n+        // have a default selected\n+        if(cboCurrentTrack.getItemCount() > 0) {\n+        \ttrackSelectionHandler();\n+        }\n+        \n+        gbc.gridy++;\n+        infoPanel.add(infoPanelText, gbc);\n+    }\n+    \n+    /**\n+     * Worker that handles track selection.\n+     */\n+    private void trackSelectionHandler() {\n+    \tTrackDropdownItem tdi = (TrackDropdownItem) cboCurrentTrack.getSelectedItem();\n+    \tif (tdi != null) {\n+\t        stratconPanel.selectTrack(tdi.contract.getStratconCampaignState(), tdi.track);\n+\t        updateCampaignState();\n+    \t}\n+    }\n+    \n+    @Override\n+    public void repaint() {\n+        updateCampaignState();\n+    }\n+    \n+    @Override\n+    public void refreshAll() {\n+        stratconPanel.repaint();\n+        updateCampaignState();\n+    }\n+\n+    @Override\n+    public GuiTabType tabType() {\n+        return GuiTabType.STRATCON;\n+    }\n+    \n+    /**\n+     * Worker function that updates the campaign state section of the info panel\n+     * with such info as current objective status, VP/SP totals, etc.\n+     */\n+    private void updateCampaignState() {\n+        if ((cboCurrentTrack == null) || (campaignStatusText == null)) {\n+            return;\n+        }\n+        \n+        // campaign state text should contain:\n+        // list of remaining objectives, percentage remaining\n+        // current VP\n+        // current support points\n+        TrackDropdownItem currentTDI = (TrackDropdownItem) cboCurrentTrack.getSelectedItem();\n+        if (currentTDI == null) {\n+            return;\n+        }\n+        AtBContract currentContract = currentTDI.contract;\n+        StratconCampaignState campaignState = currentContract.getStratconCampaignState();\n+        \n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"<html>\");\n+        \n+        sb.append(currentContract.getMissionTypeName()).append(\": \").append(currentContract.getName());\n+        sb.append(\"<br/>\");\n+        sb.append(campaignState.getBriefingText());\n+        \n+        // avoid confusing users by showing strategic objectives when there are none to show\n+        if (!campaignState.strategicObjectivesBehaveAsVPs()) {\n+            sb.append(\"<br/>Strategic Objectives: \").append(campaignState.getStrategicObjectiveCompletedCount())\n+                .append(\"/\").append(campaignState.getPendingStrategicObjectiveCount());\n+        }\n+        \n+        sb.append(\"<br/>Victory Points: \").append(campaignState.getVictoryPoints());\n+        \n+        sb.append(\"<br/>Support Points: \").append(campaignState.getSupportPoints());\n+        \n+        sb.append(\"<br/>Deployment Period: \").append(currentTDI.track.getDeploymentTime()).append(\" days\");\n+        \n+        sb.append(\"</html>\");\n+        \n+        campaignStatusText.setText(sb.toString());\n+    }\n+    \n+    /**\n+     * Refreshes the list of tracks\n+     */\n+    private void repopulateTrackList() {\n+        TrackDropdownItem currentTDI = (TrackDropdownItem) cboCurrentTrack.getSelectedItem();\n+        cboCurrentTrack.removeAllItems();\n+        \n+        // track dropdown is populated with all tracks across all active contracts\n+        for (Contract contract : getCampaignGui().getCampaign().getActiveContracts()) {\n+            if ((contract instanceof AtBContract) && \n+            \t\tcontract.isActiveOn(getCampaignGui().getCampaign().getLocalDate()) && \n+            \t\t(((AtBContract) contract).getStratconCampaignState() != null)) {\n+                for (StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    TrackDropdownItem tdi = new TrackDropdownItem((AtBContract) contract, track);\n+                    cboCurrentTrack.addItem(tdi);\n+                    \n+                    if ((currentTDI != null) && currentTDI.equals(tdi)) {\n+                        currentTDI = tdi;\n+                        cboCurrentTrack.setSelectedItem(tdi);\n+                    } else if (currentTDI == null) {\n+                        currentTDI = tdi;\n+                        cboCurrentTrack.setSelectedItem(tdi);\n+                    }\n+                }\n+            }\n+        }\n+        \n+        if ((cboCurrentTrack.getItemCount() > 0) && (currentTDI != null) && (currentTDI.contract != null)) {\n+            TrackDropdownItem selectedTrack = (TrackDropdownItem) cboCurrentTrack.getSelectedItem();\n+            \n+            stratconPanel.selectTrack(selectedTrack.contract.getStratconCampaignState(), currentTDI.track);\n+            stratconPanel.setVisible(true);\n+        } else {\n+            infoPanelText.setText(\"No active campaign tracks\");\n+            stratconPanel.setVisible(false);\n+        }\n+    }\n+    \n+    @Subscribe\n+    public void handleNewDay(NewDayEvent ev) {\n+        repopulateTrackList();\n+        updateCampaignState();\n+    }\n+    \n+    @Subscribe\n+    public void handle(MissionRemovedEvent ev) {\n+        repopulateTrackList();\n+        updateCampaignState();\n+    }\n+\n+    @Subscribe\n+    public void handle(MissionCompletedEvent ev) {\n+        repopulateTrackList();\n+        updateCampaignState();\n+    }\n+    \n+    /**\n+     * Data structure to hold necessary information about a track drop down item.\n+     * @author NickAragua\n+     *\n+     */\n+    private class TrackDropdownItem {\n+        AtBContract contract;\n+        StratconTrackState track;\n+        \n+        public TrackDropdownItem(AtBContract contract, StratconTrackState track) {\n+            this.contract = contract;\n+            this.track = track;\n+        }\n+        \n+        @Override\n+        public String toString() {\n+            return String.format(\"%s - %s\", contract.getName(), track.getDisplayableName());\n+        }\n+        \n+        @Override\n+        public boolean equals(Object other) {", "originalCommit": "558d52310b465f1182371b233362fbf805f31f96", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NjM4NTk4Mg==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r596385982", "bodyText": "What's the point? Neither the AtBContract nor the StratconTrackState implement hash. Do objects come with a meaningful default hash function?", "author": "NickAragua", "createdAt": "2021-03-17T21:12:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NjE1MTE4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NjM5MzE5OA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r596393198", "bodyText": "You must always override hashCode for any file that overrides equals, it's a Java contract.", "author": "Windchild292", "createdAt": "2021-03-17T21:24:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NjE1MTE4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NjQ0MDA3Ng==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r596440076", "bodyText": "The contract is specifically that if two objects return true for equals they must have the same hash code.", "author": "neoancient", "createdAt": "2021-03-17T23:01:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NjE1MTE4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NjE1NjQwNw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r596156407", "bodyText": "Suggested change", "author": "sixlettervariables", "createdAt": "2021-03-17T15:55:15Z", "path": "MekHQ/src/mekhq/campaign/Campaign.java", "diffHunk": "@@ -488,7 +491,7 @@ public void setFatigueLevel(int fl) {\n     public int getFatigueLevel() {\n         return fatigueLevel;\n     }\n-\n+    ", "originalCommit": "558d52310b465f1182371b233362fbf805f31f96", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NjE1NzEzMg==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r596157132", "bodyText": "How does this usage differ from the Rules Manager attached to MekHQ?", "author": "sixlettervariables", "createdAt": "2021-03-17T15:56:00Z", "path": "MekHQ/src/mekhq/campaign/Campaign.java", "diffHunk": "@@ -540,6 +543,19 @@ public AtBConfiguration getAtBConfig() {\n         return atbConfig;\n     }\n \n+    public boolean stratconRulesManagerInitialized() {\n+        return stratconRulesManager != null;\n+    }\n+    \n+    public void initStratcon() {\n+        stratconRulesManager = new StratconRulesManager();\n+        stratconRulesManager.startup();\n+    }\n+    \n+    public void shutdownStratcon() {\n+        stratconRulesManager.shutdown();\n+    }", "originalCommit": "558d52310b465f1182371b233362fbf805f31f96", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NjM4OTAzNQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r596389035", "bodyText": "Actually unused.", "author": "NickAragua", "createdAt": "2021-03-17T21:17:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NjE1NzEzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NjE1OTA5MA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r596159090", "bodyText": "Can we get a doc comment explaining what that means and when we should check this?", "author": "sixlettervariables", "createdAt": "2021-03-17T15:57:59Z", "path": "MekHQ/src/mekhq/campaign/mission/AtBDynamicScenario.java", "diffHunk": "@@ -231,14 +259,22 @@ public void setEffectiveOpforQuality(int qualityLevel) {\n         effectiveOpforQuality = qualityLevel;\n     }\n \n+    public boolean isFinalized() {\n+        return finalized;\n+    }", "originalCommit": "558d52310b465f1182371b233362fbf805f31f96", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NjE2MTIyOQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r596161229", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public ScenarioMapParameters clone() {\n          \n          \n            \n                @Override\n          \n          \n            \n                public ScenarioMapParameters clone() {", "author": "sixlettervariables", "createdAt": "2021-03-17T16:00:22Z", "path": "MekHQ/src/mekhq/campaign/mission/ScenarioMapParameters.java", "diffHunk": "@@ -9,16 +9,29 @@\n /**\n  * This class contains parameters useful for maps generated by atb-stratcon maps\n  * @author NickAragua\n- *\n  */\n-public class ScenarioMapParameters {\n+public class ScenarioMapParameters implements Cloneable {\n     public enum MapLocation {\n         AllGroundTerrain,\n         SpecificGroundTerrain,\n         Space,\n         LowAtmosphere\n     }\n     \n+    public ScenarioMapParameters clone() {", "originalCommit": "558d52310b465f1182371b233362fbf805f31f96", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NjE2NTIyMQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r596165221", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    super();", "author": "sixlettervariables", "createdAt": "2021-03-17T16:04:50Z", "path": "MekHQ/src/mekhq/gui/stratcon/ScenarioWizardLanceModel.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.gui.stratcon;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+\n+import javax.swing.DefaultListModel;\n+\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.force.Force;\n+\n+/**\n+ * List data model for the StratCon scenario wizard.\n+ * @author NickAragua\n+ */\n+public class ScenarioWizardLanceModel extends DefaultListModel<Force> {\n+    /**\n+     * Constructor - sometimes, you have a list of force IDs.\n+     */\n+    public ScenarioWizardLanceModel(Campaign campaign, Collection<Integer> forceIDs) {\n+        super();", "originalCommit": "558d52310b465f1182371b233362fbf805f31f96", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "aac2ced366aa376eb9fa78ab230f38e43d0c8362", "url": "https://github.com/MegaMek/mekhq/commit/aac2ced366aa376eb9fa78ab230f38e43d0c8362", "message": "code review changes", "committedDate": "2021-03-18T01:16:52Z", "type": "commit"}, {"oid": "8627de7d060ea44d3e33d04c259f8ab05f5bba9f", "url": "https://github.com/MegaMek/mekhq/commit/8627de7d060ea44d3e33d04c259f8ab05f5bba9f", "message": "merge from upstream", "committedDate": "2021-03-22T00:29:53Z", "type": "commit"}, {"oid": "093eaeb8fbe362bb2d525d661180c433576aab9b", "url": "https://github.com/MegaMek/mekhq/commit/093eaeb8fbe362bb2d525d661180c433576aab9b", "message": "merge from upstream", "committedDate": "2021-03-24T04:26:51Z", "type": "commit"}, {"oid": "cc3a1c6a190c69a7e22f15c883c1baeeb8bcf064", "url": "https://github.com/MegaMek/mekhq/commit/cc3a1c6a190c69a7e22f15c883c1baeeb8bcf064", "message": "implement failed reinforcement attempts; fix scenario template retrieval bug caused by code review changes", "committedDate": "2021-03-24T05:17:08Z", "type": "commit"}, {"oid": "5b5aeb8f51a762fb1b75a0e07a1d593dc52377c8", "url": "https://github.com/MegaMek/mekhq/commit/5b5aeb8f51a762fb1b75a0e07a1d593dc52377c8", "message": "UI cleanup; 'sticky' forces", "committedDate": "2021-03-25T01:49:37Z", "type": "commit"}, {"oid": "84c3b0bef4f8802121e4950282e4bccd9fd14c7e", "url": "https://github.com/MegaMek/mekhq/commit/84c3b0bef4f8802121e4950282e4bccd9fd14c7e", "message": "ui adjustments to reduce jumping", "committedDate": "2021-03-25T02:10:38Z", "type": "commit"}, {"oid": "26e5b597f03dfd53f2fa4f37047cbde3e2df0db1", "url": "https://github.com/MegaMek/mekhq/commit/26e5b597f03dfd53f2fa4f37047cbde3e2df0db1", "message": "fix compilation warnings", "committedDate": "2021-03-25T02:45:54Z", "type": "commit"}, {"oid": "1343c8b7330406c33ae8005e31cb712921f243c2", "url": "https://github.com/MegaMek/mekhq/commit/1343c8b7330406c33ae8005e31cb712921f243c2", "message": "leadership force deployment rules/UI", "committedDate": "2021-03-25T16:50:56Z", "type": "commit"}, {"oid": "e5b1d3a3fc6d825d722e496ad49832555fa65754", "url": "https://github.com/MegaMek/mekhq/commit/e5b1d3a3fc6d825d722e496ad49832555fa65754", "message": "units deployed to StratCon tracks are ineligible for repairs", "committedDate": "2021-03-25T18:08:49Z", "type": "commit"}, {"oid": "41be2e48e7c5cb4158ab4ab347a3ec87f04577b3", "url": "https://github.com/MegaMek/mekhq/commit/41be2e48e7c5cb4158ab4ab347a3ec87f04577b3", "message": "force type data fixes", "committedDate": "2021-03-26T03:36:29Z", "type": "commit"}, {"oid": "796b6728fd3cd2aea02d17122b4d735afc47dc41", "url": "https://github.com/MegaMek/mekhq/commit/796b6728fd3cd2aea02d17122b4d735afc47dc41", "message": "scenario generation for deployed forces; bomb type fixes/expansion; scenario modifier fixes", "committedDate": "2021-03-26T03:37:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjkwMDY1Nw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r602900657", "bodyText": "These should be private, and Campaign is likely final", "author": "Windchild292", "createdAt": "2021-03-28T16:34:50Z", "path": "MekHQ/src/mekhq/gui/stratcon/StratconScenarioWizard.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.gui.stratcon;\n+\n+import java.awt.Color;\n+import java.awt.GridBagConstraints;\n+import java.awt.GridBagLayout;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ResourceBundle;\n+import java.util.UUID;\n+\n+import javax.swing.DefaultListModel;\n+import javax.swing.JButton;\n+import javax.swing.JDialog;\n+import javax.swing.JLabel;\n+import javax.swing.JList;\n+import javax.swing.JPanel;\n+import javax.swing.JScrollPane;\n+import javax.swing.event.ListSelectionEvent;\n+import javax.swing.event.ListSelectionListener;\n+\n+import megamek.common.Minefield;\n+import mekhq.campaign.stratcon.StratconScenario;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.stratcon.StratconTrackState;\n+import mekhq.campaign.unit.Unit;\n+import mekhq.MekHQ;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.event.DeploymentChangedEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.personnel.Person;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconCampaignState;\n+import mekhq.campaign.stratcon.StratconRulesManager;\n+import mekhq.campaign.stratcon.StratconRulesManager.ReinforcementEligibilityType;\n+\n+/**\n+ * UI for managing force/unit assignments for individual StratCon scenarios.\n+ */\n+public class StratconScenarioWizard extends JDialog {\n+    private static final long serialVersionUID = 4447095364826529579L;\n+    \n+    StratconScenario currentScenario;\n+    Campaign campaign;\n+    StratconTrackState currentTrackState;\n+    StratconCampaignState currentCampaignState;\n+    ResourceBundle resourceMap = ResourceBundle.getBundle(\"mekhq.resources.AtBStratCon\");\n+\n+    JLabel lblTotalBV = new JLabel();\n+    \n+    Map<String, JList<Force>> availableForceLists = new HashMap<>();\n+    Map<String, JList<Unit>> availableUnitLists = new HashMap<>();\n+    \n+    JList<Unit> availableInfantryUnits = new JList<>();\n+    JList<Unit> availableLeadershipUnits = new JList<>();\n+    JLabel defensiveOptionStatus = new JLabel();\n+    \n+    JButton btnCommit;", "originalCommit": "796b6728fd3cd2aea02d17122b4d735afc47dc41", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjkwMDgzOQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r602900839", "bodyText": "This would be easier to read when combined", "author": "Windchild292", "createdAt": "2021-03-28T16:36:17Z", "path": "MekHQ/src/mekhq/gui/stratcon/StratconScenarioWizard.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.gui.stratcon;\n+\n+import java.awt.Color;\n+import java.awt.GridBagConstraints;\n+import java.awt.GridBagLayout;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ResourceBundle;\n+import java.util.UUID;\n+\n+import javax.swing.DefaultListModel;\n+import javax.swing.JButton;\n+import javax.swing.JDialog;\n+import javax.swing.JLabel;\n+import javax.swing.JList;\n+import javax.swing.JPanel;\n+import javax.swing.JScrollPane;\n+import javax.swing.event.ListSelectionEvent;\n+import javax.swing.event.ListSelectionListener;\n+\n+import megamek.common.Minefield;\n+import mekhq.campaign.stratcon.StratconScenario;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.stratcon.StratconTrackState;\n+import mekhq.campaign.unit.Unit;\n+import mekhq.MekHQ;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.event.DeploymentChangedEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.personnel.Person;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconCampaignState;\n+import mekhq.campaign.stratcon.StratconRulesManager;\n+import mekhq.campaign.stratcon.StratconRulesManager.ReinforcementEligibilityType;\n+\n+/**\n+ * UI for managing force/unit assignments for individual StratCon scenarios.\n+ */\n+public class StratconScenarioWizard extends JDialog {\n+    private static final long serialVersionUID = 4447095364826529579L;\n+    \n+    StratconScenario currentScenario;\n+    Campaign campaign;\n+    StratconTrackState currentTrackState;\n+    StratconCampaignState currentCampaignState;\n+    ResourceBundle resourceMap = ResourceBundle.getBundle(\"mekhq.resources.AtBStratCon\");\n+\n+    JLabel lblTotalBV = new JLabel();\n+    \n+    Map<String, JList<Force>> availableForceLists = new HashMap<>();\n+    Map<String, JList<Unit>> availableUnitLists = new HashMap<>();\n+    \n+    JList<Unit> availableInfantryUnits = new JList<>();\n+    JList<Unit> availableLeadershipUnits = new JList<>();\n+    JLabel defensiveOptionStatus = new JLabel();\n+    \n+    JButton btnCommit;\n+    \n+    public StratconScenarioWizard(Campaign campaign) {\n+        this.campaign = campaign;\n+        this.setModalityType(ModalityType.APPLICATION_MODAL);\n+    }\n+\n+    /**\n+     * Selects a scenario on a particular track in a particular campaign.\n+     */\n+    public void setCurrentScenario(StratconScenario scenario, StratconTrackState trackState, StratconCampaignState campaignState) {\n+        currentScenario = scenario;\n+        currentCampaignState = campaignState;\n+        currentTrackState = trackState;\n+        availableForceLists.clear();\n+        availableUnitLists.clear();\n+        \n+        setUI();\n+    }\n+\n+    /**\n+     * Sets up the UI as appropriate for the currently selected scenario.\n+     */\n+    private void setUI() {\n+        setTitle(\"Scenario Setup Wizard\");\n+        getContentPane().removeAll();\n+\n+        GridBagConstraints gbc = new GridBagConstraints();\n+        getContentPane().setLayout(new GridBagLayout());\n+\n+        gbc.gridx = 0;\n+        gbc.gridy = 0;\n+        setInstructions(gbc);\n+        \n+        switch (currentScenario.getCurrentState()) {        \n+            case UNRESOLVED:\n+                gbc.gridy++;\n+                setAssignForcesUI(gbc, false);\n+                break;\n+            default:\n+                gbc.gridy++;\n+                setAssignForcesUI(gbc, true);\n+                gbc.gridy++;\n+                \n+                List<Unit> eligibleLeadershipUnits = \n+                        StratconRulesManager.getEligibleLeadershipUnits(campaign, \n+                        currentScenario.getPrimaryForceIDs());\n+                int leadershipSkill = \n+                        currentScenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_LEADER, campaign);\n+                \n+                if ((eligibleLeadershipUnits.size() > 0) && (leadershipSkill > 0)) {                \n+                    setLeadershipUI(gbc, eligibleLeadershipUnits, leadershipSkill);\n+                    gbc.gridy++;\n+                }\n+                \n+                if (currentScenario.getNumDefensivePoints() > 0) {\n+                    setDefensiveUI(gbc);\n+                    gbc.gridy++;\n+                }\n+                break;\n+        }\n+\n+        gbc.gridx = 0;\n+        gbc.gridy++;\n+        setNavigationButtons(gbc);\n+        pack();\n+        validate();\n+    }\n+    \n+    /**\n+     * Worker function that sets up the instructions for the currently selected scenario.\n+     */\n+    private void setInstructions(GridBagConstraints gbc) {\n+        JLabel lblInfo = new JLabel();\n+        StringBuilder labelBuilder = new StringBuilder();\n+        labelBuilder.append(\"<html>\");\n+        \n+        if (currentTrackState.isGmRevealed() || currentTrackState.getRevealedCoords().contains(currentScenario.getCoords()) ||\n+                (currentScenario.getDeploymentDate() != null)) {\n+            labelBuilder.append(currentScenario.getInfo());\n+        }\n+        \n+        switch (currentScenario.getCurrentState()) {\n+            case UNRESOLVED:\n+                labelBuilder.append(\"primaryForceAssignmentInstructions.text\");\n+                break;\n+            default:\n+                labelBuilder.append(\"reinforcementsAndSupportInstructions.text\");\n+                break;\n+        }\n+        \n+        labelBuilder.append(\"<br/>\");\n+        lblInfo.setText(labelBuilder.toString());\n+        getContentPane().add(lblInfo, gbc);\n+    }\n+    \n+    /**\n+     * Worker function that sets up the \"assign forces to scenario\" UI elements.\n+     */\n+    private void setAssignForcesUI(GridBagConstraints gbc, boolean reinforcements) {\n+        // generate a lance selector with the following parameters:\n+        // all forces assigned to the current track that aren't already assigned elsewhere\n+        // max number of items that can be selected = current scenario required lances\n+        \n+        List<ScenarioForceTemplate> eligibleForceTemplates = reinforcements ?\n+                currentScenario.getScenarioTemplate().getAllPlayerReinforcementForces() :\n+                    currentScenario.getScenarioTemplate().getAllPrimaryPlayerForces();\n+        \n+        for (ScenarioForceTemplate forceTemplate : eligibleForceTemplates) {\n+            JPanel forcePanel = new JPanel();\n+            forcePanel.setLayout(new GridBagLayout());\n+            GridBagConstraints localGbc = new GridBagConstraints();\n+            localGbc.gridx = 0;\n+            localGbc.gridy = 0;\n+            \n+            String labelText = reinforcements ?\n+                    resourceMap.getString(\"selectReinforcementsForTemplate.Text\") :\n+                    String.format(resourceMap.getString(\"selectForceForTemplate.Text\"), currentScenario.getRequiredPlayerLances());\n+            \n+            JLabel assignForceListInstructions = new JLabel(labelText);\n+            forcePanel.add(assignForceListInstructions, localGbc);\n+            \n+            localGbc.gridy = 1;\n+            JLabel selectedForceInfo = new JLabel();\n+            JList<Force> availableForceList = addAvailableForceList(forcePanel, localGbc, forceTemplate);\n+            \n+            availableForceList.addListSelectionListener(new ListSelectionListener() { \n+                @Override\n+                public void valueChanged(ListSelectionEvent e) {\n+                    availableForceSelectorChanged(e, selectedForceInfo, reinforcements);\n+                }\n+            });\n+            \n+            availableForceLists.put(forceTemplate.getForceName(), availableForceList);\n+            \n+            localGbc.gridx = 1;\n+            forcePanel.add(selectedForceInfo, localGbc);\n+            \n+            getContentPane().add(forcePanel, gbc);\n+            gbc.gridy++;\n+        }\n+    }\n+\n+    /**\n+     * Set up the UI for \"defensive elements\", such as infantry, gun emplacements, minefields, etc.\n+     */\n+    private void setDefensiveUI(GridBagConstraints gbc) {\n+        gbc.anchor = GridBagConstraints.WEST;\n+        JLabel lblDefensivePostureInstructions = new JLabel(resourceMap.getString(\"lblDefensivePostureInstructions.Text\"));\n+        getContentPane().add(lblDefensivePostureInstructions, gbc);\n+        \n+        gbc.gridy++;\n+        availableInfantryUnits =\n+                addIndividualUnitSelector(StratconRulesManager.getEligibleDefensiveUnits(campaign), \n+                        gbc, currentScenario.getNumDefensivePoints());\n+        \n+        \n+        \n+        gbc.gridy++;\n+        gbc.anchor = GridBagConstraints.WEST;\n+        \n+        JLabel lblDefensiveMinefieldCount = new JLabel(String.format(resourceMap.getString(\"lblDefensiveMinefieldCount.text\"), \n+                currentScenario.getNumDefensivePoints()));\n+        \n+        availableInfantryUnits.addListSelectionListener(new ListSelectionListener() { \n+            @Override\n+            public void valueChanged(ListSelectionEvent e) {\n+                availableInfantrySelectorChanged(lblDefensiveMinefieldCount);\n+            }\n+        });\n+        \n+        getContentPane().add(lblDefensiveMinefieldCount, gbc);\n+    }\n+    \n+    private void setLeadershipUI(GridBagConstraints gbc, List<Unit> eligibleUnits, int leadershipSkill) {\n+        gbc.anchor = GridBagConstraints.WEST;\n+        JLabel lblLeadershipInstructions = new JLabel(resourceMap.getString(\"lblLeadershipInstructions.Text\"));\n+        getContentPane().add(lblLeadershipInstructions, gbc);\n+        \n+        gbc.gridy++;\n+        availableLeadershipUnits =\n+                addIndividualUnitSelector(\n+                        eligibleUnits, gbc, leadershipSkill);", "originalCommit": "796b6728fd3cd2aea02d17122b4d735afc47dc41", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjkwMDkwNQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r602900905", "bodyText": "?", "author": "Windchild292", "createdAt": "2021-03-28T16:36:53Z", "path": "MekHQ/src/mekhq/gui/stratcon/StratconScenarioWizard.java", "diffHunk": "@@ -0,0 +1,607 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.gui.stratcon;\n+\n+import java.awt.Color;\n+import java.awt.GridBagConstraints;\n+import java.awt.GridBagLayout;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ResourceBundle;\n+import java.util.UUID;\n+\n+import javax.swing.DefaultListModel;\n+import javax.swing.JButton;\n+import javax.swing.JDialog;\n+import javax.swing.JLabel;\n+import javax.swing.JList;\n+import javax.swing.JPanel;\n+import javax.swing.JScrollPane;\n+import javax.swing.event.ListSelectionEvent;\n+import javax.swing.event.ListSelectionListener;\n+\n+import megamek.common.Minefield;\n+import mekhq.campaign.stratcon.StratconScenario;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.stratcon.StratconTrackState;\n+import mekhq.campaign.unit.Unit;\n+import mekhq.MekHQ;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.event.DeploymentChangedEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.personnel.Person;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconCampaignState;\n+import mekhq.campaign.stratcon.StratconRulesManager;\n+import mekhq.campaign.stratcon.StratconRulesManager.ReinforcementEligibilityType;\n+\n+/**\n+ * UI for managing force/unit assignments for individual StratCon scenarios.\n+ */\n+public class StratconScenarioWizard extends JDialog {\n+    private static final long serialVersionUID = 4447095364826529579L;\n+    \n+    StratconScenario currentScenario;\n+    Campaign campaign;\n+    StratconTrackState currentTrackState;\n+    StratconCampaignState currentCampaignState;\n+    ResourceBundle resourceMap = ResourceBundle.getBundle(\"mekhq.resources.AtBStratCon\");\n+\n+    JLabel lblTotalBV = new JLabel();\n+    \n+    Map<String, JList<Force>> availableForceLists = new HashMap<>();\n+    Map<String, JList<Unit>> availableUnitLists = new HashMap<>();\n+    \n+    JList<Unit> availableInfantryUnits = new JList<>();\n+    JList<Unit> availableLeadershipUnits = new JList<>();\n+    JLabel defensiveOptionStatus = new JLabel();\n+    \n+    JButton btnCommit;\n+    \n+    public StratconScenarioWizard(Campaign campaign) {\n+        this.campaign = campaign;\n+        this.setModalityType(ModalityType.APPLICATION_MODAL);\n+    }\n+\n+    /**\n+     * Selects a scenario on a particular track in a particular campaign.\n+     */\n+    public void setCurrentScenario(StratconScenario scenario, StratconTrackState trackState, StratconCampaignState campaignState) {\n+        currentScenario = scenario;\n+        currentCampaignState = campaignState;\n+        currentTrackState = trackState;\n+        availableForceLists.clear();\n+        availableUnitLists.clear();\n+        \n+        setUI();\n+    }\n+\n+    /**\n+     * Sets up the UI as appropriate for the currently selected scenario.\n+     */\n+    private void setUI() {\n+        setTitle(\"Scenario Setup Wizard\");\n+        getContentPane().removeAll();\n+\n+        GridBagConstraints gbc = new GridBagConstraints();\n+        getContentPane().setLayout(new GridBagLayout());\n+\n+        gbc.gridx = 0;\n+        gbc.gridy = 0;\n+        setInstructions(gbc);\n+        \n+        switch (currentScenario.getCurrentState()) {        \n+            case UNRESOLVED:\n+                gbc.gridy++;\n+                setAssignForcesUI(gbc, false);\n+                break;\n+            default:\n+                gbc.gridy++;\n+                setAssignForcesUI(gbc, true);\n+                gbc.gridy++;\n+                \n+                List<Unit> eligibleLeadershipUnits = \n+                        StratconRulesManager.getEligibleLeadershipUnits(campaign, \n+                        currentScenario.getPrimaryForceIDs());\n+                int leadershipSkill = \n+                        currentScenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_LEADER, campaign);\n+                \n+                if ((eligibleLeadershipUnits.size() > 0) && (leadershipSkill > 0)) {                \n+                    setLeadershipUI(gbc, eligibleLeadershipUnits, leadershipSkill);\n+                    gbc.gridy++;\n+                }\n+                \n+                if (currentScenario.getNumDefensivePoints() > 0) {\n+                    setDefensiveUI(gbc);\n+                    gbc.gridy++;\n+                }\n+                break;\n+        }\n+\n+        gbc.gridx = 0;\n+        gbc.gridy++;\n+        setNavigationButtons(gbc);\n+        pack();\n+        validate();\n+    }\n+    \n+    /**\n+     * Worker function that sets up the instructions for the currently selected scenario.\n+     */\n+    private void setInstructions(GridBagConstraints gbc) {\n+        JLabel lblInfo = new JLabel();\n+        StringBuilder labelBuilder = new StringBuilder();\n+        labelBuilder.append(\"<html>\");\n+        \n+        if (currentTrackState.isGmRevealed() || currentTrackState.getRevealedCoords().contains(currentScenario.getCoords()) ||\n+                (currentScenario.getDeploymentDate() != null)) {\n+            labelBuilder.append(currentScenario.getInfo());\n+        }\n+        \n+        switch (currentScenario.getCurrentState()) {\n+            case UNRESOLVED:\n+                labelBuilder.append(\"primaryForceAssignmentInstructions.text\");\n+                break;\n+            default:\n+                labelBuilder.append(\"reinforcementsAndSupportInstructions.text\");\n+                break;\n+        }\n+        \n+        labelBuilder.append(\"<br/>\");\n+        lblInfo.setText(labelBuilder.toString());\n+        getContentPane().add(lblInfo, gbc);\n+    }\n+    \n+    /**\n+     * Worker function that sets up the \"assign forces to scenario\" UI elements.\n+     */\n+    private void setAssignForcesUI(GridBagConstraints gbc, boolean reinforcements) {\n+        // generate a lance selector with the following parameters:\n+        // all forces assigned to the current track that aren't already assigned elsewhere\n+        // max number of items that can be selected = current scenario required lances\n+        \n+        List<ScenarioForceTemplate> eligibleForceTemplates = reinforcements ?\n+                currentScenario.getScenarioTemplate().getAllPlayerReinforcementForces() :\n+                    currentScenario.getScenarioTemplate().getAllPrimaryPlayerForces();\n+        \n+        for (ScenarioForceTemplate forceTemplate : eligibleForceTemplates) {\n+            JPanel forcePanel = new JPanel();\n+            forcePanel.setLayout(new GridBagLayout());\n+            GridBagConstraints localGbc = new GridBagConstraints();\n+            localGbc.gridx = 0;\n+            localGbc.gridy = 0;\n+            \n+            String labelText = reinforcements ?\n+                    resourceMap.getString(\"selectReinforcementsForTemplate.Text\") :\n+                    String.format(resourceMap.getString(\"selectForceForTemplate.Text\"), currentScenario.getRequiredPlayerLances());\n+            \n+            JLabel assignForceListInstructions = new JLabel(labelText);\n+            forcePanel.add(assignForceListInstructions, localGbc);\n+            \n+            localGbc.gridy = 1;\n+            JLabel selectedForceInfo = new JLabel();\n+            JList<Force> availableForceList = addAvailableForceList(forcePanel, localGbc, forceTemplate);\n+            \n+            availableForceList.addListSelectionListener(new ListSelectionListener() { \n+                @Override\n+                public void valueChanged(ListSelectionEvent e) {\n+                    availableForceSelectorChanged(e, selectedForceInfo, reinforcements);\n+                }\n+            });\n+            \n+            availableForceLists.put(forceTemplate.getForceName(), availableForceList);\n+            \n+            localGbc.gridx = 1;\n+            forcePanel.add(selectedForceInfo, localGbc);\n+            \n+            getContentPane().add(forcePanel, gbc);\n+            gbc.gridy++;\n+        }\n+    }\n+\n+    /**\n+     * Set up the UI for \"defensive elements\", such as infantry, gun emplacements, minefields, etc.\n+     */\n+    private void setDefensiveUI(GridBagConstraints gbc) {\n+        gbc.anchor = GridBagConstraints.WEST;\n+        JLabel lblDefensivePostureInstructions = new JLabel(resourceMap.getString(\"lblDefensivePostureInstructions.Text\"));\n+        getContentPane().add(lblDefensivePostureInstructions, gbc);\n+        \n+        gbc.gridy++;\n+        availableInfantryUnits =\n+                addIndividualUnitSelector(StratconRulesManager.getEligibleDefensiveUnits(campaign), \n+                        gbc, currentScenario.getNumDefensivePoints());\n+        \n+        \n+        \n+        gbc.gridy++;\n+        gbc.anchor = GridBagConstraints.WEST;\n+        \n+        JLabel lblDefensiveMinefieldCount = new JLabel(String.format(resourceMap.getString(\"lblDefensiveMinefieldCount.text\"), \n+                currentScenario.getNumDefensivePoints()));\n+        \n+        availableInfantryUnits.addListSelectionListener(new ListSelectionListener() { \n+            @Override\n+            public void valueChanged(ListSelectionEvent e) {\n+                availableInfantrySelectorChanged(lblDefensiveMinefieldCount);\n+            }\n+        });\n+        \n+        getContentPane().add(lblDefensiveMinefieldCount, gbc);\n+    }\n+    \n+    private void setLeadershipUI(GridBagConstraints gbc, List<Unit> eligibleUnits, int leadershipSkill) {\n+        gbc.anchor = GridBagConstraints.WEST;\n+        JLabel lblLeadershipInstructions = new JLabel(resourceMap.getString(\"lblLeadershipInstructions.Text\"));\n+        getContentPane().add(lblLeadershipInstructions, gbc);\n+        \n+        gbc.gridy++;\n+        availableLeadershipUnits =\n+                addIndividualUnitSelector(\n+                        eligibleUnits, gbc, leadershipSkill);\n+    }\n+    \n+    /**\n+     * Add an \"available force list\" to the given control\n+     */\n+    private JList<Force> addAvailableForceList(JPanel parent, GridBagConstraints gbc, ScenarioForceTemplate forceTemplate) {\n+        JScrollPane forceListContainer = new JScrollPane();\n+\n+        ScenarioWizardLanceModel lanceModel;\n+        \n+        lanceModel = new ScenarioWizardLanceModel(campaign, \n+                StratconRulesManager.getAvailableForceIDs(forceTemplate.getAllowedUnitType(), \n+                        campaign, currentTrackState,\n+                        (forceTemplate.getArrivalTurn() == ScenarioForceTemplate.ARRIVAL_TURN_AS_REINFORCEMENTS),\n+                        currentScenario));\n+        \n+        JList<Force> availableForceList = new JList<>();\n+        availableForceList.setModel(lanceModel);\n+        availableForceList.setCellRenderer(new ScenarioWizardLanceRenderer(campaign));\n+        \n+        forceListContainer.setViewportView(availableForceList);\n+\n+        parent.add(forceListContainer, gbc);\n+        return availableForceList;\n+    }\n+\n+    /**\n+     * Adds an individual unit selector, given a list of individual units, a global grid bag constraint set\n+     * and a maximum selection size.\n+     * @param units The list of units to use as data source.\n+     * @param gbc Gridbag constraints to indicate where the control will go\n+     * @param maxSelectionSize Maximum number of units that can be selected\n+     */\n+    private JList<Unit> addIndividualUnitSelector(List<Unit> units, GridBagConstraints gbc, int maxSelectionSize) {\n+        JPanel unitPanel = new JPanel();\n+        unitPanel.setLayout(new GridBagLayout());\n+        GridBagConstraints localGbc = new GridBagConstraints();\n+        \n+        localGbc.gridx = 0;\n+        localGbc.gridy = 0;\n+        localGbc.anchor = GridBagConstraints.WEST;\n+        JLabel instructions = new JLabel();\n+        instructions.setText(String.format(resourceMap.getString(\"lblSelectIndividualUnits.text\"), maxSelectionSize));\n+        unitPanel.add(instructions);\n+        \n+        localGbc.gridy++;        \n+        DefaultListModel<Unit> availableModel = new DefaultListModel<>();\n+        for (Unit u : units) {\n+            availableModel.addElement(u);\n+        }\n+        \n+        JLabel unitStatusLabel = new JLabel();\n+        \n+        // add the # units selected control\n+        JLabel unitSelectionLabel = new JLabel();\n+        unitSelectionLabel.setText(\"0 selected\");\n+        \n+        localGbc.gridy++;\n+        unitPanel.add(unitSelectionLabel, localGbc);\n+        \n+        JList<Unit> availableUnits = new JList<>();\n+        availableUnits.setModel(availableModel);\n+        availableUnits.setCellRenderer(new ScenarioWizardUnitRenderer());\n+        availableUnits.addListSelectionListener(new ListSelectionListener() { \n+            @Override\n+            public void valueChanged(ListSelectionEvent e) {\n+                availableUnitSelectorChanged(e, unitSelectionLabel, unitStatusLabel, maxSelectionSize);\n+            }\n+        });\n+        \n+        JScrollPane infantryContainer = new JScrollPane();\n+        infantryContainer.setViewportView(availableUnits);\n+        localGbc.gridy++;\n+        unitPanel.add(infantryContainer, localGbc);\n+        \n+        // add the 'status display' control\n+        localGbc.gridx++;\n+        localGbc.anchor = GridBagConstraints.NORTHWEST;\n+        unitPanel.add(unitStatusLabel, localGbc);\n+        \n+        getContentPane().add(unitPanel, gbc);\n+        \n+        return availableUnits;\n+    }\n+    \n+    /**\n+     * Worker function that builds an \"html-enabled\" string indicating the brief status of a force\n+     */\n+    private String buildForceStatus(Force f, boolean showForceCost) {\n+        StringBuilder sb = new StringBuilder();\n+        \n+        sb.append(f.getFullName());\n+        sb.append(\": \");\n+        if (showForceCost) {\n+            sb.append(buildForceCost(f.getId()));\n+        }\n+        sb.append(\"<br/>\");\n+        \n+        for (UUID unitID : f.getUnits()) {\n+            Unit u = campaign.getUnit(unitID);\n+            sb.append(buildUnitStatus(u));\n+        }\n+        \n+        return sb.toString();\n+    }\n+    \n+    /**\n+     * Worker function that builds an \"html-enabled\" string indicating the brief status of an individual unit\n+     */\n+    private String buildUnitStatus(Unit u) {\n+        StringBuilder sb = new StringBuilder();\n+        \n+        sb.append(u.getName());\n+        sb.append(\": \");\n+        sb.append(u.getStatus());\n+        \n+        int injuryCount = 0;\n+        \n+        for (Person p : u.getCrew()) {\n+            if(p.hasInjuries(true)) {\n+                injuryCount++;\n+            }\n+        }\n+        \n+        if (injuryCount > 0) {\n+            sb.append(String.format(\", <span color='red'>%d/%d injured crew</span>\", injuryCount, u.getCrew().size()));\n+        }\n+        \n+        sb.append(\"<br/>\");\n+        return sb.toString();\n+    }\n+    \n+    /**\n+     * Worker function that builds an indicator of what it will take to deploy a particular force\n+     * to the current scenario as reinforcements.\n+     */\n+    private String buildForceCost(int forceID) {\n+        StringBuilder costBuilder = new StringBuilder();\n+        costBuilder.append(\"(\");\n+        \n+        switch(StratconRulesManager.getReinforcementType(forceID, currentTrackState, campaign)) {\n+        case SupportPoint:\n+            costBuilder.append(resourceMap.getString(\"supportPoint.text\"));\n+            if (currentCampaignState.getSupportPoints() <= 0) {\n+                costBuilder.append(\", \");\n+                if (currentCampaignState.getVictoryPoints() <= 1) {\n+                    costBuilder.append(\"<span color='red'>\");\n+                }\n+                \n+                costBuilder.append(resourceMap.getString(\"supportPointConvert.text\"));\n+                \n+                if (currentCampaignState.getVictoryPoints() <= 1) {\n+                    costBuilder.append(\"</span>\");\n+                }\n+            }\n+            break;\n+        case ChainedScenario:\n+            costBuilder.append(resourceMap.getString(\"fromChainedScenario.text\"));\n+            break;\n+        case FightLance:\n+            costBuilder.append(\"lanceInFightRole.text\");\n+            break;\n+        default:\n+            costBuilder.append(\"yikes\");", "originalCommit": "796b6728fd3cd2aea02d17122b4d735afc47dc41", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjkwMTMwNA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r602901304", "bodyText": "Remove, useless", "author": "Windchild292", "createdAt": "2021-03-28T16:39:55Z", "path": "MekHQ/src/mekhq/gui/StratconPanel.java", "diffHunk": "@@ -0,0 +1,672 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.gui;\n+\n+import java.awt.BasicStroke;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Point;\n+import java.awt.Polygon;\n+import java.awt.Stroke;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.awt.geom.AffineTransform;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import javax.swing.JCheckBoxMenuItem;\n+import javax.swing.JLabel;\n+import javax.swing.JMenuItem;\n+import javax.swing.JPanel;\n+import javax.swing.JPopupMenu;\n+import javax.swing.SwingUtilities;\n+\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.stratcon.StratconCampaignState;\n+import mekhq.campaign.stratcon.StratconCoords;\n+import mekhq.campaign.stratcon.StratconFacility;\n+import mekhq.campaign.stratcon.StratconScenario;\n+import mekhq.campaign.stratcon.StratconTrackState;\n+import mekhq.gui.stratcon.StratconScenarioWizard;\n+import mekhq.gui.stratcon.TrackForceAssignmentUI;\n+\n+/**\n+ * This panel handles AtB-Stratcon GUI interactions with a specific scenario track.\n+ * @author NickAragua\n+ */\n+public class StratconPanel extends JPanel implements ActionListener {\n+    /**\n+     * \n+     */", "originalCommit": "796b6728fd3cd2aea02d17122b4d735afc47dc41", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjkwMTQ2OA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r602901468", "bodyText": "Enum values should be capitalized", "author": "Windchild292", "createdAt": "2021-03-28T16:41:25Z", "path": "MekHQ/src/mekhq/gui/StratconPanel.java", "diffHunk": "@@ -0,0 +1,672 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.gui;\n+\n+import java.awt.BasicStroke;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Point;\n+import java.awt.Polygon;\n+import java.awt.Stroke;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.awt.geom.AffineTransform;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import javax.swing.JCheckBoxMenuItem;\n+import javax.swing.JLabel;\n+import javax.swing.JMenuItem;\n+import javax.swing.JPanel;\n+import javax.swing.JPopupMenu;\n+import javax.swing.SwingUtilities;\n+\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.stratcon.StratconCampaignState;\n+import mekhq.campaign.stratcon.StratconCoords;\n+import mekhq.campaign.stratcon.StratconFacility;\n+import mekhq.campaign.stratcon.StratconScenario;\n+import mekhq.campaign.stratcon.StratconTrackState;\n+import mekhq.gui.stratcon.StratconScenarioWizard;\n+import mekhq.gui.stratcon.TrackForceAssignmentUI;\n+\n+/**\n+ * This panel handles AtB-Stratcon GUI interactions with a specific scenario track.\n+ * @author NickAragua\n+ */\n+public class StratconPanel extends JPanel implements ActionListener {\n+    /**\n+     * \n+     */\n+    private static final long serialVersionUID = 7405934788894417292L;\n+    \n+    public static final int HEX_X_RADIUS = 42;\n+    public static final int HEX_Y_RADIUS = 37;\n+    \n+    private static final String RCLICK_COMMAND_MANAGE_FORCES = \"ManageForces\";\n+    private static final String RCLICK_COMMAND_MANAGE_SCENARIO = \"ManageScenario\";\n+    private static final String RCLICK_COMMAND_REVEAL_TRACK = \"RevealTrack\";\n+    private static final String RCLICK_COMMAND_STICKY_FORCE = \"StickyForce\";\n+    private static final String RCLICK_COMMAND_STICKY_FORCE_ID = \"StickyForceID\";\n+\n+    /**\n+     * What to do when drawing a hex\n+     */\n+    private enum DrawHexType {\n+        /**\n+         * The interior of a hex\n+         */\n+        Hex,\n+        \n+        /**\n+         * The outline of a hex\n+         */\n+        Outline,\n+        \n+        /**\n+         * Pretend we're drawing a hex, but don't actually do it, useful for \n+         * figuring out which hex a mouse click landed in, etc.\n+         */\n+        Dryrun", "originalCommit": "796b6728fd3cd2aea02d17122b4d735afc47dc41", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjkwMTQ5MQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r602901491", "bodyText": "Package access?", "author": "Windchild292", "createdAt": "2021-03-28T16:41:51Z", "path": "MekHQ/src/mekhq/gui/StratconPanel.java", "diffHunk": "@@ -0,0 +1,672 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.gui;\n+\n+import java.awt.BasicStroke;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Point;\n+import java.awt.Polygon;\n+import java.awt.Stroke;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.awt.geom.AffineTransform;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import javax.swing.JCheckBoxMenuItem;\n+import javax.swing.JLabel;\n+import javax.swing.JMenuItem;\n+import javax.swing.JPanel;\n+import javax.swing.JPopupMenu;\n+import javax.swing.SwingUtilities;\n+\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.stratcon.StratconCampaignState;\n+import mekhq.campaign.stratcon.StratconCoords;\n+import mekhq.campaign.stratcon.StratconFacility;\n+import mekhq.campaign.stratcon.StratconScenario;\n+import mekhq.campaign.stratcon.StratconTrackState;\n+import mekhq.gui.stratcon.StratconScenarioWizard;\n+import mekhq.gui.stratcon.TrackForceAssignmentUI;\n+\n+/**\n+ * This panel handles AtB-Stratcon GUI interactions with a specific scenario track.\n+ * @author NickAragua\n+ */\n+public class StratconPanel extends JPanel implements ActionListener {\n+    /**\n+     * \n+     */\n+    private static final long serialVersionUID = 7405934788894417292L;\n+    \n+    public static final int HEX_X_RADIUS = 42;\n+    public static final int HEX_Y_RADIUS = 37;\n+    \n+    private static final String RCLICK_COMMAND_MANAGE_FORCES = \"ManageForces\";\n+    private static final String RCLICK_COMMAND_MANAGE_SCENARIO = \"ManageScenario\";\n+    private static final String RCLICK_COMMAND_REVEAL_TRACK = \"RevealTrack\";\n+    private static final String RCLICK_COMMAND_STICKY_FORCE = \"StickyForce\";\n+    private static final String RCLICK_COMMAND_STICKY_FORCE_ID = \"StickyForceID\";\n+\n+    /**\n+     * What to do when drawing a hex\n+     */\n+    private enum DrawHexType {\n+        /**\n+         * The interior of a hex\n+         */\n+        Hex,\n+        \n+        /**\n+         * The outline of a hex\n+         */\n+        Outline,\n+        \n+        /**\n+         * Pretend we're drawing a hex, but don't actually do it, useful for \n+         * figuring out which hex a mouse click landed in, etc.\n+         */\n+        Dryrun\n+    }\n+\n+    private float scale = 1f;\n+\n+    private StratconTrackState currentTrack;\n+    private StratconCampaignState campaignState;\n+    private Campaign campaign;\n+\n+    private BoardState boardState = new BoardState();\n+\n+    private Point clickedPoint;\n+    private JPopupMenu rightClickMenu;\n+    private JMenuItem menuItemManageForceAssignments;\n+    private JMenuItem menuItemManageScenario;\n+    private JMenuItem menuItemGMReveal;\n+    \n+    // data structure holding how many unit/scenario/base icons have been drawn in the hex\n+    // used to control how low the text description goes.\n+    private Map<StratconCoords, Integer> numIconsInHex = new HashMap<>();\n+    \n+    private StratconScenarioWizard scenarioWizard;\n+    private TrackForceAssignmentUI assignmentUI;\n+    \n+    private JLabel infoArea;\n+\n+    /**\n+     * Constructs a StratconPanel instance, given a parent campaign GUI and a pointer to an info area.\n+     */\n+    StratconPanel(CampaignGUI gui, JLabel infoArea) {", "originalCommit": "796b6728fd3cd2aea02d17122b4d735afc47dc41", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjkwMTU0OQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r602901549", "bodyText": "Brackets", "author": "Windchild292", "createdAt": "2021-03-28T16:42:23Z", "path": "MekHQ/src/mekhq/gui/StratconPanel.java", "diffHunk": "@@ -0,0 +1,672 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.gui;\n+\n+import java.awt.BasicStroke;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Point;\n+import java.awt.Polygon;\n+import java.awt.Stroke;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.awt.geom.AffineTransform;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import javax.swing.JCheckBoxMenuItem;\n+import javax.swing.JLabel;\n+import javax.swing.JMenuItem;\n+import javax.swing.JPanel;\n+import javax.swing.JPopupMenu;\n+import javax.swing.SwingUtilities;\n+\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.stratcon.StratconCampaignState;\n+import mekhq.campaign.stratcon.StratconCoords;\n+import mekhq.campaign.stratcon.StratconFacility;\n+import mekhq.campaign.stratcon.StratconScenario;\n+import mekhq.campaign.stratcon.StratconTrackState;\n+import mekhq.gui.stratcon.StratconScenarioWizard;\n+import mekhq.gui.stratcon.TrackForceAssignmentUI;\n+\n+/**\n+ * This panel handles AtB-Stratcon GUI interactions with a specific scenario track.\n+ * @author NickAragua\n+ */\n+public class StratconPanel extends JPanel implements ActionListener {\n+    /**\n+     * \n+     */\n+    private static final long serialVersionUID = 7405934788894417292L;\n+    \n+    public static final int HEX_X_RADIUS = 42;\n+    public static final int HEX_Y_RADIUS = 37;\n+    \n+    private static final String RCLICK_COMMAND_MANAGE_FORCES = \"ManageForces\";\n+    private static final String RCLICK_COMMAND_MANAGE_SCENARIO = \"ManageScenario\";\n+    private static final String RCLICK_COMMAND_REVEAL_TRACK = \"RevealTrack\";\n+    private static final String RCLICK_COMMAND_STICKY_FORCE = \"StickyForce\";\n+    private static final String RCLICK_COMMAND_STICKY_FORCE_ID = \"StickyForceID\";\n+\n+    /**\n+     * What to do when drawing a hex\n+     */\n+    private enum DrawHexType {\n+        /**\n+         * The interior of a hex\n+         */\n+        Hex,\n+        \n+        /**\n+         * The outline of a hex\n+         */\n+        Outline,\n+        \n+        /**\n+         * Pretend we're drawing a hex, but don't actually do it, useful for \n+         * figuring out which hex a mouse click landed in, etc.\n+         */\n+        Dryrun\n+    }\n+\n+    private float scale = 1f;\n+\n+    private StratconTrackState currentTrack;\n+    private StratconCampaignState campaignState;\n+    private Campaign campaign;\n+\n+    private BoardState boardState = new BoardState();\n+\n+    private Point clickedPoint;\n+    private JPopupMenu rightClickMenu;\n+    private JMenuItem menuItemManageForceAssignments;\n+    private JMenuItem menuItemManageScenario;\n+    private JMenuItem menuItemGMReveal;\n+    \n+    // data structure holding how many unit/scenario/base icons have been drawn in the hex\n+    // used to control how low the text description goes.\n+    private Map<StratconCoords, Integer> numIconsInHex = new HashMap<>();\n+    \n+    private StratconScenarioWizard scenarioWizard;\n+    private TrackForceAssignmentUI assignmentUI;\n+    \n+    private JLabel infoArea;\n+\n+    /**\n+     * Constructs a StratconPanel instance, given a parent campaign GUI and a pointer to an info area.\n+     */\n+    StratconPanel(CampaignGUI gui, JLabel infoArea) {\n+        campaign = gui.getCampaign();\n+        scenarioWizard = new StratconScenarioWizard(campaign);\n+        this.infoArea = infoArea;\n+        \n+        assignmentUI = new TrackForceAssignmentUI(this);\n+        assignmentUI.setVisible(false);\n+        \n+        addMouseListener(new MouseAdapter() {\n+            @Override\n+            public void mouseReleased(MouseEvent e) {\n+                mouseReleasedHandler(e);\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Handler for when a specific track is selected - switches rendering to that track.\n+     */\n+    public void selectTrack(StratconCampaignState campaignState, StratconTrackState track) {\n+        this.campaignState = campaignState;\n+        currentTrack = track;\n+        repaint();\n+    }\n+    \n+    /**\n+     * Constructs the right-click context menu, optionally for a scenario\n+     */\n+    private void buildRightClickMenu(StratconCoords coords) {\n+        rightClickMenu = new JPopupMenu();\n+        \n+        StratconScenario scenario = getSelectedScenario();\n+        \n+        if (scenario == null) {\n+            menuItemManageForceAssignments = new JMenuItem();\n+            menuItemManageForceAssignments.setText(\"Manage Force Assignments\");\n+            menuItemManageForceAssignments.setActionCommand(RCLICK_COMMAND_MANAGE_FORCES);\n+            menuItemManageForceAssignments.addActionListener(this);\n+            rightClickMenu.add(menuItemManageForceAssignments);\n+        }\n+        \n+        if (scenario != null) {\n+            menuItemManageScenario = new JMenuItem();\n+            menuItemManageScenario.setText(\"Manage Scenario\");\n+            menuItemManageScenario.setActionCommand(RCLICK_COMMAND_MANAGE_SCENARIO);\n+            menuItemManageScenario.addActionListener(this);\n+            rightClickMenu.add(menuItemManageScenario);\n+        }\n+        \n+        if ((currentTrack != null) && currentTrack.getAssignedCoordForces().containsKey(coords)) {\n+            for (int forceID : currentTrack.getAssignedCoordForces().get(coords)) {\n+                String forceName = campaign.getForce(forceID).getName();\n+                \n+                JCheckBoxMenuItem stickyForceItem = new JCheckBoxMenuItem();\n+                stickyForceItem.setText(String.format(\"%s - remain deployed\", forceName));\n+                stickyForceItem.setActionCommand(RCLICK_COMMAND_STICKY_FORCE);\n+                stickyForceItem.putClientProperty(RCLICK_COMMAND_STICKY_FORCE_ID, forceID);\n+                stickyForceItem.addActionListener(this);\n+                stickyForceItem.setSelected(currentTrack.getStickyForces().contains(forceID));\n+                rightClickMenu.add(stickyForceItem);\n+            }\n+        }\n+            \n+        if ((currentTrack != null) && campaign.isGM()) {\n+            rightClickMenu.addSeparator();\n+            \n+            menuItemGMReveal = new JMenuItem();\n+            menuItemGMReveal.setText(currentTrack.isGmRevealed() ? \"Hide Track\" : \"Reveal Track\");\n+            menuItemGMReveal.setActionCommand(RCLICK_COMMAND_REVEAL_TRACK);\n+            menuItemGMReveal.addActionListener(this);\n+            rightClickMenu.add(menuItemGMReveal);\n+        }\n+    }\n+\n+    /**\n+     * Renders the panel, hexes, forces, facilities and all that.\n+     */\n+    @Override\n+    public void paintComponent(Graphics g) {\n+        super.paintComponent(g);\n+        if (campaignState == null || currentTrack == null) {", "originalCommit": "796b6728fd3cd2aea02d17122b4d735afc47dc41", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjkwMTY0Nw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r602901647", "bodyText": "Spacing between the numerator, the slash, and the denominator (i.e. xRadius / 2) - Accessibility Issue", "author": "Windchild292", "createdAt": "2021-03-28T16:43:27Z", "path": "MekHQ/src/mekhq/gui/StratconPanel.java", "diffHunk": "@@ -0,0 +1,672 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.gui;\n+\n+import java.awt.BasicStroke;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Point;\n+import java.awt.Polygon;\n+import java.awt.Stroke;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.awt.geom.AffineTransform;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import javax.swing.JCheckBoxMenuItem;\n+import javax.swing.JLabel;\n+import javax.swing.JMenuItem;\n+import javax.swing.JPanel;\n+import javax.swing.JPopupMenu;\n+import javax.swing.SwingUtilities;\n+\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.stratcon.StratconCampaignState;\n+import mekhq.campaign.stratcon.StratconCoords;\n+import mekhq.campaign.stratcon.StratconFacility;\n+import mekhq.campaign.stratcon.StratconScenario;\n+import mekhq.campaign.stratcon.StratconTrackState;\n+import mekhq.gui.stratcon.StratconScenarioWizard;\n+import mekhq.gui.stratcon.TrackForceAssignmentUI;\n+\n+/**\n+ * This panel handles AtB-Stratcon GUI interactions with a specific scenario track.\n+ * @author NickAragua\n+ */\n+public class StratconPanel extends JPanel implements ActionListener {\n+    /**\n+     * \n+     */\n+    private static final long serialVersionUID = 7405934788894417292L;\n+    \n+    public static final int HEX_X_RADIUS = 42;\n+    public static final int HEX_Y_RADIUS = 37;\n+    \n+    private static final String RCLICK_COMMAND_MANAGE_FORCES = \"ManageForces\";\n+    private static final String RCLICK_COMMAND_MANAGE_SCENARIO = \"ManageScenario\";\n+    private static final String RCLICK_COMMAND_REVEAL_TRACK = \"RevealTrack\";\n+    private static final String RCLICK_COMMAND_STICKY_FORCE = \"StickyForce\";\n+    private static final String RCLICK_COMMAND_STICKY_FORCE_ID = \"StickyForceID\";\n+\n+    /**\n+     * What to do when drawing a hex\n+     */\n+    private enum DrawHexType {\n+        /**\n+         * The interior of a hex\n+         */\n+        Hex,\n+        \n+        /**\n+         * The outline of a hex\n+         */\n+        Outline,\n+        \n+        /**\n+         * Pretend we're drawing a hex, but don't actually do it, useful for \n+         * figuring out which hex a mouse click landed in, etc.\n+         */\n+        Dryrun\n+    }\n+\n+    private float scale = 1f;\n+\n+    private StratconTrackState currentTrack;\n+    private StratconCampaignState campaignState;\n+    private Campaign campaign;\n+\n+    private BoardState boardState = new BoardState();\n+\n+    private Point clickedPoint;\n+    private JPopupMenu rightClickMenu;\n+    private JMenuItem menuItemManageForceAssignments;\n+    private JMenuItem menuItemManageScenario;\n+    private JMenuItem menuItemGMReveal;\n+    \n+    // data structure holding how many unit/scenario/base icons have been drawn in the hex\n+    // used to control how low the text description goes.\n+    private Map<StratconCoords, Integer> numIconsInHex = new HashMap<>();\n+    \n+    private StratconScenarioWizard scenarioWizard;\n+    private TrackForceAssignmentUI assignmentUI;\n+    \n+    private JLabel infoArea;\n+\n+    /**\n+     * Constructs a StratconPanel instance, given a parent campaign GUI and a pointer to an info area.\n+     */\n+    StratconPanel(CampaignGUI gui, JLabel infoArea) {\n+        campaign = gui.getCampaign();\n+        scenarioWizard = new StratconScenarioWizard(campaign);\n+        this.infoArea = infoArea;\n+        \n+        assignmentUI = new TrackForceAssignmentUI(this);\n+        assignmentUI.setVisible(false);\n+        \n+        addMouseListener(new MouseAdapter() {\n+            @Override\n+            public void mouseReleased(MouseEvent e) {\n+                mouseReleasedHandler(e);\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Handler for when a specific track is selected - switches rendering to that track.\n+     */\n+    public void selectTrack(StratconCampaignState campaignState, StratconTrackState track) {\n+        this.campaignState = campaignState;\n+        currentTrack = track;\n+        repaint();\n+    }\n+    \n+    /**\n+     * Constructs the right-click context menu, optionally for a scenario\n+     */\n+    private void buildRightClickMenu(StratconCoords coords) {\n+        rightClickMenu = new JPopupMenu();\n+        \n+        StratconScenario scenario = getSelectedScenario();\n+        \n+        if (scenario == null) {\n+            menuItemManageForceAssignments = new JMenuItem();\n+            menuItemManageForceAssignments.setText(\"Manage Force Assignments\");\n+            menuItemManageForceAssignments.setActionCommand(RCLICK_COMMAND_MANAGE_FORCES);\n+            menuItemManageForceAssignments.addActionListener(this);\n+            rightClickMenu.add(menuItemManageForceAssignments);\n+        }\n+        \n+        if (scenario != null) {\n+            menuItemManageScenario = new JMenuItem();\n+            menuItemManageScenario.setText(\"Manage Scenario\");\n+            menuItemManageScenario.setActionCommand(RCLICK_COMMAND_MANAGE_SCENARIO);\n+            menuItemManageScenario.addActionListener(this);\n+            rightClickMenu.add(menuItemManageScenario);\n+        }\n+        \n+        if ((currentTrack != null) && currentTrack.getAssignedCoordForces().containsKey(coords)) {\n+            for (int forceID : currentTrack.getAssignedCoordForces().get(coords)) {\n+                String forceName = campaign.getForce(forceID).getName();\n+                \n+                JCheckBoxMenuItem stickyForceItem = new JCheckBoxMenuItem();\n+                stickyForceItem.setText(String.format(\"%s - remain deployed\", forceName));\n+                stickyForceItem.setActionCommand(RCLICK_COMMAND_STICKY_FORCE);\n+                stickyForceItem.putClientProperty(RCLICK_COMMAND_STICKY_FORCE_ID, forceID);\n+                stickyForceItem.addActionListener(this);\n+                stickyForceItem.setSelected(currentTrack.getStickyForces().contains(forceID));\n+                rightClickMenu.add(stickyForceItem);\n+            }\n+        }\n+            \n+        if ((currentTrack != null) && campaign.isGM()) {\n+            rightClickMenu.addSeparator();\n+            \n+            menuItemGMReveal = new JMenuItem();\n+            menuItemGMReveal.setText(currentTrack.isGmRevealed() ? \"Hide Track\" : \"Reveal Track\");\n+            menuItemGMReveal.setActionCommand(RCLICK_COMMAND_REVEAL_TRACK);\n+            menuItemGMReveal.addActionListener(this);\n+            rightClickMenu.add(menuItemGMReveal);\n+        }\n+    }\n+\n+    /**\n+     * Renders the panel, hexes, forces, facilities and all that.\n+     */\n+    @Override\n+    public void paintComponent(Graphics g) {\n+        super.paintComponent(g);\n+        if (campaignState == null || currentTrack == null) {\n+            return;\n+        }\n+        \n+        numIconsInHex.clear();\n+\n+        Graphics2D g2D = (Graphics2D) g;\n+        AffineTransform initialTransform = g2D.getTransform();\n+        performInitialTransform(g2D);\n+        AffineTransform originTransform = g2D.getTransform();\n+\n+        drawHexes(g2D, DrawHexType.Hex);\n+        g2D.setTransform(originTransform);\n+        drawHexes(g2D, DrawHexType.Outline);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawScenarios(g2D);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawFacilities(g2D);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawForces(g2D);\n+\n+        g2D.setTransform(initialTransform);\n+        if (clickedPoint != null) {\n+            g2D.setColor(Color.BLUE);\n+            g2D.drawRect((int) clickedPoint.getX(), (int) clickedPoint.getY(), 2, 2);\n+        }\n+    }\n+\n+    /**\n+     * This method contains a dirty secret hack, but I forget what it is.\n+     * The point of it is to draw all the hexes for the board. \n+     * If it's a \"dry run\", we don't actually draw the hexes, we just pretend to\n+     * until we \"draw\" one that encompasses the clicked point.\n+     * @param g2D - graphics object on which to draw\n+     * @param drawHexType - whether to draw the hex backgrounds, hex outlines or a dry run for click detection\n+     */\n+    private boolean drawHexes(Graphics2D g2D, DrawHexType drawHexType) {\n+        Polygon graphHex = new Polygon();\n+        int xRadius = HEX_X_RADIUS;\n+        int yRadius = HEX_Y_RADIUS;\n+        boolean pointFound = false;\n+\n+        graphHex.addPoint(-xRadius/2, -yRadius);\n+        graphHex.addPoint(-xRadius, 0);\n+        graphHex.addPoint(-xRadius/2, yRadius);\n+        graphHex.addPoint(xRadius/2, yRadius);\n+        graphHex.addPoint(xRadius, 0);\n+        graphHex.addPoint(xRadius/2, -yRadius);", "originalCommit": "796b6728fd3cd2aea02d17122b4d735afc47dc41", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjkwMTcyMA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r602901720", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        translatedClickedPoint.translate(0, -(HEX_Y_RADIUS * 2));\n          \n          \n            \n                        translatedClickedPoint.translate(0, HEX_Y_RADIUS * -2);", "author": "Windchild292", "createdAt": "2021-03-28T16:44:07Z", "path": "MekHQ/src/mekhq/gui/StratconPanel.java", "diffHunk": "@@ -0,0 +1,672 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.gui;\n+\n+import java.awt.BasicStroke;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Point;\n+import java.awt.Polygon;\n+import java.awt.Stroke;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.awt.geom.AffineTransform;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import javax.swing.JCheckBoxMenuItem;\n+import javax.swing.JLabel;\n+import javax.swing.JMenuItem;\n+import javax.swing.JPanel;\n+import javax.swing.JPopupMenu;\n+import javax.swing.SwingUtilities;\n+\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.stratcon.StratconCampaignState;\n+import mekhq.campaign.stratcon.StratconCoords;\n+import mekhq.campaign.stratcon.StratconFacility;\n+import mekhq.campaign.stratcon.StratconScenario;\n+import mekhq.campaign.stratcon.StratconTrackState;\n+import mekhq.gui.stratcon.StratconScenarioWizard;\n+import mekhq.gui.stratcon.TrackForceAssignmentUI;\n+\n+/**\n+ * This panel handles AtB-Stratcon GUI interactions with a specific scenario track.\n+ * @author NickAragua\n+ */\n+public class StratconPanel extends JPanel implements ActionListener {\n+    /**\n+     * \n+     */\n+    private static final long serialVersionUID = 7405934788894417292L;\n+    \n+    public static final int HEX_X_RADIUS = 42;\n+    public static final int HEX_Y_RADIUS = 37;\n+    \n+    private static final String RCLICK_COMMAND_MANAGE_FORCES = \"ManageForces\";\n+    private static final String RCLICK_COMMAND_MANAGE_SCENARIO = \"ManageScenario\";\n+    private static final String RCLICK_COMMAND_REVEAL_TRACK = \"RevealTrack\";\n+    private static final String RCLICK_COMMAND_STICKY_FORCE = \"StickyForce\";\n+    private static final String RCLICK_COMMAND_STICKY_FORCE_ID = \"StickyForceID\";\n+\n+    /**\n+     * What to do when drawing a hex\n+     */\n+    private enum DrawHexType {\n+        /**\n+         * The interior of a hex\n+         */\n+        Hex,\n+        \n+        /**\n+         * The outline of a hex\n+         */\n+        Outline,\n+        \n+        /**\n+         * Pretend we're drawing a hex, but don't actually do it, useful for \n+         * figuring out which hex a mouse click landed in, etc.\n+         */\n+        Dryrun\n+    }\n+\n+    private float scale = 1f;\n+\n+    private StratconTrackState currentTrack;\n+    private StratconCampaignState campaignState;\n+    private Campaign campaign;\n+\n+    private BoardState boardState = new BoardState();\n+\n+    private Point clickedPoint;\n+    private JPopupMenu rightClickMenu;\n+    private JMenuItem menuItemManageForceAssignments;\n+    private JMenuItem menuItemManageScenario;\n+    private JMenuItem menuItemGMReveal;\n+    \n+    // data structure holding how many unit/scenario/base icons have been drawn in the hex\n+    // used to control how low the text description goes.\n+    private Map<StratconCoords, Integer> numIconsInHex = new HashMap<>();\n+    \n+    private StratconScenarioWizard scenarioWizard;\n+    private TrackForceAssignmentUI assignmentUI;\n+    \n+    private JLabel infoArea;\n+\n+    /**\n+     * Constructs a StratconPanel instance, given a parent campaign GUI and a pointer to an info area.\n+     */\n+    StratconPanel(CampaignGUI gui, JLabel infoArea) {\n+        campaign = gui.getCampaign();\n+        scenarioWizard = new StratconScenarioWizard(campaign);\n+        this.infoArea = infoArea;\n+        \n+        assignmentUI = new TrackForceAssignmentUI(this);\n+        assignmentUI.setVisible(false);\n+        \n+        addMouseListener(new MouseAdapter() {\n+            @Override\n+            public void mouseReleased(MouseEvent e) {\n+                mouseReleasedHandler(e);\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Handler for when a specific track is selected - switches rendering to that track.\n+     */\n+    public void selectTrack(StratconCampaignState campaignState, StratconTrackState track) {\n+        this.campaignState = campaignState;\n+        currentTrack = track;\n+        repaint();\n+    }\n+    \n+    /**\n+     * Constructs the right-click context menu, optionally for a scenario\n+     */\n+    private void buildRightClickMenu(StratconCoords coords) {\n+        rightClickMenu = new JPopupMenu();\n+        \n+        StratconScenario scenario = getSelectedScenario();\n+        \n+        if (scenario == null) {\n+            menuItemManageForceAssignments = new JMenuItem();\n+            menuItemManageForceAssignments.setText(\"Manage Force Assignments\");\n+            menuItemManageForceAssignments.setActionCommand(RCLICK_COMMAND_MANAGE_FORCES);\n+            menuItemManageForceAssignments.addActionListener(this);\n+            rightClickMenu.add(menuItemManageForceAssignments);\n+        }\n+        \n+        if (scenario != null) {\n+            menuItemManageScenario = new JMenuItem();\n+            menuItemManageScenario.setText(\"Manage Scenario\");\n+            menuItemManageScenario.setActionCommand(RCLICK_COMMAND_MANAGE_SCENARIO);\n+            menuItemManageScenario.addActionListener(this);\n+            rightClickMenu.add(menuItemManageScenario);\n+        }\n+        \n+        if ((currentTrack != null) && currentTrack.getAssignedCoordForces().containsKey(coords)) {\n+            for (int forceID : currentTrack.getAssignedCoordForces().get(coords)) {\n+                String forceName = campaign.getForce(forceID).getName();\n+                \n+                JCheckBoxMenuItem stickyForceItem = new JCheckBoxMenuItem();\n+                stickyForceItem.setText(String.format(\"%s - remain deployed\", forceName));\n+                stickyForceItem.setActionCommand(RCLICK_COMMAND_STICKY_FORCE);\n+                stickyForceItem.putClientProperty(RCLICK_COMMAND_STICKY_FORCE_ID, forceID);\n+                stickyForceItem.addActionListener(this);\n+                stickyForceItem.setSelected(currentTrack.getStickyForces().contains(forceID));\n+                rightClickMenu.add(stickyForceItem);\n+            }\n+        }\n+            \n+        if ((currentTrack != null) && campaign.isGM()) {\n+            rightClickMenu.addSeparator();\n+            \n+            menuItemGMReveal = new JMenuItem();\n+            menuItemGMReveal.setText(currentTrack.isGmRevealed() ? \"Hide Track\" : \"Reveal Track\");\n+            menuItemGMReveal.setActionCommand(RCLICK_COMMAND_REVEAL_TRACK);\n+            menuItemGMReveal.addActionListener(this);\n+            rightClickMenu.add(menuItemGMReveal);\n+        }\n+    }\n+\n+    /**\n+     * Renders the panel, hexes, forces, facilities and all that.\n+     */\n+    @Override\n+    public void paintComponent(Graphics g) {\n+        super.paintComponent(g);\n+        if (campaignState == null || currentTrack == null) {\n+            return;\n+        }\n+        \n+        numIconsInHex.clear();\n+\n+        Graphics2D g2D = (Graphics2D) g;\n+        AffineTransform initialTransform = g2D.getTransform();\n+        performInitialTransform(g2D);\n+        AffineTransform originTransform = g2D.getTransform();\n+\n+        drawHexes(g2D, DrawHexType.Hex);\n+        g2D.setTransform(originTransform);\n+        drawHexes(g2D, DrawHexType.Outline);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawScenarios(g2D);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawFacilities(g2D);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawForces(g2D);\n+\n+        g2D.setTransform(initialTransform);\n+        if (clickedPoint != null) {\n+            g2D.setColor(Color.BLUE);\n+            g2D.drawRect((int) clickedPoint.getX(), (int) clickedPoint.getY(), 2, 2);\n+        }\n+    }\n+\n+    /**\n+     * This method contains a dirty secret hack, but I forget what it is.\n+     * The point of it is to draw all the hexes for the board. \n+     * If it's a \"dry run\", we don't actually draw the hexes, we just pretend to\n+     * until we \"draw\" one that encompasses the clicked point.\n+     * @param g2D - graphics object on which to draw\n+     * @param drawHexType - whether to draw the hex backgrounds, hex outlines or a dry run for click detection\n+     */\n+    private boolean drawHexes(Graphics2D g2D, DrawHexType drawHexType) {\n+        Polygon graphHex = new Polygon();\n+        int xRadius = HEX_X_RADIUS;\n+        int yRadius = HEX_Y_RADIUS;\n+        boolean pointFound = false;\n+\n+        graphHex.addPoint(-xRadius/2, -yRadius);\n+        graphHex.addPoint(-xRadius, 0);\n+        graphHex.addPoint(-xRadius/2, yRadius);\n+        graphHex.addPoint(xRadius/2, yRadius);\n+        graphHex.addPoint(xRadius, 0);\n+        graphHex.addPoint(xRadius/2, -yRadius);\n+\n+        graphHex.translate(xRadius, yRadius);\n+\n+        Point translatedClickedPoint = null;\n+\n+        // this was derived somewhat experimentally\n+        // the clicked point always seems a little off, so we \n+        // a) apply the current transform to it, prior to drawing all the hexes\n+        // b) subtract an additional Y_RADIUS x 2 (Y_DIAMETER)\n+        // this gets us the point within the clicked hex\n+        // it's probably finicky, so any major changes to the rendering mechanism will likely break the detection\n+        if (clickedPoint != null) {\n+            translatedClickedPoint = (Point) clickedPoint.clone();\n+            \n+            // since we have the possibility of scrolling, we need to convert the on-screen clicked coordinates\n+            // to on-board coordinates. Thankfully, SwingUtilities provides the main computational ability for that\n+            Point actualPanelPoint = SwingUtilities.convertPoint(this, translatedClickedPoint, this.getParent());\n+            translatedClickedPoint.translate((int) -(actualPanelPoint.getX() - translatedClickedPoint.getX()), \n+                                                (int) -(actualPanelPoint.getY() - translatedClickedPoint.getY()));\n+            \n+            // now we translate to the starting point of where we're drawing and then go down a hex\n+            translatedClickedPoint.translate((int) g2D.getTransform().getTranslateX(), (int) g2D.getTransform().getTranslateY());\n+            translatedClickedPoint.translate(0, -(HEX_Y_RADIUS * 2));", "originalCommit": "796b6728fd3cd2aea02d17122b4d735afc47dc41", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjkwMTczMA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r602901730", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if(drawHexType == DrawHexType.Outline) {\n          \n          \n            \n                            if (drawHexType == DrawHexType.Outline) {", "author": "Windchild292", "createdAt": "2021-03-28T16:44:16Z", "path": "MekHQ/src/mekhq/gui/StratconPanel.java", "diffHunk": "@@ -0,0 +1,672 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.gui;\n+\n+import java.awt.BasicStroke;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Point;\n+import java.awt.Polygon;\n+import java.awt.Stroke;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.awt.geom.AffineTransform;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import javax.swing.JCheckBoxMenuItem;\n+import javax.swing.JLabel;\n+import javax.swing.JMenuItem;\n+import javax.swing.JPanel;\n+import javax.swing.JPopupMenu;\n+import javax.swing.SwingUtilities;\n+\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.stratcon.StratconCampaignState;\n+import mekhq.campaign.stratcon.StratconCoords;\n+import mekhq.campaign.stratcon.StratconFacility;\n+import mekhq.campaign.stratcon.StratconScenario;\n+import mekhq.campaign.stratcon.StratconTrackState;\n+import mekhq.gui.stratcon.StratconScenarioWizard;\n+import mekhq.gui.stratcon.TrackForceAssignmentUI;\n+\n+/**\n+ * This panel handles AtB-Stratcon GUI interactions with a specific scenario track.\n+ * @author NickAragua\n+ */\n+public class StratconPanel extends JPanel implements ActionListener {\n+    /**\n+     * \n+     */\n+    private static final long serialVersionUID = 7405934788894417292L;\n+    \n+    public static final int HEX_X_RADIUS = 42;\n+    public static final int HEX_Y_RADIUS = 37;\n+    \n+    private static final String RCLICK_COMMAND_MANAGE_FORCES = \"ManageForces\";\n+    private static final String RCLICK_COMMAND_MANAGE_SCENARIO = \"ManageScenario\";\n+    private static final String RCLICK_COMMAND_REVEAL_TRACK = \"RevealTrack\";\n+    private static final String RCLICK_COMMAND_STICKY_FORCE = \"StickyForce\";\n+    private static final String RCLICK_COMMAND_STICKY_FORCE_ID = \"StickyForceID\";\n+\n+    /**\n+     * What to do when drawing a hex\n+     */\n+    private enum DrawHexType {\n+        /**\n+         * The interior of a hex\n+         */\n+        Hex,\n+        \n+        /**\n+         * The outline of a hex\n+         */\n+        Outline,\n+        \n+        /**\n+         * Pretend we're drawing a hex, but don't actually do it, useful for \n+         * figuring out which hex a mouse click landed in, etc.\n+         */\n+        Dryrun\n+    }\n+\n+    private float scale = 1f;\n+\n+    private StratconTrackState currentTrack;\n+    private StratconCampaignState campaignState;\n+    private Campaign campaign;\n+\n+    private BoardState boardState = new BoardState();\n+\n+    private Point clickedPoint;\n+    private JPopupMenu rightClickMenu;\n+    private JMenuItem menuItemManageForceAssignments;\n+    private JMenuItem menuItemManageScenario;\n+    private JMenuItem menuItemGMReveal;\n+    \n+    // data structure holding how many unit/scenario/base icons have been drawn in the hex\n+    // used to control how low the text description goes.\n+    private Map<StratconCoords, Integer> numIconsInHex = new HashMap<>();\n+    \n+    private StratconScenarioWizard scenarioWizard;\n+    private TrackForceAssignmentUI assignmentUI;\n+    \n+    private JLabel infoArea;\n+\n+    /**\n+     * Constructs a StratconPanel instance, given a parent campaign GUI and a pointer to an info area.\n+     */\n+    StratconPanel(CampaignGUI gui, JLabel infoArea) {\n+        campaign = gui.getCampaign();\n+        scenarioWizard = new StratconScenarioWizard(campaign);\n+        this.infoArea = infoArea;\n+        \n+        assignmentUI = new TrackForceAssignmentUI(this);\n+        assignmentUI.setVisible(false);\n+        \n+        addMouseListener(new MouseAdapter() {\n+            @Override\n+            public void mouseReleased(MouseEvent e) {\n+                mouseReleasedHandler(e);\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Handler for when a specific track is selected - switches rendering to that track.\n+     */\n+    public void selectTrack(StratconCampaignState campaignState, StratconTrackState track) {\n+        this.campaignState = campaignState;\n+        currentTrack = track;\n+        repaint();\n+    }\n+    \n+    /**\n+     * Constructs the right-click context menu, optionally for a scenario\n+     */\n+    private void buildRightClickMenu(StratconCoords coords) {\n+        rightClickMenu = new JPopupMenu();\n+        \n+        StratconScenario scenario = getSelectedScenario();\n+        \n+        if (scenario == null) {\n+            menuItemManageForceAssignments = new JMenuItem();\n+            menuItemManageForceAssignments.setText(\"Manage Force Assignments\");\n+            menuItemManageForceAssignments.setActionCommand(RCLICK_COMMAND_MANAGE_FORCES);\n+            menuItemManageForceAssignments.addActionListener(this);\n+            rightClickMenu.add(menuItemManageForceAssignments);\n+        }\n+        \n+        if (scenario != null) {\n+            menuItemManageScenario = new JMenuItem();\n+            menuItemManageScenario.setText(\"Manage Scenario\");\n+            menuItemManageScenario.setActionCommand(RCLICK_COMMAND_MANAGE_SCENARIO);\n+            menuItemManageScenario.addActionListener(this);\n+            rightClickMenu.add(menuItemManageScenario);\n+        }\n+        \n+        if ((currentTrack != null) && currentTrack.getAssignedCoordForces().containsKey(coords)) {\n+            for (int forceID : currentTrack.getAssignedCoordForces().get(coords)) {\n+                String forceName = campaign.getForce(forceID).getName();\n+                \n+                JCheckBoxMenuItem stickyForceItem = new JCheckBoxMenuItem();\n+                stickyForceItem.setText(String.format(\"%s - remain deployed\", forceName));\n+                stickyForceItem.setActionCommand(RCLICK_COMMAND_STICKY_FORCE);\n+                stickyForceItem.putClientProperty(RCLICK_COMMAND_STICKY_FORCE_ID, forceID);\n+                stickyForceItem.addActionListener(this);\n+                stickyForceItem.setSelected(currentTrack.getStickyForces().contains(forceID));\n+                rightClickMenu.add(stickyForceItem);\n+            }\n+        }\n+            \n+        if ((currentTrack != null) && campaign.isGM()) {\n+            rightClickMenu.addSeparator();\n+            \n+            menuItemGMReveal = new JMenuItem();\n+            menuItemGMReveal.setText(currentTrack.isGmRevealed() ? \"Hide Track\" : \"Reveal Track\");\n+            menuItemGMReveal.setActionCommand(RCLICK_COMMAND_REVEAL_TRACK);\n+            menuItemGMReveal.addActionListener(this);\n+            rightClickMenu.add(menuItemGMReveal);\n+        }\n+    }\n+\n+    /**\n+     * Renders the panel, hexes, forces, facilities and all that.\n+     */\n+    @Override\n+    public void paintComponent(Graphics g) {\n+        super.paintComponent(g);\n+        if (campaignState == null || currentTrack == null) {\n+            return;\n+        }\n+        \n+        numIconsInHex.clear();\n+\n+        Graphics2D g2D = (Graphics2D) g;\n+        AffineTransform initialTransform = g2D.getTransform();\n+        performInitialTransform(g2D);\n+        AffineTransform originTransform = g2D.getTransform();\n+\n+        drawHexes(g2D, DrawHexType.Hex);\n+        g2D.setTransform(originTransform);\n+        drawHexes(g2D, DrawHexType.Outline);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawScenarios(g2D);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawFacilities(g2D);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawForces(g2D);\n+\n+        g2D.setTransform(initialTransform);\n+        if (clickedPoint != null) {\n+            g2D.setColor(Color.BLUE);\n+            g2D.drawRect((int) clickedPoint.getX(), (int) clickedPoint.getY(), 2, 2);\n+        }\n+    }\n+\n+    /**\n+     * This method contains a dirty secret hack, but I forget what it is.\n+     * The point of it is to draw all the hexes for the board. \n+     * If it's a \"dry run\", we don't actually draw the hexes, we just pretend to\n+     * until we \"draw\" one that encompasses the clicked point.\n+     * @param g2D - graphics object on which to draw\n+     * @param drawHexType - whether to draw the hex backgrounds, hex outlines or a dry run for click detection\n+     */\n+    private boolean drawHexes(Graphics2D g2D, DrawHexType drawHexType) {\n+        Polygon graphHex = new Polygon();\n+        int xRadius = HEX_X_RADIUS;\n+        int yRadius = HEX_Y_RADIUS;\n+        boolean pointFound = false;\n+\n+        graphHex.addPoint(-xRadius/2, -yRadius);\n+        graphHex.addPoint(-xRadius, 0);\n+        graphHex.addPoint(-xRadius/2, yRadius);\n+        graphHex.addPoint(xRadius/2, yRadius);\n+        graphHex.addPoint(xRadius, 0);\n+        graphHex.addPoint(xRadius/2, -yRadius);\n+\n+        graphHex.translate(xRadius, yRadius);\n+\n+        Point translatedClickedPoint = null;\n+\n+        // this was derived somewhat experimentally\n+        // the clicked point always seems a little off, so we \n+        // a) apply the current transform to it, prior to drawing all the hexes\n+        // b) subtract an additional Y_RADIUS x 2 (Y_DIAMETER)\n+        // this gets us the point within the clicked hex\n+        // it's probably finicky, so any major changes to the rendering mechanism will likely break the detection\n+        if (clickedPoint != null) {\n+            translatedClickedPoint = (Point) clickedPoint.clone();\n+            \n+            // since we have the possibility of scrolling, we need to convert the on-screen clicked coordinates\n+            // to on-board coordinates. Thankfully, SwingUtilities provides the main computational ability for that\n+            Point actualPanelPoint = SwingUtilities.convertPoint(this, translatedClickedPoint, this.getParent());\n+            translatedClickedPoint.translate((int) -(actualPanelPoint.getX() - translatedClickedPoint.getX()), \n+                                                (int) -(actualPanelPoint.getY() - translatedClickedPoint.getY()));\n+            \n+            // now we translate to the starting point of where we're drawing and then go down a hex\n+            translatedClickedPoint.translate((int) g2D.getTransform().getTranslateX(), (int) g2D.getTransform().getTranslateY());\n+            translatedClickedPoint.translate(0, -(HEX_Y_RADIUS * 2));\n+        }\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                if(drawHexType == DrawHexType.Outline) {", "originalCommit": "796b6728fd3cd2aea02d17122b4d735afc47dc41", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjkwMTc0Ng==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r602901746", "bodyText": "Brackets", "author": "Windchild292", "createdAt": "2021-03-28T16:44:31Z", "path": "MekHQ/src/mekhq/gui/StratconPanel.java", "diffHunk": "@@ -0,0 +1,672 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.gui;\n+\n+import java.awt.BasicStroke;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Point;\n+import java.awt.Polygon;\n+import java.awt.Stroke;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.awt.geom.AffineTransform;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import javax.swing.JCheckBoxMenuItem;\n+import javax.swing.JLabel;\n+import javax.swing.JMenuItem;\n+import javax.swing.JPanel;\n+import javax.swing.JPopupMenu;\n+import javax.swing.SwingUtilities;\n+\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.stratcon.StratconCampaignState;\n+import mekhq.campaign.stratcon.StratconCoords;\n+import mekhq.campaign.stratcon.StratconFacility;\n+import mekhq.campaign.stratcon.StratconScenario;\n+import mekhq.campaign.stratcon.StratconTrackState;\n+import mekhq.gui.stratcon.StratconScenarioWizard;\n+import mekhq.gui.stratcon.TrackForceAssignmentUI;\n+\n+/**\n+ * This panel handles AtB-Stratcon GUI interactions with a specific scenario track.\n+ * @author NickAragua\n+ */\n+public class StratconPanel extends JPanel implements ActionListener {\n+    /**\n+     * \n+     */\n+    private static final long serialVersionUID = 7405934788894417292L;\n+    \n+    public static final int HEX_X_RADIUS = 42;\n+    public static final int HEX_Y_RADIUS = 37;\n+    \n+    private static final String RCLICK_COMMAND_MANAGE_FORCES = \"ManageForces\";\n+    private static final String RCLICK_COMMAND_MANAGE_SCENARIO = \"ManageScenario\";\n+    private static final String RCLICK_COMMAND_REVEAL_TRACK = \"RevealTrack\";\n+    private static final String RCLICK_COMMAND_STICKY_FORCE = \"StickyForce\";\n+    private static final String RCLICK_COMMAND_STICKY_FORCE_ID = \"StickyForceID\";\n+\n+    /**\n+     * What to do when drawing a hex\n+     */\n+    private enum DrawHexType {\n+        /**\n+         * The interior of a hex\n+         */\n+        Hex,\n+        \n+        /**\n+         * The outline of a hex\n+         */\n+        Outline,\n+        \n+        /**\n+         * Pretend we're drawing a hex, but don't actually do it, useful for \n+         * figuring out which hex a mouse click landed in, etc.\n+         */\n+        Dryrun\n+    }\n+\n+    private float scale = 1f;\n+\n+    private StratconTrackState currentTrack;\n+    private StratconCampaignState campaignState;\n+    private Campaign campaign;\n+\n+    private BoardState boardState = new BoardState();\n+\n+    private Point clickedPoint;\n+    private JPopupMenu rightClickMenu;\n+    private JMenuItem menuItemManageForceAssignments;\n+    private JMenuItem menuItemManageScenario;\n+    private JMenuItem menuItemGMReveal;\n+    \n+    // data structure holding how many unit/scenario/base icons have been drawn in the hex\n+    // used to control how low the text description goes.\n+    private Map<StratconCoords, Integer> numIconsInHex = new HashMap<>();\n+    \n+    private StratconScenarioWizard scenarioWizard;\n+    private TrackForceAssignmentUI assignmentUI;\n+    \n+    private JLabel infoArea;\n+\n+    /**\n+     * Constructs a StratconPanel instance, given a parent campaign GUI and a pointer to an info area.\n+     */\n+    StratconPanel(CampaignGUI gui, JLabel infoArea) {\n+        campaign = gui.getCampaign();\n+        scenarioWizard = new StratconScenarioWizard(campaign);\n+        this.infoArea = infoArea;\n+        \n+        assignmentUI = new TrackForceAssignmentUI(this);\n+        assignmentUI.setVisible(false);\n+        \n+        addMouseListener(new MouseAdapter() {\n+            @Override\n+            public void mouseReleased(MouseEvent e) {\n+                mouseReleasedHandler(e);\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Handler for when a specific track is selected - switches rendering to that track.\n+     */\n+    public void selectTrack(StratconCampaignState campaignState, StratconTrackState track) {\n+        this.campaignState = campaignState;\n+        currentTrack = track;\n+        repaint();\n+    }\n+    \n+    /**\n+     * Constructs the right-click context menu, optionally for a scenario\n+     */\n+    private void buildRightClickMenu(StratconCoords coords) {\n+        rightClickMenu = new JPopupMenu();\n+        \n+        StratconScenario scenario = getSelectedScenario();\n+        \n+        if (scenario == null) {\n+            menuItemManageForceAssignments = new JMenuItem();\n+            menuItemManageForceAssignments.setText(\"Manage Force Assignments\");\n+            menuItemManageForceAssignments.setActionCommand(RCLICK_COMMAND_MANAGE_FORCES);\n+            menuItemManageForceAssignments.addActionListener(this);\n+            rightClickMenu.add(menuItemManageForceAssignments);\n+        }\n+        \n+        if (scenario != null) {\n+            menuItemManageScenario = new JMenuItem();\n+            menuItemManageScenario.setText(\"Manage Scenario\");\n+            menuItemManageScenario.setActionCommand(RCLICK_COMMAND_MANAGE_SCENARIO);\n+            menuItemManageScenario.addActionListener(this);\n+            rightClickMenu.add(menuItemManageScenario);\n+        }\n+        \n+        if ((currentTrack != null) && currentTrack.getAssignedCoordForces().containsKey(coords)) {\n+            for (int forceID : currentTrack.getAssignedCoordForces().get(coords)) {\n+                String forceName = campaign.getForce(forceID).getName();\n+                \n+                JCheckBoxMenuItem stickyForceItem = new JCheckBoxMenuItem();\n+                stickyForceItem.setText(String.format(\"%s - remain deployed\", forceName));\n+                stickyForceItem.setActionCommand(RCLICK_COMMAND_STICKY_FORCE);\n+                stickyForceItem.putClientProperty(RCLICK_COMMAND_STICKY_FORCE_ID, forceID);\n+                stickyForceItem.addActionListener(this);\n+                stickyForceItem.setSelected(currentTrack.getStickyForces().contains(forceID));\n+                rightClickMenu.add(stickyForceItem);\n+            }\n+        }\n+            \n+        if ((currentTrack != null) && campaign.isGM()) {\n+            rightClickMenu.addSeparator();\n+            \n+            menuItemGMReveal = new JMenuItem();\n+            menuItemGMReveal.setText(currentTrack.isGmRevealed() ? \"Hide Track\" : \"Reveal Track\");\n+            menuItemGMReveal.setActionCommand(RCLICK_COMMAND_REVEAL_TRACK);\n+            menuItemGMReveal.addActionListener(this);\n+            rightClickMenu.add(menuItemGMReveal);\n+        }\n+    }\n+\n+    /**\n+     * Renders the panel, hexes, forces, facilities and all that.\n+     */\n+    @Override\n+    public void paintComponent(Graphics g) {\n+        super.paintComponent(g);\n+        if (campaignState == null || currentTrack == null) {\n+            return;\n+        }\n+        \n+        numIconsInHex.clear();\n+\n+        Graphics2D g2D = (Graphics2D) g;\n+        AffineTransform initialTransform = g2D.getTransform();\n+        performInitialTransform(g2D);\n+        AffineTransform originTransform = g2D.getTransform();\n+\n+        drawHexes(g2D, DrawHexType.Hex);\n+        g2D.setTransform(originTransform);\n+        drawHexes(g2D, DrawHexType.Outline);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawScenarios(g2D);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawFacilities(g2D);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawForces(g2D);\n+\n+        g2D.setTransform(initialTransform);\n+        if (clickedPoint != null) {\n+            g2D.setColor(Color.BLUE);\n+            g2D.drawRect((int) clickedPoint.getX(), (int) clickedPoint.getY(), 2, 2);\n+        }\n+    }\n+\n+    /**\n+     * This method contains a dirty secret hack, but I forget what it is.\n+     * The point of it is to draw all the hexes for the board. \n+     * If it's a \"dry run\", we don't actually draw the hexes, we just pretend to\n+     * until we \"draw\" one that encompasses the clicked point.\n+     * @param g2D - graphics object on which to draw\n+     * @param drawHexType - whether to draw the hex backgrounds, hex outlines or a dry run for click detection\n+     */\n+    private boolean drawHexes(Graphics2D g2D, DrawHexType drawHexType) {\n+        Polygon graphHex = new Polygon();\n+        int xRadius = HEX_X_RADIUS;\n+        int yRadius = HEX_Y_RADIUS;\n+        boolean pointFound = false;\n+\n+        graphHex.addPoint(-xRadius/2, -yRadius);\n+        graphHex.addPoint(-xRadius, 0);\n+        graphHex.addPoint(-xRadius/2, yRadius);\n+        graphHex.addPoint(xRadius/2, yRadius);\n+        graphHex.addPoint(xRadius, 0);\n+        graphHex.addPoint(xRadius/2, -yRadius);\n+\n+        graphHex.translate(xRadius, yRadius);\n+\n+        Point translatedClickedPoint = null;\n+\n+        // this was derived somewhat experimentally\n+        // the clicked point always seems a little off, so we \n+        // a) apply the current transform to it, prior to drawing all the hexes\n+        // b) subtract an additional Y_RADIUS x 2 (Y_DIAMETER)\n+        // this gets us the point within the clicked hex\n+        // it's probably finicky, so any major changes to the rendering mechanism will likely break the detection\n+        if (clickedPoint != null) {\n+            translatedClickedPoint = (Point) clickedPoint.clone();\n+            \n+            // since we have the possibility of scrolling, we need to convert the on-screen clicked coordinates\n+            // to on-board coordinates. Thankfully, SwingUtilities provides the main computational ability for that\n+            Point actualPanelPoint = SwingUtilities.convertPoint(this, translatedClickedPoint, this.getParent());\n+            translatedClickedPoint.translate((int) -(actualPanelPoint.getX() - translatedClickedPoint.getX()), \n+                                                (int) -(actualPanelPoint.getY() - translatedClickedPoint.getY()));\n+            \n+            // now we translate to the starting point of where we're drawing and then go down a hex\n+            translatedClickedPoint.translate((int) g2D.getTransform().getTranslateX(), (int) g2D.getTransform().getTranslateY());\n+            translatedClickedPoint.translate(0, -(HEX_Y_RADIUS * 2));\n+        }\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                if(drawHexType == DrawHexType.Outline) {\n+                    g2D.setColor(new Color(0, 0, 0));\n+                    g2D.drawPolygon(graphHex);                    \n+                } else if (drawHexType == DrawHexType.Hex) {\n+                    \n+                    if (currentTrack.coordsRevealed(x, y) || currentTrack.isGmRevealed()) {\n+                        g2D.setColor(Color.LIGHT_GRAY);\n+                    } else {\n+                        g2D.setColor(Color.DARK_GRAY);\n+                    }\n+                    g2D.fillPolygon(graphHex);\n+                    \n+                    if (translatedClickedPoint != null && graphHex.contains(translatedClickedPoint)) {", "originalCommit": "796b6728fd3cd2aea02d17122b4d735afc47dc41", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjkwMTc1OQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r602901759", "bodyText": "Brackets", "author": "Windchild292", "createdAt": "2021-03-28T16:44:47Z", "path": "MekHQ/src/mekhq/gui/StratconPanel.java", "diffHunk": "@@ -0,0 +1,672 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.gui;\n+\n+import java.awt.BasicStroke;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Point;\n+import java.awt.Polygon;\n+import java.awt.Stroke;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.awt.geom.AffineTransform;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import javax.swing.JCheckBoxMenuItem;\n+import javax.swing.JLabel;\n+import javax.swing.JMenuItem;\n+import javax.swing.JPanel;\n+import javax.swing.JPopupMenu;\n+import javax.swing.SwingUtilities;\n+\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.stratcon.StratconCampaignState;\n+import mekhq.campaign.stratcon.StratconCoords;\n+import mekhq.campaign.stratcon.StratconFacility;\n+import mekhq.campaign.stratcon.StratconScenario;\n+import mekhq.campaign.stratcon.StratconTrackState;\n+import mekhq.gui.stratcon.StratconScenarioWizard;\n+import mekhq.gui.stratcon.TrackForceAssignmentUI;\n+\n+/**\n+ * This panel handles AtB-Stratcon GUI interactions with a specific scenario track.\n+ * @author NickAragua\n+ */\n+public class StratconPanel extends JPanel implements ActionListener {\n+    /**\n+     * \n+     */\n+    private static final long serialVersionUID = 7405934788894417292L;\n+    \n+    public static final int HEX_X_RADIUS = 42;\n+    public static final int HEX_Y_RADIUS = 37;\n+    \n+    private static final String RCLICK_COMMAND_MANAGE_FORCES = \"ManageForces\";\n+    private static final String RCLICK_COMMAND_MANAGE_SCENARIO = \"ManageScenario\";\n+    private static final String RCLICK_COMMAND_REVEAL_TRACK = \"RevealTrack\";\n+    private static final String RCLICK_COMMAND_STICKY_FORCE = \"StickyForce\";\n+    private static final String RCLICK_COMMAND_STICKY_FORCE_ID = \"StickyForceID\";\n+\n+    /**\n+     * What to do when drawing a hex\n+     */\n+    private enum DrawHexType {\n+        /**\n+         * The interior of a hex\n+         */\n+        Hex,\n+        \n+        /**\n+         * The outline of a hex\n+         */\n+        Outline,\n+        \n+        /**\n+         * Pretend we're drawing a hex, but don't actually do it, useful for \n+         * figuring out which hex a mouse click landed in, etc.\n+         */\n+        Dryrun\n+    }\n+\n+    private float scale = 1f;\n+\n+    private StratconTrackState currentTrack;\n+    private StratconCampaignState campaignState;\n+    private Campaign campaign;\n+\n+    private BoardState boardState = new BoardState();\n+\n+    private Point clickedPoint;\n+    private JPopupMenu rightClickMenu;\n+    private JMenuItem menuItemManageForceAssignments;\n+    private JMenuItem menuItemManageScenario;\n+    private JMenuItem menuItemGMReveal;\n+    \n+    // data structure holding how many unit/scenario/base icons have been drawn in the hex\n+    // used to control how low the text description goes.\n+    private Map<StratconCoords, Integer> numIconsInHex = new HashMap<>();\n+    \n+    private StratconScenarioWizard scenarioWizard;\n+    private TrackForceAssignmentUI assignmentUI;\n+    \n+    private JLabel infoArea;\n+\n+    /**\n+     * Constructs a StratconPanel instance, given a parent campaign GUI and a pointer to an info area.\n+     */\n+    StratconPanel(CampaignGUI gui, JLabel infoArea) {\n+        campaign = gui.getCampaign();\n+        scenarioWizard = new StratconScenarioWizard(campaign);\n+        this.infoArea = infoArea;\n+        \n+        assignmentUI = new TrackForceAssignmentUI(this);\n+        assignmentUI.setVisible(false);\n+        \n+        addMouseListener(new MouseAdapter() {\n+            @Override\n+            public void mouseReleased(MouseEvent e) {\n+                mouseReleasedHandler(e);\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Handler for when a specific track is selected - switches rendering to that track.\n+     */\n+    public void selectTrack(StratconCampaignState campaignState, StratconTrackState track) {\n+        this.campaignState = campaignState;\n+        currentTrack = track;\n+        repaint();\n+    }\n+    \n+    /**\n+     * Constructs the right-click context menu, optionally for a scenario\n+     */\n+    private void buildRightClickMenu(StratconCoords coords) {\n+        rightClickMenu = new JPopupMenu();\n+        \n+        StratconScenario scenario = getSelectedScenario();\n+        \n+        if (scenario == null) {\n+            menuItemManageForceAssignments = new JMenuItem();\n+            menuItemManageForceAssignments.setText(\"Manage Force Assignments\");\n+            menuItemManageForceAssignments.setActionCommand(RCLICK_COMMAND_MANAGE_FORCES);\n+            menuItemManageForceAssignments.addActionListener(this);\n+            rightClickMenu.add(menuItemManageForceAssignments);\n+        }\n+        \n+        if (scenario != null) {\n+            menuItemManageScenario = new JMenuItem();\n+            menuItemManageScenario.setText(\"Manage Scenario\");\n+            menuItemManageScenario.setActionCommand(RCLICK_COMMAND_MANAGE_SCENARIO);\n+            menuItemManageScenario.addActionListener(this);\n+            rightClickMenu.add(menuItemManageScenario);\n+        }\n+        \n+        if ((currentTrack != null) && currentTrack.getAssignedCoordForces().containsKey(coords)) {\n+            for (int forceID : currentTrack.getAssignedCoordForces().get(coords)) {\n+                String forceName = campaign.getForce(forceID).getName();\n+                \n+                JCheckBoxMenuItem stickyForceItem = new JCheckBoxMenuItem();\n+                stickyForceItem.setText(String.format(\"%s - remain deployed\", forceName));\n+                stickyForceItem.setActionCommand(RCLICK_COMMAND_STICKY_FORCE);\n+                stickyForceItem.putClientProperty(RCLICK_COMMAND_STICKY_FORCE_ID, forceID);\n+                stickyForceItem.addActionListener(this);\n+                stickyForceItem.setSelected(currentTrack.getStickyForces().contains(forceID));\n+                rightClickMenu.add(stickyForceItem);\n+            }\n+        }\n+            \n+        if ((currentTrack != null) && campaign.isGM()) {\n+            rightClickMenu.addSeparator();\n+            \n+            menuItemGMReveal = new JMenuItem();\n+            menuItemGMReveal.setText(currentTrack.isGmRevealed() ? \"Hide Track\" : \"Reveal Track\");\n+            menuItemGMReveal.setActionCommand(RCLICK_COMMAND_REVEAL_TRACK);\n+            menuItemGMReveal.addActionListener(this);\n+            rightClickMenu.add(menuItemGMReveal);\n+        }\n+    }\n+\n+    /**\n+     * Renders the panel, hexes, forces, facilities and all that.\n+     */\n+    @Override\n+    public void paintComponent(Graphics g) {\n+        super.paintComponent(g);\n+        if (campaignState == null || currentTrack == null) {\n+            return;\n+        }\n+        \n+        numIconsInHex.clear();\n+\n+        Graphics2D g2D = (Graphics2D) g;\n+        AffineTransform initialTransform = g2D.getTransform();\n+        performInitialTransform(g2D);\n+        AffineTransform originTransform = g2D.getTransform();\n+\n+        drawHexes(g2D, DrawHexType.Hex);\n+        g2D.setTransform(originTransform);\n+        drawHexes(g2D, DrawHexType.Outline);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawScenarios(g2D);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawFacilities(g2D);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawForces(g2D);\n+\n+        g2D.setTransform(initialTransform);\n+        if (clickedPoint != null) {\n+            g2D.setColor(Color.BLUE);\n+            g2D.drawRect((int) clickedPoint.getX(), (int) clickedPoint.getY(), 2, 2);\n+        }\n+    }\n+\n+    /**\n+     * This method contains a dirty secret hack, but I forget what it is.\n+     * The point of it is to draw all the hexes for the board. \n+     * If it's a \"dry run\", we don't actually draw the hexes, we just pretend to\n+     * until we \"draw\" one that encompasses the clicked point.\n+     * @param g2D - graphics object on which to draw\n+     * @param drawHexType - whether to draw the hex backgrounds, hex outlines or a dry run for click detection\n+     */\n+    private boolean drawHexes(Graphics2D g2D, DrawHexType drawHexType) {\n+        Polygon graphHex = new Polygon();\n+        int xRadius = HEX_X_RADIUS;\n+        int yRadius = HEX_Y_RADIUS;\n+        boolean pointFound = false;\n+\n+        graphHex.addPoint(-xRadius/2, -yRadius);\n+        graphHex.addPoint(-xRadius, 0);\n+        graphHex.addPoint(-xRadius/2, yRadius);\n+        graphHex.addPoint(xRadius/2, yRadius);\n+        graphHex.addPoint(xRadius, 0);\n+        graphHex.addPoint(xRadius/2, -yRadius);\n+\n+        graphHex.translate(xRadius, yRadius);\n+\n+        Point translatedClickedPoint = null;\n+\n+        // this was derived somewhat experimentally\n+        // the clicked point always seems a little off, so we \n+        // a) apply the current transform to it, prior to drawing all the hexes\n+        // b) subtract an additional Y_RADIUS x 2 (Y_DIAMETER)\n+        // this gets us the point within the clicked hex\n+        // it's probably finicky, so any major changes to the rendering mechanism will likely break the detection\n+        if (clickedPoint != null) {\n+            translatedClickedPoint = (Point) clickedPoint.clone();\n+            \n+            // since we have the possibility of scrolling, we need to convert the on-screen clicked coordinates\n+            // to on-board coordinates. Thankfully, SwingUtilities provides the main computational ability for that\n+            Point actualPanelPoint = SwingUtilities.convertPoint(this, translatedClickedPoint, this.getParent());\n+            translatedClickedPoint.translate((int) -(actualPanelPoint.getX() - translatedClickedPoint.getX()), \n+                                                (int) -(actualPanelPoint.getY() - translatedClickedPoint.getY()));\n+            \n+            // now we translate to the starting point of where we're drawing and then go down a hex\n+            translatedClickedPoint.translate((int) g2D.getTransform().getTranslateX(), (int) g2D.getTransform().getTranslateY());\n+            translatedClickedPoint.translate(0, -(HEX_Y_RADIUS * 2));\n+        }\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                if(drawHexType == DrawHexType.Outline) {\n+                    g2D.setColor(new Color(0, 0, 0));\n+                    g2D.drawPolygon(graphHex);                    \n+                } else if (drawHexType == DrawHexType.Hex) {\n+                    \n+                    if (currentTrack.coordsRevealed(x, y) || currentTrack.isGmRevealed()) {\n+                        g2D.setColor(Color.LIGHT_GRAY);\n+                    } else {\n+                        g2D.setColor(Color.DARK_GRAY);\n+                    }\n+                    g2D.fillPolygon(graphHex);\n+                    \n+                    if (translatedClickedPoint != null && graphHex.contains(translatedClickedPoint)) {\n+                        g2D.setColor(Color.WHITE);\n+                        BasicStroke s = new BasicStroke((float) 8.0);\n+                        Stroke push = g2D.getStroke();\n+                        g2D.setStroke(s);\n+                        g2D.drawPolygon(graphHex);\n+                        \n+                        boardState.selectedX = x;\n+                        boardState.selectedY = y;\n+                        pointFound = true;\n+                        g2D.setStroke(push);\n+                    }\n+                } else if (drawHexType == DrawHexType.Dryrun) {\n+                    if (translatedClickedPoint != null && graphHex.contains(translatedClickedPoint)) {", "originalCommit": "796b6728fd3cd2aea02d17122b4d735afc47dc41", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjkwMTg2Nw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r602901867", "bodyText": "I'd guess the comment from 253-259 covers it?", "author": "Windchild292", "createdAt": "2021-03-28T16:45:35Z", "path": "MekHQ/src/mekhq/gui/StratconPanel.java", "diffHunk": "@@ -0,0 +1,672 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.gui;\n+\n+import java.awt.BasicStroke;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Point;\n+import java.awt.Polygon;\n+import java.awt.Stroke;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.awt.geom.AffineTransform;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import javax.swing.JCheckBoxMenuItem;\n+import javax.swing.JLabel;\n+import javax.swing.JMenuItem;\n+import javax.swing.JPanel;\n+import javax.swing.JPopupMenu;\n+import javax.swing.SwingUtilities;\n+\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.stratcon.StratconCampaignState;\n+import mekhq.campaign.stratcon.StratconCoords;\n+import mekhq.campaign.stratcon.StratconFacility;\n+import mekhq.campaign.stratcon.StratconScenario;\n+import mekhq.campaign.stratcon.StratconTrackState;\n+import mekhq.gui.stratcon.StratconScenarioWizard;\n+import mekhq.gui.stratcon.TrackForceAssignmentUI;\n+\n+/**\n+ * This panel handles AtB-Stratcon GUI interactions with a specific scenario track.\n+ * @author NickAragua\n+ */\n+public class StratconPanel extends JPanel implements ActionListener {\n+    /**\n+     * \n+     */\n+    private static final long serialVersionUID = 7405934788894417292L;\n+    \n+    public static final int HEX_X_RADIUS = 42;\n+    public static final int HEX_Y_RADIUS = 37;\n+    \n+    private static final String RCLICK_COMMAND_MANAGE_FORCES = \"ManageForces\";\n+    private static final String RCLICK_COMMAND_MANAGE_SCENARIO = \"ManageScenario\";\n+    private static final String RCLICK_COMMAND_REVEAL_TRACK = \"RevealTrack\";\n+    private static final String RCLICK_COMMAND_STICKY_FORCE = \"StickyForce\";\n+    private static final String RCLICK_COMMAND_STICKY_FORCE_ID = \"StickyForceID\";\n+\n+    /**\n+     * What to do when drawing a hex\n+     */\n+    private enum DrawHexType {\n+        /**\n+         * The interior of a hex\n+         */\n+        Hex,\n+        \n+        /**\n+         * The outline of a hex\n+         */\n+        Outline,\n+        \n+        /**\n+         * Pretend we're drawing a hex, but don't actually do it, useful for \n+         * figuring out which hex a mouse click landed in, etc.\n+         */\n+        Dryrun\n+    }\n+\n+    private float scale = 1f;\n+\n+    private StratconTrackState currentTrack;\n+    private StratconCampaignState campaignState;\n+    private Campaign campaign;\n+\n+    private BoardState boardState = new BoardState();\n+\n+    private Point clickedPoint;\n+    private JPopupMenu rightClickMenu;\n+    private JMenuItem menuItemManageForceAssignments;\n+    private JMenuItem menuItemManageScenario;\n+    private JMenuItem menuItemGMReveal;\n+    \n+    // data structure holding how many unit/scenario/base icons have been drawn in the hex\n+    // used to control how low the text description goes.\n+    private Map<StratconCoords, Integer> numIconsInHex = new HashMap<>();\n+    \n+    private StratconScenarioWizard scenarioWizard;\n+    private TrackForceAssignmentUI assignmentUI;\n+    \n+    private JLabel infoArea;\n+\n+    /**\n+     * Constructs a StratconPanel instance, given a parent campaign GUI and a pointer to an info area.\n+     */\n+    StratconPanel(CampaignGUI gui, JLabel infoArea) {\n+        campaign = gui.getCampaign();\n+        scenarioWizard = new StratconScenarioWizard(campaign);\n+        this.infoArea = infoArea;\n+        \n+        assignmentUI = new TrackForceAssignmentUI(this);\n+        assignmentUI.setVisible(false);\n+        \n+        addMouseListener(new MouseAdapter() {\n+            @Override\n+            public void mouseReleased(MouseEvent e) {\n+                mouseReleasedHandler(e);\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Handler for when a specific track is selected - switches rendering to that track.\n+     */\n+    public void selectTrack(StratconCampaignState campaignState, StratconTrackState track) {\n+        this.campaignState = campaignState;\n+        currentTrack = track;\n+        repaint();\n+    }\n+    \n+    /**\n+     * Constructs the right-click context menu, optionally for a scenario\n+     */\n+    private void buildRightClickMenu(StratconCoords coords) {\n+        rightClickMenu = new JPopupMenu();\n+        \n+        StratconScenario scenario = getSelectedScenario();\n+        \n+        if (scenario == null) {\n+            menuItemManageForceAssignments = new JMenuItem();\n+            menuItemManageForceAssignments.setText(\"Manage Force Assignments\");\n+            menuItemManageForceAssignments.setActionCommand(RCLICK_COMMAND_MANAGE_FORCES);\n+            menuItemManageForceAssignments.addActionListener(this);\n+            rightClickMenu.add(menuItemManageForceAssignments);\n+        }\n+        \n+        if (scenario != null) {\n+            menuItemManageScenario = new JMenuItem();\n+            menuItemManageScenario.setText(\"Manage Scenario\");\n+            menuItemManageScenario.setActionCommand(RCLICK_COMMAND_MANAGE_SCENARIO);\n+            menuItemManageScenario.addActionListener(this);\n+            rightClickMenu.add(menuItemManageScenario);\n+        }\n+        \n+        if ((currentTrack != null) && currentTrack.getAssignedCoordForces().containsKey(coords)) {\n+            for (int forceID : currentTrack.getAssignedCoordForces().get(coords)) {\n+                String forceName = campaign.getForce(forceID).getName();\n+                \n+                JCheckBoxMenuItem stickyForceItem = new JCheckBoxMenuItem();\n+                stickyForceItem.setText(String.format(\"%s - remain deployed\", forceName));\n+                stickyForceItem.setActionCommand(RCLICK_COMMAND_STICKY_FORCE);\n+                stickyForceItem.putClientProperty(RCLICK_COMMAND_STICKY_FORCE_ID, forceID);\n+                stickyForceItem.addActionListener(this);\n+                stickyForceItem.setSelected(currentTrack.getStickyForces().contains(forceID));\n+                rightClickMenu.add(stickyForceItem);\n+            }\n+        }\n+            \n+        if ((currentTrack != null) && campaign.isGM()) {\n+            rightClickMenu.addSeparator();\n+            \n+            menuItemGMReveal = new JMenuItem();\n+            menuItemGMReveal.setText(currentTrack.isGmRevealed() ? \"Hide Track\" : \"Reveal Track\");\n+            menuItemGMReveal.setActionCommand(RCLICK_COMMAND_REVEAL_TRACK);\n+            menuItemGMReveal.addActionListener(this);\n+            rightClickMenu.add(menuItemGMReveal);\n+        }\n+    }\n+\n+    /**\n+     * Renders the panel, hexes, forces, facilities and all that.\n+     */\n+    @Override\n+    public void paintComponent(Graphics g) {\n+        super.paintComponent(g);\n+        if (campaignState == null || currentTrack == null) {\n+            return;\n+        }\n+        \n+        numIconsInHex.clear();\n+\n+        Graphics2D g2D = (Graphics2D) g;\n+        AffineTransform initialTransform = g2D.getTransform();\n+        performInitialTransform(g2D);\n+        AffineTransform originTransform = g2D.getTransform();\n+\n+        drawHexes(g2D, DrawHexType.Hex);\n+        g2D.setTransform(originTransform);\n+        drawHexes(g2D, DrawHexType.Outline);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawScenarios(g2D);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawFacilities(g2D);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawForces(g2D);\n+\n+        g2D.setTransform(initialTransform);\n+        if (clickedPoint != null) {\n+            g2D.setColor(Color.BLUE);\n+            g2D.drawRect((int) clickedPoint.getX(), (int) clickedPoint.getY(), 2, 2);\n+        }\n+    }\n+\n+    /**\n+     * This method contains a dirty secret hack, but I forget what it is.", "originalCommit": "796b6728fd3cd2aea02d17122b4d735afc47dc41", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjkwMTk2OA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r602901968", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                if(currentTrack.getFacility(currentCoords) == null) {\n          \n          \n            \n                                if (currentTrack.getFacility(currentCoords) == null) {", "author": "Windchild292", "createdAt": "2021-03-28T16:46:22Z", "path": "MekHQ/src/mekhq/gui/StratconPanel.java", "diffHunk": "@@ -0,0 +1,672 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.gui;\n+\n+import java.awt.BasicStroke;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Point;\n+import java.awt.Polygon;\n+import java.awt.Stroke;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.awt.geom.AffineTransform;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import javax.swing.JCheckBoxMenuItem;\n+import javax.swing.JLabel;\n+import javax.swing.JMenuItem;\n+import javax.swing.JPanel;\n+import javax.swing.JPopupMenu;\n+import javax.swing.SwingUtilities;\n+\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.stratcon.StratconCampaignState;\n+import mekhq.campaign.stratcon.StratconCoords;\n+import mekhq.campaign.stratcon.StratconFacility;\n+import mekhq.campaign.stratcon.StratconScenario;\n+import mekhq.campaign.stratcon.StratconTrackState;\n+import mekhq.gui.stratcon.StratconScenarioWizard;\n+import mekhq.gui.stratcon.TrackForceAssignmentUI;\n+\n+/**\n+ * This panel handles AtB-Stratcon GUI interactions with a specific scenario track.\n+ * @author NickAragua\n+ */\n+public class StratconPanel extends JPanel implements ActionListener {\n+    /**\n+     * \n+     */\n+    private static final long serialVersionUID = 7405934788894417292L;\n+    \n+    public static final int HEX_X_RADIUS = 42;\n+    public static final int HEX_Y_RADIUS = 37;\n+    \n+    private static final String RCLICK_COMMAND_MANAGE_FORCES = \"ManageForces\";\n+    private static final String RCLICK_COMMAND_MANAGE_SCENARIO = \"ManageScenario\";\n+    private static final String RCLICK_COMMAND_REVEAL_TRACK = \"RevealTrack\";\n+    private static final String RCLICK_COMMAND_STICKY_FORCE = \"StickyForce\";\n+    private static final String RCLICK_COMMAND_STICKY_FORCE_ID = \"StickyForceID\";\n+\n+    /**\n+     * What to do when drawing a hex\n+     */\n+    private enum DrawHexType {\n+        /**\n+         * The interior of a hex\n+         */\n+        Hex,\n+        \n+        /**\n+         * The outline of a hex\n+         */\n+        Outline,\n+        \n+        /**\n+         * Pretend we're drawing a hex, but don't actually do it, useful for \n+         * figuring out which hex a mouse click landed in, etc.\n+         */\n+        Dryrun\n+    }\n+\n+    private float scale = 1f;\n+\n+    private StratconTrackState currentTrack;\n+    private StratconCampaignState campaignState;\n+    private Campaign campaign;\n+\n+    private BoardState boardState = new BoardState();\n+\n+    private Point clickedPoint;\n+    private JPopupMenu rightClickMenu;\n+    private JMenuItem menuItemManageForceAssignments;\n+    private JMenuItem menuItemManageScenario;\n+    private JMenuItem menuItemGMReveal;\n+    \n+    // data structure holding how many unit/scenario/base icons have been drawn in the hex\n+    // used to control how low the text description goes.\n+    private Map<StratconCoords, Integer> numIconsInHex = new HashMap<>();\n+    \n+    private StratconScenarioWizard scenarioWizard;\n+    private TrackForceAssignmentUI assignmentUI;\n+    \n+    private JLabel infoArea;\n+\n+    /**\n+     * Constructs a StratconPanel instance, given a parent campaign GUI and a pointer to an info area.\n+     */\n+    StratconPanel(CampaignGUI gui, JLabel infoArea) {\n+        campaign = gui.getCampaign();\n+        scenarioWizard = new StratconScenarioWizard(campaign);\n+        this.infoArea = infoArea;\n+        \n+        assignmentUI = new TrackForceAssignmentUI(this);\n+        assignmentUI.setVisible(false);\n+        \n+        addMouseListener(new MouseAdapter() {\n+            @Override\n+            public void mouseReleased(MouseEvent e) {\n+                mouseReleasedHandler(e);\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Handler for when a specific track is selected - switches rendering to that track.\n+     */\n+    public void selectTrack(StratconCampaignState campaignState, StratconTrackState track) {\n+        this.campaignState = campaignState;\n+        currentTrack = track;\n+        repaint();\n+    }\n+    \n+    /**\n+     * Constructs the right-click context menu, optionally for a scenario\n+     */\n+    private void buildRightClickMenu(StratconCoords coords) {\n+        rightClickMenu = new JPopupMenu();\n+        \n+        StratconScenario scenario = getSelectedScenario();\n+        \n+        if (scenario == null) {\n+            menuItemManageForceAssignments = new JMenuItem();\n+            menuItemManageForceAssignments.setText(\"Manage Force Assignments\");\n+            menuItemManageForceAssignments.setActionCommand(RCLICK_COMMAND_MANAGE_FORCES);\n+            menuItemManageForceAssignments.addActionListener(this);\n+            rightClickMenu.add(menuItemManageForceAssignments);\n+        }\n+        \n+        if (scenario != null) {\n+            menuItemManageScenario = new JMenuItem();\n+            menuItemManageScenario.setText(\"Manage Scenario\");\n+            menuItemManageScenario.setActionCommand(RCLICK_COMMAND_MANAGE_SCENARIO);\n+            menuItemManageScenario.addActionListener(this);\n+            rightClickMenu.add(menuItemManageScenario);\n+        }\n+        \n+        if ((currentTrack != null) && currentTrack.getAssignedCoordForces().containsKey(coords)) {\n+            for (int forceID : currentTrack.getAssignedCoordForces().get(coords)) {\n+                String forceName = campaign.getForce(forceID).getName();\n+                \n+                JCheckBoxMenuItem stickyForceItem = new JCheckBoxMenuItem();\n+                stickyForceItem.setText(String.format(\"%s - remain deployed\", forceName));\n+                stickyForceItem.setActionCommand(RCLICK_COMMAND_STICKY_FORCE);\n+                stickyForceItem.putClientProperty(RCLICK_COMMAND_STICKY_FORCE_ID, forceID);\n+                stickyForceItem.addActionListener(this);\n+                stickyForceItem.setSelected(currentTrack.getStickyForces().contains(forceID));\n+                rightClickMenu.add(stickyForceItem);\n+            }\n+        }\n+            \n+        if ((currentTrack != null) && campaign.isGM()) {\n+            rightClickMenu.addSeparator();\n+            \n+            menuItemGMReveal = new JMenuItem();\n+            menuItemGMReveal.setText(currentTrack.isGmRevealed() ? \"Hide Track\" : \"Reveal Track\");\n+            menuItemGMReveal.setActionCommand(RCLICK_COMMAND_REVEAL_TRACK);\n+            menuItemGMReveal.addActionListener(this);\n+            rightClickMenu.add(menuItemGMReveal);\n+        }\n+    }\n+\n+    /**\n+     * Renders the panel, hexes, forces, facilities and all that.\n+     */\n+    @Override\n+    public void paintComponent(Graphics g) {\n+        super.paintComponent(g);\n+        if (campaignState == null || currentTrack == null) {\n+            return;\n+        }\n+        \n+        numIconsInHex.clear();\n+\n+        Graphics2D g2D = (Graphics2D) g;\n+        AffineTransform initialTransform = g2D.getTransform();\n+        performInitialTransform(g2D);\n+        AffineTransform originTransform = g2D.getTransform();\n+\n+        drawHexes(g2D, DrawHexType.Hex);\n+        g2D.setTransform(originTransform);\n+        drawHexes(g2D, DrawHexType.Outline);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawScenarios(g2D);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawFacilities(g2D);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawForces(g2D);\n+\n+        g2D.setTransform(initialTransform);\n+        if (clickedPoint != null) {\n+            g2D.setColor(Color.BLUE);\n+            g2D.drawRect((int) clickedPoint.getX(), (int) clickedPoint.getY(), 2, 2);\n+        }\n+    }\n+\n+    /**\n+     * This method contains a dirty secret hack, but I forget what it is.\n+     * The point of it is to draw all the hexes for the board. \n+     * If it's a \"dry run\", we don't actually draw the hexes, we just pretend to\n+     * until we \"draw\" one that encompasses the clicked point.\n+     * @param g2D - graphics object on which to draw\n+     * @param drawHexType - whether to draw the hex backgrounds, hex outlines or a dry run for click detection\n+     */\n+    private boolean drawHexes(Graphics2D g2D, DrawHexType drawHexType) {\n+        Polygon graphHex = new Polygon();\n+        int xRadius = HEX_X_RADIUS;\n+        int yRadius = HEX_Y_RADIUS;\n+        boolean pointFound = false;\n+\n+        graphHex.addPoint(-xRadius/2, -yRadius);\n+        graphHex.addPoint(-xRadius, 0);\n+        graphHex.addPoint(-xRadius/2, yRadius);\n+        graphHex.addPoint(xRadius/2, yRadius);\n+        graphHex.addPoint(xRadius, 0);\n+        graphHex.addPoint(xRadius/2, -yRadius);\n+\n+        graphHex.translate(xRadius, yRadius);\n+\n+        Point translatedClickedPoint = null;\n+\n+        // this was derived somewhat experimentally\n+        // the clicked point always seems a little off, so we \n+        // a) apply the current transform to it, prior to drawing all the hexes\n+        // b) subtract an additional Y_RADIUS x 2 (Y_DIAMETER)\n+        // this gets us the point within the clicked hex\n+        // it's probably finicky, so any major changes to the rendering mechanism will likely break the detection\n+        if (clickedPoint != null) {\n+            translatedClickedPoint = (Point) clickedPoint.clone();\n+            \n+            // since we have the possibility of scrolling, we need to convert the on-screen clicked coordinates\n+            // to on-board coordinates. Thankfully, SwingUtilities provides the main computational ability for that\n+            Point actualPanelPoint = SwingUtilities.convertPoint(this, translatedClickedPoint, this.getParent());\n+            translatedClickedPoint.translate((int) -(actualPanelPoint.getX() - translatedClickedPoint.getX()), \n+                                                (int) -(actualPanelPoint.getY() - translatedClickedPoint.getY()));\n+            \n+            // now we translate to the starting point of where we're drawing and then go down a hex\n+            translatedClickedPoint.translate((int) g2D.getTransform().getTranslateX(), (int) g2D.getTransform().getTranslateY());\n+            translatedClickedPoint.translate(0, -(HEX_Y_RADIUS * 2));\n+        }\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                if(drawHexType == DrawHexType.Outline) {\n+                    g2D.setColor(new Color(0, 0, 0));\n+                    g2D.drawPolygon(graphHex);                    \n+                } else if (drawHexType == DrawHexType.Hex) {\n+                    \n+                    if (currentTrack.coordsRevealed(x, y) || currentTrack.isGmRevealed()) {\n+                        g2D.setColor(Color.LIGHT_GRAY);\n+                    } else {\n+                        g2D.setColor(Color.DARK_GRAY);\n+                    }\n+                    g2D.fillPolygon(graphHex);\n+                    \n+                    if (translatedClickedPoint != null && graphHex.contains(translatedClickedPoint)) {\n+                        g2D.setColor(Color.WHITE);\n+                        BasicStroke s = new BasicStroke((float) 8.0);\n+                        Stroke push = g2D.getStroke();\n+                        g2D.setStroke(s);\n+                        g2D.drawPolygon(graphHex);\n+                        \n+                        boardState.selectedX = x;\n+                        boardState.selectedY = y;\n+                        pointFound = true;\n+                        g2D.setStroke(push);\n+                    }\n+                } else if (drawHexType == DrawHexType.Dryrun) {\n+                    if (translatedClickedPoint != null && graphHex.contains(translatedClickedPoint)) {\n+                        boardState.selectedX = x;\n+                        boardState.selectedY = y;\n+                        pointFound = true;\n+                    }\n+                }\n+\n+                if (drawHexType == DrawHexType.Hex) {\n+                    g2D.setColor(Color.GREEN);\n+                    g2D.drawString(x + \",\" + y, graphHex.xpoints[0] + (xRadius / 4), graphHex.ypoints[0] + yRadius);\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                graphHex.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            graphHex.translate(translationVector[0], translationVector[1]);\n+        }\n+\n+        return pointFound;\n+    }\n+\n+    /**\n+     * Worker function to render icons representing scenarios to the given surface.\n+     */\n+    private void drawScenarios(Graphics2D g2D) {\n+        Polygon scenarioMarker = new Polygon();\n+        int xRadius = HEX_X_RADIUS / 3;\n+        int yRadius = HEX_Y_RADIUS / 3;\n+\n+        scenarioMarker.addPoint(-xRadius, -yRadius);\n+        scenarioMarker.addPoint(-xRadius, yRadius);\n+        scenarioMarker.addPoint(xRadius, yRadius);\n+        scenarioMarker.addPoint(xRadius, -yRadius);\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                StratconCoords currentCoords = new StratconCoords(x, y);\n+                StratconScenario scenario = currentTrack.getScenario(currentCoords);\n+                \n+                // if there's a scenario here that has a deployment/battle date\n+                // or if there's a scenario here and we've gm-revealed everything\n+                if ((scenario != null) &&\n+                        ((scenario.getDeploymentDate() != null) || currentTrack.isGmRevealed())) {\n+                    g2D.setColor(Color.RED);\n+                    g2D.drawPolygon(scenarioMarker);\n+                    if(currentTrack.getFacility(currentCoords) == null) {", "originalCommit": "796b6728fd3cd2aea02d17122b4d735afc47dc41", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjkwMjA2Nw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r602902067", "bodyText": "Could merge these two with ++verticalOffsetIndex", "author": "Windchild292", "createdAt": "2021-03-28T16:47:20Z", "path": "MekHQ/src/mekhq/gui/StratconPanel.java", "diffHunk": "@@ -0,0 +1,672 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.gui;\n+\n+import java.awt.BasicStroke;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Point;\n+import java.awt.Polygon;\n+import java.awt.Stroke;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.awt.geom.AffineTransform;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import javax.swing.JCheckBoxMenuItem;\n+import javax.swing.JLabel;\n+import javax.swing.JMenuItem;\n+import javax.swing.JPanel;\n+import javax.swing.JPopupMenu;\n+import javax.swing.SwingUtilities;\n+\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.stratcon.StratconCampaignState;\n+import mekhq.campaign.stratcon.StratconCoords;\n+import mekhq.campaign.stratcon.StratconFacility;\n+import mekhq.campaign.stratcon.StratconScenario;\n+import mekhq.campaign.stratcon.StratconTrackState;\n+import mekhq.gui.stratcon.StratconScenarioWizard;\n+import mekhq.gui.stratcon.TrackForceAssignmentUI;\n+\n+/**\n+ * This panel handles AtB-Stratcon GUI interactions with a specific scenario track.\n+ * @author NickAragua\n+ */\n+public class StratconPanel extends JPanel implements ActionListener {\n+    /**\n+     * \n+     */\n+    private static final long serialVersionUID = 7405934788894417292L;\n+    \n+    public static final int HEX_X_RADIUS = 42;\n+    public static final int HEX_Y_RADIUS = 37;\n+    \n+    private static final String RCLICK_COMMAND_MANAGE_FORCES = \"ManageForces\";\n+    private static final String RCLICK_COMMAND_MANAGE_SCENARIO = \"ManageScenario\";\n+    private static final String RCLICK_COMMAND_REVEAL_TRACK = \"RevealTrack\";\n+    private static final String RCLICK_COMMAND_STICKY_FORCE = \"StickyForce\";\n+    private static final String RCLICK_COMMAND_STICKY_FORCE_ID = \"StickyForceID\";\n+\n+    /**\n+     * What to do when drawing a hex\n+     */\n+    private enum DrawHexType {\n+        /**\n+         * The interior of a hex\n+         */\n+        Hex,\n+        \n+        /**\n+         * The outline of a hex\n+         */\n+        Outline,\n+        \n+        /**\n+         * Pretend we're drawing a hex, but don't actually do it, useful for \n+         * figuring out which hex a mouse click landed in, etc.\n+         */\n+        Dryrun\n+    }\n+\n+    private float scale = 1f;\n+\n+    private StratconTrackState currentTrack;\n+    private StratconCampaignState campaignState;\n+    private Campaign campaign;\n+\n+    private BoardState boardState = new BoardState();\n+\n+    private Point clickedPoint;\n+    private JPopupMenu rightClickMenu;\n+    private JMenuItem menuItemManageForceAssignments;\n+    private JMenuItem menuItemManageScenario;\n+    private JMenuItem menuItemGMReveal;\n+    \n+    // data structure holding how many unit/scenario/base icons have been drawn in the hex\n+    // used to control how low the text description goes.\n+    private Map<StratconCoords, Integer> numIconsInHex = new HashMap<>();\n+    \n+    private StratconScenarioWizard scenarioWizard;\n+    private TrackForceAssignmentUI assignmentUI;\n+    \n+    private JLabel infoArea;\n+\n+    /**\n+     * Constructs a StratconPanel instance, given a parent campaign GUI and a pointer to an info area.\n+     */\n+    StratconPanel(CampaignGUI gui, JLabel infoArea) {\n+        campaign = gui.getCampaign();\n+        scenarioWizard = new StratconScenarioWizard(campaign);\n+        this.infoArea = infoArea;\n+        \n+        assignmentUI = new TrackForceAssignmentUI(this);\n+        assignmentUI.setVisible(false);\n+        \n+        addMouseListener(new MouseAdapter() {\n+            @Override\n+            public void mouseReleased(MouseEvent e) {\n+                mouseReleasedHandler(e);\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Handler for when a specific track is selected - switches rendering to that track.\n+     */\n+    public void selectTrack(StratconCampaignState campaignState, StratconTrackState track) {\n+        this.campaignState = campaignState;\n+        currentTrack = track;\n+        repaint();\n+    }\n+    \n+    /**\n+     * Constructs the right-click context menu, optionally for a scenario\n+     */\n+    private void buildRightClickMenu(StratconCoords coords) {\n+        rightClickMenu = new JPopupMenu();\n+        \n+        StratconScenario scenario = getSelectedScenario();\n+        \n+        if (scenario == null) {\n+            menuItemManageForceAssignments = new JMenuItem();\n+            menuItemManageForceAssignments.setText(\"Manage Force Assignments\");\n+            menuItemManageForceAssignments.setActionCommand(RCLICK_COMMAND_MANAGE_FORCES);\n+            menuItemManageForceAssignments.addActionListener(this);\n+            rightClickMenu.add(menuItemManageForceAssignments);\n+        }\n+        \n+        if (scenario != null) {\n+            menuItemManageScenario = new JMenuItem();\n+            menuItemManageScenario.setText(\"Manage Scenario\");\n+            menuItemManageScenario.setActionCommand(RCLICK_COMMAND_MANAGE_SCENARIO);\n+            menuItemManageScenario.addActionListener(this);\n+            rightClickMenu.add(menuItemManageScenario);\n+        }\n+        \n+        if ((currentTrack != null) && currentTrack.getAssignedCoordForces().containsKey(coords)) {\n+            for (int forceID : currentTrack.getAssignedCoordForces().get(coords)) {\n+                String forceName = campaign.getForce(forceID).getName();\n+                \n+                JCheckBoxMenuItem stickyForceItem = new JCheckBoxMenuItem();\n+                stickyForceItem.setText(String.format(\"%s - remain deployed\", forceName));\n+                stickyForceItem.setActionCommand(RCLICK_COMMAND_STICKY_FORCE);\n+                stickyForceItem.putClientProperty(RCLICK_COMMAND_STICKY_FORCE_ID, forceID);\n+                stickyForceItem.addActionListener(this);\n+                stickyForceItem.setSelected(currentTrack.getStickyForces().contains(forceID));\n+                rightClickMenu.add(stickyForceItem);\n+            }\n+        }\n+            \n+        if ((currentTrack != null) && campaign.isGM()) {\n+            rightClickMenu.addSeparator();\n+            \n+            menuItemGMReveal = new JMenuItem();\n+            menuItemGMReveal.setText(currentTrack.isGmRevealed() ? \"Hide Track\" : \"Reveal Track\");\n+            menuItemGMReveal.setActionCommand(RCLICK_COMMAND_REVEAL_TRACK);\n+            menuItemGMReveal.addActionListener(this);\n+            rightClickMenu.add(menuItemGMReveal);\n+        }\n+    }\n+\n+    /**\n+     * Renders the panel, hexes, forces, facilities and all that.\n+     */\n+    @Override\n+    public void paintComponent(Graphics g) {\n+        super.paintComponent(g);\n+        if (campaignState == null || currentTrack == null) {\n+            return;\n+        }\n+        \n+        numIconsInHex.clear();\n+\n+        Graphics2D g2D = (Graphics2D) g;\n+        AffineTransform initialTransform = g2D.getTransform();\n+        performInitialTransform(g2D);\n+        AffineTransform originTransform = g2D.getTransform();\n+\n+        drawHexes(g2D, DrawHexType.Hex);\n+        g2D.setTransform(originTransform);\n+        drawHexes(g2D, DrawHexType.Outline);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawScenarios(g2D);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawFacilities(g2D);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawForces(g2D);\n+\n+        g2D.setTransform(initialTransform);\n+        if (clickedPoint != null) {\n+            g2D.setColor(Color.BLUE);\n+            g2D.drawRect((int) clickedPoint.getX(), (int) clickedPoint.getY(), 2, 2);\n+        }\n+    }\n+\n+    /**\n+     * This method contains a dirty secret hack, but I forget what it is.\n+     * The point of it is to draw all the hexes for the board. \n+     * If it's a \"dry run\", we don't actually draw the hexes, we just pretend to\n+     * until we \"draw\" one that encompasses the clicked point.\n+     * @param g2D - graphics object on which to draw\n+     * @param drawHexType - whether to draw the hex backgrounds, hex outlines or a dry run for click detection\n+     */\n+    private boolean drawHexes(Graphics2D g2D, DrawHexType drawHexType) {\n+        Polygon graphHex = new Polygon();\n+        int xRadius = HEX_X_RADIUS;\n+        int yRadius = HEX_Y_RADIUS;\n+        boolean pointFound = false;\n+\n+        graphHex.addPoint(-xRadius/2, -yRadius);\n+        graphHex.addPoint(-xRadius, 0);\n+        graphHex.addPoint(-xRadius/2, yRadius);\n+        graphHex.addPoint(xRadius/2, yRadius);\n+        graphHex.addPoint(xRadius, 0);\n+        graphHex.addPoint(xRadius/2, -yRadius);\n+\n+        graphHex.translate(xRadius, yRadius);\n+\n+        Point translatedClickedPoint = null;\n+\n+        // this was derived somewhat experimentally\n+        // the clicked point always seems a little off, so we \n+        // a) apply the current transform to it, prior to drawing all the hexes\n+        // b) subtract an additional Y_RADIUS x 2 (Y_DIAMETER)\n+        // this gets us the point within the clicked hex\n+        // it's probably finicky, so any major changes to the rendering mechanism will likely break the detection\n+        if (clickedPoint != null) {\n+            translatedClickedPoint = (Point) clickedPoint.clone();\n+            \n+            // since we have the possibility of scrolling, we need to convert the on-screen clicked coordinates\n+            // to on-board coordinates. Thankfully, SwingUtilities provides the main computational ability for that\n+            Point actualPanelPoint = SwingUtilities.convertPoint(this, translatedClickedPoint, this.getParent());\n+            translatedClickedPoint.translate((int) -(actualPanelPoint.getX() - translatedClickedPoint.getX()), \n+                                                (int) -(actualPanelPoint.getY() - translatedClickedPoint.getY()));\n+            \n+            // now we translate to the starting point of where we're drawing and then go down a hex\n+            translatedClickedPoint.translate((int) g2D.getTransform().getTranslateX(), (int) g2D.getTransform().getTranslateY());\n+            translatedClickedPoint.translate(0, -(HEX_Y_RADIUS * 2));\n+        }\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                if(drawHexType == DrawHexType.Outline) {\n+                    g2D.setColor(new Color(0, 0, 0));\n+                    g2D.drawPolygon(graphHex);                    \n+                } else if (drawHexType == DrawHexType.Hex) {\n+                    \n+                    if (currentTrack.coordsRevealed(x, y) || currentTrack.isGmRevealed()) {\n+                        g2D.setColor(Color.LIGHT_GRAY);\n+                    } else {\n+                        g2D.setColor(Color.DARK_GRAY);\n+                    }\n+                    g2D.fillPolygon(graphHex);\n+                    \n+                    if (translatedClickedPoint != null && graphHex.contains(translatedClickedPoint)) {\n+                        g2D.setColor(Color.WHITE);\n+                        BasicStroke s = new BasicStroke((float) 8.0);\n+                        Stroke push = g2D.getStroke();\n+                        g2D.setStroke(s);\n+                        g2D.drawPolygon(graphHex);\n+                        \n+                        boardState.selectedX = x;\n+                        boardState.selectedY = y;\n+                        pointFound = true;\n+                        g2D.setStroke(push);\n+                    }\n+                } else if (drawHexType == DrawHexType.Dryrun) {\n+                    if (translatedClickedPoint != null && graphHex.contains(translatedClickedPoint)) {\n+                        boardState.selectedX = x;\n+                        boardState.selectedY = y;\n+                        pointFound = true;\n+                    }\n+                }\n+\n+                if (drawHexType == DrawHexType.Hex) {\n+                    g2D.setColor(Color.GREEN);\n+                    g2D.drawString(x + \",\" + y, graphHex.xpoints[0] + (xRadius / 4), graphHex.ypoints[0] + yRadius);\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                graphHex.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            graphHex.translate(translationVector[0], translationVector[1]);\n+        }\n+\n+        return pointFound;\n+    }\n+\n+    /**\n+     * Worker function to render icons representing scenarios to the given surface.\n+     */\n+    private void drawScenarios(Graphics2D g2D) {\n+        Polygon scenarioMarker = new Polygon();\n+        int xRadius = HEX_X_RADIUS / 3;\n+        int yRadius = HEX_Y_RADIUS / 3;\n+\n+        scenarioMarker.addPoint(-xRadius, -yRadius);\n+        scenarioMarker.addPoint(-xRadius, yRadius);\n+        scenarioMarker.addPoint(xRadius, yRadius);\n+        scenarioMarker.addPoint(xRadius, -yRadius);\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                StratconCoords currentCoords = new StratconCoords(x, y);\n+                StratconScenario scenario = currentTrack.getScenario(currentCoords);\n+                \n+                // if there's a scenario here that has a deployment/battle date\n+                // or if there's a scenario here and we've gm-revealed everything\n+                if ((scenario != null) &&\n+                        ((scenario.getDeploymentDate() != null) || currentTrack.isGmRevealed())) {\n+                    g2D.setColor(Color.RED);\n+                    g2D.drawPolygon(scenarioMarker);\n+                    if(currentTrack.getFacility(currentCoords) == null) {\n+                        drawTextEffect(g2D, scenarioMarker, \"Hostile Force Detected\", currentCoords);\n+                    }\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                scenarioMarker.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            scenarioMarker.translate(translationVector[0], translationVector[1]);\n+        }\n+    }\n+    \n+    /**\n+     * Worker function to render facility icons to the given surface.\n+     */\n+    private void drawFacilities(Graphics2D g2D) {\n+        Polygon facilityMarker = new Polygon();\n+        int xRadius = HEX_X_RADIUS / 3;\n+        int yRadius = HEX_Y_RADIUS / 3;\n+\n+        facilityMarker.addPoint(-xRadius, -yRadius);\n+        facilityMarker.addPoint(-xRadius, yRadius);\n+        facilityMarker.addPoint(xRadius, yRadius);\n+        facilityMarker.addPoint(xRadius, -yRadius);\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                StratconCoords currentCoords = new StratconCoords(x, y);\n+                StratconFacility facility = currentTrack.getFacility(currentCoords);\n+                \n+                if ((facility != null) && (facility.isVisible() || currentTrack.isGmRevealed())) {\n+                    g2D.setColor(facility.getOwner() == ForceAlignment.Allied ? Color.GREEN : Color.RED);\n+                    g2D.drawPolygon(facilityMarker);\n+                    drawTextEffect(g2D, facilityMarker, facility.getFormattedDisplayableName(), currentCoords);\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                facilityMarker.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            facilityMarker.translate(translationVector[0], translationVector[1]);\n+        }\n+    }\n+    \n+    /**\n+     * Worker function to render force icons to the given surface.\n+     */\n+    private void drawForces(Graphics2D g2D) {\n+        Polygon forceMarker = new Polygon();\n+        int xRadius = HEX_X_RADIUS / 3;\n+        int yRadius = HEX_Y_RADIUS / 3;\n+\n+        forceMarker.addPoint(-xRadius, -yRadius);\n+        forceMarker.addPoint(-xRadius, yRadius);\n+        forceMarker.addPoint(xRadius, yRadius);\n+        forceMarker.addPoint(xRadius, -yRadius);\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                StratconCoords currentCoords = new StratconCoords(x, y);\n+                \n+                if (currentTrack.getAssignedCoordForces().containsKey(currentCoords)) {\n+                    for (int forceID : currentTrack.getAssignedCoordForces().get(currentCoords)) {                   \n+                        g2D.setColor(Color.BLUE);\n+                        g2D.drawPolygon(forceMarker);\n+                        drawTextEffect(g2D, forceMarker, campaign.getForce(forceID).getName(), currentCoords);\n+                    }\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                forceMarker.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            forceMarker.translate(translationVector[0], translationVector[1]);\n+        }\n+    }\n+    \n+    /**\n+     * Draws some text and line to it from a given polygon. \n+     * Smart enough not to layer multiple strings on top of each other if they're all drawn in the same hex.\n+     */\n+    private void drawTextEffect(Graphics2D g2D, Polygon marker, String text, StratconCoords coords) {\n+        int verticalOffsetIndex = numIconsInHex.containsKey(coords) ? numIconsInHex.get(coords) : 0;\n+        \n+        double startX = marker.getBounds().getMaxX();\n+        double startY = marker.getBounds().getMinY();\n+        double midPointX = startX + HEX_X_RADIUS / 4;\n+        double midPointY = startY - HEX_Y_RADIUS / 4 + g2D.getFontMetrics().getHeight() * verticalOffsetIndex;\n+        double endPointX = midPointX + HEX_X_RADIUS / 2;\n+        \n+        g2D.drawLine((int) startX, (int) startY, (int) midPointX, (int) midPointY);\n+        g2D.drawLine((int) midPointX, (int) midPointY, (int) endPointX, (int) midPointY);\n+        g2D.drawString(text, (int) endPointX, (int) midPointY);\n+        \n+        // register that we drew text off of this hex\n+        verticalOffsetIndex++;\n+        numIconsInHex.put(coords, verticalOffsetIndex);", "originalCommit": "796b6728fd3cd2aea02d17122b4d735afc47dc41", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjkwMjEyMQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r602902121", "bodyText": "Is the cast needed?", "author": "Windchild292", "createdAt": "2021-03-28T16:47:41Z", "path": "MekHQ/src/mekhq/gui/StratconPanel.java", "diffHunk": "@@ -0,0 +1,672 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.gui;\n+\n+import java.awt.BasicStroke;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Point;\n+import java.awt.Polygon;\n+import java.awt.Stroke;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.awt.geom.AffineTransform;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import javax.swing.JCheckBoxMenuItem;\n+import javax.swing.JLabel;\n+import javax.swing.JMenuItem;\n+import javax.swing.JPanel;\n+import javax.swing.JPopupMenu;\n+import javax.swing.SwingUtilities;\n+\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.stratcon.StratconCampaignState;\n+import mekhq.campaign.stratcon.StratconCoords;\n+import mekhq.campaign.stratcon.StratconFacility;\n+import mekhq.campaign.stratcon.StratconScenario;\n+import mekhq.campaign.stratcon.StratconTrackState;\n+import mekhq.gui.stratcon.StratconScenarioWizard;\n+import mekhq.gui.stratcon.TrackForceAssignmentUI;\n+\n+/**\n+ * This panel handles AtB-Stratcon GUI interactions with a specific scenario track.\n+ * @author NickAragua\n+ */\n+public class StratconPanel extends JPanel implements ActionListener {\n+    /**\n+     * \n+     */\n+    private static final long serialVersionUID = 7405934788894417292L;\n+    \n+    public static final int HEX_X_RADIUS = 42;\n+    public static final int HEX_Y_RADIUS = 37;\n+    \n+    private static final String RCLICK_COMMAND_MANAGE_FORCES = \"ManageForces\";\n+    private static final String RCLICK_COMMAND_MANAGE_SCENARIO = \"ManageScenario\";\n+    private static final String RCLICK_COMMAND_REVEAL_TRACK = \"RevealTrack\";\n+    private static final String RCLICK_COMMAND_STICKY_FORCE = \"StickyForce\";\n+    private static final String RCLICK_COMMAND_STICKY_FORCE_ID = \"StickyForceID\";\n+\n+    /**\n+     * What to do when drawing a hex\n+     */\n+    private enum DrawHexType {\n+        /**\n+         * The interior of a hex\n+         */\n+        Hex,\n+        \n+        /**\n+         * The outline of a hex\n+         */\n+        Outline,\n+        \n+        /**\n+         * Pretend we're drawing a hex, but don't actually do it, useful for \n+         * figuring out which hex a mouse click landed in, etc.\n+         */\n+        Dryrun\n+    }\n+\n+    private float scale = 1f;\n+\n+    private StratconTrackState currentTrack;\n+    private StratconCampaignState campaignState;\n+    private Campaign campaign;\n+\n+    private BoardState boardState = new BoardState();\n+\n+    private Point clickedPoint;\n+    private JPopupMenu rightClickMenu;\n+    private JMenuItem menuItemManageForceAssignments;\n+    private JMenuItem menuItemManageScenario;\n+    private JMenuItem menuItemGMReveal;\n+    \n+    // data structure holding how many unit/scenario/base icons have been drawn in the hex\n+    // used to control how low the text description goes.\n+    private Map<StratconCoords, Integer> numIconsInHex = new HashMap<>();\n+    \n+    private StratconScenarioWizard scenarioWizard;\n+    private TrackForceAssignmentUI assignmentUI;\n+    \n+    private JLabel infoArea;\n+\n+    /**\n+     * Constructs a StratconPanel instance, given a parent campaign GUI and a pointer to an info area.\n+     */\n+    StratconPanel(CampaignGUI gui, JLabel infoArea) {\n+        campaign = gui.getCampaign();\n+        scenarioWizard = new StratconScenarioWizard(campaign);\n+        this.infoArea = infoArea;\n+        \n+        assignmentUI = new TrackForceAssignmentUI(this);\n+        assignmentUI.setVisible(false);\n+        \n+        addMouseListener(new MouseAdapter() {\n+            @Override\n+            public void mouseReleased(MouseEvent e) {\n+                mouseReleasedHandler(e);\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Handler for when a specific track is selected - switches rendering to that track.\n+     */\n+    public void selectTrack(StratconCampaignState campaignState, StratconTrackState track) {\n+        this.campaignState = campaignState;\n+        currentTrack = track;\n+        repaint();\n+    }\n+    \n+    /**\n+     * Constructs the right-click context menu, optionally for a scenario\n+     */\n+    private void buildRightClickMenu(StratconCoords coords) {\n+        rightClickMenu = new JPopupMenu();\n+        \n+        StratconScenario scenario = getSelectedScenario();\n+        \n+        if (scenario == null) {\n+            menuItemManageForceAssignments = new JMenuItem();\n+            menuItemManageForceAssignments.setText(\"Manage Force Assignments\");\n+            menuItemManageForceAssignments.setActionCommand(RCLICK_COMMAND_MANAGE_FORCES);\n+            menuItemManageForceAssignments.addActionListener(this);\n+            rightClickMenu.add(menuItemManageForceAssignments);\n+        }\n+        \n+        if (scenario != null) {\n+            menuItemManageScenario = new JMenuItem();\n+            menuItemManageScenario.setText(\"Manage Scenario\");\n+            menuItemManageScenario.setActionCommand(RCLICK_COMMAND_MANAGE_SCENARIO);\n+            menuItemManageScenario.addActionListener(this);\n+            rightClickMenu.add(menuItemManageScenario);\n+        }\n+        \n+        if ((currentTrack != null) && currentTrack.getAssignedCoordForces().containsKey(coords)) {\n+            for (int forceID : currentTrack.getAssignedCoordForces().get(coords)) {\n+                String forceName = campaign.getForce(forceID).getName();\n+                \n+                JCheckBoxMenuItem stickyForceItem = new JCheckBoxMenuItem();\n+                stickyForceItem.setText(String.format(\"%s - remain deployed\", forceName));\n+                stickyForceItem.setActionCommand(RCLICK_COMMAND_STICKY_FORCE);\n+                stickyForceItem.putClientProperty(RCLICK_COMMAND_STICKY_FORCE_ID, forceID);\n+                stickyForceItem.addActionListener(this);\n+                stickyForceItem.setSelected(currentTrack.getStickyForces().contains(forceID));\n+                rightClickMenu.add(stickyForceItem);\n+            }\n+        }\n+            \n+        if ((currentTrack != null) && campaign.isGM()) {\n+            rightClickMenu.addSeparator();\n+            \n+            menuItemGMReveal = new JMenuItem();\n+            menuItemGMReveal.setText(currentTrack.isGmRevealed() ? \"Hide Track\" : \"Reveal Track\");\n+            menuItemGMReveal.setActionCommand(RCLICK_COMMAND_REVEAL_TRACK);\n+            menuItemGMReveal.addActionListener(this);\n+            rightClickMenu.add(menuItemGMReveal);\n+        }\n+    }\n+\n+    /**\n+     * Renders the panel, hexes, forces, facilities and all that.\n+     */\n+    @Override\n+    public void paintComponent(Graphics g) {\n+        super.paintComponent(g);\n+        if (campaignState == null || currentTrack == null) {\n+            return;\n+        }\n+        \n+        numIconsInHex.clear();\n+\n+        Graphics2D g2D = (Graphics2D) g;\n+        AffineTransform initialTransform = g2D.getTransform();\n+        performInitialTransform(g2D);\n+        AffineTransform originTransform = g2D.getTransform();\n+\n+        drawHexes(g2D, DrawHexType.Hex);\n+        g2D.setTransform(originTransform);\n+        drawHexes(g2D, DrawHexType.Outline);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawScenarios(g2D);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawFacilities(g2D);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawForces(g2D);\n+\n+        g2D.setTransform(initialTransform);\n+        if (clickedPoint != null) {\n+            g2D.setColor(Color.BLUE);\n+            g2D.drawRect((int) clickedPoint.getX(), (int) clickedPoint.getY(), 2, 2);\n+        }\n+    }\n+\n+    /**\n+     * This method contains a dirty secret hack, but I forget what it is.\n+     * The point of it is to draw all the hexes for the board. \n+     * If it's a \"dry run\", we don't actually draw the hexes, we just pretend to\n+     * until we \"draw\" one that encompasses the clicked point.\n+     * @param g2D - graphics object on which to draw\n+     * @param drawHexType - whether to draw the hex backgrounds, hex outlines or a dry run for click detection\n+     */\n+    private boolean drawHexes(Graphics2D g2D, DrawHexType drawHexType) {\n+        Polygon graphHex = new Polygon();\n+        int xRadius = HEX_X_RADIUS;\n+        int yRadius = HEX_Y_RADIUS;\n+        boolean pointFound = false;\n+\n+        graphHex.addPoint(-xRadius/2, -yRadius);\n+        graphHex.addPoint(-xRadius, 0);\n+        graphHex.addPoint(-xRadius/2, yRadius);\n+        graphHex.addPoint(xRadius/2, yRadius);\n+        graphHex.addPoint(xRadius, 0);\n+        graphHex.addPoint(xRadius/2, -yRadius);\n+\n+        graphHex.translate(xRadius, yRadius);\n+\n+        Point translatedClickedPoint = null;\n+\n+        // this was derived somewhat experimentally\n+        // the clicked point always seems a little off, so we \n+        // a) apply the current transform to it, prior to drawing all the hexes\n+        // b) subtract an additional Y_RADIUS x 2 (Y_DIAMETER)\n+        // this gets us the point within the clicked hex\n+        // it's probably finicky, so any major changes to the rendering mechanism will likely break the detection\n+        if (clickedPoint != null) {\n+            translatedClickedPoint = (Point) clickedPoint.clone();\n+            \n+            // since we have the possibility of scrolling, we need to convert the on-screen clicked coordinates\n+            // to on-board coordinates. Thankfully, SwingUtilities provides the main computational ability for that\n+            Point actualPanelPoint = SwingUtilities.convertPoint(this, translatedClickedPoint, this.getParent());\n+            translatedClickedPoint.translate((int) -(actualPanelPoint.getX() - translatedClickedPoint.getX()), \n+                                                (int) -(actualPanelPoint.getY() - translatedClickedPoint.getY()));\n+            \n+            // now we translate to the starting point of where we're drawing and then go down a hex\n+            translatedClickedPoint.translate((int) g2D.getTransform().getTranslateX(), (int) g2D.getTransform().getTranslateY());\n+            translatedClickedPoint.translate(0, -(HEX_Y_RADIUS * 2));\n+        }\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                if(drawHexType == DrawHexType.Outline) {\n+                    g2D.setColor(new Color(0, 0, 0));\n+                    g2D.drawPolygon(graphHex);                    \n+                } else if (drawHexType == DrawHexType.Hex) {\n+                    \n+                    if (currentTrack.coordsRevealed(x, y) || currentTrack.isGmRevealed()) {\n+                        g2D.setColor(Color.LIGHT_GRAY);\n+                    } else {\n+                        g2D.setColor(Color.DARK_GRAY);\n+                    }\n+                    g2D.fillPolygon(graphHex);\n+                    \n+                    if (translatedClickedPoint != null && graphHex.contains(translatedClickedPoint)) {\n+                        g2D.setColor(Color.WHITE);\n+                        BasicStroke s = new BasicStroke((float) 8.0);\n+                        Stroke push = g2D.getStroke();\n+                        g2D.setStroke(s);\n+                        g2D.drawPolygon(graphHex);\n+                        \n+                        boardState.selectedX = x;\n+                        boardState.selectedY = y;\n+                        pointFound = true;\n+                        g2D.setStroke(push);\n+                    }\n+                } else if (drawHexType == DrawHexType.Dryrun) {\n+                    if (translatedClickedPoint != null && graphHex.contains(translatedClickedPoint)) {\n+                        boardState.selectedX = x;\n+                        boardState.selectedY = y;\n+                        pointFound = true;\n+                    }\n+                }\n+\n+                if (drawHexType == DrawHexType.Hex) {\n+                    g2D.setColor(Color.GREEN);\n+                    g2D.drawString(x + \",\" + y, graphHex.xpoints[0] + (xRadius / 4), graphHex.ypoints[0] + yRadius);\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                graphHex.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            graphHex.translate(translationVector[0], translationVector[1]);\n+        }\n+\n+        return pointFound;\n+    }\n+\n+    /**\n+     * Worker function to render icons representing scenarios to the given surface.\n+     */\n+    private void drawScenarios(Graphics2D g2D) {\n+        Polygon scenarioMarker = new Polygon();\n+        int xRadius = HEX_X_RADIUS / 3;\n+        int yRadius = HEX_Y_RADIUS / 3;\n+\n+        scenarioMarker.addPoint(-xRadius, -yRadius);\n+        scenarioMarker.addPoint(-xRadius, yRadius);\n+        scenarioMarker.addPoint(xRadius, yRadius);\n+        scenarioMarker.addPoint(xRadius, -yRadius);\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                StratconCoords currentCoords = new StratconCoords(x, y);\n+                StratconScenario scenario = currentTrack.getScenario(currentCoords);\n+                \n+                // if there's a scenario here that has a deployment/battle date\n+                // or if there's a scenario here and we've gm-revealed everything\n+                if ((scenario != null) &&\n+                        ((scenario.getDeploymentDate() != null) || currentTrack.isGmRevealed())) {\n+                    g2D.setColor(Color.RED);\n+                    g2D.drawPolygon(scenarioMarker);\n+                    if(currentTrack.getFacility(currentCoords) == null) {\n+                        drawTextEffect(g2D, scenarioMarker, \"Hostile Force Detected\", currentCoords);\n+                    }\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                scenarioMarker.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            scenarioMarker.translate(translationVector[0], translationVector[1]);\n+        }\n+    }\n+    \n+    /**\n+     * Worker function to render facility icons to the given surface.\n+     */\n+    private void drawFacilities(Graphics2D g2D) {\n+        Polygon facilityMarker = new Polygon();\n+        int xRadius = HEX_X_RADIUS / 3;\n+        int yRadius = HEX_Y_RADIUS / 3;\n+\n+        facilityMarker.addPoint(-xRadius, -yRadius);\n+        facilityMarker.addPoint(-xRadius, yRadius);\n+        facilityMarker.addPoint(xRadius, yRadius);\n+        facilityMarker.addPoint(xRadius, -yRadius);\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                StratconCoords currentCoords = new StratconCoords(x, y);\n+                StratconFacility facility = currentTrack.getFacility(currentCoords);\n+                \n+                if ((facility != null) && (facility.isVisible() || currentTrack.isGmRevealed())) {\n+                    g2D.setColor(facility.getOwner() == ForceAlignment.Allied ? Color.GREEN : Color.RED);\n+                    g2D.drawPolygon(facilityMarker);\n+                    drawTextEffect(g2D, facilityMarker, facility.getFormattedDisplayableName(), currentCoords);\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                facilityMarker.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            facilityMarker.translate(translationVector[0], translationVector[1]);\n+        }\n+    }\n+    \n+    /**\n+     * Worker function to render force icons to the given surface.\n+     */\n+    private void drawForces(Graphics2D g2D) {\n+        Polygon forceMarker = new Polygon();\n+        int xRadius = HEX_X_RADIUS / 3;\n+        int yRadius = HEX_Y_RADIUS / 3;\n+\n+        forceMarker.addPoint(-xRadius, -yRadius);\n+        forceMarker.addPoint(-xRadius, yRadius);\n+        forceMarker.addPoint(xRadius, yRadius);\n+        forceMarker.addPoint(xRadius, -yRadius);\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                StratconCoords currentCoords = new StratconCoords(x, y);\n+                \n+                if (currentTrack.getAssignedCoordForces().containsKey(currentCoords)) {\n+                    for (int forceID : currentTrack.getAssignedCoordForces().get(currentCoords)) {                   \n+                        g2D.setColor(Color.BLUE);\n+                        g2D.drawPolygon(forceMarker);\n+                        drawTextEffect(g2D, forceMarker, campaign.getForce(forceID).getName(), currentCoords);\n+                    }\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                forceMarker.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            forceMarker.translate(translationVector[0], translationVector[1]);\n+        }\n+    }\n+    \n+    /**\n+     * Draws some text and line to it from a given polygon. \n+     * Smart enough not to layer multiple strings on top of each other if they're all drawn in the same hex.\n+     */\n+    private void drawTextEffect(Graphics2D g2D, Polygon marker, String text, StratconCoords coords) {\n+        int verticalOffsetIndex = numIconsInHex.containsKey(coords) ? numIconsInHex.get(coords) : 0;\n+        \n+        double startX = marker.getBounds().getMaxX();\n+        double startY = marker.getBounds().getMinY();\n+        double midPointX = startX + HEX_X_RADIUS / 4;\n+        double midPointY = startY - HEX_Y_RADIUS / 4 + g2D.getFontMetrics().getHeight() * verticalOffsetIndex;\n+        double endPointX = midPointX + HEX_X_RADIUS / 2;\n+        \n+        g2D.drawLine((int) startX, (int) startY, (int) midPointX, (int) midPointY);\n+        g2D.drawLine((int) midPointX, (int) midPointY, (int) endPointX, (int) midPointY);\n+        g2D.drawString(text, (int) endPointX, (int) midPointY);\n+        \n+        // register that we drew text off of this hex\n+        verticalOffsetIndex++;\n+        numIconsInHex.put(coords, verticalOffsetIndex);\n+    }\n+\n+    /**\n+     * Returns the translation that we need to make to render the \"next downward\" hex.\n+     * @return Two dimensional array with the first element being the x vector and the second being the y vector\n+     */\n+    private int[] getDownwardYVector() {\n+        return new int[] { 0, (int) (HEX_Y_RADIUS * 2) };", "originalCommit": "796b6728fd3cd2aea02d17122b4d735afc47dc41", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjkwMjMxMg==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r602902312", "bodyText": "UP shouldn't be capitalized like that unless it is a short I'm not getting?", "author": "Windchild292", "createdAt": "2021-03-28T16:48:58Z", "path": "MekHQ/src/mekhq/gui/StratconPanel.java", "diffHunk": "@@ -0,0 +1,672 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.gui;\n+\n+import java.awt.BasicStroke;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Point;\n+import java.awt.Polygon;\n+import java.awt.Stroke;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.awt.geom.AffineTransform;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import javax.swing.JCheckBoxMenuItem;\n+import javax.swing.JLabel;\n+import javax.swing.JMenuItem;\n+import javax.swing.JPanel;\n+import javax.swing.JPopupMenu;\n+import javax.swing.SwingUtilities;\n+\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.stratcon.StratconCampaignState;\n+import mekhq.campaign.stratcon.StratconCoords;\n+import mekhq.campaign.stratcon.StratconFacility;\n+import mekhq.campaign.stratcon.StratconScenario;\n+import mekhq.campaign.stratcon.StratconTrackState;\n+import mekhq.gui.stratcon.StratconScenarioWizard;\n+import mekhq.gui.stratcon.TrackForceAssignmentUI;\n+\n+/**\n+ * This panel handles AtB-Stratcon GUI interactions with a specific scenario track.\n+ * @author NickAragua\n+ */\n+public class StratconPanel extends JPanel implements ActionListener {\n+    /**\n+     * \n+     */\n+    private static final long serialVersionUID = 7405934788894417292L;\n+    \n+    public static final int HEX_X_RADIUS = 42;\n+    public static final int HEX_Y_RADIUS = 37;\n+    \n+    private static final String RCLICK_COMMAND_MANAGE_FORCES = \"ManageForces\";\n+    private static final String RCLICK_COMMAND_MANAGE_SCENARIO = \"ManageScenario\";\n+    private static final String RCLICK_COMMAND_REVEAL_TRACK = \"RevealTrack\";\n+    private static final String RCLICK_COMMAND_STICKY_FORCE = \"StickyForce\";\n+    private static final String RCLICK_COMMAND_STICKY_FORCE_ID = \"StickyForceID\";\n+\n+    /**\n+     * What to do when drawing a hex\n+     */\n+    private enum DrawHexType {\n+        /**\n+         * The interior of a hex\n+         */\n+        Hex,\n+        \n+        /**\n+         * The outline of a hex\n+         */\n+        Outline,\n+        \n+        /**\n+         * Pretend we're drawing a hex, but don't actually do it, useful for \n+         * figuring out which hex a mouse click landed in, etc.\n+         */\n+        Dryrun\n+    }\n+\n+    private float scale = 1f;\n+\n+    private StratconTrackState currentTrack;\n+    private StratconCampaignState campaignState;\n+    private Campaign campaign;\n+\n+    private BoardState boardState = new BoardState();\n+\n+    private Point clickedPoint;\n+    private JPopupMenu rightClickMenu;\n+    private JMenuItem menuItemManageForceAssignments;\n+    private JMenuItem menuItemManageScenario;\n+    private JMenuItem menuItemGMReveal;\n+    \n+    // data structure holding how many unit/scenario/base icons have been drawn in the hex\n+    // used to control how low the text description goes.\n+    private Map<StratconCoords, Integer> numIconsInHex = new HashMap<>();\n+    \n+    private StratconScenarioWizard scenarioWizard;\n+    private TrackForceAssignmentUI assignmentUI;\n+    \n+    private JLabel infoArea;\n+\n+    /**\n+     * Constructs a StratconPanel instance, given a parent campaign GUI and a pointer to an info area.\n+     */\n+    StratconPanel(CampaignGUI gui, JLabel infoArea) {\n+        campaign = gui.getCampaign();\n+        scenarioWizard = new StratconScenarioWizard(campaign);\n+        this.infoArea = infoArea;\n+        \n+        assignmentUI = new TrackForceAssignmentUI(this);\n+        assignmentUI.setVisible(false);\n+        \n+        addMouseListener(new MouseAdapter() {\n+            @Override\n+            public void mouseReleased(MouseEvent e) {\n+                mouseReleasedHandler(e);\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Handler for when a specific track is selected - switches rendering to that track.\n+     */\n+    public void selectTrack(StratconCampaignState campaignState, StratconTrackState track) {\n+        this.campaignState = campaignState;\n+        currentTrack = track;\n+        repaint();\n+    }\n+    \n+    /**\n+     * Constructs the right-click context menu, optionally for a scenario\n+     */\n+    private void buildRightClickMenu(StratconCoords coords) {\n+        rightClickMenu = new JPopupMenu();\n+        \n+        StratconScenario scenario = getSelectedScenario();\n+        \n+        if (scenario == null) {\n+            menuItemManageForceAssignments = new JMenuItem();\n+            menuItemManageForceAssignments.setText(\"Manage Force Assignments\");\n+            menuItemManageForceAssignments.setActionCommand(RCLICK_COMMAND_MANAGE_FORCES);\n+            menuItemManageForceAssignments.addActionListener(this);\n+            rightClickMenu.add(menuItemManageForceAssignments);\n+        }\n+        \n+        if (scenario != null) {\n+            menuItemManageScenario = new JMenuItem();\n+            menuItemManageScenario.setText(\"Manage Scenario\");\n+            menuItemManageScenario.setActionCommand(RCLICK_COMMAND_MANAGE_SCENARIO);\n+            menuItemManageScenario.addActionListener(this);\n+            rightClickMenu.add(menuItemManageScenario);\n+        }\n+        \n+        if ((currentTrack != null) && currentTrack.getAssignedCoordForces().containsKey(coords)) {\n+            for (int forceID : currentTrack.getAssignedCoordForces().get(coords)) {\n+                String forceName = campaign.getForce(forceID).getName();\n+                \n+                JCheckBoxMenuItem stickyForceItem = new JCheckBoxMenuItem();\n+                stickyForceItem.setText(String.format(\"%s - remain deployed\", forceName));\n+                stickyForceItem.setActionCommand(RCLICK_COMMAND_STICKY_FORCE);\n+                stickyForceItem.putClientProperty(RCLICK_COMMAND_STICKY_FORCE_ID, forceID);\n+                stickyForceItem.addActionListener(this);\n+                stickyForceItem.setSelected(currentTrack.getStickyForces().contains(forceID));\n+                rightClickMenu.add(stickyForceItem);\n+            }\n+        }\n+            \n+        if ((currentTrack != null) && campaign.isGM()) {\n+            rightClickMenu.addSeparator();\n+            \n+            menuItemGMReveal = new JMenuItem();\n+            menuItemGMReveal.setText(currentTrack.isGmRevealed() ? \"Hide Track\" : \"Reveal Track\");\n+            menuItemGMReveal.setActionCommand(RCLICK_COMMAND_REVEAL_TRACK);\n+            menuItemGMReveal.addActionListener(this);\n+            rightClickMenu.add(menuItemGMReveal);\n+        }\n+    }\n+\n+    /**\n+     * Renders the panel, hexes, forces, facilities and all that.\n+     */\n+    @Override\n+    public void paintComponent(Graphics g) {\n+        super.paintComponent(g);\n+        if (campaignState == null || currentTrack == null) {\n+            return;\n+        }\n+        \n+        numIconsInHex.clear();\n+\n+        Graphics2D g2D = (Graphics2D) g;\n+        AffineTransform initialTransform = g2D.getTransform();\n+        performInitialTransform(g2D);\n+        AffineTransform originTransform = g2D.getTransform();\n+\n+        drawHexes(g2D, DrawHexType.Hex);\n+        g2D.setTransform(originTransform);\n+        drawHexes(g2D, DrawHexType.Outline);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawScenarios(g2D);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawFacilities(g2D);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawForces(g2D);\n+\n+        g2D.setTransform(initialTransform);\n+        if (clickedPoint != null) {\n+            g2D.setColor(Color.BLUE);\n+            g2D.drawRect((int) clickedPoint.getX(), (int) clickedPoint.getY(), 2, 2);\n+        }\n+    }\n+\n+    /**\n+     * This method contains a dirty secret hack, but I forget what it is.\n+     * The point of it is to draw all the hexes for the board. \n+     * If it's a \"dry run\", we don't actually draw the hexes, we just pretend to\n+     * until we \"draw\" one that encompasses the clicked point.\n+     * @param g2D - graphics object on which to draw\n+     * @param drawHexType - whether to draw the hex backgrounds, hex outlines or a dry run for click detection\n+     */\n+    private boolean drawHexes(Graphics2D g2D, DrawHexType drawHexType) {\n+        Polygon graphHex = new Polygon();\n+        int xRadius = HEX_X_RADIUS;\n+        int yRadius = HEX_Y_RADIUS;\n+        boolean pointFound = false;\n+\n+        graphHex.addPoint(-xRadius/2, -yRadius);\n+        graphHex.addPoint(-xRadius, 0);\n+        graphHex.addPoint(-xRadius/2, yRadius);\n+        graphHex.addPoint(xRadius/2, yRadius);\n+        graphHex.addPoint(xRadius, 0);\n+        graphHex.addPoint(xRadius/2, -yRadius);\n+\n+        graphHex.translate(xRadius, yRadius);\n+\n+        Point translatedClickedPoint = null;\n+\n+        // this was derived somewhat experimentally\n+        // the clicked point always seems a little off, so we \n+        // a) apply the current transform to it, prior to drawing all the hexes\n+        // b) subtract an additional Y_RADIUS x 2 (Y_DIAMETER)\n+        // this gets us the point within the clicked hex\n+        // it's probably finicky, so any major changes to the rendering mechanism will likely break the detection\n+        if (clickedPoint != null) {\n+            translatedClickedPoint = (Point) clickedPoint.clone();\n+            \n+            // since we have the possibility of scrolling, we need to convert the on-screen clicked coordinates\n+            // to on-board coordinates. Thankfully, SwingUtilities provides the main computational ability for that\n+            Point actualPanelPoint = SwingUtilities.convertPoint(this, translatedClickedPoint, this.getParent());\n+            translatedClickedPoint.translate((int) -(actualPanelPoint.getX() - translatedClickedPoint.getX()), \n+                                                (int) -(actualPanelPoint.getY() - translatedClickedPoint.getY()));\n+            \n+            // now we translate to the starting point of where we're drawing and then go down a hex\n+            translatedClickedPoint.translate((int) g2D.getTransform().getTranslateX(), (int) g2D.getTransform().getTranslateY());\n+            translatedClickedPoint.translate(0, -(HEX_Y_RADIUS * 2));\n+        }\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                if(drawHexType == DrawHexType.Outline) {\n+                    g2D.setColor(new Color(0, 0, 0));\n+                    g2D.drawPolygon(graphHex);                    \n+                } else if (drawHexType == DrawHexType.Hex) {\n+                    \n+                    if (currentTrack.coordsRevealed(x, y) || currentTrack.isGmRevealed()) {\n+                        g2D.setColor(Color.LIGHT_GRAY);\n+                    } else {\n+                        g2D.setColor(Color.DARK_GRAY);\n+                    }\n+                    g2D.fillPolygon(graphHex);\n+                    \n+                    if (translatedClickedPoint != null && graphHex.contains(translatedClickedPoint)) {\n+                        g2D.setColor(Color.WHITE);\n+                        BasicStroke s = new BasicStroke((float) 8.0);\n+                        Stroke push = g2D.getStroke();\n+                        g2D.setStroke(s);\n+                        g2D.drawPolygon(graphHex);\n+                        \n+                        boardState.selectedX = x;\n+                        boardState.selectedY = y;\n+                        pointFound = true;\n+                        g2D.setStroke(push);\n+                    }\n+                } else if (drawHexType == DrawHexType.Dryrun) {\n+                    if (translatedClickedPoint != null && graphHex.contains(translatedClickedPoint)) {\n+                        boardState.selectedX = x;\n+                        boardState.selectedY = y;\n+                        pointFound = true;\n+                    }\n+                }\n+\n+                if (drawHexType == DrawHexType.Hex) {\n+                    g2D.setColor(Color.GREEN);\n+                    g2D.drawString(x + \",\" + y, graphHex.xpoints[0] + (xRadius / 4), graphHex.ypoints[0] + yRadius);\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                graphHex.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            graphHex.translate(translationVector[0], translationVector[1]);\n+        }\n+\n+        return pointFound;\n+    }\n+\n+    /**\n+     * Worker function to render icons representing scenarios to the given surface.\n+     */\n+    private void drawScenarios(Graphics2D g2D) {\n+        Polygon scenarioMarker = new Polygon();\n+        int xRadius = HEX_X_RADIUS / 3;\n+        int yRadius = HEX_Y_RADIUS / 3;\n+\n+        scenarioMarker.addPoint(-xRadius, -yRadius);\n+        scenarioMarker.addPoint(-xRadius, yRadius);\n+        scenarioMarker.addPoint(xRadius, yRadius);\n+        scenarioMarker.addPoint(xRadius, -yRadius);\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                StratconCoords currentCoords = new StratconCoords(x, y);\n+                StratconScenario scenario = currentTrack.getScenario(currentCoords);\n+                \n+                // if there's a scenario here that has a deployment/battle date\n+                // or if there's a scenario here and we've gm-revealed everything\n+                if ((scenario != null) &&\n+                        ((scenario.getDeploymentDate() != null) || currentTrack.isGmRevealed())) {\n+                    g2D.setColor(Color.RED);\n+                    g2D.drawPolygon(scenarioMarker);\n+                    if(currentTrack.getFacility(currentCoords) == null) {\n+                        drawTextEffect(g2D, scenarioMarker, \"Hostile Force Detected\", currentCoords);\n+                    }\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                scenarioMarker.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            scenarioMarker.translate(translationVector[0], translationVector[1]);\n+        }\n+    }\n+    \n+    /**\n+     * Worker function to render facility icons to the given surface.\n+     */\n+    private void drawFacilities(Graphics2D g2D) {\n+        Polygon facilityMarker = new Polygon();\n+        int xRadius = HEX_X_RADIUS / 3;\n+        int yRadius = HEX_Y_RADIUS / 3;\n+\n+        facilityMarker.addPoint(-xRadius, -yRadius);\n+        facilityMarker.addPoint(-xRadius, yRadius);\n+        facilityMarker.addPoint(xRadius, yRadius);\n+        facilityMarker.addPoint(xRadius, -yRadius);\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                StratconCoords currentCoords = new StratconCoords(x, y);\n+                StratconFacility facility = currentTrack.getFacility(currentCoords);\n+                \n+                if ((facility != null) && (facility.isVisible() || currentTrack.isGmRevealed())) {\n+                    g2D.setColor(facility.getOwner() == ForceAlignment.Allied ? Color.GREEN : Color.RED);\n+                    g2D.drawPolygon(facilityMarker);\n+                    drawTextEffect(g2D, facilityMarker, facility.getFormattedDisplayableName(), currentCoords);\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                facilityMarker.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            facilityMarker.translate(translationVector[0], translationVector[1]);\n+        }\n+    }\n+    \n+    /**\n+     * Worker function to render force icons to the given surface.\n+     */\n+    private void drawForces(Graphics2D g2D) {\n+        Polygon forceMarker = new Polygon();\n+        int xRadius = HEX_X_RADIUS / 3;\n+        int yRadius = HEX_Y_RADIUS / 3;\n+\n+        forceMarker.addPoint(-xRadius, -yRadius);\n+        forceMarker.addPoint(-xRadius, yRadius);\n+        forceMarker.addPoint(xRadius, yRadius);\n+        forceMarker.addPoint(xRadius, -yRadius);\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                StratconCoords currentCoords = new StratconCoords(x, y);\n+                \n+                if (currentTrack.getAssignedCoordForces().containsKey(currentCoords)) {\n+                    for (int forceID : currentTrack.getAssignedCoordForces().get(currentCoords)) {                   \n+                        g2D.setColor(Color.BLUE);\n+                        g2D.drawPolygon(forceMarker);\n+                        drawTextEffect(g2D, forceMarker, campaign.getForce(forceID).getName(), currentCoords);\n+                    }\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                forceMarker.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            forceMarker.translate(translationVector[0], translationVector[1]);\n+        }\n+    }\n+    \n+    /**\n+     * Draws some text and line to it from a given polygon. \n+     * Smart enough not to layer multiple strings on top of each other if they're all drawn in the same hex.\n+     */\n+    private void drawTextEffect(Graphics2D g2D, Polygon marker, String text, StratconCoords coords) {\n+        int verticalOffsetIndex = numIconsInHex.containsKey(coords) ? numIconsInHex.get(coords) : 0;\n+        \n+        double startX = marker.getBounds().getMaxX();\n+        double startY = marker.getBounds().getMinY();\n+        double midPointX = startX + HEX_X_RADIUS / 4;\n+        double midPointY = startY - HEX_Y_RADIUS / 4 + g2D.getFontMetrics().getHeight() * verticalOffsetIndex;\n+        double endPointX = midPointX + HEX_X_RADIUS / 2;\n+        \n+        g2D.drawLine((int) startX, (int) startY, (int) midPointX, (int) midPointY);\n+        g2D.drawLine((int) midPointX, (int) midPointY, (int) endPointX, (int) midPointY);\n+        g2D.drawString(text, (int) endPointX, (int) midPointY);\n+        \n+        // register that we drew text off of this hex\n+        verticalOffsetIndex++;\n+        numIconsInHex.put(coords, verticalOffsetIndex);\n+    }\n+\n+    /**\n+     * Returns the translation that we need to make to render the \"next downward\" hex.\n+     * @return Two dimensional array with the first element being the x vector and the second being the y vector\n+     */\n+    private int[] getDownwardYVector() {\n+        return new int[] { 0, (int) (HEX_Y_RADIUS * 2) };\n+    }\n+\n+    /**\n+     * Returns the translation that we need to make to move from the bottom of a column to the top of the next\n+     * column to the right.\n+     * @param evenColumn Whether the column we're currently in is odd or even\n+     * @return Two dimensional array with the first element being the x vector and the second being the y vector\n+     */\n+    private int[] getRightAndUPVector(boolean evenColumn) {", "originalCommit": "796b6728fd3cd2aea02d17122b4d735afc47dc41", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjkwMjM0MA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r602902340", "bodyText": "There is zero reason to use these as separate instead of just as constants", "author": "Windchild292", "createdAt": "2021-03-28T16:49:19Z", "path": "MekHQ/src/mekhq/gui/StratconPanel.java", "diffHunk": "@@ -0,0 +1,672 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.gui;\n+\n+import java.awt.BasicStroke;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Point;\n+import java.awt.Polygon;\n+import java.awt.Stroke;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.awt.geom.AffineTransform;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import javax.swing.JCheckBoxMenuItem;\n+import javax.swing.JLabel;\n+import javax.swing.JMenuItem;\n+import javax.swing.JPanel;\n+import javax.swing.JPopupMenu;\n+import javax.swing.SwingUtilities;\n+\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.stratcon.StratconCampaignState;\n+import mekhq.campaign.stratcon.StratconCoords;\n+import mekhq.campaign.stratcon.StratconFacility;\n+import mekhq.campaign.stratcon.StratconScenario;\n+import mekhq.campaign.stratcon.StratconTrackState;\n+import mekhq.gui.stratcon.StratconScenarioWizard;\n+import mekhq.gui.stratcon.TrackForceAssignmentUI;\n+\n+/**\n+ * This panel handles AtB-Stratcon GUI interactions with a specific scenario track.\n+ * @author NickAragua\n+ */\n+public class StratconPanel extends JPanel implements ActionListener {\n+    /**\n+     * \n+     */\n+    private static final long serialVersionUID = 7405934788894417292L;\n+    \n+    public static final int HEX_X_RADIUS = 42;\n+    public static final int HEX_Y_RADIUS = 37;\n+    \n+    private static final String RCLICK_COMMAND_MANAGE_FORCES = \"ManageForces\";\n+    private static final String RCLICK_COMMAND_MANAGE_SCENARIO = \"ManageScenario\";\n+    private static final String RCLICK_COMMAND_REVEAL_TRACK = \"RevealTrack\";\n+    private static final String RCLICK_COMMAND_STICKY_FORCE = \"StickyForce\";\n+    private static final String RCLICK_COMMAND_STICKY_FORCE_ID = \"StickyForceID\";\n+\n+    /**\n+     * What to do when drawing a hex\n+     */\n+    private enum DrawHexType {\n+        /**\n+         * The interior of a hex\n+         */\n+        Hex,\n+        \n+        /**\n+         * The outline of a hex\n+         */\n+        Outline,\n+        \n+        /**\n+         * Pretend we're drawing a hex, but don't actually do it, useful for \n+         * figuring out which hex a mouse click landed in, etc.\n+         */\n+        Dryrun\n+    }\n+\n+    private float scale = 1f;\n+\n+    private StratconTrackState currentTrack;\n+    private StratconCampaignState campaignState;\n+    private Campaign campaign;\n+\n+    private BoardState boardState = new BoardState();\n+\n+    private Point clickedPoint;\n+    private JPopupMenu rightClickMenu;\n+    private JMenuItem menuItemManageForceAssignments;\n+    private JMenuItem menuItemManageScenario;\n+    private JMenuItem menuItemGMReveal;\n+    \n+    // data structure holding how many unit/scenario/base icons have been drawn in the hex\n+    // used to control how low the text description goes.\n+    private Map<StratconCoords, Integer> numIconsInHex = new HashMap<>();\n+    \n+    private StratconScenarioWizard scenarioWizard;\n+    private TrackForceAssignmentUI assignmentUI;\n+    \n+    private JLabel infoArea;\n+\n+    /**\n+     * Constructs a StratconPanel instance, given a parent campaign GUI and a pointer to an info area.\n+     */\n+    StratconPanel(CampaignGUI gui, JLabel infoArea) {\n+        campaign = gui.getCampaign();\n+        scenarioWizard = new StratconScenarioWizard(campaign);\n+        this.infoArea = infoArea;\n+        \n+        assignmentUI = new TrackForceAssignmentUI(this);\n+        assignmentUI.setVisible(false);\n+        \n+        addMouseListener(new MouseAdapter() {\n+            @Override\n+            public void mouseReleased(MouseEvent e) {\n+                mouseReleasedHandler(e);\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Handler for when a specific track is selected - switches rendering to that track.\n+     */\n+    public void selectTrack(StratconCampaignState campaignState, StratconTrackState track) {\n+        this.campaignState = campaignState;\n+        currentTrack = track;\n+        repaint();\n+    }\n+    \n+    /**\n+     * Constructs the right-click context menu, optionally for a scenario\n+     */\n+    private void buildRightClickMenu(StratconCoords coords) {\n+        rightClickMenu = new JPopupMenu();\n+        \n+        StratconScenario scenario = getSelectedScenario();\n+        \n+        if (scenario == null) {\n+            menuItemManageForceAssignments = new JMenuItem();\n+            menuItemManageForceAssignments.setText(\"Manage Force Assignments\");\n+            menuItemManageForceAssignments.setActionCommand(RCLICK_COMMAND_MANAGE_FORCES);\n+            menuItemManageForceAssignments.addActionListener(this);\n+            rightClickMenu.add(menuItemManageForceAssignments);\n+        }\n+        \n+        if (scenario != null) {\n+            menuItemManageScenario = new JMenuItem();\n+            menuItemManageScenario.setText(\"Manage Scenario\");\n+            menuItemManageScenario.setActionCommand(RCLICK_COMMAND_MANAGE_SCENARIO);\n+            menuItemManageScenario.addActionListener(this);\n+            rightClickMenu.add(menuItemManageScenario);\n+        }\n+        \n+        if ((currentTrack != null) && currentTrack.getAssignedCoordForces().containsKey(coords)) {\n+            for (int forceID : currentTrack.getAssignedCoordForces().get(coords)) {\n+                String forceName = campaign.getForce(forceID).getName();\n+                \n+                JCheckBoxMenuItem stickyForceItem = new JCheckBoxMenuItem();\n+                stickyForceItem.setText(String.format(\"%s - remain deployed\", forceName));\n+                stickyForceItem.setActionCommand(RCLICK_COMMAND_STICKY_FORCE);\n+                stickyForceItem.putClientProperty(RCLICK_COMMAND_STICKY_FORCE_ID, forceID);\n+                stickyForceItem.addActionListener(this);\n+                stickyForceItem.setSelected(currentTrack.getStickyForces().contains(forceID));\n+                rightClickMenu.add(stickyForceItem);\n+            }\n+        }\n+            \n+        if ((currentTrack != null) && campaign.isGM()) {\n+            rightClickMenu.addSeparator();\n+            \n+            menuItemGMReveal = new JMenuItem();\n+            menuItemGMReveal.setText(currentTrack.isGmRevealed() ? \"Hide Track\" : \"Reveal Track\");\n+            menuItemGMReveal.setActionCommand(RCLICK_COMMAND_REVEAL_TRACK);\n+            menuItemGMReveal.addActionListener(this);\n+            rightClickMenu.add(menuItemGMReveal);\n+        }\n+    }\n+\n+    /**\n+     * Renders the panel, hexes, forces, facilities and all that.\n+     */\n+    @Override\n+    public void paintComponent(Graphics g) {\n+        super.paintComponent(g);\n+        if (campaignState == null || currentTrack == null) {\n+            return;\n+        }\n+        \n+        numIconsInHex.clear();\n+\n+        Graphics2D g2D = (Graphics2D) g;\n+        AffineTransform initialTransform = g2D.getTransform();\n+        performInitialTransform(g2D);\n+        AffineTransform originTransform = g2D.getTransform();\n+\n+        drawHexes(g2D, DrawHexType.Hex);\n+        g2D.setTransform(originTransform);\n+        drawHexes(g2D, DrawHexType.Outline);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawScenarios(g2D);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawFacilities(g2D);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawForces(g2D);\n+\n+        g2D.setTransform(initialTransform);\n+        if (clickedPoint != null) {\n+            g2D.setColor(Color.BLUE);\n+            g2D.drawRect((int) clickedPoint.getX(), (int) clickedPoint.getY(), 2, 2);\n+        }\n+    }\n+\n+    /**\n+     * This method contains a dirty secret hack, but I forget what it is.\n+     * The point of it is to draw all the hexes for the board. \n+     * If it's a \"dry run\", we don't actually draw the hexes, we just pretend to\n+     * until we \"draw\" one that encompasses the clicked point.\n+     * @param g2D - graphics object on which to draw\n+     * @param drawHexType - whether to draw the hex backgrounds, hex outlines or a dry run for click detection\n+     */\n+    private boolean drawHexes(Graphics2D g2D, DrawHexType drawHexType) {\n+        Polygon graphHex = new Polygon();\n+        int xRadius = HEX_X_RADIUS;\n+        int yRadius = HEX_Y_RADIUS;\n+        boolean pointFound = false;\n+\n+        graphHex.addPoint(-xRadius/2, -yRadius);\n+        graphHex.addPoint(-xRadius, 0);\n+        graphHex.addPoint(-xRadius/2, yRadius);\n+        graphHex.addPoint(xRadius/2, yRadius);\n+        graphHex.addPoint(xRadius, 0);\n+        graphHex.addPoint(xRadius/2, -yRadius);\n+\n+        graphHex.translate(xRadius, yRadius);\n+\n+        Point translatedClickedPoint = null;\n+\n+        // this was derived somewhat experimentally\n+        // the clicked point always seems a little off, so we \n+        // a) apply the current transform to it, prior to drawing all the hexes\n+        // b) subtract an additional Y_RADIUS x 2 (Y_DIAMETER)\n+        // this gets us the point within the clicked hex\n+        // it's probably finicky, so any major changes to the rendering mechanism will likely break the detection\n+        if (clickedPoint != null) {\n+            translatedClickedPoint = (Point) clickedPoint.clone();\n+            \n+            // since we have the possibility of scrolling, we need to convert the on-screen clicked coordinates\n+            // to on-board coordinates. Thankfully, SwingUtilities provides the main computational ability for that\n+            Point actualPanelPoint = SwingUtilities.convertPoint(this, translatedClickedPoint, this.getParent());\n+            translatedClickedPoint.translate((int) -(actualPanelPoint.getX() - translatedClickedPoint.getX()), \n+                                                (int) -(actualPanelPoint.getY() - translatedClickedPoint.getY()));\n+            \n+            // now we translate to the starting point of where we're drawing and then go down a hex\n+            translatedClickedPoint.translate((int) g2D.getTransform().getTranslateX(), (int) g2D.getTransform().getTranslateY());\n+            translatedClickedPoint.translate(0, -(HEX_Y_RADIUS * 2));\n+        }\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                if(drawHexType == DrawHexType.Outline) {\n+                    g2D.setColor(new Color(0, 0, 0));\n+                    g2D.drawPolygon(graphHex);                    \n+                } else if (drawHexType == DrawHexType.Hex) {\n+                    \n+                    if (currentTrack.coordsRevealed(x, y) || currentTrack.isGmRevealed()) {\n+                        g2D.setColor(Color.LIGHT_GRAY);\n+                    } else {\n+                        g2D.setColor(Color.DARK_GRAY);\n+                    }\n+                    g2D.fillPolygon(graphHex);\n+                    \n+                    if (translatedClickedPoint != null && graphHex.contains(translatedClickedPoint)) {\n+                        g2D.setColor(Color.WHITE);\n+                        BasicStroke s = new BasicStroke((float) 8.0);\n+                        Stroke push = g2D.getStroke();\n+                        g2D.setStroke(s);\n+                        g2D.drawPolygon(graphHex);\n+                        \n+                        boardState.selectedX = x;\n+                        boardState.selectedY = y;\n+                        pointFound = true;\n+                        g2D.setStroke(push);\n+                    }\n+                } else if (drawHexType == DrawHexType.Dryrun) {\n+                    if (translatedClickedPoint != null && graphHex.contains(translatedClickedPoint)) {\n+                        boardState.selectedX = x;\n+                        boardState.selectedY = y;\n+                        pointFound = true;\n+                    }\n+                }\n+\n+                if (drawHexType == DrawHexType.Hex) {\n+                    g2D.setColor(Color.GREEN);\n+                    g2D.drawString(x + \",\" + y, graphHex.xpoints[0] + (xRadius / 4), graphHex.ypoints[0] + yRadius);\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                graphHex.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            graphHex.translate(translationVector[0], translationVector[1]);\n+        }\n+\n+        return pointFound;\n+    }\n+\n+    /**\n+     * Worker function to render icons representing scenarios to the given surface.\n+     */\n+    private void drawScenarios(Graphics2D g2D) {\n+        Polygon scenarioMarker = new Polygon();\n+        int xRadius = HEX_X_RADIUS / 3;\n+        int yRadius = HEX_Y_RADIUS / 3;\n+\n+        scenarioMarker.addPoint(-xRadius, -yRadius);\n+        scenarioMarker.addPoint(-xRadius, yRadius);\n+        scenarioMarker.addPoint(xRadius, yRadius);\n+        scenarioMarker.addPoint(xRadius, -yRadius);\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                StratconCoords currentCoords = new StratconCoords(x, y);\n+                StratconScenario scenario = currentTrack.getScenario(currentCoords);\n+                \n+                // if there's a scenario here that has a deployment/battle date\n+                // or if there's a scenario here and we've gm-revealed everything\n+                if ((scenario != null) &&\n+                        ((scenario.getDeploymentDate() != null) || currentTrack.isGmRevealed())) {\n+                    g2D.setColor(Color.RED);\n+                    g2D.drawPolygon(scenarioMarker);\n+                    if(currentTrack.getFacility(currentCoords) == null) {\n+                        drawTextEffect(g2D, scenarioMarker, \"Hostile Force Detected\", currentCoords);\n+                    }\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                scenarioMarker.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            scenarioMarker.translate(translationVector[0], translationVector[1]);\n+        }\n+    }\n+    \n+    /**\n+     * Worker function to render facility icons to the given surface.\n+     */\n+    private void drawFacilities(Graphics2D g2D) {\n+        Polygon facilityMarker = new Polygon();\n+        int xRadius = HEX_X_RADIUS / 3;\n+        int yRadius = HEX_Y_RADIUS / 3;\n+\n+        facilityMarker.addPoint(-xRadius, -yRadius);\n+        facilityMarker.addPoint(-xRadius, yRadius);\n+        facilityMarker.addPoint(xRadius, yRadius);\n+        facilityMarker.addPoint(xRadius, -yRadius);\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                StratconCoords currentCoords = new StratconCoords(x, y);\n+                StratconFacility facility = currentTrack.getFacility(currentCoords);\n+                \n+                if ((facility != null) && (facility.isVisible() || currentTrack.isGmRevealed())) {\n+                    g2D.setColor(facility.getOwner() == ForceAlignment.Allied ? Color.GREEN : Color.RED);\n+                    g2D.drawPolygon(facilityMarker);\n+                    drawTextEffect(g2D, facilityMarker, facility.getFormattedDisplayableName(), currentCoords);\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                facilityMarker.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            facilityMarker.translate(translationVector[0], translationVector[1]);\n+        }\n+    }\n+    \n+    /**\n+     * Worker function to render force icons to the given surface.\n+     */\n+    private void drawForces(Graphics2D g2D) {\n+        Polygon forceMarker = new Polygon();\n+        int xRadius = HEX_X_RADIUS / 3;\n+        int yRadius = HEX_Y_RADIUS / 3;\n+\n+        forceMarker.addPoint(-xRadius, -yRadius);\n+        forceMarker.addPoint(-xRadius, yRadius);\n+        forceMarker.addPoint(xRadius, yRadius);\n+        forceMarker.addPoint(xRadius, -yRadius);\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                StratconCoords currentCoords = new StratconCoords(x, y);\n+                \n+                if (currentTrack.getAssignedCoordForces().containsKey(currentCoords)) {\n+                    for (int forceID : currentTrack.getAssignedCoordForces().get(currentCoords)) {                   \n+                        g2D.setColor(Color.BLUE);\n+                        g2D.drawPolygon(forceMarker);\n+                        drawTextEffect(g2D, forceMarker, campaign.getForce(forceID).getName(), currentCoords);\n+                    }\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                forceMarker.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            forceMarker.translate(translationVector[0], translationVector[1]);\n+        }\n+    }\n+    \n+    /**\n+     * Draws some text and line to it from a given polygon. \n+     * Smart enough not to layer multiple strings on top of each other if they're all drawn in the same hex.\n+     */\n+    private void drawTextEffect(Graphics2D g2D, Polygon marker, String text, StratconCoords coords) {\n+        int verticalOffsetIndex = numIconsInHex.containsKey(coords) ? numIconsInHex.get(coords) : 0;\n+        \n+        double startX = marker.getBounds().getMaxX();\n+        double startY = marker.getBounds().getMinY();\n+        double midPointX = startX + HEX_X_RADIUS / 4;\n+        double midPointY = startY - HEX_Y_RADIUS / 4 + g2D.getFontMetrics().getHeight() * verticalOffsetIndex;\n+        double endPointX = midPointX + HEX_X_RADIUS / 2;\n+        \n+        g2D.drawLine((int) startX, (int) startY, (int) midPointX, (int) midPointY);\n+        g2D.drawLine((int) midPointX, (int) midPointY, (int) endPointX, (int) midPointY);\n+        g2D.drawString(text, (int) endPointX, (int) midPointY);\n+        \n+        // register that we drew text off of this hex\n+        verticalOffsetIndex++;\n+        numIconsInHex.put(coords, verticalOffsetIndex);\n+    }\n+\n+    /**\n+     * Returns the translation that we need to make to render the \"next downward\" hex.\n+     * @return Two dimensional array with the first element being the x vector and the second being the y vector\n+     */\n+    private int[] getDownwardYVector() {\n+        return new int[] { 0, (int) (HEX_Y_RADIUS * 2) };\n+    }\n+\n+    /**\n+     * Returns the translation that we need to make to move from the bottom of a column to the top of the next\n+     * column to the right.\n+     * @param evenColumn Whether the column we're currently in is odd or even\n+     * @return Two dimensional array with the first element being the x vector and the second being the y vector\n+     */\n+    private int[] getRightAndUPVector(boolean evenColumn) {\n+        int yRadius = (int) (HEX_Y_RADIUS);\n+        int xRadius = (int) (HEX_X_RADIUS);", "originalCommit": "796b6728fd3cd2aea02d17122b4d735afc47dc41", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjkwNzgwOQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r602907809", "bodyText": "Originally, I was hoping to be able to scale (i.e. allow zoom-in/zoom-out). I may still come back to that.", "author": "NickAragua", "createdAt": "2021-03-28T17:37:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjkwMjM0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjkwMjM4MA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r602902380", "bodyText": "Let's use a proper rounding method here", "author": "Windchild292", "createdAt": "2021-03-28T16:49:39Z", "path": "MekHQ/src/mekhq/gui/StratconPanel.java", "diffHunk": "@@ -0,0 +1,672 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.gui;\n+\n+import java.awt.BasicStroke;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Point;\n+import java.awt.Polygon;\n+import java.awt.Stroke;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.awt.geom.AffineTransform;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import javax.swing.JCheckBoxMenuItem;\n+import javax.swing.JLabel;\n+import javax.swing.JMenuItem;\n+import javax.swing.JPanel;\n+import javax.swing.JPopupMenu;\n+import javax.swing.SwingUtilities;\n+\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.stratcon.StratconCampaignState;\n+import mekhq.campaign.stratcon.StratconCoords;\n+import mekhq.campaign.stratcon.StratconFacility;\n+import mekhq.campaign.stratcon.StratconScenario;\n+import mekhq.campaign.stratcon.StratconTrackState;\n+import mekhq.gui.stratcon.StratconScenarioWizard;\n+import mekhq.gui.stratcon.TrackForceAssignmentUI;\n+\n+/**\n+ * This panel handles AtB-Stratcon GUI interactions with a specific scenario track.\n+ * @author NickAragua\n+ */\n+public class StratconPanel extends JPanel implements ActionListener {\n+    /**\n+     * \n+     */\n+    private static final long serialVersionUID = 7405934788894417292L;\n+    \n+    public static final int HEX_X_RADIUS = 42;\n+    public static final int HEX_Y_RADIUS = 37;\n+    \n+    private static final String RCLICK_COMMAND_MANAGE_FORCES = \"ManageForces\";\n+    private static final String RCLICK_COMMAND_MANAGE_SCENARIO = \"ManageScenario\";\n+    private static final String RCLICK_COMMAND_REVEAL_TRACK = \"RevealTrack\";\n+    private static final String RCLICK_COMMAND_STICKY_FORCE = \"StickyForce\";\n+    private static final String RCLICK_COMMAND_STICKY_FORCE_ID = \"StickyForceID\";\n+\n+    /**\n+     * What to do when drawing a hex\n+     */\n+    private enum DrawHexType {\n+        /**\n+         * The interior of a hex\n+         */\n+        Hex,\n+        \n+        /**\n+         * The outline of a hex\n+         */\n+        Outline,\n+        \n+        /**\n+         * Pretend we're drawing a hex, but don't actually do it, useful for \n+         * figuring out which hex a mouse click landed in, etc.\n+         */\n+        Dryrun\n+    }\n+\n+    private float scale = 1f;\n+\n+    private StratconTrackState currentTrack;\n+    private StratconCampaignState campaignState;\n+    private Campaign campaign;\n+\n+    private BoardState boardState = new BoardState();\n+\n+    private Point clickedPoint;\n+    private JPopupMenu rightClickMenu;\n+    private JMenuItem menuItemManageForceAssignments;\n+    private JMenuItem menuItemManageScenario;\n+    private JMenuItem menuItemGMReveal;\n+    \n+    // data structure holding how many unit/scenario/base icons have been drawn in the hex\n+    // used to control how low the text description goes.\n+    private Map<StratconCoords, Integer> numIconsInHex = new HashMap<>();\n+    \n+    private StratconScenarioWizard scenarioWizard;\n+    private TrackForceAssignmentUI assignmentUI;\n+    \n+    private JLabel infoArea;\n+\n+    /**\n+     * Constructs a StratconPanel instance, given a parent campaign GUI and a pointer to an info area.\n+     */\n+    StratconPanel(CampaignGUI gui, JLabel infoArea) {\n+        campaign = gui.getCampaign();\n+        scenarioWizard = new StratconScenarioWizard(campaign);\n+        this.infoArea = infoArea;\n+        \n+        assignmentUI = new TrackForceAssignmentUI(this);\n+        assignmentUI.setVisible(false);\n+        \n+        addMouseListener(new MouseAdapter() {\n+            @Override\n+            public void mouseReleased(MouseEvent e) {\n+                mouseReleasedHandler(e);\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Handler for when a specific track is selected - switches rendering to that track.\n+     */\n+    public void selectTrack(StratconCampaignState campaignState, StratconTrackState track) {\n+        this.campaignState = campaignState;\n+        currentTrack = track;\n+        repaint();\n+    }\n+    \n+    /**\n+     * Constructs the right-click context menu, optionally for a scenario\n+     */\n+    private void buildRightClickMenu(StratconCoords coords) {\n+        rightClickMenu = new JPopupMenu();\n+        \n+        StratconScenario scenario = getSelectedScenario();\n+        \n+        if (scenario == null) {\n+            menuItemManageForceAssignments = new JMenuItem();\n+            menuItemManageForceAssignments.setText(\"Manage Force Assignments\");\n+            menuItemManageForceAssignments.setActionCommand(RCLICK_COMMAND_MANAGE_FORCES);\n+            menuItemManageForceAssignments.addActionListener(this);\n+            rightClickMenu.add(menuItemManageForceAssignments);\n+        }\n+        \n+        if (scenario != null) {\n+            menuItemManageScenario = new JMenuItem();\n+            menuItemManageScenario.setText(\"Manage Scenario\");\n+            menuItemManageScenario.setActionCommand(RCLICK_COMMAND_MANAGE_SCENARIO);\n+            menuItemManageScenario.addActionListener(this);\n+            rightClickMenu.add(menuItemManageScenario);\n+        }\n+        \n+        if ((currentTrack != null) && currentTrack.getAssignedCoordForces().containsKey(coords)) {\n+            for (int forceID : currentTrack.getAssignedCoordForces().get(coords)) {\n+                String forceName = campaign.getForce(forceID).getName();\n+                \n+                JCheckBoxMenuItem stickyForceItem = new JCheckBoxMenuItem();\n+                stickyForceItem.setText(String.format(\"%s - remain deployed\", forceName));\n+                stickyForceItem.setActionCommand(RCLICK_COMMAND_STICKY_FORCE);\n+                stickyForceItem.putClientProperty(RCLICK_COMMAND_STICKY_FORCE_ID, forceID);\n+                stickyForceItem.addActionListener(this);\n+                stickyForceItem.setSelected(currentTrack.getStickyForces().contains(forceID));\n+                rightClickMenu.add(stickyForceItem);\n+            }\n+        }\n+            \n+        if ((currentTrack != null) && campaign.isGM()) {\n+            rightClickMenu.addSeparator();\n+            \n+            menuItemGMReveal = new JMenuItem();\n+            menuItemGMReveal.setText(currentTrack.isGmRevealed() ? \"Hide Track\" : \"Reveal Track\");\n+            menuItemGMReveal.setActionCommand(RCLICK_COMMAND_REVEAL_TRACK);\n+            menuItemGMReveal.addActionListener(this);\n+            rightClickMenu.add(menuItemGMReveal);\n+        }\n+    }\n+\n+    /**\n+     * Renders the panel, hexes, forces, facilities and all that.\n+     */\n+    @Override\n+    public void paintComponent(Graphics g) {\n+        super.paintComponent(g);\n+        if (campaignState == null || currentTrack == null) {\n+            return;\n+        }\n+        \n+        numIconsInHex.clear();\n+\n+        Graphics2D g2D = (Graphics2D) g;\n+        AffineTransform initialTransform = g2D.getTransform();\n+        performInitialTransform(g2D);\n+        AffineTransform originTransform = g2D.getTransform();\n+\n+        drawHexes(g2D, DrawHexType.Hex);\n+        g2D.setTransform(originTransform);\n+        drawHexes(g2D, DrawHexType.Outline);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawScenarios(g2D);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawFacilities(g2D);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawForces(g2D);\n+\n+        g2D.setTransform(initialTransform);\n+        if (clickedPoint != null) {\n+            g2D.setColor(Color.BLUE);\n+            g2D.drawRect((int) clickedPoint.getX(), (int) clickedPoint.getY(), 2, 2);\n+        }\n+    }\n+\n+    /**\n+     * This method contains a dirty secret hack, but I forget what it is.\n+     * The point of it is to draw all the hexes for the board. \n+     * If it's a \"dry run\", we don't actually draw the hexes, we just pretend to\n+     * until we \"draw\" one that encompasses the clicked point.\n+     * @param g2D - graphics object on which to draw\n+     * @param drawHexType - whether to draw the hex backgrounds, hex outlines or a dry run for click detection\n+     */\n+    private boolean drawHexes(Graphics2D g2D, DrawHexType drawHexType) {\n+        Polygon graphHex = new Polygon();\n+        int xRadius = HEX_X_RADIUS;\n+        int yRadius = HEX_Y_RADIUS;\n+        boolean pointFound = false;\n+\n+        graphHex.addPoint(-xRadius/2, -yRadius);\n+        graphHex.addPoint(-xRadius, 0);\n+        graphHex.addPoint(-xRadius/2, yRadius);\n+        graphHex.addPoint(xRadius/2, yRadius);\n+        graphHex.addPoint(xRadius, 0);\n+        graphHex.addPoint(xRadius/2, -yRadius);\n+\n+        graphHex.translate(xRadius, yRadius);\n+\n+        Point translatedClickedPoint = null;\n+\n+        // this was derived somewhat experimentally\n+        // the clicked point always seems a little off, so we \n+        // a) apply the current transform to it, prior to drawing all the hexes\n+        // b) subtract an additional Y_RADIUS x 2 (Y_DIAMETER)\n+        // this gets us the point within the clicked hex\n+        // it's probably finicky, so any major changes to the rendering mechanism will likely break the detection\n+        if (clickedPoint != null) {\n+            translatedClickedPoint = (Point) clickedPoint.clone();\n+            \n+            // since we have the possibility of scrolling, we need to convert the on-screen clicked coordinates\n+            // to on-board coordinates. Thankfully, SwingUtilities provides the main computational ability for that\n+            Point actualPanelPoint = SwingUtilities.convertPoint(this, translatedClickedPoint, this.getParent());\n+            translatedClickedPoint.translate((int) -(actualPanelPoint.getX() - translatedClickedPoint.getX()), \n+                                                (int) -(actualPanelPoint.getY() - translatedClickedPoint.getY()));\n+            \n+            // now we translate to the starting point of where we're drawing and then go down a hex\n+            translatedClickedPoint.translate((int) g2D.getTransform().getTranslateX(), (int) g2D.getTransform().getTranslateY());\n+            translatedClickedPoint.translate(0, -(HEX_Y_RADIUS * 2));\n+        }\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                if(drawHexType == DrawHexType.Outline) {\n+                    g2D.setColor(new Color(0, 0, 0));\n+                    g2D.drawPolygon(graphHex);                    \n+                } else if (drawHexType == DrawHexType.Hex) {\n+                    \n+                    if (currentTrack.coordsRevealed(x, y) || currentTrack.isGmRevealed()) {\n+                        g2D.setColor(Color.LIGHT_GRAY);\n+                    } else {\n+                        g2D.setColor(Color.DARK_GRAY);\n+                    }\n+                    g2D.fillPolygon(graphHex);\n+                    \n+                    if (translatedClickedPoint != null && graphHex.contains(translatedClickedPoint)) {\n+                        g2D.setColor(Color.WHITE);\n+                        BasicStroke s = new BasicStroke((float) 8.0);\n+                        Stroke push = g2D.getStroke();\n+                        g2D.setStroke(s);\n+                        g2D.drawPolygon(graphHex);\n+                        \n+                        boardState.selectedX = x;\n+                        boardState.selectedY = y;\n+                        pointFound = true;\n+                        g2D.setStroke(push);\n+                    }\n+                } else if (drawHexType == DrawHexType.Dryrun) {\n+                    if (translatedClickedPoint != null && graphHex.contains(translatedClickedPoint)) {\n+                        boardState.selectedX = x;\n+                        boardState.selectedY = y;\n+                        pointFound = true;\n+                    }\n+                }\n+\n+                if (drawHexType == DrawHexType.Hex) {\n+                    g2D.setColor(Color.GREEN);\n+                    g2D.drawString(x + \",\" + y, graphHex.xpoints[0] + (xRadius / 4), graphHex.ypoints[0] + yRadius);\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                graphHex.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            graphHex.translate(translationVector[0], translationVector[1]);\n+        }\n+\n+        return pointFound;\n+    }\n+\n+    /**\n+     * Worker function to render icons representing scenarios to the given surface.\n+     */\n+    private void drawScenarios(Graphics2D g2D) {\n+        Polygon scenarioMarker = new Polygon();\n+        int xRadius = HEX_X_RADIUS / 3;\n+        int yRadius = HEX_Y_RADIUS / 3;\n+\n+        scenarioMarker.addPoint(-xRadius, -yRadius);\n+        scenarioMarker.addPoint(-xRadius, yRadius);\n+        scenarioMarker.addPoint(xRadius, yRadius);\n+        scenarioMarker.addPoint(xRadius, -yRadius);\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                StratconCoords currentCoords = new StratconCoords(x, y);\n+                StratconScenario scenario = currentTrack.getScenario(currentCoords);\n+                \n+                // if there's a scenario here that has a deployment/battle date\n+                // or if there's a scenario here and we've gm-revealed everything\n+                if ((scenario != null) &&\n+                        ((scenario.getDeploymentDate() != null) || currentTrack.isGmRevealed())) {\n+                    g2D.setColor(Color.RED);\n+                    g2D.drawPolygon(scenarioMarker);\n+                    if(currentTrack.getFacility(currentCoords) == null) {\n+                        drawTextEffect(g2D, scenarioMarker, \"Hostile Force Detected\", currentCoords);\n+                    }\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                scenarioMarker.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            scenarioMarker.translate(translationVector[0], translationVector[1]);\n+        }\n+    }\n+    \n+    /**\n+     * Worker function to render facility icons to the given surface.\n+     */\n+    private void drawFacilities(Graphics2D g2D) {\n+        Polygon facilityMarker = new Polygon();\n+        int xRadius = HEX_X_RADIUS / 3;\n+        int yRadius = HEX_Y_RADIUS / 3;\n+\n+        facilityMarker.addPoint(-xRadius, -yRadius);\n+        facilityMarker.addPoint(-xRadius, yRadius);\n+        facilityMarker.addPoint(xRadius, yRadius);\n+        facilityMarker.addPoint(xRadius, -yRadius);\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                StratconCoords currentCoords = new StratconCoords(x, y);\n+                StratconFacility facility = currentTrack.getFacility(currentCoords);\n+                \n+                if ((facility != null) && (facility.isVisible() || currentTrack.isGmRevealed())) {\n+                    g2D.setColor(facility.getOwner() == ForceAlignment.Allied ? Color.GREEN : Color.RED);\n+                    g2D.drawPolygon(facilityMarker);\n+                    drawTextEffect(g2D, facilityMarker, facility.getFormattedDisplayableName(), currentCoords);\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                facilityMarker.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            facilityMarker.translate(translationVector[0], translationVector[1]);\n+        }\n+    }\n+    \n+    /**\n+     * Worker function to render force icons to the given surface.\n+     */\n+    private void drawForces(Graphics2D g2D) {\n+        Polygon forceMarker = new Polygon();\n+        int xRadius = HEX_X_RADIUS / 3;\n+        int yRadius = HEX_Y_RADIUS / 3;\n+\n+        forceMarker.addPoint(-xRadius, -yRadius);\n+        forceMarker.addPoint(-xRadius, yRadius);\n+        forceMarker.addPoint(xRadius, yRadius);\n+        forceMarker.addPoint(xRadius, -yRadius);\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                StratconCoords currentCoords = new StratconCoords(x, y);\n+                \n+                if (currentTrack.getAssignedCoordForces().containsKey(currentCoords)) {\n+                    for (int forceID : currentTrack.getAssignedCoordForces().get(currentCoords)) {                   \n+                        g2D.setColor(Color.BLUE);\n+                        g2D.drawPolygon(forceMarker);\n+                        drawTextEffect(g2D, forceMarker, campaign.getForce(forceID).getName(), currentCoords);\n+                    }\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                forceMarker.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            forceMarker.translate(translationVector[0], translationVector[1]);\n+        }\n+    }\n+    \n+    /**\n+     * Draws some text and line to it from a given polygon. \n+     * Smart enough not to layer multiple strings on top of each other if they're all drawn in the same hex.\n+     */\n+    private void drawTextEffect(Graphics2D g2D, Polygon marker, String text, StratconCoords coords) {\n+        int verticalOffsetIndex = numIconsInHex.containsKey(coords) ? numIconsInHex.get(coords) : 0;\n+        \n+        double startX = marker.getBounds().getMaxX();\n+        double startY = marker.getBounds().getMinY();\n+        double midPointX = startX + HEX_X_RADIUS / 4;\n+        double midPointY = startY - HEX_Y_RADIUS / 4 + g2D.getFontMetrics().getHeight() * verticalOffsetIndex;\n+        double endPointX = midPointX + HEX_X_RADIUS / 2;\n+        \n+        g2D.drawLine((int) startX, (int) startY, (int) midPointX, (int) midPointY);\n+        g2D.drawLine((int) midPointX, (int) midPointY, (int) endPointX, (int) midPointY);\n+        g2D.drawString(text, (int) endPointX, (int) midPointY);\n+        \n+        // register that we drew text off of this hex\n+        verticalOffsetIndex++;\n+        numIconsInHex.put(coords, verticalOffsetIndex);\n+    }\n+\n+    /**\n+     * Returns the translation that we need to make to render the \"next downward\" hex.\n+     * @return Two dimensional array with the first element being the x vector and the second being the y vector\n+     */\n+    private int[] getDownwardYVector() {\n+        return new int[] { 0, (int) (HEX_Y_RADIUS * 2) };\n+    }\n+\n+    /**\n+     * Returns the translation that we need to make to move from the bottom of a column to the top of the next\n+     * column to the right.\n+     * @param evenColumn Whether the column we're currently in is odd or even\n+     * @return Two dimensional array with the first element being the x vector and the second being the y vector\n+     */\n+    private int[] getRightAndUPVector(boolean evenColumn) {\n+        int yRadius = (int) (HEX_Y_RADIUS);\n+        int xRadius = (int) (HEX_X_RADIUS);\n+\n+        int yTranslation = currentTrack.getHeight() * yRadius * 2;\n+        if (evenColumn) {\n+            yTranslation += yRadius;\n+        } else {\n+            yTranslation -= yRadius;\n+        }\n+\n+        return new int[] {(int) (xRadius * 1.5), -yTranslation};", "originalCommit": "796b6728fd3cd2aea02d17122b4d735afc47dc41", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjkwMjQwNA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r602902404", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if(e.getSource() != this) {\n          \n          \n            \n                    if (e.getSource() != this) {", "author": "Windchild292", "createdAt": "2021-03-28T16:49:56Z", "path": "MekHQ/src/mekhq/gui/StratconPanel.java", "diffHunk": "@@ -0,0 +1,672 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.gui;\n+\n+import java.awt.BasicStroke;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Point;\n+import java.awt.Polygon;\n+import java.awt.Stroke;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.awt.geom.AffineTransform;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import javax.swing.JCheckBoxMenuItem;\n+import javax.swing.JLabel;\n+import javax.swing.JMenuItem;\n+import javax.swing.JPanel;\n+import javax.swing.JPopupMenu;\n+import javax.swing.SwingUtilities;\n+\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.stratcon.StratconCampaignState;\n+import mekhq.campaign.stratcon.StratconCoords;\n+import mekhq.campaign.stratcon.StratconFacility;\n+import mekhq.campaign.stratcon.StratconScenario;\n+import mekhq.campaign.stratcon.StratconTrackState;\n+import mekhq.gui.stratcon.StratconScenarioWizard;\n+import mekhq.gui.stratcon.TrackForceAssignmentUI;\n+\n+/**\n+ * This panel handles AtB-Stratcon GUI interactions with a specific scenario track.\n+ * @author NickAragua\n+ */\n+public class StratconPanel extends JPanel implements ActionListener {\n+    /**\n+     * \n+     */\n+    private static final long serialVersionUID = 7405934788894417292L;\n+    \n+    public static final int HEX_X_RADIUS = 42;\n+    public static final int HEX_Y_RADIUS = 37;\n+    \n+    private static final String RCLICK_COMMAND_MANAGE_FORCES = \"ManageForces\";\n+    private static final String RCLICK_COMMAND_MANAGE_SCENARIO = \"ManageScenario\";\n+    private static final String RCLICK_COMMAND_REVEAL_TRACK = \"RevealTrack\";\n+    private static final String RCLICK_COMMAND_STICKY_FORCE = \"StickyForce\";\n+    private static final String RCLICK_COMMAND_STICKY_FORCE_ID = \"StickyForceID\";\n+\n+    /**\n+     * What to do when drawing a hex\n+     */\n+    private enum DrawHexType {\n+        /**\n+         * The interior of a hex\n+         */\n+        Hex,\n+        \n+        /**\n+         * The outline of a hex\n+         */\n+        Outline,\n+        \n+        /**\n+         * Pretend we're drawing a hex, but don't actually do it, useful for \n+         * figuring out which hex a mouse click landed in, etc.\n+         */\n+        Dryrun\n+    }\n+\n+    private float scale = 1f;\n+\n+    private StratconTrackState currentTrack;\n+    private StratconCampaignState campaignState;\n+    private Campaign campaign;\n+\n+    private BoardState boardState = new BoardState();\n+\n+    private Point clickedPoint;\n+    private JPopupMenu rightClickMenu;\n+    private JMenuItem menuItemManageForceAssignments;\n+    private JMenuItem menuItemManageScenario;\n+    private JMenuItem menuItemGMReveal;\n+    \n+    // data structure holding how many unit/scenario/base icons have been drawn in the hex\n+    // used to control how low the text description goes.\n+    private Map<StratconCoords, Integer> numIconsInHex = new HashMap<>();\n+    \n+    private StratconScenarioWizard scenarioWizard;\n+    private TrackForceAssignmentUI assignmentUI;\n+    \n+    private JLabel infoArea;\n+\n+    /**\n+     * Constructs a StratconPanel instance, given a parent campaign GUI and a pointer to an info area.\n+     */\n+    StratconPanel(CampaignGUI gui, JLabel infoArea) {\n+        campaign = gui.getCampaign();\n+        scenarioWizard = new StratconScenarioWizard(campaign);\n+        this.infoArea = infoArea;\n+        \n+        assignmentUI = new TrackForceAssignmentUI(this);\n+        assignmentUI.setVisible(false);\n+        \n+        addMouseListener(new MouseAdapter() {\n+            @Override\n+            public void mouseReleased(MouseEvent e) {\n+                mouseReleasedHandler(e);\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Handler for when a specific track is selected - switches rendering to that track.\n+     */\n+    public void selectTrack(StratconCampaignState campaignState, StratconTrackState track) {\n+        this.campaignState = campaignState;\n+        currentTrack = track;\n+        repaint();\n+    }\n+    \n+    /**\n+     * Constructs the right-click context menu, optionally for a scenario\n+     */\n+    private void buildRightClickMenu(StratconCoords coords) {\n+        rightClickMenu = new JPopupMenu();\n+        \n+        StratconScenario scenario = getSelectedScenario();\n+        \n+        if (scenario == null) {\n+            menuItemManageForceAssignments = new JMenuItem();\n+            menuItemManageForceAssignments.setText(\"Manage Force Assignments\");\n+            menuItemManageForceAssignments.setActionCommand(RCLICK_COMMAND_MANAGE_FORCES);\n+            menuItemManageForceAssignments.addActionListener(this);\n+            rightClickMenu.add(menuItemManageForceAssignments);\n+        }\n+        \n+        if (scenario != null) {\n+            menuItemManageScenario = new JMenuItem();\n+            menuItemManageScenario.setText(\"Manage Scenario\");\n+            menuItemManageScenario.setActionCommand(RCLICK_COMMAND_MANAGE_SCENARIO);\n+            menuItemManageScenario.addActionListener(this);\n+            rightClickMenu.add(menuItemManageScenario);\n+        }\n+        \n+        if ((currentTrack != null) && currentTrack.getAssignedCoordForces().containsKey(coords)) {\n+            for (int forceID : currentTrack.getAssignedCoordForces().get(coords)) {\n+                String forceName = campaign.getForce(forceID).getName();\n+                \n+                JCheckBoxMenuItem stickyForceItem = new JCheckBoxMenuItem();\n+                stickyForceItem.setText(String.format(\"%s - remain deployed\", forceName));\n+                stickyForceItem.setActionCommand(RCLICK_COMMAND_STICKY_FORCE);\n+                stickyForceItem.putClientProperty(RCLICK_COMMAND_STICKY_FORCE_ID, forceID);\n+                stickyForceItem.addActionListener(this);\n+                stickyForceItem.setSelected(currentTrack.getStickyForces().contains(forceID));\n+                rightClickMenu.add(stickyForceItem);\n+            }\n+        }\n+            \n+        if ((currentTrack != null) && campaign.isGM()) {\n+            rightClickMenu.addSeparator();\n+            \n+            menuItemGMReveal = new JMenuItem();\n+            menuItemGMReveal.setText(currentTrack.isGmRevealed() ? \"Hide Track\" : \"Reveal Track\");\n+            menuItemGMReveal.setActionCommand(RCLICK_COMMAND_REVEAL_TRACK);\n+            menuItemGMReveal.addActionListener(this);\n+            rightClickMenu.add(menuItemGMReveal);\n+        }\n+    }\n+\n+    /**\n+     * Renders the panel, hexes, forces, facilities and all that.\n+     */\n+    @Override\n+    public void paintComponent(Graphics g) {\n+        super.paintComponent(g);\n+        if (campaignState == null || currentTrack == null) {\n+            return;\n+        }\n+        \n+        numIconsInHex.clear();\n+\n+        Graphics2D g2D = (Graphics2D) g;\n+        AffineTransform initialTransform = g2D.getTransform();\n+        performInitialTransform(g2D);\n+        AffineTransform originTransform = g2D.getTransform();\n+\n+        drawHexes(g2D, DrawHexType.Hex);\n+        g2D.setTransform(originTransform);\n+        drawHexes(g2D, DrawHexType.Outline);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawScenarios(g2D);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawFacilities(g2D);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawForces(g2D);\n+\n+        g2D.setTransform(initialTransform);\n+        if (clickedPoint != null) {\n+            g2D.setColor(Color.BLUE);\n+            g2D.drawRect((int) clickedPoint.getX(), (int) clickedPoint.getY(), 2, 2);\n+        }\n+    }\n+\n+    /**\n+     * This method contains a dirty secret hack, but I forget what it is.\n+     * The point of it is to draw all the hexes for the board. \n+     * If it's a \"dry run\", we don't actually draw the hexes, we just pretend to\n+     * until we \"draw\" one that encompasses the clicked point.\n+     * @param g2D - graphics object on which to draw\n+     * @param drawHexType - whether to draw the hex backgrounds, hex outlines or a dry run for click detection\n+     */\n+    private boolean drawHexes(Graphics2D g2D, DrawHexType drawHexType) {\n+        Polygon graphHex = new Polygon();\n+        int xRadius = HEX_X_RADIUS;\n+        int yRadius = HEX_Y_RADIUS;\n+        boolean pointFound = false;\n+\n+        graphHex.addPoint(-xRadius/2, -yRadius);\n+        graphHex.addPoint(-xRadius, 0);\n+        graphHex.addPoint(-xRadius/2, yRadius);\n+        graphHex.addPoint(xRadius/2, yRadius);\n+        graphHex.addPoint(xRadius, 0);\n+        graphHex.addPoint(xRadius/2, -yRadius);\n+\n+        graphHex.translate(xRadius, yRadius);\n+\n+        Point translatedClickedPoint = null;\n+\n+        // this was derived somewhat experimentally\n+        // the clicked point always seems a little off, so we \n+        // a) apply the current transform to it, prior to drawing all the hexes\n+        // b) subtract an additional Y_RADIUS x 2 (Y_DIAMETER)\n+        // this gets us the point within the clicked hex\n+        // it's probably finicky, so any major changes to the rendering mechanism will likely break the detection\n+        if (clickedPoint != null) {\n+            translatedClickedPoint = (Point) clickedPoint.clone();\n+            \n+            // since we have the possibility of scrolling, we need to convert the on-screen clicked coordinates\n+            // to on-board coordinates. Thankfully, SwingUtilities provides the main computational ability for that\n+            Point actualPanelPoint = SwingUtilities.convertPoint(this, translatedClickedPoint, this.getParent());\n+            translatedClickedPoint.translate((int) -(actualPanelPoint.getX() - translatedClickedPoint.getX()), \n+                                                (int) -(actualPanelPoint.getY() - translatedClickedPoint.getY()));\n+            \n+            // now we translate to the starting point of where we're drawing and then go down a hex\n+            translatedClickedPoint.translate((int) g2D.getTransform().getTranslateX(), (int) g2D.getTransform().getTranslateY());\n+            translatedClickedPoint.translate(0, -(HEX_Y_RADIUS * 2));\n+        }\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                if(drawHexType == DrawHexType.Outline) {\n+                    g2D.setColor(new Color(0, 0, 0));\n+                    g2D.drawPolygon(graphHex);                    \n+                } else if (drawHexType == DrawHexType.Hex) {\n+                    \n+                    if (currentTrack.coordsRevealed(x, y) || currentTrack.isGmRevealed()) {\n+                        g2D.setColor(Color.LIGHT_GRAY);\n+                    } else {\n+                        g2D.setColor(Color.DARK_GRAY);\n+                    }\n+                    g2D.fillPolygon(graphHex);\n+                    \n+                    if (translatedClickedPoint != null && graphHex.contains(translatedClickedPoint)) {\n+                        g2D.setColor(Color.WHITE);\n+                        BasicStroke s = new BasicStroke((float) 8.0);\n+                        Stroke push = g2D.getStroke();\n+                        g2D.setStroke(s);\n+                        g2D.drawPolygon(graphHex);\n+                        \n+                        boardState.selectedX = x;\n+                        boardState.selectedY = y;\n+                        pointFound = true;\n+                        g2D.setStroke(push);\n+                    }\n+                } else if (drawHexType == DrawHexType.Dryrun) {\n+                    if (translatedClickedPoint != null && graphHex.contains(translatedClickedPoint)) {\n+                        boardState.selectedX = x;\n+                        boardState.selectedY = y;\n+                        pointFound = true;\n+                    }\n+                }\n+\n+                if (drawHexType == DrawHexType.Hex) {\n+                    g2D.setColor(Color.GREEN);\n+                    g2D.drawString(x + \",\" + y, graphHex.xpoints[0] + (xRadius / 4), graphHex.ypoints[0] + yRadius);\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                graphHex.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            graphHex.translate(translationVector[0], translationVector[1]);\n+        }\n+\n+        return pointFound;\n+    }\n+\n+    /**\n+     * Worker function to render icons representing scenarios to the given surface.\n+     */\n+    private void drawScenarios(Graphics2D g2D) {\n+        Polygon scenarioMarker = new Polygon();\n+        int xRadius = HEX_X_RADIUS / 3;\n+        int yRadius = HEX_Y_RADIUS / 3;\n+\n+        scenarioMarker.addPoint(-xRadius, -yRadius);\n+        scenarioMarker.addPoint(-xRadius, yRadius);\n+        scenarioMarker.addPoint(xRadius, yRadius);\n+        scenarioMarker.addPoint(xRadius, -yRadius);\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                StratconCoords currentCoords = new StratconCoords(x, y);\n+                StratconScenario scenario = currentTrack.getScenario(currentCoords);\n+                \n+                // if there's a scenario here that has a deployment/battle date\n+                // or if there's a scenario here and we've gm-revealed everything\n+                if ((scenario != null) &&\n+                        ((scenario.getDeploymentDate() != null) || currentTrack.isGmRevealed())) {\n+                    g2D.setColor(Color.RED);\n+                    g2D.drawPolygon(scenarioMarker);\n+                    if(currentTrack.getFacility(currentCoords) == null) {\n+                        drawTextEffect(g2D, scenarioMarker, \"Hostile Force Detected\", currentCoords);\n+                    }\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                scenarioMarker.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            scenarioMarker.translate(translationVector[0], translationVector[1]);\n+        }\n+    }\n+    \n+    /**\n+     * Worker function to render facility icons to the given surface.\n+     */\n+    private void drawFacilities(Graphics2D g2D) {\n+        Polygon facilityMarker = new Polygon();\n+        int xRadius = HEX_X_RADIUS / 3;\n+        int yRadius = HEX_Y_RADIUS / 3;\n+\n+        facilityMarker.addPoint(-xRadius, -yRadius);\n+        facilityMarker.addPoint(-xRadius, yRadius);\n+        facilityMarker.addPoint(xRadius, yRadius);\n+        facilityMarker.addPoint(xRadius, -yRadius);\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                StratconCoords currentCoords = new StratconCoords(x, y);\n+                StratconFacility facility = currentTrack.getFacility(currentCoords);\n+                \n+                if ((facility != null) && (facility.isVisible() || currentTrack.isGmRevealed())) {\n+                    g2D.setColor(facility.getOwner() == ForceAlignment.Allied ? Color.GREEN : Color.RED);\n+                    g2D.drawPolygon(facilityMarker);\n+                    drawTextEffect(g2D, facilityMarker, facility.getFormattedDisplayableName(), currentCoords);\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                facilityMarker.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            facilityMarker.translate(translationVector[0], translationVector[1]);\n+        }\n+    }\n+    \n+    /**\n+     * Worker function to render force icons to the given surface.\n+     */\n+    private void drawForces(Graphics2D g2D) {\n+        Polygon forceMarker = new Polygon();\n+        int xRadius = HEX_X_RADIUS / 3;\n+        int yRadius = HEX_Y_RADIUS / 3;\n+\n+        forceMarker.addPoint(-xRadius, -yRadius);\n+        forceMarker.addPoint(-xRadius, yRadius);\n+        forceMarker.addPoint(xRadius, yRadius);\n+        forceMarker.addPoint(xRadius, -yRadius);\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                StratconCoords currentCoords = new StratconCoords(x, y);\n+                \n+                if (currentTrack.getAssignedCoordForces().containsKey(currentCoords)) {\n+                    for (int forceID : currentTrack.getAssignedCoordForces().get(currentCoords)) {                   \n+                        g2D.setColor(Color.BLUE);\n+                        g2D.drawPolygon(forceMarker);\n+                        drawTextEffect(g2D, forceMarker, campaign.getForce(forceID).getName(), currentCoords);\n+                    }\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                forceMarker.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            forceMarker.translate(translationVector[0], translationVector[1]);\n+        }\n+    }\n+    \n+    /**\n+     * Draws some text and line to it from a given polygon. \n+     * Smart enough not to layer multiple strings on top of each other if they're all drawn in the same hex.\n+     */\n+    private void drawTextEffect(Graphics2D g2D, Polygon marker, String text, StratconCoords coords) {\n+        int verticalOffsetIndex = numIconsInHex.containsKey(coords) ? numIconsInHex.get(coords) : 0;\n+        \n+        double startX = marker.getBounds().getMaxX();\n+        double startY = marker.getBounds().getMinY();\n+        double midPointX = startX + HEX_X_RADIUS / 4;\n+        double midPointY = startY - HEX_Y_RADIUS / 4 + g2D.getFontMetrics().getHeight() * verticalOffsetIndex;\n+        double endPointX = midPointX + HEX_X_RADIUS / 2;\n+        \n+        g2D.drawLine((int) startX, (int) startY, (int) midPointX, (int) midPointY);\n+        g2D.drawLine((int) midPointX, (int) midPointY, (int) endPointX, (int) midPointY);\n+        g2D.drawString(text, (int) endPointX, (int) midPointY);\n+        \n+        // register that we drew text off of this hex\n+        verticalOffsetIndex++;\n+        numIconsInHex.put(coords, verticalOffsetIndex);\n+    }\n+\n+    /**\n+     * Returns the translation that we need to make to render the \"next downward\" hex.\n+     * @return Two dimensional array with the first element being the x vector and the second being the y vector\n+     */\n+    private int[] getDownwardYVector() {\n+        return new int[] { 0, (int) (HEX_Y_RADIUS * 2) };\n+    }\n+\n+    /**\n+     * Returns the translation that we need to make to move from the bottom of a column to the top of the next\n+     * column to the right.\n+     * @param evenColumn Whether the column we're currently in is odd or even\n+     * @return Two dimensional array with the first element being the x vector and the second being the y vector\n+     */\n+    private int[] getRightAndUPVector(boolean evenColumn) {\n+        int yRadius = (int) (HEX_Y_RADIUS);\n+        int xRadius = (int) (HEX_X_RADIUS);\n+\n+        int yTranslation = currentTrack.getHeight() * yRadius * 2;\n+        if (evenColumn) {\n+            yTranslation += yRadius;\n+        } else {\n+            yTranslation -= yRadius;\n+        }\n+\n+        return new int[] {(int) (xRadius * 1.5), -yTranslation};\n+    }\n+\n+    /**\n+     * Go to the origin of the hex board and reset the scaling.\n+     */\n+    private void performInitialTransform(Graphics2D g2D) {\n+        g2D.translate(0, 0 + HEX_Y_RADIUS);\n+        g2D.scale(scale, scale);\n+    }\n+\n+    /** \n+     * Worker function that takes the current clicked point and a graphics 2D object\n+     * and detects which hex was clicked by doing a dry run hex render.\n+     * \n+     * Dependent upon clickedPoint being set and having an active graphics object for this class.\n+     * \n+     * Side effects: the dry run sets the boardState clicked hex coordinates.\n+     * @return Whether or not the clicked point was found on the hex board\n+     */\n+    private boolean detectClickedHex() {\n+        Graphics2D g2D = (Graphics2D) getGraphics();\n+        AffineTransform transform = g2D.getTransform();\n+        performInitialTransform(g2D);\n+        boolean pointFoundOnBoard = drawHexes(g2D, DrawHexType.Dryrun);\n+        g2D.setTransform(transform);\n+\n+        return pointFoundOnBoard;\n+    }\n+\n+    /**\n+     * Event handler for when a mouse button is released.\n+     */\n+    public void mouseReleasedHandler(MouseEvent e) {\n+        if(e.getSource() != this) {", "originalCommit": "796b6728fd3cd2aea02d17122b4d735afc47dc41", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjkwMjQzNg==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r602902436", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if(pointFoundOnBoard) {\n          \n          \n            \n                        if (pointFoundOnBoard) {", "author": "Windchild292", "createdAt": "2021-03-28T16:50:07Z", "path": "MekHQ/src/mekhq/gui/StratconPanel.java", "diffHunk": "@@ -0,0 +1,672 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.gui;\n+\n+import java.awt.BasicStroke;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Point;\n+import java.awt.Polygon;\n+import java.awt.Stroke;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.awt.geom.AffineTransform;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import javax.swing.JCheckBoxMenuItem;\n+import javax.swing.JLabel;\n+import javax.swing.JMenuItem;\n+import javax.swing.JPanel;\n+import javax.swing.JPopupMenu;\n+import javax.swing.SwingUtilities;\n+\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.stratcon.StratconCampaignState;\n+import mekhq.campaign.stratcon.StratconCoords;\n+import mekhq.campaign.stratcon.StratconFacility;\n+import mekhq.campaign.stratcon.StratconScenario;\n+import mekhq.campaign.stratcon.StratconTrackState;\n+import mekhq.gui.stratcon.StratconScenarioWizard;\n+import mekhq.gui.stratcon.TrackForceAssignmentUI;\n+\n+/**\n+ * This panel handles AtB-Stratcon GUI interactions with a specific scenario track.\n+ * @author NickAragua\n+ */\n+public class StratconPanel extends JPanel implements ActionListener {\n+    /**\n+     * \n+     */\n+    private static final long serialVersionUID = 7405934788894417292L;\n+    \n+    public static final int HEX_X_RADIUS = 42;\n+    public static final int HEX_Y_RADIUS = 37;\n+    \n+    private static final String RCLICK_COMMAND_MANAGE_FORCES = \"ManageForces\";\n+    private static final String RCLICK_COMMAND_MANAGE_SCENARIO = \"ManageScenario\";\n+    private static final String RCLICK_COMMAND_REVEAL_TRACK = \"RevealTrack\";\n+    private static final String RCLICK_COMMAND_STICKY_FORCE = \"StickyForce\";\n+    private static final String RCLICK_COMMAND_STICKY_FORCE_ID = \"StickyForceID\";\n+\n+    /**\n+     * What to do when drawing a hex\n+     */\n+    private enum DrawHexType {\n+        /**\n+         * The interior of a hex\n+         */\n+        Hex,\n+        \n+        /**\n+         * The outline of a hex\n+         */\n+        Outline,\n+        \n+        /**\n+         * Pretend we're drawing a hex, but don't actually do it, useful for \n+         * figuring out which hex a mouse click landed in, etc.\n+         */\n+        Dryrun\n+    }\n+\n+    private float scale = 1f;\n+\n+    private StratconTrackState currentTrack;\n+    private StratconCampaignState campaignState;\n+    private Campaign campaign;\n+\n+    private BoardState boardState = new BoardState();\n+\n+    private Point clickedPoint;\n+    private JPopupMenu rightClickMenu;\n+    private JMenuItem menuItemManageForceAssignments;\n+    private JMenuItem menuItemManageScenario;\n+    private JMenuItem menuItemGMReveal;\n+    \n+    // data structure holding how many unit/scenario/base icons have been drawn in the hex\n+    // used to control how low the text description goes.\n+    private Map<StratconCoords, Integer> numIconsInHex = new HashMap<>();\n+    \n+    private StratconScenarioWizard scenarioWizard;\n+    private TrackForceAssignmentUI assignmentUI;\n+    \n+    private JLabel infoArea;\n+\n+    /**\n+     * Constructs a StratconPanel instance, given a parent campaign GUI and a pointer to an info area.\n+     */\n+    StratconPanel(CampaignGUI gui, JLabel infoArea) {\n+        campaign = gui.getCampaign();\n+        scenarioWizard = new StratconScenarioWizard(campaign);\n+        this.infoArea = infoArea;\n+        \n+        assignmentUI = new TrackForceAssignmentUI(this);\n+        assignmentUI.setVisible(false);\n+        \n+        addMouseListener(new MouseAdapter() {\n+            @Override\n+            public void mouseReleased(MouseEvent e) {\n+                mouseReleasedHandler(e);\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Handler for when a specific track is selected - switches rendering to that track.\n+     */\n+    public void selectTrack(StratconCampaignState campaignState, StratconTrackState track) {\n+        this.campaignState = campaignState;\n+        currentTrack = track;\n+        repaint();\n+    }\n+    \n+    /**\n+     * Constructs the right-click context menu, optionally for a scenario\n+     */\n+    private void buildRightClickMenu(StratconCoords coords) {\n+        rightClickMenu = new JPopupMenu();\n+        \n+        StratconScenario scenario = getSelectedScenario();\n+        \n+        if (scenario == null) {\n+            menuItemManageForceAssignments = new JMenuItem();\n+            menuItemManageForceAssignments.setText(\"Manage Force Assignments\");\n+            menuItemManageForceAssignments.setActionCommand(RCLICK_COMMAND_MANAGE_FORCES);\n+            menuItemManageForceAssignments.addActionListener(this);\n+            rightClickMenu.add(menuItemManageForceAssignments);\n+        }\n+        \n+        if (scenario != null) {\n+            menuItemManageScenario = new JMenuItem();\n+            menuItemManageScenario.setText(\"Manage Scenario\");\n+            menuItemManageScenario.setActionCommand(RCLICK_COMMAND_MANAGE_SCENARIO);\n+            menuItemManageScenario.addActionListener(this);\n+            rightClickMenu.add(menuItemManageScenario);\n+        }\n+        \n+        if ((currentTrack != null) && currentTrack.getAssignedCoordForces().containsKey(coords)) {\n+            for (int forceID : currentTrack.getAssignedCoordForces().get(coords)) {\n+                String forceName = campaign.getForce(forceID).getName();\n+                \n+                JCheckBoxMenuItem stickyForceItem = new JCheckBoxMenuItem();\n+                stickyForceItem.setText(String.format(\"%s - remain deployed\", forceName));\n+                stickyForceItem.setActionCommand(RCLICK_COMMAND_STICKY_FORCE);\n+                stickyForceItem.putClientProperty(RCLICK_COMMAND_STICKY_FORCE_ID, forceID);\n+                stickyForceItem.addActionListener(this);\n+                stickyForceItem.setSelected(currentTrack.getStickyForces().contains(forceID));\n+                rightClickMenu.add(stickyForceItem);\n+            }\n+        }\n+            \n+        if ((currentTrack != null) && campaign.isGM()) {\n+            rightClickMenu.addSeparator();\n+            \n+            menuItemGMReveal = new JMenuItem();\n+            menuItemGMReveal.setText(currentTrack.isGmRevealed() ? \"Hide Track\" : \"Reveal Track\");\n+            menuItemGMReveal.setActionCommand(RCLICK_COMMAND_REVEAL_TRACK);\n+            menuItemGMReveal.addActionListener(this);\n+            rightClickMenu.add(menuItemGMReveal);\n+        }\n+    }\n+\n+    /**\n+     * Renders the panel, hexes, forces, facilities and all that.\n+     */\n+    @Override\n+    public void paintComponent(Graphics g) {\n+        super.paintComponent(g);\n+        if (campaignState == null || currentTrack == null) {\n+            return;\n+        }\n+        \n+        numIconsInHex.clear();\n+\n+        Graphics2D g2D = (Graphics2D) g;\n+        AffineTransform initialTransform = g2D.getTransform();\n+        performInitialTransform(g2D);\n+        AffineTransform originTransform = g2D.getTransform();\n+\n+        drawHexes(g2D, DrawHexType.Hex);\n+        g2D.setTransform(originTransform);\n+        drawHexes(g2D, DrawHexType.Outline);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawScenarios(g2D);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawFacilities(g2D);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawForces(g2D);\n+\n+        g2D.setTransform(initialTransform);\n+        if (clickedPoint != null) {\n+            g2D.setColor(Color.BLUE);\n+            g2D.drawRect((int) clickedPoint.getX(), (int) clickedPoint.getY(), 2, 2);\n+        }\n+    }\n+\n+    /**\n+     * This method contains a dirty secret hack, but I forget what it is.\n+     * The point of it is to draw all the hexes for the board. \n+     * If it's a \"dry run\", we don't actually draw the hexes, we just pretend to\n+     * until we \"draw\" one that encompasses the clicked point.\n+     * @param g2D - graphics object on which to draw\n+     * @param drawHexType - whether to draw the hex backgrounds, hex outlines or a dry run for click detection\n+     */\n+    private boolean drawHexes(Graphics2D g2D, DrawHexType drawHexType) {\n+        Polygon graphHex = new Polygon();\n+        int xRadius = HEX_X_RADIUS;\n+        int yRadius = HEX_Y_RADIUS;\n+        boolean pointFound = false;\n+\n+        graphHex.addPoint(-xRadius/2, -yRadius);\n+        graphHex.addPoint(-xRadius, 0);\n+        graphHex.addPoint(-xRadius/2, yRadius);\n+        graphHex.addPoint(xRadius/2, yRadius);\n+        graphHex.addPoint(xRadius, 0);\n+        graphHex.addPoint(xRadius/2, -yRadius);\n+\n+        graphHex.translate(xRadius, yRadius);\n+\n+        Point translatedClickedPoint = null;\n+\n+        // this was derived somewhat experimentally\n+        // the clicked point always seems a little off, so we \n+        // a) apply the current transform to it, prior to drawing all the hexes\n+        // b) subtract an additional Y_RADIUS x 2 (Y_DIAMETER)\n+        // this gets us the point within the clicked hex\n+        // it's probably finicky, so any major changes to the rendering mechanism will likely break the detection\n+        if (clickedPoint != null) {\n+            translatedClickedPoint = (Point) clickedPoint.clone();\n+            \n+            // since we have the possibility of scrolling, we need to convert the on-screen clicked coordinates\n+            // to on-board coordinates. Thankfully, SwingUtilities provides the main computational ability for that\n+            Point actualPanelPoint = SwingUtilities.convertPoint(this, translatedClickedPoint, this.getParent());\n+            translatedClickedPoint.translate((int) -(actualPanelPoint.getX() - translatedClickedPoint.getX()), \n+                                                (int) -(actualPanelPoint.getY() - translatedClickedPoint.getY()));\n+            \n+            // now we translate to the starting point of where we're drawing and then go down a hex\n+            translatedClickedPoint.translate((int) g2D.getTransform().getTranslateX(), (int) g2D.getTransform().getTranslateY());\n+            translatedClickedPoint.translate(0, -(HEX_Y_RADIUS * 2));\n+        }\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                if(drawHexType == DrawHexType.Outline) {\n+                    g2D.setColor(new Color(0, 0, 0));\n+                    g2D.drawPolygon(graphHex);                    \n+                } else if (drawHexType == DrawHexType.Hex) {\n+                    \n+                    if (currentTrack.coordsRevealed(x, y) || currentTrack.isGmRevealed()) {\n+                        g2D.setColor(Color.LIGHT_GRAY);\n+                    } else {\n+                        g2D.setColor(Color.DARK_GRAY);\n+                    }\n+                    g2D.fillPolygon(graphHex);\n+                    \n+                    if (translatedClickedPoint != null && graphHex.contains(translatedClickedPoint)) {\n+                        g2D.setColor(Color.WHITE);\n+                        BasicStroke s = new BasicStroke((float) 8.0);\n+                        Stroke push = g2D.getStroke();\n+                        g2D.setStroke(s);\n+                        g2D.drawPolygon(graphHex);\n+                        \n+                        boardState.selectedX = x;\n+                        boardState.selectedY = y;\n+                        pointFound = true;\n+                        g2D.setStroke(push);\n+                    }\n+                } else if (drawHexType == DrawHexType.Dryrun) {\n+                    if (translatedClickedPoint != null && graphHex.contains(translatedClickedPoint)) {\n+                        boardState.selectedX = x;\n+                        boardState.selectedY = y;\n+                        pointFound = true;\n+                    }\n+                }\n+\n+                if (drawHexType == DrawHexType.Hex) {\n+                    g2D.setColor(Color.GREEN);\n+                    g2D.drawString(x + \",\" + y, graphHex.xpoints[0] + (xRadius / 4), graphHex.ypoints[0] + yRadius);\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                graphHex.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            graphHex.translate(translationVector[0], translationVector[1]);\n+        }\n+\n+        return pointFound;\n+    }\n+\n+    /**\n+     * Worker function to render icons representing scenarios to the given surface.\n+     */\n+    private void drawScenarios(Graphics2D g2D) {\n+        Polygon scenarioMarker = new Polygon();\n+        int xRadius = HEX_X_RADIUS / 3;\n+        int yRadius = HEX_Y_RADIUS / 3;\n+\n+        scenarioMarker.addPoint(-xRadius, -yRadius);\n+        scenarioMarker.addPoint(-xRadius, yRadius);\n+        scenarioMarker.addPoint(xRadius, yRadius);\n+        scenarioMarker.addPoint(xRadius, -yRadius);\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                StratconCoords currentCoords = new StratconCoords(x, y);\n+                StratconScenario scenario = currentTrack.getScenario(currentCoords);\n+                \n+                // if there's a scenario here that has a deployment/battle date\n+                // or if there's a scenario here and we've gm-revealed everything\n+                if ((scenario != null) &&\n+                        ((scenario.getDeploymentDate() != null) || currentTrack.isGmRevealed())) {\n+                    g2D.setColor(Color.RED);\n+                    g2D.drawPolygon(scenarioMarker);\n+                    if(currentTrack.getFacility(currentCoords) == null) {\n+                        drawTextEffect(g2D, scenarioMarker, \"Hostile Force Detected\", currentCoords);\n+                    }\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                scenarioMarker.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            scenarioMarker.translate(translationVector[0], translationVector[1]);\n+        }\n+    }\n+    \n+    /**\n+     * Worker function to render facility icons to the given surface.\n+     */\n+    private void drawFacilities(Graphics2D g2D) {\n+        Polygon facilityMarker = new Polygon();\n+        int xRadius = HEX_X_RADIUS / 3;\n+        int yRadius = HEX_Y_RADIUS / 3;\n+\n+        facilityMarker.addPoint(-xRadius, -yRadius);\n+        facilityMarker.addPoint(-xRadius, yRadius);\n+        facilityMarker.addPoint(xRadius, yRadius);\n+        facilityMarker.addPoint(xRadius, -yRadius);\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                StratconCoords currentCoords = new StratconCoords(x, y);\n+                StratconFacility facility = currentTrack.getFacility(currentCoords);\n+                \n+                if ((facility != null) && (facility.isVisible() || currentTrack.isGmRevealed())) {\n+                    g2D.setColor(facility.getOwner() == ForceAlignment.Allied ? Color.GREEN : Color.RED);\n+                    g2D.drawPolygon(facilityMarker);\n+                    drawTextEffect(g2D, facilityMarker, facility.getFormattedDisplayableName(), currentCoords);\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                facilityMarker.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            facilityMarker.translate(translationVector[0], translationVector[1]);\n+        }\n+    }\n+    \n+    /**\n+     * Worker function to render force icons to the given surface.\n+     */\n+    private void drawForces(Graphics2D g2D) {\n+        Polygon forceMarker = new Polygon();\n+        int xRadius = HEX_X_RADIUS / 3;\n+        int yRadius = HEX_Y_RADIUS / 3;\n+\n+        forceMarker.addPoint(-xRadius, -yRadius);\n+        forceMarker.addPoint(-xRadius, yRadius);\n+        forceMarker.addPoint(xRadius, yRadius);\n+        forceMarker.addPoint(xRadius, -yRadius);\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                StratconCoords currentCoords = new StratconCoords(x, y);\n+                \n+                if (currentTrack.getAssignedCoordForces().containsKey(currentCoords)) {\n+                    for (int forceID : currentTrack.getAssignedCoordForces().get(currentCoords)) {                   \n+                        g2D.setColor(Color.BLUE);\n+                        g2D.drawPolygon(forceMarker);\n+                        drawTextEffect(g2D, forceMarker, campaign.getForce(forceID).getName(), currentCoords);\n+                    }\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                forceMarker.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            forceMarker.translate(translationVector[0], translationVector[1]);\n+        }\n+    }\n+    \n+    /**\n+     * Draws some text and line to it from a given polygon. \n+     * Smart enough not to layer multiple strings on top of each other if they're all drawn in the same hex.\n+     */\n+    private void drawTextEffect(Graphics2D g2D, Polygon marker, String text, StratconCoords coords) {\n+        int verticalOffsetIndex = numIconsInHex.containsKey(coords) ? numIconsInHex.get(coords) : 0;\n+        \n+        double startX = marker.getBounds().getMaxX();\n+        double startY = marker.getBounds().getMinY();\n+        double midPointX = startX + HEX_X_RADIUS / 4;\n+        double midPointY = startY - HEX_Y_RADIUS / 4 + g2D.getFontMetrics().getHeight() * verticalOffsetIndex;\n+        double endPointX = midPointX + HEX_X_RADIUS / 2;\n+        \n+        g2D.drawLine((int) startX, (int) startY, (int) midPointX, (int) midPointY);\n+        g2D.drawLine((int) midPointX, (int) midPointY, (int) endPointX, (int) midPointY);\n+        g2D.drawString(text, (int) endPointX, (int) midPointY);\n+        \n+        // register that we drew text off of this hex\n+        verticalOffsetIndex++;\n+        numIconsInHex.put(coords, verticalOffsetIndex);\n+    }\n+\n+    /**\n+     * Returns the translation that we need to make to render the \"next downward\" hex.\n+     * @return Two dimensional array with the first element being the x vector and the second being the y vector\n+     */\n+    private int[] getDownwardYVector() {\n+        return new int[] { 0, (int) (HEX_Y_RADIUS * 2) };\n+    }\n+\n+    /**\n+     * Returns the translation that we need to make to move from the bottom of a column to the top of the next\n+     * column to the right.\n+     * @param evenColumn Whether the column we're currently in is odd or even\n+     * @return Two dimensional array with the first element being the x vector and the second being the y vector\n+     */\n+    private int[] getRightAndUPVector(boolean evenColumn) {\n+        int yRadius = (int) (HEX_Y_RADIUS);\n+        int xRadius = (int) (HEX_X_RADIUS);\n+\n+        int yTranslation = currentTrack.getHeight() * yRadius * 2;\n+        if (evenColumn) {\n+            yTranslation += yRadius;\n+        } else {\n+            yTranslation -= yRadius;\n+        }\n+\n+        return new int[] {(int) (xRadius * 1.5), -yTranslation};\n+    }\n+\n+    /**\n+     * Go to the origin of the hex board and reset the scaling.\n+     */\n+    private void performInitialTransform(Graphics2D g2D) {\n+        g2D.translate(0, 0 + HEX_Y_RADIUS);\n+        g2D.scale(scale, scale);\n+    }\n+\n+    /** \n+     * Worker function that takes the current clicked point and a graphics 2D object\n+     * and detects which hex was clicked by doing a dry run hex render.\n+     * \n+     * Dependent upon clickedPoint being set and having an active graphics object for this class.\n+     * \n+     * Side effects: the dry run sets the boardState clicked hex coordinates.\n+     * @return Whether or not the clicked point was found on the hex board\n+     */\n+    private boolean detectClickedHex() {\n+        Graphics2D g2D = (Graphics2D) getGraphics();\n+        AffineTransform transform = g2D.getTransform();\n+        performInitialTransform(g2D);\n+        boolean pointFoundOnBoard = drawHexes(g2D, DrawHexType.Dryrun);\n+        g2D.setTransform(transform);\n+\n+        return pointFoundOnBoard;\n+    }\n+\n+    /**\n+     * Event handler for when a mouse button is released.\n+     */\n+    public void mouseReleasedHandler(MouseEvent e) {\n+        if(e.getSource() != this) {\n+            return;\n+        }\n+\n+        // left button generally selects a hex\n+        if (e.getButton() == MouseEvent.BUTTON1) {        \n+            clickedPoint = e.getPoint();\n+            boolean pointFoundOnBoard = detectClickedHex();\n+            \n+            if(pointFoundOnBoard) {", "originalCommit": "796b6728fd3cd2aea02d17122b4d735afc47dc41", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjkwMjQ5Mw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r602902493", "bodyText": "Just chain appends on different lines", "author": "Windchild292", "createdAt": "2021-03-28T16:50:36Z", "path": "MekHQ/src/mekhq/gui/StratconPanel.java", "diffHunk": "@@ -0,0 +1,672 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.gui;\n+\n+import java.awt.BasicStroke;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Point;\n+import java.awt.Polygon;\n+import java.awt.Stroke;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.awt.geom.AffineTransform;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import javax.swing.JCheckBoxMenuItem;\n+import javax.swing.JLabel;\n+import javax.swing.JMenuItem;\n+import javax.swing.JPanel;\n+import javax.swing.JPopupMenu;\n+import javax.swing.SwingUtilities;\n+\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.stratcon.StratconCampaignState;\n+import mekhq.campaign.stratcon.StratconCoords;\n+import mekhq.campaign.stratcon.StratconFacility;\n+import mekhq.campaign.stratcon.StratconScenario;\n+import mekhq.campaign.stratcon.StratconTrackState;\n+import mekhq.gui.stratcon.StratconScenarioWizard;\n+import mekhq.gui.stratcon.TrackForceAssignmentUI;\n+\n+/**\n+ * This panel handles AtB-Stratcon GUI interactions with a specific scenario track.\n+ * @author NickAragua\n+ */\n+public class StratconPanel extends JPanel implements ActionListener {\n+    /**\n+     * \n+     */\n+    private static final long serialVersionUID = 7405934788894417292L;\n+    \n+    public static final int HEX_X_RADIUS = 42;\n+    public static final int HEX_Y_RADIUS = 37;\n+    \n+    private static final String RCLICK_COMMAND_MANAGE_FORCES = \"ManageForces\";\n+    private static final String RCLICK_COMMAND_MANAGE_SCENARIO = \"ManageScenario\";\n+    private static final String RCLICK_COMMAND_REVEAL_TRACK = \"RevealTrack\";\n+    private static final String RCLICK_COMMAND_STICKY_FORCE = \"StickyForce\";\n+    private static final String RCLICK_COMMAND_STICKY_FORCE_ID = \"StickyForceID\";\n+\n+    /**\n+     * What to do when drawing a hex\n+     */\n+    private enum DrawHexType {\n+        /**\n+         * The interior of a hex\n+         */\n+        Hex,\n+        \n+        /**\n+         * The outline of a hex\n+         */\n+        Outline,\n+        \n+        /**\n+         * Pretend we're drawing a hex, but don't actually do it, useful for \n+         * figuring out which hex a mouse click landed in, etc.\n+         */\n+        Dryrun\n+    }\n+\n+    private float scale = 1f;\n+\n+    private StratconTrackState currentTrack;\n+    private StratconCampaignState campaignState;\n+    private Campaign campaign;\n+\n+    private BoardState boardState = new BoardState();\n+\n+    private Point clickedPoint;\n+    private JPopupMenu rightClickMenu;\n+    private JMenuItem menuItemManageForceAssignments;\n+    private JMenuItem menuItemManageScenario;\n+    private JMenuItem menuItemGMReveal;\n+    \n+    // data structure holding how many unit/scenario/base icons have been drawn in the hex\n+    // used to control how low the text description goes.\n+    private Map<StratconCoords, Integer> numIconsInHex = new HashMap<>();\n+    \n+    private StratconScenarioWizard scenarioWizard;\n+    private TrackForceAssignmentUI assignmentUI;\n+    \n+    private JLabel infoArea;\n+\n+    /**\n+     * Constructs a StratconPanel instance, given a parent campaign GUI and a pointer to an info area.\n+     */\n+    StratconPanel(CampaignGUI gui, JLabel infoArea) {\n+        campaign = gui.getCampaign();\n+        scenarioWizard = new StratconScenarioWizard(campaign);\n+        this.infoArea = infoArea;\n+        \n+        assignmentUI = new TrackForceAssignmentUI(this);\n+        assignmentUI.setVisible(false);\n+        \n+        addMouseListener(new MouseAdapter() {\n+            @Override\n+            public void mouseReleased(MouseEvent e) {\n+                mouseReleasedHandler(e);\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Handler for when a specific track is selected - switches rendering to that track.\n+     */\n+    public void selectTrack(StratconCampaignState campaignState, StratconTrackState track) {\n+        this.campaignState = campaignState;\n+        currentTrack = track;\n+        repaint();\n+    }\n+    \n+    /**\n+     * Constructs the right-click context menu, optionally for a scenario\n+     */\n+    private void buildRightClickMenu(StratconCoords coords) {\n+        rightClickMenu = new JPopupMenu();\n+        \n+        StratconScenario scenario = getSelectedScenario();\n+        \n+        if (scenario == null) {\n+            menuItemManageForceAssignments = new JMenuItem();\n+            menuItemManageForceAssignments.setText(\"Manage Force Assignments\");\n+            menuItemManageForceAssignments.setActionCommand(RCLICK_COMMAND_MANAGE_FORCES);\n+            menuItemManageForceAssignments.addActionListener(this);\n+            rightClickMenu.add(menuItemManageForceAssignments);\n+        }\n+        \n+        if (scenario != null) {\n+            menuItemManageScenario = new JMenuItem();\n+            menuItemManageScenario.setText(\"Manage Scenario\");\n+            menuItemManageScenario.setActionCommand(RCLICK_COMMAND_MANAGE_SCENARIO);\n+            menuItemManageScenario.addActionListener(this);\n+            rightClickMenu.add(menuItemManageScenario);\n+        }\n+        \n+        if ((currentTrack != null) && currentTrack.getAssignedCoordForces().containsKey(coords)) {\n+            for (int forceID : currentTrack.getAssignedCoordForces().get(coords)) {\n+                String forceName = campaign.getForce(forceID).getName();\n+                \n+                JCheckBoxMenuItem stickyForceItem = new JCheckBoxMenuItem();\n+                stickyForceItem.setText(String.format(\"%s - remain deployed\", forceName));\n+                stickyForceItem.setActionCommand(RCLICK_COMMAND_STICKY_FORCE);\n+                stickyForceItem.putClientProperty(RCLICK_COMMAND_STICKY_FORCE_ID, forceID);\n+                stickyForceItem.addActionListener(this);\n+                stickyForceItem.setSelected(currentTrack.getStickyForces().contains(forceID));\n+                rightClickMenu.add(stickyForceItem);\n+            }\n+        }\n+            \n+        if ((currentTrack != null) && campaign.isGM()) {\n+            rightClickMenu.addSeparator();\n+            \n+            menuItemGMReveal = new JMenuItem();\n+            menuItemGMReveal.setText(currentTrack.isGmRevealed() ? \"Hide Track\" : \"Reveal Track\");\n+            menuItemGMReveal.setActionCommand(RCLICK_COMMAND_REVEAL_TRACK);\n+            menuItemGMReveal.addActionListener(this);\n+            rightClickMenu.add(menuItemGMReveal);\n+        }\n+    }\n+\n+    /**\n+     * Renders the panel, hexes, forces, facilities and all that.\n+     */\n+    @Override\n+    public void paintComponent(Graphics g) {\n+        super.paintComponent(g);\n+        if (campaignState == null || currentTrack == null) {\n+            return;\n+        }\n+        \n+        numIconsInHex.clear();\n+\n+        Graphics2D g2D = (Graphics2D) g;\n+        AffineTransform initialTransform = g2D.getTransform();\n+        performInitialTransform(g2D);\n+        AffineTransform originTransform = g2D.getTransform();\n+\n+        drawHexes(g2D, DrawHexType.Hex);\n+        g2D.setTransform(originTransform);\n+        drawHexes(g2D, DrawHexType.Outline);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawScenarios(g2D);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawFacilities(g2D);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawForces(g2D);\n+\n+        g2D.setTransform(initialTransform);\n+        if (clickedPoint != null) {\n+            g2D.setColor(Color.BLUE);\n+            g2D.drawRect((int) clickedPoint.getX(), (int) clickedPoint.getY(), 2, 2);\n+        }\n+    }\n+\n+    /**\n+     * This method contains a dirty secret hack, but I forget what it is.\n+     * The point of it is to draw all the hexes for the board. \n+     * If it's a \"dry run\", we don't actually draw the hexes, we just pretend to\n+     * until we \"draw\" one that encompasses the clicked point.\n+     * @param g2D - graphics object on which to draw\n+     * @param drawHexType - whether to draw the hex backgrounds, hex outlines or a dry run for click detection\n+     */\n+    private boolean drawHexes(Graphics2D g2D, DrawHexType drawHexType) {\n+        Polygon graphHex = new Polygon();\n+        int xRadius = HEX_X_RADIUS;\n+        int yRadius = HEX_Y_RADIUS;\n+        boolean pointFound = false;\n+\n+        graphHex.addPoint(-xRadius/2, -yRadius);\n+        graphHex.addPoint(-xRadius, 0);\n+        graphHex.addPoint(-xRadius/2, yRadius);\n+        graphHex.addPoint(xRadius/2, yRadius);\n+        graphHex.addPoint(xRadius, 0);\n+        graphHex.addPoint(xRadius/2, -yRadius);\n+\n+        graphHex.translate(xRadius, yRadius);\n+\n+        Point translatedClickedPoint = null;\n+\n+        // this was derived somewhat experimentally\n+        // the clicked point always seems a little off, so we \n+        // a) apply the current transform to it, prior to drawing all the hexes\n+        // b) subtract an additional Y_RADIUS x 2 (Y_DIAMETER)\n+        // this gets us the point within the clicked hex\n+        // it's probably finicky, so any major changes to the rendering mechanism will likely break the detection\n+        if (clickedPoint != null) {\n+            translatedClickedPoint = (Point) clickedPoint.clone();\n+            \n+            // since we have the possibility of scrolling, we need to convert the on-screen clicked coordinates\n+            // to on-board coordinates. Thankfully, SwingUtilities provides the main computational ability for that\n+            Point actualPanelPoint = SwingUtilities.convertPoint(this, translatedClickedPoint, this.getParent());\n+            translatedClickedPoint.translate((int) -(actualPanelPoint.getX() - translatedClickedPoint.getX()), \n+                                                (int) -(actualPanelPoint.getY() - translatedClickedPoint.getY()));\n+            \n+            // now we translate to the starting point of where we're drawing and then go down a hex\n+            translatedClickedPoint.translate((int) g2D.getTransform().getTranslateX(), (int) g2D.getTransform().getTranslateY());\n+            translatedClickedPoint.translate(0, -(HEX_Y_RADIUS * 2));\n+        }\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                if(drawHexType == DrawHexType.Outline) {\n+                    g2D.setColor(new Color(0, 0, 0));\n+                    g2D.drawPolygon(graphHex);                    \n+                } else if (drawHexType == DrawHexType.Hex) {\n+                    \n+                    if (currentTrack.coordsRevealed(x, y) || currentTrack.isGmRevealed()) {\n+                        g2D.setColor(Color.LIGHT_GRAY);\n+                    } else {\n+                        g2D.setColor(Color.DARK_GRAY);\n+                    }\n+                    g2D.fillPolygon(graphHex);\n+                    \n+                    if (translatedClickedPoint != null && graphHex.contains(translatedClickedPoint)) {\n+                        g2D.setColor(Color.WHITE);\n+                        BasicStroke s = new BasicStroke((float) 8.0);\n+                        Stroke push = g2D.getStroke();\n+                        g2D.setStroke(s);\n+                        g2D.drawPolygon(graphHex);\n+                        \n+                        boardState.selectedX = x;\n+                        boardState.selectedY = y;\n+                        pointFound = true;\n+                        g2D.setStroke(push);\n+                    }\n+                } else if (drawHexType == DrawHexType.Dryrun) {\n+                    if (translatedClickedPoint != null && graphHex.contains(translatedClickedPoint)) {\n+                        boardState.selectedX = x;\n+                        boardState.selectedY = y;\n+                        pointFound = true;\n+                    }\n+                }\n+\n+                if (drawHexType == DrawHexType.Hex) {\n+                    g2D.setColor(Color.GREEN);\n+                    g2D.drawString(x + \",\" + y, graphHex.xpoints[0] + (xRadius / 4), graphHex.ypoints[0] + yRadius);\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                graphHex.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            graphHex.translate(translationVector[0], translationVector[1]);\n+        }\n+\n+        return pointFound;\n+    }\n+\n+    /**\n+     * Worker function to render icons representing scenarios to the given surface.\n+     */\n+    private void drawScenarios(Graphics2D g2D) {\n+        Polygon scenarioMarker = new Polygon();\n+        int xRadius = HEX_X_RADIUS / 3;\n+        int yRadius = HEX_Y_RADIUS / 3;\n+\n+        scenarioMarker.addPoint(-xRadius, -yRadius);\n+        scenarioMarker.addPoint(-xRadius, yRadius);\n+        scenarioMarker.addPoint(xRadius, yRadius);\n+        scenarioMarker.addPoint(xRadius, -yRadius);\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                StratconCoords currentCoords = new StratconCoords(x, y);\n+                StratconScenario scenario = currentTrack.getScenario(currentCoords);\n+                \n+                // if there's a scenario here that has a deployment/battle date\n+                // or if there's a scenario here and we've gm-revealed everything\n+                if ((scenario != null) &&\n+                        ((scenario.getDeploymentDate() != null) || currentTrack.isGmRevealed())) {\n+                    g2D.setColor(Color.RED);\n+                    g2D.drawPolygon(scenarioMarker);\n+                    if(currentTrack.getFacility(currentCoords) == null) {\n+                        drawTextEffect(g2D, scenarioMarker, \"Hostile Force Detected\", currentCoords);\n+                    }\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                scenarioMarker.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            scenarioMarker.translate(translationVector[0], translationVector[1]);\n+        }\n+    }\n+    \n+    /**\n+     * Worker function to render facility icons to the given surface.\n+     */\n+    private void drawFacilities(Graphics2D g2D) {\n+        Polygon facilityMarker = new Polygon();\n+        int xRadius = HEX_X_RADIUS / 3;\n+        int yRadius = HEX_Y_RADIUS / 3;\n+\n+        facilityMarker.addPoint(-xRadius, -yRadius);\n+        facilityMarker.addPoint(-xRadius, yRadius);\n+        facilityMarker.addPoint(xRadius, yRadius);\n+        facilityMarker.addPoint(xRadius, -yRadius);\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                StratconCoords currentCoords = new StratconCoords(x, y);\n+                StratconFacility facility = currentTrack.getFacility(currentCoords);\n+                \n+                if ((facility != null) && (facility.isVisible() || currentTrack.isGmRevealed())) {\n+                    g2D.setColor(facility.getOwner() == ForceAlignment.Allied ? Color.GREEN : Color.RED);\n+                    g2D.drawPolygon(facilityMarker);\n+                    drawTextEffect(g2D, facilityMarker, facility.getFormattedDisplayableName(), currentCoords);\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                facilityMarker.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            facilityMarker.translate(translationVector[0], translationVector[1]);\n+        }\n+    }\n+    \n+    /**\n+     * Worker function to render force icons to the given surface.\n+     */\n+    private void drawForces(Graphics2D g2D) {\n+        Polygon forceMarker = new Polygon();\n+        int xRadius = HEX_X_RADIUS / 3;\n+        int yRadius = HEX_Y_RADIUS / 3;\n+\n+        forceMarker.addPoint(-xRadius, -yRadius);\n+        forceMarker.addPoint(-xRadius, yRadius);\n+        forceMarker.addPoint(xRadius, yRadius);\n+        forceMarker.addPoint(xRadius, -yRadius);\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                StratconCoords currentCoords = new StratconCoords(x, y);\n+                \n+                if (currentTrack.getAssignedCoordForces().containsKey(currentCoords)) {\n+                    for (int forceID : currentTrack.getAssignedCoordForces().get(currentCoords)) {                   \n+                        g2D.setColor(Color.BLUE);\n+                        g2D.drawPolygon(forceMarker);\n+                        drawTextEffect(g2D, forceMarker, campaign.getForce(forceID).getName(), currentCoords);\n+                    }\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                forceMarker.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            forceMarker.translate(translationVector[0], translationVector[1]);\n+        }\n+    }\n+    \n+    /**\n+     * Draws some text and line to it from a given polygon. \n+     * Smart enough not to layer multiple strings on top of each other if they're all drawn in the same hex.\n+     */\n+    private void drawTextEffect(Graphics2D g2D, Polygon marker, String text, StratconCoords coords) {\n+        int verticalOffsetIndex = numIconsInHex.containsKey(coords) ? numIconsInHex.get(coords) : 0;\n+        \n+        double startX = marker.getBounds().getMaxX();\n+        double startY = marker.getBounds().getMinY();\n+        double midPointX = startX + HEX_X_RADIUS / 4;\n+        double midPointY = startY - HEX_Y_RADIUS / 4 + g2D.getFontMetrics().getHeight() * verticalOffsetIndex;\n+        double endPointX = midPointX + HEX_X_RADIUS / 2;\n+        \n+        g2D.drawLine((int) startX, (int) startY, (int) midPointX, (int) midPointY);\n+        g2D.drawLine((int) midPointX, (int) midPointY, (int) endPointX, (int) midPointY);\n+        g2D.drawString(text, (int) endPointX, (int) midPointY);\n+        \n+        // register that we drew text off of this hex\n+        verticalOffsetIndex++;\n+        numIconsInHex.put(coords, verticalOffsetIndex);\n+    }\n+\n+    /**\n+     * Returns the translation that we need to make to render the \"next downward\" hex.\n+     * @return Two dimensional array with the first element being the x vector and the second being the y vector\n+     */\n+    private int[] getDownwardYVector() {\n+        return new int[] { 0, (int) (HEX_Y_RADIUS * 2) };\n+    }\n+\n+    /**\n+     * Returns the translation that we need to make to move from the bottom of a column to the top of the next\n+     * column to the right.\n+     * @param evenColumn Whether the column we're currently in is odd or even\n+     * @return Two dimensional array with the first element being the x vector and the second being the y vector\n+     */\n+    private int[] getRightAndUPVector(boolean evenColumn) {\n+        int yRadius = (int) (HEX_Y_RADIUS);\n+        int xRadius = (int) (HEX_X_RADIUS);\n+\n+        int yTranslation = currentTrack.getHeight() * yRadius * 2;\n+        if (evenColumn) {\n+            yTranslation += yRadius;\n+        } else {\n+            yTranslation -= yRadius;\n+        }\n+\n+        return new int[] {(int) (xRadius * 1.5), -yTranslation};\n+    }\n+\n+    /**\n+     * Go to the origin of the hex board and reset the scaling.\n+     */\n+    private void performInitialTransform(Graphics2D g2D) {\n+        g2D.translate(0, 0 + HEX_Y_RADIUS);\n+        g2D.scale(scale, scale);\n+    }\n+\n+    /** \n+     * Worker function that takes the current clicked point and a graphics 2D object\n+     * and detects which hex was clicked by doing a dry run hex render.\n+     * \n+     * Dependent upon clickedPoint being set and having an active graphics object for this class.\n+     * \n+     * Side effects: the dry run sets the boardState clicked hex coordinates.\n+     * @return Whether or not the clicked point was found on the hex board\n+     */\n+    private boolean detectClickedHex() {\n+        Graphics2D g2D = (Graphics2D) getGraphics();\n+        AffineTransform transform = g2D.getTransform();\n+        performInitialTransform(g2D);\n+        boolean pointFoundOnBoard = drawHexes(g2D, DrawHexType.Dryrun);\n+        g2D.setTransform(transform);\n+\n+        return pointFoundOnBoard;\n+    }\n+\n+    /**\n+     * Event handler for when a mouse button is released.\n+     */\n+    public void mouseReleasedHandler(MouseEvent e) {\n+        if(e.getSource() != this) {\n+            return;\n+        }\n+\n+        // left button generally selects a hex\n+        if (e.getButton() == MouseEvent.BUTTON1) {        \n+            clickedPoint = e.getPoint();\n+            boolean pointFoundOnBoard = detectClickedHex();\n+            \n+            if(pointFoundOnBoard) {\n+                infoArea.setText(buildSelectedHexInfo());\n+            }\n+\n+            repaint();\n+        // right button generally pops up a context menu\n+        } else if (e.getButton() == MouseEvent.BUTTON3) {\n+            clickedPoint = e.getPoint();\n+            detectClickedHex();\n+            \n+            StratconCoords selectedCoords = boardState.getSelectedCoords();\n+            if (selectedCoords == null) {\n+                return;\n+            }\n+            \n+            repaint();\n+            buildRightClickMenu(selectedCoords);\n+            rightClickMenu.show(this, e.getX(), e.getY());\n+        }\n+    }\n+    \n+    public StratconScenario getSelectedScenario() {\n+        return currentTrack.getScenario(boardState.getSelectedCoords());\n+    }\n+    \n+    /**\n+     * Worker function that outputs html representing the status of a selected hex,\n+     * containing info such as whether it's been revealed, assigned forces, scenarios, facilities, etc.\n+     */\n+    private String buildSelectedHexInfo() {\n+        StringBuilder infoBuilder = new StringBuilder();\n+        infoBuilder.append(\"<html><br/>\");\n+        \n+        boolean coordsRevealed = currentTrack.getRevealedCoords().contains(boardState.getSelectedCoords());\n+        if (coordsRevealed) {\n+            infoBuilder.append(\"<span color='green'>Recon complete</span><br/>\");\n+        }\n+        \n+        if (currentTrack.getAssignedCoordForces().containsKey(boardState.getSelectedCoords())) {\n+            for (int forceID : currentTrack.getAssignedCoordForces().get(boardState.getSelectedCoords())) {\n+                Force force = campaign.getForce(forceID);\n+                infoBuilder.append(force.getName()).append(\" assigned\");\n+                \n+                if (currentTrack.getStickyForces().contains(forceID)) {\n+                    infoBuilder.append(\" - remain deployed\");\n+                }\n+                \n+                infoBuilder.append(\"<br/>\");\n+                \n+                infoBuilder.append(\"Returns on \").append(currentTrack.getAssignedForceReturnDates().get(forceID));\n+                infoBuilder.append(\"<br/>\");", "originalCommit": "796b6728fd3cd2aea02d17122b4d735afc47dc41", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjkwMjUyNQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r602902525", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if((facility != null) && (facility.getFacilityType() != null)) {\n          \n          \n            \n                        if ((facility != null) && (facility.getFacilityType() != null)) {", "author": "Windchild292", "createdAt": "2021-03-28T16:50:46Z", "path": "MekHQ/src/mekhq/gui/StratconPanel.java", "diffHunk": "@@ -0,0 +1,672 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.gui;\n+\n+import java.awt.BasicStroke;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Point;\n+import java.awt.Polygon;\n+import java.awt.Stroke;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.awt.geom.AffineTransform;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import javax.swing.JCheckBoxMenuItem;\n+import javax.swing.JLabel;\n+import javax.swing.JMenuItem;\n+import javax.swing.JPanel;\n+import javax.swing.JPopupMenu;\n+import javax.swing.SwingUtilities;\n+\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.stratcon.StratconCampaignState;\n+import mekhq.campaign.stratcon.StratconCoords;\n+import mekhq.campaign.stratcon.StratconFacility;\n+import mekhq.campaign.stratcon.StratconScenario;\n+import mekhq.campaign.stratcon.StratconTrackState;\n+import mekhq.gui.stratcon.StratconScenarioWizard;\n+import mekhq.gui.stratcon.TrackForceAssignmentUI;\n+\n+/**\n+ * This panel handles AtB-Stratcon GUI interactions with a specific scenario track.\n+ * @author NickAragua\n+ */\n+public class StratconPanel extends JPanel implements ActionListener {\n+    /**\n+     * \n+     */\n+    private static final long serialVersionUID = 7405934788894417292L;\n+    \n+    public static final int HEX_X_RADIUS = 42;\n+    public static final int HEX_Y_RADIUS = 37;\n+    \n+    private static final String RCLICK_COMMAND_MANAGE_FORCES = \"ManageForces\";\n+    private static final String RCLICK_COMMAND_MANAGE_SCENARIO = \"ManageScenario\";\n+    private static final String RCLICK_COMMAND_REVEAL_TRACK = \"RevealTrack\";\n+    private static final String RCLICK_COMMAND_STICKY_FORCE = \"StickyForce\";\n+    private static final String RCLICK_COMMAND_STICKY_FORCE_ID = \"StickyForceID\";\n+\n+    /**\n+     * What to do when drawing a hex\n+     */\n+    private enum DrawHexType {\n+        /**\n+         * The interior of a hex\n+         */\n+        Hex,\n+        \n+        /**\n+         * The outline of a hex\n+         */\n+        Outline,\n+        \n+        /**\n+         * Pretend we're drawing a hex, but don't actually do it, useful for \n+         * figuring out which hex a mouse click landed in, etc.\n+         */\n+        Dryrun\n+    }\n+\n+    private float scale = 1f;\n+\n+    private StratconTrackState currentTrack;\n+    private StratconCampaignState campaignState;\n+    private Campaign campaign;\n+\n+    private BoardState boardState = new BoardState();\n+\n+    private Point clickedPoint;\n+    private JPopupMenu rightClickMenu;\n+    private JMenuItem menuItemManageForceAssignments;\n+    private JMenuItem menuItemManageScenario;\n+    private JMenuItem menuItemGMReveal;\n+    \n+    // data structure holding how many unit/scenario/base icons have been drawn in the hex\n+    // used to control how low the text description goes.\n+    private Map<StratconCoords, Integer> numIconsInHex = new HashMap<>();\n+    \n+    private StratconScenarioWizard scenarioWizard;\n+    private TrackForceAssignmentUI assignmentUI;\n+    \n+    private JLabel infoArea;\n+\n+    /**\n+     * Constructs a StratconPanel instance, given a parent campaign GUI and a pointer to an info area.\n+     */\n+    StratconPanel(CampaignGUI gui, JLabel infoArea) {\n+        campaign = gui.getCampaign();\n+        scenarioWizard = new StratconScenarioWizard(campaign);\n+        this.infoArea = infoArea;\n+        \n+        assignmentUI = new TrackForceAssignmentUI(this);\n+        assignmentUI.setVisible(false);\n+        \n+        addMouseListener(new MouseAdapter() {\n+            @Override\n+            public void mouseReleased(MouseEvent e) {\n+                mouseReleasedHandler(e);\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Handler for when a specific track is selected - switches rendering to that track.\n+     */\n+    public void selectTrack(StratconCampaignState campaignState, StratconTrackState track) {\n+        this.campaignState = campaignState;\n+        currentTrack = track;\n+        repaint();\n+    }\n+    \n+    /**\n+     * Constructs the right-click context menu, optionally for a scenario\n+     */\n+    private void buildRightClickMenu(StratconCoords coords) {\n+        rightClickMenu = new JPopupMenu();\n+        \n+        StratconScenario scenario = getSelectedScenario();\n+        \n+        if (scenario == null) {\n+            menuItemManageForceAssignments = new JMenuItem();\n+            menuItemManageForceAssignments.setText(\"Manage Force Assignments\");\n+            menuItemManageForceAssignments.setActionCommand(RCLICK_COMMAND_MANAGE_FORCES);\n+            menuItemManageForceAssignments.addActionListener(this);\n+            rightClickMenu.add(menuItemManageForceAssignments);\n+        }\n+        \n+        if (scenario != null) {\n+            menuItemManageScenario = new JMenuItem();\n+            menuItemManageScenario.setText(\"Manage Scenario\");\n+            menuItemManageScenario.setActionCommand(RCLICK_COMMAND_MANAGE_SCENARIO);\n+            menuItemManageScenario.addActionListener(this);\n+            rightClickMenu.add(menuItemManageScenario);\n+        }\n+        \n+        if ((currentTrack != null) && currentTrack.getAssignedCoordForces().containsKey(coords)) {\n+            for (int forceID : currentTrack.getAssignedCoordForces().get(coords)) {\n+                String forceName = campaign.getForce(forceID).getName();\n+                \n+                JCheckBoxMenuItem stickyForceItem = new JCheckBoxMenuItem();\n+                stickyForceItem.setText(String.format(\"%s - remain deployed\", forceName));\n+                stickyForceItem.setActionCommand(RCLICK_COMMAND_STICKY_FORCE);\n+                stickyForceItem.putClientProperty(RCLICK_COMMAND_STICKY_FORCE_ID, forceID);\n+                stickyForceItem.addActionListener(this);\n+                stickyForceItem.setSelected(currentTrack.getStickyForces().contains(forceID));\n+                rightClickMenu.add(stickyForceItem);\n+            }\n+        }\n+            \n+        if ((currentTrack != null) && campaign.isGM()) {\n+            rightClickMenu.addSeparator();\n+            \n+            menuItemGMReveal = new JMenuItem();\n+            menuItemGMReveal.setText(currentTrack.isGmRevealed() ? \"Hide Track\" : \"Reveal Track\");\n+            menuItemGMReveal.setActionCommand(RCLICK_COMMAND_REVEAL_TRACK);\n+            menuItemGMReveal.addActionListener(this);\n+            rightClickMenu.add(menuItemGMReveal);\n+        }\n+    }\n+\n+    /**\n+     * Renders the panel, hexes, forces, facilities and all that.\n+     */\n+    @Override\n+    public void paintComponent(Graphics g) {\n+        super.paintComponent(g);\n+        if (campaignState == null || currentTrack == null) {\n+            return;\n+        }\n+        \n+        numIconsInHex.clear();\n+\n+        Graphics2D g2D = (Graphics2D) g;\n+        AffineTransform initialTransform = g2D.getTransform();\n+        performInitialTransform(g2D);\n+        AffineTransform originTransform = g2D.getTransform();\n+\n+        drawHexes(g2D, DrawHexType.Hex);\n+        g2D.setTransform(originTransform);\n+        drawHexes(g2D, DrawHexType.Outline);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawScenarios(g2D);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawFacilities(g2D);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawForces(g2D);\n+\n+        g2D.setTransform(initialTransform);\n+        if (clickedPoint != null) {\n+            g2D.setColor(Color.BLUE);\n+            g2D.drawRect((int) clickedPoint.getX(), (int) clickedPoint.getY(), 2, 2);\n+        }\n+    }\n+\n+    /**\n+     * This method contains a dirty secret hack, but I forget what it is.\n+     * The point of it is to draw all the hexes for the board. \n+     * If it's a \"dry run\", we don't actually draw the hexes, we just pretend to\n+     * until we \"draw\" one that encompasses the clicked point.\n+     * @param g2D - graphics object on which to draw\n+     * @param drawHexType - whether to draw the hex backgrounds, hex outlines or a dry run for click detection\n+     */\n+    private boolean drawHexes(Graphics2D g2D, DrawHexType drawHexType) {\n+        Polygon graphHex = new Polygon();\n+        int xRadius = HEX_X_RADIUS;\n+        int yRadius = HEX_Y_RADIUS;\n+        boolean pointFound = false;\n+\n+        graphHex.addPoint(-xRadius/2, -yRadius);\n+        graphHex.addPoint(-xRadius, 0);\n+        graphHex.addPoint(-xRadius/2, yRadius);\n+        graphHex.addPoint(xRadius/2, yRadius);\n+        graphHex.addPoint(xRadius, 0);\n+        graphHex.addPoint(xRadius/2, -yRadius);\n+\n+        graphHex.translate(xRadius, yRadius);\n+\n+        Point translatedClickedPoint = null;\n+\n+        // this was derived somewhat experimentally\n+        // the clicked point always seems a little off, so we \n+        // a) apply the current transform to it, prior to drawing all the hexes\n+        // b) subtract an additional Y_RADIUS x 2 (Y_DIAMETER)\n+        // this gets us the point within the clicked hex\n+        // it's probably finicky, so any major changes to the rendering mechanism will likely break the detection\n+        if (clickedPoint != null) {\n+            translatedClickedPoint = (Point) clickedPoint.clone();\n+            \n+            // since we have the possibility of scrolling, we need to convert the on-screen clicked coordinates\n+            // to on-board coordinates. Thankfully, SwingUtilities provides the main computational ability for that\n+            Point actualPanelPoint = SwingUtilities.convertPoint(this, translatedClickedPoint, this.getParent());\n+            translatedClickedPoint.translate((int) -(actualPanelPoint.getX() - translatedClickedPoint.getX()), \n+                                                (int) -(actualPanelPoint.getY() - translatedClickedPoint.getY()));\n+            \n+            // now we translate to the starting point of where we're drawing and then go down a hex\n+            translatedClickedPoint.translate((int) g2D.getTransform().getTranslateX(), (int) g2D.getTransform().getTranslateY());\n+            translatedClickedPoint.translate(0, -(HEX_Y_RADIUS * 2));\n+        }\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                if(drawHexType == DrawHexType.Outline) {\n+                    g2D.setColor(new Color(0, 0, 0));\n+                    g2D.drawPolygon(graphHex);                    \n+                } else if (drawHexType == DrawHexType.Hex) {\n+                    \n+                    if (currentTrack.coordsRevealed(x, y) || currentTrack.isGmRevealed()) {\n+                        g2D.setColor(Color.LIGHT_GRAY);\n+                    } else {\n+                        g2D.setColor(Color.DARK_GRAY);\n+                    }\n+                    g2D.fillPolygon(graphHex);\n+                    \n+                    if (translatedClickedPoint != null && graphHex.contains(translatedClickedPoint)) {\n+                        g2D.setColor(Color.WHITE);\n+                        BasicStroke s = new BasicStroke((float) 8.0);\n+                        Stroke push = g2D.getStroke();\n+                        g2D.setStroke(s);\n+                        g2D.drawPolygon(graphHex);\n+                        \n+                        boardState.selectedX = x;\n+                        boardState.selectedY = y;\n+                        pointFound = true;\n+                        g2D.setStroke(push);\n+                    }\n+                } else if (drawHexType == DrawHexType.Dryrun) {\n+                    if (translatedClickedPoint != null && graphHex.contains(translatedClickedPoint)) {\n+                        boardState.selectedX = x;\n+                        boardState.selectedY = y;\n+                        pointFound = true;\n+                    }\n+                }\n+\n+                if (drawHexType == DrawHexType.Hex) {\n+                    g2D.setColor(Color.GREEN);\n+                    g2D.drawString(x + \",\" + y, graphHex.xpoints[0] + (xRadius / 4), graphHex.ypoints[0] + yRadius);\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                graphHex.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            graphHex.translate(translationVector[0], translationVector[1]);\n+        }\n+\n+        return pointFound;\n+    }\n+\n+    /**\n+     * Worker function to render icons representing scenarios to the given surface.\n+     */\n+    private void drawScenarios(Graphics2D g2D) {\n+        Polygon scenarioMarker = new Polygon();\n+        int xRadius = HEX_X_RADIUS / 3;\n+        int yRadius = HEX_Y_RADIUS / 3;\n+\n+        scenarioMarker.addPoint(-xRadius, -yRadius);\n+        scenarioMarker.addPoint(-xRadius, yRadius);\n+        scenarioMarker.addPoint(xRadius, yRadius);\n+        scenarioMarker.addPoint(xRadius, -yRadius);\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                StratconCoords currentCoords = new StratconCoords(x, y);\n+                StratconScenario scenario = currentTrack.getScenario(currentCoords);\n+                \n+                // if there's a scenario here that has a deployment/battle date\n+                // or if there's a scenario here and we've gm-revealed everything\n+                if ((scenario != null) &&\n+                        ((scenario.getDeploymentDate() != null) || currentTrack.isGmRevealed())) {\n+                    g2D.setColor(Color.RED);\n+                    g2D.drawPolygon(scenarioMarker);\n+                    if(currentTrack.getFacility(currentCoords) == null) {\n+                        drawTextEffect(g2D, scenarioMarker, \"Hostile Force Detected\", currentCoords);\n+                    }\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                scenarioMarker.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            scenarioMarker.translate(translationVector[0], translationVector[1]);\n+        }\n+    }\n+    \n+    /**\n+     * Worker function to render facility icons to the given surface.\n+     */\n+    private void drawFacilities(Graphics2D g2D) {\n+        Polygon facilityMarker = new Polygon();\n+        int xRadius = HEX_X_RADIUS / 3;\n+        int yRadius = HEX_Y_RADIUS / 3;\n+\n+        facilityMarker.addPoint(-xRadius, -yRadius);\n+        facilityMarker.addPoint(-xRadius, yRadius);\n+        facilityMarker.addPoint(xRadius, yRadius);\n+        facilityMarker.addPoint(xRadius, -yRadius);\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                StratconCoords currentCoords = new StratconCoords(x, y);\n+                StratconFacility facility = currentTrack.getFacility(currentCoords);\n+                \n+                if ((facility != null) && (facility.isVisible() || currentTrack.isGmRevealed())) {\n+                    g2D.setColor(facility.getOwner() == ForceAlignment.Allied ? Color.GREEN : Color.RED);\n+                    g2D.drawPolygon(facilityMarker);\n+                    drawTextEffect(g2D, facilityMarker, facility.getFormattedDisplayableName(), currentCoords);\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                facilityMarker.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            facilityMarker.translate(translationVector[0], translationVector[1]);\n+        }\n+    }\n+    \n+    /**\n+     * Worker function to render force icons to the given surface.\n+     */\n+    private void drawForces(Graphics2D g2D) {\n+        Polygon forceMarker = new Polygon();\n+        int xRadius = HEX_X_RADIUS / 3;\n+        int yRadius = HEX_Y_RADIUS / 3;\n+\n+        forceMarker.addPoint(-xRadius, -yRadius);\n+        forceMarker.addPoint(-xRadius, yRadius);\n+        forceMarker.addPoint(xRadius, yRadius);\n+        forceMarker.addPoint(xRadius, -yRadius);\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                StratconCoords currentCoords = new StratconCoords(x, y);\n+                \n+                if (currentTrack.getAssignedCoordForces().containsKey(currentCoords)) {\n+                    for (int forceID : currentTrack.getAssignedCoordForces().get(currentCoords)) {                   \n+                        g2D.setColor(Color.BLUE);\n+                        g2D.drawPolygon(forceMarker);\n+                        drawTextEffect(g2D, forceMarker, campaign.getForce(forceID).getName(), currentCoords);\n+                    }\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                forceMarker.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            forceMarker.translate(translationVector[0], translationVector[1]);\n+        }\n+    }\n+    \n+    /**\n+     * Draws some text and line to it from a given polygon. \n+     * Smart enough not to layer multiple strings on top of each other if they're all drawn in the same hex.\n+     */\n+    private void drawTextEffect(Graphics2D g2D, Polygon marker, String text, StratconCoords coords) {\n+        int verticalOffsetIndex = numIconsInHex.containsKey(coords) ? numIconsInHex.get(coords) : 0;\n+        \n+        double startX = marker.getBounds().getMaxX();\n+        double startY = marker.getBounds().getMinY();\n+        double midPointX = startX + HEX_X_RADIUS / 4;\n+        double midPointY = startY - HEX_Y_RADIUS / 4 + g2D.getFontMetrics().getHeight() * verticalOffsetIndex;\n+        double endPointX = midPointX + HEX_X_RADIUS / 2;\n+        \n+        g2D.drawLine((int) startX, (int) startY, (int) midPointX, (int) midPointY);\n+        g2D.drawLine((int) midPointX, (int) midPointY, (int) endPointX, (int) midPointY);\n+        g2D.drawString(text, (int) endPointX, (int) midPointY);\n+        \n+        // register that we drew text off of this hex\n+        verticalOffsetIndex++;\n+        numIconsInHex.put(coords, verticalOffsetIndex);\n+    }\n+\n+    /**\n+     * Returns the translation that we need to make to render the \"next downward\" hex.\n+     * @return Two dimensional array with the first element being the x vector and the second being the y vector\n+     */\n+    private int[] getDownwardYVector() {\n+        return new int[] { 0, (int) (HEX_Y_RADIUS * 2) };\n+    }\n+\n+    /**\n+     * Returns the translation that we need to make to move from the bottom of a column to the top of the next\n+     * column to the right.\n+     * @param evenColumn Whether the column we're currently in is odd or even\n+     * @return Two dimensional array with the first element being the x vector and the second being the y vector\n+     */\n+    private int[] getRightAndUPVector(boolean evenColumn) {\n+        int yRadius = (int) (HEX_Y_RADIUS);\n+        int xRadius = (int) (HEX_X_RADIUS);\n+\n+        int yTranslation = currentTrack.getHeight() * yRadius * 2;\n+        if (evenColumn) {\n+            yTranslation += yRadius;\n+        } else {\n+            yTranslation -= yRadius;\n+        }\n+\n+        return new int[] {(int) (xRadius * 1.5), -yTranslation};\n+    }\n+\n+    /**\n+     * Go to the origin of the hex board and reset the scaling.\n+     */\n+    private void performInitialTransform(Graphics2D g2D) {\n+        g2D.translate(0, 0 + HEX_Y_RADIUS);\n+        g2D.scale(scale, scale);\n+    }\n+\n+    /** \n+     * Worker function that takes the current clicked point and a graphics 2D object\n+     * and detects which hex was clicked by doing a dry run hex render.\n+     * \n+     * Dependent upon clickedPoint being set and having an active graphics object for this class.\n+     * \n+     * Side effects: the dry run sets the boardState clicked hex coordinates.\n+     * @return Whether or not the clicked point was found on the hex board\n+     */\n+    private boolean detectClickedHex() {\n+        Graphics2D g2D = (Graphics2D) getGraphics();\n+        AffineTransform transform = g2D.getTransform();\n+        performInitialTransform(g2D);\n+        boolean pointFoundOnBoard = drawHexes(g2D, DrawHexType.Dryrun);\n+        g2D.setTransform(transform);\n+\n+        return pointFoundOnBoard;\n+    }\n+\n+    /**\n+     * Event handler for when a mouse button is released.\n+     */\n+    public void mouseReleasedHandler(MouseEvent e) {\n+        if(e.getSource() != this) {\n+            return;\n+        }\n+\n+        // left button generally selects a hex\n+        if (e.getButton() == MouseEvent.BUTTON1) {        \n+            clickedPoint = e.getPoint();\n+            boolean pointFoundOnBoard = detectClickedHex();\n+            \n+            if(pointFoundOnBoard) {\n+                infoArea.setText(buildSelectedHexInfo());\n+            }\n+\n+            repaint();\n+        // right button generally pops up a context menu\n+        } else if (e.getButton() == MouseEvent.BUTTON3) {\n+            clickedPoint = e.getPoint();\n+            detectClickedHex();\n+            \n+            StratconCoords selectedCoords = boardState.getSelectedCoords();\n+            if (selectedCoords == null) {\n+                return;\n+            }\n+            \n+            repaint();\n+            buildRightClickMenu(selectedCoords);\n+            rightClickMenu.show(this, e.getX(), e.getY());\n+        }\n+    }\n+    \n+    public StratconScenario getSelectedScenario() {\n+        return currentTrack.getScenario(boardState.getSelectedCoords());\n+    }\n+    \n+    /**\n+     * Worker function that outputs html representing the status of a selected hex,\n+     * containing info such as whether it's been revealed, assigned forces, scenarios, facilities, etc.\n+     */\n+    private String buildSelectedHexInfo() {\n+        StringBuilder infoBuilder = new StringBuilder();\n+        infoBuilder.append(\"<html><br/>\");\n+        \n+        boolean coordsRevealed = currentTrack.getRevealedCoords().contains(boardState.getSelectedCoords());\n+        if (coordsRevealed) {\n+            infoBuilder.append(\"<span color='green'>Recon complete</span><br/>\");\n+        }\n+        \n+        if (currentTrack.getAssignedCoordForces().containsKey(boardState.getSelectedCoords())) {\n+            for (int forceID : currentTrack.getAssignedCoordForces().get(boardState.getSelectedCoords())) {\n+                Force force = campaign.getForce(forceID);\n+                infoBuilder.append(force.getName()).append(\" assigned\");\n+                \n+                if (currentTrack.getStickyForces().contains(forceID)) {\n+                    infoBuilder.append(\" - remain deployed\");\n+                }\n+                \n+                infoBuilder.append(\"<br/>\");\n+                \n+                infoBuilder.append(\"Returns on \").append(currentTrack.getAssignedForceReturnDates().get(forceID));\n+                infoBuilder.append(\"<br/>\");\n+            }\n+        }\n+        \n+        if (coordsRevealed || currentTrack.isGmRevealed()) {\n+            StratconFacility facility = currentTrack.getFacility(boardState.getSelectedCoords());\n+            \n+            if((facility != null) && (facility.getFacilityType() != null)) {", "originalCommit": "796b6728fd3cd2aea02d17122b4d735afc47dc41", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjkwMjU3MA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r602902570", "bodyText": "Chain appends", "author": "Windchild292", "createdAt": "2021-03-28T16:51:25Z", "path": "MekHQ/src/mekhq/gui/StratconPanel.java", "diffHunk": "@@ -0,0 +1,672 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.gui;\n+\n+import java.awt.BasicStroke;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Point;\n+import java.awt.Polygon;\n+import java.awt.Stroke;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.awt.geom.AffineTransform;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import javax.swing.JCheckBoxMenuItem;\n+import javax.swing.JLabel;\n+import javax.swing.JMenuItem;\n+import javax.swing.JPanel;\n+import javax.swing.JPopupMenu;\n+import javax.swing.SwingUtilities;\n+\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.stratcon.StratconCampaignState;\n+import mekhq.campaign.stratcon.StratconCoords;\n+import mekhq.campaign.stratcon.StratconFacility;\n+import mekhq.campaign.stratcon.StratconScenario;\n+import mekhq.campaign.stratcon.StratconTrackState;\n+import mekhq.gui.stratcon.StratconScenarioWizard;\n+import mekhq.gui.stratcon.TrackForceAssignmentUI;\n+\n+/**\n+ * This panel handles AtB-Stratcon GUI interactions with a specific scenario track.\n+ * @author NickAragua\n+ */\n+public class StratconPanel extends JPanel implements ActionListener {\n+    /**\n+     * \n+     */\n+    private static final long serialVersionUID = 7405934788894417292L;\n+    \n+    public static final int HEX_X_RADIUS = 42;\n+    public static final int HEX_Y_RADIUS = 37;\n+    \n+    private static final String RCLICK_COMMAND_MANAGE_FORCES = \"ManageForces\";\n+    private static final String RCLICK_COMMAND_MANAGE_SCENARIO = \"ManageScenario\";\n+    private static final String RCLICK_COMMAND_REVEAL_TRACK = \"RevealTrack\";\n+    private static final String RCLICK_COMMAND_STICKY_FORCE = \"StickyForce\";\n+    private static final String RCLICK_COMMAND_STICKY_FORCE_ID = \"StickyForceID\";\n+\n+    /**\n+     * What to do when drawing a hex\n+     */\n+    private enum DrawHexType {\n+        /**\n+         * The interior of a hex\n+         */\n+        Hex,\n+        \n+        /**\n+         * The outline of a hex\n+         */\n+        Outline,\n+        \n+        /**\n+         * Pretend we're drawing a hex, but don't actually do it, useful for \n+         * figuring out which hex a mouse click landed in, etc.\n+         */\n+        Dryrun\n+    }\n+\n+    private float scale = 1f;\n+\n+    private StratconTrackState currentTrack;\n+    private StratconCampaignState campaignState;\n+    private Campaign campaign;\n+\n+    private BoardState boardState = new BoardState();\n+\n+    private Point clickedPoint;\n+    private JPopupMenu rightClickMenu;\n+    private JMenuItem menuItemManageForceAssignments;\n+    private JMenuItem menuItemManageScenario;\n+    private JMenuItem menuItemGMReveal;\n+    \n+    // data structure holding how many unit/scenario/base icons have been drawn in the hex\n+    // used to control how low the text description goes.\n+    private Map<StratconCoords, Integer> numIconsInHex = new HashMap<>();\n+    \n+    private StratconScenarioWizard scenarioWizard;\n+    private TrackForceAssignmentUI assignmentUI;\n+    \n+    private JLabel infoArea;\n+\n+    /**\n+     * Constructs a StratconPanel instance, given a parent campaign GUI and a pointer to an info area.\n+     */\n+    StratconPanel(CampaignGUI gui, JLabel infoArea) {\n+        campaign = gui.getCampaign();\n+        scenarioWizard = new StratconScenarioWizard(campaign);\n+        this.infoArea = infoArea;\n+        \n+        assignmentUI = new TrackForceAssignmentUI(this);\n+        assignmentUI.setVisible(false);\n+        \n+        addMouseListener(new MouseAdapter() {\n+            @Override\n+            public void mouseReleased(MouseEvent e) {\n+                mouseReleasedHandler(e);\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Handler for when a specific track is selected - switches rendering to that track.\n+     */\n+    public void selectTrack(StratconCampaignState campaignState, StratconTrackState track) {\n+        this.campaignState = campaignState;\n+        currentTrack = track;\n+        repaint();\n+    }\n+    \n+    /**\n+     * Constructs the right-click context menu, optionally for a scenario\n+     */\n+    private void buildRightClickMenu(StratconCoords coords) {\n+        rightClickMenu = new JPopupMenu();\n+        \n+        StratconScenario scenario = getSelectedScenario();\n+        \n+        if (scenario == null) {\n+            menuItemManageForceAssignments = new JMenuItem();\n+            menuItemManageForceAssignments.setText(\"Manage Force Assignments\");\n+            menuItemManageForceAssignments.setActionCommand(RCLICK_COMMAND_MANAGE_FORCES);\n+            menuItemManageForceAssignments.addActionListener(this);\n+            rightClickMenu.add(menuItemManageForceAssignments);\n+        }\n+        \n+        if (scenario != null) {\n+            menuItemManageScenario = new JMenuItem();\n+            menuItemManageScenario.setText(\"Manage Scenario\");\n+            menuItemManageScenario.setActionCommand(RCLICK_COMMAND_MANAGE_SCENARIO);\n+            menuItemManageScenario.addActionListener(this);\n+            rightClickMenu.add(menuItemManageScenario);\n+        }\n+        \n+        if ((currentTrack != null) && currentTrack.getAssignedCoordForces().containsKey(coords)) {\n+            for (int forceID : currentTrack.getAssignedCoordForces().get(coords)) {\n+                String forceName = campaign.getForce(forceID).getName();\n+                \n+                JCheckBoxMenuItem stickyForceItem = new JCheckBoxMenuItem();\n+                stickyForceItem.setText(String.format(\"%s - remain deployed\", forceName));\n+                stickyForceItem.setActionCommand(RCLICK_COMMAND_STICKY_FORCE);\n+                stickyForceItem.putClientProperty(RCLICK_COMMAND_STICKY_FORCE_ID, forceID);\n+                stickyForceItem.addActionListener(this);\n+                stickyForceItem.setSelected(currentTrack.getStickyForces().contains(forceID));\n+                rightClickMenu.add(stickyForceItem);\n+            }\n+        }\n+            \n+        if ((currentTrack != null) && campaign.isGM()) {\n+            rightClickMenu.addSeparator();\n+            \n+            menuItemGMReveal = new JMenuItem();\n+            menuItemGMReveal.setText(currentTrack.isGmRevealed() ? \"Hide Track\" : \"Reveal Track\");\n+            menuItemGMReveal.setActionCommand(RCLICK_COMMAND_REVEAL_TRACK);\n+            menuItemGMReveal.addActionListener(this);\n+            rightClickMenu.add(menuItemGMReveal);\n+        }\n+    }\n+\n+    /**\n+     * Renders the panel, hexes, forces, facilities and all that.\n+     */\n+    @Override\n+    public void paintComponent(Graphics g) {\n+        super.paintComponent(g);\n+        if (campaignState == null || currentTrack == null) {\n+            return;\n+        }\n+        \n+        numIconsInHex.clear();\n+\n+        Graphics2D g2D = (Graphics2D) g;\n+        AffineTransform initialTransform = g2D.getTransform();\n+        performInitialTransform(g2D);\n+        AffineTransform originTransform = g2D.getTransform();\n+\n+        drawHexes(g2D, DrawHexType.Hex);\n+        g2D.setTransform(originTransform);\n+        drawHexes(g2D, DrawHexType.Outline);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawScenarios(g2D);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawFacilities(g2D);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawForces(g2D);\n+\n+        g2D.setTransform(initialTransform);\n+        if (clickedPoint != null) {\n+            g2D.setColor(Color.BLUE);\n+            g2D.drawRect((int) clickedPoint.getX(), (int) clickedPoint.getY(), 2, 2);\n+        }\n+    }\n+\n+    /**\n+     * This method contains a dirty secret hack, but I forget what it is.\n+     * The point of it is to draw all the hexes for the board. \n+     * If it's a \"dry run\", we don't actually draw the hexes, we just pretend to\n+     * until we \"draw\" one that encompasses the clicked point.\n+     * @param g2D - graphics object on which to draw\n+     * @param drawHexType - whether to draw the hex backgrounds, hex outlines or a dry run for click detection\n+     */\n+    private boolean drawHexes(Graphics2D g2D, DrawHexType drawHexType) {\n+        Polygon graphHex = new Polygon();\n+        int xRadius = HEX_X_RADIUS;\n+        int yRadius = HEX_Y_RADIUS;\n+        boolean pointFound = false;\n+\n+        graphHex.addPoint(-xRadius/2, -yRadius);\n+        graphHex.addPoint(-xRadius, 0);\n+        graphHex.addPoint(-xRadius/2, yRadius);\n+        graphHex.addPoint(xRadius/2, yRadius);\n+        graphHex.addPoint(xRadius, 0);\n+        graphHex.addPoint(xRadius/2, -yRadius);\n+\n+        graphHex.translate(xRadius, yRadius);\n+\n+        Point translatedClickedPoint = null;\n+\n+        // this was derived somewhat experimentally\n+        // the clicked point always seems a little off, so we \n+        // a) apply the current transform to it, prior to drawing all the hexes\n+        // b) subtract an additional Y_RADIUS x 2 (Y_DIAMETER)\n+        // this gets us the point within the clicked hex\n+        // it's probably finicky, so any major changes to the rendering mechanism will likely break the detection\n+        if (clickedPoint != null) {\n+            translatedClickedPoint = (Point) clickedPoint.clone();\n+            \n+            // since we have the possibility of scrolling, we need to convert the on-screen clicked coordinates\n+            // to on-board coordinates. Thankfully, SwingUtilities provides the main computational ability for that\n+            Point actualPanelPoint = SwingUtilities.convertPoint(this, translatedClickedPoint, this.getParent());\n+            translatedClickedPoint.translate((int) -(actualPanelPoint.getX() - translatedClickedPoint.getX()), \n+                                                (int) -(actualPanelPoint.getY() - translatedClickedPoint.getY()));\n+            \n+            // now we translate to the starting point of where we're drawing and then go down a hex\n+            translatedClickedPoint.translate((int) g2D.getTransform().getTranslateX(), (int) g2D.getTransform().getTranslateY());\n+            translatedClickedPoint.translate(0, -(HEX_Y_RADIUS * 2));\n+        }\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                if(drawHexType == DrawHexType.Outline) {\n+                    g2D.setColor(new Color(0, 0, 0));\n+                    g2D.drawPolygon(graphHex);                    \n+                } else if (drawHexType == DrawHexType.Hex) {\n+                    \n+                    if (currentTrack.coordsRevealed(x, y) || currentTrack.isGmRevealed()) {\n+                        g2D.setColor(Color.LIGHT_GRAY);\n+                    } else {\n+                        g2D.setColor(Color.DARK_GRAY);\n+                    }\n+                    g2D.fillPolygon(graphHex);\n+                    \n+                    if (translatedClickedPoint != null && graphHex.contains(translatedClickedPoint)) {\n+                        g2D.setColor(Color.WHITE);\n+                        BasicStroke s = new BasicStroke((float) 8.0);\n+                        Stroke push = g2D.getStroke();\n+                        g2D.setStroke(s);\n+                        g2D.drawPolygon(graphHex);\n+                        \n+                        boardState.selectedX = x;\n+                        boardState.selectedY = y;\n+                        pointFound = true;\n+                        g2D.setStroke(push);\n+                    }\n+                } else if (drawHexType == DrawHexType.Dryrun) {\n+                    if (translatedClickedPoint != null && graphHex.contains(translatedClickedPoint)) {\n+                        boardState.selectedX = x;\n+                        boardState.selectedY = y;\n+                        pointFound = true;\n+                    }\n+                }\n+\n+                if (drawHexType == DrawHexType.Hex) {\n+                    g2D.setColor(Color.GREEN);\n+                    g2D.drawString(x + \",\" + y, graphHex.xpoints[0] + (xRadius / 4), graphHex.ypoints[0] + yRadius);\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                graphHex.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            graphHex.translate(translationVector[0], translationVector[1]);\n+        }\n+\n+        return pointFound;\n+    }\n+\n+    /**\n+     * Worker function to render icons representing scenarios to the given surface.\n+     */\n+    private void drawScenarios(Graphics2D g2D) {\n+        Polygon scenarioMarker = new Polygon();\n+        int xRadius = HEX_X_RADIUS / 3;\n+        int yRadius = HEX_Y_RADIUS / 3;\n+\n+        scenarioMarker.addPoint(-xRadius, -yRadius);\n+        scenarioMarker.addPoint(-xRadius, yRadius);\n+        scenarioMarker.addPoint(xRadius, yRadius);\n+        scenarioMarker.addPoint(xRadius, -yRadius);\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                StratconCoords currentCoords = new StratconCoords(x, y);\n+                StratconScenario scenario = currentTrack.getScenario(currentCoords);\n+                \n+                // if there's a scenario here that has a deployment/battle date\n+                // or if there's a scenario here and we've gm-revealed everything\n+                if ((scenario != null) &&\n+                        ((scenario.getDeploymentDate() != null) || currentTrack.isGmRevealed())) {\n+                    g2D.setColor(Color.RED);\n+                    g2D.drawPolygon(scenarioMarker);\n+                    if(currentTrack.getFacility(currentCoords) == null) {\n+                        drawTextEffect(g2D, scenarioMarker, \"Hostile Force Detected\", currentCoords);\n+                    }\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                scenarioMarker.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            scenarioMarker.translate(translationVector[0], translationVector[1]);\n+        }\n+    }\n+    \n+    /**\n+     * Worker function to render facility icons to the given surface.\n+     */\n+    private void drawFacilities(Graphics2D g2D) {\n+        Polygon facilityMarker = new Polygon();\n+        int xRadius = HEX_X_RADIUS / 3;\n+        int yRadius = HEX_Y_RADIUS / 3;\n+\n+        facilityMarker.addPoint(-xRadius, -yRadius);\n+        facilityMarker.addPoint(-xRadius, yRadius);\n+        facilityMarker.addPoint(xRadius, yRadius);\n+        facilityMarker.addPoint(xRadius, -yRadius);\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                StratconCoords currentCoords = new StratconCoords(x, y);\n+                StratconFacility facility = currentTrack.getFacility(currentCoords);\n+                \n+                if ((facility != null) && (facility.isVisible() || currentTrack.isGmRevealed())) {\n+                    g2D.setColor(facility.getOwner() == ForceAlignment.Allied ? Color.GREEN : Color.RED);\n+                    g2D.drawPolygon(facilityMarker);\n+                    drawTextEffect(g2D, facilityMarker, facility.getFormattedDisplayableName(), currentCoords);\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                facilityMarker.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            facilityMarker.translate(translationVector[0], translationVector[1]);\n+        }\n+    }\n+    \n+    /**\n+     * Worker function to render force icons to the given surface.\n+     */\n+    private void drawForces(Graphics2D g2D) {\n+        Polygon forceMarker = new Polygon();\n+        int xRadius = HEX_X_RADIUS / 3;\n+        int yRadius = HEX_Y_RADIUS / 3;\n+\n+        forceMarker.addPoint(-xRadius, -yRadius);\n+        forceMarker.addPoint(-xRadius, yRadius);\n+        forceMarker.addPoint(xRadius, yRadius);\n+        forceMarker.addPoint(xRadius, -yRadius);\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                StratconCoords currentCoords = new StratconCoords(x, y);\n+                \n+                if (currentTrack.getAssignedCoordForces().containsKey(currentCoords)) {\n+                    for (int forceID : currentTrack.getAssignedCoordForces().get(currentCoords)) {                   \n+                        g2D.setColor(Color.BLUE);\n+                        g2D.drawPolygon(forceMarker);\n+                        drawTextEffect(g2D, forceMarker, campaign.getForce(forceID).getName(), currentCoords);\n+                    }\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                forceMarker.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            forceMarker.translate(translationVector[0], translationVector[1]);\n+        }\n+    }\n+    \n+    /**\n+     * Draws some text and line to it from a given polygon. \n+     * Smart enough not to layer multiple strings on top of each other if they're all drawn in the same hex.\n+     */\n+    private void drawTextEffect(Graphics2D g2D, Polygon marker, String text, StratconCoords coords) {\n+        int verticalOffsetIndex = numIconsInHex.containsKey(coords) ? numIconsInHex.get(coords) : 0;\n+        \n+        double startX = marker.getBounds().getMaxX();\n+        double startY = marker.getBounds().getMinY();\n+        double midPointX = startX + HEX_X_RADIUS / 4;\n+        double midPointY = startY - HEX_Y_RADIUS / 4 + g2D.getFontMetrics().getHeight() * verticalOffsetIndex;\n+        double endPointX = midPointX + HEX_X_RADIUS / 2;\n+        \n+        g2D.drawLine((int) startX, (int) startY, (int) midPointX, (int) midPointY);\n+        g2D.drawLine((int) midPointX, (int) midPointY, (int) endPointX, (int) midPointY);\n+        g2D.drawString(text, (int) endPointX, (int) midPointY);\n+        \n+        // register that we drew text off of this hex\n+        verticalOffsetIndex++;\n+        numIconsInHex.put(coords, verticalOffsetIndex);\n+    }\n+\n+    /**\n+     * Returns the translation that we need to make to render the \"next downward\" hex.\n+     * @return Two dimensional array with the first element being the x vector and the second being the y vector\n+     */\n+    private int[] getDownwardYVector() {\n+        return new int[] { 0, (int) (HEX_Y_RADIUS * 2) };\n+    }\n+\n+    /**\n+     * Returns the translation that we need to make to move from the bottom of a column to the top of the next\n+     * column to the right.\n+     * @param evenColumn Whether the column we're currently in is odd or even\n+     * @return Two dimensional array with the first element being the x vector and the second being the y vector\n+     */\n+    private int[] getRightAndUPVector(boolean evenColumn) {\n+        int yRadius = (int) (HEX_Y_RADIUS);\n+        int xRadius = (int) (HEX_X_RADIUS);\n+\n+        int yTranslation = currentTrack.getHeight() * yRadius * 2;\n+        if (evenColumn) {\n+            yTranslation += yRadius;\n+        } else {\n+            yTranslation -= yRadius;\n+        }\n+\n+        return new int[] {(int) (xRadius * 1.5), -yTranslation};\n+    }\n+\n+    /**\n+     * Go to the origin of the hex board and reset the scaling.\n+     */\n+    private void performInitialTransform(Graphics2D g2D) {\n+        g2D.translate(0, 0 + HEX_Y_RADIUS);\n+        g2D.scale(scale, scale);\n+    }\n+\n+    /** \n+     * Worker function that takes the current clicked point and a graphics 2D object\n+     * and detects which hex was clicked by doing a dry run hex render.\n+     * \n+     * Dependent upon clickedPoint being set and having an active graphics object for this class.\n+     * \n+     * Side effects: the dry run sets the boardState clicked hex coordinates.\n+     * @return Whether or not the clicked point was found on the hex board\n+     */\n+    private boolean detectClickedHex() {\n+        Graphics2D g2D = (Graphics2D) getGraphics();\n+        AffineTransform transform = g2D.getTransform();\n+        performInitialTransform(g2D);\n+        boolean pointFoundOnBoard = drawHexes(g2D, DrawHexType.Dryrun);\n+        g2D.setTransform(transform);\n+\n+        return pointFoundOnBoard;\n+    }\n+\n+    /**\n+     * Event handler for when a mouse button is released.\n+     */\n+    public void mouseReleasedHandler(MouseEvent e) {\n+        if(e.getSource() != this) {\n+            return;\n+        }\n+\n+        // left button generally selects a hex\n+        if (e.getButton() == MouseEvent.BUTTON1) {        \n+            clickedPoint = e.getPoint();\n+            boolean pointFoundOnBoard = detectClickedHex();\n+            \n+            if(pointFoundOnBoard) {\n+                infoArea.setText(buildSelectedHexInfo());\n+            }\n+\n+            repaint();\n+        // right button generally pops up a context menu\n+        } else if (e.getButton() == MouseEvent.BUTTON3) {\n+            clickedPoint = e.getPoint();\n+            detectClickedHex();\n+            \n+            StratconCoords selectedCoords = boardState.getSelectedCoords();\n+            if (selectedCoords == null) {\n+                return;\n+            }\n+            \n+            repaint();\n+            buildRightClickMenu(selectedCoords);\n+            rightClickMenu.show(this, e.getX(), e.getY());\n+        }\n+    }\n+    \n+    public StratconScenario getSelectedScenario() {\n+        return currentTrack.getScenario(boardState.getSelectedCoords());\n+    }\n+    \n+    /**\n+     * Worker function that outputs html representing the status of a selected hex,\n+     * containing info such as whether it's been revealed, assigned forces, scenarios, facilities, etc.\n+     */\n+    private String buildSelectedHexInfo() {\n+        StringBuilder infoBuilder = new StringBuilder();\n+        infoBuilder.append(\"<html><br/>\");\n+        \n+        boolean coordsRevealed = currentTrack.getRevealedCoords().contains(boardState.getSelectedCoords());\n+        if (coordsRevealed) {\n+            infoBuilder.append(\"<span color='green'>Recon complete</span><br/>\");\n+        }\n+        \n+        if (currentTrack.getAssignedCoordForces().containsKey(boardState.getSelectedCoords())) {\n+            for (int forceID : currentTrack.getAssignedCoordForces().get(boardState.getSelectedCoords())) {\n+                Force force = campaign.getForce(forceID);\n+                infoBuilder.append(force.getName()).append(\" assigned\");\n+                \n+                if (currentTrack.getStickyForces().contains(forceID)) {\n+                    infoBuilder.append(\" - remain deployed\");\n+                }\n+                \n+                infoBuilder.append(\"<br/>\");\n+                \n+                infoBuilder.append(\"Returns on \").append(currentTrack.getAssignedForceReturnDates().get(forceID));\n+                infoBuilder.append(\"<br/>\");\n+            }\n+        }\n+        \n+        if (coordsRevealed || currentTrack.isGmRevealed()) {\n+            StratconFacility facility = currentTrack.getFacility(boardState.getSelectedCoords());\n+            \n+            if((facility != null) && (facility.getFacilityType() != null)) {\n+                if (facility.isStrategicObjective()) {\n+                    infoBuilder.append(String.format(\"<br/><span color='%s'>Contract objective located</span>\", \n+                            facility.getOwner() == ForceAlignment.Allied ? \"green\" : \"red\"));\n+                }\n+                infoBuilder.append((facility.getOwner() == ForceAlignment.Allied) ? \"<span color='green'>\" : \"<span color='red'>\");\n+                infoBuilder.append(\"<br/>\");\n+                infoBuilder.append(facility.getFormattedDisplayableName());\n+                infoBuilder.append(\"<span>\");", "originalCommit": "796b6728fd3cd2aea02d17122b4d735afc47dc41", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjkwMjU5MA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r602902590", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if((selectedX == null) || (selectedY == null)) {\n          \n          \n            \n                        if ((selectedX == null) || (selectedY == null)) {", "author": "Windchild292", "createdAt": "2021-03-28T16:51:35Z", "path": "MekHQ/src/mekhq/gui/StratconPanel.java", "diffHunk": "@@ -0,0 +1,672 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.gui;\n+\n+import java.awt.BasicStroke;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Point;\n+import java.awt.Polygon;\n+import java.awt.Stroke;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.awt.geom.AffineTransform;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import javax.swing.JCheckBoxMenuItem;\n+import javax.swing.JLabel;\n+import javax.swing.JMenuItem;\n+import javax.swing.JPanel;\n+import javax.swing.JPopupMenu;\n+import javax.swing.SwingUtilities;\n+\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.stratcon.StratconCampaignState;\n+import mekhq.campaign.stratcon.StratconCoords;\n+import mekhq.campaign.stratcon.StratconFacility;\n+import mekhq.campaign.stratcon.StratconScenario;\n+import mekhq.campaign.stratcon.StratconTrackState;\n+import mekhq.gui.stratcon.StratconScenarioWizard;\n+import mekhq.gui.stratcon.TrackForceAssignmentUI;\n+\n+/**\n+ * This panel handles AtB-Stratcon GUI interactions with a specific scenario track.\n+ * @author NickAragua\n+ */\n+public class StratconPanel extends JPanel implements ActionListener {\n+    /**\n+     * \n+     */\n+    private static final long serialVersionUID = 7405934788894417292L;\n+    \n+    public static final int HEX_X_RADIUS = 42;\n+    public static final int HEX_Y_RADIUS = 37;\n+    \n+    private static final String RCLICK_COMMAND_MANAGE_FORCES = \"ManageForces\";\n+    private static final String RCLICK_COMMAND_MANAGE_SCENARIO = \"ManageScenario\";\n+    private static final String RCLICK_COMMAND_REVEAL_TRACK = \"RevealTrack\";\n+    private static final String RCLICK_COMMAND_STICKY_FORCE = \"StickyForce\";\n+    private static final String RCLICK_COMMAND_STICKY_FORCE_ID = \"StickyForceID\";\n+\n+    /**\n+     * What to do when drawing a hex\n+     */\n+    private enum DrawHexType {\n+        /**\n+         * The interior of a hex\n+         */\n+        Hex,\n+        \n+        /**\n+         * The outline of a hex\n+         */\n+        Outline,\n+        \n+        /**\n+         * Pretend we're drawing a hex, but don't actually do it, useful for \n+         * figuring out which hex a mouse click landed in, etc.\n+         */\n+        Dryrun\n+    }\n+\n+    private float scale = 1f;\n+\n+    private StratconTrackState currentTrack;\n+    private StratconCampaignState campaignState;\n+    private Campaign campaign;\n+\n+    private BoardState boardState = new BoardState();\n+\n+    private Point clickedPoint;\n+    private JPopupMenu rightClickMenu;\n+    private JMenuItem menuItemManageForceAssignments;\n+    private JMenuItem menuItemManageScenario;\n+    private JMenuItem menuItemGMReveal;\n+    \n+    // data structure holding how many unit/scenario/base icons have been drawn in the hex\n+    // used to control how low the text description goes.\n+    private Map<StratconCoords, Integer> numIconsInHex = new HashMap<>();\n+    \n+    private StratconScenarioWizard scenarioWizard;\n+    private TrackForceAssignmentUI assignmentUI;\n+    \n+    private JLabel infoArea;\n+\n+    /**\n+     * Constructs a StratconPanel instance, given a parent campaign GUI and a pointer to an info area.\n+     */\n+    StratconPanel(CampaignGUI gui, JLabel infoArea) {\n+        campaign = gui.getCampaign();\n+        scenarioWizard = new StratconScenarioWizard(campaign);\n+        this.infoArea = infoArea;\n+        \n+        assignmentUI = new TrackForceAssignmentUI(this);\n+        assignmentUI.setVisible(false);\n+        \n+        addMouseListener(new MouseAdapter() {\n+            @Override\n+            public void mouseReleased(MouseEvent e) {\n+                mouseReleasedHandler(e);\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Handler for when a specific track is selected - switches rendering to that track.\n+     */\n+    public void selectTrack(StratconCampaignState campaignState, StratconTrackState track) {\n+        this.campaignState = campaignState;\n+        currentTrack = track;\n+        repaint();\n+    }\n+    \n+    /**\n+     * Constructs the right-click context menu, optionally for a scenario\n+     */\n+    private void buildRightClickMenu(StratconCoords coords) {\n+        rightClickMenu = new JPopupMenu();\n+        \n+        StratconScenario scenario = getSelectedScenario();\n+        \n+        if (scenario == null) {\n+            menuItemManageForceAssignments = new JMenuItem();\n+            menuItemManageForceAssignments.setText(\"Manage Force Assignments\");\n+            menuItemManageForceAssignments.setActionCommand(RCLICK_COMMAND_MANAGE_FORCES);\n+            menuItemManageForceAssignments.addActionListener(this);\n+            rightClickMenu.add(menuItemManageForceAssignments);\n+        }\n+        \n+        if (scenario != null) {\n+            menuItemManageScenario = new JMenuItem();\n+            menuItemManageScenario.setText(\"Manage Scenario\");\n+            menuItemManageScenario.setActionCommand(RCLICK_COMMAND_MANAGE_SCENARIO);\n+            menuItemManageScenario.addActionListener(this);\n+            rightClickMenu.add(menuItemManageScenario);\n+        }\n+        \n+        if ((currentTrack != null) && currentTrack.getAssignedCoordForces().containsKey(coords)) {\n+            for (int forceID : currentTrack.getAssignedCoordForces().get(coords)) {\n+                String forceName = campaign.getForce(forceID).getName();\n+                \n+                JCheckBoxMenuItem stickyForceItem = new JCheckBoxMenuItem();\n+                stickyForceItem.setText(String.format(\"%s - remain deployed\", forceName));\n+                stickyForceItem.setActionCommand(RCLICK_COMMAND_STICKY_FORCE);\n+                stickyForceItem.putClientProperty(RCLICK_COMMAND_STICKY_FORCE_ID, forceID);\n+                stickyForceItem.addActionListener(this);\n+                stickyForceItem.setSelected(currentTrack.getStickyForces().contains(forceID));\n+                rightClickMenu.add(stickyForceItem);\n+            }\n+        }\n+            \n+        if ((currentTrack != null) && campaign.isGM()) {\n+            rightClickMenu.addSeparator();\n+            \n+            menuItemGMReveal = new JMenuItem();\n+            menuItemGMReveal.setText(currentTrack.isGmRevealed() ? \"Hide Track\" : \"Reveal Track\");\n+            menuItemGMReveal.setActionCommand(RCLICK_COMMAND_REVEAL_TRACK);\n+            menuItemGMReveal.addActionListener(this);\n+            rightClickMenu.add(menuItemGMReveal);\n+        }\n+    }\n+\n+    /**\n+     * Renders the panel, hexes, forces, facilities and all that.\n+     */\n+    @Override\n+    public void paintComponent(Graphics g) {\n+        super.paintComponent(g);\n+        if (campaignState == null || currentTrack == null) {\n+            return;\n+        }\n+        \n+        numIconsInHex.clear();\n+\n+        Graphics2D g2D = (Graphics2D) g;\n+        AffineTransform initialTransform = g2D.getTransform();\n+        performInitialTransform(g2D);\n+        AffineTransform originTransform = g2D.getTransform();\n+\n+        drawHexes(g2D, DrawHexType.Hex);\n+        g2D.setTransform(originTransform);\n+        drawHexes(g2D, DrawHexType.Outline);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawScenarios(g2D);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawFacilities(g2D);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawForces(g2D);\n+\n+        g2D.setTransform(initialTransform);\n+        if (clickedPoint != null) {\n+            g2D.setColor(Color.BLUE);\n+            g2D.drawRect((int) clickedPoint.getX(), (int) clickedPoint.getY(), 2, 2);\n+        }\n+    }\n+\n+    /**\n+     * This method contains a dirty secret hack, but I forget what it is.\n+     * The point of it is to draw all the hexes for the board. \n+     * If it's a \"dry run\", we don't actually draw the hexes, we just pretend to\n+     * until we \"draw\" one that encompasses the clicked point.\n+     * @param g2D - graphics object on which to draw\n+     * @param drawHexType - whether to draw the hex backgrounds, hex outlines or a dry run for click detection\n+     */\n+    private boolean drawHexes(Graphics2D g2D, DrawHexType drawHexType) {\n+        Polygon graphHex = new Polygon();\n+        int xRadius = HEX_X_RADIUS;\n+        int yRadius = HEX_Y_RADIUS;\n+        boolean pointFound = false;\n+\n+        graphHex.addPoint(-xRadius/2, -yRadius);\n+        graphHex.addPoint(-xRadius, 0);\n+        graphHex.addPoint(-xRadius/2, yRadius);\n+        graphHex.addPoint(xRadius/2, yRadius);\n+        graphHex.addPoint(xRadius, 0);\n+        graphHex.addPoint(xRadius/2, -yRadius);\n+\n+        graphHex.translate(xRadius, yRadius);\n+\n+        Point translatedClickedPoint = null;\n+\n+        // this was derived somewhat experimentally\n+        // the clicked point always seems a little off, so we \n+        // a) apply the current transform to it, prior to drawing all the hexes\n+        // b) subtract an additional Y_RADIUS x 2 (Y_DIAMETER)\n+        // this gets us the point within the clicked hex\n+        // it's probably finicky, so any major changes to the rendering mechanism will likely break the detection\n+        if (clickedPoint != null) {\n+            translatedClickedPoint = (Point) clickedPoint.clone();\n+            \n+            // since we have the possibility of scrolling, we need to convert the on-screen clicked coordinates\n+            // to on-board coordinates. Thankfully, SwingUtilities provides the main computational ability for that\n+            Point actualPanelPoint = SwingUtilities.convertPoint(this, translatedClickedPoint, this.getParent());\n+            translatedClickedPoint.translate((int) -(actualPanelPoint.getX() - translatedClickedPoint.getX()), \n+                                                (int) -(actualPanelPoint.getY() - translatedClickedPoint.getY()));\n+            \n+            // now we translate to the starting point of where we're drawing and then go down a hex\n+            translatedClickedPoint.translate((int) g2D.getTransform().getTranslateX(), (int) g2D.getTransform().getTranslateY());\n+            translatedClickedPoint.translate(0, -(HEX_Y_RADIUS * 2));\n+        }\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                if(drawHexType == DrawHexType.Outline) {\n+                    g2D.setColor(new Color(0, 0, 0));\n+                    g2D.drawPolygon(graphHex);                    \n+                } else if (drawHexType == DrawHexType.Hex) {\n+                    \n+                    if (currentTrack.coordsRevealed(x, y) || currentTrack.isGmRevealed()) {\n+                        g2D.setColor(Color.LIGHT_GRAY);\n+                    } else {\n+                        g2D.setColor(Color.DARK_GRAY);\n+                    }\n+                    g2D.fillPolygon(graphHex);\n+                    \n+                    if (translatedClickedPoint != null && graphHex.contains(translatedClickedPoint)) {\n+                        g2D.setColor(Color.WHITE);\n+                        BasicStroke s = new BasicStroke((float) 8.0);\n+                        Stroke push = g2D.getStroke();\n+                        g2D.setStroke(s);\n+                        g2D.drawPolygon(graphHex);\n+                        \n+                        boardState.selectedX = x;\n+                        boardState.selectedY = y;\n+                        pointFound = true;\n+                        g2D.setStroke(push);\n+                    }\n+                } else if (drawHexType == DrawHexType.Dryrun) {\n+                    if (translatedClickedPoint != null && graphHex.contains(translatedClickedPoint)) {\n+                        boardState.selectedX = x;\n+                        boardState.selectedY = y;\n+                        pointFound = true;\n+                    }\n+                }\n+\n+                if (drawHexType == DrawHexType.Hex) {\n+                    g2D.setColor(Color.GREEN);\n+                    g2D.drawString(x + \",\" + y, graphHex.xpoints[0] + (xRadius / 4), graphHex.ypoints[0] + yRadius);\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                graphHex.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            graphHex.translate(translationVector[0], translationVector[1]);\n+        }\n+\n+        return pointFound;\n+    }\n+\n+    /**\n+     * Worker function to render icons representing scenarios to the given surface.\n+     */\n+    private void drawScenarios(Graphics2D g2D) {\n+        Polygon scenarioMarker = new Polygon();\n+        int xRadius = HEX_X_RADIUS / 3;\n+        int yRadius = HEX_Y_RADIUS / 3;\n+\n+        scenarioMarker.addPoint(-xRadius, -yRadius);\n+        scenarioMarker.addPoint(-xRadius, yRadius);\n+        scenarioMarker.addPoint(xRadius, yRadius);\n+        scenarioMarker.addPoint(xRadius, -yRadius);\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                StratconCoords currentCoords = new StratconCoords(x, y);\n+                StratconScenario scenario = currentTrack.getScenario(currentCoords);\n+                \n+                // if there's a scenario here that has a deployment/battle date\n+                // or if there's a scenario here and we've gm-revealed everything\n+                if ((scenario != null) &&\n+                        ((scenario.getDeploymentDate() != null) || currentTrack.isGmRevealed())) {\n+                    g2D.setColor(Color.RED);\n+                    g2D.drawPolygon(scenarioMarker);\n+                    if(currentTrack.getFacility(currentCoords) == null) {\n+                        drawTextEffect(g2D, scenarioMarker, \"Hostile Force Detected\", currentCoords);\n+                    }\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                scenarioMarker.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            scenarioMarker.translate(translationVector[0], translationVector[1]);\n+        }\n+    }\n+    \n+    /**\n+     * Worker function to render facility icons to the given surface.\n+     */\n+    private void drawFacilities(Graphics2D g2D) {\n+        Polygon facilityMarker = new Polygon();\n+        int xRadius = HEX_X_RADIUS / 3;\n+        int yRadius = HEX_Y_RADIUS / 3;\n+\n+        facilityMarker.addPoint(-xRadius, -yRadius);\n+        facilityMarker.addPoint(-xRadius, yRadius);\n+        facilityMarker.addPoint(xRadius, yRadius);\n+        facilityMarker.addPoint(xRadius, -yRadius);\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                StratconCoords currentCoords = new StratconCoords(x, y);\n+                StratconFacility facility = currentTrack.getFacility(currentCoords);\n+                \n+                if ((facility != null) && (facility.isVisible() || currentTrack.isGmRevealed())) {\n+                    g2D.setColor(facility.getOwner() == ForceAlignment.Allied ? Color.GREEN : Color.RED);\n+                    g2D.drawPolygon(facilityMarker);\n+                    drawTextEffect(g2D, facilityMarker, facility.getFormattedDisplayableName(), currentCoords);\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                facilityMarker.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            facilityMarker.translate(translationVector[0], translationVector[1]);\n+        }\n+    }\n+    \n+    /**\n+     * Worker function to render force icons to the given surface.\n+     */\n+    private void drawForces(Graphics2D g2D) {\n+        Polygon forceMarker = new Polygon();\n+        int xRadius = HEX_X_RADIUS / 3;\n+        int yRadius = HEX_Y_RADIUS / 3;\n+\n+        forceMarker.addPoint(-xRadius, -yRadius);\n+        forceMarker.addPoint(-xRadius, yRadius);\n+        forceMarker.addPoint(xRadius, yRadius);\n+        forceMarker.addPoint(xRadius, -yRadius);\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                StratconCoords currentCoords = new StratconCoords(x, y);\n+                \n+                if (currentTrack.getAssignedCoordForces().containsKey(currentCoords)) {\n+                    for (int forceID : currentTrack.getAssignedCoordForces().get(currentCoords)) {                   \n+                        g2D.setColor(Color.BLUE);\n+                        g2D.drawPolygon(forceMarker);\n+                        drawTextEffect(g2D, forceMarker, campaign.getForce(forceID).getName(), currentCoords);\n+                    }\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                forceMarker.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            forceMarker.translate(translationVector[0], translationVector[1]);\n+        }\n+    }\n+    \n+    /**\n+     * Draws some text and line to it from a given polygon. \n+     * Smart enough not to layer multiple strings on top of each other if they're all drawn in the same hex.\n+     */\n+    private void drawTextEffect(Graphics2D g2D, Polygon marker, String text, StratconCoords coords) {\n+        int verticalOffsetIndex = numIconsInHex.containsKey(coords) ? numIconsInHex.get(coords) : 0;\n+        \n+        double startX = marker.getBounds().getMaxX();\n+        double startY = marker.getBounds().getMinY();\n+        double midPointX = startX + HEX_X_RADIUS / 4;\n+        double midPointY = startY - HEX_Y_RADIUS / 4 + g2D.getFontMetrics().getHeight() * verticalOffsetIndex;\n+        double endPointX = midPointX + HEX_X_RADIUS / 2;\n+        \n+        g2D.drawLine((int) startX, (int) startY, (int) midPointX, (int) midPointY);\n+        g2D.drawLine((int) midPointX, (int) midPointY, (int) endPointX, (int) midPointY);\n+        g2D.drawString(text, (int) endPointX, (int) midPointY);\n+        \n+        // register that we drew text off of this hex\n+        verticalOffsetIndex++;\n+        numIconsInHex.put(coords, verticalOffsetIndex);\n+    }\n+\n+    /**\n+     * Returns the translation that we need to make to render the \"next downward\" hex.\n+     * @return Two dimensional array with the first element being the x vector and the second being the y vector\n+     */\n+    private int[] getDownwardYVector() {\n+        return new int[] { 0, (int) (HEX_Y_RADIUS * 2) };\n+    }\n+\n+    /**\n+     * Returns the translation that we need to make to move from the bottom of a column to the top of the next\n+     * column to the right.\n+     * @param evenColumn Whether the column we're currently in is odd or even\n+     * @return Two dimensional array with the first element being the x vector and the second being the y vector\n+     */\n+    private int[] getRightAndUPVector(boolean evenColumn) {\n+        int yRadius = (int) (HEX_Y_RADIUS);\n+        int xRadius = (int) (HEX_X_RADIUS);\n+\n+        int yTranslation = currentTrack.getHeight() * yRadius * 2;\n+        if (evenColumn) {\n+            yTranslation += yRadius;\n+        } else {\n+            yTranslation -= yRadius;\n+        }\n+\n+        return new int[] {(int) (xRadius * 1.5), -yTranslation};\n+    }\n+\n+    /**\n+     * Go to the origin of the hex board and reset the scaling.\n+     */\n+    private void performInitialTransform(Graphics2D g2D) {\n+        g2D.translate(0, 0 + HEX_Y_RADIUS);\n+        g2D.scale(scale, scale);\n+    }\n+\n+    /** \n+     * Worker function that takes the current clicked point and a graphics 2D object\n+     * and detects which hex was clicked by doing a dry run hex render.\n+     * \n+     * Dependent upon clickedPoint being set and having an active graphics object for this class.\n+     * \n+     * Side effects: the dry run sets the boardState clicked hex coordinates.\n+     * @return Whether or not the clicked point was found on the hex board\n+     */\n+    private boolean detectClickedHex() {\n+        Graphics2D g2D = (Graphics2D) getGraphics();\n+        AffineTransform transform = g2D.getTransform();\n+        performInitialTransform(g2D);\n+        boolean pointFoundOnBoard = drawHexes(g2D, DrawHexType.Dryrun);\n+        g2D.setTransform(transform);\n+\n+        return pointFoundOnBoard;\n+    }\n+\n+    /**\n+     * Event handler for when a mouse button is released.\n+     */\n+    public void mouseReleasedHandler(MouseEvent e) {\n+        if(e.getSource() != this) {\n+            return;\n+        }\n+\n+        // left button generally selects a hex\n+        if (e.getButton() == MouseEvent.BUTTON1) {        \n+            clickedPoint = e.getPoint();\n+            boolean pointFoundOnBoard = detectClickedHex();\n+            \n+            if(pointFoundOnBoard) {\n+                infoArea.setText(buildSelectedHexInfo());\n+            }\n+\n+            repaint();\n+        // right button generally pops up a context menu\n+        } else if (e.getButton() == MouseEvent.BUTTON3) {\n+            clickedPoint = e.getPoint();\n+            detectClickedHex();\n+            \n+            StratconCoords selectedCoords = boardState.getSelectedCoords();\n+            if (selectedCoords == null) {\n+                return;\n+            }\n+            \n+            repaint();\n+            buildRightClickMenu(selectedCoords);\n+            rightClickMenu.show(this, e.getX(), e.getY());\n+        }\n+    }\n+    \n+    public StratconScenario getSelectedScenario() {\n+        return currentTrack.getScenario(boardState.getSelectedCoords());\n+    }\n+    \n+    /**\n+     * Worker function that outputs html representing the status of a selected hex,\n+     * containing info such as whether it's been revealed, assigned forces, scenarios, facilities, etc.\n+     */\n+    private String buildSelectedHexInfo() {\n+        StringBuilder infoBuilder = new StringBuilder();\n+        infoBuilder.append(\"<html><br/>\");\n+        \n+        boolean coordsRevealed = currentTrack.getRevealedCoords().contains(boardState.getSelectedCoords());\n+        if (coordsRevealed) {\n+            infoBuilder.append(\"<span color='green'>Recon complete</span><br/>\");\n+        }\n+        \n+        if (currentTrack.getAssignedCoordForces().containsKey(boardState.getSelectedCoords())) {\n+            for (int forceID : currentTrack.getAssignedCoordForces().get(boardState.getSelectedCoords())) {\n+                Force force = campaign.getForce(forceID);\n+                infoBuilder.append(force.getName()).append(\" assigned\");\n+                \n+                if (currentTrack.getStickyForces().contains(forceID)) {\n+                    infoBuilder.append(\" - remain deployed\");\n+                }\n+                \n+                infoBuilder.append(\"<br/>\");\n+                \n+                infoBuilder.append(\"Returns on \").append(currentTrack.getAssignedForceReturnDates().get(forceID));\n+                infoBuilder.append(\"<br/>\");\n+            }\n+        }\n+        \n+        if (coordsRevealed || currentTrack.isGmRevealed()) {\n+            StratconFacility facility = currentTrack.getFacility(boardState.getSelectedCoords());\n+            \n+            if((facility != null) && (facility.getFacilityType() != null)) {\n+                if (facility.isStrategicObjective()) {\n+                    infoBuilder.append(String.format(\"<br/><span color='%s'>Contract objective located</span>\", \n+                            facility.getOwner() == ForceAlignment.Allied ? \"green\" : \"red\"));\n+                }\n+                infoBuilder.append((facility.getOwner() == ForceAlignment.Allied) ? \"<span color='green'>\" : \"<span color='red'>\");\n+                infoBuilder.append(\"<br/>\");\n+                infoBuilder.append(facility.getFormattedDisplayableName());\n+                infoBuilder.append(\"<span>\");\n+            }\n+            \n+        } else {\n+            infoBuilder.append(\"<span color='red'>Recon incomplete</span>\");\n+        }\n+        infoBuilder.append(\"<br/>\");\n+        \n+        \n+        StratconScenario selectedScenario = getSelectedScenario();\n+        if ((selectedScenario != null) &&\n+                ((selectedScenario.getDeploymentDate() != null) || currentTrack.isGmRevealed())) {\n+            infoBuilder.append(selectedScenario.getInfo());\n+        }\n+        \n+        infoBuilder.append(\"</html>\");\n+        \n+        return infoBuilder.toString();\n+    }\n+\n+    /**\n+     * Data structure containing current state of the board.\n+     */\n+    private static class BoardState {\n+        public Integer selectedX;\n+        public Integer selectedY;\n+        \n+        public StratconCoords getSelectedCoords() {\n+            if((selectedX == null) || (selectedY == null)) {", "originalCommit": "796b6728fd3cd2aea02d17122b4d735afc47dc41", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjkwMjYxOA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r602902618", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if(selectedCoords == null) {\n          \n          \n            \n                    if (selectedCoords == null) {", "author": "Windchild292", "createdAt": "2021-03-28T16:51:49Z", "path": "MekHQ/src/mekhq/gui/StratconPanel.java", "diffHunk": "@@ -0,0 +1,672 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.gui;\n+\n+import java.awt.BasicStroke;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Point;\n+import java.awt.Polygon;\n+import java.awt.Stroke;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.awt.geom.AffineTransform;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import javax.swing.JCheckBoxMenuItem;\n+import javax.swing.JLabel;\n+import javax.swing.JMenuItem;\n+import javax.swing.JPanel;\n+import javax.swing.JPopupMenu;\n+import javax.swing.SwingUtilities;\n+\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.stratcon.StratconCampaignState;\n+import mekhq.campaign.stratcon.StratconCoords;\n+import mekhq.campaign.stratcon.StratconFacility;\n+import mekhq.campaign.stratcon.StratconScenario;\n+import mekhq.campaign.stratcon.StratconTrackState;\n+import mekhq.gui.stratcon.StratconScenarioWizard;\n+import mekhq.gui.stratcon.TrackForceAssignmentUI;\n+\n+/**\n+ * This panel handles AtB-Stratcon GUI interactions with a specific scenario track.\n+ * @author NickAragua\n+ */\n+public class StratconPanel extends JPanel implements ActionListener {\n+    /**\n+     * \n+     */\n+    private static final long serialVersionUID = 7405934788894417292L;\n+    \n+    public static final int HEX_X_RADIUS = 42;\n+    public static final int HEX_Y_RADIUS = 37;\n+    \n+    private static final String RCLICK_COMMAND_MANAGE_FORCES = \"ManageForces\";\n+    private static final String RCLICK_COMMAND_MANAGE_SCENARIO = \"ManageScenario\";\n+    private static final String RCLICK_COMMAND_REVEAL_TRACK = \"RevealTrack\";\n+    private static final String RCLICK_COMMAND_STICKY_FORCE = \"StickyForce\";\n+    private static final String RCLICK_COMMAND_STICKY_FORCE_ID = \"StickyForceID\";\n+\n+    /**\n+     * What to do when drawing a hex\n+     */\n+    private enum DrawHexType {\n+        /**\n+         * The interior of a hex\n+         */\n+        Hex,\n+        \n+        /**\n+         * The outline of a hex\n+         */\n+        Outline,\n+        \n+        /**\n+         * Pretend we're drawing a hex, but don't actually do it, useful for \n+         * figuring out which hex a mouse click landed in, etc.\n+         */\n+        Dryrun\n+    }\n+\n+    private float scale = 1f;\n+\n+    private StratconTrackState currentTrack;\n+    private StratconCampaignState campaignState;\n+    private Campaign campaign;\n+\n+    private BoardState boardState = new BoardState();\n+\n+    private Point clickedPoint;\n+    private JPopupMenu rightClickMenu;\n+    private JMenuItem menuItemManageForceAssignments;\n+    private JMenuItem menuItemManageScenario;\n+    private JMenuItem menuItemGMReveal;\n+    \n+    // data structure holding how many unit/scenario/base icons have been drawn in the hex\n+    // used to control how low the text description goes.\n+    private Map<StratconCoords, Integer> numIconsInHex = new HashMap<>();\n+    \n+    private StratconScenarioWizard scenarioWizard;\n+    private TrackForceAssignmentUI assignmentUI;\n+    \n+    private JLabel infoArea;\n+\n+    /**\n+     * Constructs a StratconPanel instance, given a parent campaign GUI and a pointer to an info area.\n+     */\n+    StratconPanel(CampaignGUI gui, JLabel infoArea) {\n+        campaign = gui.getCampaign();\n+        scenarioWizard = new StratconScenarioWizard(campaign);\n+        this.infoArea = infoArea;\n+        \n+        assignmentUI = new TrackForceAssignmentUI(this);\n+        assignmentUI.setVisible(false);\n+        \n+        addMouseListener(new MouseAdapter() {\n+            @Override\n+            public void mouseReleased(MouseEvent e) {\n+                mouseReleasedHandler(e);\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Handler for when a specific track is selected - switches rendering to that track.\n+     */\n+    public void selectTrack(StratconCampaignState campaignState, StratconTrackState track) {\n+        this.campaignState = campaignState;\n+        currentTrack = track;\n+        repaint();\n+    }\n+    \n+    /**\n+     * Constructs the right-click context menu, optionally for a scenario\n+     */\n+    private void buildRightClickMenu(StratconCoords coords) {\n+        rightClickMenu = new JPopupMenu();\n+        \n+        StratconScenario scenario = getSelectedScenario();\n+        \n+        if (scenario == null) {\n+            menuItemManageForceAssignments = new JMenuItem();\n+            menuItemManageForceAssignments.setText(\"Manage Force Assignments\");\n+            menuItemManageForceAssignments.setActionCommand(RCLICK_COMMAND_MANAGE_FORCES);\n+            menuItemManageForceAssignments.addActionListener(this);\n+            rightClickMenu.add(menuItemManageForceAssignments);\n+        }\n+        \n+        if (scenario != null) {\n+            menuItemManageScenario = new JMenuItem();\n+            menuItemManageScenario.setText(\"Manage Scenario\");\n+            menuItemManageScenario.setActionCommand(RCLICK_COMMAND_MANAGE_SCENARIO);\n+            menuItemManageScenario.addActionListener(this);\n+            rightClickMenu.add(menuItemManageScenario);\n+        }\n+        \n+        if ((currentTrack != null) && currentTrack.getAssignedCoordForces().containsKey(coords)) {\n+            for (int forceID : currentTrack.getAssignedCoordForces().get(coords)) {\n+                String forceName = campaign.getForce(forceID).getName();\n+                \n+                JCheckBoxMenuItem stickyForceItem = new JCheckBoxMenuItem();\n+                stickyForceItem.setText(String.format(\"%s - remain deployed\", forceName));\n+                stickyForceItem.setActionCommand(RCLICK_COMMAND_STICKY_FORCE);\n+                stickyForceItem.putClientProperty(RCLICK_COMMAND_STICKY_FORCE_ID, forceID);\n+                stickyForceItem.addActionListener(this);\n+                stickyForceItem.setSelected(currentTrack.getStickyForces().contains(forceID));\n+                rightClickMenu.add(stickyForceItem);\n+            }\n+        }\n+            \n+        if ((currentTrack != null) && campaign.isGM()) {\n+            rightClickMenu.addSeparator();\n+            \n+            menuItemGMReveal = new JMenuItem();\n+            menuItemGMReveal.setText(currentTrack.isGmRevealed() ? \"Hide Track\" : \"Reveal Track\");\n+            menuItemGMReveal.setActionCommand(RCLICK_COMMAND_REVEAL_TRACK);\n+            menuItemGMReveal.addActionListener(this);\n+            rightClickMenu.add(menuItemGMReveal);\n+        }\n+    }\n+\n+    /**\n+     * Renders the panel, hexes, forces, facilities and all that.\n+     */\n+    @Override\n+    public void paintComponent(Graphics g) {\n+        super.paintComponent(g);\n+        if (campaignState == null || currentTrack == null) {\n+            return;\n+        }\n+        \n+        numIconsInHex.clear();\n+\n+        Graphics2D g2D = (Graphics2D) g;\n+        AffineTransform initialTransform = g2D.getTransform();\n+        performInitialTransform(g2D);\n+        AffineTransform originTransform = g2D.getTransform();\n+\n+        drawHexes(g2D, DrawHexType.Hex);\n+        g2D.setTransform(originTransform);\n+        drawHexes(g2D, DrawHexType.Outline);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawScenarios(g2D);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawFacilities(g2D);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawForces(g2D);\n+\n+        g2D.setTransform(initialTransform);\n+        if (clickedPoint != null) {\n+            g2D.setColor(Color.BLUE);\n+            g2D.drawRect((int) clickedPoint.getX(), (int) clickedPoint.getY(), 2, 2);\n+        }\n+    }\n+\n+    /**\n+     * This method contains a dirty secret hack, but I forget what it is.\n+     * The point of it is to draw all the hexes for the board. \n+     * If it's a \"dry run\", we don't actually draw the hexes, we just pretend to\n+     * until we \"draw\" one that encompasses the clicked point.\n+     * @param g2D - graphics object on which to draw\n+     * @param drawHexType - whether to draw the hex backgrounds, hex outlines or a dry run for click detection\n+     */\n+    private boolean drawHexes(Graphics2D g2D, DrawHexType drawHexType) {\n+        Polygon graphHex = new Polygon();\n+        int xRadius = HEX_X_RADIUS;\n+        int yRadius = HEX_Y_RADIUS;\n+        boolean pointFound = false;\n+\n+        graphHex.addPoint(-xRadius/2, -yRadius);\n+        graphHex.addPoint(-xRadius, 0);\n+        graphHex.addPoint(-xRadius/2, yRadius);\n+        graphHex.addPoint(xRadius/2, yRadius);\n+        graphHex.addPoint(xRadius, 0);\n+        graphHex.addPoint(xRadius/2, -yRadius);\n+\n+        graphHex.translate(xRadius, yRadius);\n+\n+        Point translatedClickedPoint = null;\n+\n+        // this was derived somewhat experimentally\n+        // the clicked point always seems a little off, so we \n+        // a) apply the current transform to it, prior to drawing all the hexes\n+        // b) subtract an additional Y_RADIUS x 2 (Y_DIAMETER)\n+        // this gets us the point within the clicked hex\n+        // it's probably finicky, so any major changes to the rendering mechanism will likely break the detection\n+        if (clickedPoint != null) {\n+            translatedClickedPoint = (Point) clickedPoint.clone();\n+            \n+            // since we have the possibility of scrolling, we need to convert the on-screen clicked coordinates\n+            // to on-board coordinates. Thankfully, SwingUtilities provides the main computational ability for that\n+            Point actualPanelPoint = SwingUtilities.convertPoint(this, translatedClickedPoint, this.getParent());\n+            translatedClickedPoint.translate((int) -(actualPanelPoint.getX() - translatedClickedPoint.getX()), \n+                                                (int) -(actualPanelPoint.getY() - translatedClickedPoint.getY()));\n+            \n+            // now we translate to the starting point of where we're drawing and then go down a hex\n+            translatedClickedPoint.translate((int) g2D.getTransform().getTranslateX(), (int) g2D.getTransform().getTranslateY());\n+            translatedClickedPoint.translate(0, -(HEX_Y_RADIUS * 2));\n+        }\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                if(drawHexType == DrawHexType.Outline) {\n+                    g2D.setColor(new Color(0, 0, 0));\n+                    g2D.drawPolygon(graphHex);                    \n+                } else if (drawHexType == DrawHexType.Hex) {\n+                    \n+                    if (currentTrack.coordsRevealed(x, y) || currentTrack.isGmRevealed()) {\n+                        g2D.setColor(Color.LIGHT_GRAY);\n+                    } else {\n+                        g2D.setColor(Color.DARK_GRAY);\n+                    }\n+                    g2D.fillPolygon(graphHex);\n+                    \n+                    if (translatedClickedPoint != null && graphHex.contains(translatedClickedPoint)) {\n+                        g2D.setColor(Color.WHITE);\n+                        BasicStroke s = new BasicStroke((float) 8.0);\n+                        Stroke push = g2D.getStroke();\n+                        g2D.setStroke(s);\n+                        g2D.drawPolygon(graphHex);\n+                        \n+                        boardState.selectedX = x;\n+                        boardState.selectedY = y;\n+                        pointFound = true;\n+                        g2D.setStroke(push);\n+                    }\n+                } else if (drawHexType == DrawHexType.Dryrun) {\n+                    if (translatedClickedPoint != null && graphHex.contains(translatedClickedPoint)) {\n+                        boardState.selectedX = x;\n+                        boardState.selectedY = y;\n+                        pointFound = true;\n+                    }\n+                }\n+\n+                if (drawHexType == DrawHexType.Hex) {\n+                    g2D.setColor(Color.GREEN);\n+                    g2D.drawString(x + \",\" + y, graphHex.xpoints[0] + (xRadius / 4), graphHex.ypoints[0] + yRadius);\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                graphHex.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            graphHex.translate(translationVector[0], translationVector[1]);\n+        }\n+\n+        return pointFound;\n+    }\n+\n+    /**\n+     * Worker function to render icons representing scenarios to the given surface.\n+     */\n+    private void drawScenarios(Graphics2D g2D) {\n+        Polygon scenarioMarker = new Polygon();\n+        int xRadius = HEX_X_RADIUS / 3;\n+        int yRadius = HEX_Y_RADIUS / 3;\n+\n+        scenarioMarker.addPoint(-xRadius, -yRadius);\n+        scenarioMarker.addPoint(-xRadius, yRadius);\n+        scenarioMarker.addPoint(xRadius, yRadius);\n+        scenarioMarker.addPoint(xRadius, -yRadius);\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                StratconCoords currentCoords = new StratconCoords(x, y);\n+                StratconScenario scenario = currentTrack.getScenario(currentCoords);\n+                \n+                // if there's a scenario here that has a deployment/battle date\n+                // or if there's a scenario here and we've gm-revealed everything\n+                if ((scenario != null) &&\n+                        ((scenario.getDeploymentDate() != null) || currentTrack.isGmRevealed())) {\n+                    g2D.setColor(Color.RED);\n+                    g2D.drawPolygon(scenarioMarker);\n+                    if(currentTrack.getFacility(currentCoords) == null) {\n+                        drawTextEffect(g2D, scenarioMarker, \"Hostile Force Detected\", currentCoords);\n+                    }\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                scenarioMarker.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            scenarioMarker.translate(translationVector[0], translationVector[1]);\n+        }\n+    }\n+    \n+    /**\n+     * Worker function to render facility icons to the given surface.\n+     */\n+    private void drawFacilities(Graphics2D g2D) {\n+        Polygon facilityMarker = new Polygon();\n+        int xRadius = HEX_X_RADIUS / 3;\n+        int yRadius = HEX_Y_RADIUS / 3;\n+\n+        facilityMarker.addPoint(-xRadius, -yRadius);\n+        facilityMarker.addPoint(-xRadius, yRadius);\n+        facilityMarker.addPoint(xRadius, yRadius);\n+        facilityMarker.addPoint(xRadius, -yRadius);\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                StratconCoords currentCoords = new StratconCoords(x, y);\n+                StratconFacility facility = currentTrack.getFacility(currentCoords);\n+                \n+                if ((facility != null) && (facility.isVisible() || currentTrack.isGmRevealed())) {\n+                    g2D.setColor(facility.getOwner() == ForceAlignment.Allied ? Color.GREEN : Color.RED);\n+                    g2D.drawPolygon(facilityMarker);\n+                    drawTextEffect(g2D, facilityMarker, facility.getFormattedDisplayableName(), currentCoords);\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                facilityMarker.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            facilityMarker.translate(translationVector[0], translationVector[1]);\n+        }\n+    }\n+    \n+    /**\n+     * Worker function to render force icons to the given surface.\n+     */\n+    private void drawForces(Graphics2D g2D) {\n+        Polygon forceMarker = new Polygon();\n+        int xRadius = HEX_X_RADIUS / 3;\n+        int yRadius = HEX_Y_RADIUS / 3;\n+\n+        forceMarker.addPoint(-xRadius, -yRadius);\n+        forceMarker.addPoint(-xRadius, yRadius);\n+        forceMarker.addPoint(xRadius, yRadius);\n+        forceMarker.addPoint(xRadius, -yRadius);\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                StratconCoords currentCoords = new StratconCoords(x, y);\n+                \n+                if (currentTrack.getAssignedCoordForces().containsKey(currentCoords)) {\n+                    for (int forceID : currentTrack.getAssignedCoordForces().get(currentCoords)) {                   \n+                        g2D.setColor(Color.BLUE);\n+                        g2D.drawPolygon(forceMarker);\n+                        drawTextEffect(g2D, forceMarker, campaign.getForce(forceID).getName(), currentCoords);\n+                    }\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                forceMarker.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            forceMarker.translate(translationVector[0], translationVector[1]);\n+        }\n+    }\n+    \n+    /**\n+     * Draws some text and line to it from a given polygon. \n+     * Smart enough not to layer multiple strings on top of each other if they're all drawn in the same hex.\n+     */\n+    private void drawTextEffect(Graphics2D g2D, Polygon marker, String text, StratconCoords coords) {\n+        int verticalOffsetIndex = numIconsInHex.containsKey(coords) ? numIconsInHex.get(coords) : 0;\n+        \n+        double startX = marker.getBounds().getMaxX();\n+        double startY = marker.getBounds().getMinY();\n+        double midPointX = startX + HEX_X_RADIUS / 4;\n+        double midPointY = startY - HEX_Y_RADIUS / 4 + g2D.getFontMetrics().getHeight() * verticalOffsetIndex;\n+        double endPointX = midPointX + HEX_X_RADIUS / 2;\n+        \n+        g2D.drawLine((int) startX, (int) startY, (int) midPointX, (int) midPointY);\n+        g2D.drawLine((int) midPointX, (int) midPointY, (int) endPointX, (int) midPointY);\n+        g2D.drawString(text, (int) endPointX, (int) midPointY);\n+        \n+        // register that we drew text off of this hex\n+        verticalOffsetIndex++;\n+        numIconsInHex.put(coords, verticalOffsetIndex);\n+    }\n+\n+    /**\n+     * Returns the translation that we need to make to render the \"next downward\" hex.\n+     * @return Two dimensional array with the first element being the x vector and the second being the y vector\n+     */\n+    private int[] getDownwardYVector() {\n+        return new int[] { 0, (int) (HEX_Y_RADIUS * 2) };\n+    }\n+\n+    /**\n+     * Returns the translation that we need to make to move from the bottom of a column to the top of the next\n+     * column to the right.\n+     * @param evenColumn Whether the column we're currently in is odd or even\n+     * @return Two dimensional array with the first element being the x vector and the second being the y vector\n+     */\n+    private int[] getRightAndUPVector(boolean evenColumn) {\n+        int yRadius = (int) (HEX_Y_RADIUS);\n+        int xRadius = (int) (HEX_X_RADIUS);\n+\n+        int yTranslation = currentTrack.getHeight() * yRadius * 2;\n+        if (evenColumn) {\n+            yTranslation += yRadius;\n+        } else {\n+            yTranslation -= yRadius;\n+        }\n+\n+        return new int[] {(int) (xRadius * 1.5), -yTranslation};\n+    }\n+\n+    /**\n+     * Go to the origin of the hex board and reset the scaling.\n+     */\n+    private void performInitialTransform(Graphics2D g2D) {\n+        g2D.translate(0, 0 + HEX_Y_RADIUS);\n+        g2D.scale(scale, scale);\n+    }\n+\n+    /** \n+     * Worker function that takes the current clicked point and a graphics 2D object\n+     * and detects which hex was clicked by doing a dry run hex render.\n+     * \n+     * Dependent upon clickedPoint being set and having an active graphics object for this class.\n+     * \n+     * Side effects: the dry run sets the boardState clicked hex coordinates.\n+     * @return Whether or not the clicked point was found on the hex board\n+     */\n+    private boolean detectClickedHex() {\n+        Graphics2D g2D = (Graphics2D) getGraphics();\n+        AffineTransform transform = g2D.getTransform();\n+        performInitialTransform(g2D);\n+        boolean pointFoundOnBoard = drawHexes(g2D, DrawHexType.Dryrun);\n+        g2D.setTransform(transform);\n+\n+        return pointFoundOnBoard;\n+    }\n+\n+    /**\n+     * Event handler for when a mouse button is released.\n+     */\n+    public void mouseReleasedHandler(MouseEvent e) {\n+        if(e.getSource() != this) {\n+            return;\n+        }\n+\n+        // left button generally selects a hex\n+        if (e.getButton() == MouseEvent.BUTTON1) {        \n+            clickedPoint = e.getPoint();\n+            boolean pointFoundOnBoard = detectClickedHex();\n+            \n+            if(pointFoundOnBoard) {\n+                infoArea.setText(buildSelectedHexInfo());\n+            }\n+\n+            repaint();\n+        // right button generally pops up a context menu\n+        } else if (e.getButton() == MouseEvent.BUTTON3) {\n+            clickedPoint = e.getPoint();\n+            detectClickedHex();\n+            \n+            StratconCoords selectedCoords = boardState.getSelectedCoords();\n+            if (selectedCoords == null) {\n+                return;\n+            }\n+            \n+            repaint();\n+            buildRightClickMenu(selectedCoords);\n+            rightClickMenu.show(this, e.getX(), e.getY());\n+        }\n+    }\n+    \n+    public StratconScenario getSelectedScenario() {\n+        return currentTrack.getScenario(boardState.getSelectedCoords());\n+    }\n+    \n+    /**\n+     * Worker function that outputs html representing the status of a selected hex,\n+     * containing info such as whether it's been revealed, assigned forces, scenarios, facilities, etc.\n+     */\n+    private String buildSelectedHexInfo() {\n+        StringBuilder infoBuilder = new StringBuilder();\n+        infoBuilder.append(\"<html><br/>\");\n+        \n+        boolean coordsRevealed = currentTrack.getRevealedCoords().contains(boardState.getSelectedCoords());\n+        if (coordsRevealed) {\n+            infoBuilder.append(\"<span color='green'>Recon complete</span><br/>\");\n+        }\n+        \n+        if (currentTrack.getAssignedCoordForces().containsKey(boardState.getSelectedCoords())) {\n+            for (int forceID : currentTrack.getAssignedCoordForces().get(boardState.getSelectedCoords())) {\n+                Force force = campaign.getForce(forceID);\n+                infoBuilder.append(force.getName()).append(\" assigned\");\n+                \n+                if (currentTrack.getStickyForces().contains(forceID)) {\n+                    infoBuilder.append(\" - remain deployed\");\n+                }\n+                \n+                infoBuilder.append(\"<br/>\");\n+                \n+                infoBuilder.append(\"Returns on \").append(currentTrack.getAssignedForceReturnDates().get(forceID));\n+                infoBuilder.append(\"<br/>\");\n+            }\n+        }\n+        \n+        if (coordsRevealed || currentTrack.isGmRevealed()) {\n+            StratconFacility facility = currentTrack.getFacility(boardState.getSelectedCoords());\n+            \n+            if((facility != null) && (facility.getFacilityType() != null)) {\n+                if (facility.isStrategicObjective()) {\n+                    infoBuilder.append(String.format(\"<br/><span color='%s'>Contract objective located</span>\", \n+                            facility.getOwner() == ForceAlignment.Allied ? \"green\" : \"red\"));\n+                }\n+                infoBuilder.append((facility.getOwner() == ForceAlignment.Allied) ? \"<span color='green'>\" : \"<span color='red'>\");\n+                infoBuilder.append(\"<br/>\");\n+                infoBuilder.append(facility.getFormattedDisplayableName());\n+                infoBuilder.append(\"<span>\");\n+            }\n+            \n+        } else {\n+            infoBuilder.append(\"<span color='red'>Recon incomplete</span>\");\n+        }\n+        infoBuilder.append(\"<br/>\");\n+        \n+        \n+        StratconScenario selectedScenario = getSelectedScenario();\n+        if ((selectedScenario != null) &&\n+                ((selectedScenario.getDeploymentDate() != null) || currentTrack.isGmRevealed())) {\n+            infoBuilder.append(selectedScenario.getInfo());\n+        }\n+        \n+        infoBuilder.append(\"</html>\");\n+        \n+        return infoBuilder.toString();\n+    }\n+\n+    /**\n+     * Data structure containing current state of the board.\n+     */\n+    private static class BoardState {\n+        public Integer selectedX;\n+        public Integer selectedY;\n+        \n+        public StratconCoords getSelectedCoords() {\n+            if((selectedX == null) || (selectedY == null)) {\n+                return null;\n+            } else {\n+                return new StratconCoords(selectedX, selectedY);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Event handler for various button and menu item presses.\n+     */\n+    @Override\n+    public void actionPerformed(ActionEvent e) {\n+        StratconCoords selectedCoords = boardState.getSelectedCoords();\n+        if(selectedCoords == null) {", "originalCommit": "796b6728fd3cd2aea02d17122b4d735afc47dc41", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjkwMjYyNg==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r602902626", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    switch(e.getActionCommand()) {\n          \n          \n            \n                    switch (e.getActionCommand()) {", "author": "Windchild292", "createdAt": "2021-03-28T16:51:54Z", "path": "MekHQ/src/mekhq/gui/StratconPanel.java", "diffHunk": "@@ -0,0 +1,672 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.gui;\n+\n+import java.awt.BasicStroke;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Point;\n+import java.awt.Polygon;\n+import java.awt.Stroke;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.awt.geom.AffineTransform;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import javax.swing.JCheckBoxMenuItem;\n+import javax.swing.JLabel;\n+import javax.swing.JMenuItem;\n+import javax.swing.JPanel;\n+import javax.swing.JPopupMenu;\n+import javax.swing.SwingUtilities;\n+\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.stratcon.StratconCampaignState;\n+import mekhq.campaign.stratcon.StratconCoords;\n+import mekhq.campaign.stratcon.StratconFacility;\n+import mekhq.campaign.stratcon.StratconScenario;\n+import mekhq.campaign.stratcon.StratconTrackState;\n+import mekhq.gui.stratcon.StratconScenarioWizard;\n+import mekhq.gui.stratcon.TrackForceAssignmentUI;\n+\n+/**\n+ * This panel handles AtB-Stratcon GUI interactions with a specific scenario track.\n+ * @author NickAragua\n+ */\n+public class StratconPanel extends JPanel implements ActionListener {\n+    /**\n+     * \n+     */\n+    private static final long serialVersionUID = 7405934788894417292L;\n+    \n+    public static final int HEX_X_RADIUS = 42;\n+    public static final int HEX_Y_RADIUS = 37;\n+    \n+    private static final String RCLICK_COMMAND_MANAGE_FORCES = \"ManageForces\";\n+    private static final String RCLICK_COMMAND_MANAGE_SCENARIO = \"ManageScenario\";\n+    private static final String RCLICK_COMMAND_REVEAL_TRACK = \"RevealTrack\";\n+    private static final String RCLICK_COMMAND_STICKY_FORCE = \"StickyForce\";\n+    private static final String RCLICK_COMMAND_STICKY_FORCE_ID = \"StickyForceID\";\n+\n+    /**\n+     * What to do when drawing a hex\n+     */\n+    private enum DrawHexType {\n+        /**\n+         * The interior of a hex\n+         */\n+        Hex,\n+        \n+        /**\n+         * The outline of a hex\n+         */\n+        Outline,\n+        \n+        /**\n+         * Pretend we're drawing a hex, but don't actually do it, useful for \n+         * figuring out which hex a mouse click landed in, etc.\n+         */\n+        Dryrun\n+    }\n+\n+    private float scale = 1f;\n+\n+    private StratconTrackState currentTrack;\n+    private StratconCampaignState campaignState;\n+    private Campaign campaign;\n+\n+    private BoardState boardState = new BoardState();\n+\n+    private Point clickedPoint;\n+    private JPopupMenu rightClickMenu;\n+    private JMenuItem menuItemManageForceAssignments;\n+    private JMenuItem menuItemManageScenario;\n+    private JMenuItem menuItemGMReveal;\n+    \n+    // data structure holding how many unit/scenario/base icons have been drawn in the hex\n+    // used to control how low the text description goes.\n+    private Map<StratconCoords, Integer> numIconsInHex = new HashMap<>();\n+    \n+    private StratconScenarioWizard scenarioWizard;\n+    private TrackForceAssignmentUI assignmentUI;\n+    \n+    private JLabel infoArea;\n+\n+    /**\n+     * Constructs a StratconPanel instance, given a parent campaign GUI and a pointer to an info area.\n+     */\n+    StratconPanel(CampaignGUI gui, JLabel infoArea) {\n+        campaign = gui.getCampaign();\n+        scenarioWizard = new StratconScenarioWizard(campaign);\n+        this.infoArea = infoArea;\n+        \n+        assignmentUI = new TrackForceAssignmentUI(this);\n+        assignmentUI.setVisible(false);\n+        \n+        addMouseListener(new MouseAdapter() {\n+            @Override\n+            public void mouseReleased(MouseEvent e) {\n+                mouseReleasedHandler(e);\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Handler for when a specific track is selected - switches rendering to that track.\n+     */\n+    public void selectTrack(StratconCampaignState campaignState, StratconTrackState track) {\n+        this.campaignState = campaignState;\n+        currentTrack = track;\n+        repaint();\n+    }\n+    \n+    /**\n+     * Constructs the right-click context menu, optionally for a scenario\n+     */\n+    private void buildRightClickMenu(StratconCoords coords) {\n+        rightClickMenu = new JPopupMenu();\n+        \n+        StratconScenario scenario = getSelectedScenario();\n+        \n+        if (scenario == null) {\n+            menuItemManageForceAssignments = new JMenuItem();\n+            menuItemManageForceAssignments.setText(\"Manage Force Assignments\");\n+            menuItemManageForceAssignments.setActionCommand(RCLICK_COMMAND_MANAGE_FORCES);\n+            menuItemManageForceAssignments.addActionListener(this);\n+            rightClickMenu.add(menuItemManageForceAssignments);\n+        }\n+        \n+        if (scenario != null) {\n+            menuItemManageScenario = new JMenuItem();\n+            menuItemManageScenario.setText(\"Manage Scenario\");\n+            menuItemManageScenario.setActionCommand(RCLICK_COMMAND_MANAGE_SCENARIO);\n+            menuItemManageScenario.addActionListener(this);\n+            rightClickMenu.add(menuItemManageScenario);\n+        }\n+        \n+        if ((currentTrack != null) && currentTrack.getAssignedCoordForces().containsKey(coords)) {\n+            for (int forceID : currentTrack.getAssignedCoordForces().get(coords)) {\n+                String forceName = campaign.getForce(forceID).getName();\n+                \n+                JCheckBoxMenuItem stickyForceItem = new JCheckBoxMenuItem();\n+                stickyForceItem.setText(String.format(\"%s - remain deployed\", forceName));\n+                stickyForceItem.setActionCommand(RCLICK_COMMAND_STICKY_FORCE);\n+                stickyForceItem.putClientProperty(RCLICK_COMMAND_STICKY_FORCE_ID, forceID);\n+                stickyForceItem.addActionListener(this);\n+                stickyForceItem.setSelected(currentTrack.getStickyForces().contains(forceID));\n+                rightClickMenu.add(stickyForceItem);\n+            }\n+        }\n+            \n+        if ((currentTrack != null) && campaign.isGM()) {\n+            rightClickMenu.addSeparator();\n+            \n+            menuItemGMReveal = new JMenuItem();\n+            menuItemGMReveal.setText(currentTrack.isGmRevealed() ? \"Hide Track\" : \"Reveal Track\");\n+            menuItemGMReveal.setActionCommand(RCLICK_COMMAND_REVEAL_TRACK);\n+            menuItemGMReveal.addActionListener(this);\n+            rightClickMenu.add(menuItemGMReveal);\n+        }\n+    }\n+\n+    /**\n+     * Renders the panel, hexes, forces, facilities and all that.\n+     */\n+    @Override\n+    public void paintComponent(Graphics g) {\n+        super.paintComponent(g);\n+        if (campaignState == null || currentTrack == null) {\n+            return;\n+        }\n+        \n+        numIconsInHex.clear();\n+\n+        Graphics2D g2D = (Graphics2D) g;\n+        AffineTransform initialTransform = g2D.getTransform();\n+        performInitialTransform(g2D);\n+        AffineTransform originTransform = g2D.getTransform();\n+\n+        drawHexes(g2D, DrawHexType.Hex);\n+        g2D.setTransform(originTransform);\n+        drawHexes(g2D, DrawHexType.Outline);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawScenarios(g2D);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawFacilities(g2D);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawForces(g2D);\n+\n+        g2D.setTransform(initialTransform);\n+        if (clickedPoint != null) {\n+            g2D.setColor(Color.BLUE);\n+            g2D.drawRect((int) clickedPoint.getX(), (int) clickedPoint.getY(), 2, 2);\n+        }\n+    }\n+\n+    /**\n+     * This method contains a dirty secret hack, but I forget what it is.\n+     * The point of it is to draw all the hexes for the board. \n+     * If it's a \"dry run\", we don't actually draw the hexes, we just pretend to\n+     * until we \"draw\" one that encompasses the clicked point.\n+     * @param g2D - graphics object on which to draw\n+     * @param drawHexType - whether to draw the hex backgrounds, hex outlines or a dry run for click detection\n+     */\n+    private boolean drawHexes(Graphics2D g2D, DrawHexType drawHexType) {\n+        Polygon graphHex = new Polygon();\n+        int xRadius = HEX_X_RADIUS;\n+        int yRadius = HEX_Y_RADIUS;\n+        boolean pointFound = false;\n+\n+        graphHex.addPoint(-xRadius/2, -yRadius);\n+        graphHex.addPoint(-xRadius, 0);\n+        graphHex.addPoint(-xRadius/2, yRadius);\n+        graphHex.addPoint(xRadius/2, yRadius);\n+        graphHex.addPoint(xRadius, 0);\n+        graphHex.addPoint(xRadius/2, -yRadius);\n+\n+        graphHex.translate(xRadius, yRadius);\n+\n+        Point translatedClickedPoint = null;\n+\n+        // this was derived somewhat experimentally\n+        // the clicked point always seems a little off, so we \n+        // a) apply the current transform to it, prior to drawing all the hexes\n+        // b) subtract an additional Y_RADIUS x 2 (Y_DIAMETER)\n+        // this gets us the point within the clicked hex\n+        // it's probably finicky, so any major changes to the rendering mechanism will likely break the detection\n+        if (clickedPoint != null) {\n+            translatedClickedPoint = (Point) clickedPoint.clone();\n+            \n+            // since we have the possibility of scrolling, we need to convert the on-screen clicked coordinates\n+            // to on-board coordinates. Thankfully, SwingUtilities provides the main computational ability for that\n+            Point actualPanelPoint = SwingUtilities.convertPoint(this, translatedClickedPoint, this.getParent());\n+            translatedClickedPoint.translate((int) -(actualPanelPoint.getX() - translatedClickedPoint.getX()), \n+                                                (int) -(actualPanelPoint.getY() - translatedClickedPoint.getY()));\n+            \n+            // now we translate to the starting point of where we're drawing and then go down a hex\n+            translatedClickedPoint.translate((int) g2D.getTransform().getTranslateX(), (int) g2D.getTransform().getTranslateY());\n+            translatedClickedPoint.translate(0, -(HEX_Y_RADIUS * 2));\n+        }\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                if(drawHexType == DrawHexType.Outline) {\n+                    g2D.setColor(new Color(0, 0, 0));\n+                    g2D.drawPolygon(graphHex);                    \n+                } else if (drawHexType == DrawHexType.Hex) {\n+                    \n+                    if (currentTrack.coordsRevealed(x, y) || currentTrack.isGmRevealed()) {\n+                        g2D.setColor(Color.LIGHT_GRAY);\n+                    } else {\n+                        g2D.setColor(Color.DARK_GRAY);\n+                    }\n+                    g2D.fillPolygon(graphHex);\n+                    \n+                    if (translatedClickedPoint != null && graphHex.contains(translatedClickedPoint)) {\n+                        g2D.setColor(Color.WHITE);\n+                        BasicStroke s = new BasicStroke((float) 8.0);\n+                        Stroke push = g2D.getStroke();\n+                        g2D.setStroke(s);\n+                        g2D.drawPolygon(graphHex);\n+                        \n+                        boardState.selectedX = x;\n+                        boardState.selectedY = y;\n+                        pointFound = true;\n+                        g2D.setStroke(push);\n+                    }\n+                } else if (drawHexType == DrawHexType.Dryrun) {\n+                    if (translatedClickedPoint != null && graphHex.contains(translatedClickedPoint)) {\n+                        boardState.selectedX = x;\n+                        boardState.selectedY = y;\n+                        pointFound = true;\n+                    }\n+                }\n+\n+                if (drawHexType == DrawHexType.Hex) {\n+                    g2D.setColor(Color.GREEN);\n+                    g2D.drawString(x + \",\" + y, graphHex.xpoints[0] + (xRadius / 4), graphHex.ypoints[0] + yRadius);\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                graphHex.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            graphHex.translate(translationVector[0], translationVector[1]);\n+        }\n+\n+        return pointFound;\n+    }\n+\n+    /**\n+     * Worker function to render icons representing scenarios to the given surface.\n+     */\n+    private void drawScenarios(Graphics2D g2D) {\n+        Polygon scenarioMarker = new Polygon();\n+        int xRadius = HEX_X_RADIUS / 3;\n+        int yRadius = HEX_Y_RADIUS / 3;\n+\n+        scenarioMarker.addPoint(-xRadius, -yRadius);\n+        scenarioMarker.addPoint(-xRadius, yRadius);\n+        scenarioMarker.addPoint(xRadius, yRadius);\n+        scenarioMarker.addPoint(xRadius, -yRadius);\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                StratconCoords currentCoords = new StratconCoords(x, y);\n+                StratconScenario scenario = currentTrack.getScenario(currentCoords);\n+                \n+                // if there's a scenario here that has a deployment/battle date\n+                // or if there's a scenario here and we've gm-revealed everything\n+                if ((scenario != null) &&\n+                        ((scenario.getDeploymentDate() != null) || currentTrack.isGmRevealed())) {\n+                    g2D.setColor(Color.RED);\n+                    g2D.drawPolygon(scenarioMarker);\n+                    if(currentTrack.getFacility(currentCoords) == null) {\n+                        drawTextEffect(g2D, scenarioMarker, \"Hostile Force Detected\", currentCoords);\n+                    }\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                scenarioMarker.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            scenarioMarker.translate(translationVector[0], translationVector[1]);\n+        }\n+    }\n+    \n+    /**\n+     * Worker function to render facility icons to the given surface.\n+     */\n+    private void drawFacilities(Graphics2D g2D) {\n+        Polygon facilityMarker = new Polygon();\n+        int xRadius = HEX_X_RADIUS / 3;\n+        int yRadius = HEX_Y_RADIUS / 3;\n+\n+        facilityMarker.addPoint(-xRadius, -yRadius);\n+        facilityMarker.addPoint(-xRadius, yRadius);\n+        facilityMarker.addPoint(xRadius, yRadius);\n+        facilityMarker.addPoint(xRadius, -yRadius);\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                StratconCoords currentCoords = new StratconCoords(x, y);\n+                StratconFacility facility = currentTrack.getFacility(currentCoords);\n+                \n+                if ((facility != null) && (facility.isVisible() || currentTrack.isGmRevealed())) {\n+                    g2D.setColor(facility.getOwner() == ForceAlignment.Allied ? Color.GREEN : Color.RED);\n+                    g2D.drawPolygon(facilityMarker);\n+                    drawTextEffect(g2D, facilityMarker, facility.getFormattedDisplayableName(), currentCoords);\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                facilityMarker.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            facilityMarker.translate(translationVector[0], translationVector[1]);\n+        }\n+    }\n+    \n+    /**\n+     * Worker function to render force icons to the given surface.\n+     */\n+    private void drawForces(Graphics2D g2D) {\n+        Polygon forceMarker = new Polygon();\n+        int xRadius = HEX_X_RADIUS / 3;\n+        int yRadius = HEX_Y_RADIUS / 3;\n+\n+        forceMarker.addPoint(-xRadius, -yRadius);\n+        forceMarker.addPoint(-xRadius, yRadius);\n+        forceMarker.addPoint(xRadius, yRadius);\n+        forceMarker.addPoint(xRadius, -yRadius);\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                StratconCoords currentCoords = new StratconCoords(x, y);\n+                \n+                if (currentTrack.getAssignedCoordForces().containsKey(currentCoords)) {\n+                    for (int forceID : currentTrack.getAssignedCoordForces().get(currentCoords)) {                   \n+                        g2D.setColor(Color.BLUE);\n+                        g2D.drawPolygon(forceMarker);\n+                        drawTextEffect(g2D, forceMarker, campaign.getForce(forceID).getName(), currentCoords);\n+                    }\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                forceMarker.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            forceMarker.translate(translationVector[0], translationVector[1]);\n+        }\n+    }\n+    \n+    /**\n+     * Draws some text and line to it from a given polygon. \n+     * Smart enough not to layer multiple strings on top of each other if they're all drawn in the same hex.\n+     */\n+    private void drawTextEffect(Graphics2D g2D, Polygon marker, String text, StratconCoords coords) {\n+        int verticalOffsetIndex = numIconsInHex.containsKey(coords) ? numIconsInHex.get(coords) : 0;\n+        \n+        double startX = marker.getBounds().getMaxX();\n+        double startY = marker.getBounds().getMinY();\n+        double midPointX = startX + HEX_X_RADIUS / 4;\n+        double midPointY = startY - HEX_Y_RADIUS / 4 + g2D.getFontMetrics().getHeight() * verticalOffsetIndex;\n+        double endPointX = midPointX + HEX_X_RADIUS / 2;\n+        \n+        g2D.drawLine((int) startX, (int) startY, (int) midPointX, (int) midPointY);\n+        g2D.drawLine((int) midPointX, (int) midPointY, (int) endPointX, (int) midPointY);\n+        g2D.drawString(text, (int) endPointX, (int) midPointY);\n+        \n+        // register that we drew text off of this hex\n+        verticalOffsetIndex++;\n+        numIconsInHex.put(coords, verticalOffsetIndex);\n+    }\n+\n+    /**\n+     * Returns the translation that we need to make to render the \"next downward\" hex.\n+     * @return Two dimensional array with the first element being the x vector and the second being the y vector\n+     */\n+    private int[] getDownwardYVector() {\n+        return new int[] { 0, (int) (HEX_Y_RADIUS * 2) };\n+    }\n+\n+    /**\n+     * Returns the translation that we need to make to move from the bottom of a column to the top of the next\n+     * column to the right.\n+     * @param evenColumn Whether the column we're currently in is odd or even\n+     * @return Two dimensional array with the first element being the x vector and the second being the y vector\n+     */\n+    private int[] getRightAndUPVector(boolean evenColumn) {\n+        int yRadius = (int) (HEX_Y_RADIUS);\n+        int xRadius = (int) (HEX_X_RADIUS);\n+\n+        int yTranslation = currentTrack.getHeight() * yRadius * 2;\n+        if (evenColumn) {\n+            yTranslation += yRadius;\n+        } else {\n+            yTranslation -= yRadius;\n+        }\n+\n+        return new int[] {(int) (xRadius * 1.5), -yTranslation};\n+    }\n+\n+    /**\n+     * Go to the origin of the hex board and reset the scaling.\n+     */\n+    private void performInitialTransform(Graphics2D g2D) {\n+        g2D.translate(0, 0 + HEX_Y_RADIUS);\n+        g2D.scale(scale, scale);\n+    }\n+\n+    /** \n+     * Worker function that takes the current clicked point and a graphics 2D object\n+     * and detects which hex was clicked by doing a dry run hex render.\n+     * \n+     * Dependent upon clickedPoint being set and having an active graphics object for this class.\n+     * \n+     * Side effects: the dry run sets the boardState clicked hex coordinates.\n+     * @return Whether or not the clicked point was found on the hex board\n+     */\n+    private boolean detectClickedHex() {\n+        Graphics2D g2D = (Graphics2D) getGraphics();\n+        AffineTransform transform = g2D.getTransform();\n+        performInitialTransform(g2D);\n+        boolean pointFoundOnBoard = drawHexes(g2D, DrawHexType.Dryrun);\n+        g2D.setTransform(transform);\n+\n+        return pointFoundOnBoard;\n+    }\n+\n+    /**\n+     * Event handler for when a mouse button is released.\n+     */\n+    public void mouseReleasedHandler(MouseEvent e) {\n+        if(e.getSource() != this) {\n+            return;\n+        }\n+\n+        // left button generally selects a hex\n+        if (e.getButton() == MouseEvent.BUTTON1) {        \n+            clickedPoint = e.getPoint();\n+            boolean pointFoundOnBoard = detectClickedHex();\n+            \n+            if(pointFoundOnBoard) {\n+                infoArea.setText(buildSelectedHexInfo());\n+            }\n+\n+            repaint();\n+        // right button generally pops up a context menu\n+        } else if (e.getButton() == MouseEvent.BUTTON3) {\n+            clickedPoint = e.getPoint();\n+            detectClickedHex();\n+            \n+            StratconCoords selectedCoords = boardState.getSelectedCoords();\n+            if (selectedCoords == null) {\n+                return;\n+            }\n+            \n+            repaint();\n+            buildRightClickMenu(selectedCoords);\n+            rightClickMenu.show(this, e.getX(), e.getY());\n+        }\n+    }\n+    \n+    public StratconScenario getSelectedScenario() {\n+        return currentTrack.getScenario(boardState.getSelectedCoords());\n+    }\n+    \n+    /**\n+     * Worker function that outputs html representing the status of a selected hex,\n+     * containing info such as whether it's been revealed, assigned forces, scenarios, facilities, etc.\n+     */\n+    private String buildSelectedHexInfo() {\n+        StringBuilder infoBuilder = new StringBuilder();\n+        infoBuilder.append(\"<html><br/>\");\n+        \n+        boolean coordsRevealed = currentTrack.getRevealedCoords().contains(boardState.getSelectedCoords());\n+        if (coordsRevealed) {\n+            infoBuilder.append(\"<span color='green'>Recon complete</span><br/>\");\n+        }\n+        \n+        if (currentTrack.getAssignedCoordForces().containsKey(boardState.getSelectedCoords())) {\n+            for (int forceID : currentTrack.getAssignedCoordForces().get(boardState.getSelectedCoords())) {\n+                Force force = campaign.getForce(forceID);\n+                infoBuilder.append(force.getName()).append(\" assigned\");\n+                \n+                if (currentTrack.getStickyForces().contains(forceID)) {\n+                    infoBuilder.append(\" - remain deployed\");\n+                }\n+                \n+                infoBuilder.append(\"<br/>\");\n+                \n+                infoBuilder.append(\"Returns on \").append(currentTrack.getAssignedForceReturnDates().get(forceID));\n+                infoBuilder.append(\"<br/>\");\n+            }\n+        }\n+        \n+        if (coordsRevealed || currentTrack.isGmRevealed()) {\n+            StratconFacility facility = currentTrack.getFacility(boardState.getSelectedCoords());\n+            \n+            if((facility != null) && (facility.getFacilityType() != null)) {\n+                if (facility.isStrategicObjective()) {\n+                    infoBuilder.append(String.format(\"<br/><span color='%s'>Contract objective located</span>\", \n+                            facility.getOwner() == ForceAlignment.Allied ? \"green\" : \"red\"));\n+                }\n+                infoBuilder.append((facility.getOwner() == ForceAlignment.Allied) ? \"<span color='green'>\" : \"<span color='red'>\");\n+                infoBuilder.append(\"<br/>\");\n+                infoBuilder.append(facility.getFormattedDisplayableName());\n+                infoBuilder.append(\"<span>\");\n+            }\n+            \n+        } else {\n+            infoBuilder.append(\"<span color='red'>Recon incomplete</span>\");\n+        }\n+        infoBuilder.append(\"<br/>\");\n+        \n+        \n+        StratconScenario selectedScenario = getSelectedScenario();\n+        if ((selectedScenario != null) &&\n+                ((selectedScenario.getDeploymentDate() != null) || currentTrack.isGmRevealed())) {\n+            infoBuilder.append(selectedScenario.getInfo());\n+        }\n+        \n+        infoBuilder.append(\"</html>\");\n+        \n+        return infoBuilder.toString();\n+    }\n+\n+    /**\n+     * Data structure containing current state of the board.\n+     */\n+    private static class BoardState {\n+        public Integer selectedX;\n+        public Integer selectedY;\n+        \n+        public StratconCoords getSelectedCoords() {\n+            if((selectedX == null) || (selectedY == null)) {\n+                return null;\n+            } else {\n+                return new StratconCoords(selectedX, selectedY);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Event handler for various button and menu item presses.\n+     */\n+    @Override\n+    public void actionPerformed(ActionEvent e) {\n+        StratconCoords selectedCoords = boardState.getSelectedCoords();\n+        if(selectedCoords == null) {\n+            return;\n+        }\n+        \n+        switch(e.getActionCommand()) {", "originalCommit": "796b6728fd3cd2aea02d17122b4d735afc47dc41", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjkwMjY1Ng==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r602902656", "bodyText": "Merge lines a bit", "author": "Windchild292", "createdAt": "2021-03-28T16:52:05Z", "path": "MekHQ/src/mekhq/gui/StratconPanel.java", "diffHunk": "@@ -0,0 +1,672 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.gui;\n+\n+import java.awt.BasicStroke;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Point;\n+import java.awt.Polygon;\n+import java.awt.Stroke;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.awt.geom.AffineTransform;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import javax.swing.JCheckBoxMenuItem;\n+import javax.swing.JLabel;\n+import javax.swing.JMenuItem;\n+import javax.swing.JPanel;\n+import javax.swing.JPopupMenu;\n+import javax.swing.SwingUtilities;\n+\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.stratcon.StratconCampaignState;\n+import mekhq.campaign.stratcon.StratconCoords;\n+import mekhq.campaign.stratcon.StratconFacility;\n+import mekhq.campaign.stratcon.StratconScenario;\n+import mekhq.campaign.stratcon.StratconTrackState;\n+import mekhq.gui.stratcon.StratconScenarioWizard;\n+import mekhq.gui.stratcon.TrackForceAssignmentUI;\n+\n+/**\n+ * This panel handles AtB-Stratcon GUI interactions with a specific scenario track.\n+ * @author NickAragua\n+ */\n+public class StratconPanel extends JPanel implements ActionListener {\n+    /**\n+     * \n+     */\n+    private static final long serialVersionUID = 7405934788894417292L;\n+    \n+    public static final int HEX_X_RADIUS = 42;\n+    public static final int HEX_Y_RADIUS = 37;\n+    \n+    private static final String RCLICK_COMMAND_MANAGE_FORCES = \"ManageForces\";\n+    private static final String RCLICK_COMMAND_MANAGE_SCENARIO = \"ManageScenario\";\n+    private static final String RCLICK_COMMAND_REVEAL_TRACK = \"RevealTrack\";\n+    private static final String RCLICK_COMMAND_STICKY_FORCE = \"StickyForce\";\n+    private static final String RCLICK_COMMAND_STICKY_FORCE_ID = \"StickyForceID\";\n+\n+    /**\n+     * What to do when drawing a hex\n+     */\n+    private enum DrawHexType {\n+        /**\n+         * The interior of a hex\n+         */\n+        Hex,\n+        \n+        /**\n+         * The outline of a hex\n+         */\n+        Outline,\n+        \n+        /**\n+         * Pretend we're drawing a hex, but don't actually do it, useful for \n+         * figuring out which hex a mouse click landed in, etc.\n+         */\n+        Dryrun\n+    }\n+\n+    private float scale = 1f;\n+\n+    private StratconTrackState currentTrack;\n+    private StratconCampaignState campaignState;\n+    private Campaign campaign;\n+\n+    private BoardState boardState = new BoardState();\n+\n+    private Point clickedPoint;\n+    private JPopupMenu rightClickMenu;\n+    private JMenuItem menuItemManageForceAssignments;\n+    private JMenuItem menuItemManageScenario;\n+    private JMenuItem menuItemGMReveal;\n+    \n+    // data structure holding how many unit/scenario/base icons have been drawn in the hex\n+    // used to control how low the text description goes.\n+    private Map<StratconCoords, Integer> numIconsInHex = new HashMap<>();\n+    \n+    private StratconScenarioWizard scenarioWizard;\n+    private TrackForceAssignmentUI assignmentUI;\n+    \n+    private JLabel infoArea;\n+\n+    /**\n+     * Constructs a StratconPanel instance, given a parent campaign GUI and a pointer to an info area.\n+     */\n+    StratconPanel(CampaignGUI gui, JLabel infoArea) {\n+        campaign = gui.getCampaign();\n+        scenarioWizard = new StratconScenarioWizard(campaign);\n+        this.infoArea = infoArea;\n+        \n+        assignmentUI = new TrackForceAssignmentUI(this);\n+        assignmentUI.setVisible(false);\n+        \n+        addMouseListener(new MouseAdapter() {\n+            @Override\n+            public void mouseReleased(MouseEvent e) {\n+                mouseReleasedHandler(e);\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Handler for when a specific track is selected - switches rendering to that track.\n+     */\n+    public void selectTrack(StratconCampaignState campaignState, StratconTrackState track) {\n+        this.campaignState = campaignState;\n+        currentTrack = track;\n+        repaint();\n+    }\n+    \n+    /**\n+     * Constructs the right-click context menu, optionally for a scenario\n+     */\n+    private void buildRightClickMenu(StratconCoords coords) {\n+        rightClickMenu = new JPopupMenu();\n+        \n+        StratconScenario scenario = getSelectedScenario();\n+        \n+        if (scenario == null) {\n+            menuItemManageForceAssignments = new JMenuItem();\n+            menuItemManageForceAssignments.setText(\"Manage Force Assignments\");\n+            menuItemManageForceAssignments.setActionCommand(RCLICK_COMMAND_MANAGE_FORCES);\n+            menuItemManageForceAssignments.addActionListener(this);\n+            rightClickMenu.add(menuItemManageForceAssignments);\n+        }\n+        \n+        if (scenario != null) {\n+            menuItemManageScenario = new JMenuItem();\n+            menuItemManageScenario.setText(\"Manage Scenario\");\n+            menuItemManageScenario.setActionCommand(RCLICK_COMMAND_MANAGE_SCENARIO);\n+            menuItemManageScenario.addActionListener(this);\n+            rightClickMenu.add(menuItemManageScenario);\n+        }\n+        \n+        if ((currentTrack != null) && currentTrack.getAssignedCoordForces().containsKey(coords)) {\n+            for (int forceID : currentTrack.getAssignedCoordForces().get(coords)) {\n+                String forceName = campaign.getForce(forceID).getName();\n+                \n+                JCheckBoxMenuItem stickyForceItem = new JCheckBoxMenuItem();\n+                stickyForceItem.setText(String.format(\"%s - remain deployed\", forceName));\n+                stickyForceItem.setActionCommand(RCLICK_COMMAND_STICKY_FORCE);\n+                stickyForceItem.putClientProperty(RCLICK_COMMAND_STICKY_FORCE_ID, forceID);\n+                stickyForceItem.addActionListener(this);\n+                stickyForceItem.setSelected(currentTrack.getStickyForces().contains(forceID));\n+                rightClickMenu.add(stickyForceItem);\n+            }\n+        }\n+            \n+        if ((currentTrack != null) && campaign.isGM()) {\n+            rightClickMenu.addSeparator();\n+            \n+            menuItemGMReveal = new JMenuItem();\n+            menuItemGMReveal.setText(currentTrack.isGmRevealed() ? \"Hide Track\" : \"Reveal Track\");\n+            menuItemGMReveal.setActionCommand(RCLICK_COMMAND_REVEAL_TRACK);\n+            menuItemGMReveal.addActionListener(this);\n+            rightClickMenu.add(menuItemGMReveal);\n+        }\n+    }\n+\n+    /**\n+     * Renders the panel, hexes, forces, facilities and all that.\n+     */\n+    @Override\n+    public void paintComponent(Graphics g) {\n+        super.paintComponent(g);\n+        if (campaignState == null || currentTrack == null) {\n+            return;\n+        }\n+        \n+        numIconsInHex.clear();\n+\n+        Graphics2D g2D = (Graphics2D) g;\n+        AffineTransform initialTransform = g2D.getTransform();\n+        performInitialTransform(g2D);\n+        AffineTransform originTransform = g2D.getTransform();\n+\n+        drawHexes(g2D, DrawHexType.Hex);\n+        g2D.setTransform(originTransform);\n+        drawHexes(g2D, DrawHexType.Outline);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawScenarios(g2D);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawFacilities(g2D);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawForces(g2D);\n+\n+        g2D.setTransform(initialTransform);\n+        if (clickedPoint != null) {\n+            g2D.setColor(Color.BLUE);\n+            g2D.drawRect((int) clickedPoint.getX(), (int) clickedPoint.getY(), 2, 2);\n+        }\n+    }\n+\n+    /**\n+     * This method contains a dirty secret hack, but I forget what it is.\n+     * The point of it is to draw all the hexes for the board. \n+     * If it's a \"dry run\", we don't actually draw the hexes, we just pretend to\n+     * until we \"draw\" one that encompasses the clicked point.\n+     * @param g2D - graphics object on which to draw\n+     * @param drawHexType - whether to draw the hex backgrounds, hex outlines or a dry run for click detection\n+     */\n+    private boolean drawHexes(Graphics2D g2D, DrawHexType drawHexType) {\n+        Polygon graphHex = new Polygon();\n+        int xRadius = HEX_X_RADIUS;\n+        int yRadius = HEX_Y_RADIUS;\n+        boolean pointFound = false;\n+\n+        graphHex.addPoint(-xRadius/2, -yRadius);\n+        graphHex.addPoint(-xRadius, 0);\n+        graphHex.addPoint(-xRadius/2, yRadius);\n+        graphHex.addPoint(xRadius/2, yRadius);\n+        graphHex.addPoint(xRadius, 0);\n+        graphHex.addPoint(xRadius/2, -yRadius);\n+\n+        graphHex.translate(xRadius, yRadius);\n+\n+        Point translatedClickedPoint = null;\n+\n+        // this was derived somewhat experimentally\n+        // the clicked point always seems a little off, so we \n+        // a) apply the current transform to it, prior to drawing all the hexes\n+        // b) subtract an additional Y_RADIUS x 2 (Y_DIAMETER)\n+        // this gets us the point within the clicked hex\n+        // it's probably finicky, so any major changes to the rendering mechanism will likely break the detection\n+        if (clickedPoint != null) {\n+            translatedClickedPoint = (Point) clickedPoint.clone();\n+            \n+            // since we have the possibility of scrolling, we need to convert the on-screen clicked coordinates\n+            // to on-board coordinates. Thankfully, SwingUtilities provides the main computational ability for that\n+            Point actualPanelPoint = SwingUtilities.convertPoint(this, translatedClickedPoint, this.getParent());\n+            translatedClickedPoint.translate((int) -(actualPanelPoint.getX() - translatedClickedPoint.getX()), \n+                                                (int) -(actualPanelPoint.getY() - translatedClickedPoint.getY()));\n+            \n+            // now we translate to the starting point of where we're drawing and then go down a hex\n+            translatedClickedPoint.translate((int) g2D.getTransform().getTranslateX(), (int) g2D.getTransform().getTranslateY());\n+            translatedClickedPoint.translate(0, -(HEX_Y_RADIUS * 2));\n+        }\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                if(drawHexType == DrawHexType.Outline) {\n+                    g2D.setColor(new Color(0, 0, 0));\n+                    g2D.drawPolygon(graphHex);                    \n+                } else if (drawHexType == DrawHexType.Hex) {\n+                    \n+                    if (currentTrack.coordsRevealed(x, y) || currentTrack.isGmRevealed()) {\n+                        g2D.setColor(Color.LIGHT_GRAY);\n+                    } else {\n+                        g2D.setColor(Color.DARK_GRAY);\n+                    }\n+                    g2D.fillPolygon(graphHex);\n+                    \n+                    if (translatedClickedPoint != null && graphHex.contains(translatedClickedPoint)) {\n+                        g2D.setColor(Color.WHITE);\n+                        BasicStroke s = new BasicStroke((float) 8.0);\n+                        Stroke push = g2D.getStroke();\n+                        g2D.setStroke(s);\n+                        g2D.drawPolygon(graphHex);\n+                        \n+                        boardState.selectedX = x;\n+                        boardState.selectedY = y;\n+                        pointFound = true;\n+                        g2D.setStroke(push);\n+                    }\n+                } else if (drawHexType == DrawHexType.Dryrun) {\n+                    if (translatedClickedPoint != null && graphHex.contains(translatedClickedPoint)) {\n+                        boardState.selectedX = x;\n+                        boardState.selectedY = y;\n+                        pointFound = true;\n+                    }\n+                }\n+\n+                if (drawHexType == DrawHexType.Hex) {\n+                    g2D.setColor(Color.GREEN);\n+                    g2D.drawString(x + \",\" + y, graphHex.xpoints[0] + (xRadius / 4), graphHex.ypoints[0] + yRadius);\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                graphHex.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            graphHex.translate(translationVector[0], translationVector[1]);\n+        }\n+\n+        return pointFound;\n+    }\n+\n+    /**\n+     * Worker function to render icons representing scenarios to the given surface.\n+     */\n+    private void drawScenarios(Graphics2D g2D) {\n+        Polygon scenarioMarker = new Polygon();\n+        int xRadius = HEX_X_RADIUS / 3;\n+        int yRadius = HEX_Y_RADIUS / 3;\n+\n+        scenarioMarker.addPoint(-xRadius, -yRadius);\n+        scenarioMarker.addPoint(-xRadius, yRadius);\n+        scenarioMarker.addPoint(xRadius, yRadius);\n+        scenarioMarker.addPoint(xRadius, -yRadius);\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                StratconCoords currentCoords = new StratconCoords(x, y);\n+                StratconScenario scenario = currentTrack.getScenario(currentCoords);\n+                \n+                // if there's a scenario here that has a deployment/battle date\n+                // or if there's a scenario here and we've gm-revealed everything\n+                if ((scenario != null) &&\n+                        ((scenario.getDeploymentDate() != null) || currentTrack.isGmRevealed())) {\n+                    g2D.setColor(Color.RED);\n+                    g2D.drawPolygon(scenarioMarker);\n+                    if(currentTrack.getFacility(currentCoords) == null) {\n+                        drawTextEffect(g2D, scenarioMarker, \"Hostile Force Detected\", currentCoords);\n+                    }\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                scenarioMarker.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            scenarioMarker.translate(translationVector[0], translationVector[1]);\n+        }\n+    }\n+    \n+    /**\n+     * Worker function to render facility icons to the given surface.\n+     */\n+    private void drawFacilities(Graphics2D g2D) {\n+        Polygon facilityMarker = new Polygon();\n+        int xRadius = HEX_X_RADIUS / 3;\n+        int yRadius = HEX_Y_RADIUS / 3;\n+\n+        facilityMarker.addPoint(-xRadius, -yRadius);\n+        facilityMarker.addPoint(-xRadius, yRadius);\n+        facilityMarker.addPoint(xRadius, yRadius);\n+        facilityMarker.addPoint(xRadius, -yRadius);\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                StratconCoords currentCoords = new StratconCoords(x, y);\n+                StratconFacility facility = currentTrack.getFacility(currentCoords);\n+                \n+                if ((facility != null) && (facility.isVisible() || currentTrack.isGmRevealed())) {\n+                    g2D.setColor(facility.getOwner() == ForceAlignment.Allied ? Color.GREEN : Color.RED);\n+                    g2D.drawPolygon(facilityMarker);\n+                    drawTextEffect(g2D, facilityMarker, facility.getFormattedDisplayableName(), currentCoords);\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                facilityMarker.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            facilityMarker.translate(translationVector[0], translationVector[1]);\n+        }\n+    }\n+    \n+    /**\n+     * Worker function to render force icons to the given surface.\n+     */\n+    private void drawForces(Graphics2D g2D) {\n+        Polygon forceMarker = new Polygon();\n+        int xRadius = HEX_X_RADIUS / 3;\n+        int yRadius = HEX_Y_RADIUS / 3;\n+\n+        forceMarker.addPoint(-xRadius, -yRadius);\n+        forceMarker.addPoint(-xRadius, yRadius);\n+        forceMarker.addPoint(xRadius, yRadius);\n+        forceMarker.addPoint(xRadius, -yRadius);\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                StratconCoords currentCoords = new StratconCoords(x, y);\n+                \n+                if (currentTrack.getAssignedCoordForces().containsKey(currentCoords)) {\n+                    for (int forceID : currentTrack.getAssignedCoordForces().get(currentCoords)) {                   \n+                        g2D.setColor(Color.BLUE);\n+                        g2D.drawPolygon(forceMarker);\n+                        drawTextEffect(g2D, forceMarker, campaign.getForce(forceID).getName(), currentCoords);\n+                    }\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                forceMarker.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            forceMarker.translate(translationVector[0], translationVector[1]);\n+        }\n+    }\n+    \n+    /**\n+     * Draws some text and line to it from a given polygon. \n+     * Smart enough not to layer multiple strings on top of each other if they're all drawn in the same hex.\n+     */\n+    private void drawTextEffect(Graphics2D g2D, Polygon marker, String text, StratconCoords coords) {\n+        int verticalOffsetIndex = numIconsInHex.containsKey(coords) ? numIconsInHex.get(coords) : 0;\n+        \n+        double startX = marker.getBounds().getMaxX();\n+        double startY = marker.getBounds().getMinY();\n+        double midPointX = startX + HEX_X_RADIUS / 4;\n+        double midPointY = startY - HEX_Y_RADIUS / 4 + g2D.getFontMetrics().getHeight() * verticalOffsetIndex;\n+        double endPointX = midPointX + HEX_X_RADIUS / 2;\n+        \n+        g2D.drawLine((int) startX, (int) startY, (int) midPointX, (int) midPointY);\n+        g2D.drawLine((int) midPointX, (int) midPointY, (int) endPointX, (int) midPointY);\n+        g2D.drawString(text, (int) endPointX, (int) midPointY);\n+        \n+        // register that we drew text off of this hex\n+        verticalOffsetIndex++;\n+        numIconsInHex.put(coords, verticalOffsetIndex);\n+    }\n+\n+    /**\n+     * Returns the translation that we need to make to render the \"next downward\" hex.\n+     * @return Two dimensional array with the first element being the x vector and the second being the y vector\n+     */\n+    private int[] getDownwardYVector() {\n+        return new int[] { 0, (int) (HEX_Y_RADIUS * 2) };\n+    }\n+\n+    /**\n+     * Returns the translation that we need to make to move from the bottom of a column to the top of the next\n+     * column to the right.\n+     * @param evenColumn Whether the column we're currently in is odd or even\n+     * @return Two dimensional array with the first element being the x vector and the second being the y vector\n+     */\n+    private int[] getRightAndUPVector(boolean evenColumn) {\n+        int yRadius = (int) (HEX_Y_RADIUS);\n+        int xRadius = (int) (HEX_X_RADIUS);\n+\n+        int yTranslation = currentTrack.getHeight() * yRadius * 2;\n+        if (evenColumn) {\n+            yTranslation += yRadius;\n+        } else {\n+            yTranslation -= yRadius;\n+        }\n+\n+        return new int[] {(int) (xRadius * 1.5), -yTranslation};\n+    }\n+\n+    /**\n+     * Go to the origin of the hex board and reset the scaling.\n+     */\n+    private void performInitialTransform(Graphics2D g2D) {\n+        g2D.translate(0, 0 + HEX_Y_RADIUS);\n+        g2D.scale(scale, scale);\n+    }\n+\n+    /** \n+     * Worker function that takes the current clicked point and a graphics 2D object\n+     * and detects which hex was clicked by doing a dry run hex render.\n+     * \n+     * Dependent upon clickedPoint being set and having an active graphics object for this class.\n+     * \n+     * Side effects: the dry run sets the boardState clicked hex coordinates.\n+     * @return Whether or not the clicked point was found on the hex board\n+     */\n+    private boolean detectClickedHex() {\n+        Graphics2D g2D = (Graphics2D) getGraphics();\n+        AffineTransform transform = g2D.getTransform();\n+        performInitialTransform(g2D);\n+        boolean pointFoundOnBoard = drawHexes(g2D, DrawHexType.Dryrun);\n+        g2D.setTransform(transform);\n+\n+        return pointFoundOnBoard;\n+    }\n+\n+    /**\n+     * Event handler for when a mouse button is released.\n+     */\n+    public void mouseReleasedHandler(MouseEvent e) {\n+        if(e.getSource() != this) {\n+            return;\n+        }\n+\n+        // left button generally selects a hex\n+        if (e.getButton() == MouseEvent.BUTTON1) {        \n+            clickedPoint = e.getPoint();\n+            boolean pointFoundOnBoard = detectClickedHex();\n+            \n+            if(pointFoundOnBoard) {\n+                infoArea.setText(buildSelectedHexInfo());\n+            }\n+\n+            repaint();\n+        // right button generally pops up a context menu\n+        } else if (e.getButton() == MouseEvent.BUTTON3) {\n+            clickedPoint = e.getPoint();\n+            detectClickedHex();\n+            \n+            StratconCoords selectedCoords = boardState.getSelectedCoords();\n+            if (selectedCoords == null) {\n+                return;\n+            }\n+            \n+            repaint();\n+            buildRightClickMenu(selectedCoords);\n+            rightClickMenu.show(this, e.getX(), e.getY());\n+        }\n+    }\n+    \n+    public StratconScenario getSelectedScenario() {\n+        return currentTrack.getScenario(boardState.getSelectedCoords());\n+    }\n+    \n+    /**\n+     * Worker function that outputs html representing the status of a selected hex,\n+     * containing info such as whether it's been revealed, assigned forces, scenarios, facilities, etc.\n+     */\n+    private String buildSelectedHexInfo() {\n+        StringBuilder infoBuilder = new StringBuilder();\n+        infoBuilder.append(\"<html><br/>\");\n+        \n+        boolean coordsRevealed = currentTrack.getRevealedCoords().contains(boardState.getSelectedCoords());\n+        if (coordsRevealed) {\n+            infoBuilder.append(\"<span color='green'>Recon complete</span><br/>\");\n+        }\n+        \n+        if (currentTrack.getAssignedCoordForces().containsKey(boardState.getSelectedCoords())) {\n+            for (int forceID : currentTrack.getAssignedCoordForces().get(boardState.getSelectedCoords())) {\n+                Force force = campaign.getForce(forceID);\n+                infoBuilder.append(force.getName()).append(\" assigned\");\n+                \n+                if (currentTrack.getStickyForces().contains(forceID)) {\n+                    infoBuilder.append(\" - remain deployed\");\n+                }\n+                \n+                infoBuilder.append(\"<br/>\");\n+                \n+                infoBuilder.append(\"Returns on \").append(currentTrack.getAssignedForceReturnDates().get(forceID));\n+                infoBuilder.append(\"<br/>\");\n+            }\n+        }\n+        \n+        if (coordsRevealed || currentTrack.isGmRevealed()) {\n+            StratconFacility facility = currentTrack.getFacility(boardState.getSelectedCoords());\n+            \n+            if((facility != null) && (facility.getFacilityType() != null)) {\n+                if (facility.isStrategicObjective()) {\n+                    infoBuilder.append(String.format(\"<br/><span color='%s'>Contract objective located</span>\", \n+                            facility.getOwner() == ForceAlignment.Allied ? \"green\" : \"red\"));\n+                }\n+                infoBuilder.append((facility.getOwner() == ForceAlignment.Allied) ? \"<span color='green'>\" : \"<span color='red'>\");\n+                infoBuilder.append(\"<br/>\");\n+                infoBuilder.append(facility.getFormattedDisplayableName());\n+                infoBuilder.append(\"<span>\");\n+            }\n+            \n+        } else {\n+            infoBuilder.append(\"<span color='red'>Recon incomplete</span>\");\n+        }\n+        infoBuilder.append(\"<br/>\");\n+        \n+        \n+        StratconScenario selectedScenario = getSelectedScenario();\n+        if ((selectedScenario != null) &&\n+                ((selectedScenario.getDeploymentDate() != null) || currentTrack.isGmRevealed())) {\n+            infoBuilder.append(selectedScenario.getInfo());\n+        }\n+        \n+        infoBuilder.append(\"</html>\");\n+        \n+        return infoBuilder.toString();\n+    }\n+\n+    /**\n+     * Data structure containing current state of the board.\n+     */\n+    private static class BoardState {\n+        public Integer selectedX;\n+        public Integer selectedY;\n+        \n+        public StratconCoords getSelectedCoords() {\n+            if((selectedX == null) || (selectedY == null)) {\n+                return null;\n+            } else {\n+                return new StratconCoords(selectedX, selectedY);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Event handler for various button and menu item presses.\n+     */\n+    @Override\n+    public void actionPerformed(ActionEvent e) {\n+        StratconCoords selectedCoords = boardState.getSelectedCoords();\n+        if(selectedCoords == null) {\n+            return;\n+        }\n+        \n+        switch(e.getActionCommand()) {\n+        case RCLICK_COMMAND_MANAGE_FORCES:\n+            assignmentUI.display(campaign, campaignState, 0, selectedCoords);\n+            assignmentUI.setVisible(true);\n+            break;\n+        case RCLICK_COMMAND_MANAGE_SCENARIO:\n+            scenarioWizard.setCurrentScenario(currentTrack.getScenario(selectedCoords),\n+                    currentTrack,\n+                    campaignState);", "originalCommit": "796b6728fd3cd2aea02d17122b4d735afc47dc41", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjkwMjY3OQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r602902679", "bodyText": "Indent the switch", "author": "Windchild292", "createdAt": "2021-03-28T16:52:23Z", "path": "MekHQ/src/mekhq/gui/StratconPanel.java", "diffHunk": "@@ -0,0 +1,672 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.gui;\n+\n+import java.awt.BasicStroke;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Point;\n+import java.awt.Polygon;\n+import java.awt.Stroke;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.awt.geom.AffineTransform;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import javax.swing.JCheckBoxMenuItem;\n+import javax.swing.JLabel;\n+import javax.swing.JMenuItem;\n+import javax.swing.JPanel;\n+import javax.swing.JPopupMenu;\n+import javax.swing.SwingUtilities;\n+\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.stratcon.StratconCampaignState;\n+import mekhq.campaign.stratcon.StratconCoords;\n+import mekhq.campaign.stratcon.StratconFacility;\n+import mekhq.campaign.stratcon.StratconScenario;\n+import mekhq.campaign.stratcon.StratconTrackState;\n+import mekhq.gui.stratcon.StratconScenarioWizard;\n+import mekhq.gui.stratcon.TrackForceAssignmentUI;\n+\n+/**\n+ * This panel handles AtB-Stratcon GUI interactions with a specific scenario track.\n+ * @author NickAragua\n+ */\n+public class StratconPanel extends JPanel implements ActionListener {\n+    /**\n+     * \n+     */\n+    private static final long serialVersionUID = 7405934788894417292L;\n+    \n+    public static final int HEX_X_RADIUS = 42;\n+    public static final int HEX_Y_RADIUS = 37;\n+    \n+    private static final String RCLICK_COMMAND_MANAGE_FORCES = \"ManageForces\";\n+    private static final String RCLICK_COMMAND_MANAGE_SCENARIO = \"ManageScenario\";\n+    private static final String RCLICK_COMMAND_REVEAL_TRACK = \"RevealTrack\";\n+    private static final String RCLICK_COMMAND_STICKY_FORCE = \"StickyForce\";\n+    private static final String RCLICK_COMMAND_STICKY_FORCE_ID = \"StickyForceID\";\n+\n+    /**\n+     * What to do when drawing a hex\n+     */\n+    private enum DrawHexType {\n+        /**\n+         * The interior of a hex\n+         */\n+        Hex,\n+        \n+        /**\n+         * The outline of a hex\n+         */\n+        Outline,\n+        \n+        /**\n+         * Pretend we're drawing a hex, but don't actually do it, useful for \n+         * figuring out which hex a mouse click landed in, etc.\n+         */\n+        Dryrun\n+    }\n+\n+    private float scale = 1f;\n+\n+    private StratconTrackState currentTrack;\n+    private StratconCampaignState campaignState;\n+    private Campaign campaign;\n+\n+    private BoardState boardState = new BoardState();\n+\n+    private Point clickedPoint;\n+    private JPopupMenu rightClickMenu;\n+    private JMenuItem menuItemManageForceAssignments;\n+    private JMenuItem menuItemManageScenario;\n+    private JMenuItem menuItemGMReveal;\n+    \n+    // data structure holding how many unit/scenario/base icons have been drawn in the hex\n+    // used to control how low the text description goes.\n+    private Map<StratconCoords, Integer> numIconsInHex = new HashMap<>();\n+    \n+    private StratconScenarioWizard scenarioWizard;\n+    private TrackForceAssignmentUI assignmentUI;\n+    \n+    private JLabel infoArea;\n+\n+    /**\n+     * Constructs a StratconPanel instance, given a parent campaign GUI and a pointer to an info area.\n+     */\n+    StratconPanel(CampaignGUI gui, JLabel infoArea) {\n+        campaign = gui.getCampaign();\n+        scenarioWizard = new StratconScenarioWizard(campaign);\n+        this.infoArea = infoArea;\n+        \n+        assignmentUI = new TrackForceAssignmentUI(this);\n+        assignmentUI.setVisible(false);\n+        \n+        addMouseListener(new MouseAdapter() {\n+            @Override\n+            public void mouseReleased(MouseEvent e) {\n+                mouseReleasedHandler(e);\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Handler for when a specific track is selected - switches rendering to that track.\n+     */\n+    public void selectTrack(StratconCampaignState campaignState, StratconTrackState track) {\n+        this.campaignState = campaignState;\n+        currentTrack = track;\n+        repaint();\n+    }\n+    \n+    /**\n+     * Constructs the right-click context menu, optionally for a scenario\n+     */\n+    private void buildRightClickMenu(StratconCoords coords) {\n+        rightClickMenu = new JPopupMenu();\n+        \n+        StratconScenario scenario = getSelectedScenario();\n+        \n+        if (scenario == null) {\n+            menuItemManageForceAssignments = new JMenuItem();\n+            menuItemManageForceAssignments.setText(\"Manage Force Assignments\");\n+            menuItemManageForceAssignments.setActionCommand(RCLICK_COMMAND_MANAGE_FORCES);\n+            menuItemManageForceAssignments.addActionListener(this);\n+            rightClickMenu.add(menuItemManageForceAssignments);\n+        }\n+        \n+        if (scenario != null) {\n+            menuItemManageScenario = new JMenuItem();\n+            menuItemManageScenario.setText(\"Manage Scenario\");\n+            menuItemManageScenario.setActionCommand(RCLICK_COMMAND_MANAGE_SCENARIO);\n+            menuItemManageScenario.addActionListener(this);\n+            rightClickMenu.add(menuItemManageScenario);\n+        }\n+        \n+        if ((currentTrack != null) && currentTrack.getAssignedCoordForces().containsKey(coords)) {\n+            for (int forceID : currentTrack.getAssignedCoordForces().get(coords)) {\n+                String forceName = campaign.getForce(forceID).getName();\n+                \n+                JCheckBoxMenuItem stickyForceItem = new JCheckBoxMenuItem();\n+                stickyForceItem.setText(String.format(\"%s - remain deployed\", forceName));\n+                stickyForceItem.setActionCommand(RCLICK_COMMAND_STICKY_FORCE);\n+                stickyForceItem.putClientProperty(RCLICK_COMMAND_STICKY_FORCE_ID, forceID);\n+                stickyForceItem.addActionListener(this);\n+                stickyForceItem.setSelected(currentTrack.getStickyForces().contains(forceID));\n+                rightClickMenu.add(stickyForceItem);\n+            }\n+        }\n+            \n+        if ((currentTrack != null) && campaign.isGM()) {\n+            rightClickMenu.addSeparator();\n+            \n+            menuItemGMReveal = new JMenuItem();\n+            menuItemGMReveal.setText(currentTrack.isGmRevealed() ? \"Hide Track\" : \"Reveal Track\");\n+            menuItemGMReveal.setActionCommand(RCLICK_COMMAND_REVEAL_TRACK);\n+            menuItemGMReveal.addActionListener(this);\n+            rightClickMenu.add(menuItemGMReveal);\n+        }\n+    }\n+\n+    /**\n+     * Renders the panel, hexes, forces, facilities and all that.\n+     */\n+    @Override\n+    public void paintComponent(Graphics g) {\n+        super.paintComponent(g);\n+        if (campaignState == null || currentTrack == null) {\n+            return;\n+        }\n+        \n+        numIconsInHex.clear();\n+\n+        Graphics2D g2D = (Graphics2D) g;\n+        AffineTransform initialTransform = g2D.getTransform();\n+        performInitialTransform(g2D);\n+        AffineTransform originTransform = g2D.getTransform();\n+\n+        drawHexes(g2D, DrawHexType.Hex);\n+        g2D.setTransform(originTransform);\n+        drawHexes(g2D, DrawHexType.Outline);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawScenarios(g2D);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawFacilities(g2D);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawForces(g2D);\n+\n+        g2D.setTransform(initialTransform);\n+        if (clickedPoint != null) {\n+            g2D.setColor(Color.BLUE);\n+            g2D.drawRect((int) clickedPoint.getX(), (int) clickedPoint.getY(), 2, 2);\n+        }\n+    }\n+\n+    /**\n+     * This method contains a dirty secret hack, but I forget what it is.\n+     * The point of it is to draw all the hexes for the board. \n+     * If it's a \"dry run\", we don't actually draw the hexes, we just pretend to\n+     * until we \"draw\" one that encompasses the clicked point.\n+     * @param g2D - graphics object on which to draw\n+     * @param drawHexType - whether to draw the hex backgrounds, hex outlines or a dry run for click detection\n+     */\n+    private boolean drawHexes(Graphics2D g2D, DrawHexType drawHexType) {\n+        Polygon graphHex = new Polygon();\n+        int xRadius = HEX_X_RADIUS;\n+        int yRadius = HEX_Y_RADIUS;\n+        boolean pointFound = false;\n+\n+        graphHex.addPoint(-xRadius/2, -yRadius);\n+        graphHex.addPoint(-xRadius, 0);\n+        graphHex.addPoint(-xRadius/2, yRadius);\n+        graphHex.addPoint(xRadius/2, yRadius);\n+        graphHex.addPoint(xRadius, 0);\n+        graphHex.addPoint(xRadius/2, -yRadius);\n+\n+        graphHex.translate(xRadius, yRadius);\n+\n+        Point translatedClickedPoint = null;\n+\n+        // this was derived somewhat experimentally\n+        // the clicked point always seems a little off, so we \n+        // a) apply the current transform to it, prior to drawing all the hexes\n+        // b) subtract an additional Y_RADIUS x 2 (Y_DIAMETER)\n+        // this gets us the point within the clicked hex\n+        // it's probably finicky, so any major changes to the rendering mechanism will likely break the detection\n+        if (clickedPoint != null) {\n+            translatedClickedPoint = (Point) clickedPoint.clone();\n+            \n+            // since we have the possibility of scrolling, we need to convert the on-screen clicked coordinates\n+            // to on-board coordinates. Thankfully, SwingUtilities provides the main computational ability for that\n+            Point actualPanelPoint = SwingUtilities.convertPoint(this, translatedClickedPoint, this.getParent());\n+            translatedClickedPoint.translate((int) -(actualPanelPoint.getX() - translatedClickedPoint.getX()), \n+                                                (int) -(actualPanelPoint.getY() - translatedClickedPoint.getY()));\n+            \n+            // now we translate to the starting point of where we're drawing and then go down a hex\n+            translatedClickedPoint.translate((int) g2D.getTransform().getTranslateX(), (int) g2D.getTransform().getTranslateY());\n+            translatedClickedPoint.translate(0, -(HEX_Y_RADIUS * 2));\n+        }\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                if(drawHexType == DrawHexType.Outline) {\n+                    g2D.setColor(new Color(0, 0, 0));\n+                    g2D.drawPolygon(graphHex);                    \n+                } else if (drawHexType == DrawHexType.Hex) {\n+                    \n+                    if (currentTrack.coordsRevealed(x, y) || currentTrack.isGmRevealed()) {\n+                        g2D.setColor(Color.LIGHT_GRAY);\n+                    } else {\n+                        g2D.setColor(Color.DARK_GRAY);\n+                    }\n+                    g2D.fillPolygon(graphHex);\n+                    \n+                    if (translatedClickedPoint != null && graphHex.contains(translatedClickedPoint)) {\n+                        g2D.setColor(Color.WHITE);\n+                        BasicStroke s = new BasicStroke((float) 8.0);\n+                        Stroke push = g2D.getStroke();\n+                        g2D.setStroke(s);\n+                        g2D.drawPolygon(graphHex);\n+                        \n+                        boardState.selectedX = x;\n+                        boardState.selectedY = y;\n+                        pointFound = true;\n+                        g2D.setStroke(push);\n+                    }\n+                } else if (drawHexType == DrawHexType.Dryrun) {\n+                    if (translatedClickedPoint != null && graphHex.contains(translatedClickedPoint)) {\n+                        boardState.selectedX = x;\n+                        boardState.selectedY = y;\n+                        pointFound = true;\n+                    }\n+                }\n+\n+                if (drawHexType == DrawHexType.Hex) {\n+                    g2D.setColor(Color.GREEN);\n+                    g2D.drawString(x + \",\" + y, graphHex.xpoints[0] + (xRadius / 4), graphHex.ypoints[0] + yRadius);\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                graphHex.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            graphHex.translate(translationVector[0], translationVector[1]);\n+        }\n+\n+        return pointFound;\n+    }\n+\n+    /**\n+     * Worker function to render icons representing scenarios to the given surface.\n+     */\n+    private void drawScenarios(Graphics2D g2D) {\n+        Polygon scenarioMarker = new Polygon();\n+        int xRadius = HEX_X_RADIUS / 3;\n+        int yRadius = HEX_Y_RADIUS / 3;\n+\n+        scenarioMarker.addPoint(-xRadius, -yRadius);\n+        scenarioMarker.addPoint(-xRadius, yRadius);\n+        scenarioMarker.addPoint(xRadius, yRadius);\n+        scenarioMarker.addPoint(xRadius, -yRadius);\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                StratconCoords currentCoords = new StratconCoords(x, y);\n+                StratconScenario scenario = currentTrack.getScenario(currentCoords);\n+                \n+                // if there's a scenario here that has a deployment/battle date\n+                // or if there's a scenario here and we've gm-revealed everything\n+                if ((scenario != null) &&\n+                        ((scenario.getDeploymentDate() != null) || currentTrack.isGmRevealed())) {\n+                    g2D.setColor(Color.RED);\n+                    g2D.drawPolygon(scenarioMarker);\n+                    if(currentTrack.getFacility(currentCoords) == null) {\n+                        drawTextEffect(g2D, scenarioMarker, \"Hostile Force Detected\", currentCoords);\n+                    }\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                scenarioMarker.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            scenarioMarker.translate(translationVector[0], translationVector[1]);\n+        }\n+    }\n+    \n+    /**\n+     * Worker function to render facility icons to the given surface.\n+     */\n+    private void drawFacilities(Graphics2D g2D) {\n+        Polygon facilityMarker = new Polygon();\n+        int xRadius = HEX_X_RADIUS / 3;\n+        int yRadius = HEX_Y_RADIUS / 3;\n+\n+        facilityMarker.addPoint(-xRadius, -yRadius);\n+        facilityMarker.addPoint(-xRadius, yRadius);\n+        facilityMarker.addPoint(xRadius, yRadius);\n+        facilityMarker.addPoint(xRadius, -yRadius);\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                StratconCoords currentCoords = new StratconCoords(x, y);\n+                StratconFacility facility = currentTrack.getFacility(currentCoords);\n+                \n+                if ((facility != null) && (facility.isVisible() || currentTrack.isGmRevealed())) {\n+                    g2D.setColor(facility.getOwner() == ForceAlignment.Allied ? Color.GREEN : Color.RED);\n+                    g2D.drawPolygon(facilityMarker);\n+                    drawTextEffect(g2D, facilityMarker, facility.getFormattedDisplayableName(), currentCoords);\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                facilityMarker.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            facilityMarker.translate(translationVector[0], translationVector[1]);\n+        }\n+    }\n+    \n+    /**\n+     * Worker function to render force icons to the given surface.\n+     */\n+    private void drawForces(Graphics2D g2D) {\n+        Polygon forceMarker = new Polygon();\n+        int xRadius = HEX_X_RADIUS / 3;\n+        int yRadius = HEX_Y_RADIUS / 3;\n+\n+        forceMarker.addPoint(-xRadius, -yRadius);\n+        forceMarker.addPoint(-xRadius, yRadius);\n+        forceMarker.addPoint(xRadius, yRadius);\n+        forceMarker.addPoint(xRadius, -yRadius);\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                StratconCoords currentCoords = new StratconCoords(x, y);\n+                \n+                if (currentTrack.getAssignedCoordForces().containsKey(currentCoords)) {\n+                    for (int forceID : currentTrack.getAssignedCoordForces().get(currentCoords)) {                   \n+                        g2D.setColor(Color.BLUE);\n+                        g2D.drawPolygon(forceMarker);\n+                        drawTextEffect(g2D, forceMarker, campaign.getForce(forceID).getName(), currentCoords);\n+                    }\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                forceMarker.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            forceMarker.translate(translationVector[0], translationVector[1]);\n+        }\n+    }\n+    \n+    /**\n+     * Draws some text and line to it from a given polygon. \n+     * Smart enough not to layer multiple strings on top of each other if they're all drawn in the same hex.\n+     */\n+    private void drawTextEffect(Graphics2D g2D, Polygon marker, String text, StratconCoords coords) {\n+        int verticalOffsetIndex = numIconsInHex.containsKey(coords) ? numIconsInHex.get(coords) : 0;\n+        \n+        double startX = marker.getBounds().getMaxX();\n+        double startY = marker.getBounds().getMinY();\n+        double midPointX = startX + HEX_X_RADIUS / 4;\n+        double midPointY = startY - HEX_Y_RADIUS / 4 + g2D.getFontMetrics().getHeight() * verticalOffsetIndex;\n+        double endPointX = midPointX + HEX_X_RADIUS / 2;\n+        \n+        g2D.drawLine((int) startX, (int) startY, (int) midPointX, (int) midPointY);\n+        g2D.drawLine((int) midPointX, (int) midPointY, (int) endPointX, (int) midPointY);\n+        g2D.drawString(text, (int) endPointX, (int) midPointY);\n+        \n+        // register that we drew text off of this hex\n+        verticalOffsetIndex++;\n+        numIconsInHex.put(coords, verticalOffsetIndex);\n+    }\n+\n+    /**\n+     * Returns the translation that we need to make to render the \"next downward\" hex.\n+     * @return Two dimensional array with the first element being the x vector and the second being the y vector\n+     */\n+    private int[] getDownwardYVector() {\n+        return new int[] { 0, (int) (HEX_Y_RADIUS * 2) };\n+    }\n+\n+    /**\n+     * Returns the translation that we need to make to move from the bottom of a column to the top of the next\n+     * column to the right.\n+     * @param evenColumn Whether the column we're currently in is odd or even\n+     * @return Two dimensional array with the first element being the x vector and the second being the y vector\n+     */\n+    private int[] getRightAndUPVector(boolean evenColumn) {\n+        int yRadius = (int) (HEX_Y_RADIUS);\n+        int xRadius = (int) (HEX_X_RADIUS);\n+\n+        int yTranslation = currentTrack.getHeight() * yRadius * 2;\n+        if (evenColumn) {\n+            yTranslation += yRadius;\n+        } else {\n+            yTranslation -= yRadius;\n+        }\n+\n+        return new int[] {(int) (xRadius * 1.5), -yTranslation};\n+    }\n+\n+    /**\n+     * Go to the origin of the hex board and reset the scaling.\n+     */\n+    private void performInitialTransform(Graphics2D g2D) {\n+        g2D.translate(0, 0 + HEX_Y_RADIUS);\n+        g2D.scale(scale, scale);\n+    }\n+\n+    /** \n+     * Worker function that takes the current clicked point and a graphics 2D object\n+     * and detects which hex was clicked by doing a dry run hex render.\n+     * \n+     * Dependent upon clickedPoint being set and having an active graphics object for this class.\n+     * \n+     * Side effects: the dry run sets the boardState clicked hex coordinates.\n+     * @return Whether or not the clicked point was found on the hex board\n+     */\n+    private boolean detectClickedHex() {\n+        Graphics2D g2D = (Graphics2D) getGraphics();\n+        AffineTransform transform = g2D.getTransform();\n+        performInitialTransform(g2D);\n+        boolean pointFoundOnBoard = drawHexes(g2D, DrawHexType.Dryrun);\n+        g2D.setTransform(transform);\n+\n+        return pointFoundOnBoard;\n+    }\n+\n+    /**\n+     * Event handler for when a mouse button is released.\n+     */\n+    public void mouseReleasedHandler(MouseEvent e) {\n+        if(e.getSource() != this) {\n+            return;\n+        }\n+\n+        // left button generally selects a hex\n+        if (e.getButton() == MouseEvent.BUTTON1) {        \n+            clickedPoint = e.getPoint();\n+            boolean pointFoundOnBoard = detectClickedHex();\n+            \n+            if(pointFoundOnBoard) {\n+                infoArea.setText(buildSelectedHexInfo());\n+            }\n+\n+            repaint();\n+        // right button generally pops up a context menu\n+        } else if (e.getButton() == MouseEvent.BUTTON3) {\n+            clickedPoint = e.getPoint();\n+            detectClickedHex();\n+            \n+            StratconCoords selectedCoords = boardState.getSelectedCoords();\n+            if (selectedCoords == null) {\n+                return;\n+            }\n+            \n+            repaint();\n+            buildRightClickMenu(selectedCoords);\n+            rightClickMenu.show(this, e.getX(), e.getY());\n+        }\n+    }\n+    \n+    public StratconScenario getSelectedScenario() {\n+        return currentTrack.getScenario(boardState.getSelectedCoords());\n+    }\n+    \n+    /**\n+     * Worker function that outputs html representing the status of a selected hex,\n+     * containing info such as whether it's been revealed, assigned forces, scenarios, facilities, etc.\n+     */\n+    private String buildSelectedHexInfo() {\n+        StringBuilder infoBuilder = new StringBuilder();\n+        infoBuilder.append(\"<html><br/>\");\n+        \n+        boolean coordsRevealed = currentTrack.getRevealedCoords().contains(boardState.getSelectedCoords());\n+        if (coordsRevealed) {\n+            infoBuilder.append(\"<span color='green'>Recon complete</span><br/>\");\n+        }\n+        \n+        if (currentTrack.getAssignedCoordForces().containsKey(boardState.getSelectedCoords())) {\n+            for (int forceID : currentTrack.getAssignedCoordForces().get(boardState.getSelectedCoords())) {\n+                Force force = campaign.getForce(forceID);\n+                infoBuilder.append(force.getName()).append(\" assigned\");\n+                \n+                if (currentTrack.getStickyForces().contains(forceID)) {\n+                    infoBuilder.append(\" - remain deployed\");\n+                }\n+                \n+                infoBuilder.append(\"<br/>\");\n+                \n+                infoBuilder.append(\"Returns on \").append(currentTrack.getAssignedForceReturnDates().get(forceID));\n+                infoBuilder.append(\"<br/>\");\n+            }\n+        }\n+        \n+        if (coordsRevealed || currentTrack.isGmRevealed()) {\n+            StratconFacility facility = currentTrack.getFacility(boardState.getSelectedCoords());\n+            \n+            if((facility != null) && (facility.getFacilityType() != null)) {\n+                if (facility.isStrategicObjective()) {\n+                    infoBuilder.append(String.format(\"<br/><span color='%s'>Contract objective located</span>\", \n+                            facility.getOwner() == ForceAlignment.Allied ? \"green\" : \"red\"));\n+                }\n+                infoBuilder.append((facility.getOwner() == ForceAlignment.Allied) ? \"<span color='green'>\" : \"<span color='red'>\");\n+                infoBuilder.append(\"<br/>\");\n+                infoBuilder.append(facility.getFormattedDisplayableName());\n+                infoBuilder.append(\"<span>\");\n+            }\n+            \n+        } else {\n+            infoBuilder.append(\"<span color='red'>Recon incomplete</span>\");\n+        }\n+        infoBuilder.append(\"<br/>\");\n+        \n+        \n+        StratconScenario selectedScenario = getSelectedScenario();\n+        if ((selectedScenario != null) &&\n+                ((selectedScenario.getDeploymentDate() != null) || currentTrack.isGmRevealed())) {\n+            infoBuilder.append(selectedScenario.getInfo());\n+        }\n+        \n+        infoBuilder.append(\"</html>\");\n+        \n+        return infoBuilder.toString();\n+    }\n+\n+    /**\n+     * Data structure containing current state of the board.\n+     */\n+    private static class BoardState {\n+        public Integer selectedX;\n+        public Integer selectedY;\n+        \n+        public StratconCoords getSelectedCoords() {\n+            if((selectedX == null) || (selectedY == null)) {\n+                return null;\n+            } else {\n+                return new StratconCoords(selectedX, selectedY);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Event handler for various button and menu item presses.\n+     */\n+    @Override\n+    public void actionPerformed(ActionEvent e) {\n+        StratconCoords selectedCoords = boardState.getSelectedCoords();\n+        if(selectedCoords == null) {\n+            return;\n+        }\n+        \n+        switch(e.getActionCommand()) {\n+        case RCLICK_COMMAND_MANAGE_FORCES:", "originalCommit": "796b6728fd3cd2aea02d17122b4d735afc47dc41", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjkwMjY4NA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r602902684", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if(currentTrack != null) {\n          \n          \n            \n                    if (currentTrack != null) {", "author": "Windchild292", "createdAt": "2021-03-28T16:52:31Z", "path": "MekHQ/src/mekhq/gui/StratconPanel.java", "diffHunk": "@@ -0,0 +1,672 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.gui;\n+\n+import java.awt.BasicStroke;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Point;\n+import java.awt.Polygon;\n+import java.awt.Stroke;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.awt.geom.AffineTransform;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import javax.swing.JCheckBoxMenuItem;\n+import javax.swing.JLabel;\n+import javax.swing.JMenuItem;\n+import javax.swing.JPanel;\n+import javax.swing.JPopupMenu;\n+import javax.swing.SwingUtilities;\n+\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.stratcon.StratconCampaignState;\n+import mekhq.campaign.stratcon.StratconCoords;\n+import mekhq.campaign.stratcon.StratconFacility;\n+import mekhq.campaign.stratcon.StratconScenario;\n+import mekhq.campaign.stratcon.StratconTrackState;\n+import mekhq.gui.stratcon.StratconScenarioWizard;\n+import mekhq.gui.stratcon.TrackForceAssignmentUI;\n+\n+/**\n+ * This panel handles AtB-Stratcon GUI interactions with a specific scenario track.\n+ * @author NickAragua\n+ */\n+public class StratconPanel extends JPanel implements ActionListener {\n+    /**\n+     * \n+     */\n+    private static final long serialVersionUID = 7405934788894417292L;\n+    \n+    public static final int HEX_X_RADIUS = 42;\n+    public static final int HEX_Y_RADIUS = 37;\n+    \n+    private static final String RCLICK_COMMAND_MANAGE_FORCES = \"ManageForces\";\n+    private static final String RCLICK_COMMAND_MANAGE_SCENARIO = \"ManageScenario\";\n+    private static final String RCLICK_COMMAND_REVEAL_TRACK = \"RevealTrack\";\n+    private static final String RCLICK_COMMAND_STICKY_FORCE = \"StickyForce\";\n+    private static final String RCLICK_COMMAND_STICKY_FORCE_ID = \"StickyForceID\";\n+\n+    /**\n+     * What to do when drawing a hex\n+     */\n+    private enum DrawHexType {\n+        /**\n+         * The interior of a hex\n+         */\n+        Hex,\n+        \n+        /**\n+         * The outline of a hex\n+         */\n+        Outline,\n+        \n+        /**\n+         * Pretend we're drawing a hex, but don't actually do it, useful for \n+         * figuring out which hex a mouse click landed in, etc.\n+         */\n+        Dryrun\n+    }\n+\n+    private float scale = 1f;\n+\n+    private StratconTrackState currentTrack;\n+    private StratconCampaignState campaignState;\n+    private Campaign campaign;\n+\n+    private BoardState boardState = new BoardState();\n+\n+    private Point clickedPoint;\n+    private JPopupMenu rightClickMenu;\n+    private JMenuItem menuItemManageForceAssignments;\n+    private JMenuItem menuItemManageScenario;\n+    private JMenuItem menuItemGMReveal;\n+    \n+    // data structure holding how many unit/scenario/base icons have been drawn in the hex\n+    // used to control how low the text description goes.\n+    private Map<StratconCoords, Integer> numIconsInHex = new HashMap<>();\n+    \n+    private StratconScenarioWizard scenarioWizard;\n+    private TrackForceAssignmentUI assignmentUI;\n+    \n+    private JLabel infoArea;\n+\n+    /**\n+     * Constructs a StratconPanel instance, given a parent campaign GUI and a pointer to an info area.\n+     */\n+    StratconPanel(CampaignGUI gui, JLabel infoArea) {\n+        campaign = gui.getCampaign();\n+        scenarioWizard = new StratconScenarioWizard(campaign);\n+        this.infoArea = infoArea;\n+        \n+        assignmentUI = new TrackForceAssignmentUI(this);\n+        assignmentUI.setVisible(false);\n+        \n+        addMouseListener(new MouseAdapter() {\n+            @Override\n+            public void mouseReleased(MouseEvent e) {\n+                mouseReleasedHandler(e);\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Handler for when a specific track is selected - switches rendering to that track.\n+     */\n+    public void selectTrack(StratconCampaignState campaignState, StratconTrackState track) {\n+        this.campaignState = campaignState;\n+        currentTrack = track;\n+        repaint();\n+    }\n+    \n+    /**\n+     * Constructs the right-click context menu, optionally for a scenario\n+     */\n+    private void buildRightClickMenu(StratconCoords coords) {\n+        rightClickMenu = new JPopupMenu();\n+        \n+        StratconScenario scenario = getSelectedScenario();\n+        \n+        if (scenario == null) {\n+            menuItemManageForceAssignments = new JMenuItem();\n+            menuItemManageForceAssignments.setText(\"Manage Force Assignments\");\n+            menuItemManageForceAssignments.setActionCommand(RCLICK_COMMAND_MANAGE_FORCES);\n+            menuItemManageForceAssignments.addActionListener(this);\n+            rightClickMenu.add(menuItemManageForceAssignments);\n+        }\n+        \n+        if (scenario != null) {\n+            menuItemManageScenario = new JMenuItem();\n+            menuItemManageScenario.setText(\"Manage Scenario\");\n+            menuItemManageScenario.setActionCommand(RCLICK_COMMAND_MANAGE_SCENARIO);\n+            menuItemManageScenario.addActionListener(this);\n+            rightClickMenu.add(menuItemManageScenario);\n+        }\n+        \n+        if ((currentTrack != null) && currentTrack.getAssignedCoordForces().containsKey(coords)) {\n+            for (int forceID : currentTrack.getAssignedCoordForces().get(coords)) {\n+                String forceName = campaign.getForce(forceID).getName();\n+                \n+                JCheckBoxMenuItem stickyForceItem = new JCheckBoxMenuItem();\n+                stickyForceItem.setText(String.format(\"%s - remain deployed\", forceName));\n+                stickyForceItem.setActionCommand(RCLICK_COMMAND_STICKY_FORCE);\n+                stickyForceItem.putClientProperty(RCLICK_COMMAND_STICKY_FORCE_ID, forceID);\n+                stickyForceItem.addActionListener(this);\n+                stickyForceItem.setSelected(currentTrack.getStickyForces().contains(forceID));\n+                rightClickMenu.add(stickyForceItem);\n+            }\n+        }\n+            \n+        if ((currentTrack != null) && campaign.isGM()) {\n+            rightClickMenu.addSeparator();\n+            \n+            menuItemGMReveal = new JMenuItem();\n+            menuItemGMReveal.setText(currentTrack.isGmRevealed() ? \"Hide Track\" : \"Reveal Track\");\n+            menuItemGMReveal.setActionCommand(RCLICK_COMMAND_REVEAL_TRACK);\n+            menuItemGMReveal.addActionListener(this);\n+            rightClickMenu.add(menuItemGMReveal);\n+        }\n+    }\n+\n+    /**\n+     * Renders the panel, hexes, forces, facilities and all that.\n+     */\n+    @Override\n+    public void paintComponent(Graphics g) {\n+        super.paintComponent(g);\n+        if (campaignState == null || currentTrack == null) {\n+            return;\n+        }\n+        \n+        numIconsInHex.clear();\n+\n+        Graphics2D g2D = (Graphics2D) g;\n+        AffineTransform initialTransform = g2D.getTransform();\n+        performInitialTransform(g2D);\n+        AffineTransform originTransform = g2D.getTransform();\n+\n+        drawHexes(g2D, DrawHexType.Hex);\n+        g2D.setTransform(originTransform);\n+        drawHexes(g2D, DrawHexType.Outline);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawScenarios(g2D);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawFacilities(g2D);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawForces(g2D);\n+\n+        g2D.setTransform(initialTransform);\n+        if (clickedPoint != null) {\n+            g2D.setColor(Color.BLUE);\n+            g2D.drawRect((int) clickedPoint.getX(), (int) clickedPoint.getY(), 2, 2);\n+        }\n+    }\n+\n+    /**\n+     * This method contains a dirty secret hack, but I forget what it is.\n+     * The point of it is to draw all the hexes for the board. \n+     * If it's a \"dry run\", we don't actually draw the hexes, we just pretend to\n+     * until we \"draw\" one that encompasses the clicked point.\n+     * @param g2D - graphics object on which to draw\n+     * @param drawHexType - whether to draw the hex backgrounds, hex outlines or a dry run for click detection\n+     */\n+    private boolean drawHexes(Graphics2D g2D, DrawHexType drawHexType) {\n+        Polygon graphHex = new Polygon();\n+        int xRadius = HEX_X_RADIUS;\n+        int yRadius = HEX_Y_RADIUS;\n+        boolean pointFound = false;\n+\n+        graphHex.addPoint(-xRadius/2, -yRadius);\n+        graphHex.addPoint(-xRadius, 0);\n+        graphHex.addPoint(-xRadius/2, yRadius);\n+        graphHex.addPoint(xRadius/2, yRadius);\n+        graphHex.addPoint(xRadius, 0);\n+        graphHex.addPoint(xRadius/2, -yRadius);\n+\n+        graphHex.translate(xRadius, yRadius);\n+\n+        Point translatedClickedPoint = null;\n+\n+        // this was derived somewhat experimentally\n+        // the clicked point always seems a little off, so we \n+        // a) apply the current transform to it, prior to drawing all the hexes\n+        // b) subtract an additional Y_RADIUS x 2 (Y_DIAMETER)\n+        // this gets us the point within the clicked hex\n+        // it's probably finicky, so any major changes to the rendering mechanism will likely break the detection\n+        if (clickedPoint != null) {\n+            translatedClickedPoint = (Point) clickedPoint.clone();\n+            \n+            // since we have the possibility of scrolling, we need to convert the on-screen clicked coordinates\n+            // to on-board coordinates. Thankfully, SwingUtilities provides the main computational ability for that\n+            Point actualPanelPoint = SwingUtilities.convertPoint(this, translatedClickedPoint, this.getParent());\n+            translatedClickedPoint.translate((int) -(actualPanelPoint.getX() - translatedClickedPoint.getX()), \n+                                                (int) -(actualPanelPoint.getY() - translatedClickedPoint.getY()));\n+            \n+            // now we translate to the starting point of where we're drawing and then go down a hex\n+            translatedClickedPoint.translate((int) g2D.getTransform().getTranslateX(), (int) g2D.getTransform().getTranslateY());\n+            translatedClickedPoint.translate(0, -(HEX_Y_RADIUS * 2));\n+        }\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                if(drawHexType == DrawHexType.Outline) {\n+                    g2D.setColor(new Color(0, 0, 0));\n+                    g2D.drawPolygon(graphHex);                    \n+                } else if (drawHexType == DrawHexType.Hex) {\n+                    \n+                    if (currentTrack.coordsRevealed(x, y) || currentTrack.isGmRevealed()) {\n+                        g2D.setColor(Color.LIGHT_GRAY);\n+                    } else {\n+                        g2D.setColor(Color.DARK_GRAY);\n+                    }\n+                    g2D.fillPolygon(graphHex);\n+                    \n+                    if (translatedClickedPoint != null && graphHex.contains(translatedClickedPoint)) {\n+                        g2D.setColor(Color.WHITE);\n+                        BasicStroke s = new BasicStroke((float) 8.0);\n+                        Stroke push = g2D.getStroke();\n+                        g2D.setStroke(s);\n+                        g2D.drawPolygon(graphHex);\n+                        \n+                        boardState.selectedX = x;\n+                        boardState.selectedY = y;\n+                        pointFound = true;\n+                        g2D.setStroke(push);\n+                    }\n+                } else if (drawHexType == DrawHexType.Dryrun) {\n+                    if (translatedClickedPoint != null && graphHex.contains(translatedClickedPoint)) {\n+                        boardState.selectedX = x;\n+                        boardState.selectedY = y;\n+                        pointFound = true;\n+                    }\n+                }\n+\n+                if (drawHexType == DrawHexType.Hex) {\n+                    g2D.setColor(Color.GREEN);\n+                    g2D.drawString(x + \",\" + y, graphHex.xpoints[0] + (xRadius / 4), graphHex.ypoints[0] + yRadius);\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                graphHex.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            graphHex.translate(translationVector[0], translationVector[1]);\n+        }\n+\n+        return pointFound;\n+    }\n+\n+    /**\n+     * Worker function to render icons representing scenarios to the given surface.\n+     */\n+    private void drawScenarios(Graphics2D g2D) {\n+        Polygon scenarioMarker = new Polygon();\n+        int xRadius = HEX_X_RADIUS / 3;\n+        int yRadius = HEX_Y_RADIUS / 3;\n+\n+        scenarioMarker.addPoint(-xRadius, -yRadius);\n+        scenarioMarker.addPoint(-xRadius, yRadius);\n+        scenarioMarker.addPoint(xRadius, yRadius);\n+        scenarioMarker.addPoint(xRadius, -yRadius);\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                StratconCoords currentCoords = new StratconCoords(x, y);\n+                StratconScenario scenario = currentTrack.getScenario(currentCoords);\n+                \n+                // if there's a scenario here that has a deployment/battle date\n+                // or if there's a scenario here and we've gm-revealed everything\n+                if ((scenario != null) &&\n+                        ((scenario.getDeploymentDate() != null) || currentTrack.isGmRevealed())) {\n+                    g2D.setColor(Color.RED);\n+                    g2D.drawPolygon(scenarioMarker);\n+                    if(currentTrack.getFacility(currentCoords) == null) {\n+                        drawTextEffect(g2D, scenarioMarker, \"Hostile Force Detected\", currentCoords);\n+                    }\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                scenarioMarker.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            scenarioMarker.translate(translationVector[0], translationVector[1]);\n+        }\n+    }\n+    \n+    /**\n+     * Worker function to render facility icons to the given surface.\n+     */\n+    private void drawFacilities(Graphics2D g2D) {\n+        Polygon facilityMarker = new Polygon();\n+        int xRadius = HEX_X_RADIUS / 3;\n+        int yRadius = HEX_Y_RADIUS / 3;\n+\n+        facilityMarker.addPoint(-xRadius, -yRadius);\n+        facilityMarker.addPoint(-xRadius, yRadius);\n+        facilityMarker.addPoint(xRadius, yRadius);\n+        facilityMarker.addPoint(xRadius, -yRadius);\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                StratconCoords currentCoords = new StratconCoords(x, y);\n+                StratconFacility facility = currentTrack.getFacility(currentCoords);\n+                \n+                if ((facility != null) && (facility.isVisible() || currentTrack.isGmRevealed())) {\n+                    g2D.setColor(facility.getOwner() == ForceAlignment.Allied ? Color.GREEN : Color.RED);\n+                    g2D.drawPolygon(facilityMarker);\n+                    drawTextEffect(g2D, facilityMarker, facility.getFormattedDisplayableName(), currentCoords);\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                facilityMarker.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            facilityMarker.translate(translationVector[0], translationVector[1]);\n+        }\n+    }\n+    \n+    /**\n+     * Worker function to render force icons to the given surface.\n+     */\n+    private void drawForces(Graphics2D g2D) {\n+        Polygon forceMarker = new Polygon();\n+        int xRadius = HEX_X_RADIUS / 3;\n+        int yRadius = HEX_Y_RADIUS / 3;\n+\n+        forceMarker.addPoint(-xRadius, -yRadius);\n+        forceMarker.addPoint(-xRadius, yRadius);\n+        forceMarker.addPoint(xRadius, yRadius);\n+        forceMarker.addPoint(xRadius, -yRadius);\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                StratconCoords currentCoords = new StratconCoords(x, y);\n+                \n+                if (currentTrack.getAssignedCoordForces().containsKey(currentCoords)) {\n+                    for (int forceID : currentTrack.getAssignedCoordForces().get(currentCoords)) {                   \n+                        g2D.setColor(Color.BLUE);\n+                        g2D.drawPolygon(forceMarker);\n+                        drawTextEffect(g2D, forceMarker, campaign.getForce(forceID).getName(), currentCoords);\n+                    }\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                forceMarker.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            forceMarker.translate(translationVector[0], translationVector[1]);\n+        }\n+    }\n+    \n+    /**\n+     * Draws some text and line to it from a given polygon. \n+     * Smart enough not to layer multiple strings on top of each other if they're all drawn in the same hex.\n+     */\n+    private void drawTextEffect(Graphics2D g2D, Polygon marker, String text, StratconCoords coords) {\n+        int verticalOffsetIndex = numIconsInHex.containsKey(coords) ? numIconsInHex.get(coords) : 0;\n+        \n+        double startX = marker.getBounds().getMaxX();\n+        double startY = marker.getBounds().getMinY();\n+        double midPointX = startX + HEX_X_RADIUS / 4;\n+        double midPointY = startY - HEX_Y_RADIUS / 4 + g2D.getFontMetrics().getHeight() * verticalOffsetIndex;\n+        double endPointX = midPointX + HEX_X_RADIUS / 2;\n+        \n+        g2D.drawLine((int) startX, (int) startY, (int) midPointX, (int) midPointY);\n+        g2D.drawLine((int) midPointX, (int) midPointY, (int) endPointX, (int) midPointY);\n+        g2D.drawString(text, (int) endPointX, (int) midPointY);\n+        \n+        // register that we drew text off of this hex\n+        verticalOffsetIndex++;\n+        numIconsInHex.put(coords, verticalOffsetIndex);\n+    }\n+\n+    /**\n+     * Returns the translation that we need to make to render the \"next downward\" hex.\n+     * @return Two dimensional array with the first element being the x vector and the second being the y vector\n+     */\n+    private int[] getDownwardYVector() {\n+        return new int[] { 0, (int) (HEX_Y_RADIUS * 2) };\n+    }\n+\n+    /**\n+     * Returns the translation that we need to make to move from the bottom of a column to the top of the next\n+     * column to the right.\n+     * @param evenColumn Whether the column we're currently in is odd or even\n+     * @return Two dimensional array with the first element being the x vector and the second being the y vector\n+     */\n+    private int[] getRightAndUPVector(boolean evenColumn) {\n+        int yRadius = (int) (HEX_Y_RADIUS);\n+        int xRadius = (int) (HEX_X_RADIUS);\n+\n+        int yTranslation = currentTrack.getHeight() * yRadius * 2;\n+        if (evenColumn) {\n+            yTranslation += yRadius;\n+        } else {\n+            yTranslation -= yRadius;\n+        }\n+\n+        return new int[] {(int) (xRadius * 1.5), -yTranslation};\n+    }\n+\n+    /**\n+     * Go to the origin of the hex board and reset the scaling.\n+     */\n+    private void performInitialTransform(Graphics2D g2D) {\n+        g2D.translate(0, 0 + HEX_Y_RADIUS);\n+        g2D.scale(scale, scale);\n+    }\n+\n+    /** \n+     * Worker function that takes the current clicked point and a graphics 2D object\n+     * and detects which hex was clicked by doing a dry run hex render.\n+     * \n+     * Dependent upon clickedPoint being set and having an active graphics object for this class.\n+     * \n+     * Side effects: the dry run sets the boardState clicked hex coordinates.\n+     * @return Whether or not the clicked point was found on the hex board\n+     */\n+    private boolean detectClickedHex() {\n+        Graphics2D g2D = (Graphics2D) getGraphics();\n+        AffineTransform transform = g2D.getTransform();\n+        performInitialTransform(g2D);\n+        boolean pointFoundOnBoard = drawHexes(g2D, DrawHexType.Dryrun);\n+        g2D.setTransform(transform);\n+\n+        return pointFoundOnBoard;\n+    }\n+\n+    /**\n+     * Event handler for when a mouse button is released.\n+     */\n+    public void mouseReleasedHandler(MouseEvent e) {\n+        if(e.getSource() != this) {\n+            return;\n+        }\n+\n+        // left button generally selects a hex\n+        if (e.getButton() == MouseEvent.BUTTON1) {        \n+            clickedPoint = e.getPoint();\n+            boolean pointFoundOnBoard = detectClickedHex();\n+            \n+            if(pointFoundOnBoard) {\n+                infoArea.setText(buildSelectedHexInfo());\n+            }\n+\n+            repaint();\n+        // right button generally pops up a context menu\n+        } else if (e.getButton() == MouseEvent.BUTTON3) {\n+            clickedPoint = e.getPoint();\n+            detectClickedHex();\n+            \n+            StratconCoords selectedCoords = boardState.getSelectedCoords();\n+            if (selectedCoords == null) {\n+                return;\n+            }\n+            \n+            repaint();\n+            buildRightClickMenu(selectedCoords);\n+            rightClickMenu.show(this, e.getX(), e.getY());\n+        }\n+    }\n+    \n+    public StratconScenario getSelectedScenario() {\n+        return currentTrack.getScenario(boardState.getSelectedCoords());\n+    }\n+    \n+    /**\n+     * Worker function that outputs html representing the status of a selected hex,\n+     * containing info such as whether it's been revealed, assigned forces, scenarios, facilities, etc.\n+     */\n+    private String buildSelectedHexInfo() {\n+        StringBuilder infoBuilder = new StringBuilder();\n+        infoBuilder.append(\"<html><br/>\");\n+        \n+        boolean coordsRevealed = currentTrack.getRevealedCoords().contains(boardState.getSelectedCoords());\n+        if (coordsRevealed) {\n+            infoBuilder.append(\"<span color='green'>Recon complete</span><br/>\");\n+        }\n+        \n+        if (currentTrack.getAssignedCoordForces().containsKey(boardState.getSelectedCoords())) {\n+            for (int forceID : currentTrack.getAssignedCoordForces().get(boardState.getSelectedCoords())) {\n+                Force force = campaign.getForce(forceID);\n+                infoBuilder.append(force.getName()).append(\" assigned\");\n+                \n+                if (currentTrack.getStickyForces().contains(forceID)) {\n+                    infoBuilder.append(\" - remain deployed\");\n+                }\n+                \n+                infoBuilder.append(\"<br/>\");\n+                \n+                infoBuilder.append(\"Returns on \").append(currentTrack.getAssignedForceReturnDates().get(forceID));\n+                infoBuilder.append(\"<br/>\");\n+            }\n+        }\n+        \n+        if (coordsRevealed || currentTrack.isGmRevealed()) {\n+            StratconFacility facility = currentTrack.getFacility(boardState.getSelectedCoords());\n+            \n+            if((facility != null) && (facility.getFacilityType() != null)) {\n+                if (facility.isStrategicObjective()) {\n+                    infoBuilder.append(String.format(\"<br/><span color='%s'>Contract objective located</span>\", \n+                            facility.getOwner() == ForceAlignment.Allied ? \"green\" : \"red\"));\n+                }\n+                infoBuilder.append((facility.getOwner() == ForceAlignment.Allied) ? \"<span color='green'>\" : \"<span color='red'>\");\n+                infoBuilder.append(\"<br/>\");\n+                infoBuilder.append(facility.getFormattedDisplayableName());\n+                infoBuilder.append(\"<span>\");\n+            }\n+            \n+        } else {\n+            infoBuilder.append(\"<span color='red'>Recon incomplete</span>\");\n+        }\n+        infoBuilder.append(\"<br/>\");\n+        \n+        \n+        StratconScenario selectedScenario = getSelectedScenario();\n+        if ((selectedScenario != null) &&\n+                ((selectedScenario.getDeploymentDate() != null) || currentTrack.isGmRevealed())) {\n+            infoBuilder.append(selectedScenario.getInfo());\n+        }\n+        \n+        infoBuilder.append(\"</html>\");\n+        \n+        return infoBuilder.toString();\n+    }\n+\n+    /**\n+     * Data structure containing current state of the board.\n+     */\n+    private static class BoardState {\n+        public Integer selectedX;\n+        public Integer selectedY;\n+        \n+        public StratconCoords getSelectedCoords() {\n+            if((selectedX == null) || (selectedY == null)) {\n+                return null;\n+            } else {\n+                return new StratconCoords(selectedX, selectedY);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Event handler for various button and menu item presses.\n+     */\n+    @Override\n+    public void actionPerformed(ActionEvent e) {\n+        StratconCoords selectedCoords = boardState.getSelectedCoords();\n+        if(selectedCoords == null) {\n+            return;\n+        }\n+        \n+        switch(e.getActionCommand()) {\n+        case RCLICK_COMMAND_MANAGE_FORCES:\n+            assignmentUI.display(campaign, campaignState, 0, selectedCoords);\n+            assignmentUI.setVisible(true);\n+            break;\n+        case RCLICK_COMMAND_MANAGE_SCENARIO:\n+            scenarioWizard.setCurrentScenario(currentTrack.getScenario(selectedCoords),\n+                    currentTrack,\n+                    campaignState);\n+            scenarioWizard.toFront();\n+            scenarioWizard.setVisible(true);\n+            break;\n+        case RCLICK_COMMAND_REVEAL_TRACK:\n+            currentTrack.setGmRevealed(!currentTrack.isGmRevealed());\n+            menuItemGMReveal.setText(currentTrack.isGmRevealed() ? \"Hide Track\" : \"Reveal Track\");\n+            break;\n+        case RCLICK_COMMAND_STICKY_FORCE:\n+            JCheckBoxMenuItem source = (JCheckBoxMenuItem) e.getSource();\n+            int forceID = (int) source.getClientProperty(RCLICK_COMMAND_STICKY_FORCE_ID);\n+            \n+            if (source.isSelected()) {\n+                currentTrack.addStickyForce(forceID);\n+            } else {\n+                currentTrack.removeStickyForce(forceID);\n+            }\n+            \n+            break;\n+        }\n+        \n+        repaint();\n+    }\n+\n+    @Override\n+    public Dimension getPreferredSize() {\n+        if(currentTrack != null) {", "originalCommit": "796b6728fd3cd2aea02d17122b4d735afc47dc41", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjkwMjY5OQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r602902699", "bodyText": "Improve the rounding by using a rounding method", "author": "Windchild292", "createdAt": "2021-03-28T16:52:46Z", "path": "MekHQ/src/mekhq/gui/StratconPanel.java", "diffHunk": "@@ -0,0 +1,672 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.gui;\n+\n+import java.awt.BasicStroke;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Point;\n+import java.awt.Polygon;\n+import java.awt.Stroke;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.awt.geom.AffineTransform;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import javax.swing.JCheckBoxMenuItem;\n+import javax.swing.JLabel;\n+import javax.swing.JMenuItem;\n+import javax.swing.JPanel;\n+import javax.swing.JPopupMenu;\n+import javax.swing.SwingUtilities;\n+\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.stratcon.StratconCampaignState;\n+import mekhq.campaign.stratcon.StratconCoords;\n+import mekhq.campaign.stratcon.StratconFacility;\n+import mekhq.campaign.stratcon.StratconScenario;\n+import mekhq.campaign.stratcon.StratconTrackState;\n+import mekhq.gui.stratcon.StratconScenarioWizard;\n+import mekhq.gui.stratcon.TrackForceAssignmentUI;\n+\n+/**\n+ * This panel handles AtB-Stratcon GUI interactions with a specific scenario track.\n+ * @author NickAragua\n+ */\n+public class StratconPanel extends JPanel implements ActionListener {\n+    /**\n+     * \n+     */\n+    private static final long serialVersionUID = 7405934788894417292L;\n+    \n+    public static final int HEX_X_RADIUS = 42;\n+    public static final int HEX_Y_RADIUS = 37;\n+    \n+    private static final String RCLICK_COMMAND_MANAGE_FORCES = \"ManageForces\";\n+    private static final String RCLICK_COMMAND_MANAGE_SCENARIO = \"ManageScenario\";\n+    private static final String RCLICK_COMMAND_REVEAL_TRACK = \"RevealTrack\";\n+    private static final String RCLICK_COMMAND_STICKY_FORCE = \"StickyForce\";\n+    private static final String RCLICK_COMMAND_STICKY_FORCE_ID = \"StickyForceID\";\n+\n+    /**\n+     * What to do when drawing a hex\n+     */\n+    private enum DrawHexType {\n+        /**\n+         * The interior of a hex\n+         */\n+        Hex,\n+        \n+        /**\n+         * The outline of a hex\n+         */\n+        Outline,\n+        \n+        /**\n+         * Pretend we're drawing a hex, but don't actually do it, useful for \n+         * figuring out which hex a mouse click landed in, etc.\n+         */\n+        Dryrun\n+    }\n+\n+    private float scale = 1f;\n+\n+    private StratconTrackState currentTrack;\n+    private StratconCampaignState campaignState;\n+    private Campaign campaign;\n+\n+    private BoardState boardState = new BoardState();\n+\n+    private Point clickedPoint;\n+    private JPopupMenu rightClickMenu;\n+    private JMenuItem menuItemManageForceAssignments;\n+    private JMenuItem menuItemManageScenario;\n+    private JMenuItem menuItemGMReveal;\n+    \n+    // data structure holding how many unit/scenario/base icons have been drawn in the hex\n+    // used to control how low the text description goes.\n+    private Map<StratconCoords, Integer> numIconsInHex = new HashMap<>();\n+    \n+    private StratconScenarioWizard scenarioWizard;\n+    private TrackForceAssignmentUI assignmentUI;\n+    \n+    private JLabel infoArea;\n+\n+    /**\n+     * Constructs a StratconPanel instance, given a parent campaign GUI and a pointer to an info area.\n+     */\n+    StratconPanel(CampaignGUI gui, JLabel infoArea) {\n+        campaign = gui.getCampaign();\n+        scenarioWizard = new StratconScenarioWizard(campaign);\n+        this.infoArea = infoArea;\n+        \n+        assignmentUI = new TrackForceAssignmentUI(this);\n+        assignmentUI.setVisible(false);\n+        \n+        addMouseListener(new MouseAdapter() {\n+            @Override\n+            public void mouseReleased(MouseEvent e) {\n+                mouseReleasedHandler(e);\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Handler for when a specific track is selected - switches rendering to that track.\n+     */\n+    public void selectTrack(StratconCampaignState campaignState, StratconTrackState track) {\n+        this.campaignState = campaignState;\n+        currentTrack = track;\n+        repaint();\n+    }\n+    \n+    /**\n+     * Constructs the right-click context menu, optionally for a scenario\n+     */\n+    private void buildRightClickMenu(StratconCoords coords) {\n+        rightClickMenu = new JPopupMenu();\n+        \n+        StratconScenario scenario = getSelectedScenario();\n+        \n+        if (scenario == null) {\n+            menuItemManageForceAssignments = new JMenuItem();\n+            menuItemManageForceAssignments.setText(\"Manage Force Assignments\");\n+            menuItemManageForceAssignments.setActionCommand(RCLICK_COMMAND_MANAGE_FORCES);\n+            menuItemManageForceAssignments.addActionListener(this);\n+            rightClickMenu.add(menuItemManageForceAssignments);\n+        }\n+        \n+        if (scenario != null) {\n+            menuItemManageScenario = new JMenuItem();\n+            menuItemManageScenario.setText(\"Manage Scenario\");\n+            menuItemManageScenario.setActionCommand(RCLICK_COMMAND_MANAGE_SCENARIO);\n+            menuItemManageScenario.addActionListener(this);\n+            rightClickMenu.add(menuItemManageScenario);\n+        }\n+        \n+        if ((currentTrack != null) && currentTrack.getAssignedCoordForces().containsKey(coords)) {\n+            for (int forceID : currentTrack.getAssignedCoordForces().get(coords)) {\n+                String forceName = campaign.getForce(forceID).getName();\n+                \n+                JCheckBoxMenuItem stickyForceItem = new JCheckBoxMenuItem();\n+                stickyForceItem.setText(String.format(\"%s - remain deployed\", forceName));\n+                stickyForceItem.setActionCommand(RCLICK_COMMAND_STICKY_FORCE);\n+                stickyForceItem.putClientProperty(RCLICK_COMMAND_STICKY_FORCE_ID, forceID);\n+                stickyForceItem.addActionListener(this);\n+                stickyForceItem.setSelected(currentTrack.getStickyForces().contains(forceID));\n+                rightClickMenu.add(stickyForceItem);\n+            }\n+        }\n+            \n+        if ((currentTrack != null) && campaign.isGM()) {\n+            rightClickMenu.addSeparator();\n+            \n+            menuItemGMReveal = new JMenuItem();\n+            menuItemGMReveal.setText(currentTrack.isGmRevealed() ? \"Hide Track\" : \"Reveal Track\");\n+            menuItemGMReveal.setActionCommand(RCLICK_COMMAND_REVEAL_TRACK);\n+            menuItemGMReveal.addActionListener(this);\n+            rightClickMenu.add(menuItemGMReveal);\n+        }\n+    }\n+\n+    /**\n+     * Renders the panel, hexes, forces, facilities and all that.\n+     */\n+    @Override\n+    public void paintComponent(Graphics g) {\n+        super.paintComponent(g);\n+        if (campaignState == null || currentTrack == null) {\n+            return;\n+        }\n+        \n+        numIconsInHex.clear();\n+\n+        Graphics2D g2D = (Graphics2D) g;\n+        AffineTransform initialTransform = g2D.getTransform();\n+        performInitialTransform(g2D);\n+        AffineTransform originTransform = g2D.getTransform();\n+\n+        drawHexes(g2D, DrawHexType.Hex);\n+        g2D.setTransform(originTransform);\n+        drawHexes(g2D, DrawHexType.Outline);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawScenarios(g2D);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawFacilities(g2D);\n+        g2D.setTransform(originTransform);\n+        g2D.translate(HEX_X_RADIUS, HEX_Y_RADIUS);\n+        drawForces(g2D);\n+\n+        g2D.setTransform(initialTransform);\n+        if (clickedPoint != null) {\n+            g2D.setColor(Color.BLUE);\n+            g2D.drawRect((int) clickedPoint.getX(), (int) clickedPoint.getY(), 2, 2);\n+        }\n+    }\n+\n+    /**\n+     * This method contains a dirty secret hack, but I forget what it is.\n+     * The point of it is to draw all the hexes for the board. \n+     * If it's a \"dry run\", we don't actually draw the hexes, we just pretend to\n+     * until we \"draw\" one that encompasses the clicked point.\n+     * @param g2D - graphics object on which to draw\n+     * @param drawHexType - whether to draw the hex backgrounds, hex outlines or a dry run for click detection\n+     */\n+    private boolean drawHexes(Graphics2D g2D, DrawHexType drawHexType) {\n+        Polygon graphHex = new Polygon();\n+        int xRadius = HEX_X_RADIUS;\n+        int yRadius = HEX_Y_RADIUS;\n+        boolean pointFound = false;\n+\n+        graphHex.addPoint(-xRadius/2, -yRadius);\n+        graphHex.addPoint(-xRadius, 0);\n+        graphHex.addPoint(-xRadius/2, yRadius);\n+        graphHex.addPoint(xRadius/2, yRadius);\n+        graphHex.addPoint(xRadius, 0);\n+        graphHex.addPoint(xRadius/2, -yRadius);\n+\n+        graphHex.translate(xRadius, yRadius);\n+\n+        Point translatedClickedPoint = null;\n+\n+        // this was derived somewhat experimentally\n+        // the clicked point always seems a little off, so we \n+        // a) apply the current transform to it, prior to drawing all the hexes\n+        // b) subtract an additional Y_RADIUS x 2 (Y_DIAMETER)\n+        // this gets us the point within the clicked hex\n+        // it's probably finicky, so any major changes to the rendering mechanism will likely break the detection\n+        if (clickedPoint != null) {\n+            translatedClickedPoint = (Point) clickedPoint.clone();\n+            \n+            // since we have the possibility of scrolling, we need to convert the on-screen clicked coordinates\n+            // to on-board coordinates. Thankfully, SwingUtilities provides the main computational ability for that\n+            Point actualPanelPoint = SwingUtilities.convertPoint(this, translatedClickedPoint, this.getParent());\n+            translatedClickedPoint.translate((int) -(actualPanelPoint.getX() - translatedClickedPoint.getX()), \n+                                                (int) -(actualPanelPoint.getY() - translatedClickedPoint.getY()));\n+            \n+            // now we translate to the starting point of where we're drawing and then go down a hex\n+            translatedClickedPoint.translate((int) g2D.getTransform().getTranslateX(), (int) g2D.getTransform().getTranslateY());\n+            translatedClickedPoint.translate(0, -(HEX_Y_RADIUS * 2));\n+        }\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                if(drawHexType == DrawHexType.Outline) {\n+                    g2D.setColor(new Color(0, 0, 0));\n+                    g2D.drawPolygon(graphHex);                    \n+                } else if (drawHexType == DrawHexType.Hex) {\n+                    \n+                    if (currentTrack.coordsRevealed(x, y) || currentTrack.isGmRevealed()) {\n+                        g2D.setColor(Color.LIGHT_GRAY);\n+                    } else {\n+                        g2D.setColor(Color.DARK_GRAY);\n+                    }\n+                    g2D.fillPolygon(graphHex);\n+                    \n+                    if (translatedClickedPoint != null && graphHex.contains(translatedClickedPoint)) {\n+                        g2D.setColor(Color.WHITE);\n+                        BasicStroke s = new BasicStroke((float) 8.0);\n+                        Stroke push = g2D.getStroke();\n+                        g2D.setStroke(s);\n+                        g2D.drawPolygon(graphHex);\n+                        \n+                        boardState.selectedX = x;\n+                        boardState.selectedY = y;\n+                        pointFound = true;\n+                        g2D.setStroke(push);\n+                    }\n+                } else if (drawHexType == DrawHexType.Dryrun) {\n+                    if (translatedClickedPoint != null && graphHex.contains(translatedClickedPoint)) {\n+                        boardState.selectedX = x;\n+                        boardState.selectedY = y;\n+                        pointFound = true;\n+                    }\n+                }\n+\n+                if (drawHexType == DrawHexType.Hex) {\n+                    g2D.setColor(Color.GREEN);\n+                    g2D.drawString(x + \",\" + y, graphHex.xpoints[0] + (xRadius / 4), graphHex.ypoints[0] + yRadius);\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                graphHex.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            graphHex.translate(translationVector[0], translationVector[1]);\n+        }\n+\n+        return pointFound;\n+    }\n+\n+    /**\n+     * Worker function to render icons representing scenarios to the given surface.\n+     */\n+    private void drawScenarios(Graphics2D g2D) {\n+        Polygon scenarioMarker = new Polygon();\n+        int xRadius = HEX_X_RADIUS / 3;\n+        int yRadius = HEX_Y_RADIUS / 3;\n+\n+        scenarioMarker.addPoint(-xRadius, -yRadius);\n+        scenarioMarker.addPoint(-xRadius, yRadius);\n+        scenarioMarker.addPoint(xRadius, yRadius);\n+        scenarioMarker.addPoint(xRadius, -yRadius);\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                StratconCoords currentCoords = new StratconCoords(x, y);\n+                StratconScenario scenario = currentTrack.getScenario(currentCoords);\n+                \n+                // if there's a scenario here that has a deployment/battle date\n+                // or if there's a scenario here and we've gm-revealed everything\n+                if ((scenario != null) &&\n+                        ((scenario.getDeploymentDate() != null) || currentTrack.isGmRevealed())) {\n+                    g2D.setColor(Color.RED);\n+                    g2D.drawPolygon(scenarioMarker);\n+                    if(currentTrack.getFacility(currentCoords) == null) {\n+                        drawTextEffect(g2D, scenarioMarker, \"Hostile Force Detected\", currentCoords);\n+                    }\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                scenarioMarker.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            scenarioMarker.translate(translationVector[0], translationVector[1]);\n+        }\n+    }\n+    \n+    /**\n+     * Worker function to render facility icons to the given surface.\n+     */\n+    private void drawFacilities(Graphics2D g2D) {\n+        Polygon facilityMarker = new Polygon();\n+        int xRadius = HEX_X_RADIUS / 3;\n+        int yRadius = HEX_Y_RADIUS / 3;\n+\n+        facilityMarker.addPoint(-xRadius, -yRadius);\n+        facilityMarker.addPoint(-xRadius, yRadius);\n+        facilityMarker.addPoint(xRadius, yRadius);\n+        facilityMarker.addPoint(xRadius, -yRadius);\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                StratconCoords currentCoords = new StratconCoords(x, y);\n+                StratconFacility facility = currentTrack.getFacility(currentCoords);\n+                \n+                if ((facility != null) && (facility.isVisible() || currentTrack.isGmRevealed())) {\n+                    g2D.setColor(facility.getOwner() == ForceAlignment.Allied ? Color.GREEN : Color.RED);\n+                    g2D.drawPolygon(facilityMarker);\n+                    drawTextEffect(g2D, facilityMarker, facility.getFormattedDisplayableName(), currentCoords);\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                facilityMarker.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            facilityMarker.translate(translationVector[0], translationVector[1]);\n+        }\n+    }\n+    \n+    /**\n+     * Worker function to render force icons to the given surface.\n+     */\n+    private void drawForces(Graphics2D g2D) {\n+        Polygon forceMarker = new Polygon();\n+        int xRadius = HEX_X_RADIUS / 3;\n+        int yRadius = HEX_Y_RADIUS / 3;\n+\n+        forceMarker.addPoint(-xRadius, -yRadius);\n+        forceMarker.addPoint(-xRadius, yRadius);\n+        forceMarker.addPoint(xRadius, yRadius);\n+        forceMarker.addPoint(xRadius, -yRadius);\n+\n+        for (int x = 0; x < currentTrack.getWidth(); x++) {            \n+            for (int y = 0; y < currentTrack.getHeight(); y++) {\n+                StratconCoords currentCoords = new StratconCoords(x, y);\n+                \n+                if (currentTrack.getAssignedCoordForces().containsKey(currentCoords)) {\n+                    for (int forceID : currentTrack.getAssignedCoordForces().get(currentCoords)) {                   \n+                        g2D.setColor(Color.BLUE);\n+                        g2D.drawPolygon(forceMarker);\n+                        drawTextEffect(g2D, forceMarker, campaign.getForce(forceID).getName(), currentCoords);\n+                    }\n+                }\n+\n+                int[] downwardVector = getDownwardYVector();\n+                forceMarker.translate(downwardVector[0], downwardVector[1]);\n+            }\n+\n+            int[] translationVector = getRightAndUPVector(x % 2 == 0);\n+            forceMarker.translate(translationVector[0], translationVector[1]);\n+        }\n+    }\n+    \n+    /**\n+     * Draws some text and line to it from a given polygon. \n+     * Smart enough not to layer multiple strings on top of each other if they're all drawn in the same hex.\n+     */\n+    private void drawTextEffect(Graphics2D g2D, Polygon marker, String text, StratconCoords coords) {\n+        int verticalOffsetIndex = numIconsInHex.containsKey(coords) ? numIconsInHex.get(coords) : 0;\n+        \n+        double startX = marker.getBounds().getMaxX();\n+        double startY = marker.getBounds().getMinY();\n+        double midPointX = startX + HEX_X_RADIUS / 4;\n+        double midPointY = startY - HEX_Y_RADIUS / 4 + g2D.getFontMetrics().getHeight() * verticalOffsetIndex;\n+        double endPointX = midPointX + HEX_X_RADIUS / 2;\n+        \n+        g2D.drawLine((int) startX, (int) startY, (int) midPointX, (int) midPointY);\n+        g2D.drawLine((int) midPointX, (int) midPointY, (int) endPointX, (int) midPointY);\n+        g2D.drawString(text, (int) endPointX, (int) midPointY);\n+        \n+        // register that we drew text off of this hex\n+        verticalOffsetIndex++;\n+        numIconsInHex.put(coords, verticalOffsetIndex);\n+    }\n+\n+    /**\n+     * Returns the translation that we need to make to render the \"next downward\" hex.\n+     * @return Two dimensional array with the first element being the x vector and the second being the y vector\n+     */\n+    private int[] getDownwardYVector() {\n+        return new int[] { 0, (int) (HEX_Y_RADIUS * 2) };\n+    }\n+\n+    /**\n+     * Returns the translation that we need to make to move from the bottom of a column to the top of the next\n+     * column to the right.\n+     * @param evenColumn Whether the column we're currently in is odd or even\n+     * @return Two dimensional array with the first element being the x vector and the second being the y vector\n+     */\n+    private int[] getRightAndUPVector(boolean evenColumn) {\n+        int yRadius = (int) (HEX_Y_RADIUS);\n+        int xRadius = (int) (HEX_X_RADIUS);\n+\n+        int yTranslation = currentTrack.getHeight() * yRadius * 2;\n+        if (evenColumn) {\n+            yTranslation += yRadius;\n+        } else {\n+            yTranslation -= yRadius;\n+        }\n+\n+        return new int[] {(int) (xRadius * 1.5), -yTranslation};\n+    }\n+\n+    /**\n+     * Go to the origin of the hex board and reset the scaling.\n+     */\n+    private void performInitialTransform(Graphics2D g2D) {\n+        g2D.translate(0, 0 + HEX_Y_RADIUS);\n+        g2D.scale(scale, scale);\n+    }\n+\n+    /** \n+     * Worker function that takes the current clicked point and a graphics 2D object\n+     * and detects which hex was clicked by doing a dry run hex render.\n+     * \n+     * Dependent upon clickedPoint being set and having an active graphics object for this class.\n+     * \n+     * Side effects: the dry run sets the boardState clicked hex coordinates.\n+     * @return Whether or not the clicked point was found on the hex board\n+     */\n+    private boolean detectClickedHex() {\n+        Graphics2D g2D = (Graphics2D) getGraphics();\n+        AffineTransform transform = g2D.getTransform();\n+        performInitialTransform(g2D);\n+        boolean pointFoundOnBoard = drawHexes(g2D, DrawHexType.Dryrun);\n+        g2D.setTransform(transform);\n+\n+        return pointFoundOnBoard;\n+    }\n+\n+    /**\n+     * Event handler for when a mouse button is released.\n+     */\n+    public void mouseReleasedHandler(MouseEvent e) {\n+        if(e.getSource() != this) {\n+            return;\n+        }\n+\n+        // left button generally selects a hex\n+        if (e.getButton() == MouseEvent.BUTTON1) {        \n+            clickedPoint = e.getPoint();\n+            boolean pointFoundOnBoard = detectClickedHex();\n+            \n+            if(pointFoundOnBoard) {\n+                infoArea.setText(buildSelectedHexInfo());\n+            }\n+\n+            repaint();\n+        // right button generally pops up a context menu\n+        } else if (e.getButton() == MouseEvent.BUTTON3) {\n+            clickedPoint = e.getPoint();\n+            detectClickedHex();\n+            \n+            StratconCoords selectedCoords = boardState.getSelectedCoords();\n+            if (selectedCoords == null) {\n+                return;\n+            }\n+            \n+            repaint();\n+            buildRightClickMenu(selectedCoords);\n+            rightClickMenu.show(this, e.getX(), e.getY());\n+        }\n+    }\n+    \n+    public StratconScenario getSelectedScenario() {\n+        return currentTrack.getScenario(boardState.getSelectedCoords());\n+    }\n+    \n+    /**\n+     * Worker function that outputs html representing the status of a selected hex,\n+     * containing info such as whether it's been revealed, assigned forces, scenarios, facilities, etc.\n+     */\n+    private String buildSelectedHexInfo() {\n+        StringBuilder infoBuilder = new StringBuilder();\n+        infoBuilder.append(\"<html><br/>\");\n+        \n+        boolean coordsRevealed = currentTrack.getRevealedCoords().contains(boardState.getSelectedCoords());\n+        if (coordsRevealed) {\n+            infoBuilder.append(\"<span color='green'>Recon complete</span><br/>\");\n+        }\n+        \n+        if (currentTrack.getAssignedCoordForces().containsKey(boardState.getSelectedCoords())) {\n+            for (int forceID : currentTrack.getAssignedCoordForces().get(boardState.getSelectedCoords())) {\n+                Force force = campaign.getForce(forceID);\n+                infoBuilder.append(force.getName()).append(\" assigned\");\n+                \n+                if (currentTrack.getStickyForces().contains(forceID)) {\n+                    infoBuilder.append(\" - remain deployed\");\n+                }\n+                \n+                infoBuilder.append(\"<br/>\");\n+                \n+                infoBuilder.append(\"Returns on \").append(currentTrack.getAssignedForceReturnDates().get(forceID));\n+                infoBuilder.append(\"<br/>\");\n+            }\n+        }\n+        \n+        if (coordsRevealed || currentTrack.isGmRevealed()) {\n+            StratconFacility facility = currentTrack.getFacility(boardState.getSelectedCoords());\n+            \n+            if((facility != null) && (facility.getFacilityType() != null)) {\n+                if (facility.isStrategicObjective()) {\n+                    infoBuilder.append(String.format(\"<br/><span color='%s'>Contract objective located</span>\", \n+                            facility.getOwner() == ForceAlignment.Allied ? \"green\" : \"red\"));\n+                }\n+                infoBuilder.append((facility.getOwner() == ForceAlignment.Allied) ? \"<span color='green'>\" : \"<span color='red'>\");\n+                infoBuilder.append(\"<br/>\");\n+                infoBuilder.append(facility.getFormattedDisplayableName());\n+                infoBuilder.append(\"<span>\");\n+            }\n+            \n+        } else {\n+            infoBuilder.append(\"<span color='red'>Recon incomplete</span>\");\n+        }\n+        infoBuilder.append(\"<br/>\");\n+        \n+        \n+        StratconScenario selectedScenario = getSelectedScenario();\n+        if ((selectedScenario != null) &&\n+                ((selectedScenario.getDeploymentDate() != null) || currentTrack.isGmRevealed())) {\n+            infoBuilder.append(selectedScenario.getInfo());\n+        }\n+        \n+        infoBuilder.append(\"</html>\");\n+        \n+        return infoBuilder.toString();\n+    }\n+\n+    /**\n+     * Data structure containing current state of the board.\n+     */\n+    private static class BoardState {\n+        public Integer selectedX;\n+        public Integer selectedY;\n+        \n+        public StratconCoords getSelectedCoords() {\n+            if((selectedX == null) || (selectedY == null)) {\n+                return null;\n+            } else {\n+                return new StratconCoords(selectedX, selectedY);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Event handler for various button and menu item presses.\n+     */\n+    @Override\n+    public void actionPerformed(ActionEvent e) {\n+        StratconCoords selectedCoords = boardState.getSelectedCoords();\n+        if(selectedCoords == null) {\n+            return;\n+        }\n+        \n+        switch(e.getActionCommand()) {\n+        case RCLICK_COMMAND_MANAGE_FORCES:\n+            assignmentUI.display(campaign, campaignState, 0, selectedCoords);\n+            assignmentUI.setVisible(true);\n+            break;\n+        case RCLICK_COMMAND_MANAGE_SCENARIO:\n+            scenarioWizard.setCurrentScenario(currentTrack.getScenario(selectedCoords),\n+                    currentTrack,\n+                    campaignState);\n+            scenarioWizard.toFront();\n+            scenarioWizard.setVisible(true);\n+            break;\n+        case RCLICK_COMMAND_REVEAL_TRACK:\n+            currentTrack.setGmRevealed(!currentTrack.isGmRevealed());\n+            menuItemGMReveal.setText(currentTrack.isGmRevealed() ? \"Hide Track\" : \"Reveal Track\");\n+            break;\n+        case RCLICK_COMMAND_STICKY_FORCE:\n+            JCheckBoxMenuItem source = (JCheckBoxMenuItem) e.getSource();\n+            int forceID = (int) source.getClientProperty(RCLICK_COMMAND_STICKY_FORCE_ID);\n+            \n+            if (source.isSelected()) {\n+                currentTrack.addStickyForce(forceID);\n+            } else {\n+                currentTrack.removeStickyForce(forceID);\n+            }\n+            \n+            break;\n+        }\n+        \n+        repaint();\n+    }\n+\n+    @Override\n+    public Dimension getPreferredSize() {\n+        if(currentTrack != null) {\n+            int xDimension = (int) (HEX_X_RADIUS * 1.75 * currentTrack.getWidth());\n+            int yDimension = (int) (HEX_Y_RADIUS * 2.1 * currentTrack.getHeight());", "originalCommit": "796b6728fd3cd2aea02d17122b4d735afc47dc41", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjkwMjc2MQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r602902761", "bodyText": "Useless, get rid of it", "author": "Windchild292", "createdAt": "2021-03-28T16:53:21Z", "path": "MekHQ/src/mekhq/gui/StratconTab.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+\n+package mekhq.gui;\n+\n+import java.awt.GridBagConstraints;\n+import java.awt.GridBagLayout;\n+import java.awt.event.ItemEvent;\n+import java.awt.event.ItemListener;\n+import java.util.Objects;\n+\n+import javax.swing.JComboBox;\n+import javax.swing.JLabel;\n+import javax.swing.JPanel;\n+import javax.swing.JScrollPane;\n+\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.campaign.event.MissionCompletedEvent;\n+import mekhq.campaign.event.MissionRemovedEvent;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.stratcon.StratconCampaignState;\n+import mekhq.campaign.stratcon.StratconTrackState;\n+\n+public class StratconTab extends CampaignGuiTab {\n+    /**\n+     * \n+     */", "originalCommit": "796b6728fd3cd2aea02d17122b4d735afc47dc41", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjkwMjc3NA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r602902774", "bodyText": "Thoughts on this TODO?", "author": "Windchild292", "createdAt": "2021-03-28T16:53:31Z", "path": "MekHQ/src/mekhq/gui/StratconTab.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+\n+package mekhq.gui;\n+\n+import java.awt.GridBagConstraints;\n+import java.awt.GridBagLayout;\n+import java.awt.event.ItemEvent;\n+import java.awt.event.ItemListener;\n+import java.util.Objects;\n+\n+import javax.swing.JComboBox;\n+import javax.swing.JLabel;\n+import javax.swing.JPanel;\n+import javax.swing.JScrollPane;\n+\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.campaign.event.MissionCompletedEvent;\n+import mekhq.campaign.event.MissionRemovedEvent;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.stratcon.StratconCampaignState;\n+import mekhq.campaign.stratcon.StratconTrackState;\n+\n+public class StratconTab extends CampaignGuiTab {\n+    /**\n+     * \n+     */\n+    private static final long serialVersionUID = 8179754409939346465L;\n+    \n+    private StratconPanel stratconPanel;\n+    private JPanel infoPanel;\n+    private JComboBox<TrackDropdownItem> cboCurrentTrack;\n+    private JLabel infoPanelText;\n+    private JLabel campaignStatusText;\n+\n+    /**\n+     * Creates an instance of the StratconTab.\n+     */\n+    StratconTab(CampaignGUI gui, String tabName) {\n+        super(gui, tabName);\n+    }\n+\n+    /**\n+     * Override of the base initTab method. Populates the tab.\n+     */\n+    @Override\n+    public void initTab() { \n+        removeAll();\n+        \n+        infoPanelText = new JLabel();\n+        campaignStatusText = new JLabel();\n+        \n+        setLayout(new GridBagLayout());\n+        GridBagConstraints gbc = new GridBagConstraints();\n+        gbc.gridx = 0;\n+        gbc.gridy = 0;\n+        gbc.gridwidth = 4;\n+        gbc.fill = GridBagConstraints.BOTH;\n+        gbc.anchor = GridBagConstraints.WEST;\n+        gbc.ipadx = 5;\n+        stratconPanel = new StratconPanel(getCampaignGui(), infoPanelText);\n+        JScrollPane scrollPane = new JScrollPane(stratconPanel);\n+        scrollPane.getHorizontalScrollBar().setUnitIncrement(StratconPanel.HEX_X_RADIUS);\n+        scrollPane.getVerticalScrollBar().setUnitIncrement(StratconPanel.HEX_Y_RADIUS);\n+        this.add(scrollPane, gbc);\n+        \n+        // TODO: lance role assignment UI here?", "originalCommit": "796b6728fd3cd2aea02d17122b4d735afc47dc41", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjkwODcwMw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r602908703", "bodyText": "Going to take a pass on it for this PR.", "author": "NickAragua", "createdAt": "2021-03-28T17:45:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjkwMjc3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjkwMjg0Mw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r602902843", "bodyText": "Formatting oddity, maybe tab spaced?", "author": "Windchild292", "createdAt": "2021-03-28T16:54:03Z", "path": "MekHQ/src/mekhq/gui/StratconTab.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+\n+package mekhq.gui;\n+\n+import java.awt.GridBagConstraints;\n+import java.awt.GridBagLayout;\n+import java.awt.event.ItemEvent;\n+import java.awt.event.ItemListener;\n+import java.util.Objects;\n+\n+import javax.swing.JComboBox;\n+import javax.swing.JLabel;\n+import javax.swing.JPanel;\n+import javax.swing.JScrollPane;\n+\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.campaign.event.MissionCompletedEvent;\n+import mekhq.campaign.event.MissionRemovedEvent;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.stratcon.StratconCampaignState;\n+import mekhq.campaign.stratcon.StratconTrackState;\n+\n+public class StratconTab extends CampaignGuiTab {\n+    /**\n+     * \n+     */\n+    private static final long serialVersionUID = 8179754409939346465L;\n+    \n+    private StratconPanel stratconPanel;\n+    private JPanel infoPanel;\n+    private JComboBox<TrackDropdownItem> cboCurrentTrack;\n+    private JLabel infoPanelText;\n+    private JLabel campaignStatusText;\n+\n+    /**\n+     * Creates an instance of the StratconTab.\n+     */\n+    StratconTab(CampaignGUI gui, String tabName) {\n+        super(gui, tabName);\n+    }\n+\n+    /**\n+     * Override of the base initTab method. Populates the tab.\n+     */\n+    @Override\n+    public void initTab() { \n+        removeAll();\n+        \n+        infoPanelText = new JLabel();\n+        campaignStatusText = new JLabel();\n+        \n+        setLayout(new GridBagLayout());\n+        GridBagConstraints gbc = new GridBagConstraints();\n+        gbc.gridx = 0;\n+        gbc.gridy = 0;\n+        gbc.gridwidth = 4;\n+        gbc.fill = GridBagConstraints.BOTH;\n+        gbc.anchor = GridBagConstraints.WEST;\n+        gbc.ipadx = 5;\n+        stratconPanel = new StratconPanel(getCampaignGui(), infoPanelText);\n+        JScrollPane scrollPane = new JScrollPane(stratconPanel);\n+        scrollPane.getHorizontalScrollBar().setUnitIncrement(StratconPanel.HEX_X_RADIUS);\n+        scrollPane.getVerticalScrollBar().setUnitIncrement(StratconPanel.HEX_Y_RADIUS);\n+        this.add(scrollPane, gbc);\n+        \n+        // TODO: lance role assignment UI here?\n+        \n+        initializeInfoPanel();\n+        gbc.gridx = 4;\n+        gbc.gridwidth = 1;\n+        gbc.anchor = GridBagConstraints.NORTH;\n+        this.add(infoPanel, gbc);\n+        \n+        MekHQ.registerHandler(this);\n+    }\n+\n+    /**\n+     * Worker function that sets up the layout of the right-side info panel.\n+     */\n+    private void initializeInfoPanel() {\n+        infoPanel = new JPanel();        \n+        infoPanel.setLayout(new GridBagLayout()); \n+        GridBagConstraints gbc = new GridBagConstraints();\n+        gbc.gridx = 0;\n+        gbc.gridy = 0;\n+        gbc.gridwidth = 2;\n+        gbc.anchor = GridBagConstraints.WEST;\n+        \n+        infoPanel.add(new JLabel(\"Current Campaign Status:\"), gbc);\n+        \n+        gbc.gridy++;\n+        \n+        infoPanel.add(campaignStatusText, gbc);        \n+        gbc.gridy++;\n+        \n+        gbc.gridwidth = 1;\n+        gbc.gridheight = 2;\n+        JLabel lblCurrentTrack = new JLabel(\"Current Track:\");\n+        infoPanel.add(lblCurrentTrack, gbc);\n+        gbc.gridx = 1;\n+                \n+        cboCurrentTrack = new JComboBox<>();\n+        repopulateTrackList();\n+        cboCurrentTrack.addItemListener(new ItemListener() {\n+            @Override\n+            public void itemStateChanged(ItemEvent e) {\n+            \ttrackSelectionHandler();\n+            }", "originalCommit": "796b6728fd3cd2aea02d17122b4d735afc47dc41", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjkwMjg1OA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r602902858", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if(cboCurrentTrack.getItemCount() > 0) {\n          \n          \n            \n                    if (cboCurrentTrack.getItemCount() > 0) {", "author": "Windchild292", "createdAt": "2021-03-28T16:54:14Z", "path": "MekHQ/src/mekhq/gui/StratconTab.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+\n+package mekhq.gui;\n+\n+import java.awt.GridBagConstraints;\n+import java.awt.GridBagLayout;\n+import java.awt.event.ItemEvent;\n+import java.awt.event.ItemListener;\n+import java.util.Objects;\n+\n+import javax.swing.JComboBox;\n+import javax.swing.JLabel;\n+import javax.swing.JPanel;\n+import javax.swing.JScrollPane;\n+\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.campaign.event.MissionCompletedEvent;\n+import mekhq.campaign.event.MissionRemovedEvent;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.stratcon.StratconCampaignState;\n+import mekhq.campaign.stratcon.StratconTrackState;\n+\n+public class StratconTab extends CampaignGuiTab {\n+    /**\n+     * \n+     */\n+    private static final long serialVersionUID = 8179754409939346465L;\n+    \n+    private StratconPanel stratconPanel;\n+    private JPanel infoPanel;\n+    private JComboBox<TrackDropdownItem> cboCurrentTrack;\n+    private JLabel infoPanelText;\n+    private JLabel campaignStatusText;\n+\n+    /**\n+     * Creates an instance of the StratconTab.\n+     */\n+    StratconTab(CampaignGUI gui, String tabName) {\n+        super(gui, tabName);\n+    }\n+\n+    /**\n+     * Override of the base initTab method. Populates the tab.\n+     */\n+    @Override\n+    public void initTab() { \n+        removeAll();\n+        \n+        infoPanelText = new JLabel();\n+        campaignStatusText = new JLabel();\n+        \n+        setLayout(new GridBagLayout());\n+        GridBagConstraints gbc = new GridBagConstraints();\n+        gbc.gridx = 0;\n+        gbc.gridy = 0;\n+        gbc.gridwidth = 4;\n+        gbc.fill = GridBagConstraints.BOTH;\n+        gbc.anchor = GridBagConstraints.WEST;\n+        gbc.ipadx = 5;\n+        stratconPanel = new StratconPanel(getCampaignGui(), infoPanelText);\n+        JScrollPane scrollPane = new JScrollPane(stratconPanel);\n+        scrollPane.getHorizontalScrollBar().setUnitIncrement(StratconPanel.HEX_X_RADIUS);\n+        scrollPane.getVerticalScrollBar().setUnitIncrement(StratconPanel.HEX_Y_RADIUS);\n+        this.add(scrollPane, gbc);\n+        \n+        // TODO: lance role assignment UI here?\n+        \n+        initializeInfoPanel();\n+        gbc.gridx = 4;\n+        gbc.gridwidth = 1;\n+        gbc.anchor = GridBagConstraints.NORTH;\n+        this.add(infoPanel, gbc);\n+        \n+        MekHQ.registerHandler(this);\n+    }\n+\n+    /**\n+     * Worker function that sets up the layout of the right-side info panel.\n+     */\n+    private void initializeInfoPanel() {\n+        infoPanel = new JPanel();        \n+        infoPanel.setLayout(new GridBagLayout()); \n+        GridBagConstraints gbc = new GridBagConstraints();\n+        gbc.gridx = 0;\n+        gbc.gridy = 0;\n+        gbc.gridwidth = 2;\n+        gbc.anchor = GridBagConstraints.WEST;\n+        \n+        infoPanel.add(new JLabel(\"Current Campaign Status:\"), gbc);\n+        \n+        gbc.gridy++;\n+        \n+        infoPanel.add(campaignStatusText, gbc);        \n+        gbc.gridy++;\n+        \n+        gbc.gridwidth = 1;\n+        gbc.gridheight = 2;\n+        JLabel lblCurrentTrack = new JLabel(\"Current Track:\");\n+        infoPanel.add(lblCurrentTrack, gbc);\n+        gbc.gridx = 1;\n+                \n+        cboCurrentTrack = new JComboBox<>();\n+        repopulateTrackList();\n+        cboCurrentTrack.addItemListener(new ItemListener() {\n+            @Override\n+            public void itemStateChanged(ItemEvent e) {\n+            \ttrackSelectionHandler();\n+            }\n+        });\n+\n+        infoPanel.add(cboCurrentTrack, gbc);\n+        \n+        // have a default selected\n+        if(cboCurrentTrack.getItemCount() > 0) {", "originalCommit": "796b6728fd3cd2aea02d17122b4d735afc47dc41", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjkwMjg5Ng==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r602902896", "bodyText": "Chain appends", "author": "Windchild292", "createdAt": "2021-03-28T16:54:43Z", "path": "MekHQ/src/mekhq/gui/StratconTab.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+\n+package mekhq.gui;\n+\n+import java.awt.GridBagConstraints;\n+import java.awt.GridBagLayout;\n+import java.awt.event.ItemEvent;\n+import java.awt.event.ItemListener;\n+import java.util.Objects;\n+\n+import javax.swing.JComboBox;\n+import javax.swing.JLabel;\n+import javax.swing.JPanel;\n+import javax.swing.JScrollPane;\n+\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.campaign.event.MissionCompletedEvent;\n+import mekhq.campaign.event.MissionRemovedEvent;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.stratcon.StratconCampaignState;\n+import mekhq.campaign.stratcon.StratconTrackState;\n+\n+public class StratconTab extends CampaignGuiTab {\n+    /**\n+     * \n+     */\n+    private static final long serialVersionUID = 8179754409939346465L;\n+    \n+    private StratconPanel stratconPanel;\n+    private JPanel infoPanel;\n+    private JComboBox<TrackDropdownItem> cboCurrentTrack;\n+    private JLabel infoPanelText;\n+    private JLabel campaignStatusText;\n+\n+    /**\n+     * Creates an instance of the StratconTab.\n+     */\n+    StratconTab(CampaignGUI gui, String tabName) {\n+        super(gui, tabName);\n+    }\n+\n+    /**\n+     * Override of the base initTab method. Populates the tab.\n+     */\n+    @Override\n+    public void initTab() { \n+        removeAll();\n+        \n+        infoPanelText = new JLabel();\n+        campaignStatusText = new JLabel();\n+        \n+        setLayout(new GridBagLayout());\n+        GridBagConstraints gbc = new GridBagConstraints();\n+        gbc.gridx = 0;\n+        gbc.gridy = 0;\n+        gbc.gridwidth = 4;\n+        gbc.fill = GridBagConstraints.BOTH;\n+        gbc.anchor = GridBagConstraints.WEST;\n+        gbc.ipadx = 5;\n+        stratconPanel = new StratconPanel(getCampaignGui(), infoPanelText);\n+        JScrollPane scrollPane = new JScrollPane(stratconPanel);\n+        scrollPane.getHorizontalScrollBar().setUnitIncrement(StratconPanel.HEX_X_RADIUS);\n+        scrollPane.getVerticalScrollBar().setUnitIncrement(StratconPanel.HEX_Y_RADIUS);\n+        this.add(scrollPane, gbc);\n+        \n+        // TODO: lance role assignment UI here?\n+        \n+        initializeInfoPanel();\n+        gbc.gridx = 4;\n+        gbc.gridwidth = 1;\n+        gbc.anchor = GridBagConstraints.NORTH;\n+        this.add(infoPanel, gbc);\n+        \n+        MekHQ.registerHandler(this);\n+    }\n+\n+    /**\n+     * Worker function that sets up the layout of the right-side info panel.\n+     */\n+    private void initializeInfoPanel() {\n+        infoPanel = new JPanel();        \n+        infoPanel.setLayout(new GridBagLayout()); \n+        GridBagConstraints gbc = new GridBagConstraints();\n+        gbc.gridx = 0;\n+        gbc.gridy = 0;\n+        gbc.gridwidth = 2;\n+        gbc.anchor = GridBagConstraints.WEST;\n+        \n+        infoPanel.add(new JLabel(\"Current Campaign Status:\"), gbc);\n+        \n+        gbc.gridy++;\n+        \n+        infoPanel.add(campaignStatusText, gbc);        \n+        gbc.gridy++;\n+        \n+        gbc.gridwidth = 1;\n+        gbc.gridheight = 2;\n+        JLabel lblCurrentTrack = new JLabel(\"Current Track:\");\n+        infoPanel.add(lblCurrentTrack, gbc);\n+        gbc.gridx = 1;\n+                \n+        cboCurrentTrack = new JComboBox<>();\n+        repopulateTrackList();\n+        cboCurrentTrack.addItemListener(new ItemListener() {\n+            @Override\n+            public void itemStateChanged(ItemEvent e) {\n+            \ttrackSelectionHandler();\n+            }\n+        });\n+\n+        infoPanel.add(cboCurrentTrack, gbc);\n+        \n+        // have a default selected\n+        if(cboCurrentTrack.getItemCount() > 0) {\n+        \ttrackSelectionHandler();\n+        }\n+        \n+        gbc.gridy += 2;\n+        gbc.gridx = 0;\n+        gbc.gridwidth = 2;\n+        gbc.gridheight = 1;\n+        infoPanel.add(infoPanelText, gbc);\n+    }\n+    \n+    /**\n+     * Worker that handles track selection.\n+     */\n+    private void trackSelectionHandler() {\n+    \tTrackDropdownItem tdi = (TrackDropdownItem) cboCurrentTrack.getSelectedItem();\n+    \tif (tdi != null) {\n+\t        stratconPanel.selectTrack(tdi.contract.getStratconCampaignState(), tdi.track);\n+\t        updateCampaignState();\n+    \t}\n+    }\n+    \n+    @Override\n+    public void repaint() {\n+        updateCampaignState();\n+    }\n+    \n+    @Override\n+    public void refreshAll() {\n+        stratconPanel.repaint();\n+        updateCampaignState();\n+    }\n+\n+    @Override\n+    public GuiTabType tabType() {\n+        return GuiTabType.STRATCON;\n+    }\n+    \n+    /**\n+     * Worker function that updates the campaign state section of the info panel\n+     * with such info as current objective status, VP/SP totals, etc.\n+     */\n+    private void updateCampaignState() {\n+        if ((cboCurrentTrack == null) || (campaignStatusText == null)) {\n+            return;\n+        }\n+        \n+        // campaign state text should contain:\n+        // list of remaining objectives, percentage remaining\n+        // current VP\n+        // current support points\n+        TrackDropdownItem currentTDI = (TrackDropdownItem) cboCurrentTrack.getSelectedItem();\n+        if (currentTDI == null) {\n+            return;\n+        }\n+        AtBContract currentContract = currentTDI.contract;\n+        StratconCampaignState campaignState = currentContract.getStratconCampaignState();\n+        \n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"<html>\");\n+        \n+        sb.append(currentContract.getMissionTypeName()).append(\": \").append(currentContract.getName());\n+        sb.append(\"<br/>\");\n+        sb.append(campaignState.getBriefingText());\n+        \n+        // avoid confusing users by showing strategic objectives when there are none to show\n+        if (!campaignState.strategicObjectivesBehaveAsVPs()) {\n+            sb.append(\"<br/>Strategic Objectives: \").append(campaignState.getStrategicObjectiveCompletedCount())\n+                .append(\"/\").append(campaignState.getPendingStrategicObjectiveCount());\n+        }\n+        \n+        sb.append(\"<br/>Victory Points: \").append(campaignState.getVictoryPoints());\n+        \n+        sb.append(\"<br/>Support Points: \").append(campaignState.getSupportPoints());\n+        \n+        sb.append(\"<br/>Deployment Period: \").append(currentTDI.track.getDeploymentTime()).append(\" days\");\n+        \n+        sb.append(\"</html>\");", "originalCommit": "796b6728fd3cd2aea02d17122b4d735afc47dc41", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjkwMjkwMg==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r602902902", "bodyText": "Chain appends", "author": "Windchild292", "createdAt": "2021-03-28T16:54:47Z", "path": "MekHQ/src/mekhq/gui/StratconTab.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+\n+package mekhq.gui;\n+\n+import java.awt.GridBagConstraints;\n+import java.awt.GridBagLayout;\n+import java.awt.event.ItemEvent;\n+import java.awt.event.ItemListener;\n+import java.util.Objects;\n+\n+import javax.swing.JComboBox;\n+import javax.swing.JLabel;\n+import javax.swing.JPanel;\n+import javax.swing.JScrollPane;\n+\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.campaign.event.MissionCompletedEvent;\n+import mekhq.campaign.event.MissionRemovedEvent;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.stratcon.StratconCampaignState;\n+import mekhq.campaign.stratcon.StratconTrackState;\n+\n+public class StratconTab extends CampaignGuiTab {\n+    /**\n+     * \n+     */\n+    private static final long serialVersionUID = 8179754409939346465L;\n+    \n+    private StratconPanel stratconPanel;\n+    private JPanel infoPanel;\n+    private JComboBox<TrackDropdownItem> cboCurrentTrack;\n+    private JLabel infoPanelText;\n+    private JLabel campaignStatusText;\n+\n+    /**\n+     * Creates an instance of the StratconTab.\n+     */\n+    StratconTab(CampaignGUI gui, String tabName) {\n+        super(gui, tabName);\n+    }\n+\n+    /**\n+     * Override of the base initTab method. Populates the tab.\n+     */\n+    @Override\n+    public void initTab() { \n+        removeAll();\n+        \n+        infoPanelText = new JLabel();\n+        campaignStatusText = new JLabel();\n+        \n+        setLayout(new GridBagLayout());\n+        GridBagConstraints gbc = new GridBagConstraints();\n+        gbc.gridx = 0;\n+        gbc.gridy = 0;\n+        gbc.gridwidth = 4;\n+        gbc.fill = GridBagConstraints.BOTH;\n+        gbc.anchor = GridBagConstraints.WEST;\n+        gbc.ipadx = 5;\n+        stratconPanel = new StratconPanel(getCampaignGui(), infoPanelText);\n+        JScrollPane scrollPane = new JScrollPane(stratconPanel);\n+        scrollPane.getHorizontalScrollBar().setUnitIncrement(StratconPanel.HEX_X_RADIUS);\n+        scrollPane.getVerticalScrollBar().setUnitIncrement(StratconPanel.HEX_Y_RADIUS);\n+        this.add(scrollPane, gbc);\n+        \n+        // TODO: lance role assignment UI here?\n+        \n+        initializeInfoPanel();\n+        gbc.gridx = 4;\n+        gbc.gridwidth = 1;\n+        gbc.anchor = GridBagConstraints.NORTH;\n+        this.add(infoPanel, gbc);\n+        \n+        MekHQ.registerHandler(this);\n+    }\n+\n+    /**\n+     * Worker function that sets up the layout of the right-side info panel.\n+     */\n+    private void initializeInfoPanel() {\n+        infoPanel = new JPanel();        \n+        infoPanel.setLayout(new GridBagLayout()); \n+        GridBagConstraints gbc = new GridBagConstraints();\n+        gbc.gridx = 0;\n+        gbc.gridy = 0;\n+        gbc.gridwidth = 2;\n+        gbc.anchor = GridBagConstraints.WEST;\n+        \n+        infoPanel.add(new JLabel(\"Current Campaign Status:\"), gbc);\n+        \n+        gbc.gridy++;\n+        \n+        infoPanel.add(campaignStatusText, gbc);        \n+        gbc.gridy++;\n+        \n+        gbc.gridwidth = 1;\n+        gbc.gridheight = 2;\n+        JLabel lblCurrentTrack = new JLabel(\"Current Track:\");\n+        infoPanel.add(lblCurrentTrack, gbc);\n+        gbc.gridx = 1;\n+                \n+        cboCurrentTrack = new JComboBox<>();\n+        repopulateTrackList();\n+        cboCurrentTrack.addItemListener(new ItemListener() {\n+            @Override\n+            public void itemStateChanged(ItemEvent e) {\n+            \ttrackSelectionHandler();\n+            }\n+        });\n+\n+        infoPanel.add(cboCurrentTrack, gbc);\n+        \n+        // have a default selected\n+        if(cboCurrentTrack.getItemCount() > 0) {\n+        \ttrackSelectionHandler();\n+        }\n+        \n+        gbc.gridy += 2;\n+        gbc.gridx = 0;\n+        gbc.gridwidth = 2;\n+        gbc.gridheight = 1;\n+        infoPanel.add(infoPanelText, gbc);\n+    }\n+    \n+    /**\n+     * Worker that handles track selection.\n+     */\n+    private void trackSelectionHandler() {\n+    \tTrackDropdownItem tdi = (TrackDropdownItem) cboCurrentTrack.getSelectedItem();\n+    \tif (tdi != null) {\n+\t        stratconPanel.selectTrack(tdi.contract.getStratconCampaignState(), tdi.track);\n+\t        updateCampaignState();\n+    \t}\n+    }\n+    \n+    @Override\n+    public void repaint() {\n+        updateCampaignState();\n+    }\n+    \n+    @Override\n+    public void refreshAll() {\n+        stratconPanel.repaint();\n+        updateCampaignState();\n+    }\n+\n+    @Override\n+    public GuiTabType tabType() {\n+        return GuiTabType.STRATCON;\n+    }\n+    \n+    /**\n+     * Worker function that updates the campaign state section of the info panel\n+     * with such info as current objective status, VP/SP totals, etc.\n+     */\n+    private void updateCampaignState() {\n+        if ((cboCurrentTrack == null) || (campaignStatusText == null)) {\n+            return;\n+        }\n+        \n+        // campaign state text should contain:\n+        // list of remaining objectives, percentage remaining\n+        // current VP\n+        // current support points\n+        TrackDropdownItem currentTDI = (TrackDropdownItem) cboCurrentTrack.getSelectedItem();\n+        if (currentTDI == null) {\n+            return;\n+        }\n+        AtBContract currentContract = currentTDI.contract;\n+        StratconCampaignState campaignState = currentContract.getStratconCampaignState();\n+        \n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"<html>\");\n+        \n+        sb.append(currentContract.getMissionTypeName()).append(\": \").append(currentContract.getName());\n+        sb.append(\"<br/>\");\n+        sb.append(campaignState.getBriefingText());", "originalCommit": "796b6728fd3cd2aea02d17122b4d735afc47dc41", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjkwMzE1Mg==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r602903152", "bodyText": "Spacing between name and equals", "author": "Windchild292", "createdAt": "2021-03-28T16:56:53Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconFacilityManifest.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.util.List;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBElement;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.transform.Source;\n+\n+import mekhq.MekHQ;\n+import mekhq.MekHqXmlUtil;\n+\n+/**\n+ * A manifest containing IDs and file names of stratcon facility definitions\n+ * @author NickAragua\n+ */\n+@XmlRootElement(name=\"facilityManifest\")\n+public class StratconFacilityManifest {\n+    @XmlElementWrapper(name=\"facilityFileNames\")\n+    @XmlElement(name=\"facilityFileName\")", "originalCommit": "796b6728fd3cd2aea02d17122b4d735afc47dc41", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjkwMzU2OQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r602903569", "bodyText": "Should be nullable annotated", "author": "Windchild292", "createdAt": "2021-03-28T16:59:49Z", "path": "MekHQ/src/mekhq/campaign/mission/ScenarioForceTemplate.java", "diffHunk": "@@ -76,15 +76,41 @@\n     // this is used to indicate that a \"fixed\" size unit should deploy as a lance\n     public static final int FIXED_UNIT_SIZE_LANCE = -1;\n \n+    public static final String PRIMARY_FORCE_TEMPLATE_ID = \"Player\";\n     public static final String REINFORCEMENT_TEMPLATE_ID = \"Reinforcements\";\n \n+    /**\n+     * Which side a particular force will fight for\n+     */\n     public enum ForceAlignment {\n+        /**\n+         * On this player's side, controlled by the player\n+         */\n         Player,\n+        \n+        /**\n+         * Allied, bot-controlled\n+         */\n         Allied,\n+        \n+        /**\n+         * Opposing, bot-controlled\n+         */\n         Opposing,\n+        \n+        /**\n+         * Hostile to both allied and opposing, bot-controlled\n+         */\n         Third,\n+        \n+        /**\n+         * Dynamically either allied, opposing or third, depending on who owns the current planet\n+         */\n         PlanetOwner;\n \n+        /**\n+         * Get a force alignment value given an int\n+         */\n         public static ForceAlignment getForceAlignment(int ordinal) {", "originalCommit": "796b6728fd3cd2aea02d17122b4d735afc47dc41", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjkwMzc0Mg==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r602903742", "bodyText": "Could swap to indent++ and --indent on the open/close tags for ease of reading (in my eye, at least)", "author": "Windchild292", "createdAt": "2021-03-28T17:01:31Z", "path": "MekHQ/src/mekhq/campaign/mission/AtBScenario.java", "diffHunk": "@@ -1635,6 +1638,19 @@ protected void writeToXmlEnd(PrintWriter pw1, int indent) {\n \n             pw1.println(MekHqXmlUtil.indentStr(indent+1) + \"</transportLinkages>\");\n         }\n+        \n+        if (numPlayerMinefields.size() > 0) {\n+            MekHqXmlUtil.writeSimpleXMLOpenIndentedLine(pw1, indent + 1, \"numPlayerMinefields\");\n+\n+            for (int key : numPlayerMinefields.keySet()) {\n+                MekHqXmlUtil.writeSimpleXMLOpenIndentedLine(pw1, indent + 2, \"numPlayerMinefield\");\n+                MekHqXmlUtil.writeSimpleXmlTag(pw1, indent + 3, \"minefieldType\", key);\n+                MekHqXmlUtil.writeSimpleXmlTag(pw1, indent + 3, \"minefieldCount\", numPlayerMinefields.get(key).toString());\n+                MekHqXmlUtil.writeSimpleXMLCloseIndentedLine(pw1, indent + 2, \"numPlayerMinefield\");\n+            }\n+\n+            MekHqXmlUtil.writeSimpleXMLCloseIndentedLine(pw1, indent + 1, \"numPlayerMinefields\");", "originalCommit": "796b6728fd3cd2aea02d17122b4d735afc47dc41", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjkxMDExMQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r602910111", "bodyText": "All the other ones in the file look the same as these, so let's leave them until the whole file can be converted.", "author": "NickAragua", "createdAt": "2021-03-28T17:57:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjkwMzc0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjkwMzc5Ng==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r602903796", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Mek HQ event relating to the deployment of a force to a StratCon track.\n          \n          \n            \n             * MekHQ event relating to the deployment of a force to a StratCon track.", "author": "Windchild292", "createdAt": "2021-03-28T17:02:08Z", "path": "MekHQ/src/mekhq/campaign/event/StratconDeploymentEvent.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.event;\n+\n+import megamek.common.event.MMEvent;\n+import mekhq.campaign.force.Force;\n+\n+/**\n+ * Mek HQ event relating to the deployment of a force to a StratCon track.", "originalCommit": "796b6728fd3cd2aea02d17122b4d735afc47dc41", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjkwMzgzOA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r602903838", "bodyText": "Uhm... I'm pretty sure this should set the force", "author": "Windchild292", "createdAt": "2021-03-28T17:02:31Z", "path": "MekHQ/src/mekhq/campaign/event/StratconDeploymentEvent.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.event;\n+\n+import megamek.common.event.MMEvent;\n+import mekhq.campaign.force.Force;\n+\n+/**\n+ * Mek HQ event relating to the deployment of a force to a StratCon track.\n+ * @author NickAragua\n+ */\n+public class StratconDeploymentEvent extends MMEvent {\n+    private Force force;\n+    \n+    public StratconDeploymentEvent(Force force) {\n+        super();\n+    }", "originalCommit": "796b6728fd3cd2aea02d17122b4d735afc47dc41", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjkwOTMwOA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r602909308", "bodyText": "Luckily, I don't actually use that info.", "author": "NickAragua", "createdAt": "2021-03-28T17:50:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjkwMzgzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjkwMzg1Mw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r602903853", "bodyText": "This can almost certainly be final", "author": "Windchild292", "createdAt": "2021-03-28T17:02:41Z", "path": "MekHQ/src/mekhq/campaign/event/StratconDeploymentEvent.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.event;\n+\n+import megamek.common.event.MMEvent;\n+import mekhq.campaign.force.Force;\n+\n+/**\n+ * Mek HQ event relating to the deployment of a force to a StratCon track.\n+ * @author NickAragua\n+ */\n+public class StratconDeploymentEvent extends MMEvent {\n+    private Force force;", "originalCommit": "796b6728fd3cd2aea02d17122b4d735afc47dc41", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjkwNDA0NA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r602904044", "bodyText": "Tab spacing", "author": "Windchild292", "createdAt": "2021-03-28T17:04:55Z", "path": "MekHQ/src/mekhq/MekHQ.java", "diffHunk": "@@ -683,10 +684,14 @@ static public void unregisterHandler(Object handler) {\n         EVENT_BUS.unregister(handler);\n     }\n \n-    // TODO: This needs to be way more flexible, but it will do for now.\n-    private void initEventHandlers() {\n-        EVENT_BUS.register(new XPHandler());\n-    }\n+\t// TODO: This needs to be way more flexible, but it will do for now.\n+\tprivate void initEventHandlers() {\n+\t    EVENT_BUS.register(new XPHandler());\n+\t    \n+\t    StratconRulesManager srm = new StratconRulesManager();\n+\t    srm.startup();\n+\t    EVENT_BUS.register(srm);\t    \n+\t}", "originalCommit": "796b6728fd3cd2aea02d17122b4d735afc47dc41", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjkwNTA2MQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r602905061", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if(eventRecipient != ForceAlignment.Opposing) {\n          \n          \n            \n                    if (eventRecipient != ForceAlignment.Opposing) {", "author": "Windchild292", "createdAt": "2021-03-28T17:13:44Z", "path": "MekHQ/src/mekhq/campaign/mission/atb/AtBScenarioModifierApplicator.java", "diffHunk": "@@ -214,14 +202,10 @@ public static void adjustSkill(AtBDynamicScenario scenario, Campaign campaign,\n      * Worker function that adjusts the scenario's unit quality by the indicated amount,\n      * capped between 0 and 5. Only effective for units generated after the adjustment has taken place.\n      * Only capable of being applied to opfor.\n-     * @param scenario Scenario to modify.\n-     * @param c Working campaign\n-     * @param eventRecipient Whose\n-     * @param qualityAdjustment\n      */\n     public static void adjustQuality(AtBDynamicScenario scenario, Campaign c, ForceAlignment eventRecipient, int qualityAdjustment) {\n-        if (eventRecipient != ForceAlignment.Opposing) {\n-            MekHQ.getLogger().warning(AtBScenarioModifierApplicator.class, \"adjustQuality\", \"Cannot only adjust opfor unit quality\");\n+        if(eventRecipient != ForceAlignment.Opposing) {", "originalCommit": "796b6728fd3cd2aea02d17122b4d735afc47dc41", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d14fb801ae5450e1ddcbeb8da491b3e937b2f0a3", "url": "https://github.com/MegaMek/mekhq/commit/d14fb801ae5450e1ddcbeb8da491b3e937b2f0a3", "message": "code review changes", "committedDate": "2021-03-28T17:58:30Z", "type": "commit"}, {"oid": "3ad5f4e7489bdcb62c16b5826270355176588afe", "url": "https://github.com/MegaMek/mekhq/commit/3ad5f4e7489bdcb62c16b5826270355176588afe", "message": "missed a spot", "committedDate": "2021-03-28T18:00:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzAwNDY2OQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603004669", "bodyText": "Still need the fix here. This is a code accessibility issue.", "author": "Windchild292", "createdAt": "2021-03-29T04:13:58Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconFacilityManifest.java", "diffHunk": "@@ -35,8 +35,8 @@\n  */\n @XmlRootElement(name=\"facilityManifest\")", "originalCommit": "d14fb801ae5450e1ddcbeb8da491b3e937b2f0a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ded0a76ab00c54323f9c24291d0a2582367b1792", "url": "https://github.com/MegaMek/mekhq/commit/ded0a76ab00c54323f9c24291d0a2582367b1792", "message": "missed another spot", "committedDate": "2021-03-29T04:37:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzM3MjUzOA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603372538", "bodyText": "Still some tab spacing here", "author": "Windchild292", "createdAt": "2021-03-29T15:05:03Z", "path": "MekHQ/src/mekhq/MekHQ.java", "diffHunk": "@@ -683,10 +684,14 @@ static public void unregisterHandler(Object handler) {\n         EVENT_BUS.unregister(handler);\n     }\n \n-    // TODO: This needs to be way more flexible, but it will do for now.\n-    private void initEventHandlers() {\n-        EVENT_BUS.register(new XPHandler());\n-    }\n+\t// TODO: This needs to be way more flexible, but it will do for now.\n+\tprivate void initEventHandlers() {\n+\t    EVENT_BUS.register(new XPHandler());\n+\t    \n+        StratconRulesManager srm = new StratconRulesManager();\n+        srm.startup();\n+        EVENT_BUS.register(srm);\t    \n+\t}", "originalCommit": "ded0a76ab00c54323f9c24291d0a2582367b1792", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzM3MzYxMw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603373613", "bodyText": "???", "author": "Windchild292", "createdAt": "2021-03-29T15:06:20Z", "path": "MekHQ/src/mekhq/campaign/mission/AtBDynamicScenario.java", "diffHunk": "@@ -151,13 +174,18 @@ public int getMapY() {\n     }\n \n     /**\n-     * Adds a bot force to this dynamic scenario.\n+     * Adds a bot force to this fenario.", "originalCommit": "ded0a76ab00c54323f9c24291d0a2582367b1792", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzM3NTcyMA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603375720", "bodyText": "Merge the two calls, all you need to do is add , ex to the end of the top one", "author": "Windchild292", "createdAt": "2021-03-29T15:08:54Z", "path": "MekHQ/src/mekhq/campaign/mission/AtBDynamicScenarioFactory.java", "diffHunk": "@@ -1281,8 +1302,8 @@ public static Entity createEntityWithCrew(String factionCode, int skill, Campaig\n         try {\n             en = new MechFileParser(ms.getSourceFile(), ms.getEntryName()).getEntity();\n         } catch (Exception ex) {\n-            MekHQ.getLogger().error(AtBDynamicScenarioFactory.class, \"Unable to load entity: \" + ms.getSourceFile() + \": \" + ms.getEntryName() + \": \" + ex.getMessage());\n-            MekHQ.getLogger().error(AtBDynamicScenarioFactory.class, ex);\n+            MekHQ.getLogger().error(\"Unable to load entity: \" + ms.getSourceFile() + \": \" + ms.getEntryName() + \": \" + ex.getMessage());\n+            MekHQ.getLogger().error(ex);", "originalCommit": "ded0a76ab00c54323f9c24291d0a2582367b1792", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzM3NjIyNg==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603376226", "bodyText": "brackets", "author": "Windchild292", "createdAt": "2021-03-29T15:09:32Z", "path": "MekHQ/src/mekhq/campaign/mission/AtBDynamicScenarioFactory.java", "diffHunk": "@@ -2304,26 +2325,41 @@ public static void populateAeroBombs(List<Entity> entityList, Campaign campaign,\n             if (entity.isBomber()) {\n                 // if this entity has no guns (e.g. is a Boeing Jump Bomber)\n                 if (entity.getIndividualWeaponList().size() == 0) {\n-                    loadBombs(entity, validBombChoices);\n+                    loadBombs(entity, validBombChoices, campaign.getGameYear());\n                     continue;\n                 }\n \n                 if (numBombers >= maxBombers) {\n                     break;\n                 }\n \n-                loadBombs(entity, validBombChoices);\n+                loadBombs(entity, validBombChoices, campaign.getGameYear());\n                 numBombers++;\n             }\n         }\n     }\n \n-    // todo: determine how many bombs can fit on this entity, and either pick\n-    // a random amount or fill 'er up\n-    private static void loadBombs(Entity entity, int[] validBombChoices) {\n+    /**\n+     * Worker function that takes an entity and an array of bomb types\n+     * and loads it up with a random amount of bombs that it's capable of holding\n+     */\n+    private static void loadBombs(Entity entity, int[] validBombChoices, int year) {\n         int[] bombChoices = new int[BombType.B_NUM];\n+        \n+        // remove bomb choices if they're not era-appropriate\n+        List<Integer> actualBombChoices = new ArrayList<>();\n+        for (int x = 0; x < validBombChoices.length; x++) {\n+            String typeName = BombType.getBombInternalName(validBombChoices[x]);\n+            \n+            // hack: make rocket launcher pods available before 3055\n+            if (validBombChoices[x] == BombType.B_RL ||", "originalCommit": "ded0a76ab00c54323f9c24291d0a2582367b1792", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzM3NzU0MQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603377541", "bodyText": "This doesn't seem to randomize the number of bombs added?", "author": "Windchild292", "createdAt": "2021-03-29T15:11:04Z", "path": "MekHQ/src/mekhq/campaign/mission/AtBDynamicScenarioFactory.java", "diffHunk": "@@ -2304,26 +2325,41 @@ public static void populateAeroBombs(List<Entity> entityList, Campaign campaign,\n             if (entity.isBomber()) {\n                 // if this entity has no guns (e.g. is a Boeing Jump Bomber)\n                 if (entity.getIndividualWeaponList().size() == 0) {\n-                    loadBombs(entity, validBombChoices);\n+                    loadBombs(entity, validBombChoices, campaign.getGameYear());\n                     continue;\n                 }\n \n                 if (numBombers >= maxBombers) {\n                     break;\n                 }\n \n-                loadBombs(entity, validBombChoices);\n+                loadBombs(entity, validBombChoices, campaign.getGameYear());\n                 numBombers++;\n             }\n         }\n     }\n \n-    // todo: determine how many bombs can fit on this entity, and either pick\n-    // a random amount or fill 'er up\n-    private static void loadBombs(Entity entity, int[] validBombChoices) {\n+    /**\n+     * Worker function that takes an entity and an array of bomb types\n+     * and loads it up with a random amount of bombs that it's capable of holding\n+     */\n+    private static void loadBombs(Entity entity, int[] validBombChoices, int year) {\n         int[] bombChoices = new int[BombType.B_NUM];\n+        \n+        // remove bomb choices if they're not era-appropriate\n+        List<Integer> actualBombChoices = new ArrayList<>();\n+        for (int x = 0; x < validBombChoices.length; x++) {\n+            String typeName = BombType.getBombInternalName(validBombChoices[x]);\n+            \n+            // hack: make rocket launcher pods available before 3055\n+            if (validBombChoices[x] == BombType.B_RL ||\n+                    BombType.get(typeName).isAvailableIn(year)) {\n+                actualBombChoices.add(validBombChoices[x]);\n+            }\n+        }\n+        \n         int numBombs = (int) (entity.getWeight() / 5);", "originalCommit": "ded0a76ab00c54323f9c24291d0a2582367b1792", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzYwNDM0OQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603604349", "bodyText": "Updated with a bugfix, but looks like my intent was to give it a full bomb load, so comment updated.", "author": "NickAragua", "createdAt": "2021-03-29T20:50:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzM3NzU0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzM5NTg3Mw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603395873", "bodyText": "Spacing for the equals", "author": "Windchild292", "createdAt": "2021-03-29T15:32:52Z", "path": "MekHQ/src/mekhq/campaign/mission/atb/AtBScenarioManifest.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.mission.atb;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.util.Map;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBElement;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.transform.Source;\n+\n+import mekhq.MekHQ;\n+import mekhq.MekHqXmlUtil;\n+\n+/**\n+ * A manifest containing IDs and file names of scenario template definitions\n+ * @author NickAragua\n+ */\n+@XmlRootElement(name=\"scenarioManifest\")\n+public class AtBScenarioManifest {\n+    @XmlElementWrapper(name=\"scenarioFileNames\")\n+    @XmlElement(name=\"scenarioFileName\")", "originalCommit": "ded0a76ab00c54323f9c24291d0a2582367b1792", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzM5Njc3Ng==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603396776", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if(eventTiming == getEventTiming()) {\n          \n          \n            \n                    if (eventTiming == getEventTiming()) {", "author": "Windchild292", "createdAt": "2021-03-29T15:34:02Z", "path": "MekHQ/src/mekhq/campaign/mission/atb/AtBScenarioModifier.java", "diffHunk": "@@ -92,40 +102,41 @@ public static AtBScenarioModifier generateTestModifier() {\n      * @param eventTiming Whether this is occurring before or after primary forces have been generated.\n      */\n     public void processModifier(AtBDynamicScenario scenario, Campaign campaign, EventTiming eventTiming) {\n-        if(eventTiming == this.getEventTiming()) {\n-            if(getAdditionalBriefingText() != null && getAdditionalBriefingText().length() > 0) {\n-                AtBScenarioModifierApplicator.appendScenarioBriefingText(scenario, getAdditionalBriefingText());\n+        if(eventTiming == getEventTiming()) {", "originalCommit": "ded0a76ab00c54323f9c24291d0a2582367b1792", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzM5Njg4MQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603396881", "bodyText": "brackets", "author": "Windchild292", "createdAt": "2021-03-29T15:34:10Z", "path": "MekHQ/src/mekhq/campaign/mission/atb/AtBScenarioModifier.java", "diffHunk": "@@ -92,40 +102,41 @@ public static AtBScenarioModifier generateTestModifier() {\n      * @param eventTiming Whether this is occurring before or after primary forces have been generated.\n      */\n     public void processModifier(AtBDynamicScenario scenario, Campaign campaign, EventTiming eventTiming) {\n-        if(eventTiming == this.getEventTiming()) {\n-            if(getAdditionalBriefingText() != null && getAdditionalBriefingText().length() > 0) {\n-                AtBScenarioModifierApplicator.appendScenarioBriefingText(scenario, getAdditionalBriefingText());\n+        if(eventTiming == getEventTiming()) {\n+            if (getAdditionalBriefingText() != null && getAdditionalBriefingText().length() > 0) {", "originalCommit": "ded0a76ab00c54323f9c24291d0a2582367b1792", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzM5Njk5Mw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603396993", "bodyText": "brackets", "author": "Windchild292", "createdAt": "2021-03-29T15:34:18Z", "path": "MekHQ/src/mekhq/campaign/mission/atb/AtBScenarioModifier.java", "diffHunk": "@@ -92,40 +102,41 @@ public static AtBScenarioModifier generateTestModifier() {\n      * @param eventTiming Whether this is occurring before or after primary forces have been generated.\n      */\n     public void processModifier(AtBDynamicScenario scenario, Campaign campaign, EventTiming eventTiming) {\n-        if(eventTiming == this.getEventTiming()) {\n-            if(getAdditionalBriefingText() != null && getAdditionalBriefingText().length() > 0) {\n-                AtBScenarioModifierApplicator.appendScenarioBriefingText(scenario, getAdditionalBriefingText());\n+        if(eventTiming == getEventTiming()) {\n+            if (getAdditionalBriefingText() != null && getAdditionalBriefingText().length() > 0) {\n+                AtBScenarioModifierApplicator.appendScenarioBriefingText(scenario, \n+                        String.format(\"%s: %s\", getModifierName(), getAdditionalBriefingText()));\n             }\n             \n-            if(getForceDefinition() != null) {\n+            if (getForceDefinition() != null) {\n                 AtBScenarioModifierApplicator.addForce(campaign, scenario, getForceDefinition(), eventTiming);\n             }\n             \n-            if(getSkillAdjustment() != null && getEventRecipient() != null) {\n+            if (getSkillAdjustment() != null && getEventRecipient() != null) {", "originalCommit": "ded0a76ab00c54323f9c24291d0a2582367b1792", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzM5NzAzMQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603397031", "bodyText": "brackets", "author": "Windchild292", "createdAt": "2021-03-29T15:34:21Z", "path": "MekHQ/src/mekhq/campaign/mission/atb/AtBScenarioModifier.java", "diffHunk": "@@ -92,40 +102,41 @@ public static AtBScenarioModifier generateTestModifier() {\n      * @param eventTiming Whether this is occurring before or after primary forces have been generated.\n      */\n     public void processModifier(AtBDynamicScenario scenario, Campaign campaign, EventTiming eventTiming) {\n-        if(eventTiming == this.getEventTiming()) {\n-            if(getAdditionalBriefingText() != null && getAdditionalBriefingText().length() > 0) {\n-                AtBScenarioModifierApplicator.appendScenarioBriefingText(scenario, getAdditionalBriefingText());\n+        if(eventTiming == getEventTiming()) {\n+            if (getAdditionalBriefingText() != null && getAdditionalBriefingText().length() > 0) {\n+                AtBScenarioModifierApplicator.appendScenarioBriefingText(scenario, \n+                        String.format(\"%s: %s\", getModifierName(), getAdditionalBriefingText()));\n             }\n             \n-            if(getForceDefinition() != null) {\n+            if (getForceDefinition() != null) {\n                 AtBScenarioModifierApplicator.addForce(campaign, scenario, getForceDefinition(), eventTiming);\n             }\n             \n-            if(getSkillAdjustment() != null && getEventRecipient() != null) {\n+            if (getSkillAdjustment() != null && getEventRecipient() != null) {\n                 AtBScenarioModifierApplicator.adjustSkill(scenario, campaign, getEventRecipient(), getSkillAdjustment());\n             }\n             \n-            if(getQualityAdjustment() != null && getEventRecipient() != null) {\n+            if (getQualityAdjustment() != null && getEventRecipient() != null) {\n                 AtBScenarioModifierApplicator.adjustQuality(scenario, campaign, getEventRecipient(), getQualityAdjustment());\n             }\n             \n-            if(getBattleDamageIntensity() != null && getEventRecipient() != null) {\n+            if (getBattleDamageIntensity() != null && getEventRecipient() != null) {", "originalCommit": "ded0a76ab00c54323f9c24291d0a2582367b1792", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzM5NzA3OA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603397078", "bodyText": "brackets", "author": "Windchild292", "createdAt": "2021-03-29T15:34:24Z", "path": "MekHQ/src/mekhq/campaign/mission/atb/AtBScenarioModifier.java", "diffHunk": "@@ -92,40 +102,41 @@ public static AtBScenarioModifier generateTestModifier() {\n      * @param eventTiming Whether this is occurring before or after primary forces have been generated.\n      */\n     public void processModifier(AtBDynamicScenario scenario, Campaign campaign, EventTiming eventTiming) {\n-        if(eventTiming == this.getEventTiming()) {\n-            if(getAdditionalBriefingText() != null && getAdditionalBriefingText().length() > 0) {\n-                AtBScenarioModifierApplicator.appendScenarioBriefingText(scenario, getAdditionalBriefingText());\n+        if(eventTiming == getEventTiming()) {\n+            if (getAdditionalBriefingText() != null && getAdditionalBriefingText().length() > 0) {\n+                AtBScenarioModifierApplicator.appendScenarioBriefingText(scenario, \n+                        String.format(\"%s: %s\", getModifierName(), getAdditionalBriefingText()));\n             }\n             \n-            if(getForceDefinition() != null) {\n+            if (getForceDefinition() != null) {\n                 AtBScenarioModifierApplicator.addForce(campaign, scenario, getForceDefinition(), eventTiming);\n             }\n             \n-            if(getSkillAdjustment() != null && getEventRecipient() != null) {\n+            if (getSkillAdjustment() != null && getEventRecipient() != null) {\n                 AtBScenarioModifierApplicator.adjustSkill(scenario, campaign, getEventRecipient(), getSkillAdjustment());\n             }\n             \n-            if(getQualityAdjustment() != null && getEventRecipient() != null) {\n+            if (getQualityAdjustment() != null && getEventRecipient() != null) {", "originalCommit": "ded0a76ab00c54323f9c24291d0a2582367b1792", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzM5NzI3MA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603397270", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if(getNumExtraEvents() != null && getNumExtraEvents() > 0) {\n          \n          \n            \n                        if ((getNumExtraEvents() != null) && (getNumExtraEvents() > 0)) {", "author": "Windchild292", "createdAt": "2021-03-29T15:34:41Z", "path": "MekHQ/src/mekhq/campaign/mission/atb/AtBScenarioModifier.java", "diffHunk": "@@ -134,6 +145,10 @@ public void processModifier(AtBDynamicScenario scenario, Campaign campaign, Even\n                     AtBScenarioModifierApplicator.applyObjective(scenario, campaign, objective, eventTiming);\n                 }\n             }\n+            \n+            if(getNumExtraEvents() != null && getNumExtraEvents() > 0) {", "originalCommit": "ded0a76ab00c54323f9c24291d0a2582367b1792", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzM5NzY1Mg==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603397652", "bodyText": "brackets", "author": "Windchild292", "createdAt": "2021-03-29T15:35:10Z", "path": "MekHQ/src/mekhq/campaign/mission/atb/AtBScenarioModifier.java", "diffHunk": "@@ -92,40 +102,41 @@ public static AtBScenarioModifier generateTestModifier() {\n      * @param eventTiming Whether this is occurring before or after primary forces have been generated.\n      */\n     public void processModifier(AtBDynamicScenario scenario, Campaign campaign, EventTiming eventTiming) {\n-        if(eventTiming == this.getEventTiming()) {\n-            if(getAdditionalBriefingText() != null && getAdditionalBriefingText().length() > 0) {\n-                AtBScenarioModifierApplicator.appendScenarioBriefingText(scenario, getAdditionalBriefingText());\n+        if(eventTiming == getEventTiming()) {\n+            if (getAdditionalBriefingText() != null && getAdditionalBriefingText().length() > 0) {\n+                AtBScenarioModifierApplicator.appendScenarioBriefingText(scenario, \n+                        String.format(\"%s: %s\", getModifierName(), getAdditionalBriefingText()));\n             }\n             \n-            if(getForceDefinition() != null) {\n+            if (getForceDefinition() != null) {\n                 AtBScenarioModifierApplicator.addForce(campaign, scenario, getForceDefinition(), eventTiming);\n             }\n             \n-            if(getSkillAdjustment() != null && getEventRecipient() != null) {\n+            if (getSkillAdjustment() != null && getEventRecipient() != null) {\n                 AtBScenarioModifierApplicator.adjustSkill(scenario, campaign, getEventRecipient(), getSkillAdjustment());\n             }\n             \n-            if(getQualityAdjustment() != null && getEventRecipient() != null) {\n+            if (getQualityAdjustment() != null && getEventRecipient() != null) {\n                 AtBScenarioModifierApplicator.adjustQuality(scenario, campaign, getEventRecipient(), getQualityAdjustment());\n             }\n             \n-            if(getBattleDamageIntensity() != null && getEventRecipient() != null) {\n+            if (getBattleDamageIntensity() != null && getEventRecipient() != null) {\n                 AtBScenarioModifierApplicator.inflictBattleDamage(scenario, campaign, getEventRecipient(), getBattleDamageIntensity());\n             }\n             \n-            if(getAmmoExpenditureIntensity() != null && getEventRecipient() != null) {\n+            if (getAmmoExpenditureIntensity() != null && getEventRecipient() != null) {", "originalCommit": "ded0a76ab00c54323f9c24291d0a2582367b1792", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzM5Nzc1MQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603397751", "bodyText": "brackets", "author": "Windchild292", "createdAt": "2021-03-29T15:35:17Z", "path": "MekHQ/src/mekhq/campaign/mission/atb/AtBScenarioModifier.java", "diffHunk": "@@ -92,40 +102,41 @@ public static AtBScenarioModifier generateTestModifier() {\n      * @param eventTiming Whether this is occurring before or after primary forces have been generated.\n      */\n     public void processModifier(AtBDynamicScenario scenario, Campaign campaign, EventTiming eventTiming) {\n-        if(eventTiming == this.getEventTiming()) {\n-            if(getAdditionalBriefingText() != null && getAdditionalBriefingText().length() > 0) {\n-                AtBScenarioModifierApplicator.appendScenarioBriefingText(scenario, getAdditionalBriefingText());\n+        if(eventTiming == getEventTiming()) {\n+            if (getAdditionalBriefingText() != null && getAdditionalBriefingText().length() > 0) {\n+                AtBScenarioModifierApplicator.appendScenarioBriefingText(scenario, \n+                        String.format(\"%s: %s\", getModifierName(), getAdditionalBriefingText()));\n             }\n             \n-            if(getForceDefinition() != null) {\n+            if (getForceDefinition() != null) {\n                 AtBScenarioModifierApplicator.addForce(campaign, scenario, getForceDefinition(), eventTiming);\n             }\n             \n-            if(getSkillAdjustment() != null && getEventRecipient() != null) {\n+            if (getSkillAdjustment() != null && getEventRecipient() != null) {\n                 AtBScenarioModifierApplicator.adjustSkill(scenario, campaign, getEventRecipient(), getSkillAdjustment());\n             }\n             \n-            if(getQualityAdjustment() != null && getEventRecipient() != null) {\n+            if (getQualityAdjustment() != null && getEventRecipient() != null) {\n                 AtBScenarioModifierApplicator.adjustQuality(scenario, campaign, getEventRecipient(), getQualityAdjustment());\n             }\n             \n-            if(getBattleDamageIntensity() != null && getEventRecipient() != null) {\n+            if (getBattleDamageIntensity() != null && getEventRecipient() != null) {\n                 AtBScenarioModifierApplicator.inflictBattleDamage(scenario, campaign, getEventRecipient(), getBattleDamageIntensity());\n             }\n             \n-            if(getAmmoExpenditureIntensity() != null && getEventRecipient() != null) {\n+            if (getAmmoExpenditureIntensity() != null && getEventRecipient() != null) {\n                 AtBScenarioModifierApplicator.expendAmmo(scenario, campaign, getEventRecipient(), getAmmoExpenditureIntensity());\n             }\n             \n-            if(getUnitRemovalCount() != null && getEventRecipient() != null) {\n+            if (getUnitRemovalCount() != null && getEventRecipient() != null) {\n                 AtBScenarioModifierApplicator.removeUnits(scenario, campaign, getEventRecipient(), getUnitRemovalCount());\n             }\n             \n-            if(getUseAmbushLogic() != null && getEventRecipient() != null) {\n+            if (getUseAmbushLogic() != null && getEventRecipient() != null) {\n                 AtBScenarioModifierApplicator.setupAmbush(scenario, campaign, getEventRecipient());\n             }\n             \n-            if(getSwitchSides() != null && getEventRecipient() != null) {\n+            if (getSwitchSides() != null && getEventRecipient() != null) {", "originalCommit": "ded0a76ab00c54323f9c24291d0a2582367b1792", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzM5Nzc5Mw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603397793", "bodyText": "brackets", "author": "Windchild292", "createdAt": "2021-03-29T15:35:20Z", "path": "MekHQ/src/mekhq/campaign/mission/atb/AtBScenarioModifier.java", "diffHunk": "@@ -92,40 +102,41 @@ public static AtBScenarioModifier generateTestModifier() {\n      * @param eventTiming Whether this is occurring before or after primary forces have been generated.\n      */\n     public void processModifier(AtBDynamicScenario scenario, Campaign campaign, EventTiming eventTiming) {\n-        if(eventTiming == this.getEventTiming()) {\n-            if(getAdditionalBriefingText() != null && getAdditionalBriefingText().length() > 0) {\n-                AtBScenarioModifierApplicator.appendScenarioBriefingText(scenario, getAdditionalBriefingText());\n+        if(eventTiming == getEventTiming()) {\n+            if (getAdditionalBriefingText() != null && getAdditionalBriefingText().length() > 0) {\n+                AtBScenarioModifierApplicator.appendScenarioBriefingText(scenario, \n+                        String.format(\"%s: %s\", getModifierName(), getAdditionalBriefingText()));\n             }\n             \n-            if(getForceDefinition() != null) {\n+            if (getForceDefinition() != null) {\n                 AtBScenarioModifierApplicator.addForce(campaign, scenario, getForceDefinition(), eventTiming);\n             }\n             \n-            if(getSkillAdjustment() != null && getEventRecipient() != null) {\n+            if (getSkillAdjustment() != null && getEventRecipient() != null) {\n                 AtBScenarioModifierApplicator.adjustSkill(scenario, campaign, getEventRecipient(), getSkillAdjustment());\n             }\n             \n-            if(getQualityAdjustment() != null && getEventRecipient() != null) {\n+            if (getQualityAdjustment() != null && getEventRecipient() != null) {\n                 AtBScenarioModifierApplicator.adjustQuality(scenario, campaign, getEventRecipient(), getQualityAdjustment());\n             }\n             \n-            if(getBattleDamageIntensity() != null && getEventRecipient() != null) {\n+            if (getBattleDamageIntensity() != null && getEventRecipient() != null) {\n                 AtBScenarioModifierApplicator.inflictBattleDamage(scenario, campaign, getEventRecipient(), getBattleDamageIntensity());\n             }\n             \n-            if(getAmmoExpenditureIntensity() != null && getEventRecipient() != null) {\n+            if (getAmmoExpenditureIntensity() != null && getEventRecipient() != null) {\n                 AtBScenarioModifierApplicator.expendAmmo(scenario, campaign, getEventRecipient(), getAmmoExpenditureIntensity());\n             }\n             \n-            if(getUnitRemovalCount() != null && getEventRecipient() != null) {\n+            if (getUnitRemovalCount() != null && getEventRecipient() != null) {", "originalCommit": "ded0a76ab00c54323f9c24291d0a2582367b1792", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzM5Nzg2Mw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603397863", "bodyText": "brackets", "author": "Windchild292", "createdAt": "2021-03-29T15:35:24Z", "path": "MekHQ/src/mekhq/campaign/mission/atb/AtBScenarioModifier.java", "diffHunk": "@@ -92,40 +102,41 @@ public static AtBScenarioModifier generateTestModifier() {\n      * @param eventTiming Whether this is occurring before or after primary forces have been generated.\n      */\n     public void processModifier(AtBDynamicScenario scenario, Campaign campaign, EventTiming eventTiming) {\n-        if(eventTiming == this.getEventTiming()) {\n-            if(getAdditionalBriefingText() != null && getAdditionalBriefingText().length() > 0) {\n-                AtBScenarioModifierApplicator.appendScenarioBriefingText(scenario, getAdditionalBriefingText());\n+        if(eventTiming == getEventTiming()) {\n+            if (getAdditionalBriefingText() != null && getAdditionalBriefingText().length() > 0) {\n+                AtBScenarioModifierApplicator.appendScenarioBriefingText(scenario, \n+                        String.format(\"%s: %s\", getModifierName(), getAdditionalBriefingText()));\n             }\n             \n-            if(getForceDefinition() != null) {\n+            if (getForceDefinition() != null) {\n                 AtBScenarioModifierApplicator.addForce(campaign, scenario, getForceDefinition(), eventTiming);\n             }\n             \n-            if(getSkillAdjustment() != null && getEventRecipient() != null) {\n+            if (getSkillAdjustment() != null && getEventRecipient() != null) {\n                 AtBScenarioModifierApplicator.adjustSkill(scenario, campaign, getEventRecipient(), getSkillAdjustment());\n             }\n             \n-            if(getQualityAdjustment() != null && getEventRecipient() != null) {\n+            if (getQualityAdjustment() != null && getEventRecipient() != null) {\n                 AtBScenarioModifierApplicator.adjustQuality(scenario, campaign, getEventRecipient(), getQualityAdjustment());\n             }\n             \n-            if(getBattleDamageIntensity() != null && getEventRecipient() != null) {\n+            if (getBattleDamageIntensity() != null && getEventRecipient() != null) {\n                 AtBScenarioModifierApplicator.inflictBattleDamage(scenario, campaign, getEventRecipient(), getBattleDamageIntensity());\n             }\n             \n-            if(getAmmoExpenditureIntensity() != null && getEventRecipient() != null) {\n+            if (getAmmoExpenditureIntensity() != null && getEventRecipient() != null) {\n                 AtBScenarioModifierApplicator.expendAmmo(scenario, campaign, getEventRecipient(), getAmmoExpenditureIntensity());\n             }\n             \n-            if(getUnitRemovalCount() != null && getEventRecipient() != null) {\n+            if (getUnitRemovalCount() != null && getEventRecipient() != null) {\n                 AtBScenarioModifierApplicator.removeUnits(scenario, campaign, getEventRecipient(), getUnitRemovalCount());\n             }\n             \n-            if(getUseAmbushLogic() != null && getEventRecipient() != null) {\n+            if (getUseAmbushLogic() != null && getEventRecipient() != null) {", "originalCommit": "ded0a76ab00c54323f9c24291d0a2582367b1792", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzM5ODQ4MQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603398481", "bodyText": "Could do this as a single two line statement?", "author": "Windchild292", "createdAt": "2021-03-29T15:36:07Z", "path": "MekHQ/src/mekhq/campaign/mission/atb/AtBScenarioModifier.java", "diffHunk": "@@ -157,23 +182,142 @@ public void processModifier(AtBDynamicScenario scenario, Campaign campaign, Even\n         return scenarioModifierKeys;\n     }\n     \n-    public static AtBScenarioModifier getRandomScenarioModifier() {\n-        int modIndex = Compute.randomInt(scenarioModifierKeys.size());\n-        return scenarioModifiers.get(scenarioModifierKeys.get(modIndex));\n-    }\n-    \n     /**\n      * Convenience method to get a scenario modifier with the specified key.\n      * @param key The key\n      * @return The scenario modifier, if any.\n      */\n     public static AtBScenarioModifier getScenarioModifier(String key) {\n-        return scenarioModifiers.get(key);\n+        if (!scenarioModifiers.containsKey(key)) {\n+            MekHQ.getLogger().error(\"Scenario modifier \" + key + \" does not exist.\");\n+            return null;\n+        }\n+        \n+        // clone it to avoid calling code changing the modifier\n+        return scenarioModifiers.get(key).clone();\n+    }\n+    \n+    /**\n+     * Convenience method to get all the 'required' hostile facility modifiers()\n+     */\n+    public static List<AtBScenarioModifier> getRequiredHostileFacilityModifiers() {\n+        List<AtBScenarioModifier> retval = new ArrayList<>();\n+        for (String key : requiredHostileFacilityModifierKeys) {\n+            retval.add(scenarioModifiers.get(key).clone());\n+        }\n+        \n+        return retval;\n+    }\n+    \n+    /**\n+     * Convenience method to get a random hostile facility modifier\n+     * @return The scenario modifier, if any.\n+     */\n+    public static AtBScenarioModifier getRandomHostileFacilityModifier() {\n+        int modIndex = Compute.randomInt(hostileFacilityModifierKeys.size());\n+        \n+        return getScenarioModifier(hostileFacilityModifierKeys.get(modIndex));", "originalCommit": "ded0a76ab00c54323f9c24291d0a2582367b1792", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzM5ODU5NQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603398595", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Convenience method to get a random allied  facility modifier\n          \n          \n            \n                 * Convenience method to get a random allied facility modifier", "author": "Windchild292", "createdAt": "2021-03-29T15:36:16Z", "path": "MekHQ/src/mekhq/campaign/mission/atb/AtBScenarioModifier.java", "diffHunk": "@@ -157,23 +182,142 @@ public void processModifier(AtBDynamicScenario scenario, Campaign campaign, Even\n         return scenarioModifierKeys;\n     }\n     \n-    public static AtBScenarioModifier getRandomScenarioModifier() {\n-        int modIndex = Compute.randomInt(scenarioModifierKeys.size());\n-        return scenarioModifiers.get(scenarioModifierKeys.get(modIndex));\n-    }\n-    \n     /**\n      * Convenience method to get a scenario modifier with the specified key.\n      * @param key The key\n      * @return The scenario modifier, if any.\n      */\n     public static AtBScenarioModifier getScenarioModifier(String key) {\n-        return scenarioModifiers.get(key);\n+        if (!scenarioModifiers.containsKey(key)) {\n+            MekHQ.getLogger().error(\"Scenario modifier \" + key + \" does not exist.\");\n+            return null;\n+        }\n+        \n+        // clone it to avoid calling code changing the modifier\n+        return scenarioModifiers.get(key).clone();\n+    }\n+    \n+    /**\n+     * Convenience method to get all the 'required' hostile facility modifiers()\n+     */\n+    public static List<AtBScenarioModifier> getRequiredHostileFacilityModifiers() {\n+        List<AtBScenarioModifier> retval = new ArrayList<>();\n+        for (String key : requiredHostileFacilityModifierKeys) {\n+            retval.add(scenarioModifiers.get(key).clone());\n+        }\n+        \n+        return retval;\n+    }\n+    \n+    /**\n+     * Convenience method to get a random hostile facility modifier\n+     * @return The scenario modifier, if any.\n+     */\n+    public static AtBScenarioModifier getRandomHostileFacilityModifier() {\n+        int modIndex = Compute.randomInt(hostileFacilityModifierKeys.size());\n+        \n+        return getScenarioModifier(hostileFacilityModifierKeys.get(modIndex));\n+    }\n+    \n+    /**\n+     * Convenience method to get a random allied  facility modifier", "originalCommit": "ded0a76ab00c54323f9c24291d0a2582367b1792", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzM5ODg5MA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603398890", "bodyText": "Indent the switch", "author": "Windchild292", "createdAt": "2021-03-29T15:36:38Z", "path": "MekHQ/src/mekhq/campaign/mission/atb/AtBScenarioModifier.java", "diffHunk": "@@ -157,23 +182,142 @@ public void processModifier(AtBDynamicScenario scenario, Campaign campaign, Even\n         return scenarioModifierKeys;\n     }\n     \n-    public static AtBScenarioModifier getRandomScenarioModifier() {\n-        int modIndex = Compute.randomInt(scenarioModifierKeys.size());\n-        return scenarioModifiers.get(scenarioModifierKeys.get(modIndex));\n-    }\n-    \n     /**\n      * Convenience method to get a scenario modifier with the specified key.\n      * @param key The key\n      * @return The scenario modifier, if any.\n      */\n     public static AtBScenarioModifier getScenarioModifier(String key) {\n-        return scenarioModifiers.get(key);\n+        if (!scenarioModifiers.containsKey(key)) {\n+            MekHQ.getLogger().error(\"Scenario modifier \" + key + \" does not exist.\");\n+            return null;\n+        }\n+        \n+        // clone it to avoid calling code changing the modifier\n+        return scenarioModifiers.get(key).clone();\n+    }\n+    \n+    /**\n+     * Convenience method to get all the 'required' hostile facility modifiers()\n+     */\n+    public static List<AtBScenarioModifier> getRequiredHostileFacilityModifiers() {\n+        List<AtBScenarioModifier> retval = new ArrayList<>();\n+        for (String key : requiredHostileFacilityModifierKeys) {\n+            retval.add(scenarioModifiers.get(key).clone());\n+        }\n+        \n+        return retval;\n+    }\n+    \n+    /**\n+     * Convenience method to get a random hostile facility modifier\n+     * @return The scenario modifier, if any.\n+     */\n+    public static AtBScenarioModifier getRandomHostileFacilityModifier() {\n+        int modIndex = Compute.randomInt(hostileFacilityModifierKeys.size());\n+        \n+        return getScenarioModifier(hostileFacilityModifierKeys.get(modIndex));\n+    }\n+    \n+    /**\n+     * Convenience method to get a random allied  facility modifier\n+     * @return The scenario modifier, if any.\n+     */\n+    public static AtBScenarioModifier getRandomAlliedFacilityModifier() {\n+        int modIndex = Compute.randomInt(alliedFacilityModifierKeys.size());\n+        \n+        return getScenarioModifier(alliedFacilityModifierKeys.get(modIndex));\n+    }\n+    \n+    /**\n+     * Get a random modifier, appropriate for the map location (space, atmo, ground)\n+     */\n+    public static AtBScenarioModifier getRandomBattleModifier(MapLocation mapLocation) {\n+        return getRandomBattleModifier(mapLocation, null);\n+    }\n+    \n+    /**\n+     * Convenience method to get a random battle modifier\n+     * @return The scenario modifier, if any.\n+     */\n+    public static AtBScenarioModifier getRandomBattleModifier(MapLocation mapLocation, Boolean beneficial) {\n+        List<String> keyList = null;\n+        \n+        switch (mapLocation) {\n+        case Space:", "originalCommit": "ded0a76ab00c54323f9c24291d0a2582367b1792", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzM5OTA3OA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603399078", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if(keyList == null) {\n          \n          \n            \n                    if (keyList == null) {", "author": "Windchild292", "createdAt": "2021-03-29T15:36:50Z", "path": "MekHQ/src/mekhq/campaign/mission/atb/AtBScenarioModifier.java", "diffHunk": "@@ -157,23 +182,142 @@ public void processModifier(AtBDynamicScenario scenario, Campaign campaign, Even\n         return scenarioModifierKeys;\n     }\n     \n-    public static AtBScenarioModifier getRandomScenarioModifier() {\n-        int modIndex = Compute.randomInt(scenarioModifierKeys.size());\n-        return scenarioModifiers.get(scenarioModifierKeys.get(modIndex));\n-    }\n-    \n     /**\n      * Convenience method to get a scenario modifier with the specified key.\n      * @param key The key\n      * @return The scenario modifier, if any.\n      */\n     public static AtBScenarioModifier getScenarioModifier(String key) {\n-        return scenarioModifiers.get(key);\n+        if (!scenarioModifiers.containsKey(key)) {\n+            MekHQ.getLogger().error(\"Scenario modifier \" + key + \" does not exist.\");\n+            return null;\n+        }\n+        \n+        // clone it to avoid calling code changing the modifier\n+        return scenarioModifiers.get(key).clone();\n+    }\n+    \n+    /**\n+     * Convenience method to get all the 'required' hostile facility modifiers()\n+     */\n+    public static List<AtBScenarioModifier> getRequiredHostileFacilityModifiers() {\n+        List<AtBScenarioModifier> retval = new ArrayList<>();\n+        for (String key : requiredHostileFacilityModifierKeys) {\n+            retval.add(scenarioModifiers.get(key).clone());\n+        }\n+        \n+        return retval;\n+    }\n+    \n+    /**\n+     * Convenience method to get a random hostile facility modifier\n+     * @return The scenario modifier, if any.\n+     */\n+    public static AtBScenarioModifier getRandomHostileFacilityModifier() {\n+        int modIndex = Compute.randomInt(hostileFacilityModifierKeys.size());\n+        \n+        return getScenarioModifier(hostileFacilityModifierKeys.get(modIndex));\n+    }\n+    \n+    /**\n+     * Convenience method to get a random allied  facility modifier\n+     * @return The scenario modifier, if any.\n+     */\n+    public static AtBScenarioModifier getRandomAlliedFacilityModifier() {\n+        int modIndex = Compute.randomInt(alliedFacilityModifierKeys.size());\n+        \n+        return getScenarioModifier(alliedFacilityModifierKeys.get(modIndex));\n+    }\n+    \n+    /**\n+     * Get a random modifier, appropriate for the map location (space, atmo, ground)\n+     */\n+    public static AtBScenarioModifier getRandomBattleModifier(MapLocation mapLocation) {\n+        return getRandomBattleModifier(mapLocation, null);\n+    }\n+    \n+    /**\n+     * Convenience method to get a random battle modifier\n+     * @return The scenario modifier, if any.\n+     */\n+    public static AtBScenarioModifier getRandomBattleModifier(MapLocation mapLocation, Boolean beneficial) {\n+        List<String> keyList = null;\n+        \n+        switch (mapLocation) {\n+        case Space:\n+        case LowAtmosphere:\n+            if (beneficial == null) {\n+                keyList = airBattleModifierKeys;\n+            } else if (beneficial) {\n+                keyList = positiveAirBattleModifierKeys;\n+            } else if (!beneficial) {\n+                keyList = negativeAirBattleModifierKeys;\n+            }\n+            break;\n+        case AllGroundTerrain:\n+        case SpecificGroundTerrain:\n+        default:\n+            if (beneficial == null) {\n+                keyList = groundBattleModifierKeys;\n+            } else if (beneficial) {\n+                keyList = positiveGroundBattleModifierKeys;\n+            } else if (!beneficial) {\n+                keyList = negativeGroundBattleModifierKeys;\n+            }\n+            break;\n+        \n+        }\n+        \n+        if(keyList == null) {", "originalCommit": "ded0a76ab00c54323f9c24291d0a2582367b1792", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzM5OTM0Nw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603399347", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for(String modifierName : manifest.fileNameList) {\n          \n          \n            \n                    for (String modifierName : manifest.fileNameList) {", "author": "Windchild292", "createdAt": "2021-03-29T15:37:08Z", "path": "MekHQ/src/mekhq/campaign/mission/atb/AtBScenarioModifier.java", "diffHunk": "@@ -157,23 +182,142 @@ public void processModifier(AtBDynamicScenario scenario, Campaign campaign, Even\n         return scenarioModifierKeys;\n     }\n     \n-    public static AtBScenarioModifier getRandomScenarioModifier() {\n-        int modIndex = Compute.randomInt(scenarioModifierKeys.size());\n-        return scenarioModifiers.get(scenarioModifierKeys.get(modIndex));\n-    }\n-    \n     /**\n      * Convenience method to get a scenario modifier with the specified key.\n      * @param key The key\n      * @return The scenario modifier, if any.\n      */\n     public static AtBScenarioModifier getScenarioModifier(String key) {\n-        return scenarioModifiers.get(key);\n+        if (!scenarioModifiers.containsKey(key)) {\n+            MekHQ.getLogger().error(\"Scenario modifier \" + key + \" does not exist.\");\n+            return null;\n+        }\n+        \n+        // clone it to avoid calling code changing the modifier\n+        return scenarioModifiers.get(key).clone();\n+    }\n+    \n+    /**\n+     * Convenience method to get all the 'required' hostile facility modifiers()\n+     */\n+    public static List<AtBScenarioModifier> getRequiredHostileFacilityModifiers() {\n+        List<AtBScenarioModifier> retval = new ArrayList<>();\n+        for (String key : requiredHostileFacilityModifierKeys) {\n+            retval.add(scenarioModifiers.get(key).clone());\n+        }\n+        \n+        return retval;\n+    }\n+    \n+    /**\n+     * Convenience method to get a random hostile facility modifier\n+     * @return The scenario modifier, if any.\n+     */\n+    public static AtBScenarioModifier getRandomHostileFacilityModifier() {\n+        int modIndex = Compute.randomInt(hostileFacilityModifierKeys.size());\n+        \n+        return getScenarioModifier(hostileFacilityModifierKeys.get(modIndex));\n+    }\n+    \n+    /**\n+     * Convenience method to get a random allied  facility modifier\n+     * @return The scenario modifier, if any.\n+     */\n+    public static AtBScenarioModifier getRandomAlliedFacilityModifier() {\n+        int modIndex = Compute.randomInt(alliedFacilityModifierKeys.size());\n+        \n+        return getScenarioModifier(alliedFacilityModifierKeys.get(modIndex));\n+    }\n+    \n+    /**\n+     * Get a random modifier, appropriate for the map location (space, atmo, ground)\n+     */\n+    public static AtBScenarioModifier getRandomBattleModifier(MapLocation mapLocation) {\n+        return getRandomBattleModifier(mapLocation, null);\n+    }\n+    \n+    /**\n+     * Convenience method to get a random battle modifier\n+     * @return The scenario modifier, if any.\n+     */\n+    public static AtBScenarioModifier getRandomBattleModifier(MapLocation mapLocation, Boolean beneficial) {\n+        List<String> keyList = null;\n+        \n+        switch (mapLocation) {\n+        case Space:\n+        case LowAtmosphere:\n+            if (beneficial == null) {\n+                keyList = airBattleModifierKeys;\n+            } else if (beneficial) {\n+                keyList = positiveAirBattleModifierKeys;\n+            } else if (!beneficial) {\n+                keyList = negativeAirBattleModifierKeys;\n+            }\n+            break;\n+        case AllGroundTerrain:\n+        case SpecificGroundTerrain:\n+        default:\n+            if (beneficial == null) {\n+                keyList = groundBattleModifierKeys;\n+            } else if (beneficial) {\n+                keyList = positiveGroundBattleModifierKeys;\n+            } else if (!beneficial) {\n+                keyList = negativeGroundBattleModifierKeys;\n+            }\n+            break;\n+        \n+        }\n+        \n+        if(keyList == null) {\n+            return null;\n+        }\n+        \n+        int modIndex = Compute.randomInt(keyList.size());\n+        return getScenarioModifier(keyList.get(modIndex));\n     }\n     \n     static {\n         loadManifest();\n         loadScenarioModifiers();\n+\n+        initializeSpecificManifest(MekHqConstants.STRATCON_REQUIRED_HOSTILE_FACILITY_MODS, requiredHostileFacilityModifierKeys);\n+        initializeSpecificManifest(MekHqConstants.STRATCON_HOSTILE_FACILITY_MODS, hostileFacilityModifierKeys);\n+        initializeSpecificManifest(MekHqConstants.STRATCON_ALLIED_FACILITY_MODS, alliedFacilityModifierKeys);\n+        initializeSpecificManifest(MekHqConstants.STRATCON_GROUND_MODS, groundBattleModifierKeys);\n+        initializeSpecificManifest(MekHqConstants.STRATCON_AIR_MODS, airBattleModifierKeys);\n+        initializeSpecificManifest(MekHqConstants.STRATCON_PRIMARY_PLAYER_FORCE_MODS, primaryPlayerForceModifierKeys);\n+        \n+        initializePositiveNegativeManifests(groundBattleModifierKeys, positiveGroundBattleModifierKeys, negativeGroundBattleModifierKeys);\n+        initializePositiveNegativeManifests(airBattleModifierKeys, positiveAirBattleModifierKeys, negativeAirBattleModifierKeys);\n+    }\n+    \n+    /**\n+     * Initializes a specific manifest file name list from a file with the given name\n+     */\n+    private static void initializeSpecificManifest(String manifestFileName, List<String> keyCollection) {\n+        ScenarioModifierManifest manifest = ScenarioModifierManifest.Deserialize(manifestFileName);\n+        \n+        // add trimmed versions of each file name to the given collection\n+        for(String modifierName : manifest.fileNameList) {", "originalCommit": "ded0a76ab00c54323f9c24291d0a2582367b1792", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzM5OTQ4NQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603399485", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for(String modifier : modifiers) {\n          \n          \n            \n                        if(!scenarioModifiers.containsKey(modifier)) {\n          \n          \n            \n                    for (String modifier : modifiers) {\n          \n          \n            \n                        if (!scenarioModifiers.containsKey(modifier)) {", "author": "Windchild292", "createdAt": "2021-03-29T15:37:19Z", "path": "MekHQ/src/mekhq/campaign/mission/atb/AtBScenarioModifier.java", "diffHunk": "@@ -157,23 +182,142 @@ public void processModifier(AtBDynamicScenario scenario, Campaign campaign, Even\n         return scenarioModifierKeys;\n     }\n     \n-    public static AtBScenarioModifier getRandomScenarioModifier() {\n-        int modIndex = Compute.randomInt(scenarioModifierKeys.size());\n-        return scenarioModifiers.get(scenarioModifierKeys.get(modIndex));\n-    }\n-    \n     /**\n      * Convenience method to get a scenario modifier with the specified key.\n      * @param key The key\n      * @return The scenario modifier, if any.\n      */\n     public static AtBScenarioModifier getScenarioModifier(String key) {\n-        return scenarioModifiers.get(key);\n+        if (!scenarioModifiers.containsKey(key)) {\n+            MekHQ.getLogger().error(\"Scenario modifier \" + key + \" does not exist.\");\n+            return null;\n+        }\n+        \n+        // clone it to avoid calling code changing the modifier\n+        return scenarioModifiers.get(key).clone();\n+    }\n+    \n+    /**\n+     * Convenience method to get all the 'required' hostile facility modifiers()\n+     */\n+    public static List<AtBScenarioModifier> getRequiredHostileFacilityModifiers() {\n+        List<AtBScenarioModifier> retval = new ArrayList<>();\n+        for (String key : requiredHostileFacilityModifierKeys) {\n+            retval.add(scenarioModifiers.get(key).clone());\n+        }\n+        \n+        return retval;\n+    }\n+    \n+    /**\n+     * Convenience method to get a random hostile facility modifier\n+     * @return The scenario modifier, if any.\n+     */\n+    public static AtBScenarioModifier getRandomHostileFacilityModifier() {\n+        int modIndex = Compute.randomInt(hostileFacilityModifierKeys.size());\n+        \n+        return getScenarioModifier(hostileFacilityModifierKeys.get(modIndex));\n+    }\n+    \n+    /**\n+     * Convenience method to get a random allied  facility modifier\n+     * @return The scenario modifier, if any.\n+     */\n+    public static AtBScenarioModifier getRandomAlliedFacilityModifier() {\n+        int modIndex = Compute.randomInt(alliedFacilityModifierKeys.size());\n+        \n+        return getScenarioModifier(alliedFacilityModifierKeys.get(modIndex));\n+    }\n+    \n+    /**\n+     * Get a random modifier, appropriate for the map location (space, atmo, ground)\n+     */\n+    public static AtBScenarioModifier getRandomBattleModifier(MapLocation mapLocation) {\n+        return getRandomBattleModifier(mapLocation, null);\n+    }\n+    \n+    /**\n+     * Convenience method to get a random battle modifier\n+     * @return The scenario modifier, if any.\n+     */\n+    public static AtBScenarioModifier getRandomBattleModifier(MapLocation mapLocation, Boolean beneficial) {\n+        List<String> keyList = null;\n+        \n+        switch (mapLocation) {\n+        case Space:\n+        case LowAtmosphere:\n+            if (beneficial == null) {\n+                keyList = airBattleModifierKeys;\n+            } else if (beneficial) {\n+                keyList = positiveAirBattleModifierKeys;\n+            } else if (!beneficial) {\n+                keyList = negativeAirBattleModifierKeys;\n+            }\n+            break;\n+        case AllGroundTerrain:\n+        case SpecificGroundTerrain:\n+        default:\n+            if (beneficial == null) {\n+                keyList = groundBattleModifierKeys;\n+            } else if (beneficial) {\n+                keyList = positiveGroundBattleModifierKeys;\n+            } else if (!beneficial) {\n+                keyList = negativeGroundBattleModifierKeys;\n+            }\n+            break;\n+        \n+        }\n+        \n+        if(keyList == null) {\n+            return null;\n+        }\n+        \n+        int modIndex = Compute.randomInt(keyList.size());\n+        return getScenarioModifier(keyList.get(modIndex));\n     }\n     \n     static {\n         loadManifest();\n         loadScenarioModifiers();\n+\n+        initializeSpecificManifest(MekHqConstants.STRATCON_REQUIRED_HOSTILE_FACILITY_MODS, requiredHostileFacilityModifierKeys);\n+        initializeSpecificManifest(MekHqConstants.STRATCON_HOSTILE_FACILITY_MODS, hostileFacilityModifierKeys);\n+        initializeSpecificManifest(MekHqConstants.STRATCON_ALLIED_FACILITY_MODS, alliedFacilityModifierKeys);\n+        initializeSpecificManifest(MekHqConstants.STRATCON_GROUND_MODS, groundBattleModifierKeys);\n+        initializeSpecificManifest(MekHqConstants.STRATCON_AIR_MODS, airBattleModifierKeys);\n+        initializeSpecificManifest(MekHqConstants.STRATCON_PRIMARY_PLAYER_FORCE_MODS, primaryPlayerForceModifierKeys);\n+        \n+        initializePositiveNegativeManifests(groundBattleModifierKeys, positiveGroundBattleModifierKeys, negativeGroundBattleModifierKeys);\n+        initializePositiveNegativeManifests(airBattleModifierKeys, positiveAirBattleModifierKeys, negativeAirBattleModifierKeys);\n+    }\n+    \n+    /**\n+     * Initializes a specific manifest file name list from a file with the given name\n+     */\n+    private static void initializeSpecificManifest(String manifestFileName, List<String> keyCollection) {\n+        ScenarioModifierManifest manifest = ScenarioModifierManifest.Deserialize(manifestFileName);\n+        \n+        // add trimmed versions of each file name to the given collection\n+        for(String modifierName : manifest.fileNameList) {\n+            keyCollection.add(modifierName.trim());\n+        }\n+    }\n+    \n+    /**\n+     * Divides the given modifiers into a positive and negative bucket.\n+     */\n+    private static void initializePositiveNegativeManifests(List<String> modifiers, List<String> positiveKeyCollection, List<String> negativeKeyCollection) {\n+        for(String modifier : modifiers) {\n+            if(!scenarioModifiers.containsKey(modifier)) {", "originalCommit": "ded0a76ab00c54323f9c24291d0a2582367b1792", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzM5OTYwOA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603399608", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if(scenarioModifiers.get(modifier).benefitsPlayer) {\n          \n          \n            \n                        if (scenarioModifiers.get(modifier).benefitsPlayer) {", "author": "Windchild292", "createdAt": "2021-03-29T15:37:26Z", "path": "MekHQ/src/mekhq/campaign/mission/atb/AtBScenarioModifier.java", "diffHunk": "@@ -157,23 +182,142 @@ public void processModifier(AtBDynamicScenario scenario, Campaign campaign, Even\n         return scenarioModifierKeys;\n     }\n     \n-    public static AtBScenarioModifier getRandomScenarioModifier() {\n-        int modIndex = Compute.randomInt(scenarioModifierKeys.size());\n-        return scenarioModifiers.get(scenarioModifierKeys.get(modIndex));\n-    }\n-    \n     /**\n      * Convenience method to get a scenario modifier with the specified key.\n      * @param key The key\n      * @return The scenario modifier, if any.\n      */\n     public static AtBScenarioModifier getScenarioModifier(String key) {\n-        return scenarioModifiers.get(key);\n+        if (!scenarioModifiers.containsKey(key)) {\n+            MekHQ.getLogger().error(\"Scenario modifier \" + key + \" does not exist.\");\n+            return null;\n+        }\n+        \n+        // clone it to avoid calling code changing the modifier\n+        return scenarioModifiers.get(key).clone();\n+    }\n+    \n+    /**\n+     * Convenience method to get all the 'required' hostile facility modifiers()\n+     */\n+    public static List<AtBScenarioModifier> getRequiredHostileFacilityModifiers() {\n+        List<AtBScenarioModifier> retval = new ArrayList<>();\n+        for (String key : requiredHostileFacilityModifierKeys) {\n+            retval.add(scenarioModifiers.get(key).clone());\n+        }\n+        \n+        return retval;\n+    }\n+    \n+    /**\n+     * Convenience method to get a random hostile facility modifier\n+     * @return The scenario modifier, if any.\n+     */\n+    public static AtBScenarioModifier getRandomHostileFacilityModifier() {\n+        int modIndex = Compute.randomInt(hostileFacilityModifierKeys.size());\n+        \n+        return getScenarioModifier(hostileFacilityModifierKeys.get(modIndex));\n+    }\n+    \n+    /**\n+     * Convenience method to get a random allied  facility modifier\n+     * @return The scenario modifier, if any.\n+     */\n+    public static AtBScenarioModifier getRandomAlliedFacilityModifier() {\n+        int modIndex = Compute.randomInt(alliedFacilityModifierKeys.size());\n+        \n+        return getScenarioModifier(alliedFacilityModifierKeys.get(modIndex));\n+    }\n+    \n+    /**\n+     * Get a random modifier, appropriate for the map location (space, atmo, ground)\n+     */\n+    public static AtBScenarioModifier getRandomBattleModifier(MapLocation mapLocation) {\n+        return getRandomBattleModifier(mapLocation, null);\n+    }\n+    \n+    /**\n+     * Convenience method to get a random battle modifier\n+     * @return The scenario modifier, if any.\n+     */\n+    public static AtBScenarioModifier getRandomBattleModifier(MapLocation mapLocation, Boolean beneficial) {\n+        List<String> keyList = null;\n+        \n+        switch (mapLocation) {\n+        case Space:\n+        case LowAtmosphere:\n+            if (beneficial == null) {\n+                keyList = airBattleModifierKeys;\n+            } else if (beneficial) {\n+                keyList = positiveAirBattleModifierKeys;\n+            } else if (!beneficial) {\n+                keyList = negativeAirBattleModifierKeys;\n+            }\n+            break;\n+        case AllGroundTerrain:\n+        case SpecificGroundTerrain:\n+        default:\n+            if (beneficial == null) {\n+                keyList = groundBattleModifierKeys;\n+            } else if (beneficial) {\n+                keyList = positiveGroundBattleModifierKeys;\n+            } else if (!beneficial) {\n+                keyList = negativeGroundBattleModifierKeys;\n+            }\n+            break;\n+        \n+        }\n+        \n+        if(keyList == null) {\n+            return null;\n+        }\n+        \n+        int modIndex = Compute.randomInt(keyList.size());\n+        return getScenarioModifier(keyList.get(modIndex));\n     }\n     \n     static {\n         loadManifest();\n         loadScenarioModifiers();\n+\n+        initializeSpecificManifest(MekHqConstants.STRATCON_REQUIRED_HOSTILE_FACILITY_MODS, requiredHostileFacilityModifierKeys);\n+        initializeSpecificManifest(MekHqConstants.STRATCON_HOSTILE_FACILITY_MODS, hostileFacilityModifierKeys);\n+        initializeSpecificManifest(MekHqConstants.STRATCON_ALLIED_FACILITY_MODS, alliedFacilityModifierKeys);\n+        initializeSpecificManifest(MekHqConstants.STRATCON_GROUND_MODS, groundBattleModifierKeys);\n+        initializeSpecificManifest(MekHqConstants.STRATCON_AIR_MODS, airBattleModifierKeys);\n+        initializeSpecificManifest(MekHqConstants.STRATCON_PRIMARY_PLAYER_FORCE_MODS, primaryPlayerForceModifierKeys);\n+        \n+        initializePositiveNegativeManifests(groundBattleModifierKeys, positiveGroundBattleModifierKeys, negativeGroundBattleModifierKeys);\n+        initializePositiveNegativeManifests(airBattleModifierKeys, positiveAirBattleModifierKeys, negativeAirBattleModifierKeys);\n+    }\n+    \n+    /**\n+     * Initializes a specific manifest file name list from a file with the given name\n+     */\n+    private static void initializeSpecificManifest(String manifestFileName, List<String> keyCollection) {\n+        ScenarioModifierManifest manifest = ScenarioModifierManifest.Deserialize(manifestFileName);\n+        \n+        // add trimmed versions of each file name to the given collection\n+        for(String modifierName : manifest.fileNameList) {\n+            keyCollection.add(modifierName.trim());\n+        }\n+    }\n+    \n+    /**\n+     * Divides the given modifiers into a positive and negative bucket.\n+     */\n+    private static void initializePositiveNegativeManifests(List<String> modifiers, List<String> positiveKeyCollection, List<String> negativeKeyCollection) {\n+        for(String modifier : modifiers) {\n+            if(!scenarioModifiers.containsKey(modifier)) {\n+                continue;\n+            }\n+            \n+            if(scenarioModifiers.get(modifier).benefitsPlayer) {", "originalCommit": "ded0a76ab00c54323f9c24291d0a2582367b1792", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzM5OTgxNQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603399815", "bodyText": "This looks odd...", "author": "Windchild292", "createdAt": "2021-03-29T15:37:42Z", "path": "MekHQ/src/mekhq/campaign/mission/atb/AtBScenarioModifier.java", "diffHunk": "@@ -208,17 +352,16 @@ private static void loadScenarioModifiers() {\n                 AtBScenarioModifier modifier = Deserialize(filePath);\n                 \n                 if(modifier != null) {\n+                    scenarioModifiers.put(fileName, modifier);\n+                    scenarioModifierKeys.add(fileName);\n+                    \n                     if(modifier.getModifierName() == null) {\n                         modifier.setModifierName(fileName);\n                     }\n-                    \n-                    scenarioModifiers.put(modifier.getModifierName(), modifier);\n-                    scenarioModifierKeys.add(modifier.getModifierName());\n-                }\n+\t\t\t\t}", "originalCommit": "ded0a76ab00c54323f9c24291d0a2582367b1792", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzQwMDM1OA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603400358", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @XmlElementWrapper(name=\"allowedMapLocations\")\n          \n          \n            \n                @XmlElement(name=\"allowedMapLocation\")\n          \n          \n            \n                @XmlElementWrapper(name = \"allowedMapLocations\")\n          \n          \n            \n                @XmlElement(name = \"allowedMapLocation\")", "author": "Windchild292", "createdAt": "2021-03-29T15:38:19Z", "path": "MekHQ/src/mekhq/campaign/mission/atb/AtBScenarioModifier.java", "diffHunk": "@@ -377,6 +543,8 @@ public void setUnitRemovalCount(Integer unitRemovalCount) {\n         this.unitRemovalCount = unitRemovalCount;\n     }\n \n+    @XmlElementWrapper(name=\"allowedMapLocations\")\n+    @XmlElement(name=\"allowedMapLocation\")", "originalCommit": "ded0a76ab00c54323f9c24291d0a2582367b1792", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzQwMTA2Mw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603401063", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             *\n          \n          \n            \n             */\n          \n          \n            \n             */", "author": "Windchild292", "createdAt": "2021-03-29T15:39:13Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconFacility.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBElement;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.transform.Source;\n+\n+import mekhq.MekHQ;\n+import mekhq.MekHqXmlUtil;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+\n+/**\n+ * This represents a facility in the StratCon context\n+ * @author NickAragua\n+ *\n+ */", "originalCommit": "ded0a76ab00c54323f9c24291d0a2582367b1792", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzQwMTE4Mg==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603401182", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            @XmlRootElement(name=\"StratconFacility\")\n          \n          \n            \n            @XmlRootElement(name = \"StratconFacility\")", "author": "Windchild292", "createdAt": "2021-03-29T15:39:24Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconFacility.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBElement;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.transform.Source;\n+\n+import mekhq.MekHQ;\n+import mekhq.MekHqXmlUtil;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+\n+/**\n+ * This represents a facility in the StratCon context\n+ * @author NickAragua\n+ *\n+ */\n+@XmlRootElement(name=\"StratconFacility\")", "originalCommit": "ded0a76ab00c54323f9c24291d0a2582367b1792", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzQwMTgwMA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603401800", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             *\n          \n          \n            \n             */\n          \n          \n            \n             */", "author": "Windchild292", "createdAt": "2021-03-29T15:40:11Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconFacilityFactory.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import megamek.common.Compute;\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.Utilities;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+\n+/**\n+ * This class handles functionality related to loading and stratcon facility definitions.\n+ * @author NickAragua\n+ *\n+ */", "originalCommit": "ded0a76ab00c54323f9c24291d0a2582367b1792", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzQwMjIwMw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603402203", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if(facilityManifest != null) {\n          \n          \n            \n                    if (facilityManifest != null) {", "author": "Windchild292", "createdAt": "2021-03-29T15:40:43Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconFacilityFactory.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import megamek.common.Compute;\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.Utilities;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+\n+/**\n+ * This class handles functionality related to loading and stratcon facility definitions.\n+ * @author NickAragua\n+ *\n+ */\n+public class StratconFacilityFactory {\n+    // loaded facility definitions\n+    \n+    // map of filename -> facility definition, for specific facility retrieval\n+    private static Map<String, StratconFacility> stratconFacilityMap = new HashMap<>();\n+    \n+    // list of all loaded facility definitions\n+    private static List<StratconFacility> stratconFacilityList = new ArrayList<>();\n+    \n+    // list of all hostile facility defs for convenience\n+    private static List<StratconFacility> hostileFacilities = new ArrayList<>();\n+    \n+    // list of all allied facility defs for convenience\n+    private static List<StratconFacility> alliedFacilities = new ArrayList<>();\n+    \n+    static {\n+        reloadFacilities();\n+    }\n+    \n+    /**\n+     * Worker function that reloads all the facilities from disk\n+     */\n+    public static void reloadFacilities() {\n+        stratconFacilityList.clear();\n+        hostileFacilities.clear();\n+        alliedFacilities.clear();\n+        stratconFacilityMap.clear();\n+        \n+        // load dynamic scenarios\n+        StratconFacilityManifest facilityManifest = StratconFacilityManifest.deserialize(MekHqConstants.STRATCON_FACILITY_MANIFEST);\n+        \n+        // load user-specified scenario list\n+        StratconFacilityManifest userManifest = StratconFacilityManifest.deserialize(MekHqConstants.STRATCON_USER_FACILITY_MANIFEST);\n+        \n+        if(facilityManifest != null) {", "originalCommit": "ded0a76ab00c54323f9c24291d0a2582367b1792", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzQwMjI5Mw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603402293", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if(userManifest != null) {\n          \n          \n            \n                    if (userManifest != null) {", "author": "Windchild292", "createdAt": "2021-03-29T15:40:50Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconFacilityFactory.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import megamek.common.Compute;\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.Utilities;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+\n+/**\n+ * This class handles functionality related to loading and stratcon facility definitions.\n+ * @author NickAragua\n+ *\n+ */\n+public class StratconFacilityFactory {\n+    // loaded facility definitions\n+    \n+    // map of filename -> facility definition, for specific facility retrieval\n+    private static Map<String, StratconFacility> stratconFacilityMap = new HashMap<>();\n+    \n+    // list of all loaded facility definitions\n+    private static List<StratconFacility> stratconFacilityList = new ArrayList<>();\n+    \n+    // list of all hostile facility defs for convenience\n+    private static List<StratconFacility> hostileFacilities = new ArrayList<>();\n+    \n+    // list of all allied facility defs for convenience\n+    private static List<StratconFacility> alliedFacilities = new ArrayList<>();\n+    \n+    static {\n+        reloadFacilities();\n+    }\n+    \n+    /**\n+     * Worker function that reloads all the facilities from disk\n+     */\n+    public static void reloadFacilities() {\n+        stratconFacilityList.clear();\n+        hostileFacilities.clear();\n+        alliedFacilities.clear();\n+        stratconFacilityMap.clear();\n+        \n+        // load dynamic scenarios\n+        StratconFacilityManifest facilityManifest = StratconFacilityManifest.deserialize(MekHqConstants.STRATCON_FACILITY_MANIFEST);\n+        \n+        // load user-specified scenario list\n+        StratconFacilityManifest userManifest = StratconFacilityManifest.deserialize(MekHqConstants.STRATCON_USER_FACILITY_MANIFEST);\n+        \n+        if(facilityManifest != null) {\n+            loadFacilitiesFromManifest(facilityManifest);\n+        }\n+        \n+        if(userManifest != null) {", "originalCommit": "ded0a76ab00c54323f9c24291d0a2582367b1792", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzQwMjM5Mg==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603402392", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if(manifest == null) {\n          \n          \n            \n                    if (manifest == null) {", "author": "Windchild292", "createdAt": "2021-03-29T15:40:58Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconFacilityFactory.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import megamek.common.Compute;\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.Utilities;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+\n+/**\n+ * This class handles functionality related to loading and stratcon facility definitions.\n+ * @author NickAragua\n+ *\n+ */\n+public class StratconFacilityFactory {\n+    // loaded facility definitions\n+    \n+    // map of filename -> facility definition, for specific facility retrieval\n+    private static Map<String, StratconFacility> stratconFacilityMap = new HashMap<>();\n+    \n+    // list of all loaded facility definitions\n+    private static List<StratconFacility> stratconFacilityList = new ArrayList<>();\n+    \n+    // list of all hostile facility defs for convenience\n+    private static List<StratconFacility> hostileFacilities = new ArrayList<>();\n+    \n+    // list of all allied facility defs for convenience\n+    private static List<StratconFacility> alliedFacilities = new ArrayList<>();\n+    \n+    static {\n+        reloadFacilities();\n+    }\n+    \n+    /**\n+     * Worker function that reloads all the facilities from disk\n+     */\n+    public static void reloadFacilities() {\n+        stratconFacilityList.clear();\n+        hostileFacilities.clear();\n+        alliedFacilities.clear();\n+        stratconFacilityMap.clear();\n+        \n+        // load dynamic scenarios\n+        StratconFacilityManifest facilityManifest = StratconFacilityManifest.deserialize(MekHqConstants.STRATCON_FACILITY_MANIFEST);\n+        \n+        // load user-specified scenario list\n+        StratconFacilityManifest userManifest = StratconFacilityManifest.deserialize(MekHqConstants.STRATCON_USER_FACILITY_MANIFEST);\n+        \n+        if(facilityManifest != null) {\n+            loadFacilitiesFromManifest(facilityManifest);\n+        }\n+        \n+        if(userManifest != null) {\n+            loadFacilitiesFromManifest(userManifest);\n+        }\n+    }\n+    \n+    /**\n+     * Helper function that loads scenario templates from the given manifest.\n+     * @param manifest The manifest to process\n+     */\n+    private static void loadFacilitiesFromManifest(StratconFacilityManifest manifest) {\n+        if(manifest == null) {", "originalCommit": "ded0a76ab00c54323f9c24291d0a2582367b1792", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzQwMjUwOA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603402508", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for(String fileName : manifest.facilityFileNames) {\n          \n          \n            \n                    for (String fileName : manifest.facilityFileNames) {", "author": "Windchild292", "createdAt": "2021-03-29T15:41:06Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconFacilityFactory.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import megamek.common.Compute;\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.Utilities;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+\n+/**\n+ * This class handles functionality related to loading and stratcon facility definitions.\n+ * @author NickAragua\n+ *\n+ */\n+public class StratconFacilityFactory {\n+    // loaded facility definitions\n+    \n+    // map of filename -> facility definition, for specific facility retrieval\n+    private static Map<String, StratconFacility> stratconFacilityMap = new HashMap<>();\n+    \n+    // list of all loaded facility definitions\n+    private static List<StratconFacility> stratconFacilityList = new ArrayList<>();\n+    \n+    // list of all hostile facility defs for convenience\n+    private static List<StratconFacility> hostileFacilities = new ArrayList<>();\n+    \n+    // list of all allied facility defs for convenience\n+    private static List<StratconFacility> alliedFacilities = new ArrayList<>();\n+    \n+    static {\n+        reloadFacilities();\n+    }\n+    \n+    /**\n+     * Worker function that reloads all the facilities from disk\n+     */\n+    public static void reloadFacilities() {\n+        stratconFacilityList.clear();\n+        hostileFacilities.clear();\n+        alliedFacilities.clear();\n+        stratconFacilityMap.clear();\n+        \n+        // load dynamic scenarios\n+        StratconFacilityManifest facilityManifest = StratconFacilityManifest.deserialize(MekHqConstants.STRATCON_FACILITY_MANIFEST);\n+        \n+        // load user-specified scenario list\n+        StratconFacilityManifest userManifest = StratconFacilityManifest.deserialize(MekHqConstants.STRATCON_USER_FACILITY_MANIFEST);\n+        \n+        if(facilityManifest != null) {\n+            loadFacilitiesFromManifest(facilityManifest);\n+        }\n+        \n+        if(userManifest != null) {\n+            loadFacilitiesFromManifest(userManifest);\n+        }\n+    }\n+    \n+    /**\n+     * Helper function that loads scenario templates from the given manifest.\n+     * @param manifest The manifest to process\n+     */\n+    private static void loadFacilitiesFromManifest(StratconFacilityManifest manifest) {\n+        if(manifest == null) {\n+            return;\n+        }\n+        \n+        for(String fileName : manifest.facilityFileNames) {", "originalCommit": "ded0a76ab00c54323f9c24291d0a2582367b1792", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzQwMjU4MQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603402581", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if(facility != null) {\n          \n          \n            \n                            if (facility != null) {", "author": "Windchild292", "createdAt": "2021-03-29T15:41:12Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconFacilityFactory.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import megamek.common.Compute;\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.Utilities;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+\n+/**\n+ * This class handles functionality related to loading and stratcon facility definitions.\n+ * @author NickAragua\n+ *\n+ */\n+public class StratconFacilityFactory {\n+    // loaded facility definitions\n+    \n+    // map of filename -> facility definition, for specific facility retrieval\n+    private static Map<String, StratconFacility> stratconFacilityMap = new HashMap<>();\n+    \n+    // list of all loaded facility definitions\n+    private static List<StratconFacility> stratconFacilityList = new ArrayList<>();\n+    \n+    // list of all hostile facility defs for convenience\n+    private static List<StratconFacility> hostileFacilities = new ArrayList<>();\n+    \n+    // list of all allied facility defs for convenience\n+    private static List<StratconFacility> alliedFacilities = new ArrayList<>();\n+    \n+    static {\n+        reloadFacilities();\n+    }\n+    \n+    /**\n+     * Worker function that reloads all the facilities from disk\n+     */\n+    public static void reloadFacilities() {\n+        stratconFacilityList.clear();\n+        hostileFacilities.clear();\n+        alliedFacilities.clear();\n+        stratconFacilityMap.clear();\n+        \n+        // load dynamic scenarios\n+        StratconFacilityManifest facilityManifest = StratconFacilityManifest.deserialize(MekHqConstants.STRATCON_FACILITY_MANIFEST);\n+        \n+        // load user-specified scenario list\n+        StratconFacilityManifest userManifest = StratconFacilityManifest.deserialize(MekHqConstants.STRATCON_USER_FACILITY_MANIFEST);\n+        \n+        if(facilityManifest != null) {\n+            loadFacilitiesFromManifest(facilityManifest);\n+        }\n+        \n+        if(userManifest != null) {\n+            loadFacilitiesFromManifest(userManifest);\n+        }\n+    }\n+    \n+    /**\n+     * Helper function that loads scenario templates from the given manifest.\n+     * @param manifest The manifest to process\n+     */\n+    private static void loadFacilitiesFromManifest(StratconFacilityManifest manifest) {\n+        if(manifest == null) {\n+            return;\n+        }\n+        \n+        for(String fileName : manifest.facilityFileNames) {\n+            String filePath = Paths.get(MekHqConstants.STRATCON_FACILITY_PATH, fileName.trim()).toString();\n+            \n+            try {\n+                StratconFacility facility = StratconFacility.deserialize(filePath);\n+                \n+                if(facility != null) {", "originalCommit": "ded0a76ab00c54323f9c24291d0a2582367b1792", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzQwMjY2MQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603402661", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                if(facility.getOwner() == ForceAlignment.Allied) {\n          \n          \n            \n                                if (facility.getOwner() == ForceAlignment.Allied) {", "author": "Windchild292", "createdAt": "2021-03-29T15:41:19Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconFacilityFactory.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import megamek.common.Compute;\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.Utilities;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+\n+/**\n+ * This class handles functionality related to loading and stratcon facility definitions.\n+ * @author NickAragua\n+ *\n+ */\n+public class StratconFacilityFactory {\n+    // loaded facility definitions\n+    \n+    // map of filename -> facility definition, for specific facility retrieval\n+    private static Map<String, StratconFacility> stratconFacilityMap = new HashMap<>();\n+    \n+    // list of all loaded facility definitions\n+    private static List<StratconFacility> stratconFacilityList = new ArrayList<>();\n+    \n+    // list of all hostile facility defs for convenience\n+    private static List<StratconFacility> hostileFacilities = new ArrayList<>();\n+    \n+    // list of all allied facility defs for convenience\n+    private static List<StratconFacility> alliedFacilities = new ArrayList<>();\n+    \n+    static {\n+        reloadFacilities();\n+    }\n+    \n+    /**\n+     * Worker function that reloads all the facilities from disk\n+     */\n+    public static void reloadFacilities() {\n+        stratconFacilityList.clear();\n+        hostileFacilities.clear();\n+        alliedFacilities.clear();\n+        stratconFacilityMap.clear();\n+        \n+        // load dynamic scenarios\n+        StratconFacilityManifest facilityManifest = StratconFacilityManifest.deserialize(MekHqConstants.STRATCON_FACILITY_MANIFEST);\n+        \n+        // load user-specified scenario list\n+        StratconFacilityManifest userManifest = StratconFacilityManifest.deserialize(MekHqConstants.STRATCON_USER_FACILITY_MANIFEST);\n+        \n+        if(facilityManifest != null) {\n+            loadFacilitiesFromManifest(facilityManifest);\n+        }\n+        \n+        if(userManifest != null) {\n+            loadFacilitiesFromManifest(userManifest);\n+        }\n+    }\n+    \n+    /**\n+     * Helper function that loads scenario templates from the given manifest.\n+     * @param manifest The manifest to process\n+     */\n+    private static void loadFacilitiesFromManifest(StratconFacilityManifest manifest) {\n+        if(manifest == null) {\n+            return;\n+        }\n+        \n+        for(String fileName : manifest.facilityFileNames) {\n+            String filePath = Paths.get(MekHqConstants.STRATCON_FACILITY_PATH, fileName.trim()).toString();\n+            \n+            try {\n+                StratconFacility facility = StratconFacility.deserialize(filePath);\n+                \n+                if(facility != null) {\n+                    stratconFacilityList.add(facility);\n+                    stratconFacilityMap.put(fileName.trim(), facility);\n+                    \n+                    if(facility.getOwner() == ForceAlignment.Allied) {", "originalCommit": "ded0a76ab00c54323f9c24291d0a2582367b1792", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzQwMjc0NQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603402745", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        } catch(Exception e) {\n          \n          \n            \n                        } catch (Exception e) {", "author": "Windchild292", "createdAt": "2021-03-29T15:41:24Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconFacilityFactory.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import megamek.common.Compute;\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.Utilities;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+\n+/**\n+ * This class handles functionality related to loading and stratcon facility definitions.\n+ * @author NickAragua\n+ *\n+ */\n+public class StratconFacilityFactory {\n+    // loaded facility definitions\n+    \n+    // map of filename -> facility definition, for specific facility retrieval\n+    private static Map<String, StratconFacility> stratconFacilityMap = new HashMap<>();\n+    \n+    // list of all loaded facility definitions\n+    private static List<StratconFacility> stratconFacilityList = new ArrayList<>();\n+    \n+    // list of all hostile facility defs for convenience\n+    private static List<StratconFacility> hostileFacilities = new ArrayList<>();\n+    \n+    // list of all allied facility defs for convenience\n+    private static List<StratconFacility> alliedFacilities = new ArrayList<>();\n+    \n+    static {\n+        reloadFacilities();\n+    }\n+    \n+    /**\n+     * Worker function that reloads all the facilities from disk\n+     */\n+    public static void reloadFacilities() {\n+        stratconFacilityList.clear();\n+        hostileFacilities.clear();\n+        alliedFacilities.clear();\n+        stratconFacilityMap.clear();\n+        \n+        // load dynamic scenarios\n+        StratconFacilityManifest facilityManifest = StratconFacilityManifest.deserialize(MekHqConstants.STRATCON_FACILITY_MANIFEST);\n+        \n+        // load user-specified scenario list\n+        StratconFacilityManifest userManifest = StratconFacilityManifest.deserialize(MekHqConstants.STRATCON_USER_FACILITY_MANIFEST);\n+        \n+        if(facilityManifest != null) {\n+            loadFacilitiesFromManifest(facilityManifest);\n+        }\n+        \n+        if(userManifest != null) {\n+            loadFacilitiesFromManifest(userManifest);\n+        }\n+    }\n+    \n+    /**\n+     * Helper function that loads scenario templates from the given manifest.\n+     * @param manifest The manifest to process\n+     */\n+    private static void loadFacilitiesFromManifest(StratconFacilityManifest manifest) {\n+        if(manifest == null) {\n+            return;\n+        }\n+        \n+        for(String fileName : manifest.facilityFileNames) {\n+            String filePath = Paths.get(MekHqConstants.STRATCON_FACILITY_PATH, fileName.trim()).toString();\n+            \n+            try {\n+                StratconFacility facility = StratconFacility.deserialize(filePath);\n+                \n+                if(facility != null) {\n+                    stratconFacilityList.add(facility);\n+                    stratconFacilityMap.put(fileName.trim(), facility);\n+                    \n+                    if(facility.getOwner() == ForceAlignment.Allied) {\n+                        alliedFacilities.add(facility);\n+                    } else {\n+                        hostileFacilities.add(facility);\n+                    }\n+                }\n+            } catch(Exception e) {", "originalCommit": "ded0a76ab00c54323f9c24291d0a2582367b1792", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzQwMzIzNA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603403234", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n          \n          \n            \n             * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the", "author": "Windchild292", "createdAt": "2021-03-29T15:42:07Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconCampaignState.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright (c) 2019 The Megamek Team. All rights reserved.\n+ *\n+ * This file is part of MekHQ.\n+ *\n+ * MekHQ is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * MekHQ is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", "originalCommit": "ded0a76ab00c54323f9c24291d0a2582367b1792", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzQwMzM2NQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603403365", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * along with MekHQ.  If not, see <http://www.gnu.org/licenses/>.\n          \n          \n            \n             * along with MekHQ. If not, see <http://www.gnu.org/licenses/>.", "author": "Windchild292", "createdAt": "2021-03-29T15:42:15Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconCampaignState.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright (c) 2019 The Megamek Team. All rights reserved.\n+ *\n+ * This file is part of MekHQ.\n+ *\n+ * MekHQ is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * MekHQ is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with MekHQ.  If not, see <http://www.gnu.org/licenses/>.", "originalCommit": "ded0a76ab00c54323f9c24291d0a2582367b1792", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzQwMzUxNA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603403514", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            @XmlRootElement(name=\"StratconCampaignState\")\n          \n          \n            \n            @XmlRootElement(name = \"StratconCampaignState\")", "author": "Windchild292", "createdAt": "2021-03-29T15:42:25Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconCampaignState.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright (c) 2019 The Megamek Team. All rights reserved.\n+ *\n+ * This file is part of MekHQ.\n+ *\n+ * MekHQ is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * MekHQ is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with MekHQ.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBElement;\n+import javax.xml.bind.Marshaller;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlTransient;\n+import javax.xml.namespace.QName;\n+\n+import org.w3c.dom.Node;\n+\n+import mekhq.MekHQ;\n+import mekhq.campaign.mission.AtBContract;\n+\n+/**\n+ * Contract-level state object for a StratCon campaign.\n+ * @author NickAragua\n+ */\n+@XmlRootElement(name=\"StratconCampaignState\")", "originalCommit": "ded0a76ab00c54323f9c24291d0a2582367b1792", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzQwMzY3NA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603403674", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @XmlElementWrapper(name=\"campaignTracks\")\n          \n          \n            \n                @XmlElement(name=\"campaignTrack\")\n          \n          \n            \n                @XmlElementWrapper(name = \"campaignTracks\")\n          \n          \n            \n                @XmlElement(name = \"campaignTrack\")", "author": "Windchild292", "createdAt": "2021-03-29T15:42:38Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconCampaignState.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright (c) 2019 The Megamek Team. All rights reserved.\n+ *\n+ * This file is part of MekHQ.\n+ *\n+ * MekHQ is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * MekHQ is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with MekHQ.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBElement;\n+import javax.xml.bind.Marshaller;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlTransient;\n+import javax.xml.namespace.QName;\n+\n+import org.w3c.dom.Node;\n+\n+import mekhq.MekHQ;\n+import mekhq.campaign.mission.AtBContract;\n+\n+/**\n+ * Contract-level state object for a StratCon campaign.\n+ * @author NickAragua\n+ */\n+@XmlRootElement(name=\"StratconCampaignState\")\n+public class StratconCampaignState {\n+    public static final String ROOT_XML_ELEMENT_NAME = \"StratconCampaignState\";\n+    \n+    @XmlTransient\n+    private AtBContract contract;\n+\n+    // these are all state variables that affect the current Stratcon Campaign\n+    private double globalOpforBVMultiplier;\n+    private int supportPoints;\n+    private int victoryPoints;\n+    private int pendingStrategicObjectiveCount;\n+    private int completedStrategicObjectiveCount;\n+    private String briefingText; \n+    private boolean strategicObjectivesBehaveAsVPs;\n+    \n+    // these are applied to any scenario generated in the campaign; use sparingly\n+    private List<String> globalScenarioModifiers = new ArrayList<>(); \n+    \n+    @XmlElementWrapper(name=\"campaignTracks\")\n+    @XmlElement(name=\"campaignTrack\")", "originalCommit": "ded0a76ab00c54323f9c24291d0a2582367b1792", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzQwNDAxNQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603404015", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if(trackState.getAssignedForceCoords().containsKey(forceID)) {\n          \n          \n            \n                        if (trackState.getAssignedForceCoords().containsKey(forceID)) {", "author": "Windchild292", "createdAt": "2021-03-29T15:43:04Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconCampaignState.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright (c) 2019 The Megamek Team. All rights reserved.\n+ *\n+ * This file is part of MekHQ.\n+ *\n+ * MekHQ is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * MekHQ is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with MekHQ.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBElement;\n+import javax.xml.bind.Marshaller;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlTransient;\n+import javax.xml.namespace.QName;\n+\n+import org.w3c.dom.Node;\n+\n+import mekhq.MekHQ;\n+import mekhq.campaign.mission.AtBContract;\n+\n+/**\n+ * Contract-level state object for a StratCon campaign.\n+ * @author NickAragua\n+ */\n+@XmlRootElement(name=\"StratconCampaignState\")\n+public class StratconCampaignState {\n+    public static final String ROOT_XML_ELEMENT_NAME = \"StratconCampaignState\";\n+    \n+    @XmlTransient\n+    private AtBContract contract;\n+\n+    // these are all state variables that affect the current Stratcon Campaign\n+    private double globalOpforBVMultiplier;\n+    private int supportPoints;\n+    private int victoryPoints;\n+    private int pendingStrategicObjectiveCount;\n+    private int completedStrategicObjectiveCount;\n+    private String briefingText; \n+    private boolean strategicObjectivesBehaveAsVPs;\n+    \n+    // these are applied to any scenario generated in the campaign; use sparingly\n+    private List<String> globalScenarioModifiers = new ArrayList<>(); \n+    \n+    @XmlElementWrapper(name=\"campaignTracks\")\n+    @XmlElement(name=\"campaignTrack\")\n+    private List<StratconTrackState> tracks;\n+\n+    @XmlTransient\n+    public AtBContract getContract() {\n+        return contract;\n+    }\n+\n+    public void setContract(AtBContract contract) {\n+        this.contract = contract;\n+    }\n+\n+    public StratconCampaignState() {\n+        tracks = new ArrayList<>();\n+    }\n+    \n+    public StratconCampaignState(AtBContract contract) {\n+        tracks = new ArrayList<>();\n+        setContract(contract);\n+    }\n+\n+    /**\n+     * The opfor BV multiplier. Intended to be additive.\n+     * @return The additive opfor BV multiplier.\n+     */\n+    public double getGlobalOpforBVMultiplier() {\n+        return globalOpforBVMultiplier;\n+    }\n+    \n+    public StratconTrackState getTrack(int index) {\n+        return tracks.get(index);\n+    }\n+    \n+    public List<StratconTrackState> getTracks() {\n+        return tracks;\n+    }\n+    \n+    public void addTrack(StratconTrackState track) {\n+        tracks.add(track);\n+    }\n+    \n+    public int getSupportPoints() {\n+        return supportPoints;\n+    }\n+    \n+    public void addSupportPoints(int number) {\n+        supportPoints += number;\n+    }\n+    \n+    public void setSupportPoints(int supportPoints) {\n+        this.supportPoints = supportPoints;\n+    }\n+\n+    public int getVictoryPoints() {\n+        return victoryPoints;\n+    }\n+\n+    public void setVictoryPoints(int victoryPoints) {\n+        this.victoryPoints = victoryPoints;\n+    }\n+    \n+    public void updateVictoryPoints(int increment) {\n+        victoryPoints += increment;\n+    }\n+\n+    public String getBriefingText() {\n+        return briefingText;\n+    }\n+\n+    public void setBriefingText(String briefingText) {\n+        this.briefingText = briefingText;\n+    }\n+\n+    public boolean strategicObjectivesBehaveAsVPs() {\n+        return strategicObjectivesBehaveAsVPs;\n+    }\n+\n+    public void setStrategicObjectivesBehaveAsVPs(boolean strategicObjectivesBehaveAsVPs) {\n+        this.strategicObjectivesBehaveAsVPs = strategicObjectivesBehaveAsVPs;\n+    }\n+\n+    public List<String> getGlobalScenarioModifiers() {\n+        return globalScenarioModifiers;\n+    }\n+\n+    public void setGlobalScenarioModifiers(List<String> globalScenarioModifiers) {\n+        this.globalScenarioModifiers = globalScenarioModifiers;\n+    }\n+\n+    public int getPendingStrategicObjectiveCount() {\n+        return pendingStrategicObjectiveCount;\n+    }\n+\n+    public void setPendingStrategicObjectiveCount(int pendingStrategicObjectiveCount) {\n+        this.pendingStrategicObjectiveCount = pendingStrategicObjectiveCount;\n+    }\n+    \n+    public void incrementPendingStrategicObjectiveCount(int increment) {\n+        pendingStrategicObjectiveCount += increment;\n+    }\n+    \n+    public void incrementPendingStrategicObjectiveCount() {\n+        pendingStrategicObjectiveCount++;\n+    }\n+    \n+    public int getStrategicObjectiveCompletedCount() {\n+        return completedStrategicObjectiveCount;\n+    }\n+    \n+    public void incrementStrategicObjectiveCompletedCount() {\n+        completedStrategicObjectiveCount++;\n+    }\n+    \n+    public void decrementStrategicObjectiveCompletedCount() {\n+        completedStrategicObjectiveCount--;\n+    }\n+    \n+    public void useSupportPoint() {\n+        supportPoints--;\n+    }\n+    \n+    public void convertVictoryToSupportPoint() {\n+        victoryPoints--;\n+        supportPoints++;\n+    }\n+    \n+    /**\n+     * Convenience/speed method of determining whether or not a force with the given ID has been deployed to a track in this campaign.\n+     * @param forceID the force ID to check\n+     * @return Deployed or not.\n+     */\n+    public boolean isForceDeployedHere(int forceID) {\n+        for (StratconTrackState trackState : tracks) {\n+            if(trackState.getAssignedForceCoords().containsKey(forceID)) {", "originalCommit": "ded0a76ab00c54323f9c24291d0a2582367b1792", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzQwNDI3Mw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603404273", "bodyText": "Could easily be swapped to using a stream", "author": "Windchild292", "createdAt": "2021-03-29T15:43:24Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconCampaignState.java", "diffHunk": "@@ -0,0 +1,252 @@\n+/*\n+ * Copyright (c) 2019 The Megamek Team. All rights reserved.\n+ *\n+ * This file is part of MekHQ.\n+ *\n+ * MekHQ is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * MekHQ is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with MekHQ.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBElement;\n+import javax.xml.bind.Marshaller;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlTransient;\n+import javax.xml.namespace.QName;\n+\n+import org.w3c.dom.Node;\n+\n+import mekhq.MekHQ;\n+import mekhq.campaign.mission.AtBContract;\n+\n+/**\n+ * Contract-level state object for a StratCon campaign.\n+ * @author NickAragua\n+ */\n+@XmlRootElement(name=\"StratconCampaignState\")\n+public class StratconCampaignState {\n+    public static final String ROOT_XML_ELEMENT_NAME = \"StratconCampaignState\";\n+    \n+    @XmlTransient\n+    private AtBContract contract;\n+\n+    // these are all state variables that affect the current Stratcon Campaign\n+    private double globalOpforBVMultiplier;\n+    private int supportPoints;\n+    private int victoryPoints;\n+    private int pendingStrategicObjectiveCount;\n+    private int completedStrategicObjectiveCount;\n+    private String briefingText; \n+    private boolean strategicObjectivesBehaveAsVPs;\n+    \n+    // these are applied to any scenario generated in the campaign; use sparingly\n+    private List<String> globalScenarioModifiers = new ArrayList<>(); \n+    \n+    @XmlElementWrapper(name=\"campaignTracks\")\n+    @XmlElement(name=\"campaignTrack\")\n+    private List<StratconTrackState> tracks;\n+\n+    @XmlTransient\n+    public AtBContract getContract() {\n+        return contract;\n+    }\n+\n+    public void setContract(AtBContract contract) {\n+        this.contract = contract;\n+    }\n+\n+    public StratconCampaignState() {\n+        tracks = new ArrayList<>();\n+    }\n+    \n+    public StratconCampaignState(AtBContract contract) {\n+        tracks = new ArrayList<>();\n+        setContract(contract);\n+    }\n+\n+    /**\n+     * The opfor BV multiplier. Intended to be additive.\n+     * @return The additive opfor BV multiplier.\n+     */\n+    public double getGlobalOpforBVMultiplier() {\n+        return globalOpforBVMultiplier;\n+    }\n+    \n+    public StratconTrackState getTrack(int index) {\n+        return tracks.get(index);\n+    }\n+    \n+    public List<StratconTrackState> getTracks() {\n+        return tracks;\n+    }\n+    \n+    public void addTrack(StratconTrackState track) {\n+        tracks.add(track);\n+    }\n+    \n+    public int getSupportPoints() {\n+        return supportPoints;\n+    }\n+    \n+    public void addSupportPoints(int number) {\n+        supportPoints += number;\n+    }\n+    \n+    public void setSupportPoints(int supportPoints) {\n+        this.supportPoints = supportPoints;\n+    }\n+\n+    public int getVictoryPoints() {\n+        return victoryPoints;\n+    }\n+\n+    public void setVictoryPoints(int victoryPoints) {\n+        this.victoryPoints = victoryPoints;\n+    }\n+    \n+    public void updateVictoryPoints(int increment) {\n+        victoryPoints += increment;\n+    }\n+\n+    public String getBriefingText() {\n+        return briefingText;\n+    }\n+\n+    public void setBriefingText(String briefingText) {\n+        this.briefingText = briefingText;\n+    }\n+\n+    public boolean strategicObjectivesBehaveAsVPs() {\n+        return strategicObjectivesBehaveAsVPs;\n+    }\n+\n+    public void setStrategicObjectivesBehaveAsVPs(boolean strategicObjectivesBehaveAsVPs) {\n+        this.strategicObjectivesBehaveAsVPs = strategicObjectivesBehaveAsVPs;\n+    }\n+\n+    public List<String> getGlobalScenarioModifiers() {\n+        return globalScenarioModifiers;\n+    }\n+\n+    public void setGlobalScenarioModifiers(List<String> globalScenarioModifiers) {\n+        this.globalScenarioModifiers = globalScenarioModifiers;\n+    }\n+\n+    public int getPendingStrategicObjectiveCount() {\n+        return pendingStrategicObjectiveCount;\n+    }\n+\n+    public void setPendingStrategicObjectiveCount(int pendingStrategicObjectiveCount) {\n+        this.pendingStrategicObjectiveCount = pendingStrategicObjectiveCount;\n+    }\n+    \n+    public void incrementPendingStrategicObjectiveCount(int increment) {\n+        pendingStrategicObjectiveCount += increment;\n+    }\n+    \n+    public void incrementPendingStrategicObjectiveCount() {\n+        pendingStrategicObjectiveCount++;\n+    }\n+    \n+    public int getStrategicObjectiveCompletedCount() {\n+        return completedStrategicObjectiveCount;\n+    }\n+    \n+    public void incrementStrategicObjectiveCompletedCount() {\n+        completedStrategicObjectiveCount++;\n+    }\n+    \n+    public void decrementStrategicObjectiveCompletedCount() {\n+        completedStrategicObjectiveCount--;\n+    }\n+    \n+    public void useSupportPoint() {\n+        supportPoints--;\n+    }\n+    \n+    public void convertVictoryToSupportPoint() {\n+        victoryPoints--;\n+        supportPoints++;\n+    }\n+    \n+    /**\n+     * Convenience/speed method of determining whether or not a force with the given ID has been deployed to a track in this campaign.\n+     * @param forceID the force ID to check\n+     * @return Deployed or not.\n+     */\n+    public boolean isForceDeployedHere(int forceID) {\n+        for (StratconTrackState trackState : tracks) {\n+            if(trackState.getAssignedForceCoords().containsKey(forceID)) {\n+                return true;\n+            }\n+        }\n+        \n+        return false;", "originalCommit": "ded0a76ab00c54323f9c24291d0a2582367b1792", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzQwNDczOA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603404738", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * along with MekHQ.  If not, see <http://www.gnu.org/licenses/>.\n          \n          \n            \n             * along with MekHQ. If not, see <http://www.gnu.org/licenses/>.", "author": "Windchild292", "createdAt": "2021-03-29T15:43:57Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconContractDefinition.java", "diffHunk": "@@ -0,0 +1,418 @@\n+/*\n+ * Copyright (c) 2019 The Megamek Team. All rights reserved.\n+ *\n+ * This file is part of MekHQ.\n+ *\n+ * MekHQ is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * MekHQ is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with MekHQ.  If not, see <http://www.gnu.org/licenses/>.", "originalCommit": "ded0a76ab00c54323f9c24291d0a2582367b1792", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzQwNDc5OQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603404799", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n          \n          \n            \n             * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the", "author": "Windchild292", "createdAt": "2021-03-29T15:44:02Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconContractDefinition.java", "diffHunk": "@@ -0,0 +1,418 @@\n+/*\n+ * Copyright (c) 2019 The Megamek Team. All rights reserved.\n+ *\n+ * This file is part of MekHQ.\n+ *\n+ * MekHQ is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * MekHQ is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", "originalCommit": "ded0a76ab00c54323f9c24291d0a2582367b1792", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzQwNDkxNw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603404917", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            @XmlRootElement(name=\"StratconContractDefinition\")\n          \n          \n            \n            @XmlRootElement(name = \"StratconContractDefinition\")", "author": "Windchild292", "createdAt": "2021-03-29T15:44:10Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconContractDefinition.java", "diffHunk": "@@ -0,0 +1,418 @@\n+/*\n+ * Copyright (c) 2019 The Megamek Team. All rights reserved.\n+ *\n+ * This file is part of MekHQ.\n+ *\n+ * MekHQ is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * MekHQ is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with MekHQ.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBElement;\n+import javax.xml.bind.Marshaller;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.namespace.QName;\n+import javax.xml.transform.Source;\n+\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.MekHqXmlUtil;\n+\n+/**\n+ * This class holds data relevant to the various types of contract\n+ * that can occur in the StratCon campaign system.\n+ * @author NickAragua\n+ *\n+ */\n+@XmlRootElement(name=\"StratconContractDefinition\")", "originalCommit": "ded0a76ab00c54323f9c24291d0a2582367b1792", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzQwNTAzNQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603405035", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             *\n          \n          \n            \n             */\n          \n          \n            \n             */", "author": "Windchild292", "createdAt": "2021-03-29T15:44:18Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconContractDefinition.java", "diffHunk": "@@ -0,0 +1,418 @@\n+/*\n+ * Copyright (c) 2019 The Megamek Team. All rights reserved.\n+ *\n+ * This file is part of MekHQ.\n+ *\n+ * MekHQ is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * MekHQ is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with MekHQ.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBElement;\n+import javax.xml.bind.Marshaller;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.namespace.QName;\n+import javax.xml.transform.Source;\n+\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.MekHqXmlUtil;\n+\n+/**\n+ * This class holds data relevant to the various types of contract\n+ * that can occur in the StratCon campaign system.\n+ * @author NickAragua\n+ *\n+ */", "originalCommit": "ded0a76ab00c54323f9c24291d0a2582367b1792", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzQwNTc0Nw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603405747", "bodyText": "Odd to have a method in the middle of the variable declarations", "author": "Windchild292", "createdAt": "2021-03-29T15:45:15Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconContractDefinition.java", "diffHunk": "@@ -0,0 +1,418 @@\n+/*\n+ * Copyright (c) 2019 The Megamek Team. All rights reserved.\n+ *\n+ * This file is part of MekHQ.\n+ *\n+ * MekHQ is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * MekHQ is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with MekHQ.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBElement;\n+import javax.xml.bind.Marshaller;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.namespace.QName;\n+import javax.xml.transform.Source;\n+\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.MekHqXmlUtil;\n+\n+/**\n+ * This class holds data relevant to the various types of contract\n+ * that can occur in the StratCon campaign system.\n+ * @author NickAragua\n+ *\n+ */\n+@XmlRootElement(name=\"StratconContractDefinition\")\n+public class StratconContractDefinition {\n+    public static final String ROOT_XML_ELEMENT_NAME = \"ScenarioTemplate\";\n+    public static final int COUNT_SCALED = -1;\n+    \n+    private static ContractDefinitionManifest definitionManifest;\n+    private static Map<Integer, StratconContractDefinition> loadedDefinitions = new HashMap<>();\n+    \n+    private static ContractDefinitionManifest getContractDefinitionManifest() {", "originalCommit": "ded0a76ab00c54323f9c24291d0a2582367b1792", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzU5NzgyMw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603597823", "bodyText": "statics appear to be grouped together in this file.", "author": "NickAragua", "createdAt": "2021-03-29T20:39:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzQwNTc0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzQwNTgwOA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603405808", "bodyText": "Odd to have a method in the middle of the variable declarations", "author": "Windchild292", "createdAt": "2021-03-29T15:45:19Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconContractDefinition.java", "diffHunk": "@@ -0,0 +1,418 @@\n+/*\n+ * Copyright (c) 2019 The Megamek Team. All rights reserved.\n+ *\n+ * This file is part of MekHQ.\n+ *\n+ * MekHQ is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * MekHQ is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with MekHQ.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBElement;\n+import javax.xml.bind.Marshaller;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.namespace.QName;\n+import javax.xml.transform.Source;\n+\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.MekHqXmlUtil;\n+\n+/**\n+ * This class holds data relevant to the various types of contract\n+ * that can occur in the StratCon campaign system.\n+ * @author NickAragua\n+ *\n+ */\n+@XmlRootElement(name=\"StratconContractDefinition\")\n+public class StratconContractDefinition {\n+    public static final String ROOT_XML_ELEMENT_NAME = \"ScenarioTemplate\";\n+    public static final int COUNT_SCALED = -1;\n+    \n+    private static ContractDefinitionManifest definitionManifest;\n+    private static Map<Integer, StratconContractDefinition> loadedDefinitions = new HashMap<>();\n+    \n+    private static ContractDefinitionManifest getContractDefinitionManifest() {\n+        if (definitionManifest == null) {\n+            definitionManifest = ContractDefinitionManifest.Deserialize(MekHqConstants.STRATCON_CONTRACT_MANIFEST);\n+            \n+            // load user-specified modifier list\n+            ContractDefinitionManifest userDefinitionList = ContractDefinitionManifest.Deserialize(MekHqConstants.STRATCON_USER_CONTRACT_MANIFEST);\n+            if (userDefinitionList != null) {\n+                definitionManifest.definitionFileNames.putAll(userDefinitionList.definitionFileNames);\n+            }\n+        }\n+        \n+        return definitionManifest;\n+    }\n+    \n+    /**\n+     * Returns the stratcon contract definition for the given AtB Contract Type \n+     * as defined in AtBContract.java\n+     */\n+    public static StratconContractDefinition getContractDefinition(int atbContractType) {", "originalCommit": "ded0a76ab00c54323f9c24291d0a2582367b1792", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzQwNjExNQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603406115", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @XmlElementWrapper(name=\"allowedScenarios\")\n          \n          \n            \n                @XmlElement(name=\"allowedScenario\")\n          \n          \n            \n                @XmlElementWrapper(name = \"allowedScenarios\")\n          \n          \n            \n                @XmlElement(name = \"allowedScenario\")", "author": "Windchild292", "createdAt": "2021-03-29T15:45:40Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconContractDefinition.java", "diffHunk": "@@ -0,0 +1,418 @@\n+/*\n+ * Copyright (c) 2019 The Megamek Team. All rights reserved.\n+ *\n+ * This file is part of MekHQ.\n+ *\n+ * MekHQ is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * MekHQ is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with MekHQ.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBElement;\n+import javax.xml.bind.Marshaller;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.namespace.QName;\n+import javax.xml.transform.Source;\n+\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.MekHqXmlUtil;\n+\n+/**\n+ * This class holds data relevant to the various types of contract\n+ * that can occur in the StratCon campaign system.\n+ * @author NickAragua\n+ *\n+ */\n+@XmlRootElement(name=\"StratconContractDefinition\")\n+public class StratconContractDefinition {\n+    public static final String ROOT_XML_ELEMENT_NAME = \"ScenarioTemplate\";\n+    public static final int COUNT_SCALED = -1;\n+    \n+    private static ContractDefinitionManifest definitionManifest;\n+    private static Map<Integer, StratconContractDefinition> loadedDefinitions = new HashMap<>();\n+    \n+    private static ContractDefinitionManifest getContractDefinitionManifest() {\n+        if (definitionManifest == null) {\n+            definitionManifest = ContractDefinitionManifest.Deserialize(MekHqConstants.STRATCON_CONTRACT_MANIFEST);\n+            \n+            // load user-specified modifier list\n+            ContractDefinitionManifest userDefinitionList = ContractDefinitionManifest.Deserialize(MekHqConstants.STRATCON_USER_CONTRACT_MANIFEST);\n+            if (userDefinitionList != null) {\n+                definitionManifest.definitionFileNames.putAll(userDefinitionList.definitionFileNames);\n+            }\n+        }\n+        \n+        return definitionManifest;\n+    }\n+    \n+    /**\n+     * Returns the stratcon contract definition for the given AtB Contract Type \n+     * as defined in AtBContract.java\n+     */\n+    public static StratconContractDefinition getContractDefinition(int atbContractType) {\n+        if (!loadedDefinitions.containsKey(atbContractType)) {\n+            String filePath = Paths.get(MekHqConstants.STRATCON_CONTRACT_PATH, \n+                    getContractDefinitionManifest().definitionFileNames.get(atbContractType)).toString();\n+            StratconContractDefinition def = Deserialize(new File(filePath));\n+            \n+            if (def == null) {\n+                MekHQ.getLogger().error(String.format(\"Unable to load contract definition %s\", filePath));\n+                return null;\n+            }\n+            \n+            loadedDefinitions.put(atbContractType, def);\n+        }\n+        \n+        return loadedDefinitions.get(atbContractType);\n+    }\n+    \n+    /**\n+     * The kind of actions that the player needs to undertake to complete\n+     * strategic objectives for this contract.\n+     */\n+    public enum StrategicObjectiveType {\n+        /**\n+         * Victory in any scenario\n+         */\n+        AnyScenarioVictory,\n+        \n+        /**\n+         * Victory in scenarios - designated by the \"objectiveScenarios\" collection.\n+         * These are one-off scenarios that stick around on tracks - when revealed, \n+         * they get a deploy/action/return date as usual, and the player gets one shot to complete them\n+         */\n+        SpecificScenarioVictory,\n+        \n+        /**\n+         * Control of allied facilities generated at contract start time\n+         * Each track will be seeded with some number of allied facilities\n+         * They must not be destroyed and the player must have control of them at the end-of-contract date \n+         */\n+        AlliedFacilityControl,\n+        \n+        /**\n+         * Control of hostile facilities generated at contract start time\n+         * Each track will be seeded with some number of hostile facilities\n+         * They must not be destroyed and the player must have control of them at the end-of-contract date\n+         */\n+        HostileFacilityControl,\n+        \n+        /**\n+         * Destruction of hostile facilities generated at contract start time\n+         * Each track will be seeded with some number of hostile facilities\n+         * They may either be destroyed or the player must have control of them at the end-of-contract date\n+         */\n+        FacilityDestruction\n+    }\n+    \n+    private String contractTypeName;\n+    private String briefing;\n+    \n+    /**\n+     * How many allied facilities to generate for the contract, \n+     * in addition to any facilities placed by objectives.\n+     * < 0 indicates that the number of facilities should be scaled to the number of \n+     * lances required by the contract. 0 indicates no additional allied facilities.\n+     */\n+    private double alliedFacilityCount;\n+    \n+    /**\n+     * How many hostile facilities to generate for the contract, \n+     * in addition to any facilities placed by objectives.\n+     * -1 indicates that the number of facilities should be scaled to the number of \n+     * lances required by the contract. 0 indicates no additional hostile facilities.\n+     */\n+    private double hostileFacilityCount;\n+    \n+    /**\n+     * List of scenario IDs (file names) that are allowed for this contract type\n+     */\n+    private List<String> allowedScenarios;\n+    \n+    /**\n+     * List of scenario IDs (file names) that are not allowed for this contract type\n+     */\n+    private List<String> forbiddenScenarios;\n+    \n+    /**\n+     * Strategic objectives for this contract.\n+     */\n+    private List<ObjectiveParameters> objectiveParameters;\n+    \n+    /**\n+     * If true, strategic objective scenarios contribute to the VP count\n+     */\n+    private boolean objectivesBehaveAsVPs;\n+    \n+    private List<Integer> scenarioOdds;\n+    \n+    private List<Integer> deploymentTimes;\n+\n+    public String getContractTypeName() {\n+        return contractTypeName;\n+    }\n+\n+    public void setContractTypeName(String contractTypeName) {\n+        this.contractTypeName = contractTypeName;\n+    }\n+\n+    /**\n+     * @return the briefing\n+     */\n+    public String getBriefing() {\n+        return briefing;\n+    }\n+\n+    /**\n+     * @param briefing the briefing to set\n+     */\n+    public void setBriefing(String briefing) {\n+        this.briefing = briefing;\n+    }\n+\n+    /**\n+     * @return the alliedFacilityCount\n+     */\n+    public double getAlliedFacilityCount() {\n+        return alliedFacilityCount;\n+    }\n+\n+    /**\n+     * @param alliedFacilityCount the alliedFacilityCount to set\n+     */\n+    public void setAlliedFacilityCount(double alliedFacilityCount) {\n+        this.alliedFacilityCount = alliedFacilityCount;\n+    }\n+\n+    /**\n+     * @return the hostileFacilityCount\n+     */\n+    public double getHostileFacilityCount() {\n+        return hostileFacilityCount;\n+    }\n+\n+    /**\n+     * @param hostileFacilityCount the hostileFacilityCount to set\n+     */\n+    public void setHostileFacilityCount(double hostileFacilityCount) {\n+        this.hostileFacilityCount = hostileFacilityCount;\n+    }\n+\n+    @XmlElementWrapper(name=\"allowedScenarios\")\n+    @XmlElement(name=\"allowedScenario\")", "originalCommit": "ded0a76ab00c54323f9c24291d0a2582367b1792", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzQwNjI4OA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603406288", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @XmlElementWrapper(name=\"forbiddenScenarios\")\n          \n          \n            \n                @XmlElement(name=\"forbiddenScenario\")\n          \n          \n            \n                @XmlElementWrapper(name = \"forbiddenScenarios\")\n          \n          \n            \n                @XmlElement(name = \"forbiddenScenario\")", "author": "Windchild292", "createdAt": "2021-03-29T15:45:53Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconContractDefinition.java", "diffHunk": "@@ -0,0 +1,418 @@\n+/*\n+ * Copyright (c) 2019 The Megamek Team. All rights reserved.\n+ *\n+ * This file is part of MekHQ.\n+ *\n+ * MekHQ is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * MekHQ is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with MekHQ.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBElement;\n+import javax.xml.bind.Marshaller;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.namespace.QName;\n+import javax.xml.transform.Source;\n+\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.MekHqXmlUtil;\n+\n+/**\n+ * This class holds data relevant to the various types of contract\n+ * that can occur in the StratCon campaign system.\n+ * @author NickAragua\n+ *\n+ */\n+@XmlRootElement(name=\"StratconContractDefinition\")\n+public class StratconContractDefinition {\n+    public static final String ROOT_XML_ELEMENT_NAME = \"ScenarioTemplate\";\n+    public static final int COUNT_SCALED = -1;\n+    \n+    private static ContractDefinitionManifest definitionManifest;\n+    private static Map<Integer, StratconContractDefinition> loadedDefinitions = new HashMap<>();\n+    \n+    private static ContractDefinitionManifest getContractDefinitionManifest() {\n+        if (definitionManifest == null) {\n+            definitionManifest = ContractDefinitionManifest.Deserialize(MekHqConstants.STRATCON_CONTRACT_MANIFEST);\n+            \n+            // load user-specified modifier list\n+            ContractDefinitionManifest userDefinitionList = ContractDefinitionManifest.Deserialize(MekHqConstants.STRATCON_USER_CONTRACT_MANIFEST);\n+            if (userDefinitionList != null) {\n+                definitionManifest.definitionFileNames.putAll(userDefinitionList.definitionFileNames);\n+            }\n+        }\n+        \n+        return definitionManifest;\n+    }\n+    \n+    /**\n+     * Returns the stratcon contract definition for the given AtB Contract Type \n+     * as defined in AtBContract.java\n+     */\n+    public static StratconContractDefinition getContractDefinition(int atbContractType) {\n+        if (!loadedDefinitions.containsKey(atbContractType)) {\n+            String filePath = Paths.get(MekHqConstants.STRATCON_CONTRACT_PATH, \n+                    getContractDefinitionManifest().definitionFileNames.get(atbContractType)).toString();\n+            StratconContractDefinition def = Deserialize(new File(filePath));\n+            \n+            if (def == null) {\n+                MekHQ.getLogger().error(String.format(\"Unable to load contract definition %s\", filePath));\n+                return null;\n+            }\n+            \n+            loadedDefinitions.put(atbContractType, def);\n+        }\n+        \n+        return loadedDefinitions.get(atbContractType);\n+    }\n+    \n+    /**\n+     * The kind of actions that the player needs to undertake to complete\n+     * strategic objectives for this contract.\n+     */\n+    public enum StrategicObjectiveType {\n+        /**\n+         * Victory in any scenario\n+         */\n+        AnyScenarioVictory,\n+        \n+        /**\n+         * Victory in scenarios - designated by the \"objectiveScenarios\" collection.\n+         * These are one-off scenarios that stick around on tracks - when revealed, \n+         * they get a deploy/action/return date as usual, and the player gets one shot to complete them\n+         */\n+        SpecificScenarioVictory,\n+        \n+        /**\n+         * Control of allied facilities generated at contract start time\n+         * Each track will be seeded with some number of allied facilities\n+         * They must not be destroyed and the player must have control of them at the end-of-contract date \n+         */\n+        AlliedFacilityControl,\n+        \n+        /**\n+         * Control of hostile facilities generated at contract start time\n+         * Each track will be seeded with some number of hostile facilities\n+         * They must not be destroyed and the player must have control of them at the end-of-contract date\n+         */\n+        HostileFacilityControl,\n+        \n+        /**\n+         * Destruction of hostile facilities generated at contract start time\n+         * Each track will be seeded with some number of hostile facilities\n+         * They may either be destroyed or the player must have control of them at the end-of-contract date\n+         */\n+        FacilityDestruction\n+    }\n+    \n+    private String contractTypeName;\n+    private String briefing;\n+    \n+    /**\n+     * How many allied facilities to generate for the contract, \n+     * in addition to any facilities placed by objectives.\n+     * < 0 indicates that the number of facilities should be scaled to the number of \n+     * lances required by the contract. 0 indicates no additional allied facilities.\n+     */\n+    private double alliedFacilityCount;\n+    \n+    /**\n+     * How many hostile facilities to generate for the contract, \n+     * in addition to any facilities placed by objectives.\n+     * -1 indicates that the number of facilities should be scaled to the number of \n+     * lances required by the contract. 0 indicates no additional hostile facilities.\n+     */\n+    private double hostileFacilityCount;\n+    \n+    /**\n+     * List of scenario IDs (file names) that are allowed for this contract type\n+     */\n+    private List<String> allowedScenarios;\n+    \n+    /**\n+     * List of scenario IDs (file names) that are not allowed for this contract type\n+     */\n+    private List<String> forbiddenScenarios;\n+    \n+    /**\n+     * Strategic objectives for this contract.\n+     */\n+    private List<ObjectiveParameters> objectiveParameters;\n+    \n+    /**\n+     * If true, strategic objective scenarios contribute to the VP count\n+     */\n+    private boolean objectivesBehaveAsVPs;\n+    \n+    private List<Integer> scenarioOdds;\n+    \n+    private List<Integer> deploymentTimes;\n+\n+    public String getContractTypeName() {\n+        return contractTypeName;\n+    }\n+\n+    public void setContractTypeName(String contractTypeName) {\n+        this.contractTypeName = contractTypeName;\n+    }\n+\n+    /**\n+     * @return the briefing\n+     */\n+    public String getBriefing() {\n+        return briefing;\n+    }\n+\n+    /**\n+     * @param briefing the briefing to set\n+     */\n+    public void setBriefing(String briefing) {\n+        this.briefing = briefing;\n+    }\n+\n+    /**\n+     * @return the alliedFacilityCount\n+     */\n+    public double getAlliedFacilityCount() {\n+        return alliedFacilityCount;\n+    }\n+\n+    /**\n+     * @param alliedFacilityCount the alliedFacilityCount to set\n+     */\n+    public void setAlliedFacilityCount(double alliedFacilityCount) {\n+        this.alliedFacilityCount = alliedFacilityCount;\n+    }\n+\n+    /**\n+     * @return the hostileFacilityCount\n+     */\n+    public double getHostileFacilityCount() {\n+        return hostileFacilityCount;\n+    }\n+\n+    /**\n+     * @param hostileFacilityCount the hostileFacilityCount to set\n+     */\n+    public void setHostileFacilityCount(double hostileFacilityCount) {\n+        this.hostileFacilityCount = hostileFacilityCount;\n+    }\n+\n+    @XmlElementWrapper(name=\"allowedScenarios\")\n+    @XmlElement(name=\"allowedScenario\")\n+    public List<String> getAllowedScenarios() {\n+        return allowedScenarios;\n+    }\n+\n+    public void setAllowedScenarios(List<String> allowedScenarios) {\n+        this.allowedScenarios = allowedScenarios;\n+    }\n+\n+    @XmlElementWrapper(name=\"forbiddenScenarios\")\n+    @XmlElement(name=\"forbiddenScenario\")", "originalCommit": "ded0a76ab00c54323f9c24291d0a2582367b1792", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzQwNjQ4MA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603406480", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @XmlElementWrapper(name=\"objectiveParameters\")\n          \n          \n            \n                @XmlElement(name=\"objectiveParameter\")\n          \n          \n            \n                @XmlElementWrapper(name = \"objectiveParameters\")\n          \n          \n            \n                @XmlElement(name = \"objectiveParameter\")", "author": "Windchild292", "createdAt": "2021-03-29T15:46:07Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconContractDefinition.java", "diffHunk": "@@ -0,0 +1,418 @@\n+/*\n+ * Copyright (c) 2019 The Megamek Team. All rights reserved.\n+ *\n+ * This file is part of MekHQ.\n+ *\n+ * MekHQ is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * MekHQ is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with MekHQ.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBElement;\n+import javax.xml.bind.Marshaller;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.namespace.QName;\n+import javax.xml.transform.Source;\n+\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.MekHqXmlUtil;\n+\n+/**\n+ * This class holds data relevant to the various types of contract\n+ * that can occur in the StratCon campaign system.\n+ * @author NickAragua\n+ *\n+ */\n+@XmlRootElement(name=\"StratconContractDefinition\")\n+public class StratconContractDefinition {\n+    public static final String ROOT_XML_ELEMENT_NAME = \"ScenarioTemplate\";\n+    public static final int COUNT_SCALED = -1;\n+    \n+    private static ContractDefinitionManifest definitionManifest;\n+    private static Map<Integer, StratconContractDefinition> loadedDefinitions = new HashMap<>();\n+    \n+    private static ContractDefinitionManifest getContractDefinitionManifest() {\n+        if (definitionManifest == null) {\n+            definitionManifest = ContractDefinitionManifest.Deserialize(MekHqConstants.STRATCON_CONTRACT_MANIFEST);\n+            \n+            // load user-specified modifier list\n+            ContractDefinitionManifest userDefinitionList = ContractDefinitionManifest.Deserialize(MekHqConstants.STRATCON_USER_CONTRACT_MANIFEST);\n+            if (userDefinitionList != null) {\n+                definitionManifest.definitionFileNames.putAll(userDefinitionList.definitionFileNames);\n+            }\n+        }\n+        \n+        return definitionManifest;\n+    }\n+    \n+    /**\n+     * Returns the stratcon contract definition for the given AtB Contract Type \n+     * as defined in AtBContract.java\n+     */\n+    public static StratconContractDefinition getContractDefinition(int atbContractType) {\n+        if (!loadedDefinitions.containsKey(atbContractType)) {\n+            String filePath = Paths.get(MekHqConstants.STRATCON_CONTRACT_PATH, \n+                    getContractDefinitionManifest().definitionFileNames.get(atbContractType)).toString();\n+            StratconContractDefinition def = Deserialize(new File(filePath));\n+            \n+            if (def == null) {\n+                MekHQ.getLogger().error(String.format(\"Unable to load contract definition %s\", filePath));\n+                return null;\n+            }\n+            \n+            loadedDefinitions.put(atbContractType, def);\n+        }\n+        \n+        return loadedDefinitions.get(atbContractType);\n+    }\n+    \n+    /**\n+     * The kind of actions that the player needs to undertake to complete\n+     * strategic objectives for this contract.\n+     */\n+    public enum StrategicObjectiveType {\n+        /**\n+         * Victory in any scenario\n+         */\n+        AnyScenarioVictory,\n+        \n+        /**\n+         * Victory in scenarios - designated by the \"objectiveScenarios\" collection.\n+         * These are one-off scenarios that stick around on tracks - when revealed, \n+         * they get a deploy/action/return date as usual, and the player gets one shot to complete them\n+         */\n+        SpecificScenarioVictory,\n+        \n+        /**\n+         * Control of allied facilities generated at contract start time\n+         * Each track will be seeded with some number of allied facilities\n+         * They must not be destroyed and the player must have control of them at the end-of-contract date \n+         */\n+        AlliedFacilityControl,\n+        \n+        /**\n+         * Control of hostile facilities generated at contract start time\n+         * Each track will be seeded with some number of hostile facilities\n+         * They must not be destroyed and the player must have control of them at the end-of-contract date\n+         */\n+        HostileFacilityControl,\n+        \n+        /**\n+         * Destruction of hostile facilities generated at contract start time\n+         * Each track will be seeded with some number of hostile facilities\n+         * They may either be destroyed or the player must have control of them at the end-of-contract date\n+         */\n+        FacilityDestruction\n+    }\n+    \n+    private String contractTypeName;\n+    private String briefing;\n+    \n+    /**\n+     * How many allied facilities to generate for the contract, \n+     * in addition to any facilities placed by objectives.\n+     * < 0 indicates that the number of facilities should be scaled to the number of \n+     * lances required by the contract. 0 indicates no additional allied facilities.\n+     */\n+    private double alliedFacilityCount;\n+    \n+    /**\n+     * How many hostile facilities to generate for the contract, \n+     * in addition to any facilities placed by objectives.\n+     * -1 indicates that the number of facilities should be scaled to the number of \n+     * lances required by the contract. 0 indicates no additional hostile facilities.\n+     */\n+    private double hostileFacilityCount;\n+    \n+    /**\n+     * List of scenario IDs (file names) that are allowed for this contract type\n+     */\n+    private List<String> allowedScenarios;\n+    \n+    /**\n+     * List of scenario IDs (file names) that are not allowed for this contract type\n+     */\n+    private List<String> forbiddenScenarios;\n+    \n+    /**\n+     * Strategic objectives for this contract.\n+     */\n+    private List<ObjectiveParameters> objectiveParameters;\n+    \n+    /**\n+     * If true, strategic objective scenarios contribute to the VP count\n+     */\n+    private boolean objectivesBehaveAsVPs;\n+    \n+    private List<Integer> scenarioOdds;\n+    \n+    private List<Integer> deploymentTimes;\n+\n+    public String getContractTypeName() {\n+        return contractTypeName;\n+    }\n+\n+    public void setContractTypeName(String contractTypeName) {\n+        this.contractTypeName = contractTypeName;\n+    }\n+\n+    /**\n+     * @return the briefing\n+     */\n+    public String getBriefing() {\n+        return briefing;\n+    }\n+\n+    /**\n+     * @param briefing the briefing to set\n+     */\n+    public void setBriefing(String briefing) {\n+        this.briefing = briefing;\n+    }\n+\n+    /**\n+     * @return the alliedFacilityCount\n+     */\n+    public double getAlliedFacilityCount() {\n+        return alliedFacilityCount;\n+    }\n+\n+    /**\n+     * @param alliedFacilityCount the alliedFacilityCount to set\n+     */\n+    public void setAlliedFacilityCount(double alliedFacilityCount) {\n+        this.alliedFacilityCount = alliedFacilityCount;\n+    }\n+\n+    /**\n+     * @return the hostileFacilityCount\n+     */\n+    public double getHostileFacilityCount() {\n+        return hostileFacilityCount;\n+    }\n+\n+    /**\n+     * @param hostileFacilityCount the hostileFacilityCount to set\n+     */\n+    public void setHostileFacilityCount(double hostileFacilityCount) {\n+        this.hostileFacilityCount = hostileFacilityCount;\n+    }\n+\n+    @XmlElementWrapper(name=\"allowedScenarios\")\n+    @XmlElement(name=\"allowedScenario\")\n+    public List<String> getAllowedScenarios() {\n+        return allowedScenarios;\n+    }\n+\n+    public void setAllowedScenarios(List<String> allowedScenarios) {\n+        this.allowedScenarios = allowedScenarios;\n+    }\n+\n+    @XmlElementWrapper(name=\"forbiddenScenarios\")\n+    @XmlElement(name=\"forbiddenScenario\")\n+    public List<String> getForbiddenScenarios() {\n+        return forbiddenScenarios;\n+    }\n+\n+    public void setForbiddenScenarios(List<String> forbiddenScenarios) {\n+        this.forbiddenScenarios = forbiddenScenarios;\n+    }\n+    \n+    @XmlElementWrapper(name=\"objectiveParameters\")\n+    @XmlElement(name=\"objectiveParameter\")", "originalCommit": "ded0a76ab00c54323f9c24291d0a2582367b1792", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzQwNjYzNg==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603406636", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @XmlElementWrapper(name=\"scenarioOdds\")\n          \n          \n            \n                @XmlElement(name=\"scenarioOdds\")\n          \n          \n            \n                @XmlElementWrapper(name = \"scenarioOdds\")\n          \n          \n            \n                @XmlElement(name = \"scenarioOdds\")", "author": "Windchild292", "createdAt": "2021-03-29T15:46:17Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconContractDefinition.java", "diffHunk": "@@ -0,0 +1,418 @@\n+/*\n+ * Copyright (c) 2019 The Megamek Team. All rights reserved.\n+ *\n+ * This file is part of MekHQ.\n+ *\n+ * MekHQ is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * MekHQ is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with MekHQ.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBElement;\n+import javax.xml.bind.Marshaller;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.namespace.QName;\n+import javax.xml.transform.Source;\n+\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.MekHqXmlUtil;\n+\n+/**\n+ * This class holds data relevant to the various types of contract\n+ * that can occur in the StratCon campaign system.\n+ * @author NickAragua\n+ *\n+ */\n+@XmlRootElement(name=\"StratconContractDefinition\")\n+public class StratconContractDefinition {\n+    public static final String ROOT_XML_ELEMENT_NAME = \"ScenarioTemplate\";\n+    public static final int COUNT_SCALED = -1;\n+    \n+    private static ContractDefinitionManifest definitionManifest;\n+    private static Map<Integer, StratconContractDefinition> loadedDefinitions = new HashMap<>();\n+    \n+    private static ContractDefinitionManifest getContractDefinitionManifest() {\n+        if (definitionManifest == null) {\n+            definitionManifest = ContractDefinitionManifest.Deserialize(MekHqConstants.STRATCON_CONTRACT_MANIFEST);\n+            \n+            // load user-specified modifier list\n+            ContractDefinitionManifest userDefinitionList = ContractDefinitionManifest.Deserialize(MekHqConstants.STRATCON_USER_CONTRACT_MANIFEST);\n+            if (userDefinitionList != null) {\n+                definitionManifest.definitionFileNames.putAll(userDefinitionList.definitionFileNames);\n+            }\n+        }\n+        \n+        return definitionManifest;\n+    }\n+    \n+    /**\n+     * Returns the stratcon contract definition for the given AtB Contract Type \n+     * as defined in AtBContract.java\n+     */\n+    public static StratconContractDefinition getContractDefinition(int atbContractType) {\n+        if (!loadedDefinitions.containsKey(atbContractType)) {\n+            String filePath = Paths.get(MekHqConstants.STRATCON_CONTRACT_PATH, \n+                    getContractDefinitionManifest().definitionFileNames.get(atbContractType)).toString();\n+            StratconContractDefinition def = Deserialize(new File(filePath));\n+            \n+            if (def == null) {\n+                MekHQ.getLogger().error(String.format(\"Unable to load contract definition %s\", filePath));\n+                return null;\n+            }\n+            \n+            loadedDefinitions.put(atbContractType, def);\n+        }\n+        \n+        return loadedDefinitions.get(atbContractType);\n+    }\n+    \n+    /**\n+     * The kind of actions that the player needs to undertake to complete\n+     * strategic objectives for this contract.\n+     */\n+    public enum StrategicObjectiveType {\n+        /**\n+         * Victory in any scenario\n+         */\n+        AnyScenarioVictory,\n+        \n+        /**\n+         * Victory in scenarios - designated by the \"objectiveScenarios\" collection.\n+         * These are one-off scenarios that stick around on tracks - when revealed, \n+         * they get a deploy/action/return date as usual, and the player gets one shot to complete them\n+         */\n+        SpecificScenarioVictory,\n+        \n+        /**\n+         * Control of allied facilities generated at contract start time\n+         * Each track will be seeded with some number of allied facilities\n+         * They must not be destroyed and the player must have control of them at the end-of-contract date \n+         */\n+        AlliedFacilityControl,\n+        \n+        /**\n+         * Control of hostile facilities generated at contract start time\n+         * Each track will be seeded with some number of hostile facilities\n+         * They must not be destroyed and the player must have control of them at the end-of-contract date\n+         */\n+        HostileFacilityControl,\n+        \n+        /**\n+         * Destruction of hostile facilities generated at contract start time\n+         * Each track will be seeded with some number of hostile facilities\n+         * They may either be destroyed or the player must have control of them at the end-of-contract date\n+         */\n+        FacilityDestruction\n+    }\n+    \n+    private String contractTypeName;\n+    private String briefing;\n+    \n+    /**\n+     * How many allied facilities to generate for the contract, \n+     * in addition to any facilities placed by objectives.\n+     * < 0 indicates that the number of facilities should be scaled to the number of \n+     * lances required by the contract. 0 indicates no additional allied facilities.\n+     */\n+    private double alliedFacilityCount;\n+    \n+    /**\n+     * How many hostile facilities to generate for the contract, \n+     * in addition to any facilities placed by objectives.\n+     * -1 indicates that the number of facilities should be scaled to the number of \n+     * lances required by the contract. 0 indicates no additional hostile facilities.\n+     */\n+    private double hostileFacilityCount;\n+    \n+    /**\n+     * List of scenario IDs (file names) that are allowed for this contract type\n+     */\n+    private List<String> allowedScenarios;\n+    \n+    /**\n+     * List of scenario IDs (file names) that are not allowed for this contract type\n+     */\n+    private List<String> forbiddenScenarios;\n+    \n+    /**\n+     * Strategic objectives for this contract.\n+     */\n+    private List<ObjectiveParameters> objectiveParameters;\n+    \n+    /**\n+     * If true, strategic objective scenarios contribute to the VP count\n+     */\n+    private boolean objectivesBehaveAsVPs;\n+    \n+    private List<Integer> scenarioOdds;\n+    \n+    private List<Integer> deploymentTimes;\n+\n+    public String getContractTypeName() {\n+        return contractTypeName;\n+    }\n+\n+    public void setContractTypeName(String contractTypeName) {\n+        this.contractTypeName = contractTypeName;\n+    }\n+\n+    /**\n+     * @return the briefing\n+     */\n+    public String getBriefing() {\n+        return briefing;\n+    }\n+\n+    /**\n+     * @param briefing the briefing to set\n+     */\n+    public void setBriefing(String briefing) {\n+        this.briefing = briefing;\n+    }\n+\n+    /**\n+     * @return the alliedFacilityCount\n+     */\n+    public double getAlliedFacilityCount() {\n+        return alliedFacilityCount;\n+    }\n+\n+    /**\n+     * @param alliedFacilityCount the alliedFacilityCount to set\n+     */\n+    public void setAlliedFacilityCount(double alliedFacilityCount) {\n+        this.alliedFacilityCount = alliedFacilityCount;\n+    }\n+\n+    /**\n+     * @return the hostileFacilityCount\n+     */\n+    public double getHostileFacilityCount() {\n+        return hostileFacilityCount;\n+    }\n+\n+    /**\n+     * @param hostileFacilityCount the hostileFacilityCount to set\n+     */\n+    public void setHostileFacilityCount(double hostileFacilityCount) {\n+        this.hostileFacilityCount = hostileFacilityCount;\n+    }\n+\n+    @XmlElementWrapper(name=\"allowedScenarios\")\n+    @XmlElement(name=\"allowedScenario\")\n+    public List<String> getAllowedScenarios() {\n+        return allowedScenarios;\n+    }\n+\n+    public void setAllowedScenarios(List<String> allowedScenarios) {\n+        this.allowedScenarios = allowedScenarios;\n+    }\n+\n+    @XmlElementWrapper(name=\"forbiddenScenarios\")\n+    @XmlElement(name=\"forbiddenScenario\")\n+    public List<String> getForbiddenScenarios() {\n+        return forbiddenScenarios;\n+    }\n+\n+    public void setForbiddenScenarios(List<String> forbiddenScenarios) {\n+        this.forbiddenScenarios = forbiddenScenarios;\n+    }\n+    \n+    @XmlElementWrapper(name=\"objectiveParameters\")\n+    @XmlElement(name=\"objectiveParameter\")\n+    public List<ObjectiveParameters> getObjectiveParameters() {\n+        return objectiveParameters;\n+    }\n+\n+    public void setObjectiveParameters(List<ObjectiveParameters> objectiveParameters) {\n+        this.objectiveParameters = objectiveParameters;\n+    }\n+\n+    public boolean objectivesBehaveAsVPs() {\n+        return objectivesBehaveAsVPs;\n+    }\n+\n+    public void setObjectivesBehaveAsVPs(boolean objectivesBehaveAsVPs) {\n+        this.objectivesBehaveAsVPs = objectivesBehaveAsVPs;\n+    }\n+\n+    @XmlElementWrapper(name=\"scenarioOdds\")\n+    @XmlElement(name=\"scenarioOdds\")", "originalCommit": "ded0a76ab00c54323f9c24291d0a2582367b1792", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzQwNjc1NQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603406755", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @XmlElementWrapper(name=\"deploymentTimes\")\n          \n          \n            \n                @XmlElement(name=\"deploymentTimes\")\n          \n          \n            \n                @XmlElementWrapper(name = \"deploymentTimes\")\n          \n          \n            \n                @XmlElement(name = \"deploymentTimes\")", "author": "Windchild292", "createdAt": "2021-03-29T15:46:27Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconContractDefinition.java", "diffHunk": "@@ -0,0 +1,418 @@\n+/*\n+ * Copyright (c) 2019 The Megamek Team. All rights reserved.\n+ *\n+ * This file is part of MekHQ.\n+ *\n+ * MekHQ is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * MekHQ is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with MekHQ.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBElement;\n+import javax.xml.bind.Marshaller;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.namespace.QName;\n+import javax.xml.transform.Source;\n+\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.MekHqXmlUtil;\n+\n+/**\n+ * This class holds data relevant to the various types of contract\n+ * that can occur in the StratCon campaign system.\n+ * @author NickAragua\n+ *\n+ */\n+@XmlRootElement(name=\"StratconContractDefinition\")\n+public class StratconContractDefinition {\n+    public static final String ROOT_XML_ELEMENT_NAME = \"ScenarioTemplate\";\n+    public static final int COUNT_SCALED = -1;\n+    \n+    private static ContractDefinitionManifest definitionManifest;\n+    private static Map<Integer, StratconContractDefinition> loadedDefinitions = new HashMap<>();\n+    \n+    private static ContractDefinitionManifest getContractDefinitionManifest() {\n+        if (definitionManifest == null) {\n+            definitionManifest = ContractDefinitionManifest.Deserialize(MekHqConstants.STRATCON_CONTRACT_MANIFEST);\n+            \n+            // load user-specified modifier list\n+            ContractDefinitionManifest userDefinitionList = ContractDefinitionManifest.Deserialize(MekHqConstants.STRATCON_USER_CONTRACT_MANIFEST);\n+            if (userDefinitionList != null) {\n+                definitionManifest.definitionFileNames.putAll(userDefinitionList.definitionFileNames);\n+            }\n+        }\n+        \n+        return definitionManifest;\n+    }\n+    \n+    /**\n+     * Returns the stratcon contract definition for the given AtB Contract Type \n+     * as defined in AtBContract.java\n+     */\n+    public static StratconContractDefinition getContractDefinition(int atbContractType) {\n+        if (!loadedDefinitions.containsKey(atbContractType)) {\n+            String filePath = Paths.get(MekHqConstants.STRATCON_CONTRACT_PATH, \n+                    getContractDefinitionManifest().definitionFileNames.get(atbContractType)).toString();\n+            StratconContractDefinition def = Deserialize(new File(filePath));\n+            \n+            if (def == null) {\n+                MekHQ.getLogger().error(String.format(\"Unable to load contract definition %s\", filePath));\n+                return null;\n+            }\n+            \n+            loadedDefinitions.put(atbContractType, def);\n+        }\n+        \n+        return loadedDefinitions.get(atbContractType);\n+    }\n+    \n+    /**\n+     * The kind of actions that the player needs to undertake to complete\n+     * strategic objectives for this contract.\n+     */\n+    public enum StrategicObjectiveType {\n+        /**\n+         * Victory in any scenario\n+         */\n+        AnyScenarioVictory,\n+        \n+        /**\n+         * Victory in scenarios - designated by the \"objectiveScenarios\" collection.\n+         * These are one-off scenarios that stick around on tracks - when revealed, \n+         * they get a deploy/action/return date as usual, and the player gets one shot to complete them\n+         */\n+        SpecificScenarioVictory,\n+        \n+        /**\n+         * Control of allied facilities generated at contract start time\n+         * Each track will be seeded with some number of allied facilities\n+         * They must not be destroyed and the player must have control of them at the end-of-contract date \n+         */\n+        AlliedFacilityControl,\n+        \n+        /**\n+         * Control of hostile facilities generated at contract start time\n+         * Each track will be seeded with some number of hostile facilities\n+         * They must not be destroyed and the player must have control of them at the end-of-contract date\n+         */\n+        HostileFacilityControl,\n+        \n+        /**\n+         * Destruction of hostile facilities generated at contract start time\n+         * Each track will be seeded with some number of hostile facilities\n+         * They may either be destroyed or the player must have control of them at the end-of-contract date\n+         */\n+        FacilityDestruction\n+    }\n+    \n+    private String contractTypeName;\n+    private String briefing;\n+    \n+    /**\n+     * How many allied facilities to generate for the contract, \n+     * in addition to any facilities placed by objectives.\n+     * < 0 indicates that the number of facilities should be scaled to the number of \n+     * lances required by the contract. 0 indicates no additional allied facilities.\n+     */\n+    private double alliedFacilityCount;\n+    \n+    /**\n+     * How many hostile facilities to generate for the contract, \n+     * in addition to any facilities placed by objectives.\n+     * -1 indicates that the number of facilities should be scaled to the number of \n+     * lances required by the contract. 0 indicates no additional hostile facilities.\n+     */\n+    private double hostileFacilityCount;\n+    \n+    /**\n+     * List of scenario IDs (file names) that are allowed for this contract type\n+     */\n+    private List<String> allowedScenarios;\n+    \n+    /**\n+     * List of scenario IDs (file names) that are not allowed for this contract type\n+     */\n+    private List<String> forbiddenScenarios;\n+    \n+    /**\n+     * Strategic objectives for this contract.\n+     */\n+    private List<ObjectiveParameters> objectiveParameters;\n+    \n+    /**\n+     * If true, strategic objective scenarios contribute to the VP count\n+     */\n+    private boolean objectivesBehaveAsVPs;\n+    \n+    private List<Integer> scenarioOdds;\n+    \n+    private List<Integer> deploymentTimes;\n+\n+    public String getContractTypeName() {\n+        return contractTypeName;\n+    }\n+\n+    public void setContractTypeName(String contractTypeName) {\n+        this.contractTypeName = contractTypeName;\n+    }\n+\n+    /**\n+     * @return the briefing\n+     */\n+    public String getBriefing() {\n+        return briefing;\n+    }\n+\n+    /**\n+     * @param briefing the briefing to set\n+     */\n+    public void setBriefing(String briefing) {\n+        this.briefing = briefing;\n+    }\n+\n+    /**\n+     * @return the alliedFacilityCount\n+     */\n+    public double getAlliedFacilityCount() {\n+        return alliedFacilityCount;\n+    }\n+\n+    /**\n+     * @param alliedFacilityCount the alliedFacilityCount to set\n+     */\n+    public void setAlliedFacilityCount(double alliedFacilityCount) {\n+        this.alliedFacilityCount = alliedFacilityCount;\n+    }\n+\n+    /**\n+     * @return the hostileFacilityCount\n+     */\n+    public double getHostileFacilityCount() {\n+        return hostileFacilityCount;\n+    }\n+\n+    /**\n+     * @param hostileFacilityCount the hostileFacilityCount to set\n+     */\n+    public void setHostileFacilityCount(double hostileFacilityCount) {\n+        this.hostileFacilityCount = hostileFacilityCount;\n+    }\n+\n+    @XmlElementWrapper(name=\"allowedScenarios\")\n+    @XmlElement(name=\"allowedScenario\")\n+    public List<String> getAllowedScenarios() {\n+        return allowedScenarios;\n+    }\n+\n+    public void setAllowedScenarios(List<String> allowedScenarios) {\n+        this.allowedScenarios = allowedScenarios;\n+    }\n+\n+    @XmlElementWrapper(name=\"forbiddenScenarios\")\n+    @XmlElement(name=\"forbiddenScenario\")\n+    public List<String> getForbiddenScenarios() {\n+        return forbiddenScenarios;\n+    }\n+\n+    public void setForbiddenScenarios(List<String> forbiddenScenarios) {\n+        this.forbiddenScenarios = forbiddenScenarios;\n+    }\n+    \n+    @XmlElementWrapper(name=\"objectiveParameters\")\n+    @XmlElement(name=\"objectiveParameter\")\n+    public List<ObjectiveParameters> getObjectiveParameters() {\n+        return objectiveParameters;\n+    }\n+\n+    public void setObjectiveParameters(List<ObjectiveParameters> objectiveParameters) {\n+        this.objectiveParameters = objectiveParameters;\n+    }\n+\n+    public boolean objectivesBehaveAsVPs() {\n+        return objectivesBehaveAsVPs;\n+    }\n+\n+    public void setObjectivesBehaveAsVPs(boolean objectivesBehaveAsVPs) {\n+        this.objectivesBehaveAsVPs = objectivesBehaveAsVPs;\n+    }\n+\n+    @XmlElementWrapper(name=\"scenarioOdds\")\n+    @XmlElement(name=\"scenarioOdds\")\n+    public List<Integer> getScenarioOdds() {\n+        return scenarioOdds;\n+    }\n+\n+    public void setScenarioOdds(List<Integer> scenarioOdds) {\n+        this.scenarioOdds = scenarioOdds;\n+    }\n+\n+    @XmlElementWrapper(name=\"deploymentTimes\")\n+    @XmlElement(name=\"deploymentTimes\")", "originalCommit": "ded0a76ab00c54323f9c24291d0a2582367b1792", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzQwNjg1OA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603406858", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    @XmlElement(name=\"objectiveType\")\n          \n          \n            \n                    @XmlElement(name = \"objectiveType\")", "author": "Windchild292", "createdAt": "2021-03-29T15:46:36Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconContractDefinition.java", "diffHunk": "@@ -0,0 +1,418 @@\n+/*\n+ * Copyright (c) 2019 The Megamek Team. All rights reserved.\n+ *\n+ * This file is part of MekHQ.\n+ *\n+ * MekHQ is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * MekHQ is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with MekHQ.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBElement;\n+import javax.xml.bind.Marshaller;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.namespace.QName;\n+import javax.xml.transform.Source;\n+\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.MekHqXmlUtil;\n+\n+/**\n+ * This class holds data relevant to the various types of contract\n+ * that can occur in the StratCon campaign system.\n+ * @author NickAragua\n+ *\n+ */\n+@XmlRootElement(name=\"StratconContractDefinition\")\n+public class StratconContractDefinition {\n+    public static final String ROOT_XML_ELEMENT_NAME = \"ScenarioTemplate\";\n+    public static final int COUNT_SCALED = -1;\n+    \n+    private static ContractDefinitionManifest definitionManifest;\n+    private static Map<Integer, StratconContractDefinition> loadedDefinitions = new HashMap<>();\n+    \n+    private static ContractDefinitionManifest getContractDefinitionManifest() {\n+        if (definitionManifest == null) {\n+            definitionManifest = ContractDefinitionManifest.Deserialize(MekHqConstants.STRATCON_CONTRACT_MANIFEST);\n+            \n+            // load user-specified modifier list\n+            ContractDefinitionManifest userDefinitionList = ContractDefinitionManifest.Deserialize(MekHqConstants.STRATCON_USER_CONTRACT_MANIFEST);\n+            if (userDefinitionList != null) {\n+                definitionManifest.definitionFileNames.putAll(userDefinitionList.definitionFileNames);\n+            }\n+        }\n+        \n+        return definitionManifest;\n+    }\n+    \n+    /**\n+     * Returns the stratcon contract definition for the given AtB Contract Type \n+     * as defined in AtBContract.java\n+     */\n+    public static StratconContractDefinition getContractDefinition(int atbContractType) {\n+        if (!loadedDefinitions.containsKey(atbContractType)) {\n+            String filePath = Paths.get(MekHqConstants.STRATCON_CONTRACT_PATH, \n+                    getContractDefinitionManifest().definitionFileNames.get(atbContractType)).toString();\n+            StratconContractDefinition def = Deserialize(new File(filePath));\n+            \n+            if (def == null) {\n+                MekHQ.getLogger().error(String.format(\"Unable to load contract definition %s\", filePath));\n+                return null;\n+            }\n+            \n+            loadedDefinitions.put(atbContractType, def);\n+        }\n+        \n+        return loadedDefinitions.get(atbContractType);\n+    }\n+    \n+    /**\n+     * The kind of actions that the player needs to undertake to complete\n+     * strategic objectives for this contract.\n+     */\n+    public enum StrategicObjectiveType {\n+        /**\n+         * Victory in any scenario\n+         */\n+        AnyScenarioVictory,\n+        \n+        /**\n+         * Victory in scenarios - designated by the \"objectiveScenarios\" collection.\n+         * These are one-off scenarios that stick around on tracks - when revealed, \n+         * they get a deploy/action/return date as usual, and the player gets one shot to complete them\n+         */\n+        SpecificScenarioVictory,\n+        \n+        /**\n+         * Control of allied facilities generated at contract start time\n+         * Each track will be seeded with some number of allied facilities\n+         * They must not be destroyed and the player must have control of them at the end-of-contract date \n+         */\n+        AlliedFacilityControl,\n+        \n+        /**\n+         * Control of hostile facilities generated at contract start time\n+         * Each track will be seeded with some number of hostile facilities\n+         * They must not be destroyed and the player must have control of them at the end-of-contract date\n+         */\n+        HostileFacilityControl,\n+        \n+        /**\n+         * Destruction of hostile facilities generated at contract start time\n+         * Each track will be seeded with some number of hostile facilities\n+         * They may either be destroyed or the player must have control of them at the end-of-contract date\n+         */\n+        FacilityDestruction\n+    }\n+    \n+    private String contractTypeName;\n+    private String briefing;\n+    \n+    /**\n+     * How many allied facilities to generate for the contract, \n+     * in addition to any facilities placed by objectives.\n+     * < 0 indicates that the number of facilities should be scaled to the number of \n+     * lances required by the contract. 0 indicates no additional allied facilities.\n+     */\n+    private double alliedFacilityCount;\n+    \n+    /**\n+     * How many hostile facilities to generate for the contract, \n+     * in addition to any facilities placed by objectives.\n+     * -1 indicates that the number of facilities should be scaled to the number of \n+     * lances required by the contract. 0 indicates no additional hostile facilities.\n+     */\n+    private double hostileFacilityCount;\n+    \n+    /**\n+     * List of scenario IDs (file names) that are allowed for this contract type\n+     */\n+    private List<String> allowedScenarios;\n+    \n+    /**\n+     * List of scenario IDs (file names) that are not allowed for this contract type\n+     */\n+    private List<String> forbiddenScenarios;\n+    \n+    /**\n+     * Strategic objectives for this contract.\n+     */\n+    private List<ObjectiveParameters> objectiveParameters;\n+    \n+    /**\n+     * If true, strategic objective scenarios contribute to the VP count\n+     */\n+    private boolean objectivesBehaveAsVPs;\n+    \n+    private List<Integer> scenarioOdds;\n+    \n+    private List<Integer> deploymentTimes;\n+\n+    public String getContractTypeName() {\n+        return contractTypeName;\n+    }\n+\n+    public void setContractTypeName(String contractTypeName) {\n+        this.contractTypeName = contractTypeName;\n+    }\n+\n+    /**\n+     * @return the briefing\n+     */\n+    public String getBriefing() {\n+        return briefing;\n+    }\n+\n+    /**\n+     * @param briefing the briefing to set\n+     */\n+    public void setBriefing(String briefing) {\n+        this.briefing = briefing;\n+    }\n+\n+    /**\n+     * @return the alliedFacilityCount\n+     */\n+    public double getAlliedFacilityCount() {\n+        return alliedFacilityCount;\n+    }\n+\n+    /**\n+     * @param alliedFacilityCount the alliedFacilityCount to set\n+     */\n+    public void setAlliedFacilityCount(double alliedFacilityCount) {\n+        this.alliedFacilityCount = alliedFacilityCount;\n+    }\n+\n+    /**\n+     * @return the hostileFacilityCount\n+     */\n+    public double getHostileFacilityCount() {\n+        return hostileFacilityCount;\n+    }\n+\n+    /**\n+     * @param hostileFacilityCount the hostileFacilityCount to set\n+     */\n+    public void setHostileFacilityCount(double hostileFacilityCount) {\n+        this.hostileFacilityCount = hostileFacilityCount;\n+    }\n+\n+    @XmlElementWrapper(name=\"allowedScenarios\")\n+    @XmlElement(name=\"allowedScenario\")\n+    public List<String> getAllowedScenarios() {\n+        return allowedScenarios;\n+    }\n+\n+    public void setAllowedScenarios(List<String> allowedScenarios) {\n+        this.allowedScenarios = allowedScenarios;\n+    }\n+\n+    @XmlElementWrapper(name=\"forbiddenScenarios\")\n+    @XmlElement(name=\"forbiddenScenario\")\n+    public List<String> getForbiddenScenarios() {\n+        return forbiddenScenarios;\n+    }\n+\n+    public void setForbiddenScenarios(List<String> forbiddenScenarios) {\n+        this.forbiddenScenarios = forbiddenScenarios;\n+    }\n+    \n+    @XmlElementWrapper(name=\"objectiveParameters\")\n+    @XmlElement(name=\"objectiveParameter\")\n+    public List<ObjectiveParameters> getObjectiveParameters() {\n+        return objectiveParameters;\n+    }\n+\n+    public void setObjectiveParameters(List<ObjectiveParameters> objectiveParameters) {\n+        this.objectiveParameters = objectiveParameters;\n+    }\n+\n+    public boolean objectivesBehaveAsVPs() {\n+        return objectivesBehaveAsVPs;\n+    }\n+\n+    public void setObjectivesBehaveAsVPs(boolean objectivesBehaveAsVPs) {\n+        this.objectivesBehaveAsVPs = objectivesBehaveAsVPs;\n+    }\n+\n+    @XmlElementWrapper(name=\"scenarioOdds\")\n+    @XmlElement(name=\"scenarioOdds\")\n+    public List<Integer> getScenarioOdds() {\n+        return scenarioOdds;\n+    }\n+\n+    public void setScenarioOdds(List<Integer> scenarioOdds) {\n+        this.scenarioOdds = scenarioOdds;\n+    }\n+\n+    @XmlElementWrapper(name=\"deploymentTimes\")\n+    @XmlElement(name=\"deploymentTimes\")\n+    public List<Integer> getDeploymentTimes() {\n+        return deploymentTimes;\n+    }\n+\n+    public void setDeploymentTimes(List<Integer> deploymentTimes) {\n+        this.deploymentTimes = deploymentTimes;\n+    }\n+\n+    /**\n+     * Data structure that deals with the characteristics that a StratCon scenario objective may have\n+     *\n+     */\n+    public static class ObjectiveParameters {\n+        /**\n+         * The type of objective this is; \n+         */\n+        @XmlElement(name=\"objectiveType\")", "originalCommit": "ded0a76ab00c54323f9c24291d0a2582367b1792", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzQwNjk0OA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603406948", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *\n          \n          \n            \n                 */\n          \n          \n            \n                 */", "author": "Windchild292", "createdAt": "2021-03-29T15:46:43Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconContractDefinition.java", "diffHunk": "@@ -0,0 +1,418 @@\n+/*\n+ * Copyright (c) 2019 The Megamek Team. All rights reserved.\n+ *\n+ * This file is part of MekHQ.\n+ *\n+ * MekHQ is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * MekHQ is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with MekHQ.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBElement;\n+import javax.xml.bind.Marshaller;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.namespace.QName;\n+import javax.xml.transform.Source;\n+\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.MekHqXmlUtil;\n+\n+/**\n+ * This class holds data relevant to the various types of contract\n+ * that can occur in the StratCon campaign system.\n+ * @author NickAragua\n+ *\n+ */\n+@XmlRootElement(name=\"StratconContractDefinition\")\n+public class StratconContractDefinition {\n+    public static final String ROOT_XML_ELEMENT_NAME = \"ScenarioTemplate\";\n+    public static final int COUNT_SCALED = -1;\n+    \n+    private static ContractDefinitionManifest definitionManifest;\n+    private static Map<Integer, StratconContractDefinition> loadedDefinitions = new HashMap<>();\n+    \n+    private static ContractDefinitionManifest getContractDefinitionManifest() {\n+        if (definitionManifest == null) {\n+            definitionManifest = ContractDefinitionManifest.Deserialize(MekHqConstants.STRATCON_CONTRACT_MANIFEST);\n+            \n+            // load user-specified modifier list\n+            ContractDefinitionManifest userDefinitionList = ContractDefinitionManifest.Deserialize(MekHqConstants.STRATCON_USER_CONTRACT_MANIFEST);\n+            if (userDefinitionList != null) {\n+                definitionManifest.definitionFileNames.putAll(userDefinitionList.definitionFileNames);\n+            }\n+        }\n+        \n+        return definitionManifest;\n+    }\n+    \n+    /**\n+     * Returns the stratcon contract definition for the given AtB Contract Type \n+     * as defined in AtBContract.java\n+     */\n+    public static StratconContractDefinition getContractDefinition(int atbContractType) {\n+        if (!loadedDefinitions.containsKey(atbContractType)) {\n+            String filePath = Paths.get(MekHqConstants.STRATCON_CONTRACT_PATH, \n+                    getContractDefinitionManifest().definitionFileNames.get(atbContractType)).toString();\n+            StratconContractDefinition def = Deserialize(new File(filePath));\n+            \n+            if (def == null) {\n+                MekHQ.getLogger().error(String.format(\"Unable to load contract definition %s\", filePath));\n+                return null;\n+            }\n+            \n+            loadedDefinitions.put(atbContractType, def);\n+        }\n+        \n+        return loadedDefinitions.get(atbContractType);\n+    }\n+    \n+    /**\n+     * The kind of actions that the player needs to undertake to complete\n+     * strategic objectives for this contract.\n+     */\n+    public enum StrategicObjectiveType {\n+        /**\n+         * Victory in any scenario\n+         */\n+        AnyScenarioVictory,\n+        \n+        /**\n+         * Victory in scenarios - designated by the \"objectiveScenarios\" collection.\n+         * These are one-off scenarios that stick around on tracks - when revealed, \n+         * they get a deploy/action/return date as usual, and the player gets one shot to complete them\n+         */\n+        SpecificScenarioVictory,\n+        \n+        /**\n+         * Control of allied facilities generated at contract start time\n+         * Each track will be seeded with some number of allied facilities\n+         * They must not be destroyed and the player must have control of them at the end-of-contract date \n+         */\n+        AlliedFacilityControl,\n+        \n+        /**\n+         * Control of hostile facilities generated at contract start time\n+         * Each track will be seeded with some number of hostile facilities\n+         * They must not be destroyed and the player must have control of them at the end-of-contract date\n+         */\n+        HostileFacilityControl,\n+        \n+        /**\n+         * Destruction of hostile facilities generated at contract start time\n+         * Each track will be seeded with some number of hostile facilities\n+         * They may either be destroyed or the player must have control of them at the end-of-contract date\n+         */\n+        FacilityDestruction\n+    }\n+    \n+    private String contractTypeName;\n+    private String briefing;\n+    \n+    /**\n+     * How many allied facilities to generate for the contract, \n+     * in addition to any facilities placed by objectives.\n+     * < 0 indicates that the number of facilities should be scaled to the number of \n+     * lances required by the contract. 0 indicates no additional allied facilities.\n+     */\n+    private double alliedFacilityCount;\n+    \n+    /**\n+     * How many hostile facilities to generate for the contract, \n+     * in addition to any facilities placed by objectives.\n+     * -1 indicates that the number of facilities should be scaled to the number of \n+     * lances required by the contract. 0 indicates no additional hostile facilities.\n+     */\n+    private double hostileFacilityCount;\n+    \n+    /**\n+     * List of scenario IDs (file names) that are allowed for this contract type\n+     */\n+    private List<String> allowedScenarios;\n+    \n+    /**\n+     * List of scenario IDs (file names) that are not allowed for this contract type\n+     */\n+    private List<String> forbiddenScenarios;\n+    \n+    /**\n+     * Strategic objectives for this contract.\n+     */\n+    private List<ObjectiveParameters> objectiveParameters;\n+    \n+    /**\n+     * If true, strategic objective scenarios contribute to the VP count\n+     */\n+    private boolean objectivesBehaveAsVPs;\n+    \n+    private List<Integer> scenarioOdds;\n+    \n+    private List<Integer> deploymentTimes;\n+\n+    public String getContractTypeName() {\n+        return contractTypeName;\n+    }\n+\n+    public void setContractTypeName(String contractTypeName) {\n+        this.contractTypeName = contractTypeName;\n+    }\n+\n+    /**\n+     * @return the briefing\n+     */\n+    public String getBriefing() {\n+        return briefing;\n+    }\n+\n+    /**\n+     * @param briefing the briefing to set\n+     */\n+    public void setBriefing(String briefing) {\n+        this.briefing = briefing;\n+    }\n+\n+    /**\n+     * @return the alliedFacilityCount\n+     */\n+    public double getAlliedFacilityCount() {\n+        return alliedFacilityCount;\n+    }\n+\n+    /**\n+     * @param alliedFacilityCount the alliedFacilityCount to set\n+     */\n+    public void setAlliedFacilityCount(double alliedFacilityCount) {\n+        this.alliedFacilityCount = alliedFacilityCount;\n+    }\n+\n+    /**\n+     * @return the hostileFacilityCount\n+     */\n+    public double getHostileFacilityCount() {\n+        return hostileFacilityCount;\n+    }\n+\n+    /**\n+     * @param hostileFacilityCount the hostileFacilityCount to set\n+     */\n+    public void setHostileFacilityCount(double hostileFacilityCount) {\n+        this.hostileFacilityCount = hostileFacilityCount;\n+    }\n+\n+    @XmlElementWrapper(name=\"allowedScenarios\")\n+    @XmlElement(name=\"allowedScenario\")\n+    public List<String> getAllowedScenarios() {\n+        return allowedScenarios;\n+    }\n+\n+    public void setAllowedScenarios(List<String> allowedScenarios) {\n+        this.allowedScenarios = allowedScenarios;\n+    }\n+\n+    @XmlElementWrapper(name=\"forbiddenScenarios\")\n+    @XmlElement(name=\"forbiddenScenario\")\n+    public List<String> getForbiddenScenarios() {\n+        return forbiddenScenarios;\n+    }\n+\n+    public void setForbiddenScenarios(List<String> forbiddenScenarios) {\n+        this.forbiddenScenarios = forbiddenScenarios;\n+    }\n+    \n+    @XmlElementWrapper(name=\"objectiveParameters\")\n+    @XmlElement(name=\"objectiveParameter\")\n+    public List<ObjectiveParameters> getObjectiveParameters() {\n+        return objectiveParameters;\n+    }\n+\n+    public void setObjectiveParameters(List<ObjectiveParameters> objectiveParameters) {\n+        this.objectiveParameters = objectiveParameters;\n+    }\n+\n+    public boolean objectivesBehaveAsVPs() {\n+        return objectivesBehaveAsVPs;\n+    }\n+\n+    public void setObjectivesBehaveAsVPs(boolean objectivesBehaveAsVPs) {\n+        this.objectivesBehaveAsVPs = objectivesBehaveAsVPs;\n+    }\n+\n+    @XmlElementWrapper(name=\"scenarioOdds\")\n+    @XmlElement(name=\"scenarioOdds\")\n+    public List<Integer> getScenarioOdds() {\n+        return scenarioOdds;\n+    }\n+\n+    public void setScenarioOdds(List<Integer> scenarioOdds) {\n+        this.scenarioOdds = scenarioOdds;\n+    }\n+\n+    @XmlElementWrapper(name=\"deploymentTimes\")\n+    @XmlElement(name=\"deploymentTimes\")\n+    public List<Integer> getDeploymentTimes() {\n+        return deploymentTimes;\n+    }\n+\n+    public void setDeploymentTimes(List<Integer> deploymentTimes) {\n+        this.deploymentTimes = deploymentTimes;\n+    }\n+\n+    /**\n+     * Data structure that deals with the characteristics that a StratCon scenario objective may have\n+     *\n+     */", "originalCommit": "ded0a76ab00c54323f9c24291d0a2582367b1792", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzQwNzExMA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603407110", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    @XmlElement(name=\"objectiveCount\")\n          \n          \n            \n                    @XmlElement(name = \"objectiveCount\")", "author": "Windchild292", "createdAt": "2021-03-29T15:46:55Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconContractDefinition.java", "diffHunk": "@@ -0,0 +1,418 @@\n+/*\n+ * Copyright (c) 2019 The Megamek Team. All rights reserved.\n+ *\n+ * This file is part of MekHQ.\n+ *\n+ * MekHQ is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * MekHQ is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with MekHQ.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBElement;\n+import javax.xml.bind.Marshaller;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.namespace.QName;\n+import javax.xml.transform.Source;\n+\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.MekHqXmlUtil;\n+\n+/**\n+ * This class holds data relevant to the various types of contract\n+ * that can occur in the StratCon campaign system.\n+ * @author NickAragua\n+ *\n+ */\n+@XmlRootElement(name=\"StratconContractDefinition\")\n+public class StratconContractDefinition {\n+    public static final String ROOT_XML_ELEMENT_NAME = \"ScenarioTemplate\";\n+    public static final int COUNT_SCALED = -1;\n+    \n+    private static ContractDefinitionManifest definitionManifest;\n+    private static Map<Integer, StratconContractDefinition> loadedDefinitions = new HashMap<>();\n+    \n+    private static ContractDefinitionManifest getContractDefinitionManifest() {\n+        if (definitionManifest == null) {\n+            definitionManifest = ContractDefinitionManifest.Deserialize(MekHqConstants.STRATCON_CONTRACT_MANIFEST);\n+            \n+            // load user-specified modifier list\n+            ContractDefinitionManifest userDefinitionList = ContractDefinitionManifest.Deserialize(MekHqConstants.STRATCON_USER_CONTRACT_MANIFEST);\n+            if (userDefinitionList != null) {\n+                definitionManifest.definitionFileNames.putAll(userDefinitionList.definitionFileNames);\n+            }\n+        }\n+        \n+        return definitionManifest;\n+    }\n+    \n+    /**\n+     * Returns the stratcon contract definition for the given AtB Contract Type \n+     * as defined in AtBContract.java\n+     */\n+    public static StratconContractDefinition getContractDefinition(int atbContractType) {\n+        if (!loadedDefinitions.containsKey(atbContractType)) {\n+            String filePath = Paths.get(MekHqConstants.STRATCON_CONTRACT_PATH, \n+                    getContractDefinitionManifest().definitionFileNames.get(atbContractType)).toString();\n+            StratconContractDefinition def = Deserialize(new File(filePath));\n+            \n+            if (def == null) {\n+                MekHQ.getLogger().error(String.format(\"Unable to load contract definition %s\", filePath));\n+                return null;\n+            }\n+            \n+            loadedDefinitions.put(atbContractType, def);\n+        }\n+        \n+        return loadedDefinitions.get(atbContractType);\n+    }\n+    \n+    /**\n+     * The kind of actions that the player needs to undertake to complete\n+     * strategic objectives for this contract.\n+     */\n+    public enum StrategicObjectiveType {\n+        /**\n+         * Victory in any scenario\n+         */\n+        AnyScenarioVictory,\n+        \n+        /**\n+         * Victory in scenarios - designated by the \"objectiveScenarios\" collection.\n+         * These are one-off scenarios that stick around on tracks - when revealed, \n+         * they get a deploy/action/return date as usual, and the player gets one shot to complete them\n+         */\n+        SpecificScenarioVictory,\n+        \n+        /**\n+         * Control of allied facilities generated at contract start time\n+         * Each track will be seeded with some number of allied facilities\n+         * They must not be destroyed and the player must have control of them at the end-of-contract date \n+         */\n+        AlliedFacilityControl,\n+        \n+        /**\n+         * Control of hostile facilities generated at contract start time\n+         * Each track will be seeded with some number of hostile facilities\n+         * They must not be destroyed and the player must have control of them at the end-of-contract date\n+         */\n+        HostileFacilityControl,\n+        \n+        /**\n+         * Destruction of hostile facilities generated at contract start time\n+         * Each track will be seeded with some number of hostile facilities\n+         * They may either be destroyed or the player must have control of them at the end-of-contract date\n+         */\n+        FacilityDestruction\n+    }\n+    \n+    private String contractTypeName;\n+    private String briefing;\n+    \n+    /**\n+     * How many allied facilities to generate for the contract, \n+     * in addition to any facilities placed by objectives.\n+     * < 0 indicates that the number of facilities should be scaled to the number of \n+     * lances required by the contract. 0 indicates no additional allied facilities.\n+     */\n+    private double alliedFacilityCount;\n+    \n+    /**\n+     * How many hostile facilities to generate for the contract, \n+     * in addition to any facilities placed by objectives.\n+     * -1 indicates that the number of facilities should be scaled to the number of \n+     * lances required by the contract. 0 indicates no additional hostile facilities.\n+     */\n+    private double hostileFacilityCount;\n+    \n+    /**\n+     * List of scenario IDs (file names) that are allowed for this contract type\n+     */\n+    private List<String> allowedScenarios;\n+    \n+    /**\n+     * List of scenario IDs (file names) that are not allowed for this contract type\n+     */\n+    private List<String> forbiddenScenarios;\n+    \n+    /**\n+     * Strategic objectives for this contract.\n+     */\n+    private List<ObjectiveParameters> objectiveParameters;\n+    \n+    /**\n+     * If true, strategic objective scenarios contribute to the VP count\n+     */\n+    private boolean objectivesBehaveAsVPs;\n+    \n+    private List<Integer> scenarioOdds;\n+    \n+    private List<Integer> deploymentTimes;\n+\n+    public String getContractTypeName() {\n+        return contractTypeName;\n+    }\n+\n+    public void setContractTypeName(String contractTypeName) {\n+        this.contractTypeName = contractTypeName;\n+    }\n+\n+    /**\n+     * @return the briefing\n+     */\n+    public String getBriefing() {\n+        return briefing;\n+    }\n+\n+    /**\n+     * @param briefing the briefing to set\n+     */\n+    public void setBriefing(String briefing) {\n+        this.briefing = briefing;\n+    }\n+\n+    /**\n+     * @return the alliedFacilityCount\n+     */\n+    public double getAlliedFacilityCount() {\n+        return alliedFacilityCount;\n+    }\n+\n+    /**\n+     * @param alliedFacilityCount the alliedFacilityCount to set\n+     */\n+    public void setAlliedFacilityCount(double alliedFacilityCount) {\n+        this.alliedFacilityCount = alliedFacilityCount;\n+    }\n+\n+    /**\n+     * @return the hostileFacilityCount\n+     */\n+    public double getHostileFacilityCount() {\n+        return hostileFacilityCount;\n+    }\n+\n+    /**\n+     * @param hostileFacilityCount the hostileFacilityCount to set\n+     */\n+    public void setHostileFacilityCount(double hostileFacilityCount) {\n+        this.hostileFacilityCount = hostileFacilityCount;\n+    }\n+\n+    @XmlElementWrapper(name=\"allowedScenarios\")\n+    @XmlElement(name=\"allowedScenario\")\n+    public List<String> getAllowedScenarios() {\n+        return allowedScenarios;\n+    }\n+\n+    public void setAllowedScenarios(List<String> allowedScenarios) {\n+        this.allowedScenarios = allowedScenarios;\n+    }\n+\n+    @XmlElementWrapper(name=\"forbiddenScenarios\")\n+    @XmlElement(name=\"forbiddenScenario\")\n+    public List<String> getForbiddenScenarios() {\n+        return forbiddenScenarios;\n+    }\n+\n+    public void setForbiddenScenarios(List<String> forbiddenScenarios) {\n+        this.forbiddenScenarios = forbiddenScenarios;\n+    }\n+    \n+    @XmlElementWrapper(name=\"objectiveParameters\")\n+    @XmlElement(name=\"objectiveParameter\")\n+    public List<ObjectiveParameters> getObjectiveParameters() {\n+        return objectiveParameters;\n+    }\n+\n+    public void setObjectiveParameters(List<ObjectiveParameters> objectiveParameters) {\n+        this.objectiveParameters = objectiveParameters;\n+    }\n+\n+    public boolean objectivesBehaveAsVPs() {\n+        return objectivesBehaveAsVPs;\n+    }\n+\n+    public void setObjectivesBehaveAsVPs(boolean objectivesBehaveAsVPs) {\n+        this.objectivesBehaveAsVPs = objectivesBehaveAsVPs;\n+    }\n+\n+    @XmlElementWrapper(name=\"scenarioOdds\")\n+    @XmlElement(name=\"scenarioOdds\")\n+    public List<Integer> getScenarioOdds() {\n+        return scenarioOdds;\n+    }\n+\n+    public void setScenarioOdds(List<Integer> scenarioOdds) {\n+        this.scenarioOdds = scenarioOdds;\n+    }\n+\n+    @XmlElementWrapper(name=\"deploymentTimes\")\n+    @XmlElement(name=\"deploymentTimes\")\n+    public List<Integer> getDeploymentTimes() {\n+        return deploymentTimes;\n+    }\n+\n+    public void setDeploymentTimes(List<Integer> deploymentTimes) {\n+        this.deploymentTimes = deploymentTimes;\n+    }\n+\n+    /**\n+     * Data structure that deals with the characteristics that a StratCon scenario objective may have\n+     *\n+     */\n+    public static class ObjectiveParameters {\n+        /**\n+         * The type of objective this is; \n+         */\n+        @XmlElement(name=\"objectiveType\")\n+        StrategicObjectiveType objectiveType;\n+        \n+        /**\n+         * How many strategic objectives will be placed for this contract.\n+         * 0 means none. A number less than zero indicates that the number of strategic objectives \n+         * should be scaled to the number of lances required by the contract, and multiplied by that factor. \n+         */\n+        @XmlElement(name=\"objectiveCount\")", "originalCommit": "ded0a76ab00c54323f9c24291d0a2582367b1792", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzQwNzE5NQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603407195", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    @XmlElementWrapper(name=\"objectiveScenarios\")\n          \n          \n            \n                    @XmlElement(name=\"objectiveScenario\")\n          \n          \n            \n                    @XmlElementWrapper(name = \"objectiveScenarios\")\n          \n          \n            \n                    @XmlElement(name = \"objectiveScenario\")", "author": "Windchild292", "createdAt": "2021-03-29T15:47:01Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconContractDefinition.java", "diffHunk": "@@ -0,0 +1,418 @@\n+/*\n+ * Copyright (c) 2019 The Megamek Team. All rights reserved.\n+ *\n+ * This file is part of MekHQ.\n+ *\n+ * MekHQ is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * MekHQ is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with MekHQ.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBElement;\n+import javax.xml.bind.Marshaller;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.namespace.QName;\n+import javax.xml.transform.Source;\n+\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.MekHqXmlUtil;\n+\n+/**\n+ * This class holds data relevant to the various types of contract\n+ * that can occur in the StratCon campaign system.\n+ * @author NickAragua\n+ *\n+ */\n+@XmlRootElement(name=\"StratconContractDefinition\")\n+public class StratconContractDefinition {\n+    public static final String ROOT_XML_ELEMENT_NAME = \"ScenarioTemplate\";\n+    public static final int COUNT_SCALED = -1;\n+    \n+    private static ContractDefinitionManifest definitionManifest;\n+    private static Map<Integer, StratconContractDefinition> loadedDefinitions = new HashMap<>();\n+    \n+    private static ContractDefinitionManifest getContractDefinitionManifest() {\n+        if (definitionManifest == null) {\n+            definitionManifest = ContractDefinitionManifest.Deserialize(MekHqConstants.STRATCON_CONTRACT_MANIFEST);\n+            \n+            // load user-specified modifier list\n+            ContractDefinitionManifest userDefinitionList = ContractDefinitionManifest.Deserialize(MekHqConstants.STRATCON_USER_CONTRACT_MANIFEST);\n+            if (userDefinitionList != null) {\n+                definitionManifest.definitionFileNames.putAll(userDefinitionList.definitionFileNames);\n+            }\n+        }\n+        \n+        return definitionManifest;\n+    }\n+    \n+    /**\n+     * Returns the stratcon contract definition for the given AtB Contract Type \n+     * as defined in AtBContract.java\n+     */\n+    public static StratconContractDefinition getContractDefinition(int atbContractType) {\n+        if (!loadedDefinitions.containsKey(atbContractType)) {\n+            String filePath = Paths.get(MekHqConstants.STRATCON_CONTRACT_PATH, \n+                    getContractDefinitionManifest().definitionFileNames.get(atbContractType)).toString();\n+            StratconContractDefinition def = Deserialize(new File(filePath));\n+            \n+            if (def == null) {\n+                MekHQ.getLogger().error(String.format(\"Unable to load contract definition %s\", filePath));\n+                return null;\n+            }\n+            \n+            loadedDefinitions.put(atbContractType, def);\n+        }\n+        \n+        return loadedDefinitions.get(atbContractType);\n+    }\n+    \n+    /**\n+     * The kind of actions that the player needs to undertake to complete\n+     * strategic objectives for this contract.\n+     */\n+    public enum StrategicObjectiveType {\n+        /**\n+         * Victory in any scenario\n+         */\n+        AnyScenarioVictory,\n+        \n+        /**\n+         * Victory in scenarios - designated by the \"objectiveScenarios\" collection.\n+         * These are one-off scenarios that stick around on tracks - when revealed, \n+         * they get a deploy/action/return date as usual, and the player gets one shot to complete them\n+         */\n+        SpecificScenarioVictory,\n+        \n+        /**\n+         * Control of allied facilities generated at contract start time\n+         * Each track will be seeded with some number of allied facilities\n+         * They must not be destroyed and the player must have control of them at the end-of-contract date \n+         */\n+        AlliedFacilityControl,\n+        \n+        /**\n+         * Control of hostile facilities generated at contract start time\n+         * Each track will be seeded with some number of hostile facilities\n+         * They must not be destroyed and the player must have control of them at the end-of-contract date\n+         */\n+        HostileFacilityControl,\n+        \n+        /**\n+         * Destruction of hostile facilities generated at contract start time\n+         * Each track will be seeded with some number of hostile facilities\n+         * They may either be destroyed or the player must have control of them at the end-of-contract date\n+         */\n+        FacilityDestruction\n+    }\n+    \n+    private String contractTypeName;\n+    private String briefing;\n+    \n+    /**\n+     * How many allied facilities to generate for the contract, \n+     * in addition to any facilities placed by objectives.\n+     * < 0 indicates that the number of facilities should be scaled to the number of \n+     * lances required by the contract. 0 indicates no additional allied facilities.\n+     */\n+    private double alliedFacilityCount;\n+    \n+    /**\n+     * How many hostile facilities to generate for the contract, \n+     * in addition to any facilities placed by objectives.\n+     * -1 indicates that the number of facilities should be scaled to the number of \n+     * lances required by the contract. 0 indicates no additional hostile facilities.\n+     */\n+    private double hostileFacilityCount;\n+    \n+    /**\n+     * List of scenario IDs (file names) that are allowed for this contract type\n+     */\n+    private List<String> allowedScenarios;\n+    \n+    /**\n+     * List of scenario IDs (file names) that are not allowed for this contract type\n+     */\n+    private List<String> forbiddenScenarios;\n+    \n+    /**\n+     * Strategic objectives for this contract.\n+     */\n+    private List<ObjectiveParameters> objectiveParameters;\n+    \n+    /**\n+     * If true, strategic objective scenarios contribute to the VP count\n+     */\n+    private boolean objectivesBehaveAsVPs;\n+    \n+    private List<Integer> scenarioOdds;\n+    \n+    private List<Integer> deploymentTimes;\n+\n+    public String getContractTypeName() {\n+        return contractTypeName;\n+    }\n+\n+    public void setContractTypeName(String contractTypeName) {\n+        this.contractTypeName = contractTypeName;\n+    }\n+\n+    /**\n+     * @return the briefing\n+     */\n+    public String getBriefing() {\n+        return briefing;\n+    }\n+\n+    /**\n+     * @param briefing the briefing to set\n+     */\n+    public void setBriefing(String briefing) {\n+        this.briefing = briefing;\n+    }\n+\n+    /**\n+     * @return the alliedFacilityCount\n+     */\n+    public double getAlliedFacilityCount() {\n+        return alliedFacilityCount;\n+    }\n+\n+    /**\n+     * @param alliedFacilityCount the alliedFacilityCount to set\n+     */\n+    public void setAlliedFacilityCount(double alliedFacilityCount) {\n+        this.alliedFacilityCount = alliedFacilityCount;\n+    }\n+\n+    /**\n+     * @return the hostileFacilityCount\n+     */\n+    public double getHostileFacilityCount() {\n+        return hostileFacilityCount;\n+    }\n+\n+    /**\n+     * @param hostileFacilityCount the hostileFacilityCount to set\n+     */\n+    public void setHostileFacilityCount(double hostileFacilityCount) {\n+        this.hostileFacilityCount = hostileFacilityCount;\n+    }\n+\n+    @XmlElementWrapper(name=\"allowedScenarios\")\n+    @XmlElement(name=\"allowedScenario\")\n+    public List<String> getAllowedScenarios() {\n+        return allowedScenarios;\n+    }\n+\n+    public void setAllowedScenarios(List<String> allowedScenarios) {\n+        this.allowedScenarios = allowedScenarios;\n+    }\n+\n+    @XmlElementWrapper(name=\"forbiddenScenarios\")\n+    @XmlElement(name=\"forbiddenScenario\")\n+    public List<String> getForbiddenScenarios() {\n+        return forbiddenScenarios;\n+    }\n+\n+    public void setForbiddenScenarios(List<String> forbiddenScenarios) {\n+        this.forbiddenScenarios = forbiddenScenarios;\n+    }\n+    \n+    @XmlElementWrapper(name=\"objectiveParameters\")\n+    @XmlElement(name=\"objectiveParameter\")\n+    public List<ObjectiveParameters> getObjectiveParameters() {\n+        return objectiveParameters;\n+    }\n+\n+    public void setObjectiveParameters(List<ObjectiveParameters> objectiveParameters) {\n+        this.objectiveParameters = objectiveParameters;\n+    }\n+\n+    public boolean objectivesBehaveAsVPs() {\n+        return objectivesBehaveAsVPs;\n+    }\n+\n+    public void setObjectivesBehaveAsVPs(boolean objectivesBehaveAsVPs) {\n+        this.objectivesBehaveAsVPs = objectivesBehaveAsVPs;\n+    }\n+\n+    @XmlElementWrapper(name=\"scenarioOdds\")\n+    @XmlElement(name=\"scenarioOdds\")\n+    public List<Integer> getScenarioOdds() {\n+        return scenarioOdds;\n+    }\n+\n+    public void setScenarioOdds(List<Integer> scenarioOdds) {\n+        this.scenarioOdds = scenarioOdds;\n+    }\n+\n+    @XmlElementWrapper(name=\"deploymentTimes\")\n+    @XmlElement(name=\"deploymentTimes\")\n+    public List<Integer> getDeploymentTimes() {\n+        return deploymentTimes;\n+    }\n+\n+    public void setDeploymentTimes(List<Integer> deploymentTimes) {\n+        this.deploymentTimes = deploymentTimes;\n+    }\n+\n+    /**\n+     * Data structure that deals with the characteristics that a StratCon scenario objective may have\n+     *\n+     */\n+    public static class ObjectiveParameters {\n+        /**\n+         * The type of objective this is; \n+         */\n+        @XmlElement(name=\"objectiveType\")\n+        StrategicObjectiveType objectiveType;\n+        \n+        /**\n+         * How many strategic objectives will be placed for this contract.\n+         * 0 means none. A number less than zero indicates that the number of strategic objectives \n+         * should be scaled to the number of lances required by the contract, and multiplied by that factor. \n+         */\n+        @XmlElement(name=\"objectiveCount\")\n+        double objectiveCount;\n+        \n+        /**\n+         * List of IDs (file names) of specific scenarios to use for this objective.\n+         * Ignored for AnyScenarioVictory or AlliedFacilityControl objective types\n+         */\n+        @XmlElementWrapper(name=\"objectiveScenarios\")\n+        @XmlElement(name=\"objectiveScenario\")", "originalCommit": "ded0a76ab00c54323f9c24291d0a2582367b1792", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzQwNzM5NQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603407395", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    @XmlElementWrapper(name=\"objectiveScenarioModifiers\")\n          \n          \n            \n                    @XmlElement(name=\"objectiveScenarioModifier\")\n          \n          \n            \n                    @XmlElementWrapper(name = \"objectiveScenarioModifiers\")\n          \n          \n            \n                    @XmlElement(name = \"objectiveScenarioModifier\")", "author": "Windchild292", "createdAt": "2021-03-29T15:47:16Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconContractDefinition.java", "diffHunk": "@@ -0,0 +1,418 @@\n+/*\n+ * Copyright (c) 2019 The Megamek Team. All rights reserved.\n+ *\n+ * This file is part of MekHQ.\n+ *\n+ * MekHQ is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * MekHQ is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with MekHQ.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBElement;\n+import javax.xml.bind.Marshaller;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.namespace.QName;\n+import javax.xml.transform.Source;\n+\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.MekHqXmlUtil;\n+\n+/**\n+ * This class holds data relevant to the various types of contract\n+ * that can occur in the StratCon campaign system.\n+ * @author NickAragua\n+ *\n+ */\n+@XmlRootElement(name=\"StratconContractDefinition\")\n+public class StratconContractDefinition {\n+    public static final String ROOT_XML_ELEMENT_NAME = \"ScenarioTemplate\";\n+    public static final int COUNT_SCALED = -1;\n+    \n+    private static ContractDefinitionManifest definitionManifest;\n+    private static Map<Integer, StratconContractDefinition> loadedDefinitions = new HashMap<>();\n+    \n+    private static ContractDefinitionManifest getContractDefinitionManifest() {\n+        if (definitionManifest == null) {\n+            definitionManifest = ContractDefinitionManifest.Deserialize(MekHqConstants.STRATCON_CONTRACT_MANIFEST);\n+            \n+            // load user-specified modifier list\n+            ContractDefinitionManifest userDefinitionList = ContractDefinitionManifest.Deserialize(MekHqConstants.STRATCON_USER_CONTRACT_MANIFEST);\n+            if (userDefinitionList != null) {\n+                definitionManifest.definitionFileNames.putAll(userDefinitionList.definitionFileNames);\n+            }\n+        }\n+        \n+        return definitionManifest;\n+    }\n+    \n+    /**\n+     * Returns the stratcon contract definition for the given AtB Contract Type \n+     * as defined in AtBContract.java\n+     */\n+    public static StratconContractDefinition getContractDefinition(int atbContractType) {\n+        if (!loadedDefinitions.containsKey(atbContractType)) {\n+            String filePath = Paths.get(MekHqConstants.STRATCON_CONTRACT_PATH, \n+                    getContractDefinitionManifest().definitionFileNames.get(atbContractType)).toString();\n+            StratconContractDefinition def = Deserialize(new File(filePath));\n+            \n+            if (def == null) {\n+                MekHQ.getLogger().error(String.format(\"Unable to load contract definition %s\", filePath));\n+                return null;\n+            }\n+            \n+            loadedDefinitions.put(atbContractType, def);\n+        }\n+        \n+        return loadedDefinitions.get(atbContractType);\n+    }\n+    \n+    /**\n+     * The kind of actions that the player needs to undertake to complete\n+     * strategic objectives for this contract.\n+     */\n+    public enum StrategicObjectiveType {\n+        /**\n+         * Victory in any scenario\n+         */\n+        AnyScenarioVictory,\n+        \n+        /**\n+         * Victory in scenarios - designated by the \"objectiveScenarios\" collection.\n+         * These are one-off scenarios that stick around on tracks - when revealed, \n+         * they get a deploy/action/return date as usual, and the player gets one shot to complete them\n+         */\n+        SpecificScenarioVictory,\n+        \n+        /**\n+         * Control of allied facilities generated at contract start time\n+         * Each track will be seeded with some number of allied facilities\n+         * They must not be destroyed and the player must have control of them at the end-of-contract date \n+         */\n+        AlliedFacilityControl,\n+        \n+        /**\n+         * Control of hostile facilities generated at contract start time\n+         * Each track will be seeded with some number of hostile facilities\n+         * They must not be destroyed and the player must have control of them at the end-of-contract date\n+         */\n+        HostileFacilityControl,\n+        \n+        /**\n+         * Destruction of hostile facilities generated at contract start time\n+         * Each track will be seeded with some number of hostile facilities\n+         * They may either be destroyed or the player must have control of them at the end-of-contract date\n+         */\n+        FacilityDestruction\n+    }\n+    \n+    private String contractTypeName;\n+    private String briefing;\n+    \n+    /**\n+     * How many allied facilities to generate for the contract, \n+     * in addition to any facilities placed by objectives.\n+     * < 0 indicates that the number of facilities should be scaled to the number of \n+     * lances required by the contract. 0 indicates no additional allied facilities.\n+     */\n+    private double alliedFacilityCount;\n+    \n+    /**\n+     * How many hostile facilities to generate for the contract, \n+     * in addition to any facilities placed by objectives.\n+     * -1 indicates that the number of facilities should be scaled to the number of \n+     * lances required by the contract. 0 indicates no additional hostile facilities.\n+     */\n+    private double hostileFacilityCount;\n+    \n+    /**\n+     * List of scenario IDs (file names) that are allowed for this contract type\n+     */\n+    private List<String> allowedScenarios;\n+    \n+    /**\n+     * List of scenario IDs (file names) that are not allowed for this contract type\n+     */\n+    private List<String> forbiddenScenarios;\n+    \n+    /**\n+     * Strategic objectives for this contract.\n+     */\n+    private List<ObjectiveParameters> objectiveParameters;\n+    \n+    /**\n+     * If true, strategic objective scenarios contribute to the VP count\n+     */\n+    private boolean objectivesBehaveAsVPs;\n+    \n+    private List<Integer> scenarioOdds;\n+    \n+    private List<Integer> deploymentTimes;\n+\n+    public String getContractTypeName() {\n+        return contractTypeName;\n+    }\n+\n+    public void setContractTypeName(String contractTypeName) {\n+        this.contractTypeName = contractTypeName;\n+    }\n+\n+    /**\n+     * @return the briefing\n+     */\n+    public String getBriefing() {\n+        return briefing;\n+    }\n+\n+    /**\n+     * @param briefing the briefing to set\n+     */\n+    public void setBriefing(String briefing) {\n+        this.briefing = briefing;\n+    }\n+\n+    /**\n+     * @return the alliedFacilityCount\n+     */\n+    public double getAlliedFacilityCount() {\n+        return alliedFacilityCount;\n+    }\n+\n+    /**\n+     * @param alliedFacilityCount the alliedFacilityCount to set\n+     */\n+    public void setAlliedFacilityCount(double alliedFacilityCount) {\n+        this.alliedFacilityCount = alliedFacilityCount;\n+    }\n+\n+    /**\n+     * @return the hostileFacilityCount\n+     */\n+    public double getHostileFacilityCount() {\n+        return hostileFacilityCount;\n+    }\n+\n+    /**\n+     * @param hostileFacilityCount the hostileFacilityCount to set\n+     */\n+    public void setHostileFacilityCount(double hostileFacilityCount) {\n+        this.hostileFacilityCount = hostileFacilityCount;\n+    }\n+\n+    @XmlElementWrapper(name=\"allowedScenarios\")\n+    @XmlElement(name=\"allowedScenario\")\n+    public List<String> getAllowedScenarios() {\n+        return allowedScenarios;\n+    }\n+\n+    public void setAllowedScenarios(List<String> allowedScenarios) {\n+        this.allowedScenarios = allowedScenarios;\n+    }\n+\n+    @XmlElementWrapper(name=\"forbiddenScenarios\")\n+    @XmlElement(name=\"forbiddenScenario\")\n+    public List<String> getForbiddenScenarios() {\n+        return forbiddenScenarios;\n+    }\n+\n+    public void setForbiddenScenarios(List<String> forbiddenScenarios) {\n+        this.forbiddenScenarios = forbiddenScenarios;\n+    }\n+    \n+    @XmlElementWrapper(name=\"objectiveParameters\")\n+    @XmlElement(name=\"objectiveParameter\")\n+    public List<ObjectiveParameters> getObjectiveParameters() {\n+        return objectiveParameters;\n+    }\n+\n+    public void setObjectiveParameters(List<ObjectiveParameters> objectiveParameters) {\n+        this.objectiveParameters = objectiveParameters;\n+    }\n+\n+    public boolean objectivesBehaveAsVPs() {\n+        return objectivesBehaveAsVPs;\n+    }\n+\n+    public void setObjectivesBehaveAsVPs(boolean objectivesBehaveAsVPs) {\n+        this.objectivesBehaveAsVPs = objectivesBehaveAsVPs;\n+    }\n+\n+    @XmlElementWrapper(name=\"scenarioOdds\")\n+    @XmlElement(name=\"scenarioOdds\")\n+    public List<Integer> getScenarioOdds() {\n+        return scenarioOdds;\n+    }\n+\n+    public void setScenarioOdds(List<Integer> scenarioOdds) {\n+        this.scenarioOdds = scenarioOdds;\n+    }\n+\n+    @XmlElementWrapper(name=\"deploymentTimes\")\n+    @XmlElement(name=\"deploymentTimes\")\n+    public List<Integer> getDeploymentTimes() {\n+        return deploymentTimes;\n+    }\n+\n+    public void setDeploymentTimes(List<Integer> deploymentTimes) {\n+        this.deploymentTimes = deploymentTimes;\n+    }\n+\n+    /**\n+     * Data structure that deals with the characteristics that a StratCon scenario objective may have\n+     *\n+     */\n+    public static class ObjectiveParameters {\n+        /**\n+         * The type of objective this is; \n+         */\n+        @XmlElement(name=\"objectiveType\")\n+        StrategicObjectiveType objectiveType;\n+        \n+        /**\n+         * How many strategic objectives will be placed for this contract.\n+         * 0 means none. A number less than zero indicates that the number of strategic objectives \n+         * should be scaled to the number of lances required by the contract, and multiplied by that factor. \n+         */\n+        @XmlElement(name=\"objectiveCount\")\n+        double objectiveCount;\n+        \n+        /**\n+         * List of IDs (file names) of specific scenarios to use for this objective.\n+         * Ignored for AnyScenarioVictory or AlliedFacilityControl objective types\n+         */\n+        @XmlElementWrapper(name=\"objectiveScenarios\")\n+        @XmlElement(name=\"objectiveScenario\")\n+        List<String> objectiveScenarios;\n+        \n+        /**\n+         * If a particular scenario being generated is a strategic objective, it will have\n+         * these modifiers applied to it\n+         */\n+        @XmlElementWrapper(name=\"objectiveScenarioModifiers\")\n+        @XmlElement(name=\"objectiveScenarioModifier\")", "originalCommit": "ded0a76ab00c54323f9c24291d0a2582367b1792", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzQwNzU1OQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603407559", "bodyText": "Why is this located here?", "author": "Windchild292", "createdAt": "2021-03-29T15:47:29Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconContractDefinition.java", "diffHunk": "@@ -0,0 +1,418 @@\n+/*\n+ * Copyright (c) 2019 The Megamek Team. All rights reserved.\n+ *\n+ * This file is part of MekHQ.\n+ *\n+ * MekHQ is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * MekHQ is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with MekHQ.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBElement;\n+import javax.xml.bind.Marshaller;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.namespace.QName;\n+import javax.xml.transform.Source;\n+\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.MekHqXmlUtil;\n+\n+/**\n+ * This class holds data relevant to the various types of contract\n+ * that can occur in the StratCon campaign system.\n+ * @author NickAragua\n+ *\n+ */\n+@XmlRootElement(name=\"StratconContractDefinition\")\n+public class StratconContractDefinition {\n+    public static final String ROOT_XML_ELEMENT_NAME = \"ScenarioTemplate\";\n+    public static final int COUNT_SCALED = -1;\n+    \n+    private static ContractDefinitionManifest definitionManifest;\n+    private static Map<Integer, StratconContractDefinition> loadedDefinitions = new HashMap<>();\n+    \n+    private static ContractDefinitionManifest getContractDefinitionManifest() {\n+        if (definitionManifest == null) {\n+            definitionManifest = ContractDefinitionManifest.Deserialize(MekHqConstants.STRATCON_CONTRACT_MANIFEST);\n+            \n+            // load user-specified modifier list\n+            ContractDefinitionManifest userDefinitionList = ContractDefinitionManifest.Deserialize(MekHqConstants.STRATCON_USER_CONTRACT_MANIFEST);\n+            if (userDefinitionList != null) {\n+                definitionManifest.definitionFileNames.putAll(userDefinitionList.definitionFileNames);\n+            }\n+        }\n+        \n+        return definitionManifest;\n+    }\n+    \n+    /**\n+     * Returns the stratcon contract definition for the given AtB Contract Type \n+     * as defined in AtBContract.java\n+     */\n+    public static StratconContractDefinition getContractDefinition(int atbContractType) {\n+        if (!loadedDefinitions.containsKey(atbContractType)) {\n+            String filePath = Paths.get(MekHqConstants.STRATCON_CONTRACT_PATH, \n+                    getContractDefinitionManifest().definitionFileNames.get(atbContractType)).toString();\n+            StratconContractDefinition def = Deserialize(new File(filePath));\n+            \n+            if (def == null) {\n+                MekHQ.getLogger().error(String.format(\"Unable to load contract definition %s\", filePath));\n+                return null;\n+            }\n+            \n+            loadedDefinitions.put(atbContractType, def);\n+        }\n+        \n+        return loadedDefinitions.get(atbContractType);\n+    }\n+    \n+    /**\n+     * The kind of actions that the player needs to undertake to complete\n+     * strategic objectives for this contract.\n+     */\n+    public enum StrategicObjectiveType {\n+        /**\n+         * Victory in any scenario\n+         */\n+        AnyScenarioVictory,\n+        \n+        /**\n+         * Victory in scenarios - designated by the \"objectiveScenarios\" collection.\n+         * These are one-off scenarios that stick around on tracks - when revealed, \n+         * they get a deploy/action/return date as usual, and the player gets one shot to complete them\n+         */\n+        SpecificScenarioVictory,\n+        \n+        /**\n+         * Control of allied facilities generated at contract start time\n+         * Each track will be seeded with some number of allied facilities\n+         * They must not be destroyed and the player must have control of them at the end-of-contract date \n+         */\n+        AlliedFacilityControl,\n+        \n+        /**\n+         * Control of hostile facilities generated at contract start time\n+         * Each track will be seeded with some number of hostile facilities\n+         * They must not be destroyed and the player must have control of them at the end-of-contract date\n+         */\n+        HostileFacilityControl,\n+        \n+        /**\n+         * Destruction of hostile facilities generated at contract start time\n+         * Each track will be seeded with some number of hostile facilities\n+         * They may either be destroyed or the player must have control of them at the end-of-contract date\n+         */\n+        FacilityDestruction\n+    }\n+    \n+    private String contractTypeName;\n+    private String briefing;\n+    \n+    /**\n+     * How many allied facilities to generate for the contract, \n+     * in addition to any facilities placed by objectives.\n+     * < 0 indicates that the number of facilities should be scaled to the number of \n+     * lances required by the contract. 0 indicates no additional allied facilities.\n+     */\n+    private double alliedFacilityCount;\n+    \n+    /**\n+     * How many hostile facilities to generate for the contract, \n+     * in addition to any facilities placed by objectives.\n+     * -1 indicates that the number of facilities should be scaled to the number of \n+     * lances required by the contract. 0 indicates no additional hostile facilities.\n+     */\n+    private double hostileFacilityCount;\n+    \n+    /**\n+     * List of scenario IDs (file names) that are allowed for this contract type\n+     */\n+    private List<String> allowedScenarios;\n+    \n+    /**\n+     * List of scenario IDs (file names) that are not allowed for this contract type\n+     */\n+    private List<String> forbiddenScenarios;\n+    \n+    /**\n+     * Strategic objectives for this contract.\n+     */\n+    private List<ObjectiveParameters> objectiveParameters;\n+    \n+    /**\n+     * If true, strategic objective scenarios contribute to the VP count\n+     */\n+    private boolean objectivesBehaveAsVPs;\n+    \n+    private List<Integer> scenarioOdds;\n+    \n+    private List<Integer> deploymentTimes;\n+\n+    public String getContractTypeName() {\n+        return contractTypeName;\n+    }\n+\n+    public void setContractTypeName(String contractTypeName) {\n+        this.contractTypeName = contractTypeName;\n+    }\n+\n+    /**\n+     * @return the briefing\n+     */\n+    public String getBriefing() {\n+        return briefing;\n+    }\n+\n+    /**\n+     * @param briefing the briefing to set\n+     */\n+    public void setBriefing(String briefing) {\n+        this.briefing = briefing;\n+    }\n+\n+    /**\n+     * @return the alliedFacilityCount\n+     */\n+    public double getAlliedFacilityCount() {\n+        return alliedFacilityCount;\n+    }\n+\n+    /**\n+     * @param alliedFacilityCount the alliedFacilityCount to set\n+     */\n+    public void setAlliedFacilityCount(double alliedFacilityCount) {\n+        this.alliedFacilityCount = alliedFacilityCount;\n+    }\n+\n+    /**\n+     * @return the hostileFacilityCount\n+     */\n+    public double getHostileFacilityCount() {\n+        return hostileFacilityCount;\n+    }\n+\n+    /**\n+     * @param hostileFacilityCount the hostileFacilityCount to set\n+     */\n+    public void setHostileFacilityCount(double hostileFacilityCount) {\n+        this.hostileFacilityCount = hostileFacilityCount;\n+    }\n+\n+    @XmlElementWrapper(name=\"allowedScenarios\")\n+    @XmlElement(name=\"allowedScenario\")\n+    public List<String> getAllowedScenarios() {\n+        return allowedScenarios;\n+    }\n+\n+    public void setAllowedScenarios(List<String> allowedScenarios) {\n+        this.allowedScenarios = allowedScenarios;\n+    }\n+\n+    @XmlElementWrapper(name=\"forbiddenScenarios\")\n+    @XmlElement(name=\"forbiddenScenario\")\n+    public List<String> getForbiddenScenarios() {\n+        return forbiddenScenarios;\n+    }\n+\n+    public void setForbiddenScenarios(List<String> forbiddenScenarios) {\n+        this.forbiddenScenarios = forbiddenScenarios;\n+    }\n+    \n+    @XmlElementWrapper(name=\"objectiveParameters\")\n+    @XmlElement(name=\"objectiveParameter\")\n+    public List<ObjectiveParameters> getObjectiveParameters() {\n+        return objectiveParameters;\n+    }\n+\n+    public void setObjectiveParameters(List<ObjectiveParameters> objectiveParameters) {\n+        this.objectiveParameters = objectiveParameters;\n+    }\n+\n+    public boolean objectivesBehaveAsVPs() {\n+        return objectivesBehaveAsVPs;\n+    }\n+\n+    public void setObjectivesBehaveAsVPs(boolean objectivesBehaveAsVPs) {\n+        this.objectivesBehaveAsVPs = objectivesBehaveAsVPs;\n+    }\n+\n+    @XmlElementWrapper(name=\"scenarioOdds\")\n+    @XmlElement(name=\"scenarioOdds\")\n+    public List<Integer> getScenarioOdds() {\n+        return scenarioOdds;\n+    }\n+\n+    public void setScenarioOdds(List<Integer> scenarioOdds) {\n+        this.scenarioOdds = scenarioOdds;\n+    }\n+\n+    @XmlElementWrapper(name=\"deploymentTimes\")\n+    @XmlElement(name=\"deploymentTimes\")\n+    public List<Integer> getDeploymentTimes() {\n+        return deploymentTimes;\n+    }\n+\n+    public void setDeploymentTimes(List<Integer> deploymentTimes) {\n+        this.deploymentTimes = deploymentTimes;\n+    }\n+\n+    /**\n+     * Data structure that deals with the characteristics that a StratCon scenario objective may have\n+     *\n+     */\n+    public static class ObjectiveParameters {\n+        /**\n+         * The type of objective this is; \n+         */\n+        @XmlElement(name=\"objectiveType\")\n+        StrategicObjectiveType objectiveType;\n+        \n+        /**\n+         * How many strategic objectives will be placed for this contract.\n+         * 0 means none. A number less than zero indicates that the number of strategic objectives \n+         * should be scaled to the number of lances required by the contract, and multiplied by that factor. \n+         */\n+        @XmlElement(name=\"objectiveCount\")\n+        double objectiveCount;\n+        \n+        /**\n+         * List of IDs (file names) of specific scenarios to use for this objective.\n+         * Ignored for AnyScenarioVictory or AlliedFacilityControl objective types\n+         */\n+        @XmlElementWrapper(name=\"objectiveScenarios\")\n+        @XmlElement(name=\"objectiveScenario\")\n+        List<String> objectiveScenarios;\n+        \n+        /**\n+         * If a particular scenario being generated is a strategic objective, it will have\n+         * these modifiers applied to it\n+         */\n+        @XmlElementWrapper(name=\"objectiveScenarioModifiers\")\n+        @XmlElement(name=\"objectiveScenarioModifier\")\n+        List<String> objectiveScenarioModifiers;\n+    }\n+    \n+    // Garrison Duty: Defend X facilities\n+    // Cadre Duty: Victory in X Training Exercise scenarios\n+    // Security Duty: Defend X facilities\n+    // Riot Duty: Defend X facilities, Riot Suppression scenarios\n+    // Planetary Assault: Destroy or Capture and Hold X facilities\n+    // Relief Duty: Hold X facilities (on hostile world!)\n+    // Guerilla Warfare: Victory in X scenarios, soft time limit (reinforcements) on all scenarios\n+    // Pirate Hunting: Victory in X scenarios \n+    // Diversionary Warfare: Victory in X scenarios\n+    // Objective Raid: Destroy X facilities\n+    // Extraction Raid: Extract from X facilities, victory in X capture scenarios\n+    // Recon Raid: Recon on X facilities\n+    // \n+    // future expansion:\n+    // Assassination: Victory in X Assassination scenarios\n+    // Terrorism: Victory in X \"Riot Suppression\" scenarios\n+    // Bounty Hunt: Victory in X Assassination, X Capture scenarios\n+    // Mole Hunting: ?\n+    // Espionage: ?\n+    // Sabotage: ?\n+    // Observation Raid: ?", "originalCommit": "ded0a76ab00c54323f9c24291d0a2582367b1792", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzQwNzgwNw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603407807", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @XmlRootElement(name=\"contractDefinitionManifest\")\n          \n          \n            \n                @XmlRootElement(name = \"contractDefinitionManifest\")", "author": "Windchild292", "createdAt": "2021-03-29T15:47:45Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconContractDefinition.java", "diffHunk": "@@ -0,0 +1,418 @@\n+/*\n+ * Copyright (c) 2019 The Megamek Team. All rights reserved.\n+ *\n+ * This file is part of MekHQ.\n+ *\n+ * MekHQ is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * MekHQ is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with MekHQ.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBElement;\n+import javax.xml.bind.Marshaller;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.namespace.QName;\n+import javax.xml.transform.Source;\n+\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.MekHqXmlUtil;\n+\n+/**\n+ * This class holds data relevant to the various types of contract\n+ * that can occur in the StratCon campaign system.\n+ * @author NickAragua\n+ *\n+ */\n+@XmlRootElement(name=\"StratconContractDefinition\")\n+public class StratconContractDefinition {\n+    public static final String ROOT_XML_ELEMENT_NAME = \"ScenarioTemplate\";\n+    public static final int COUNT_SCALED = -1;\n+    \n+    private static ContractDefinitionManifest definitionManifest;\n+    private static Map<Integer, StratconContractDefinition> loadedDefinitions = new HashMap<>();\n+    \n+    private static ContractDefinitionManifest getContractDefinitionManifest() {\n+        if (definitionManifest == null) {\n+            definitionManifest = ContractDefinitionManifest.Deserialize(MekHqConstants.STRATCON_CONTRACT_MANIFEST);\n+            \n+            // load user-specified modifier list\n+            ContractDefinitionManifest userDefinitionList = ContractDefinitionManifest.Deserialize(MekHqConstants.STRATCON_USER_CONTRACT_MANIFEST);\n+            if (userDefinitionList != null) {\n+                definitionManifest.definitionFileNames.putAll(userDefinitionList.definitionFileNames);\n+            }\n+        }\n+        \n+        return definitionManifest;\n+    }\n+    \n+    /**\n+     * Returns the stratcon contract definition for the given AtB Contract Type \n+     * as defined in AtBContract.java\n+     */\n+    public static StratconContractDefinition getContractDefinition(int atbContractType) {\n+        if (!loadedDefinitions.containsKey(atbContractType)) {\n+            String filePath = Paths.get(MekHqConstants.STRATCON_CONTRACT_PATH, \n+                    getContractDefinitionManifest().definitionFileNames.get(atbContractType)).toString();\n+            StratconContractDefinition def = Deserialize(new File(filePath));\n+            \n+            if (def == null) {\n+                MekHQ.getLogger().error(String.format(\"Unable to load contract definition %s\", filePath));\n+                return null;\n+            }\n+            \n+            loadedDefinitions.put(atbContractType, def);\n+        }\n+        \n+        return loadedDefinitions.get(atbContractType);\n+    }\n+    \n+    /**\n+     * The kind of actions that the player needs to undertake to complete\n+     * strategic objectives for this contract.\n+     */\n+    public enum StrategicObjectiveType {\n+        /**\n+         * Victory in any scenario\n+         */\n+        AnyScenarioVictory,\n+        \n+        /**\n+         * Victory in scenarios - designated by the \"objectiveScenarios\" collection.\n+         * These are one-off scenarios that stick around on tracks - when revealed, \n+         * they get a deploy/action/return date as usual, and the player gets one shot to complete them\n+         */\n+        SpecificScenarioVictory,\n+        \n+        /**\n+         * Control of allied facilities generated at contract start time\n+         * Each track will be seeded with some number of allied facilities\n+         * They must not be destroyed and the player must have control of them at the end-of-contract date \n+         */\n+        AlliedFacilityControl,\n+        \n+        /**\n+         * Control of hostile facilities generated at contract start time\n+         * Each track will be seeded with some number of hostile facilities\n+         * They must not be destroyed and the player must have control of them at the end-of-contract date\n+         */\n+        HostileFacilityControl,\n+        \n+        /**\n+         * Destruction of hostile facilities generated at contract start time\n+         * Each track will be seeded with some number of hostile facilities\n+         * They may either be destroyed or the player must have control of them at the end-of-contract date\n+         */\n+        FacilityDestruction\n+    }\n+    \n+    private String contractTypeName;\n+    private String briefing;\n+    \n+    /**\n+     * How many allied facilities to generate for the contract, \n+     * in addition to any facilities placed by objectives.\n+     * < 0 indicates that the number of facilities should be scaled to the number of \n+     * lances required by the contract. 0 indicates no additional allied facilities.\n+     */\n+    private double alliedFacilityCount;\n+    \n+    /**\n+     * How many hostile facilities to generate for the contract, \n+     * in addition to any facilities placed by objectives.\n+     * -1 indicates that the number of facilities should be scaled to the number of \n+     * lances required by the contract. 0 indicates no additional hostile facilities.\n+     */\n+    private double hostileFacilityCount;\n+    \n+    /**\n+     * List of scenario IDs (file names) that are allowed for this contract type\n+     */\n+    private List<String> allowedScenarios;\n+    \n+    /**\n+     * List of scenario IDs (file names) that are not allowed for this contract type\n+     */\n+    private List<String> forbiddenScenarios;\n+    \n+    /**\n+     * Strategic objectives for this contract.\n+     */\n+    private List<ObjectiveParameters> objectiveParameters;\n+    \n+    /**\n+     * If true, strategic objective scenarios contribute to the VP count\n+     */\n+    private boolean objectivesBehaveAsVPs;\n+    \n+    private List<Integer> scenarioOdds;\n+    \n+    private List<Integer> deploymentTimes;\n+\n+    public String getContractTypeName() {\n+        return contractTypeName;\n+    }\n+\n+    public void setContractTypeName(String contractTypeName) {\n+        this.contractTypeName = contractTypeName;\n+    }\n+\n+    /**\n+     * @return the briefing\n+     */\n+    public String getBriefing() {\n+        return briefing;\n+    }\n+\n+    /**\n+     * @param briefing the briefing to set\n+     */\n+    public void setBriefing(String briefing) {\n+        this.briefing = briefing;\n+    }\n+\n+    /**\n+     * @return the alliedFacilityCount\n+     */\n+    public double getAlliedFacilityCount() {\n+        return alliedFacilityCount;\n+    }\n+\n+    /**\n+     * @param alliedFacilityCount the alliedFacilityCount to set\n+     */\n+    public void setAlliedFacilityCount(double alliedFacilityCount) {\n+        this.alliedFacilityCount = alliedFacilityCount;\n+    }\n+\n+    /**\n+     * @return the hostileFacilityCount\n+     */\n+    public double getHostileFacilityCount() {\n+        return hostileFacilityCount;\n+    }\n+\n+    /**\n+     * @param hostileFacilityCount the hostileFacilityCount to set\n+     */\n+    public void setHostileFacilityCount(double hostileFacilityCount) {\n+        this.hostileFacilityCount = hostileFacilityCount;\n+    }\n+\n+    @XmlElementWrapper(name=\"allowedScenarios\")\n+    @XmlElement(name=\"allowedScenario\")\n+    public List<String> getAllowedScenarios() {\n+        return allowedScenarios;\n+    }\n+\n+    public void setAllowedScenarios(List<String> allowedScenarios) {\n+        this.allowedScenarios = allowedScenarios;\n+    }\n+\n+    @XmlElementWrapper(name=\"forbiddenScenarios\")\n+    @XmlElement(name=\"forbiddenScenario\")\n+    public List<String> getForbiddenScenarios() {\n+        return forbiddenScenarios;\n+    }\n+\n+    public void setForbiddenScenarios(List<String> forbiddenScenarios) {\n+        this.forbiddenScenarios = forbiddenScenarios;\n+    }\n+    \n+    @XmlElementWrapper(name=\"objectiveParameters\")\n+    @XmlElement(name=\"objectiveParameter\")\n+    public List<ObjectiveParameters> getObjectiveParameters() {\n+        return objectiveParameters;\n+    }\n+\n+    public void setObjectiveParameters(List<ObjectiveParameters> objectiveParameters) {\n+        this.objectiveParameters = objectiveParameters;\n+    }\n+\n+    public boolean objectivesBehaveAsVPs() {\n+        return objectivesBehaveAsVPs;\n+    }\n+\n+    public void setObjectivesBehaveAsVPs(boolean objectivesBehaveAsVPs) {\n+        this.objectivesBehaveAsVPs = objectivesBehaveAsVPs;\n+    }\n+\n+    @XmlElementWrapper(name=\"scenarioOdds\")\n+    @XmlElement(name=\"scenarioOdds\")\n+    public List<Integer> getScenarioOdds() {\n+        return scenarioOdds;\n+    }\n+\n+    public void setScenarioOdds(List<Integer> scenarioOdds) {\n+        this.scenarioOdds = scenarioOdds;\n+    }\n+\n+    @XmlElementWrapper(name=\"deploymentTimes\")\n+    @XmlElement(name=\"deploymentTimes\")\n+    public List<Integer> getDeploymentTimes() {\n+        return deploymentTimes;\n+    }\n+\n+    public void setDeploymentTimes(List<Integer> deploymentTimes) {\n+        this.deploymentTimes = deploymentTimes;\n+    }\n+\n+    /**\n+     * Data structure that deals with the characteristics that a StratCon scenario objective may have\n+     *\n+     */\n+    public static class ObjectiveParameters {\n+        /**\n+         * The type of objective this is; \n+         */\n+        @XmlElement(name=\"objectiveType\")\n+        StrategicObjectiveType objectiveType;\n+        \n+        /**\n+         * How many strategic objectives will be placed for this contract.\n+         * 0 means none. A number less than zero indicates that the number of strategic objectives \n+         * should be scaled to the number of lances required by the contract, and multiplied by that factor. \n+         */\n+        @XmlElement(name=\"objectiveCount\")\n+        double objectiveCount;\n+        \n+        /**\n+         * List of IDs (file names) of specific scenarios to use for this objective.\n+         * Ignored for AnyScenarioVictory or AlliedFacilityControl objective types\n+         */\n+        @XmlElementWrapper(name=\"objectiveScenarios\")\n+        @XmlElement(name=\"objectiveScenario\")\n+        List<String> objectiveScenarios;\n+        \n+        /**\n+         * If a particular scenario being generated is a strategic objective, it will have\n+         * these modifiers applied to it\n+         */\n+        @XmlElementWrapper(name=\"objectiveScenarioModifiers\")\n+        @XmlElement(name=\"objectiveScenarioModifier\")\n+        List<String> objectiveScenarioModifiers;\n+    }\n+    \n+    // Garrison Duty: Defend X facilities\n+    // Cadre Duty: Victory in X Training Exercise scenarios\n+    // Security Duty: Defend X facilities\n+    // Riot Duty: Defend X facilities, Riot Suppression scenarios\n+    // Planetary Assault: Destroy or Capture and Hold X facilities\n+    // Relief Duty: Hold X facilities (on hostile world!)\n+    // Guerilla Warfare: Victory in X scenarios, soft time limit (reinforcements) on all scenarios\n+    // Pirate Hunting: Victory in X scenarios \n+    // Diversionary Warfare: Victory in X scenarios\n+    // Objective Raid: Destroy X facilities\n+    // Extraction Raid: Extract from X facilities, victory in X capture scenarios\n+    // Recon Raid: Recon on X facilities\n+    // \n+    // future expansion:\n+    // Assassination: Victory in X Assassination scenarios\n+    // Terrorism: Victory in X \"Riot Suppression\" scenarios\n+    // Bounty Hunt: Victory in X Assassination, X Capture scenarios\n+    // Mole Hunting: ?\n+    // Espionage: ?\n+    // Sabotage: ?\n+    // Observation Raid: ?\n+    \n+    /**\n+     * Serialize this instance of a scenario template to a File\n+     * Please pass in a non-null file.\n+     * @param outputFile The destination file.\n+     */\n+    public void Serialize(File outputFile) {\n+        try {\n+            JAXBContext context = JAXBContext.newInstance(StratconContractDefinition.class);\n+            JAXBElement<StratconContractDefinition> templateElement = new JAXBElement<>(new QName(ROOT_XML_ELEMENT_NAME), StratconContractDefinition.class, this);\n+            Marshaller m = context.createMarshaller();\n+            m.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);\n+            m.marshal(templateElement, outputFile);\n+        } catch (Exception e) {\n+            MekHQ.getLogger().error(\"Erorr serializing \" + outputFile.getPath(), e);\n+        }\n+    }\n+    \n+    /**\n+     * Attempt to deserialize an instance of a ScenarioTemplate from the passed-in file \n+     * @param inputFile The source file\n+     * @return Possibly an instance of a ScenarioTemplate\n+     */\n+    public static StratconContractDefinition Deserialize(File inputFile) {\n+        StratconContractDefinition resultingDefinition = null;\n+\n+        try {\n+            JAXBContext context = JAXBContext.newInstance(StratconContractDefinition.class);\n+            Unmarshaller um = context.createUnmarshaller();\n+            try (FileInputStream fileStream = new FileInputStream(inputFile)) {\n+                Source inputSource = MekHqXmlUtil.createSafeXmlSource(fileStream);\n+                JAXBElement<StratconContractDefinition> definitionElement = um.unmarshal(inputSource, StratconContractDefinition.class);\n+                resultingDefinition = definitionElement.getValue();\n+            }\n+        } catch (Exception e) {\n+            MekHQ.getLogger().error(\"Error deserializing contract definition \" + inputFile.getPath(), e);\n+        }\n+\n+        return resultingDefinition;\n+    }\n+    \n+    /**\n+     * A manifest containing IDs and file names of scenario template definitions\n+     * @author NickAragua\n+     */\n+    @XmlRootElement(name=\"contractDefinitionManifest\")", "originalCommit": "ded0a76ab00c54323f9c24291d0a2582367b1792", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzQwNzkyMw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r603407923", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    @XmlElementWrapper(name=\"contractDefinitions\")\n          \n          \n            \n                    @XmlElement(name=\"contractDefinition\")\n          \n          \n            \n                    @XmlElementWrapper(name = \"contractDefinitions\")\n          \n          \n            \n                    @XmlElement(name = \"contractDefinition\")", "author": "Windchild292", "createdAt": "2021-03-29T15:47:55Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconContractDefinition.java", "diffHunk": "@@ -0,0 +1,418 @@\n+/*\n+ * Copyright (c) 2019 The Megamek Team. All rights reserved.\n+ *\n+ * This file is part of MekHQ.\n+ *\n+ * MekHQ is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * MekHQ is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with MekHQ.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBElement;\n+import javax.xml.bind.Marshaller;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.namespace.QName;\n+import javax.xml.transform.Source;\n+\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.MekHqXmlUtil;\n+\n+/**\n+ * This class holds data relevant to the various types of contract\n+ * that can occur in the StratCon campaign system.\n+ * @author NickAragua\n+ *\n+ */\n+@XmlRootElement(name=\"StratconContractDefinition\")\n+public class StratconContractDefinition {\n+    public static final String ROOT_XML_ELEMENT_NAME = \"ScenarioTemplate\";\n+    public static final int COUNT_SCALED = -1;\n+    \n+    private static ContractDefinitionManifest definitionManifest;\n+    private static Map<Integer, StratconContractDefinition> loadedDefinitions = new HashMap<>();\n+    \n+    private static ContractDefinitionManifest getContractDefinitionManifest() {\n+        if (definitionManifest == null) {\n+            definitionManifest = ContractDefinitionManifest.Deserialize(MekHqConstants.STRATCON_CONTRACT_MANIFEST);\n+            \n+            // load user-specified modifier list\n+            ContractDefinitionManifest userDefinitionList = ContractDefinitionManifest.Deserialize(MekHqConstants.STRATCON_USER_CONTRACT_MANIFEST);\n+            if (userDefinitionList != null) {\n+                definitionManifest.definitionFileNames.putAll(userDefinitionList.definitionFileNames);\n+            }\n+        }\n+        \n+        return definitionManifest;\n+    }\n+    \n+    /**\n+     * Returns the stratcon contract definition for the given AtB Contract Type \n+     * as defined in AtBContract.java\n+     */\n+    public static StratconContractDefinition getContractDefinition(int atbContractType) {\n+        if (!loadedDefinitions.containsKey(atbContractType)) {\n+            String filePath = Paths.get(MekHqConstants.STRATCON_CONTRACT_PATH, \n+                    getContractDefinitionManifest().definitionFileNames.get(atbContractType)).toString();\n+            StratconContractDefinition def = Deserialize(new File(filePath));\n+            \n+            if (def == null) {\n+                MekHQ.getLogger().error(String.format(\"Unable to load contract definition %s\", filePath));\n+                return null;\n+            }\n+            \n+            loadedDefinitions.put(atbContractType, def);\n+        }\n+        \n+        return loadedDefinitions.get(atbContractType);\n+    }\n+    \n+    /**\n+     * The kind of actions that the player needs to undertake to complete\n+     * strategic objectives for this contract.\n+     */\n+    public enum StrategicObjectiveType {\n+        /**\n+         * Victory in any scenario\n+         */\n+        AnyScenarioVictory,\n+        \n+        /**\n+         * Victory in scenarios - designated by the \"objectiveScenarios\" collection.\n+         * These are one-off scenarios that stick around on tracks - when revealed, \n+         * they get a deploy/action/return date as usual, and the player gets one shot to complete them\n+         */\n+        SpecificScenarioVictory,\n+        \n+        /**\n+         * Control of allied facilities generated at contract start time\n+         * Each track will be seeded with some number of allied facilities\n+         * They must not be destroyed and the player must have control of them at the end-of-contract date \n+         */\n+        AlliedFacilityControl,\n+        \n+        /**\n+         * Control of hostile facilities generated at contract start time\n+         * Each track will be seeded with some number of hostile facilities\n+         * They must not be destroyed and the player must have control of them at the end-of-contract date\n+         */\n+        HostileFacilityControl,\n+        \n+        /**\n+         * Destruction of hostile facilities generated at contract start time\n+         * Each track will be seeded with some number of hostile facilities\n+         * They may either be destroyed or the player must have control of them at the end-of-contract date\n+         */\n+        FacilityDestruction\n+    }\n+    \n+    private String contractTypeName;\n+    private String briefing;\n+    \n+    /**\n+     * How many allied facilities to generate for the contract, \n+     * in addition to any facilities placed by objectives.\n+     * < 0 indicates that the number of facilities should be scaled to the number of \n+     * lances required by the contract. 0 indicates no additional allied facilities.\n+     */\n+    private double alliedFacilityCount;\n+    \n+    /**\n+     * How many hostile facilities to generate for the contract, \n+     * in addition to any facilities placed by objectives.\n+     * -1 indicates that the number of facilities should be scaled to the number of \n+     * lances required by the contract. 0 indicates no additional hostile facilities.\n+     */\n+    private double hostileFacilityCount;\n+    \n+    /**\n+     * List of scenario IDs (file names) that are allowed for this contract type\n+     */\n+    private List<String> allowedScenarios;\n+    \n+    /**\n+     * List of scenario IDs (file names) that are not allowed for this contract type\n+     */\n+    private List<String> forbiddenScenarios;\n+    \n+    /**\n+     * Strategic objectives for this contract.\n+     */\n+    private List<ObjectiveParameters> objectiveParameters;\n+    \n+    /**\n+     * If true, strategic objective scenarios contribute to the VP count\n+     */\n+    private boolean objectivesBehaveAsVPs;\n+    \n+    private List<Integer> scenarioOdds;\n+    \n+    private List<Integer> deploymentTimes;\n+\n+    public String getContractTypeName() {\n+        return contractTypeName;\n+    }\n+\n+    public void setContractTypeName(String contractTypeName) {\n+        this.contractTypeName = contractTypeName;\n+    }\n+\n+    /**\n+     * @return the briefing\n+     */\n+    public String getBriefing() {\n+        return briefing;\n+    }\n+\n+    /**\n+     * @param briefing the briefing to set\n+     */\n+    public void setBriefing(String briefing) {\n+        this.briefing = briefing;\n+    }\n+\n+    /**\n+     * @return the alliedFacilityCount\n+     */\n+    public double getAlliedFacilityCount() {\n+        return alliedFacilityCount;\n+    }\n+\n+    /**\n+     * @param alliedFacilityCount the alliedFacilityCount to set\n+     */\n+    public void setAlliedFacilityCount(double alliedFacilityCount) {\n+        this.alliedFacilityCount = alliedFacilityCount;\n+    }\n+\n+    /**\n+     * @return the hostileFacilityCount\n+     */\n+    public double getHostileFacilityCount() {\n+        return hostileFacilityCount;\n+    }\n+\n+    /**\n+     * @param hostileFacilityCount the hostileFacilityCount to set\n+     */\n+    public void setHostileFacilityCount(double hostileFacilityCount) {\n+        this.hostileFacilityCount = hostileFacilityCount;\n+    }\n+\n+    @XmlElementWrapper(name=\"allowedScenarios\")\n+    @XmlElement(name=\"allowedScenario\")\n+    public List<String> getAllowedScenarios() {\n+        return allowedScenarios;\n+    }\n+\n+    public void setAllowedScenarios(List<String> allowedScenarios) {\n+        this.allowedScenarios = allowedScenarios;\n+    }\n+\n+    @XmlElementWrapper(name=\"forbiddenScenarios\")\n+    @XmlElement(name=\"forbiddenScenario\")\n+    public List<String> getForbiddenScenarios() {\n+        return forbiddenScenarios;\n+    }\n+\n+    public void setForbiddenScenarios(List<String> forbiddenScenarios) {\n+        this.forbiddenScenarios = forbiddenScenarios;\n+    }\n+    \n+    @XmlElementWrapper(name=\"objectiveParameters\")\n+    @XmlElement(name=\"objectiveParameter\")\n+    public List<ObjectiveParameters> getObjectiveParameters() {\n+        return objectiveParameters;\n+    }\n+\n+    public void setObjectiveParameters(List<ObjectiveParameters> objectiveParameters) {\n+        this.objectiveParameters = objectiveParameters;\n+    }\n+\n+    public boolean objectivesBehaveAsVPs() {\n+        return objectivesBehaveAsVPs;\n+    }\n+\n+    public void setObjectivesBehaveAsVPs(boolean objectivesBehaveAsVPs) {\n+        this.objectivesBehaveAsVPs = objectivesBehaveAsVPs;\n+    }\n+\n+    @XmlElementWrapper(name=\"scenarioOdds\")\n+    @XmlElement(name=\"scenarioOdds\")\n+    public List<Integer> getScenarioOdds() {\n+        return scenarioOdds;\n+    }\n+\n+    public void setScenarioOdds(List<Integer> scenarioOdds) {\n+        this.scenarioOdds = scenarioOdds;\n+    }\n+\n+    @XmlElementWrapper(name=\"deploymentTimes\")\n+    @XmlElement(name=\"deploymentTimes\")\n+    public List<Integer> getDeploymentTimes() {\n+        return deploymentTimes;\n+    }\n+\n+    public void setDeploymentTimes(List<Integer> deploymentTimes) {\n+        this.deploymentTimes = deploymentTimes;\n+    }\n+\n+    /**\n+     * Data structure that deals with the characteristics that a StratCon scenario objective may have\n+     *\n+     */\n+    public static class ObjectiveParameters {\n+        /**\n+         * The type of objective this is; \n+         */\n+        @XmlElement(name=\"objectiveType\")\n+        StrategicObjectiveType objectiveType;\n+        \n+        /**\n+         * How many strategic objectives will be placed for this contract.\n+         * 0 means none. A number less than zero indicates that the number of strategic objectives \n+         * should be scaled to the number of lances required by the contract, and multiplied by that factor. \n+         */\n+        @XmlElement(name=\"objectiveCount\")\n+        double objectiveCount;\n+        \n+        /**\n+         * List of IDs (file names) of specific scenarios to use for this objective.\n+         * Ignored for AnyScenarioVictory or AlliedFacilityControl objective types\n+         */\n+        @XmlElementWrapper(name=\"objectiveScenarios\")\n+        @XmlElement(name=\"objectiveScenario\")\n+        List<String> objectiveScenarios;\n+        \n+        /**\n+         * If a particular scenario being generated is a strategic objective, it will have\n+         * these modifiers applied to it\n+         */\n+        @XmlElementWrapper(name=\"objectiveScenarioModifiers\")\n+        @XmlElement(name=\"objectiveScenarioModifier\")\n+        List<String> objectiveScenarioModifiers;\n+    }\n+    \n+    // Garrison Duty: Defend X facilities\n+    // Cadre Duty: Victory in X Training Exercise scenarios\n+    // Security Duty: Defend X facilities\n+    // Riot Duty: Defend X facilities, Riot Suppression scenarios\n+    // Planetary Assault: Destroy or Capture and Hold X facilities\n+    // Relief Duty: Hold X facilities (on hostile world!)\n+    // Guerilla Warfare: Victory in X scenarios, soft time limit (reinforcements) on all scenarios\n+    // Pirate Hunting: Victory in X scenarios \n+    // Diversionary Warfare: Victory in X scenarios\n+    // Objective Raid: Destroy X facilities\n+    // Extraction Raid: Extract from X facilities, victory in X capture scenarios\n+    // Recon Raid: Recon on X facilities\n+    // \n+    // future expansion:\n+    // Assassination: Victory in X Assassination scenarios\n+    // Terrorism: Victory in X \"Riot Suppression\" scenarios\n+    // Bounty Hunt: Victory in X Assassination, X Capture scenarios\n+    // Mole Hunting: ?\n+    // Espionage: ?\n+    // Sabotage: ?\n+    // Observation Raid: ?\n+    \n+    /**\n+     * Serialize this instance of a scenario template to a File\n+     * Please pass in a non-null file.\n+     * @param outputFile The destination file.\n+     */\n+    public void Serialize(File outputFile) {\n+        try {\n+            JAXBContext context = JAXBContext.newInstance(StratconContractDefinition.class);\n+            JAXBElement<StratconContractDefinition> templateElement = new JAXBElement<>(new QName(ROOT_XML_ELEMENT_NAME), StratconContractDefinition.class, this);\n+            Marshaller m = context.createMarshaller();\n+            m.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);\n+            m.marshal(templateElement, outputFile);\n+        } catch (Exception e) {\n+            MekHQ.getLogger().error(\"Erorr serializing \" + outputFile.getPath(), e);\n+        }\n+    }\n+    \n+    /**\n+     * Attempt to deserialize an instance of a ScenarioTemplate from the passed-in file \n+     * @param inputFile The source file\n+     * @return Possibly an instance of a ScenarioTemplate\n+     */\n+    public static StratconContractDefinition Deserialize(File inputFile) {\n+        StratconContractDefinition resultingDefinition = null;\n+\n+        try {\n+            JAXBContext context = JAXBContext.newInstance(StratconContractDefinition.class);\n+            Unmarshaller um = context.createUnmarshaller();\n+            try (FileInputStream fileStream = new FileInputStream(inputFile)) {\n+                Source inputSource = MekHqXmlUtil.createSafeXmlSource(fileStream);\n+                JAXBElement<StratconContractDefinition> definitionElement = um.unmarshal(inputSource, StratconContractDefinition.class);\n+                resultingDefinition = definitionElement.getValue();\n+            }\n+        } catch (Exception e) {\n+            MekHQ.getLogger().error(\"Error deserializing contract definition \" + inputFile.getPath(), e);\n+        }\n+\n+        return resultingDefinition;\n+    }\n+    \n+    /**\n+     * A manifest containing IDs and file names of scenario template definitions\n+     * @author NickAragua\n+     */\n+    @XmlRootElement(name=\"contractDefinitionManifest\")\n+    private static class ContractDefinitionManifest {\n+        @XmlElementWrapper(name=\"contractDefinitions\")\n+        @XmlElement(name=\"contractDefinition\")", "originalCommit": "ded0a76ab00c54323f9c24291d0a2582367b1792", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3dded0625ac8cc74cf71fba631d6e7c6df97c371", "url": "https://github.com/MegaMek/mekhq/commit/3dded0625ac8cc74cf71fba631d6e7c6df97c371", "message": "code review changes", "committedDate": "2021-03-29T20:43:36Z", "type": "commit"}, {"oid": "8a2b3d0d594289885a5c010bfe1bf743a7de3938", "url": "https://github.com/MegaMek/mekhq/commit/8a2b3d0d594289885a5c010bfe1bf743a7de3938", "message": "more code review changes", "committedDate": "2021-03-29T20:52:53Z", "type": "commit"}, {"oid": "82e5dd27dc3e10e985bdcbed19cd76b6259dff97", "url": "https://github.com/MegaMek/mekhq/commit/82e5dd27dc3e10e985bdcbed19cd76b6259dff97", "message": "spacing fix", "committedDate": "2021-03-29T20:55:28Z", "type": "commit"}, {"oid": "28c4109397359f03a0b1d7aa3f4cd077dfa3d957", "url": "https://github.com/MegaMek/mekhq/commit/28c4109397359f03a0b1d7aa3f4cd077dfa3d957", "message": "Apply suggestions from code review\r\n\r\nPretty sure you can read it just fine, but whatever.\n\nCo-authored-by: Justin Bowen <39067288+Windchild292@users.noreply.github.com>", "committedDate": "2021-03-30T20:07:14Z", "type": "commit"}, {"oid": "4354381199803fb2531169486b957f10bfd2bbc7", "url": "https://github.com/MegaMek/mekhq/commit/4354381199803fb2531169486b957f10bfd2bbc7", "message": "Apply suggestions from code review\n\nCo-authored-by: Justin Bowen <39067288+Windchild292@users.noreply.github.com>", "committedDate": "2021-03-30T20:12:26Z", "type": "commit"}, {"oid": "0244602bac43aacfd804a92250447a67a4fbd75a", "url": "https://github.com/MegaMek/mekhq/commit/0244602bac43aacfd804a92250447a67a4fbd75a", "message": "Apply suggestions from code review\n\nCo-authored-by: Justin Bowen <39067288+Windchild292@users.noreply.github.com>", "committedDate": "2021-03-30T20:19:57Z", "type": "commit"}, {"oid": "37144650aef43bd5f3a8a14257376f2d6fe133f8", "url": "https://github.com/MegaMek/mekhq/commit/37144650aef43bd5f3a8a14257376f2d6fe133f8", "message": "merge from upstream", "committedDate": "2021-03-30T20:21:13Z", "type": "commit"}, {"oid": "7ab4b9b32a85421a74aca114cd2cede13b5ebf1a", "url": "https://github.com/MegaMek/mekhq/commit/7ab4b9b32a85421a74aca114cd2cede13b5ebf1a", "message": "Update MekHQ/data/scenariomodifiers/FacilityHostileCapture.xml\n\nCo-authored-by: Justin Bowen <39067288+Windchild292@users.noreply.github.com>", "committedDate": "2021-03-31T01:35:57Z", "type": "commit"}, {"oid": "55af097696b44f689e0ff88123ab5f39b18bd8c0", "url": "https://github.com/MegaMek/mekhq/commit/55af097696b44f689e0ff88123ab5f39b18bd8c0", "message": "merge", "committedDate": "2021-03-31T02:49:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNDQ5NjUyNg==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r604496526", "bodyText": "Switch was properly indented and is no longer.", "author": "Windchild292", "createdAt": "2021-03-30T23:30:38Z", "path": "MekHQ/src/mekhq/MekHQ.java", "diffHunk": "@@ -146,18 +147,18 @@ private static LogLevel verbosityToLogLevel(final int verbosity) {\n             return LogLevel.OFF;\n         }\n         switch (verbosity) {\n-            case 0:\n-                return LogLevel.FATAL;\n-            case 1:\n-                return LogLevel.ERROR;\n-            case 2:\n-                return LogLevel.WARNING;\n-            case 3:\n-                return LogLevel.INFO;\n-            case 4:\n-                return LogLevel.DEBUG;\n-            case 5:\n-                return LogLevel.TRACE;", "originalCommit": "0244602bac43aacfd804a92250447a67a4fbd75a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNDQ5NzM3NQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r604497375", "bodyText": "Revert or merge these two lines. Also... The changes make me think you used the full formatter with standard parameters. In general that's a solid improvement, but devs can make better decisions in some cases. This can be better handled as:\nEclipse: https://javarevisited.blogspot.com/2016/06/how-to-make-eclipse-use-spaces-instead.html\nIDEA: https://stackoverflow.com/questions/41532061/shortcut-for-changing-tabs-spaces-tabs-in-intellij-idea#:~:text=In%20IntelliJ%20IDEA%2C%20to%20convert,this%2C%20while%20applying%20other%20changes.", "author": "Windchild292", "createdAt": "2021-03-30T23:33:24Z", "path": "MekHQ/src/mekhq/MekHQ.java", "diffHunk": "@@ -343,33 +342,34 @@ public static void main(String[] args) {\n     }\n \n     private void showInfo() {\n-        final long TIMESTAMP = new File(PreferenceManager.getClientPreferences().getLogDirectory()\n-                + File.separator + \"timestamp\").lastModified();\n+        final long TIMESTAMP = new File(\n+                PreferenceManager.getClientPreferences().getLogDirectory() + File.separator + \"timestamp\")\n+                        .lastModified();\n         // echo some useful stuff\n         ResourceBundle resourceMap = ResourceBundle.getBundle(\"mekhq.resources.MekHQ\", new EncodeControl());\n \n         StringBuilder msg = new StringBuilder();\n-        msg.append(\"\\t\").append(resourceMap.getString(\"Application.name\")).append(\" \").append(resourceMap.getString(\"Application.version\"));\n+        msg.append(\"\\t\").append(resourceMap.getString(\"Application.name\")).append(\" \")\n+                .append(resourceMap.getString(\"Application.version\"));\n         if (TIMESTAMP > 0) {\n             msg.append(\"\\n\\tCompiled on \").append(Instant.ofEpochMilli(TIMESTAMP));\n         }\n-        msg.append(\"\\n\\tToday is \").append(LocalDate.now())\n-                .append(\"\\n\\tJava vendor \").append(System.getProperty(\"java.vendor\"))\n-                .append(\"\\n\\tJava version \").append(System.getProperty(\"java.version\"))\n-                .append(\"\\n\\tPlatform \")\n-                .append(System.getProperty(\"os.name\")).append(\" \").append(System.getProperty(\"os.version\"))\n-               .append(\" (\").append(System.getProperty(\"os.arch\")).append(\")\");\n+        msg.append(\"\\n\\tToday is \").append(LocalDate.now()).append(\"\\n\\tJava vendor \")\n+                .append(System.getProperty(\"java.vendor\")).append(\"\\n\\tJava version \")\n+                .append(System.getProperty(\"java.version\")).append(\"\\n\\tPlatform \")\n+                .append(System.getProperty(\"os.name\")).append(\" \").append(System.getProperty(\"os.version\")).append(\" (\")\n+                .append(System.getProperty(\"os.arch\")).append(\")\");\n         msg.append(\"\\n\\tTotal memory available to MegaMek: \")\n-                .append(NumberFormat.getInstance().format(Runtime.getRuntime().maxMemory() / 1024))\n-                .append(\" kB\");\n+                .append(NumberFormat.getInstance().format(Runtime.getRuntime().maxMemory() / 1024)).append(\" kB\");\n         getLogger().info(msg.toString());\n     }\n \n     /**\n-     * This function redirects the standard error and output streams to the\n-     * given File name.\n+     * This function redirects the standard error and output streams to the given\n+     * File name.\n      */\n-    @Deprecated // March 12th, 2020. This is no longer used by MekHQ, but is required to hide MegaMek's\n+    @Deprecated // March 12th, 2020. This is no longer used by MekHQ, but is required to hide\n+                // MegaMek's\n     // output to the console for dev builds", "originalCommit": "0244602bac43aacfd804a92250447a67a4fbd75a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNDQ5NzYzMA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r604497630", "bodyText": "Legacy format, fix", "author": "Windchild292", "createdAt": "2021-03-30T23:34:10Z", "path": "MekHQ/src/mekhq/MekHQ.java", "diffHunk": "@@ -386,8 +386,7 @@ private static void redirectOutput(String logFilename) {\n             System.setOut(ps);\n             System.setErr(ps);\n         } catch (Exception e) {\n-            MekHQ.getLogger().error(MekHQ.class, \"redirectOutput\",\n-                    \"Unable to redirect output to mekhqlog.txt\", e);\n+            MekHQ.getLogger().error(MekHQ.class, \"redirectOutput\", \"Unable to redirect output to mekhqlog.txt\", e);", "originalCommit": "0244602bac43aacfd804a92250447a67a4fbd75a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNDQ5ODM1NA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r604498354", "bodyText": "Dev formatting override case, revert changes", "author": "Windchild292", "createdAt": "2021-03-30T23:36:13Z", "path": "MekHQ/src/mekhq/MekHQ.java", "diffHunk": "@@ -576,14 +576,14 @@ public void gameVictory(GameVictoryEvent gve) {\n \n         try {\n             boolean control = JOptionPane.showConfirmDialog(campaigngui.getFrame(),\n-                    \"Did your side control the battlefield at the end of the scenario?\",\n-                    \"Control of Battlefield?\",\n+                    \"Did your side control the battlefield at the end of the scenario?\", \"Control of Battlefield?\",\n                     JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE) == JOptionPane.YES_OPTION;\n             ResolveScenarioTracker tracker = new ResolveScenarioTracker(currentScenario, getCampaign(), control);\n             tracker.setClient(gameThread.getClient());\n             tracker.setEvent(gve);\n             tracker.processGame();\n-            ResolveScenarioWizardDialog resolveDialog = new ResolveScenarioWizardDialog(campaigngui.getFrame(), true, tracker);\n+            ResolveScenarioWizardDialog resolveDialog = new ResolveScenarioWizardDialog(campaigngui.getFrame(), true,\n+                    tracker);", "originalCommit": "0244602bac43aacfd804a92250447a67a4fbd75a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNDQ5ODQwNA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r604498404", "bodyText": "Swap to single line format", "author": "Windchild292", "createdAt": "2021-03-30T23:36:24Z", "path": "MekHQ/src/mekhq/MekHQ.java", "diffHunk": "@@ -596,7 +596,7 @@ public void gameVictory(GameVictoryEvent gve) {\n                 }\n             }\n             gameThread.requestStop();\n-            /*MegaMek dumps these in the deployment phase to free memory*/\n+            /* MegaMek dumps these in the deployment phase to free memory */", "originalCommit": "0244602bac43aacfd804a92250447a67a4fbd75a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNDUwMTI4OA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r604501288", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    int numBombs = (int) (entity.getWeight() / BombType.getBombCost(bombIndex) * 5);\n          \n          \n            \n                    int numBombs = (int) (entity.getWeight() / (BombType.getBombCost(bombIndex) * 5));", "author": "Windchild292", "createdAt": "2021-03-30T23:44:53Z", "path": "MekHQ/src/mekhq/campaign/mission/AtBDynamicScenarioFactory.java", "diffHunk": "@@ -2341,25 +2340,28 @@ public static void populateAeroBombs(List<Entity> entityList, Campaign campaign,\n \n     /**\n      * Worker function that takes an entity and an array of bomb types\n-     * and loads it up with a random amount of bombs that it's capable of holding\n+     * and loads it up with as many of a mostly period-appropriate random bomb type \n+     * as it's capable of holding\n      */\n     private static void loadBombs(Entity entity, int[] validBombChoices, int year) {\n         int[] bombChoices = new int[BombType.B_NUM];\n         \n         // remove bomb choices if they're not era-appropriate\n-        List<Integer> actualBombChoices = new ArrayList<>();\n+        List<Integer> actualValidBombChoices = new ArrayList<>();\n         for (int x = 0; x < validBombChoices.length; x++) {\n             String typeName = BombType.getBombInternalName(validBombChoices[x]);\n             \n             // hack: make rocket launcher pods available before 3055\n-            if (validBombChoices[x] == BombType.B_RL ||\n+            if ((validBombChoices[x] == BombType.B_RL) ||\n                     BombType.get(typeName).isAvailableIn(year)) {\n-                actualBombChoices.add(validBombChoices[x]);\n+                actualValidBombChoices.add(validBombChoices[x]);\n             }\n         }\n         \n-        int numBombs = (int) (entity.getWeight() / 5);\n-        int bombIndex = actualBombChoices.get(Compute.randomInt(actualBombChoices.size()));\n+        // pick out the index in the BombType array\n+        int bombIndex = actualValidBombChoices.get(Compute.randomInt(actualValidBombChoices.size()));\n+        // # of bombs is the unit's weight / (bomb cost * 5)\n+        int numBombs = (int) (entity.getWeight() / BombType.getBombCost(bombIndex) * 5);", "originalCommit": "0244602bac43aacfd804a92250447a67a4fbd75a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNDUwMTQ1OA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r604501458", "bodyText": "Far easier to read if it dupes the comment", "author": "Windchild292", "createdAt": "2021-03-30T23:45:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNDUwMTI4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNjUzOTQ4OA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r606539488", "bodyText": "More importantly, the order of operations matters.", "author": "NickAragua", "createdAt": "2021-04-03T00:42:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNDUwMTI4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNDUwMzk4Mw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r604503983", "bodyText": "Can likely be combined into a single line", "author": "Windchild292", "createdAt": "2021-03-30T23:52:39Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1291 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.UUID;\n+\n+import megamek.common.Compute;\n+import megamek.common.Minefield;\n+import megamek.common.UnitType;\n+import megamek.common.annotations.Nullable;\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.Utilities;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.ResolveScenarioTracker;\n+import mekhq.campaign.againstTheBot.enums.AtBLanceRole;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.event.StratconDeploymentEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.force.Lance;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier.EventTiming;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.unit.Unit;\n+\n+/**\n+ * This class contains \"rules\" logic for the AtB-Stratcon state\n+ * @author NickAragua\n+ */\n+public class StratconRulesManager {\n+    /**\n+     * What makes a particular lance eligible to be reinforcements for a scenario\n+     * @author NickAragua\n+     */\n+    public enum ReinforcementEligibilityType {\n+        /**\n+         * Nothing\n+         */\n+        None,\n+\n+        /**\n+         * Lance is already deployed to the track\n+         */\n+        ChainedScenario,\n+\n+        /**\n+         * We pay a support point or convert a victory point to a support point\n+         */\n+        SupportPoint,\n+\n+        /**\n+         * The lance's deployment orders are \"Fight\"\n+         */\n+        FightLance\n+    }\n+\n+    /**\n+     * This function potentially generates non-player-initiated scenarios for the given track.\n+     */\n+    public static void generateScenariosForTrack(Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // maps scenarios to force IDs\n+        List<StratconScenario> generatedScenarios = new ArrayList<>();\n+        boolean autoAssignLances = contract.getCommandRights() == AtBContract.COM_INTEGRATED;\n+\n+        // get this list just so we have it available\n+        List<Integer> availableForceIDs = getAvailableForceIDs(campaign);\n+        Map<MapLocation, List<Integer>> sortedAvailableForceIDs = sortForcesByMapType(availableForceIDs, campaign);\n+\n+        // make X rolls, where X is the number of required lances for the track\n+        // that's the chance to spawn a scenario.\n+        // if a scenario occurs, then we pick a random non-deployed lance and use it to drive the opfor generation later\n+        // once we've determined that scenarios occur, we loop through the ones that we generated\n+        // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all\n+        for (int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            // if we haven't already used all the player forces and are required to randomly generate a scenario\n+            if ((availableForceIDs.size() > 0) &&\n+                    (Compute.randomInt(100) <= track.getScenarioOdds())) {", "originalCommit": "0244602bac43aacfd804a92250447a67a4fbd75a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNDUwNTU2MQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r604505561", "bodyText": "Indent switch", "author": "Windchild292", "createdAt": "2021-03-30T23:57:35Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1291 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.UUID;\n+\n+import megamek.common.Compute;\n+import megamek.common.Minefield;\n+import megamek.common.UnitType;\n+import megamek.common.annotations.Nullable;\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.Utilities;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.ResolveScenarioTracker;\n+import mekhq.campaign.againstTheBot.enums.AtBLanceRole;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.event.StratconDeploymentEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.force.Lance;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier.EventTiming;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.unit.Unit;\n+\n+/**\n+ * This class contains \"rules\" logic for the AtB-Stratcon state\n+ * @author NickAragua\n+ */\n+public class StratconRulesManager {\n+    /**\n+     * What makes a particular lance eligible to be reinforcements for a scenario\n+     * @author NickAragua\n+     */\n+    public enum ReinforcementEligibilityType {\n+        /**\n+         * Nothing\n+         */\n+        None,\n+\n+        /**\n+         * Lance is already deployed to the track\n+         */\n+        ChainedScenario,\n+\n+        /**\n+         * We pay a support point or convert a victory point to a support point\n+         */\n+        SupportPoint,\n+\n+        /**\n+         * The lance's deployment orders are \"Fight\"\n+         */\n+        FightLance\n+    }\n+\n+    /**\n+     * This function potentially generates non-player-initiated scenarios for the given track.\n+     */\n+    public static void generateScenariosForTrack(Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // maps scenarios to force IDs\n+        List<StratconScenario> generatedScenarios = new ArrayList<>();\n+        boolean autoAssignLances = contract.getCommandRights() == AtBContract.COM_INTEGRATED;\n+\n+        // get this list just so we have it available\n+        List<Integer> availableForceIDs = getAvailableForceIDs(campaign);\n+        Map<MapLocation, List<Integer>> sortedAvailableForceIDs = sortForcesByMapType(availableForceIDs, campaign);\n+\n+        // make X rolls, where X is the number of required lances for the track\n+        // that's the chance to spawn a scenario.\n+        // if a scenario occurs, then we pick a random non-deployed lance and use it to drive the opfor generation later\n+        // once we've determined that scenarios occur, we loop through the ones that we generated\n+        // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all\n+        for (int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            // if we haven't already used all the player forces and are required to randomly generate a scenario\n+            if ((availableForceIDs.size() > 0) &&\n+                    (Compute.randomInt(100) <= track.getScenarioOdds())) {\n+                // pick random coordinates and force to drive the scenario\n+                int x = Compute.randomInt(track.getWidth());\n+                int y = Compute.randomInt(track.getHeight());\n+\n+                StratconCoords scenarioCoords = new StratconCoords(x, y);\n+\n+                // if forces are already assigned to these coordinates, use those instead\n+                // of randomly-selected ones\n+                if (track.getAssignedCoordForces().containsKey(scenarioCoords)) {\n+                    StratconScenario scenario = generateScenarioForExistingForces(scenarioCoords,\n+                            track.getAssignedCoordForces().get(scenarioCoords), \n+                            contract, campaign, track);\n+                    generatedScenarios.add(scenario);\n+                    continue;\n+                }\n+                \n+                // otherwise, pick a random force from the avail\n+                int randomForceIndex = Compute.randomInt(availableForceIDs.size());\n+                int randomForceID = availableForceIDs.get(randomForceIndex);\n+                \n+                // remove the force from the available lists so we don't designate it as primary twice\n+                availableForceIDs.remove(randomForceIndex);\n+\n+                // we want to remove the actual int with the value, not the value at the index\n+                sortedAvailableForceIDs.get(MapLocation.AllGroundTerrain).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.LowAtmosphere).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.Space).remove((Integer) randomForceID);\n+\n+                // two scenarios on the same coordinates wind up increasing in size\n+                if (track.getScenarios().containsKey(scenarioCoords)) {\n+                    track.getScenarios().get(scenarioCoords).incrementRequiredPlayerLances();\n+                    assignAppropriateExtraForceToScenario(track.getScenarios().get(scenarioCoords), sortedAvailableForceIDs);\n+                    continue;\n+                }\n+\n+                StratconScenario scenario = setupScenario(scenarioCoords, randomForceID, campaign, contract, track);\n+                generatedScenarios.add(scenario);\n+\n+                // if we're auto-assigning lances, deploy the force to the track as well\n+                if (autoAssignLances) {\n+                    processForceDeployment(scenarioCoords, randomForceID, campaign, track, false);\n+                }\n+            }\n+        }\n+\n+        // if under liaison command, pick a random scenario from the ones generated\n+        // to set as required and attach liaison\n+        if (contract.getCommandRights() == AtBContract.COM_LIAISON) {\n+        \tStratconScenario randomScenario = Utilities.getRandomItem(generatedScenarios);\n+        \trandomScenario.setRequiredScenario(true);\n+            setAttachedUnitsModifier(randomScenario, contract);\n+        }\n+\n+        // now, we loop through all the scenarios we set up\n+        // and generate the opfors / events / etc\n+        // if not auto-assigning lances, we then back out the lance assignments.\n+        for (StratconScenario scenario : generatedScenarios) {\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+\n+            if(!autoAssignLances && !scenario.ignoreForceAutoAssignment()) {\n+                for(int forceID : scenario.getPlayerTemplateForceIDs()) {\n+                    scenario.getBackingScenario().removeForce(forceID);\n+                }\n+\n+                scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                track.addScenario(scenario);\n+            } else {\n+                commitPrimaryForces(campaign, contract, scenario, track);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Given a set of force IDs and coordinates, generate a scenario\n+     * Useful for when we want to generate scenarios \n+     * for forces already deployed to a track\n+     */\n+    public static StratconScenario generateScenarioForExistingForces(StratconCoords scenarioCoords, \n+            Set<Integer> forceIDs, AtBContract contract, Campaign campaign, StratconTrackState track) {\n+        boolean firstForce = true;\n+        StratconScenario scenario = null;\n+        \n+        for (int forceID : forceIDs) {\n+            if (firstForce) {\n+                scenario = setupScenario(scenarioCoords, forceID, campaign, contract, track);\n+                firstForce = false;\n+            } else {\n+                scenario.incrementRequiredPlayerLances();\n+                scenario.addPrimaryForce(forceID);\n+            }\n+        }\n+        \n+        scenario.setIgnoreForceAutoAssignment(true);\n+        return scenario;\n+    }\n+\n+    /**\n+     * Deploys a force to the given coordinates on the given track as a result of explicit player action.\n+     */\n+    public static void deployForceToCoords(StratconCoords coords, int forceID, \n+            Campaign campaign, AtBContract contract, StratconTrackState track, boolean sticky) {\n+        // the following things should happen:\n+        // 1. call to \"process force deployment\", which reveals fog of war in or around the coords, depending on force role\n+        // 2. if coords are a hostile facility, we get a facility mission\n+        // 3. if coords are empty, we *may* get a mission\n+\n+        processForceDeployment(coords, forceID, campaign, track, sticky);\n+\n+        // don't create a scenario on top of allied facilities\n+        StratconFacility facility = track.getFacility(coords);\n+        boolean isNonAlliedFacility = (facility != null) && (facility.getOwner() != ForceAlignment.Allied);\n+        boolean spawnScenario = (facility == null) && (Compute.randomInt(100) <= track.getScenarioOdds());\n+\n+        if (isNonAlliedFacility || spawnScenario) {\n+            StratconScenario scenario = setupScenario(coords, forceID, campaign, contract, track);\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            commitPrimaryForces(campaign, contract, scenario, track);\n+        }\n+    }\n+\n+    /**\n+     * Logic to set up a scenario\n+     */\n+    private static StratconScenario setupScenario(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        StratconScenario scenario = null;\n+\n+        if (track.getFacilities().containsKey(coords)) {\n+            StratconFacility facility = track.getFacility(coords);\n+            boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+            ScenarioTemplate template = StratconScenarioFactory.getFacilityScenario(alliedFacility);\n+            scenario = generateScenario(campaign, contract, track, forceID, coords, template);\n+            setupFacilityScenario(scenario, facility);\n+        } else {\n+            scenario = generateScenario(campaign, contract, track, forceID, coords);\n+\n+            // we may generate a facility scenario randomly - if so, do the facility-related stuff\n+            // and add a new facility to the track\n+            if (scenario.getBackingScenario().getTemplate().isFacilityScenario()) {\n+                StratconFacility facility = scenario.getBackingScenario().getTemplate().isHostileFacility() ?\n+                        StratconFacilityFactory.getRandomHostileFacility() : StratconFacilityFactory.getRandomAlliedFacility();\n+                facility.setVisible(true);\n+                track.addFacility(coords, facility);\n+                setupFacilityScenario(scenario, facility);\n+            }\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * carries out tasks relevant to facility scenarios\n+     */\n+    private static void setupFacilityScenario(StratconScenario scenario, StratconFacility facility) {\n+        // this includes:\n+        // for hostile facilities\n+        // - add a destroy objective (always the option to level the facility)\n+        // - add a capture objective (always the option to capture the facility)\n+        // - if so indicated by parameter, roll a random hostile facility objective and add it if not capture/destroy\n+        // for allied facilities\n+        // - add a defend objective (always the option to defend the facility)\n+        // - if so indicated by parameter, roll a random allied facility objective and add it if not defend\n+        AtBScenarioModifier objectiveModifier = null;\n+        boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+\n+        if (alliedFacility) {\n+            objectiveModifier = AtBScenarioModifier.getRandomAlliedFacilityModifier();\n+        } else {\n+            objectiveModifier = AtBScenarioModifier.getRandomHostileFacilityModifier();\n+        }\n+\n+        if (objectiveModifier != null) {\n+            scenario.getBackingScenario().addScenarioModifier(objectiveModifier);\n+            scenario.getBackingScenario().setName(String.format(\"%s - %s - %s\",\n+                    facility.getFacilityType(), alliedFacility ? \"Allied\" : \"Hostile\", objectiveModifier.getModifierName()));\n+        }\n+\n+        // add the \"fixed\" hostile facility modifiers after the primary ones\n+        if (!alliedFacility) {\n+            for(AtBScenarioModifier modifier : AtBScenarioModifier.getRequiredHostileFacilityModifiers()) {\n+                if(!scenario.getBackingScenario().alreadyHasModifier(modifier)) {\n+                    scenario.getBackingScenario().addScenarioModifier(modifier);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void processFacilityEffects(StratconTrackState track) {\n+        // TODO: these are \"weekly\"? effects that a stratcon facility has on the campaign/track state\n+        // currrently, that's\n+        // supply depot - allied - +1 sp\n+        // supply depot - hostile - +5% BV budget to all scenarios on track (shared modifier, so should be implemented there)\n+        // data center - allied - +1% star league cache contract (don't implement yet, but...)\n+        // data center - hostile - +5% scenario odds in track\n+        // industrial center - allied - all scenarios here have THIS IS COMING OUT OF YOUR PAYCHECK modifier\n+        // orbital defense - allied - sets 'no hostile aircraft' flag for track\n+        // orbital defense - hostile - sets 'no allied aircraft' flag for track\n+        // early warning system - allied - sets 'intercept allied base attacks' flag for track\n+        // early warning system - hostile - sets 'intercept hostile base attacks' flag for track\n+    }\n+\n+    /**\n+     * Process the deployment of a force to the given coordinates on the given track.\n+     */\n+    public static void processForceDeployment(StratconCoords coords, int forceID, \n+            Campaign campaign, StratconTrackState track, boolean sticky) {\n+        track.getRevealedCoords().add(coords);\n+        StratconFacility facility = track.getFacility(coords);\n+        if (facility != null) {\n+            facility.setVisible(true);\n+        }\n+\n+        if (campaign.getLances().get(forceID).getRole() == AtBLanceRole.SCOUTING) {\n+            for(int direction = 0; direction < 6; direction++) {\n+                StratconCoords checkCoords = coords.translate(direction);\n+\n+                facility = track.getFacility(checkCoords);\n+                if(facility != null) {\n+                    facility.setVisible(true);\n+                }\n+\n+                track.getRevealedCoords().add(coords.translate(direction));\n+            }\n+        }\n+\n+        // the force may be located in other places on the track - clear it out\n+        track.unassignForce(forceID);\n+        track.assignForce(forceID, coords, campaign.getLocalDate(), sticky);\n+        MekHQ.triggerEvent(new StratconDeploymentEvent(campaign.getForce(forceID)));\n+    }\n+\n+    /**\n+     * Worker function that processes the effects of deploying a reinforcement force to a scenario\n+     */\n+    public static boolean processReinforcementDeployment(ReinforcementEligibilityType reinforcementType,\n+            StratconCampaignState campaignState, StratconScenario scenario, Campaign campaign) {\n+        // if the force is already deployed to the track, we're done\n+        // if the force is a fight lance or we're using a support point\n+        // if there is an SP to burn, burn it and we're done\n+        // if there is a VP to burn, burn it and we're done\n+        // now, roll 2d6 + lance commander tactics\n+        // 9+ = deploy\n+        // 6+ = deploy, apply negative modifier to scenario\n+        // 2+ = fail to deploy, apply negative modifier to scenario; if fight lance, treat as 6+\n+\n+        if ((reinforcementType == ReinforcementEligibilityType.FightLance) ||\n+                (reinforcementType == ReinforcementEligibilityType.SupportPoint)) {\n+\n+            if (campaignState.getSupportPoints() > 0) {\n+                campaignState.useSupportPoint();\n+                return true;\n+            } else if (campaignState.getVictoryPoints() > 0) {\n+                campaignState.updateVictoryPoints(-1);\n+                return true;\n+            }\n+\n+            int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+            int roll = Compute.d6(2);\n+            int result = roll + tactics;\n+\n+            StringBuilder reportStatus = new StringBuilder();\n+            reportStatus.append(String.format(\"Attempting to reinforce scenario %s without SP/VP, roll 2d6 + %d: %d\",\n+                    scenario.getName(), tactics, result));\n+\n+            // fail to reinforce\n+            if ((result < 6) && (reinforcementType != ReinforcementEligibilityType.FightLance)) {\n+                reportStatus.append(\" - reinforcement attempt failed.\");\n+                campaign.addReport(reportStatus.toString());\n+                return false;\n+            // succeed but get an extra negative event added to the scenario\n+            } else if (result < 9) {\n+                MapLocation mapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+                AtBScenarioModifier scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+\n+                // keep rolling until we get an applicable one\n+                // TODO: have the AtBScenarioModifier sort these out instead for performance?\n+                while (scenarioModifier.getEventTiming() != EventTiming.PostForceGeneration) {\n+                    scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+                }\n+\n+                scenarioModifier.processModifier(scenario.getBackingScenario(), campaign, EventTiming.PostForceGeneration);\n+\n+                reportStatus.append(String.format(\" - reinforcement attempt succeeded; extra negative modifier (%s) applied to scenario.\",\n+                        scenarioModifier.getModifierName()));\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            // succeed without reservation\n+            } else {\n+                reportStatus.append(\" - reinforcement attempt succeeded;\");\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            }\n+        } else if (reinforcementType == ReinforcementEligibilityType.None) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Assigns a force to the scenario such that the majority of the force can be deployed\n+     */\n+    private static void assignAppropriateExtraForceToScenario(StratconScenario scenario,\n+            Map<MapLocation, List<Integer>> sortedAvailableForceIDs) {\n+        // the goal of this function is to avoid assigning ground units to air battles\n+        // and ground units/conventional fighters to space battle\n+\n+        List<MapLocation> mapLocations = new ArrayList<>();\n+        mapLocations.add(MapLocation.Space); // can always add ASFs\n+\n+        MapLocation scenarioMapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+\n+        if (scenarioMapLocation == MapLocation.LowAtmosphere) {\n+            mapLocations.add(MapLocation.LowAtmosphere); // can add conventional fighters to ground or low atmo battles\n+        }\n+\n+        if ((scenarioMapLocation == MapLocation.AllGroundTerrain) ||\n+                (scenarioMapLocation == MapLocation.SpecificGroundTerrain)) {\n+            mapLocations.add(MapLocation.AllGroundTerrain); // can only add ground units to ground battles\n+        }\n+\n+        MapLocation selectedLocation = mapLocations.get(Compute.randomInt(mapLocations.size()));\n+        List<Integer> forceIDs = sortedAvailableForceIDs.get(selectedLocation);\n+        int forceIndex = Compute.randomInt(forceIDs.size());\n+        int forceID = forceIDs.get(forceIndex);\n+        forceIDs.remove(forceIndex);\n+\n+        scenario.addPrimaryForce(forceID);\n+    }\n+\n+    /**\n+     * Worker function that \"locks in\" a scenario -\n+     * Adds it to the campaign so it's visible in the briefing room,\n+     * adds it to the track\n+     *\n+     */\n+    public static void commitPrimaryForces(Campaign campaign, AtBContract contract, StratconScenario scenario, StratconTrackState trackState) {\n+        // order of operations is important here, we need a valid scenario ID prior to adding the scenario to the track.\n+        campaign.addScenario(scenario.getBackingScenario(), contract);\n+        scenario.setBackingScenarioID(scenario.getBackingScenario().getId());\n+        trackState.addScenario(scenario);\n+\n+        // set up dates for the scenario if doesn't have them already\n+        if (scenario.getDeploymentDate() == null) {\n+            scenario.setDeploymentDate(campaign.getLocalDate());\n+        }\n+\n+        if (scenario.getActionDate() == null) {\n+            scenario.setActionDate(campaign.getLocalDate());\n+        }\n+\n+        if(scenario.getReturnDate() == null) {\n+            scenario.setReturnDate(campaign.getLocalDate().plusDays(trackState.getDeploymentTime()));\n+        }\n+\n+        // set the # of rerolls based on the actual lance assigned.\n+        int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+        scenario.getBackingScenario().setRerolls(tactics);\n+        // The number of defensive points available to a force entering a scenario is\n+        // 2 x tactics. By default, those points are spent on conventional minefields.\n+        if (commanderLanceHasDefensiveAssignment(scenario.getBackingScenario(), campaign)) {\n+            scenario.setNumDefensivePoints(tactics * 2);\n+            scenario.updateMinefieldCount(Minefield.TYPE_CONVENTIONAL, tactics * 2);\n+        }\n+\n+        for (int forceID : scenario.getPlayerTemplateForceIDs()) {\n+            Force force = campaign.getForce(forceID);\n+            force.clearScenarioIds(campaign, true);\n+            force.setScenarioId(scenario.getBackingScenarioID());\n+        }\n+\n+        scenario.commitPrimaryForces();\n+    }\n+\n+    /**\n+     * Utility method to determine if the current scenario's force commander\n+     * is on defence\n+     */\n+    private static boolean commanderLanceHasDefensiveAssignment(AtBDynamicScenario scenario, Campaign campaign) {\n+        Unit commanderUnit = scenario.getLanceCommander(campaign).getUnit();\n+        Lance lance = campaign.getLances().get(commanderUnit.getForceId());\n+\n+        if ((lance != null) && (lance.getRole() == AtBLanceRole.DEFENCE)) {\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * A hackish worker function that takes the given list of force IDs and\n+     * separates it into three sets;\n+     * one of forces that can be \"primary\" on a ground map\n+     * one of forces that can be \"primary\" on an atmospheric map\n+     * one of forces that can be \"primary\" in a space map\n+     * @param forceIDs List of force IDs to check\n+     * @return Sorted hash map\n+     */\n+    private static Map<MapLocation, List<Integer>> sortForcesByMapType(List<Integer> forceIDs, Campaign campaign) {\n+        Map<MapLocation, List<Integer>> retVal = new HashMap<>();\n+\n+        retVal.put(MapLocation.AllGroundTerrain, new ArrayList<>());\n+        retVal.put(MapLocation.LowAtmosphere, new ArrayList<>());\n+        retVal.put(MapLocation.Space, new ArrayList<>());\n+\n+        for (int forceID : forceIDs) {\n+            switch(campaign.getForce(forceID).getPrimaryUnitType(campaign)) {\n+            case UnitType.BATTLE_ARMOR:\n+            case UnitType.INFANTRY:\n+            case UnitType.MEK:\n+            case UnitType.TANK:\n+            case UnitType.PROTOMEK:\n+            case UnitType.VTOL:\n+                retVal.get(MapLocation.AllGroundTerrain).add(forceID);\n+                break;\n+            case UnitType.AERO:\n+                retVal.get(MapLocation.Space).add(forceID);\n+                // intentional fallthrough here, ASFs can go to atmospheric maps too\n+            case UnitType.CONV_FIGHTER:\n+                retVal.get(MapLocation.LowAtmosphere).add(forceID);\n+                break;\n+            }\n+        }\n+\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * Determine whether the user should be nagged about unresolved scenarios on AtB Stratcon tracks.\n+     * @param campaign Campaign to check.\n+     * @return An informative string containing the reasons the user was nagged.\n+     */\n+    public static String nagUnresolvedContacts(Campaign campaign) {\n+        StringBuilder sb = new StringBuilder();\n+\n+        // check every track attached to an active contract for unresolved scenarios\n+        // to which the player must deploy forces today\n+        for (Contract contract : campaign.getActiveContracts()) {\n+            if(contract instanceof AtBContract) {\n+                for(StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    for(StratconScenario scenario : track.getScenarios().values()) {\n+                        if(scenario.getCurrentState() == ScenarioState.UNRESOLVED &&\n+                                campaign.getLocalDate().equals(scenario.getDeploymentDate())) {\n+                            // \"scenario name, track name\"\n+                            sb.append(String.format(\"%s, %s\\n\", scenario.getName(), track.getDisplayableName()));\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track.\n+     * Also registers it with the track and campaign.\n+     */\n+    private static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords) {\n+        int unitType = campaign.getForce(forceID).getPrimaryUnitType(campaign);\n+        ScenarioTemplate template = StratconScenarioFactory.getRandomScenario(unitType);\n+        // useful for debugging specific scenario types\n+        //ScenarioTemplate template = StratconScenarioFactory.getSpecificScenario(\"Allied Facility.xml\");\n+\n+        return generateScenario(campaign, contract, track, forceID, coords, template);\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track,\n+     * using the given template. Also registers it with the track and campaign.\n+     */\n+    static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords, ScenarioTemplate template) {\n+        StratconScenario scenario = new StratconScenario();\n+        scenario.setBackingScenario(AtBDynamicScenarioFactory.initializeScenarioFromTemplate(template, contract, campaign));\n+        scenario.setCoords(coords);\n+        \n+        // by default, certain conditions may make this bigger\n+        scenario.setRequiredPlayerLances(1);\n+\n+        // do an appropriate allied force if the contract calls for it\n+        // do any attached or integrated units\n+        setAlliedForceModifier(scenario, contract);\n+        setAttachedUnitsModifier(scenario, contract);\n+        applyFacilityModifiers(scenario, track, coords);\n+        applyGlobalModifiers(scenario, contract.getStratconCampaignState());\n+\n+        if ((contract.getCommandRights() == AtBContract.COM_HOUSE) ||\n+                (contract.getCommandRights() == AtBContract.COM_INTEGRATED)) {\n+            scenario.setRequiredScenario(true);\n+        }\n+\n+        AtBDynamicScenarioFactory.setScenarioModifiers(scenario.getBackingScenario());\n+        scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+        setScenarioDates(track, campaign, scenario);\n+\n+        // register the scenario with the campaign and the track it's generated on\n+        if (forceID > Force.FORCE_NONE) {\n+            scenario.addPrimaryForce(forceID);\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * Apply global scenario modifiers from campaign state to given scenario.\n+     */\n+    private static void applyGlobalModifiers(StratconScenario scenario, StratconCampaignState campaignState) {\n+        for (String modifierName : campaignState.getGlobalScenarioModifiers()) {\n+            AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierName);\n+\n+            if (modifier == null) {\n+                MekHQ.getLogger().error(String.format(\"Modifier %s not found; ignoring\", modifierName));\n+                continue;\n+            }\n+\n+            scenario.getBackingScenario().addScenarioModifier(modifier);\n+        }\n+    }\n+\n+    /**\n+     * Applies scenario modifiers from the current track to the given scenario.\n+     * @param scenario\n+     * @param track\n+     */\n+    private static void applyFacilityModifiers(StratconScenario scenario, StratconTrackState track, StratconCoords coords) {\n+        // loop through all the facilities on the track\n+        // if a facility has been revealed, then it has a 100% chance to apply its effect\n+        // if a facility has not been revealed, then it has a x% chance to apply its effect\n+        // if a facility is on the the scenario coordinates the it applies the local effects\n+        for (StratconCoords facilityCoords : track.getFacilities().keySet()) {\n+            boolean scenarioAtFacility = facilityCoords.equals(coords);\n+            StratconFacility facility = track.getFacilities().get(facilityCoords);\n+            List<String> modifierIDs = new ArrayList<>();\n+\n+            if (scenarioAtFacility) {\n+                modifierIDs = facility.getLocalModifiers();\n+            } else if (facility.isVisible() || (Compute.randomInt(100) <= facility.getAggroRating())) {\n+                modifierIDs = facility.getSharedModifiers();\n+            }\n+\n+            for (String modifierID : modifierIDs) {\n+                AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierID);\n+                if(modifier == null) {\n+                    MekHQ.getLogger().error(String.format(\"Modifier %s not found for facility %s\", modifierID, facility.getFormattedDisplayableName()));\n+                    continue;\n+                }\n+\n+                scenario.getBackingScenario().addScenarioModifier(modifier);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set up the appropriate primary allied force modifier, if any\n+     * @param contract The scenario's contract.\n+     */\n+    private static void setAlliedForceModifier(StratconScenario scenario, AtBContract contract) {\n+        int alliedUnitOdds = 0;\n+\n+        // first, we determine the odds of having an allied unit present\n+        // TODO: move this override out to the contract definition\n+        if (contract.getMissionType() == AtBContract.MT_RELIEFDUTY) {\n+            alliedUnitOdds = 50;\n+        } else {\n+            switch(contract.getCommandRights()) {\n+            case AtBContract.COM_INTEGRATED:\n+                alliedUnitOdds = 50;\n+                break;\n+            case AtBContract.COM_HOUSE:\n+                alliedUnitOdds = 30;\n+                break;\n+            case AtBContract.COM_LIAISON:\n+                alliedUnitOdds = 10;\n+                break;\n+            }", "originalCommit": "0244602bac43aacfd804a92250447a67a4fbd75a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNDUwNjQ2OA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r604506468", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (airBattle) {\n          \n          \n            \n                                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_INTEGRATED_UNITS_AIR));\n          \n          \n            \n                            } else {\n          \n          \n            \n                                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_INTEGRATED_UNITS_GROUND));\n          \n          \n            \n                            }\n          \n          \n            \n                            backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(airBattle\n          \n          \n            \n                                ? AtBScenarioModifier.SCENARIO_MODIFIER_INTEGRATED_UNITS_AIR\n          \n          \n            \n                                : AtBScenarioModifier.SCENARIO_MODIFIER_INTEGRATED_UNITS_GROUND));\n          \n      \n    \n    \n  \n\nWould be far easier to read, and what @sixlettervariables was suggesting in text", "author": "Windchild292", "createdAt": "2021-03-31T00:00:12Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1291 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.UUID;\n+\n+import megamek.common.Compute;\n+import megamek.common.Minefield;\n+import megamek.common.UnitType;\n+import megamek.common.annotations.Nullable;\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.Utilities;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.ResolveScenarioTracker;\n+import mekhq.campaign.againstTheBot.enums.AtBLanceRole;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.event.StratconDeploymentEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.force.Lance;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier.EventTiming;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.unit.Unit;\n+\n+/**\n+ * This class contains \"rules\" logic for the AtB-Stratcon state\n+ * @author NickAragua\n+ */\n+public class StratconRulesManager {\n+    /**\n+     * What makes a particular lance eligible to be reinforcements for a scenario\n+     * @author NickAragua\n+     */\n+    public enum ReinforcementEligibilityType {\n+        /**\n+         * Nothing\n+         */\n+        None,\n+\n+        /**\n+         * Lance is already deployed to the track\n+         */\n+        ChainedScenario,\n+\n+        /**\n+         * We pay a support point or convert a victory point to a support point\n+         */\n+        SupportPoint,\n+\n+        /**\n+         * The lance's deployment orders are \"Fight\"\n+         */\n+        FightLance\n+    }\n+\n+    /**\n+     * This function potentially generates non-player-initiated scenarios for the given track.\n+     */\n+    public static void generateScenariosForTrack(Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // maps scenarios to force IDs\n+        List<StratconScenario> generatedScenarios = new ArrayList<>();\n+        boolean autoAssignLances = contract.getCommandRights() == AtBContract.COM_INTEGRATED;\n+\n+        // get this list just so we have it available\n+        List<Integer> availableForceIDs = getAvailableForceIDs(campaign);\n+        Map<MapLocation, List<Integer>> sortedAvailableForceIDs = sortForcesByMapType(availableForceIDs, campaign);\n+\n+        // make X rolls, where X is the number of required lances for the track\n+        // that's the chance to spawn a scenario.\n+        // if a scenario occurs, then we pick a random non-deployed lance and use it to drive the opfor generation later\n+        // once we've determined that scenarios occur, we loop through the ones that we generated\n+        // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all\n+        for (int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            // if we haven't already used all the player forces and are required to randomly generate a scenario\n+            if ((availableForceIDs.size() > 0) &&\n+                    (Compute.randomInt(100) <= track.getScenarioOdds())) {\n+                // pick random coordinates and force to drive the scenario\n+                int x = Compute.randomInt(track.getWidth());\n+                int y = Compute.randomInt(track.getHeight());\n+\n+                StratconCoords scenarioCoords = new StratconCoords(x, y);\n+\n+                // if forces are already assigned to these coordinates, use those instead\n+                // of randomly-selected ones\n+                if (track.getAssignedCoordForces().containsKey(scenarioCoords)) {\n+                    StratconScenario scenario = generateScenarioForExistingForces(scenarioCoords,\n+                            track.getAssignedCoordForces().get(scenarioCoords), \n+                            contract, campaign, track);\n+                    generatedScenarios.add(scenario);\n+                    continue;\n+                }\n+                \n+                // otherwise, pick a random force from the avail\n+                int randomForceIndex = Compute.randomInt(availableForceIDs.size());\n+                int randomForceID = availableForceIDs.get(randomForceIndex);\n+                \n+                // remove the force from the available lists so we don't designate it as primary twice\n+                availableForceIDs.remove(randomForceIndex);\n+\n+                // we want to remove the actual int with the value, not the value at the index\n+                sortedAvailableForceIDs.get(MapLocation.AllGroundTerrain).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.LowAtmosphere).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.Space).remove((Integer) randomForceID);\n+\n+                // two scenarios on the same coordinates wind up increasing in size\n+                if (track.getScenarios().containsKey(scenarioCoords)) {\n+                    track.getScenarios().get(scenarioCoords).incrementRequiredPlayerLances();\n+                    assignAppropriateExtraForceToScenario(track.getScenarios().get(scenarioCoords), sortedAvailableForceIDs);\n+                    continue;\n+                }\n+\n+                StratconScenario scenario = setupScenario(scenarioCoords, randomForceID, campaign, contract, track);\n+                generatedScenarios.add(scenario);\n+\n+                // if we're auto-assigning lances, deploy the force to the track as well\n+                if (autoAssignLances) {\n+                    processForceDeployment(scenarioCoords, randomForceID, campaign, track, false);\n+                }\n+            }\n+        }\n+\n+        // if under liaison command, pick a random scenario from the ones generated\n+        // to set as required and attach liaison\n+        if (contract.getCommandRights() == AtBContract.COM_LIAISON) {\n+        \tStratconScenario randomScenario = Utilities.getRandomItem(generatedScenarios);\n+        \trandomScenario.setRequiredScenario(true);\n+            setAttachedUnitsModifier(randomScenario, contract);\n+        }\n+\n+        // now, we loop through all the scenarios we set up\n+        // and generate the opfors / events / etc\n+        // if not auto-assigning lances, we then back out the lance assignments.\n+        for (StratconScenario scenario : generatedScenarios) {\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+\n+            if(!autoAssignLances && !scenario.ignoreForceAutoAssignment()) {\n+                for(int forceID : scenario.getPlayerTemplateForceIDs()) {\n+                    scenario.getBackingScenario().removeForce(forceID);\n+                }\n+\n+                scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                track.addScenario(scenario);\n+            } else {\n+                commitPrimaryForces(campaign, contract, scenario, track);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Given a set of force IDs and coordinates, generate a scenario\n+     * Useful for when we want to generate scenarios \n+     * for forces already deployed to a track\n+     */\n+    public static StratconScenario generateScenarioForExistingForces(StratconCoords scenarioCoords, \n+            Set<Integer> forceIDs, AtBContract contract, Campaign campaign, StratconTrackState track) {\n+        boolean firstForce = true;\n+        StratconScenario scenario = null;\n+        \n+        for (int forceID : forceIDs) {\n+            if (firstForce) {\n+                scenario = setupScenario(scenarioCoords, forceID, campaign, contract, track);\n+                firstForce = false;\n+            } else {\n+                scenario.incrementRequiredPlayerLances();\n+                scenario.addPrimaryForce(forceID);\n+            }\n+        }\n+        \n+        scenario.setIgnoreForceAutoAssignment(true);\n+        return scenario;\n+    }\n+\n+    /**\n+     * Deploys a force to the given coordinates on the given track as a result of explicit player action.\n+     */\n+    public static void deployForceToCoords(StratconCoords coords, int forceID, \n+            Campaign campaign, AtBContract contract, StratconTrackState track, boolean sticky) {\n+        // the following things should happen:\n+        // 1. call to \"process force deployment\", which reveals fog of war in or around the coords, depending on force role\n+        // 2. if coords are a hostile facility, we get a facility mission\n+        // 3. if coords are empty, we *may* get a mission\n+\n+        processForceDeployment(coords, forceID, campaign, track, sticky);\n+\n+        // don't create a scenario on top of allied facilities\n+        StratconFacility facility = track.getFacility(coords);\n+        boolean isNonAlliedFacility = (facility != null) && (facility.getOwner() != ForceAlignment.Allied);\n+        boolean spawnScenario = (facility == null) && (Compute.randomInt(100) <= track.getScenarioOdds());\n+\n+        if (isNonAlliedFacility || spawnScenario) {\n+            StratconScenario scenario = setupScenario(coords, forceID, campaign, contract, track);\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            commitPrimaryForces(campaign, contract, scenario, track);\n+        }\n+    }\n+\n+    /**\n+     * Logic to set up a scenario\n+     */\n+    private static StratconScenario setupScenario(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        StratconScenario scenario = null;\n+\n+        if (track.getFacilities().containsKey(coords)) {\n+            StratconFacility facility = track.getFacility(coords);\n+            boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+            ScenarioTemplate template = StratconScenarioFactory.getFacilityScenario(alliedFacility);\n+            scenario = generateScenario(campaign, contract, track, forceID, coords, template);\n+            setupFacilityScenario(scenario, facility);\n+        } else {\n+            scenario = generateScenario(campaign, contract, track, forceID, coords);\n+\n+            // we may generate a facility scenario randomly - if so, do the facility-related stuff\n+            // and add a new facility to the track\n+            if (scenario.getBackingScenario().getTemplate().isFacilityScenario()) {\n+                StratconFacility facility = scenario.getBackingScenario().getTemplate().isHostileFacility() ?\n+                        StratconFacilityFactory.getRandomHostileFacility() : StratconFacilityFactory.getRandomAlliedFacility();\n+                facility.setVisible(true);\n+                track.addFacility(coords, facility);\n+                setupFacilityScenario(scenario, facility);\n+            }\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * carries out tasks relevant to facility scenarios\n+     */\n+    private static void setupFacilityScenario(StratconScenario scenario, StratconFacility facility) {\n+        // this includes:\n+        // for hostile facilities\n+        // - add a destroy objective (always the option to level the facility)\n+        // - add a capture objective (always the option to capture the facility)\n+        // - if so indicated by parameter, roll a random hostile facility objective and add it if not capture/destroy\n+        // for allied facilities\n+        // - add a defend objective (always the option to defend the facility)\n+        // - if so indicated by parameter, roll a random allied facility objective and add it if not defend\n+        AtBScenarioModifier objectiveModifier = null;\n+        boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+\n+        if (alliedFacility) {\n+            objectiveModifier = AtBScenarioModifier.getRandomAlliedFacilityModifier();\n+        } else {\n+            objectiveModifier = AtBScenarioModifier.getRandomHostileFacilityModifier();\n+        }\n+\n+        if (objectiveModifier != null) {\n+            scenario.getBackingScenario().addScenarioModifier(objectiveModifier);\n+            scenario.getBackingScenario().setName(String.format(\"%s - %s - %s\",\n+                    facility.getFacilityType(), alliedFacility ? \"Allied\" : \"Hostile\", objectiveModifier.getModifierName()));\n+        }\n+\n+        // add the \"fixed\" hostile facility modifiers after the primary ones\n+        if (!alliedFacility) {\n+            for(AtBScenarioModifier modifier : AtBScenarioModifier.getRequiredHostileFacilityModifiers()) {\n+                if(!scenario.getBackingScenario().alreadyHasModifier(modifier)) {\n+                    scenario.getBackingScenario().addScenarioModifier(modifier);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void processFacilityEffects(StratconTrackState track) {\n+        // TODO: these are \"weekly\"? effects that a stratcon facility has on the campaign/track state\n+        // currrently, that's\n+        // supply depot - allied - +1 sp\n+        // supply depot - hostile - +5% BV budget to all scenarios on track (shared modifier, so should be implemented there)\n+        // data center - allied - +1% star league cache contract (don't implement yet, but...)\n+        // data center - hostile - +5% scenario odds in track\n+        // industrial center - allied - all scenarios here have THIS IS COMING OUT OF YOUR PAYCHECK modifier\n+        // orbital defense - allied - sets 'no hostile aircraft' flag for track\n+        // orbital defense - hostile - sets 'no allied aircraft' flag for track\n+        // early warning system - allied - sets 'intercept allied base attacks' flag for track\n+        // early warning system - hostile - sets 'intercept hostile base attacks' flag for track\n+    }\n+\n+    /**\n+     * Process the deployment of a force to the given coordinates on the given track.\n+     */\n+    public static void processForceDeployment(StratconCoords coords, int forceID, \n+            Campaign campaign, StratconTrackState track, boolean sticky) {\n+        track.getRevealedCoords().add(coords);\n+        StratconFacility facility = track.getFacility(coords);\n+        if (facility != null) {\n+            facility.setVisible(true);\n+        }\n+\n+        if (campaign.getLances().get(forceID).getRole() == AtBLanceRole.SCOUTING) {\n+            for(int direction = 0; direction < 6; direction++) {\n+                StratconCoords checkCoords = coords.translate(direction);\n+\n+                facility = track.getFacility(checkCoords);\n+                if(facility != null) {\n+                    facility.setVisible(true);\n+                }\n+\n+                track.getRevealedCoords().add(coords.translate(direction));\n+            }\n+        }\n+\n+        // the force may be located in other places on the track - clear it out\n+        track.unassignForce(forceID);\n+        track.assignForce(forceID, coords, campaign.getLocalDate(), sticky);\n+        MekHQ.triggerEvent(new StratconDeploymentEvent(campaign.getForce(forceID)));\n+    }\n+\n+    /**\n+     * Worker function that processes the effects of deploying a reinforcement force to a scenario\n+     */\n+    public static boolean processReinforcementDeployment(ReinforcementEligibilityType reinforcementType,\n+            StratconCampaignState campaignState, StratconScenario scenario, Campaign campaign) {\n+        // if the force is already deployed to the track, we're done\n+        // if the force is a fight lance or we're using a support point\n+        // if there is an SP to burn, burn it and we're done\n+        // if there is a VP to burn, burn it and we're done\n+        // now, roll 2d6 + lance commander tactics\n+        // 9+ = deploy\n+        // 6+ = deploy, apply negative modifier to scenario\n+        // 2+ = fail to deploy, apply negative modifier to scenario; if fight lance, treat as 6+\n+\n+        if ((reinforcementType == ReinforcementEligibilityType.FightLance) ||\n+                (reinforcementType == ReinforcementEligibilityType.SupportPoint)) {\n+\n+            if (campaignState.getSupportPoints() > 0) {\n+                campaignState.useSupportPoint();\n+                return true;\n+            } else if (campaignState.getVictoryPoints() > 0) {\n+                campaignState.updateVictoryPoints(-1);\n+                return true;\n+            }\n+\n+            int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+            int roll = Compute.d6(2);\n+            int result = roll + tactics;\n+\n+            StringBuilder reportStatus = new StringBuilder();\n+            reportStatus.append(String.format(\"Attempting to reinforce scenario %s without SP/VP, roll 2d6 + %d: %d\",\n+                    scenario.getName(), tactics, result));\n+\n+            // fail to reinforce\n+            if ((result < 6) && (reinforcementType != ReinforcementEligibilityType.FightLance)) {\n+                reportStatus.append(\" - reinforcement attempt failed.\");\n+                campaign.addReport(reportStatus.toString());\n+                return false;\n+            // succeed but get an extra negative event added to the scenario\n+            } else if (result < 9) {\n+                MapLocation mapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+                AtBScenarioModifier scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+\n+                // keep rolling until we get an applicable one\n+                // TODO: have the AtBScenarioModifier sort these out instead for performance?\n+                while (scenarioModifier.getEventTiming() != EventTiming.PostForceGeneration) {\n+                    scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+                }\n+\n+                scenarioModifier.processModifier(scenario.getBackingScenario(), campaign, EventTiming.PostForceGeneration);\n+\n+                reportStatus.append(String.format(\" - reinforcement attempt succeeded; extra negative modifier (%s) applied to scenario.\",\n+                        scenarioModifier.getModifierName()));\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            // succeed without reservation\n+            } else {\n+                reportStatus.append(\" - reinforcement attempt succeeded;\");\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            }\n+        } else if (reinforcementType == ReinforcementEligibilityType.None) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Assigns a force to the scenario such that the majority of the force can be deployed\n+     */\n+    private static void assignAppropriateExtraForceToScenario(StratconScenario scenario,\n+            Map<MapLocation, List<Integer>> sortedAvailableForceIDs) {\n+        // the goal of this function is to avoid assigning ground units to air battles\n+        // and ground units/conventional fighters to space battle\n+\n+        List<MapLocation> mapLocations = new ArrayList<>();\n+        mapLocations.add(MapLocation.Space); // can always add ASFs\n+\n+        MapLocation scenarioMapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+\n+        if (scenarioMapLocation == MapLocation.LowAtmosphere) {\n+            mapLocations.add(MapLocation.LowAtmosphere); // can add conventional fighters to ground or low atmo battles\n+        }\n+\n+        if ((scenarioMapLocation == MapLocation.AllGroundTerrain) ||\n+                (scenarioMapLocation == MapLocation.SpecificGroundTerrain)) {\n+            mapLocations.add(MapLocation.AllGroundTerrain); // can only add ground units to ground battles\n+        }\n+\n+        MapLocation selectedLocation = mapLocations.get(Compute.randomInt(mapLocations.size()));\n+        List<Integer> forceIDs = sortedAvailableForceIDs.get(selectedLocation);\n+        int forceIndex = Compute.randomInt(forceIDs.size());\n+        int forceID = forceIDs.get(forceIndex);\n+        forceIDs.remove(forceIndex);\n+\n+        scenario.addPrimaryForce(forceID);\n+    }\n+\n+    /**\n+     * Worker function that \"locks in\" a scenario -\n+     * Adds it to the campaign so it's visible in the briefing room,\n+     * adds it to the track\n+     *\n+     */\n+    public static void commitPrimaryForces(Campaign campaign, AtBContract contract, StratconScenario scenario, StratconTrackState trackState) {\n+        // order of operations is important here, we need a valid scenario ID prior to adding the scenario to the track.\n+        campaign.addScenario(scenario.getBackingScenario(), contract);\n+        scenario.setBackingScenarioID(scenario.getBackingScenario().getId());\n+        trackState.addScenario(scenario);\n+\n+        // set up dates for the scenario if doesn't have them already\n+        if (scenario.getDeploymentDate() == null) {\n+            scenario.setDeploymentDate(campaign.getLocalDate());\n+        }\n+\n+        if (scenario.getActionDate() == null) {\n+            scenario.setActionDate(campaign.getLocalDate());\n+        }\n+\n+        if(scenario.getReturnDate() == null) {\n+            scenario.setReturnDate(campaign.getLocalDate().plusDays(trackState.getDeploymentTime()));\n+        }\n+\n+        // set the # of rerolls based on the actual lance assigned.\n+        int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+        scenario.getBackingScenario().setRerolls(tactics);\n+        // The number of defensive points available to a force entering a scenario is\n+        // 2 x tactics. By default, those points are spent on conventional minefields.\n+        if (commanderLanceHasDefensiveAssignment(scenario.getBackingScenario(), campaign)) {\n+            scenario.setNumDefensivePoints(tactics * 2);\n+            scenario.updateMinefieldCount(Minefield.TYPE_CONVENTIONAL, tactics * 2);\n+        }\n+\n+        for (int forceID : scenario.getPlayerTemplateForceIDs()) {\n+            Force force = campaign.getForce(forceID);\n+            force.clearScenarioIds(campaign, true);\n+            force.setScenarioId(scenario.getBackingScenarioID());\n+        }\n+\n+        scenario.commitPrimaryForces();\n+    }\n+\n+    /**\n+     * Utility method to determine if the current scenario's force commander\n+     * is on defence\n+     */\n+    private static boolean commanderLanceHasDefensiveAssignment(AtBDynamicScenario scenario, Campaign campaign) {\n+        Unit commanderUnit = scenario.getLanceCommander(campaign).getUnit();\n+        Lance lance = campaign.getLances().get(commanderUnit.getForceId());\n+\n+        if ((lance != null) && (lance.getRole() == AtBLanceRole.DEFENCE)) {\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * A hackish worker function that takes the given list of force IDs and\n+     * separates it into three sets;\n+     * one of forces that can be \"primary\" on a ground map\n+     * one of forces that can be \"primary\" on an atmospheric map\n+     * one of forces that can be \"primary\" in a space map\n+     * @param forceIDs List of force IDs to check\n+     * @return Sorted hash map\n+     */\n+    private static Map<MapLocation, List<Integer>> sortForcesByMapType(List<Integer> forceIDs, Campaign campaign) {\n+        Map<MapLocation, List<Integer>> retVal = new HashMap<>();\n+\n+        retVal.put(MapLocation.AllGroundTerrain, new ArrayList<>());\n+        retVal.put(MapLocation.LowAtmosphere, new ArrayList<>());\n+        retVal.put(MapLocation.Space, new ArrayList<>());\n+\n+        for (int forceID : forceIDs) {\n+            switch(campaign.getForce(forceID).getPrimaryUnitType(campaign)) {\n+            case UnitType.BATTLE_ARMOR:\n+            case UnitType.INFANTRY:\n+            case UnitType.MEK:\n+            case UnitType.TANK:\n+            case UnitType.PROTOMEK:\n+            case UnitType.VTOL:\n+                retVal.get(MapLocation.AllGroundTerrain).add(forceID);\n+                break;\n+            case UnitType.AERO:\n+                retVal.get(MapLocation.Space).add(forceID);\n+                // intentional fallthrough here, ASFs can go to atmospheric maps too\n+            case UnitType.CONV_FIGHTER:\n+                retVal.get(MapLocation.LowAtmosphere).add(forceID);\n+                break;\n+            }\n+        }\n+\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * Determine whether the user should be nagged about unresolved scenarios on AtB Stratcon tracks.\n+     * @param campaign Campaign to check.\n+     * @return An informative string containing the reasons the user was nagged.\n+     */\n+    public static String nagUnresolvedContacts(Campaign campaign) {\n+        StringBuilder sb = new StringBuilder();\n+\n+        // check every track attached to an active contract for unresolved scenarios\n+        // to which the player must deploy forces today\n+        for (Contract contract : campaign.getActiveContracts()) {\n+            if(contract instanceof AtBContract) {\n+                for(StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    for(StratconScenario scenario : track.getScenarios().values()) {\n+                        if(scenario.getCurrentState() == ScenarioState.UNRESOLVED &&\n+                                campaign.getLocalDate().equals(scenario.getDeploymentDate())) {\n+                            // \"scenario name, track name\"\n+                            sb.append(String.format(\"%s, %s\\n\", scenario.getName(), track.getDisplayableName()));\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track.\n+     * Also registers it with the track and campaign.\n+     */\n+    private static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords) {\n+        int unitType = campaign.getForce(forceID).getPrimaryUnitType(campaign);\n+        ScenarioTemplate template = StratconScenarioFactory.getRandomScenario(unitType);\n+        // useful for debugging specific scenario types\n+        //ScenarioTemplate template = StratconScenarioFactory.getSpecificScenario(\"Allied Facility.xml\");\n+\n+        return generateScenario(campaign, contract, track, forceID, coords, template);\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track,\n+     * using the given template. Also registers it with the track and campaign.\n+     */\n+    static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords, ScenarioTemplate template) {\n+        StratconScenario scenario = new StratconScenario();\n+        scenario.setBackingScenario(AtBDynamicScenarioFactory.initializeScenarioFromTemplate(template, contract, campaign));\n+        scenario.setCoords(coords);\n+        \n+        // by default, certain conditions may make this bigger\n+        scenario.setRequiredPlayerLances(1);\n+\n+        // do an appropriate allied force if the contract calls for it\n+        // do any attached or integrated units\n+        setAlliedForceModifier(scenario, contract);\n+        setAttachedUnitsModifier(scenario, contract);\n+        applyFacilityModifiers(scenario, track, coords);\n+        applyGlobalModifiers(scenario, contract.getStratconCampaignState());\n+\n+        if ((contract.getCommandRights() == AtBContract.COM_HOUSE) ||\n+                (contract.getCommandRights() == AtBContract.COM_INTEGRATED)) {\n+            scenario.setRequiredScenario(true);\n+        }\n+\n+        AtBDynamicScenarioFactory.setScenarioModifiers(scenario.getBackingScenario());\n+        scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+        setScenarioDates(track, campaign, scenario);\n+\n+        // register the scenario with the campaign and the track it's generated on\n+        if (forceID > Force.FORCE_NONE) {\n+            scenario.addPrimaryForce(forceID);\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * Apply global scenario modifiers from campaign state to given scenario.\n+     */\n+    private static void applyGlobalModifiers(StratconScenario scenario, StratconCampaignState campaignState) {\n+        for (String modifierName : campaignState.getGlobalScenarioModifiers()) {\n+            AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierName);\n+\n+            if (modifier == null) {\n+                MekHQ.getLogger().error(String.format(\"Modifier %s not found; ignoring\", modifierName));\n+                continue;\n+            }\n+\n+            scenario.getBackingScenario().addScenarioModifier(modifier);\n+        }\n+    }\n+\n+    /**\n+     * Applies scenario modifiers from the current track to the given scenario.\n+     * @param scenario\n+     * @param track\n+     */\n+    private static void applyFacilityModifiers(StratconScenario scenario, StratconTrackState track, StratconCoords coords) {\n+        // loop through all the facilities on the track\n+        // if a facility has been revealed, then it has a 100% chance to apply its effect\n+        // if a facility has not been revealed, then it has a x% chance to apply its effect\n+        // if a facility is on the the scenario coordinates the it applies the local effects\n+        for (StratconCoords facilityCoords : track.getFacilities().keySet()) {\n+            boolean scenarioAtFacility = facilityCoords.equals(coords);\n+            StratconFacility facility = track.getFacilities().get(facilityCoords);\n+            List<String> modifierIDs = new ArrayList<>();\n+\n+            if (scenarioAtFacility) {\n+                modifierIDs = facility.getLocalModifiers();\n+            } else if (facility.isVisible() || (Compute.randomInt(100) <= facility.getAggroRating())) {\n+                modifierIDs = facility.getSharedModifiers();\n+            }\n+\n+            for (String modifierID : modifierIDs) {\n+                AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierID);\n+                if(modifier == null) {\n+                    MekHQ.getLogger().error(String.format(\"Modifier %s not found for facility %s\", modifierID, facility.getFormattedDisplayableName()));\n+                    continue;\n+                }\n+\n+                scenario.getBackingScenario().addScenarioModifier(modifier);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set up the appropriate primary allied force modifier, if any\n+     * @param contract The scenario's contract.\n+     */\n+    private static void setAlliedForceModifier(StratconScenario scenario, AtBContract contract) {\n+        int alliedUnitOdds = 0;\n+\n+        // first, we determine the odds of having an allied unit present\n+        // TODO: move this override out to the contract definition\n+        if (contract.getMissionType() == AtBContract.MT_RELIEFDUTY) {\n+            alliedUnitOdds = 50;\n+        } else {\n+            switch(contract.getCommandRights()) {\n+            case AtBContract.COM_INTEGRATED:\n+                alliedUnitOdds = 50;\n+                break;\n+            case AtBContract.COM_HOUSE:\n+                alliedUnitOdds = 30;\n+                break;\n+            case AtBContract.COM_LIAISON:\n+                alliedUnitOdds = 10;\n+                break;\n+            }\n+        }\n+\n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+\n+        // if an allied unit is present, then we want to make sure that it's ground units\n+        // for ground battles\n+        if (Compute.randomInt(100) <= alliedUnitOdds) {\n+            if((backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+               (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space)) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_ALLIED_AIR_UNITS));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_ALLIED_GROUND_UNITS));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set the 'attached' units modifier for the current scenario (integrated, house, liaison),\n+     * and make sure we're not deploying ground units to an air scenario\n+     * @param contract The scenario's contract\n+     */\n+    public static void setAttachedUnitsModifier(StratconScenario scenario, AtBContract contract) {\n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+        boolean airBattle = (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+                (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space);\n+\n+        // if we're on cadre duty, we're getting three trainees, period\n+        if (contract.getMissionType() == AtBContract.MT_CADREDUTY) {\n+            if (airBattle) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_TRAINEES_AIR));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_TRAINEES_GROUND));\n+            }\n+            return;\n+        }\n+\n+        // if we're under non-independent command rights, a supervisor may come along\n+        switch (contract.getCommandRights()) {\n+            case AtBContract.COM_INTEGRATED:\n+                if (airBattle) {\n+                    backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_INTEGRATED_UNITS_AIR));\n+                } else {\n+                    backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_INTEGRATED_UNITS_GROUND));\n+                }", "originalCommit": "0244602bac43aacfd804a92250447a67a4fbd75a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNDUwNjYxNQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r604506615", "bodyText": "Fix", "author": "Windchild292", "createdAt": "2021-03-31T00:00:38Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1291 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.UUID;\n+\n+import megamek.common.Compute;\n+import megamek.common.Minefield;\n+import megamek.common.UnitType;\n+import megamek.common.annotations.Nullable;\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.Utilities;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.ResolveScenarioTracker;\n+import mekhq.campaign.againstTheBot.enums.AtBLanceRole;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.event.StratconDeploymentEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.force.Lance;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier.EventTiming;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.unit.Unit;\n+\n+/**\n+ * This class contains \"rules\" logic for the AtB-Stratcon state\n+ * @author NickAragua\n+ */\n+public class StratconRulesManager {\n+    /**\n+     * What makes a particular lance eligible to be reinforcements for a scenario\n+     * @author NickAragua\n+     */\n+    public enum ReinforcementEligibilityType {\n+        /**\n+         * Nothing\n+         */\n+        None,\n+\n+        /**\n+         * Lance is already deployed to the track\n+         */\n+        ChainedScenario,\n+\n+        /**\n+         * We pay a support point or convert a victory point to a support point\n+         */\n+        SupportPoint,\n+\n+        /**\n+         * The lance's deployment orders are \"Fight\"\n+         */\n+        FightLance\n+    }\n+\n+    /**\n+     * This function potentially generates non-player-initiated scenarios for the given track.\n+     */\n+    public static void generateScenariosForTrack(Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // maps scenarios to force IDs\n+        List<StratconScenario> generatedScenarios = new ArrayList<>();\n+        boolean autoAssignLances = contract.getCommandRights() == AtBContract.COM_INTEGRATED;\n+\n+        // get this list just so we have it available\n+        List<Integer> availableForceIDs = getAvailableForceIDs(campaign);\n+        Map<MapLocation, List<Integer>> sortedAvailableForceIDs = sortForcesByMapType(availableForceIDs, campaign);\n+\n+        // make X rolls, where X is the number of required lances for the track\n+        // that's the chance to spawn a scenario.\n+        // if a scenario occurs, then we pick a random non-deployed lance and use it to drive the opfor generation later\n+        // once we've determined that scenarios occur, we loop through the ones that we generated\n+        // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all\n+        for (int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            // if we haven't already used all the player forces and are required to randomly generate a scenario\n+            if ((availableForceIDs.size() > 0) &&\n+                    (Compute.randomInt(100) <= track.getScenarioOdds())) {\n+                // pick random coordinates and force to drive the scenario\n+                int x = Compute.randomInt(track.getWidth());\n+                int y = Compute.randomInt(track.getHeight());\n+\n+                StratconCoords scenarioCoords = new StratconCoords(x, y);\n+\n+                // if forces are already assigned to these coordinates, use those instead\n+                // of randomly-selected ones\n+                if (track.getAssignedCoordForces().containsKey(scenarioCoords)) {\n+                    StratconScenario scenario = generateScenarioForExistingForces(scenarioCoords,\n+                            track.getAssignedCoordForces().get(scenarioCoords), \n+                            contract, campaign, track);\n+                    generatedScenarios.add(scenario);\n+                    continue;\n+                }\n+                \n+                // otherwise, pick a random force from the avail\n+                int randomForceIndex = Compute.randomInt(availableForceIDs.size());\n+                int randomForceID = availableForceIDs.get(randomForceIndex);\n+                \n+                // remove the force from the available lists so we don't designate it as primary twice\n+                availableForceIDs.remove(randomForceIndex);\n+\n+                // we want to remove the actual int with the value, not the value at the index\n+                sortedAvailableForceIDs.get(MapLocation.AllGroundTerrain).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.LowAtmosphere).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.Space).remove((Integer) randomForceID);\n+\n+                // two scenarios on the same coordinates wind up increasing in size\n+                if (track.getScenarios().containsKey(scenarioCoords)) {\n+                    track.getScenarios().get(scenarioCoords).incrementRequiredPlayerLances();\n+                    assignAppropriateExtraForceToScenario(track.getScenarios().get(scenarioCoords), sortedAvailableForceIDs);\n+                    continue;\n+                }\n+\n+                StratconScenario scenario = setupScenario(scenarioCoords, randomForceID, campaign, contract, track);\n+                generatedScenarios.add(scenario);\n+\n+                // if we're auto-assigning lances, deploy the force to the track as well\n+                if (autoAssignLances) {\n+                    processForceDeployment(scenarioCoords, randomForceID, campaign, track, false);\n+                }\n+            }\n+        }\n+\n+        // if under liaison command, pick a random scenario from the ones generated\n+        // to set as required and attach liaison\n+        if (contract.getCommandRights() == AtBContract.COM_LIAISON) {\n+        \tStratconScenario randomScenario = Utilities.getRandomItem(generatedScenarios);\n+        \trandomScenario.setRequiredScenario(true);\n+            setAttachedUnitsModifier(randomScenario, contract);\n+        }\n+\n+        // now, we loop through all the scenarios we set up\n+        // and generate the opfors / events / etc\n+        // if not auto-assigning lances, we then back out the lance assignments.\n+        for (StratconScenario scenario : generatedScenarios) {\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+\n+            if(!autoAssignLances && !scenario.ignoreForceAutoAssignment()) {\n+                for(int forceID : scenario.getPlayerTemplateForceIDs()) {\n+                    scenario.getBackingScenario().removeForce(forceID);\n+                }\n+\n+                scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                track.addScenario(scenario);\n+            } else {\n+                commitPrimaryForces(campaign, contract, scenario, track);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Given a set of force IDs and coordinates, generate a scenario\n+     * Useful for when we want to generate scenarios \n+     * for forces already deployed to a track\n+     */\n+    public static StratconScenario generateScenarioForExistingForces(StratconCoords scenarioCoords, \n+            Set<Integer> forceIDs, AtBContract contract, Campaign campaign, StratconTrackState track) {\n+        boolean firstForce = true;\n+        StratconScenario scenario = null;\n+        \n+        for (int forceID : forceIDs) {\n+            if (firstForce) {\n+                scenario = setupScenario(scenarioCoords, forceID, campaign, contract, track);\n+                firstForce = false;\n+            } else {\n+                scenario.incrementRequiredPlayerLances();\n+                scenario.addPrimaryForce(forceID);\n+            }\n+        }\n+        \n+        scenario.setIgnoreForceAutoAssignment(true);\n+        return scenario;\n+    }\n+\n+    /**\n+     * Deploys a force to the given coordinates on the given track as a result of explicit player action.\n+     */\n+    public static void deployForceToCoords(StratconCoords coords, int forceID, \n+            Campaign campaign, AtBContract contract, StratconTrackState track, boolean sticky) {\n+        // the following things should happen:\n+        // 1. call to \"process force deployment\", which reveals fog of war in or around the coords, depending on force role\n+        // 2. if coords are a hostile facility, we get a facility mission\n+        // 3. if coords are empty, we *may* get a mission\n+\n+        processForceDeployment(coords, forceID, campaign, track, sticky);\n+\n+        // don't create a scenario on top of allied facilities\n+        StratconFacility facility = track.getFacility(coords);\n+        boolean isNonAlliedFacility = (facility != null) && (facility.getOwner() != ForceAlignment.Allied);\n+        boolean spawnScenario = (facility == null) && (Compute.randomInt(100) <= track.getScenarioOdds());\n+\n+        if (isNonAlliedFacility || spawnScenario) {\n+            StratconScenario scenario = setupScenario(coords, forceID, campaign, contract, track);\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            commitPrimaryForces(campaign, contract, scenario, track);\n+        }\n+    }\n+\n+    /**\n+     * Logic to set up a scenario\n+     */\n+    private static StratconScenario setupScenario(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        StratconScenario scenario = null;\n+\n+        if (track.getFacilities().containsKey(coords)) {\n+            StratconFacility facility = track.getFacility(coords);\n+            boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+            ScenarioTemplate template = StratconScenarioFactory.getFacilityScenario(alliedFacility);\n+            scenario = generateScenario(campaign, contract, track, forceID, coords, template);\n+            setupFacilityScenario(scenario, facility);\n+        } else {\n+            scenario = generateScenario(campaign, contract, track, forceID, coords);\n+\n+            // we may generate a facility scenario randomly - if so, do the facility-related stuff\n+            // and add a new facility to the track\n+            if (scenario.getBackingScenario().getTemplate().isFacilityScenario()) {\n+                StratconFacility facility = scenario.getBackingScenario().getTemplate().isHostileFacility() ?\n+                        StratconFacilityFactory.getRandomHostileFacility() : StratconFacilityFactory.getRandomAlliedFacility();\n+                facility.setVisible(true);\n+                track.addFacility(coords, facility);\n+                setupFacilityScenario(scenario, facility);\n+            }\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * carries out tasks relevant to facility scenarios\n+     */\n+    private static void setupFacilityScenario(StratconScenario scenario, StratconFacility facility) {\n+        // this includes:\n+        // for hostile facilities\n+        // - add a destroy objective (always the option to level the facility)\n+        // - add a capture objective (always the option to capture the facility)\n+        // - if so indicated by parameter, roll a random hostile facility objective and add it if not capture/destroy\n+        // for allied facilities\n+        // - add a defend objective (always the option to defend the facility)\n+        // - if so indicated by parameter, roll a random allied facility objective and add it if not defend\n+        AtBScenarioModifier objectiveModifier = null;\n+        boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+\n+        if (alliedFacility) {\n+            objectiveModifier = AtBScenarioModifier.getRandomAlliedFacilityModifier();\n+        } else {\n+            objectiveModifier = AtBScenarioModifier.getRandomHostileFacilityModifier();\n+        }\n+\n+        if (objectiveModifier != null) {\n+            scenario.getBackingScenario().addScenarioModifier(objectiveModifier);\n+            scenario.getBackingScenario().setName(String.format(\"%s - %s - %s\",\n+                    facility.getFacilityType(), alliedFacility ? \"Allied\" : \"Hostile\", objectiveModifier.getModifierName()));\n+        }\n+\n+        // add the \"fixed\" hostile facility modifiers after the primary ones\n+        if (!alliedFacility) {\n+            for(AtBScenarioModifier modifier : AtBScenarioModifier.getRequiredHostileFacilityModifiers()) {\n+                if(!scenario.getBackingScenario().alreadyHasModifier(modifier)) {\n+                    scenario.getBackingScenario().addScenarioModifier(modifier);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void processFacilityEffects(StratconTrackState track) {\n+        // TODO: these are \"weekly\"? effects that a stratcon facility has on the campaign/track state\n+        // currrently, that's\n+        // supply depot - allied - +1 sp\n+        // supply depot - hostile - +5% BV budget to all scenarios on track (shared modifier, so should be implemented there)\n+        // data center - allied - +1% star league cache contract (don't implement yet, but...)\n+        // data center - hostile - +5% scenario odds in track\n+        // industrial center - allied - all scenarios here have THIS IS COMING OUT OF YOUR PAYCHECK modifier\n+        // orbital defense - allied - sets 'no hostile aircraft' flag for track\n+        // orbital defense - hostile - sets 'no allied aircraft' flag for track\n+        // early warning system - allied - sets 'intercept allied base attacks' flag for track\n+        // early warning system - hostile - sets 'intercept hostile base attacks' flag for track\n+    }\n+\n+    /**\n+     * Process the deployment of a force to the given coordinates on the given track.\n+     */\n+    public static void processForceDeployment(StratconCoords coords, int forceID, \n+            Campaign campaign, StratconTrackState track, boolean sticky) {\n+        track.getRevealedCoords().add(coords);\n+        StratconFacility facility = track.getFacility(coords);\n+        if (facility != null) {\n+            facility.setVisible(true);\n+        }\n+\n+        if (campaign.getLances().get(forceID).getRole() == AtBLanceRole.SCOUTING) {\n+            for(int direction = 0; direction < 6; direction++) {\n+                StratconCoords checkCoords = coords.translate(direction);\n+\n+                facility = track.getFacility(checkCoords);\n+                if(facility != null) {\n+                    facility.setVisible(true);\n+                }\n+\n+                track.getRevealedCoords().add(coords.translate(direction));\n+            }\n+        }\n+\n+        // the force may be located in other places on the track - clear it out\n+        track.unassignForce(forceID);\n+        track.assignForce(forceID, coords, campaign.getLocalDate(), sticky);\n+        MekHQ.triggerEvent(new StratconDeploymentEvent(campaign.getForce(forceID)));\n+    }\n+\n+    /**\n+     * Worker function that processes the effects of deploying a reinforcement force to a scenario\n+     */\n+    public static boolean processReinforcementDeployment(ReinforcementEligibilityType reinforcementType,\n+            StratconCampaignState campaignState, StratconScenario scenario, Campaign campaign) {\n+        // if the force is already deployed to the track, we're done\n+        // if the force is a fight lance or we're using a support point\n+        // if there is an SP to burn, burn it and we're done\n+        // if there is a VP to burn, burn it and we're done\n+        // now, roll 2d6 + lance commander tactics\n+        // 9+ = deploy\n+        // 6+ = deploy, apply negative modifier to scenario\n+        // 2+ = fail to deploy, apply negative modifier to scenario; if fight lance, treat as 6+\n+\n+        if ((reinforcementType == ReinforcementEligibilityType.FightLance) ||\n+                (reinforcementType == ReinforcementEligibilityType.SupportPoint)) {\n+\n+            if (campaignState.getSupportPoints() > 0) {\n+                campaignState.useSupportPoint();\n+                return true;\n+            } else if (campaignState.getVictoryPoints() > 0) {\n+                campaignState.updateVictoryPoints(-1);\n+                return true;\n+            }\n+\n+            int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+            int roll = Compute.d6(2);\n+            int result = roll + tactics;\n+\n+            StringBuilder reportStatus = new StringBuilder();\n+            reportStatus.append(String.format(\"Attempting to reinforce scenario %s without SP/VP, roll 2d6 + %d: %d\",\n+                    scenario.getName(), tactics, result));\n+\n+            // fail to reinforce\n+            if ((result < 6) && (reinforcementType != ReinforcementEligibilityType.FightLance)) {\n+                reportStatus.append(\" - reinforcement attempt failed.\");\n+                campaign.addReport(reportStatus.toString());\n+                return false;\n+            // succeed but get an extra negative event added to the scenario\n+            } else if (result < 9) {\n+                MapLocation mapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+                AtBScenarioModifier scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+\n+                // keep rolling until we get an applicable one\n+                // TODO: have the AtBScenarioModifier sort these out instead for performance?\n+                while (scenarioModifier.getEventTiming() != EventTiming.PostForceGeneration) {\n+                    scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+                }\n+\n+                scenarioModifier.processModifier(scenario.getBackingScenario(), campaign, EventTiming.PostForceGeneration);\n+\n+                reportStatus.append(String.format(\" - reinforcement attempt succeeded; extra negative modifier (%s) applied to scenario.\",\n+                        scenarioModifier.getModifierName()));\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            // succeed without reservation\n+            } else {\n+                reportStatus.append(\" - reinforcement attempt succeeded;\");\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            }\n+        } else if (reinforcementType == ReinforcementEligibilityType.None) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Assigns a force to the scenario such that the majority of the force can be deployed\n+     */\n+    private static void assignAppropriateExtraForceToScenario(StratconScenario scenario,\n+            Map<MapLocation, List<Integer>> sortedAvailableForceIDs) {\n+        // the goal of this function is to avoid assigning ground units to air battles\n+        // and ground units/conventional fighters to space battle\n+\n+        List<MapLocation> mapLocations = new ArrayList<>();\n+        mapLocations.add(MapLocation.Space); // can always add ASFs\n+\n+        MapLocation scenarioMapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+\n+        if (scenarioMapLocation == MapLocation.LowAtmosphere) {\n+            mapLocations.add(MapLocation.LowAtmosphere); // can add conventional fighters to ground or low atmo battles\n+        }\n+\n+        if ((scenarioMapLocation == MapLocation.AllGroundTerrain) ||\n+                (scenarioMapLocation == MapLocation.SpecificGroundTerrain)) {\n+            mapLocations.add(MapLocation.AllGroundTerrain); // can only add ground units to ground battles\n+        }\n+\n+        MapLocation selectedLocation = mapLocations.get(Compute.randomInt(mapLocations.size()));\n+        List<Integer> forceIDs = sortedAvailableForceIDs.get(selectedLocation);\n+        int forceIndex = Compute.randomInt(forceIDs.size());\n+        int forceID = forceIDs.get(forceIndex);\n+        forceIDs.remove(forceIndex);\n+\n+        scenario.addPrimaryForce(forceID);\n+    }\n+\n+    /**\n+     * Worker function that \"locks in\" a scenario -\n+     * Adds it to the campaign so it's visible in the briefing room,\n+     * adds it to the track\n+     *\n+     */\n+    public static void commitPrimaryForces(Campaign campaign, AtBContract contract, StratconScenario scenario, StratconTrackState trackState) {\n+        // order of operations is important here, we need a valid scenario ID prior to adding the scenario to the track.\n+        campaign.addScenario(scenario.getBackingScenario(), contract);\n+        scenario.setBackingScenarioID(scenario.getBackingScenario().getId());\n+        trackState.addScenario(scenario);\n+\n+        // set up dates for the scenario if doesn't have them already\n+        if (scenario.getDeploymentDate() == null) {\n+            scenario.setDeploymentDate(campaign.getLocalDate());\n+        }\n+\n+        if (scenario.getActionDate() == null) {\n+            scenario.setActionDate(campaign.getLocalDate());\n+        }\n+\n+        if(scenario.getReturnDate() == null) {\n+            scenario.setReturnDate(campaign.getLocalDate().plusDays(trackState.getDeploymentTime()));\n+        }\n+\n+        // set the # of rerolls based on the actual lance assigned.\n+        int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+        scenario.getBackingScenario().setRerolls(tactics);\n+        // The number of defensive points available to a force entering a scenario is\n+        // 2 x tactics. By default, those points are spent on conventional minefields.\n+        if (commanderLanceHasDefensiveAssignment(scenario.getBackingScenario(), campaign)) {\n+            scenario.setNumDefensivePoints(tactics * 2);\n+            scenario.updateMinefieldCount(Minefield.TYPE_CONVENTIONAL, tactics * 2);\n+        }\n+\n+        for (int forceID : scenario.getPlayerTemplateForceIDs()) {\n+            Force force = campaign.getForce(forceID);\n+            force.clearScenarioIds(campaign, true);\n+            force.setScenarioId(scenario.getBackingScenarioID());\n+        }\n+\n+        scenario.commitPrimaryForces();\n+    }\n+\n+    /**\n+     * Utility method to determine if the current scenario's force commander\n+     * is on defence\n+     */\n+    private static boolean commanderLanceHasDefensiveAssignment(AtBDynamicScenario scenario, Campaign campaign) {\n+        Unit commanderUnit = scenario.getLanceCommander(campaign).getUnit();\n+        Lance lance = campaign.getLances().get(commanderUnit.getForceId());\n+\n+        if ((lance != null) && (lance.getRole() == AtBLanceRole.DEFENCE)) {\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * A hackish worker function that takes the given list of force IDs and\n+     * separates it into three sets;\n+     * one of forces that can be \"primary\" on a ground map\n+     * one of forces that can be \"primary\" on an atmospheric map\n+     * one of forces that can be \"primary\" in a space map\n+     * @param forceIDs List of force IDs to check\n+     * @return Sorted hash map\n+     */\n+    private static Map<MapLocation, List<Integer>> sortForcesByMapType(List<Integer> forceIDs, Campaign campaign) {\n+        Map<MapLocation, List<Integer>> retVal = new HashMap<>();\n+\n+        retVal.put(MapLocation.AllGroundTerrain, new ArrayList<>());\n+        retVal.put(MapLocation.LowAtmosphere, new ArrayList<>());\n+        retVal.put(MapLocation.Space, new ArrayList<>());\n+\n+        for (int forceID : forceIDs) {\n+            switch(campaign.getForce(forceID).getPrimaryUnitType(campaign)) {\n+            case UnitType.BATTLE_ARMOR:\n+            case UnitType.INFANTRY:\n+            case UnitType.MEK:\n+            case UnitType.TANK:\n+            case UnitType.PROTOMEK:\n+            case UnitType.VTOL:\n+                retVal.get(MapLocation.AllGroundTerrain).add(forceID);\n+                break;\n+            case UnitType.AERO:\n+                retVal.get(MapLocation.Space).add(forceID);\n+                // intentional fallthrough here, ASFs can go to atmospheric maps too\n+            case UnitType.CONV_FIGHTER:\n+                retVal.get(MapLocation.LowAtmosphere).add(forceID);\n+                break;\n+            }\n+        }\n+\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * Determine whether the user should be nagged about unresolved scenarios on AtB Stratcon tracks.\n+     * @param campaign Campaign to check.\n+     * @return An informative string containing the reasons the user was nagged.\n+     */\n+    public static String nagUnresolvedContacts(Campaign campaign) {\n+        StringBuilder sb = new StringBuilder();\n+\n+        // check every track attached to an active contract for unresolved scenarios\n+        // to which the player must deploy forces today\n+        for (Contract contract : campaign.getActiveContracts()) {\n+            if(contract instanceof AtBContract) {\n+                for(StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    for(StratconScenario scenario : track.getScenarios().values()) {\n+                        if(scenario.getCurrentState() == ScenarioState.UNRESOLVED &&\n+                                campaign.getLocalDate().equals(scenario.getDeploymentDate())) {\n+                            // \"scenario name, track name\"\n+                            sb.append(String.format(\"%s, %s\\n\", scenario.getName(), track.getDisplayableName()));\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track.\n+     * Also registers it with the track and campaign.\n+     */\n+    private static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords) {\n+        int unitType = campaign.getForce(forceID).getPrimaryUnitType(campaign);\n+        ScenarioTemplate template = StratconScenarioFactory.getRandomScenario(unitType);\n+        // useful for debugging specific scenario types\n+        //ScenarioTemplate template = StratconScenarioFactory.getSpecificScenario(\"Allied Facility.xml\");\n+\n+        return generateScenario(campaign, contract, track, forceID, coords, template);\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track,\n+     * using the given template. Also registers it with the track and campaign.\n+     */\n+    static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords, ScenarioTemplate template) {\n+        StratconScenario scenario = new StratconScenario();\n+        scenario.setBackingScenario(AtBDynamicScenarioFactory.initializeScenarioFromTemplate(template, contract, campaign));\n+        scenario.setCoords(coords);\n+        \n+        // by default, certain conditions may make this bigger\n+        scenario.setRequiredPlayerLances(1);\n+\n+        // do an appropriate allied force if the contract calls for it\n+        // do any attached or integrated units\n+        setAlliedForceModifier(scenario, contract);\n+        setAttachedUnitsModifier(scenario, contract);\n+        applyFacilityModifiers(scenario, track, coords);\n+        applyGlobalModifiers(scenario, contract.getStratconCampaignState());\n+\n+        if ((contract.getCommandRights() == AtBContract.COM_HOUSE) ||\n+                (contract.getCommandRights() == AtBContract.COM_INTEGRATED)) {\n+            scenario.setRequiredScenario(true);\n+        }\n+\n+        AtBDynamicScenarioFactory.setScenarioModifiers(scenario.getBackingScenario());\n+        scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+        setScenarioDates(track, campaign, scenario);\n+\n+        // register the scenario with the campaign and the track it's generated on\n+        if (forceID > Force.FORCE_NONE) {\n+            scenario.addPrimaryForce(forceID);\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * Apply global scenario modifiers from campaign state to given scenario.\n+     */\n+    private static void applyGlobalModifiers(StratconScenario scenario, StratconCampaignState campaignState) {\n+        for (String modifierName : campaignState.getGlobalScenarioModifiers()) {\n+            AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierName);\n+\n+            if (modifier == null) {\n+                MekHQ.getLogger().error(String.format(\"Modifier %s not found; ignoring\", modifierName));\n+                continue;\n+            }\n+\n+            scenario.getBackingScenario().addScenarioModifier(modifier);\n+        }\n+    }\n+\n+    /**\n+     * Applies scenario modifiers from the current track to the given scenario.\n+     * @param scenario\n+     * @param track\n+     */\n+    private static void applyFacilityModifiers(StratconScenario scenario, StratconTrackState track, StratconCoords coords) {\n+        // loop through all the facilities on the track\n+        // if a facility has been revealed, then it has a 100% chance to apply its effect\n+        // if a facility has not been revealed, then it has a x% chance to apply its effect\n+        // if a facility is on the the scenario coordinates the it applies the local effects\n+        for (StratconCoords facilityCoords : track.getFacilities().keySet()) {\n+            boolean scenarioAtFacility = facilityCoords.equals(coords);\n+            StratconFacility facility = track.getFacilities().get(facilityCoords);\n+            List<String> modifierIDs = new ArrayList<>();\n+\n+            if (scenarioAtFacility) {\n+                modifierIDs = facility.getLocalModifiers();\n+            } else if (facility.isVisible() || (Compute.randomInt(100) <= facility.getAggroRating())) {\n+                modifierIDs = facility.getSharedModifiers();\n+            }\n+\n+            for (String modifierID : modifierIDs) {\n+                AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierID);\n+                if(modifier == null) {\n+                    MekHQ.getLogger().error(String.format(\"Modifier %s not found for facility %s\", modifierID, facility.getFormattedDisplayableName()));\n+                    continue;\n+                }\n+\n+                scenario.getBackingScenario().addScenarioModifier(modifier);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set up the appropriate primary allied force modifier, if any\n+     * @param contract The scenario's contract.\n+     */\n+    private static void setAlliedForceModifier(StratconScenario scenario, AtBContract contract) {\n+        int alliedUnitOdds = 0;\n+\n+        // first, we determine the odds of having an allied unit present\n+        // TODO: move this override out to the contract definition\n+        if (contract.getMissionType() == AtBContract.MT_RELIEFDUTY) {\n+            alliedUnitOdds = 50;\n+        } else {\n+            switch(contract.getCommandRights()) {\n+            case AtBContract.COM_INTEGRATED:\n+                alliedUnitOdds = 50;\n+                break;\n+            case AtBContract.COM_HOUSE:\n+                alliedUnitOdds = 30;\n+                break;\n+            case AtBContract.COM_LIAISON:\n+                alliedUnitOdds = 10;\n+                break;\n+            }\n+        }\n+\n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+\n+        // if an allied unit is present, then we want to make sure that it's ground units\n+        // for ground battles\n+        if (Compute.randomInt(100) <= alliedUnitOdds) {\n+            if((backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+               (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space)) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_ALLIED_AIR_UNITS));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_ALLIED_GROUND_UNITS));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set the 'attached' units modifier for the current scenario (integrated, house, liaison),\n+     * and make sure we're not deploying ground units to an air scenario\n+     * @param contract The scenario's contract\n+     */\n+    public static void setAttachedUnitsModifier(StratconScenario scenario, AtBContract contract) {\n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+        boolean airBattle = (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+                (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space);\n+\n+        // if we're on cadre duty, we're getting three trainees, period\n+        if (contract.getMissionType() == AtBContract.MT_CADREDUTY) {\n+            if (airBattle) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_TRAINEES_AIR));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_TRAINEES_GROUND));\n+            }\n+            return;\n+        }\n+\n+        // if we're under non-independent command rights, a supervisor may come along\n+        switch (contract.getCommandRights()) {\n+            case AtBContract.COM_INTEGRATED:\n+                if (airBattle) {\n+                    backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_INTEGRATED_UNITS_AIR));\n+                } else {\n+                    backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_INTEGRATED_UNITS_GROUND));\n+                }\n+                break;\n+            case AtBContract.COM_HOUSE:\n+                if (airBattle) {\n+                    backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_HOUSE_CO_AIR));\n+                } else {\n+                    backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_HOUSE_CO_GROUND));\n+                }\n+                break;\n+            case AtBContract.COM_LIAISON:\n+                if (scenario.isRequiredScenario()) {\n+                    if(airBattle) {\n+                        backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_LIAISON_AIR));\n+                    } else {\n+                        backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_LIAISON_GROUND));\n+                    }\n+                }\n+                break;\n+        }\n+    }\n+\n+    /**\n+     * Worker function that sets scenario deploy/battle/return dates based on the track's properties and current campaign date\n+     */\n+    private static void setScenarioDates(StratconTrackState track, Campaign campaign, StratconScenario scenario) {\n+     // set up deployment day, battle day, return day here\n+        // safety code to prevent attempts to generate random int with upper bound of 0 which is apparently illegal\n+        int deploymentDay = track.getDeploymentTime() < 7 ? Compute.randomInt(7 - track.getDeploymentTime()) : 0;\n+        int battleDay = deploymentDay + (track.getDeploymentTime() > 0 ? Compute.randomInt(track.getDeploymentTime()) : 0);\n+        int returnDay = deploymentDay + track.getDeploymentTime();\n+\n+        LocalDate deploymentDate = campaign.getLocalDate();\n+        deploymentDate.plusDays(deploymentDay);\n+        LocalDate battleDate = campaign.getLocalDate();\n+        deploymentDate.plusDays(battleDay);\n+        LocalDate returnDate = campaign.getLocalDate();\n+        returnDate.plusDays(returnDay);\n+\n+        scenario.setDeploymentDate(deploymentDate);\n+        scenario.setActionDate(battleDate);\n+        scenario.setReturnDate(returnDate);\n+    }\n+\n+    /**\n+     * Helper function that determines if the unit type specified in the given scenario force template\n+     * would start out airborne on a ground map (hot dropped units aside)\n+     */\n+    private static boolean unitTypeIsAirborne(ScenarioForceTemplate template) {\n+        int unitType = template.getAllowedUnitType();\n+\n+        return (unitType == UnitType.AERO ||\n+                unitType == UnitType.CONV_FIGHTER ||\n+                unitType == UnitType.DROPSHIP ||\n+                unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_MIX) &&\n+                template.getStartingAltitude() > 0;\n+    }\n+\n+    /**\n+     * Determines whether the force in question has the same primary unit type as the force template.\n+     * @return Whether or not the unit types match.\n+     */\n+    public static boolean forceCompositionMatchesDeclaredUnitType(int primaryUnitType, int unitType, boolean reinforcements) {\n+        // special cases are \"ATB_MIX\" and \"ATB_AERO_MIX\", which encompass multiple unit types\n+        if (unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_MIX) {\n+            // \"AtB mix\" is usually ground units, but air units can sub in\n+            return primaryUnitType == UnitType.MEK ||\n+                    primaryUnitType == UnitType.TANK ||\n+                    primaryUnitType == UnitType.INFANTRY ||\n+                    primaryUnitType == UnitType.BATTLE_ARMOR ||\n+                    primaryUnitType == UnitType.PROTOMEK ||\n+                    primaryUnitType == UnitType.VTOL ||\n+                    (primaryUnitType == UnitType.AERO) && reinforcements ||\n+                    (primaryUnitType == UnitType.CONV_FIGHTER) && reinforcements;\n+        } else if (unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_AERO_MIX) {\n+            return primaryUnitType == UnitType.AERO ||\n+                    primaryUnitType == UnitType.CONV_FIGHTER;\n+        } else {\n+            return primaryUnitType == unitType;\n+        }\n+    }\n+\n+    /**\n+     * This is a set of all force IDs for forces that can be deployed to a scenario.\n+     * @param campaign Current campaign\n+     * @return Set of available force IDs.\n+     */\n+    public static List<Integer> getAvailableForceIDs(Campaign campaign) {\n+        List<Integer> retVal = new ArrayList<>();\n+\n+        // first, we gather a set of all forces that are already deployed to a track so we eliminate those later\n+        Set<Integer> forcesInTracks = new HashSet<>();\n+        for (Contract contract : campaign.getActiveContracts()) {\n+            if(contract instanceof AtBContract) {", "originalCommit": "0244602bac43aacfd804a92250447a67a4fbd75a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNDUwNjY1Mg==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r604506652", "bodyText": "Fix", "author": "Windchild292", "createdAt": "2021-03-31T00:00:41Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1291 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.UUID;\n+\n+import megamek.common.Compute;\n+import megamek.common.Minefield;\n+import megamek.common.UnitType;\n+import megamek.common.annotations.Nullable;\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.Utilities;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.ResolveScenarioTracker;\n+import mekhq.campaign.againstTheBot.enums.AtBLanceRole;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.event.StratconDeploymentEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.force.Lance;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier.EventTiming;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.unit.Unit;\n+\n+/**\n+ * This class contains \"rules\" logic for the AtB-Stratcon state\n+ * @author NickAragua\n+ */\n+public class StratconRulesManager {\n+    /**\n+     * What makes a particular lance eligible to be reinforcements for a scenario\n+     * @author NickAragua\n+     */\n+    public enum ReinforcementEligibilityType {\n+        /**\n+         * Nothing\n+         */\n+        None,\n+\n+        /**\n+         * Lance is already deployed to the track\n+         */\n+        ChainedScenario,\n+\n+        /**\n+         * We pay a support point or convert a victory point to a support point\n+         */\n+        SupportPoint,\n+\n+        /**\n+         * The lance's deployment orders are \"Fight\"\n+         */\n+        FightLance\n+    }\n+\n+    /**\n+     * This function potentially generates non-player-initiated scenarios for the given track.\n+     */\n+    public static void generateScenariosForTrack(Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // maps scenarios to force IDs\n+        List<StratconScenario> generatedScenarios = new ArrayList<>();\n+        boolean autoAssignLances = contract.getCommandRights() == AtBContract.COM_INTEGRATED;\n+\n+        // get this list just so we have it available\n+        List<Integer> availableForceIDs = getAvailableForceIDs(campaign);\n+        Map<MapLocation, List<Integer>> sortedAvailableForceIDs = sortForcesByMapType(availableForceIDs, campaign);\n+\n+        // make X rolls, where X is the number of required lances for the track\n+        // that's the chance to spawn a scenario.\n+        // if a scenario occurs, then we pick a random non-deployed lance and use it to drive the opfor generation later\n+        // once we've determined that scenarios occur, we loop through the ones that we generated\n+        // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all\n+        for (int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            // if we haven't already used all the player forces and are required to randomly generate a scenario\n+            if ((availableForceIDs.size() > 0) &&\n+                    (Compute.randomInt(100) <= track.getScenarioOdds())) {\n+                // pick random coordinates and force to drive the scenario\n+                int x = Compute.randomInt(track.getWidth());\n+                int y = Compute.randomInt(track.getHeight());\n+\n+                StratconCoords scenarioCoords = new StratconCoords(x, y);\n+\n+                // if forces are already assigned to these coordinates, use those instead\n+                // of randomly-selected ones\n+                if (track.getAssignedCoordForces().containsKey(scenarioCoords)) {\n+                    StratconScenario scenario = generateScenarioForExistingForces(scenarioCoords,\n+                            track.getAssignedCoordForces().get(scenarioCoords), \n+                            contract, campaign, track);\n+                    generatedScenarios.add(scenario);\n+                    continue;\n+                }\n+                \n+                // otherwise, pick a random force from the avail\n+                int randomForceIndex = Compute.randomInt(availableForceIDs.size());\n+                int randomForceID = availableForceIDs.get(randomForceIndex);\n+                \n+                // remove the force from the available lists so we don't designate it as primary twice\n+                availableForceIDs.remove(randomForceIndex);\n+\n+                // we want to remove the actual int with the value, not the value at the index\n+                sortedAvailableForceIDs.get(MapLocation.AllGroundTerrain).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.LowAtmosphere).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.Space).remove((Integer) randomForceID);\n+\n+                // two scenarios on the same coordinates wind up increasing in size\n+                if (track.getScenarios().containsKey(scenarioCoords)) {\n+                    track.getScenarios().get(scenarioCoords).incrementRequiredPlayerLances();\n+                    assignAppropriateExtraForceToScenario(track.getScenarios().get(scenarioCoords), sortedAvailableForceIDs);\n+                    continue;\n+                }\n+\n+                StratconScenario scenario = setupScenario(scenarioCoords, randomForceID, campaign, contract, track);\n+                generatedScenarios.add(scenario);\n+\n+                // if we're auto-assigning lances, deploy the force to the track as well\n+                if (autoAssignLances) {\n+                    processForceDeployment(scenarioCoords, randomForceID, campaign, track, false);\n+                }\n+            }\n+        }\n+\n+        // if under liaison command, pick a random scenario from the ones generated\n+        // to set as required and attach liaison\n+        if (contract.getCommandRights() == AtBContract.COM_LIAISON) {\n+        \tStratconScenario randomScenario = Utilities.getRandomItem(generatedScenarios);\n+        \trandomScenario.setRequiredScenario(true);\n+            setAttachedUnitsModifier(randomScenario, contract);\n+        }\n+\n+        // now, we loop through all the scenarios we set up\n+        // and generate the opfors / events / etc\n+        // if not auto-assigning lances, we then back out the lance assignments.\n+        for (StratconScenario scenario : generatedScenarios) {\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+\n+            if(!autoAssignLances && !scenario.ignoreForceAutoAssignment()) {\n+                for(int forceID : scenario.getPlayerTemplateForceIDs()) {\n+                    scenario.getBackingScenario().removeForce(forceID);\n+                }\n+\n+                scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                track.addScenario(scenario);\n+            } else {\n+                commitPrimaryForces(campaign, contract, scenario, track);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Given a set of force IDs and coordinates, generate a scenario\n+     * Useful for when we want to generate scenarios \n+     * for forces already deployed to a track\n+     */\n+    public static StratconScenario generateScenarioForExistingForces(StratconCoords scenarioCoords, \n+            Set<Integer> forceIDs, AtBContract contract, Campaign campaign, StratconTrackState track) {\n+        boolean firstForce = true;\n+        StratconScenario scenario = null;\n+        \n+        for (int forceID : forceIDs) {\n+            if (firstForce) {\n+                scenario = setupScenario(scenarioCoords, forceID, campaign, contract, track);\n+                firstForce = false;\n+            } else {\n+                scenario.incrementRequiredPlayerLances();\n+                scenario.addPrimaryForce(forceID);\n+            }\n+        }\n+        \n+        scenario.setIgnoreForceAutoAssignment(true);\n+        return scenario;\n+    }\n+\n+    /**\n+     * Deploys a force to the given coordinates on the given track as a result of explicit player action.\n+     */\n+    public static void deployForceToCoords(StratconCoords coords, int forceID, \n+            Campaign campaign, AtBContract contract, StratconTrackState track, boolean sticky) {\n+        // the following things should happen:\n+        // 1. call to \"process force deployment\", which reveals fog of war in or around the coords, depending on force role\n+        // 2. if coords are a hostile facility, we get a facility mission\n+        // 3. if coords are empty, we *may* get a mission\n+\n+        processForceDeployment(coords, forceID, campaign, track, sticky);\n+\n+        // don't create a scenario on top of allied facilities\n+        StratconFacility facility = track.getFacility(coords);\n+        boolean isNonAlliedFacility = (facility != null) && (facility.getOwner() != ForceAlignment.Allied);\n+        boolean spawnScenario = (facility == null) && (Compute.randomInt(100) <= track.getScenarioOdds());\n+\n+        if (isNonAlliedFacility || spawnScenario) {\n+            StratconScenario scenario = setupScenario(coords, forceID, campaign, contract, track);\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            commitPrimaryForces(campaign, contract, scenario, track);\n+        }\n+    }\n+\n+    /**\n+     * Logic to set up a scenario\n+     */\n+    private static StratconScenario setupScenario(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        StratconScenario scenario = null;\n+\n+        if (track.getFacilities().containsKey(coords)) {\n+            StratconFacility facility = track.getFacility(coords);\n+            boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+            ScenarioTemplate template = StratconScenarioFactory.getFacilityScenario(alliedFacility);\n+            scenario = generateScenario(campaign, contract, track, forceID, coords, template);\n+            setupFacilityScenario(scenario, facility);\n+        } else {\n+            scenario = generateScenario(campaign, contract, track, forceID, coords);\n+\n+            // we may generate a facility scenario randomly - if so, do the facility-related stuff\n+            // and add a new facility to the track\n+            if (scenario.getBackingScenario().getTemplate().isFacilityScenario()) {\n+                StratconFacility facility = scenario.getBackingScenario().getTemplate().isHostileFacility() ?\n+                        StratconFacilityFactory.getRandomHostileFacility() : StratconFacilityFactory.getRandomAlliedFacility();\n+                facility.setVisible(true);\n+                track.addFacility(coords, facility);\n+                setupFacilityScenario(scenario, facility);\n+            }\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * carries out tasks relevant to facility scenarios\n+     */\n+    private static void setupFacilityScenario(StratconScenario scenario, StratconFacility facility) {\n+        // this includes:\n+        // for hostile facilities\n+        // - add a destroy objective (always the option to level the facility)\n+        // - add a capture objective (always the option to capture the facility)\n+        // - if so indicated by parameter, roll a random hostile facility objective and add it if not capture/destroy\n+        // for allied facilities\n+        // - add a defend objective (always the option to defend the facility)\n+        // - if so indicated by parameter, roll a random allied facility objective and add it if not defend\n+        AtBScenarioModifier objectiveModifier = null;\n+        boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+\n+        if (alliedFacility) {\n+            objectiveModifier = AtBScenarioModifier.getRandomAlliedFacilityModifier();\n+        } else {\n+            objectiveModifier = AtBScenarioModifier.getRandomHostileFacilityModifier();\n+        }\n+\n+        if (objectiveModifier != null) {\n+            scenario.getBackingScenario().addScenarioModifier(objectiveModifier);\n+            scenario.getBackingScenario().setName(String.format(\"%s - %s - %s\",\n+                    facility.getFacilityType(), alliedFacility ? \"Allied\" : \"Hostile\", objectiveModifier.getModifierName()));\n+        }\n+\n+        // add the \"fixed\" hostile facility modifiers after the primary ones\n+        if (!alliedFacility) {\n+            for(AtBScenarioModifier modifier : AtBScenarioModifier.getRequiredHostileFacilityModifiers()) {\n+                if(!scenario.getBackingScenario().alreadyHasModifier(modifier)) {\n+                    scenario.getBackingScenario().addScenarioModifier(modifier);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void processFacilityEffects(StratconTrackState track) {\n+        // TODO: these are \"weekly\"? effects that a stratcon facility has on the campaign/track state\n+        // currrently, that's\n+        // supply depot - allied - +1 sp\n+        // supply depot - hostile - +5% BV budget to all scenarios on track (shared modifier, so should be implemented there)\n+        // data center - allied - +1% star league cache contract (don't implement yet, but...)\n+        // data center - hostile - +5% scenario odds in track\n+        // industrial center - allied - all scenarios here have THIS IS COMING OUT OF YOUR PAYCHECK modifier\n+        // orbital defense - allied - sets 'no hostile aircraft' flag for track\n+        // orbital defense - hostile - sets 'no allied aircraft' flag for track\n+        // early warning system - allied - sets 'intercept allied base attacks' flag for track\n+        // early warning system - hostile - sets 'intercept hostile base attacks' flag for track\n+    }\n+\n+    /**\n+     * Process the deployment of a force to the given coordinates on the given track.\n+     */\n+    public static void processForceDeployment(StratconCoords coords, int forceID, \n+            Campaign campaign, StratconTrackState track, boolean sticky) {\n+        track.getRevealedCoords().add(coords);\n+        StratconFacility facility = track.getFacility(coords);\n+        if (facility != null) {\n+            facility.setVisible(true);\n+        }\n+\n+        if (campaign.getLances().get(forceID).getRole() == AtBLanceRole.SCOUTING) {\n+            for(int direction = 0; direction < 6; direction++) {\n+                StratconCoords checkCoords = coords.translate(direction);\n+\n+                facility = track.getFacility(checkCoords);\n+                if(facility != null) {\n+                    facility.setVisible(true);\n+                }\n+\n+                track.getRevealedCoords().add(coords.translate(direction));\n+            }\n+        }\n+\n+        // the force may be located in other places on the track - clear it out\n+        track.unassignForce(forceID);\n+        track.assignForce(forceID, coords, campaign.getLocalDate(), sticky);\n+        MekHQ.triggerEvent(new StratconDeploymentEvent(campaign.getForce(forceID)));\n+    }\n+\n+    /**\n+     * Worker function that processes the effects of deploying a reinforcement force to a scenario\n+     */\n+    public static boolean processReinforcementDeployment(ReinforcementEligibilityType reinforcementType,\n+            StratconCampaignState campaignState, StratconScenario scenario, Campaign campaign) {\n+        // if the force is already deployed to the track, we're done\n+        // if the force is a fight lance or we're using a support point\n+        // if there is an SP to burn, burn it and we're done\n+        // if there is a VP to burn, burn it and we're done\n+        // now, roll 2d6 + lance commander tactics\n+        // 9+ = deploy\n+        // 6+ = deploy, apply negative modifier to scenario\n+        // 2+ = fail to deploy, apply negative modifier to scenario; if fight lance, treat as 6+\n+\n+        if ((reinforcementType == ReinforcementEligibilityType.FightLance) ||\n+                (reinforcementType == ReinforcementEligibilityType.SupportPoint)) {\n+\n+            if (campaignState.getSupportPoints() > 0) {\n+                campaignState.useSupportPoint();\n+                return true;\n+            } else if (campaignState.getVictoryPoints() > 0) {\n+                campaignState.updateVictoryPoints(-1);\n+                return true;\n+            }\n+\n+            int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+            int roll = Compute.d6(2);\n+            int result = roll + tactics;\n+\n+            StringBuilder reportStatus = new StringBuilder();\n+            reportStatus.append(String.format(\"Attempting to reinforce scenario %s without SP/VP, roll 2d6 + %d: %d\",\n+                    scenario.getName(), tactics, result));\n+\n+            // fail to reinforce\n+            if ((result < 6) && (reinforcementType != ReinforcementEligibilityType.FightLance)) {\n+                reportStatus.append(\" - reinforcement attempt failed.\");\n+                campaign.addReport(reportStatus.toString());\n+                return false;\n+            // succeed but get an extra negative event added to the scenario\n+            } else if (result < 9) {\n+                MapLocation mapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+                AtBScenarioModifier scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+\n+                // keep rolling until we get an applicable one\n+                // TODO: have the AtBScenarioModifier sort these out instead for performance?\n+                while (scenarioModifier.getEventTiming() != EventTiming.PostForceGeneration) {\n+                    scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+                }\n+\n+                scenarioModifier.processModifier(scenario.getBackingScenario(), campaign, EventTiming.PostForceGeneration);\n+\n+                reportStatus.append(String.format(\" - reinforcement attempt succeeded; extra negative modifier (%s) applied to scenario.\",\n+                        scenarioModifier.getModifierName()));\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            // succeed without reservation\n+            } else {\n+                reportStatus.append(\" - reinforcement attempt succeeded;\");\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            }\n+        } else if (reinforcementType == ReinforcementEligibilityType.None) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Assigns a force to the scenario such that the majority of the force can be deployed\n+     */\n+    private static void assignAppropriateExtraForceToScenario(StratconScenario scenario,\n+            Map<MapLocation, List<Integer>> sortedAvailableForceIDs) {\n+        // the goal of this function is to avoid assigning ground units to air battles\n+        // and ground units/conventional fighters to space battle\n+\n+        List<MapLocation> mapLocations = new ArrayList<>();\n+        mapLocations.add(MapLocation.Space); // can always add ASFs\n+\n+        MapLocation scenarioMapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+\n+        if (scenarioMapLocation == MapLocation.LowAtmosphere) {\n+            mapLocations.add(MapLocation.LowAtmosphere); // can add conventional fighters to ground or low atmo battles\n+        }\n+\n+        if ((scenarioMapLocation == MapLocation.AllGroundTerrain) ||\n+                (scenarioMapLocation == MapLocation.SpecificGroundTerrain)) {\n+            mapLocations.add(MapLocation.AllGroundTerrain); // can only add ground units to ground battles\n+        }\n+\n+        MapLocation selectedLocation = mapLocations.get(Compute.randomInt(mapLocations.size()));\n+        List<Integer> forceIDs = sortedAvailableForceIDs.get(selectedLocation);\n+        int forceIndex = Compute.randomInt(forceIDs.size());\n+        int forceID = forceIDs.get(forceIndex);\n+        forceIDs.remove(forceIndex);\n+\n+        scenario.addPrimaryForce(forceID);\n+    }\n+\n+    /**\n+     * Worker function that \"locks in\" a scenario -\n+     * Adds it to the campaign so it's visible in the briefing room,\n+     * adds it to the track\n+     *\n+     */\n+    public static void commitPrimaryForces(Campaign campaign, AtBContract contract, StratconScenario scenario, StratconTrackState trackState) {\n+        // order of operations is important here, we need a valid scenario ID prior to adding the scenario to the track.\n+        campaign.addScenario(scenario.getBackingScenario(), contract);\n+        scenario.setBackingScenarioID(scenario.getBackingScenario().getId());\n+        trackState.addScenario(scenario);\n+\n+        // set up dates for the scenario if doesn't have them already\n+        if (scenario.getDeploymentDate() == null) {\n+            scenario.setDeploymentDate(campaign.getLocalDate());\n+        }\n+\n+        if (scenario.getActionDate() == null) {\n+            scenario.setActionDate(campaign.getLocalDate());\n+        }\n+\n+        if(scenario.getReturnDate() == null) {\n+            scenario.setReturnDate(campaign.getLocalDate().plusDays(trackState.getDeploymentTime()));\n+        }\n+\n+        // set the # of rerolls based on the actual lance assigned.\n+        int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+        scenario.getBackingScenario().setRerolls(tactics);\n+        // The number of defensive points available to a force entering a scenario is\n+        // 2 x tactics. By default, those points are spent on conventional minefields.\n+        if (commanderLanceHasDefensiveAssignment(scenario.getBackingScenario(), campaign)) {\n+            scenario.setNumDefensivePoints(tactics * 2);\n+            scenario.updateMinefieldCount(Minefield.TYPE_CONVENTIONAL, tactics * 2);\n+        }\n+\n+        for (int forceID : scenario.getPlayerTemplateForceIDs()) {\n+            Force force = campaign.getForce(forceID);\n+            force.clearScenarioIds(campaign, true);\n+            force.setScenarioId(scenario.getBackingScenarioID());\n+        }\n+\n+        scenario.commitPrimaryForces();\n+    }\n+\n+    /**\n+     * Utility method to determine if the current scenario's force commander\n+     * is on defence\n+     */\n+    private static boolean commanderLanceHasDefensiveAssignment(AtBDynamicScenario scenario, Campaign campaign) {\n+        Unit commanderUnit = scenario.getLanceCommander(campaign).getUnit();\n+        Lance lance = campaign.getLances().get(commanderUnit.getForceId());\n+\n+        if ((lance != null) && (lance.getRole() == AtBLanceRole.DEFENCE)) {\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * A hackish worker function that takes the given list of force IDs and\n+     * separates it into three sets;\n+     * one of forces that can be \"primary\" on a ground map\n+     * one of forces that can be \"primary\" on an atmospheric map\n+     * one of forces that can be \"primary\" in a space map\n+     * @param forceIDs List of force IDs to check\n+     * @return Sorted hash map\n+     */\n+    private static Map<MapLocation, List<Integer>> sortForcesByMapType(List<Integer> forceIDs, Campaign campaign) {\n+        Map<MapLocation, List<Integer>> retVal = new HashMap<>();\n+\n+        retVal.put(MapLocation.AllGroundTerrain, new ArrayList<>());\n+        retVal.put(MapLocation.LowAtmosphere, new ArrayList<>());\n+        retVal.put(MapLocation.Space, new ArrayList<>());\n+\n+        for (int forceID : forceIDs) {\n+            switch(campaign.getForce(forceID).getPrimaryUnitType(campaign)) {\n+            case UnitType.BATTLE_ARMOR:\n+            case UnitType.INFANTRY:\n+            case UnitType.MEK:\n+            case UnitType.TANK:\n+            case UnitType.PROTOMEK:\n+            case UnitType.VTOL:\n+                retVal.get(MapLocation.AllGroundTerrain).add(forceID);\n+                break;\n+            case UnitType.AERO:\n+                retVal.get(MapLocation.Space).add(forceID);\n+                // intentional fallthrough here, ASFs can go to atmospheric maps too\n+            case UnitType.CONV_FIGHTER:\n+                retVal.get(MapLocation.LowAtmosphere).add(forceID);\n+                break;\n+            }\n+        }\n+\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * Determine whether the user should be nagged about unresolved scenarios on AtB Stratcon tracks.\n+     * @param campaign Campaign to check.\n+     * @return An informative string containing the reasons the user was nagged.\n+     */\n+    public static String nagUnresolvedContacts(Campaign campaign) {\n+        StringBuilder sb = new StringBuilder();\n+\n+        // check every track attached to an active contract for unresolved scenarios\n+        // to which the player must deploy forces today\n+        for (Contract contract : campaign.getActiveContracts()) {\n+            if(contract instanceof AtBContract) {\n+                for(StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    for(StratconScenario scenario : track.getScenarios().values()) {\n+                        if(scenario.getCurrentState() == ScenarioState.UNRESOLVED &&\n+                                campaign.getLocalDate().equals(scenario.getDeploymentDate())) {\n+                            // \"scenario name, track name\"\n+                            sb.append(String.format(\"%s, %s\\n\", scenario.getName(), track.getDisplayableName()));\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track.\n+     * Also registers it with the track and campaign.\n+     */\n+    private static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords) {\n+        int unitType = campaign.getForce(forceID).getPrimaryUnitType(campaign);\n+        ScenarioTemplate template = StratconScenarioFactory.getRandomScenario(unitType);\n+        // useful for debugging specific scenario types\n+        //ScenarioTemplate template = StratconScenarioFactory.getSpecificScenario(\"Allied Facility.xml\");\n+\n+        return generateScenario(campaign, contract, track, forceID, coords, template);\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track,\n+     * using the given template. Also registers it with the track and campaign.\n+     */\n+    static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords, ScenarioTemplate template) {\n+        StratconScenario scenario = new StratconScenario();\n+        scenario.setBackingScenario(AtBDynamicScenarioFactory.initializeScenarioFromTemplate(template, contract, campaign));\n+        scenario.setCoords(coords);\n+        \n+        // by default, certain conditions may make this bigger\n+        scenario.setRequiredPlayerLances(1);\n+\n+        // do an appropriate allied force if the contract calls for it\n+        // do any attached or integrated units\n+        setAlliedForceModifier(scenario, contract);\n+        setAttachedUnitsModifier(scenario, contract);\n+        applyFacilityModifiers(scenario, track, coords);\n+        applyGlobalModifiers(scenario, contract.getStratconCampaignState());\n+\n+        if ((contract.getCommandRights() == AtBContract.COM_HOUSE) ||\n+                (contract.getCommandRights() == AtBContract.COM_INTEGRATED)) {\n+            scenario.setRequiredScenario(true);\n+        }\n+\n+        AtBDynamicScenarioFactory.setScenarioModifiers(scenario.getBackingScenario());\n+        scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+        setScenarioDates(track, campaign, scenario);\n+\n+        // register the scenario with the campaign and the track it's generated on\n+        if (forceID > Force.FORCE_NONE) {\n+            scenario.addPrimaryForce(forceID);\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * Apply global scenario modifiers from campaign state to given scenario.\n+     */\n+    private static void applyGlobalModifiers(StratconScenario scenario, StratconCampaignState campaignState) {\n+        for (String modifierName : campaignState.getGlobalScenarioModifiers()) {\n+            AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierName);\n+\n+            if (modifier == null) {\n+                MekHQ.getLogger().error(String.format(\"Modifier %s not found; ignoring\", modifierName));\n+                continue;\n+            }\n+\n+            scenario.getBackingScenario().addScenarioModifier(modifier);\n+        }\n+    }\n+\n+    /**\n+     * Applies scenario modifiers from the current track to the given scenario.\n+     * @param scenario\n+     * @param track\n+     */\n+    private static void applyFacilityModifiers(StratconScenario scenario, StratconTrackState track, StratconCoords coords) {\n+        // loop through all the facilities on the track\n+        // if a facility has been revealed, then it has a 100% chance to apply its effect\n+        // if a facility has not been revealed, then it has a x% chance to apply its effect\n+        // if a facility is on the the scenario coordinates the it applies the local effects\n+        for (StratconCoords facilityCoords : track.getFacilities().keySet()) {\n+            boolean scenarioAtFacility = facilityCoords.equals(coords);\n+            StratconFacility facility = track.getFacilities().get(facilityCoords);\n+            List<String> modifierIDs = new ArrayList<>();\n+\n+            if (scenarioAtFacility) {\n+                modifierIDs = facility.getLocalModifiers();\n+            } else if (facility.isVisible() || (Compute.randomInt(100) <= facility.getAggroRating())) {\n+                modifierIDs = facility.getSharedModifiers();\n+            }\n+\n+            for (String modifierID : modifierIDs) {\n+                AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierID);\n+                if(modifier == null) {\n+                    MekHQ.getLogger().error(String.format(\"Modifier %s not found for facility %s\", modifierID, facility.getFormattedDisplayableName()));\n+                    continue;\n+                }\n+\n+                scenario.getBackingScenario().addScenarioModifier(modifier);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set up the appropriate primary allied force modifier, if any\n+     * @param contract The scenario's contract.\n+     */\n+    private static void setAlliedForceModifier(StratconScenario scenario, AtBContract contract) {\n+        int alliedUnitOdds = 0;\n+\n+        // first, we determine the odds of having an allied unit present\n+        // TODO: move this override out to the contract definition\n+        if (contract.getMissionType() == AtBContract.MT_RELIEFDUTY) {\n+            alliedUnitOdds = 50;\n+        } else {\n+            switch(contract.getCommandRights()) {\n+            case AtBContract.COM_INTEGRATED:\n+                alliedUnitOdds = 50;\n+                break;\n+            case AtBContract.COM_HOUSE:\n+                alliedUnitOdds = 30;\n+                break;\n+            case AtBContract.COM_LIAISON:\n+                alliedUnitOdds = 10;\n+                break;\n+            }\n+        }\n+\n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+\n+        // if an allied unit is present, then we want to make sure that it's ground units\n+        // for ground battles\n+        if (Compute.randomInt(100) <= alliedUnitOdds) {\n+            if((backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+               (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space)) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_ALLIED_AIR_UNITS));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_ALLIED_GROUND_UNITS));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set the 'attached' units modifier for the current scenario (integrated, house, liaison),\n+     * and make sure we're not deploying ground units to an air scenario\n+     * @param contract The scenario's contract\n+     */\n+    public static void setAttachedUnitsModifier(StratconScenario scenario, AtBContract contract) {\n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+        boolean airBattle = (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+                (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space);\n+\n+        // if we're on cadre duty, we're getting three trainees, period\n+        if (contract.getMissionType() == AtBContract.MT_CADREDUTY) {\n+            if (airBattle) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_TRAINEES_AIR));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_TRAINEES_GROUND));\n+            }\n+            return;\n+        }\n+\n+        // if we're under non-independent command rights, a supervisor may come along\n+        switch (contract.getCommandRights()) {\n+            case AtBContract.COM_INTEGRATED:\n+                if (airBattle) {\n+                    backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_INTEGRATED_UNITS_AIR));\n+                } else {\n+                    backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_INTEGRATED_UNITS_GROUND));\n+                }\n+                break;\n+            case AtBContract.COM_HOUSE:\n+                if (airBattle) {\n+                    backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_HOUSE_CO_AIR));\n+                } else {\n+                    backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_HOUSE_CO_GROUND));\n+                }\n+                break;\n+            case AtBContract.COM_LIAISON:\n+                if (scenario.isRequiredScenario()) {\n+                    if(airBattle) {\n+                        backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_LIAISON_AIR));\n+                    } else {\n+                        backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_LIAISON_GROUND));\n+                    }\n+                }\n+                break;\n+        }\n+    }\n+\n+    /**\n+     * Worker function that sets scenario deploy/battle/return dates based on the track's properties and current campaign date\n+     */\n+    private static void setScenarioDates(StratconTrackState track, Campaign campaign, StratconScenario scenario) {\n+     // set up deployment day, battle day, return day here\n+        // safety code to prevent attempts to generate random int with upper bound of 0 which is apparently illegal\n+        int deploymentDay = track.getDeploymentTime() < 7 ? Compute.randomInt(7 - track.getDeploymentTime()) : 0;\n+        int battleDay = deploymentDay + (track.getDeploymentTime() > 0 ? Compute.randomInt(track.getDeploymentTime()) : 0);\n+        int returnDay = deploymentDay + track.getDeploymentTime();\n+\n+        LocalDate deploymentDate = campaign.getLocalDate();\n+        deploymentDate.plusDays(deploymentDay);\n+        LocalDate battleDate = campaign.getLocalDate();\n+        deploymentDate.plusDays(battleDay);\n+        LocalDate returnDate = campaign.getLocalDate();\n+        returnDate.plusDays(returnDay);\n+\n+        scenario.setDeploymentDate(deploymentDate);\n+        scenario.setActionDate(battleDate);\n+        scenario.setReturnDate(returnDate);\n+    }\n+\n+    /**\n+     * Helper function that determines if the unit type specified in the given scenario force template\n+     * would start out airborne on a ground map (hot dropped units aside)\n+     */\n+    private static boolean unitTypeIsAirborne(ScenarioForceTemplate template) {\n+        int unitType = template.getAllowedUnitType();\n+\n+        return (unitType == UnitType.AERO ||\n+                unitType == UnitType.CONV_FIGHTER ||\n+                unitType == UnitType.DROPSHIP ||\n+                unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_MIX) &&\n+                template.getStartingAltitude() > 0;\n+    }\n+\n+    /**\n+     * Determines whether the force in question has the same primary unit type as the force template.\n+     * @return Whether or not the unit types match.\n+     */\n+    public static boolean forceCompositionMatchesDeclaredUnitType(int primaryUnitType, int unitType, boolean reinforcements) {\n+        // special cases are \"ATB_MIX\" and \"ATB_AERO_MIX\", which encompass multiple unit types\n+        if (unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_MIX) {\n+            // \"AtB mix\" is usually ground units, but air units can sub in\n+            return primaryUnitType == UnitType.MEK ||\n+                    primaryUnitType == UnitType.TANK ||\n+                    primaryUnitType == UnitType.INFANTRY ||\n+                    primaryUnitType == UnitType.BATTLE_ARMOR ||\n+                    primaryUnitType == UnitType.PROTOMEK ||\n+                    primaryUnitType == UnitType.VTOL ||\n+                    (primaryUnitType == UnitType.AERO) && reinforcements ||\n+                    (primaryUnitType == UnitType.CONV_FIGHTER) && reinforcements;\n+        } else if (unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_AERO_MIX) {\n+            return primaryUnitType == UnitType.AERO ||\n+                    primaryUnitType == UnitType.CONV_FIGHTER;\n+        } else {\n+            return primaryUnitType == unitType;\n+        }\n+    }\n+\n+    /**\n+     * This is a set of all force IDs for forces that can be deployed to a scenario.\n+     * @param campaign Current campaign\n+     * @return Set of available force IDs.\n+     */\n+    public static List<Integer> getAvailableForceIDs(Campaign campaign) {\n+        List<Integer> retVal = new ArrayList<>();\n+\n+        // first, we gather a set of all forces that are already deployed to a track so we eliminate those later\n+        Set<Integer> forcesInTracks = new HashSet<>();\n+        for (Contract contract : campaign.getActiveContracts()) {\n+            if(contract instanceof AtBContract) {\n+                for(StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {", "originalCommit": "0244602bac43aacfd804a92250447a67a4fbd75a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNDUwNjczMg==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r604506732", "bodyText": "Bracket, combine", "author": "Windchild292", "createdAt": "2021-03-31T00:00:53Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1291 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.UUID;\n+\n+import megamek.common.Compute;\n+import megamek.common.Minefield;\n+import megamek.common.UnitType;\n+import megamek.common.annotations.Nullable;\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.Utilities;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.ResolveScenarioTracker;\n+import mekhq.campaign.againstTheBot.enums.AtBLanceRole;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.event.StratconDeploymentEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.force.Lance;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier.EventTiming;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.unit.Unit;\n+\n+/**\n+ * This class contains \"rules\" logic for the AtB-Stratcon state\n+ * @author NickAragua\n+ */\n+public class StratconRulesManager {\n+    /**\n+     * What makes a particular lance eligible to be reinforcements for a scenario\n+     * @author NickAragua\n+     */\n+    public enum ReinforcementEligibilityType {\n+        /**\n+         * Nothing\n+         */\n+        None,\n+\n+        /**\n+         * Lance is already deployed to the track\n+         */\n+        ChainedScenario,\n+\n+        /**\n+         * We pay a support point or convert a victory point to a support point\n+         */\n+        SupportPoint,\n+\n+        /**\n+         * The lance's deployment orders are \"Fight\"\n+         */\n+        FightLance\n+    }\n+\n+    /**\n+     * This function potentially generates non-player-initiated scenarios for the given track.\n+     */\n+    public static void generateScenariosForTrack(Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // maps scenarios to force IDs\n+        List<StratconScenario> generatedScenarios = new ArrayList<>();\n+        boolean autoAssignLances = contract.getCommandRights() == AtBContract.COM_INTEGRATED;\n+\n+        // get this list just so we have it available\n+        List<Integer> availableForceIDs = getAvailableForceIDs(campaign);\n+        Map<MapLocation, List<Integer>> sortedAvailableForceIDs = sortForcesByMapType(availableForceIDs, campaign);\n+\n+        // make X rolls, where X is the number of required lances for the track\n+        // that's the chance to spawn a scenario.\n+        // if a scenario occurs, then we pick a random non-deployed lance and use it to drive the opfor generation later\n+        // once we've determined that scenarios occur, we loop through the ones that we generated\n+        // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all\n+        for (int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            // if we haven't already used all the player forces and are required to randomly generate a scenario\n+            if ((availableForceIDs.size() > 0) &&\n+                    (Compute.randomInt(100) <= track.getScenarioOdds())) {\n+                // pick random coordinates and force to drive the scenario\n+                int x = Compute.randomInt(track.getWidth());\n+                int y = Compute.randomInt(track.getHeight());\n+\n+                StratconCoords scenarioCoords = new StratconCoords(x, y);\n+\n+                // if forces are already assigned to these coordinates, use those instead\n+                // of randomly-selected ones\n+                if (track.getAssignedCoordForces().containsKey(scenarioCoords)) {\n+                    StratconScenario scenario = generateScenarioForExistingForces(scenarioCoords,\n+                            track.getAssignedCoordForces().get(scenarioCoords), \n+                            contract, campaign, track);\n+                    generatedScenarios.add(scenario);\n+                    continue;\n+                }\n+                \n+                // otherwise, pick a random force from the avail\n+                int randomForceIndex = Compute.randomInt(availableForceIDs.size());\n+                int randomForceID = availableForceIDs.get(randomForceIndex);\n+                \n+                // remove the force from the available lists so we don't designate it as primary twice\n+                availableForceIDs.remove(randomForceIndex);\n+\n+                // we want to remove the actual int with the value, not the value at the index\n+                sortedAvailableForceIDs.get(MapLocation.AllGroundTerrain).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.LowAtmosphere).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.Space).remove((Integer) randomForceID);\n+\n+                // two scenarios on the same coordinates wind up increasing in size\n+                if (track.getScenarios().containsKey(scenarioCoords)) {\n+                    track.getScenarios().get(scenarioCoords).incrementRequiredPlayerLances();\n+                    assignAppropriateExtraForceToScenario(track.getScenarios().get(scenarioCoords), sortedAvailableForceIDs);\n+                    continue;\n+                }\n+\n+                StratconScenario scenario = setupScenario(scenarioCoords, randomForceID, campaign, contract, track);\n+                generatedScenarios.add(scenario);\n+\n+                // if we're auto-assigning lances, deploy the force to the track as well\n+                if (autoAssignLances) {\n+                    processForceDeployment(scenarioCoords, randomForceID, campaign, track, false);\n+                }\n+            }\n+        }\n+\n+        // if under liaison command, pick a random scenario from the ones generated\n+        // to set as required and attach liaison\n+        if (contract.getCommandRights() == AtBContract.COM_LIAISON) {\n+        \tStratconScenario randomScenario = Utilities.getRandomItem(generatedScenarios);\n+        \trandomScenario.setRequiredScenario(true);\n+            setAttachedUnitsModifier(randomScenario, contract);\n+        }\n+\n+        // now, we loop through all the scenarios we set up\n+        // and generate the opfors / events / etc\n+        // if not auto-assigning lances, we then back out the lance assignments.\n+        for (StratconScenario scenario : generatedScenarios) {\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+\n+            if(!autoAssignLances && !scenario.ignoreForceAutoAssignment()) {\n+                for(int forceID : scenario.getPlayerTemplateForceIDs()) {\n+                    scenario.getBackingScenario().removeForce(forceID);\n+                }\n+\n+                scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                track.addScenario(scenario);\n+            } else {\n+                commitPrimaryForces(campaign, contract, scenario, track);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Given a set of force IDs and coordinates, generate a scenario\n+     * Useful for when we want to generate scenarios \n+     * for forces already deployed to a track\n+     */\n+    public static StratconScenario generateScenarioForExistingForces(StratconCoords scenarioCoords, \n+            Set<Integer> forceIDs, AtBContract contract, Campaign campaign, StratconTrackState track) {\n+        boolean firstForce = true;\n+        StratconScenario scenario = null;\n+        \n+        for (int forceID : forceIDs) {\n+            if (firstForce) {\n+                scenario = setupScenario(scenarioCoords, forceID, campaign, contract, track);\n+                firstForce = false;\n+            } else {\n+                scenario.incrementRequiredPlayerLances();\n+                scenario.addPrimaryForce(forceID);\n+            }\n+        }\n+        \n+        scenario.setIgnoreForceAutoAssignment(true);\n+        return scenario;\n+    }\n+\n+    /**\n+     * Deploys a force to the given coordinates on the given track as a result of explicit player action.\n+     */\n+    public static void deployForceToCoords(StratconCoords coords, int forceID, \n+            Campaign campaign, AtBContract contract, StratconTrackState track, boolean sticky) {\n+        // the following things should happen:\n+        // 1. call to \"process force deployment\", which reveals fog of war in or around the coords, depending on force role\n+        // 2. if coords are a hostile facility, we get a facility mission\n+        // 3. if coords are empty, we *may* get a mission\n+\n+        processForceDeployment(coords, forceID, campaign, track, sticky);\n+\n+        // don't create a scenario on top of allied facilities\n+        StratconFacility facility = track.getFacility(coords);\n+        boolean isNonAlliedFacility = (facility != null) && (facility.getOwner() != ForceAlignment.Allied);\n+        boolean spawnScenario = (facility == null) && (Compute.randomInt(100) <= track.getScenarioOdds());\n+\n+        if (isNonAlliedFacility || spawnScenario) {\n+            StratconScenario scenario = setupScenario(coords, forceID, campaign, contract, track);\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            commitPrimaryForces(campaign, contract, scenario, track);\n+        }\n+    }\n+\n+    /**\n+     * Logic to set up a scenario\n+     */\n+    private static StratconScenario setupScenario(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        StratconScenario scenario = null;\n+\n+        if (track.getFacilities().containsKey(coords)) {\n+            StratconFacility facility = track.getFacility(coords);\n+            boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+            ScenarioTemplate template = StratconScenarioFactory.getFacilityScenario(alliedFacility);\n+            scenario = generateScenario(campaign, contract, track, forceID, coords, template);\n+            setupFacilityScenario(scenario, facility);\n+        } else {\n+            scenario = generateScenario(campaign, contract, track, forceID, coords);\n+\n+            // we may generate a facility scenario randomly - if so, do the facility-related stuff\n+            // and add a new facility to the track\n+            if (scenario.getBackingScenario().getTemplate().isFacilityScenario()) {\n+                StratconFacility facility = scenario.getBackingScenario().getTemplate().isHostileFacility() ?\n+                        StratconFacilityFactory.getRandomHostileFacility() : StratconFacilityFactory.getRandomAlliedFacility();\n+                facility.setVisible(true);\n+                track.addFacility(coords, facility);\n+                setupFacilityScenario(scenario, facility);\n+            }\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * carries out tasks relevant to facility scenarios\n+     */\n+    private static void setupFacilityScenario(StratconScenario scenario, StratconFacility facility) {\n+        // this includes:\n+        // for hostile facilities\n+        // - add a destroy objective (always the option to level the facility)\n+        // - add a capture objective (always the option to capture the facility)\n+        // - if so indicated by parameter, roll a random hostile facility objective and add it if not capture/destroy\n+        // for allied facilities\n+        // - add a defend objective (always the option to defend the facility)\n+        // - if so indicated by parameter, roll a random allied facility objective and add it if not defend\n+        AtBScenarioModifier objectiveModifier = null;\n+        boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+\n+        if (alliedFacility) {\n+            objectiveModifier = AtBScenarioModifier.getRandomAlliedFacilityModifier();\n+        } else {\n+            objectiveModifier = AtBScenarioModifier.getRandomHostileFacilityModifier();\n+        }\n+\n+        if (objectiveModifier != null) {\n+            scenario.getBackingScenario().addScenarioModifier(objectiveModifier);\n+            scenario.getBackingScenario().setName(String.format(\"%s - %s - %s\",\n+                    facility.getFacilityType(), alliedFacility ? \"Allied\" : \"Hostile\", objectiveModifier.getModifierName()));\n+        }\n+\n+        // add the \"fixed\" hostile facility modifiers after the primary ones\n+        if (!alliedFacility) {\n+            for(AtBScenarioModifier modifier : AtBScenarioModifier.getRequiredHostileFacilityModifiers()) {\n+                if(!scenario.getBackingScenario().alreadyHasModifier(modifier)) {\n+                    scenario.getBackingScenario().addScenarioModifier(modifier);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void processFacilityEffects(StratconTrackState track) {\n+        // TODO: these are \"weekly\"? effects that a stratcon facility has on the campaign/track state\n+        // currrently, that's\n+        // supply depot - allied - +1 sp\n+        // supply depot - hostile - +5% BV budget to all scenarios on track (shared modifier, so should be implemented there)\n+        // data center - allied - +1% star league cache contract (don't implement yet, but...)\n+        // data center - hostile - +5% scenario odds in track\n+        // industrial center - allied - all scenarios here have THIS IS COMING OUT OF YOUR PAYCHECK modifier\n+        // orbital defense - allied - sets 'no hostile aircraft' flag for track\n+        // orbital defense - hostile - sets 'no allied aircraft' flag for track\n+        // early warning system - allied - sets 'intercept allied base attacks' flag for track\n+        // early warning system - hostile - sets 'intercept hostile base attacks' flag for track\n+    }\n+\n+    /**\n+     * Process the deployment of a force to the given coordinates on the given track.\n+     */\n+    public static void processForceDeployment(StratconCoords coords, int forceID, \n+            Campaign campaign, StratconTrackState track, boolean sticky) {\n+        track.getRevealedCoords().add(coords);\n+        StratconFacility facility = track.getFacility(coords);\n+        if (facility != null) {\n+            facility.setVisible(true);\n+        }\n+\n+        if (campaign.getLances().get(forceID).getRole() == AtBLanceRole.SCOUTING) {\n+            for(int direction = 0; direction < 6; direction++) {\n+                StratconCoords checkCoords = coords.translate(direction);\n+\n+                facility = track.getFacility(checkCoords);\n+                if(facility != null) {\n+                    facility.setVisible(true);\n+                }\n+\n+                track.getRevealedCoords().add(coords.translate(direction));\n+            }\n+        }\n+\n+        // the force may be located in other places on the track - clear it out\n+        track.unassignForce(forceID);\n+        track.assignForce(forceID, coords, campaign.getLocalDate(), sticky);\n+        MekHQ.triggerEvent(new StratconDeploymentEvent(campaign.getForce(forceID)));\n+    }\n+\n+    /**\n+     * Worker function that processes the effects of deploying a reinforcement force to a scenario\n+     */\n+    public static boolean processReinforcementDeployment(ReinforcementEligibilityType reinforcementType,\n+            StratconCampaignState campaignState, StratconScenario scenario, Campaign campaign) {\n+        // if the force is already deployed to the track, we're done\n+        // if the force is a fight lance or we're using a support point\n+        // if there is an SP to burn, burn it and we're done\n+        // if there is a VP to burn, burn it and we're done\n+        // now, roll 2d6 + lance commander tactics\n+        // 9+ = deploy\n+        // 6+ = deploy, apply negative modifier to scenario\n+        // 2+ = fail to deploy, apply negative modifier to scenario; if fight lance, treat as 6+\n+\n+        if ((reinforcementType == ReinforcementEligibilityType.FightLance) ||\n+                (reinforcementType == ReinforcementEligibilityType.SupportPoint)) {\n+\n+            if (campaignState.getSupportPoints() > 0) {\n+                campaignState.useSupportPoint();\n+                return true;\n+            } else if (campaignState.getVictoryPoints() > 0) {\n+                campaignState.updateVictoryPoints(-1);\n+                return true;\n+            }\n+\n+            int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+            int roll = Compute.d6(2);\n+            int result = roll + tactics;\n+\n+            StringBuilder reportStatus = new StringBuilder();\n+            reportStatus.append(String.format(\"Attempting to reinforce scenario %s without SP/VP, roll 2d6 + %d: %d\",\n+                    scenario.getName(), tactics, result));\n+\n+            // fail to reinforce\n+            if ((result < 6) && (reinforcementType != ReinforcementEligibilityType.FightLance)) {\n+                reportStatus.append(\" - reinforcement attempt failed.\");\n+                campaign.addReport(reportStatus.toString());\n+                return false;\n+            // succeed but get an extra negative event added to the scenario\n+            } else if (result < 9) {\n+                MapLocation mapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+                AtBScenarioModifier scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+\n+                // keep rolling until we get an applicable one\n+                // TODO: have the AtBScenarioModifier sort these out instead for performance?\n+                while (scenarioModifier.getEventTiming() != EventTiming.PostForceGeneration) {\n+                    scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+                }\n+\n+                scenarioModifier.processModifier(scenario.getBackingScenario(), campaign, EventTiming.PostForceGeneration);\n+\n+                reportStatus.append(String.format(\" - reinforcement attempt succeeded; extra negative modifier (%s) applied to scenario.\",\n+                        scenarioModifier.getModifierName()));\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            // succeed without reservation\n+            } else {\n+                reportStatus.append(\" - reinforcement attempt succeeded;\");\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            }\n+        } else if (reinforcementType == ReinforcementEligibilityType.None) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Assigns a force to the scenario such that the majority of the force can be deployed\n+     */\n+    private static void assignAppropriateExtraForceToScenario(StratconScenario scenario,\n+            Map<MapLocation, List<Integer>> sortedAvailableForceIDs) {\n+        // the goal of this function is to avoid assigning ground units to air battles\n+        // and ground units/conventional fighters to space battle\n+\n+        List<MapLocation> mapLocations = new ArrayList<>();\n+        mapLocations.add(MapLocation.Space); // can always add ASFs\n+\n+        MapLocation scenarioMapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+\n+        if (scenarioMapLocation == MapLocation.LowAtmosphere) {\n+            mapLocations.add(MapLocation.LowAtmosphere); // can add conventional fighters to ground or low atmo battles\n+        }\n+\n+        if ((scenarioMapLocation == MapLocation.AllGroundTerrain) ||\n+                (scenarioMapLocation == MapLocation.SpecificGroundTerrain)) {\n+            mapLocations.add(MapLocation.AllGroundTerrain); // can only add ground units to ground battles\n+        }\n+\n+        MapLocation selectedLocation = mapLocations.get(Compute.randomInt(mapLocations.size()));\n+        List<Integer> forceIDs = sortedAvailableForceIDs.get(selectedLocation);\n+        int forceIndex = Compute.randomInt(forceIDs.size());\n+        int forceID = forceIDs.get(forceIndex);\n+        forceIDs.remove(forceIndex);\n+\n+        scenario.addPrimaryForce(forceID);\n+    }\n+\n+    /**\n+     * Worker function that \"locks in\" a scenario -\n+     * Adds it to the campaign so it's visible in the briefing room,\n+     * adds it to the track\n+     *\n+     */\n+    public static void commitPrimaryForces(Campaign campaign, AtBContract contract, StratconScenario scenario, StratconTrackState trackState) {\n+        // order of operations is important here, we need a valid scenario ID prior to adding the scenario to the track.\n+        campaign.addScenario(scenario.getBackingScenario(), contract);\n+        scenario.setBackingScenarioID(scenario.getBackingScenario().getId());\n+        trackState.addScenario(scenario);\n+\n+        // set up dates for the scenario if doesn't have them already\n+        if (scenario.getDeploymentDate() == null) {\n+            scenario.setDeploymentDate(campaign.getLocalDate());\n+        }\n+\n+        if (scenario.getActionDate() == null) {\n+            scenario.setActionDate(campaign.getLocalDate());\n+        }\n+\n+        if(scenario.getReturnDate() == null) {\n+            scenario.setReturnDate(campaign.getLocalDate().plusDays(trackState.getDeploymentTime()));\n+        }\n+\n+        // set the # of rerolls based on the actual lance assigned.\n+        int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+        scenario.getBackingScenario().setRerolls(tactics);\n+        // The number of defensive points available to a force entering a scenario is\n+        // 2 x tactics. By default, those points are spent on conventional minefields.\n+        if (commanderLanceHasDefensiveAssignment(scenario.getBackingScenario(), campaign)) {\n+            scenario.setNumDefensivePoints(tactics * 2);\n+            scenario.updateMinefieldCount(Minefield.TYPE_CONVENTIONAL, tactics * 2);\n+        }\n+\n+        for (int forceID : scenario.getPlayerTemplateForceIDs()) {\n+            Force force = campaign.getForce(forceID);\n+            force.clearScenarioIds(campaign, true);\n+            force.setScenarioId(scenario.getBackingScenarioID());\n+        }\n+\n+        scenario.commitPrimaryForces();\n+    }\n+\n+    /**\n+     * Utility method to determine if the current scenario's force commander\n+     * is on defence\n+     */\n+    private static boolean commanderLanceHasDefensiveAssignment(AtBDynamicScenario scenario, Campaign campaign) {\n+        Unit commanderUnit = scenario.getLanceCommander(campaign).getUnit();\n+        Lance lance = campaign.getLances().get(commanderUnit.getForceId());\n+\n+        if ((lance != null) && (lance.getRole() == AtBLanceRole.DEFENCE)) {\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * A hackish worker function that takes the given list of force IDs and\n+     * separates it into three sets;\n+     * one of forces that can be \"primary\" on a ground map\n+     * one of forces that can be \"primary\" on an atmospheric map\n+     * one of forces that can be \"primary\" in a space map\n+     * @param forceIDs List of force IDs to check\n+     * @return Sorted hash map\n+     */\n+    private static Map<MapLocation, List<Integer>> sortForcesByMapType(List<Integer> forceIDs, Campaign campaign) {\n+        Map<MapLocation, List<Integer>> retVal = new HashMap<>();\n+\n+        retVal.put(MapLocation.AllGroundTerrain, new ArrayList<>());\n+        retVal.put(MapLocation.LowAtmosphere, new ArrayList<>());\n+        retVal.put(MapLocation.Space, new ArrayList<>());\n+\n+        for (int forceID : forceIDs) {\n+            switch(campaign.getForce(forceID).getPrimaryUnitType(campaign)) {\n+            case UnitType.BATTLE_ARMOR:\n+            case UnitType.INFANTRY:\n+            case UnitType.MEK:\n+            case UnitType.TANK:\n+            case UnitType.PROTOMEK:\n+            case UnitType.VTOL:\n+                retVal.get(MapLocation.AllGroundTerrain).add(forceID);\n+                break;\n+            case UnitType.AERO:\n+                retVal.get(MapLocation.Space).add(forceID);\n+                // intentional fallthrough here, ASFs can go to atmospheric maps too\n+            case UnitType.CONV_FIGHTER:\n+                retVal.get(MapLocation.LowAtmosphere).add(forceID);\n+                break;\n+            }\n+        }\n+\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * Determine whether the user should be nagged about unresolved scenarios on AtB Stratcon tracks.\n+     * @param campaign Campaign to check.\n+     * @return An informative string containing the reasons the user was nagged.\n+     */\n+    public static String nagUnresolvedContacts(Campaign campaign) {\n+        StringBuilder sb = new StringBuilder();\n+\n+        // check every track attached to an active contract for unresolved scenarios\n+        // to which the player must deploy forces today\n+        for (Contract contract : campaign.getActiveContracts()) {\n+            if(contract instanceof AtBContract) {\n+                for(StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    for(StratconScenario scenario : track.getScenarios().values()) {\n+                        if(scenario.getCurrentState() == ScenarioState.UNRESOLVED &&\n+                                campaign.getLocalDate().equals(scenario.getDeploymentDate())) {\n+                            // \"scenario name, track name\"\n+                            sb.append(String.format(\"%s, %s\\n\", scenario.getName(), track.getDisplayableName()));\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track.\n+     * Also registers it with the track and campaign.\n+     */\n+    private static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords) {\n+        int unitType = campaign.getForce(forceID).getPrimaryUnitType(campaign);\n+        ScenarioTemplate template = StratconScenarioFactory.getRandomScenario(unitType);\n+        // useful for debugging specific scenario types\n+        //ScenarioTemplate template = StratconScenarioFactory.getSpecificScenario(\"Allied Facility.xml\");\n+\n+        return generateScenario(campaign, contract, track, forceID, coords, template);\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track,\n+     * using the given template. Also registers it with the track and campaign.\n+     */\n+    static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords, ScenarioTemplate template) {\n+        StratconScenario scenario = new StratconScenario();\n+        scenario.setBackingScenario(AtBDynamicScenarioFactory.initializeScenarioFromTemplate(template, contract, campaign));\n+        scenario.setCoords(coords);\n+        \n+        // by default, certain conditions may make this bigger\n+        scenario.setRequiredPlayerLances(1);\n+\n+        // do an appropriate allied force if the contract calls for it\n+        // do any attached or integrated units\n+        setAlliedForceModifier(scenario, contract);\n+        setAttachedUnitsModifier(scenario, contract);\n+        applyFacilityModifiers(scenario, track, coords);\n+        applyGlobalModifiers(scenario, contract.getStratconCampaignState());\n+\n+        if ((contract.getCommandRights() == AtBContract.COM_HOUSE) ||\n+                (contract.getCommandRights() == AtBContract.COM_INTEGRATED)) {\n+            scenario.setRequiredScenario(true);\n+        }\n+\n+        AtBDynamicScenarioFactory.setScenarioModifiers(scenario.getBackingScenario());\n+        scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+        setScenarioDates(track, campaign, scenario);\n+\n+        // register the scenario with the campaign and the track it's generated on\n+        if (forceID > Force.FORCE_NONE) {\n+            scenario.addPrimaryForce(forceID);\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * Apply global scenario modifiers from campaign state to given scenario.\n+     */\n+    private static void applyGlobalModifiers(StratconScenario scenario, StratconCampaignState campaignState) {\n+        for (String modifierName : campaignState.getGlobalScenarioModifiers()) {\n+            AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierName);\n+\n+            if (modifier == null) {\n+                MekHQ.getLogger().error(String.format(\"Modifier %s not found; ignoring\", modifierName));\n+                continue;\n+            }\n+\n+            scenario.getBackingScenario().addScenarioModifier(modifier);\n+        }\n+    }\n+\n+    /**\n+     * Applies scenario modifiers from the current track to the given scenario.\n+     * @param scenario\n+     * @param track\n+     */\n+    private static void applyFacilityModifiers(StratconScenario scenario, StratconTrackState track, StratconCoords coords) {\n+        // loop through all the facilities on the track\n+        // if a facility has been revealed, then it has a 100% chance to apply its effect\n+        // if a facility has not been revealed, then it has a x% chance to apply its effect\n+        // if a facility is on the the scenario coordinates the it applies the local effects\n+        for (StratconCoords facilityCoords : track.getFacilities().keySet()) {\n+            boolean scenarioAtFacility = facilityCoords.equals(coords);\n+            StratconFacility facility = track.getFacilities().get(facilityCoords);\n+            List<String> modifierIDs = new ArrayList<>();\n+\n+            if (scenarioAtFacility) {\n+                modifierIDs = facility.getLocalModifiers();\n+            } else if (facility.isVisible() || (Compute.randomInt(100) <= facility.getAggroRating())) {\n+                modifierIDs = facility.getSharedModifiers();\n+            }\n+\n+            for (String modifierID : modifierIDs) {\n+                AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierID);\n+                if(modifier == null) {\n+                    MekHQ.getLogger().error(String.format(\"Modifier %s not found for facility %s\", modifierID, facility.getFormattedDisplayableName()));\n+                    continue;\n+                }\n+\n+                scenario.getBackingScenario().addScenarioModifier(modifier);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set up the appropriate primary allied force modifier, if any\n+     * @param contract The scenario's contract.\n+     */\n+    private static void setAlliedForceModifier(StratconScenario scenario, AtBContract contract) {\n+        int alliedUnitOdds = 0;\n+\n+        // first, we determine the odds of having an allied unit present\n+        // TODO: move this override out to the contract definition\n+        if (contract.getMissionType() == AtBContract.MT_RELIEFDUTY) {\n+            alliedUnitOdds = 50;\n+        } else {\n+            switch(contract.getCommandRights()) {\n+            case AtBContract.COM_INTEGRATED:\n+                alliedUnitOdds = 50;\n+                break;\n+            case AtBContract.COM_HOUSE:\n+                alliedUnitOdds = 30;\n+                break;\n+            case AtBContract.COM_LIAISON:\n+                alliedUnitOdds = 10;\n+                break;\n+            }\n+        }\n+\n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+\n+        // if an allied unit is present, then we want to make sure that it's ground units\n+        // for ground battles\n+        if (Compute.randomInt(100) <= alliedUnitOdds) {\n+            if((backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+               (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space)) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_ALLIED_AIR_UNITS));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_ALLIED_GROUND_UNITS));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set the 'attached' units modifier for the current scenario (integrated, house, liaison),\n+     * and make sure we're not deploying ground units to an air scenario\n+     * @param contract The scenario's contract\n+     */\n+    public static void setAttachedUnitsModifier(StratconScenario scenario, AtBContract contract) {\n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+        boolean airBattle = (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+                (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space);\n+\n+        // if we're on cadre duty, we're getting three trainees, period\n+        if (contract.getMissionType() == AtBContract.MT_CADREDUTY) {\n+            if (airBattle) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_TRAINEES_AIR));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_TRAINEES_GROUND));\n+            }\n+            return;\n+        }\n+\n+        // if we're under non-independent command rights, a supervisor may come along\n+        switch (contract.getCommandRights()) {\n+            case AtBContract.COM_INTEGRATED:\n+                if (airBattle) {\n+                    backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_INTEGRATED_UNITS_AIR));\n+                } else {\n+                    backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_INTEGRATED_UNITS_GROUND));\n+                }\n+                break;\n+            case AtBContract.COM_HOUSE:\n+                if (airBattle) {\n+                    backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_HOUSE_CO_AIR));\n+                } else {\n+                    backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_HOUSE_CO_GROUND));\n+                }\n+                break;\n+            case AtBContract.COM_LIAISON:\n+                if (scenario.isRequiredScenario()) {\n+                    if(airBattle) {\n+                        backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_LIAISON_AIR));\n+                    } else {\n+                        backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_LIAISON_GROUND));\n+                    }\n+                }\n+                break;\n+        }\n+    }\n+\n+    /**\n+     * Worker function that sets scenario deploy/battle/return dates based on the track's properties and current campaign date\n+     */\n+    private static void setScenarioDates(StratconTrackState track, Campaign campaign, StratconScenario scenario) {\n+     // set up deployment day, battle day, return day here\n+        // safety code to prevent attempts to generate random int with upper bound of 0 which is apparently illegal\n+        int deploymentDay = track.getDeploymentTime() < 7 ? Compute.randomInt(7 - track.getDeploymentTime()) : 0;\n+        int battleDay = deploymentDay + (track.getDeploymentTime() > 0 ? Compute.randomInt(track.getDeploymentTime()) : 0);\n+        int returnDay = deploymentDay + track.getDeploymentTime();\n+\n+        LocalDate deploymentDate = campaign.getLocalDate();\n+        deploymentDate.plusDays(deploymentDay);\n+        LocalDate battleDate = campaign.getLocalDate();\n+        deploymentDate.plusDays(battleDay);\n+        LocalDate returnDate = campaign.getLocalDate();\n+        returnDate.plusDays(returnDay);\n+\n+        scenario.setDeploymentDate(deploymentDate);\n+        scenario.setActionDate(battleDate);\n+        scenario.setReturnDate(returnDate);\n+    }\n+\n+    /**\n+     * Helper function that determines if the unit type specified in the given scenario force template\n+     * would start out airborne on a ground map (hot dropped units aside)\n+     */\n+    private static boolean unitTypeIsAirborne(ScenarioForceTemplate template) {\n+        int unitType = template.getAllowedUnitType();\n+\n+        return (unitType == UnitType.AERO ||\n+                unitType == UnitType.CONV_FIGHTER ||\n+                unitType == UnitType.DROPSHIP ||\n+                unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_MIX) &&\n+                template.getStartingAltitude() > 0;\n+    }\n+\n+    /**\n+     * Determines whether the force in question has the same primary unit type as the force template.\n+     * @return Whether or not the unit types match.\n+     */\n+    public static boolean forceCompositionMatchesDeclaredUnitType(int primaryUnitType, int unitType, boolean reinforcements) {\n+        // special cases are \"ATB_MIX\" and \"ATB_AERO_MIX\", which encompass multiple unit types\n+        if (unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_MIX) {\n+            // \"AtB mix\" is usually ground units, but air units can sub in\n+            return primaryUnitType == UnitType.MEK ||\n+                    primaryUnitType == UnitType.TANK ||\n+                    primaryUnitType == UnitType.INFANTRY ||\n+                    primaryUnitType == UnitType.BATTLE_ARMOR ||\n+                    primaryUnitType == UnitType.PROTOMEK ||\n+                    primaryUnitType == UnitType.VTOL ||\n+                    (primaryUnitType == UnitType.AERO) && reinforcements ||\n+                    (primaryUnitType == UnitType.CONV_FIGHTER) && reinforcements;\n+        } else if (unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_AERO_MIX) {\n+            return primaryUnitType == UnitType.AERO ||\n+                    primaryUnitType == UnitType.CONV_FIGHTER;\n+        } else {\n+            return primaryUnitType == unitType;\n+        }\n+    }\n+\n+    /**\n+     * This is a set of all force IDs for forces that can be deployed to a scenario.\n+     * @param campaign Current campaign\n+     * @return Set of available force IDs.\n+     */\n+    public static List<Integer> getAvailableForceIDs(Campaign campaign) {\n+        List<Integer> retVal = new ArrayList<>();\n+\n+        // first, we gather a set of all forces that are already deployed to a track so we eliminate those later\n+        Set<Integer> forcesInTracks = new HashSet<>();\n+        for (Contract contract : campaign.getActiveContracts()) {\n+            if(contract instanceof AtBContract) {\n+                for(StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    forcesInTracks.addAll(track.getAssignedForceCoords().keySet());\n+                }\n+            }\n+        }\n+\n+        // now, we get all the forces that qualify as \"lances\", and filter out those that are\n+        // deployed to a scenario and not in a track already\n+        for (int key : campaign.getLances().keySet()) {\n+            Force force = campaign.getForce(key);\n+            if (force != null &&\n+                    !force.isDeployed() &&\n+                    !forcesInTracks.contains(force.getId())) {", "originalCommit": "0244602bac43aacfd804a92250447a67a4fbd75a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNDUwNjg2Nw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r604506867", "bodyText": "can merge lines easiely", "author": "Windchild292", "createdAt": "2021-03-31T00:01:15Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1291 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.UUID;\n+\n+import megamek.common.Compute;\n+import megamek.common.Minefield;\n+import megamek.common.UnitType;\n+import megamek.common.annotations.Nullable;\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.Utilities;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.ResolveScenarioTracker;\n+import mekhq.campaign.againstTheBot.enums.AtBLanceRole;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.event.StratconDeploymentEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.force.Lance;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier.EventTiming;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.unit.Unit;\n+\n+/**\n+ * This class contains \"rules\" logic for the AtB-Stratcon state\n+ * @author NickAragua\n+ */\n+public class StratconRulesManager {\n+    /**\n+     * What makes a particular lance eligible to be reinforcements for a scenario\n+     * @author NickAragua\n+     */\n+    public enum ReinforcementEligibilityType {\n+        /**\n+         * Nothing\n+         */\n+        None,\n+\n+        /**\n+         * Lance is already deployed to the track\n+         */\n+        ChainedScenario,\n+\n+        /**\n+         * We pay a support point or convert a victory point to a support point\n+         */\n+        SupportPoint,\n+\n+        /**\n+         * The lance's deployment orders are \"Fight\"\n+         */\n+        FightLance\n+    }\n+\n+    /**\n+     * This function potentially generates non-player-initiated scenarios for the given track.\n+     */\n+    public static void generateScenariosForTrack(Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // maps scenarios to force IDs\n+        List<StratconScenario> generatedScenarios = new ArrayList<>();\n+        boolean autoAssignLances = contract.getCommandRights() == AtBContract.COM_INTEGRATED;\n+\n+        // get this list just so we have it available\n+        List<Integer> availableForceIDs = getAvailableForceIDs(campaign);\n+        Map<MapLocation, List<Integer>> sortedAvailableForceIDs = sortForcesByMapType(availableForceIDs, campaign);\n+\n+        // make X rolls, where X is the number of required lances for the track\n+        // that's the chance to spawn a scenario.\n+        // if a scenario occurs, then we pick a random non-deployed lance and use it to drive the opfor generation later\n+        // once we've determined that scenarios occur, we loop through the ones that we generated\n+        // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all\n+        for (int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            // if we haven't already used all the player forces and are required to randomly generate a scenario\n+            if ((availableForceIDs.size() > 0) &&\n+                    (Compute.randomInt(100) <= track.getScenarioOdds())) {\n+                // pick random coordinates and force to drive the scenario\n+                int x = Compute.randomInt(track.getWidth());\n+                int y = Compute.randomInt(track.getHeight());\n+\n+                StratconCoords scenarioCoords = new StratconCoords(x, y);\n+\n+                // if forces are already assigned to these coordinates, use those instead\n+                // of randomly-selected ones\n+                if (track.getAssignedCoordForces().containsKey(scenarioCoords)) {\n+                    StratconScenario scenario = generateScenarioForExistingForces(scenarioCoords,\n+                            track.getAssignedCoordForces().get(scenarioCoords), \n+                            contract, campaign, track);\n+                    generatedScenarios.add(scenario);\n+                    continue;\n+                }\n+                \n+                // otherwise, pick a random force from the avail\n+                int randomForceIndex = Compute.randomInt(availableForceIDs.size());\n+                int randomForceID = availableForceIDs.get(randomForceIndex);\n+                \n+                // remove the force from the available lists so we don't designate it as primary twice\n+                availableForceIDs.remove(randomForceIndex);\n+\n+                // we want to remove the actual int with the value, not the value at the index\n+                sortedAvailableForceIDs.get(MapLocation.AllGroundTerrain).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.LowAtmosphere).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.Space).remove((Integer) randomForceID);\n+\n+                // two scenarios on the same coordinates wind up increasing in size\n+                if (track.getScenarios().containsKey(scenarioCoords)) {\n+                    track.getScenarios().get(scenarioCoords).incrementRequiredPlayerLances();\n+                    assignAppropriateExtraForceToScenario(track.getScenarios().get(scenarioCoords), sortedAvailableForceIDs);\n+                    continue;\n+                }\n+\n+                StratconScenario scenario = setupScenario(scenarioCoords, randomForceID, campaign, contract, track);\n+                generatedScenarios.add(scenario);\n+\n+                // if we're auto-assigning lances, deploy the force to the track as well\n+                if (autoAssignLances) {\n+                    processForceDeployment(scenarioCoords, randomForceID, campaign, track, false);\n+                }\n+            }\n+        }\n+\n+        // if under liaison command, pick a random scenario from the ones generated\n+        // to set as required and attach liaison\n+        if (contract.getCommandRights() == AtBContract.COM_LIAISON) {\n+        \tStratconScenario randomScenario = Utilities.getRandomItem(generatedScenarios);\n+        \trandomScenario.setRequiredScenario(true);\n+            setAttachedUnitsModifier(randomScenario, contract);\n+        }\n+\n+        // now, we loop through all the scenarios we set up\n+        // and generate the opfors / events / etc\n+        // if not auto-assigning lances, we then back out the lance assignments.\n+        for (StratconScenario scenario : generatedScenarios) {\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+\n+            if(!autoAssignLances && !scenario.ignoreForceAutoAssignment()) {\n+                for(int forceID : scenario.getPlayerTemplateForceIDs()) {\n+                    scenario.getBackingScenario().removeForce(forceID);\n+                }\n+\n+                scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                track.addScenario(scenario);\n+            } else {\n+                commitPrimaryForces(campaign, contract, scenario, track);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Given a set of force IDs and coordinates, generate a scenario\n+     * Useful for when we want to generate scenarios \n+     * for forces already deployed to a track\n+     */\n+    public static StratconScenario generateScenarioForExistingForces(StratconCoords scenarioCoords, \n+            Set<Integer> forceIDs, AtBContract contract, Campaign campaign, StratconTrackState track) {\n+        boolean firstForce = true;\n+        StratconScenario scenario = null;\n+        \n+        for (int forceID : forceIDs) {\n+            if (firstForce) {\n+                scenario = setupScenario(scenarioCoords, forceID, campaign, contract, track);\n+                firstForce = false;\n+            } else {\n+                scenario.incrementRequiredPlayerLances();\n+                scenario.addPrimaryForce(forceID);\n+            }\n+        }\n+        \n+        scenario.setIgnoreForceAutoAssignment(true);\n+        return scenario;\n+    }\n+\n+    /**\n+     * Deploys a force to the given coordinates on the given track as a result of explicit player action.\n+     */\n+    public static void deployForceToCoords(StratconCoords coords, int forceID, \n+            Campaign campaign, AtBContract contract, StratconTrackState track, boolean sticky) {\n+        // the following things should happen:\n+        // 1. call to \"process force deployment\", which reveals fog of war in or around the coords, depending on force role\n+        // 2. if coords are a hostile facility, we get a facility mission\n+        // 3. if coords are empty, we *may* get a mission\n+\n+        processForceDeployment(coords, forceID, campaign, track, sticky);\n+\n+        // don't create a scenario on top of allied facilities\n+        StratconFacility facility = track.getFacility(coords);\n+        boolean isNonAlliedFacility = (facility != null) && (facility.getOwner() != ForceAlignment.Allied);\n+        boolean spawnScenario = (facility == null) && (Compute.randomInt(100) <= track.getScenarioOdds());\n+\n+        if (isNonAlliedFacility || spawnScenario) {\n+            StratconScenario scenario = setupScenario(coords, forceID, campaign, contract, track);\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            commitPrimaryForces(campaign, contract, scenario, track);\n+        }\n+    }\n+\n+    /**\n+     * Logic to set up a scenario\n+     */\n+    private static StratconScenario setupScenario(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        StratconScenario scenario = null;\n+\n+        if (track.getFacilities().containsKey(coords)) {\n+            StratconFacility facility = track.getFacility(coords);\n+            boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+            ScenarioTemplate template = StratconScenarioFactory.getFacilityScenario(alliedFacility);\n+            scenario = generateScenario(campaign, contract, track, forceID, coords, template);\n+            setupFacilityScenario(scenario, facility);\n+        } else {\n+            scenario = generateScenario(campaign, contract, track, forceID, coords);\n+\n+            // we may generate a facility scenario randomly - if so, do the facility-related stuff\n+            // and add a new facility to the track\n+            if (scenario.getBackingScenario().getTemplate().isFacilityScenario()) {\n+                StratconFacility facility = scenario.getBackingScenario().getTemplate().isHostileFacility() ?\n+                        StratconFacilityFactory.getRandomHostileFacility() : StratconFacilityFactory.getRandomAlliedFacility();\n+                facility.setVisible(true);\n+                track.addFacility(coords, facility);\n+                setupFacilityScenario(scenario, facility);\n+            }\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * carries out tasks relevant to facility scenarios\n+     */\n+    private static void setupFacilityScenario(StratconScenario scenario, StratconFacility facility) {\n+        // this includes:\n+        // for hostile facilities\n+        // - add a destroy objective (always the option to level the facility)\n+        // - add a capture objective (always the option to capture the facility)\n+        // - if so indicated by parameter, roll a random hostile facility objective and add it if not capture/destroy\n+        // for allied facilities\n+        // - add a defend objective (always the option to defend the facility)\n+        // - if so indicated by parameter, roll a random allied facility objective and add it if not defend\n+        AtBScenarioModifier objectiveModifier = null;\n+        boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+\n+        if (alliedFacility) {\n+            objectiveModifier = AtBScenarioModifier.getRandomAlliedFacilityModifier();\n+        } else {\n+            objectiveModifier = AtBScenarioModifier.getRandomHostileFacilityModifier();\n+        }\n+\n+        if (objectiveModifier != null) {\n+            scenario.getBackingScenario().addScenarioModifier(objectiveModifier);\n+            scenario.getBackingScenario().setName(String.format(\"%s - %s - %s\",\n+                    facility.getFacilityType(), alliedFacility ? \"Allied\" : \"Hostile\", objectiveModifier.getModifierName()));\n+        }\n+\n+        // add the \"fixed\" hostile facility modifiers after the primary ones\n+        if (!alliedFacility) {\n+            for(AtBScenarioModifier modifier : AtBScenarioModifier.getRequiredHostileFacilityModifiers()) {\n+                if(!scenario.getBackingScenario().alreadyHasModifier(modifier)) {\n+                    scenario.getBackingScenario().addScenarioModifier(modifier);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void processFacilityEffects(StratconTrackState track) {\n+        // TODO: these are \"weekly\"? effects that a stratcon facility has on the campaign/track state\n+        // currrently, that's\n+        // supply depot - allied - +1 sp\n+        // supply depot - hostile - +5% BV budget to all scenarios on track (shared modifier, so should be implemented there)\n+        // data center - allied - +1% star league cache contract (don't implement yet, but...)\n+        // data center - hostile - +5% scenario odds in track\n+        // industrial center - allied - all scenarios here have THIS IS COMING OUT OF YOUR PAYCHECK modifier\n+        // orbital defense - allied - sets 'no hostile aircraft' flag for track\n+        // orbital defense - hostile - sets 'no allied aircraft' flag for track\n+        // early warning system - allied - sets 'intercept allied base attacks' flag for track\n+        // early warning system - hostile - sets 'intercept hostile base attacks' flag for track\n+    }\n+\n+    /**\n+     * Process the deployment of a force to the given coordinates on the given track.\n+     */\n+    public static void processForceDeployment(StratconCoords coords, int forceID, \n+            Campaign campaign, StratconTrackState track, boolean sticky) {\n+        track.getRevealedCoords().add(coords);\n+        StratconFacility facility = track.getFacility(coords);\n+        if (facility != null) {\n+            facility.setVisible(true);\n+        }\n+\n+        if (campaign.getLances().get(forceID).getRole() == AtBLanceRole.SCOUTING) {\n+            for(int direction = 0; direction < 6; direction++) {\n+                StratconCoords checkCoords = coords.translate(direction);\n+\n+                facility = track.getFacility(checkCoords);\n+                if(facility != null) {\n+                    facility.setVisible(true);\n+                }\n+\n+                track.getRevealedCoords().add(coords.translate(direction));\n+            }\n+        }\n+\n+        // the force may be located in other places on the track - clear it out\n+        track.unassignForce(forceID);\n+        track.assignForce(forceID, coords, campaign.getLocalDate(), sticky);\n+        MekHQ.triggerEvent(new StratconDeploymentEvent(campaign.getForce(forceID)));\n+    }\n+\n+    /**\n+     * Worker function that processes the effects of deploying a reinforcement force to a scenario\n+     */\n+    public static boolean processReinforcementDeployment(ReinforcementEligibilityType reinforcementType,\n+            StratconCampaignState campaignState, StratconScenario scenario, Campaign campaign) {\n+        // if the force is already deployed to the track, we're done\n+        // if the force is a fight lance or we're using a support point\n+        // if there is an SP to burn, burn it and we're done\n+        // if there is a VP to burn, burn it and we're done\n+        // now, roll 2d6 + lance commander tactics\n+        // 9+ = deploy\n+        // 6+ = deploy, apply negative modifier to scenario\n+        // 2+ = fail to deploy, apply negative modifier to scenario; if fight lance, treat as 6+\n+\n+        if ((reinforcementType == ReinforcementEligibilityType.FightLance) ||\n+                (reinforcementType == ReinforcementEligibilityType.SupportPoint)) {\n+\n+            if (campaignState.getSupportPoints() > 0) {\n+                campaignState.useSupportPoint();\n+                return true;\n+            } else if (campaignState.getVictoryPoints() > 0) {\n+                campaignState.updateVictoryPoints(-1);\n+                return true;\n+            }\n+\n+            int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+            int roll = Compute.d6(2);\n+            int result = roll + tactics;\n+\n+            StringBuilder reportStatus = new StringBuilder();\n+            reportStatus.append(String.format(\"Attempting to reinforce scenario %s without SP/VP, roll 2d6 + %d: %d\",\n+                    scenario.getName(), tactics, result));\n+\n+            // fail to reinforce\n+            if ((result < 6) && (reinforcementType != ReinforcementEligibilityType.FightLance)) {\n+                reportStatus.append(\" - reinforcement attempt failed.\");\n+                campaign.addReport(reportStatus.toString());\n+                return false;\n+            // succeed but get an extra negative event added to the scenario\n+            } else if (result < 9) {\n+                MapLocation mapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+                AtBScenarioModifier scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+\n+                // keep rolling until we get an applicable one\n+                // TODO: have the AtBScenarioModifier sort these out instead for performance?\n+                while (scenarioModifier.getEventTiming() != EventTiming.PostForceGeneration) {\n+                    scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+                }\n+\n+                scenarioModifier.processModifier(scenario.getBackingScenario(), campaign, EventTiming.PostForceGeneration);\n+\n+                reportStatus.append(String.format(\" - reinforcement attempt succeeded; extra negative modifier (%s) applied to scenario.\",\n+                        scenarioModifier.getModifierName()));\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            // succeed without reservation\n+            } else {\n+                reportStatus.append(\" - reinforcement attempt succeeded;\");\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            }\n+        } else if (reinforcementType == ReinforcementEligibilityType.None) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Assigns a force to the scenario such that the majority of the force can be deployed\n+     */\n+    private static void assignAppropriateExtraForceToScenario(StratconScenario scenario,\n+            Map<MapLocation, List<Integer>> sortedAvailableForceIDs) {\n+        // the goal of this function is to avoid assigning ground units to air battles\n+        // and ground units/conventional fighters to space battle\n+\n+        List<MapLocation> mapLocations = new ArrayList<>();\n+        mapLocations.add(MapLocation.Space); // can always add ASFs\n+\n+        MapLocation scenarioMapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+\n+        if (scenarioMapLocation == MapLocation.LowAtmosphere) {\n+            mapLocations.add(MapLocation.LowAtmosphere); // can add conventional fighters to ground or low atmo battles\n+        }\n+\n+        if ((scenarioMapLocation == MapLocation.AllGroundTerrain) ||\n+                (scenarioMapLocation == MapLocation.SpecificGroundTerrain)) {\n+            mapLocations.add(MapLocation.AllGroundTerrain); // can only add ground units to ground battles\n+        }\n+\n+        MapLocation selectedLocation = mapLocations.get(Compute.randomInt(mapLocations.size()));\n+        List<Integer> forceIDs = sortedAvailableForceIDs.get(selectedLocation);\n+        int forceIndex = Compute.randomInt(forceIDs.size());\n+        int forceID = forceIDs.get(forceIndex);\n+        forceIDs.remove(forceIndex);\n+\n+        scenario.addPrimaryForce(forceID);\n+    }\n+\n+    /**\n+     * Worker function that \"locks in\" a scenario -\n+     * Adds it to the campaign so it's visible in the briefing room,\n+     * adds it to the track\n+     *\n+     */\n+    public static void commitPrimaryForces(Campaign campaign, AtBContract contract, StratconScenario scenario, StratconTrackState trackState) {\n+        // order of operations is important here, we need a valid scenario ID prior to adding the scenario to the track.\n+        campaign.addScenario(scenario.getBackingScenario(), contract);\n+        scenario.setBackingScenarioID(scenario.getBackingScenario().getId());\n+        trackState.addScenario(scenario);\n+\n+        // set up dates for the scenario if doesn't have them already\n+        if (scenario.getDeploymentDate() == null) {\n+            scenario.setDeploymentDate(campaign.getLocalDate());\n+        }\n+\n+        if (scenario.getActionDate() == null) {\n+            scenario.setActionDate(campaign.getLocalDate());\n+        }\n+\n+        if(scenario.getReturnDate() == null) {\n+            scenario.setReturnDate(campaign.getLocalDate().plusDays(trackState.getDeploymentTime()));\n+        }\n+\n+        // set the # of rerolls based on the actual lance assigned.\n+        int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+        scenario.getBackingScenario().setRerolls(tactics);\n+        // The number of defensive points available to a force entering a scenario is\n+        // 2 x tactics. By default, those points are spent on conventional minefields.\n+        if (commanderLanceHasDefensiveAssignment(scenario.getBackingScenario(), campaign)) {\n+            scenario.setNumDefensivePoints(tactics * 2);\n+            scenario.updateMinefieldCount(Minefield.TYPE_CONVENTIONAL, tactics * 2);\n+        }\n+\n+        for (int forceID : scenario.getPlayerTemplateForceIDs()) {\n+            Force force = campaign.getForce(forceID);\n+            force.clearScenarioIds(campaign, true);\n+            force.setScenarioId(scenario.getBackingScenarioID());\n+        }\n+\n+        scenario.commitPrimaryForces();\n+    }\n+\n+    /**\n+     * Utility method to determine if the current scenario's force commander\n+     * is on defence\n+     */\n+    private static boolean commanderLanceHasDefensiveAssignment(AtBDynamicScenario scenario, Campaign campaign) {\n+        Unit commanderUnit = scenario.getLanceCommander(campaign).getUnit();\n+        Lance lance = campaign.getLances().get(commanderUnit.getForceId());\n+\n+        if ((lance != null) && (lance.getRole() == AtBLanceRole.DEFENCE)) {\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * A hackish worker function that takes the given list of force IDs and\n+     * separates it into three sets;\n+     * one of forces that can be \"primary\" on a ground map\n+     * one of forces that can be \"primary\" on an atmospheric map\n+     * one of forces that can be \"primary\" in a space map\n+     * @param forceIDs List of force IDs to check\n+     * @return Sorted hash map\n+     */\n+    private static Map<MapLocation, List<Integer>> sortForcesByMapType(List<Integer> forceIDs, Campaign campaign) {\n+        Map<MapLocation, List<Integer>> retVal = new HashMap<>();\n+\n+        retVal.put(MapLocation.AllGroundTerrain, new ArrayList<>());\n+        retVal.put(MapLocation.LowAtmosphere, new ArrayList<>());\n+        retVal.put(MapLocation.Space, new ArrayList<>());\n+\n+        for (int forceID : forceIDs) {\n+            switch(campaign.getForce(forceID).getPrimaryUnitType(campaign)) {\n+            case UnitType.BATTLE_ARMOR:\n+            case UnitType.INFANTRY:\n+            case UnitType.MEK:\n+            case UnitType.TANK:\n+            case UnitType.PROTOMEK:\n+            case UnitType.VTOL:\n+                retVal.get(MapLocation.AllGroundTerrain).add(forceID);\n+                break;\n+            case UnitType.AERO:\n+                retVal.get(MapLocation.Space).add(forceID);\n+                // intentional fallthrough here, ASFs can go to atmospheric maps too\n+            case UnitType.CONV_FIGHTER:\n+                retVal.get(MapLocation.LowAtmosphere).add(forceID);\n+                break;\n+            }\n+        }\n+\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * Determine whether the user should be nagged about unresolved scenarios on AtB Stratcon tracks.\n+     * @param campaign Campaign to check.\n+     * @return An informative string containing the reasons the user was nagged.\n+     */\n+    public static String nagUnresolvedContacts(Campaign campaign) {\n+        StringBuilder sb = new StringBuilder();\n+\n+        // check every track attached to an active contract for unresolved scenarios\n+        // to which the player must deploy forces today\n+        for (Contract contract : campaign.getActiveContracts()) {\n+            if(contract instanceof AtBContract) {\n+                for(StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    for(StratconScenario scenario : track.getScenarios().values()) {\n+                        if(scenario.getCurrentState() == ScenarioState.UNRESOLVED &&\n+                                campaign.getLocalDate().equals(scenario.getDeploymentDate())) {\n+                            // \"scenario name, track name\"\n+                            sb.append(String.format(\"%s, %s\\n\", scenario.getName(), track.getDisplayableName()));\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track.\n+     * Also registers it with the track and campaign.\n+     */\n+    private static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords) {\n+        int unitType = campaign.getForce(forceID).getPrimaryUnitType(campaign);\n+        ScenarioTemplate template = StratconScenarioFactory.getRandomScenario(unitType);\n+        // useful for debugging specific scenario types\n+        //ScenarioTemplate template = StratconScenarioFactory.getSpecificScenario(\"Allied Facility.xml\");\n+\n+        return generateScenario(campaign, contract, track, forceID, coords, template);\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track,\n+     * using the given template. Also registers it with the track and campaign.\n+     */\n+    static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords, ScenarioTemplate template) {\n+        StratconScenario scenario = new StratconScenario();\n+        scenario.setBackingScenario(AtBDynamicScenarioFactory.initializeScenarioFromTemplate(template, contract, campaign));\n+        scenario.setCoords(coords);\n+        \n+        // by default, certain conditions may make this bigger\n+        scenario.setRequiredPlayerLances(1);\n+\n+        // do an appropriate allied force if the contract calls for it\n+        // do any attached or integrated units\n+        setAlliedForceModifier(scenario, contract);\n+        setAttachedUnitsModifier(scenario, contract);\n+        applyFacilityModifiers(scenario, track, coords);\n+        applyGlobalModifiers(scenario, contract.getStratconCampaignState());\n+\n+        if ((contract.getCommandRights() == AtBContract.COM_HOUSE) ||\n+                (contract.getCommandRights() == AtBContract.COM_INTEGRATED)) {\n+            scenario.setRequiredScenario(true);\n+        }\n+\n+        AtBDynamicScenarioFactory.setScenarioModifiers(scenario.getBackingScenario());\n+        scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+        setScenarioDates(track, campaign, scenario);\n+\n+        // register the scenario with the campaign and the track it's generated on\n+        if (forceID > Force.FORCE_NONE) {\n+            scenario.addPrimaryForce(forceID);\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * Apply global scenario modifiers from campaign state to given scenario.\n+     */\n+    private static void applyGlobalModifiers(StratconScenario scenario, StratconCampaignState campaignState) {\n+        for (String modifierName : campaignState.getGlobalScenarioModifiers()) {\n+            AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierName);\n+\n+            if (modifier == null) {\n+                MekHQ.getLogger().error(String.format(\"Modifier %s not found; ignoring\", modifierName));\n+                continue;\n+            }\n+\n+            scenario.getBackingScenario().addScenarioModifier(modifier);\n+        }\n+    }\n+\n+    /**\n+     * Applies scenario modifiers from the current track to the given scenario.\n+     * @param scenario\n+     * @param track\n+     */\n+    private static void applyFacilityModifiers(StratconScenario scenario, StratconTrackState track, StratconCoords coords) {\n+        // loop through all the facilities on the track\n+        // if a facility has been revealed, then it has a 100% chance to apply its effect\n+        // if a facility has not been revealed, then it has a x% chance to apply its effect\n+        // if a facility is on the the scenario coordinates the it applies the local effects\n+        for (StratconCoords facilityCoords : track.getFacilities().keySet()) {\n+            boolean scenarioAtFacility = facilityCoords.equals(coords);\n+            StratconFacility facility = track.getFacilities().get(facilityCoords);\n+            List<String> modifierIDs = new ArrayList<>();\n+\n+            if (scenarioAtFacility) {\n+                modifierIDs = facility.getLocalModifiers();\n+            } else if (facility.isVisible() || (Compute.randomInt(100) <= facility.getAggroRating())) {\n+                modifierIDs = facility.getSharedModifiers();\n+            }\n+\n+            for (String modifierID : modifierIDs) {\n+                AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierID);\n+                if(modifier == null) {\n+                    MekHQ.getLogger().error(String.format(\"Modifier %s not found for facility %s\", modifierID, facility.getFormattedDisplayableName()));\n+                    continue;\n+                }\n+\n+                scenario.getBackingScenario().addScenarioModifier(modifier);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set up the appropriate primary allied force modifier, if any\n+     * @param contract The scenario's contract.\n+     */\n+    private static void setAlliedForceModifier(StratconScenario scenario, AtBContract contract) {\n+        int alliedUnitOdds = 0;\n+\n+        // first, we determine the odds of having an allied unit present\n+        // TODO: move this override out to the contract definition\n+        if (contract.getMissionType() == AtBContract.MT_RELIEFDUTY) {\n+            alliedUnitOdds = 50;\n+        } else {\n+            switch(contract.getCommandRights()) {\n+            case AtBContract.COM_INTEGRATED:\n+                alliedUnitOdds = 50;\n+                break;\n+            case AtBContract.COM_HOUSE:\n+                alliedUnitOdds = 30;\n+                break;\n+            case AtBContract.COM_LIAISON:\n+                alliedUnitOdds = 10;\n+                break;\n+            }\n+        }\n+\n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+\n+        // if an allied unit is present, then we want to make sure that it's ground units\n+        // for ground battles\n+        if (Compute.randomInt(100) <= alliedUnitOdds) {\n+            if((backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+               (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space)) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_ALLIED_AIR_UNITS));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_ALLIED_GROUND_UNITS));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set the 'attached' units modifier for the current scenario (integrated, house, liaison),\n+     * and make sure we're not deploying ground units to an air scenario\n+     * @param contract The scenario's contract\n+     */\n+    public static void setAttachedUnitsModifier(StratconScenario scenario, AtBContract contract) {\n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+        boolean airBattle = (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+                (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space);\n+\n+        // if we're on cadre duty, we're getting three trainees, period\n+        if (contract.getMissionType() == AtBContract.MT_CADREDUTY) {\n+            if (airBattle) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_TRAINEES_AIR));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_TRAINEES_GROUND));\n+            }\n+            return;\n+        }\n+\n+        // if we're under non-independent command rights, a supervisor may come along\n+        switch (contract.getCommandRights()) {\n+            case AtBContract.COM_INTEGRATED:\n+                if (airBattle) {\n+                    backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_INTEGRATED_UNITS_AIR));\n+                } else {\n+                    backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_INTEGRATED_UNITS_GROUND));\n+                }\n+                break;\n+            case AtBContract.COM_HOUSE:\n+                if (airBattle) {\n+                    backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_HOUSE_CO_AIR));\n+                } else {\n+                    backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_HOUSE_CO_GROUND));\n+                }\n+                break;\n+            case AtBContract.COM_LIAISON:\n+                if (scenario.isRequiredScenario()) {\n+                    if(airBattle) {\n+                        backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_LIAISON_AIR));\n+                    } else {\n+                        backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_LIAISON_GROUND));\n+                    }\n+                }\n+                break;\n+        }\n+    }\n+\n+    /**\n+     * Worker function that sets scenario deploy/battle/return dates based on the track's properties and current campaign date\n+     */\n+    private static void setScenarioDates(StratconTrackState track, Campaign campaign, StratconScenario scenario) {\n+     // set up deployment day, battle day, return day here\n+        // safety code to prevent attempts to generate random int with upper bound of 0 which is apparently illegal\n+        int deploymentDay = track.getDeploymentTime() < 7 ? Compute.randomInt(7 - track.getDeploymentTime()) : 0;\n+        int battleDay = deploymentDay + (track.getDeploymentTime() > 0 ? Compute.randomInt(track.getDeploymentTime()) : 0);\n+        int returnDay = deploymentDay + track.getDeploymentTime();\n+\n+        LocalDate deploymentDate = campaign.getLocalDate();\n+        deploymentDate.plusDays(deploymentDay);\n+        LocalDate battleDate = campaign.getLocalDate();\n+        deploymentDate.plusDays(battleDay);\n+        LocalDate returnDate = campaign.getLocalDate();\n+        returnDate.plusDays(returnDay);\n+\n+        scenario.setDeploymentDate(deploymentDate);\n+        scenario.setActionDate(battleDate);\n+        scenario.setReturnDate(returnDate);\n+    }\n+\n+    /**\n+     * Helper function that determines if the unit type specified in the given scenario force template\n+     * would start out airborne on a ground map (hot dropped units aside)\n+     */\n+    private static boolean unitTypeIsAirborne(ScenarioForceTemplate template) {\n+        int unitType = template.getAllowedUnitType();\n+\n+        return (unitType == UnitType.AERO ||\n+                unitType == UnitType.CONV_FIGHTER ||\n+                unitType == UnitType.DROPSHIP ||\n+                unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_MIX) &&\n+                template.getStartingAltitude() > 0;\n+    }\n+\n+    /**\n+     * Determines whether the force in question has the same primary unit type as the force template.\n+     * @return Whether or not the unit types match.\n+     */\n+    public static boolean forceCompositionMatchesDeclaredUnitType(int primaryUnitType, int unitType, boolean reinforcements) {\n+        // special cases are \"ATB_MIX\" and \"ATB_AERO_MIX\", which encompass multiple unit types\n+        if (unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_MIX) {\n+            // \"AtB mix\" is usually ground units, but air units can sub in\n+            return primaryUnitType == UnitType.MEK ||\n+                    primaryUnitType == UnitType.TANK ||\n+                    primaryUnitType == UnitType.INFANTRY ||\n+                    primaryUnitType == UnitType.BATTLE_ARMOR ||\n+                    primaryUnitType == UnitType.PROTOMEK ||\n+                    primaryUnitType == UnitType.VTOL ||\n+                    (primaryUnitType == UnitType.AERO) && reinforcements ||\n+                    (primaryUnitType == UnitType.CONV_FIGHTER) && reinforcements;\n+        } else if (unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_AERO_MIX) {\n+            return primaryUnitType == UnitType.AERO ||\n+                    primaryUnitType == UnitType.CONV_FIGHTER;\n+        } else {\n+            return primaryUnitType == unitType;\n+        }\n+    }\n+\n+    /**\n+     * This is a set of all force IDs for forces that can be deployed to a scenario.\n+     * @param campaign Current campaign\n+     * @return Set of available force IDs.\n+     */\n+    public static List<Integer> getAvailableForceIDs(Campaign campaign) {\n+        List<Integer> retVal = new ArrayList<>();\n+\n+        // first, we gather a set of all forces that are already deployed to a track so we eliminate those later\n+        Set<Integer> forcesInTracks = new HashSet<>();\n+        for (Contract contract : campaign.getActiveContracts()) {\n+            if(contract instanceof AtBContract) {\n+                for(StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    forcesInTracks.addAll(track.getAssignedForceCoords().keySet());\n+                }\n+            }\n+        }\n+\n+        // now, we get all the forces that qualify as \"lances\", and filter out those that are\n+        // deployed to a scenario and not in a track already\n+        for (int key : campaign.getLances().keySet()) {\n+            Force force = campaign.getForce(key);\n+            if (force != null &&\n+                    !force.isDeployed() &&\n+                    !forcesInTracks.contains(force.getId())) {\n+                retVal.add(force.getId());\n+            }\n+        }\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * This is a list of all force IDs for forces that can be deployed to a scenario in the given force template\n+     * a) have not been assigned to a track\n+     * b) are combat-capable\n+     * c) are not deployed to a scenario\n+     * d) if attempting to deploy as reinforcements, haven't already failed to deploy\n+     */\n+    public static List<Integer> getAvailableForceIDs(int unitType, Campaign campaign, StratconTrackState currentTrack,\n+            boolean reinforcements, @Nullable StratconScenario currentScenario) {\n+        List<Integer> retVal = new ArrayList<>();\n+\n+        Set<Integer> forcesInTracks = new HashSet<>();\n+        // assemble a set of all force IDs that are currently assigned to tracks that are not this one\n+        for (Contract contract : campaign.getActiveContracts()) {\n+            if (contract instanceof AtBContract) {\n+                for (StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    if ((track != currentTrack) || !reinforcements) {\n+                        forcesInTracks.addAll(track.getAssignedForceCoords().keySet());\n+                    }\n+                }\n+            }\n+        }\n+        \n+        // if there's an existing scenario and we're doing reinforcements,\n+        // prevent forces that failed to deploy from trying to deploy again\n+        if (reinforcements && (currentScenario != null)) {\n+            forcesInTracks.addAll(currentScenario.getFailedReinforcements());\n+        }\n+\n+        for (int key : campaign.getLances().keySet()) {\n+            Force force = campaign.getForce(key);\n+\n+            if (force == null) {\n+                continue;\n+            }\n+\n+            int primaryUnitType = force.getPrimaryUnitType(campaign);\n+            if (!force.isDeployed() &&\n+                    (force.getScenarioId() <= 0) &&\n+                    !force.getUnits().isEmpty() &&\n+                    !forcesInTracks.contains(force.getId()) &&\n+                    forceCompositionMatchesDeclaredUnitType(primaryUnitType, unitType, reinforcements)) {", "originalCommit": "0244602bac43aacfd804a92250447a67a4fbd75a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNjU0MjU2NA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r606542564", "bodyText": "I can, but there are so many clauses that it's more readable to have them on a separate line.", "author": "NickAragua", "createdAt": "2021-04-03T00:47:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNDUwNjg2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNDUwNjk1Mw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r604506953", "bodyText": "Easily merge lines", "author": "Windchild292", "createdAt": "2021-03-31T00:01:28Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1291 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.UUID;\n+\n+import megamek.common.Compute;\n+import megamek.common.Minefield;\n+import megamek.common.UnitType;\n+import megamek.common.annotations.Nullable;\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.Utilities;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.ResolveScenarioTracker;\n+import mekhq.campaign.againstTheBot.enums.AtBLanceRole;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.event.StratconDeploymentEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.force.Lance;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier.EventTiming;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.unit.Unit;\n+\n+/**\n+ * This class contains \"rules\" logic for the AtB-Stratcon state\n+ * @author NickAragua\n+ */\n+public class StratconRulesManager {\n+    /**\n+     * What makes a particular lance eligible to be reinforcements for a scenario\n+     * @author NickAragua\n+     */\n+    public enum ReinforcementEligibilityType {\n+        /**\n+         * Nothing\n+         */\n+        None,\n+\n+        /**\n+         * Lance is already deployed to the track\n+         */\n+        ChainedScenario,\n+\n+        /**\n+         * We pay a support point or convert a victory point to a support point\n+         */\n+        SupportPoint,\n+\n+        /**\n+         * The lance's deployment orders are \"Fight\"\n+         */\n+        FightLance\n+    }\n+\n+    /**\n+     * This function potentially generates non-player-initiated scenarios for the given track.\n+     */\n+    public static void generateScenariosForTrack(Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // maps scenarios to force IDs\n+        List<StratconScenario> generatedScenarios = new ArrayList<>();\n+        boolean autoAssignLances = contract.getCommandRights() == AtBContract.COM_INTEGRATED;\n+\n+        // get this list just so we have it available\n+        List<Integer> availableForceIDs = getAvailableForceIDs(campaign);\n+        Map<MapLocation, List<Integer>> sortedAvailableForceIDs = sortForcesByMapType(availableForceIDs, campaign);\n+\n+        // make X rolls, where X is the number of required lances for the track\n+        // that's the chance to spawn a scenario.\n+        // if a scenario occurs, then we pick a random non-deployed lance and use it to drive the opfor generation later\n+        // once we've determined that scenarios occur, we loop through the ones that we generated\n+        // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all\n+        for (int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            // if we haven't already used all the player forces and are required to randomly generate a scenario\n+            if ((availableForceIDs.size() > 0) &&\n+                    (Compute.randomInt(100) <= track.getScenarioOdds())) {\n+                // pick random coordinates and force to drive the scenario\n+                int x = Compute.randomInt(track.getWidth());\n+                int y = Compute.randomInt(track.getHeight());\n+\n+                StratconCoords scenarioCoords = new StratconCoords(x, y);\n+\n+                // if forces are already assigned to these coordinates, use those instead\n+                // of randomly-selected ones\n+                if (track.getAssignedCoordForces().containsKey(scenarioCoords)) {\n+                    StratconScenario scenario = generateScenarioForExistingForces(scenarioCoords,\n+                            track.getAssignedCoordForces().get(scenarioCoords), \n+                            contract, campaign, track);\n+                    generatedScenarios.add(scenario);\n+                    continue;\n+                }\n+                \n+                // otherwise, pick a random force from the avail\n+                int randomForceIndex = Compute.randomInt(availableForceIDs.size());\n+                int randomForceID = availableForceIDs.get(randomForceIndex);\n+                \n+                // remove the force from the available lists so we don't designate it as primary twice\n+                availableForceIDs.remove(randomForceIndex);\n+\n+                // we want to remove the actual int with the value, not the value at the index\n+                sortedAvailableForceIDs.get(MapLocation.AllGroundTerrain).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.LowAtmosphere).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.Space).remove((Integer) randomForceID);\n+\n+                // two scenarios on the same coordinates wind up increasing in size\n+                if (track.getScenarios().containsKey(scenarioCoords)) {\n+                    track.getScenarios().get(scenarioCoords).incrementRequiredPlayerLances();\n+                    assignAppropriateExtraForceToScenario(track.getScenarios().get(scenarioCoords), sortedAvailableForceIDs);\n+                    continue;\n+                }\n+\n+                StratconScenario scenario = setupScenario(scenarioCoords, randomForceID, campaign, contract, track);\n+                generatedScenarios.add(scenario);\n+\n+                // if we're auto-assigning lances, deploy the force to the track as well\n+                if (autoAssignLances) {\n+                    processForceDeployment(scenarioCoords, randomForceID, campaign, track, false);\n+                }\n+            }\n+        }\n+\n+        // if under liaison command, pick a random scenario from the ones generated\n+        // to set as required and attach liaison\n+        if (contract.getCommandRights() == AtBContract.COM_LIAISON) {\n+        \tStratconScenario randomScenario = Utilities.getRandomItem(generatedScenarios);\n+        \trandomScenario.setRequiredScenario(true);\n+            setAttachedUnitsModifier(randomScenario, contract);\n+        }\n+\n+        // now, we loop through all the scenarios we set up\n+        // and generate the opfors / events / etc\n+        // if not auto-assigning lances, we then back out the lance assignments.\n+        for (StratconScenario scenario : generatedScenarios) {\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+\n+            if(!autoAssignLances && !scenario.ignoreForceAutoAssignment()) {\n+                for(int forceID : scenario.getPlayerTemplateForceIDs()) {\n+                    scenario.getBackingScenario().removeForce(forceID);\n+                }\n+\n+                scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                track.addScenario(scenario);\n+            } else {\n+                commitPrimaryForces(campaign, contract, scenario, track);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Given a set of force IDs and coordinates, generate a scenario\n+     * Useful for when we want to generate scenarios \n+     * for forces already deployed to a track\n+     */\n+    public static StratconScenario generateScenarioForExistingForces(StratconCoords scenarioCoords, \n+            Set<Integer> forceIDs, AtBContract contract, Campaign campaign, StratconTrackState track) {\n+        boolean firstForce = true;\n+        StratconScenario scenario = null;\n+        \n+        for (int forceID : forceIDs) {\n+            if (firstForce) {\n+                scenario = setupScenario(scenarioCoords, forceID, campaign, contract, track);\n+                firstForce = false;\n+            } else {\n+                scenario.incrementRequiredPlayerLances();\n+                scenario.addPrimaryForce(forceID);\n+            }\n+        }\n+        \n+        scenario.setIgnoreForceAutoAssignment(true);\n+        return scenario;\n+    }\n+\n+    /**\n+     * Deploys a force to the given coordinates on the given track as a result of explicit player action.\n+     */\n+    public static void deployForceToCoords(StratconCoords coords, int forceID, \n+            Campaign campaign, AtBContract contract, StratconTrackState track, boolean sticky) {\n+        // the following things should happen:\n+        // 1. call to \"process force deployment\", which reveals fog of war in or around the coords, depending on force role\n+        // 2. if coords are a hostile facility, we get a facility mission\n+        // 3. if coords are empty, we *may* get a mission\n+\n+        processForceDeployment(coords, forceID, campaign, track, sticky);\n+\n+        // don't create a scenario on top of allied facilities\n+        StratconFacility facility = track.getFacility(coords);\n+        boolean isNonAlliedFacility = (facility != null) && (facility.getOwner() != ForceAlignment.Allied);\n+        boolean spawnScenario = (facility == null) && (Compute.randomInt(100) <= track.getScenarioOdds());\n+\n+        if (isNonAlliedFacility || spawnScenario) {\n+            StratconScenario scenario = setupScenario(coords, forceID, campaign, contract, track);\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            commitPrimaryForces(campaign, contract, scenario, track);\n+        }\n+    }\n+\n+    /**\n+     * Logic to set up a scenario\n+     */\n+    private static StratconScenario setupScenario(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        StratconScenario scenario = null;\n+\n+        if (track.getFacilities().containsKey(coords)) {\n+            StratconFacility facility = track.getFacility(coords);\n+            boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+            ScenarioTemplate template = StratconScenarioFactory.getFacilityScenario(alliedFacility);\n+            scenario = generateScenario(campaign, contract, track, forceID, coords, template);\n+            setupFacilityScenario(scenario, facility);\n+        } else {\n+            scenario = generateScenario(campaign, contract, track, forceID, coords);\n+\n+            // we may generate a facility scenario randomly - if so, do the facility-related stuff\n+            // and add a new facility to the track\n+            if (scenario.getBackingScenario().getTemplate().isFacilityScenario()) {\n+                StratconFacility facility = scenario.getBackingScenario().getTemplate().isHostileFacility() ?\n+                        StratconFacilityFactory.getRandomHostileFacility() : StratconFacilityFactory.getRandomAlliedFacility();\n+                facility.setVisible(true);\n+                track.addFacility(coords, facility);\n+                setupFacilityScenario(scenario, facility);\n+            }\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * carries out tasks relevant to facility scenarios\n+     */\n+    private static void setupFacilityScenario(StratconScenario scenario, StratconFacility facility) {\n+        // this includes:\n+        // for hostile facilities\n+        // - add a destroy objective (always the option to level the facility)\n+        // - add a capture objective (always the option to capture the facility)\n+        // - if so indicated by parameter, roll a random hostile facility objective and add it if not capture/destroy\n+        // for allied facilities\n+        // - add a defend objective (always the option to defend the facility)\n+        // - if so indicated by parameter, roll a random allied facility objective and add it if not defend\n+        AtBScenarioModifier objectiveModifier = null;\n+        boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+\n+        if (alliedFacility) {\n+            objectiveModifier = AtBScenarioModifier.getRandomAlliedFacilityModifier();\n+        } else {\n+            objectiveModifier = AtBScenarioModifier.getRandomHostileFacilityModifier();\n+        }\n+\n+        if (objectiveModifier != null) {\n+            scenario.getBackingScenario().addScenarioModifier(objectiveModifier);\n+            scenario.getBackingScenario().setName(String.format(\"%s - %s - %s\",\n+                    facility.getFacilityType(), alliedFacility ? \"Allied\" : \"Hostile\", objectiveModifier.getModifierName()));\n+        }\n+\n+        // add the \"fixed\" hostile facility modifiers after the primary ones\n+        if (!alliedFacility) {\n+            for(AtBScenarioModifier modifier : AtBScenarioModifier.getRequiredHostileFacilityModifiers()) {\n+                if(!scenario.getBackingScenario().alreadyHasModifier(modifier)) {\n+                    scenario.getBackingScenario().addScenarioModifier(modifier);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void processFacilityEffects(StratconTrackState track) {\n+        // TODO: these are \"weekly\"? effects that a stratcon facility has on the campaign/track state\n+        // currrently, that's\n+        // supply depot - allied - +1 sp\n+        // supply depot - hostile - +5% BV budget to all scenarios on track (shared modifier, so should be implemented there)\n+        // data center - allied - +1% star league cache contract (don't implement yet, but...)\n+        // data center - hostile - +5% scenario odds in track\n+        // industrial center - allied - all scenarios here have THIS IS COMING OUT OF YOUR PAYCHECK modifier\n+        // orbital defense - allied - sets 'no hostile aircraft' flag for track\n+        // orbital defense - hostile - sets 'no allied aircraft' flag for track\n+        // early warning system - allied - sets 'intercept allied base attacks' flag for track\n+        // early warning system - hostile - sets 'intercept hostile base attacks' flag for track\n+    }\n+\n+    /**\n+     * Process the deployment of a force to the given coordinates on the given track.\n+     */\n+    public static void processForceDeployment(StratconCoords coords, int forceID, \n+            Campaign campaign, StratconTrackState track, boolean sticky) {\n+        track.getRevealedCoords().add(coords);\n+        StratconFacility facility = track.getFacility(coords);\n+        if (facility != null) {\n+            facility.setVisible(true);\n+        }\n+\n+        if (campaign.getLances().get(forceID).getRole() == AtBLanceRole.SCOUTING) {\n+            for(int direction = 0; direction < 6; direction++) {\n+                StratconCoords checkCoords = coords.translate(direction);\n+\n+                facility = track.getFacility(checkCoords);\n+                if(facility != null) {\n+                    facility.setVisible(true);\n+                }\n+\n+                track.getRevealedCoords().add(coords.translate(direction));\n+            }\n+        }\n+\n+        // the force may be located in other places on the track - clear it out\n+        track.unassignForce(forceID);\n+        track.assignForce(forceID, coords, campaign.getLocalDate(), sticky);\n+        MekHQ.triggerEvent(new StratconDeploymentEvent(campaign.getForce(forceID)));\n+    }\n+\n+    /**\n+     * Worker function that processes the effects of deploying a reinforcement force to a scenario\n+     */\n+    public static boolean processReinforcementDeployment(ReinforcementEligibilityType reinforcementType,\n+            StratconCampaignState campaignState, StratconScenario scenario, Campaign campaign) {\n+        // if the force is already deployed to the track, we're done\n+        // if the force is a fight lance or we're using a support point\n+        // if there is an SP to burn, burn it and we're done\n+        // if there is a VP to burn, burn it and we're done\n+        // now, roll 2d6 + lance commander tactics\n+        // 9+ = deploy\n+        // 6+ = deploy, apply negative modifier to scenario\n+        // 2+ = fail to deploy, apply negative modifier to scenario; if fight lance, treat as 6+\n+\n+        if ((reinforcementType == ReinforcementEligibilityType.FightLance) ||\n+                (reinforcementType == ReinforcementEligibilityType.SupportPoint)) {\n+\n+            if (campaignState.getSupportPoints() > 0) {\n+                campaignState.useSupportPoint();\n+                return true;\n+            } else if (campaignState.getVictoryPoints() > 0) {\n+                campaignState.updateVictoryPoints(-1);\n+                return true;\n+            }\n+\n+            int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+            int roll = Compute.d6(2);\n+            int result = roll + tactics;\n+\n+            StringBuilder reportStatus = new StringBuilder();\n+            reportStatus.append(String.format(\"Attempting to reinforce scenario %s without SP/VP, roll 2d6 + %d: %d\",\n+                    scenario.getName(), tactics, result));\n+\n+            // fail to reinforce\n+            if ((result < 6) && (reinforcementType != ReinforcementEligibilityType.FightLance)) {\n+                reportStatus.append(\" - reinforcement attempt failed.\");\n+                campaign.addReport(reportStatus.toString());\n+                return false;\n+            // succeed but get an extra negative event added to the scenario\n+            } else if (result < 9) {\n+                MapLocation mapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+                AtBScenarioModifier scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+\n+                // keep rolling until we get an applicable one\n+                // TODO: have the AtBScenarioModifier sort these out instead for performance?\n+                while (scenarioModifier.getEventTiming() != EventTiming.PostForceGeneration) {\n+                    scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+                }\n+\n+                scenarioModifier.processModifier(scenario.getBackingScenario(), campaign, EventTiming.PostForceGeneration);\n+\n+                reportStatus.append(String.format(\" - reinforcement attempt succeeded; extra negative modifier (%s) applied to scenario.\",\n+                        scenarioModifier.getModifierName()));\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            // succeed without reservation\n+            } else {\n+                reportStatus.append(\" - reinforcement attempt succeeded;\");\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            }\n+        } else if (reinforcementType == ReinforcementEligibilityType.None) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Assigns a force to the scenario such that the majority of the force can be deployed\n+     */\n+    private static void assignAppropriateExtraForceToScenario(StratconScenario scenario,\n+            Map<MapLocation, List<Integer>> sortedAvailableForceIDs) {\n+        // the goal of this function is to avoid assigning ground units to air battles\n+        // and ground units/conventional fighters to space battle\n+\n+        List<MapLocation> mapLocations = new ArrayList<>();\n+        mapLocations.add(MapLocation.Space); // can always add ASFs\n+\n+        MapLocation scenarioMapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+\n+        if (scenarioMapLocation == MapLocation.LowAtmosphere) {\n+            mapLocations.add(MapLocation.LowAtmosphere); // can add conventional fighters to ground or low atmo battles\n+        }\n+\n+        if ((scenarioMapLocation == MapLocation.AllGroundTerrain) ||\n+                (scenarioMapLocation == MapLocation.SpecificGroundTerrain)) {\n+            mapLocations.add(MapLocation.AllGroundTerrain); // can only add ground units to ground battles\n+        }\n+\n+        MapLocation selectedLocation = mapLocations.get(Compute.randomInt(mapLocations.size()));\n+        List<Integer> forceIDs = sortedAvailableForceIDs.get(selectedLocation);\n+        int forceIndex = Compute.randomInt(forceIDs.size());\n+        int forceID = forceIDs.get(forceIndex);\n+        forceIDs.remove(forceIndex);\n+\n+        scenario.addPrimaryForce(forceID);\n+    }\n+\n+    /**\n+     * Worker function that \"locks in\" a scenario -\n+     * Adds it to the campaign so it's visible in the briefing room,\n+     * adds it to the track\n+     *\n+     */\n+    public static void commitPrimaryForces(Campaign campaign, AtBContract contract, StratconScenario scenario, StratconTrackState trackState) {\n+        // order of operations is important here, we need a valid scenario ID prior to adding the scenario to the track.\n+        campaign.addScenario(scenario.getBackingScenario(), contract);\n+        scenario.setBackingScenarioID(scenario.getBackingScenario().getId());\n+        trackState.addScenario(scenario);\n+\n+        // set up dates for the scenario if doesn't have them already\n+        if (scenario.getDeploymentDate() == null) {\n+            scenario.setDeploymentDate(campaign.getLocalDate());\n+        }\n+\n+        if (scenario.getActionDate() == null) {\n+            scenario.setActionDate(campaign.getLocalDate());\n+        }\n+\n+        if(scenario.getReturnDate() == null) {\n+            scenario.setReturnDate(campaign.getLocalDate().plusDays(trackState.getDeploymentTime()));\n+        }\n+\n+        // set the # of rerolls based on the actual lance assigned.\n+        int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+        scenario.getBackingScenario().setRerolls(tactics);\n+        // The number of defensive points available to a force entering a scenario is\n+        // 2 x tactics. By default, those points are spent on conventional minefields.\n+        if (commanderLanceHasDefensiveAssignment(scenario.getBackingScenario(), campaign)) {\n+            scenario.setNumDefensivePoints(tactics * 2);\n+            scenario.updateMinefieldCount(Minefield.TYPE_CONVENTIONAL, tactics * 2);\n+        }\n+\n+        for (int forceID : scenario.getPlayerTemplateForceIDs()) {\n+            Force force = campaign.getForce(forceID);\n+            force.clearScenarioIds(campaign, true);\n+            force.setScenarioId(scenario.getBackingScenarioID());\n+        }\n+\n+        scenario.commitPrimaryForces();\n+    }\n+\n+    /**\n+     * Utility method to determine if the current scenario's force commander\n+     * is on defence\n+     */\n+    private static boolean commanderLanceHasDefensiveAssignment(AtBDynamicScenario scenario, Campaign campaign) {\n+        Unit commanderUnit = scenario.getLanceCommander(campaign).getUnit();\n+        Lance lance = campaign.getLances().get(commanderUnit.getForceId());\n+\n+        if ((lance != null) && (lance.getRole() == AtBLanceRole.DEFENCE)) {\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * A hackish worker function that takes the given list of force IDs and\n+     * separates it into three sets;\n+     * one of forces that can be \"primary\" on a ground map\n+     * one of forces that can be \"primary\" on an atmospheric map\n+     * one of forces that can be \"primary\" in a space map\n+     * @param forceIDs List of force IDs to check\n+     * @return Sorted hash map\n+     */\n+    private static Map<MapLocation, List<Integer>> sortForcesByMapType(List<Integer> forceIDs, Campaign campaign) {\n+        Map<MapLocation, List<Integer>> retVal = new HashMap<>();\n+\n+        retVal.put(MapLocation.AllGroundTerrain, new ArrayList<>());\n+        retVal.put(MapLocation.LowAtmosphere, new ArrayList<>());\n+        retVal.put(MapLocation.Space, new ArrayList<>());\n+\n+        for (int forceID : forceIDs) {\n+            switch(campaign.getForce(forceID).getPrimaryUnitType(campaign)) {\n+            case UnitType.BATTLE_ARMOR:\n+            case UnitType.INFANTRY:\n+            case UnitType.MEK:\n+            case UnitType.TANK:\n+            case UnitType.PROTOMEK:\n+            case UnitType.VTOL:\n+                retVal.get(MapLocation.AllGroundTerrain).add(forceID);\n+                break;\n+            case UnitType.AERO:\n+                retVal.get(MapLocation.Space).add(forceID);\n+                // intentional fallthrough here, ASFs can go to atmospheric maps too\n+            case UnitType.CONV_FIGHTER:\n+                retVal.get(MapLocation.LowAtmosphere).add(forceID);\n+                break;\n+            }\n+        }\n+\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * Determine whether the user should be nagged about unresolved scenarios on AtB Stratcon tracks.\n+     * @param campaign Campaign to check.\n+     * @return An informative string containing the reasons the user was nagged.\n+     */\n+    public static String nagUnresolvedContacts(Campaign campaign) {\n+        StringBuilder sb = new StringBuilder();\n+\n+        // check every track attached to an active contract for unresolved scenarios\n+        // to which the player must deploy forces today\n+        for (Contract contract : campaign.getActiveContracts()) {\n+            if(contract instanceof AtBContract) {\n+                for(StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    for(StratconScenario scenario : track.getScenarios().values()) {\n+                        if(scenario.getCurrentState() == ScenarioState.UNRESOLVED &&\n+                                campaign.getLocalDate().equals(scenario.getDeploymentDate())) {\n+                            // \"scenario name, track name\"\n+                            sb.append(String.format(\"%s, %s\\n\", scenario.getName(), track.getDisplayableName()));\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track.\n+     * Also registers it with the track and campaign.\n+     */\n+    private static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords) {\n+        int unitType = campaign.getForce(forceID).getPrimaryUnitType(campaign);\n+        ScenarioTemplate template = StratconScenarioFactory.getRandomScenario(unitType);\n+        // useful for debugging specific scenario types\n+        //ScenarioTemplate template = StratconScenarioFactory.getSpecificScenario(\"Allied Facility.xml\");\n+\n+        return generateScenario(campaign, contract, track, forceID, coords, template);\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track,\n+     * using the given template. Also registers it with the track and campaign.\n+     */\n+    static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords, ScenarioTemplate template) {\n+        StratconScenario scenario = new StratconScenario();\n+        scenario.setBackingScenario(AtBDynamicScenarioFactory.initializeScenarioFromTemplate(template, contract, campaign));\n+        scenario.setCoords(coords);\n+        \n+        // by default, certain conditions may make this bigger\n+        scenario.setRequiredPlayerLances(1);\n+\n+        // do an appropriate allied force if the contract calls for it\n+        // do any attached or integrated units\n+        setAlliedForceModifier(scenario, contract);\n+        setAttachedUnitsModifier(scenario, contract);\n+        applyFacilityModifiers(scenario, track, coords);\n+        applyGlobalModifiers(scenario, contract.getStratconCampaignState());\n+\n+        if ((contract.getCommandRights() == AtBContract.COM_HOUSE) ||\n+                (contract.getCommandRights() == AtBContract.COM_INTEGRATED)) {\n+            scenario.setRequiredScenario(true);\n+        }\n+\n+        AtBDynamicScenarioFactory.setScenarioModifiers(scenario.getBackingScenario());\n+        scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+        setScenarioDates(track, campaign, scenario);\n+\n+        // register the scenario with the campaign and the track it's generated on\n+        if (forceID > Force.FORCE_NONE) {\n+            scenario.addPrimaryForce(forceID);\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * Apply global scenario modifiers from campaign state to given scenario.\n+     */\n+    private static void applyGlobalModifiers(StratconScenario scenario, StratconCampaignState campaignState) {\n+        for (String modifierName : campaignState.getGlobalScenarioModifiers()) {\n+            AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierName);\n+\n+            if (modifier == null) {\n+                MekHQ.getLogger().error(String.format(\"Modifier %s not found; ignoring\", modifierName));\n+                continue;\n+            }\n+\n+            scenario.getBackingScenario().addScenarioModifier(modifier);\n+        }\n+    }\n+\n+    /**\n+     * Applies scenario modifiers from the current track to the given scenario.\n+     * @param scenario\n+     * @param track\n+     */\n+    private static void applyFacilityModifiers(StratconScenario scenario, StratconTrackState track, StratconCoords coords) {\n+        // loop through all the facilities on the track\n+        // if a facility has been revealed, then it has a 100% chance to apply its effect\n+        // if a facility has not been revealed, then it has a x% chance to apply its effect\n+        // if a facility is on the the scenario coordinates the it applies the local effects\n+        for (StratconCoords facilityCoords : track.getFacilities().keySet()) {\n+            boolean scenarioAtFacility = facilityCoords.equals(coords);\n+            StratconFacility facility = track.getFacilities().get(facilityCoords);\n+            List<String> modifierIDs = new ArrayList<>();\n+\n+            if (scenarioAtFacility) {\n+                modifierIDs = facility.getLocalModifiers();\n+            } else if (facility.isVisible() || (Compute.randomInt(100) <= facility.getAggroRating())) {\n+                modifierIDs = facility.getSharedModifiers();\n+            }\n+\n+            for (String modifierID : modifierIDs) {\n+                AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierID);\n+                if(modifier == null) {\n+                    MekHQ.getLogger().error(String.format(\"Modifier %s not found for facility %s\", modifierID, facility.getFormattedDisplayableName()));\n+                    continue;\n+                }\n+\n+                scenario.getBackingScenario().addScenarioModifier(modifier);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set up the appropriate primary allied force modifier, if any\n+     * @param contract The scenario's contract.\n+     */\n+    private static void setAlliedForceModifier(StratconScenario scenario, AtBContract contract) {\n+        int alliedUnitOdds = 0;\n+\n+        // first, we determine the odds of having an allied unit present\n+        // TODO: move this override out to the contract definition\n+        if (contract.getMissionType() == AtBContract.MT_RELIEFDUTY) {\n+            alliedUnitOdds = 50;\n+        } else {\n+            switch(contract.getCommandRights()) {\n+            case AtBContract.COM_INTEGRATED:\n+                alliedUnitOdds = 50;\n+                break;\n+            case AtBContract.COM_HOUSE:\n+                alliedUnitOdds = 30;\n+                break;\n+            case AtBContract.COM_LIAISON:\n+                alliedUnitOdds = 10;\n+                break;\n+            }\n+        }\n+\n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+\n+        // if an allied unit is present, then we want to make sure that it's ground units\n+        // for ground battles\n+        if (Compute.randomInt(100) <= alliedUnitOdds) {\n+            if((backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+               (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space)) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_ALLIED_AIR_UNITS));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_ALLIED_GROUND_UNITS));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set the 'attached' units modifier for the current scenario (integrated, house, liaison),\n+     * and make sure we're not deploying ground units to an air scenario\n+     * @param contract The scenario's contract\n+     */\n+    public static void setAttachedUnitsModifier(StratconScenario scenario, AtBContract contract) {\n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+        boolean airBattle = (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+                (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space);\n+\n+        // if we're on cadre duty, we're getting three trainees, period\n+        if (contract.getMissionType() == AtBContract.MT_CADREDUTY) {\n+            if (airBattle) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_TRAINEES_AIR));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_TRAINEES_GROUND));\n+            }\n+            return;\n+        }\n+\n+        // if we're under non-independent command rights, a supervisor may come along\n+        switch (contract.getCommandRights()) {\n+            case AtBContract.COM_INTEGRATED:\n+                if (airBattle) {\n+                    backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_INTEGRATED_UNITS_AIR));\n+                } else {\n+                    backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_INTEGRATED_UNITS_GROUND));\n+                }\n+                break;\n+            case AtBContract.COM_HOUSE:\n+                if (airBattle) {\n+                    backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_HOUSE_CO_AIR));\n+                } else {\n+                    backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_HOUSE_CO_GROUND));\n+                }\n+                break;\n+            case AtBContract.COM_LIAISON:\n+                if (scenario.isRequiredScenario()) {\n+                    if(airBattle) {\n+                        backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_LIAISON_AIR));\n+                    } else {\n+                        backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_LIAISON_GROUND));\n+                    }\n+                }\n+                break;\n+        }\n+    }\n+\n+    /**\n+     * Worker function that sets scenario deploy/battle/return dates based on the track's properties and current campaign date\n+     */\n+    private static void setScenarioDates(StratconTrackState track, Campaign campaign, StratconScenario scenario) {\n+     // set up deployment day, battle day, return day here\n+        // safety code to prevent attempts to generate random int with upper bound of 0 which is apparently illegal\n+        int deploymentDay = track.getDeploymentTime() < 7 ? Compute.randomInt(7 - track.getDeploymentTime()) : 0;\n+        int battleDay = deploymentDay + (track.getDeploymentTime() > 0 ? Compute.randomInt(track.getDeploymentTime()) : 0);\n+        int returnDay = deploymentDay + track.getDeploymentTime();\n+\n+        LocalDate deploymentDate = campaign.getLocalDate();\n+        deploymentDate.plusDays(deploymentDay);\n+        LocalDate battleDate = campaign.getLocalDate();\n+        deploymentDate.plusDays(battleDay);\n+        LocalDate returnDate = campaign.getLocalDate();\n+        returnDate.plusDays(returnDay);\n+\n+        scenario.setDeploymentDate(deploymentDate);\n+        scenario.setActionDate(battleDate);\n+        scenario.setReturnDate(returnDate);\n+    }\n+\n+    /**\n+     * Helper function that determines if the unit type specified in the given scenario force template\n+     * would start out airborne on a ground map (hot dropped units aside)\n+     */\n+    private static boolean unitTypeIsAirborne(ScenarioForceTemplate template) {\n+        int unitType = template.getAllowedUnitType();\n+\n+        return (unitType == UnitType.AERO ||\n+                unitType == UnitType.CONV_FIGHTER ||\n+                unitType == UnitType.DROPSHIP ||\n+                unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_MIX) &&\n+                template.getStartingAltitude() > 0;\n+    }\n+\n+    /**\n+     * Determines whether the force in question has the same primary unit type as the force template.\n+     * @return Whether or not the unit types match.\n+     */\n+    public static boolean forceCompositionMatchesDeclaredUnitType(int primaryUnitType, int unitType, boolean reinforcements) {\n+        // special cases are \"ATB_MIX\" and \"ATB_AERO_MIX\", which encompass multiple unit types\n+        if (unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_MIX) {\n+            // \"AtB mix\" is usually ground units, but air units can sub in\n+            return primaryUnitType == UnitType.MEK ||\n+                    primaryUnitType == UnitType.TANK ||\n+                    primaryUnitType == UnitType.INFANTRY ||\n+                    primaryUnitType == UnitType.BATTLE_ARMOR ||\n+                    primaryUnitType == UnitType.PROTOMEK ||\n+                    primaryUnitType == UnitType.VTOL ||\n+                    (primaryUnitType == UnitType.AERO) && reinforcements ||\n+                    (primaryUnitType == UnitType.CONV_FIGHTER) && reinforcements;\n+        } else if (unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_AERO_MIX) {\n+            return primaryUnitType == UnitType.AERO ||\n+                    primaryUnitType == UnitType.CONV_FIGHTER;\n+        } else {\n+            return primaryUnitType == unitType;\n+        }\n+    }\n+\n+    /**\n+     * This is a set of all force IDs for forces that can be deployed to a scenario.\n+     * @param campaign Current campaign\n+     * @return Set of available force IDs.\n+     */\n+    public static List<Integer> getAvailableForceIDs(Campaign campaign) {\n+        List<Integer> retVal = new ArrayList<>();\n+\n+        // first, we gather a set of all forces that are already deployed to a track so we eliminate those later\n+        Set<Integer> forcesInTracks = new HashSet<>();\n+        for (Contract contract : campaign.getActiveContracts()) {\n+            if(contract instanceof AtBContract) {\n+                for(StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    forcesInTracks.addAll(track.getAssignedForceCoords().keySet());\n+                }\n+            }\n+        }\n+\n+        // now, we get all the forces that qualify as \"lances\", and filter out those that are\n+        // deployed to a scenario and not in a track already\n+        for (int key : campaign.getLances().keySet()) {\n+            Force force = campaign.getForce(key);\n+            if (force != null &&\n+                    !force.isDeployed() &&\n+                    !forcesInTracks.contains(force.getId())) {\n+                retVal.add(force.getId());\n+            }\n+        }\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * This is a list of all force IDs for forces that can be deployed to a scenario in the given force template\n+     * a) have not been assigned to a track\n+     * b) are combat-capable\n+     * c) are not deployed to a scenario\n+     * d) if attempting to deploy as reinforcements, haven't already failed to deploy\n+     */\n+    public static List<Integer> getAvailableForceIDs(int unitType, Campaign campaign, StratconTrackState currentTrack,\n+            boolean reinforcements, @Nullable StratconScenario currentScenario) {\n+        List<Integer> retVal = new ArrayList<>();\n+\n+        Set<Integer> forcesInTracks = new HashSet<>();\n+        // assemble a set of all force IDs that are currently assigned to tracks that are not this one\n+        for (Contract contract : campaign.getActiveContracts()) {\n+            if (contract instanceof AtBContract) {\n+                for (StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    if ((track != currentTrack) || !reinforcements) {\n+                        forcesInTracks.addAll(track.getAssignedForceCoords().keySet());\n+                    }\n+                }\n+            }\n+        }\n+        \n+        // if there's an existing scenario and we're doing reinforcements,\n+        // prevent forces that failed to deploy from trying to deploy again\n+        if (reinforcements && (currentScenario != null)) {\n+            forcesInTracks.addAll(currentScenario.getFailedReinforcements());\n+        }\n+\n+        for (int key : campaign.getLances().keySet()) {\n+            Force force = campaign.getForce(key);\n+\n+            if (force == null) {\n+                continue;\n+            }\n+\n+            int primaryUnitType = force.getPrimaryUnitType(campaign);\n+            if (!force.isDeployed() &&\n+                    (force.getScenarioId() <= 0) &&\n+                    !force.getUnits().isEmpty() &&\n+                    !forcesInTracks.contains(force.getId()) &&\n+                    forceCompositionMatchesDeclaredUnitType(primaryUnitType, unitType, reinforcements)) {\n+                retVal.add(force.getId());\n+            }\n+        }\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * Returns a list of individual units eligible for deployment in scenarios run by \"Defend\" lances\n+     * @return List of unit IDs.\n+     */\n+    public static List<Unit> getEligibleDefensiveUnits(Campaign campaign) {\n+        List<Unit> retVal = new ArrayList<>();\n+\n+        for (Unit u : campaign.getUnits()) {\n+            // \"defensive\" units are infantry, battle armor and (Weisman help you) gun emplacements\n+        \t// and also said unit should be intact/alive/etc\n+        \tboolean isEligibleInfantry = \n+        \t\t\t((u.getEntity().getUnitType() == UnitType.INFANTRY) ||\n+                    (u.getEntity().getUnitType() == UnitType.BATTLE_ARMOR)) &&\n+                    !u.isUnmanned();\n+        \t\n+        \tboolean isEligibleGunEmplacement = u.getEntity().getUnitType() == UnitType.GUN_EMPLACEMENT;\n+        \t\n+        \tif ((isEligibleInfantry || isEligibleGunEmplacement) && \n+            \t\t!u.isDeployed() &&\n+                    !u.isMothballed() &&\n+                    u.isFunctional()) {", "originalCommit": "0244602bac43aacfd804a92250447a67a4fbd75a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNjU0MjkwMQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r606542901", "bodyText": "Again, number of clauses renders it less readable on one line.", "author": "NickAragua", "createdAt": "2021-04-03T00:47:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNDUwNjk1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNDUwNzA2Ng==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r604507066", "bodyText": "Convert to getActiveAtBContracts, spacing", "author": "Windchild292", "createdAt": "2021-03-31T00:01:55Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1291 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.UUID;\n+\n+import megamek.common.Compute;\n+import megamek.common.Minefield;\n+import megamek.common.UnitType;\n+import megamek.common.annotations.Nullable;\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.Utilities;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.ResolveScenarioTracker;\n+import mekhq.campaign.againstTheBot.enums.AtBLanceRole;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.event.StratconDeploymentEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.force.Lance;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier.EventTiming;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.unit.Unit;\n+\n+/**\n+ * This class contains \"rules\" logic for the AtB-Stratcon state\n+ * @author NickAragua\n+ */\n+public class StratconRulesManager {\n+    /**\n+     * What makes a particular lance eligible to be reinforcements for a scenario\n+     * @author NickAragua\n+     */\n+    public enum ReinforcementEligibilityType {\n+        /**\n+         * Nothing\n+         */\n+        None,\n+\n+        /**\n+         * Lance is already deployed to the track\n+         */\n+        ChainedScenario,\n+\n+        /**\n+         * We pay a support point or convert a victory point to a support point\n+         */\n+        SupportPoint,\n+\n+        /**\n+         * The lance's deployment orders are \"Fight\"\n+         */\n+        FightLance\n+    }\n+\n+    /**\n+     * This function potentially generates non-player-initiated scenarios for the given track.\n+     */\n+    public static void generateScenariosForTrack(Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // maps scenarios to force IDs\n+        List<StratconScenario> generatedScenarios = new ArrayList<>();\n+        boolean autoAssignLances = contract.getCommandRights() == AtBContract.COM_INTEGRATED;\n+\n+        // get this list just so we have it available\n+        List<Integer> availableForceIDs = getAvailableForceIDs(campaign);\n+        Map<MapLocation, List<Integer>> sortedAvailableForceIDs = sortForcesByMapType(availableForceIDs, campaign);\n+\n+        // make X rolls, where X is the number of required lances for the track\n+        // that's the chance to spawn a scenario.\n+        // if a scenario occurs, then we pick a random non-deployed lance and use it to drive the opfor generation later\n+        // once we've determined that scenarios occur, we loop through the ones that we generated\n+        // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all\n+        for (int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            // if we haven't already used all the player forces and are required to randomly generate a scenario\n+            if ((availableForceIDs.size() > 0) &&\n+                    (Compute.randomInt(100) <= track.getScenarioOdds())) {\n+                // pick random coordinates and force to drive the scenario\n+                int x = Compute.randomInt(track.getWidth());\n+                int y = Compute.randomInt(track.getHeight());\n+\n+                StratconCoords scenarioCoords = new StratconCoords(x, y);\n+\n+                // if forces are already assigned to these coordinates, use those instead\n+                // of randomly-selected ones\n+                if (track.getAssignedCoordForces().containsKey(scenarioCoords)) {\n+                    StratconScenario scenario = generateScenarioForExistingForces(scenarioCoords,\n+                            track.getAssignedCoordForces().get(scenarioCoords), \n+                            contract, campaign, track);\n+                    generatedScenarios.add(scenario);\n+                    continue;\n+                }\n+                \n+                // otherwise, pick a random force from the avail\n+                int randomForceIndex = Compute.randomInt(availableForceIDs.size());\n+                int randomForceID = availableForceIDs.get(randomForceIndex);\n+                \n+                // remove the force from the available lists so we don't designate it as primary twice\n+                availableForceIDs.remove(randomForceIndex);\n+\n+                // we want to remove the actual int with the value, not the value at the index\n+                sortedAvailableForceIDs.get(MapLocation.AllGroundTerrain).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.LowAtmosphere).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.Space).remove((Integer) randomForceID);\n+\n+                // two scenarios on the same coordinates wind up increasing in size\n+                if (track.getScenarios().containsKey(scenarioCoords)) {\n+                    track.getScenarios().get(scenarioCoords).incrementRequiredPlayerLances();\n+                    assignAppropriateExtraForceToScenario(track.getScenarios().get(scenarioCoords), sortedAvailableForceIDs);\n+                    continue;\n+                }\n+\n+                StratconScenario scenario = setupScenario(scenarioCoords, randomForceID, campaign, contract, track);\n+                generatedScenarios.add(scenario);\n+\n+                // if we're auto-assigning lances, deploy the force to the track as well\n+                if (autoAssignLances) {\n+                    processForceDeployment(scenarioCoords, randomForceID, campaign, track, false);\n+                }\n+            }\n+        }\n+\n+        // if under liaison command, pick a random scenario from the ones generated\n+        // to set as required and attach liaison\n+        if (contract.getCommandRights() == AtBContract.COM_LIAISON) {\n+        \tStratconScenario randomScenario = Utilities.getRandomItem(generatedScenarios);\n+        \trandomScenario.setRequiredScenario(true);\n+            setAttachedUnitsModifier(randomScenario, contract);\n+        }\n+\n+        // now, we loop through all the scenarios we set up\n+        // and generate the opfors / events / etc\n+        // if not auto-assigning lances, we then back out the lance assignments.\n+        for (StratconScenario scenario : generatedScenarios) {\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+\n+            if(!autoAssignLances && !scenario.ignoreForceAutoAssignment()) {\n+                for(int forceID : scenario.getPlayerTemplateForceIDs()) {\n+                    scenario.getBackingScenario().removeForce(forceID);\n+                }\n+\n+                scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                track.addScenario(scenario);\n+            } else {\n+                commitPrimaryForces(campaign, contract, scenario, track);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Given a set of force IDs and coordinates, generate a scenario\n+     * Useful for when we want to generate scenarios \n+     * for forces already deployed to a track\n+     */\n+    public static StratconScenario generateScenarioForExistingForces(StratconCoords scenarioCoords, \n+            Set<Integer> forceIDs, AtBContract contract, Campaign campaign, StratconTrackState track) {\n+        boolean firstForce = true;\n+        StratconScenario scenario = null;\n+        \n+        for (int forceID : forceIDs) {\n+            if (firstForce) {\n+                scenario = setupScenario(scenarioCoords, forceID, campaign, contract, track);\n+                firstForce = false;\n+            } else {\n+                scenario.incrementRequiredPlayerLances();\n+                scenario.addPrimaryForce(forceID);\n+            }\n+        }\n+        \n+        scenario.setIgnoreForceAutoAssignment(true);\n+        return scenario;\n+    }\n+\n+    /**\n+     * Deploys a force to the given coordinates on the given track as a result of explicit player action.\n+     */\n+    public static void deployForceToCoords(StratconCoords coords, int forceID, \n+            Campaign campaign, AtBContract contract, StratconTrackState track, boolean sticky) {\n+        // the following things should happen:\n+        // 1. call to \"process force deployment\", which reveals fog of war in or around the coords, depending on force role\n+        // 2. if coords are a hostile facility, we get a facility mission\n+        // 3. if coords are empty, we *may* get a mission\n+\n+        processForceDeployment(coords, forceID, campaign, track, sticky);\n+\n+        // don't create a scenario on top of allied facilities\n+        StratconFacility facility = track.getFacility(coords);\n+        boolean isNonAlliedFacility = (facility != null) && (facility.getOwner() != ForceAlignment.Allied);\n+        boolean spawnScenario = (facility == null) && (Compute.randomInt(100) <= track.getScenarioOdds());\n+\n+        if (isNonAlliedFacility || spawnScenario) {\n+            StratconScenario scenario = setupScenario(coords, forceID, campaign, contract, track);\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            commitPrimaryForces(campaign, contract, scenario, track);\n+        }\n+    }\n+\n+    /**\n+     * Logic to set up a scenario\n+     */\n+    private static StratconScenario setupScenario(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        StratconScenario scenario = null;\n+\n+        if (track.getFacilities().containsKey(coords)) {\n+            StratconFacility facility = track.getFacility(coords);\n+            boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+            ScenarioTemplate template = StratconScenarioFactory.getFacilityScenario(alliedFacility);\n+            scenario = generateScenario(campaign, contract, track, forceID, coords, template);\n+            setupFacilityScenario(scenario, facility);\n+        } else {\n+            scenario = generateScenario(campaign, contract, track, forceID, coords);\n+\n+            // we may generate a facility scenario randomly - if so, do the facility-related stuff\n+            // and add a new facility to the track\n+            if (scenario.getBackingScenario().getTemplate().isFacilityScenario()) {\n+                StratconFacility facility = scenario.getBackingScenario().getTemplate().isHostileFacility() ?\n+                        StratconFacilityFactory.getRandomHostileFacility() : StratconFacilityFactory.getRandomAlliedFacility();\n+                facility.setVisible(true);\n+                track.addFacility(coords, facility);\n+                setupFacilityScenario(scenario, facility);\n+            }\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * carries out tasks relevant to facility scenarios\n+     */\n+    private static void setupFacilityScenario(StratconScenario scenario, StratconFacility facility) {\n+        // this includes:\n+        // for hostile facilities\n+        // - add a destroy objective (always the option to level the facility)\n+        // - add a capture objective (always the option to capture the facility)\n+        // - if so indicated by parameter, roll a random hostile facility objective and add it if not capture/destroy\n+        // for allied facilities\n+        // - add a defend objective (always the option to defend the facility)\n+        // - if so indicated by parameter, roll a random allied facility objective and add it if not defend\n+        AtBScenarioModifier objectiveModifier = null;\n+        boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+\n+        if (alliedFacility) {\n+            objectiveModifier = AtBScenarioModifier.getRandomAlliedFacilityModifier();\n+        } else {\n+            objectiveModifier = AtBScenarioModifier.getRandomHostileFacilityModifier();\n+        }\n+\n+        if (objectiveModifier != null) {\n+            scenario.getBackingScenario().addScenarioModifier(objectiveModifier);\n+            scenario.getBackingScenario().setName(String.format(\"%s - %s - %s\",\n+                    facility.getFacilityType(), alliedFacility ? \"Allied\" : \"Hostile\", objectiveModifier.getModifierName()));\n+        }\n+\n+        // add the \"fixed\" hostile facility modifiers after the primary ones\n+        if (!alliedFacility) {\n+            for(AtBScenarioModifier modifier : AtBScenarioModifier.getRequiredHostileFacilityModifiers()) {\n+                if(!scenario.getBackingScenario().alreadyHasModifier(modifier)) {\n+                    scenario.getBackingScenario().addScenarioModifier(modifier);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void processFacilityEffects(StratconTrackState track) {\n+        // TODO: these are \"weekly\"? effects that a stratcon facility has on the campaign/track state\n+        // currrently, that's\n+        // supply depot - allied - +1 sp\n+        // supply depot - hostile - +5% BV budget to all scenarios on track (shared modifier, so should be implemented there)\n+        // data center - allied - +1% star league cache contract (don't implement yet, but...)\n+        // data center - hostile - +5% scenario odds in track\n+        // industrial center - allied - all scenarios here have THIS IS COMING OUT OF YOUR PAYCHECK modifier\n+        // orbital defense - allied - sets 'no hostile aircraft' flag for track\n+        // orbital defense - hostile - sets 'no allied aircraft' flag for track\n+        // early warning system - allied - sets 'intercept allied base attacks' flag for track\n+        // early warning system - hostile - sets 'intercept hostile base attacks' flag for track\n+    }\n+\n+    /**\n+     * Process the deployment of a force to the given coordinates on the given track.\n+     */\n+    public static void processForceDeployment(StratconCoords coords, int forceID, \n+            Campaign campaign, StratconTrackState track, boolean sticky) {\n+        track.getRevealedCoords().add(coords);\n+        StratconFacility facility = track.getFacility(coords);\n+        if (facility != null) {\n+            facility.setVisible(true);\n+        }\n+\n+        if (campaign.getLances().get(forceID).getRole() == AtBLanceRole.SCOUTING) {\n+            for(int direction = 0; direction < 6; direction++) {\n+                StratconCoords checkCoords = coords.translate(direction);\n+\n+                facility = track.getFacility(checkCoords);\n+                if(facility != null) {\n+                    facility.setVisible(true);\n+                }\n+\n+                track.getRevealedCoords().add(coords.translate(direction));\n+            }\n+        }\n+\n+        // the force may be located in other places on the track - clear it out\n+        track.unassignForce(forceID);\n+        track.assignForce(forceID, coords, campaign.getLocalDate(), sticky);\n+        MekHQ.triggerEvent(new StratconDeploymentEvent(campaign.getForce(forceID)));\n+    }\n+\n+    /**\n+     * Worker function that processes the effects of deploying a reinforcement force to a scenario\n+     */\n+    public static boolean processReinforcementDeployment(ReinforcementEligibilityType reinforcementType,\n+            StratconCampaignState campaignState, StratconScenario scenario, Campaign campaign) {\n+        // if the force is already deployed to the track, we're done\n+        // if the force is a fight lance or we're using a support point\n+        // if there is an SP to burn, burn it and we're done\n+        // if there is a VP to burn, burn it and we're done\n+        // now, roll 2d6 + lance commander tactics\n+        // 9+ = deploy\n+        // 6+ = deploy, apply negative modifier to scenario\n+        // 2+ = fail to deploy, apply negative modifier to scenario; if fight lance, treat as 6+\n+\n+        if ((reinforcementType == ReinforcementEligibilityType.FightLance) ||\n+                (reinforcementType == ReinforcementEligibilityType.SupportPoint)) {\n+\n+            if (campaignState.getSupportPoints() > 0) {\n+                campaignState.useSupportPoint();\n+                return true;\n+            } else if (campaignState.getVictoryPoints() > 0) {\n+                campaignState.updateVictoryPoints(-1);\n+                return true;\n+            }\n+\n+            int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+            int roll = Compute.d6(2);\n+            int result = roll + tactics;\n+\n+            StringBuilder reportStatus = new StringBuilder();\n+            reportStatus.append(String.format(\"Attempting to reinforce scenario %s without SP/VP, roll 2d6 + %d: %d\",\n+                    scenario.getName(), tactics, result));\n+\n+            // fail to reinforce\n+            if ((result < 6) && (reinforcementType != ReinforcementEligibilityType.FightLance)) {\n+                reportStatus.append(\" - reinforcement attempt failed.\");\n+                campaign.addReport(reportStatus.toString());\n+                return false;\n+            // succeed but get an extra negative event added to the scenario\n+            } else if (result < 9) {\n+                MapLocation mapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+                AtBScenarioModifier scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+\n+                // keep rolling until we get an applicable one\n+                // TODO: have the AtBScenarioModifier sort these out instead for performance?\n+                while (scenarioModifier.getEventTiming() != EventTiming.PostForceGeneration) {\n+                    scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+                }\n+\n+                scenarioModifier.processModifier(scenario.getBackingScenario(), campaign, EventTiming.PostForceGeneration);\n+\n+                reportStatus.append(String.format(\" - reinforcement attempt succeeded; extra negative modifier (%s) applied to scenario.\",\n+                        scenarioModifier.getModifierName()));\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            // succeed without reservation\n+            } else {\n+                reportStatus.append(\" - reinforcement attempt succeeded;\");\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            }\n+        } else if (reinforcementType == ReinforcementEligibilityType.None) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Assigns a force to the scenario such that the majority of the force can be deployed\n+     */\n+    private static void assignAppropriateExtraForceToScenario(StratconScenario scenario,\n+            Map<MapLocation, List<Integer>> sortedAvailableForceIDs) {\n+        // the goal of this function is to avoid assigning ground units to air battles\n+        // and ground units/conventional fighters to space battle\n+\n+        List<MapLocation> mapLocations = new ArrayList<>();\n+        mapLocations.add(MapLocation.Space); // can always add ASFs\n+\n+        MapLocation scenarioMapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+\n+        if (scenarioMapLocation == MapLocation.LowAtmosphere) {\n+            mapLocations.add(MapLocation.LowAtmosphere); // can add conventional fighters to ground or low atmo battles\n+        }\n+\n+        if ((scenarioMapLocation == MapLocation.AllGroundTerrain) ||\n+                (scenarioMapLocation == MapLocation.SpecificGroundTerrain)) {\n+            mapLocations.add(MapLocation.AllGroundTerrain); // can only add ground units to ground battles\n+        }\n+\n+        MapLocation selectedLocation = mapLocations.get(Compute.randomInt(mapLocations.size()));\n+        List<Integer> forceIDs = sortedAvailableForceIDs.get(selectedLocation);\n+        int forceIndex = Compute.randomInt(forceIDs.size());\n+        int forceID = forceIDs.get(forceIndex);\n+        forceIDs.remove(forceIndex);\n+\n+        scenario.addPrimaryForce(forceID);\n+    }\n+\n+    /**\n+     * Worker function that \"locks in\" a scenario -\n+     * Adds it to the campaign so it's visible in the briefing room,\n+     * adds it to the track\n+     *\n+     */\n+    public static void commitPrimaryForces(Campaign campaign, AtBContract contract, StratconScenario scenario, StratconTrackState trackState) {\n+        // order of operations is important here, we need a valid scenario ID prior to adding the scenario to the track.\n+        campaign.addScenario(scenario.getBackingScenario(), contract);\n+        scenario.setBackingScenarioID(scenario.getBackingScenario().getId());\n+        trackState.addScenario(scenario);\n+\n+        // set up dates for the scenario if doesn't have them already\n+        if (scenario.getDeploymentDate() == null) {\n+            scenario.setDeploymentDate(campaign.getLocalDate());\n+        }\n+\n+        if (scenario.getActionDate() == null) {\n+            scenario.setActionDate(campaign.getLocalDate());\n+        }\n+\n+        if(scenario.getReturnDate() == null) {\n+            scenario.setReturnDate(campaign.getLocalDate().plusDays(trackState.getDeploymentTime()));\n+        }\n+\n+        // set the # of rerolls based on the actual lance assigned.\n+        int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+        scenario.getBackingScenario().setRerolls(tactics);\n+        // The number of defensive points available to a force entering a scenario is\n+        // 2 x tactics. By default, those points are spent on conventional minefields.\n+        if (commanderLanceHasDefensiveAssignment(scenario.getBackingScenario(), campaign)) {\n+            scenario.setNumDefensivePoints(tactics * 2);\n+            scenario.updateMinefieldCount(Minefield.TYPE_CONVENTIONAL, tactics * 2);\n+        }\n+\n+        for (int forceID : scenario.getPlayerTemplateForceIDs()) {\n+            Force force = campaign.getForce(forceID);\n+            force.clearScenarioIds(campaign, true);\n+            force.setScenarioId(scenario.getBackingScenarioID());\n+        }\n+\n+        scenario.commitPrimaryForces();\n+    }\n+\n+    /**\n+     * Utility method to determine if the current scenario's force commander\n+     * is on defence\n+     */\n+    private static boolean commanderLanceHasDefensiveAssignment(AtBDynamicScenario scenario, Campaign campaign) {\n+        Unit commanderUnit = scenario.getLanceCommander(campaign).getUnit();\n+        Lance lance = campaign.getLances().get(commanderUnit.getForceId());\n+\n+        if ((lance != null) && (lance.getRole() == AtBLanceRole.DEFENCE)) {\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * A hackish worker function that takes the given list of force IDs and\n+     * separates it into three sets;\n+     * one of forces that can be \"primary\" on a ground map\n+     * one of forces that can be \"primary\" on an atmospheric map\n+     * one of forces that can be \"primary\" in a space map\n+     * @param forceIDs List of force IDs to check\n+     * @return Sorted hash map\n+     */\n+    private static Map<MapLocation, List<Integer>> sortForcesByMapType(List<Integer> forceIDs, Campaign campaign) {\n+        Map<MapLocation, List<Integer>> retVal = new HashMap<>();\n+\n+        retVal.put(MapLocation.AllGroundTerrain, new ArrayList<>());\n+        retVal.put(MapLocation.LowAtmosphere, new ArrayList<>());\n+        retVal.put(MapLocation.Space, new ArrayList<>());\n+\n+        for (int forceID : forceIDs) {\n+            switch(campaign.getForce(forceID).getPrimaryUnitType(campaign)) {\n+            case UnitType.BATTLE_ARMOR:\n+            case UnitType.INFANTRY:\n+            case UnitType.MEK:\n+            case UnitType.TANK:\n+            case UnitType.PROTOMEK:\n+            case UnitType.VTOL:\n+                retVal.get(MapLocation.AllGroundTerrain).add(forceID);\n+                break;\n+            case UnitType.AERO:\n+                retVal.get(MapLocation.Space).add(forceID);\n+                // intentional fallthrough here, ASFs can go to atmospheric maps too\n+            case UnitType.CONV_FIGHTER:\n+                retVal.get(MapLocation.LowAtmosphere).add(forceID);\n+                break;\n+            }\n+        }\n+\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * Determine whether the user should be nagged about unresolved scenarios on AtB Stratcon tracks.\n+     * @param campaign Campaign to check.\n+     * @return An informative string containing the reasons the user was nagged.\n+     */\n+    public static String nagUnresolvedContacts(Campaign campaign) {\n+        StringBuilder sb = new StringBuilder();\n+\n+        // check every track attached to an active contract for unresolved scenarios\n+        // to which the player must deploy forces today\n+        for (Contract contract : campaign.getActiveContracts()) {\n+            if(contract instanceof AtBContract) {\n+                for(StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    for(StratconScenario scenario : track.getScenarios().values()) {\n+                        if(scenario.getCurrentState() == ScenarioState.UNRESOLVED &&\n+                                campaign.getLocalDate().equals(scenario.getDeploymentDate())) {\n+                            // \"scenario name, track name\"\n+                            sb.append(String.format(\"%s, %s\\n\", scenario.getName(), track.getDisplayableName()));\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track.\n+     * Also registers it with the track and campaign.\n+     */\n+    private static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords) {\n+        int unitType = campaign.getForce(forceID).getPrimaryUnitType(campaign);\n+        ScenarioTemplate template = StratconScenarioFactory.getRandomScenario(unitType);\n+        // useful for debugging specific scenario types\n+        //ScenarioTemplate template = StratconScenarioFactory.getSpecificScenario(\"Allied Facility.xml\");\n+\n+        return generateScenario(campaign, contract, track, forceID, coords, template);\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track,\n+     * using the given template. Also registers it with the track and campaign.\n+     */\n+    static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords, ScenarioTemplate template) {\n+        StratconScenario scenario = new StratconScenario();\n+        scenario.setBackingScenario(AtBDynamicScenarioFactory.initializeScenarioFromTemplate(template, contract, campaign));\n+        scenario.setCoords(coords);\n+        \n+        // by default, certain conditions may make this bigger\n+        scenario.setRequiredPlayerLances(1);\n+\n+        // do an appropriate allied force if the contract calls for it\n+        // do any attached or integrated units\n+        setAlliedForceModifier(scenario, contract);\n+        setAttachedUnitsModifier(scenario, contract);\n+        applyFacilityModifiers(scenario, track, coords);\n+        applyGlobalModifiers(scenario, contract.getStratconCampaignState());\n+\n+        if ((contract.getCommandRights() == AtBContract.COM_HOUSE) ||\n+                (contract.getCommandRights() == AtBContract.COM_INTEGRATED)) {\n+            scenario.setRequiredScenario(true);\n+        }\n+\n+        AtBDynamicScenarioFactory.setScenarioModifiers(scenario.getBackingScenario());\n+        scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+        setScenarioDates(track, campaign, scenario);\n+\n+        // register the scenario with the campaign and the track it's generated on\n+        if (forceID > Force.FORCE_NONE) {\n+            scenario.addPrimaryForce(forceID);\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * Apply global scenario modifiers from campaign state to given scenario.\n+     */\n+    private static void applyGlobalModifiers(StratconScenario scenario, StratconCampaignState campaignState) {\n+        for (String modifierName : campaignState.getGlobalScenarioModifiers()) {\n+            AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierName);\n+\n+            if (modifier == null) {\n+                MekHQ.getLogger().error(String.format(\"Modifier %s not found; ignoring\", modifierName));\n+                continue;\n+            }\n+\n+            scenario.getBackingScenario().addScenarioModifier(modifier);\n+        }\n+    }\n+\n+    /**\n+     * Applies scenario modifiers from the current track to the given scenario.\n+     * @param scenario\n+     * @param track\n+     */\n+    private static void applyFacilityModifiers(StratconScenario scenario, StratconTrackState track, StratconCoords coords) {\n+        // loop through all the facilities on the track\n+        // if a facility has been revealed, then it has a 100% chance to apply its effect\n+        // if a facility has not been revealed, then it has a x% chance to apply its effect\n+        // if a facility is on the the scenario coordinates the it applies the local effects\n+        for (StratconCoords facilityCoords : track.getFacilities().keySet()) {\n+            boolean scenarioAtFacility = facilityCoords.equals(coords);\n+            StratconFacility facility = track.getFacilities().get(facilityCoords);\n+            List<String> modifierIDs = new ArrayList<>();\n+\n+            if (scenarioAtFacility) {\n+                modifierIDs = facility.getLocalModifiers();\n+            } else if (facility.isVisible() || (Compute.randomInt(100) <= facility.getAggroRating())) {\n+                modifierIDs = facility.getSharedModifiers();\n+            }\n+\n+            for (String modifierID : modifierIDs) {\n+                AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierID);\n+                if(modifier == null) {\n+                    MekHQ.getLogger().error(String.format(\"Modifier %s not found for facility %s\", modifierID, facility.getFormattedDisplayableName()));\n+                    continue;\n+                }\n+\n+                scenario.getBackingScenario().addScenarioModifier(modifier);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set up the appropriate primary allied force modifier, if any\n+     * @param contract The scenario's contract.\n+     */\n+    private static void setAlliedForceModifier(StratconScenario scenario, AtBContract contract) {\n+        int alliedUnitOdds = 0;\n+\n+        // first, we determine the odds of having an allied unit present\n+        // TODO: move this override out to the contract definition\n+        if (contract.getMissionType() == AtBContract.MT_RELIEFDUTY) {\n+            alliedUnitOdds = 50;\n+        } else {\n+            switch(contract.getCommandRights()) {\n+            case AtBContract.COM_INTEGRATED:\n+                alliedUnitOdds = 50;\n+                break;\n+            case AtBContract.COM_HOUSE:\n+                alliedUnitOdds = 30;\n+                break;\n+            case AtBContract.COM_LIAISON:\n+                alliedUnitOdds = 10;\n+                break;\n+            }\n+        }\n+\n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+\n+        // if an allied unit is present, then we want to make sure that it's ground units\n+        // for ground battles\n+        if (Compute.randomInt(100) <= alliedUnitOdds) {\n+            if((backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+               (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space)) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_ALLIED_AIR_UNITS));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_ALLIED_GROUND_UNITS));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set the 'attached' units modifier for the current scenario (integrated, house, liaison),\n+     * and make sure we're not deploying ground units to an air scenario\n+     * @param contract The scenario's contract\n+     */\n+    public static void setAttachedUnitsModifier(StratconScenario scenario, AtBContract contract) {\n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+        boolean airBattle = (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+                (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space);\n+\n+        // if we're on cadre duty, we're getting three trainees, period\n+        if (contract.getMissionType() == AtBContract.MT_CADREDUTY) {\n+            if (airBattle) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_TRAINEES_AIR));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_TRAINEES_GROUND));\n+            }\n+            return;\n+        }\n+\n+        // if we're under non-independent command rights, a supervisor may come along\n+        switch (contract.getCommandRights()) {\n+            case AtBContract.COM_INTEGRATED:\n+                if (airBattle) {\n+                    backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_INTEGRATED_UNITS_AIR));\n+                } else {\n+                    backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_INTEGRATED_UNITS_GROUND));\n+                }\n+                break;\n+            case AtBContract.COM_HOUSE:\n+                if (airBattle) {\n+                    backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_HOUSE_CO_AIR));\n+                } else {\n+                    backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_HOUSE_CO_GROUND));\n+                }\n+                break;\n+            case AtBContract.COM_LIAISON:\n+                if (scenario.isRequiredScenario()) {\n+                    if(airBattle) {\n+                        backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_LIAISON_AIR));\n+                    } else {\n+                        backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_LIAISON_GROUND));\n+                    }\n+                }\n+                break;\n+        }\n+    }\n+\n+    /**\n+     * Worker function that sets scenario deploy/battle/return dates based on the track's properties and current campaign date\n+     */\n+    private static void setScenarioDates(StratconTrackState track, Campaign campaign, StratconScenario scenario) {\n+     // set up deployment day, battle day, return day here\n+        // safety code to prevent attempts to generate random int with upper bound of 0 which is apparently illegal\n+        int deploymentDay = track.getDeploymentTime() < 7 ? Compute.randomInt(7 - track.getDeploymentTime()) : 0;\n+        int battleDay = deploymentDay + (track.getDeploymentTime() > 0 ? Compute.randomInt(track.getDeploymentTime()) : 0);\n+        int returnDay = deploymentDay + track.getDeploymentTime();\n+\n+        LocalDate deploymentDate = campaign.getLocalDate();\n+        deploymentDate.plusDays(deploymentDay);\n+        LocalDate battleDate = campaign.getLocalDate();\n+        deploymentDate.plusDays(battleDay);\n+        LocalDate returnDate = campaign.getLocalDate();\n+        returnDate.plusDays(returnDay);\n+\n+        scenario.setDeploymentDate(deploymentDate);\n+        scenario.setActionDate(battleDate);\n+        scenario.setReturnDate(returnDate);\n+    }\n+\n+    /**\n+     * Helper function that determines if the unit type specified in the given scenario force template\n+     * would start out airborne on a ground map (hot dropped units aside)\n+     */\n+    private static boolean unitTypeIsAirborne(ScenarioForceTemplate template) {\n+        int unitType = template.getAllowedUnitType();\n+\n+        return (unitType == UnitType.AERO ||\n+                unitType == UnitType.CONV_FIGHTER ||\n+                unitType == UnitType.DROPSHIP ||\n+                unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_MIX) &&\n+                template.getStartingAltitude() > 0;\n+    }\n+\n+    /**\n+     * Determines whether the force in question has the same primary unit type as the force template.\n+     * @return Whether or not the unit types match.\n+     */\n+    public static boolean forceCompositionMatchesDeclaredUnitType(int primaryUnitType, int unitType, boolean reinforcements) {\n+        // special cases are \"ATB_MIX\" and \"ATB_AERO_MIX\", which encompass multiple unit types\n+        if (unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_MIX) {\n+            // \"AtB mix\" is usually ground units, but air units can sub in\n+            return primaryUnitType == UnitType.MEK ||\n+                    primaryUnitType == UnitType.TANK ||\n+                    primaryUnitType == UnitType.INFANTRY ||\n+                    primaryUnitType == UnitType.BATTLE_ARMOR ||\n+                    primaryUnitType == UnitType.PROTOMEK ||\n+                    primaryUnitType == UnitType.VTOL ||\n+                    (primaryUnitType == UnitType.AERO) && reinforcements ||\n+                    (primaryUnitType == UnitType.CONV_FIGHTER) && reinforcements;\n+        } else if (unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_AERO_MIX) {\n+            return primaryUnitType == UnitType.AERO ||\n+                    primaryUnitType == UnitType.CONV_FIGHTER;\n+        } else {\n+            return primaryUnitType == unitType;\n+        }\n+    }\n+\n+    /**\n+     * This is a set of all force IDs for forces that can be deployed to a scenario.\n+     * @param campaign Current campaign\n+     * @return Set of available force IDs.\n+     */\n+    public static List<Integer> getAvailableForceIDs(Campaign campaign) {\n+        List<Integer> retVal = new ArrayList<>();\n+\n+        // first, we gather a set of all forces that are already deployed to a track so we eliminate those later\n+        Set<Integer> forcesInTracks = new HashSet<>();\n+        for (Contract contract : campaign.getActiveContracts()) {\n+            if(contract instanceof AtBContract) {\n+                for(StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    forcesInTracks.addAll(track.getAssignedForceCoords().keySet());\n+                }\n+            }\n+        }\n+\n+        // now, we get all the forces that qualify as \"lances\", and filter out those that are\n+        // deployed to a scenario and not in a track already\n+        for (int key : campaign.getLances().keySet()) {\n+            Force force = campaign.getForce(key);\n+            if (force != null &&\n+                    !force.isDeployed() &&\n+                    !forcesInTracks.contains(force.getId())) {\n+                retVal.add(force.getId());\n+            }\n+        }\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * This is a list of all force IDs for forces that can be deployed to a scenario in the given force template\n+     * a) have not been assigned to a track\n+     * b) are combat-capable\n+     * c) are not deployed to a scenario\n+     * d) if attempting to deploy as reinforcements, haven't already failed to deploy\n+     */\n+    public static List<Integer> getAvailableForceIDs(int unitType, Campaign campaign, StratconTrackState currentTrack,\n+            boolean reinforcements, @Nullable StratconScenario currentScenario) {\n+        List<Integer> retVal = new ArrayList<>();\n+\n+        Set<Integer> forcesInTracks = new HashSet<>();\n+        // assemble a set of all force IDs that are currently assigned to tracks that are not this one\n+        for (Contract contract : campaign.getActiveContracts()) {\n+            if (contract instanceof AtBContract) {\n+                for (StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    if ((track != currentTrack) || !reinforcements) {\n+                        forcesInTracks.addAll(track.getAssignedForceCoords().keySet());\n+                    }\n+                }\n+            }\n+        }\n+        \n+        // if there's an existing scenario and we're doing reinforcements,\n+        // prevent forces that failed to deploy from trying to deploy again\n+        if (reinforcements && (currentScenario != null)) {\n+            forcesInTracks.addAll(currentScenario.getFailedReinforcements());\n+        }\n+\n+        for (int key : campaign.getLances().keySet()) {\n+            Force force = campaign.getForce(key);\n+\n+            if (force == null) {\n+                continue;\n+            }\n+\n+            int primaryUnitType = force.getPrimaryUnitType(campaign);\n+            if (!force.isDeployed() &&\n+                    (force.getScenarioId() <= 0) &&\n+                    !force.getUnits().isEmpty() &&\n+                    !forcesInTracks.contains(force.getId()) &&\n+                    forceCompositionMatchesDeclaredUnitType(primaryUnitType, unitType, reinforcements)) {\n+                retVal.add(force.getId());\n+            }\n+        }\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * Returns a list of individual units eligible for deployment in scenarios run by \"Defend\" lances\n+     * @return List of unit IDs.\n+     */\n+    public static List<Unit> getEligibleDefensiveUnits(Campaign campaign) {\n+        List<Unit> retVal = new ArrayList<>();\n+\n+        for (Unit u : campaign.getUnits()) {\n+            // \"defensive\" units are infantry, battle armor and (Weisman help you) gun emplacements\n+        \t// and also said unit should be intact/alive/etc\n+        \tboolean isEligibleInfantry = \n+        \t\t\t((u.getEntity().getUnitType() == UnitType.INFANTRY) ||\n+                    (u.getEntity().getUnitType() == UnitType.BATTLE_ARMOR)) &&\n+                    !u.isUnmanned();\n+        \t\n+        \tboolean isEligibleGunEmplacement = u.getEntity().getUnitType() == UnitType.GUN_EMPLACEMENT;\n+        \t\n+        \tif ((isEligibleInfantry || isEligibleGunEmplacement) && \n+            \t\t!u.isDeployed() &&\n+                    !u.isMothballed() &&\n+                    u.isFunctional()) {\n+\n+                // this is a little inefficient, but probably there aren't too many active AtB contracts at a time\n+                for (Contract contract : campaign.getActiveContracts()) {\n+                    if((contract instanceof AtBContract) &&", "originalCommit": "0244602bac43aacfd804a92250447a67a4fbd75a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNDUwNzE0MA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r604507140", "bodyText": "combine lines", "author": "Windchild292", "createdAt": "2021-03-31T00:02:07Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1291 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.UUID;\n+\n+import megamek.common.Compute;\n+import megamek.common.Minefield;\n+import megamek.common.UnitType;\n+import megamek.common.annotations.Nullable;\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.Utilities;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.ResolveScenarioTracker;\n+import mekhq.campaign.againstTheBot.enums.AtBLanceRole;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.event.StratconDeploymentEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.force.Lance;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier.EventTiming;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.unit.Unit;\n+\n+/**\n+ * This class contains \"rules\" logic for the AtB-Stratcon state\n+ * @author NickAragua\n+ */\n+public class StratconRulesManager {\n+    /**\n+     * What makes a particular lance eligible to be reinforcements for a scenario\n+     * @author NickAragua\n+     */\n+    public enum ReinforcementEligibilityType {\n+        /**\n+         * Nothing\n+         */\n+        None,\n+\n+        /**\n+         * Lance is already deployed to the track\n+         */\n+        ChainedScenario,\n+\n+        /**\n+         * We pay a support point or convert a victory point to a support point\n+         */\n+        SupportPoint,\n+\n+        /**\n+         * The lance's deployment orders are \"Fight\"\n+         */\n+        FightLance\n+    }\n+\n+    /**\n+     * This function potentially generates non-player-initiated scenarios for the given track.\n+     */\n+    public static void generateScenariosForTrack(Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // maps scenarios to force IDs\n+        List<StratconScenario> generatedScenarios = new ArrayList<>();\n+        boolean autoAssignLances = contract.getCommandRights() == AtBContract.COM_INTEGRATED;\n+\n+        // get this list just so we have it available\n+        List<Integer> availableForceIDs = getAvailableForceIDs(campaign);\n+        Map<MapLocation, List<Integer>> sortedAvailableForceIDs = sortForcesByMapType(availableForceIDs, campaign);\n+\n+        // make X rolls, where X is the number of required lances for the track\n+        // that's the chance to spawn a scenario.\n+        // if a scenario occurs, then we pick a random non-deployed lance and use it to drive the opfor generation later\n+        // once we've determined that scenarios occur, we loop through the ones that we generated\n+        // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all\n+        for (int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            // if we haven't already used all the player forces and are required to randomly generate a scenario\n+            if ((availableForceIDs.size() > 0) &&\n+                    (Compute.randomInt(100) <= track.getScenarioOdds())) {\n+                // pick random coordinates and force to drive the scenario\n+                int x = Compute.randomInt(track.getWidth());\n+                int y = Compute.randomInt(track.getHeight());\n+\n+                StratconCoords scenarioCoords = new StratconCoords(x, y);\n+\n+                // if forces are already assigned to these coordinates, use those instead\n+                // of randomly-selected ones\n+                if (track.getAssignedCoordForces().containsKey(scenarioCoords)) {\n+                    StratconScenario scenario = generateScenarioForExistingForces(scenarioCoords,\n+                            track.getAssignedCoordForces().get(scenarioCoords), \n+                            contract, campaign, track);\n+                    generatedScenarios.add(scenario);\n+                    continue;\n+                }\n+                \n+                // otherwise, pick a random force from the avail\n+                int randomForceIndex = Compute.randomInt(availableForceIDs.size());\n+                int randomForceID = availableForceIDs.get(randomForceIndex);\n+                \n+                // remove the force from the available lists so we don't designate it as primary twice\n+                availableForceIDs.remove(randomForceIndex);\n+\n+                // we want to remove the actual int with the value, not the value at the index\n+                sortedAvailableForceIDs.get(MapLocation.AllGroundTerrain).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.LowAtmosphere).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.Space).remove((Integer) randomForceID);\n+\n+                // two scenarios on the same coordinates wind up increasing in size\n+                if (track.getScenarios().containsKey(scenarioCoords)) {\n+                    track.getScenarios().get(scenarioCoords).incrementRequiredPlayerLances();\n+                    assignAppropriateExtraForceToScenario(track.getScenarios().get(scenarioCoords), sortedAvailableForceIDs);\n+                    continue;\n+                }\n+\n+                StratconScenario scenario = setupScenario(scenarioCoords, randomForceID, campaign, contract, track);\n+                generatedScenarios.add(scenario);\n+\n+                // if we're auto-assigning lances, deploy the force to the track as well\n+                if (autoAssignLances) {\n+                    processForceDeployment(scenarioCoords, randomForceID, campaign, track, false);\n+                }\n+            }\n+        }\n+\n+        // if under liaison command, pick a random scenario from the ones generated\n+        // to set as required and attach liaison\n+        if (contract.getCommandRights() == AtBContract.COM_LIAISON) {\n+        \tStratconScenario randomScenario = Utilities.getRandomItem(generatedScenarios);\n+        \trandomScenario.setRequiredScenario(true);\n+            setAttachedUnitsModifier(randomScenario, contract);\n+        }\n+\n+        // now, we loop through all the scenarios we set up\n+        // and generate the opfors / events / etc\n+        // if not auto-assigning lances, we then back out the lance assignments.\n+        for (StratconScenario scenario : generatedScenarios) {\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+\n+            if(!autoAssignLances && !scenario.ignoreForceAutoAssignment()) {\n+                for(int forceID : scenario.getPlayerTemplateForceIDs()) {\n+                    scenario.getBackingScenario().removeForce(forceID);\n+                }\n+\n+                scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                track.addScenario(scenario);\n+            } else {\n+                commitPrimaryForces(campaign, contract, scenario, track);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Given a set of force IDs and coordinates, generate a scenario\n+     * Useful for when we want to generate scenarios \n+     * for forces already deployed to a track\n+     */\n+    public static StratconScenario generateScenarioForExistingForces(StratconCoords scenarioCoords, \n+            Set<Integer> forceIDs, AtBContract contract, Campaign campaign, StratconTrackState track) {\n+        boolean firstForce = true;\n+        StratconScenario scenario = null;\n+        \n+        for (int forceID : forceIDs) {\n+            if (firstForce) {\n+                scenario = setupScenario(scenarioCoords, forceID, campaign, contract, track);\n+                firstForce = false;\n+            } else {\n+                scenario.incrementRequiredPlayerLances();\n+                scenario.addPrimaryForce(forceID);\n+            }\n+        }\n+        \n+        scenario.setIgnoreForceAutoAssignment(true);\n+        return scenario;\n+    }\n+\n+    /**\n+     * Deploys a force to the given coordinates on the given track as a result of explicit player action.\n+     */\n+    public static void deployForceToCoords(StratconCoords coords, int forceID, \n+            Campaign campaign, AtBContract contract, StratconTrackState track, boolean sticky) {\n+        // the following things should happen:\n+        // 1. call to \"process force deployment\", which reveals fog of war in or around the coords, depending on force role\n+        // 2. if coords are a hostile facility, we get a facility mission\n+        // 3. if coords are empty, we *may* get a mission\n+\n+        processForceDeployment(coords, forceID, campaign, track, sticky);\n+\n+        // don't create a scenario on top of allied facilities\n+        StratconFacility facility = track.getFacility(coords);\n+        boolean isNonAlliedFacility = (facility != null) && (facility.getOwner() != ForceAlignment.Allied);\n+        boolean spawnScenario = (facility == null) && (Compute.randomInt(100) <= track.getScenarioOdds());\n+\n+        if (isNonAlliedFacility || spawnScenario) {\n+            StratconScenario scenario = setupScenario(coords, forceID, campaign, contract, track);\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            commitPrimaryForces(campaign, contract, scenario, track);\n+        }\n+    }\n+\n+    /**\n+     * Logic to set up a scenario\n+     */\n+    private static StratconScenario setupScenario(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        StratconScenario scenario = null;\n+\n+        if (track.getFacilities().containsKey(coords)) {\n+            StratconFacility facility = track.getFacility(coords);\n+            boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+            ScenarioTemplate template = StratconScenarioFactory.getFacilityScenario(alliedFacility);\n+            scenario = generateScenario(campaign, contract, track, forceID, coords, template);\n+            setupFacilityScenario(scenario, facility);\n+        } else {\n+            scenario = generateScenario(campaign, contract, track, forceID, coords);\n+\n+            // we may generate a facility scenario randomly - if so, do the facility-related stuff\n+            // and add a new facility to the track\n+            if (scenario.getBackingScenario().getTemplate().isFacilityScenario()) {\n+                StratconFacility facility = scenario.getBackingScenario().getTemplate().isHostileFacility() ?\n+                        StratconFacilityFactory.getRandomHostileFacility() : StratconFacilityFactory.getRandomAlliedFacility();\n+                facility.setVisible(true);\n+                track.addFacility(coords, facility);\n+                setupFacilityScenario(scenario, facility);\n+            }\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * carries out tasks relevant to facility scenarios\n+     */\n+    private static void setupFacilityScenario(StratconScenario scenario, StratconFacility facility) {\n+        // this includes:\n+        // for hostile facilities\n+        // - add a destroy objective (always the option to level the facility)\n+        // - add a capture objective (always the option to capture the facility)\n+        // - if so indicated by parameter, roll a random hostile facility objective and add it if not capture/destroy\n+        // for allied facilities\n+        // - add a defend objective (always the option to defend the facility)\n+        // - if so indicated by parameter, roll a random allied facility objective and add it if not defend\n+        AtBScenarioModifier objectiveModifier = null;\n+        boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+\n+        if (alliedFacility) {\n+            objectiveModifier = AtBScenarioModifier.getRandomAlliedFacilityModifier();\n+        } else {\n+            objectiveModifier = AtBScenarioModifier.getRandomHostileFacilityModifier();\n+        }\n+\n+        if (objectiveModifier != null) {\n+            scenario.getBackingScenario().addScenarioModifier(objectiveModifier);\n+            scenario.getBackingScenario().setName(String.format(\"%s - %s - %s\",\n+                    facility.getFacilityType(), alliedFacility ? \"Allied\" : \"Hostile\", objectiveModifier.getModifierName()));\n+        }\n+\n+        // add the \"fixed\" hostile facility modifiers after the primary ones\n+        if (!alliedFacility) {\n+            for(AtBScenarioModifier modifier : AtBScenarioModifier.getRequiredHostileFacilityModifiers()) {\n+                if(!scenario.getBackingScenario().alreadyHasModifier(modifier)) {\n+                    scenario.getBackingScenario().addScenarioModifier(modifier);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void processFacilityEffects(StratconTrackState track) {\n+        // TODO: these are \"weekly\"? effects that a stratcon facility has on the campaign/track state\n+        // currrently, that's\n+        // supply depot - allied - +1 sp\n+        // supply depot - hostile - +5% BV budget to all scenarios on track (shared modifier, so should be implemented there)\n+        // data center - allied - +1% star league cache contract (don't implement yet, but...)\n+        // data center - hostile - +5% scenario odds in track\n+        // industrial center - allied - all scenarios here have THIS IS COMING OUT OF YOUR PAYCHECK modifier\n+        // orbital defense - allied - sets 'no hostile aircraft' flag for track\n+        // orbital defense - hostile - sets 'no allied aircraft' flag for track\n+        // early warning system - allied - sets 'intercept allied base attacks' flag for track\n+        // early warning system - hostile - sets 'intercept hostile base attacks' flag for track\n+    }\n+\n+    /**\n+     * Process the deployment of a force to the given coordinates on the given track.\n+     */\n+    public static void processForceDeployment(StratconCoords coords, int forceID, \n+            Campaign campaign, StratconTrackState track, boolean sticky) {\n+        track.getRevealedCoords().add(coords);\n+        StratconFacility facility = track.getFacility(coords);\n+        if (facility != null) {\n+            facility.setVisible(true);\n+        }\n+\n+        if (campaign.getLances().get(forceID).getRole() == AtBLanceRole.SCOUTING) {\n+            for(int direction = 0; direction < 6; direction++) {\n+                StratconCoords checkCoords = coords.translate(direction);\n+\n+                facility = track.getFacility(checkCoords);\n+                if(facility != null) {\n+                    facility.setVisible(true);\n+                }\n+\n+                track.getRevealedCoords().add(coords.translate(direction));\n+            }\n+        }\n+\n+        // the force may be located in other places on the track - clear it out\n+        track.unassignForce(forceID);\n+        track.assignForce(forceID, coords, campaign.getLocalDate(), sticky);\n+        MekHQ.triggerEvent(new StratconDeploymentEvent(campaign.getForce(forceID)));\n+    }\n+\n+    /**\n+     * Worker function that processes the effects of deploying a reinforcement force to a scenario\n+     */\n+    public static boolean processReinforcementDeployment(ReinforcementEligibilityType reinforcementType,\n+            StratconCampaignState campaignState, StratconScenario scenario, Campaign campaign) {\n+        // if the force is already deployed to the track, we're done\n+        // if the force is a fight lance or we're using a support point\n+        // if there is an SP to burn, burn it and we're done\n+        // if there is a VP to burn, burn it and we're done\n+        // now, roll 2d6 + lance commander tactics\n+        // 9+ = deploy\n+        // 6+ = deploy, apply negative modifier to scenario\n+        // 2+ = fail to deploy, apply negative modifier to scenario; if fight lance, treat as 6+\n+\n+        if ((reinforcementType == ReinforcementEligibilityType.FightLance) ||\n+                (reinforcementType == ReinforcementEligibilityType.SupportPoint)) {\n+\n+            if (campaignState.getSupportPoints() > 0) {\n+                campaignState.useSupportPoint();\n+                return true;\n+            } else if (campaignState.getVictoryPoints() > 0) {\n+                campaignState.updateVictoryPoints(-1);\n+                return true;\n+            }\n+\n+            int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+            int roll = Compute.d6(2);\n+            int result = roll + tactics;\n+\n+            StringBuilder reportStatus = new StringBuilder();\n+            reportStatus.append(String.format(\"Attempting to reinforce scenario %s without SP/VP, roll 2d6 + %d: %d\",\n+                    scenario.getName(), tactics, result));\n+\n+            // fail to reinforce\n+            if ((result < 6) && (reinforcementType != ReinforcementEligibilityType.FightLance)) {\n+                reportStatus.append(\" - reinforcement attempt failed.\");\n+                campaign.addReport(reportStatus.toString());\n+                return false;\n+            // succeed but get an extra negative event added to the scenario\n+            } else if (result < 9) {\n+                MapLocation mapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+                AtBScenarioModifier scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+\n+                // keep rolling until we get an applicable one\n+                // TODO: have the AtBScenarioModifier sort these out instead for performance?\n+                while (scenarioModifier.getEventTiming() != EventTiming.PostForceGeneration) {\n+                    scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+                }\n+\n+                scenarioModifier.processModifier(scenario.getBackingScenario(), campaign, EventTiming.PostForceGeneration);\n+\n+                reportStatus.append(String.format(\" - reinforcement attempt succeeded; extra negative modifier (%s) applied to scenario.\",\n+                        scenarioModifier.getModifierName()));\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            // succeed without reservation\n+            } else {\n+                reportStatus.append(\" - reinforcement attempt succeeded;\");\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            }\n+        } else if (reinforcementType == ReinforcementEligibilityType.None) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Assigns a force to the scenario such that the majority of the force can be deployed\n+     */\n+    private static void assignAppropriateExtraForceToScenario(StratconScenario scenario,\n+            Map<MapLocation, List<Integer>> sortedAvailableForceIDs) {\n+        // the goal of this function is to avoid assigning ground units to air battles\n+        // and ground units/conventional fighters to space battle\n+\n+        List<MapLocation> mapLocations = new ArrayList<>();\n+        mapLocations.add(MapLocation.Space); // can always add ASFs\n+\n+        MapLocation scenarioMapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+\n+        if (scenarioMapLocation == MapLocation.LowAtmosphere) {\n+            mapLocations.add(MapLocation.LowAtmosphere); // can add conventional fighters to ground or low atmo battles\n+        }\n+\n+        if ((scenarioMapLocation == MapLocation.AllGroundTerrain) ||\n+                (scenarioMapLocation == MapLocation.SpecificGroundTerrain)) {\n+            mapLocations.add(MapLocation.AllGroundTerrain); // can only add ground units to ground battles\n+        }\n+\n+        MapLocation selectedLocation = mapLocations.get(Compute.randomInt(mapLocations.size()));\n+        List<Integer> forceIDs = sortedAvailableForceIDs.get(selectedLocation);\n+        int forceIndex = Compute.randomInt(forceIDs.size());\n+        int forceID = forceIDs.get(forceIndex);\n+        forceIDs.remove(forceIndex);\n+\n+        scenario.addPrimaryForce(forceID);\n+    }\n+\n+    /**\n+     * Worker function that \"locks in\" a scenario -\n+     * Adds it to the campaign so it's visible in the briefing room,\n+     * adds it to the track\n+     *\n+     */\n+    public static void commitPrimaryForces(Campaign campaign, AtBContract contract, StratconScenario scenario, StratconTrackState trackState) {\n+        // order of operations is important here, we need a valid scenario ID prior to adding the scenario to the track.\n+        campaign.addScenario(scenario.getBackingScenario(), contract);\n+        scenario.setBackingScenarioID(scenario.getBackingScenario().getId());\n+        trackState.addScenario(scenario);\n+\n+        // set up dates for the scenario if doesn't have them already\n+        if (scenario.getDeploymentDate() == null) {\n+            scenario.setDeploymentDate(campaign.getLocalDate());\n+        }\n+\n+        if (scenario.getActionDate() == null) {\n+            scenario.setActionDate(campaign.getLocalDate());\n+        }\n+\n+        if(scenario.getReturnDate() == null) {\n+            scenario.setReturnDate(campaign.getLocalDate().plusDays(trackState.getDeploymentTime()));\n+        }\n+\n+        // set the # of rerolls based on the actual lance assigned.\n+        int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+        scenario.getBackingScenario().setRerolls(tactics);\n+        // The number of defensive points available to a force entering a scenario is\n+        // 2 x tactics. By default, those points are spent on conventional minefields.\n+        if (commanderLanceHasDefensiveAssignment(scenario.getBackingScenario(), campaign)) {\n+            scenario.setNumDefensivePoints(tactics * 2);\n+            scenario.updateMinefieldCount(Minefield.TYPE_CONVENTIONAL, tactics * 2);\n+        }\n+\n+        for (int forceID : scenario.getPlayerTemplateForceIDs()) {\n+            Force force = campaign.getForce(forceID);\n+            force.clearScenarioIds(campaign, true);\n+            force.setScenarioId(scenario.getBackingScenarioID());\n+        }\n+\n+        scenario.commitPrimaryForces();\n+    }\n+\n+    /**\n+     * Utility method to determine if the current scenario's force commander\n+     * is on defence\n+     */\n+    private static boolean commanderLanceHasDefensiveAssignment(AtBDynamicScenario scenario, Campaign campaign) {\n+        Unit commanderUnit = scenario.getLanceCommander(campaign).getUnit();\n+        Lance lance = campaign.getLances().get(commanderUnit.getForceId());\n+\n+        if ((lance != null) && (lance.getRole() == AtBLanceRole.DEFENCE)) {\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * A hackish worker function that takes the given list of force IDs and\n+     * separates it into three sets;\n+     * one of forces that can be \"primary\" on a ground map\n+     * one of forces that can be \"primary\" on an atmospheric map\n+     * one of forces that can be \"primary\" in a space map\n+     * @param forceIDs List of force IDs to check\n+     * @return Sorted hash map\n+     */\n+    private static Map<MapLocation, List<Integer>> sortForcesByMapType(List<Integer> forceIDs, Campaign campaign) {\n+        Map<MapLocation, List<Integer>> retVal = new HashMap<>();\n+\n+        retVal.put(MapLocation.AllGroundTerrain, new ArrayList<>());\n+        retVal.put(MapLocation.LowAtmosphere, new ArrayList<>());\n+        retVal.put(MapLocation.Space, new ArrayList<>());\n+\n+        for (int forceID : forceIDs) {\n+            switch(campaign.getForce(forceID).getPrimaryUnitType(campaign)) {\n+            case UnitType.BATTLE_ARMOR:\n+            case UnitType.INFANTRY:\n+            case UnitType.MEK:\n+            case UnitType.TANK:\n+            case UnitType.PROTOMEK:\n+            case UnitType.VTOL:\n+                retVal.get(MapLocation.AllGroundTerrain).add(forceID);\n+                break;\n+            case UnitType.AERO:\n+                retVal.get(MapLocation.Space).add(forceID);\n+                // intentional fallthrough here, ASFs can go to atmospheric maps too\n+            case UnitType.CONV_FIGHTER:\n+                retVal.get(MapLocation.LowAtmosphere).add(forceID);\n+                break;\n+            }\n+        }\n+\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * Determine whether the user should be nagged about unresolved scenarios on AtB Stratcon tracks.\n+     * @param campaign Campaign to check.\n+     * @return An informative string containing the reasons the user was nagged.\n+     */\n+    public static String nagUnresolvedContacts(Campaign campaign) {\n+        StringBuilder sb = new StringBuilder();\n+\n+        // check every track attached to an active contract for unresolved scenarios\n+        // to which the player must deploy forces today\n+        for (Contract contract : campaign.getActiveContracts()) {\n+            if(contract instanceof AtBContract) {\n+                for(StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    for(StratconScenario scenario : track.getScenarios().values()) {\n+                        if(scenario.getCurrentState() == ScenarioState.UNRESOLVED &&\n+                                campaign.getLocalDate().equals(scenario.getDeploymentDate())) {\n+                            // \"scenario name, track name\"\n+                            sb.append(String.format(\"%s, %s\\n\", scenario.getName(), track.getDisplayableName()));\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track.\n+     * Also registers it with the track and campaign.\n+     */\n+    private static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords) {\n+        int unitType = campaign.getForce(forceID).getPrimaryUnitType(campaign);\n+        ScenarioTemplate template = StratconScenarioFactory.getRandomScenario(unitType);\n+        // useful for debugging specific scenario types\n+        //ScenarioTemplate template = StratconScenarioFactory.getSpecificScenario(\"Allied Facility.xml\");\n+\n+        return generateScenario(campaign, contract, track, forceID, coords, template);\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track,\n+     * using the given template. Also registers it with the track and campaign.\n+     */\n+    static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords, ScenarioTemplate template) {\n+        StratconScenario scenario = new StratconScenario();\n+        scenario.setBackingScenario(AtBDynamicScenarioFactory.initializeScenarioFromTemplate(template, contract, campaign));\n+        scenario.setCoords(coords);\n+        \n+        // by default, certain conditions may make this bigger\n+        scenario.setRequiredPlayerLances(1);\n+\n+        // do an appropriate allied force if the contract calls for it\n+        // do any attached or integrated units\n+        setAlliedForceModifier(scenario, contract);\n+        setAttachedUnitsModifier(scenario, contract);\n+        applyFacilityModifiers(scenario, track, coords);\n+        applyGlobalModifiers(scenario, contract.getStratconCampaignState());\n+\n+        if ((contract.getCommandRights() == AtBContract.COM_HOUSE) ||\n+                (contract.getCommandRights() == AtBContract.COM_INTEGRATED)) {\n+            scenario.setRequiredScenario(true);\n+        }\n+\n+        AtBDynamicScenarioFactory.setScenarioModifiers(scenario.getBackingScenario());\n+        scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+        setScenarioDates(track, campaign, scenario);\n+\n+        // register the scenario with the campaign and the track it's generated on\n+        if (forceID > Force.FORCE_NONE) {\n+            scenario.addPrimaryForce(forceID);\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * Apply global scenario modifiers from campaign state to given scenario.\n+     */\n+    private static void applyGlobalModifiers(StratconScenario scenario, StratconCampaignState campaignState) {\n+        for (String modifierName : campaignState.getGlobalScenarioModifiers()) {\n+            AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierName);\n+\n+            if (modifier == null) {\n+                MekHQ.getLogger().error(String.format(\"Modifier %s not found; ignoring\", modifierName));\n+                continue;\n+            }\n+\n+            scenario.getBackingScenario().addScenarioModifier(modifier);\n+        }\n+    }\n+\n+    /**\n+     * Applies scenario modifiers from the current track to the given scenario.\n+     * @param scenario\n+     * @param track\n+     */\n+    private static void applyFacilityModifiers(StratconScenario scenario, StratconTrackState track, StratconCoords coords) {\n+        // loop through all the facilities on the track\n+        // if a facility has been revealed, then it has a 100% chance to apply its effect\n+        // if a facility has not been revealed, then it has a x% chance to apply its effect\n+        // if a facility is on the the scenario coordinates the it applies the local effects\n+        for (StratconCoords facilityCoords : track.getFacilities().keySet()) {\n+            boolean scenarioAtFacility = facilityCoords.equals(coords);\n+            StratconFacility facility = track.getFacilities().get(facilityCoords);\n+            List<String> modifierIDs = new ArrayList<>();\n+\n+            if (scenarioAtFacility) {\n+                modifierIDs = facility.getLocalModifiers();\n+            } else if (facility.isVisible() || (Compute.randomInt(100) <= facility.getAggroRating())) {\n+                modifierIDs = facility.getSharedModifiers();\n+            }\n+\n+            for (String modifierID : modifierIDs) {\n+                AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierID);\n+                if(modifier == null) {\n+                    MekHQ.getLogger().error(String.format(\"Modifier %s not found for facility %s\", modifierID, facility.getFormattedDisplayableName()));\n+                    continue;\n+                }\n+\n+                scenario.getBackingScenario().addScenarioModifier(modifier);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set up the appropriate primary allied force modifier, if any\n+     * @param contract The scenario's contract.\n+     */\n+    private static void setAlliedForceModifier(StratconScenario scenario, AtBContract contract) {\n+        int alliedUnitOdds = 0;\n+\n+        // first, we determine the odds of having an allied unit present\n+        // TODO: move this override out to the contract definition\n+        if (contract.getMissionType() == AtBContract.MT_RELIEFDUTY) {\n+            alliedUnitOdds = 50;\n+        } else {\n+            switch(contract.getCommandRights()) {\n+            case AtBContract.COM_INTEGRATED:\n+                alliedUnitOdds = 50;\n+                break;\n+            case AtBContract.COM_HOUSE:\n+                alliedUnitOdds = 30;\n+                break;\n+            case AtBContract.COM_LIAISON:\n+                alliedUnitOdds = 10;\n+                break;\n+            }\n+        }\n+\n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+\n+        // if an allied unit is present, then we want to make sure that it's ground units\n+        // for ground battles\n+        if (Compute.randomInt(100) <= alliedUnitOdds) {\n+            if((backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+               (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space)) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_ALLIED_AIR_UNITS));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_ALLIED_GROUND_UNITS));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set the 'attached' units modifier for the current scenario (integrated, house, liaison),\n+     * and make sure we're not deploying ground units to an air scenario\n+     * @param contract The scenario's contract\n+     */\n+    public static void setAttachedUnitsModifier(StratconScenario scenario, AtBContract contract) {\n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+        boolean airBattle = (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+                (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space);\n+\n+        // if we're on cadre duty, we're getting three trainees, period\n+        if (contract.getMissionType() == AtBContract.MT_CADREDUTY) {\n+            if (airBattle) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_TRAINEES_AIR));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_TRAINEES_GROUND));\n+            }\n+            return;\n+        }\n+\n+        // if we're under non-independent command rights, a supervisor may come along\n+        switch (contract.getCommandRights()) {\n+            case AtBContract.COM_INTEGRATED:\n+                if (airBattle) {\n+                    backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_INTEGRATED_UNITS_AIR));\n+                } else {\n+                    backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_INTEGRATED_UNITS_GROUND));\n+                }\n+                break;\n+            case AtBContract.COM_HOUSE:\n+                if (airBattle) {\n+                    backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_HOUSE_CO_AIR));\n+                } else {\n+                    backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_HOUSE_CO_GROUND));\n+                }\n+                break;\n+            case AtBContract.COM_LIAISON:\n+                if (scenario.isRequiredScenario()) {\n+                    if(airBattle) {\n+                        backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_LIAISON_AIR));\n+                    } else {\n+                        backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_LIAISON_GROUND));\n+                    }\n+                }\n+                break;\n+        }\n+    }\n+\n+    /**\n+     * Worker function that sets scenario deploy/battle/return dates based on the track's properties and current campaign date\n+     */\n+    private static void setScenarioDates(StratconTrackState track, Campaign campaign, StratconScenario scenario) {\n+     // set up deployment day, battle day, return day here\n+        // safety code to prevent attempts to generate random int with upper bound of 0 which is apparently illegal\n+        int deploymentDay = track.getDeploymentTime() < 7 ? Compute.randomInt(7 - track.getDeploymentTime()) : 0;\n+        int battleDay = deploymentDay + (track.getDeploymentTime() > 0 ? Compute.randomInt(track.getDeploymentTime()) : 0);\n+        int returnDay = deploymentDay + track.getDeploymentTime();\n+\n+        LocalDate deploymentDate = campaign.getLocalDate();\n+        deploymentDate.plusDays(deploymentDay);\n+        LocalDate battleDate = campaign.getLocalDate();\n+        deploymentDate.plusDays(battleDay);\n+        LocalDate returnDate = campaign.getLocalDate();\n+        returnDate.plusDays(returnDay);\n+\n+        scenario.setDeploymentDate(deploymentDate);\n+        scenario.setActionDate(battleDate);\n+        scenario.setReturnDate(returnDate);\n+    }\n+\n+    /**\n+     * Helper function that determines if the unit type specified in the given scenario force template\n+     * would start out airborne on a ground map (hot dropped units aside)\n+     */\n+    private static boolean unitTypeIsAirborne(ScenarioForceTemplate template) {\n+        int unitType = template.getAllowedUnitType();\n+\n+        return (unitType == UnitType.AERO ||\n+                unitType == UnitType.CONV_FIGHTER ||\n+                unitType == UnitType.DROPSHIP ||\n+                unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_MIX) &&\n+                template.getStartingAltitude() > 0;\n+    }\n+\n+    /**\n+     * Determines whether the force in question has the same primary unit type as the force template.\n+     * @return Whether or not the unit types match.\n+     */\n+    public static boolean forceCompositionMatchesDeclaredUnitType(int primaryUnitType, int unitType, boolean reinforcements) {\n+        // special cases are \"ATB_MIX\" and \"ATB_AERO_MIX\", which encompass multiple unit types\n+        if (unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_MIX) {\n+            // \"AtB mix\" is usually ground units, but air units can sub in\n+            return primaryUnitType == UnitType.MEK ||\n+                    primaryUnitType == UnitType.TANK ||\n+                    primaryUnitType == UnitType.INFANTRY ||\n+                    primaryUnitType == UnitType.BATTLE_ARMOR ||\n+                    primaryUnitType == UnitType.PROTOMEK ||\n+                    primaryUnitType == UnitType.VTOL ||\n+                    (primaryUnitType == UnitType.AERO) && reinforcements ||\n+                    (primaryUnitType == UnitType.CONV_FIGHTER) && reinforcements;\n+        } else if (unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_AERO_MIX) {\n+            return primaryUnitType == UnitType.AERO ||\n+                    primaryUnitType == UnitType.CONV_FIGHTER;\n+        } else {\n+            return primaryUnitType == unitType;\n+        }\n+    }\n+\n+    /**\n+     * This is a set of all force IDs for forces that can be deployed to a scenario.\n+     * @param campaign Current campaign\n+     * @return Set of available force IDs.\n+     */\n+    public static List<Integer> getAvailableForceIDs(Campaign campaign) {\n+        List<Integer> retVal = new ArrayList<>();\n+\n+        // first, we gather a set of all forces that are already deployed to a track so we eliminate those later\n+        Set<Integer> forcesInTracks = new HashSet<>();\n+        for (Contract contract : campaign.getActiveContracts()) {\n+            if(contract instanceof AtBContract) {\n+                for(StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    forcesInTracks.addAll(track.getAssignedForceCoords().keySet());\n+                }\n+            }\n+        }\n+\n+        // now, we get all the forces that qualify as \"lances\", and filter out those that are\n+        // deployed to a scenario and not in a track already\n+        for (int key : campaign.getLances().keySet()) {\n+            Force force = campaign.getForce(key);\n+            if (force != null &&\n+                    !force.isDeployed() &&\n+                    !forcesInTracks.contains(force.getId())) {\n+                retVal.add(force.getId());\n+            }\n+        }\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * This is a list of all force IDs for forces that can be deployed to a scenario in the given force template\n+     * a) have not been assigned to a track\n+     * b) are combat-capable\n+     * c) are not deployed to a scenario\n+     * d) if attempting to deploy as reinforcements, haven't already failed to deploy\n+     */\n+    public static List<Integer> getAvailableForceIDs(int unitType, Campaign campaign, StratconTrackState currentTrack,\n+            boolean reinforcements, @Nullable StratconScenario currentScenario) {\n+        List<Integer> retVal = new ArrayList<>();\n+\n+        Set<Integer> forcesInTracks = new HashSet<>();\n+        // assemble a set of all force IDs that are currently assigned to tracks that are not this one\n+        for (Contract contract : campaign.getActiveContracts()) {\n+            if (contract instanceof AtBContract) {\n+                for (StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    if ((track != currentTrack) || !reinforcements) {\n+                        forcesInTracks.addAll(track.getAssignedForceCoords().keySet());\n+                    }\n+                }\n+            }\n+        }\n+        \n+        // if there's an existing scenario and we're doing reinforcements,\n+        // prevent forces that failed to deploy from trying to deploy again\n+        if (reinforcements && (currentScenario != null)) {\n+            forcesInTracks.addAll(currentScenario.getFailedReinforcements());\n+        }\n+\n+        for (int key : campaign.getLances().keySet()) {\n+            Force force = campaign.getForce(key);\n+\n+            if (force == null) {\n+                continue;\n+            }\n+\n+            int primaryUnitType = force.getPrimaryUnitType(campaign);\n+            if (!force.isDeployed() &&\n+                    (force.getScenarioId() <= 0) &&\n+                    !force.getUnits().isEmpty() &&\n+                    !forcesInTracks.contains(force.getId()) &&\n+                    forceCompositionMatchesDeclaredUnitType(primaryUnitType, unitType, reinforcements)) {\n+                retVal.add(force.getId());\n+            }\n+        }\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * Returns a list of individual units eligible for deployment in scenarios run by \"Defend\" lances\n+     * @return List of unit IDs.\n+     */\n+    public static List<Unit> getEligibleDefensiveUnits(Campaign campaign) {\n+        List<Unit> retVal = new ArrayList<>();\n+\n+        for (Unit u : campaign.getUnits()) {\n+            // \"defensive\" units are infantry, battle armor and (Weisman help you) gun emplacements\n+        \t// and also said unit should be intact/alive/etc\n+        \tboolean isEligibleInfantry = \n+        \t\t\t((u.getEntity().getUnitType() == UnitType.INFANTRY) ||\n+                    (u.getEntity().getUnitType() == UnitType.BATTLE_ARMOR)) &&\n+                    !u.isUnmanned();\n+        \t\n+        \tboolean isEligibleGunEmplacement = u.getEntity().getUnitType() == UnitType.GUN_EMPLACEMENT;\n+        \t\n+        \tif ((isEligibleInfantry || isEligibleGunEmplacement) && \n+            \t\t!u.isDeployed() &&\n+                    !u.isMothballed() &&\n+                    u.isFunctional()) {\n+\n+                // this is a little inefficient, but probably there aren't too many active AtB contracts at a time\n+                for (Contract contract : campaign.getActiveContracts()) {\n+                    if((contract instanceof AtBContract) &&\n+                            ((AtBContract) contract).getStratconCampaignState().isForceDeployedHere(u.getForceId())) {\n+                        continue;\n+                    }\n+                }\n+\n+                retVal.add(u);\n+            }\n+        }\n+\n+        return retVal;\n+    }\n+    \n+    /**\n+     * Returns a list of individual units eligible for deployment in scenarios\n+     * that result from the lance leader having a leadership score\n+     * @return List of unit IDs.\n+     */\n+    public static List<Unit> getEligibleLeadershipUnits(Campaign campaign, Set<Integer> forceIDs) {\n+        List<Unit> retVal = new ArrayList<>();\n+\n+        // The criteria are as follows:\n+        // - unit is of a different unit type than the primary unit type of the force \n+        // - unit has a lower BV than the force's lowest BV unit\n+        \n+        Integer lowestBV = getLowestBV(campaign, forceIDs);\n+        \n+        // no units assigned, the rest is meaningless.\n+        if (lowestBV == null) {\n+            return retVal;\n+        }\n+        \n+        int primaryUnitType = getPrimaryUnitType(campaign, forceIDs);\n+        \n+        for (Unit u : campaign.getUnits()) {\n+            if ((primaryUnitType != u.getEntity().getUnitType()) &&\n+                    !u.isDeployed() &&\n+                    !u.isMothballed() &&\n+                    u.isFunctional() &&\n+                    (u.getEntity().calculateBattleValue() < lowestBV) &&\n+                    !isUnitDeployedToStratCon(u)) {", "originalCommit": "0244602bac43aacfd804a92250447a67a4fbd75a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNDUwNzI2NA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r604507264", "bodyText": "getActiveAtBContracts, spacing", "author": "Windchild292", "createdAt": "2021-03-31T00:02:31Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1291 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.UUID;\n+\n+import megamek.common.Compute;\n+import megamek.common.Minefield;\n+import megamek.common.UnitType;\n+import megamek.common.annotations.Nullable;\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.Utilities;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.ResolveScenarioTracker;\n+import mekhq.campaign.againstTheBot.enums.AtBLanceRole;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.event.StratconDeploymentEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.force.Lance;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier.EventTiming;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.unit.Unit;\n+\n+/**\n+ * This class contains \"rules\" logic for the AtB-Stratcon state\n+ * @author NickAragua\n+ */\n+public class StratconRulesManager {\n+    /**\n+     * What makes a particular lance eligible to be reinforcements for a scenario\n+     * @author NickAragua\n+     */\n+    public enum ReinforcementEligibilityType {\n+        /**\n+         * Nothing\n+         */\n+        None,\n+\n+        /**\n+         * Lance is already deployed to the track\n+         */\n+        ChainedScenario,\n+\n+        /**\n+         * We pay a support point or convert a victory point to a support point\n+         */\n+        SupportPoint,\n+\n+        /**\n+         * The lance's deployment orders are \"Fight\"\n+         */\n+        FightLance\n+    }\n+\n+    /**\n+     * This function potentially generates non-player-initiated scenarios for the given track.\n+     */\n+    public static void generateScenariosForTrack(Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // maps scenarios to force IDs\n+        List<StratconScenario> generatedScenarios = new ArrayList<>();\n+        boolean autoAssignLances = contract.getCommandRights() == AtBContract.COM_INTEGRATED;\n+\n+        // get this list just so we have it available\n+        List<Integer> availableForceIDs = getAvailableForceIDs(campaign);\n+        Map<MapLocation, List<Integer>> sortedAvailableForceIDs = sortForcesByMapType(availableForceIDs, campaign);\n+\n+        // make X rolls, where X is the number of required lances for the track\n+        // that's the chance to spawn a scenario.\n+        // if a scenario occurs, then we pick a random non-deployed lance and use it to drive the opfor generation later\n+        // once we've determined that scenarios occur, we loop through the ones that we generated\n+        // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all\n+        for (int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            // if we haven't already used all the player forces and are required to randomly generate a scenario\n+            if ((availableForceIDs.size() > 0) &&\n+                    (Compute.randomInt(100) <= track.getScenarioOdds())) {\n+                // pick random coordinates and force to drive the scenario\n+                int x = Compute.randomInt(track.getWidth());\n+                int y = Compute.randomInt(track.getHeight());\n+\n+                StratconCoords scenarioCoords = new StratconCoords(x, y);\n+\n+                // if forces are already assigned to these coordinates, use those instead\n+                // of randomly-selected ones\n+                if (track.getAssignedCoordForces().containsKey(scenarioCoords)) {\n+                    StratconScenario scenario = generateScenarioForExistingForces(scenarioCoords,\n+                            track.getAssignedCoordForces().get(scenarioCoords), \n+                            contract, campaign, track);\n+                    generatedScenarios.add(scenario);\n+                    continue;\n+                }\n+                \n+                // otherwise, pick a random force from the avail\n+                int randomForceIndex = Compute.randomInt(availableForceIDs.size());\n+                int randomForceID = availableForceIDs.get(randomForceIndex);\n+                \n+                // remove the force from the available lists so we don't designate it as primary twice\n+                availableForceIDs.remove(randomForceIndex);\n+\n+                // we want to remove the actual int with the value, not the value at the index\n+                sortedAvailableForceIDs.get(MapLocation.AllGroundTerrain).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.LowAtmosphere).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.Space).remove((Integer) randomForceID);\n+\n+                // two scenarios on the same coordinates wind up increasing in size\n+                if (track.getScenarios().containsKey(scenarioCoords)) {\n+                    track.getScenarios().get(scenarioCoords).incrementRequiredPlayerLances();\n+                    assignAppropriateExtraForceToScenario(track.getScenarios().get(scenarioCoords), sortedAvailableForceIDs);\n+                    continue;\n+                }\n+\n+                StratconScenario scenario = setupScenario(scenarioCoords, randomForceID, campaign, contract, track);\n+                generatedScenarios.add(scenario);\n+\n+                // if we're auto-assigning lances, deploy the force to the track as well\n+                if (autoAssignLances) {\n+                    processForceDeployment(scenarioCoords, randomForceID, campaign, track, false);\n+                }\n+            }\n+        }\n+\n+        // if under liaison command, pick a random scenario from the ones generated\n+        // to set as required and attach liaison\n+        if (contract.getCommandRights() == AtBContract.COM_LIAISON) {\n+        \tStratconScenario randomScenario = Utilities.getRandomItem(generatedScenarios);\n+        \trandomScenario.setRequiredScenario(true);\n+            setAttachedUnitsModifier(randomScenario, contract);\n+        }\n+\n+        // now, we loop through all the scenarios we set up\n+        // and generate the opfors / events / etc\n+        // if not auto-assigning lances, we then back out the lance assignments.\n+        for (StratconScenario scenario : generatedScenarios) {\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+\n+            if(!autoAssignLances && !scenario.ignoreForceAutoAssignment()) {\n+                for(int forceID : scenario.getPlayerTemplateForceIDs()) {\n+                    scenario.getBackingScenario().removeForce(forceID);\n+                }\n+\n+                scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                track.addScenario(scenario);\n+            } else {\n+                commitPrimaryForces(campaign, contract, scenario, track);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Given a set of force IDs and coordinates, generate a scenario\n+     * Useful for when we want to generate scenarios \n+     * for forces already deployed to a track\n+     */\n+    public static StratconScenario generateScenarioForExistingForces(StratconCoords scenarioCoords, \n+            Set<Integer> forceIDs, AtBContract contract, Campaign campaign, StratconTrackState track) {\n+        boolean firstForce = true;\n+        StratconScenario scenario = null;\n+        \n+        for (int forceID : forceIDs) {\n+            if (firstForce) {\n+                scenario = setupScenario(scenarioCoords, forceID, campaign, contract, track);\n+                firstForce = false;\n+            } else {\n+                scenario.incrementRequiredPlayerLances();\n+                scenario.addPrimaryForce(forceID);\n+            }\n+        }\n+        \n+        scenario.setIgnoreForceAutoAssignment(true);\n+        return scenario;\n+    }\n+\n+    /**\n+     * Deploys a force to the given coordinates on the given track as a result of explicit player action.\n+     */\n+    public static void deployForceToCoords(StratconCoords coords, int forceID, \n+            Campaign campaign, AtBContract contract, StratconTrackState track, boolean sticky) {\n+        // the following things should happen:\n+        // 1. call to \"process force deployment\", which reveals fog of war in or around the coords, depending on force role\n+        // 2. if coords are a hostile facility, we get a facility mission\n+        // 3. if coords are empty, we *may* get a mission\n+\n+        processForceDeployment(coords, forceID, campaign, track, sticky);\n+\n+        // don't create a scenario on top of allied facilities\n+        StratconFacility facility = track.getFacility(coords);\n+        boolean isNonAlliedFacility = (facility != null) && (facility.getOwner() != ForceAlignment.Allied);\n+        boolean spawnScenario = (facility == null) && (Compute.randomInt(100) <= track.getScenarioOdds());\n+\n+        if (isNonAlliedFacility || spawnScenario) {\n+            StratconScenario scenario = setupScenario(coords, forceID, campaign, contract, track);\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            commitPrimaryForces(campaign, contract, scenario, track);\n+        }\n+    }\n+\n+    /**\n+     * Logic to set up a scenario\n+     */\n+    private static StratconScenario setupScenario(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        StratconScenario scenario = null;\n+\n+        if (track.getFacilities().containsKey(coords)) {\n+            StratconFacility facility = track.getFacility(coords);\n+            boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+            ScenarioTemplate template = StratconScenarioFactory.getFacilityScenario(alliedFacility);\n+            scenario = generateScenario(campaign, contract, track, forceID, coords, template);\n+            setupFacilityScenario(scenario, facility);\n+        } else {\n+            scenario = generateScenario(campaign, contract, track, forceID, coords);\n+\n+            // we may generate a facility scenario randomly - if so, do the facility-related stuff\n+            // and add a new facility to the track\n+            if (scenario.getBackingScenario().getTemplate().isFacilityScenario()) {\n+                StratconFacility facility = scenario.getBackingScenario().getTemplate().isHostileFacility() ?\n+                        StratconFacilityFactory.getRandomHostileFacility() : StratconFacilityFactory.getRandomAlliedFacility();\n+                facility.setVisible(true);\n+                track.addFacility(coords, facility);\n+                setupFacilityScenario(scenario, facility);\n+            }\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * carries out tasks relevant to facility scenarios\n+     */\n+    private static void setupFacilityScenario(StratconScenario scenario, StratconFacility facility) {\n+        // this includes:\n+        // for hostile facilities\n+        // - add a destroy objective (always the option to level the facility)\n+        // - add a capture objective (always the option to capture the facility)\n+        // - if so indicated by parameter, roll a random hostile facility objective and add it if not capture/destroy\n+        // for allied facilities\n+        // - add a defend objective (always the option to defend the facility)\n+        // - if so indicated by parameter, roll a random allied facility objective and add it if not defend\n+        AtBScenarioModifier objectiveModifier = null;\n+        boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+\n+        if (alliedFacility) {\n+            objectiveModifier = AtBScenarioModifier.getRandomAlliedFacilityModifier();\n+        } else {\n+            objectiveModifier = AtBScenarioModifier.getRandomHostileFacilityModifier();\n+        }\n+\n+        if (objectiveModifier != null) {\n+            scenario.getBackingScenario().addScenarioModifier(objectiveModifier);\n+            scenario.getBackingScenario().setName(String.format(\"%s - %s - %s\",\n+                    facility.getFacilityType(), alliedFacility ? \"Allied\" : \"Hostile\", objectiveModifier.getModifierName()));\n+        }\n+\n+        // add the \"fixed\" hostile facility modifiers after the primary ones\n+        if (!alliedFacility) {\n+            for(AtBScenarioModifier modifier : AtBScenarioModifier.getRequiredHostileFacilityModifiers()) {\n+                if(!scenario.getBackingScenario().alreadyHasModifier(modifier)) {\n+                    scenario.getBackingScenario().addScenarioModifier(modifier);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void processFacilityEffects(StratconTrackState track) {\n+        // TODO: these are \"weekly\"? effects that a stratcon facility has on the campaign/track state\n+        // currrently, that's\n+        // supply depot - allied - +1 sp\n+        // supply depot - hostile - +5% BV budget to all scenarios on track (shared modifier, so should be implemented there)\n+        // data center - allied - +1% star league cache contract (don't implement yet, but...)\n+        // data center - hostile - +5% scenario odds in track\n+        // industrial center - allied - all scenarios here have THIS IS COMING OUT OF YOUR PAYCHECK modifier\n+        // orbital defense - allied - sets 'no hostile aircraft' flag for track\n+        // orbital defense - hostile - sets 'no allied aircraft' flag for track\n+        // early warning system - allied - sets 'intercept allied base attacks' flag for track\n+        // early warning system - hostile - sets 'intercept hostile base attacks' flag for track\n+    }\n+\n+    /**\n+     * Process the deployment of a force to the given coordinates on the given track.\n+     */\n+    public static void processForceDeployment(StratconCoords coords, int forceID, \n+            Campaign campaign, StratconTrackState track, boolean sticky) {\n+        track.getRevealedCoords().add(coords);\n+        StratconFacility facility = track.getFacility(coords);\n+        if (facility != null) {\n+            facility.setVisible(true);\n+        }\n+\n+        if (campaign.getLances().get(forceID).getRole() == AtBLanceRole.SCOUTING) {\n+            for(int direction = 0; direction < 6; direction++) {\n+                StratconCoords checkCoords = coords.translate(direction);\n+\n+                facility = track.getFacility(checkCoords);\n+                if(facility != null) {\n+                    facility.setVisible(true);\n+                }\n+\n+                track.getRevealedCoords().add(coords.translate(direction));\n+            }\n+        }\n+\n+        // the force may be located in other places on the track - clear it out\n+        track.unassignForce(forceID);\n+        track.assignForce(forceID, coords, campaign.getLocalDate(), sticky);\n+        MekHQ.triggerEvent(new StratconDeploymentEvent(campaign.getForce(forceID)));\n+    }\n+\n+    /**\n+     * Worker function that processes the effects of deploying a reinforcement force to a scenario\n+     */\n+    public static boolean processReinforcementDeployment(ReinforcementEligibilityType reinforcementType,\n+            StratconCampaignState campaignState, StratconScenario scenario, Campaign campaign) {\n+        // if the force is already deployed to the track, we're done\n+        // if the force is a fight lance or we're using a support point\n+        // if there is an SP to burn, burn it and we're done\n+        // if there is a VP to burn, burn it and we're done\n+        // now, roll 2d6 + lance commander tactics\n+        // 9+ = deploy\n+        // 6+ = deploy, apply negative modifier to scenario\n+        // 2+ = fail to deploy, apply negative modifier to scenario; if fight lance, treat as 6+\n+\n+        if ((reinforcementType == ReinforcementEligibilityType.FightLance) ||\n+                (reinforcementType == ReinforcementEligibilityType.SupportPoint)) {\n+\n+            if (campaignState.getSupportPoints() > 0) {\n+                campaignState.useSupportPoint();\n+                return true;\n+            } else if (campaignState.getVictoryPoints() > 0) {\n+                campaignState.updateVictoryPoints(-1);\n+                return true;\n+            }\n+\n+            int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+            int roll = Compute.d6(2);\n+            int result = roll + tactics;\n+\n+            StringBuilder reportStatus = new StringBuilder();\n+            reportStatus.append(String.format(\"Attempting to reinforce scenario %s without SP/VP, roll 2d6 + %d: %d\",\n+                    scenario.getName(), tactics, result));\n+\n+            // fail to reinforce\n+            if ((result < 6) && (reinforcementType != ReinforcementEligibilityType.FightLance)) {\n+                reportStatus.append(\" - reinforcement attempt failed.\");\n+                campaign.addReport(reportStatus.toString());\n+                return false;\n+            // succeed but get an extra negative event added to the scenario\n+            } else if (result < 9) {\n+                MapLocation mapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+                AtBScenarioModifier scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+\n+                // keep rolling until we get an applicable one\n+                // TODO: have the AtBScenarioModifier sort these out instead for performance?\n+                while (scenarioModifier.getEventTiming() != EventTiming.PostForceGeneration) {\n+                    scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+                }\n+\n+                scenarioModifier.processModifier(scenario.getBackingScenario(), campaign, EventTiming.PostForceGeneration);\n+\n+                reportStatus.append(String.format(\" - reinforcement attempt succeeded; extra negative modifier (%s) applied to scenario.\",\n+                        scenarioModifier.getModifierName()));\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            // succeed without reservation\n+            } else {\n+                reportStatus.append(\" - reinforcement attempt succeeded;\");\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            }\n+        } else if (reinforcementType == ReinforcementEligibilityType.None) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Assigns a force to the scenario such that the majority of the force can be deployed\n+     */\n+    private static void assignAppropriateExtraForceToScenario(StratconScenario scenario,\n+            Map<MapLocation, List<Integer>> sortedAvailableForceIDs) {\n+        // the goal of this function is to avoid assigning ground units to air battles\n+        // and ground units/conventional fighters to space battle\n+\n+        List<MapLocation> mapLocations = new ArrayList<>();\n+        mapLocations.add(MapLocation.Space); // can always add ASFs\n+\n+        MapLocation scenarioMapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+\n+        if (scenarioMapLocation == MapLocation.LowAtmosphere) {\n+            mapLocations.add(MapLocation.LowAtmosphere); // can add conventional fighters to ground or low atmo battles\n+        }\n+\n+        if ((scenarioMapLocation == MapLocation.AllGroundTerrain) ||\n+                (scenarioMapLocation == MapLocation.SpecificGroundTerrain)) {\n+            mapLocations.add(MapLocation.AllGroundTerrain); // can only add ground units to ground battles\n+        }\n+\n+        MapLocation selectedLocation = mapLocations.get(Compute.randomInt(mapLocations.size()));\n+        List<Integer> forceIDs = sortedAvailableForceIDs.get(selectedLocation);\n+        int forceIndex = Compute.randomInt(forceIDs.size());\n+        int forceID = forceIDs.get(forceIndex);\n+        forceIDs.remove(forceIndex);\n+\n+        scenario.addPrimaryForce(forceID);\n+    }\n+\n+    /**\n+     * Worker function that \"locks in\" a scenario -\n+     * Adds it to the campaign so it's visible in the briefing room,\n+     * adds it to the track\n+     *\n+     */\n+    public static void commitPrimaryForces(Campaign campaign, AtBContract contract, StratconScenario scenario, StratconTrackState trackState) {\n+        // order of operations is important here, we need a valid scenario ID prior to adding the scenario to the track.\n+        campaign.addScenario(scenario.getBackingScenario(), contract);\n+        scenario.setBackingScenarioID(scenario.getBackingScenario().getId());\n+        trackState.addScenario(scenario);\n+\n+        // set up dates for the scenario if doesn't have them already\n+        if (scenario.getDeploymentDate() == null) {\n+            scenario.setDeploymentDate(campaign.getLocalDate());\n+        }\n+\n+        if (scenario.getActionDate() == null) {\n+            scenario.setActionDate(campaign.getLocalDate());\n+        }\n+\n+        if(scenario.getReturnDate() == null) {\n+            scenario.setReturnDate(campaign.getLocalDate().plusDays(trackState.getDeploymentTime()));\n+        }\n+\n+        // set the # of rerolls based on the actual lance assigned.\n+        int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+        scenario.getBackingScenario().setRerolls(tactics);\n+        // The number of defensive points available to a force entering a scenario is\n+        // 2 x tactics. By default, those points are spent on conventional minefields.\n+        if (commanderLanceHasDefensiveAssignment(scenario.getBackingScenario(), campaign)) {\n+            scenario.setNumDefensivePoints(tactics * 2);\n+            scenario.updateMinefieldCount(Minefield.TYPE_CONVENTIONAL, tactics * 2);\n+        }\n+\n+        for (int forceID : scenario.getPlayerTemplateForceIDs()) {\n+            Force force = campaign.getForce(forceID);\n+            force.clearScenarioIds(campaign, true);\n+            force.setScenarioId(scenario.getBackingScenarioID());\n+        }\n+\n+        scenario.commitPrimaryForces();\n+    }\n+\n+    /**\n+     * Utility method to determine if the current scenario's force commander\n+     * is on defence\n+     */\n+    private static boolean commanderLanceHasDefensiveAssignment(AtBDynamicScenario scenario, Campaign campaign) {\n+        Unit commanderUnit = scenario.getLanceCommander(campaign).getUnit();\n+        Lance lance = campaign.getLances().get(commanderUnit.getForceId());\n+\n+        if ((lance != null) && (lance.getRole() == AtBLanceRole.DEFENCE)) {\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * A hackish worker function that takes the given list of force IDs and\n+     * separates it into three sets;\n+     * one of forces that can be \"primary\" on a ground map\n+     * one of forces that can be \"primary\" on an atmospheric map\n+     * one of forces that can be \"primary\" in a space map\n+     * @param forceIDs List of force IDs to check\n+     * @return Sorted hash map\n+     */\n+    private static Map<MapLocation, List<Integer>> sortForcesByMapType(List<Integer> forceIDs, Campaign campaign) {\n+        Map<MapLocation, List<Integer>> retVal = new HashMap<>();\n+\n+        retVal.put(MapLocation.AllGroundTerrain, new ArrayList<>());\n+        retVal.put(MapLocation.LowAtmosphere, new ArrayList<>());\n+        retVal.put(MapLocation.Space, new ArrayList<>());\n+\n+        for (int forceID : forceIDs) {\n+            switch(campaign.getForce(forceID).getPrimaryUnitType(campaign)) {\n+            case UnitType.BATTLE_ARMOR:\n+            case UnitType.INFANTRY:\n+            case UnitType.MEK:\n+            case UnitType.TANK:\n+            case UnitType.PROTOMEK:\n+            case UnitType.VTOL:\n+                retVal.get(MapLocation.AllGroundTerrain).add(forceID);\n+                break;\n+            case UnitType.AERO:\n+                retVal.get(MapLocation.Space).add(forceID);\n+                // intentional fallthrough here, ASFs can go to atmospheric maps too\n+            case UnitType.CONV_FIGHTER:\n+                retVal.get(MapLocation.LowAtmosphere).add(forceID);\n+                break;\n+            }\n+        }\n+\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * Determine whether the user should be nagged about unresolved scenarios on AtB Stratcon tracks.\n+     * @param campaign Campaign to check.\n+     * @return An informative string containing the reasons the user was nagged.\n+     */\n+    public static String nagUnresolvedContacts(Campaign campaign) {\n+        StringBuilder sb = new StringBuilder();\n+\n+        // check every track attached to an active contract for unresolved scenarios\n+        // to which the player must deploy forces today\n+        for (Contract contract : campaign.getActiveContracts()) {\n+            if(contract instanceof AtBContract) {\n+                for(StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    for(StratconScenario scenario : track.getScenarios().values()) {\n+                        if(scenario.getCurrentState() == ScenarioState.UNRESOLVED &&\n+                                campaign.getLocalDate().equals(scenario.getDeploymentDate())) {\n+                            // \"scenario name, track name\"\n+                            sb.append(String.format(\"%s, %s\\n\", scenario.getName(), track.getDisplayableName()));\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track.\n+     * Also registers it with the track and campaign.\n+     */\n+    private static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords) {\n+        int unitType = campaign.getForce(forceID).getPrimaryUnitType(campaign);\n+        ScenarioTemplate template = StratconScenarioFactory.getRandomScenario(unitType);\n+        // useful for debugging specific scenario types\n+        //ScenarioTemplate template = StratconScenarioFactory.getSpecificScenario(\"Allied Facility.xml\");\n+\n+        return generateScenario(campaign, contract, track, forceID, coords, template);\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track,\n+     * using the given template. Also registers it with the track and campaign.\n+     */\n+    static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords, ScenarioTemplate template) {\n+        StratconScenario scenario = new StratconScenario();\n+        scenario.setBackingScenario(AtBDynamicScenarioFactory.initializeScenarioFromTemplate(template, contract, campaign));\n+        scenario.setCoords(coords);\n+        \n+        // by default, certain conditions may make this bigger\n+        scenario.setRequiredPlayerLances(1);\n+\n+        // do an appropriate allied force if the contract calls for it\n+        // do any attached or integrated units\n+        setAlliedForceModifier(scenario, contract);\n+        setAttachedUnitsModifier(scenario, contract);\n+        applyFacilityModifiers(scenario, track, coords);\n+        applyGlobalModifiers(scenario, contract.getStratconCampaignState());\n+\n+        if ((contract.getCommandRights() == AtBContract.COM_HOUSE) ||\n+                (contract.getCommandRights() == AtBContract.COM_INTEGRATED)) {\n+            scenario.setRequiredScenario(true);\n+        }\n+\n+        AtBDynamicScenarioFactory.setScenarioModifiers(scenario.getBackingScenario());\n+        scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+        setScenarioDates(track, campaign, scenario);\n+\n+        // register the scenario with the campaign and the track it's generated on\n+        if (forceID > Force.FORCE_NONE) {\n+            scenario.addPrimaryForce(forceID);\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * Apply global scenario modifiers from campaign state to given scenario.\n+     */\n+    private static void applyGlobalModifiers(StratconScenario scenario, StratconCampaignState campaignState) {\n+        for (String modifierName : campaignState.getGlobalScenarioModifiers()) {\n+            AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierName);\n+\n+            if (modifier == null) {\n+                MekHQ.getLogger().error(String.format(\"Modifier %s not found; ignoring\", modifierName));\n+                continue;\n+            }\n+\n+            scenario.getBackingScenario().addScenarioModifier(modifier);\n+        }\n+    }\n+\n+    /**\n+     * Applies scenario modifiers from the current track to the given scenario.\n+     * @param scenario\n+     * @param track\n+     */\n+    private static void applyFacilityModifiers(StratconScenario scenario, StratconTrackState track, StratconCoords coords) {\n+        // loop through all the facilities on the track\n+        // if a facility has been revealed, then it has a 100% chance to apply its effect\n+        // if a facility has not been revealed, then it has a x% chance to apply its effect\n+        // if a facility is on the the scenario coordinates the it applies the local effects\n+        for (StratconCoords facilityCoords : track.getFacilities().keySet()) {\n+            boolean scenarioAtFacility = facilityCoords.equals(coords);\n+            StratconFacility facility = track.getFacilities().get(facilityCoords);\n+            List<String> modifierIDs = new ArrayList<>();\n+\n+            if (scenarioAtFacility) {\n+                modifierIDs = facility.getLocalModifiers();\n+            } else if (facility.isVisible() || (Compute.randomInt(100) <= facility.getAggroRating())) {\n+                modifierIDs = facility.getSharedModifiers();\n+            }\n+\n+            for (String modifierID : modifierIDs) {\n+                AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierID);\n+                if(modifier == null) {\n+                    MekHQ.getLogger().error(String.format(\"Modifier %s not found for facility %s\", modifierID, facility.getFormattedDisplayableName()));\n+                    continue;\n+                }\n+\n+                scenario.getBackingScenario().addScenarioModifier(modifier);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set up the appropriate primary allied force modifier, if any\n+     * @param contract The scenario's contract.\n+     */\n+    private static void setAlliedForceModifier(StratconScenario scenario, AtBContract contract) {\n+        int alliedUnitOdds = 0;\n+\n+        // first, we determine the odds of having an allied unit present\n+        // TODO: move this override out to the contract definition\n+        if (contract.getMissionType() == AtBContract.MT_RELIEFDUTY) {\n+            alliedUnitOdds = 50;\n+        } else {\n+            switch(contract.getCommandRights()) {\n+            case AtBContract.COM_INTEGRATED:\n+                alliedUnitOdds = 50;\n+                break;\n+            case AtBContract.COM_HOUSE:\n+                alliedUnitOdds = 30;\n+                break;\n+            case AtBContract.COM_LIAISON:\n+                alliedUnitOdds = 10;\n+                break;\n+            }\n+        }\n+\n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+\n+        // if an allied unit is present, then we want to make sure that it's ground units\n+        // for ground battles\n+        if (Compute.randomInt(100) <= alliedUnitOdds) {\n+            if((backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+               (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space)) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_ALLIED_AIR_UNITS));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_ALLIED_GROUND_UNITS));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set the 'attached' units modifier for the current scenario (integrated, house, liaison),\n+     * and make sure we're not deploying ground units to an air scenario\n+     * @param contract The scenario's contract\n+     */\n+    public static void setAttachedUnitsModifier(StratconScenario scenario, AtBContract contract) {\n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+        boolean airBattle = (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+                (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space);\n+\n+        // if we're on cadre duty, we're getting three trainees, period\n+        if (contract.getMissionType() == AtBContract.MT_CADREDUTY) {\n+            if (airBattle) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_TRAINEES_AIR));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_TRAINEES_GROUND));\n+            }\n+            return;\n+        }\n+\n+        // if we're under non-independent command rights, a supervisor may come along\n+        switch (contract.getCommandRights()) {\n+            case AtBContract.COM_INTEGRATED:\n+                if (airBattle) {\n+                    backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_INTEGRATED_UNITS_AIR));\n+                } else {\n+                    backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_INTEGRATED_UNITS_GROUND));\n+                }\n+                break;\n+            case AtBContract.COM_HOUSE:\n+                if (airBattle) {\n+                    backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_HOUSE_CO_AIR));\n+                } else {\n+                    backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_HOUSE_CO_GROUND));\n+                }\n+                break;\n+            case AtBContract.COM_LIAISON:\n+                if (scenario.isRequiredScenario()) {\n+                    if(airBattle) {\n+                        backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_LIAISON_AIR));\n+                    } else {\n+                        backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(AtBScenarioModifier.SCENARIO_MODIFIER_LIAISON_GROUND));\n+                    }\n+                }\n+                break;\n+        }\n+    }\n+\n+    /**\n+     * Worker function that sets scenario deploy/battle/return dates based on the track's properties and current campaign date\n+     */\n+    private static void setScenarioDates(StratconTrackState track, Campaign campaign, StratconScenario scenario) {\n+     // set up deployment day, battle day, return day here\n+        // safety code to prevent attempts to generate random int with upper bound of 0 which is apparently illegal\n+        int deploymentDay = track.getDeploymentTime() < 7 ? Compute.randomInt(7 - track.getDeploymentTime()) : 0;\n+        int battleDay = deploymentDay + (track.getDeploymentTime() > 0 ? Compute.randomInt(track.getDeploymentTime()) : 0);\n+        int returnDay = deploymentDay + track.getDeploymentTime();\n+\n+        LocalDate deploymentDate = campaign.getLocalDate();\n+        deploymentDate.plusDays(deploymentDay);\n+        LocalDate battleDate = campaign.getLocalDate();\n+        deploymentDate.plusDays(battleDay);\n+        LocalDate returnDate = campaign.getLocalDate();\n+        returnDate.plusDays(returnDay);\n+\n+        scenario.setDeploymentDate(deploymentDate);\n+        scenario.setActionDate(battleDate);\n+        scenario.setReturnDate(returnDate);\n+    }\n+\n+    /**\n+     * Helper function that determines if the unit type specified in the given scenario force template\n+     * would start out airborne on a ground map (hot dropped units aside)\n+     */\n+    private static boolean unitTypeIsAirborne(ScenarioForceTemplate template) {\n+        int unitType = template.getAllowedUnitType();\n+\n+        return (unitType == UnitType.AERO ||\n+                unitType == UnitType.CONV_FIGHTER ||\n+                unitType == UnitType.DROPSHIP ||\n+                unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_MIX) &&\n+                template.getStartingAltitude() > 0;\n+    }\n+\n+    /**\n+     * Determines whether the force in question has the same primary unit type as the force template.\n+     * @return Whether or not the unit types match.\n+     */\n+    public static boolean forceCompositionMatchesDeclaredUnitType(int primaryUnitType, int unitType, boolean reinforcements) {\n+        // special cases are \"ATB_MIX\" and \"ATB_AERO_MIX\", which encompass multiple unit types\n+        if (unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_MIX) {\n+            // \"AtB mix\" is usually ground units, but air units can sub in\n+            return primaryUnitType == UnitType.MEK ||\n+                    primaryUnitType == UnitType.TANK ||\n+                    primaryUnitType == UnitType.INFANTRY ||\n+                    primaryUnitType == UnitType.BATTLE_ARMOR ||\n+                    primaryUnitType == UnitType.PROTOMEK ||\n+                    primaryUnitType == UnitType.VTOL ||\n+                    (primaryUnitType == UnitType.AERO) && reinforcements ||\n+                    (primaryUnitType == UnitType.CONV_FIGHTER) && reinforcements;\n+        } else if (unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_AERO_MIX) {\n+            return primaryUnitType == UnitType.AERO ||\n+                    primaryUnitType == UnitType.CONV_FIGHTER;\n+        } else {\n+            return primaryUnitType == unitType;\n+        }\n+    }\n+\n+    /**\n+     * This is a set of all force IDs for forces that can be deployed to a scenario.\n+     * @param campaign Current campaign\n+     * @return Set of available force IDs.\n+     */\n+    public static List<Integer> getAvailableForceIDs(Campaign campaign) {\n+        List<Integer> retVal = new ArrayList<>();\n+\n+        // first, we gather a set of all forces that are already deployed to a track so we eliminate those later\n+        Set<Integer> forcesInTracks = new HashSet<>();\n+        for (Contract contract : campaign.getActiveContracts()) {\n+            if(contract instanceof AtBContract) {\n+                for(StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    forcesInTracks.addAll(track.getAssignedForceCoords().keySet());\n+                }\n+            }\n+        }\n+\n+        // now, we get all the forces that qualify as \"lances\", and filter out those that are\n+        // deployed to a scenario and not in a track already\n+        for (int key : campaign.getLances().keySet()) {\n+            Force force = campaign.getForce(key);\n+            if (force != null &&\n+                    !force.isDeployed() &&\n+                    !forcesInTracks.contains(force.getId())) {\n+                retVal.add(force.getId());\n+            }\n+        }\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * This is a list of all force IDs for forces that can be deployed to a scenario in the given force template\n+     * a) have not been assigned to a track\n+     * b) are combat-capable\n+     * c) are not deployed to a scenario\n+     * d) if attempting to deploy as reinforcements, haven't already failed to deploy\n+     */\n+    public static List<Integer> getAvailableForceIDs(int unitType, Campaign campaign, StratconTrackState currentTrack,\n+            boolean reinforcements, @Nullable StratconScenario currentScenario) {\n+        List<Integer> retVal = new ArrayList<>();\n+\n+        Set<Integer> forcesInTracks = new HashSet<>();\n+        // assemble a set of all force IDs that are currently assigned to tracks that are not this one\n+        for (Contract contract : campaign.getActiveContracts()) {\n+            if (contract instanceof AtBContract) {\n+                for (StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    if ((track != currentTrack) || !reinforcements) {\n+                        forcesInTracks.addAll(track.getAssignedForceCoords().keySet());\n+                    }\n+                }\n+            }\n+        }\n+        \n+        // if there's an existing scenario and we're doing reinforcements,\n+        // prevent forces that failed to deploy from trying to deploy again\n+        if (reinforcements && (currentScenario != null)) {\n+            forcesInTracks.addAll(currentScenario.getFailedReinforcements());\n+        }\n+\n+        for (int key : campaign.getLances().keySet()) {\n+            Force force = campaign.getForce(key);\n+\n+            if (force == null) {\n+                continue;\n+            }\n+\n+            int primaryUnitType = force.getPrimaryUnitType(campaign);\n+            if (!force.isDeployed() &&\n+                    (force.getScenarioId() <= 0) &&\n+                    !force.getUnits().isEmpty() &&\n+                    !forcesInTracks.contains(force.getId()) &&\n+                    forceCompositionMatchesDeclaredUnitType(primaryUnitType, unitType, reinforcements)) {\n+                retVal.add(force.getId());\n+            }\n+        }\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * Returns a list of individual units eligible for deployment in scenarios run by \"Defend\" lances\n+     * @return List of unit IDs.\n+     */\n+    public static List<Unit> getEligibleDefensiveUnits(Campaign campaign) {\n+        List<Unit> retVal = new ArrayList<>();\n+\n+        for (Unit u : campaign.getUnits()) {\n+            // \"defensive\" units are infantry, battle armor and (Weisman help you) gun emplacements\n+        \t// and also said unit should be intact/alive/etc\n+        \tboolean isEligibleInfantry = \n+        \t\t\t((u.getEntity().getUnitType() == UnitType.INFANTRY) ||\n+                    (u.getEntity().getUnitType() == UnitType.BATTLE_ARMOR)) &&\n+                    !u.isUnmanned();\n+        \t\n+        \tboolean isEligibleGunEmplacement = u.getEntity().getUnitType() == UnitType.GUN_EMPLACEMENT;\n+        \t\n+        \tif ((isEligibleInfantry || isEligibleGunEmplacement) && \n+            \t\t!u.isDeployed() &&\n+                    !u.isMothballed() &&\n+                    u.isFunctional()) {\n+\n+                // this is a little inefficient, but probably there aren't too many active AtB contracts at a time\n+                for (Contract contract : campaign.getActiveContracts()) {\n+                    if((contract instanceof AtBContract) &&\n+                            ((AtBContract) contract).getStratconCampaignState().isForceDeployedHere(u.getForceId())) {\n+                        continue;\n+                    }\n+                }\n+\n+                retVal.add(u);\n+            }\n+        }\n+\n+        return retVal;\n+    }\n+    \n+    /**\n+     * Returns a list of individual units eligible for deployment in scenarios\n+     * that result from the lance leader having a leadership score\n+     * @return List of unit IDs.\n+     */\n+    public static List<Unit> getEligibleLeadershipUnits(Campaign campaign, Set<Integer> forceIDs) {\n+        List<Unit> retVal = new ArrayList<>();\n+\n+        // The criteria are as follows:\n+        // - unit is of a different unit type than the primary unit type of the force \n+        // - unit has a lower BV than the force's lowest BV unit\n+        \n+        Integer lowestBV = getLowestBV(campaign, forceIDs);\n+        \n+        // no units assigned, the rest is meaningless.\n+        if (lowestBV == null) {\n+            return retVal;\n+        }\n+        \n+        int primaryUnitType = getPrimaryUnitType(campaign, forceIDs);\n+        \n+        for (Unit u : campaign.getUnits()) {\n+            if ((primaryUnitType != u.getEntity().getUnitType()) &&\n+                    !u.isDeployed() &&\n+                    !u.isMothballed() &&\n+                    u.isFunctional() &&\n+                    (u.getEntity().calculateBattleValue() < lowestBV) &&\n+                    !isUnitDeployedToStratCon(u)) {\n+                retVal.add(u);\n+            }\n+        }\n+\n+        return retVal;\n+    }\n+    \n+    /**\n+     * Check if the unit's force (if one exists) has been deployed to a StratCon track\n+     */\n+    public static boolean isUnitDeployedToStratCon(Unit u) {\n+        if (!u.getCampaign().getCampaignOptions().getUseStratCon()) {\n+            return false;\n+        }\n+        \n+        //this is a little inefficient, but probably there aren't too many active AtB contracts at a time\n+        for (Contract contract : u.getCampaign().getActiveContracts()) {\n+            if((contract instanceof AtBContract) &&", "originalCommit": "0244602bac43aacfd804a92250447a67a4fbd75a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNDUwOTM1Mg==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r604509352", "bodyText": "This should be after all of the variable declarations", "author": "Windchild292", "createdAt": "2021-03-31T00:09:05Z", "path": "MekHQ/src/mekhq/campaign/mission/atb/AtBScenarioModifier.java", "diffHunk": "@@ -75,65 +90,63 @@\n     private List<MapLocation> allowedMapLocations = null;\n     private Boolean useAmbushLogic = null; \n     private Boolean switchSides = null;\n+    private Integer numExtraEvents = null;\n     private List<ScenarioObjective> objectives = new ArrayList<>();\n     \n-    public static AtBScenarioModifier generateTestModifier() {\n-        AtBScenarioModifier sm = new AtBScenarioModifier();\n-        sm.objectives = new ArrayList<>();\n-        sm.objectives.add(new ScenarioObjective());\n-        \n-        return sm;\n-    }\n+    private Map<String, String> linkedModifiers = new HashMap<>(); \n     \n     /**\n      * Process this scenario modifier for a particular scenario, given a particular timing indicator.\n-     * @param scenario\n-     * @param campaign\n      * @param eventTiming Whether this is occurring before or after primary forces have been generated.\n      */\n     public void processModifier(AtBDynamicScenario scenario, Campaign campaign, EventTiming eventTiming) {", "originalCommit": "0244602bac43aacfd804a92250447a67a4fbd75a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNjI4NzU2NQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r606287565", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n          \n          \n            \n             * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the", "author": "Windchild292", "createdAt": "2021-04-02T15:27:57Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconContractInitializer.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ * Copyright (c) 2019 The Megamek Team. All rights reserved.\n+ *\n+ * This file is part of MekHQ.\n+ *\n+ * MekHQ is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * MekHQ is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the", "originalCommit": "55af097696b44f689e0ff88123ab5f39b18bd8c0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNjI4NzYyNw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r606287627", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * along with MekHQ.  If not, see <http://www.gnu.org/licenses/>.\n          \n          \n            \n             * along with MekHQ. If not, see <http://www.gnu.org/licenses/>.", "author": "Windchild292", "createdAt": "2021-04-02T15:28:05Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconContractInitializer.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ * Copyright (c) 2019 The Megamek Team. All rights reserved.\n+ *\n+ * This file is part of MekHQ.\n+ *\n+ * MekHQ is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * MekHQ is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with MekHQ.  If not, see <http://www.gnu.org/licenses/>.", "originalCommit": "55af097696b44f689e0ff88123ab5f39b18bd8c0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNjI4Nzg4OQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r606287889", "bodyText": "Not certain, but <br> should work just fine", "author": "Windchild292", "createdAt": "2021-04-02T15:28:39Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconContractInitializer.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ * Copyright (c) 2019 The Megamek Team. All rights reserved.\n+ *\n+ * This file is part of MekHQ.\n+ *\n+ * MekHQ is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * MekHQ is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with MekHQ.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import megamek.common.Compute;\n+import mekhq.MekHQ;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.Mission;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.stratcon.StratconContractDefinition.ObjectiveParameters;\n+\n+/**\n+ * This class handles StratCon state initialization when a contract is signed.\n+ */\n+public class StratconContractInitializer {\n+    public static final int NUM_LANCES_PER_TRACK = 3;\n+\n+    /**\n+     * Initializes the campaign state given a contract, campaign and contract definition\n+     */\n+    public static void initializeCampaignState(AtBContract contract, Campaign campaign, StratconContractDefinition contractDefinition) {\n+        StratconCampaignState campaignState = new StratconCampaignState(contract);\n+        campaignState.setBriefingText(contractDefinition.getBriefing() + \"<br/>\" + generateCommandLevelText(contract));", "originalCommit": "55af097696b44f689e0ff88123ab5f39b18bd8c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNjU0NzEwOA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r606547108", "bodyText": "Probably, but it's a personal preference.", "author": "NickAragua", "createdAt": "2021-04-03T00:55:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNjI4Nzg4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNjI4ODg1Mg==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r606288852", "bodyText": "Odd indenting here", "author": "Windchild292", "createdAt": "2021-04-02T15:30:55Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconScenarioFactory.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import megamek.common.UnitType;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.Utilities;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.atb.AtBScenarioManifest;\n+\n+/**\n+ * This class handles functionality related to loading and sorting scenario templates.\n+ * @author NickAragua\n+ */\n+public class StratconScenarioFactory {\n+    // loaded dynamic scenario templates, sorted by location (ground, low atmosphere, space)\n+    private static Map<MapLocation, List<ScenarioTemplate>> dynamicScenarioLocationMap = new HashMap<>();\n+    private static Map<Integer, List<ScenarioTemplate>> dynamicScenarioUnitTypeMap = new HashMap<>();\n+    private static Map<String, ScenarioTemplate> dynamicScenarioNameMap = new HashMap<>();\n+    private static String HOSTILE_FACILITY_SCENARIO = \"Hostile Facility.xml\";\n+    private static String ALLIED_FACILITY_SCENARIO = \"Allied Facility.xml\";\n+    \n+    static {\n+        reloadScenarios();\n+    }\n+    \n+    /**\n+     * Reload the dynamic scenarios. \n+     */\n+    public static void reloadScenarios() {\n+        dynamicScenarioLocationMap.clear();\n+        dynamicScenarioUnitTypeMap.clear();\n+        \n+        // load dynamic scenarios\n+        AtBScenarioManifest scenarioManifest = AtBScenarioManifest.Deserialize(MekHqConstants.STRATCON_SCENARIO_MANIFEST);\n+        \n+        // load user-specified scenario list\n+        AtBScenarioManifest userManifest = AtBScenarioManifest.Deserialize(MekHqConstants.STRATCON_USER_SCENARIO_MANIFEST);\n+        \n+        if (scenarioManifest != null) {\n+            loadScenariosFromManifest(scenarioManifest);\n+        }\n+        \n+        if (userManifest != null) {\n+            loadScenariosFromManifest(userManifest);\n+        }\n+    }\n+    \n+    /**\n+     * Helper function that loads scenario templates from the given manifest.\n+     * @param manifest The manifest to process\n+     */\n+    private static void loadScenariosFromManifest(AtBScenarioManifest manifest) {\n+        if (manifest == null) {\n+            return;\n+        }\n+        \n+        for (int key : manifest.scenarioFileNames.keySet()) {\n+            String fileName = manifest.scenarioFileNames.get(key).trim();\n+            String filePath = Paths.get(MekHqConstants.STRATCON_SCENARIO_TEMPLATE_PATH, \n+            \t\tmanifest.scenarioFileNames.get(key).trim()).toString();\n+            \n+            try {\n+                ScenarioTemplate template = ScenarioTemplate.Deserialize(filePath);\n+                \n+                if (template != null) {\n+                    MapLocation locationKey = template.mapParameters.getMapLocation();\n+                    \n+                    // sort templates by location\n+                    if (!dynamicScenarioLocationMap.containsKey(locationKey)) {\n+                        dynamicScenarioLocationMap.put(locationKey, new ArrayList<>());\n+                    }\n+                    \n+                    dynamicScenarioLocationMap.get(locationKey).add(template);\n+                    \n+                    // sort templates by primary force unit type\n+                    int playerForceUnitType = template.getPrimaryPlayerForce().getAllowedUnitType();\n+                    if (!dynamicScenarioUnitTypeMap.containsKey(playerForceUnitType)) {\n+                        dynamicScenarioUnitTypeMap.put(playerForceUnitType, new ArrayList<>());\n+                    }\n+                    \n+                    dynamicScenarioUnitTypeMap.get(playerForceUnitType).add(template);\n+                    \n+                    dynamicScenarioNameMap.put(fileName, template);\n+                }\n+            } catch (Exception e) {\n+                MekHQ.getLogger().error(String.format(\"Error loading file: %s\", filePath), e);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Retrieves a random scenario template in the appropriate location.\n+     * @param location The location (ground/low atmo/space) category of the scenario.\n+     * @return Random scenario template.\n+     */\n+    public static ScenarioTemplate getRandomScenario(MapLocation location) {\n+    \treturn Utilities.getRandomItem(dynamicScenarioLocationMap.get(location)).clone();\n+    }\n+    \n+    /**\n+     * Retrieves a specific scenario given the key (file name)\n+     */\n+    public static ScenarioTemplate getSpecificScenario(String name) {\n+        return dynamicScenarioNameMap.get(name).clone();\n+    }\n+    \n+    /**\n+     * Retrieves a random scenario template appropriate for the given unit type.\n+     * This includes the more general ATB_MIX and ATB_AERO_MIX where appropriate\n+     * @param unitType The desired unit type, as per megamek.common.UnitType\n+     * @return Random scenario template.\n+     */\n+    public static ScenarioTemplate getRandomScenario(int unitType) {\n+        int generalUnitType = convertSpecificUnitTypeToGeneral(unitType);\n+        \n+        // if the specific unit type doesn't have any scenario templates for it\n+        // then we can't generate a scenario.\n+        if (!dynamicScenarioUnitTypeMap.containsKey(unitType) &&\n+            !dynamicScenarioUnitTypeMap.containsKey(generalUnitType)) {\n+                MekHQ.getLogger().warning(String.format(\"No scenarios configured for unit type %d\", unitType));\n+                return null;\n+        }", "originalCommit": "55af097696b44f689e0ff88123ab5f39b18bd8c0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNjI4OTE5OA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r606289198", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (allied) {\n          \n          \n            \n                        return getSpecificScenario(ALLIED_FACILITY_SCENARIO);\n          \n          \n            \n                    } else {\n          \n          \n            \n                        return getSpecificScenario(HOSTILE_FACILITY_SCENARIO);\n          \n          \n            \n                    }\n          \n          \n            \n                    return getSpecificScenario(allied ? ALLIED_FACILITY_SCENARIO : HOSTILE_FACILITY_SCENARIO);", "author": "Windchild292", "createdAt": "2021-04-02T15:31:51Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconScenarioFactory.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import megamek.common.UnitType;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.Utilities;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.atb.AtBScenarioManifest;\n+\n+/**\n+ * This class handles functionality related to loading and sorting scenario templates.\n+ * @author NickAragua\n+ */\n+public class StratconScenarioFactory {\n+    // loaded dynamic scenario templates, sorted by location (ground, low atmosphere, space)\n+    private static Map<MapLocation, List<ScenarioTemplate>> dynamicScenarioLocationMap = new HashMap<>();\n+    private static Map<Integer, List<ScenarioTemplate>> dynamicScenarioUnitTypeMap = new HashMap<>();\n+    private static Map<String, ScenarioTemplate> dynamicScenarioNameMap = new HashMap<>();\n+    private static String HOSTILE_FACILITY_SCENARIO = \"Hostile Facility.xml\";\n+    private static String ALLIED_FACILITY_SCENARIO = \"Allied Facility.xml\";\n+    \n+    static {\n+        reloadScenarios();\n+    }\n+    \n+    /**\n+     * Reload the dynamic scenarios. \n+     */\n+    public static void reloadScenarios() {\n+        dynamicScenarioLocationMap.clear();\n+        dynamicScenarioUnitTypeMap.clear();\n+        \n+        // load dynamic scenarios\n+        AtBScenarioManifest scenarioManifest = AtBScenarioManifest.Deserialize(MekHqConstants.STRATCON_SCENARIO_MANIFEST);\n+        \n+        // load user-specified scenario list\n+        AtBScenarioManifest userManifest = AtBScenarioManifest.Deserialize(MekHqConstants.STRATCON_USER_SCENARIO_MANIFEST);\n+        \n+        if (scenarioManifest != null) {\n+            loadScenariosFromManifest(scenarioManifest);\n+        }\n+        \n+        if (userManifest != null) {\n+            loadScenariosFromManifest(userManifest);\n+        }\n+    }\n+    \n+    /**\n+     * Helper function that loads scenario templates from the given manifest.\n+     * @param manifest The manifest to process\n+     */\n+    private static void loadScenariosFromManifest(AtBScenarioManifest manifest) {\n+        if (manifest == null) {\n+            return;\n+        }\n+        \n+        for (int key : manifest.scenarioFileNames.keySet()) {\n+            String fileName = manifest.scenarioFileNames.get(key).trim();\n+            String filePath = Paths.get(MekHqConstants.STRATCON_SCENARIO_TEMPLATE_PATH, \n+            \t\tmanifest.scenarioFileNames.get(key).trim()).toString();\n+            \n+            try {\n+                ScenarioTemplate template = ScenarioTemplate.Deserialize(filePath);\n+                \n+                if (template != null) {\n+                    MapLocation locationKey = template.mapParameters.getMapLocation();\n+                    \n+                    // sort templates by location\n+                    if (!dynamicScenarioLocationMap.containsKey(locationKey)) {\n+                        dynamicScenarioLocationMap.put(locationKey, new ArrayList<>());\n+                    }\n+                    \n+                    dynamicScenarioLocationMap.get(locationKey).add(template);\n+                    \n+                    // sort templates by primary force unit type\n+                    int playerForceUnitType = template.getPrimaryPlayerForce().getAllowedUnitType();\n+                    if (!dynamicScenarioUnitTypeMap.containsKey(playerForceUnitType)) {\n+                        dynamicScenarioUnitTypeMap.put(playerForceUnitType, new ArrayList<>());\n+                    }\n+                    \n+                    dynamicScenarioUnitTypeMap.get(playerForceUnitType).add(template);\n+                    \n+                    dynamicScenarioNameMap.put(fileName, template);\n+                }\n+            } catch (Exception e) {\n+                MekHQ.getLogger().error(String.format(\"Error loading file: %s\", filePath), e);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Retrieves a random scenario template in the appropriate location.\n+     * @param location The location (ground/low atmo/space) category of the scenario.\n+     * @return Random scenario template.\n+     */\n+    public static ScenarioTemplate getRandomScenario(MapLocation location) {\n+    \treturn Utilities.getRandomItem(dynamicScenarioLocationMap.get(location)).clone();\n+    }\n+    \n+    /**\n+     * Retrieves a specific scenario given the key (file name)\n+     */\n+    public static ScenarioTemplate getSpecificScenario(String name) {\n+        return dynamicScenarioNameMap.get(name).clone();\n+    }\n+    \n+    /**\n+     * Retrieves a random scenario template appropriate for the given unit type.\n+     * This includes the more general ATB_MIX and ATB_AERO_MIX where appropriate\n+     * @param unitType The desired unit type, as per megamek.common.UnitType\n+     * @return Random scenario template.\n+     */\n+    public static ScenarioTemplate getRandomScenario(int unitType) {\n+        int generalUnitType = convertSpecificUnitTypeToGeneral(unitType);\n+        \n+        // if the specific unit type doesn't have any scenario templates for it\n+        // then we can't generate a scenario.\n+        if (!dynamicScenarioUnitTypeMap.containsKey(unitType) &&\n+            !dynamicScenarioUnitTypeMap.containsKey(generalUnitType)) {\n+                MekHQ.getLogger().warning(String.format(\"No scenarios configured for unit type %d\", unitType));\n+                return null;\n+        }\n+        \n+        List<ScenarioTemplate> jointList = new ArrayList<>();\n+        \n+        if (dynamicScenarioUnitTypeMap.containsKey(unitType)) {\n+            jointList.addAll(dynamicScenarioUnitTypeMap.get(unitType));\n+        }\n+        \n+        if (dynamicScenarioUnitTypeMap.containsKey(generalUnitType)) {\n+            jointList.addAll(dynamicScenarioUnitTypeMap.get(generalUnitType));\n+        }\n+        \n+        return Utilities.getRandomItem(jointList).clone();\n+    }\n+    \n+    /**\n+     * Get an allied or hostile facility scenario, depending on passed on parameter.\n+     */\n+    public static ScenarioTemplate getFacilityScenario(boolean allied) {\n+        if (allied) {\n+            return getSpecificScenario(ALLIED_FACILITY_SCENARIO);\n+        } else {\n+            return getSpecificScenario(HOSTILE_FACILITY_SCENARIO);\n+        }", "originalCommit": "55af097696b44f689e0ff88123ab5f39b18bd8c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNjU0NzkwNQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r606547905", "bodyText": "Future expansion may feature a situation where a ternary operator is insufficient.", "author": "NickAragua", "createdAt": "2021-04-03T00:56:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNjI4OTE5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNjI4OTcxNw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r606289717", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             *\n          \n          \n            \n             */\n          \n          \n            \n             */", "author": "Windchild292", "createdAt": "2021-04-02T15:33:12Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconScenario.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.LocalDate;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+import javax.xml.bind.annotation.XmlTransient;\n+import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;\n+\n+import mekhq.adapter.DateAdapter;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+\n+/**\n+ * Class that handles scenario metadata and interaction at the StratCon level\n+ * @author NickAragua\n+ *\n+ */", "originalCommit": "55af097696b44f689e0ff88123ab5f39b18bd8c0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNjI5MDA5NQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r606290095", "bodyText": "This would be best done as part of an enum", "author": "Windchild292", "createdAt": "2021-04-02T15:34:05Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconScenario.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.LocalDate;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+import javax.xml.bind.annotation.XmlTransient;\n+import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;\n+\n+import mekhq.adapter.DateAdapter;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+\n+/**\n+ * Class that handles scenario metadata and interaction at the StratCon level\n+ * @author NickAragua\n+ *\n+ */\n+public class StratconScenario implements IStratconDisplayable {\n+    public enum ScenarioState {\n+        NONEXISTENT,\n+        UNRESOLVED,\n+        PRIMARY_FORCES_COMMITTED,\n+        REINFORCEMENTS_COMMITTED,\n+        COMPLETED,\n+        IGNORED,\n+        DEFEATED;\n+    }\n+    \n+    private final static Map<ScenarioState, String> scenarioStateNames;\n+    \n+    static {\n+        scenarioStateNames = new HashMap<>();\n+        scenarioStateNames.put(ScenarioState.NONEXISTENT, \"Shouldn't be seen\");\n+        scenarioStateNames.put(ScenarioState.UNRESOLVED, \"Unresolved\");\n+        scenarioStateNames.put(ScenarioState.PRIMARY_FORCES_COMMITTED, \"Primary forces committed\");\n+        scenarioStateNames.put(ScenarioState.COMPLETED, \"Victory\");\n+        scenarioStateNames.put(ScenarioState.IGNORED, \"Ignored\");\n+        scenarioStateNames.put(ScenarioState.DEFEATED, \"Defeat\");\n+    }", "originalCommit": "55af097696b44f689e0ff88123ab5f39b18bd8c0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNjI5MDM5OQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r606290399", "bodyText": "Either describe or clean up all of these parameters", "author": "Windchild292", "createdAt": "2021-04-02T15:34:52Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconScenario.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.LocalDate;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+import javax.xml.bind.annotation.XmlTransient;\n+import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;\n+\n+import mekhq.adapter.DateAdapter;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+\n+/**\n+ * Class that handles scenario metadata and interaction at the StratCon level\n+ * @author NickAragua\n+ *\n+ */\n+public class StratconScenario implements IStratconDisplayable {\n+    public enum ScenarioState {\n+        NONEXISTENT,\n+        UNRESOLVED,\n+        PRIMARY_FORCES_COMMITTED,\n+        REINFORCEMENTS_COMMITTED,\n+        COMPLETED,\n+        IGNORED,\n+        DEFEATED;\n+    }\n+    \n+    private final static Map<ScenarioState, String> scenarioStateNames;\n+    \n+    static {\n+        scenarioStateNames = new HashMap<>();\n+        scenarioStateNames.put(ScenarioState.NONEXISTENT, \"Shouldn't be seen\");\n+        scenarioStateNames.put(ScenarioState.UNRESOLVED, \"Unresolved\");\n+        scenarioStateNames.put(ScenarioState.PRIMARY_FORCES_COMMITTED, \"Primary forces committed\");\n+        scenarioStateNames.put(ScenarioState.COMPLETED, \"Victory\");\n+        scenarioStateNames.put(ScenarioState.IGNORED, \"Ignored\");\n+        scenarioStateNames.put(ScenarioState.DEFEATED, \"Defeat\");\n+    }\n+    \n+    private AtBDynamicScenario backingScenario;\n+    \n+    private int backingScenarioID; \n+    private ScenarioState currentState = ScenarioState.UNRESOLVED;\n+    private int requiredPlayerLances;\n+    private boolean requiredScenario;\n+    private boolean isStrategicObjective;\n+    private LocalDate deploymentDate;\n+    private LocalDate actionDate;\n+    private LocalDate returnDate;\n+    private StratconCoords coords;\n+    private int numDefensivePoints;\n+    private boolean ignoreForceAutoAssignment;\n+    private Set<Integer> failedReinforcements = new HashSet<>();\n+    private Set<Integer> primaryForceIDs = new HashSet<>();\n+\n+    /**\n+     * Add a force to the backing scenario. Do our best to add the force as a \"primary\" force, as defined in the scenario template.\n+     * @param forceID ID of the force to add.\n+     */\n+    public void addPrimaryForce(int forceID) {\n+        backingScenario.addForce(forceID, ScenarioForceTemplate.PRIMARY_FORCE_TEMPLATE_ID);\n+    }\n+    \n+    /**\n+     * Add a force to the backing scenario, trying to associate it with the given template.\n+     * @param forceID\n+     * @param templateID", "originalCommit": "55af097696b44f689e0ff88123ab5f39b18bd8c0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNjI5MDQ4NA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r606290484", "bodyText": "spaces", "author": "Windchild292", "createdAt": "2021-04-02T15:35:02Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconScenario.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.LocalDate;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+import javax.xml.bind.annotation.XmlTransient;\n+import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;\n+\n+import mekhq.adapter.DateAdapter;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+\n+/**\n+ * Class that handles scenario metadata and interaction at the StratCon level\n+ * @author NickAragua\n+ *\n+ */\n+public class StratconScenario implements IStratconDisplayable {\n+    public enum ScenarioState {\n+        NONEXISTENT,\n+        UNRESOLVED,\n+        PRIMARY_FORCES_COMMITTED,\n+        REINFORCEMENTS_COMMITTED,\n+        COMPLETED,\n+        IGNORED,\n+        DEFEATED;\n+    }\n+    \n+    private final static Map<ScenarioState, String> scenarioStateNames;\n+    \n+    static {\n+        scenarioStateNames = new HashMap<>();\n+        scenarioStateNames.put(ScenarioState.NONEXISTENT, \"Shouldn't be seen\");\n+        scenarioStateNames.put(ScenarioState.UNRESOLVED, \"Unresolved\");\n+        scenarioStateNames.put(ScenarioState.PRIMARY_FORCES_COMMITTED, \"Primary forces committed\");\n+        scenarioStateNames.put(ScenarioState.COMPLETED, \"Victory\");\n+        scenarioStateNames.put(ScenarioState.IGNORED, \"Ignored\");\n+        scenarioStateNames.put(ScenarioState.DEFEATED, \"Defeat\");\n+    }\n+    \n+    private AtBDynamicScenario backingScenario;\n+    \n+    private int backingScenarioID; \n+    private ScenarioState currentState = ScenarioState.UNRESOLVED;\n+    private int requiredPlayerLances;\n+    private boolean requiredScenario;\n+    private boolean isStrategicObjective;\n+    private LocalDate deploymentDate;\n+    private LocalDate actionDate;\n+    private LocalDate returnDate;\n+    private StratconCoords coords;\n+    private int numDefensivePoints;\n+    private boolean ignoreForceAutoAssignment;\n+    private Set<Integer> failedReinforcements = new HashSet<>();\n+    private Set<Integer> primaryForceIDs = new HashSet<>();\n+\n+    /**\n+     * Add a force to the backing scenario. Do our best to add the force as a \"primary\" force, as defined in the scenario template.\n+     * @param forceID ID of the force to add.\n+     */\n+    public void addPrimaryForce(int forceID) {\n+        backingScenario.addForce(forceID, ScenarioForceTemplate.PRIMARY_FORCE_TEMPLATE_ID);\n+    }\n+    \n+    /**\n+     * Add a force to the backing scenario, trying to associate it with the given template.\n+     * @param forceID\n+     * @param templateID\n+     */\n+    public void addForce(int forceID, String templateID) {\n+        backingScenario.addForce(forceID, templateID);\n+    }\n+    \n+    /**\n+     * Add an individual unit to the backing scenario, trying to associate it with the given template.\n+     * @param unitID\n+     * @param templateID\n+     */\n+    public void addUnit(UUID unitID, String templateID) {\n+        backingScenario.addUnit(unitID, templateID);\n+    }\n+    \n+    public void clearReinforcements() {\n+        for(int forceID : backingScenario.getForceIDs()) {\n+            if(!backingScenario.getPlayerForceTemplates().containsKey(forceID)) {", "originalCommit": "55af097696b44f689e0ff88123ab5f39b18bd8c0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNjI5MDc2MA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r606290760", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if(this.isStrategicObjective) {\n          \n          \n            \n                    if (isStrategicObjective) {", "author": "Windchild292", "createdAt": "2021-04-02T15:35:41Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconScenario.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.LocalDate;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+import javax.xml.bind.annotation.XmlTransient;\n+import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;\n+\n+import mekhq.adapter.DateAdapter;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+\n+/**\n+ * Class that handles scenario metadata and interaction at the StratCon level\n+ * @author NickAragua\n+ *\n+ */\n+public class StratconScenario implements IStratconDisplayable {\n+    public enum ScenarioState {\n+        NONEXISTENT,\n+        UNRESOLVED,\n+        PRIMARY_FORCES_COMMITTED,\n+        REINFORCEMENTS_COMMITTED,\n+        COMPLETED,\n+        IGNORED,\n+        DEFEATED;\n+    }\n+    \n+    private final static Map<ScenarioState, String> scenarioStateNames;\n+    \n+    static {\n+        scenarioStateNames = new HashMap<>();\n+        scenarioStateNames.put(ScenarioState.NONEXISTENT, \"Shouldn't be seen\");\n+        scenarioStateNames.put(ScenarioState.UNRESOLVED, \"Unresolved\");\n+        scenarioStateNames.put(ScenarioState.PRIMARY_FORCES_COMMITTED, \"Primary forces committed\");\n+        scenarioStateNames.put(ScenarioState.COMPLETED, \"Victory\");\n+        scenarioStateNames.put(ScenarioState.IGNORED, \"Ignored\");\n+        scenarioStateNames.put(ScenarioState.DEFEATED, \"Defeat\");\n+    }\n+    \n+    private AtBDynamicScenario backingScenario;\n+    \n+    private int backingScenarioID; \n+    private ScenarioState currentState = ScenarioState.UNRESOLVED;\n+    private int requiredPlayerLances;\n+    private boolean requiredScenario;\n+    private boolean isStrategicObjective;\n+    private LocalDate deploymentDate;\n+    private LocalDate actionDate;\n+    private LocalDate returnDate;\n+    private StratconCoords coords;\n+    private int numDefensivePoints;\n+    private boolean ignoreForceAutoAssignment;\n+    private Set<Integer> failedReinforcements = new HashSet<>();\n+    private Set<Integer> primaryForceIDs = new HashSet<>();\n+\n+    /**\n+     * Add a force to the backing scenario. Do our best to add the force as a \"primary\" force, as defined in the scenario template.\n+     * @param forceID ID of the force to add.\n+     */\n+    public void addPrimaryForce(int forceID) {\n+        backingScenario.addForce(forceID, ScenarioForceTemplate.PRIMARY_FORCE_TEMPLATE_ID);\n+    }\n+    \n+    /**\n+     * Add a force to the backing scenario, trying to associate it with the given template.\n+     * @param forceID\n+     * @param templateID\n+     */\n+    public void addForce(int forceID, String templateID) {\n+        backingScenario.addForce(forceID, templateID);\n+    }\n+    \n+    /**\n+     * Add an individual unit to the backing scenario, trying to associate it with the given template.\n+     * @param unitID\n+     * @param templateID\n+     */\n+    public void addUnit(UUID unitID, String templateID) {\n+        backingScenario.addUnit(unitID, templateID);\n+    }\n+    \n+    public void clearReinforcements() {\n+        for(int forceID : backingScenario.getForceIDs()) {\n+            if(!backingScenario.getPlayerForceTemplates().containsKey(forceID)) {\n+                backingScenario.removeForce(forceID);\n+            }\n+        }\n+    }\n+\n+    public List<Integer> getAssignedForces() {\n+        return backingScenario.getForceIDs();\n+    }\n+    \n+    /**\n+     * These are all of the force IDs that have been matched up to a template\n+     * Note: since there's a default Reinforcements template, this is all forces\n+     * that have been assigned to this scenario\n+     */\n+    public List<Integer> getPlayerTemplateForceIDs() {\n+        return backingScenario.getPlayerTemplateForceIDs();\n+    }\n+    \n+    /**\n+     * These are all the \"primary\" force IDs, meaning forces that have been used\n+     * by the scenario to drive the generation of the OpFor.\n+     */\n+    public Set<Integer> getPrimaryForceIDs() {\n+        return primaryForceIDs;\n+    }\n+    \n+    public void setPrimaryForceIDs(Set<Integer> primaryForceIDs) {\n+        this.primaryForceIDs = primaryForceIDs;\n+    }\n+    \n+    /**\n+     * This convenience method sets the scenario's current state to PRIMARY_FORCES_COMMITTED\n+     * and fixes the forces that were assigned to this scenario prior as \"primary\".\n+     */\n+    public void commitPrimaryForces() {\n+        currentState = ScenarioState.PRIMARY_FORCES_COMMITTED;\n+        getPrimaryForceIDs().clear();\n+        \n+        for (int forceID : backingScenario.getPlayerTemplateForceIDs()) {\n+            getPrimaryForceIDs().add(forceID);\n+        }\n+    }\n+\n+    public ScenarioState getCurrentState() {\n+        return currentState;\n+    }\n+\n+    public void setCurrentState(ScenarioState state) {\n+        currentState = state;\n+    }\n+\n+    @Override\n+    public String getInfo() {\n+        return getInfo(true);\n+    }\n+    \n+    public String getInfo(boolean html) {\n+        StringBuilder stateBuilder = new StringBuilder();\n+\n+        if(this.isStrategicObjective) {", "originalCommit": "55af097696b44f689e0ff88123ab5f39b18bd8c0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNjI5MDk2Ng==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r606290966", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if(this.isRequiredScenario()) {\n          \n          \n            \n                    if (isRequiredScenario()) {", "author": "Windchild292", "createdAt": "2021-04-02T15:36:02Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconScenario.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.LocalDate;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+import javax.xml.bind.annotation.XmlTransient;\n+import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;\n+\n+import mekhq.adapter.DateAdapter;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+\n+/**\n+ * Class that handles scenario metadata and interaction at the StratCon level\n+ * @author NickAragua\n+ *\n+ */\n+public class StratconScenario implements IStratconDisplayable {\n+    public enum ScenarioState {\n+        NONEXISTENT,\n+        UNRESOLVED,\n+        PRIMARY_FORCES_COMMITTED,\n+        REINFORCEMENTS_COMMITTED,\n+        COMPLETED,\n+        IGNORED,\n+        DEFEATED;\n+    }\n+    \n+    private final static Map<ScenarioState, String> scenarioStateNames;\n+    \n+    static {\n+        scenarioStateNames = new HashMap<>();\n+        scenarioStateNames.put(ScenarioState.NONEXISTENT, \"Shouldn't be seen\");\n+        scenarioStateNames.put(ScenarioState.UNRESOLVED, \"Unresolved\");\n+        scenarioStateNames.put(ScenarioState.PRIMARY_FORCES_COMMITTED, \"Primary forces committed\");\n+        scenarioStateNames.put(ScenarioState.COMPLETED, \"Victory\");\n+        scenarioStateNames.put(ScenarioState.IGNORED, \"Ignored\");\n+        scenarioStateNames.put(ScenarioState.DEFEATED, \"Defeat\");\n+    }\n+    \n+    private AtBDynamicScenario backingScenario;\n+    \n+    private int backingScenarioID; \n+    private ScenarioState currentState = ScenarioState.UNRESOLVED;\n+    private int requiredPlayerLances;\n+    private boolean requiredScenario;\n+    private boolean isStrategicObjective;\n+    private LocalDate deploymentDate;\n+    private LocalDate actionDate;\n+    private LocalDate returnDate;\n+    private StratconCoords coords;\n+    private int numDefensivePoints;\n+    private boolean ignoreForceAutoAssignment;\n+    private Set<Integer> failedReinforcements = new HashSet<>();\n+    private Set<Integer> primaryForceIDs = new HashSet<>();\n+\n+    /**\n+     * Add a force to the backing scenario. Do our best to add the force as a \"primary\" force, as defined in the scenario template.\n+     * @param forceID ID of the force to add.\n+     */\n+    public void addPrimaryForce(int forceID) {\n+        backingScenario.addForce(forceID, ScenarioForceTemplate.PRIMARY_FORCE_TEMPLATE_ID);\n+    }\n+    \n+    /**\n+     * Add a force to the backing scenario, trying to associate it with the given template.\n+     * @param forceID\n+     * @param templateID\n+     */\n+    public void addForce(int forceID, String templateID) {\n+        backingScenario.addForce(forceID, templateID);\n+    }\n+    \n+    /**\n+     * Add an individual unit to the backing scenario, trying to associate it with the given template.\n+     * @param unitID\n+     * @param templateID\n+     */\n+    public void addUnit(UUID unitID, String templateID) {\n+        backingScenario.addUnit(unitID, templateID);\n+    }\n+    \n+    public void clearReinforcements() {\n+        for(int forceID : backingScenario.getForceIDs()) {\n+            if(!backingScenario.getPlayerForceTemplates().containsKey(forceID)) {\n+                backingScenario.removeForce(forceID);\n+            }\n+        }\n+    }\n+\n+    public List<Integer> getAssignedForces() {\n+        return backingScenario.getForceIDs();\n+    }\n+    \n+    /**\n+     * These are all of the force IDs that have been matched up to a template\n+     * Note: since there's a default Reinforcements template, this is all forces\n+     * that have been assigned to this scenario\n+     */\n+    public List<Integer> getPlayerTemplateForceIDs() {\n+        return backingScenario.getPlayerTemplateForceIDs();\n+    }\n+    \n+    /**\n+     * These are all the \"primary\" force IDs, meaning forces that have been used\n+     * by the scenario to drive the generation of the OpFor.\n+     */\n+    public Set<Integer> getPrimaryForceIDs() {\n+        return primaryForceIDs;\n+    }\n+    \n+    public void setPrimaryForceIDs(Set<Integer> primaryForceIDs) {\n+        this.primaryForceIDs = primaryForceIDs;\n+    }\n+    \n+    /**\n+     * This convenience method sets the scenario's current state to PRIMARY_FORCES_COMMITTED\n+     * and fixes the forces that were assigned to this scenario prior as \"primary\".\n+     */\n+    public void commitPrimaryForces() {\n+        currentState = ScenarioState.PRIMARY_FORCES_COMMITTED;\n+        getPrimaryForceIDs().clear();\n+        \n+        for (int forceID : backingScenario.getPlayerTemplateForceIDs()) {\n+            getPrimaryForceIDs().add(forceID);\n+        }\n+    }\n+\n+    public ScenarioState getCurrentState() {\n+        return currentState;\n+    }\n+\n+    public void setCurrentState(ScenarioState state) {\n+        currentState = state;\n+    }\n+\n+    @Override\n+    public String getInfo() {\n+        return getInfo(true);\n+    }\n+    \n+    public String getInfo(boolean html) {\n+        StringBuilder stateBuilder = new StringBuilder();\n+\n+        if(this.isStrategicObjective) {\n+            stateBuilder.append(\"<span color='red'>Contract objective located</span>\").append(html ? \"<br/>\" : \"\");\n+        }\n+        \n+        stateBuilder.append(\"Scenario: \");\n+        stateBuilder.append(backingScenario.getName());\n+        stateBuilder.append(html ? \"<br/>\" : \"\");\n+        stateBuilder.append(backingScenario.getTemplate().shortBriefing);\n+        stateBuilder.append(html ? \"<br/>\" : \"\");\n+        \n+        if(this.isRequiredScenario()) {", "originalCommit": "55af097696b44f689e0ff88123ab5f39b18bd8c0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNjI5MTE1Mg==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r606291152", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if((backingScenario.getTerrainType() >= 0) && (backingScenario.getTerrainType() < AtBScenario.terrainTypes.length)) {\n          \n          \n            \n                    if ((backingScenario.getTerrainType() >= 0) && (backingScenario.getTerrainType() < AtBScenario.terrainTypes.length)) {", "author": "Windchild292", "createdAt": "2021-04-02T15:36:32Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconScenario.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.LocalDate;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+import javax.xml.bind.annotation.XmlTransient;\n+import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;\n+\n+import mekhq.adapter.DateAdapter;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+\n+/**\n+ * Class that handles scenario metadata and interaction at the StratCon level\n+ * @author NickAragua\n+ *\n+ */\n+public class StratconScenario implements IStratconDisplayable {\n+    public enum ScenarioState {\n+        NONEXISTENT,\n+        UNRESOLVED,\n+        PRIMARY_FORCES_COMMITTED,\n+        REINFORCEMENTS_COMMITTED,\n+        COMPLETED,\n+        IGNORED,\n+        DEFEATED;\n+    }\n+    \n+    private final static Map<ScenarioState, String> scenarioStateNames;\n+    \n+    static {\n+        scenarioStateNames = new HashMap<>();\n+        scenarioStateNames.put(ScenarioState.NONEXISTENT, \"Shouldn't be seen\");\n+        scenarioStateNames.put(ScenarioState.UNRESOLVED, \"Unresolved\");\n+        scenarioStateNames.put(ScenarioState.PRIMARY_FORCES_COMMITTED, \"Primary forces committed\");\n+        scenarioStateNames.put(ScenarioState.COMPLETED, \"Victory\");\n+        scenarioStateNames.put(ScenarioState.IGNORED, \"Ignored\");\n+        scenarioStateNames.put(ScenarioState.DEFEATED, \"Defeat\");\n+    }\n+    \n+    private AtBDynamicScenario backingScenario;\n+    \n+    private int backingScenarioID; \n+    private ScenarioState currentState = ScenarioState.UNRESOLVED;\n+    private int requiredPlayerLances;\n+    private boolean requiredScenario;\n+    private boolean isStrategicObjective;\n+    private LocalDate deploymentDate;\n+    private LocalDate actionDate;\n+    private LocalDate returnDate;\n+    private StratconCoords coords;\n+    private int numDefensivePoints;\n+    private boolean ignoreForceAutoAssignment;\n+    private Set<Integer> failedReinforcements = new HashSet<>();\n+    private Set<Integer> primaryForceIDs = new HashSet<>();\n+\n+    /**\n+     * Add a force to the backing scenario. Do our best to add the force as a \"primary\" force, as defined in the scenario template.\n+     * @param forceID ID of the force to add.\n+     */\n+    public void addPrimaryForce(int forceID) {\n+        backingScenario.addForce(forceID, ScenarioForceTemplate.PRIMARY_FORCE_TEMPLATE_ID);\n+    }\n+    \n+    /**\n+     * Add a force to the backing scenario, trying to associate it with the given template.\n+     * @param forceID\n+     * @param templateID\n+     */\n+    public void addForce(int forceID, String templateID) {\n+        backingScenario.addForce(forceID, templateID);\n+    }\n+    \n+    /**\n+     * Add an individual unit to the backing scenario, trying to associate it with the given template.\n+     * @param unitID\n+     * @param templateID\n+     */\n+    public void addUnit(UUID unitID, String templateID) {\n+        backingScenario.addUnit(unitID, templateID);\n+    }\n+    \n+    public void clearReinforcements() {\n+        for(int forceID : backingScenario.getForceIDs()) {\n+            if(!backingScenario.getPlayerForceTemplates().containsKey(forceID)) {\n+                backingScenario.removeForce(forceID);\n+            }\n+        }\n+    }\n+\n+    public List<Integer> getAssignedForces() {\n+        return backingScenario.getForceIDs();\n+    }\n+    \n+    /**\n+     * These are all of the force IDs that have been matched up to a template\n+     * Note: since there's a default Reinforcements template, this is all forces\n+     * that have been assigned to this scenario\n+     */\n+    public List<Integer> getPlayerTemplateForceIDs() {\n+        return backingScenario.getPlayerTemplateForceIDs();\n+    }\n+    \n+    /**\n+     * These are all the \"primary\" force IDs, meaning forces that have been used\n+     * by the scenario to drive the generation of the OpFor.\n+     */\n+    public Set<Integer> getPrimaryForceIDs() {\n+        return primaryForceIDs;\n+    }\n+    \n+    public void setPrimaryForceIDs(Set<Integer> primaryForceIDs) {\n+        this.primaryForceIDs = primaryForceIDs;\n+    }\n+    \n+    /**\n+     * This convenience method sets the scenario's current state to PRIMARY_FORCES_COMMITTED\n+     * and fixes the forces that were assigned to this scenario prior as \"primary\".\n+     */\n+    public void commitPrimaryForces() {\n+        currentState = ScenarioState.PRIMARY_FORCES_COMMITTED;\n+        getPrimaryForceIDs().clear();\n+        \n+        for (int forceID : backingScenario.getPlayerTemplateForceIDs()) {\n+            getPrimaryForceIDs().add(forceID);\n+        }\n+    }\n+\n+    public ScenarioState getCurrentState() {\n+        return currentState;\n+    }\n+\n+    public void setCurrentState(ScenarioState state) {\n+        currentState = state;\n+    }\n+\n+    @Override\n+    public String getInfo() {\n+        return getInfo(true);\n+    }\n+    \n+    public String getInfo(boolean html) {\n+        StringBuilder stateBuilder = new StringBuilder();\n+\n+        if(this.isStrategicObjective) {\n+            stateBuilder.append(\"<span color='red'>Contract objective located</span>\").append(html ? \"<br/>\" : \"\");\n+        }\n+        \n+        stateBuilder.append(\"Scenario: \");\n+        stateBuilder.append(backingScenario.getName());\n+        stateBuilder.append(html ? \"<br/>\" : \"\");\n+        stateBuilder.append(backingScenario.getTemplate().shortBriefing);\n+        stateBuilder.append(html ? \"<br/>\" : \"\");\n+        \n+        if(this.isRequiredScenario()) {\n+            stateBuilder.append(\"<span color='red'>Deployment required by contract</span>\").append(html ? \"<br/>\" : \"\");\n+        }\n+        \n+        stateBuilder.append(\"Status: \");\n+        stateBuilder.append(scenarioStateNames.get(currentState));\n+        stateBuilder.append(\"<br/>\");\n+        \n+        stateBuilder.append(\"Terrain: \");\n+        if((backingScenario.getTerrainType() >= 0) && (backingScenario.getTerrainType() < AtBScenario.terrainTypes.length)) {", "originalCommit": "55af097696b44f689e0ff88123ab5f39b18bd8c0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNjI5MTMxNw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r606291317", "bodyText": "In general, chain appends in this method", "author": "Windchild292", "createdAt": "2021-04-02T15:36:50Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconScenario.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.LocalDate;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+import javax.xml.bind.annotation.XmlTransient;\n+import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;\n+\n+import mekhq.adapter.DateAdapter;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+\n+/**\n+ * Class that handles scenario metadata and interaction at the StratCon level\n+ * @author NickAragua\n+ *\n+ */\n+public class StratconScenario implements IStratconDisplayable {\n+    public enum ScenarioState {\n+        NONEXISTENT,\n+        UNRESOLVED,\n+        PRIMARY_FORCES_COMMITTED,\n+        REINFORCEMENTS_COMMITTED,\n+        COMPLETED,\n+        IGNORED,\n+        DEFEATED;\n+    }\n+    \n+    private final static Map<ScenarioState, String> scenarioStateNames;\n+    \n+    static {\n+        scenarioStateNames = new HashMap<>();\n+        scenarioStateNames.put(ScenarioState.NONEXISTENT, \"Shouldn't be seen\");\n+        scenarioStateNames.put(ScenarioState.UNRESOLVED, \"Unresolved\");\n+        scenarioStateNames.put(ScenarioState.PRIMARY_FORCES_COMMITTED, \"Primary forces committed\");\n+        scenarioStateNames.put(ScenarioState.COMPLETED, \"Victory\");\n+        scenarioStateNames.put(ScenarioState.IGNORED, \"Ignored\");\n+        scenarioStateNames.put(ScenarioState.DEFEATED, \"Defeat\");\n+    }\n+    \n+    private AtBDynamicScenario backingScenario;\n+    \n+    private int backingScenarioID; \n+    private ScenarioState currentState = ScenarioState.UNRESOLVED;\n+    private int requiredPlayerLances;\n+    private boolean requiredScenario;\n+    private boolean isStrategicObjective;\n+    private LocalDate deploymentDate;\n+    private LocalDate actionDate;\n+    private LocalDate returnDate;\n+    private StratconCoords coords;\n+    private int numDefensivePoints;\n+    private boolean ignoreForceAutoAssignment;\n+    private Set<Integer> failedReinforcements = new HashSet<>();\n+    private Set<Integer> primaryForceIDs = new HashSet<>();\n+\n+    /**\n+     * Add a force to the backing scenario. Do our best to add the force as a \"primary\" force, as defined in the scenario template.\n+     * @param forceID ID of the force to add.\n+     */\n+    public void addPrimaryForce(int forceID) {\n+        backingScenario.addForce(forceID, ScenarioForceTemplate.PRIMARY_FORCE_TEMPLATE_ID);\n+    }\n+    \n+    /**\n+     * Add a force to the backing scenario, trying to associate it with the given template.\n+     * @param forceID\n+     * @param templateID\n+     */\n+    public void addForce(int forceID, String templateID) {\n+        backingScenario.addForce(forceID, templateID);\n+    }\n+    \n+    /**\n+     * Add an individual unit to the backing scenario, trying to associate it with the given template.\n+     * @param unitID\n+     * @param templateID\n+     */\n+    public void addUnit(UUID unitID, String templateID) {\n+        backingScenario.addUnit(unitID, templateID);\n+    }\n+    \n+    public void clearReinforcements() {\n+        for(int forceID : backingScenario.getForceIDs()) {\n+            if(!backingScenario.getPlayerForceTemplates().containsKey(forceID)) {\n+                backingScenario.removeForce(forceID);\n+            }\n+        }\n+    }\n+\n+    public List<Integer> getAssignedForces() {\n+        return backingScenario.getForceIDs();\n+    }\n+    \n+    /**\n+     * These are all of the force IDs that have been matched up to a template\n+     * Note: since there's a default Reinforcements template, this is all forces\n+     * that have been assigned to this scenario\n+     */\n+    public List<Integer> getPlayerTemplateForceIDs() {\n+        return backingScenario.getPlayerTemplateForceIDs();\n+    }\n+    \n+    /**\n+     * These are all the \"primary\" force IDs, meaning forces that have been used\n+     * by the scenario to drive the generation of the OpFor.\n+     */\n+    public Set<Integer> getPrimaryForceIDs() {\n+        return primaryForceIDs;\n+    }\n+    \n+    public void setPrimaryForceIDs(Set<Integer> primaryForceIDs) {\n+        this.primaryForceIDs = primaryForceIDs;\n+    }\n+    \n+    /**\n+     * This convenience method sets the scenario's current state to PRIMARY_FORCES_COMMITTED\n+     * and fixes the forces that were assigned to this scenario prior as \"primary\".\n+     */\n+    public void commitPrimaryForces() {\n+        currentState = ScenarioState.PRIMARY_FORCES_COMMITTED;\n+        getPrimaryForceIDs().clear();\n+        \n+        for (int forceID : backingScenario.getPlayerTemplateForceIDs()) {\n+            getPrimaryForceIDs().add(forceID);\n+        }\n+    }\n+\n+    public ScenarioState getCurrentState() {\n+        return currentState;\n+    }\n+\n+    public void setCurrentState(ScenarioState state) {\n+        currentState = state;\n+    }\n+\n+    @Override\n+    public String getInfo() {\n+        return getInfo(true);\n+    }\n+    \n+    public String getInfo(boolean html) {", "originalCommit": "55af097696b44f689e0ff88123ab5f39b18bd8c0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNjI5MTkxNA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r606291914", "bodyText": "spaces", "author": "Windchild292", "createdAt": "2021-04-02T15:38:04Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconTrackState.java", "diffHunk": "@@ -0,0 +1,359 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.LocalDate;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlTransient;\n+\n+import mekhq.MekHQ;\n+import mekhq.MekHqXmlUtil;\n+import mekhq.campaign.event.DeploymentChangedEvent;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+\n+/**\n+ * Track-level state object for a stratcon campaign.\n+ * @author NickAragua\n+ */\n+@XmlRootElement(name=\"campaignTrack\")", "originalCommit": "55af097696b44f689e0ff88123ab5f39b18bd8c0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNjI5MjAzMA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r606292030", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Map<StratconCoords, HashSet<Integer>> assignedCoordForces; \n          \n          \n            \n                private Map<StratconCoords, Set<Integer>> assignedCoordForces;", "author": "Windchild292", "createdAt": "2021-04-02T15:38:21Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconTrackState.java", "diffHunk": "@@ -0,0 +1,359 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.LocalDate;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlTransient;\n+\n+import mekhq.MekHQ;\n+import mekhq.MekHqXmlUtil;\n+import mekhq.campaign.event.DeploymentChangedEvent;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+\n+/**\n+ * Track-level state object for a stratcon campaign.\n+ * @author NickAragua\n+ */\n+@XmlRootElement(name=\"campaignTrack\")\n+public class StratconTrackState {\n+    public static final String ROOT_XML_ELEMENT_NAME = \"StratconTrackState\";\n+    \n+    // a track has the following characteristics:\n+    // width/height\n+    // [future]: terrain information by coordinates\n+    // scenario information by coordinates\n+    // active facilities by coordinates\n+    private String displayableName;\n+    private int width;\n+    private int height;\n+    private boolean gmRevealed;\n+    \n+    private Map<StratconCoords, StratconFacility> facilities;   \n+    private Map<StratconCoords, StratconScenario> scenarios;\n+    private Map<StratconCoords, HashSet<Integer>> assignedCoordForces; ", "originalCommit": "55af097696b44f689e0ff88123ab5f39b18bd8c0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNjI5MjIyNQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r606292225", "bodyText": "spaces", "author": "Windchild292", "createdAt": "2021-04-02T15:38:48Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconTrackState.java", "diffHunk": "@@ -0,0 +1,359 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.LocalDate;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlTransient;\n+\n+import mekhq.MekHQ;\n+import mekhq.MekHqXmlUtil;\n+import mekhq.campaign.event.DeploymentChangedEvent;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+\n+/**\n+ * Track-level state object for a stratcon campaign.\n+ * @author NickAragua\n+ */\n+@XmlRootElement(name=\"campaignTrack\")\n+public class StratconTrackState {\n+    public static final String ROOT_XML_ELEMENT_NAME = \"StratconTrackState\";\n+    \n+    // a track has the following characteristics:\n+    // width/height\n+    // [future]: terrain information by coordinates\n+    // scenario information by coordinates\n+    // active facilities by coordinates\n+    private String displayableName;\n+    private int width;\n+    private int height;\n+    private boolean gmRevealed;\n+    \n+    private Map<StratconCoords, StratconFacility> facilities;   \n+    private Map<StratconCoords, StratconScenario> scenarios;\n+    private Map<StratconCoords, HashSet<Integer>> assignedCoordForces; \n+    private Map<Integer, StratconCoords> assignedForceCoords;\n+    private Map<Integer, LocalDate> assignedForceReturnDates;\n+    private Set<Integer> stickyForces;\n+    private Map<Integer, String> assignedForceReturnDatesForStorage;\n+    private Set<StratconCoords> revealedCoords;\n+\n+    // don't serialize this\n+    private transient Map<Integer, StratconScenario> backingScenarioMap;\n+    \n+    private int scenarioOdds;\n+    private int deploymentTime;\n+    private int requiredLanceCount;\n+    \n+    public StratconTrackState() {\n+        facilities = new HashMap<>();\n+        scenarios = new HashMap<>();\n+        assignedForceCoords = new HashMap<>();\n+        assignedForceReturnDates = new HashMap<>();\n+        assignedCoordForces = new HashMap<>();\n+        setAssignedForceReturnDatesForStorage(new HashMap<>());\n+        revealedCoords = new HashSet<>();\n+        stickyForces = new HashSet<>();\n+    }\n+    \n+    public String getDisplayableName() {\n+        return displayableName;\n+    }\n+    \n+    public void setDisplayableName(String name) {\n+        displayableName = name;\n+    }\n+\n+    public int getWidth() {\n+        return width;\n+    }\n+\n+    public void setWidth(int width) {\n+        this.width = width;\n+    }\n+\n+    public int getHeight() {\n+        return height;\n+    }\n+\n+    public void setHeight(int height) {\n+        this.height = height;\n+    }\n+\n+    @XmlElementWrapper(name=\"trackFacilities\")\n+    @XmlElement(name=\"facility\")", "originalCommit": "55af097696b44f689e0ff88123ab5f39b18bd8c0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNjI5MjI5MQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r606292291", "bodyText": "spaces", "author": "Windchild292", "createdAt": "2021-04-02T15:38:56Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconTrackState.java", "diffHunk": "@@ -0,0 +1,359 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.LocalDate;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlTransient;\n+\n+import mekhq.MekHQ;\n+import mekhq.MekHqXmlUtil;\n+import mekhq.campaign.event.DeploymentChangedEvent;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+\n+/**\n+ * Track-level state object for a stratcon campaign.\n+ * @author NickAragua\n+ */\n+@XmlRootElement(name=\"campaignTrack\")\n+public class StratconTrackState {\n+    public static final String ROOT_XML_ELEMENT_NAME = \"StratconTrackState\";\n+    \n+    // a track has the following characteristics:\n+    // width/height\n+    // [future]: terrain information by coordinates\n+    // scenario information by coordinates\n+    // active facilities by coordinates\n+    private String displayableName;\n+    private int width;\n+    private int height;\n+    private boolean gmRevealed;\n+    \n+    private Map<StratconCoords, StratconFacility> facilities;   \n+    private Map<StratconCoords, StratconScenario> scenarios;\n+    private Map<StratconCoords, HashSet<Integer>> assignedCoordForces; \n+    private Map<Integer, StratconCoords> assignedForceCoords;\n+    private Map<Integer, LocalDate> assignedForceReturnDates;\n+    private Set<Integer> stickyForces;\n+    private Map<Integer, String> assignedForceReturnDatesForStorage;\n+    private Set<StratconCoords> revealedCoords;\n+\n+    // don't serialize this\n+    private transient Map<Integer, StratconScenario> backingScenarioMap;\n+    \n+    private int scenarioOdds;\n+    private int deploymentTime;\n+    private int requiredLanceCount;\n+    \n+    public StratconTrackState() {\n+        facilities = new HashMap<>();\n+        scenarios = new HashMap<>();\n+        assignedForceCoords = new HashMap<>();\n+        assignedForceReturnDates = new HashMap<>();\n+        assignedCoordForces = new HashMap<>();\n+        setAssignedForceReturnDatesForStorage(new HashMap<>());\n+        revealedCoords = new HashSet<>();\n+        stickyForces = new HashSet<>();\n+    }\n+    \n+    public String getDisplayableName() {\n+        return displayableName;\n+    }\n+    \n+    public void setDisplayableName(String name) {\n+        displayableName = name;\n+    }\n+\n+    public int getWidth() {\n+        return width;\n+    }\n+\n+    public void setWidth(int width) {\n+        this.width = width;\n+    }\n+\n+    public int getHeight() {\n+        return height;\n+    }\n+\n+    public void setHeight(int height) {\n+        this.height = height;\n+    }\n+\n+    @XmlElementWrapper(name=\"trackFacilities\")\n+    @XmlElement(name=\"facility\")\n+    public Map<StratconCoords, StratconFacility> getFacilities() {\n+        return facilities;\n+    }\n+\n+    public void setFacilities(Map<StratconCoords, StratconFacility> facilities) {\n+        this.facilities = facilities;\n+    }\n+\n+    public StratconFacility getFacility(StratconCoords coords) {\n+        return facilities.get(coords);\n+    }\n+    \n+    /**\n+     * Used for serialization/deserialization.\n+     * Do not manipulate directly, or things get unpleasant.\n+     */\n+    @XmlElementWrapper(name=\"trackScenarios\")\n+    @XmlElement(name=\"scenario\")", "originalCommit": "55af097696b44f689e0ff88123ab5f39b18bd8c0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNjI5MjQzNQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r606292435", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if(scenarios.containsKey(scenario.getCoords()) && (scenario.getBackingScenarioID() > 0)) {\n          \n          \n            \n                    if (scenarios.containsKey(scenario.getCoords()) && (scenario.getBackingScenarioID() > 0)) {", "author": "Windchild292", "createdAt": "2021-04-02T15:39:22Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconTrackState.java", "diffHunk": "@@ -0,0 +1,359 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.LocalDate;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlTransient;\n+\n+import mekhq.MekHQ;\n+import mekhq.MekHqXmlUtil;\n+import mekhq.campaign.event.DeploymentChangedEvent;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+\n+/**\n+ * Track-level state object for a stratcon campaign.\n+ * @author NickAragua\n+ */\n+@XmlRootElement(name=\"campaignTrack\")\n+public class StratconTrackState {\n+    public static final String ROOT_XML_ELEMENT_NAME = \"StratconTrackState\";\n+    \n+    // a track has the following characteristics:\n+    // width/height\n+    // [future]: terrain information by coordinates\n+    // scenario information by coordinates\n+    // active facilities by coordinates\n+    private String displayableName;\n+    private int width;\n+    private int height;\n+    private boolean gmRevealed;\n+    \n+    private Map<StratconCoords, StratconFacility> facilities;   \n+    private Map<StratconCoords, StratconScenario> scenarios;\n+    private Map<StratconCoords, HashSet<Integer>> assignedCoordForces; \n+    private Map<Integer, StratconCoords> assignedForceCoords;\n+    private Map<Integer, LocalDate> assignedForceReturnDates;\n+    private Set<Integer> stickyForces;\n+    private Map<Integer, String> assignedForceReturnDatesForStorage;\n+    private Set<StratconCoords> revealedCoords;\n+\n+    // don't serialize this\n+    private transient Map<Integer, StratconScenario> backingScenarioMap;\n+    \n+    private int scenarioOdds;\n+    private int deploymentTime;\n+    private int requiredLanceCount;\n+    \n+    public StratconTrackState() {\n+        facilities = new HashMap<>();\n+        scenarios = new HashMap<>();\n+        assignedForceCoords = new HashMap<>();\n+        assignedForceReturnDates = new HashMap<>();\n+        assignedCoordForces = new HashMap<>();\n+        setAssignedForceReturnDatesForStorage(new HashMap<>());\n+        revealedCoords = new HashSet<>();\n+        stickyForces = new HashSet<>();\n+    }\n+    \n+    public String getDisplayableName() {\n+        return displayableName;\n+    }\n+    \n+    public void setDisplayableName(String name) {\n+        displayableName = name;\n+    }\n+\n+    public int getWidth() {\n+        return width;\n+    }\n+\n+    public void setWidth(int width) {\n+        this.width = width;\n+    }\n+\n+    public int getHeight() {\n+        return height;\n+    }\n+\n+    public void setHeight(int height) {\n+        this.height = height;\n+    }\n+\n+    @XmlElementWrapper(name=\"trackFacilities\")\n+    @XmlElement(name=\"facility\")\n+    public Map<StratconCoords, StratconFacility> getFacilities() {\n+        return facilities;\n+    }\n+\n+    public void setFacilities(Map<StratconCoords, StratconFacility> facilities) {\n+        this.facilities = facilities;\n+    }\n+\n+    public StratconFacility getFacility(StratconCoords coords) {\n+        return facilities.get(coords);\n+    }\n+    \n+    /**\n+     * Used for serialization/deserialization.\n+     * Do not manipulate directly, or things get unpleasant.\n+     */\n+    @XmlElementWrapper(name=\"trackScenarios\")\n+    @XmlElement(name=\"scenario\")\n+    public Map<StratconCoords, StratconScenario> getScenarios() {\n+        return scenarios;\n+    }\n+\n+    public void setScenarios(Map<StratconCoords, StratconScenario> scenarios) {\n+        this.scenarios = scenarios;\n+    }\n+    \n+    /**\n+     * Adds a StratconScenario to this track. Assumes it already has some coordinates assigned,\n+     * and a valid campaign scenario ID for its backing AtB scenario\n+     */\n+    public void addScenario(StratconScenario scenario) {\n+        scenarios.put(scenario.getCoords(), scenario);\n+        \n+        updateScenario(scenario);\n+    }\n+    \n+    /**\n+     * Updates an existing scenario on this track.\n+     */\n+    public void updateScenario(StratconScenario scenario) {\n+        if(scenarios.containsKey(scenario.getCoords()) && (scenario.getBackingScenarioID() > 0)) {", "originalCommit": "55af097696b44f689e0ff88123ab5f39b18bd8c0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNjI5MjgyNA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r606292824", "bodyText": "Set?", "author": "Windchild292", "createdAt": "2021-04-02T15:40:17Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconTrackState.java", "diffHunk": "@@ -0,0 +1,359 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.LocalDate;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlTransient;\n+\n+import mekhq.MekHQ;\n+import mekhq.MekHqXmlUtil;\n+import mekhq.campaign.event.DeploymentChangedEvent;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+\n+/**\n+ * Track-level state object for a stratcon campaign.\n+ * @author NickAragua\n+ */\n+@XmlRootElement(name=\"campaignTrack\")\n+public class StratconTrackState {\n+    public static final String ROOT_XML_ELEMENT_NAME = \"StratconTrackState\";\n+    \n+    // a track has the following characteristics:\n+    // width/height\n+    // [future]: terrain information by coordinates\n+    // scenario information by coordinates\n+    // active facilities by coordinates\n+    private String displayableName;\n+    private int width;\n+    private int height;\n+    private boolean gmRevealed;\n+    \n+    private Map<StratconCoords, StratconFacility> facilities;   \n+    private Map<StratconCoords, StratconScenario> scenarios;\n+    private Map<StratconCoords, HashSet<Integer>> assignedCoordForces; \n+    private Map<Integer, StratconCoords> assignedForceCoords;\n+    private Map<Integer, LocalDate> assignedForceReturnDates;\n+    private Set<Integer> stickyForces;\n+    private Map<Integer, String> assignedForceReturnDatesForStorage;\n+    private Set<StratconCoords> revealedCoords;\n+\n+    // don't serialize this\n+    private transient Map<Integer, StratconScenario> backingScenarioMap;\n+    \n+    private int scenarioOdds;\n+    private int deploymentTime;\n+    private int requiredLanceCount;\n+    \n+    public StratconTrackState() {\n+        facilities = new HashMap<>();\n+        scenarios = new HashMap<>();\n+        assignedForceCoords = new HashMap<>();\n+        assignedForceReturnDates = new HashMap<>();\n+        assignedCoordForces = new HashMap<>();\n+        setAssignedForceReturnDatesForStorage(new HashMap<>());\n+        revealedCoords = new HashSet<>();\n+        stickyForces = new HashSet<>();\n+    }\n+    \n+    public String getDisplayableName() {\n+        return displayableName;\n+    }\n+    \n+    public void setDisplayableName(String name) {\n+        displayableName = name;\n+    }\n+\n+    public int getWidth() {\n+        return width;\n+    }\n+\n+    public void setWidth(int width) {\n+        this.width = width;\n+    }\n+\n+    public int getHeight() {\n+        return height;\n+    }\n+\n+    public void setHeight(int height) {\n+        this.height = height;\n+    }\n+\n+    @XmlElementWrapper(name=\"trackFacilities\")\n+    @XmlElement(name=\"facility\")\n+    public Map<StratconCoords, StratconFacility> getFacilities() {\n+        return facilities;\n+    }\n+\n+    public void setFacilities(Map<StratconCoords, StratconFacility> facilities) {\n+        this.facilities = facilities;\n+    }\n+\n+    public StratconFacility getFacility(StratconCoords coords) {\n+        return facilities.get(coords);\n+    }\n+    \n+    /**\n+     * Used for serialization/deserialization.\n+     * Do not manipulate directly, or things get unpleasant.\n+     */\n+    @XmlElementWrapper(name=\"trackScenarios\")\n+    @XmlElement(name=\"scenario\")\n+    public Map<StratconCoords, StratconScenario> getScenarios() {\n+        return scenarios;\n+    }\n+\n+    public void setScenarios(Map<StratconCoords, StratconScenario> scenarios) {\n+        this.scenarios = scenarios;\n+    }\n+    \n+    /**\n+     * Adds a StratconScenario to this track. Assumes it already has some coordinates assigned,\n+     * and a valid campaign scenario ID for its backing AtB scenario\n+     */\n+    public void addScenario(StratconScenario scenario) {\n+        scenarios.put(scenario.getCoords(), scenario);\n+        \n+        updateScenario(scenario);\n+    }\n+    \n+    /**\n+     * Updates an existing scenario on this track.\n+     */\n+    public void updateScenario(StratconScenario scenario) {\n+        if(scenarios.containsKey(scenario.getCoords()) && (scenario.getBackingScenarioID() > 0)) {\n+            getBackingScenariosMap().put(scenario.getBackingScenarioID(), scenario);\n+        }\n+    }\n+    \n+    /**\n+     * Removes a StratconScenario from this track.\n+     */\n+    public void removeScenario(StratconScenario scenario) {\n+        scenarios.remove(scenario.getCoords());\n+        getBackingScenariosMap().remove(scenario.getBackingScenarioID());\n+    }\n+    \n+    public StratconScenario getScenario(StratconCoords coords) {\n+        return scenarios.get(coords);\n+    }\n+    \n+    public int getRequiredLanceCount() {\n+        return requiredLanceCount;\n+    }\n+\n+    public void setRequiredLanceCount(int requiredLanceCount) {\n+        this.requiredLanceCount = requiredLanceCount;\n+    }\n+    \n+    public int getDeploymentTime() {\n+        return deploymentTime;\n+    }\n+\n+    public void setDeploymentTime(int deploymentTime) {\n+        this.deploymentTime = deploymentTime;\n+    }\n+\n+    public int getScenarioOdds() {\n+        return scenarioOdds;\n+    }\n+\n+    public void setScenarioOdds(int scenarioOdds) {\n+        this.scenarioOdds = scenarioOdds;\n+    }\n+\n+    public boolean isGmRevealed() {\n+        return gmRevealed;\n+    }\n+\n+    public void setGmRevealed(boolean gmRevealed) {\n+        this.gmRevealed = gmRevealed;\n+    }\n+\n+    /**\n+     * Handles the assignment of a force to the given coordinates on this track on the given date.\n+     */\n+    public void assignForce(int forceID, StratconCoords coords, LocalDate date, boolean sticky) {\n+        assignedForceCoords.put(forceID, coords);\n+        assignedForceReturnDates.put(forceID, date.plusDays(deploymentTime));\n+        \n+        assignedCoordForces.putIfAbsent(coords, new HashSet<>());\n+        assignedCoordForces.get(coords).add(forceID);\n+        \n+        if (sticky) {\n+            addStickyForce(forceID);\n+        }\n+        \n+        getAssignedForceReturnDatesForStorage().put(forceID, date.plusDays(deploymentTime).toString());\n+    }\n+    \n+    /**\n+     * Handles the unassignment of a force from this track.\n+     */\n+    public void unassignForce(int forceID) {\n+        if (assignedForceCoords.containsKey(forceID)) {\n+            assignedCoordForces.get(assignedForceCoords.get(forceID)).remove(forceID);\n+            assignedForceCoords.remove(forceID);\n+            assignedForceReturnDates.remove(forceID);\n+            removeStickyForce(forceID);\n+            getAssignedForceReturnDatesForStorage().remove(forceID);\n+        }\n+    }\n+    \n+    /**\n+     * Restores the look up table of force IDs to return dates\n+     */\n+    public void restoreReturnDates() {\n+        for (int forceID : getAssignedForceReturnDatesForStorage().keySet()) {\n+            assignedForceReturnDates.put(forceID, MekHqXmlUtil.parseDate(getAssignedForceReturnDatesForStorage().get(forceID)));\n+        }\n+    }\n+    \n+    public Map<Integer, StratconCoords> getAssignedForceCoords() {\n+        return assignedForceCoords;\n+    }\n+\n+    public void setAssignedForceCoords(Map<Integer, StratconCoords> assignedForceCoords) {\n+        this.assignedForceCoords = assignedForceCoords;\n+    }\n+    \n+    @XmlTransient\n+    public Map<StratconCoords, HashSet<Integer>> getAssignedCoordForces() {\n+        return assignedCoordForces;\n+    }\n+\n+    public void setAssignedCoordForces(Map<StratconCoords, HashSet<Integer>> assignedCoordForces) {", "originalCommit": "55af097696b44f689e0ff88123ab5f39b18bd8c0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNjI5Mzk3Mw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r606293973", "bodyText": "nullable annotation", "author": "Windchild292", "createdAt": "2021-04-02T15:43:12Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconTrackState.java", "diffHunk": "@@ -0,0 +1,359 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.LocalDate;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlTransient;\n+\n+import mekhq.MekHQ;\n+import mekhq.MekHqXmlUtil;\n+import mekhq.campaign.event.DeploymentChangedEvent;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+\n+/**\n+ * Track-level state object for a stratcon campaign.\n+ * @author NickAragua\n+ */\n+@XmlRootElement(name=\"campaignTrack\")\n+public class StratconTrackState {\n+    public static final String ROOT_XML_ELEMENT_NAME = \"StratconTrackState\";\n+    \n+    // a track has the following characteristics:\n+    // width/height\n+    // [future]: terrain information by coordinates\n+    // scenario information by coordinates\n+    // active facilities by coordinates\n+    private String displayableName;\n+    private int width;\n+    private int height;\n+    private boolean gmRevealed;\n+    \n+    private Map<StratconCoords, StratconFacility> facilities;   \n+    private Map<StratconCoords, StratconScenario> scenarios;\n+    private Map<StratconCoords, HashSet<Integer>> assignedCoordForces; \n+    private Map<Integer, StratconCoords> assignedForceCoords;\n+    private Map<Integer, LocalDate> assignedForceReturnDates;\n+    private Set<Integer> stickyForces;\n+    private Map<Integer, String> assignedForceReturnDatesForStorage;\n+    private Set<StratconCoords> revealedCoords;\n+\n+    // don't serialize this\n+    private transient Map<Integer, StratconScenario> backingScenarioMap;\n+    \n+    private int scenarioOdds;\n+    private int deploymentTime;\n+    private int requiredLanceCount;\n+    \n+    public StratconTrackState() {\n+        facilities = new HashMap<>();\n+        scenarios = new HashMap<>();\n+        assignedForceCoords = new HashMap<>();\n+        assignedForceReturnDates = new HashMap<>();\n+        assignedCoordForces = new HashMap<>();\n+        setAssignedForceReturnDatesForStorage(new HashMap<>());\n+        revealedCoords = new HashSet<>();\n+        stickyForces = new HashSet<>();\n+    }\n+    \n+    public String getDisplayableName() {\n+        return displayableName;\n+    }\n+    \n+    public void setDisplayableName(String name) {\n+        displayableName = name;\n+    }\n+\n+    public int getWidth() {\n+        return width;\n+    }\n+\n+    public void setWidth(int width) {\n+        this.width = width;\n+    }\n+\n+    public int getHeight() {\n+        return height;\n+    }\n+\n+    public void setHeight(int height) {\n+        this.height = height;\n+    }\n+\n+    @XmlElementWrapper(name=\"trackFacilities\")\n+    @XmlElement(name=\"facility\")\n+    public Map<StratconCoords, StratconFacility> getFacilities() {\n+        return facilities;\n+    }\n+\n+    public void setFacilities(Map<StratconCoords, StratconFacility> facilities) {\n+        this.facilities = facilities;\n+    }\n+\n+    public StratconFacility getFacility(StratconCoords coords) {\n+        return facilities.get(coords);\n+    }\n+    \n+    /**\n+     * Used for serialization/deserialization.\n+     * Do not manipulate directly, or things get unpleasant.\n+     */\n+    @XmlElementWrapper(name=\"trackScenarios\")\n+    @XmlElement(name=\"scenario\")\n+    public Map<StratconCoords, StratconScenario> getScenarios() {\n+        return scenarios;\n+    }\n+\n+    public void setScenarios(Map<StratconCoords, StratconScenario> scenarios) {\n+        this.scenarios = scenarios;\n+    }\n+    \n+    /**\n+     * Adds a StratconScenario to this track. Assumes it already has some coordinates assigned,\n+     * and a valid campaign scenario ID for its backing AtB scenario\n+     */\n+    public void addScenario(StratconScenario scenario) {\n+        scenarios.put(scenario.getCoords(), scenario);\n+        \n+        updateScenario(scenario);\n+    }\n+    \n+    /**\n+     * Updates an existing scenario on this track.\n+     */\n+    public void updateScenario(StratconScenario scenario) {\n+        if(scenarios.containsKey(scenario.getCoords()) && (scenario.getBackingScenarioID() > 0)) {\n+            getBackingScenariosMap().put(scenario.getBackingScenarioID(), scenario);\n+        }\n+    }\n+    \n+    /**\n+     * Removes a StratconScenario from this track.\n+     */\n+    public void removeScenario(StratconScenario scenario) {\n+        scenarios.remove(scenario.getCoords());\n+        getBackingScenariosMap().remove(scenario.getBackingScenarioID());\n+    }\n+    \n+    public StratconScenario getScenario(StratconCoords coords) {\n+        return scenarios.get(coords);\n+    }\n+    \n+    public int getRequiredLanceCount() {\n+        return requiredLanceCount;\n+    }\n+\n+    public void setRequiredLanceCount(int requiredLanceCount) {\n+        this.requiredLanceCount = requiredLanceCount;\n+    }\n+    \n+    public int getDeploymentTime() {\n+        return deploymentTime;\n+    }\n+\n+    public void setDeploymentTime(int deploymentTime) {\n+        this.deploymentTime = deploymentTime;\n+    }\n+\n+    public int getScenarioOdds() {\n+        return scenarioOdds;\n+    }\n+\n+    public void setScenarioOdds(int scenarioOdds) {\n+        this.scenarioOdds = scenarioOdds;\n+    }\n+\n+    public boolean isGmRevealed() {\n+        return gmRevealed;\n+    }\n+\n+    public void setGmRevealed(boolean gmRevealed) {\n+        this.gmRevealed = gmRevealed;\n+    }\n+\n+    /**\n+     * Handles the assignment of a force to the given coordinates on this track on the given date.\n+     */\n+    public void assignForce(int forceID, StratconCoords coords, LocalDate date, boolean sticky) {\n+        assignedForceCoords.put(forceID, coords);\n+        assignedForceReturnDates.put(forceID, date.plusDays(deploymentTime));\n+        \n+        assignedCoordForces.putIfAbsent(coords, new HashSet<>());\n+        assignedCoordForces.get(coords).add(forceID);\n+        \n+        if (sticky) {\n+            addStickyForce(forceID);\n+        }\n+        \n+        getAssignedForceReturnDatesForStorage().put(forceID, date.plusDays(deploymentTime).toString());\n+    }\n+    \n+    /**\n+     * Handles the unassignment of a force from this track.\n+     */\n+    public void unassignForce(int forceID) {\n+        if (assignedForceCoords.containsKey(forceID)) {\n+            assignedCoordForces.get(assignedForceCoords.get(forceID)).remove(forceID);\n+            assignedForceCoords.remove(forceID);\n+            assignedForceReturnDates.remove(forceID);\n+            removeStickyForce(forceID);\n+            getAssignedForceReturnDatesForStorage().remove(forceID);\n+        }\n+    }\n+    \n+    /**\n+     * Restores the look up table of force IDs to return dates\n+     */\n+    public void restoreReturnDates() {\n+        for (int forceID : getAssignedForceReturnDatesForStorage().keySet()) {\n+            assignedForceReturnDates.put(forceID, MekHqXmlUtil.parseDate(getAssignedForceReturnDatesForStorage().get(forceID)));\n+        }\n+    }\n+    \n+    public Map<Integer, StratconCoords> getAssignedForceCoords() {\n+        return assignedForceCoords;\n+    }\n+\n+    public void setAssignedForceCoords(Map<Integer, StratconCoords> assignedForceCoords) {\n+        this.assignedForceCoords = assignedForceCoords;\n+    }\n+    \n+    @XmlTransient\n+    public Map<StratconCoords, HashSet<Integer>> getAssignedCoordForces() {\n+        return assignedCoordForces;\n+    }\n+\n+    public void setAssignedCoordForces(Map<StratconCoords, HashSet<Integer>> assignedCoordForces) {\n+        this.assignedCoordForces = assignedCoordForces;\n+    }\n+    \n+    /**\n+     * Restores the look up table of coordinates to force lists\n+     */\n+    public void restoreAssignedCoordForces() {\n+        for (int forceID : assignedForceCoords.keySet()) {\n+            assignedCoordForces.putIfAbsent(assignedForceCoords.get(forceID), new HashSet<>());\n+            assignedCoordForces.get(assignedForceCoords.get(forceID)).add(forceID);\n+        }\n+    }\n+\n+    @XmlTransient\n+    public Map<Integer, LocalDate> getAssignedForceReturnDates() {\n+        return assignedForceReturnDates;\n+    }\n+\n+    public void setAssignedForceReturnDates(Map<Integer, LocalDate> assignedForceReturnDates) {\n+        this.assignedForceReturnDates = assignedForceReturnDates;\n+    }\n+\n+    public Map<Integer, String> getAssignedForceReturnDatesForStorage() {\n+        return assignedForceReturnDatesForStorage;\n+    }\n+\n+    public void setAssignedForceReturnDatesForStorage(Map<Integer, String> assignedForceReturnDatesForStorage) {\n+        this.assignedForceReturnDatesForStorage = assignedForceReturnDatesForStorage;\n+    }\n+\n+    public boolean coordsRevealed(int x, int y) {\n+        return revealedCoords.contains(new StratconCoords(x, y));\n+    }\n+    \n+    public Set<StratconCoords> getRevealedCoords() {\n+        return revealedCoords;\n+    }\n+\n+    public void setRevealedCoords(Set<StratconCoords> revealedCoords) {\n+        this.revealedCoords = revealedCoords;\n+    }\n+\n+    public void addFacility(StratconCoords coords, StratconFacility facility) {\n+        facilities.put(coords, facility);\n+    }\n+    \n+    public void removeFacility(StratconCoords coords) {\n+        facilities.remove(coords);\n+    }\n+    \n+    /**\n+     * Returns the allied facility coordinates closest to the given coordinates. Null if no allied facilities on the board.\n+     */\n+    public StratconCoords findClosestAlliedFacilityCoords(StratconCoords coords) {", "originalCommit": "55af097696b44f689e0ff88123ab5f39b18bd8c0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNjI5NTQ0MA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r606295440", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // todo: place terrain\n          \n          \n            \n                    // TODO: place terrain", "author": "Windchild292", "createdAt": "2021-04-02T15:46:38Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconContractInitializer.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ * Copyright (c) 2019 The Megamek Team. All rights reserved.\n+ *\n+ * This file is part of MekHQ.\n+ *\n+ * MekHQ is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * MekHQ is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with MekHQ.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import megamek.common.Compute;\n+import mekhq.MekHQ;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.Mission;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.stratcon.StratconContractDefinition.ObjectiveParameters;\n+\n+/**\n+ * This class handles StratCon state initialization when a contract is signed.\n+ */\n+public class StratconContractInitializer {\n+    public static final int NUM_LANCES_PER_TRACK = 3;\n+\n+    /**\n+     * Initializes the campaign state given a contract, campaign and contract definition\n+     */\n+    public static void initializeCampaignState(AtBContract contract, Campaign campaign, StratconContractDefinition contractDefinition) {\n+        StratconCampaignState campaignState = new StratconCampaignState(contract);\n+        campaignState.setBriefingText(contractDefinition.getBriefing() + \"<br/>\" + generateCommandLevelText(contract));\n+        campaignState.setStrategicObjectivesBehaveAsVPs(contractDefinition.objectivesBehaveAsVPs());\n+        \n+        // dependency: this is required here in order for scenario initialization to work properly\n+        contract.setStratconCampaignState(campaignState);\n+        \n+        // First, initialize the proper number of tracks. Then:\n+        // for each objective: \n+        //  step 1: calculate objective count\n+        //          if scaled, multiply # required lances by factor, round up, otherwise just fixed #\n+        //  step 2: evenly distribute objectives through tracks\n+        //          if uneven number remaining, distribute randomly \n+        //          when objective is specific scenario victory, place specially flagged scenarios\n+        //          when objective is allied/hostile facility, place those facilities\n+\n+        int numTracks = contract.getRequiredLances() / NUM_LANCES_PER_TRACK;\n+        \n+        for (int x = 0; x < numTracks; x++) {\n+            int scenarioOdds = contractDefinition.getScenarioOdds().get(Compute.randomInt(contractDefinition.getScenarioOdds().size()));\n+            int deploymentTime = contractDefinition.getDeploymentTimes().get(Compute.randomInt(contractDefinition.getDeploymentTimes().size()));\n+            \n+            StratconTrackState track = initializeTrackState(NUM_LANCES_PER_TRACK, scenarioOdds, deploymentTime);\n+            track.setDisplayableName(String.format(\"Track %d\", x));\n+            campaignState.addTrack(track);\n+        }\n+        \n+        // a campaign will have X tracks going at a time, where\n+        // X = # required lances / 3, rounded up. The last track will have fewer required lances.\n+        int oddLanceCount = contract.getRequiredLances() % NUM_LANCES_PER_TRACK;\n+        if (oddLanceCount > 0) {\n+            int scenarioOdds = contractDefinition.getScenarioOdds().get(Compute.randomInt(contractDefinition.getScenarioOdds().size()));\n+            int deploymentTime = contractDefinition.getDeploymentTimes().get(Compute.randomInt(contractDefinition.getDeploymentTimes().size()));\n+            \n+            StratconTrackState track = initializeTrackState(oddLanceCount, scenarioOdds, deploymentTime);\n+            track.setDisplayableName(String.format(\"Track %d\", campaignState.getTracks().size()));\n+            campaignState.addTrack(track);\n+        }\n+        \n+        // now seed the tracks with objectives and facilities\n+        for (ObjectiveParameters objectiveParams : contractDefinition.getObjectiveParameters()) {\n+            int objectiveCount = objectiveParams.objectiveCount > 0 ?\n+                    (int) objectiveParams.objectiveCount :\n+                    (int) (-objectiveParams.objectiveCount * contract.getRequiredLances());\n+                    \n+            campaignState.incrementPendingStrategicObjectiveCount(objectiveCount);\n+                    \n+            List<Integer> trackObjects = trackObjectDistribution(objectiveCount, campaignState.getTracks().size()); \n+                   \n+            for (int x = 0; x < trackObjects.size(); x++) {\n+                int numObjects = trackObjects.get(x);\n+                \n+                switch (objectiveParams.objectiveType) {\n+                    case SpecificScenarioVictory:\n+                        initializeObjectiveScenarios(campaign, contract, campaignState.getTrack(x), numObjects,\n+                                objectiveParams.objectiveScenarios, objectiveParams.objectiveScenarioModifiers);\n+                        break;\n+                    case AlliedFacilityControl:\n+                        initializeTrackFacilities(campaignState.getTrack(x), numObjects, ForceAlignment.Allied, null, true);\n+                        break;\n+                    case HostileFacilityControl:\n+                    case FacilityDestruction:\n+                        initializeTrackFacilities(campaignState.getTrack(x), numObjects, ForceAlignment.Opposing, null, true);\n+                        break;\n+                    case AnyScenarioVictory:\n+                        if (objectiveParams.objectiveScenarioModifiers != null) {\n+                            campaignState.getGlobalScenarioModifiers().addAll(objectiveParams.objectiveScenarioModifiers);\n+                        }\n+                    break;\n+                }\n+            }\n+        }\n+        \n+        // non-objective allied facilities\n+        int facilityCount = contractDefinition.getAlliedFacilityCount() > 0 ?\n+                (int) contractDefinition.getAlliedFacilityCount() :\n+                (int) (-contractDefinition.getAlliedFacilityCount() * contract.getRequiredLances());\n+                \n+        List<Integer> trackObjects = trackObjectDistribution(facilityCount, campaignState.getTracks().size()); \n+               \n+        for (int x = 0; x < trackObjects.size(); x++) {\n+            int numObjects = trackObjects.get(x);\n+            \n+            initializeTrackFacilities(campaignState.getTrack(x), numObjects, ForceAlignment.Allied, null, false);\n+        }\n+        \n+        // non-objective hostile facilities\n+        facilityCount = contractDefinition.getHostileFacilityCount() > 0 ?\n+                (int) contractDefinition.getHostileFacilityCount() :\n+                (int) (-contractDefinition.getHostileFacilityCount() * contract.getRequiredLances());\n+                \n+        trackObjects = trackObjectDistribution(facilityCount, campaignState.getTracks().size()); \n+               \n+        for (int x = 0; x < trackObjects.size(); x++) {\n+            int numObjects = trackObjects.get(x);\n+            \n+            initializeTrackFacilities(campaignState.getTrack(x), numObjects, ForceAlignment.Opposing, null, false);\n+        }\n+        \n+        // now we're done\n+    }\n+    \n+    /**\n+     * Set up initial state of a track, dimensions are based on number of assigned lances.\n+     */\n+    public static StratconTrackState initializeTrackState(int numLances, int scenarioOdds, int deploymentTime) {\n+        // to initialize a track, \n+        // 1. we set the # of required lances\n+        // 2. set the track size to a total of numlances * 28 hexes, a rectangle that is wider than it is taller\n+        //      the idea being to create a roughly rectangular playing field that,\n+        //      if one deploys a scout lance each week to a different spot, can be more or less fully covered\n+        \n+        StratconTrackState retVal = new StratconTrackState();\n+        retVal.setRequiredLanceCount(numLances);\n+        \n+        // set width and height\n+        int numHexes = numLances * 28;\n+        int height = (int) Math.floor(Math.sqrt(numHexes));\n+        int width = numHexes / height;\n+        retVal.setWidth(width);\n+        retVal.setHeight(height);\n+        \n+        retVal.setScenarioOdds(scenarioOdds);\n+        retVal.setDeploymentTime(deploymentTime);\n+        \n+        // todo: place terrain", "originalCommit": "55af097696b44f689e0ff88123ab5f39b18bd8c0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNjI5NTgxMg==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r606295812", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if(leftOver > 0) {\n          \n          \n            \n                        if (leftOver > 0) {", "author": "Windchild292", "createdAt": "2021-04-02T15:47:23Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconContractInitializer.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ * Copyright (c) 2019 The Megamek Team. All rights reserved.\n+ *\n+ * This file is part of MekHQ.\n+ *\n+ * MekHQ is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * MekHQ is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with MekHQ.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import megamek.common.Compute;\n+import mekhq.MekHQ;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.Mission;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.stratcon.StratconContractDefinition.ObjectiveParameters;\n+\n+/**\n+ * This class handles StratCon state initialization when a contract is signed.\n+ */\n+public class StratconContractInitializer {\n+    public static final int NUM_LANCES_PER_TRACK = 3;\n+\n+    /**\n+     * Initializes the campaign state given a contract, campaign and contract definition\n+     */\n+    public static void initializeCampaignState(AtBContract contract, Campaign campaign, StratconContractDefinition contractDefinition) {\n+        StratconCampaignState campaignState = new StratconCampaignState(contract);\n+        campaignState.setBriefingText(contractDefinition.getBriefing() + \"<br/>\" + generateCommandLevelText(contract));\n+        campaignState.setStrategicObjectivesBehaveAsVPs(contractDefinition.objectivesBehaveAsVPs());\n+        \n+        // dependency: this is required here in order for scenario initialization to work properly\n+        contract.setStratconCampaignState(campaignState);\n+        \n+        // First, initialize the proper number of tracks. Then:\n+        // for each objective: \n+        //  step 1: calculate objective count\n+        //          if scaled, multiply # required lances by factor, round up, otherwise just fixed #\n+        //  step 2: evenly distribute objectives through tracks\n+        //          if uneven number remaining, distribute randomly \n+        //          when objective is specific scenario victory, place specially flagged scenarios\n+        //          when objective is allied/hostile facility, place those facilities\n+\n+        int numTracks = contract.getRequiredLances() / NUM_LANCES_PER_TRACK;\n+        \n+        for (int x = 0; x < numTracks; x++) {\n+            int scenarioOdds = contractDefinition.getScenarioOdds().get(Compute.randomInt(contractDefinition.getScenarioOdds().size()));\n+            int deploymentTime = contractDefinition.getDeploymentTimes().get(Compute.randomInt(contractDefinition.getDeploymentTimes().size()));\n+            \n+            StratconTrackState track = initializeTrackState(NUM_LANCES_PER_TRACK, scenarioOdds, deploymentTime);\n+            track.setDisplayableName(String.format(\"Track %d\", x));\n+            campaignState.addTrack(track);\n+        }\n+        \n+        // a campaign will have X tracks going at a time, where\n+        // X = # required lances / 3, rounded up. The last track will have fewer required lances.\n+        int oddLanceCount = contract.getRequiredLances() % NUM_LANCES_PER_TRACK;\n+        if (oddLanceCount > 0) {\n+            int scenarioOdds = contractDefinition.getScenarioOdds().get(Compute.randomInt(contractDefinition.getScenarioOdds().size()));\n+            int deploymentTime = contractDefinition.getDeploymentTimes().get(Compute.randomInt(contractDefinition.getDeploymentTimes().size()));\n+            \n+            StratconTrackState track = initializeTrackState(oddLanceCount, scenarioOdds, deploymentTime);\n+            track.setDisplayableName(String.format(\"Track %d\", campaignState.getTracks().size()));\n+            campaignState.addTrack(track);\n+        }\n+        \n+        // now seed the tracks with objectives and facilities\n+        for (ObjectiveParameters objectiveParams : contractDefinition.getObjectiveParameters()) {\n+            int objectiveCount = objectiveParams.objectiveCount > 0 ?\n+                    (int) objectiveParams.objectiveCount :\n+                    (int) (-objectiveParams.objectiveCount * contract.getRequiredLances());\n+                    \n+            campaignState.incrementPendingStrategicObjectiveCount(objectiveCount);\n+                    \n+            List<Integer> trackObjects = trackObjectDistribution(objectiveCount, campaignState.getTracks().size()); \n+                   \n+            for (int x = 0; x < trackObjects.size(); x++) {\n+                int numObjects = trackObjects.get(x);\n+                \n+                switch (objectiveParams.objectiveType) {\n+                    case SpecificScenarioVictory:\n+                        initializeObjectiveScenarios(campaign, contract, campaignState.getTrack(x), numObjects,\n+                                objectiveParams.objectiveScenarios, objectiveParams.objectiveScenarioModifiers);\n+                        break;\n+                    case AlliedFacilityControl:\n+                        initializeTrackFacilities(campaignState.getTrack(x), numObjects, ForceAlignment.Allied, null, true);\n+                        break;\n+                    case HostileFacilityControl:\n+                    case FacilityDestruction:\n+                        initializeTrackFacilities(campaignState.getTrack(x), numObjects, ForceAlignment.Opposing, null, true);\n+                        break;\n+                    case AnyScenarioVictory:\n+                        if (objectiveParams.objectiveScenarioModifiers != null) {\n+                            campaignState.getGlobalScenarioModifiers().addAll(objectiveParams.objectiveScenarioModifiers);\n+                        }\n+                    break;\n+                }\n+            }\n+        }\n+        \n+        // non-objective allied facilities\n+        int facilityCount = contractDefinition.getAlliedFacilityCount() > 0 ?\n+                (int) contractDefinition.getAlliedFacilityCount() :\n+                (int) (-contractDefinition.getAlliedFacilityCount() * contract.getRequiredLances());\n+                \n+        List<Integer> trackObjects = trackObjectDistribution(facilityCount, campaignState.getTracks().size()); \n+               \n+        for (int x = 0; x < trackObjects.size(); x++) {\n+            int numObjects = trackObjects.get(x);\n+            \n+            initializeTrackFacilities(campaignState.getTrack(x), numObjects, ForceAlignment.Allied, null, false);\n+        }\n+        \n+        // non-objective hostile facilities\n+        facilityCount = contractDefinition.getHostileFacilityCount() > 0 ?\n+                (int) contractDefinition.getHostileFacilityCount() :\n+                (int) (-contractDefinition.getHostileFacilityCount() * contract.getRequiredLances());\n+                \n+        trackObjects = trackObjectDistribution(facilityCount, campaignState.getTracks().size()); \n+               \n+        for (int x = 0; x < trackObjects.size(); x++) {\n+            int numObjects = trackObjects.get(x);\n+            \n+            initializeTrackFacilities(campaignState.getTrack(x), numObjects, ForceAlignment.Opposing, null, false);\n+        }\n+        \n+        // now we're done\n+    }\n+    \n+    /**\n+     * Set up initial state of a track, dimensions are based on number of assigned lances.\n+     */\n+    public static StratconTrackState initializeTrackState(int numLances, int scenarioOdds, int deploymentTime) {\n+        // to initialize a track, \n+        // 1. we set the # of required lances\n+        // 2. set the track size to a total of numlances * 28 hexes, a rectangle that is wider than it is taller\n+        //      the idea being to create a roughly rectangular playing field that,\n+        //      if one deploys a scout lance each week to a different spot, can be more or less fully covered\n+        \n+        StratconTrackState retVal = new StratconTrackState();\n+        retVal.setRequiredLanceCount(numLances);\n+        \n+        // set width and height\n+        int numHexes = numLances * 28;\n+        int height = (int) Math.floor(Math.sqrt(numHexes));\n+        int width = numHexes / height;\n+        retVal.setWidth(width);\n+        retVal.setHeight(height);\n+        \n+        retVal.setScenarioOdds(scenarioOdds);\n+        retVal.setDeploymentTime(deploymentTime);\n+        \n+        // todo: place terrain\n+        \n+        return retVal;\n+    }\n+    \n+    /**\n+     * Generates an array list representing the number of objects to place in a given number of tracks.\n+     */\n+    private static List<Integer> trackObjectDistribution(int numObjects, int numTracks) {\n+        List<Integer> retVal = new ArrayList<>();\n+        int leftOver = numObjects % numTracks;\n+        \n+        for (int track = 0; track < numTracks; track++) {\n+            int trackObjects = numObjects / numTracks;\n+            \n+            // if we are unevenly distributed, add an extra one\n+            if(leftOver > 0) {", "originalCommit": "55af097696b44f689e0ff88123ab5f39b18bd8c0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNjI5NjU3NQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r606296575", "bodyText": "Is it possible this will infinite loop?", "author": "Windchild292", "createdAt": "2021-04-02T15:49:01Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconContractInitializer.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ * Copyright (c) 2019 The Megamek Team. All rights reserved.\n+ *\n+ * This file is part of MekHQ.\n+ *\n+ * MekHQ is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * MekHQ is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with MekHQ.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import megamek.common.Compute;\n+import mekhq.MekHQ;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.Mission;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.stratcon.StratconContractDefinition.ObjectiveParameters;\n+\n+/**\n+ * This class handles StratCon state initialization when a contract is signed.\n+ */\n+public class StratconContractInitializer {\n+    public static final int NUM_LANCES_PER_TRACK = 3;\n+\n+    /**\n+     * Initializes the campaign state given a contract, campaign and contract definition\n+     */\n+    public static void initializeCampaignState(AtBContract contract, Campaign campaign, StratconContractDefinition contractDefinition) {\n+        StratconCampaignState campaignState = new StratconCampaignState(contract);\n+        campaignState.setBriefingText(contractDefinition.getBriefing() + \"<br/>\" + generateCommandLevelText(contract));\n+        campaignState.setStrategicObjectivesBehaveAsVPs(contractDefinition.objectivesBehaveAsVPs());\n+        \n+        // dependency: this is required here in order for scenario initialization to work properly\n+        contract.setStratconCampaignState(campaignState);\n+        \n+        // First, initialize the proper number of tracks. Then:\n+        // for each objective: \n+        //  step 1: calculate objective count\n+        //          if scaled, multiply # required lances by factor, round up, otherwise just fixed #\n+        //  step 2: evenly distribute objectives through tracks\n+        //          if uneven number remaining, distribute randomly \n+        //          when objective is specific scenario victory, place specially flagged scenarios\n+        //          when objective is allied/hostile facility, place those facilities\n+\n+        int numTracks = contract.getRequiredLances() / NUM_LANCES_PER_TRACK;\n+        \n+        for (int x = 0; x < numTracks; x++) {\n+            int scenarioOdds = contractDefinition.getScenarioOdds().get(Compute.randomInt(contractDefinition.getScenarioOdds().size()));\n+            int deploymentTime = contractDefinition.getDeploymentTimes().get(Compute.randomInt(contractDefinition.getDeploymentTimes().size()));\n+            \n+            StratconTrackState track = initializeTrackState(NUM_LANCES_PER_TRACK, scenarioOdds, deploymentTime);\n+            track.setDisplayableName(String.format(\"Track %d\", x));\n+            campaignState.addTrack(track);\n+        }\n+        \n+        // a campaign will have X tracks going at a time, where\n+        // X = # required lances / 3, rounded up. The last track will have fewer required lances.\n+        int oddLanceCount = contract.getRequiredLances() % NUM_LANCES_PER_TRACK;\n+        if (oddLanceCount > 0) {\n+            int scenarioOdds = contractDefinition.getScenarioOdds().get(Compute.randomInt(contractDefinition.getScenarioOdds().size()));\n+            int deploymentTime = contractDefinition.getDeploymentTimes().get(Compute.randomInt(contractDefinition.getDeploymentTimes().size()));\n+            \n+            StratconTrackState track = initializeTrackState(oddLanceCount, scenarioOdds, deploymentTime);\n+            track.setDisplayableName(String.format(\"Track %d\", campaignState.getTracks().size()));\n+            campaignState.addTrack(track);\n+        }\n+        \n+        // now seed the tracks with objectives and facilities\n+        for (ObjectiveParameters objectiveParams : contractDefinition.getObjectiveParameters()) {\n+            int objectiveCount = objectiveParams.objectiveCount > 0 ?\n+                    (int) objectiveParams.objectiveCount :\n+                    (int) (-objectiveParams.objectiveCount * contract.getRequiredLances());\n+                    \n+            campaignState.incrementPendingStrategicObjectiveCount(objectiveCount);\n+                    \n+            List<Integer> trackObjects = trackObjectDistribution(objectiveCount, campaignState.getTracks().size()); \n+                   \n+            for (int x = 0; x < trackObjects.size(); x++) {\n+                int numObjects = trackObjects.get(x);\n+                \n+                switch (objectiveParams.objectiveType) {\n+                    case SpecificScenarioVictory:\n+                        initializeObjectiveScenarios(campaign, contract, campaignState.getTrack(x), numObjects,\n+                                objectiveParams.objectiveScenarios, objectiveParams.objectiveScenarioModifiers);\n+                        break;\n+                    case AlliedFacilityControl:\n+                        initializeTrackFacilities(campaignState.getTrack(x), numObjects, ForceAlignment.Allied, null, true);\n+                        break;\n+                    case HostileFacilityControl:\n+                    case FacilityDestruction:\n+                        initializeTrackFacilities(campaignState.getTrack(x), numObjects, ForceAlignment.Opposing, null, true);\n+                        break;\n+                    case AnyScenarioVictory:\n+                        if (objectiveParams.objectiveScenarioModifiers != null) {\n+                            campaignState.getGlobalScenarioModifiers().addAll(objectiveParams.objectiveScenarioModifiers);\n+                        }\n+                    break;\n+                }\n+            }\n+        }\n+        \n+        // non-objective allied facilities\n+        int facilityCount = contractDefinition.getAlliedFacilityCount() > 0 ?\n+                (int) contractDefinition.getAlliedFacilityCount() :\n+                (int) (-contractDefinition.getAlliedFacilityCount() * contract.getRequiredLances());\n+                \n+        List<Integer> trackObjects = trackObjectDistribution(facilityCount, campaignState.getTracks().size()); \n+               \n+        for (int x = 0; x < trackObjects.size(); x++) {\n+            int numObjects = trackObjects.get(x);\n+            \n+            initializeTrackFacilities(campaignState.getTrack(x), numObjects, ForceAlignment.Allied, null, false);\n+        }\n+        \n+        // non-objective hostile facilities\n+        facilityCount = contractDefinition.getHostileFacilityCount() > 0 ?\n+                (int) contractDefinition.getHostileFacilityCount() :\n+                (int) (-contractDefinition.getHostileFacilityCount() * contract.getRequiredLances());\n+                \n+        trackObjects = trackObjectDistribution(facilityCount, campaignState.getTracks().size()); \n+               \n+        for (int x = 0; x < trackObjects.size(); x++) {\n+            int numObjects = trackObjects.get(x);\n+            \n+            initializeTrackFacilities(campaignState.getTrack(x), numObjects, ForceAlignment.Opposing, null, false);\n+        }\n+        \n+        // now we're done\n+    }\n+    \n+    /**\n+     * Set up initial state of a track, dimensions are based on number of assigned lances.\n+     */\n+    public static StratconTrackState initializeTrackState(int numLances, int scenarioOdds, int deploymentTime) {\n+        // to initialize a track, \n+        // 1. we set the # of required lances\n+        // 2. set the track size to a total of numlances * 28 hexes, a rectangle that is wider than it is taller\n+        //      the idea being to create a roughly rectangular playing field that,\n+        //      if one deploys a scout lance each week to a different spot, can be more or less fully covered\n+        \n+        StratconTrackState retVal = new StratconTrackState();\n+        retVal.setRequiredLanceCount(numLances);\n+        \n+        // set width and height\n+        int numHexes = numLances * 28;\n+        int height = (int) Math.floor(Math.sqrt(numHexes));\n+        int width = numHexes / height;\n+        retVal.setWidth(width);\n+        retVal.setHeight(height);\n+        \n+        retVal.setScenarioOdds(scenarioOdds);\n+        retVal.setDeploymentTime(deploymentTime);\n+        \n+        // todo: place terrain\n+        \n+        return retVal;\n+    }\n+    \n+    /**\n+     * Generates an array list representing the number of objects to place in a given number of tracks.\n+     */\n+    private static List<Integer> trackObjectDistribution(int numObjects, int numTracks) {\n+        List<Integer> retVal = new ArrayList<>();\n+        int leftOver = numObjects % numTracks;\n+        \n+        for (int track = 0; track < numTracks; track++) {\n+            int trackObjects = numObjects / numTracks;\n+            \n+            // if we are unevenly distributed, add an extra one\n+            if(leftOver > 0) {\n+                trackObjects++;\n+                leftOver--;\n+            }\n+            \n+            retVal.add(trackObjects);\n+        }\n+        \n+        // don't always front-load extra objects\n+        Collections.shuffle(retVal);        \n+        return retVal;\n+    }\n+    \n+    /**\n+     * Worker function that takes a trackstate and plops down the given number of facilities owned by the given faction\n+     * Avoids places with existing facilities and scenarios, capable of taking facility sub set and setting strategic objective flag.\n+     */\n+    private static void initializeTrackFacilities(StratconTrackState trackState, int numFacilities, ForceAlignment owner, \n+            List<String> facilitySubset, boolean strategicObjective) {\n+        for (int fCount = 0; fCount < numFacilities; fCount++) {\n+            StratconFacility sf =\n+                    facilitySubset == null ? \n+                    StratconFacilityFactory.getRandomFacility() :\n+                    StratconFacilityFactory.getFacilityByName(facilitySubset.get(Compute.randomInt(facilitySubset.size())));\n+            sf.setOwner(owner);\n+            sf.setStrategicObjective(strategicObjective);\n+            \n+            int x = Compute.randomInt(trackState.getWidth());\n+            int y = Compute.randomInt(trackState.getHeight());\n+            StratconCoords coords = new StratconCoords(x, y);\n+            \n+            // make sure we don't put the facility down on top of anything else\n+            while ((trackState.getFacility(coords) != null) ||\n+                    (trackState.getScenario(coords) != null)) {", "originalCommit": "55af097696b44f689e0ff88123ab5f39b18bd8c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNjU1NTE3OQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r606555179", "bodyText": "That would mean that the whole map is covered with facilities and scenarios. Not something that's going to happen normally, but it's probably possible to create some kind of edge case contract definition that results in this behavior.", "author": "NickAragua", "createdAt": "2021-04-03T01:09:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNjI5NjU3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNjI5NzE2Mw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r606297163", "bodyText": "Infinite loop? Also, given this is used multiple times it might be best to create a separate method for this.", "author": "Windchild292", "createdAt": "2021-04-02T15:50:20Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconContractInitializer.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ * Copyright (c) 2019 The Megamek Team. All rights reserved.\n+ *\n+ * This file is part of MekHQ.\n+ *\n+ * MekHQ is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * MekHQ is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with MekHQ.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import megamek.common.Compute;\n+import mekhq.MekHQ;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.Mission;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.stratcon.StratconContractDefinition.ObjectiveParameters;\n+\n+/**\n+ * This class handles StratCon state initialization when a contract is signed.\n+ */\n+public class StratconContractInitializer {\n+    public static final int NUM_LANCES_PER_TRACK = 3;\n+\n+    /**\n+     * Initializes the campaign state given a contract, campaign and contract definition\n+     */\n+    public static void initializeCampaignState(AtBContract contract, Campaign campaign, StratconContractDefinition contractDefinition) {\n+        StratconCampaignState campaignState = new StratconCampaignState(contract);\n+        campaignState.setBriefingText(contractDefinition.getBriefing() + \"<br/>\" + generateCommandLevelText(contract));\n+        campaignState.setStrategicObjectivesBehaveAsVPs(contractDefinition.objectivesBehaveAsVPs());\n+        \n+        // dependency: this is required here in order for scenario initialization to work properly\n+        contract.setStratconCampaignState(campaignState);\n+        \n+        // First, initialize the proper number of tracks. Then:\n+        // for each objective: \n+        //  step 1: calculate objective count\n+        //          if scaled, multiply # required lances by factor, round up, otherwise just fixed #\n+        //  step 2: evenly distribute objectives through tracks\n+        //          if uneven number remaining, distribute randomly \n+        //          when objective is specific scenario victory, place specially flagged scenarios\n+        //          when objective is allied/hostile facility, place those facilities\n+\n+        int numTracks = contract.getRequiredLances() / NUM_LANCES_PER_TRACK;\n+        \n+        for (int x = 0; x < numTracks; x++) {\n+            int scenarioOdds = contractDefinition.getScenarioOdds().get(Compute.randomInt(contractDefinition.getScenarioOdds().size()));\n+            int deploymentTime = contractDefinition.getDeploymentTimes().get(Compute.randomInt(contractDefinition.getDeploymentTimes().size()));\n+            \n+            StratconTrackState track = initializeTrackState(NUM_LANCES_PER_TRACK, scenarioOdds, deploymentTime);\n+            track.setDisplayableName(String.format(\"Track %d\", x));\n+            campaignState.addTrack(track);\n+        }\n+        \n+        // a campaign will have X tracks going at a time, where\n+        // X = # required lances / 3, rounded up. The last track will have fewer required lances.\n+        int oddLanceCount = contract.getRequiredLances() % NUM_LANCES_PER_TRACK;\n+        if (oddLanceCount > 0) {\n+            int scenarioOdds = contractDefinition.getScenarioOdds().get(Compute.randomInt(contractDefinition.getScenarioOdds().size()));\n+            int deploymentTime = contractDefinition.getDeploymentTimes().get(Compute.randomInt(contractDefinition.getDeploymentTimes().size()));\n+            \n+            StratconTrackState track = initializeTrackState(oddLanceCount, scenarioOdds, deploymentTime);\n+            track.setDisplayableName(String.format(\"Track %d\", campaignState.getTracks().size()));\n+            campaignState.addTrack(track);\n+        }\n+        \n+        // now seed the tracks with objectives and facilities\n+        for (ObjectiveParameters objectiveParams : contractDefinition.getObjectiveParameters()) {\n+            int objectiveCount = objectiveParams.objectiveCount > 0 ?\n+                    (int) objectiveParams.objectiveCount :\n+                    (int) (-objectiveParams.objectiveCount * contract.getRequiredLances());\n+                    \n+            campaignState.incrementPendingStrategicObjectiveCount(objectiveCount);\n+                    \n+            List<Integer> trackObjects = trackObjectDistribution(objectiveCount, campaignState.getTracks().size()); \n+                   \n+            for (int x = 0; x < trackObjects.size(); x++) {\n+                int numObjects = trackObjects.get(x);\n+                \n+                switch (objectiveParams.objectiveType) {\n+                    case SpecificScenarioVictory:\n+                        initializeObjectiveScenarios(campaign, contract, campaignState.getTrack(x), numObjects,\n+                                objectiveParams.objectiveScenarios, objectiveParams.objectiveScenarioModifiers);\n+                        break;\n+                    case AlliedFacilityControl:\n+                        initializeTrackFacilities(campaignState.getTrack(x), numObjects, ForceAlignment.Allied, null, true);\n+                        break;\n+                    case HostileFacilityControl:\n+                    case FacilityDestruction:\n+                        initializeTrackFacilities(campaignState.getTrack(x), numObjects, ForceAlignment.Opposing, null, true);\n+                        break;\n+                    case AnyScenarioVictory:\n+                        if (objectiveParams.objectiveScenarioModifiers != null) {\n+                            campaignState.getGlobalScenarioModifiers().addAll(objectiveParams.objectiveScenarioModifiers);\n+                        }\n+                    break;\n+                }\n+            }\n+        }\n+        \n+        // non-objective allied facilities\n+        int facilityCount = contractDefinition.getAlliedFacilityCount() > 0 ?\n+                (int) contractDefinition.getAlliedFacilityCount() :\n+                (int) (-contractDefinition.getAlliedFacilityCount() * contract.getRequiredLances());\n+                \n+        List<Integer> trackObjects = trackObjectDistribution(facilityCount, campaignState.getTracks().size()); \n+               \n+        for (int x = 0; x < trackObjects.size(); x++) {\n+            int numObjects = trackObjects.get(x);\n+            \n+            initializeTrackFacilities(campaignState.getTrack(x), numObjects, ForceAlignment.Allied, null, false);\n+        }\n+        \n+        // non-objective hostile facilities\n+        facilityCount = contractDefinition.getHostileFacilityCount() > 0 ?\n+                (int) contractDefinition.getHostileFacilityCount() :\n+                (int) (-contractDefinition.getHostileFacilityCount() * contract.getRequiredLances());\n+                \n+        trackObjects = trackObjectDistribution(facilityCount, campaignState.getTracks().size()); \n+               \n+        for (int x = 0; x < trackObjects.size(); x++) {\n+            int numObjects = trackObjects.get(x);\n+            \n+            initializeTrackFacilities(campaignState.getTrack(x), numObjects, ForceAlignment.Opposing, null, false);\n+        }\n+        \n+        // now we're done\n+    }\n+    \n+    /**\n+     * Set up initial state of a track, dimensions are based on number of assigned lances.\n+     */\n+    public static StratconTrackState initializeTrackState(int numLances, int scenarioOdds, int deploymentTime) {\n+        // to initialize a track, \n+        // 1. we set the # of required lances\n+        // 2. set the track size to a total of numlances * 28 hexes, a rectangle that is wider than it is taller\n+        //      the idea being to create a roughly rectangular playing field that,\n+        //      if one deploys a scout lance each week to a different spot, can be more or less fully covered\n+        \n+        StratconTrackState retVal = new StratconTrackState();\n+        retVal.setRequiredLanceCount(numLances);\n+        \n+        // set width and height\n+        int numHexes = numLances * 28;\n+        int height = (int) Math.floor(Math.sqrt(numHexes));\n+        int width = numHexes / height;\n+        retVal.setWidth(width);\n+        retVal.setHeight(height);\n+        \n+        retVal.setScenarioOdds(scenarioOdds);\n+        retVal.setDeploymentTime(deploymentTime);\n+        \n+        // todo: place terrain\n+        \n+        return retVal;\n+    }\n+    \n+    /**\n+     * Generates an array list representing the number of objects to place in a given number of tracks.\n+     */\n+    private static List<Integer> trackObjectDistribution(int numObjects, int numTracks) {\n+        List<Integer> retVal = new ArrayList<>();\n+        int leftOver = numObjects % numTracks;\n+        \n+        for (int track = 0; track < numTracks; track++) {\n+            int trackObjects = numObjects / numTracks;\n+            \n+            // if we are unevenly distributed, add an extra one\n+            if(leftOver > 0) {\n+                trackObjects++;\n+                leftOver--;\n+            }\n+            \n+            retVal.add(trackObjects);\n+        }\n+        \n+        // don't always front-load extra objects\n+        Collections.shuffle(retVal);        \n+        return retVal;\n+    }\n+    \n+    /**\n+     * Worker function that takes a trackstate and plops down the given number of facilities owned by the given faction\n+     * Avoids places with existing facilities and scenarios, capable of taking facility sub set and setting strategic objective flag.\n+     */\n+    private static void initializeTrackFacilities(StratconTrackState trackState, int numFacilities, ForceAlignment owner, \n+            List<String> facilitySubset, boolean strategicObjective) {\n+        for (int fCount = 0; fCount < numFacilities; fCount++) {\n+            StratconFacility sf =\n+                    facilitySubset == null ? \n+                    StratconFacilityFactory.getRandomFacility() :\n+                    StratconFacilityFactory.getFacilityByName(facilitySubset.get(Compute.randomInt(facilitySubset.size())));\n+            sf.setOwner(owner);\n+            sf.setStrategicObjective(strategicObjective);\n+            \n+            int x = Compute.randomInt(trackState.getWidth());\n+            int y = Compute.randomInt(trackState.getHeight());\n+            StratconCoords coords = new StratconCoords(x, y);\n+            \n+            // make sure we don't put the facility down on top of anything else\n+            while ((trackState.getFacility(coords) != null) ||\n+                    (trackState.getScenario(coords) != null)) {\n+                x = Compute.randomInt(trackState.getWidth());\n+                y = Compute.randomInt(trackState.getHeight());\n+                coords = new StratconCoords(x, y);\n+            }\n+            \n+            trackState.addFacility(coords, sf);\n+            if (sf.getOwner() == ForceAlignment.Allied) {\n+                trackState.getRevealedCoords().add(coords);\n+                sf.setVisible(true);\n+            } else {\n+                sf.setVisible(false);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Worker function that takes a trackstate and plops down the given number of facilities owned by the given faction\n+     */\n+    private static void initializeObjectiveScenarios(Campaign campaign, AtBContract contract, StratconTrackState trackState, \n+            int numScenarios, List<String> objectiveScenarios, List<String> objectiveModifiers) {\n+        // pick scenario from subset\n+        // place it on the map somewhere nothing else has been placed yet\n+        // if it's a facility scenario, place the facility\n+        // run generateScenario() to apply all the necessary mods\n+        // apply objective mods (?)\n+        \n+        \n+        for (int sCount = 0; sCount < numScenarios; sCount++) {\n+            // pick\n+            ScenarioTemplate template = StratconScenarioFactory.getSpecificScenario(\n+                    objectiveScenarios.get(Compute.randomInt(objectiveScenarios.size())));\n+            \n+            // plonk\n+            int x = Compute.randomInt(trackState.getWidth());\n+            int y = Compute.randomInt(trackState.getHeight());\n+            StratconCoords coords = new StratconCoords(x, y);\n+            \n+            // make sure we don't put the facility down on top of anything else\n+            while ((trackState.getFacility(coords) != null) ||\n+                    (trackState.getScenario(coords) != null)) {", "originalCommit": "55af097696b44f689e0ff88123ab5f39b18bd8c0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNjI5NzI2MA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r606297260", "bodyText": "Indent Switch", "author": "Windchild292", "createdAt": "2021-04-02T15:50:35Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconContractInitializer.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ * Copyright (c) 2019 The Megamek Team. All rights reserved.\n+ *\n+ * This file is part of MekHQ.\n+ *\n+ * MekHQ is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * MekHQ is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with MekHQ.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import megamek.common.Compute;\n+import mekhq.MekHQ;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.Mission;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.stratcon.StratconContractDefinition.ObjectiveParameters;\n+\n+/**\n+ * This class handles StratCon state initialization when a contract is signed.\n+ */\n+public class StratconContractInitializer {\n+    public static final int NUM_LANCES_PER_TRACK = 3;\n+\n+    /**\n+     * Initializes the campaign state given a contract, campaign and contract definition\n+     */\n+    public static void initializeCampaignState(AtBContract contract, Campaign campaign, StratconContractDefinition contractDefinition) {\n+        StratconCampaignState campaignState = new StratconCampaignState(contract);\n+        campaignState.setBriefingText(contractDefinition.getBriefing() + \"<br/>\" + generateCommandLevelText(contract));\n+        campaignState.setStrategicObjectivesBehaveAsVPs(contractDefinition.objectivesBehaveAsVPs());\n+        \n+        // dependency: this is required here in order for scenario initialization to work properly\n+        contract.setStratconCampaignState(campaignState);\n+        \n+        // First, initialize the proper number of tracks. Then:\n+        // for each objective: \n+        //  step 1: calculate objective count\n+        //          if scaled, multiply # required lances by factor, round up, otherwise just fixed #\n+        //  step 2: evenly distribute objectives through tracks\n+        //          if uneven number remaining, distribute randomly \n+        //          when objective is specific scenario victory, place specially flagged scenarios\n+        //          when objective is allied/hostile facility, place those facilities\n+\n+        int numTracks = contract.getRequiredLances() / NUM_LANCES_PER_TRACK;\n+        \n+        for (int x = 0; x < numTracks; x++) {\n+            int scenarioOdds = contractDefinition.getScenarioOdds().get(Compute.randomInt(contractDefinition.getScenarioOdds().size()));\n+            int deploymentTime = contractDefinition.getDeploymentTimes().get(Compute.randomInt(contractDefinition.getDeploymentTimes().size()));\n+            \n+            StratconTrackState track = initializeTrackState(NUM_LANCES_PER_TRACK, scenarioOdds, deploymentTime);\n+            track.setDisplayableName(String.format(\"Track %d\", x));\n+            campaignState.addTrack(track);\n+        }\n+        \n+        // a campaign will have X tracks going at a time, where\n+        // X = # required lances / 3, rounded up. The last track will have fewer required lances.\n+        int oddLanceCount = contract.getRequiredLances() % NUM_LANCES_PER_TRACK;\n+        if (oddLanceCount > 0) {\n+            int scenarioOdds = contractDefinition.getScenarioOdds().get(Compute.randomInt(contractDefinition.getScenarioOdds().size()));\n+            int deploymentTime = contractDefinition.getDeploymentTimes().get(Compute.randomInt(contractDefinition.getDeploymentTimes().size()));\n+            \n+            StratconTrackState track = initializeTrackState(oddLanceCount, scenarioOdds, deploymentTime);\n+            track.setDisplayableName(String.format(\"Track %d\", campaignState.getTracks().size()));\n+            campaignState.addTrack(track);\n+        }\n+        \n+        // now seed the tracks with objectives and facilities\n+        for (ObjectiveParameters objectiveParams : contractDefinition.getObjectiveParameters()) {\n+            int objectiveCount = objectiveParams.objectiveCount > 0 ?\n+                    (int) objectiveParams.objectiveCount :\n+                    (int) (-objectiveParams.objectiveCount * contract.getRequiredLances());\n+                    \n+            campaignState.incrementPendingStrategicObjectiveCount(objectiveCount);\n+                    \n+            List<Integer> trackObjects = trackObjectDistribution(objectiveCount, campaignState.getTracks().size()); \n+                   \n+            for (int x = 0; x < trackObjects.size(); x++) {\n+                int numObjects = trackObjects.get(x);\n+                \n+                switch (objectiveParams.objectiveType) {\n+                    case SpecificScenarioVictory:\n+                        initializeObjectiveScenarios(campaign, contract, campaignState.getTrack(x), numObjects,\n+                                objectiveParams.objectiveScenarios, objectiveParams.objectiveScenarioModifiers);\n+                        break;\n+                    case AlliedFacilityControl:\n+                        initializeTrackFacilities(campaignState.getTrack(x), numObjects, ForceAlignment.Allied, null, true);\n+                        break;\n+                    case HostileFacilityControl:\n+                    case FacilityDestruction:\n+                        initializeTrackFacilities(campaignState.getTrack(x), numObjects, ForceAlignment.Opposing, null, true);\n+                        break;\n+                    case AnyScenarioVictory:\n+                        if (objectiveParams.objectiveScenarioModifiers != null) {\n+                            campaignState.getGlobalScenarioModifiers().addAll(objectiveParams.objectiveScenarioModifiers);\n+                        }\n+                    break;\n+                }\n+            }\n+        }\n+        \n+        // non-objective allied facilities\n+        int facilityCount = contractDefinition.getAlliedFacilityCount() > 0 ?\n+                (int) contractDefinition.getAlliedFacilityCount() :\n+                (int) (-contractDefinition.getAlliedFacilityCount() * contract.getRequiredLances());\n+                \n+        List<Integer> trackObjects = trackObjectDistribution(facilityCount, campaignState.getTracks().size()); \n+               \n+        for (int x = 0; x < trackObjects.size(); x++) {\n+            int numObjects = trackObjects.get(x);\n+            \n+            initializeTrackFacilities(campaignState.getTrack(x), numObjects, ForceAlignment.Allied, null, false);\n+        }\n+        \n+        // non-objective hostile facilities\n+        facilityCount = contractDefinition.getHostileFacilityCount() > 0 ?\n+                (int) contractDefinition.getHostileFacilityCount() :\n+                (int) (-contractDefinition.getHostileFacilityCount() * contract.getRequiredLances());\n+                \n+        trackObjects = trackObjectDistribution(facilityCount, campaignState.getTracks().size()); \n+               \n+        for (int x = 0; x < trackObjects.size(); x++) {\n+            int numObjects = trackObjects.get(x);\n+            \n+            initializeTrackFacilities(campaignState.getTrack(x), numObjects, ForceAlignment.Opposing, null, false);\n+        }\n+        \n+        // now we're done\n+    }\n+    \n+    /**\n+     * Set up initial state of a track, dimensions are based on number of assigned lances.\n+     */\n+    public static StratconTrackState initializeTrackState(int numLances, int scenarioOdds, int deploymentTime) {\n+        // to initialize a track, \n+        // 1. we set the # of required lances\n+        // 2. set the track size to a total of numlances * 28 hexes, a rectangle that is wider than it is taller\n+        //      the idea being to create a roughly rectangular playing field that,\n+        //      if one deploys a scout lance each week to a different spot, can be more or less fully covered\n+        \n+        StratconTrackState retVal = new StratconTrackState();\n+        retVal.setRequiredLanceCount(numLances);\n+        \n+        // set width and height\n+        int numHexes = numLances * 28;\n+        int height = (int) Math.floor(Math.sqrt(numHexes));\n+        int width = numHexes / height;\n+        retVal.setWidth(width);\n+        retVal.setHeight(height);\n+        \n+        retVal.setScenarioOdds(scenarioOdds);\n+        retVal.setDeploymentTime(deploymentTime);\n+        \n+        // todo: place terrain\n+        \n+        return retVal;\n+    }\n+    \n+    /**\n+     * Generates an array list representing the number of objects to place in a given number of tracks.\n+     */\n+    private static List<Integer> trackObjectDistribution(int numObjects, int numTracks) {\n+        List<Integer> retVal = new ArrayList<>();\n+        int leftOver = numObjects % numTracks;\n+        \n+        for (int track = 0; track < numTracks; track++) {\n+            int trackObjects = numObjects / numTracks;\n+            \n+            // if we are unevenly distributed, add an extra one\n+            if(leftOver > 0) {\n+                trackObjects++;\n+                leftOver--;\n+            }\n+            \n+            retVal.add(trackObjects);\n+        }\n+        \n+        // don't always front-load extra objects\n+        Collections.shuffle(retVal);        \n+        return retVal;\n+    }\n+    \n+    /**\n+     * Worker function that takes a trackstate and plops down the given number of facilities owned by the given faction\n+     * Avoids places with existing facilities and scenarios, capable of taking facility sub set and setting strategic objective flag.\n+     */\n+    private static void initializeTrackFacilities(StratconTrackState trackState, int numFacilities, ForceAlignment owner, \n+            List<String> facilitySubset, boolean strategicObjective) {\n+        for (int fCount = 0; fCount < numFacilities; fCount++) {\n+            StratconFacility sf =\n+                    facilitySubset == null ? \n+                    StratconFacilityFactory.getRandomFacility() :\n+                    StratconFacilityFactory.getFacilityByName(facilitySubset.get(Compute.randomInt(facilitySubset.size())));\n+            sf.setOwner(owner);\n+            sf.setStrategicObjective(strategicObjective);\n+            \n+            int x = Compute.randomInt(trackState.getWidth());\n+            int y = Compute.randomInt(trackState.getHeight());\n+            StratconCoords coords = new StratconCoords(x, y);\n+            \n+            // make sure we don't put the facility down on top of anything else\n+            while ((trackState.getFacility(coords) != null) ||\n+                    (trackState.getScenario(coords) != null)) {\n+                x = Compute.randomInt(trackState.getWidth());\n+                y = Compute.randomInt(trackState.getHeight());\n+                coords = new StratconCoords(x, y);\n+            }\n+            \n+            trackState.addFacility(coords, sf);\n+            if (sf.getOwner() == ForceAlignment.Allied) {\n+                trackState.getRevealedCoords().add(coords);\n+                sf.setVisible(true);\n+            } else {\n+                sf.setVisible(false);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Worker function that takes a trackstate and plops down the given number of facilities owned by the given faction\n+     */\n+    private static void initializeObjectiveScenarios(Campaign campaign, AtBContract contract, StratconTrackState trackState, \n+            int numScenarios, List<String> objectiveScenarios, List<String> objectiveModifiers) {\n+        // pick scenario from subset\n+        // place it on the map somewhere nothing else has been placed yet\n+        // if it's a facility scenario, place the facility\n+        // run generateScenario() to apply all the necessary mods\n+        // apply objective mods (?)\n+        \n+        \n+        for (int sCount = 0; sCount < numScenarios; sCount++) {\n+            // pick\n+            ScenarioTemplate template = StratconScenarioFactory.getSpecificScenario(\n+                    objectiveScenarios.get(Compute.randomInt(objectiveScenarios.size())));\n+            \n+            // plonk\n+            int x = Compute.randomInt(trackState.getWidth());\n+            int y = Compute.randomInt(trackState.getHeight());\n+            StratconCoords coords = new StratconCoords(x, y);\n+            \n+            // make sure we don't put the facility down on top of anything else\n+            while ((trackState.getFacility(coords) != null) ||\n+                    (trackState.getScenario(coords) != null)) {\n+                x = Compute.randomInt(trackState.getWidth());\n+                y = Compute.randomInt(trackState.getHeight());\n+                coords = new StratconCoords(x, y);\n+            }\n+            \n+            // facility\n+            if (template.isFacilityScenario()) {\n+                StratconFacility facility = template.isHostileFacility() ?\n+                        StratconFacilityFactory.getRandomHostileFacility() : StratconFacilityFactory.getRandomAlliedFacility();\n+                trackState.addFacility(coords, facility);\n+            }\n+            \n+            // create scenario - don't assign a force yet\n+            StratconScenario scenario = StratconRulesManager.generateScenario(campaign, contract, trackState, Force.FORCE_NONE, coords, template);\n+            \n+            // clear dates, because we don't want the scenario disappearing on us\n+            scenario.setDeploymentDate(null);\n+            scenario.setActionDate(null);\n+            scenario.setReturnDate(null);\n+            scenario.setStrategicObjective(true);\n+            \n+            // apply objective mods\n+            if (objectiveModifiers != null) {\n+                for (String modifier : objectiveModifiers) {\n+                    scenario.getBackingScenario().addScenarioModifier(AtBScenarioModifier.getScenarioModifier(modifier));\n+                }\n+            }\n+            \n+            trackState.addScenario(scenario);\n+        }\n+    }\n+    \n+    /**\n+     * Generates additional instructional text based on the contract command rights\n+     */\n+    private static String generateCommandLevelText(AtBContract contract) {\n+        switch (contract.getCommandRights()) {\n+        case AtBContract.COM_INTEGRATED:", "originalCommit": "55af097696b44f689e0ff88123ab5f39b18bd8c0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNjI5NzUyNQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r606297525", "bodyText": "brackets", "author": "Windchild292", "createdAt": "2021-04-02T15:51:08Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconContractInitializer.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ * Copyright (c) 2019 The Megamek Team. All rights reserved.\n+ *\n+ * This file is part of MekHQ.\n+ *\n+ * MekHQ is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * MekHQ is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with MekHQ.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import megamek.common.Compute;\n+import mekhq.MekHQ;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.Mission;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.stratcon.StratconContractDefinition.ObjectiveParameters;\n+\n+/**\n+ * This class handles StratCon state initialization when a contract is signed.\n+ */\n+public class StratconContractInitializer {\n+    public static final int NUM_LANCES_PER_TRACK = 3;\n+\n+    /**\n+     * Initializes the campaign state given a contract, campaign and contract definition\n+     */\n+    public static void initializeCampaignState(AtBContract contract, Campaign campaign, StratconContractDefinition contractDefinition) {\n+        StratconCampaignState campaignState = new StratconCampaignState(contract);\n+        campaignState.setBriefingText(contractDefinition.getBriefing() + \"<br/>\" + generateCommandLevelText(contract));\n+        campaignState.setStrategicObjectivesBehaveAsVPs(contractDefinition.objectivesBehaveAsVPs());\n+        \n+        // dependency: this is required here in order for scenario initialization to work properly\n+        contract.setStratconCampaignState(campaignState);\n+        \n+        // First, initialize the proper number of tracks. Then:\n+        // for each objective: \n+        //  step 1: calculate objective count\n+        //          if scaled, multiply # required lances by factor, round up, otherwise just fixed #\n+        //  step 2: evenly distribute objectives through tracks\n+        //          if uneven number remaining, distribute randomly \n+        //          when objective is specific scenario victory, place specially flagged scenarios\n+        //          when objective is allied/hostile facility, place those facilities\n+\n+        int numTracks = contract.getRequiredLances() / NUM_LANCES_PER_TRACK;\n+        \n+        for (int x = 0; x < numTracks; x++) {\n+            int scenarioOdds = contractDefinition.getScenarioOdds().get(Compute.randomInt(contractDefinition.getScenarioOdds().size()));\n+            int deploymentTime = contractDefinition.getDeploymentTimes().get(Compute.randomInt(contractDefinition.getDeploymentTimes().size()));\n+            \n+            StratconTrackState track = initializeTrackState(NUM_LANCES_PER_TRACK, scenarioOdds, deploymentTime);\n+            track.setDisplayableName(String.format(\"Track %d\", x));\n+            campaignState.addTrack(track);\n+        }\n+        \n+        // a campaign will have X tracks going at a time, where\n+        // X = # required lances / 3, rounded up. The last track will have fewer required lances.\n+        int oddLanceCount = contract.getRequiredLances() % NUM_LANCES_PER_TRACK;\n+        if (oddLanceCount > 0) {\n+            int scenarioOdds = contractDefinition.getScenarioOdds().get(Compute.randomInt(contractDefinition.getScenarioOdds().size()));\n+            int deploymentTime = contractDefinition.getDeploymentTimes().get(Compute.randomInt(contractDefinition.getDeploymentTimes().size()));\n+            \n+            StratconTrackState track = initializeTrackState(oddLanceCount, scenarioOdds, deploymentTime);\n+            track.setDisplayableName(String.format(\"Track %d\", campaignState.getTracks().size()));\n+            campaignState.addTrack(track);\n+        }\n+        \n+        // now seed the tracks with objectives and facilities\n+        for (ObjectiveParameters objectiveParams : contractDefinition.getObjectiveParameters()) {\n+            int objectiveCount = objectiveParams.objectiveCount > 0 ?\n+                    (int) objectiveParams.objectiveCount :\n+                    (int) (-objectiveParams.objectiveCount * contract.getRequiredLances());\n+                    \n+            campaignState.incrementPendingStrategicObjectiveCount(objectiveCount);\n+                    \n+            List<Integer> trackObjects = trackObjectDistribution(objectiveCount, campaignState.getTracks().size()); \n+                   \n+            for (int x = 0; x < trackObjects.size(); x++) {\n+                int numObjects = trackObjects.get(x);\n+                \n+                switch (objectiveParams.objectiveType) {\n+                    case SpecificScenarioVictory:\n+                        initializeObjectiveScenarios(campaign, contract, campaignState.getTrack(x), numObjects,\n+                                objectiveParams.objectiveScenarios, objectiveParams.objectiveScenarioModifiers);\n+                        break;\n+                    case AlliedFacilityControl:\n+                        initializeTrackFacilities(campaignState.getTrack(x), numObjects, ForceAlignment.Allied, null, true);\n+                        break;\n+                    case HostileFacilityControl:\n+                    case FacilityDestruction:\n+                        initializeTrackFacilities(campaignState.getTrack(x), numObjects, ForceAlignment.Opposing, null, true);\n+                        break;\n+                    case AnyScenarioVictory:\n+                        if (objectiveParams.objectiveScenarioModifiers != null) {\n+                            campaignState.getGlobalScenarioModifiers().addAll(objectiveParams.objectiveScenarioModifiers);\n+                        }\n+                    break;\n+                }\n+            }\n+        }\n+        \n+        // non-objective allied facilities\n+        int facilityCount = contractDefinition.getAlliedFacilityCount() > 0 ?\n+                (int) contractDefinition.getAlliedFacilityCount() :\n+                (int) (-contractDefinition.getAlliedFacilityCount() * contract.getRequiredLances());\n+                \n+        List<Integer> trackObjects = trackObjectDistribution(facilityCount, campaignState.getTracks().size()); \n+               \n+        for (int x = 0; x < trackObjects.size(); x++) {\n+            int numObjects = trackObjects.get(x);\n+            \n+            initializeTrackFacilities(campaignState.getTrack(x), numObjects, ForceAlignment.Allied, null, false);\n+        }\n+        \n+        // non-objective hostile facilities\n+        facilityCount = contractDefinition.getHostileFacilityCount() > 0 ?\n+                (int) contractDefinition.getHostileFacilityCount() :\n+                (int) (-contractDefinition.getHostileFacilityCount() * contract.getRequiredLances());\n+                \n+        trackObjects = trackObjectDistribution(facilityCount, campaignState.getTracks().size()); \n+               \n+        for (int x = 0; x < trackObjects.size(); x++) {\n+            int numObjects = trackObjects.get(x);\n+            \n+            initializeTrackFacilities(campaignState.getTrack(x), numObjects, ForceAlignment.Opposing, null, false);\n+        }\n+        \n+        // now we're done\n+    }\n+    \n+    /**\n+     * Set up initial state of a track, dimensions are based on number of assigned lances.\n+     */\n+    public static StratconTrackState initializeTrackState(int numLances, int scenarioOdds, int deploymentTime) {\n+        // to initialize a track, \n+        // 1. we set the # of required lances\n+        // 2. set the track size to a total of numlances * 28 hexes, a rectangle that is wider than it is taller\n+        //      the idea being to create a roughly rectangular playing field that,\n+        //      if one deploys a scout lance each week to a different spot, can be more or less fully covered\n+        \n+        StratconTrackState retVal = new StratconTrackState();\n+        retVal.setRequiredLanceCount(numLances);\n+        \n+        // set width and height\n+        int numHexes = numLances * 28;\n+        int height = (int) Math.floor(Math.sqrt(numHexes));\n+        int width = numHexes / height;\n+        retVal.setWidth(width);\n+        retVal.setHeight(height);\n+        \n+        retVal.setScenarioOdds(scenarioOdds);\n+        retVal.setDeploymentTime(deploymentTime);\n+        \n+        // todo: place terrain\n+        \n+        return retVal;\n+    }\n+    \n+    /**\n+     * Generates an array list representing the number of objects to place in a given number of tracks.\n+     */\n+    private static List<Integer> trackObjectDistribution(int numObjects, int numTracks) {\n+        List<Integer> retVal = new ArrayList<>();\n+        int leftOver = numObjects % numTracks;\n+        \n+        for (int track = 0; track < numTracks; track++) {\n+            int trackObjects = numObjects / numTracks;\n+            \n+            // if we are unevenly distributed, add an extra one\n+            if(leftOver > 0) {\n+                trackObjects++;\n+                leftOver--;\n+            }\n+            \n+            retVal.add(trackObjects);\n+        }\n+        \n+        // don't always front-load extra objects\n+        Collections.shuffle(retVal);        \n+        return retVal;\n+    }\n+    \n+    /**\n+     * Worker function that takes a trackstate and plops down the given number of facilities owned by the given faction\n+     * Avoids places with existing facilities and scenarios, capable of taking facility sub set and setting strategic objective flag.\n+     */\n+    private static void initializeTrackFacilities(StratconTrackState trackState, int numFacilities, ForceAlignment owner, \n+            List<String> facilitySubset, boolean strategicObjective) {\n+        for (int fCount = 0; fCount < numFacilities; fCount++) {\n+            StratconFacility sf =\n+                    facilitySubset == null ? \n+                    StratconFacilityFactory.getRandomFacility() :\n+                    StratconFacilityFactory.getFacilityByName(facilitySubset.get(Compute.randomInt(facilitySubset.size())));\n+            sf.setOwner(owner);\n+            sf.setStrategicObjective(strategicObjective);\n+            \n+            int x = Compute.randomInt(trackState.getWidth());\n+            int y = Compute.randomInt(trackState.getHeight());\n+            StratconCoords coords = new StratconCoords(x, y);\n+            \n+            // make sure we don't put the facility down on top of anything else\n+            while ((trackState.getFacility(coords) != null) ||\n+                    (trackState.getScenario(coords) != null)) {\n+                x = Compute.randomInt(trackState.getWidth());\n+                y = Compute.randomInt(trackState.getHeight());\n+                coords = new StratconCoords(x, y);\n+            }\n+            \n+            trackState.addFacility(coords, sf);\n+            if (sf.getOwner() == ForceAlignment.Allied) {\n+                trackState.getRevealedCoords().add(coords);\n+                sf.setVisible(true);\n+            } else {\n+                sf.setVisible(false);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Worker function that takes a trackstate and plops down the given number of facilities owned by the given faction\n+     */\n+    private static void initializeObjectiveScenarios(Campaign campaign, AtBContract contract, StratconTrackState trackState, \n+            int numScenarios, List<String> objectiveScenarios, List<String> objectiveModifiers) {\n+        // pick scenario from subset\n+        // place it on the map somewhere nothing else has been placed yet\n+        // if it's a facility scenario, place the facility\n+        // run generateScenario() to apply all the necessary mods\n+        // apply objective mods (?)\n+        \n+        \n+        for (int sCount = 0; sCount < numScenarios; sCount++) {\n+            // pick\n+            ScenarioTemplate template = StratconScenarioFactory.getSpecificScenario(\n+                    objectiveScenarios.get(Compute.randomInt(objectiveScenarios.size())));\n+            \n+            // plonk\n+            int x = Compute.randomInt(trackState.getWidth());\n+            int y = Compute.randomInt(trackState.getHeight());\n+            StratconCoords coords = new StratconCoords(x, y);\n+            \n+            // make sure we don't put the facility down on top of anything else\n+            while ((trackState.getFacility(coords) != null) ||\n+                    (trackState.getScenario(coords) != null)) {\n+                x = Compute.randomInt(trackState.getWidth());\n+                y = Compute.randomInt(trackState.getHeight());\n+                coords = new StratconCoords(x, y);\n+            }\n+            \n+            // facility\n+            if (template.isFacilityScenario()) {\n+                StratconFacility facility = template.isHostileFacility() ?\n+                        StratconFacilityFactory.getRandomHostileFacility() : StratconFacilityFactory.getRandomAlliedFacility();\n+                trackState.addFacility(coords, facility);\n+            }\n+            \n+            // create scenario - don't assign a force yet\n+            StratconScenario scenario = StratconRulesManager.generateScenario(campaign, contract, trackState, Force.FORCE_NONE, coords, template);\n+            \n+            // clear dates, because we don't want the scenario disappearing on us\n+            scenario.setDeploymentDate(null);\n+            scenario.setActionDate(null);\n+            scenario.setReturnDate(null);\n+            scenario.setStrategicObjective(true);\n+            \n+            // apply objective mods\n+            if (objectiveModifiers != null) {\n+                for (String modifier : objectiveModifiers) {\n+                    scenario.getBackingScenario().addScenarioModifier(AtBScenarioModifier.getScenarioModifier(modifier));\n+                }\n+            }\n+            \n+            trackState.addScenario(scenario);\n+        }\n+    }\n+    \n+    /**\n+     * Generates additional instructional text based on the contract command rights\n+     */\n+    private static String generateCommandLevelText(AtBContract contract) {\n+        switch (contract.getCommandRights()) {\n+        case AtBContract.COM_INTEGRATED:\n+            return \"Lance assignments will be made by the employer. \"\n+                    + \"Complete required scenarios to fulfill contract conditions.\"; \n+        case AtBContract.COM_HOUSE:\n+            return \"Complete required scenarios to fulfill contract conditions.\";\n+        case AtBContract.COM_LIAISON:\n+            return \"Complete required scenarios and strategic objectives to fulfill contract conditions.\";\n+        case AtBContract.COM_INDEP:\n+            return \"Complete strategic objectives to fulfill contract conditions.\";\n+        default:\n+            return \"\";\n+        }\n+    }\n+\n+    /**\n+     * Given a mission (that's an AtB contract), restore track state information,\n+     * such as pointers from StratCon scenario objects to AtB scenario objects.\n+     */\n+    public static void restoreTransientStratconInformation(Mission m, Campaign campaign) {\n+        if (m instanceof AtBContract) {\n+            // Having loaded scenarios and such, we now need to go through any StratCon scenarios for this contract\n+            // and set their backing scenario pointers to the existing scenarios stored in the campaign for this contract\n+            AtBContract atbContract = (AtBContract) m;\n+            if (atbContract.getStratconCampaignState() != null) {\n+                for (StratconTrackState track : atbContract.getStratconCampaignState().getTracks()) {\n+                    for (StratconScenario scenario : track.getScenarios().values()) {\n+                        Scenario campaignScenario = campaign.getScenario(scenario.getBackingScenarioID());\n+                        \n+                        if (campaignScenario != null && campaignScenario instanceof AtBDynamicScenario) {", "originalCommit": "55af097696b44f689e0ff88123ab5f39b18bd8c0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8c476d8674ecb033e44fd012837075474a9c6533", "url": "https://github.com/MegaMek/mekhq/commit/8c476d8674ecb033e44fd012837075474a9c6533", "message": "code review changes", "committedDate": "2021-04-03T01:15:32Z", "type": "commit"}, {"oid": "fbd59fb4db2c649d5e570c69e3716d28e9f8e4ac", "url": "https://github.com/MegaMek/mekhq/commit/fbd59fb4db2c649d5e570c69e3716d28e9f8e4ac", "message": "Update MekHQ/data/scenariotemplates/LegacyAtB/AceDuel.xml\n\nCo-authored-by: Justin Bowen <39067288+Windchild292@users.noreply.github.com>", "committedDate": "2021-04-03T01:19:26Z", "type": "commit"}, {"oid": "72a4646cbf3939751ba7f45a983a4bdeec92ff1c", "url": "https://github.com/MegaMek/mekhq/commit/72a4646cbf3939751ba7f45a983a4bdeec92ff1c", "message": "Update MekHQ/data/scenariomodifiers/AlliedMechReinforcements.xml\n\nCo-authored-by: Justin Bowen <39067288+Windchild292@users.noreply.github.com>", "committedDate": "2021-04-03T01:19:34Z", "type": "commit"}, {"oid": "c2d264c23786de4ea703861360c3bcb46e79c5ac", "url": "https://github.com/MegaMek/mekhq/commit/c2d264c23786de4ea703861360c3bcb46e79c5ac", "message": "merge from upstream", "committedDate": "2021-04-07T04:13:59Z", "type": "commit"}, {"oid": "08c5d5bff47cb9225633a27e34a4f793c642ffac", "url": "https://github.com/MegaMek/mekhq/commit/08c5d5bff47cb9225633a27e34a4f793c642ffac", "message": "merge from upstream", "committedDate": "2021-04-07T04:14:21Z", "type": "commit"}, {"oid": "94511019f9954ef45e6a02e9f7251d5530254781", "url": "https://github.com/MegaMek/mekhq/commit/94511019f9954ef45e6a02e9f7251d5530254781", "message": "missed folders in build script", "committedDate": "2021-04-09T01:05:31Z", "type": "commit"}, {"oid": "52905d6975e3cd97a4babfbb3b2093702769b837", "url": "https://github.com/MegaMek/mekhq/commit/52905d6975e3cd97a4babfbb3b2093702769b837", "message": "fix new day nag NPEs", "committedDate": "2021-04-09T02:47:05Z", "type": "commit"}, {"oid": "882838fc955802a3563d6ecf5636cb6780bbdc24", "url": "https://github.com/MegaMek/mekhq/commit/882838fc955802a3563d6ecf5636cb6780bbdc24", "message": "disable legacy scenario generation for stratcon contracts", "committedDate": "2021-04-09T02:52:36Z", "type": "commit"}, {"oid": "c29f3db9aff2d6e022ba899d50b4fd1082f3a2ab", "url": "https://github.com/MegaMek/mekhq/commit/c29f3db9aff2d6e022ba899d50b4fd1082f3a2ab", "message": "don't save color if we don't have one", "committedDate": "2021-04-13T00:58:12Z", "type": "commit"}, {"oid": "5cc994186952f3cae140b5579922cdd35b6c3dc1", "url": "https://github.com/MegaMek/mekhq/commit/5cc994186952f3cae140b5579922cdd35b6c3dc1", "message": "Merge branch 'master' of https://github.com/MegaMek/mekhq into legacy_atb_conversion", "committedDate": "2021-04-13T01:21:06Z", "type": "commit"}, {"oid": "aed743fbfb83156948808ac6e325d6b1cc2608a3", "url": "https://github.com/MegaMek/mekhq/commit/aed743fbfb83156948808ac6e325d6b1cc2608a3", "message": "deploy forces to currently selected track", "committedDate": "2021-04-13T01:43:33Z", "type": "commit"}, {"oid": "fde52dde21e6d6cc956e34fc3f2cbd477e99e461", "url": "https://github.com/MegaMek/mekhq/commit/fde52dde21e6d6cc956e34fc3f2cbd477e99e461", "message": "clean up phantom scenarios to prevent new day processing errors", "committedDate": "2021-04-13T01:59:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjA3ODg0Nw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r612078847", "bodyText": "Reopened #2503, as this is not a bugfix but rather an illegal statement. PlayerColour is by design non-nullable, and if it is null that will cause deeper issues.", "author": "Windchild292", "createdAt": "2021-04-13T02:11:32Z", "path": "MekHQ/src/mekhq/campaign/mission/BotForce.java", "diffHunk": "@@ -231,7 +231,11 @@ public void writeToXml(PrintWriter pw1, int indent) {\n         if (!getCamouflage().hasDefaultFilename()) {\n             MekHqXmlUtil.writeSimpleXmlTag(pw1, indent, \"camoFileName\", getCamouflage().getFilename());\n         }\n-        MekHqXmlUtil.writeSimpleXmlTag(pw1, indent, \"colour\", getColour().name());\n+        \n+        if (getColour() != null) {\n+                MekHqXmlUtil.writeSimpleXmlTag(pw1, indent, \"colour\", getColour().name());\n+        }", "originalCommit": "fde52dde21e6d6cc956e34fc3f2cbd477e99e461", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjA4NDU2Nw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r612084567", "bodyText": "Sure, and if you want to track down what causes the color to be set to null, you're welcome to. I'll make it write out some default color, but that's about the limit of my interest in this problem.", "author": "NickAragua", "createdAt": "2021-04-13T02:29:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjA3ODg0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjA4NzE4Nw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r612087187", "bodyText": "Given not a single report of this in stable, I consider this to be a bug in StratCon.", "author": "Windchild292", "createdAt": "2021-04-13T02:38:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjA3ODg0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjA5MTQyMg==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r612091422", "bodyText": "Fair enough, I've adjusted the no-parameters constructor, which is the only place where the color doesn't get initialized.", "author": "NickAragua", "createdAt": "2021-04-13T02:53:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjA3ODg0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjA3OTQyNw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r612079427", "bodyText": "Could ternary this return", "author": "Windchild292", "createdAt": "2021-04-13T02:13:35Z", "path": "MekHQ/src/mekhq/campaign/mission/atb/AtBScenarioModifier.java", "diffHunk": "@@ -157,23 +125,136 @@ public void processModifier(AtBDynamicScenario scenario, Campaign campaign, Even\n         return scenarioModifierKeys;\n     }\n     \n-    public static AtBScenarioModifier getRandomScenarioModifier() {\n-        int modIndex = Compute.randomInt(scenarioModifierKeys.size());\n-        return scenarioModifiers.get(scenarioModifierKeys.get(modIndex));\n-    }\n-    \n     /**\n      * Convenience method to get a scenario modifier with the specified key.\n      * @param key The key\n      * @return The scenario modifier, if any.\n      */\n     public static AtBScenarioModifier getScenarioModifier(String key) {\n-        return scenarioModifiers.get(key);\n+        if (!scenarioModifiers.containsKey(key)) {\n+            MekHQ.getLogger().error(\"Scenario modifier \" + key + \" does not exist.\");\n+            return null;\n+        }\n+        \n+        // clone it to avoid calling code changing the modifier\n+        return scenarioModifiers.get(key).clone();\n+    }\n+    \n+    /**\n+     * Convenience method to get all the 'required' hostile facility modifiers()\n+     */\n+    public static List<AtBScenarioModifier> getRequiredHostileFacilityModifiers() {\n+        List<AtBScenarioModifier> retval = new ArrayList<>();\n+        for (String key : requiredHostileFacilityModifierKeys) {\n+            retval.add(scenarioModifiers.get(key).clone());\n+        }\n+        \n+        return retval;\n+    }\n+    \n+    /**\n+     * Convenience method to get a random hostile facility modifier\n+     * @return The scenario modifier, if any.\n+     */\n+    public static AtBScenarioModifier getRandomHostileFacilityModifier() {\n+        return getScenarioModifier(Utilities.getRandomItem(hostileFacilityModifierKeys));\n+    }\n+    \n+    /**\n+     * Convenience method to get a random allied facility modifier\n+     * @return The scenario modifier, if any.\n+     */\n+    public static AtBScenarioModifier getRandomAlliedFacilityModifier() {\n+        return getScenarioModifier(Utilities.getRandomItem(alliedFacilityModifierKeys));\n+    }\n+    \n+    /**\n+     * Get a random modifier, appropriate for the map location (space, atmo, ground)\n+     */\n+    public static AtBScenarioModifier getRandomBattleModifier(MapLocation mapLocation) {\n+        return getRandomBattleModifier(mapLocation, null);\n+    }\n+    \n+    /**\n+     * Convenience method to get a random battle modifier\n+     * @return The scenario modifier, if any.\n+     */\n+    public static AtBScenarioModifier getRandomBattleModifier(MapLocation mapLocation, Boolean beneficial) {\n+        List<String> keyList = null;\n+        \n+        switch (mapLocation) {\n+            case Space:\n+            case LowAtmosphere:\n+                if (beneficial == null) {\n+                    keyList = airBattleModifierKeys;\n+                } else if (beneficial) {\n+                    keyList = positiveAirBattleModifierKeys;\n+                } else if (!beneficial) {\n+                    keyList = negativeAirBattleModifierKeys;\n+                }\n+                break;\n+            case AllGroundTerrain:\n+            case SpecificGroundTerrain:\n+            default:\n+                if (beneficial == null) {\n+                    keyList = groundBattleModifierKeys;\n+                } else if (beneficial) {\n+                    keyList = positiveGroundBattleModifierKeys;\n+                } else if (!beneficial) {\n+                    keyList = negativeGroundBattleModifierKeys;\n+                }\n+                break;\n+        }\n+        \n+        if (keyList == null) {\n+            return null;\n+        }\n+        \n+        return getScenarioModifier(Utilities.getRandomItem(keyList));", "originalCommit": "fde52dde21e6d6cc956e34fc3f2cbd477e99e461", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjA4NDgzOA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r612084838", "bodyText": "Don't really see why.", "author": "NickAragua", "createdAt": "2021-04-13T02:30:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjA3OTQyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjA3OTU4Mw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r612079583", "bodyText": "Brackets (latter statement)", "author": "Windchild292", "createdAt": "2021-04-13T02:14:08Z", "path": "MekHQ/src/mekhq/campaign/mission/atb/AtBScenarioModifier.java", "diffHunk": "@@ -271,16 +350,94 @@ public void Serialize(File outputFile) {\n             Marshaller m = context.createMarshaller();\n             m.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);\n             m.marshal(templateElement, outputFile);\n-        } catch(Exception e) {\n-            MekHQ.getLogger().error(AtBScenarioModifier.class, \"Serialize\", e.getMessage());\n+        } catch (Exception e) {\n+            MekHQ.getLogger().error(e);\n+        }\n+    }\n+    \n+    /**\n+     * Process this scenario modifier for a particular scenario, given a particular timing indicator.\n+     * @param eventTiming Whether this is occurring before or after primary forces have been generated.\n+     */\n+    public void processModifier(AtBDynamicScenario scenario, Campaign campaign, EventTiming eventTiming) {\n+        if (eventTiming == getEventTiming()) {\n+            if ((getAdditionalBriefingText() != null) && getAdditionalBriefingText().length() > 0) {", "originalCommit": "fde52dde21e6d6cc956e34fc3f2cbd477e99e461", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjA3OTc1NQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r612079755", "bodyText": "Also... can't this be isBlank?", "author": "Windchild292", "createdAt": "2021-04-13T02:14:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjA3OTU4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjA3OTgyNQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r612079825", "bodyText": "You can probably use !isEmpty", "author": "Windchild292", "createdAt": "2021-04-13T02:14:53Z", "path": "MekHQ/src/mekhq/campaign/mission/atb/AtBScenarioModifier.java", "diffHunk": "@@ -271,16 +350,94 @@ public void Serialize(File outputFile) {\n             Marshaller m = context.createMarshaller();\n             m.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);\n             m.marshal(templateElement, outputFile);\n-        } catch(Exception e) {\n-            MekHQ.getLogger().error(AtBScenarioModifier.class, \"Serialize\", e.getMessage());\n+        } catch (Exception e) {\n+            MekHQ.getLogger().error(e);\n+        }\n+    }\n+    \n+    /**\n+     * Process this scenario modifier for a particular scenario, given a particular timing indicator.\n+     * @param eventTiming Whether this is occurring before or after primary forces have been generated.\n+     */\n+    public void processModifier(AtBDynamicScenario scenario, Campaign campaign, EventTiming eventTiming) {\n+        if (eventTiming == getEventTiming()) {\n+            if ((getAdditionalBriefingText() != null) && getAdditionalBriefingText().length() > 0) {\n+                AtBScenarioModifierApplicator.appendScenarioBriefingText(scenario, \n+                        String.format(\"%s: %s\", getModifierName(), getAdditionalBriefingText()));\n+            }\n+            \n+            if (getForceDefinition() != null) {\n+                AtBScenarioModifierApplicator.addForce(campaign, scenario, getForceDefinition(), eventTiming);\n+            }\n+            \n+            if ((getSkillAdjustment() != null) && (getEventRecipient() != null)) {\n+                AtBScenarioModifierApplicator.adjustSkill(scenario, campaign, getEventRecipient(), getSkillAdjustment());\n+            }\n+            \n+            if ((getQualityAdjustment() != null) && (getEventRecipient() != null)) {\n+                AtBScenarioModifierApplicator.adjustQuality(scenario, campaign, getEventRecipient(), getQualityAdjustment());\n+            }\n+            \n+            if ((getBattleDamageIntensity() != null) && (getEventRecipient() != null)) {\n+                AtBScenarioModifierApplicator.inflictBattleDamage(scenario, campaign, getEventRecipient(), getBattleDamageIntensity());\n+            }\n+            \n+            if ((getAmmoExpenditureIntensity() != null) && (getEventRecipient() != null)) {\n+                AtBScenarioModifierApplicator.expendAmmo(scenario, campaign, getEventRecipient(), getAmmoExpenditureIntensity());\n+            }\n+            \n+            if ((getUnitRemovalCount() != null) && (getEventRecipient() != null)) {\n+                AtBScenarioModifierApplicator.removeUnits(scenario, campaign, getEventRecipient(), getUnitRemovalCount());\n+            }\n+            \n+            if ((getUseAmbushLogic() != null) && (getEventRecipient() != null)) {\n+                AtBScenarioModifierApplicator.setupAmbush(scenario, campaign, getEventRecipient());\n+            }\n+            \n+            if ((getSwitchSides() != null) && (getEventRecipient() != null)) {\n+                AtBScenarioModifierApplicator.switchSides(scenario, getEventRecipient());\n+            }\n+            \n+            if ((getObjectives() != null) && (getObjectives().size() > 0)) {", "originalCommit": "fde52dde21e6d6cc956e34fc3f2cbd477e99e461", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "975ff32d4d84bab31e4c1af4e9e62cb72886e9e7", "url": "https://github.com/MegaMek/mekhq/commit/975ff32d4d84bab31e4c1af4e9e62cb72886e9e7", "message": "sort lance lists by alphabetical order", "committedDate": "2021-04-13T02:23:03Z", "type": "commit"}, {"oid": "058ae23f7b599111087b9db1819657b61d65ebdf", "url": "https://github.com/MegaMek/mekhq/commit/058ae23f7b599111087b9db1819657b61d65ebdf", "message": "code review changes", "committedDate": "2021-04-13T02:29:25Z", "type": "commit"}, {"oid": "01bf8804cc209a9022e172aeb3a2b1ba95c30a83", "url": "https://github.com/MegaMek/mekhq/commit/01bf8804cc209a9022e172aeb3a2b1ba95c30a83", "message": "fix potential null color situation", "committedDate": "2021-04-13T02:52:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjEwNDc4OQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r612104789", "bodyText": "This can be removed and replaced with just the standard colour write", "author": "Windchild292", "createdAt": "2021-04-13T03:41:21Z", "path": "MekHQ/src/mekhq/campaign/mission/BotForce.java", "diffHunk": "@@ -231,7 +232,14 @@ public void writeToXml(PrintWriter pw1, int indent) {\n         if (!getCamouflage().hasDefaultFilename()) {\n             MekHqXmlUtil.writeSimpleXmlTag(pw1, indent, \"camoFileName\", getCamouflage().getFilename());\n         }\n-        MekHqXmlUtil.writeSimpleXmlTag(pw1, indent, \"colour\", getColour().name());\n+        \n+        // if we've got a legitimate color, great. Otherwise, write out something default\n+        if (getColour() != null) {\n+            MekHqXmlUtil.writeSimpleXmlTag(pw1, indent, \"colour\", getColour().name());\n+        } else {\n+            MekHqXmlUtil.writeSimpleXmlTag(pw1, indent, \"colour\", PlayerColour.FIRE_BRICK.name());\n+        }\n+        ", "originalCommit": "01bf8804cc209a9022e172aeb3a2b1ba95c30a83", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNDk5NzY1OQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r614997659", "bodyText": "Still valid, as colour should be back to a non-nullable state.", "author": "Windchild292", "createdAt": "2021-04-16T17:00:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjEwNDc4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTE4MjU4NA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r615182584", "bodyText": "I never really figured out where the original null came from, the parameterless constructor thing was just a guess, so I'm still a little paranoid about it and would prefer to keep the default. This way, if we see a camo turn to fire brick, we know there's another hole somewhere.", "author": "NickAragua", "createdAt": "2021-04-17T01:02:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjEwNDc4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTE4NjA0Mg==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r615186042", "bodyText": "In that case... can we add an error message with it? That way we can tell within a version or two if that was the cause or not.", "author": "Windchild292", "createdAt": "2021-04-17T01:28:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjEwNDc4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTE4NjEzOA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r615186138", "bodyText": "Will do.", "author": "NickAragua", "createdAt": "2021-04-17T01:29:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjEwNDc4OQ=="}], "type": "inlineReview"}, {"oid": "133e5865e2ee8dd5900b26dfe5f9aa0459a1a04c", "url": "https://github.com/MegaMek/mekhq/commit/133e5865e2ee8dd5900b26dfe5f9aa0459a1a04c", "message": "multiple bugs with ignoring scenarios; ground pirats on air maps", "committedDate": "2021-04-14T15:31:25Z", "type": "commit"}, {"oid": "0c8de948564008e0fe74bf50742dd3e72c55a601", "url": "https://github.com/MegaMek/mekhq/commit/0c8de948564008e0fe74bf50742dd3e72c55a601", "message": "calculate track odds granularly; fix scenario generation/saving under independent/liaison command", "committedDate": "2021-04-15T03:20:46Z", "type": "commit"}, {"oid": "ba7898afc777a1f9f405a590c5abc91eeaa8242a", "url": "https://github.com/MegaMek/mekhq/commit/ba7898afc777a1f9f405a590c5abc91eeaa8242a", "message": "update VP/SP in GUI when deploying reinforcements", "committedDate": "2021-04-15T03:35:02Z", "type": "commit"}, {"oid": "b08b95c4c7a346938b6266131a8b3dd0373f0f5b", "url": "https://github.com/MegaMek/mekhq/commit/b08b95c4c7a346938b6266131a8b3dd0373f0f5b", "message": "prevent transported infantry from throwing off reinforcement turn calculations", "committedDate": "2021-04-16T03:13:52Z", "type": "commit"}, {"oid": "e23eb599a907e75100b6b1f2fc149adfd3d7576d", "url": "https://github.com/MegaMek/mekhq/commit/e23eb599a907e75100b6b1f2fc149adfd3d7576d", "message": "faq", "committedDate": "2021-04-16T03:33:04Z", "type": "commit"}, {"oid": "ed3e5f5abe005b11fb49a199f3ee32ef849bfb8e", "url": "https://github.com/MegaMek/mekhq/commit/ed3e5f5abe005b11fb49a199f3ee32ef849bfb8e", "message": "prevent unlimited assignment of leadership auxiliaries", "committedDate": "2021-04-16T16:04:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNDk5Mjg0Mw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r614992843", "bodyText": "I should be using a NaturalOrderComparator to handle localized human order sort.", "author": "Windchild292", "createdAt": "2021-04-16T16:52:55Z", "path": "MekHQ/src/mekhq/gui/stratcon/ScenarioWizardLanceModel.java", "diffHunk": "@@ -26,12 +30,24 @@\n  * @author NickAragua\n  */\n public class ScenarioWizardLanceModel extends DefaultListModel<Force> {\n+    private static final long serialVersionUID = 5015606735749150646L;\n+\n     /**\n      * Constructor - sometimes, you have a list of force IDs.\n      */\n     public ScenarioWizardLanceModel(Campaign campaign, Collection<Integer> forceIDs) {\n+        List<Force> sortedForces = new ArrayList<>(); \n+        \n         for (int forceID : forceIDs) {\n-            super.addElement(campaign.getForce(forceID));\n+            sortedForces.add(campaign.getForce(forceID));    \n+        }\n+        \n+        // let's sort these guys by alphabetical order\n+        Collections.sort(sortedForces, \n+                (Comparator<Force>) (Force o1, Force o2) -> o1.getName().compareTo(o2.getName()) );", "originalCommit": "975ff32d4d84bab31e4c1af4e9e62cb72886e9e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTE4Mzc5MA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r615183790", "bodyText": "I'd agree, but the compared items are technically Force objects rather than strings, and I'd rather keep it as a Model so I can just retrieve the selected force rather than muck around with IDs.", "author": "NickAragua", "createdAt": "2021-04-17T01:11:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNDk5Mjg0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTE4OTY1NA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r615189654", "bodyText": "final NaturalOrderComparator noc = new NaturalOrderComparator();\n        sortedForces.sort((f1, f2) -> noc.compare(f1.getName(), f2.getName()));\n\nDoes the sort properly and uses the human order sort.\nHowever, I think a SortedComboBoxModel using the above force comparator would actually be the best implementation and future-proofs it so you can add more elements without needing to recreate.", "author": "Windchild292", "createdAt": "2021-04-17T01:43:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNDk5Mjg0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTE5MDYwMQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r615190601", "bodyText": "And... that also gives me an idea. I could add an override of DefaultComboBoxModel::getSelectedItem that returns null or E, instead of Object...", "author": "Windchild292", "createdAt": "2021-04-17T01:51:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNDk5Mjg0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNDk5NDE3Mw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r614994173", "bodyText": "No bulk addElements or addAll?", "author": "Windchild292", "createdAt": "2021-04-16T16:55:00Z", "path": "MekHQ/src/mekhq/gui/stratcon/ScenarioWizardLanceModel.java", "diffHunk": "@@ -26,12 +30,24 @@\n  * @author NickAragua\n  */\n public class ScenarioWizardLanceModel extends DefaultListModel<Force> {\n+    private static final long serialVersionUID = 5015606735749150646L;\n+\n     /**\n      * Constructor - sometimes, you have a list of force IDs.\n      */\n     public ScenarioWizardLanceModel(Campaign campaign, Collection<Integer> forceIDs) {\n+        List<Force> sortedForces = new ArrayList<>(); \n+        \n         for (int forceID : forceIDs) {\n-            super.addElement(campaign.getForce(forceID));\n+            sortedForces.add(campaign.getForce(forceID));    \n+        }\n+        \n+        // let's sort these guys by alphabetical order\n+        Collections.sort(sortedForces, \n+                (Comparator<Force>) (Force o1, Force o2) -> o1.getName().compareTo(o2.getName()) );\n+        \n+        for (Force force : sortedForces) {\n+            super.addElement(force); \n         }", "originalCommit": "975ff32d4d84bab31e4c1af4e9e62cb72886e9e7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNDk5NDgwMw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r614994803", "bodyText": "Overall... can't this just be a SortedComboBoxModel using a NaturalOrderComparator to sort the force names?", "author": "Windchild292", "createdAt": "2021-04-16T16:55:52Z", "path": "MekHQ/src/mekhq/gui/stratcon/ScenarioWizardLanceModel.java", "diffHunk": "@@ -26,12 +30,24 @@\n  * @author NickAragua\n  */\n public class ScenarioWizardLanceModel extends DefaultListModel<Force> {\n+    private static final long serialVersionUID = 5015606735749150646L;\n+\n     /**\n      * Constructor - sometimes, you have a list of force IDs.\n      */\n     public ScenarioWizardLanceModel(Campaign campaign, Collection<Integer> forceIDs) {", "originalCommit": "975ff32d4d84bab31e4c1af4e9e62cb72886e9e7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNDk5NzA5OQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r614997099", "bodyText": "Could be !isBlank", "author": "Windchild292", "createdAt": "2021-04-16T16:59:39Z", "path": "MekHQ/src/mekhq/campaign/mission/atb/AtBScenarioModifier.java", "diffHunk": "@@ -361,7 +361,7 @@ public void Serialize(File outputFile) {\n      */\n     public void processModifier(AtBDynamicScenario scenario, Campaign campaign, EventTiming eventTiming) {\n         if (eventTiming == getEventTiming()) {\n-            if ((getAdditionalBriefingText() != null) && getAdditionalBriefingText().length() > 0) {\n+            if ((getAdditionalBriefingText() != null) && (getAdditionalBriefingText().length() > 0)) {", "originalCommit": "058ae23f7b599111087b9db1819657b61d65ebdf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNDk5Nzg0OQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r614997849", "bodyText": "spacing", "author": "Windchild292", "createdAt": "2021-04-16T17:00:52Z", "path": "MekHQ/src/mekhq/campaign/Campaign.java", "diffHunk": "@@ -3025,12 +3026,19 @@ private void processNewDayATBScenarios() {\n                     continue;\n                 }\n                 if ((s.getDate() != null) && s.getDate().isBefore(getLocalDate())) {\n-                    s.setStatus(Scenario.S_DEFEAT);\n-                    s.clearAllForcesAndPersonnel(this);\n-                    contract.addPlayerMinorBreach();\n+                    if (getCampaignOptions().getUseStratCon() &&\n+                            s instanceof AtBDynamicScenario) {\n+                        StratconRulesManager.processIgnoredScenario(\n+                                (AtBDynamicScenario) s, contract.getStratconCampaignState());\n+                    } else {\n+                        s.setStatus(Scenario.S_DEFEAT);\n+                        s.clearAllForcesAndPersonnel(this);\n+                        contract.addPlayerMinorBreach();\n+                        s.generateStub(this);\n+                    }\n+                    \n                     addReport(\"Failure to deploy for \" + s.getName()\n-                            + \" resulted in defeat and a minor contract breach.\");\n-                    s.generateStub(this);\n+                    + \" resulted in defeat and a minor contract breach.\");", "originalCommit": "ed3e5f5abe005b11fb49a199f3ee32ef849bfb8e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNDk5NzkzMA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r614997930", "bodyText": "brackets", "author": "Windchild292", "createdAt": "2021-04-16T17:01:00Z", "path": "MekHQ/src/mekhq/campaign/Campaign.java", "diffHunk": "@@ -3025,12 +3026,19 @@ private void processNewDayATBScenarios() {\n                     continue;\n                 }\n                 if ((s.getDate() != null) && s.getDate().isBefore(getLocalDate())) {\n-                    s.setStatus(Scenario.S_DEFEAT);\n-                    s.clearAllForcesAndPersonnel(this);\n-                    contract.addPlayerMinorBreach();\n+                    if (getCampaignOptions().getUseStratCon() &&\n+                            s instanceof AtBDynamicScenario) {", "originalCommit": "ed3e5f5abe005b11fb49a199f3ee32ef849bfb8e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNDk5ODc2NQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r614998765", "bodyText": "!isEmpty", "author": "Windchild292", "createdAt": "2021-04-16T17:02:27Z", "path": "MekHQ/src/mekhq/campaign/mission/atb/AtBScenarioModifierApplicator.java", "diffHunk": "@@ -112,7 +117,11 @@ public static void removeUnits(AtBDynamicScenario scenario, Campaign campaign, F\n         for (int x = 0; x < actualUnitsToRemove; x++) {\n             int botForceIndex = Compute.randomInt(scenario.getNumBots());\n             BotForce bf = scenario.getBotForce(botForceIndex);\n-            if (bf.getTeam() == ScenarioForceTemplate.TEAM_IDS.get(eventRecipient.ordinal())) {\n+            \n+            // only remove units from a bot force if it's on the affected team\n+            // AND if it has any units to remove\n+            if ((bf.getTeam() == ScenarioForceTemplate.TEAM_IDS.get(eventRecipient.ordinal()))\n+                    && (bf.getEntityList().size() > 0)) {", "originalCommit": "ed3e5f5abe005b11fb49a199f3ee32ef849bfb8e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNDk5ODg2NA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r614998864", "bodyText": "!isEmpty", "author": "Windchild292", "createdAt": "2021-04-16T17:02:39Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -104,8 +105,10 @@ public static void generateScenariosForTrack(Campaign campaign, AtBContract cont\n         // once we've determined that scenarios occur, we loop through the ones that we generated\n         // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all\n         for (int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            int targetNum = calculateScenarioOdds(track, contract, false);\n+            \n             // if we haven't already used all the player forces and are required to randomly generate a scenario\n-            if ((availableForceIDs.size() > 0) && (Compute.randomInt(100) <= track.getScenarioOdds())) {\n+            if ((availableForceIDs.size() > 0) && (Compute.randomInt(100) <= targetNum)) {", "originalCommit": "ed3e5f5abe005b11fb49a199f3ee32ef849bfb8e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNDk5OTExOQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r614999119", "bodyText": "keeping contract for future use?", "author": "Windchild292", "createdAt": "2021-04-16T17:03:12Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -447,9 +451,6 @@ private static void assignAppropriateExtraForceToScenario(StratconScenario scena\n      *\n      */\n     public static void commitPrimaryForces(Campaign campaign, AtBContract contract, StratconScenario scenario, StratconTrackState trackState) {", "originalCommit": "ed3e5f5abe005b11fb49a199f3ee32ef849bfb8e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTE4MDU4MA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r615180580", "bodyText": "Even if I was, I can't imagine what it'd be at this point, so I'm going to remove it.", "author": "NickAragua", "createdAt": "2021-04-17T00:47:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNDk5OTExOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNDk5OTk4MA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r614999980", "bodyText": "Odd spacing here, should be tabbed", "author": "Windchild292", "createdAt": "2021-04-16T17:04:48Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconScenario.java", "diffHunk": "@@ -163,9 +164,12 @@ public String getInfo(boolean html) {\n         \n         stateBuilder.append(\"Scenario: \")\n             .append(backingScenario.getName())\n-            .append(html ? \"<br/>\" : \"\")\n-            .append(backingScenario.getTemplate().shortBriefing)\n             .append(html ? \"<br/>\" : \"\");\n+            \n+        if (backingScenario.getTemplate() != null) {\n+            stateBuilder.append(backingScenario.getTemplate().shortBriefing)\n+            .append(html ? \"<br/>\" : \"\");", "originalCommit": "ed3e5f5abe005b11fb49a199f3ee32ef849bfb8e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTAwMDQzNg==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r615000436", "bodyText": "Double brackets is unnecessary", "author": "Windchild292", "createdAt": "2021-04-16T17:05:38Z", "path": "MekHQ/src/mekhq/gui/CampaignGUI.java", "diffHunk": "@@ -2542,6 +2540,14 @@ public void handleDayEnding(DayEndingEvent ev) {\n             if (nagShortDeployments()) {\n                 ev.cancel();\n             }\n+            \n+            if (getCampaign().getCampaignOptions().getUseStratCon() &&\n+                    nagUnresolvedStratconContacts()) {\n+                {\n+                    ev.cancel();\n+                }            ", "originalCommit": "ed3e5f5abe005b11fb49a199f3ee32ef849bfb8e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTE4MDc3Nw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r615180777", "bodyText": "lol, that's some copypasta right there.", "author": "NickAragua", "createdAt": "2021-04-17T00:48:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTAwMDQzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTAwNzg0NQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r615007845", "bodyText": "No bulk addElements/addAll support?", "author": "Windchild292", "createdAt": "2021-04-16T17:18:31Z", "path": "MekHQ/src/mekhq/gui/stratcon/ScenarioWizardLanceModel.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.gui.stratcon;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+\n+import javax.swing.DefaultListModel;\n+\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.force.Force;\n+\n+/**\n+ * List data model for the StratCon scenario wizard.\n+ * @author NickAragua\n+ */\n+public class ScenarioWizardLanceModel extends DefaultListModel<Force> {\n+    private static final long serialVersionUID = 5015606735749150646L;\n+\n+    /**\n+     * Constructor - sometimes, you have a list of force IDs.\n+     */\n+    public ScenarioWizardLanceModel(Campaign campaign, Collection<Integer> forceIDs) {\n+        List<Force> sortedForces = new ArrayList<>(); \n+        \n+        for (int forceID : forceIDs) {\n+            sortedForces.add(campaign.getForce(forceID));    \n+        }\n+        \n+        // let's sort these guys by alphabetical order\n+        Collections.sort(sortedForces, \n+                (Comparator<Force>) (Force o1, Force o2) -> o1.getName().compareTo(o2.getName()) );\n+        \n+        for (Force force : sortedForces) {\n+            super.addElement(force); \n+        }", "originalCommit": "ed3e5f5abe005b11fb49a199f3ee32ef849bfb8e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTAxMDQ5Ng==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r615010496", "bodyText": "Can we move these to MekHqConstants too, so we have a single location with all filenames and paths (eventually speaking)", "author": "Windchild292", "createdAt": "2021-04-16T17:23:12Z", "path": "MekHQ/src/mekhq/campaign/mission/atb/AtBScenarioModifier.java", "diffHunk": "@@ -48,8 +49,22 @@\n import mekhq.campaign.mission.ScenarioObjective;\n \n @XmlRootElement(name=\"AtBScenarioModifier\")\n-public class AtBScenarioModifier {\n-\n+public class AtBScenarioModifier implements Cloneable {\n+\n+    public static final String SCENARIO_MODIFIER_ALLIED_GROUND_UNITS = \"PrimaryAlliesGround.xml\";\n+    public static final String SCENARIO_MODIFIER_ALLIED_AIR_UNITS = \"PrimaryAlliesAir.xml\";\n+    public static final String SCENARIO_MODIFIER_LIAISON_GROUND = \"LiaisonGround.xml\";\n+    public static final String SCENARIO_MODIFIER_HOUSE_CO_GROUND = \"HouseOfficerGround.xml\";\n+    public static final String SCENARIO_MODIFIER_INTEGRATED_UNITS_GROUND = \"IntegratedAlliesGround.xml\";\n+    public static final String SCENARIO_MODIFIER_LIAISON_AIR = \"LiaisonAir.xml\";\n+    public static final String SCENARIO_MODIFIER_HOUSE_CO_AIR = \"HouseOfficerAir.xml\";\n+    public static final String SCENARIO_MODIFIER_INTEGRATED_UNITS_AIR = \"IntegratedAlliesAir.xml\";\n+    public static final String SCENARIO_MODIFIER_TRAINEES_AIR = \"AlliedTraineesAir.xml\";\n+    public static final String SCENARIO_MODIFIER_TRAINEES_GROUND = \"AlliedTraineesGround.xml\";\n+    public static final String SCENARIO_MODIFIER_ALLIED_GROUND_SUPPORT = \"AlliedGroundSupportImmediate.xml\";\n+    public static final String SCENARIO_MODIFIER_ALLIED_AIR_SUPPORT = \"AlliedAirSupportImmediate.xml\";\n+    public static final String SCENARIO_MODIFIER_ALLIED_ARTY_SUPPORT = \"AlliedArtillerySupportImmediate.xml\";", "originalCommit": "ed3e5f5abe005b11fb49a199f3ee32ef849bfb8e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTAxMjMxMA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r615012310", "bodyText": "brackets on the instanceof", "author": "Windchild292", "createdAt": "2021-04-16T17:26:12Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconContractInitializer.java", "diffHunk": "@@ -0,0 +1,353 @@\n+/*\n+ * Copyright (c) 2019 The Megamek Team. All rights reserved.\n+ *\n+ * This file is part of MekHQ.\n+ *\n+ * MekHQ is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * MekHQ is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with MekHQ. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import megamek.common.Compute;\n+import mekhq.MekHQ;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.Mission;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.stratcon.StratconContractDefinition.ObjectiveParameters;\n+\n+/**\n+ * This class handles StratCon state initialization when a contract is signed.\n+ */\n+public class StratconContractInitializer {\n+    public static final int NUM_LANCES_PER_TRACK = 3;\n+\n+    /**\n+     * Initializes the campaign state given a contract, campaign and contract definition\n+     */\n+    public static void initializeCampaignState(AtBContract contract, Campaign campaign, StratconContractDefinition contractDefinition) {\n+        StratconCampaignState campaignState = new StratconCampaignState(contract);\n+        campaignState.setBriefingText(contractDefinition.getBriefing() + \"<br/>\" + generateCommandLevelText(contract));\n+        campaignState.setStrategicObjectivesBehaveAsVPs(contractDefinition.objectivesBehaveAsVPs());\n+        \n+        // dependency: this is required here in order for scenario initialization to work properly\n+        contract.setStratconCampaignState(campaignState);\n+        \n+        // First, initialize the proper number of tracks. Then:\n+        // for each objective: \n+        //  step 1: calculate objective count\n+        //          if scaled, multiply # required lances by factor, round up, otherwise just fixed #\n+        //  step 2: evenly distribute objectives through tracks\n+        //          if uneven number remaining, distribute randomly \n+        //          when objective is specific scenario victory, place specially flagged scenarios\n+        //          when objective is allied/hostile facility, place those facilities\n+\n+        int numTracks = contract.getRequiredLances() / NUM_LANCES_PER_TRACK;\n+        \n+        for (int x = 0; x < numTracks; x++) {\n+            int scenarioOdds = contractDefinition.getScenarioOdds().get(Compute.randomInt(contractDefinition.getScenarioOdds().size()));\n+            int deploymentTime = contractDefinition.getDeploymentTimes().get(Compute.randomInt(contractDefinition.getDeploymentTimes().size()));\n+            \n+            StratconTrackState track = initializeTrackState(NUM_LANCES_PER_TRACK, scenarioOdds, deploymentTime);\n+            track.setDisplayableName(String.format(\"Track %d\", x));\n+            campaignState.addTrack(track);\n+        }\n+        \n+        // a campaign will have X tracks going at a time, where\n+        // X = # required lances / 3, rounded up. The last track will have fewer required lances.\n+        int oddLanceCount = contract.getRequiredLances() % NUM_LANCES_PER_TRACK;\n+        if (oddLanceCount > 0) {\n+            int scenarioOdds = contractDefinition.getScenarioOdds().get(Compute.randomInt(contractDefinition.getScenarioOdds().size()));\n+            int deploymentTime = contractDefinition.getDeploymentTimes().get(Compute.randomInt(contractDefinition.getDeploymentTimes().size()));\n+            \n+            StratconTrackState track = initializeTrackState(oddLanceCount, scenarioOdds, deploymentTime);\n+            track.setDisplayableName(String.format(\"Track %d\", campaignState.getTracks().size()));\n+            campaignState.addTrack(track);\n+        }\n+        \n+        // now seed the tracks with objectives and facilities\n+        for (ObjectiveParameters objectiveParams : contractDefinition.getObjectiveParameters()) {\n+            int objectiveCount = objectiveParams.objectiveCount > 0 ?\n+                    (int) objectiveParams.objectiveCount :\n+                    (int) (-objectiveParams.objectiveCount * contract.getRequiredLances());\n+                    \n+            campaignState.incrementPendingStrategicObjectiveCount(objectiveCount);\n+                    \n+            List<Integer> trackObjects = trackObjectDistribution(objectiveCount, campaignState.getTracks().size()); \n+                   \n+            for (int x = 0; x < trackObjects.size(); x++) {\n+                int numObjects = trackObjects.get(x);\n+                \n+                switch (objectiveParams.objectiveType) {\n+                    case SpecificScenarioVictory:\n+                        initializeObjectiveScenarios(campaign, contract, campaignState.getTrack(x), numObjects,\n+                                objectiveParams.objectiveScenarios, objectiveParams.objectiveScenarioModifiers);\n+                        break;\n+                    case AlliedFacilityControl:\n+                        initializeTrackFacilities(campaignState.getTrack(x), numObjects, ForceAlignment.Allied, null, true);\n+                        break;\n+                    case HostileFacilityControl:\n+                    case FacilityDestruction:\n+                        initializeTrackFacilities(campaignState.getTrack(x), numObjects, ForceAlignment.Opposing, null, true);\n+                        break;\n+                    case AnyScenarioVictory:\n+                        if (objectiveParams.objectiveScenarioModifiers != null) {\n+                            campaignState.getGlobalScenarioModifiers().addAll(objectiveParams.objectiveScenarioModifiers);\n+                        }\n+                    break;\n+                }\n+            }\n+        }\n+        \n+        // non-objective allied facilities\n+        int facilityCount = contractDefinition.getAlliedFacilityCount() > 0 ?\n+                (int) contractDefinition.getAlliedFacilityCount() :\n+                (int) (-contractDefinition.getAlliedFacilityCount() * contract.getRequiredLances());\n+                \n+        List<Integer> trackObjects = trackObjectDistribution(facilityCount, campaignState.getTracks().size()); \n+               \n+        for (int x = 0; x < trackObjects.size(); x++) {\n+            int numObjects = trackObjects.get(x);\n+            \n+            initializeTrackFacilities(campaignState.getTrack(x), numObjects, ForceAlignment.Allied, null, false);\n+        }\n+        \n+        // non-objective hostile facilities\n+        facilityCount = contractDefinition.getHostileFacilityCount() > 0 ?\n+                (int) contractDefinition.getHostileFacilityCount() :\n+                (int) (-contractDefinition.getHostileFacilityCount() * contract.getRequiredLances());\n+                \n+        trackObjects = trackObjectDistribution(facilityCount, campaignState.getTracks().size()); \n+               \n+        for (int x = 0; x < trackObjects.size(); x++) {\n+            int numObjects = trackObjects.get(x);\n+            \n+            initializeTrackFacilities(campaignState.getTrack(x), numObjects, ForceAlignment.Opposing, null, false);\n+        }\n+        \n+        // now we're done\n+    }\n+    \n+    /**\n+     * Set up initial state of a track, dimensions are based on number of assigned lances.\n+     */\n+    public static StratconTrackState initializeTrackState(int numLances, int scenarioOdds, int deploymentTime) {\n+        // to initialize a track, \n+        // 1. we set the # of required lances\n+        // 2. set the track size to a total of numlances * 28 hexes, a rectangle that is wider than it is taller\n+        //      the idea being to create a roughly rectangular playing field that,\n+        //      if one deploys a scout lance each week to a different spot, can be more or less fully covered\n+        \n+        StratconTrackState retVal = new StratconTrackState();\n+        retVal.setRequiredLanceCount(numLances);\n+        \n+        // set width and height\n+        int numHexes = numLances * 28;\n+        int height = (int) Math.floor(Math.sqrt(numHexes));\n+        int width = numHexes / height;\n+        retVal.setWidth(width);\n+        retVal.setHeight(height);\n+        \n+        retVal.setScenarioOdds(scenarioOdds);\n+        retVal.setDeploymentTime(deploymentTime);\n+        \n+        // TODO: place terrain\n+        \n+        return retVal;\n+    }\n+    \n+    /**\n+     * Generates an array list representing the number of objects to place in a given number of tracks.\n+     */\n+    private static List<Integer> trackObjectDistribution(int numObjects, int numTracks) {\n+        List<Integer> retVal = new ArrayList<>();\n+        int leftOver = numObjects % numTracks;\n+        \n+        for (int track = 0; track < numTracks; track++) {\n+            int trackObjects = numObjects / numTracks;\n+            \n+            // if we are unevenly distributed, add an extra one\n+            if (leftOver > 0) {\n+                trackObjects++;\n+                leftOver--;\n+            }\n+            \n+            retVal.add(trackObjects);\n+        }\n+        \n+        // don't always front-load extra objects\n+        Collections.shuffle(retVal);        \n+        return retVal;\n+    }\n+    \n+    /**\n+     * Worker function that takes a trackstate and plops down the given number of facilities owned by the given faction\n+     * Avoids places with existing facilities and scenarios, capable of taking facility sub set and setting strategic objective flag.\n+     */\n+    private static void initializeTrackFacilities(StratconTrackState trackState, int numFacilities, ForceAlignment owner, \n+            List<String> facilitySubset, boolean strategicObjective) {\n+        \n+        int trackSize = trackState.getWidth() * trackState.getHeight();\n+        \n+        for (int fCount = 0; fCount < numFacilities; fCount++) {\n+            // if there's no possible empty places to put down a new scenario, then move on\n+            if ((trackState.getFacilities().size() + trackState.getScenarios().size()) >= trackSize) { \n+                break;\n+            }\n+            \n+            StratconFacility sf =\n+                    facilitySubset == null ? \n+                    StratconFacilityFactory.getRandomFacility() :\n+                    StratconFacilityFactory.getFacilityByName(facilitySubset.get(Compute.randomInt(facilitySubset.size())));\n+            sf.setOwner(owner);\n+            sf.setStrategicObjective(strategicObjective);\n+            \n+            StratconCoords coords = getUnoccupiedCoords(trackState);\n+            \n+            trackState.addFacility(coords, sf);\n+            if (sf.getOwner() == ForceAlignment.Allied) {\n+                trackState.getRevealedCoords().add(coords);\n+                sf.setVisible(true);\n+            } else {\n+                sf.setVisible(false);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Worker function that takes a trackstate and plops down the given number of facilities owned by the given faction\n+     */\n+    private static void initializeObjectiveScenarios(Campaign campaign, AtBContract contract, StratconTrackState trackState, \n+            int numScenarios, List<String> objectiveScenarios, List<String> objectiveModifiers) {\n+        // pick scenario from subset\n+        // place it on the map somewhere nothing else has been placed yet\n+        // if it's a facility scenario, place the facility\n+        // run generateScenario() to apply all the necessary mods\n+        // apply objective mods (?)\n+        \n+        int trackSize = trackState.getWidth() * trackState.getHeight();\n+        \n+        for (int sCount = 0; sCount < numScenarios; sCount++) {\n+            // if there's no possible empty places to put down a new scenario, then move on\n+            if ((trackState.getFacilities().size() + trackState.getScenarios().size()) >= trackSize) { \n+                break;\n+            }\n+            \n+            // pick\n+            ScenarioTemplate template = StratconScenarioFactory.getSpecificScenario(\n+                    objectiveScenarios.get(Compute.randomInt(objectiveScenarios.size())));\n+            \n+            StratconCoords coords = getUnoccupiedCoords(trackState);\n+            \n+            // facility\n+            if (template.isFacilityScenario()) {\n+                StratconFacility facility = template.isHostileFacility() ?\n+                        StratconFacilityFactory.getRandomHostileFacility() : StratconFacilityFactory.getRandomAlliedFacility();\n+                trackState.addFacility(coords, facility);\n+            }\n+            \n+            // create scenario - don't assign a force yet\n+            StratconScenario scenario = StratconRulesManager.generateScenario(campaign, contract, trackState, Force.FORCE_NONE, coords, template);\n+            \n+            // clear dates, because we don't want the scenario disappearing on us\n+            scenario.setDeploymentDate(null);\n+            scenario.setActionDate(null);\n+            scenario.setReturnDate(null);\n+            scenario.setStrategicObjective(true);\n+            \n+            // apply objective mods\n+            if (objectiveModifiers != null) {\n+                for (String modifier : objectiveModifiers) {\n+                    scenario.getBackingScenario().addScenarioModifier(AtBScenarioModifier.getScenarioModifier(modifier));\n+                }\n+            }\n+            \n+            trackState.addScenario(scenario);\n+        }\n+    }\n+    \n+    /**\n+     * Utility function that, given a track state, picks a random set of unoccupied coordinates.\n+     */\n+    private static StratconCoords getUnoccupiedCoords(StratconTrackState trackState) {\n+        // plonk\n+        int x = Compute.randomInt(trackState.getWidth());\n+        int y = Compute.randomInt(trackState.getHeight());\n+        StratconCoords coords = new StratconCoords(x, y);\n+        \n+        // make sure we don't put the facility down on top of anything else\n+        while ((trackState.getFacility(coords) != null) ||\n+                (trackState.getScenario(coords) != null)) {\n+            x = Compute.randomInt(trackState.getWidth());\n+            y = Compute.randomInt(trackState.getHeight());\n+            coords = new StratconCoords(x, y);\n+        }\n+        \n+        return coords;\n+    }\n+    \n+    /**\n+     * Generates additional instructional text based on the contract command rights\n+     */\n+    private static String generateCommandLevelText(AtBContract contract) {\n+        switch (contract.getCommandRights()) {\n+            case AtBContract.COM_INTEGRATED:\n+                return \"Lance assignments will be made by the employer. \"\n+                        + \"Complete required scenarios to fulfill contract conditions.\"; \n+            case AtBContract.COM_HOUSE:\n+                return \"Complete required scenarios to fulfill contract conditions.\";\n+            case AtBContract.COM_LIAISON:\n+                return \"Complete required scenarios and strategic objectives to fulfill contract conditions.\";\n+            case AtBContract.COM_INDEP:\n+                return \"Complete strategic objectives to fulfill contract conditions.\";\n+            default:\n+                return \"\";\n+        }\n+    }\n+\n+    /**\n+     * Given a mission (that's an AtB contract), restore track state information,\n+     * such as pointers from StratCon scenario objects to AtB scenario objects.\n+     */\n+    public static void restoreTransientStratconInformation(Mission m, Campaign campaign) {\n+        if (m instanceof AtBContract) {\n+            // Having loaded scenarios and such, we now need to go through any StratCon scenarios for this contract\n+            // and set their backing scenario pointers to the existing scenarios stored in the campaign for this contract\n+            AtBContract atbContract = (AtBContract) m;\n+            if (atbContract.getStratconCampaignState() != null) {\n+                for (StratconTrackState track : atbContract.getStratconCampaignState().getTracks()) {\n+                    for (StratconScenario scenario : track.getScenarios().values()) {\n+                        Scenario campaignScenario = campaign.getScenario(scenario.getBackingScenarioID());\n+                        \n+                        if ((campaignScenario != null) && campaignScenario instanceof AtBDynamicScenario) {", "originalCommit": "ed3e5f5abe005b11fb49a199f3ee32ef849bfb8e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTAxMjYzNA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r615012634", "bodyText": "As before, let's move these to MekHqConstants just to keep a single place with filenames.", "author": "Windchild292", "createdAt": "2021-04-16T17:26:47Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconScenarioFactory.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import megamek.common.UnitType;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.Utilities;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.atb.AtBScenarioManifest;\n+\n+/**\n+ * This class handles functionality related to loading and sorting scenario templates.\n+ * @author NickAragua\n+ */\n+public class StratconScenarioFactory {\n+    // loaded dynamic scenario templates, sorted by location (ground, low atmosphere, space)\n+    private static Map<MapLocation, List<ScenarioTemplate>> dynamicScenarioLocationMap = new HashMap<>();\n+    private static Map<Integer, List<ScenarioTemplate>> dynamicScenarioUnitTypeMap = new HashMap<>();\n+    private static Map<String, ScenarioTemplate> dynamicScenarioNameMap = new HashMap<>();\n+    private static String HOSTILE_FACILITY_SCENARIO = \"Hostile Facility.xml\";\n+    private static String ALLIED_FACILITY_SCENARIO = \"Allied Facility.xml\";\n+    ", "originalCommit": "ed3e5f5abe005b11fb49a199f3ee32ef849bfb8e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3d8916caadfbc4085e509724142f929fc9d7f1d5", "url": "https://github.com/MegaMek/mekhq/commit/3d8916caadfbc4085e509724142f929fc9d7f1d5", "message": "add text resources; remove campaign scenarios after ignoring in stratcon UI", "committedDate": "2021-04-16T21:31:08Z", "type": "commit"}, {"oid": "2e00ea9a5b972b07d7446e75a06d3d493ac69426", "url": "https://github.com/MegaMek/mekhq/commit/2e00ea9a5b972b07d7446e75a06d3d493ac69426", "message": "code review changes", "committedDate": "2021-04-17T01:14:35Z", "type": "commit"}, {"oid": "78b310e4b3013ae99ff33e56c1b3d6099f3751ed", "url": "https://github.com/MegaMek/mekhq/commit/78b310e4b3013ae99ff33e56c1b3d6099f3751ed", "message": "faq update", "committedDate": "2021-04-17T01:27:03Z", "type": "commit"}, {"oid": "c38a1f7ea57220c1c16c3ab516c53f61768b7c28", "url": "https://github.com/MegaMek/mekhq/commit/c38a1f7ea57220c1c16c3ab516c53f61768b7c28", "message": "missed isempty", "committedDate": "2021-04-17T01:29:09Z", "type": "commit"}, {"oid": "e5f7b6efc00b475401474e024c921bff06b25116", "url": "https://github.com/MegaMek/mekhq/commit/e5f7b6efc00b475401474e024c921bff06b25116", "message": "fire brick error", "committedDate": "2021-04-17T01:30:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTE4NjQ2NQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r615186465", "bodyText": "Missing the not here", "author": "Windchild292", "createdAt": "2021-04-17T01:32:29Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -108,7 +108,7 @@ public static void generateScenariosForTrack(Campaign campaign, AtBContract cont\n             int targetNum = calculateScenarioOdds(track, contract, false);\n             \n             // if we haven't already used all the player forces and are required to randomly generate a scenario\n-            if ((availableForceIDs.size() > 0) && (Compute.randomInt(100) <= targetNum)) {\n+            if (availableForceIDs.isEmpty() && (Compute.randomInt(100) <= targetNum)) {", "originalCommit": "c38a1f7ea57220c1c16c3ab516c53f61768b7c28", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b36d9fa6bf982c7b833b1ac0a0473d37f6e84760", "url": "https://github.com/MegaMek/mekhq/commit/b36d9fa6bf982c7b833b1ac0a0473d37f6e84760", "message": "whoops", "committedDate": "2021-04-17T01:33:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTE5MDc4Mw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r615190783", "bodyText": "Fix tab spacing in this file", "author": "Windchild292", "createdAt": "2021-04-17T01:53:57Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1404 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.UUID;\n+\n+import megamek.common.Compute;\n+import megamek.common.Minefield;\n+import megamek.common.UnitType;\n+import megamek.common.annotations.Nullable;\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.Utilities;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.ResolveScenarioTracker;\n+import mekhq.campaign.againstTheBot.enums.AtBLanceRole;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.event.StratconDeploymentEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.force.Lance;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier.EventTiming;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconFacility.FacilityType;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.unit.Unit;\n+\n+/**\n+ * This class contains \"rules\" logic for the AtB-Stratcon state\n+ * @author NickAragua\n+ */\n+public class StratconRulesManager {\n+    /**\n+     * What makes a particular lance eligible to be reinforcements for a scenario\n+     */\n+    public enum ReinforcementEligibilityType {\n+        /**\n+         * Nothing\n+         */\n+        None,\n+\n+        /**\n+         * Lance is already deployed to the track\n+         */\n+        ChainedScenario,\n+\n+        /**\n+         * We pay a support point or convert a victory point to a support point\n+         */\n+        SupportPoint,\n+\n+        /**\n+         * The lance's deployment orders are \"Fight\"\n+         */\n+        FightLance\n+    }\n+\n+    /**\n+     * This function potentially generates non-player-initiated scenarios for the given track.\n+     */\n+    public static void generateScenariosForTrack(Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // maps scenarios to force IDs\n+        List<StratconScenario> generatedScenarios = new ArrayList<>();\n+        boolean autoAssignLances = contract.getCommandRights() == AtBContract.COM_INTEGRATED;\n+\n+        // get this list just so we have it available\n+        List<Integer> availableForceIDs = getAvailableForceIDs(campaign);\n+        Map<MapLocation, List<Integer>> sortedAvailableForceIDs = sortForcesByMapType(availableForceIDs, campaign);\n+\n+        // make X rolls, where X is the number of required lances for the track\n+        // that's the chance to spawn a scenario.\n+        // if a scenario occurs, then we pick a random non-deployed lance and use it to drive the opfor generation later\n+        // once we've determined that scenarios occur, we loop through the ones that we generated\n+        // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all\n+        for (int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            int targetNum = calculateScenarioOdds(track, contract, false);\n+            \n+            // if we haven't already used all the player forces and are required to randomly generate a scenario\n+            if (!availableForceIDs.isEmpty() && (Compute.randomInt(100) <= targetNum)) {\n+                // pick random coordinates and force to drive the scenario\n+                int x = Compute.randomInt(track.getWidth());\n+                int y = Compute.randomInt(track.getHeight());\n+\n+                StratconCoords scenarioCoords = new StratconCoords(x, y);\n+\n+                // if forces are already assigned to these coordinates, use those instead\n+                // of randomly-selected ones\n+                if (track.getAssignedCoordForces().containsKey(scenarioCoords)) {\n+                    StratconScenario scenario = generateScenarioForExistingForces(scenarioCoords,\n+                            track.getAssignedCoordForces().get(scenarioCoords), \n+                            contract, campaign, track);\n+                    generatedScenarios.add(scenario);\n+                    continue;\n+                }\n+                \n+                // otherwise, pick a random force from the avail\n+                int randomForceIndex = Compute.randomInt(availableForceIDs.size());\n+                int randomForceID = availableForceIDs.get(randomForceIndex);\n+                \n+                // remove the force from the available lists so we don't designate it as primary twice\n+                availableForceIDs.remove(randomForceIndex);\n+\n+                // we want to remove the actual int with the value, not the value at the index\n+                sortedAvailableForceIDs.get(MapLocation.AllGroundTerrain).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.LowAtmosphere).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.Space).remove((Integer) randomForceID);\n+\n+                // two scenarios on the same coordinates wind up increasing in size\n+                if (track.getScenarios().containsKey(scenarioCoords)) {\n+                    track.getScenarios().get(scenarioCoords).incrementRequiredPlayerLances();\n+                    assignAppropriateExtraForceToScenario(track.getScenarios().get(scenarioCoords), sortedAvailableForceIDs);\n+                    continue;\n+                }\n+\n+                StratconScenario scenario = setupScenario(scenarioCoords, randomForceID, campaign, contract, track);\n+                generatedScenarios.add(scenario);\n+\n+                // if we're auto-assigning lances, deploy the force to the track as well\n+                if (autoAssignLances) {\n+                    processForceDeployment(scenarioCoords, randomForceID, campaign, track, false);\n+                }\n+            }\n+        }\n+\n+        // if under liaison command, pick a random scenario from the ones generated\n+        // to set as required and attach liaison\n+        if (contract.getCommandRights() == AtBContract.COM_LIAISON) {\n+        \tStratconScenario randomScenario = Utilities.getRandomItem(generatedScenarios);\n+        \trandomScenario.setRequiredScenario(true);\n+            setAttachedUnitsModifier(randomScenario, contract);", "originalCommit": "b36d9fa6bf982c7b833b1ac0a0473d37f6e84760", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTE5MDgyMQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r615190821", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if(!autoAssignLances && !scenario.ignoreForceAutoAssignment()) {\n          \n          \n            \n                        if (!autoAssignLances && !scenario.ignoreForceAutoAssignment()) {", "author": "Windchild292", "createdAt": "2021-04-17T01:54:13Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1404 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.UUID;\n+\n+import megamek.common.Compute;\n+import megamek.common.Minefield;\n+import megamek.common.UnitType;\n+import megamek.common.annotations.Nullable;\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.Utilities;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.ResolveScenarioTracker;\n+import mekhq.campaign.againstTheBot.enums.AtBLanceRole;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.event.StratconDeploymentEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.force.Lance;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier.EventTiming;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconFacility.FacilityType;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.unit.Unit;\n+\n+/**\n+ * This class contains \"rules\" logic for the AtB-Stratcon state\n+ * @author NickAragua\n+ */\n+public class StratconRulesManager {\n+    /**\n+     * What makes a particular lance eligible to be reinforcements for a scenario\n+     */\n+    public enum ReinforcementEligibilityType {\n+        /**\n+         * Nothing\n+         */\n+        None,\n+\n+        /**\n+         * Lance is already deployed to the track\n+         */\n+        ChainedScenario,\n+\n+        /**\n+         * We pay a support point or convert a victory point to a support point\n+         */\n+        SupportPoint,\n+\n+        /**\n+         * The lance's deployment orders are \"Fight\"\n+         */\n+        FightLance\n+    }\n+\n+    /**\n+     * This function potentially generates non-player-initiated scenarios for the given track.\n+     */\n+    public static void generateScenariosForTrack(Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // maps scenarios to force IDs\n+        List<StratconScenario> generatedScenarios = new ArrayList<>();\n+        boolean autoAssignLances = contract.getCommandRights() == AtBContract.COM_INTEGRATED;\n+\n+        // get this list just so we have it available\n+        List<Integer> availableForceIDs = getAvailableForceIDs(campaign);\n+        Map<MapLocation, List<Integer>> sortedAvailableForceIDs = sortForcesByMapType(availableForceIDs, campaign);\n+\n+        // make X rolls, where X is the number of required lances for the track\n+        // that's the chance to spawn a scenario.\n+        // if a scenario occurs, then we pick a random non-deployed lance and use it to drive the opfor generation later\n+        // once we've determined that scenarios occur, we loop through the ones that we generated\n+        // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all\n+        for (int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            int targetNum = calculateScenarioOdds(track, contract, false);\n+            \n+            // if we haven't already used all the player forces and are required to randomly generate a scenario\n+            if (!availableForceIDs.isEmpty() && (Compute.randomInt(100) <= targetNum)) {\n+                // pick random coordinates and force to drive the scenario\n+                int x = Compute.randomInt(track.getWidth());\n+                int y = Compute.randomInt(track.getHeight());\n+\n+                StratconCoords scenarioCoords = new StratconCoords(x, y);\n+\n+                // if forces are already assigned to these coordinates, use those instead\n+                // of randomly-selected ones\n+                if (track.getAssignedCoordForces().containsKey(scenarioCoords)) {\n+                    StratconScenario scenario = generateScenarioForExistingForces(scenarioCoords,\n+                            track.getAssignedCoordForces().get(scenarioCoords), \n+                            contract, campaign, track);\n+                    generatedScenarios.add(scenario);\n+                    continue;\n+                }\n+                \n+                // otherwise, pick a random force from the avail\n+                int randomForceIndex = Compute.randomInt(availableForceIDs.size());\n+                int randomForceID = availableForceIDs.get(randomForceIndex);\n+                \n+                // remove the force from the available lists so we don't designate it as primary twice\n+                availableForceIDs.remove(randomForceIndex);\n+\n+                // we want to remove the actual int with the value, not the value at the index\n+                sortedAvailableForceIDs.get(MapLocation.AllGroundTerrain).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.LowAtmosphere).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.Space).remove((Integer) randomForceID);\n+\n+                // two scenarios on the same coordinates wind up increasing in size\n+                if (track.getScenarios().containsKey(scenarioCoords)) {\n+                    track.getScenarios().get(scenarioCoords).incrementRequiredPlayerLances();\n+                    assignAppropriateExtraForceToScenario(track.getScenarios().get(scenarioCoords), sortedAvailableForceIDs);\n+                    continue;\n+                }\n+\n+                StratconScenario scenario = setupScenario(scenarioCoords, randomForceID, campaign, contract, track);\n+                generatedScenarios.add(scenario);\n+\n+                // if we're auto-assigning lances, deploy the force to the track as well\n+                if (autoAssignLances) {\n+                    processForceDeployment(scenarioCoords, randomForceID, campaign, track, false);\n+                }\n+            }\n+        }\n+\n+        // if under liaison command, pick a random scenario from the ones generated\n+        // to set as required and attach liaison\n+        if (contract.getCommandRights() == AtBContract.COM_LIAISON) {\n+        \tStratconScenario randomScenario = Utilities.getRandomItem(generatedScenarios);\n+        \trandomScenario.setRequiredScenario(true);\n+            setAttachedUnitsModifier(randomScenario, contract);\n+        }\n+\n+        // now, we loop through all the scenarios we set up\n+        // and generate the opfors / events / etc\n+        // if not auto-assigning lances, we then back out the lance assignments.\n+        for (StratconScenario scenario : generatedScenarios) {\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+\n+            if(!autoAssignLances && !scenario.ignoreForceAutoAssignment()) {", "originalCommit": "b36d9fa6bf982c7b833b1ac0a0473d37f6e84760", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTE5MDg0OQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r615190849", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if(!autoAssignLances && !scenario.ignoreForceAutoAssignment()) {\n          \n          \n            \n                            for(int forceID : scenario.getPlayerTemplateForceIDs()) {\n          \n          \n            \n                        if (!autoAssignLances && !scenario.ignoreForceAutoAssignment()) {\n          \n          \n            \n                            for (int forceID : scenario.getPlayerTemplateForceIDs()) {", "author": "Windchild292", "createdAt": "2021-04-17T01:54:30Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1404 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.UUID;\n+\n+import megamek.common.Compute;\n+import megamek.common.Minefield;\n+import megamek.common.UnitType;\n+import megamek.common.annotations.Nullable;\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.Utilities;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.ResolveScenarioTracker;\n+import mekhq.campaign.againstTheBot.enums.AtBLanceRole;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.event.StratconDeploymentEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.force.Lance;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier.EventTiming;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconFacility.FacilityType;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.unit.Unit;\n+\n+/**\n+ * This class contains \"rules\" logic for the AtB-Stratcon state\n+ * @author NickAragua\n+ */\n+public class StratconRulesManager {\n+    /**\n+     * What makes a particular lance eligible to be reinforcements for a scenario\n+     */\n+    public enum ReinforcementEligibilityType {\n+        /**\n+         * Nothing\n+         */\n+        None,\n+\n+        /**\n+         * Lance is already deployed to the track\n+         */\n+        ChainedScenario,\n+\n+        /**\n+         * We pay a support point or convert a victory point to a support point\n+         */\n+        SupportPoint,\n+\n+        /**\n+         * The lance's deployment orders are \"Fight\"\n+         */\n+        FightLance\n+    }\n+\n+    /**\n+     * This function potentially generates non-player-initiated scenarios for the given track.\n+     */\n+    public static void generateScenariosForTrack(Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // maps scenarios to force IDs\n+        List<StratconScenario> generatedScenarios = new ArrayList<>();\n+        boolean autoAssignLances = contract.getCommandRights() == AtBContract.COM_INTEGRATED;\n+\n+        // get this list just so we have it available\n+        List<Integer> availableForceIDs = getAvailableForceIDs(campaign);\n+        Map<MapLocation, List<Integer>> sortedAvailableForceIDs = sortForcesByMapType(availableForceIDs, campaign);\n+\n+        // make X rolls, where X is the number of required lances for the track\n+        // that's the chance to spawn a scenario.\n+        // if a scenario occurs, then we pick a random non-deployed lance and use it to drive the opfor generation later\n+        // once we've determined that scenarios occur, we loop through the ones that we generated\n+        // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all\n+        for (int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            int targetNum = calculateScenarioOdds(track, contract, false);\n+            \n+            // if we haven't already used all the player forces and are required to randomly generate a scenario\n+            if (!availableForceIDs.isEmpty() && (Compute.randomInt(100) <= targetNum)) {\n+                // pick random coordinates and force to drive the scenario\n+                int x = Compute.randomInt(track.getWidth());\n+                int y = Compute.randomInt(track.getHeight());\n+\n+                StratconCoords scenarioCoords = new StratconCoords(x, y);\n+\n+                // if forces are already assigned to these coordinates, use those instead\n+                // of randomly-selected ones\n+                if (track.getAssignedCoordForces().containsKey(scenarioCoords)) {\n+                    StratconScenario scenario = generateScenarioForExistingForces(scenarioCoords,\n+                            track.getAssignedCoordForces().get(scenarioCoords), \n+                            contract, campaign, track);\n+                    generatedScenarios.add(scenario);\n+                    continue;\n+                }\n+                \n+                // otherwise, pick a random force from the avail\n+                int randomForceIndex = Compute.randomInt(availableForceIDs.size());\n+                int randomForceID = availableForceIDs.get(randomForceIndex);\n+                \n+                // remove the force from the available lists so we don't designate it as primary twice\n+                availableForceIDs.remove(randomForceIndex);\n+\n+                // we want to remove the actual int with the value, not the value at the index\n+                sortedAvailableForceIDs.get(MapLocation.AllGroundTerrain).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.LowAtmosphere).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.Space).remove((Integer) randomForceID);\n+\n+                // two scenarios on the same coordinates wind up increasing in size\n+                if (track.getScenarios().containsKey(scenarioCoords)) {\n+                    track.getScenarios().get(scenarioCoords).incrementRequiredPlayerLances();\n+                    assignAppropriateExtraForceToScenario(track.getScenarios().get(scenarioCoords), sortedAvailableForceIDs);\n+                    continue;\n+                }\n+\n+                StratconScenario scenario = setupScenario(scenarioCoords, randomForceID, campaign, contract, track);\n+                generatedScenarios.add(scenario);\n+\n+                // if we're auto-assigning lances, deploy the force to the track as well\n+                if (autoAssignLances) {\n+                    processForceDeployment(scenarioCoords, randomForceID, campaign, track, false);\n+                }\n+            }\n+        }\n+\n+        // if under liaison command, pick a random scenario from the ones generated\n+        // to set as required and attach liaison\n+        if (contract.getCommandRights() == AtBContract.COM_LIAISON) {\n+        \tStratconScenario randomScenario = Utilities.getRandomItem(generatedScenarios);\n+        \trandomScenario.setRequiredScenario(true);\n+            setAttachedUnitsModifier(randomScenario, contract);\n+        }\n+\n+        // now, we loop through all the scenarios we set up\n+        // and generate the opfors / events / etc\n+        // if not auto-assigning lances, we then back out the lance assignments.\n+        for (StratconScenario scenario : generatedScenarios) {\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+\n+            if(!autoAssignLances && !scenario.ignoreForceAutoAssignment()) {\n+                for(int forceID : scenario.getPlayerTemplateForceIDs()) {", "originalCommit": "b36d9fa6bf982c7b833b1ac0a0473d37f6e84760", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTE5MDk5MQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r615190991", "bodyText": "Empty, not null. IIRC the for loop will break if it is null", "author": "Windchild292", "createdAt": "2021-04-17T01:55:51Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1404 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.UUID;\n+\n+import megamek.common.Compute;\n+import megamek.common.Minefield;\n+import megamek.common.UnitType;\n+import megamek.common.annotations.Nullable;\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.Utilities;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.ResolveScenarioTracker;\n+import mekhq.campaign.againstTheBot.enums.AtBLanceRole;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.event.StratconDeploymentEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.force.Lance;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier.EventTiming;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconFacility.FacilityType;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.unit.Unit;\n+\n+/**\n+ * This class contains \"rules\" logic for the AtB-Stratcon state\n+ * @author NickAragua\n+ */\n+public class StratconRulesManager {\n+    /**\n+     * What makes a particular lance eligible to be reinforcements for a scenario\n+     */\n+    public enum ReinforcementEligibilityType {\n+        /**\n+         * Nothing\n+         */\n+        None,\n+\n+        /**\n+         * Lance is already deployed to the track\n+         */\n+        ChainedScenario,\n+\n+        /**\n+         * We pay a support point or convert a victory point to a support point\n+         */\n+        SupportPoint,\n+\n+        /**\n+         * The lance's deployment orders are \"Fight\"\n+         */\n+        FightLance\n+    }\n+\n+    /**\n+     * This function potentially generates non-player-initiated scenarios for the given track.\n+     */\n+    public static void generateScenariosForTrack(Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // maps scenarios to force IDs\n+        List<StratconScenario> generatedScenarios = new ArrayList<>();\n+        boolean autoAssignLances = contract.getCommandRights() == AtBContract.COM_INTEGRATED;\n+\n+        // get this list just so we have it available\n+        List<Integer> availableForceIDs = getAvailableForceIDs(campaign);\n+        Map<MapLocation, List<Integer>> sortedAvailableForceIDs = sortForcesByMapType(availableForceIDs, campaign);\n+\n+        // make X rolls, where X is the number of required lances for the track\n+        // that's the chance to spawn a scenario.\n+        // if a scenario occurs, then we pick a random non-deployed lance and use it to drive the opfor generation later\n+        // once we've determined that scenarios occur, we loop through the ones that we generated\n+        // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all\n+        for (int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            int targetNum = calculateScenarioOdds(track, contract, false);\n+            \n+            // if we haven't already used all the player forces and are required to randomly generate a scenario\n+            if (!availableForceIDs.isEmpty() && (Compute.randomInt(100) <= targetNum)) {\n+                // pick random coordinates and force to drive the scenario\n+                int x = Compute.randomInt(track.getWidth());\n+                int y = Compute.randomInt(track.getHeight());\n+\n+                StratconCoords scenarioCoords = new StratconCoords(x, y);\n+\n+                // if forces are already assigned to these coordinates, use those instead\n+                // of randomly-selected ones\n+                if (track.getAssignedCoordForces().containsKey(scenarioCoords)) {\n+                    StratconScenario scenario = generateScenarioForExistingForces(scenarioCoords,\n+                            track.getAssignedCoordForces().get(scenarioCoords), \n+                            contract, campaign, track);\n+                    generatedScenarios.add(scenario);\n+                    continue;\n+                }\n+                \n+                // otherwise, pick a random force from the avail\n+                int randomForceIndex = Compute.randomInt(availableForceIDs.size());\n+                int randomForceID = availableForceIDs.get(randomForceIndex);\n+                \n+                // remove the force from the available lists so we don't designate it as primary twice\n+                availableForceIDs.remove(randomForceIndex);\n+\n+                // we want to remove the actual int with the value, not the value at the index\n+                sortedAvailableForceIDs.get(MapLocation.AllGroundTerrain).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.LowAtmosphere).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.Space).remove((Integer) randomForceID);\n+\n+                // two scenarios on the same coordinates wind up increasing in size\n+                if (track.getScenarios().containsKey(scenarioCoords)) {\n+                    track.getScenarios().get(scenarioCoords).incrementRequiredPlayerLances();\n+                    assignAppropriateExtraForceToScenario(track.getScenarios().get(scenarioCoords), sortedAvailableForceIDs);\n+                    continue;\n+                }\n+\n+                StratconScenario scenario = setupScenario(scenarioCoords, randomForceID, campaign, contract, track);\n+                generatedScenarios.add(scenario);\n+\n+                // if we're auto-assigning lances, deploy the force to the track as well\n+                if (autoAssignLances) {\n+                    processForceDeployment(scenarioCoords, randomForceID, campaign, track, false);\n+                }\n+            }\n+        }\n+\n+        // if under liaison command, pick a random scenario from the ones generated\n+        // to set as required and attach liaison\n+        if (contract.getCommandRights() == AtBContract.COM_LIAISON) {\n+        \tStratconScenario randomScenario = Utilities.getRandomItem(generatedScenarios);\n+        \trandomScenario.setRequiredScenario(true);\n+            setAttachedUnitsModifier(randomScenario, contract);\n+        }\n+\n+        // now, we loop through all the scenarios we set up\n+        // and generate the opfors / events / etc\n+        // if not auto-assigning lances, we then back out the lance assignments.\n+        for (StratconScenario scenario : generatedScenarios) {\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+\n+            if(!autoAssignLances && !scenario.ignoreForceAutoAssignment()) {\n+                for(int forceID : scenario.getPlayerTemplateForceIDs()) {\n+                    scenario.getBackingScenario().removeForce(forceID);\n+                }\n+\n+                scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                track.addScenario(scenario);\n+            } else {\n+                commitPrimaryForces(campaign, scenario, track);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Given a set of force IDs and coordinates, generate a scenario\n+     * Useful for when we want to generate scenarios \n+     * for forces already deployed to a track\n+     */\n+    public static StratconScenario generateScenarioForExistingForces(StratconCoords scenarioCoords, \n+            Set<Integer> forceIDs, AtBContract contract, Campaign campaign, StratconTrackState track) {\n+        boolean firstForce = true;\n+        StratconScenario scenario = null;\n+        \n+        for (int forceID : forceIDs) {\n+            if (firstForce) {\n+                scenario = setupScenario(scenarioCoords, forceID, campaign, contract, track);\n+                firstForce = false;\n+            } else {\n+                scenario.incrementRequiredPlayerLances();\n+                scenario.addPrimaryForce(forceID);\n+            }\n+        }\n+        \n+        // this is theoretically possible if forceIDs is passed in as null - not likely in practice", "originalCommit": "b36d9fa6bf982c7b833b1ac0a0473d37f6e84760", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTE5MTE0Mg==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r615191142", "bodyText": "Ternary candidate", "author": "Windchild292", "createdAt": "2021-04-17T01:57:25Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1404 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.UUID;\n+\n+import megamek.common.Compute;\n+import megamek.common.Minefield;\n+import megamek.common.UnitType;\n+import megamek.common.annotations.Nullable;\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.Utilities;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.ResolveScenarioTracker;\n+import mekhq.campaign.againstTheBot.enums.AtBLanceRole;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.event.StratconDeploymentEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.force.Lance;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier.EventTiming;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconFacility.FacilityType;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.unit.Unit;\n+\n+/**\n+ * This class contains \"rules\" logic for the AtB-Stratcon state\n+ * @author NickAragua\n+ */\n+public class StratconRulesManager {\n+    /**\n+     * What makes a particular lance eligible to be reinforcements for a scenario\n+     */\n+    public enum ReinforcementEligibilityType {\n+        /**\n+         * Nothing\n+         */\n+        None,\n+\n+        /**\n+         * Lance is already deployed to the track\n+         */\n+        ChainedScenario,\n+\n+        /**\n+         * We pay a support point or convert a victory point to a support point\n+         */\n+        SupportPoint,\n+\n+        /**\n+         * The lance's deployment orders are \"Fight\"\n+         */\n+        FightLance\n+    }\n+\n+    /**\n+     * This function potentially generates non-player-initiated scenarios for the given track.\n+     */\n+    public static void generateScenariosForTrack(Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // maps scenarios to force IDs\n+        List<StratconScenario> generatedScenarios = new ArrayList<>();\n+        boolean autoAssignLances = contract.getCommandRights() == AtBContract.COM_INTEGRATED;\n+\n+        // get this list just so we have it available\n+        List<Integer> availableForceIDs = getAvailableForceIDs(campaign);\n+        Map<MapLocation, List<Integer>> sortedAvailableForceIDs = sortForcesByMapType(availableForceIDs, campaign);\n+\n+        // make X rolls, where X is the number of required lances for the track\n+        // that's the chance to spawn a scenario.\n+        // if a scenario occurs, then we pick a random non-deployed lance and use it to drive the opfor generation later\n+        // once we've determined that scenarios occur, we loop through the ones that we generated\n+        // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all\n+        for (int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            int targetNum = calculateScenarioOdds(track, contract, false);\n+            \n+            // if we haven't already used all the player forces and are required to randomly generate a scenario\n+            if (!availableForceIDs.isEmpty() && (Compute.randomInt(100) <= targetNum)) {\n+                // pick random coordinates and force to drive the scenario\n+                int x = Compute.randomInt(track.getWidth());\n+                int y = Compute.randomInt(track.getHeight());\n+\n+                StratconCoords scenarioCoords = new StratconCoords(x, y);\n+\n+                // if forces are already assigned to these coordinates, use those instead\n+                // of randomly-selected ones\n+                if (track.getAssignedCoordForces().containsKey(scenarioCoords)) {\n+                    StratconScenario scenario = generateScenarioForExistingForces(scenarioCoords,\n+                            track.getAssignedCoordForces().get(scenarioCoords), \n+                            contract, campaign, track);\n+                    generatedScenarios.add(scenario);\n+                    continue;\n+                }\n+                \n+                // otherwise, pick a random force from the avail\n+                int randomForceIndex = Compute.randomInt(availableForceIDs.size());\n+                int randomForceID = availableForceIDs.get(randomForceIndex);\n+                \n+                // remove the force from the available lists so we don't designate it as primary twice\n+                availableForceIDs.remove(randomForceIndex);\n+\n+                // we want to remove the actual int with the value, not the value at the index\n+                sortedAvailableForceIDs.get(MapLocation.AllGroundTerrain).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.LowAtmosphere).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.Space).remove((Integer) randomForceID);\n+\n+                // two scenarios on the same coordinates wind up increasing in size\n+                if (track.getScenarios().containsKey(scenarioCoords)) {\n+                    track.getScenarios().get(scenarioCoords).incrementRequiredPlayerLances();\n+                    assignAppropriateExtraForceToScenario(track.getScenarios().get(scenarioCoords), sortedAvailableForceIDs);\n+                    continue;\n+                }\n+\n+                StratconScenario scenario = setupScenario(scenarioCoords, randomForceID, campaign, contract, track);\n+                generatedScenarios.add(scenario);\n+\n+                // if we're auto-assigning lances, deploy the force to the track as well\n+                if (autoAssignLances) {\n+                    processForceDeployment(scenarioCoords, randomForceID, campaign, track, false);\n+                }\n+            }\n+        }\n+\n+        // if under liaison command, pick a random scenario from the ones generated\n+        // to set as required and attach liaison\n+        if (contract.getCommandRights() == AtBContract.COM_LIAISON) {\n+        \tStratconScenario randomScenario = Utilities.getRandomItem(generatedScenarios);\n+        \trandomScenario.setRequiredScenario(true);\n+            setAttachedUnitsModifier(randomScenario, contract);\n+        }\n+\n+        // now, we loop through all the scenarios we set up\n+        // and generate the opfors / events / etc\n+        // if not auto-assigning lances, we then back out the lance assignments.\n+        for (StratconScenario scenario : generatedScenarios) {\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+\n+            if(!autoAssignLances && !scenario.ignoreForceAutoAssignment()) {\n+                for(int forceID : scenario.getPlayerTemplateForceIDs()) {\n+                    scenario.getBackingScenario().removeForce(forceID);\n+                }\n+\n+                scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                track.addScenario(scenario);\n+            } else {\n+                commitPrimaryForces(campaign, scenario, track);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Given a set of force IDs and coordinates, generate a scenario\n+     * Useful for when we want to generate scenarios \n+     * for forces already deployed to a track\n+     */\n+    public static StratconScenario generateScenarioForExistingForces(StratconCoords scenarioCoords, \n+            Set<Integer> forceIDs, AtBContract contract, Campaign campaign, StratconTrackState track) {\n+        boolean firstForce = true;\n+        StratconScenario scenario = null;\n+        \n+        for (int forceID : forceIDs) {\n+            if (firstForce) {\n+                scenario = setupScenario(scenarioCoords, forceID, campaign, contract, track);\n+                firstForce = false;\n+            } else {\n+                scenario.incrementRequiredPlayerLances();\n+                scenario.addPrimaryForce(forceID);\n+            }\n+        }\n+        \n+        // this is theoretically possible if forceIDs is passed in as null - not likely in practice\n+        // but might as well, to future-proof.\n+        if (scenario != null) {\n+            scenario.setIgnoreForceAutoAssignment(true);\n+        }\n+        \n+        return scenario;\n+    }\n+\n+    /**\n+     * Deploys a force to the given coordinates on the given track as a result of explicit player action.\n+     */\n+    public static void deployForceToCoords(StratconCoords coords, int forceID, \n+            Campaign campaign, AtBContract contract, StratconTrackState track, boolean sticky) {\n+        // the following things should happen:\n+        // 1. call to \"process force deployment\", which reveals fog of war in or around the coords, depending on force role\n+        // 2. if coords are a hostile facility, we get a facility mission\n+        // 3. if coords are empty, we *may* get a mission\n+\n+        processForceDeployment(coords, forceID, campaign, track, sticky);\n+\n+        // don't create a scenario on top of allied facilities\n+        StratconFacility facility = track.getFacility(coords);\n+        boolean isNonAlliedFacility = (facility != null) && (facility.getOwner() != ForceAlignment.Allied);\n+        int targetNum = calculateScenarioOdds(track, contract, true);\n+        boolean spawnScenario = (facility == null) && (Compute.randomInt(100) <= targetNum);\n+\n+        if (isNonAlliedFacility || spawnScenario) {\n+            StratconScenario scenario = setupScenario(coords, forceID, campaign, contract, track);\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            commitPrimaryForces(campaign, scenario, track);\n+        }\n+    }\n+\n+    /**\n+     * Logic to set up a scenario\n+     */\n+    private static StratconScenario setupScenario(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        StratconScenario scenario = null;\n+\n+        if (track.getFacilities().containsKey(coords)) {\n+            StratconFacility facility = track.getFacility(coords);\n+            boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+            ScenarioTemplate template = StratconScenarioFactory.getFacilityScenario(alliedFacility);\n+            scenario = generateScenario(campaign, contract, track, forceID, coords, template);\n+            setupFacilityScenario(scenario, facility);\n+        } else {\n+            scenario = generateScenario(campaign, contract, track, forceID, coords);\n+\n+            // we may generate a facility scenario randomly - if so, do the facility-related stuff\n+            // and add a new facility to the track\n+            if (scenario.getBackingScenario().getTemplate().isFacilityScenario()) {\n+                StratconFacility facility = scenario.getBackingScenario().getTemplate().isHostileFacility() ?\n+                        StratconFacilityFactory.getRandomHostileFacility() : StratconFacilityFactory.getRandomAlliedFacility();\n+                facility.setVisible(true);\n+                track.addFacility(coords, facility);\n+                setupFacilityScenario(scenario, facility);\n+            }\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * carries out tasks relevant to facility scenarios\n+     */\n+    private static void setupFacilityScenario(StratconScenario scenario, StratconFacility facility) {\n+        // this includes:\n+        // for hostile facilities\n+        // - add a destroy objective (always the option to level the facility)\n+        // - add a capture objective (always the option to capture the facility)\n+        // - if so indicated by parameter, roll a random hostile facility objective and add it if not capture/destroy\n+        // for allied facilities\n+        // - add a defend objective (always the option to defend the facility)\n+        // - if so indicated by parameter, roll a random allied facility objective and add it if not defend\n+        AtBScenarioModifier objectiveModifier = null;\n+        boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+\n+        if (alliedFacility) {\n+            objectiveModifier = AtBScenarioModifier.getRandomAlliedFacilityModifier();\n+        } else {\n+            objectiveModifier = AtBScenarioModifier.getRandomHostileFacilityModifier();\n+        }", "originalCommit": "b36d9fa6bf982c7b833b1ac0a0473d37f6e84760", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTE5MTIxMQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r615191211", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        for(AtBScenarioModifier modifier : AtBScenarioModifier.getRequiredHostileFacilityModifiers()) {\n          \n          \n            \n                            if(!scenario.getBackingScenario().alreadyHasModifier(modifier)) {\n          \n          \n            \n                        for (AtBScenarioModifier modifier : AtBScenarioModifier.getRequiredHostileFacilityModifiers()) {\n          \n          \n            \n                            if (!scenario.getBackingScenario().alreadyHasModifier(modifier)) {", "author": "Windchild292", "createdAt": "2021-04-17T01:57:40Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1404 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.UUID;\n+\n+import megamek.common.Compute;\n+import megamek.common.Minefield;\n+import megamek.common.UnitType;\n+import megamek.common.annotations.Nullable;\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.Utilities;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.ResolveScenarioTracker;\n+import mekhq.campaign.againstTheBot.enums.AtBLanceRole;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.event.StratconDeploymentEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.force.Lance;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier.EventTiming;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconFacility.FacilityType;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.unit.Unit;\n+\n+/**\n+ * This class contains \"rules\" logic for the AtB-Stratcon state\n+ * @author NickAragua\n+ */\n+public class StratconRulesManager {\n+    /**\n+     * What makes a particular lance eligible to be reinforcements for a scenario\n+     */\n+    public enum ReinforcementEligibilityType {\n+        /**\n+         * Nothing\n+         */\n+        None,\n+\n+        /**\n+         * Lance is already deployed to the track\n+         */\n+        ChainedScenario,\n+\n+        /**\n+         * We pay a support point or convert a victory point to a support point\n+         */\n+        SupportPoint,\n+\n+        /**\n+         * The lance's deployment orders are \"Fight\"\n+         */\n+        FightLance\n+    }\n+\n+    /**\n+     * This function potentially generates non-player-initiated scenarios for the given track.\n+     */\n+    public static void generateScenariosForTrack(Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // maps scenarios to force IDs\n+        List<StratconScenario> generatedScenarios = new ArrayList<>();\n+        boolean autoAssignLances = contract.getCommandRights() == AtBContract.COM_INTEGRATED;\n+\n+        // get this list just so we have it available\n+        List<Integer> availableForceIDs = getAvailableForceIDs(campaign);\n+        Map<MapLocation, List<Integer>> sortedAvailableForceIDs = sortForcesByMapType(availableForceIDs, campaign);\n+\n+        // make X rolls, where X is the number of required lances for the track\n+        // that's the chance to spawn a scenario.\n+        // if a scenario occurs, then we pick a random non-deployed lance and use it to drive the opfor generation later\n+        // once we've determined that scenarios occur, we loop through the ones that we generated\n+        // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all\n+        for (int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            int targetNum = calculateScenarioOdds(track, contract, false);\n+            \n+            // if we haven't already used all the player forces and are required to randomly generate a scenario\n+            if (!availableForceIDs.isEmpty() && (Compute.randomInt(100) <= targetNum)) {\n+                // pick random coordinates and force to drive the scenario\n+                int x = Compute.randomInt(track.getWidth());\n+                int y = Compute.randomInt(track.getHeight());\n+\n+                StratconCoords scenarioCoords = new StratconCoords(x, y);\n+\n+                // if forces are already assigned to these coordinates, use those instead\n+                // of randomly-selected ones\n+                if (track.getAssignedCoordForces().containsKey(scenarioCoords)) {\n+                    StratconScenario scenario = generateScenarioForExistingForces(scenarioCoords,\n+                            track.getAssignedCoordForces().get(scenarioCoords), \n+                            contract, campaign, track);\n+                    generatedScenarios.add(scenario);\n+                    continue;\n+                }\n+                \n+                // otherwise, pick a random force from the avail\n+                int randomForceIndex = Compute.randomInt(availableForceIDs.size());\n+                int randomForceID = availableForceIDs.get(randomForceIndex);\n+                \n+                // remove the force from the available lists so we don't designate it as primary twice\n+                availableForceIDs.remove(randomForceIndex);\n+\n+                // we want to remove the actual int with the value, not the value at the index\n+                sortedAvailableForceIDs.get(MapLocation.AllGroundTerrain).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.LowAtmosphere).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.Space).remove((Integer) randomForceID);\n+\n+                // two scenarios on the same coordinates wind up increasing in size\n+                if (track.getScenarios().containsKey(scenarioCoords)) {\n+                    track.getScenarios().get(scenarioCoords).incrementRequiredPlayerLances();\n+                    assignAppropriateExtraForceToScenario(track.getScenarios().get(scenarioCoords), sortedAvailableForceIDs);\n+                    continue;\n+                }\n+\n+                StratconScenario scenario = setupScenario(scenarioCoords, randomForceID, campaign, contract, track);\n+                generatedScenarios.add(scenario);\n+\n+                // if we're auto-assigning lances, deploy the force to the track as well\n+                if (autoAssignLances) {\n+                    processForceDeployment(scenarioCoords, randomForceID, campaign, track, false);\n+                }\n+            }\n+        }\n+\n+        // if under liaison command, pick a random scenario from the ones generated\n+        // to set as required and attach liaison\n+        if (contract.getCommandRights() == AtBContract.COM_LIAISON) {\n+        \tStratconScenario randomScenario = Utilities.getRandomItem(generatedScenarios);\n+        \trandomScenario.setRequiredScenario(true);\n+            setAttachedUnitsModifier(randomScenario, contract);\n+        }\n+\n+        // now, we loop through all the scenarios we set up\n+        // and generate the opfors / events / etc\n+        // if not auto-assigning lances, we then back out the lance assignments.\n+        for (StratconScenario scenario : generatedScenarios) {\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+\n+            if(!autoAssignLances && !scenario.ignoreForceAutoAssignment()) {\n+                for(int forceID : scenario.getPlayerTemplateForceIDs()) {\n+                    scenario.getBackingScenario().removeForce(forceID);\n+                }\n+\n+                scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                track.addScenario(scenario);\n+            } else {\n+                commitPrimaryForces(campaign, scenario, track);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Given a set of force IDs and coordinates, generate a scenario\n+     * Useful for when we want to generate scenarios \n+     * for forces already deployed to a track\n+     */\n+    public static StratconScenario generateScenarioForExistingForces(StratconCoords scenarioCoords, \n+            Set<Integer> forceIDs, AtBContract contract, Campaign campaign, StratconTrackState track) {\n+        boolean firstForce = true;\n+        StratconScenario scenario = null;\n+        \n+        for (int forceID : forceIDs) {\n+            if (firstForce) {\n+                scenario = setupScenario(scenarioCoords, forceID, campaign, contract, track);\n+                firstForce = false;\n+            } else {\n+                scenario.incrementRequiredPlayerLances();\n+                scenario.addPrimaryForce(forceID);\n+            }\n+        }\n+        \n+        // this is theoretically possible if forceIDs is passed in as null - not likely in practice\n+        // but might as well, to future-proof.\n+        if (scenario != null) {\n+            scenario.setIgnoreForceAutoAssignment(true);\n+        }\n+        \n+        return scenario;\n+    }\n+\n+    /**\n+     * Deploys a force to the given coordinates on the given track as a result of explicit player action.\n+     */\n+    public static void deployForceToCoords(StratconCoords coords, int forceID, \n+            Campaign campaign, AtBContract contract, StratconTrackState track, boolean sticky) {\n+        // the following things should happen:\n+        // 1. call to \"process force deployment\", which reveals fog of war in or around the coords, depending on force role\n+        // 2. if coords are a hostile facility, we get a facility mission\n+        // 3. if coords are empty, we *may* get a mission\n+\n+        processForceDeployment(coords, forceID, campaign, track, sticky);\n+\n+        // don't create a scenario on top of allied facilities\n+        StratconFacility facility = track.getFacility(coords);\n+        boolean isNonAlliedFacility = (facility != null) && (facility.getOwner() != ForceAlignment.Allied);\n+        int targetNum = calculateScenarioOdds(track, contract, true);\n+        boolean spawnScenario = (facility == null) && (Compute.randomInt(100) <= targetNum);\n+\n+        if (isNonAlliedFacility || spawnScenario) {\n+            StratconScenario scenario = setupScenario(coords, forceID, campaign, contract, track);\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            commitPrimaryForces(campaign, scenario, track);\n+        }\n+    }\n+\n+    /**\n+     * Logic to set up a scenario\n+     */\n+    private static StratconScenario setupScenario(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        StratconScenario scenario = null;\n+\n+        if (track.getFacilities().containsKey(coords)) {\n+            StratconFacility facility = track.getFacility(coords);\n+            boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+            ScenarioTemplate template = StratconScenarioFactory.getFacilityScenario(alliedFacility);\n+            scenario = generateScenario(campaign, contract, track, forceID, coords, template);\n+            setupFacilityScenario(scenario, facility);\n+        } else {\n+            scenario = generateScenario(campaign, contract, track, forceID, coords);\n+\n+            // we may generate a facility scenario randomly - if so, do the facility-related stuff\n+            // and add a new facility to the track\n+            if (scenario.getBackingScenario().getTemplate().isFacilityScenario()) {\n+                StratconFacility facility = scenario.getBackingScenario().getTemplate().isHostileFacility() ?\n+                        StratconFacilityFactory.getRandomHostileFacility() : StratconFacilityFactory.getRandomAlliedFacility();\n+                facility.setVisible(true);\n+                track.addFacility(coords, facility);\n+                setupFacilityScenario(scenario, facility);\n+            }\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * carries out tasks relevant to facility scenarios\n+     */\n+    private static void setupFacilityScenario(StratconScenario scenario, StratconFacility facility) {\n+        // this includes:\n+        // for hostile facilities\n+        // - add a destroy objective (always the option to level the facility)\n+        // - add a capture objective (always the option to capture the facility)\n+        // - if so indicated by parameter, roll a random hostile facility objective and add it if not capture/destroy\n+        // for allied facilities\n+        // - add a defend objective (always the option to defend the facility)\n+        // - if so indicated by parameter, roll a random allied facility objective and add it if not defend\n+        AtBScenarioModifier objectiveModifier = null;\n+        boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+\n+        if (alliedFacility) {\n+            objectiveModifier = AtBScenarioModifier.getRandomAlliedFacilityModifier();\n+        } else {\n+            objectiveModifier = AtBScenarioModifier.getRandomHostileFacilityModifier();\n+        }\n+\n+        if (objectiveModifier != null) {\n+            scenario.getBackingScenario().addScenarioModifier(objectiveModifier);\n+            scenario.getBackingScenario().setName(String.format(\"%s - %s - %s\",\n+                    facility.getFacilityType(), alliedFacility ? \"Allied\" : \"Hostile\", objectiveModifier.getModifierName()));\n+        }\n+\n+        // add the \"fixed\" hostile facility modifiers after the primary ones\n+        if (!alliedFacility) {\n+            for(AtBScenarioModifier modifier : AtBScenarioModifier.getRequiredHostileFacilityModifiers()) {\n+                if(!scenario.getBackingScenario().alreadyHasModifier(modifier)) {", "originalCommit": "b36d9fa6bf982c7b833b1ac0a0473d37f6e84760", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTE5MTI5MA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r615191290", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        for(int direction = 0; direction < 6; direction++) {\n          \n          \n            \n                        for (int direction = 0; direction < 6; direction++) {", "author": "Windchild292", "createdAt": "2021-04-17T01:58:34Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1404 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.UUID;\n+\n+import megamek.common.Compute;\n+import megamek.common.Minefield;\n+import megamek.common.UnitType;\n+import megamek.common.annotations.Nullable;\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.Utilities;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.ResolveScenarioTracker;\n+import mekhq.campaign.againstTheBot.enums.AtBLanceRole;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.event.StratconDeploymentEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.force.Lance;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier.EventTiming;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconFacility.FacilityType;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.unit.Unit;\n+\n+/**\n+ * This class contains \"rules\" logic for the AtB-Stratcon state\n+ * @author NickAragua\n+ */\n+public class StratconRulesManager {\n+    /**\n+     * What makes a particular lance eligible to be reinforcements for a scenario\n+     */\n+    public enum ReinforcementEligibilityType {\n+        /**\n+         * Nothing\n+         */\n+        None,\n+\n+        /**\n+         * Lance is already deployed to the track\n+         */\n+        ChainedScenario,\n+\n+        /**\n+         * We pay a support point or convert a victory point to a support point\n+         */\n+        SupportPoint,\n+\n+        /**\n+         * The lance's deployment orders are \"Fight\"\n+         */\n+        FightLance\n+    }\n+\n+    /**\n+     * This function potentially generates non-player-initiated scenarios for the given track.\n+     */\n+    public static void generateScenariosForTrack(Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // maps scenarios to force IDs\n+        List<StratconScenario> generatedScenarios = new ArrayList<>();\n+        boolean autoAssignLances = contract.getCommandRights() == AtBContract.COM_INTEGRATED;\n+\n+        // get this list just so we have it available\n+        List<Integer> availableForceIDs = getAvailableForceIDs(campaign);\n+        Map<MapLocation, List<Integer>> sortedAvailableForceIDs = sortForcesByMapType(availableForceIDs, campaign);\n+\n+        // make X rolls, where X is the number of required lances for the track\n+        // that's the chance to spawn a scenario.\n+        // if a scenario occurs, then we pick a random non-deployed lance and use it to drive the opfor generation later\n+        // once we've determined that scenarios occur, we loop through the ones that we generated\n+        // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all\n+        for (int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            int targetNum = calculateScenarioOdds(track, contract, false);\n+            \n+            // if we haven't already used all the player forces and are required to randomly generate a scenario\n+            if (!availableForceIDs.isEmpty() && (Compute.randomInt(100) <= targetNum)) {\n+                // pick random coordinates and force to drive the scenario\n+                int x = Compute.randomInt(track.getWidth());\n+                int y = Compute.randomInt(track.getHeight());\n+\n+                StratconCoords scenarioCoords = new StratconCoords(x, y);\n+\n+                // if forces are already assigned to these coordinates, use those instead\n+                // of randomly-selected ones\n+                if (track.getAssignedCoordForces().containsKey(scenarioCoords)) {\n+                    StratconScenario scenario = generateScenarioForExistingForces(scenarioCoords,\n+                            track.getAssignedCoordForces().get(scenarioCoords), \n+                            contract, campaign, track);\n+                    generatedScenarios.add(scenario);\n+                    continue;\n+                }\n+                \n+                // otherwise, pick a random force from the avail\n+                int randomForceIndex = Compute.randomInt(availableForceIDs.size());\n+                int randomForceID = availableForceIDs.get(randomForceIndex);\n+                \n+                // remove the force from the available lists so we don't designate it as primary twice\n+                availableForceIDs.remove(randomForceIndex);\n+\n+                // we want to remove the actual int with the value, not the value at the index\n+                sortedAvailableForceIDs.get(MapLocation.AllGroundTerrain).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.LowAtmosphere).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.Space).remove((Integer) randomForceID);\n+\n+                // two scenarios on the same coordinates wind up increasing in size\n+                if (track.getScenarios().containsKey(scenarioCoords)) {\n+                    track.getScenarios().get(scenarioCoords).incrementRequiredPlayerLances();\n+                    assignAppropriateExtraForceToScenario(track.getScenarios().get(scenarioCoords), sortedAvailableForceIDs);\n+                    continue;\n+                }\n+\n+                StratconScenario scenario = setupScenario(scenarioCoords, randomForceID, campaign, contract, track);\n+                generatedScenarios.add(scenario);\n+\n+                // if we're auto-assigning lances, deploy the force to the track as well\n+                if (autoAssignLances) {\n+                    processForceDeployment(scenarioCoords, randomForceID, campaign, track, false);\n+                }\n+            }\n+        }\n+\n+        // if under liaison command, pick a random scenario from the ones generated\n+        // to set as required and attach liaison\n+        if (contract.getCommandRights() == AtBContract.COM_LIAISON) {\n+        \tStratconScenario randomScenario = Utilities.getRandomItem(generatedScenarios);\n+        \trandomScenario.setRequiredScenario(true);\n+            setAttachedUnitsModifier(randomScenario, contract);\n+        }\n+\n+        // now, we loop through all the scenarios we set up\n+        // and generate the opfors / events / etc\n+        // if not auto-assigning lances, we then back out the lance assignments.\n+        for (StratconScenario scenario : generatedScenarios) {\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+\n+            if(!autoAssignLances && !scenario.ignoreForceAutoAssignment()) {\n+                for(int forceID : scenario.getPlayerTemplateForceIDs()) {\n+                    scenario.getBackingScenario().removeForce(forceID);\n+                }\n+\n+                scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                track.addScenario(scenario);\n+            } else {\n+                commitPrimaryForces(campaign, scenario, track);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Given a set of force IDs and coordinates, generate a scenario\n+     * Useful for when we want to generate scenarios \n+     * for forces already deployed to a track\n+     */\n+    public static StratconScenario generateScenarioForExistingForces(StratconCoords scenarioCoords, \n+            Set<Integer> forceIDs, AtBContract contract, Campaign campaign, StratconTrackState track) {\n+        boolean firstForce = true;\n+        StratconScenario scenario = null;\n+        \n+        for (int forceID : forceIDs) {\n+            if (firstForce) {\n+                scenario = setupScenario(scenarioCoords, forceID, campaign, contract, track);\n+                firstForce = false;\n+            } else {\n+                scenario.incrementRequiredPlayerLances();\n+                scenario.addPrimaryForce(forceID);\n+            }\n+        }\n+        \n+        // this is theoretically possible if forceIDs is passed in as null - not likely in practice\n+        // but might as well, to future-proof.\n+        if (scenario != null) {\n+            scenario.setIgnoreForceAutoAssignment(true);\n+        }\n+        \n+        return scenario;\n+    }\n+\n+    /**\n+     * Deploys a force to the given coordinates on the given track as a result of explicit player action.\n+     */\n+    public static void deployForceToCoords(StratconCoords coords, int forceID, \n+            Campaign campaign, AtBContract contract, StratconTrackState track, boolean sticky) {\n+        // the following things should happen:\n+        // 1. call to \"process force deployment\", which reveals fog of war in or around the coords, depending on force role\n+        // 2. if coords are a hostile facility, we get a facility mission\n+        // 3. if coords are empty, we *may* get a mission\n+\n+        processForceDeployment(coords, forceID, campaign, track, sticky);\n+\n+        // don't create a scenario on top of allied facilities\n+        StratconFacility facility = track.getFacility(coords);\n+        boolean isNonAlliedFacility = (facility != null) && (facility.getOwner() != ForceAlignment.Allied);\n+        int targetNum = calculateScenarioOdds(track, contract, true);\n+        boolean spawnScenario = (facility == null) && (Compute.randomInt(100) <= targetNum);\n+\n+        if (isNonAlliedFacility || spawnScenario) {\n+            StratconScenario scenario = setupScenario(coords, forceID, campaign, contract, track);\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            commitPrimaryForces(campaign, scenario, track);\n+        }\n+    }\n+\n+    /**\n+     * Logic to set up a scenario\n+     */\n+    private static StratconScenario setupScenario(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        StratconScenario scenario = null;\n+\n+        if (track.getFacilities().containsKey(coords)) {\n+            StratconFacility facility = track.getFacility(coords);\n+            boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+            ScenarioTemplate template = StratconScenarioFactory.getFacilityScenario(alliedFacility);\n+            scenario = generateScenario(campaign, contract, track, forceID, coords, template);\n+            setupFacilityScenario(scenario, facility);\n+        } else {\n+            scenario = generateScenario(campaign, contract, track, forceID, coords);\n+\n+            // we may generate a facility scenario randomly - if so, do the facility-related stuff\n+            // and add a new facility to the track\n+            if (scenario.getBackingScenario().getTemplate().isFacilityScenario()) {\n+                StratconFacility facility = scenario.getBackingScenario().getTemplate().isHostileFacility() ?\n+                        StratconFacilityFactory.getRandomHostileFacility() : StratconFacilityFactory.getRandomAlliedFacility();\n+                facility.setVisible(true);\n+                track.addFacility(coords, facility);\n+                setupFacilityScenario(scenario, facility);\n+            }\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * carries out tasks relevant to facility scenarios\n+     */\n+    private static void setupFacilityScenario(StratconScenario scenario, StratconFacility facility) {\n+        // this includes:\n+        // for hostile facilities\n+        // - add a destroy objective (always the option to level the facility)\n+        // - add a capture objective (always the option to capture the facility)\n+        // - if so indicated by parameter, roll a random hostile facility objective and add it if not capture/destroy\n+        // for allied facilities\n+        // - add a defend objective (always the option to defend the facility)\n+        // - if so indicated by parameter, roll a random allied facility objective and add it if not defend\n+        AtBScenarioModifier objectiveModifier = null;\n+        boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+\n+        if (alliedFacility) {\n+            objectiveModifier = AtBScenarioModifier.getRandomAlliedFacilityModifier();\n+        } else {\n+            objectiveModifier = AtBScenarioModifier.getRandomHostileFacilityModifier();\n+        }\n+\n+        if (objectiveModifier != null) {\n+            scenario.getBackingScenario().addScenarioModifier(objectiveModifier);\n+            scenario.getBackingScenario().setName(String.format(\"%s - %s - %s\",\n+                    facility.getFacilityType(), alliedFacility ? \"Allied\" : \"Hostile\", objectiveModifier.getModifierName()));\n+        }\n+\n+        // add the \"fixed\" hostile facility modifiers after the primary ones\n+        if (!alliedFacility) {\n+            for(AtBScenarioModifier modifier : AtBScenarioModifier.getRequiredHostileFacilityModifiers()) {\n+                if(!scenario.getBackingScenario().alreadyHasModifier(modifier)) {\n+                    scenario.getBackingScenario().addScenarioModifier(modifier);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void processFacilityEffects(StratconTrackState track) {\n+        // TODO: these are \"weekly\"? effects that a stratcon facility has on the campaign/track state\n+        // currrently, that's\n+        // supply depot - allied - +1 sp\n+        // supply depot - hostile - +5% BV budget to all scenarios on track (shared modifier, so should be implemented there)\n+        // data center - allied - +1% star league cache contract (don't implement yet, but...)\n+        // data center - hostile - +5% scenario odds in track\n+        // industrial center - allied - all scenarios here have THIS IS COMING OUT OF YOUR PAYCHECK modifier\n+        // orbital defense - allied - sets 'no hostile aircraft' flag for track\n+        // orbital defense - hostile - sets 'no allied aircraft' flag for track\n+        // early warning system - allied - sets 'intercept allied base attacks' flag for track\n+        // early warning system - hostile - sets 'intercept hostile base attacks' flag for track\n+    }\n+\n+    /**\n+     * Process the deployment of a force to the given coordinates on the given track.\n+     */\n+    public static void processForceDeployment(StratconCoords coords, int forceID, \n+            Campaign campaign, StratconTrackState track, boolean sticky) {\n+        track.getRevealedCoords().add(coords);\n+        StratconFacility facility = track.getFacility(coords);\n+        if (facility != null) {\n+            facility.setVisible(true);\n+        }\n+\n+        if (campaign.getLances().get(forceID).getRole() == AtBLanceRole.SCOUTING) {\n+            for(int direction = 0; direction < 6; direction++) {", "originalCommit": "b36d9fa6bf982c7b833b1ac0a0473d37f6e84760", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTE5MTMwOA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r615191308", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if(facility != null) {\n          \n          \n            \n                            if (facility != null) {", "author": "Windchild292", "createdAt": "2021-04-17T01:58:41Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1404 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.UUID;\n+\n+import megamek.common.Compute;\n+import megamek.common.Minefield;\n+import megamek.common.UnitType;\n+import megamek.common.annotations.Nullable;\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.Utilities;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.ResolveScenarioTracker;\n+import mekhq.campaign.againstTheBot.enums.AtBLanceRole;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.event.StratconDeploymentEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.force.Lance;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier.EventTiming;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconFacility.FacilityType;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.unit.Unit;\n+\n+/**\n+ * This class contains \"rules\" logic for the AtB-Stratcon state\n+ * @author NickAragua\n+ */\n+public class StratconRulesManager {\n+    /**\n+     * What makes a particular lance eligible to be reinforcements for a scenario\n+     */\n+    public enum ReinforcementEligibilityType {\n+        /**\n+         * Nothing\n+         */\n+        None,\n+\n+        /**\n+         * Lance is already deployed to the track\n+         */\n+        ChainedScenario,\n+\n+        /**\n+         * We pay a support point or convert a victory point to a support point\n+         */\n+        SupportPoint,\n+\n+        /**\n+         * The lance's deployment orders are \"Fight\"\n+         */\n+        FightLance\n+    }\n+\n+    /**\n+     * This function potentially generates non-player-initiated scenarios for the given track.\n+     */\n+    public static void generateScenariosForTrack(Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // maps scenarios to force IDs\n+        List<StratconScenario> generatedScenarios = new ArrayList<>();\n+        boolean autoAssignLances = contract.getCommandRights() == AtBContract.COM_INTEGRATED;\n+\n+        // get this list just so we have it available\n+        List<Integer> availableForceIDs = getAvailableForceIDs(campaign);\n+        Map<MapLocation, List<Integer>> sortedAvailableForceIDs = sortForcesByMapType(availableForceIDs, campaign);\n+\n+        // make X rolls, where X is the number of required lances for the track\n+        // that's the chance to spawn a scenario.\n+        // if a scenario occurs, then we pick a random non-deployed lance and use it to drive the opfor generation later\n+        // once we've determined that scenarios occur, we loop through the ones that we generated\n+        // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all\n+        for (int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            int targetNum = calculateScenarioOdds(track, contract, false);\n+            \n+            // if we haven't already used all the player forces and are required to randomly generate a scenario\n+            if (!availableForceIDs.isEmpty() && (Compute.randomInt(100) <= targetNum)) {\n+                // pick random coordinates and force to drive the scenario\n+                int x = Compute.randomInt(track.getWidth());\n+                int y = Compute.randomInt(track.getHeight());\n+\n+                StratconCoords scenarioCoords = new StratconCoords(x, y);\n+\n+                // if forces are already assigned to these coordinates, use those instead\n+                // of randomly-selected ones\n+                if (track.getAssignedCoordForces().containsKey(scenarioCoords)) {\n+                    StratconScenario scenario = generateScenarioForExistingForces(scenarioCoords,\n+                            track.getAssignedCoordForces().get(scenarioCoords), \n+                            contract, campaign, track);\n+                    generatedScenarios.add(scenario);\n+                    continue;\n+                }\n+                \n+                // otherwise, pick a random force from the avail\n+                int randomForceIndex = Compute.randomInt(availableForceIDs.size());\n+                int randomForceID = availableForceIDs.get(randomForceIndex);\n+                \n+                // remove the force from the available lists so we don't designate it as primary twice\n+                availableForceIDs.remove(randomForceIndex);\n+\n+                // we want to remove the actual int with the value, not the value at the index\n+                sortedAvailableForceIDs.get(MapLocation.AllGroundTerrain).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.LowAtmosphere).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.Space).remove((Integer) randomForceID);\n+\n+                // two scenarios on the same coordinates wind up increasing in size\n+                if (track.getScenarios().containsKey(scenarioCoords)) {\n+                    track.getScenarios().get(scenarioCoords).incrementRequiredPlayerLances();\n+                    assignAppropriateExtraForceToScenario(track.getScenarios().get(scenarioCoords), sortedAvailableForceIDs);\n+                    continue;\n+                }\n+\n+                StratconScenario scenario = setupScenario(scenarioCoords, randomForceID, campaign, contract, track);\n+                generatedScenarios.add(scenario);\n+\n+                // if we're auto-assigning lances, deploy the force to the track as well\n+                if (autoAssignLances) {\n+                    processForceDeployment(scenarioCoords, randomForceID, campaign, track, false);\n+                }\n+            }\n+        }\n+\n+        // if under liaison command, pick a random scenario from the ones generated\n+        // to set as required and attach liaison\n+        if (contract.getCommandRights() == AtBContract.COM_LIAISON) {\n+        \tStratconScenario randomScenario = Utilities.getRandomItem(generatedScenarios);\n+        \trandomScenario.setRequiredScenario(true);\n+            setAttachedUnitsModifier(randomScenario, contract);\n+        }\n+\n+        // now, we loop through all the scenarios we set up\n+        // and generate the opfors / events / etc\n+        // if not auto-assigning lances, we then back out the lance assignments.\n+        for (StratconScenario scenario : generatedScenarios) {\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+\n+            if(!autoAssignLances && !scenario.ignoreForceAutoAssignment()) {\n+                for(int forceID : scenario.getPlayerTemplateForceIDs()) {\n+                    scenario.getBackingScenario().removeForce(forceID);\n+                }\n+\n+                scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                track.addScenario(scenario);\n+            } else {\n+                commitPrimaryForces(campaign, scenario, track);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Given a set of force IDs and coordinates, generate a scenario\n+     * Useful for when we want to generate scenarios \n+     * for forces already deployed to a track\n+     */\n+    public static StratconScenario generateScenarioForExistingForces(StratconCoords scenarioCoords, \n+            Set<Integer> forceIDs, AtBContract contract, Campaign campaign, StratconTrackState track) {\n+        boolean firstForce = true;\n+        StratconScenario scenario = null;\n+        \n+        for (int forceID : forceIDs) {\n+            if (firstForce) {\n+                scenario = setupScenario(scenarioCoords, forceID, campaign, contract, track);\n+                firstForce = false;\n+            } else {\n+                scenario.incrementRequiredPlayerLances();\n+                scenario.addPrimaryForce(forceID);\n+            }\n+        }\n+        \n+        // this is theoretically possible if forceIDs is passed in as null - not likely in practice\n+        // but might as well, to future-proof.\n+        if (scenario != null) {\n+            scenario.setIgnoreForceAutoAssignment(true);\n+        }\n+        \n+        return scenario;\n+    }\n+\n+    /**\n+     * Deploys a force to the given coordinates on the given track as a result of explicit player action.\n+     */\n+    public static void deployForceToCoords(StratconCoords coords, int forceID, \n+            Campaign campaign, AtBContract contract, StratconTrackState track, boolean sticky) {\n+        // the following things should happen:\n+        // 1. call to \"process force deployment\", which reveals fog of war in or around the coords, depending on force role\n+        // 2. if coords are a hostile facility, we get a facility mission\n+        // 3. if coords are empty, we *may* get a mission\n+\n+        processForceDeployment(coords, forceID, campaign, track, sticky);\n+\n+        // don't create a scenario on top of allied facilities\n+        StratconFacility facility = track.getFacility(coords);\n+        boolean isNonAlliedFacility = (facility != null) && (facility.getOwner() != ForceAlignment.Allied);\n+        int targetNum = calculateScenarioOdds(track, contract, true);\n+        boolean spawnScenario = (facility == null) && (Compute.randomInt(100) <= targetNum);\n+\n+        if (isNonAlliedFacility || spawnScenario) {\n+            StratconScenario scenario = setupScenario(coords, forceID, campaign, contract, track);\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            commitPrimaryForces(campaign, scenario, track);\n+        }\n+    }\n+\n+    /**\n+     * Logic to set up a scenario\n+     */\n+    private static StratconScenario setupScenario(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        StratconScenario scenario = null;\n+\n+        if (track.getFacilities().containsKey(coords)) {\n+            StratconFacility facility = track.getFacility(coords);\n+            boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+            ScenarioTemplate template = StratconScenarioFactory.getFacilityScenario(alliedFacility);\n+            scenario = generateScenario(campaign, contract, track, forceID, coords, template);\n+            setupFacilityScenario(scenario, facility);\n+        } else {\n+            scenario = generateScenario(campaign, contract, track, forceID, coords);\n+\n+            // we may generate a facility scenario randomly - if so, do the facility-related stuff\n+            // and add a new facility to the track\n+            if (scenario.getBackingScenario().getTemplate().isFacilityScenario()) {\n+                StratconFacility facility = scenario.getBackingScenario().getTemplate().isHostileFacility() ?\n+                        StratconFacilityFactory.getRandomHostileFacility() : StratconFacilityFactory.getRandomAlliedFacility();\n+                facility.setVisible(true);\n+                track.addFacility(coords, facility);\n+                setupFacilityScenario(scenario, facility);\n+            }\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * carries out tasks relevant to facility scenarios\n+     */\n+    private static void setupFacilityScenario(StratconScenario scenario, StratconFacility facility) {\n+        // this includes:\n+        // for hostile facilities\n+        // - add a destroy objective (always the option to level the facility)\n+        // - add a capture objective (always the option to capture the facility)\n+        // - if so indicated by parameter, roll a random hostile facility objective and add it if not capture/destroy\n+        // for allied facilities\n+        // - add a defend objective (always the option to defend the facility)\n+        // - if so indicated by parameter, roll a random allied facility objective and add it if not defend\n+        AtBScenarioModifier objectiveModifier = null;\n+        boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+\n+        if (alliedFacility) {\n+            objectiveModifier = AtBScenarioModifier.getRandomAlliedFacilityModifier();\n+        } else {\n+            objectiveModifier = AtBScenarioModifier.getRandomHostileFacilityModifier();\n+        }\n+\n+        if (objectiveModifier != null) {\n+            scenario.getBackingScenario().addScenarioModifier(objectiveModifier);\n+            scenario.getBackingScenario().setName(String.format(\"%s - %s - %s\",\n+                    facility.getFacilityType(), alliedFacility ? \"Allied\" : \"Hostile\", objectiveModifier.getModifierName()));\n+        }\n+\n+        // add the \"fixed\" hostile facility modifiers after the primary ones\n+        if (!alliedFacility) {\n+            for(AtBScenarioModifier modifier : AtBScenarioModifier.getRequiredHostileFacilityModifiers()) {\n+                if(!scenario.getBackingScenario().alreadyHasModifier(modifier)) {\n+                    scenario.getBackingScenario().addScenarioModifier(modifier);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void processFacilityEffects(StratconTrackState track) {\n+        // TODO: these are \"weekly\"? effects that a stratcon facility has on the campaign/track state\n+        // currrently, that's\n+        // supply depot - allied - +1 sp\n+        // supply depot - hostile - +5% BV budget to all scenarios on track (shared modifier, so should be implemented there)\n+        // data center - allied - +1% star league cache contract (don't implement yet, but...)\n+        // data center - hostile - +5% scenario odds in track\n+        // industrial center - allied - all scenarios here have THIS IS COMING OUT OF YOUR PAYCHECK modifier\n+        // orbital defense - allied - sets 'no hostile aircraft' flag for track\n+        // orbital defense - hostile - sets 'no allied aircraft' flag for track\n+        // early warning system - allied - sets 'intercept allied base attacks' flag for track\n+        // early warning system - hostile - sets 'intercept hostile base attacks' flag for track\n+    }\n+\n+    /**\n+     * Process the deployment of a force to the given coordinates on the given track.\n+     */\n+    public static void processForceDeployment(StratconCoords coords, int forceID, \n+            Campaign campaign, StratconTrackState track, boolean sticky) {\n+        track.getRevealedCoords().add(coords);\n+        StratconFacility facility = track.getFacility(coords);\n+        if (facility != null) {\n+            facility.setVisible(true);\n+        }\n+\n+        if (campaign.getLances().get(forceID).getRole() == AtBLanceRole.SCOUTING) {\n+            for(int direction = 0; direction < 6; direction++) {\n+                StratconCoords checkCoords = coords.translate(direction);\n+\n+                facility = track.getFacility(checkCoords);\n+                if(facility != null) {", "originalCommit": "b36d9fa6bf982c7b833b1ac0a0473d37f6e84760", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTE5MTQ0Mg==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r615191442", "bodyText": "Might want to use a switch statement?", "author": "Windchild292", "createdAt": "2021-04-17T01:59:52Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1404 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.UUID;\n+\n+import megamek.common.Compute;\n+import megamek.common.Minefield;\n+import megamek.common.UnitType;\n+import megamek.common.annotations.Nullable;\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.Utilities;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.ResolveScenarioTracker;\n+import mekhq.campaign.againstTheBot.enums.AtBLanceRole;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.event.StratconDeploymentEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.force.Lance;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier.EventTiming;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconFacility.FacilityType;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.unit.Unit;\n+\n+/**\n+ * This class contains \"rules\" logic for the AtB-Stratcon state\n+ * @author NickAragua\n+ */\n+public class StratconRulesManager {\n+    /**\n+     * What makes a particular lance eligible to be reinforcements for a scenario\n+     */\n+    public enum ReinforcementEligibilityType {\n+        /**\n+         * Nothing\n+         */\n+        None,\n+\n+        /**\n+         * Lance is already deployed to the track\n+         */\n+        ChainedScenario,\n+\n+        /**\n+         * We pay a support point or convert a victory point to a support point\n+         */\n+        SupportPoint,\n+\n+        /**\n+         * The lance's deployment orders are \"Fight\"\n+         */\n+        FightLance\n+    }\n+\n+    /**\n+     * This function potentially generates non-player-initiated scenarios for the given track.\n+     */\n+    public static void generateScenariosForTrack(Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // maps scenarios to force IDs\n+        List<StratconScenario> generatedScenarios = new ArrayList<>();\n+        boolean autoAssignLances = contract.getCommandRights() == AtBContract.COM_INTEGRATED;\n+\n+        // get this list just so we have it available\n+        List<Integer> availableForceIDs = getAvailableForceIDs(campaign);\n+        Map<MapLocation, List<Integer>> sortedAvailableForceIDs = sortForcesByMapType(availableForceIDs, campaign);\n+\n+        // make X rolls, where X is the number of required lances for the track\n+        // that's the chance to spawn a scenario.\n+        // if a scenario occurs, then we pick a random non-deployed lance and use it to drive the opfor generation later\n+        // once we've determined that scenarios occur, we loop through the ones that we generated\n+        // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all\n+        for (int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            int targetNum = calculateScenarioOdds(track, contract, false);\n+            \n+            // if we haven't already used all the player forces and are required to randomly generate a scenario\n+            if (!availableForceIDs.isEmpty() && (Compute.randomInt(100) <= targetNum)) {\n+                // pick random coordinates and force to drive the scenario\n+                int x = Compute.randomInt(track.getWidth());\n+                int y = Compute.randomInt(track.getHeight());\n+\n+                StratconCoords scenarioCoords = new StratconCoords(x, y);\n+\n+                // if forces are already assigned to these coordinates, use those instead\n+                // of randomly-selected ones\n+                if (track.getAssignedCoordForces().containsKey(scenarioCoords)) {\n+                    StratconScenario scenario = generateScenarioForExistingForces(scenarioCoords,\n+                            track.getAssignedCoordForces().get(scenarioCoords), \n+                            contract, campaign, track);\n+                    generatedScenarios.add(scenario);\n+                    continue;\n+                }\n+                \n+                // otherwise, pick a random force from the avail\n+                int randomForceIndex = Compute.randomInt(availableForceIDs.size());\n+                int randomForceID = availableForceIDs.get(randomForceIndex);\n+                \n+                // remove the force from the available lists so we don't designate it as primary twice\n+                availableForceIDs.remove(randomForceIndex);\n+\n+                // we want to remove the actual int with the value, not the value at the index\n+                sortedAvailableForceIDs.get(MapLocation.AllGroundTerrain).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.LowAtmosphere).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.Space).remove((Integer) randomForceID);\n+\n+                // two scenarios on the same coordinates wind up increasing in size\n+                if (track.getScenarios().containsKey(scenarioCoords)) {\n+                    track.getScenarios().get(scenarioCoords).incrementRequiredPlayerLances();\n+                    assignAppropriateExtraForceToScenario(track.getScenarios().get(scenarioCoords), sortedAvailableForceIDs);\n+                    continue;\n+                }\n+\n+                StratconScenario scenario = setupScenario(scenarioCoords, randomForceID, campaign, contract, track);\n+                generatedScenarios.add(scenario);\n+\n+                // if we're auto-assigning lances, deploy the force to the track as well\n+                if (autoAssignLances) {\n+                    processForceDeployment(scenarioCoords, randomForceID, campaign, track, false);\n+                }\n+            }\n+        }\n+\n+        // if under liaison command, pick a random scenario from the ones generated\n+        // to set as required and attach liaison\n+        if (contract.getCommandRights() == AtBContract.COM_LIAISON) {\n+        \tStratconScenario randomScenario = Utilities.getRandomItem(generatedScenarios);\n+        \trandomScenario.setRequiredScenario(true);\n+            setAttachedUnitsModifier(randomScenario, contract);\n+        }\n+\n+        // now, we loop through all the scenarios we set up\n+        // and generate the opfors / events / etc\n+        // if not auto-assigning lances, we then back out the lance assignments.\n+        for (StratconScenario scenario : generatedScenarios) {\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+\n+            if(!autoAssignLances && !scenario.ignoreForceAutoAssignment()) {\n+                for(int forceID : scenario.getPlayerTemplateForceIDs()) {\n+                    scenario.getBackingScenario().removeForce(forceID);\n+                }\n+\n+                scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                track.addScenario(scenario);\n+            } else {\n+                commitPrimaryForces(campaign, scenario, track);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Given a set of force IDs and coordinates, generate a scenario\n+     * Useful for when we want to generate scenarios \n+     * for forces already deployed to a track\n+     */\n+    public static StratconScenario generateScenarioForExistingForces(StratconCoords scenarioCoords, \n+            Set<Integer> forceIDs, AtBContract contract, Campaign campaign, StratconTrackState track) {\n+        boolean firstForce = true;\n+        StratconScenario scenario = null;\n+        \n+        for (int forceID : forceIDs) {\n+            if (firstForce) {\n+                scenario = setupScenario(scenarioCoords, forceID, campaign, contract, track);\n+                firstForce = false;\n+            } else {\n+                scenario.incrementRequiredPlayerLances();\n+                scenario.addPrimaryForce(forceID);\n+            }\n+        }\n+        \n+        // this is theoretically possible if forceIDs is passed in as null - not likely in practice\n+        // but might as well, to future-proof.\n+        if (scenario != null) {\n+            scenario.setIgnoreForceAutoAssignment(true);\n+        }\n+        \n+        return scenario;\n+    }\n+\n+    /**\n+     * Deploys a force to the given coordinates on the given track as a result of explicit player action.\n+     */\n+    public static void deployForceToCoords(StratconCoords coords, int forceID, \n+            Campaign campaign, AtBContract contract, StratconTrackState track, boolean sticky) {\n+        // the following things should happen:\n+        // 1. call to \"process force deployment\", which reveals fog of war in or around the coords, depending on force role\n+        // 2. if coords are a hostile facility, we get a facility mission\n+        // 3. if coords are empty, we *may* get a mission\n+\n+        processForceDeployment(coords, forceID, campaign, track, sticky);\n+\n+        // don't create a scenario on top of allied facilities\n+        StratconFacility facility = track.getFacility(coords);\n+        boolean isNonAlliedFacility = (facility != null) && (facility.getOwner() != ForceAlignment.Allied);\n+        int targetNum = calculateScenarioOdds(track, contract, true);\n+        boolean spawnScenario = (facility == null) && (Compute.randomInt(100) <= targetNum);\n+\n+        if (isNonAlliedFacility || spawnScenario) {\n+            StratconScenario scenario = setupScenario(coords, forceID, campaign, contract, track);\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            commitPrimaryForces(campaign, scenario, track);\n+        }\n+    }\n+\n+    /**\n+     * Logic to set up a scenario\n+     */\n+    private static StratconScenario setupScenario(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        StratconScenario scenario = null;\n+\n+        if (track.getFacilities().containsKey(coords)) {\n+            StratconFacility facility = track.getFacility(coords);\n+            boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+            ScenarioTemplate template = StratconScenarioFactory.getFacilityScenario(alliedFacility);\n+            scenario = generateScenario(campaign, contract, track, forceID, coords, template);\n+            setupFacilityScenario(scenario, facility);\n+        } else {\n+            scenario = generateScenario(campaign, contract, track, forceID, coords);\n+\n+            // we may generate a facility scenario randomly - if so, do the facility-related stuff\n+            // and add a new facility to the track\n+            if (scenario.getBackingScenario().getTemplate().isFacilityScenario()) {\n+                StratconFacility facility = scenario.getBackingScenario().getTemplate().isHostileFacility() ?\n+                        StratconFacilityFactory.getRandomHostileFacility() : StratconFacilityFactory.getRandomAlliedFacility();\n+                facility.setVisible(true);\n+                track.addFacility(coords, facility);\n+                setupFacilityScenario(scenario, facility);\n+            }\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * carries out tasks relevant to facility scenarios\n+     */\n+    private static void setupFacilityScenario(StratconScenario scenario, StratconFacility facility) {\n+        // this includes:\n+        // for hostile facilities\n+        // - add a destroy objective (always the option to level the facility)\n+        // - add a capture objective (always the option to capture the facility)\n+        // - if so indicated by parameter, roll a random hostile facility objective and add it if not capture/destroy\n+        // for allied facilities\n+        // - add a defend objective (always the option to defend the facility)\n+        // - if so indicated by parameter, roll a random allied facility objective and add it if not defend\n+        AtBScenarioModifier objectiveModifier = null;\n+        boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+\n+        if (alliedFacility) {\n+            objectiveModifier = AtBScenarioModifier.getRandomAlliedFacilityModifier();\n+        } else {\n+            objectiveModifier = AtBScenarioModifier.getRandomHostileFacilityModifier();\n+        }\n+\n+        if (objectiveModifier != null) {\n+            scenario.getBackingScenario().addScenarioModifier(objectiveModifier);\n+            scenario.getBackingScenario().setName(String.format(\"%s - %s - %s\",\n+                    facility.getFacilityType(), alliedFacility ? \"Allied\" : \"Hostile\", objectiveModifier.getModifierName()));\n+        }\n+\n+        // add the \"fixed\" hostile facility modifiers after the primary ones\n+        if (!alliedFacility) {\n+            for(AtBScenarioModifier modifier : AtBScenarioModifier.getRequiredHostileFacilityModifiers()) {\n+                if(!scenario.getBackingScenario().alreadyHasModifier(modifier)) {\n+                    scenario.getBackingScenario().addScenarioModifier(modifier);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void processFacilityEffects(StratconTrackState track) {\n+        // TODO: these are \"weekly\"? effects that a stratcon facility has on the campaign/track state\n+        // currrently, that's\n+        // supply depot - allied - +1 sp\n+        // supply depot - hostile - +5% BV budget to all scenarios on track (shared modifier, so should be implemented there)\n+        // data center - allied - +1% star league cache contract (don't implement yet, but...)\n+        // data center - hostile - +5% scenario odds in track\n+        // industrial center - allied - all scenarios here have THIS IS COMING OUT OF YOUR PAYCHECK modifier\n+        // orbital defense - allied - sets 'no hostile aircraft' flag for track\n+        // orbital defense - hostile - sets 'no allied aircraft' flag for track\n+        // early warning system - allied - sets 'intercept allied base attacks' flag for track\n+        // early warning system - hostile - sets 'intercept hostile base attacks' flag for track\n+    }\n+\n+    /**\n+     * Process the deployment of a force to the given coordinates on the given track.\n+     */\n+    public static void processForceDeployment(StratconCoords coords, int forceID, \n+            Campaign campaign, StratconTrackState track, boolean sticky) {\n+        track.getRevealedCoords().add(coords);\n+        StratconFacility facility = track.getFacility(coords);\n+        if (facility != null) {\n+            facility.setVisible(true);\n+        }\n+\n+        if (campaign.getLances().get(forceID).getRole() == AtBLanceRole.SCOUTING) {\n+            for(int direction = 0; direction < 6; direction++) {\n+                StratconCoords checkCoords = coords.translate(direction);\n+\n+                facility = track.getFacility(checkCoords);\n+                if(facility != null) {\n+                    facility.setVisible(true);\n+                }\n+\n+                track.getRevealedCoords().add(coords.translate(direction));\n+            }\n+        }\n+\n+        // the force may be located in other places on the track - clear it out\n+        track.unassignForce(forceID);\n+        track.assignForce(forceID, coords, campaign.getLocalDate(), sticky);\n+        MekHQ.triggerEvent(new StratconDeploymentEvent(campaign.getForce(forceID)));\n+    }\n+\n+    /**\n+     * Worker function that processes the effects of deploying a reinforcement force to a scenario\n+     */\n+    public static boolean processReinforcementDeployment(ReinforcementEligibilityType reinforcementType,\n+            StratconCampaignState campaignState, StratconScenario scenario, Campaign campaign) {\n+        // if the force is already deployed to the track, we're done\n+        // if the force is a fight lance or we're using a support point\n+        // if there is an SP to burn, burn it and we're done\n+        // if there is a VP to burn, burn it and we're done\n+        // now, roll 2d6 + lance commander tactics\n+        // 9+ = deploy\n+        // 6+ = deploy, apply negative modifier to scenario\n+        // 2+ = fail to deploy, apply negative modifier to scenario; if fight lance, treat as 6+\n+\n+        if ((reinforcementType == ReinforcementEligibilityType.FightLance) ||", "originalCommit": "b36d9fa6bf982c7b833b1ac0a0473d37f6e84760", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTE5MTUxNw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r615191517", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 *", "author": "Windchild292", "createdAt": "2021-04-17T02:00:33Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1404 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.UUID;\n+\n+import megamek.common.Compute;\n+import megamek.common.Minefield;\n+import megamek.common.UnitType;\n+import megamek.common.annotations.Nullable;\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.Utilities;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.ResolveScenarioTracker;\n+import mekhq.campaign.againstTheBot.enums.AtBLanceRole;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.event.StratconDeploymentEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.force.Lance;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier.EventTiming;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconFacility.FacilityType;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.unit.Unit;\n+\n+/**\n+ * This class contains \"rules\" logic for the AtB-Stratcon state\n+ * @author NickAragua\n+ */\n+public class StratconRulesManager {\n+    /**\n+     * What makes a particular lance eligible to be reinforcements for a scenario\n+     */\n+    public enum ReinforcementEligibilityType {\n+        /**\n+         * Nothing\n+         */\n+        None,\n+\n+        /**\n+         * Lance is already deployed to the track\n+         */\n+        ChainedScenario,\n+\n+        /**\n+         * We pay a support point or convert a victory point to a support point\n+         */\n+        SupportPoint,\n+\n+        /**\n+         * The lance's deployment orders are \"Fight\"\n+         */\n+        FightLance\n+    }\n+\n+    /**\n+     * This function potentially generates non-player-initiated scenarios for the given track.\n+     */\n+    public static void generateScenariosForTrack(Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // maps scenarios to force IDs\n+        List<StratconScenario> generatedScenarios = new ArrayList<>();\n+        boolean autoAssignLances = contract.getCommandRights() == AtBContract.COM_INTEGRATED;\n+\n+        // get this list just so we have it available\n+        List<Integer> availableForceIDs = getAvailableForceIDs(campaign);\n+        Map<MapLocation, List<Integer>> sortedAvailableForceIDs = sortForcesByMapType(availableForceIDs, campaign);\n+\n+        // make X rolls, where X is the number of required lances for the track\n+        // that's the chance to spawn a scenario.\n+        // if a scenario occurs, then we pick a random non-deployed lance and use it to drive the opfor generation later\n+        // once we've determined that scenarios occur, we loop through the ones that we generated\n+        // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all\n+        for (int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            int targetNum = calculateScenarioOdds(track, contract, false);\n+            \n+            // if we haven't already used all the player forces and are required to randomly generate a scenario\n+            if (!availableForceIDs.isEmpty() && (Compute.randomInt(100) <= targetNum)) {\n+                // pick random coordinates and force to drive the scenario\n+                int x = Compute.randomInt(track.getWidth());\n+                int y = Compute.randomInt(track.getHeight());\n+\n+                StratconCoords scenarioCoords = new StratconCoords(x, y);\n+\n+                // if forces are already assigned to these coordinates, use those instead\n+                // of randomly-selected ones\n+                if (track.getAssignedCoordForces().containsKey(scenarioCoords)) {\n+                    StratconScenario scenario = generateScenarioForExistingForces(scenarioCoords,\n+                            track.getAssignedCoordForces().get(scenarioCoords), \n+                            contract, campaign, track);\n+                    generatedScenarios.add(scenario);\n+                    continue;\n+                }\n+                \n+                // otherwise, pick a random force from the avail\n+                int randomForceIndex = Compute.randomInt(availableForceIDs.size());\n+                int randomForceID = availableForceIDs.get(randomForceIndex);\n+                \n+                // remove the force from the available lists so we don't designate it as primary twice\n+                availableForceIDs.remove(randomForceIndex);\n+\n+                // we want to remove the actual int with the value, not the value at the index\n+                sortedAvailableForceIDs.get(MapLocation.AllGroundTerrain).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.LowAtmosphere).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.Space).remove((Integer) randomForceID);\n+\n+                // two scenarios on the same coordinates wind up increasing in size\n+                if (track.getScenarios().containsKey(scenarioCoords)) {\n+                    track.getScenarios().get(scenarioCoords).incrementRequiredPlayerLances();\n+                    assignAppropriateExtraForceToScenario(track.getScenarios().get(scenarioCoords), sortedAvailableForceIDs);\n+                    continue;\n+                }\n+\n+                StratconScenario scenario = setupScenario(scenarioCoords, randomForceID, campaign, contract, track);\n+                generatedScenarios.add(scenario);\n+\n+                // if we're auto-assigning lances, deploy the force to the track as well\n+                if (autoAssignLances) {\n+                    processForceDeployment(scenarioCoords, randomForceID, campaign, track, false);\n+                }\n+            }\n+        }\n+\n+        // if under liaison command, pick a random scenario from the ones generated\n+        // to set as required and attach liaison\n+        if (contract.getCommandRights() == AtBContract.COM_LIAISON) {\n+        \tStratconScenario randomScenario = Utilities.getRandomItem(generatedScenarios);\n+        \trandomScenario.setRequiredScenario(true);\n+            setAttachedUnitsModifier(randomScenario, contract);\n+        }\n+\n+        // now, we loop through all the scenarios we set up\n+        // and generate the opfors / events / etc\n+        // if not auto-assigning lances, we then back out the lance assignments.\n+        for (StratconScenario scenario : generatedScenarios) {\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+\n+            if(!autoAssignLances && !scenario.ignoreForceAutoAssignment()) {\n+                for(int forceID : scenario.getPlayerTemplateForceIDs()) {\n+                    scenario.getBackingScenario().removeForce(forceID);\n+                }\n+\n+                scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                track.addScenario(scenario);\n+            } else {\n+                commitPrimaryForces(campaign, scenario, track);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Given a set of force IDs and coordinates, generate a scenario\n+     * Useful for when we want to generate scenarios \n+     * for forces already deployed to a track\n+     */\n+    public static StratconScenario generateScenarioForExistingForces(StratconCoords scenarioCoords, \n+            Set<Integer> forceIDs, AtBContract contract, Campaign campaign, StratconTrackState track) {\n+        boolean firstForce = true;\n+        StratconScenario scenario = null;\n+        \n+        for (int forceID : forceIDs) {\n+            if (firstForce) {\n+                scenario = setupScenario(scenarioCoords, forceID, campaign, contract, track);\n+                firstForce = false;\n+            } else {\n+                scenario.incrementRequiredPlayerLances();\n+                scenario.addPrimaryForce(forceID);\n+            }\n+        }\n+        \n+        // this is theoretically possible if forceIDs is passed in as null - not likely in practice\n+        // but might as well, to future-proof.\n+        if (scenario != null) {\n+            scenario.setIgnoreForceAutoAssignment(true);\n+        }\n+        \n+        return scenario;\n+    }\n+\n+    /**\n+     * Deploys a force to the given coordinates on the given track as a result of explicit player action.\n+     */\n+    public static void deployForceToCoords(StratconCoords coords, int forceID, \n+            Campaign campaign, AtBContract contract, StratconTrackState track, boolean sticky) {\n+        // the following things should happen:\n+        // 1. call to \"process force deployment\", which reveals fog of war in or around the coords, depending on force role\n+        // 2. if coords are a hostile facility, we get a facility mission\n+        // 3. if coords are empty, we *may* get a mission\n+\n+        processForceDeployment(coords, forceID, campaign, track, sticky);\n+\n+        // don't create a scenario on top of allied facilities\n+        StratconFacility facility = track.getFacility(coords);\n+        boolean isNonAlliedFacility = (facility != null) && (facility.getOwner() != ForceAlignment.Allied);\n+        int targetNum = calculateScenarioOdds(track, contract, true);\n+        boolean spawnScenario = (facility == null) && (Compute.randomInt(100) <= targetNum);\n+\n+        if (isNonAlliedFacility || spawnScenario) {\n+            StratconScenario scenario = setupScenario(coords, forceID, campaign, contract, track);\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            commitPrimaryForces(campaign, scenario, track);\n+        }\n+    }\n+\n+    /**\n+     * Logic to set up a scenario\n+     */\n+    private static StratconScenario setupScenario(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        StratconScenario scenario = null;\n+\n+        if (track.getFacilities().containsKey(coords)) {\n+            StratconFacility facility = track.getFacility(coords);\n+            boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+            ScenarioTemplate template = StratconScenarioFactory.getFacilityScenario(alliedFacility);\n+            scenario = generateScenario(campaign, contract, track, forceID, coords, template);\n+            setupFacilityScenario(scenario, facility);\n+        } else {\n+            scenario = generateScenario(campaign, contract, track, forceID, coords);\n+\n+            // we may generate a facility scenario randomly - if so, do the facility-related stuff\n+            // and add a new facility to the track\n+            if (scenario.getBackingScenario().getTemplate().isFacilityScenario()) {\n+                StratconFacility facility = scenario.getBackingScenario().getTemplate().isHostileFacility() ?\n+                        StratconFacilityFactory.getRandomHostileFacility() : StratconFacilityFactory.getRandomAlliedFacility();\n+                facility.setVisible(true);\n+                track.addFacility(coords, facility);\n+                setupFacilityScenario(scenario, facility);\n+            }\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * carries out tasks relevant to facility scenarios\n+     */\n+    private static void setupFacilityScenario(StratconScenario scenario, StratconFacility facility) {\n+        // this includes:\n+        // for hostile facilities\n+        // - add a destroy objective (always the option to level the facility)\n+        // - add a capture objective (always the option to capture the facility)\n+        // - if so indicated by parameter, roll a random hostile facility objective and add it if not capture/destroy\n+        // for allied facilities\n+        // - add a defend objective (always the option to defend the facility)\n+        // - if so indicated by parameter, roll a random allied facility objective and add it if not defend\n+        AtBScenarioModifier objectiveModifier = null;\n+        boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+\n+        if (alliedFacility) {\n+            objectiveModifier = AtBScenarioModifier.getRandomAlliedFacilityModifier();\n+        } else {\n+            objectiveModifier = AtBScenarioModifier.getRandomHostileFacilityModifier();\n+        }\n+\n+        if (objectiveModifier != null) {\n+            scenario.getBackingScenario().addScenarioModifier(objectiveModifier);\n+            scenario.getBackingScenario().setName(String.format(\"%s - %s - %s\",\n+                    facility.getFacilityType(), alliedFacility ? \"Allied\" : \"Hostile\", objectiveModifier.getModifierName()));\n+        }\n+\n+        // add the \"fixed\" hostile facility modifiers after the primary ones\n+        if (!alliedFacility) {\n+            for(AtBScenarioModifier modifier : AtBScenarioModifier.getRequiredHostileFacilityModifiers()) {\n+                if(!scenario.getBackingScenario().alreadyHasModifier(modifier)) {\n+                    scenario.getBackingScenario().addScenarioModifier(modifier);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void processFacilityEffects(StratconTrackState track) {\n+        // TODO: these are \"weekly\"? effects that a stratcon facility has on the campaign/track state\n+        // currrently, that's\n+        // supply depot - allied - +1 sp\n+        // supply depot - hostile - +5% BV budget to all scenarios on track (shared modifier, so should be implemented there)\n+        // data center - allied - +1% star league cache contract (don't implement yet, but...)\n+        // data center - hostile - +5% scenario odds in track\n+        // industrial center - allied - all scenarios here have THIS IS COMING OUT OF YOUR PAYCHECK modifier\n+        // orbital defense - allied - sets 'no hostile aircraft' flag for track\n+        // orbital defense - hostile - sets 'no allied aircraft' flag for track\n+        // early warning system - allied - sets 'intercept allied base attacks' flag for track\n+        // early warning system - hostile - sets 'intercept hostile base attacks' flag for track\n+    }\n+\n+    /**\n+     * Process the deployment of a force to the given coordinates on the given track.\n+     */\n+    public static void processForceDeployment(StratconCoords coords, int forceID, \n+            Campaign campaign, StratconTrackState track, boolean sticky) {\n+        track.getRevealedCoords().add(coords);\n+        StratconFacility facility = track.getFacility(coords);\n+        if (facility != null) {\n+            facility.setVisible(true);\n+        }\n+\n+        if (campaign.getLances().get(forceID).getRole() == AtBLanceRole.SCOUTING) {\n+            for(int direction = 0; direction < 6; direction++) {\n+                StratconCoords checkCoords = coords.translate(direction);\n+\n+                facility = track.getFacility(checkCoords);\n+                if(facility != null) {\n+                    facility.setVisible(true);\n+                }\n+\n+                track.getRevealedCoords().add(coords.translate(direction));\n+            }\n+        }\n+\n+        // the force may be located in other places on the track - clear it out\n+        track.unassignForce(forceID);\n+        track.assignForce(forceID, coords, campaign.getLocalDate(), sticky);\n+        MekHQ.triggerEvent(new StratconDeploymentEvent(campaign.getForce(forceID)));\n+    }\n+\n+    /**\n+     * Worker function that processes the effects of deploying a reinforcement force to a scenario\n+     */\n+    public static boolean processReinforcementDeployment(ReinforcementEligibilityType reinforcementType,\n+            StratconCampaignState campaignState, StratconScenario scenario, Campaign campaign) {\n+        // if the force is already deployed to the track, we're done\n+        // if the force is a fight lance or we're using a support point\n+        // if there is an SP to burn, burn it and we're done\n+        // if there is a VP to burn, burn it and we're done\n+        // now, roll 2d6 + lance commander tactics\n+        // 9+ = deploy\n+        // 6+ = deploy, apply negative modifier to scenario\n+        // 2+ = fail to deploy, apply negative modifier to scenario; if fight lance, treat as 6+\n+\n+        if ((reinforcementType == ReinforcementEligibilityType.FightLance) ||\n+                (reinforcementType == ReinforcementEligibilityType.SupportPoint)) {\n+\n+            if (campaignState.getSupportPoints() > 0) {\n+                campaignState.useSupportPoint();\n+                return true;\n+            } else if (campaignState.getVictoryPoints() > 0) {\n+                campaignState.updateVictoryPoints(-1);\n+                return true;\n+            }\n+\n+            int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+            int roll = Compute.d6(2);\n+            int result = roll + tactics;\n+\n+            StringBuilder reportStatus = new StringBuilder();\n+            reportStatus.append(String.format(\"Attempting to reinforce scenario %s without SP/VP, roll 2d6 + %d: %d\",\n+                    scenario.getName(), tactics, result));\n+\n+            // fail to reinforce\n+            if ((result < 6) && (reinforcementType != ReinforcementEligibilityType.FightLance)) {\n+                reportStatus.append(\" - reinforcement attempt failed.\");\n+                campaign.addReport(reportStatus.toString());\n+                return false;\n+            // succeed but get an extra negative event added to the scenario\n+            } else if (result < 9) {\n+                MapLocation mapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+                AtBScenarioModifier scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+\n+                // keep rolling until we get an applicable one\n+                // TODO: have the AtBScenarioModifier sort these out instead for performance?\n+                while (scenarioModifier.getEventTiming() != EventTiming.PostForceGeneration) {\n+                    scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+                }\n+\n+                scenarioModifier.processModifier(scenario.getBackingScenario(), campaign, EventTiming.PostForceGeneration);\n+\n+                reportStatus.append(String.format(\" - reinforcement attempt succeeded; extra negative modifier (%s) applied to scenario.\",\n+                        scenarioModifier.getModifierName()));\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            // succeed without reservation\n+            } else {\n+                reportStatus.append(\" - reinforcement attempt succeeded;\");\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            }\n+        } else if (reinforcementType == ReinforcementEligibilityType.None) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Assigns a force to the scenario such that the majority of the force can be deployed\n+     */\n+    private static void assignAppropriateExtraForceToScenario(StratconScenario scenario,\n+            Map<MapLocation, List<Integer>> sortedAvailableForceIDs) {\n+        // the goal of this function is to avoid assigning ground units to air battles\n+        // and ground units/conventional fighters to space battle\n+\n+        List<MapLocation> mapLocations = new ArrayList<>();\n+        mapLocations.add(MapLocation.Space); // can always add ASFs\n+\n+        MapLocation scenarioMapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+\n+        if (scenarioMapLocation == MapLocation.LowAtmosphere) {\n+            mapLocations.add(MapLocation.LowAtmosphere); // can add conventional fighters to ground or low atmo battles\n+        }\n+\n+        if ((scenarioMapLocation == MapLocation.AllGroundTerrain) ||\n+                (scenarioMapLocation == MapLocation.SpecificGroundTerrain)) {\n+            mapLocations.add(MapLocation.AllGroundTerrain); // can only add ground units to ground battles\n+        }\n+\n+        MapLocation selectedLocation = mapLocations.get(Compute.randomInt(mapLocations.size()));\n+        List<Integer> forceIDs = sortedAvailableForceIDs.get(selectedLocation);\n+        int forceIndex = Compute.randomInt(forceIDs.size());\n+        int forceID = forceIDs.get(forceIndex);\n+        forceIDs.remove(forceIndex);\n+\n+        scenario.addPrimaryForce(forceID);\n+    }\n+\n+    /**\n+     * Worker function that \"locks in\" a scenario -\n+     * Adds it to the campaign so it's visible in the briefing room,\n+     * adds it to the track\n+     *", "originalCommit": "b36d9fa6bf982c7b833b1ac0a0473d37f6e84760", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTE5MTU2MQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r615191561", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if(scenario.getReturnDate() == null) {\n          \n          \n            \n                    if (scenario.getReturnDate() == null) {", "author": "Windchild292", "createdAt": "2021-04-17T02:00:48Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1404 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.UUID;\n+\n+import megamek.common.Compute;\n+import megamek.common.Minefield;\n+import megamek.common.UnitType;\n+import megamek.common.annotations.Nullable;\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.Utilities;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.ResolveScenarioTracker;\n+import mekhq.campaign.againstTheBot.enums.AtBLanceRole;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.event.StratconDeploymentEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.force.Lance;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier.EventTiming;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconFacility.FacilityType;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.unit.Unit;\n+\n+/**\n+ * This class contains \"rules\" logic for the AtB-Stratcon state\n+ * @author NickAragua\n+ */\n+public class StratconRulesManager {\n+    /**\n+     * What makes a particular lance eligible to be reinforcements for a scenario\n+     */\n+    public enum ReinforcementEligibilityType {\n+        /**\n+         * Nothing\n+         */\n+        None,\n+\n+        /**\n+         * Lance is already deployed to the track\n+         */\n+        ChainedScenario,\n+\n+        /**\n+         * We pay a support point or convert a victory point to a support point\n+         */\n+        SupportPoint,\n+\n+        /**\n+         * The lance's deployment orders are \"Fight\"\n+         */\n+        FightLance\n+    }\n+\n+    /**\n+     * This function potentially generates non-player-initiated scenarios for the given track.\n+     */\n+    public static void generateScenariosForTrack(Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // maps scenarios to force IDs\n+        List<StratconScenario> generatedScenarios = new ArrayList<>();\n+        boolean autoAssignLances = contract.getCommandRights() == AtBContract.COM_INTEGRATED;\n+\n+        // get this list just so we have it available\n+        List<Integer> availableForceIDs = getAvailableForceIDs(campaign);\n+        Map<MapLocation, List<Integer>> sortedAvailableForceIDs = sortForcesByMapType(availableForceIDs, campaign);\n+\n+        // make X rolls, where X is the number of required lances for the track\n+        // that's the chance to spawn a scenario.\n+        // if a scenario occurs, then we pick a random non-deployed lance and use it to drive the opfor generation later\n+        // once we've determined that scenarios occur, we loop through the ones that we generated\n+        // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all\n+        for (int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            int targetNum = calculateScenarioOdds(track, contract, false);\n+            \n+            // if we haven't already used all the player forces and are required to randomly generate a scenario\n+            if (!availableForceIDs.isEmpty() && (Compute.randomInt(100) <= targetNum)) {\n+                // pick random coordinates and force to drive the scenario\n+                int x = Compute.randomInt(track.getWidth());\n+                int y = Compute.randomInt(track.getHeight());\n+\n+                StratconCoords scenarioCoords = new StratconCoords(x, y);\n+\n+                // if forces are already assigned to these coordinates, use those instead\n+                // of randomly-selected ones\n+                if (track.getAssignedCoordForces().containsKey(scenarioCoords)) {\n+                    StratconScenario scenario = generateScenarioForExistingForces(scenarioCoords,\n+                            track.getAssignedCoordForces().get(scenarioCoords), \n+                            contract, campaign, track);\n+                    generatedScenarios.add(scenario);\n+                    continue;\n+                }\n+                \n+                // otherwise, pick a random force from the avail\n+                int randomForceIndex = Compute.randomInt(availableForceIDs.size());\n+                int randomForceID = availableForceIDs.get(randomForceIndex);\n+                \n+                // remove the force from the available lists so we don't designate it as primary twice\n+                availableForceIDs.remove(randomForceIndex);\n+\n+                // we want to remove the actual int with the value, not the value at the index\n+                sortedAvailableForceIDs.get(MapLocation.AllGroundTerrain).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.LowAtmosphere).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.Space).remove((Integer) randomForceID);\n+\n+                // two scenarios on the same coordinates wind up increasing in size\n+                if (track.getScenarios().containsKey(scenarioCoords)) {\n+                    track.getScenarios().get(scenarioCoords).incrementRequiredPlayerLances();\n+                    assignAppropriateExtraForceToScenario(track.getScenarios().get(scenarioCoords), sortedAvailableForceIDs);\n+                    continue;\n+                }\n+\n+                StratconScenario scenario = setupScenario(scenarioCoords, randomForceID, campaign, contract, track);\n+                generatedScenarios.add(scenario);\n+\n+                // if we're auto-assigning lances, deploy the force to the track as well\n+                if (autoAssignLances) {\n+                    processForceDeployment(scenarioCoords, randomForceID, campaign, track, false);\n+                }\n+            }\n+        }\n+\n+        // if under liaison command, pick a random scenario from the ones generated\n+        // to set as required and attach liaison\n+        if (contract.getCommandRights() == AtBContract.COM_LIAISON) {\n+        \tStratconScenario randomScenario = Utilities.getRandomItem(generatedScenarios);\n+        \trandomScenario.setRequiredScenario(true);\n+            setAttachedUnitsModifier(randomScenario, contract);\n+        }\n+\n+        // now, we loop through all the scenarios we set up\n+        // and generate the opfors / events / etc\n+        // if not auto-assigning lances, we then back out the lance assignments.\n+        for (StratconScenario scenario : generatedScenarios) {\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+\n+            if(!autoAssignLances && !scenario.ignoreForceAutoAssignment()) {\n+                for(int forceID : scenario.getPlayerTemplateForceIDs()) {\n+                    scenario.getBackingScenario().removeForce(forceID);\n+                }\n+\n+                scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                track.addScenario(scenario);\n+            } else {\n+                commitPrimaryForces(campaign, scenario, track);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Given a set of force IDs and coordinates, generate a scenario\n+     * Useful for when we want to generate scenarios \n+     * for forces already deployed to a track\n+     */\n+    public static StratconScenario generateScenarioForExistingForces(StratconCoords scenarioCoords, \n+            Set<Integer> forceIDs, AtBContract contract, Campaign campaign, StratconTrackState track) {\n+        boolean firstForce = true;\n+        StratconScenario scenario = null;\n+        \n+        for (int forceID : forceIDs) {\n+            if (firstForce) {\n+                scenario = setupScenario(scenarioCoords, forceID, campaign, contract, track);\n+                firstForce = false;\n+            } else {\n+                scenario.incrementRequiredPlayerLances();\n+                scenario.addPrimaryForce(forceID);\n+            }\n+        }\n+        \n+        // this is theoretically possible if forceIDs is passed in as null - not likely in practice\n+        // but might as well, to future-proof.\n+        if (scenario != null) {\n+            scenario.setIgnoreForceAutoAssignment(true);\n+        }\n+        \n+        return scenario;\n+    }\n+\n+    /**\n+     * Deploys a force to the given coordinates on the given track as a result of explicit player action.\n+     */\n+    public static void deployForceToCoords(StratconCoords coords, int forceID, \n+            Campaign campaign, AtBContract contract, StratconTrackState track, boolean sticky) {\n+        // the following things should happen:\n+        // 1. call to \"process force deployment\", which reveals fog of war in or around the coords, depending on force role\n+        // 2. if coords are a hostile facility, we get a facility mission\n+        // 3. if coords are empty, we *may* get a mission\n+\n+        processForceDeployment(coords, forceID, campaign, track, sticky);\n+\n+        // don't create a scenario on top of allied facilities\n+        StratconFacility facility = track.getFacility(coords);\n+        boolean isNonAlliedFacility = (facility != null) && (facility.getOwner() != ForceAlignment.Allied);\n+        int targetNum = calculateScenarioOdds(track, contract, true);\n+        boolean spawnScenario = (facility == null) && (Compute.randomInt(100) <= targetNum);\n+\n+        if (isNonAlliedFacility || spawnScenario) {\n+            StratconScenario scenario = setupScenario(coords, forceID, campaign, contract, track);\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            commitPrimaryForces(campaign, scenario, track);\n+        }\n+    }\n+\n+    /**\n+     * Logic to set up a scenario\n+     */\n+    private static StratconScenario setupScenario(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        StratconScenario scenario = null;\n+\n+        if (track.getFacilities().containsKey(coords)) {\n+            StratconFacility facility = track.getFacility(coords);\n+            boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+            ScenarioTemplate template = StratconScenarioFactory.getFacilityScenario(alliedFacility);\n+            scenario = generateScenario(campaign, contract, track, forceID, coords, template);\n+            setupFacilityScenario(scenario, facility);\n+        } else {\n+            scenario = generateScenario(campaign, contract, track, forceID, coords);\n+\n+            // we may generate a facility scenario randomly - if so, do the facility-related stuff\n+            // and add a new facility to the track\n+            if (scenario.getBackingScenario().getTemplate().isFacilityScenario()) {\n+                StratconFacility facility = scenario.getBackingScenario().getTemplate().isHostileFacility() ?\n+                        StratconFacilityFactory.getRandomHostileFacility() : StratconFacilityFactory.getRandomAlliedFacility();\n+                facility.setVisible(true);\n+                track.addFacility(coords, facility);\n+                setupFacilityScenario(scenario, facility);\n+            }\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * carries out tasks relevant to facility scenarios\n+     */\n+    private static void setupFacilityScenario(StratconScenario scenario, StratconFacility facility) {\n+        // this includes:\n+        // for hostile facilities\n+        // - add a destroy objective (always the option to level the facility)\n+        // - add a capture objective (always the option to capture the facility)\n+        // - if so indicated by parameter, roll a random hostile facility objective and add it if not capture/destroy\n+        // for allied facilities\n+        // - add a defend objective (always the option to defend the facility)\n+        // - if so indicated by parameter, roll a random allied facility objective and add it if not defend\n+        AtBScenarioModifier objectiveModifier = null;\n+        boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+\n+        if (alliedFacility) {\n+            objectiveModifier = AtBScenarioModifier.getRandomAlliedFacilityModifier();\n+        } else {\n+            objectiveModifier = AtBScenarioModifier.getRandomHostileFacilityModifier();\n+        }\n+\n+        if (objectiveModifier != null) {\n+            scenario.getBackingScenario().addScenarioModifier(objectiveModifier);\n+            scenario.getBackingScenario().setName(String.format(\"%s - %s - %s\",\n+                    facility.getFacilityType(), alliedFacility ? \"Allied\" : \"Hostile\", objectiveModifier.getModifierName()));\n+        }\n+\n+        // add the \"fixed\" hostile facility modifiers after the primary ones\n+        if (!alliedFacility) {\n+            for(AtBScenarioModifier modifier : AtBScenarioModifier.getRequiredHostileFacilityModifiers()) {\n+                if(!scenario.getBackingScenario().alreadyHasModifier(modifier)) {\n+                    scenario.getBackingScenario().addScenarioModifier(modifier);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void processFacilityEffects(StratconTrackState track) {\n+        // TODO: these are \"weekly\"? effects that a stratcon facility has on the campaign/track state\n+        // currrently, that's\n+        // supply depot - allied - +1 sp\n+        // supply depot - hostile - +5% BV budget to all scenarios on track (shared modifier, so should be implemented there)\n+        // data center - allied - +1% star league cache contract (don't implement yet, but...)\n+        // data center - hostile - +5% scenario odds in track\n+        // industrial center - allied - all scenarios here have THIS IS COMING OUT OF YOUR PAYCHECK modifier\n+        // orbital defense - allied - sets 'no hostile aircraft' flag for track\n+        // orbital defense - hostile - sets 'no allied aircraft' flag for track\n+        // early warning system - allied - sets 'intercept allied base attacks' flag for track\n+        // early warning system - hostile - sets 'intercept hostile base attacks' flag for track\n+    }\n+\n+    /**\n+     * Process the deployment of a force to the given coordinates on the given track.\n+     */\n+    public static void processForceDeployment(StratconCoords coords, int forceID, \n+            Campaign campaign, StratconTrackState track, boolean sticky) {\n+        track.getRevealedCoords().add(coords);\n+        StratconFacility facility = track.getFacility(coords);\n+        if (facility != null) {\n+            facility.setVisible(true);\n+        }\n+\n+        if (campaign.getLances().get(forceID).getRole() == AtBLanceRole.SCOUTING) {\n+            for(int direction = 0; direction < 6; direction++) {\n+                StratconCoords checkCoords = coords.translate(direction);\n+\n+                facility = track.getFacility(checkCoords);\n+                if(facility != null) {\n+                    facility.setVisible(true);\n+                }\n+\n+                track.getRevealedCoords().add(coords.translate(direction));\n+            }\n+        }\n+\n+        // the force may be located in other places on the track - clear it out\n+        track.unassignForce(forceID);\n+        track.assignForce(forceID, coords, campaign.getLocalDate(), sticky);\n+        MekHQ.triggerEvent(new StratconDeploymentEvent(campaign.getForce(forceID)));\n+    }\n+\n+    /**\n+     * Worker function that processes the effects of deploying a reinforcement force to a scenario\n+     */\n+    public static boolean processReinforcementDeployment(ReinforcementEligibilityType reinforcementType,\n+            StratconCampaignState campaignState, StratconScenario scenario, Campaign campaign) {\n+        // if the force is already deployed to the track, we're done\n+        // if the force is a fight lance or we're using a support point\n+        // if there is an SP to burn, burn it and we're done\n+        // if there is a VP to burn, burn it and we're done\n+        // now, roll 2d6 + lance commander tactics\n+        // 9+ = deploy\n+        // 6+ = deploy, apply negative modifier to scenario\n+        // 2+ = fail to deploy, apply negative modifier to scenario; if fight lance, treat as 6+\n+\n+        if ((reinforcementType == ReinforcementEligibilityType.FightLance) ||\n+                (reinforcementType == ReinforcementEligibilityType.SupportPoint)) {\n+\n+            if (campaignState.getSupportPoints() > 0) {\n+                campaignState.useSupportPoint();\n+                return true;\n+            } else if (campaignState.getVictoryPoints() > 0) {\n+                campaignState.updateVictoryPoints(-1);\n+                return true;\n+            }\n+\n+            int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+            int roll = Compute.d6(2);\n+            int result = roll + tactics;\n+\n+            StringBuilder reportStatus = new StringBuilder();\n+            reportStatus.append(String.format(\"Attempting to reinforce scenario %s without SP/VP, roll 2d6 + %d: %d\",\n+                    scenario.getName(), tactics, result));\n+\n+            // fail to reinforce\n+            if ((result < 6) && (reinforcementType != ReinforcementEligibilityType.FightLance)) {\n+                reportStatus.append(\" - reinforcement attempt failed.\");\n+                campaign.addReport(reportStatus.toString());\n+                return false;\n+            // succeed but get an extra negative event added to the scenario\n+            } else if (result < 9) {\n+                MapLocation mapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+                AtBScenarioModifier scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+\n+                // keep rolling until we get an applicable one\n+                // TODO: have the AtBScenarioModifier sort these out instead for performance?\n+                while (scenarioModifier.getEventTiming() != EventTiming.PostForceGeneration) {\n+                    scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+                }\n+\n+                scenarioModifier.processModifier(scenario.getBackingScenario(), campaign, EventTiming.PostForceGeneration);\n+\n+                reportStatus.append(String.format(\" - reinforcement attempt succeeded; extra negative modifier (%s) applied to scenario.\",\n+                        scenarioModifier.getModifierName()));\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            // succeed without reservation\n+            } else {\n+                reportStatus.append(\" - reinforcement attempt succeeded;\");\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            }\n+        } else if (reinforcementType == ReinforcementEligibilityType.None) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Assigns a force to the scenario such that the majority of the force can be deployed\n+     */\n+    private static void assignAppropriateExtraForceToScenario(StratconScenario scenario,\n+            Map<MapLocation, List<Integer>> sortedAvailableForceIDs) {\n+        // the goal of this function is to avoid assigning ground units to air battles\n+        // and ground units/conventional fighters to space battle\n+\n+        List<MapLocation> mapLocations = new ArrayList<>();\n+        mapLocations.add(MapLocation.Space); // can always add ASFs\n+\n+        MapLocation scenarioMapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+\n+        if (scenarioMapLocation == MapLocation.LowAtmosphere) {\n+            mapLocations.add(MapLocation.LowAtmosphere); // can add conventional fighters to ground or low atmo battles\n+        }\n+\n+        if ((scenarioMapLocation == MapLocation.AllGroundTerrain) ||\n+                (scenarioMapLocation == MapLocation.SpecificGroundTerrain)) {\n+            mapLocations.add(MapLocation.AllGroundTerrain); // can only add ground units to ground battles\n+        }\n+\n+        MapLocation selectedLocation = mapLocations.get(Compute.randomInt(mapLocations.size()));\n+        List<Integer> forceIDs = sortedAvailableForceIDs.get(selectedLocation);\n+        int forceIndex = Compute.randomInt(forceIDs.size());\n+        int forceID = forceIDs.get(forceIndex);\n+        forceIDs.remove(forceIndex);\n+\n+        scenario.addPrimaryForce(forceID);\n+    }\n+\n+    /**\n+     * Worker function that \"locks in\" a scenario -\n+     * Adds it to the campaign so it's visible in the briefing room,\n+     * adds it to the track\n+     *\n+     */\n+    public static void commitPrimaryForces(Campaign campaign, StratconScenario scenario, StratconTrackState trackState) {\n+        trackState.addScenario(scenario);\n+\n+        // set up dates for the scenario if doesn't have them already\n+        if (scenario.getDeploymentDate() == null) {\n+            scenario.setDeploymentDate(campaign.getLocalDate());\n+        }\n+\n+        if (scenario.getActionDate() == null) {\n+            scenario.setActionDate(campaign.getLocalDate());\n+        }\n+\n+        if(scenario.getReturnDate() == null) {", "originalCommit": "b36d9fa6bf982c7b833b1ac0a0473d37f6e84760", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTE5MTU4OA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r615191588", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        switch(campaign.getForce(forceID).getPrimaryUnitType(campaign)) {\n          \n          \n            \n                        switch (campaign.getForce(forceID).getPrimaryUnitType(campaign)) {", "author": "Windchild292", "createdAt": "2021-04-17T02:01:30Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1404 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.UUID;\n+\n+import megamek.common.Compute;\n+import megamek.common.Minefield;\n+import megamek.common.UnitType;\n+import megamek.common.annotations.Nullable;\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.Utilities;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.ResolveScenarioTracker;\n+import mekhq.campaign.againstTheBot.enums.AtBLanceRole;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.event.StratconDeploymentEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.force.Lance;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier.EventTiming;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconFacility.FacilityType;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.unit.Unit;\n+\n+/**\n+ * This class contains \"rules\" logic for the AtB-Stratcon state\n+ * @author NickAragua\n+ */\n+public class StratconRulesManager {\n+    /**\n+     * What makes a particular lance eligible to be reinforcements for a scenario\n+     */\n+    public enum ReinforcementEligibilityType {\n+        /**\n+         * Nothing\n+         */\n+        None,\n+\n+        /**\n+         * Lance is already deployed to the track\n+         */\n+        ChainedScenario,\n+\n+        /**\n+         * We pay a support point or convert a victory point to a support point\n+         */\n+        SupportPoint,\n+\n+        /**\n+         * The lance's deployment orders are \"Fight\"\n+         */\n+        FightLance\n+    }\n+\n+    /**\n+     * This function potentially generates non-player-initiated scenarios for the given track.\n+     */\n+    public static void generateScenariosForTrack(Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // maps scenarios to force IDs\n+        List<StratconScenario> generatedScenarios = new ArrayList<>();\n+        boolean autoAssignLances = contract.getCommandRights() == AtBContract.COM_INTEGRATED;\n+\n+        // get this list just so we have it available\n+        List<Integer> availableForceIDs = getAvailableForceIDs(campaign);\n+        Map<MapLocation, List<Integer>> sortedAvailableForceIDs = sortForcesByMapType(availableForceIDs, campaign);\n+\n+        // make X rolls, where X is the number of required lances for the track\n+        // that's the chance to spawn a scenario.\n+        // if a scenario occurs, then we pick a random non-deployed lance and use it to drive the opfor generation later\n+        // once we've determined that scenarios occur, we loop through the ones that we generated\n+        // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all\n+        for (int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            int targetNum = calculateScenarioOdds(track, contract, false);\n+            \n+            // if we haven't already used all the player forces and are required to randomly generate a scenario\n+            if (!availableForceIDs.isEmpty() && (Compute.randomInt(100) <= targetNum)) {\n+                // pick random coordinates and force to drive the scenario\n+                int x = Compute.randomInt(track.getWidth());\n+                int y = Compute.randomInt(track.getHeight());\n+\n+                StratconCoords scenarioCoords = new StratconCoords(x, y);\n+\n+                // if forces are already assigned to these coordinates, use those instead\n+                // of randomly-selected ones\n+                if (track.getAssignedCoordForces().containsKey(scenarioCoords)) {\n+                    StratconScenario scenario = generateScenarioForExistingForces(scenarioCoords,\n+                            track.getAssignedCoordForces().get(scenarioCoords), \n+                            contract, campaign, track);\n+                    generatedScenarios.add(scenario);\n+                    continue;\n+                }\n+                \n+                // otherwise, pick a random force from the avail\n+                int randomForceIndex = Compute.randomInt(availableForceIDs.size());\n+                int randomForceID = availableForceIDs.get(randomForceIndex);\n+                \n+                // remove the force from the available lists so we don't designate it as primary twice\n+                availableForceIDs.remove(randomForceIndex);\n+\n+                // we want to remove the actual int with the value, not the value at the index\n+                sortedAvailableForceIDs.get(MapLocation.AllGroundTerrain).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.LowAtmosphere).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.Space).remove((Integer) randomForceID);\n+\n+                // two scenarios on the same coordinates wind up increasing in size\n+                if (track.getScenarios().containsKey(scenarioCoords)) {\n+                    track.getScenarios().get(scenarioCoords).incrementRequiredPlayerLances();\n+                    assignAppropriateExtraForceToScenario(track.getScenarios().get(scenarioCoords), sortedAvailableForceIDs);\n+                    continue;\n+                }\n+\n+                StratconScenario scenario = setupScenario(scenarioCoords, randomForceID, campaign, contract, track);\n+                generatedScenarios.add(scenario);\n+\n+                // if we're auto-assigning lances, deploy the force to the track as well\n+                if (autoAssignLances) {\n+                    processForceDeployment(scenarioCoords, randomForceID, campaign, track, false);\n+                }\n+            }\n+        }\n+\n+        // if under liaison command, pick a random scenario from the ones generated\n+        // to set as required and attach liaison\n+        if (contract.getCommandRights() == AtBContract.COM_LIAISON) {\n+        \tStratconScenario randomScenario = Utilities.getRandomItem(generatedScenarios);\n+        \trandomScenario.setRequiredScenario(true);\n+            setAttachedUnitsModifier(randomScenario, contract);\n+        }\n+\n+        // now, we loop through all the scenarios we set up\n+        // and generate the opfors / events / etc\n+        // if not auto-assigning lances, we then back out the lance assignments.\n+        for (StratconScenario scenario : generatedScenarios) {\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+\n+            if(!autoAssignLances && !scenario.ignoreForceAutoAssignment()) {\n+                for(int forceID : scenario.getPlayerTemplateForceIDs()) {\n+                    scenario.getBackingScenario().removeForce(forceID);\n+                }\n+\n+                scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                track.addScenario(scenario);\n+            } else {\n+                commitPrimaryForces(campaign, scenario, track);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Given a set of force IDs and coordinates, generate a scenario\n+     * Useful for when we want to generate scenarios \n+     * for forces already deployed to a track\n+     */\n+    public static StratconScenario generateScenarioForExistingForces(StratconCoords scenarioCoords, \n+            Set<Integer> forceIDs, AtBContract contract, Campaign campaign, StratconTrackState track) {\n+        boolean firstForce = true;\n+        StratconScenario scenario = null;\n+        \n+        for (int forceID : forceIDs) {\n+            if (firstForce) {\n+                scenario = setupScenario(scenarioCoords, forceID, campaign, contract, track);\n+                firstForce = false;\n+            } else {\n+                scenario.incrementRequiredPlayerLances();\n+                scenario.addPrimaryForce(forceID);\n+            }\n+        }\n+        \n+        // this is theoretically possible if forceIDs is passed in as null - not likely in practice\n+        // but might as well, to future-proof.\n+        if (scenario != null) {\n+            scenario.setIgnoreForceAutoAssignment(true);\n+        }\n+        \n+        return scenario;\n+    }\n+\n+    /**\n+     * Deploys a force to the given coordinates on the given track as a result of explicit player action.\n+     */\n+    public static void deployForceToCoords(StratconCoords coords, int forceID, \n+            Campaign campaign, AtBContract contract, StratconTrackState track, boolean sticky) {\n+        // the following things should happen:\n+        // 1. call to \"process force deployment\", which reveals fog of war in or around the coords, depending on force role\n+        // 2. if coords are a hostile facility, we get a facility mission\n+        // 3. if coords are empty, we *may* get a mission\n+\n+        processForceDeployment(coords, forceID, campaign, track, sticky);\n+\n+        // don't create a scenario on top of allied facilities\n+        StratconFacility facility = track.getFacility(coords);\n+        boolean isNonAlliedFacility = (facility != null) && (facility.getOwner() != ForceAlignment.Allied);\n+        int targetNum = calculateScenarioOdds(track, contract, true);\n+        boolean spawnScenario = (facility == null) && (Compute.randomInt(100) <= targetNum);\n+\n+        if (isNonAlliedFacility || spawnScenario) {\n+            StratconScenario scenario = setupScenario(coords, forceID, campaign, contract, track);\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            commitPrimaryForces(campaign, scenario, track);\n+        }\n+    }\n+\n+    /**\n+     * Logic to set up a scenario\n+     */\n+    private static StratconScenario setupScenario(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        StratconScenario scenario = null;\n+\n+        if (track.getFacilities().containsKey(coords)) {\n+            StratconFacility facility = track.getFacility(coords);\n+            boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+            ScenarioTemplate template = StratconScenarioFactory.getFacilityScenario(alliedFacility);\n+            scenario = generateScenario(campaign, contract, track, forceID, coords, template);\n+            setupFacilityScenario(scenario, facility);\n+        } else {\n+            scenario = generateScenario(campaign, contract, track, forceID, coords);\n+\n+            // we may generate a facility scenario randomly - if so, do the facility-related stuff\n+            // and add a new facility to the track\n+            if (scenario.getBackingScenario().getTemplate().isFacilityScenario()) {\n+                StratconFacility facility = scenario.getBackingScenario().getTemplate().isHostileFacility() ?\n+                        StratconFacilityFactory.getRandomHostileFacility() : StratconFacilityFactory.getRandomAlliedFacility();\n+                facility.setVisible(true);\n+                track.addFacility(coords, facility);\n+                setupFacilityScenario(scenario, facility);\n+            }\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * carries out tasks relevant to facility scenarios\n+     */\n+    private static void setupFacilityScenario(StratconScenario scenario, StratconFacility facility) {\n+        // this includes:\n+        // for hostile facilities\n+        // - add a destroy objective (always the option to level the facility)\n+        // - add a capture objective (always the option to capture the facility)\n+        // - if so indicated by parameter, roll a random hostile facility objective and add it if not capture/destroy\n+        // for allied facilities\n+        // - add a defend objective (always the option to defend the facility)\n+        // - if so indicated by parameter, roll a random allied facility objective and add it if not defend\n+        AtBScenarioModifier objectiveModifier = null;\n+        boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+\n+        if (alliedFacility) {\n+            objectiveModifier = AtBScenarioModifier.getRandomAlliedFacilityModifier();\n+        } else {\n+            objectiveModifier = AtBScenarioModifier.getRandomHostileFacilityModifier();\n+        }\n+\n+        if (objectiveModifier != null) {\n+            scenario.getBackingScenario().addScenarioModifier(objectiveModifier);\n+            scenario.getBackingScenario().setName(String.format(\"%s - %s - %s\",\n+                    facility.getFacilityType(), alliedFacility ? \"Allied\" : \"Hostile\", objectiveModifier.getModifierName()));\n+        }\n+\n+        // add the \"fixed\" hostile facility modifiers after the primary ones\n+        if (!alliedFacility) {\n+            for(AtBScenarioModifier modifier : AtBScenarioModifier.getRequiredHostileFacilityModifiers()) {\n+                if(!scenario.getBackingScenario().alreadyHasModifier(modifier)) {\n+                    scenario.getBackingScenario().addScenarioModifier(modifier);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void processFacilityEffects(StratconTrackState track) {\n+        // TODO: these are \"weekly\"? effects that a stratcon facility has on the campaign/track state\n+        // currrently, that's\n+        // supply depot - allied - +1 sp\n+        // supply depot - hostile - +5% BV budget to all scenarios on track (shared modifier, so should be implemented there)\n+        // data center - allied - +1% star league cache contract (don't implement yet, but...)\n+        // data center - hostile - +5% scenario odds in track\n+        // industrial center - allied - all scenarios here have THIS IS COMING OUT OF YOUR PAYCHECK modifier\n+        // orbital defense - allied - sets 'no hostile aircraft' flag for track\n+        // orbital defense - hostile - sets 'no allied aircraft' flag for track\n+        // early warning system - allied - sets 'intercept allied base attacks' flag for track\n+        // early warning system - hostile - sets 'intercept hostile base attacks' flag for track\n+    }\n+\n+    /**\n+     * Process the deployment of a force to the given coordinates on the given track.\n+     */\n+    public static void processForceDeployment(StratconCoords coords, int forceID, \n+            Campaign campaign, StratconTrackState track, boolean sticky) {\n+        track.getRevealedCoords().add(coords);\n+        StratconFacility facility = track.getFacility(coords);\n+        if (facility != null) {\n+            facility.setVisible(true);\n+        }\n+\n+        if (campaign.getLances().get(forceID).getRole() == AtBLanceRole.SCOUTING) {\n+            for(int direction = 0; direction < 6; direction++) {\n+                StratconCoords checkCoords = coords.translate(direction);\n+\n+                facility = track.getFacility(checkCoords);\n+                if(facility != null) {\n+                    facility.setVisible(true);\n+                }\n+\n+                track.getRevealedCoords().add(coords.translate(direction));\n+            }\n+        }\n+\n+        // the force may be located in other places on the track - clear it out\n+        track.unassignForce(forceID);\n+        track.assignForce(forceID, coords, campaign.getLocalDate(), sticky);\n+        MekHQ.triggerEvent(new StratconDeploymentEvent(campaign.getForce(forceID)));\n+    }\n+\n+    /**\n+     * Worker function that processes the effects of deploying a reinforcement force to a scenario\n+     */\n+    public static boolean processReinforcementDeployment(ReinforcementEligibilityType reinforcementType,\n+            StratconCampaignState campaignState, StratconScenario scenario, Campaign campaign) {\n+        // if the force is already deployed to the track, we're done\n+        // if the force is a fight lance or we're using a support point\n+        // if there is an SP to burn, burn it and we're done\n+        // if there is a VP to burn, burn it and we're done\n+        // now, roll 2d6 + lance commander tactics\n+        // 9+ = deploy\n+        // 6+ = deploy, apply negative modifier to scenario\n+        // 2+ = fail to deploy, apply negative modifier to scenario; if fight lance, treat as 6+\n+\n+        if ((reinforcementType == ReinforcementEligibilityType.FightLance) ||\n+                (reinforcementType == ReinforcementEligibilityType.SupportPoint)) {\n+\n+            if (campaignState.getSupportPoints() > 0) {\n+                campaignState.useSupportPoint();\n+                return true;\n+            } else if (campaignState.getVictoryPoints() > 0) {\n+                campaignState.updateVictoryPoints(-1);\n+                return true;\n+            }\n+\n+            int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+            int roll = Compute.d6(2);\n+            int result = roll + tactics;\n+\n+            StringBuilder reportStatus = new StringBuilder();\n+            reportStatus.append(String.format(\"Attempting to reinforce scenario %s without SP/VP, roll 2d6 + %d: %d\",\n+                    scenario.getName(), tactics, result));\n+\n+            // fail to reinforce\n+            if ((result < 6) && (reinforcementType != ReinforcementEligibilityType.FightLance)) {\n+                reportStatus.append(\" - reinforcement attempt failed.\");\n+                campaign.addReport(reportStatus.toString());\n+                return false;\n+            // succeed but get an extra negative event added to the scenario\n+            } else if (result < 9) {\n+                MapLocation mapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+                AtBScenarioModifier scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+\n+                // keep rolling until we get an applicable one\n+                // TODO: have the AtBScenarioModifier sort these out instead for performance?\n+                while (scenarioModifier.getEventTiming() != EventTiming.PostForceGeneration) {\n+                    scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+                }\n+\n+                scenarioModifier.processModifier(scenario.getBackingScenario(), campaign, EventTiming.PostForceGeneration);\n+\n+                reportStatus.append(String.format(\" - reinforcement attempt succeeded; extra negative modifier (%s) applied to scenario.\",\n+                        scenarioModifier.getModifierName()));\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            // succeed without reservation\n+            } else {\n+                reportStatus.append(\" - reinforcement attempt succeeded;\");\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            }\n+        } else if (reinforcementType == ReinforcementEligibilityType.None) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Assigns a force to the scenario such that the majority of the force can be deployed\n+     */\n+    private static void assignAppropriateExtraForceToScenario(StratconScenario scenario,\n+            Map<MapLocation, List<Integer>> sortedAvailableForceIDs) {\n+        // the goal of this function is to avoid assigning ground units to air battles\n+        // and ground units/conventional fighters to space battle\n+\n+        List<MapLocation> mapLocations = new ArrayList<>();\n+        mapLocations.add(MapLocation.Space); // can always add ASFs\n+\n+        MapLocation scenarioMapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+\n+        if (scenarioMapLocation == MapLocation.LowAtmosphere) {\n+            mapLocations.add(MapLocation.LowAtmosphere); // can add conventional fighters to ground or low atmo battles\n+        }\n+\n+        if ((scenarioMapLocation == MapLocation.AllGroundTerrain) ||\n+                (scenarioMapLocation == MapLocation.SpecificGroundTerrain)) {\n+            mapLocations.add(MapLocation.AllGroundTerrain); // can only add ground units to ground battles\n+        }\n+\n+        MapLocation selectedLocation = mapLocations.get(Compute.randomInt(mapLocations.size()));\n+        List<Integer> forceIDs = sortedAvailableForceIDs.get(selectedLocation);\n+        int forceIndex = Compute.randomInt(forceIDs.size());\n+        int forceID = forceIDs.get(forceIndex);\n+        forceIDs.remove(forceIndex);\n+\n+        scenario.addPrimaryForce(forceID);\n+    }\n+\n+    /**\n+     * Worker function that \"locks in\" a scenario -\n+     * Adds it to the campaign so it's visible in the briefing room,\n+     * adds it to the track\n+     *\n+     */\n+    public static void commitPrimaryForces(Campaign campaign, StratconScenario scenario, StratconTrackState trackState) {\n+        trackState.addScenario(scenario);\n+\n+        // set up dates for the scenario if doesn't have them already\n+        if (scenario.getDeploymentDate() == null) {\n+            scenario.setDeploymentDate(campaign.getLocalDate());\n+        }\n+\n+        if (scenario.getActionDate() == null) {\n+            scenario.setActionDate(campaign.getLocalDate());\n+        }\n+\n+        if(scenario.getReturnDate() == null) {\n+            scenario.setReturnDate(campaign.getLocalDate().plusDays(trackState.getDeploymentTime()));\n+        }\n+\n+        // set the # of rerolls based on the actual lance assigned.\n+        int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+        scenario.getBackingScenario().setRerolls(tactics);\n+        // The number of defensive points available to a force entering a scenario is\n+        // 2 x tactics. By default, those points are spent on conventional minefields.\n+        if (commanderLanceHasDefensiveAssignment(scenario.getBackingScenario(), campaign)) {\n+            scenario.setNumDefensivePoints(tactics * 2);\n+            scenario.updateMinefieldCount(Minefield.TYPE_CONVENTIONAL, tactics * 2);\n+        }\n+\n+        for (int forceID : scenario.getPlayerTemplateForceIDs()) {\n+            Force force = campaign.getForce(forceID);\n+            force.clearScenarioIds(campaign, true);\n+            force.setScenarioId(scenario.getBackingScenarioID());\n+        }\n+\n+        scenario.commitPrimaryForces();\n+    }\n+\n+    /**\n+     * Utility method to determine if the current scenario's force commander\n+     * is on defence\n+     */\n+    private static boolean commanderLanceHasDefensiveAssignment(AtBDynamicScenario scenario, Campaign campaign) {\n+        Unit commanderUnit = scenario.getLanceCommander(campaign).getUnit();\n+        Lance lance = campaign.getLances().get(commanderUnit.getForceId());\n+\n+        if ((lance != null) && (lance.getRole() == AtBLanceRole.DEFENCE)) {\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * A hackish worker function that takes the given list of force IDs and\n+     * separates it into three sets;\n+     * one of forces that can be \"primary\" on a ground map\n+     * one of forces that can be \"primary\" on an atmospheric map\n+     * one of forces that can be \"primary\" in a space map\n+     * @param forceIDs List of force IDs to check\n+     * @return Sorted hash map\n+     */\n+    private static Map<MapLocation, List<Integer>> sortForcesByMapType(List<Integer> forceIDs, Campaign campaign) {\n+        Map<MapLocation, List<Integer>> retVal = new HashMap<>();\n+\n+        retVal.put(MapLocation.AllGroundTerrain, new ArrayList<>());\n+        retVal.put(MapLocation.LowAtmosphere, new ArrayList<>());\n+        retVal.put(MapLocation.Space, new ArrayList<>());\n+\n+        for (int forceID : forceIDs) {\n+            switch(campaign.getForce(forceID).getPrimaryUnitType(campaign)) {", "originalCommit": "b36d9fa6bf982c7b833b1ac0a0473d37f6e84760", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTE5MTU5NA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r615191594", "bodyText": "Indent cases", "author": "Windchild292", "createdAt": "2021-04-17T02:01:46Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1404 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.UUID;\n+\n+import megamek.common.Compute;\n+import megamek.common.Minefield;\n+import megamek.common.UnitType;\n+import megamek.common.annotations.Nullable;\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.Utilities;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.ResolveScenarioTracker;\n+import mekhq.campaign.againstTheBot.enums.AtBLanceRole;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.event.StratconDeploymentEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.force.Lance;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier.EventTiming;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconFacility.FacilityType;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.unit.Unit;\n+\n+/**\n+ * This class contains \"rules\" logic for the AtB-Stratcon state\n+ * @author NickAragua\n+ */\n+public class StratconRulesManager {\n+    /**\n+     * What makes a particular lance eligible to be reinforcements for a scenario\n+     */\n+    public enum ReinforcementEligibilityType {\n+        /**\n+         * Nothing\n+         */\n+        None,\n+\n+        /**\n+         * Lance is already deployed to the track\n+         */\n+        ChainedScenario,\n+\n+        /**\n+         * We pay a support point or convert a victory point to a support point\n+         */\n+        SupportPoint,\n+\n+        /**\n+         * The lance's deployment orders are \"Fight\"\n+         */\n+        FightLance\n+    }\n+\n+    /**\n+     * This function potentially generates non-player-initiated scenarios for the given track.\n+     */\n+    public static void generateScenariosForTrack(Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // maps scenarios to force IDs\n+        List<StratconScenario> generatedScenarios = new ArrayList<>();\n+        boolean autoAssignLances = contract.getCommandRights() == AtBContract.COM_INTEGRATED;\n+\n+        // get this list just so we have it available\n+        List<Integer> availableForceIDs = getAvailableForceIDs(campaign);\n+        Map<MapLocation, List<Integer>> sortedAvailableForceIDs = sortForcesByMapType(availableForceIDs, campaign);\n+\n+        // make X rolls, where X is the number of required lances for the track\n+        // that's the chance to spawn a scenario.\n+        // if a scenario occurs, then we pick a random non-deployed lance and use it to drive the opfor generation later\n+        // once we've determined that scenarios occur, we loop through the ones that we generated\n+        // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all\n+        for (int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            int targetNum = calculateScenarioOdds(track, contract, false);\n+            \n+            // if we haven't already used all the player forces and are required to randomly generate a scenario\n+            if (!availableForceIDs.isEmpty() && (Compute.randomInt(100) <= targetNum)) {\n+                // pick random coordinates and force to drive the scenario\n+                int x = Compute.randomInt(track.getWidth());\n+                int y = Compute.randomInt(track.getHeight());\n+\n+                StratconCoords scenarioCoords = new StratconCoords(x, y);\n+\n+                // if forces are already assigned to these coordinates, use those instead\n+                // of randomly-selected ones\n+                if (track.getAssignedCoordForces().containsKey(scenarioCoords)) {\n+                    StratconScenario scenario = generateScenarioForExistingForces(scenarioCoords,\n+                            track.getAssignedCoordForces().get(scenarioCoords), \n+                            contract, campaign, track);\n+                    generatedScenarios.add(scenario);\n+                    continue;\n+                }\n+                \n+                // otherwise, pick a random force from the avail\n+                int randomForceIndex = Compute.randomInt(availableForceIDs.size());\n+                int randomForceID = availableForceIDs.get(randomForceIndex);\n+                \n+                // remove the force from the available lists so we don't designate it as primary twice\n+                availableForceIDs.remove(randomForceIndex);\n+\n+                // we want to remove the actual int with the value, not the value at the index\n+                sortedAvailableForceIDs.get(MapLocation.AllGroundTerrain).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.LowAtmosphere).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.Space).remove((Integer) randomForceID);\n+\n+                // two scenarios on the same coordinates wind up increasing in size\n+                if (track.getScenarios().containsKey(scenarioCoords)) {\n+                    track.getScenarios().get(scenarioCoords).incrementRequiredPlayerLances();\n+                    assignAppropriateExtraForceToScenario(track.getScenarios().get(scenarioCoords), sortedAvailableForceIDs);\n+                    continue;\n+                }\n+\n+                StratconScenario scenario = setupScenario(scenarioCoords, randomForceID, campaign, contract, track);\n+                generatedScenarios.add(scenario);\n+\n+                // if we're auto-assigning lances, deploy the force to the track as well\n+                if (autoAssignLances) {\n+                    processForceDeployment(scenarioCoords, randomForceID, campaign, track, false);\n+                }\n+            }\n+        }\n+\n+        // if under liaison command, pick a random scenario from the ones generated\n+        // to set as required and attach liaison\n+        if (contract.getCommandRights() == AtBContract.COM_LIAISON) {\n+        \tStratconScenario randomScenario = Utilities.getRandomItem(generatedScenarios);\n+        \trandomScenario.setRequiredScenario(true);\n+            setAttachedUnitsModifier(randomScenario, contract);\n+        }\n+\n+        // now, we loop through all the scenarios we set up\n+        // and generate the opfors / events / etc\n+        // if not auto-assigning lances, we then back out the lance assignments.\n+        for (StratconScenario scenario : generatedScenarios) {\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+\n+            if(!autoAssignLances && !scenario.ignoreForceAutoAssignment()) {\n+                for(int forceID : scenario.getPlayerTemplateForceIDs()) {\n+                    scenario.getBackingScenario().removeForce(forceID);\n+                }\n+\n+                scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                track.addScenario(scenario);\n+            } else {\n+                commitPrimaryForces(campaign, scenario, track);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Given a set of force IDs and coordinates, generate a scenario\n+     * Useful for when we want to generate scenarios \n+     * for forces already deployed to a track\n+     */\n+    public static StratconScenario generateScenarioForExistingForces(StratconCoords scenarioCoords, \n+            Set<Integer> forceIDs, AtBContract contract, Campaign campaign, StratconTrackState track) {\n+        boolean firstForce = true;\n+        StratconScenario scenario = null;\n+        \n+        for (int forceID : forceIDs) {\n+            if (firstForce) {\n+                scenario = setupScenario(scenarioCoords, forceID, campaign, contract, track);\n+                firstForce = false;\n+            } else {\n+                scenario.incrementRequiredPlayerLances();\n+                scenario.addPrimaryForce(forceID);\n+            }\n+        }\n+        \n+        // this is theoretically possible if forceIDs is passed in as null - not likely in practice\n+        // but might as well, to future-proof.\n+        if (scenario != null) {\n+            scenario.setIgnoreForceAutoAssignment(true);\n+        }\n+        \n+        return scenario;\n+    }\n+\n+    /**\n+     * Deploys a force to the given coordinates on the given track as a result of explicit player action.\n+     */\n+    public static void deployForceToCoords(StratconCoords coords, int forceID, \n+            Campaign campaign, AtBContract contract, StratconTrackState track, boolean sticky) {\n+        // the following things should happen:\n+        // 1. call to \"process force deployment\", which reveals fog of war in or around the coords, depending on force role\n+        // 2. if coords are a hostile facility, we get a facility mission\n+        // 3. if coords are empty, we *may* get a mission\n+\n+        processForceDeployment(coords, forceID, campaign, track, sticky);\n+\n+        // don't create a scenario on top of allied facilities\n+        StratconFacility facility = track.getFacility(coords);\n+        boolean isNonAlliedFacility = (facility != null) && (facility.getOwner() != ForceAlignment.Allied);\n+        int targetNum = calculateScenarioOdds(track, contract, true);\n+        boolean spawnScenario = (facility == null) && (Compute.randomInt(100) <= targetNum);\n+\n+        if (isNonAlliedFacility || spawnScenario) {\n+            StratconScenario scenario = setupScenario(coords, forceID, campaign, contract, track);\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            commitPrimaryForces(campaign, scenario, track);\n+        }\n+    }\n+\n+    /**\n+     * Logic to set up a scenario\n+     */\n+    private static StratconScenario setupScenario(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        StratconScenario scenario = null;\n+\n+        if (track.getFacilities().containsKey(coords)) {\n+            StratconFacility facility = track.getFacility(coords);\n+            boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+            ScenarioTemplate template = StratconScenarioFactory.getFacilityScenario(alliedFacility);\n+            scenario = generateScenario(campaign, contract, track, forceID, coords, template);\n+            setupFacilityScenario(scenario, facility);\n+        } else {\n+            scenario = generateScenario(campaign, contract, track, forceID, coords);\n+\n+            // we may generate a facility scenario randomly - if so, do the facility-related stuff\n+            // and add a new facility to the track\n+            if (scenario.getBackingScenario().getTemplate().isFacilityScenario()) {\n+                StratconFacility facility = scenario.getBackingScenario().getTemplate().isHostileFacility() ?\n+                        StratconFacilityFactory.getRandomHostileFacility() : StratconFacilityFactory.getRandomAlliedFacility();\n+                facility.setVisible(true);\n+                track.addFacility(coords, facility);\n+                setupFacilityScenario(scenario, facility);\n+            }\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * carries out tasks relevant to facility scenarios\n+     */\n+    private static void setupFacilityScenario(StratconScenario scenario, StratconFacility facility) {\n+        // this includes:\n+        // for hostile facilities\n+        // - add a destroy objective (always the option to level the facility)\n+        // - add a capture objective (always the option to capture the facility)\n+        // - if so indicated by parameter, roll a random hostile facility objective and add it if not capture/destroy\n+        // for allied facilities\n+        // - add a defend objective (always the option to defend the facility)\n+        // - if so indicated by parameter, roll a random allied facility objective and add it if not defend\n+        AtBScenarioModifier objectiveModifier = null;\n+        boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+\n+        if (alliedFacility) {\n+            objectiveModifier = AtBScenarioModifier.getRandomAlliedFacilityModifier();\n+        } else {\n+            objectiveModifier = AtBScenarioModifier.getRandomHostileFacilityModifier();\n+        }\n+\n+        if (objectiveModifier != null) {\n+            scenario.getBackingScenario().addScenarioModifier(objectiveModifier);\n+            scenario.getBackingScenario().setName(String.format(\"%s - %s - %s\",\n+                    facility.getFacilityType(), alliedFacility ? \"Allied\" : \"Hostile\", objectiveModifier.getModifierName()));\n+        }\n+\n+        // add the \"fixed\" hostile facility modifiers after the primary ones\n+        if (!alliedFacility) {\n+            for(AtBScenarioModifier modifier : AtBScenarioModifier.getRequiredHostileFacilityModifiers()) {\n+                if(!scenario.getBackingScenario().alreadyHasModifier(modifier)) {\n+                    scenario.getBackingScenario().addScenarioModifier(modifier);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void processFacilityEffects(StratconTrackState track) {\n+        // TODO: these are \"weekly\"? effects that a stratcon facility has on the campaign/track state\n+        // currrently, that's\n+        // supply depot - allied - +1 sp\n+        // supply depot - hostile - +5% BV budget to all scenarios on track (shared modifier, so should be implemented there)\n+        // data center - allied - +1% star league cache contract (don't implement yet, but...)\n+        // data center - hostile - +5% scenario odds in track\n+        // industrial center - allied - all scenarios here have THIS IS COMING OUT OF YOUR PAYCHECK modifier\n+        // orbital defense - allied - sets 'no hostile aircraft' flag for track\n+        // orbital defense - hostile - sets 'no allied aircraft' flag for track\n+        // early warning system - allied - sets 'intercept allied base attacks' flag for track\n+        // early warning system - hostile - sets 'intercept hostile base attacks' flag for track\n+    }\n+\n+    /**\n+     * Process the deployment of a force to the given coordinates on the given track.\n+     */\n+    public static void processForceDeployment(StratconCoords coords, int forceID, \n+            Campaign campaign, StratconTrackState track, boolean sticky) {\n+        track.getRevealedCoords().add(coords);\n+        StratconFacility facility = track.getFacility(coords);\n+        if (facility != null) {\n+            facility.setVisible(true);\n+        }\n+\n+        if (campaign.getLances().get(forceID).getRole() == AtBLanceRole.SCOUTING) {\n+            for(int direction = 0; direction < 6; direction++) {\n+                StratconCoords checkCoords = coords.translate(direction);\n+\n+                facility = track.getFacility(checkCoords);\n+                if(facility != null) {\n+                    facility.setVisible(true);\n+                }\n+\n+                track.getRevealedCoords().add(coords.translate(direction));\n+            }\n+        }\n+\n+        // the force may be located in other places on the track - clear it out\n+        track.unassignForce(forceID);\n+        track.assignForce(forceID, coords, campaign.getLocalDate(), sticky);\n+        MekHQ.triggerEvent(new StratconDeploymentEvent(campaign.getForce(forceID)));\n+    }\n+\n+    /**\n+     * Worker function that processes the effects of deploying a reinforcement force to a scenario\n+     */\n+    public static boolean processReinforcementDeployment(ReinforcementEligibilityType reinforcementType,\n+            StratconCampaignState campaignState, StratconScenario scenario, Campaign campaign) {\n+        // if the force is already deployed to the track, we're done\n+        // if the force is a fight lance or we're using a support point\n+        // if there is an SP to burn, burn it and we're done\n+        // if there is a VP to burn, burn it and we're done\n+        // now, roll 2d6 + lance commander tactics\n+        // 9+ = deploy\n+        // 6+ = deploy, apply negative modifier to scenario\n+        // 2+ = fail to deploy, apply negative modifier to scenario; if fight lance, treat as 6+\n+\n+        if ((reinforcementType == ReinforcementEligibilityType.FightLance) ||\n+                (reinforcementType == ReinforcementEligibilityType.SupportPoint)) {\n+\n+            if (campaignState.getSupportPoints() > 0) {\n+                campaignState.useSupportPoint();\n+                return true;\n+            } else if (campaignState.getVictoryPoints() > 0) {\n+                campaignState.updateVictoryPoints(-1);\n+                return true;\n+            }\n+\n+            int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+            int roll = Compute.d6(2);\n+            int result = roll + tactics;\n+\n+            StringBuilder reportStatus = new StringBuilder();\n+            reportStatus.append(String.format(\"Attempting to reinforce scenario %s without SP/VP, roll 2d6 + %d: %d\",\n+                    scenario.getName(), tactics, result));\n+\n+            // fail to reinforce\n+            if ((result < 6) && (reinforcementType != ReinforcementEligibilityType.FightLance)) {\n+                reportStatus.append(\" - reinforcement attempt failed.\");\n+                campaign.addReport(reportStatus.toString());\n+                return false;\n+            // succeed but get an extra negative event added to the scenario\n+            } else if (result < 9) {\n+                MapLocation mapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+                AtBScenarioModifier scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+\n+                // keep rolling until we get an applicable one\n+                // TODO: have the AtBScenarioModifier sort these out instead for performance?\n+                while (scenarioModifier.getEventTiming() != EventTiming.PostForceGeneration) {\n+                    scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+                }\n+\n+                scenarioModifier.processModifier(scenario.getBackingScenario(), campaign, EventTiming.PostForceGeneration);\n+\n+                reportStatus.append(String.format(\" - reinforcement attempt succeeded; extra negative modifier (%s) applied to scenario.\",\n+                        scenarioModifier.getModifierName()));\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            // succeed without reservation\n+            } else {\n+                reportStatus.append(\" - reinforcement attempt succeeded;\");\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            }\n+        } else if (reinforcementType == ReinforcementEligibilityType.None) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Assigns a force to the scenario such that the majority of the force can be deployed\n+     */\n+    private static void assignAppropriateExtraForceToScenario(StratconScenario scenario,\n+            Map<MapLocation, List<Integer>> sortedAvailableForceIDs) {\n+        // the goal of this function is to avoid assigning ground units to air battles\n+        // and ground units/conventional fighters to space battle\n+\n+        List<MapLocation> mapLocations = new ArrayList<>();\n+        mapLocations.add(MapLocation.Space); // can always add ASFs\n+\n+        MapLocation scenarioMapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+\n+        if (scenarioMapLocation == MapLocation.LowAtmosphere) {\n+            mapLocations.add(MapLocation.LowAtmosphere); // can add conventional fighters to ground or low atmo battles\n+        }\n+\n+        if ((scenarioMapLocation == MapLocation.AllGroundTerrain) ||\n+                (scenarioMapLocation == MapLocation.SpecificGroundTerrain)) {\n+            mapLocations.add(MapLocation.AllGroundTerrain); // can only add ground units to ground battles\n+        }\n+\n+        MapLocation selectedLocation = mapLocations.get(Compute.randomInt(mapLocations.size()));\n+        List<Integer> forceIDs = sortedAvailableForceIDs.get(selectedLocation);\n+        int forceIndex = Compute.randomInt(forceIDs.size());\n+        int forceID = forceIDs.get(forceIndex);\n+        forceIDs.remove(forceIndex);\n+\n+        scenario.addPrimaryForce(forceID);\n+    }\n+\n+    /**\n+     * Worker function that \"locks in\" a scenario -\n+     * Adds it to the campaign so it's visible in the briefing room,\n+     * adds it to the track\n+     *\n+     */\n+    public static void commitPrimaryForces(Campaign campaign, StratconScenario scenario, StratconTrackState trackState) {\n+        trackState.addScenario(scenario);\n+\n+        // set up dates for the scenario if doesn't have them already\n+        if (scenario.getDeploymentDate() == null) {\n+            scenario.setDeploymentDate(campaign.getLocalDate());\n+        }\n+\n+        if (scenario.getActionDate() == null) {\n+            scenario.setActionDate(campaign.getLocalDate());\n+        }\n+\n+        if(scenario.getReturnDate() == null) {\n+            scenario.setReturnDate(campaign.getLocalDate().plusDays(trackState.getDeploymentTime()));\n+        }\n+\n+        // set the # of rerolls based on the actual lance assigned.\n+        int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+        scenario.getBackingScenario().setRerolls(tactics);\n+        // The number of defensive points available to a force entering a scenario is\n+        // 2 x tactics. By default, those points are spent on conventional minefields.\n+        if (commanderLanceHasDefensiveAssignment(scenario.getBackingScenario(), campaign)) {\n+            scenario.setNumDefensivePoints(tactics * 2);\n+            scenario.updateMinefieldCount(Minefield.TYPE_CONVENTIONAL, tactics * 2);\n+        }\n+\n+        for (int forceID : scenario.getPlayerTemplateForceIDs()) {\n+            Force force = campaign.getForce(forceID);\n+            force.clearScenarioIds(campaign, true);\n+            force.setScenarioId(scenario.getBackingScenarioID());\n+        }\n+\n+        scenario.commitPrimaryForces();\n+    }\n+\n+    /**\n+     * Utility method to determine if the current scenario's force commander\n+     * is on defence\n+     */\n+    private static boolean commanderLanceHasDefensiveAssignment(AtBDynamicScenario scenario, Campaign campaign) {\n+        Unit commanderUnit = scenario.getLanceCommander(campaign).getUnit();\n+        Lance lance = campaign.getLances().get(commanderUnit.getForceId());\n+\n+        if ((lance != null) && (lance.getRole() == AtBLanceRole.DEFENCE)) {\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * A hackish worker function that takes the given list of force IDs and\n+     * separates it into three sets;\n+     * one of forces that can be \"primary\" on a ground map\n+     * one of forces that can be \"primary\" on an atmospheric map\n+     * one of forces that can be \"primary\" in a space map\n+     * @param forceIDs List of force IDs to check\n+     * @return Sorted hash map\n+     */\n+    private static Map<MapLocation, List<Integer>> sortForcesByMapType(List<Integer> forceIDs, Campaign campaign) {\n+        Map<MapLocation, List<Integer>> retVal = new HashMap<>();\n+\n+        retVal.put(MapLocation.AllGroundTerrain, new ArrayList<>());\n+        retVal.put(MapLocation.LowAtmosphere, new ArrayList<>());\n+        retVal.put(MapLocation.Space, new ArrayList<>());\n+\n+        for (int forceID : forceIDs) {\n+            switch(campaign.getForce(forceID).getPrimaryUnitType(campaign)) {\n+            case UnitType.BATTLE_ARMOR:\n+            case UnitType.INFANTRY:\n+            case UnitType.MEK:\n+            case UnitType.TANK:\n+            case UnitType.PROTOMEK:\n+            case UnitType.VTOL:\n+                retVal.get(MapLocation.AllGroundTerrain).add(forceID);\n+                break;\n+            case UnitType.AERO:\n+                retVal.get(MapLocation.Space).add(forceID);\n+                // intentional fallthrough here, ASFs can go to atmospheric maps too\n+            case UnitType.CONV_FIGHTER:\n+                retVal.get(MapLocation.LowAtmosphere).add(forceID);\n+                break;", "originalCommit": "b36d9fa6bf982c7b833b1ac0a0473d37f6e84760", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTE5MTYwNw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r615191607", "bodyText": "Suggested change", "author": "Windchild292", "createdAt": "2021-04-17T02:02:01Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1404 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.UUID;\n+\n+import megamek.common.Compute;\n+import megamek.common.Minefield;\n+import megamek.common.UnitType;\n+import megamek.common.annotations.Nullable;\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.Utilities;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.ResolveScenarioTracker;\n+import mekhq.campaign.againstTheBot.enums.AtBLanceRole;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.event.StratconDeploymentEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.force.Lance;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier.EventTiming;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconFacility.FacilityType;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.unit.Unit;\n+\n+/**\n+ * This class contains \"rules\" logic for the AtB-Stratcon state\n+ * @author NickAragua\n+ */\n+public class StratconRulesManager {\n+    /**\n+     * What makes a particular lance eligible to be reinforcements for a scenario\n+     */\n+    public enum ReinforcementEligibilityType {\n+        /**\n+         * Nothing\n+         */\n+        None,\n+\n+        /**\n+         * Lance is already deployed to the track\n+         */\n+        ChainedScenario,\n+\n+        /**\n+         * We pay a support point or convert a victory point to a support point\n+         */\n+        SupportPoint,\n+\n+        /**\n+         * The lance's deployment orders are \"Fight\"\n+         */\n+        FightLance\n+    }\n+\n+    /**\n+     * This function potentially generates non-player-initiated scenarios for the given track.\n+     */\n+    public static void generateScenariosForTrack(Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // maps scenarios to force IDs\n+        List<StratconScenario> generatedScenarios = new ArrayList<>();\n+        boolean autoAssignLances = contract.getCommandRights() == AtBContract.COM_INTEGRATED;\n+\n+        // get this list just so we have it available\n+        List<Integer> availableForceIDs = getAvailableForceIDs(campaign);\n+        Map<MapLocation, List<Integer>> sortedAvailableForceIDs = sortForcesByMapType(availableForceIDs, campaign);\n+\n+        // make X rolls, where X is the number of required lances for the track\n+        // that's the chance to spawn a scenario.\n+        // if a scenario occurs, then we pick a random non-deployed lance and use it to drive the opfor generation later\n+        // once we've determined that scenarios occur, we loop through the ones that we generated\n+        // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all\n+        for (int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            int targetNum = calculateScenarioOdds(track, contract, false);\n+            \n+            // if we haven't already used all the player forces and are required to randomly generate a scenario\n+            if (!availableForceIDs.isEmpty() && (Compute.randomInt(100) <= targetNum)) {\n+                // pick random coordinates and force to drive the scenario\n+                int x = Compute.randomInt(track.getWidth());\n+                int y = Compute.randomInt(track.getHeight());\n+\n+                StratconCoords scenarioCoords = new StratconCoords(x, y);\n+\n+                // if forces are already assigned to these coordinates, use those instead\n+                // of randomly-selected ones\n+                if (track.getAssignedCoordForces().containsKey(scenarioCoords)) {\n+                    StratconScenario scenario = generateScenarioForExistingForces(scenarioCoords,\n+                            track.getAssignedCoordForces().get(scenarioCoords), \n+                            contract, campaign, track);\n+                    generatedScenarios.add(scenario);\n+                    continue;\n+                }\n+                \n+                // otherwise, pick a random force from the avail\n+                int randomForceIndex = Compute.randomInt(availableForceIDs.size());\n+                int randomForceID = availableForceIDs.get(randomForceIndex);\n+                \n+                // remove the force from the available lists so we don't designate it as primary twice\n+                availableForceIDs.remove(randomForceIndex);\n+\n+                // we want to remove the actual int with the value, not the value at the index\n+                sortedAvailableForceIDs.get(MapLocation.AllGroundTerrain).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.LowAtmosphere).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.Space).remove((Integer) randomForceID);\n+\n+                // two scenarios on the same coordinates wind up increasing in size\n+                if (track.getScenarios().containsKey(scenarioCoords)) {\n+                    track.getScenarios().get(scenarioCoords).incrementRequiredPlayerLances();\n+                    assignAppropriateExtraForceToScenario(track.getScenarios().get(scenarioCoords), sortedAvailableForceIDs);\n+                    continue;\n+                }\n+\n+                StratconScenario scenario = setupScenario(scenarioCoords, randomForceID, campaign, contract, track);\n+                generatedScenarios.add(scenario);\n+\n+                // if we're auto-assigning lances, deploy the force to the track as well\n+                if (autoAssignLances) {\n+                    processForceDeployment(scenarioCoords, randomForceID, campaign, track, false);\n+                }\n+            }\n+        }\n+\n+        // if under liaison command, pick a random scenario from the ones generated\n+        // to set as required and attach liaison\n+        if (contract.getCommandRights() == AtBContract.COM_LIAISON) {\n+        \tStratconScenario randomScenario = Utilities.getRandomItem(generatedScenarios);\n+        \trandomScenario.setRequiredScenario(true);\n+            setAttachedUnitsModifier(randomScenario, contract);\n+        }\n+\n+        // now, we loop through all the scenarios we set up\n+        // and generate the opfors / events / etc\n+        // if not auto-assigning lances, we then back out the lance assignments.\n+        for (StratconScenario scenario : generatedScenarios) {\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+\n+            if(!autoAssignLances && !scenario.ignoreForceAutoAssignment()) {\n+                for(int forceID : scenario.getPlayerTemplateForceIDs()) {\n+                    scenario.getBackingScenario().removeForce(forceID);\n+                }\n+\n+                scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                track.addScenario(scenario);\n+            } else {\n+                commitPrimaryForces(campaign, scenario, track);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Given a set of force IDs and coordinates, generate a scenario\n+     * Useful for when we want to generate scenarios \n+     * for forces already deployed to a track\n+     */\n+    public static StratconScenario generateScenarioForExistingForces(StratconCoords scenarioCoords, \n+            Set<Integer> forceIDs, AtBContract contract, Campaign campaign, StratconTrackState track) {\n+        boolean firstForce = true;\n+        StratconScenario scenario = null;\n+        \n+        for (int forceID : forceIDs) {\n+            if (firstForce) {\n+                scenario = setupScenario(scenarioCoords, forceID, campaign, contract, track);\n+                firstForce = false;\n+            } else {\n+                scenario.incrementRequiredPlayerLances();\n+                scenario.addPrimaryForce(forceID);\n+            }\n+        }\n+        \n+        // this is theoretically possible if forceIDs is passed in as null - not likely in practice\n+        // but might as well, to future-proof.\n+        if (scenario != null) {\n+            scenario.setIgnoreForceAutoAssignment(true);\n+        }\n+        \n+        return scenario;\n+    }\n+\n+    /**\n+     * Deploys a force to the given coordinates on the given track as a result of explicit player action.\n+     */\n+    public static void deployForceToCoords(StratconCoords coords, int forceID, \n+            Campaign campaign, AtBContract contract, StratconTrackState track, boolean sticky) {\n+        // the following things should happen:\n+        // 1. call to \"process force deployment\", which reveals fog of war in or around the coords, depending on force role\n+        // 2. if coords are a hostile facility, we get a facility mission\n+        // 3. if coords are empty, we *may* get a mission\n+\n+        processForceDeployment(coords, forceID, campaign, track, sticky);\n+\n+        // don't create a scenario on top of allied facilities\n+        StratconFacility facility = track.getFacility(coords);\n+        boolean isNonAlliedFacility = (facility != null) && (facility.getOwner() != ForceAlignment.Allied);\n+        int targetNum = calculateScenarioOdds(track, contract, true);\n+        boolean spawnScenario = (facility == null) && (Compute.randomInt(100) <= targetNum);\n+\n+        if (isNonAlliedFacility || spawnScenario) {\n+            StratconScenario scenario = setupScenario(coords, forceID, campaign, contract, track);\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            commitPrimaryForces(campaign, scenario, track);\n+        }\n+    }\n+\n+    /**\n+     * Logic to set up a scenario\n+     */\n+    private static StratconScenario setupScenario(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        StratconScenario scenario = null;\n+\n+        if (track.getFacilities().containsKey(coords)) {\n+            StratconFacility facility = track.getFacility(coords);\n+            boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+            ScenarioTemplate template = StratconScenarioFactory.getFacilityScenario(alliedFacility);\n+            scenario = generateScenario(campaign, contract, track, forceID, coords, template);\n+            setupFacilityScenario(scenario, facility);\n+        } else {\n+            scenario = generateScenario(campaign, contract, track, forceID, coords);\n+\n+            // we may generate a facility scenario randomly - if so, do the facility-related stuff\n+            // and add a new facility to the track\n+            if (scenario.getBackingScenario().getTemplate().isFacilityScenario()) {\n+                StratconFacility facility = scenario.getBackingScenario().getTemplate().isHostileFacility() ?\n+                        StratconFacilityFactory.getRandomHostileFacility() : StratconFacilityFactory.getRandomAlliedFacility();\n+                facility.setVisible(true);\n+                track.addFacility(coords, facility);\n+                setupFacilityScenario(scenario, facility);\n+            }\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * carries out tasks relevant to facility scenarios\n+     */\n+    private static void setupFacilityScenario(StratconScenario scenario, StratconFacility facility) {\n+        // this includes:\n+        // for hostile facilities\n+        // - add a destroy objective (always the option to level the facility)\n+        // - add a capture objective (always the option to capture the facility)\n+        // - if so indicated by parameter, roll a random hostile facility objective and add it if not capture/destroy\n+        // for allied facilities\n+        // - add a defend objective (always the option to defend the facility)\n+        // - if so indicated by parameter, roll a random allied facility objective and add it if not defend\n+        AtBScenarioModifier objectiveModifier = null;\n+        boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+\n+        if (alliedFacility) {\n+            objectiveModifier = AtBScenarioModifier.getRandomAlliedFacilityModifier();\n+        } else {\n+            objectiveModifier = AtBScenarioModifier.getRandomHostileFacilityModifier();\n+        }\n+\n+        if (objectiveModifier != null) {\n+            scenario.getBackingScenario().addScenarioModifier(objectiveModifier);\n+            scenario.getBackingScenario().setName(String.format(\"%s - %s - %s\",\n+                    facility.getFacilityType(), alliedFacility ? \"Allied\" : \"Hostile\", objectiveModifier.getModifierName()));\n+        }\n+\n+        // add the \"fixed\" hostile facility modifiers after the primary ones\n+        if (!alliedFacility) {\n+            for(AtBScenarioModifier modifier : AtBScenarioModifier.getRequiredHostileFacilityModifiers()) {\n+                if(!scenario.getBackingScenario().alreadyHasModifier(modifier)) {\n+                    scenario.getBackingScenario().addScenarioModifier(modifier);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void processFacilityEffects(StratconTrackState track) {\n+        // TODO: these are \"weekly\"? effects that a stratcon facility has on the campaign/track state\n+        // currrently, that's\n+        // supply depot - allied - +1 sp\n+        // supply depot - hostile - +5% BV budget to all scenarios on track (shared modifier, so should be implemented there)\n+        // data center - allied - +1% star league cache contract (don't implement yet, but...)\n+        // data center - hostile - +5% scenario odds in track\n+        // industrial center - allied - all scenarios here have THIS IS COMING OUT OF YOUR PAYCHECK modifier\n+        // orbital defense - allied - sets 'no hostile aircraft' flag for track\n+        // orbital defense - hostile - sets 'no allied aircraft' flag for track\n+        // early warning system - allied - sets 'intercept allied base attacks' flag for track\n+        // early warning system - hostile - sets 'intercept hostile base attacks' flag for track\n+    }\n+\n+    /**\n+     * Process the deployment of a force to the given coordinates on the given track.\n+     */\n+    public static void processForceDeployment(StratconCoords coords, int forceID, \n+            Campaign campaign, StratconTrackState track, boolean sticky) {\n+        track.getRevealedCoords().add(coords);\n+        StratconFacility facility = track.getFacility(coords);\n+        if (facility != null) {\n+            facility.setVisible(true);\n+        }\n+\n+        if (campaign.getLances().get(forceID).getRole() == AtBLanceRole.SCOUTING) {\n+            for(int direction = 0; direction < 6; direction++) {\n+                StratconCoords checkCoords = coords.translate(direction);\n+\n+                facility = track.getFacility(checkCoords);\n+                if(facility != null) {\n+                    facility.setVisible(true);\n+                }\n+\n+                track.getRevealedCoords().add(coords.translate(direction));\n+            }\n+        }\n+\n+        // the force may be located in other places on the track - clear it out\n+        track.unassignForce(forceID);\n+        track.assignForce(forceID, coords, campaign.getLocalDate(), sticky);\n+        MekHQ.triggerEvent(new StratconDeploymentEvent(campaign.getForce(forceID)));\n+    }\n+\n+    /**\n+     * Worker function that processes the effects of deploying a reinforcement force to a scenario\n+     */\n+    public static boolean processReinforcementDeployment(ReinforcementEligibilityType reinforcementType,\n+            StratconCampaignState campaignState, StratconScenario scenario, Campaign campaign) {\n+        // if the force is already deployed to the track, we're done\n+        // if the force is a fight lance or we're using a support point\n+        // if there is an SP to burn, burn it and we're done\n+        // if there is a VP to burn, burn it and we're done\n+        // now, roll 2d6 + lance commander tactics\n+        // 9+ = deploy\n+        // 6+ = deploy, apply negative modifier to scenario\n+        // 2+ = fail to deploy, apply negative modifier to scenario; if fight lance, treat as 6+\n+\n+        if ((reinforcementType == ReinforcementEligibilityType.FightLance) ||\n+                (reinforcementType == ReinforcementEligibilityType.SupportPoint)) {\n+\n+            if (campaignState.getSupportPoints() > 0) {\n+                campaignState.useSupportPoint();\n+                return true;\n+            } else if (campaignState.getVictoryPoints() > 0) {\n+                campaignState.updateVictoryPoints(-1);\n+                return true;\n+            }\n+\n+            int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+            int roll = Compute.d6(2);\n+            int result = roll + tactics;\n+\n+            StringBuilder reportStatus = new StringBuilder();\n+            reportStatus.append(String.format(\"Attempting to reinforce scenario %s without SP/VP, roll 2d6 + %d: %d\",\n+                    scenario.getName(), tactics, result));\n+\n+            // fail to reinforce\n+            if ((result < 6) && (reinforcementType != ReinforcementEligibilityType.FightLance)) {\n+                reportStatus.append(\" - reinforcement attempt failed.\");\n+                campaign.addReport(reportStatus.toString());\n+                return false;\n+            // succeed but get an extra negative event added to the scenario\n+            } else if (result < 9) {\n+                MapLocation mapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+                AtBScenarioModifier scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+\n+                // keep rolling until we get an applicable one\n+                // TODO: have the AtBScenarioModifier sort these out instead for performance?\n+                while (scenarioModifier.getEventTiming() != EventTiming.PostForceGeneration) {\n+                    scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+                }\n+\n+                scenarioModifier.processModifier(scenario.getBackingScenario(), campaign, EventTiming.PostForceGeneration);\n+\n+                reportStatus.append(String.format(\" - reinforcement attempt succeeded; extra negative modifier (%s) applied to scenario.\",\n+                        scenarioModifier.getModifierName()));\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            // succeed without reservation\n+            } else {\n+                reportStatus.append(\" - reinforcement attempt succeeded;\");\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            }\n+        } else if (reinforcementType == ReinforcementEligibilityType.None) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Assigns a force to the scenario such that the majority of the force can be deployed\n+     */\n+    private static void assignAppropriateExtraForceToScenario(StratconScenario scenario,\n+            Map<MapLocation, List<Integer>> sortedAvailableForceIDs) {\n+        // the goal of this function is to avoid assigning ground units to air battles\n+        // and ground units/conventional fighters to space battle\n+\n+        List<MapLocation> mapLocations = new ArrayList<>();\n+        mapLocations.add(MapLocation.Space); // can always add ASFs\n+\n+        MapLocation scenarioMapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+\n+        if (scenarioMapLocation == MapLocation.LowAtmosphere) {\n+            mapLocations.add(MapLocation.LowAtmosphere); // can add conventional fighters to ground or low atmo battles\n+        }\n+\n+        if ((scenarioMapLocation == MapLocation.AllGroundTerrain) ||\n+                (scenarioMapLocation == MapLocation.SpecificGroundTerrain)) {\n+            mapLocations.add(MapLocation.AllGroundTerrain); // can only add ground units to ground battles\n+        }\n+\n+        MapLocation selectedLocation = mapLocations.get(Compute.randomInt(mapLocations.size()));\n+        List<Integer> forceIDs = sortedAvailableForceIDs.get(selectedLocation);\n+        int forceIndex = Compute.randomInt(forceIDs.size());\n+        int forceID = forceIDs.get(forceIndex);\n+        forceIDs.remove(forceIndex);\n+\n+        scenario.addPrimaryForce(forceID);\n+    }\n+\n+    /**\n+     * Worker function that \"locks in\" a scenario -\n+     * Adds it to the campaign so it's visible in the briefing room,\n+     * adds it to the track\n+     *\n+     */\n+    public static void commitPrimaryForces(Campaign campaign, StratconScenario scenario, StratconTrackState trackState) {\n+        trackState.addScenario(scenario);\n+\n+        // set up dates for the scenario if doesn't have them already\n+        if (scenario.getDeploymentDate() == null) {\n+            scenario.setDeploymentDate(campaign.getLocalDate());\n+        }\n+\n+        if (scenario.getActionDate() == null) {\n+            scenario.setActionDate(campaign.getLocalDate());\n+        }\n+\n+        if(scenario.getReturnDate() == null) {\n+            scenario.setReturnDate(campaign.getLocalDate().plusDays(trackState.getDeploymentTime()));\n+        }\n+\n+        // set the # of rerolls based on the actual lance assigned.\n+        int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+        scenario.getBackingScenario().setRerolls(tactics);\n+        // The number of defensive points available to a force entering a scenario is\n+        // 2 x tactics. By default, those points are spent on conventional minefields.\n+        if (commanderLanceHasDefensiveAssignment(scenario.getBackingScenario(), campaign)) {\n+            scenario.setNumDefensivePoints(tactics * 2);\n+            scenario.updateMinefieldCount(Minefield.TYPE_CONVENTIONAL, tactics * 2);\n+        }\n+\n+        for (int forceID : scenario.getPlayerTemplateForceIDs()) {\n+            Force force = campaign.getForce(forceID);\n+            force.clearScenarioIds(campaign, true);\n+            force.setScenarioId(scenario.getBackingScenarioID());\n+        }\n+\n+        scenario.commitPrimaryForces();\n+    }\n+\n+    /**\n+     * Utility method to determine if the current scenario's force commander\n+     * is on defence\n+     */\n+    private static boolean commanderLanceHasDefensiveAssignment(AtBDynamicScenario scenario, Campaign campaign) {\n+        Unit commanderUnit = scenario.getLanceCommander(campaign).getUnit();\n+        Lance lance = campaign.getLances().get(commanderUnit.getForceId());\n+\n+        if ((lance != null) && (lance.getRole() == AtBLanceRole.DEFENCE)) {\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * A hackish worker function that takes the given list of force IDs and\n+     * separates it into three sets;\n+     * one of forces that can be \"primary\" on a ground map\n+     * one of forces that can be \"primary\" on an atmospheric map\n+     * one of forces that can be \"primary\" in a space map\n+     * @param forceIDs List of force IDs to check\n+     * @return Sorted hash map\n+     */\n+    private static Map<MapLocation, List<Integer>> sortForcesByMapType(List<Integer> forceIDs, Campaign campaign) {\n+        Map<MapLocation, List<Integer>> retVal = new HashMap<>();\n+\n+        retVal.put(MapLocation.AllGroundTerrain, new ArrayList<>());\n+        retVal.put(MapLocation.LowAtmosphere, new ArrayList<>());\n+        retVal.put(MapLocation.Space, new ArrayList<>());\n+\n+        for (int forceID : forceIDs) {\n+            switch(campaign.getForce(forceID).getPrimaryUnitType(campaign)) {\n+            case UnitType.BATTLE_ARMOR:\n+            case UnitType.INFANTRY:\n+            case UnitType.MEK:\n+            case UnitType.TANK:\n+            case UnitType.PROTOMEK:\n+            case UnitType.VTOL:\n+                retVal.get(MapLocation.AllGroundTerrain).add(forceID);\n+                break;\n+            case UnitType.AERO:\n+                retVal.get(MapLocation.Space).add(forceID);\n+                // intentional fallthrough here, ASFs can go to atmospheric maps too\n+            case UnitType.CONV_FIGHTER:\n+                retVal.get(MapLocation.LowAtmosphere).add(forceID);\n+                break;\n+            }\n+        }\n+", "originalCommit": "b36d9fa6bf982c7b833b1ac0a0473d37f6e84760", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTE5MTY1Mw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r615191653", "bodyText": "Brackets", "author": "Windchild292", "createdAt": "2021-04-17T02:02:14Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1404 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.UUID;\n+\n+import megamek.common.Compute;\n+import megamek.common.Minefield;\n+import megamek.common.UnitType;\n+import megamek.common.annotations.Nullable;\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.Utilities;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.ResolveScenarioTracker;\n+import mekhq.campaign.againstTheBot.enums.AtBLanceRole;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.event.StratconDeploymentEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.force.Lance;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier.EventTiming;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconFacility.FacilityType;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.unit.Unit;\n+\n+/**\n+ * This class contains \"rules\" logic for the AtB-Stratcon state\n+ * @author NickAragua\n+ */\n+public class StratconRulesManager {\n+    /**\n+     * What makes a particular lance eligible to be reinforcements for a scenario\n+     */\n+    public enum ReinforcementEligibilityType {\n+        /**\n+         * Nothing\n+         */\n+        None,\n+\n+        /**\n+         * Lance is already deployed to the track\n+         */\n+        ChainedScenario,\n+\n+        /**\n+         * We pay a support point or convert a victory point to a support point\n+         */\n+        SupportPoint,\n+\n+        /**\n+         * The lance's deployment orders are \"Fight\"\n+         */\n+        FightLance\n+    }\n+\n+    /**\n+     * This function potentially generates non-player-initiated scenarios for the given track.\n+     */\n+    public static void generateScenariosForTrack(Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // maps scenarios to force IDs\n+        List<StratconScenario> generatedScenarios = new ArrayList<>();\n+        boolean autoAssignLances = contract.getCommandRights() == AtBContract.COM_INTEGRATED;\n+\n+        // get this list just so we have it available\n+        List<Integer> availableForceIDs = getAvailableForceIDs(campaign);\n+        Map<MapLocation, List<Integer>> sortedAvailableForceIDs = sortForcesByMapType(availableForceIDs, campaign);\n+\n+        // make X rolls, where X is the number of required lances for the track\n+        // that's the chance to spawn a scenario.\n+        // if a scenario occurs, then we pick a random non-deployed lance and use it to drive the opfor generation later\n+        // once we've determined that scenarios occur, we loop through the ones that we generated\n+        // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all\n+        for (int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            int targetNum = calculateScenarioOdds(track, contract, false);\n+            \n+            // if we haven't already used all the player forces and are required to randomly generate a scenario\n+            if (!availableForceIDs.isEmpty() && (Compute.randomInt(100) <= targetNum)) {\n+                // pick random coordinates and force to drive the scenario\n+                int x = Compute.randomInt(track.getWidth());\n+                int y = Compute.randomInt(track.getHeight());\n+\n+                StratconCoords scenarioCoords = new StratconCoords(x, y);\n+\n+                // if forces are already assigned to these coordinates, use those instead\n+                // of randomly-selected ones\n+                if (track.getAssignedCoordForces().containsKey(scenarioCoords)) {\n+                    StratconScenario scenario = generateScenarioForExistingForces(scenarioCoords,\n+                            track.getAssignedCoordForces().get(scenarioCoords), \n+                            contract, campaign, track);\n+                    generatedScenarios.add(scenario);\n+                    continue;\n+                }\n+                \n+                // otherwise, pick a random force from the avail\n+                int randomForceIndex = Compute.randomInt(availableForceIDs.size());\n+                int randomForceID = availableForceIDs.get(randomForceIndex);\n+                \n+                // remove the force from the available lists so we don't designate it as primary twice\n+                availableForceIDs.remove(randomForceIndex);\n+\n+                // we want to remove the actual int with the value, not the value at the index\n+                sortedAvailableForceIDs.get(MapLocation.AllGroundTerrain).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.LowAtmosphere).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.Space).remove((Integer) randomForceID);\n+\n+                // two scenarios on the same coordinates wind up increasing in size\n+                if (track.getScenarios().containsKey(scenarioCoords)) {\n+                    track.getScenarios().get(scenarioCoords).incrementRequiredPlayerLances();\n+                    assignAppropriateExtraForceToScenario(track.getScenarios().get(scenarioCoords), sortedAvailableForceIDs);\n+                    continue;\n+                }\n+\n+                StratconScenario scenario = setupScenario(scenarioCoords, randomForceID, campaign, contract, track);\n+                generatedScenarios.add(scenario);\n+\n+                // if we're auto-assigning lances, deploy the force to the track as well\n+                if (autoAssignLances) {\n+                    processForceDeployment(scenarioCoords, randomForceID, campaign, track, false);\n+                }\n+            }\n+        }\n+\n+        // if under liaison command, pick a random scenario from the ones generated\n+        // to set as required and attach liaison\n+        if (contract.getCommandRights() == AtBContract.COM_LIAISON) {\n+        \tStratconScenario randomScenario = Utilities.getRandomItem(generatedScenarios);\n+        \trandomScenario.setRequiredScenario(true);\n+            setAttachedUnitsModifier(randomScenario, contract);\n+        }\n+\n+        // now, we loop through all the scenarios we set up\n+        // and generate the opfors / events / etc\n+        // if not auto-assigning lances, we then back out the lance assignments.\n+        for (StratconScenario scenario : generatedScenarios) {\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+\n+            if(!autoAssignLances && !scenario.ignoreForceAutoAssignment()) {\n+                for(int forceID : scenario.getPlayerTemplateForceIDs()) {\n+                    scenario.getBackingScenario().removeForce(forceID);\n+                }\n+\n+                scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                track.addScenario(scenario);\n+            } else {\n+                commitPrimaryForces(campaign, scenario, track);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Given a set of force IDs and coordinates, generate a scenario\n+     * Useful for when we want to generate scenarios \n+     * for forces already deployed to a track\n+     */\n+    public static StratconScenario generateScenarioForExistingForces(StratconCoords scenarioCoords, \n+            Set<Integer> forceIDs, AtBContract contract, Campaign campaign, StratconTrackState track) {\n+        boolean firstForce = true;\n+        StratconScenario scenario = null;\n+        \n+        for (int forceID : forceIDs) {\n+            if (firstForce) {\n+                scenario = setupScenario(scenarioCoords, forceID, campaign, contract, track);\n+                firstForce = false;\n+            } else {\n+                scenario.incrementRequiredPlayerLances();\n+                scenario.addPrimaryForce(forceID);\n+            }\n+        }\n+        \n+        // this is theoretically possible if forceIDs is passed in as null - not likely in practice\n+        // but might as well, to future-proof.\n+        if (scenario != null) {\n+            scenario.setIgnoreForceAutoAssignment(true);\n+        }\n+        \n+        return scenario;\n+    }\n+\n+    /**\n+     * Deploys a force to the given coordinates on the given track as a result of explicit player action.\n+     */\n+    public static void deployForceToCoords(StratconCoords coords, int forceID, \n+            Campaign campaign, AtBContract contract, StratconTrackState track, boolean sticky) {\n+        // the following things should happen:\n+        // 1. call to \"process force deployment\", which reveals fog of war in or around the coords, depending on force role\n+        // 2. if coords are a hostile facility, we get a facility mission\n+        // 3. if coords are empty, we *may* get a mission\n+\n+        processForceDeployment(coords, forceID, campaign, track, sticky);\n+\n+        // don't create a scenario on top of allied facilities\n+        StratconFacility facility = track.getFacility(coords);\n+        boolean isNonAlliedFacility = (facility != null) && (facility.getOwner() != ForceAlignment.Allied);\n+        int targetNum = calculateScenarioOdds(track, contract, true);\n+        boolean spawnScenario = (facility == null) && (Compute.randomInt(100) <= targetNum);\n+\n+        if (isNonAlliedFacility || spawnScenario) {\n+            StratconScenario scenario = setupScenario(coords, forceID, campaign, contract, track);\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            commitPrimaryForces(campaign, scenario, track);\n+        }\n+    }\n+\n+    /**\n+     * Logic to set up a scenario\n+     */\n+    private static StratconScenario setupScenario(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        StratconScenario scenario = null;\n+\n+        if (track.getFacilities().containsKey(coords)) {\n+            StratconFacility facility = track.getFacility(coords);\n+            boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+            ScenarioTemplate template = StratconScenarioFactory.getFacilityScenario(alliedFacility);\n+            scenario = generateScenario(campaign, contract, track, forceID, coords, template);\n+            setupFacilityScenario(scenario, facility);\n+        } else {\n+            scenario = generateScenario(campaign, contract, track, forceID, coords);\n+\n+            // we may generate a facility scenario randomly - if so, do the facility-related stuff\n+            // and add a new facility to the track\n+            if (scenario.getBackingScenario().getTemplate().isFacilityScenario()) {\n+                StratconFacility facility = scenario.getBackingScenario().getTemplate().isHostileFacility() ?\n+                        StratconFacilityFactory.getRandomHostileFacility() : StratconFacilityFactory.getRandomAlliedFacility();\n+                facility.setVisible(true);\n+                track.addFacility(coords, facility);\n+                setupFacilityScenario(scenario, facility);\n+            }\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * carries out tasks relevant to facility scenarios\n+     */\n+    private static void setupFacilityScenario(StratconScenario scenario, StratconFacility facility) {\n+        // this includes:\n+        // for hostile facilities\n+        // - add a destroy objective (always the option to level the facility)\n+        // - add a capture objective (always the option to capture the facility)\n+        // - if so indicated by parameter, roll a random hostile facility objective and add it if not capture/destroy\n+        // for allied facilities\n+        // - add a defend objective (always the option to defend the facility)\n+        // - if so indicated by parameter, roll a random allied facility objective and add it if not defend\n+        AtBScenarioModifier objectiveModifier = null;\n+        boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+\n+        if (alliedFacility) {\n+            objectiveModifier = AtBScenarioModifier.getRandomAlliedFacilityModifier();\n+        } else {\n+            objectiveModifier = AtBScenarioModifier.getRandomHostileFacilityModifier();\n+        }\n+\n+        if (objectiveModifier != null) {\n+            scenario.getBackingScenario().addScenarioModifier(objectiveModifier);\n+            scenario.getBackingScenario().setName(String.format(\"%s - %s - %s\",\n+                    facility.getFacilityType(), alliedFacility ? \"Allied\" : \"Hostile\", objectiveModifier.getModifierName()));\n+        }\n+\n+        // add the \"fixed\" hostile facility modifiers after the primary ones\n+        if (!alliedFacility) {\n+            for(AtBScenarioModifier modifier : AtBScenarioModifier.getRequiredHostileFacilityModifiers()) {\n+                if(!scenario.getBackingScenario().alreadyHasModifier(modifier)) {\n+                    scenario.getBackingScenario().addScenarioModifier(modifier);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void processFacilityEffects(StratconTrackState track) {\n+        // TODO: these are \"weekly\"? effects that a stratcon facility has on the campaign/track state\n+        // currrently, that's\n+        // supply depot - allied - +1 sp\n+        // supply depot - hostile - +5% BV budget to all scenarios on track (shared modifier, so should be implemented there)\n+        // data center - allied - +1% star league cache contract (don't implement yet, but...)\n+        // data center - hostile - +5% scenario odds in track\n+        // industrial center - allied - all scenarios here have THIS IS COMING OUT OF YOUR PAYCHECK modifier\n+        // orbital defense - allied - sets 'no hostile aircraft' flag for track\n+        // orbital defense - hostile - sets 'no allied aircraft' flag for track\n+        // early warning system - allied - sets 'intercept allied base attacks' flag for track\n+        // early warning system - hostile - sets 'intercept hostile base attacks' flag for track\n+    }\n+\n+    /**\n+     * Process the deployment of a force to the given coordinates on the given track.\n+     */\n+    public static void processForceDeployment(StratconCoords coords, int forceID, \n+            Campaign campaign, StratconTrackState track, boolean sticky) {\n+        track.getRevealedCoords().add(coords);\n+        StratconFacility facility = track.getFacility(coords);\n+        if (facility != null) {\n+            facility.setVisible(true);\n+        }\n+\n+        if (campaign.getLances().get(forceID).getRole() == AtBLanceRole.SCOUTING) {\n+            for(int direction = 0; direction < 6; direction++) {\n+                StratconCoords checkCoords = coords.translate(direction);\n+\n+                facility = track.getFacility(checkCoords);\n+                if(facility != null) {\n+                    facility.setVisible(true);\n+                }\n+\n+                track.getRevealedCoords().add(coords.translate(direction));\n+            }\n+        }\n+\n+        // the force may be located in other places on the track - clear it out\n+        track.unassignForce(forceID);\n+        track.assignForce(forceID, coords, campaign.getLocalDate(), sticky);\n+        MekHQ.triggerEvent(new StratconDeploymentEvent(campaign.getForce(forceID)));\n+    }\n+\n+    /**\n+     * Worker function that processes the effects of deploying a reinforcement force to a scenario\n+     */\n+    public static boolean processReinforcementDeployment(ReinforcementEligibilityType reinforcementType,\n+            StratconCampaignState campaignState, StratconScenario scenario, Campaign campaign) {\n+        // if the force is already deployed to the track, we're done\n+        // if the force is a fight lance or we're using a support point\n+        // if there is an SP to burn, burn it and we're done\n+        // if there is a VP to burn, burn it and we're done\n+        // now, roll 2d6 + lance commander tactics\n+        // 9+ = deploy\n+        // 6+ = deploy, apply negative modifier to scenario\n+        // 2+ = fail to deploy, apply negative modifier to scenario; if fight lance, treat as 6+\n+\n+        if ((reinforcementType == ReinforcementEligibilityType.FightLance) ||\n+                (reinforcementType == ReinforcementEligibilityType.SupportPoint)) {\n+\n+            if (campaignState.getSupportPoints() > 0) {\n+                campaignState.useSupportPoint();\n+                return true;\n+            } else if (campaignState.getVictoryPoints() > 0) {\n+                campaignState.updateVictoryPoints(-1);\n+                return true;\n+            }\n+\n+            int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+            int roll = Compute.d6(2);\n+            int result = roll + tactics;\n+\n+            StringBuilder reportStatus = new StringBuilder();\n+            reportStatus.append(String.format(\"Attempting to reinforce scenario %s without SP/VP, roll 2d6 + %d: %d\",\n+                    scenario.getName(), tactics, result));\n+\n+            // fail to reinforce\n+            if ((result < 6) && (reinforcementType != ReinforcementEligibilityType.FightLance)) {\n+                reportStatus.append(\" - reinforcement attempt failed.\");\n+                campaign.addReport(reportStatus.toString());\n+                return false;\n+            // succeed but get an extra negative event added to the scenario\n+            } else if (result < 9) {\n+                MapLocation mapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+                AtBScenarioModifier scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+\n+                // keep rolling until we get an applicable one\n+                // TODO: have the AtBScenarioModifier sort these out instead for performance?\n+                while (scenarioModifier.getEventTiming() != EventTiming.PostForceGeneration) {\n+                    scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+                }\n+\n+                scenarioModifier.processModifier(scenario.getBackingScenario(), campaign, EventTiming.PostForceGeneration);\n+\n+                reportStatus.append(String.format(\" - reinforcement attempt succeeded; extra negative modifier (%s) applied to scenario.\",\n+                        scenarioModifier.getModifierName()));\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            // succeed without reservation\n+            } else {\n+                reportStatus.append(\" - reinforcement attempt succeeded;\");\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            }\n+        } else if (reinforcementType == ReinforcementEligibilityType.None) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Assigns a force to the scenario such that the majority of the force can be deployed\n+     */\n+    private static void assignAppropriateExtraForceToScenario(StratconScenario scenario,\n+            Map<MapLocation, List<Integer>> sortedAvailableForceIDs) {\n+        // the goal of this function is to avoid assigning ground units to air battles\n+        // and ground units/conventional fighters to space battle\n+\n+        List<MapLocation> mapLocations = new ArrayList<>();\n+        mapLocations.add(MapLocation.Space); // can always add ASFs\n+\n+        MapLocation scenarioMapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+\n+        if (scenarioMapLocation == MapLocation.LowAtmosphere) {\n+            mapLocations.add(MapLocation.LowAtmosphere); // can add conventional fighters to ground or low atmo battles\n+        }\n+\n+        if ((scenarioMapLocation == MapLocation.AllGroundTerrain) ||\n+                (scenarioMapLocation == MapLocation.SpecificGroundTerrain)) {\n+            mapLocations.add(MapLocation.AllGroundTerrain); // can only add ground units to ground battles\n+        }\n+\n+        MapLocation selectedLocation = mapLocations.get(Compute.randomInt(mapLocations.size()));\n+        List<Integer> forceIDs = sortedAvailableForceIDs.get(selectedLocation);\n+        int forceIndex = Compute.randomInt(forceIDs.size());\n+        int forceID = forceIDs.get(forceIndex);\n+        forceIDs.remove(forceIndex);\n+\n+        scenario.addPrimaryForce(forceID);\n+    }\n+\n+    /**\n+     * Worker function that \"locks in\" a scenario -\n+     * Adds it to the campaign so it's visible in the briefing room,\n+     * adds it to the track\n+     *\n+     */\n+    public static void commitPrimaryForces(Campaign campaign, StratconScenario scenario, StratconTrackState trackState) {\n+        trackState.addScenario(scenario);\n+\n+        // set up dates for the scenario if doesn't have them already\n+        if (scenario.getDeploymentDate() == null) {\n+            scenario.setDeploymentDate(campaign.getLocalDate());\n+        }\n+\n+        if (scenario.getActionDate() == null) {\n+            scenario.setActionDate(campaign.getLocalDate());\n+        }\n+\n+        if(scenario.getReturnDate() == null) {\n+            scenario.setReturnDate(campaign.getLocalDate().plusDays(trackState.getDeploymentTime()));\n+        }\n+\n+        // set the # of rerolls based on the actual lance assigned.\n+        int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+        scenario.getBackingScenario().setRerolls(tactics);\n+        // The number of defensive points available to a force entering a scenario is\n+        // 2 x tactics. By default, those points are spent on conventional minefields.\n+        if (commanderLanceHasDefensiveAssignment(scenario.getBackingScenario(), campaign)) {\n+            scenario.setNumDefensivePoints(tactics * 2);\n+            scenario.updateMinefieldCount(Minefield.TYPE_CONVENTIONAL, tactics * 2);\n+        }\n+\n+        for (int forceID : scenario.getPlayerTemplateForceIDs()) {\n+            Force force = campaign.getForce(forceID);\n+            force.clearScenarioIds(campaign, true);\n+            force.setScenarioId(scenario.getBackingScenarioID());\n+        }\n+\n+        scenario.commitPrimaryForces();\n+    }\n+\n+    /**\n+     * Utility method to determine if the current scenario's force commander\n+     * is on defence\n+     */\n+    private static boolean commanderLanceHasDefensiveAssignment(AtBDynamicScenario scenario, Campaign campaign) {\n+        Unit commanderUnit = scenario.getLanceCommander(campaign).getUnit();\n+        Lance lance = campaign.getLances().get(commanderUnit.getForceId());\n+\n+        if ((lance != null) && (lance.getRole() == AtBLanceRole.DEFENCE)) {\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * A hackish worker function that takes the given list of force IDs and\n+     * separates it into three sets;\n+     * one of forces that can be \"primary\" on a ground map\n+     * one of forces that can be \"primary\" on an atmospheric map\n+     * one of forces that can be \"primary\" in a space map\n+     * @param forceIDs List of force IDs to check\n+     * @return Sorted hash map\n+     */\n+    private static Map<MapLocation, List<Integer>> sortForcesByMapType(List<Integer> forceIDs, Campaign campaign) {\n+        Map<MapLocation, List<Integer>> retVal = new HashMap<>();\n+\n+        retVal.put(MapLocation.AllGroundTerrain, new ArrayList<>());\n+        retVal.put(MapLocation.LowAtmosphere, new ArrayList<>());\n+        retVal.put(MapLocation.Space, new ArrayList<>());\n+\n+        for (int forceID : forceIDs) {\n+            switch(campaign.getForce(forceID).getPrimaryUnitType(campaign)) {\n+            case UnitType.BATTLE_ARMOR:\n+            case UnitType.INFANTRY:\n+            case UnitType.MEK:\n+            case UnitType.TANK:\n+            case UnitType.PROTOMEK:\n+            case UnitType.VTOL:\n+                retVal.get(MapLocation.AllGroundTerrain).add(forceID);\n+                break;\n+            case UnitType.AERO:\n+                retVal.get(MapLocation.Space).add(forceID);\n+                // intentional fallthrough here, ASFs can go to atmospheric maps too\n+            case UnitType.CONV_FIGHTER:\n+                retVal.get(MapLocation.LowAtmosphere).add(forceID);\n+                break;\n+            }\n+        }\n+\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * Determine whether the user should be nagged about unresolved scenarios on AtB Stratcon tracks.\n+     * @param campaign Campaign to check.\n+     * @return An informative string containing the reasons the user was nagged.\n+     */\n+    public static String nagUnresolvedContacts(Campaign campaign) {\n+        StringBuilder sb = new StringBuilder();\n+\n+        // check every track attached to an active contract for unresolved scenarios\n+        // to which the player must deploy forces today\n+        for (AtBContract contract : campaign.getActiveAtBContracts()) {\n+            if (contract.getStratconCampaignState() == null) {\n+                continue;\n+            }\n+            \n+            for (StratconTrackState track : contract.getStratconCampaignState().getTracks()) {\n+                for (StratconScenario scenario : track.getScenarios().values()) {\n+                    if (scenario.getCurrentState() == ScenarioState.UNRESOLVED &&", "originalCommit": "b36d9fa6bf982c7b833b1ac0a0473d37f6e84760", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTE5MTc1Mg==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r615191752", "bodyText": "Aggro Rating, not x", "author": "Windchild292", "createdAt": "2021-04-17T02:03:49Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1404 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.UUID;\n+\n+import megamek.common.Compute;\n+import megamek.common.Minefield;\n+import megamek.common.UnitType;\n+import megamek.common.annotations.Nullable;\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.Utilities;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.ResolveScenarioTracker;\n+import mekhq.campaign.againstTheBot.enums.AtBLanceRole;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.event.StratconDeploymentEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.force.Lance;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier.EventTiming;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconFacility.FacilityType;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.unit.Unit;\n+\n+/**\n+ * This class contains \"rules\" logic for the AtB-Stratcon state\n+ * @author NickAragua\n+ */\n+public class StratconRulesManager {\n+    /**\n+     * What makes a particular lance eligible to be reinforcements for a scenario\n+     */\n+    public enum ReinforcementEligibilityType {\n+        /**\n+         * Nothing\n+         */\n+        None,\n+\n+        /**\n+         * Lance is already deployed to the track\n+         */\n+        ChainedScenario,\n+\n+        /**\n+         * We pay a support point or convert a victory point to a support point\n+         */\n+        SupportPoint,\n+\n+        /**\n+         * The lance's deployment orders are \"Fight\"\n+         */\n+        FightLance\n+    }\n+\n+    /**\n+     * This function potentially generates non-player-initiated scenarios for the given track.\n+     */\n+    public static void generateScenariosForTrack(Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // maps scenarios to force IDs\n+        List<StratconScenario> generatedScenarios = new ArrayList<>();\n+        boolean autoAssignLances = contract.getCommandRights() == AtBContract.COM_INTEGRATED;\n+\n+        // get this list just so we have it available\n+        List<Integer> availableForceIDs = getAvailableForceIDs(campaign);\n+        Map<MapLocation, List<Integer>> sortedAvailableForceIDs = sortForcesByMapType(availableForceIDs, campaign);\n+\n+        // make X rolls, where X is the number of required lances for the track\n+        // that's the chance to spawn a scenario.\n+        // if a scenario occurs, then we pick a random non-deployed lance and use it to drive the opfor generation later\n+        // once we've determined that scenarios occur, we loop through the ones that we generated\n+        // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all\n+        for (int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            int targetNum = calculateScenarioOdds(track, contract, false);\n+            \n+            // if we haven't already used all the player forces and are required to randomly generate a scenario\n+            if (!availableForceIDs.isEmpty() && (Compute.randomInt(100) <= targetNum)) {\n+                // pick random coordinates and force to drive the scenario\n+                int x = Compute.randomInt(track.getWidth());\n+                int y = Compute.randomInt(track.getHeight());\n+\n+                StratconCoords scenarioCoords = new StratconCoords(x, y);\n+\n+                // if forces are already assigned to these coordinates, use those instead\n+                // of randomly-selected ones\n+                if (track.getAssignedCoordForces().containsKey(scenarioCoords)) {\n+                    StratconScenario scenario = generateScenarioForExistingForces(scenarioCoords,\n+                            track.getAssignedCoordForces().get(scenarioCoords), \n+                            contract, campaign, track);\n+                    generatedScenarios.add(scenario);\n+                    continue;\n+                }\n+                \n+                // otherwise, pick a random force from the avail\n+                int randomForceIndex = Compute.randomInt(availableForceIDs.size());\n+                int randomForceID = availableForceIDs.get(randomForceIndex);\n+                \n+                // remove the force from the available lists so we don't designate it as primary twice\n+                availableForceIDs.remove(randomForceIndex);\n+\n+                // we want to remove the actual int with the value, not the value at the index\n+                sortedAvailableForceIDs.get(MapLocation.AllGroundTerrain).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.LowAtmosphere).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.Space).remove((Integer) randomForceID);\n+\n+                // two scenarios on the same coordinates wind up increasing in size\n+                if (track.getScenarios().containsKey(scenarioCoords)) {\n+                    track.getScenarios().get(scenarioCoords).incrementRequiredPlayerLances();\n+                    assignAppropriateExtraForceToScenario(track.getScenarios().get(scenarioCoords), sortedAvailableForceIDs);\n+                    continue;\n+                }\n+\n+                StratconScenario scenario = setupScenario(scenarioCoords, randomForceID, campaign, contract, track);\n+                generatedScenarios.add(scenario);\n+\n+                // if we're auto-assigning lances, deploy the force to the track as well\n+                if (autoAssignLances) {\n+                    processForceDeployment(scenarioCoords, randomForceID, campaign, track, false);\n+                }\n+            }\n+        }\n+\n+        // if under liaison command, pick a random scenario from the ones generated\n+        // to set as required and attach liaison\n+        if (contract.getCommandRights() == AtBContract.COM_LIAISON) {\n+        \tStratconScenario randomScenario = Utilities.getRandomItem(generatedScenarios);\n+        \trandomScenario.setRequiredScenario(true);\n+            setAttachedUnitsModifier(randomScenario, contract);\n+        }\n+\n+        // now, we loop through all the scenarios we set up\n+        // and generate the opfors / events / etc\n+        // if not auto-assigning lances, we then back out the lance assignments.\n+        for (StratconScenario scenario : generatedScenarios) {\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+\n+            if(!autoAssignLances && !scenario.ignoreForceAutoAssignment()) {\n+                for(int forceID : scenario.getPlayerTemplateForceIDs()) {\n+                    scenario.getBackingScenario().removeForce(forceID);\n+                }\n+\n+                scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                track.addScenario(scenario);\n+            } else {\n+                commitPrimaryForces(campaign, scenario, track);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Given a set of force IDs and coordinates, generate a scenario\n+     * Useful for when we want to generate scenarios \n+     * for forces already deployed to a track\n+     */\n+    public static StratconScenario generateScenarioForExistingForces(StratconCoords scenarioCoords, \n+            Set<Integer> forceIDs, AtBContract contract, Campaign campaign, StratconTrackState track) {\n+        boolean firstForce = true;\n+        StratconScenario scenario = null;\n+        \n+        for (int forceID : forceIDs) {\n+            if (firstForce) {\n+                scenario = setupScenario(scenarioCoords, forceID, campaign, contract, track);\n+                firstForce = false;\n+            } else {\n+                scenario.incrementRequiredPlayerLances();\n+                scenario.addPrimaryForce(forceID);\n+            }\n+        }\n+        \n+        // this is theoretically possible if forceIDs is passed in as null - not likely in practice\n+        // but might as well, to future-proof.\n+        if (scenario != null) {\n+            scenario.setIgnoreForceAutoAssignment(true);\n+        }\n+        \n+        return scenario;\n+    }\n+\n+    /**\n+     * Deploys a force to the given coordinates on the given track as a result of explicit player action.\n+     */\n+    public static void deployForceToCoords(StratconCoords coords, int forceID, \n+            Campaign campaign, AtBContract contract, StratconTrackState track, boolean sticky) {\n+        // the following things should happen:\n+        // 1. call to \"process force deployment\", which reveals fog of war in or around the coords, depending on force role\n+        // 2. if coords are a hostile facility, we get a facility mission\n+        // 3. if coords are empty, we *may* get a mission\n+\n+        processForceDeployment(coords, forceID, campaign, track, sticky);\n+\n+        // don't create a scenario on top of allied facilities\n+        StratconFacility facility = track.getFacility(coords);\n+        boolean isNonAlliedFacility = (facility != null) && (facility.getOwner() != ForceAlignment.Allied);\n+        int targetNum = calculateScenarioOdds(track, contract, true);\n+        boolean spawnScenario = (facility == null) && (Compute.randomInt(100) <= targetNum);\n+\n+        if (isNonAlliedFacility || spawnScenario) {\n+            StratconScenario scenario = setupScenario(coords, forceID, campaign, contract, track);\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            commitPrimaryForces(campaign, scenario, track);\n+        }\n+    }\n+\n+    /**\n+     * Logic to set up a scenario\n+     */\n+    private static StratconScenario setupScenario(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        StratconScenario scenario = null;\n+\n+        if (track.getFacilities().containsKey(coords)) {\n+            StratconFacility facility = track.getFacility(coords);\n+            boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+            ScenarioTemplate template = StratconScenarioFactory.getFacilityScenario(alliedFacility);\n+            scenario = generateScenario(campaign, contract, track, forceID, coords, template);\n+            setupFacilityScenario(scenario, facility);\n+        } else {\n+            scenario = generateScenario(campaign, contract, track, forceID, coords);\n+\n+            // we may generate a facility scenario randomly - if so, do the facility-related stuff\n+            // and add a new facility to the track\n+            if (scenario.getBackingScenario().getTemplate().isFacilityScenario()) {\n+                StratconFacility facility = scenario.getBackingScenario().getTemplate().isHostileFacility() ?\n+                        StratconFacilityFactory.getRandomHostileFacility() : StratconFacilityFactory.getRandomAlliedFacility();\n+                facility.setVisible(true);\n+                track.addFacility(coords, facility);\n+                setupFacilityScenario(scenario, facility);\n+            }\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * carries out tasks relevant to facility scenarios\n+     */\n+    private static void setupFacilityScenario(StratconScenario scenario, StratconFacility facility) {\n+        // this includes:\n+        // for hostile facilities\n+        // - add a destroy objective (always the option to level the facility)\n+        // - add a capture objective (always the option to capture the facility)\n+        // - if so indicated by parameter, roll a random hostile facility objective and add it if not capture/destroy\n+        // for allied facilities\n+        // - add a defend objective (always the option to defend the facility)\n+        // - if so indicated by parameter, roll a random allied facility objective and add it if not defend\n+        AtBScenarioModifier objectiveModifier = null;\n+        boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+\n+        if (alliedFacility) {\n+            objectiveModifier = AtBScenarioModifier.getRandomAlliedFacilityModifier();\n+        } else {\n+            objectiveModifier = AtBScenarioModifier.getRandomHostileFacilityModifier();\n+        }\n+\n+        if (objectiveModifier != null) {\n+            scenario.getBackingScenario().addScenarioModifier(objectiveModifier);\n+            scenario.getBackingScenario().setName(String.format(\"%s - %s - %s\",\n+                    facility.getFacilityType(), alliedFacility ? \"Allied\" : \"Hostile\", objectiveModifier.getModifierName()));\n+        }\n+\n+        // add the \"fixed\" hostile facility modifiers after the primary ones\n+        if (!alliedFacility) {\n+            for(AtBScenarioModifier modifier : AtBScenarioModifier.getRequiredHostileFacilityModifiers()) {\n+                if(!scenario.getBackingScenario().alreadyHasModifier(modifier)) {\n+                    scenario.getBackingScenario().addScenarioModifier(modifier);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void processFacilityEffects(StratconTrackState track) {\n+        // TODO: these are \"weekly\"? effects that a stratcon facility has on the campaign/track state\n+        // currrently, that's\n+        // supply depot - allied - +1 sp\n+        // supply depot - hostile - +5% BV budget to all scenarios on track (shared modifier, so should be implemented there)\n+        // data center - allied - +1% star league cache contract (don't implement yet, but...)\n+        // data center - hostile - +5% scenario odds in track\n+        // industrial center - allied - all scenarios here have THIS IS COMING OUT OF YOUR PAYCHECK modifier\n+        // orbital defense - allied - sets 'no hostile aircraft' flag for track\n+        // orbital defense - hostile - sets 'no allied aircraft' flag for track\n+        // early warning system - allied - sets 'intercept allied base attacks' flag for track\n+        // early warning system - hostile - sets 'intercept hostile base attacks' flag for track\n+    }\n+\n+    /**\n+     * Process the deployment of a force to the given coordinates on the given track.\n+     */\n+    public static void processForceDeployment(StratconCoords coords, int forceID, \n+            Campaign campaign, StratconTrackState track, boolean sticky) {\n+        track.getRevealedCoords().add(coords);\n+        StratconFacility facility = track.getFacility(coords);\n+        if (facility != null) {\n+            facility.setVisible(true);\n+        }\n+\n+        if (campaign.getLances().get(forceID).getRole() == AtBLanceRole.SCOUTING) {\n+            for(int direction = 0; direction < 6; direction++) {\n+                StratconCoords checkCoords = coords.translate(direction);\n+\n+                facility = track.getFacility(checkCoords);\n+                if(facility != null) {\n+                    facility.setVisible(true);\n+                }\n+\n+                track.getRevealedCoords().add(coords.translate(direction));\n+            }\n+        }\n+\n+        // the force may be located in other places on the track - clear it out\n+        track.unassignForce(forceID);\n+        track.assignForce(forceID, coords, campaign.getLocalDate(), sticky);\n+        MekHQ.triggerEvent(new StratconDeploymentEvent(campaign.getForce(forceID)));\n+    }\n+\n+    /**\n+     * Worker function that processes the effects of deploying a reinforcement force to a scenario\n+     */\n+    public static boolean processReinforcementDeployment(ReinforcementEligibilityType reinforcementType,\n+            StratconCampaignState campaignState, StratconScenario scenario, Campaign campaign) {\n+        // if the force is already deployed to the track, we're done\n+        // if the force is a fight lance or we're using a support point\n+        // if there is an SP to burn, burn it and we're done\n+        // if there is a VP to burn, burn it and we're done\n+        // now, roll 2d6 + lance commander tactics\n+        // 9+ = deploy\n+        // 6+ = deploy, apply negative modifier to scenario\n+        // 2+ = fail to deploy, apply negative modifier to scenario; if fight lance, treat as 6+\n+\n+        if ((reinforcementType == ReinforcementEligibilityType.FightLance) ||\n+                (reinforcementType == ReinforcementEligibilityType.SupportPoint)) {\n+\n+            if (campaignState.getSupportPoints() > 0) {\n+                campaignState.useSupportPoint();\n+                return true;\n+            } else if (campaignState.getVictoryPoints() > 0) {\n+                campaignState.updateVictoryPoints(-1);\n+                return true;\n+            }\n+\n+            int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+            int roll = Compute.d6(2);\n+            int result = roll + tactics;\n+\n+            StringBuilder reportStatus = new StringBuilder();\n+            reportStatus.append(String.format(\"Attempting to reinforce scenario %s without SP/VP, roll 2d6 + %d: %d\",\n+                    scenario.getName(), tactics, result));\n+\n+            // fail to reinforce\n+            if ((result < 6) && (reinforcementType != ReinforcementEligibilityType.FightLance)) {\n+                reportStatus.append(\" - reinforcement attempt failed.\");\n+                campaign.addReport(reportStatus.toString());\n+                return false;\n+            // succeed but get an extra negative event added to the scenario\n+            } else if (result < 9) {\n+                MapLocation mapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+                AtBScenarioModifier scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+\n+                // keep rolling until we get an applicable one\n+                // TODO: have the AtBScenarioModifier sort these out instead for performance?\n+                while (scenarioModifier.getEventTiming() != EventTiming.PostForceGeneration) {\n+                    scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+                }\n+\n+                scenarioModifier.processModifier(scenario.getBackingScenario(), campaign, EventTiming.PostForceGeneration);\n+\n+                reportStatus.append(String.format(\" - reinforcement attempt succeeded; extra negative modifier (%s) applied to scenario.\",\n+                        scenarioModifier.getModifierName()));\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            // succeed without reservation\n+            } else {\n+                reportStatus.append(\" - reinforcement attempt succeeded;\");\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            }\n+        } else if (reinforcementType == ReinforcementEligibilityType.None) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Assigns a force to the scenario such that the majority of the force can be deployed\n+     */\n+    private static void assignAppropriateExtraForceToScenario(StratconScenario scenario,\n+            Map<MapLocation, List<Integer>> sortedAvailableForceIDs) {\n+        // the goal of this function is to avoid assigning ground units to air battles\n+        // and ground units/conventional fighters to space battle\n+\n+        List<MapLocation> mapLocations = new ArrayList<>();\n+        mapLocations.add(MapLocation.Space); // can always add ASFs\n+\n+        MapLocation scenarioMapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+\n+        if (scenarioMapLocation == MapLocation.LowAtmosphere) {\n+            mapLocations.add(MapLocation.LowAtmosphere); // can add conventional fighters to ground or low atmo battles\n+        }\n+\n+        if ((scenarioMapLocation == MapLocation.AllGroundTerrain) ||\n+                (scenarioMapLocation == MapLocation.SpecificGroundTerrain)) {\n+            mapLocations.add(MapLocation.AllGroundTerrain); // can only add ground units to ground battles\n+        }\n+\n+        MapLocation selectedLocation = mapLocations.get(Compute.randomInt(mapLocations.size()));\n+        List<Integer> forceIDs = sortedAvailableForceIDs.get(selectedLocation);\n+        int forceIndex = Compute.randomInt(forceIDs.size());\n+        int forceID = forceIDs.get(forceIndex);\n+        forceIDs.remove(forceIndex);\n+\n+        scenario.addPrimaryForce(forceID);\n+    }\n+\n+    /**\n+     * Worker function that \"locks in\" a scenario -\n+     * Adds it to the campaign so it's visible in the briefing room,\n+     * adds it to the track\n+     *\n+     */\n+    public static void commitPrimaryForces(Campaign campaign, StratconScenario scenario, StratconTrackState trackState) {\n+        trackState.addScenario(scenario);\n+\n+        // set up dates for the scenario if doesn't have them already\n+        if (scenario.getDeploymentDate() == null) {\n+            scenario.setDeploymentDate(campaign.getLocalDate());\n+        }\n+\n+        if (scenario.getActionDate() == null) {\n+            scenario.setActionDate(campaign.getLocalDate());\n+        }\n+\n+        if(scenario.getReturnDate() == null) {\n+            scenario.setReturnDate(campaign.getLocalDate().plusDays(trackState.getDeploymentTime()));\n+        }\n+\n+        // set the # of rerolls based on the actual lance assigned.\n+        int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+        scenario.getBackingScenario().setRerolls(tactics);\n+        // The number of defensive points available to a force entering a scenario is\n+        // 2 x tactics. By default, those points are spent on conventional minefields.\n+        if (commanderLanceHasDefensiveAssignment(scenario.getBackingScenario(), campaign)) {\n+            scenario.setNumDefensivePoints(tactics * 2);\n+            scenario.updateMinefieldCount(Minefield.TYPE_CONVENTIONAL, tactics * 2);\n+        }\n+\n+        for (int forceID : scenario.getPlayerTemplateForceIDs()) {\n+            Force force = campaign.getForce(forceID);\n+            force.clearScenarioIds(campaign, true);\n+            force.setScenarioId(scenario.getBackingScenarioID());\n+        }\n+\n+        scenario.commitPrimaryForces();\n+    }\n+\n+    /**\n+     * Utility method to determine if the current scenario's force commander\n+     * is on defence\n+     */\n+    private static boolean commanderLanceHasDefensiveAssignment(AtBDynamicScenario scenario, Campaign campaign) {\n+        Unit commanderUnit = scenario.getLanceCommander(campaign).getUnit();\n+        Lance lance = campaign.getLances().get(commanderUnit.getForceId());\n+\n+        if ((lance != null) && (lance.getRole() == AtBLanceRole.DEFENCE)) {\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * A hackish worker function that takes the given list of force IDs and\n+     * separates it into three sets;\n+     * one of forces that can be \"primary\" on a ground map\n+     * one of forces that can be \"primary\" on an atmospheric map\n+     * one of forces that can be \"primary\" in a space map\n+     * @param forceIDs List of force IDs to check\n+     * @return Sorted hash map\n+     */\n+    private static Map<MapLocation, List<Integer>> sortForcesByMapType(List<Integer> forceIDs, Campaign campaign) {\n+        Map<MapLocation, List<Integer>> retVal = new HashMap<>();\n+\n+        retVal.put(MapLocation.AllGroundTerrain, new ArrayList<>());\n+        retVal.put(MapLocation.LowAtmosphere, new ArrayList<>());\n+        retVal.put(MapLocation.Space, new ArrayList<>());\n+\n+        for (int forceID : forceIDs) {\n+            switch(campaign.getForce(forceID).getPrimaryUnitType(campaign)) {\n+            case UnitType.BATTLE_ARMOR:\n+            case UnitType.INFANTRY:\n+            case UnitType.MEK:\n+            case UnitType.TANK:\n+            case UnitType.PROTOMEK:\n+            case UnitType.VTOL:\n+                retVal.get(MapLocation.AllGroundTerrain).add(forceID);\n+                break;\n+            case UnitType.AERO:\n+                retVal.get(MapLocation.Space).add(forceID);\n+                // intentional fallthrough here, ASFs can go to atmospheric maps too\n+            case UnitType.CONV_FIGHTER:\n+                retVal.get(MapLocation.LowAtmosphere).add(forceID);\n+                break;\n+            }\n+        }\n+\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * Determine whether the user should be nagged about unresolved scenarios on AtB Stratcon tracks.\n+     * @param campaign Campaign to check.\n+     * @return An informative string containing the reasons the user was nagged.\n+     */\n+    public static String nagUnresolvedContacts(Campaign campaign) {\n+        StringBuilder sb = new StringBuilder();\n+\n+        // check every track attached to an active contract for unresolved scenarios\n+        // to which the player must deploy forces today\n+        for (AtBContract contract : campaign.getActiveAtBContracts()) {\n+            if (contract.getStratconCampaignState() == null) {\n+                continue;\n+            }\n+            \n+            for (StratconTrackState track : contract.getStratconCampaignState().getTracks()) {\n+                for (StratconScenario scenario : track.getScenarios().values()) {\n+                    if (scenario.getCurrentState() == ScenarioState.UNRESOLVED &&\n+                            campaign.getLocalDate().equals(scenario.getDeploymentDate())) {\n+                        // \"scenario name, track name\"\n+                        sb.append(String.format(\"%s, %s\\n\", scenario.getName(), track.getDisplayableName()));\n+                    }\n+                }\n+            }\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track.\n+     * Also registers it with the track and campaign.\n+     */\n+    private static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords) {\n+        int unitType = campaign.getForce(forceID).getPrimaryUnitType(campaign);\n+        ScenarioTemplate template = StratconScenarioFactory.getRandomScenario(unitType);\n+        // useful for debugging specific scenario types\n+        //ScenarioTemplate template = StratconScenarioFactory.getSpecificScenario(\"Hostile Facility.xml\");\n+\n+        return generateScenario(campaign, contract, track, forceID, coords, template);\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track,\n+     * using the given template. Also registers it with the campaign.\n+     */\n+    static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords, ScenarioTemplate template) {\n+        StratconScenario scenario = new StratconScenario();\n+        \n+        AtBDynamicScenario backingScenario = AtBDynamicScenarioFactory.initializeScenarioFromTemplate(template, contract, campaign);        \n+        scenario.setBackingScenario(backingScenario);\n+        scenario.setCoords(coords);\n+        \n+        // by default, certain conditions may make this bigger\n+        scenario.setRequiredPlayerLances(1);\n+\n+        // do an appropriate allied force if the contract calls for it\n+        // do any attached or integrated units\n+        setAlliedForceModifier(scenario, contract);\n+        setAttachedUnitsModifier(scenario, contract);\n+        applyFacilityModifiers(scenario, track, coords);\n+        applyGlobalModifiers(scenario, contract.getStratconCampaignState());\n+\n+        if ((contract.getCommandRights() == AtBContract.COM_HOUSE) ||\n+                (contract.getCommandRights() == AtBContract.COM_INTEGRATED)) {\n+            scenario.setRequiredScenario(true);\n+        }\n+\n+        AtBDynamicScenarioFactory.setScenarioModifiers(scenario.getBackingScenario());\n+        scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+        setScenarioDates(track, campaign, scenario);\n+        \n+        // the backing scenario ID must be updated after registering the backing scenario \n+        // with the campaign, so that the stratcon - backing scenario association is maintained\n+        // registering the scenario with the campaign should be done after setting\n+        // dates, otherwise, the report messages for new scenarios look weird\n+        campaign.addScenario(backingScenario, contract);\n+        scenario.setBackingScenarioID(backingScenario.getId());\n+        \n+        if (forceID > Force.FORCE_NONE) {\n+            scenario.addPrimaryForce(forceID);\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * Apply global scenario modifiers from campaign state to given scenario.\n+     */\n+    private static void applyGlobalModifiers(StratconScenario scenario, StratconCampaignState campaignState) {\n+        for (String modifierName : campaignState.getGlobalScenarioModifiers()) {\n+            AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierName);\n+\n+            if (modifier == null) {\n+                MekHQ.getLogger().error(String.format(\"Modifier %s not found; ignoring\", modifierName));\n+                continue;\n+            }\n+\n+            scenario.getBackingScenario().addScenarioModifier(modifier);\n+        }\n+    }\n+\n+    /**\n+     * Applies scenario modifiers from the current track to the given scenario.\n+     * @param scenario\n+     * @param track\n+     */\n+    private static void applyFacilityModifiers(StratconScenario scenario, StratconTrackState track, StratconCoords coords) {\n+        // loop through all the facilities on the track\n+        // if a facility has been revealed, then it has a 100% chance to apply its effect\n+        // if a facility has not been revealed, then it has a x% chance to apply its effect", "originalCommit": "b36d9fa6bf982c7b833b1ac0a0473d37f6e84760", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTE5MTc4OA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r615191788", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // if a facility is on the the scenario coordinates the it applies the local effects\n          \n          \n            \n                    // if a facility is on the the scenario coordinates, then it applies the local effects", "author": "Windchild292", "createdAt": "2021-04-17T02:04:09Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1404 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.UUID;\n+\n+import megamek.common.Compute;\n+import megamek.common.Minefield;\n+import megamek.common.UnitType;\n+import megamek.common.annotations.Nullable;\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.Utilities;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.ResolveScenarioTracker;\n+import mekhq.campaign.againstTheBot.enums.AtBLanceRole;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.event.StratconDeploymentEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.force.Lance;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier.EventTiming;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconFacility.FacilityType;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.unit.Unit;\n+\n+/**\n+ * This class contains \"rules\" logic for the AtB-Stratcon state\n+ * @author NickAragua\n+ */\n+public class StratconRulesManager {\n+    /**\n+     * What makes a particular lance eligible to be reinforcements for a scenario\n+     */\n+    public enum ReinforcementEligibilityType {\n+        /**\n+         * Nothing\n+         */\n+        None,\n+\n+        /**\n+         * Lance is already deployed to the track\n+         */\n+        ChainedScenario,\n+\n+        /**\n+         * We pay a support point or convert a victory point to a support point\n+         */\n+        SupportPoint,\n+\n+        /**\n+         * The lance's deployment orders are \"Fight\"\n+         */\n+        FightLance\n+    }\n+\n+    /**\n+     * This function potentially generates non-player-initiated scenarios for the given track.\n+     */\n+    public static void generateScenariosForTrack(Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // maps scenarios to force IDs\n+        List<StratconScenario> generatedScenarios = new ArrayList<>();\n+        boolean autoAssignLances = contract.getCommandRights() == AtBContract.COM_INTEGRATED;\n+\n+        // get this list just so we have it available\n+        List<Integer> availableForceIDs = getAvailableForceIDs(campaign);\n+        Map<MapLocation, List<Integer>> sortedAvailableForceIDs = sortForcesByMapType(availableForceIDs, campaign);\n+\n+        // make X rolls, where X is the number of required lances for the track\n+        // that's the chance to spawn a scenario.\n+        // if a scenario occurs, then we pick a random non-deployed lance and use it to drive the opfor generation later\n+        // once we've determined that scenarios occur, we loop through the ones that we generated\n+        // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all\n+        for (int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            int targetNum = calculateScenarioOdds(track, contract, false);\n+            \n+            // if we haven't already used all the player forces and are required to randomly generate a scenario\n+            if (!availableForceIDs.isEmpty() && (Compute.randomInt(100) <= targetNum)) {\n+                // pick random coordinates and force to drive the scenario\n+                int x = Compute.randomInt(track.getWidth());\n+                int y = Compute.randomInt(track.getHeight());\n+\n+                StratconCoords scenarioCoords = new StratconCoords(x, y);\n+\n+                // if forces are already assigned to these coordinates, use those instead\n+                // of randomly-selected ones\n+                if (track.getAssignedCoordForces().containsKey(scenarioCoords)) {\n+                    StratconScenario scenario = generateScenarioForExistingForces(scenarioCoords,\n+                            track.getAssignedCoordForces().get(scenarioCoords), \n+                            contract, campaign, track);\n+                    generatedScenarios.add(scenario);\n+                    continue;\n+                }\n+                \n+                // otherwise, pick a random force from the avail\n+                int randomForceIndex = Compute.randomInt(availableForceIDs.size());\n+                int randomForceID = availableForceIDs.get(randomForceIndex);\n+                \n+                // remove the force from the available lists so we don't designate it as primary twice\n+                availableForceIDs.remove(randomForceIndex);\n+\n+                // we want to remove the actual int with the value, not the value at the index\n+                sortedAvailableForceIDs.get(MapLocation.AllGroundTerrain).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.LowAtmosphere).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.Space).remove((Integer) randomForceID);\n+\n+                // two scenarios on the same coordinates wind up increasing in size\n+                if (track.getScenarios().containsKey(scenarioCoords)) {\n+                    track.getScenarios().get(scenarioCoords).incrementRequiredPlayerLances();\n+                    assignAppropriateExtraForceToScenario(track.getScenarios().get(scenarioCoords), sortedAvailableForceIDs);\n+                    continue;\n+                }\n+\n+                StratconScenario scenario = setupScenario(scenarioCoords, randomForceID, campaign, contract, track);\n+                generatedScenarios.add(scenario);\n+\n+                // if we're auto-assigning lances, deploy the force to the track as well\n+                if (autoAssignLances) {\n+                    processForceDeployment(scenarioCoords, randomForceID, campaign, track, false);\n+                }\n+            }\n+        }\n+\n+        // if under liaison command, pick a random scenario from the ones generated\n+        // to set as required and attach liaison\n+        if (contract.getCommandRights() == AtBContract.COM_LIAISON) {\n+        \tStratconScenario randomScenario = Utilities.getRandomItem(generatedScenarios);\n+        \trandomScenario.setRequiredScenario(true);\n+            setAttachedUnitsModifier(randomScenario, contract);\n+        }\n+\n+        // now, we loop through all the scenarios we set up\n+        // and generate the opfors / events / etc\n+        // if not auto-assigning lances, we then back out the lance assignments.\n+        for (StratconScenario scenario : generatedScenarios) {\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+\n+            if(!autoAssignLances && !scenario.ignoreForceAutoAssignment()) {\n+                for(int forceID : scenario.getPlayerTemplateForceIDs()) {\n+                    scenario.getBackingScenario().removeForce(forceID);\n+                }\n+\n+                scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                track.addScenario(scenario);\n+            } else {\n+                commitPrimaryForces(campaign, scenario, track);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Given a set of force IDs and coordinates, generate a scenario\n+     * Useful for when we want to generate scenarios \n+     * for forces already deployed to a track\n+     */\n+    public static StratconScenario generateScenarioForExistingForces(StratconCoords scenarioCoords, \n+            Set<Integer> forceIDs, AtBContract contract, Campaign campaign, StratconTrackState track) {\n+        boolean firstForce = true;\n+        StratconScenario scenario = null;\n+        \n+        for (int forceID : forceIDs) {\n+            if (firstForce) {\n+                scenario = setupScenario(scenarioCoords, forceID, campaign, contract, track);\n+                firstForce = false;\n+            } else {\n+                scenario.incrementRequiredPlayerLances();\n+                scenario.addPrimaryForce(forceID);\n+            }\n+        }\n+        \n+        // this is theoretically possible if forceIDs is passed in as null - not likely in practice\n+        // but might as well, to future-proof.\n+        if (scenario != null) {\n+            scenario.setIgnoreForceAutoAssignment(true);\n+        }\n+        \n+        return scenario;\n+    }\n+\n+    /**\n+     * Deploys a force to the given coordinates on the given track as a result of explicit player action.\n+     */\n+    public static void deployForceToCoords(StratconCoords coords, int forceID, \n+            Campaign campaign, AtBContract contract, StratconTrackState track, boolean sticky) {\n+        // the following things should happen:\n+        // 1. call to \"process force deployment\", which reveals fog of war in or around the coords, depending on force role\n+        // 2. if coords are a hostile facility, we get a facility mission\n+        // 3. if coords are empty, we *may* get a mission\n+\n+        processForceDeployment(coords, forceID, campaign, track, sticky);\n+\n+        // don't create a scenario on top of allied facilities\n+        StratconFacility facility = track.getFacility(coords);\n+        boolean isNonAlliedFacility = (facility != null) && (facility.getOwner() != ForceAlignment.Allied);\n+        int targetNum = calculateScenarioOdds(track, contract, true);\n+        boolean spawnScenario = (facility == null) && (Compute.randomInt(100) <= targetNum);\n+\n+        if (isNonAlliedFacility || spawnScenario) {\n+            StratconScenario scenario = setupScenario(coords, forceID, campaign, contract, track);\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            commitPrimaryForces(campaign, scenario, track);\n+        }\n+    }\n+\n+    /**\n+     * Logic to set up a scenario\n+     */\n+    private static StratconScenario setupScenario(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        StratconScenario scenario = null;\n+\n+        if (track.getFacilities().containsKey(coords)) {\n+            StratconFacility facility = track.getFacility(coords);\n+            boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+            ScenarioTemplate template = StratconScenarioFactory.getFacilityScenario(alliedFacility);\n+            scenario = generateScenario(campaign, contract, track, forceID, coords, template);\n+            setupFacilityScenario(scenario, facility);\n+        } else {\n+            scenario = generateScenario(campaign, contract, track, forceID, coords);\n+\n+            // we may generate a facility scenario randomly - if so, do the facility-related stuff\n+            // and add a new facility to the track\n+            if (scenario.getBackingScenario().getTemplate().isFacilityScenario()) {\n+                StratconFacility facility = scenario.getBackingScenario().getTemplate().isHostileFacility() ?\n+                        StratconFacilityFactory.getRandomHostileFacility() : StratconFacilityFactory.getRandomAlliedFacility();\n+                facility.setVisible(true);\n+                track.addFacility(coords, facility);\n+                setupFacilityScenario(scenario, facility);\n+            }\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * carries out tasks relevant to facility scenarios\n+     */\n+    private static void setupFacilityScenario(StratconScenario scenario, StratconFacility facility) {\n+        // this includes:\n+        // for hostile facilities\n+        // - add a destroy objective (always the option to level the facility)\n+        // - add a capture objective (always the option to capture the facility)\n+        // - if so indicated by parameter, roll a random hostile facility objective and add it if not capture/destroy\n+        // for allied facilities\n+        // - add a defend objective (always the option to defend the facility)\n+        // - if so indicated by parameter, roll a random allied facility objective and add it if not defend\n+        AtBScenarioModifier objectiveModifier = null;\n+        boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+\n+        if (alliedFacility) {\n+            objectiveModifier = AtBScenarioModifier.getRandomAlliedFacilityModifier();\n+        } else {\n+            objectiveModifier = AtBScenarioModifier.getRandomHostileFacilityModifier();\n+        }\n+\n+        if (objectiveModifier != null) {\n+            scenario.getBackingScenario().addScenarioModifier(objectiveModifier);\n+            scenario.getBackingScenario().setName(String.format(\"%s - %s - %s\",\n+                    facility.getFacilityType(), alliedFacility ? \"Allied\" : \"Hostile\", objectiveModifier.getModifierName()));\n+        }\n+\n+        // add the \"fixed\" hostile facility modifiers after the primary ones\n+        if (!alliedFacility) {\n+            for(AtBScenarioModifier modifier : AtBScenarioModifier.getRequiredHostileFacilityModifiers()) {\n+                if(!scenario.getBackingScenario().alreadyHasModifier(modifier)) {\n+                    scenario.getBackingScenario().addScenarioModifier(modifier);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void processFacilityEffects(StratconTrackState track) {\n+        // TODO: these are \"weekly\"? effects that a stratcon facility has on the campaign/track state\n+        // currrently, that's\n+        // supply depot - allied - +1 sp\n+        // supply depot - hostile - +5% BV budget to all scenarios on track (shared modifier, so should be implemented there)\n+        // data center - allied - +1% star league cache contract (don't implement yet, but...)\n+        // data center - hostile - +5% scenario odds in track\n+        // industrial center - allied - all scenarios here have THIS IS COMING OUT OF YOUR PAYCHECK modifier\n+        // orbital defense - allied - sets 'no hostile aircraft' flag for track\n+        // orbital defense - hostile - sets 'no allied aircraft' flag for track\n+        // early warning system - allied - sets 'intercept allied base attacks' flag for track\n+        // early warning system - hostile - sets 'intercept hostile base attacks' flag for track\n+    }\n+\n+    /**\n+     * Process the deployment of a force to the given coordinates on the given track.\n+     */\n+    public static void processForceDeployment(StratconCoords coords, int forceID, \n+            Campaign campaign, StratconTrackState track, boolean sticky) {\n+        track.getRevealedCoords().add(coords);\n+        StratconFacility facility = track.getFacility(coords);\n+        if (facility != null) {\n+            facility.setVisible(true);\n+        }\n+\n+        if (campaign.getLances().get(forceID).getRole() == AtBLanceRole.SCOUTING) {\n+            for(int direction = 0; direction < 6; direction++) {\n+                StratconCoords checkCoords = coords.translate(direction);\n+\n+                facility = track.getFacility(checkCoords);\n+                if(facility != null) {\n+                    facility.setVisible(true);\n+                }\n+\n+                track.getRevealedCoords().add(coords.translate(direction));\n+            }\n+        }\n+\n+        // the force may be located in other places on the track - clear it out\n+        track.unassignForce(forceID);\n+        track.assignForce(forceID, coords, campaign.getLocalDate(), sticky);\n+        MekHQ.triggerEvent(new StratconDeploymentEvent(campaign.getForce(forceID)));\n+    }\n+\n+    /**\n+     * Worker function that processes the effects of deploying a reinforcement force to a scenario\n+     */\n+    public static boolean processReinforcementDeployment(ReinforcementEligibilityType reinforcementType,\n+            StratconCampaignState campaignState, StratconScenario scenario, Campaign campaign) {\n+        // if the force is already deployed to the track, we're done\n+        // if the force is a fight lance or we're using a support point\n+        // if there is an SP to burn, burn it and we're done\n+        // if there is a VP to burn, burn it and we're done\n+        // now, roll 2d6 + lance commander tactics\n+        // 9+ = deploy\n+        // 6+ = deploy, apply negative modifier to scenario\n+        // 2+ = fail to deploy, apply negative modifier to scenario; if fight lance, treat as 6+\n+\n+        if ((reinforcementType == ReinforcementEligibilityType.FightLance) ||\n+                (reinforcementType == ReinforcementEligibilityType.SupportPoint)) {\n+\n+            if (campaignState.getSupportPoints() > 0) {\n+                campaignState.useSupportPoint();\n+                return true;\n+            } else if (campaignState.getVictoryPoints() > 0) {\n+                campaignState.updateVictoryPoints(-1);\n+                return true;\n+            }\n+\n+            int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+            int roll = Compute.d6(2);\n+            int result = roll + tactics;\n+\n+            StringBuilder reportStatus = new StringBuilder();\n+            reportStatus.append(String.format(\"Attempting to reinforce scenario %s without SP/VP, roll 2d6 + %d: %d\",\n+                    scenario.getName(), tactics, result));\n+\n+            // fail to reinforce\n+            if ((result < 6) && (reinforcementType != ReinforcementEligibilityType.FightLance)) {\n+                reportStatus.append(\" - reinforcement attempt failed.\");\n+                campaign.addReport(reportStatus.toString());\n+                return false;\n+            // succeed but get an extra negative event added to the scenario\n+            } else if (result < 9) {\n+                MapLocation mapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+                AtBScenarioModifier scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+\n+                // keep rolling until we get an applicable one\n+                // TODO: have the AtBScenarioModifier sort these out instead for performance?\n+                while (scenarioModifier.getEventTiming() != EventTiming.PostForceGeneration) {\n+                    scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+                }\n+\n+                scenarioModifier.processModifier(scenario.getBackingScenario(), campaign, EventTiming.PostForceGeneration);\n+\n+                reportStatus.append(String.format(\" - reinforcement attempt succeeded; extra negative modifier (%s) applied to scenario.\",\n+                        scenarioModifier.getModifierName()));\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            // succeed without reservation\n+            } else {\n+                reportStatus.append(\" - reinforcement attempt succeeded;\");\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            }\n+        } else if (reinforcementType == ReinforcementEligibilityType.None) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Assigns a force to the scenario such that the majority of the force can be deployed\n+     */\n+    private static void assignAppropriateExtraForceToScenario(StratconScenario scenario,\n+            Map<MapLocation, List<Integer>> sortedAvailableForceIDs) {\n+        // the goal of this function is to avoid assigning ground units to air battles\n+        // and ground units/conventional fighters to space battle\n+\n+        List<MapLocation> mapLocations = new ArrayList<>();\n+        mapLocations.add(MapLocation.Space); // can always add ASFs\n+\n+        MapLocation scenarioMapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+\n+        if (scenarioMapLocation == MapLocation.LowAtmosphere) {\n+            mapLocations.add(MapLocation.LowAtmosphere); // can add conventional fighters to ground or low atmo battles\n+        }\n+\n+        if ((scenarioMapLocation == MapLocation.AllGroundTerrain) ||\n+                (scenarioMapLocation == MapLocation.SpecificGroundTerrain)) {\n+            mapLocations.add(MapLocation.AllGroundTerrain); // can only add ground units to ground battles\n+        }\n+\n+        MapLocation selectedLocation = mapLocations.get(Compute.randomInt(mapLocations.size()));\n+        List<Integer> forceIDs = sortedAvailableForceIDs.get(selectedLocation);\n+        int forceIndex = Compute.randomInt(forceIDs.size());\n+        int forceID = forceIDs.get(forceIndex);\n+        forceIDs.remove(forceIndex);\n+\n+        scenario.addPrimaryForce(forceID);\n+    }\n+\n+    /**\n+     * Worker function that \"locks in\" a scenario -\n+     * Adds it to the campaign so it's visible in the briefing room,\n+     * adds it to the track\n+     *\n+     */\n+    public static void commitPrimaryForces(Campaign campaign, StratconScenario scenario, StratconTrackState trackState) {\n+        trackState.addScenario(scenario);\n+\n+        // set up dates for the scenario if doesn't have them already\n+        if (scenario.getDeploymentDate() == null) {\n+            scenario.setDeploymentDate(campaign.getLocalDate());\n+        }\n+\n+        if (scenario.getActionDate() == null) {\n+            scenario.setActionDate(campaign.getLocalDate());\n+        }\n+\n+        if(scenario.getReturnDate() == null) {\n+            scenario.setReturnDate(campaign.getLocalDate().plusDays(trackState.getDeploymentTime()));\n+        }\n+\n+        // set the # of rerolls based on the actual lance assigned.\n+        int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+        scenario.getBackingScenario().setRerolls(tactics);\n+        // The number of defensive points available to a force entering a scenario is\n+        // 2 x tactics. By default, those points are spent on conventional minefields.\n+        if (commanderLanceHasDefensiveAssignment(scenario.getBackingScenario(), campaign)) {\n+            scenario.setNumDefensivePoints(tactics * 2);\n+            scenario.updateMinefieldCount(Minefield.TYPE_CONVENTIONAL, tactics * 2);\n+        }\n+\n+        for (int forceID : scenario.getPlayerTemplateForceIDs()) {\n+            Force force = campaign.getForce(forceID);\n+            force.clearScenarioIds(campaign, true);\n+            force.setScenarioId(scenario.getBackingScenarioID());\n+        }\n+\n+        scenario.commitPrimaryForces();\n+    }\n+\n+    /**\n+     * Utility method to determine if the current scenario's force commander\n+     * is on defence\n+     */\n+    private static boolean commanderLanceHasDefensiveAssignment(AtBDynamicScenario scenario, Campaign campaign) {\n+        Unit commanderUnit = scenario.getLanceCommander(campaign).getUnit();\n+        Lance lance = campaign.getLances().get(commanderUnit.getForceId());\n+\n+        if ((lance != null) && (lance.getRole() == AtBLanceRole.DEFENCE)) {\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * A hackish worker function that takes the given list of force IDs and\n+     * separates it into three sets;\n+     * one of forces that can be \"primary\" on a ground map\n+     * one of forces that can be \"primary\" on an atmospheric map\n+     * one of forces that can be \"primary\" in a space map\n+     * @param forceIDs List of force IDs to check\n+     * @return Sorted hash map\n+     */\n+    private static Map<MapLocation, List<Integer>> sortForcesByMapType(List<Integer> forceIDs, Campaign campaign) {\n+        Map<MapLocation, List<Integer>> retVal = new HashMap<>();\n+\n+        retVal.put(MapLocation.AllGroundTerrain, new ArrayList<>());\n+        retVal.put(MapLocation.LowAtmosphere, new ArrayList<>());\n+        retVal.put(MapLocation.Space, new ArrayList<>());\n+\n+        for (int forceID : forceIDs) {\n+            switch(campaign.getForce(forceID).getPrimaryUnitType(campaign)) {\n+            case UnitType.BATTLE_ARMOR:\n+            case UnitType.INFANTRY:\n+            case UnitType.MEK:\n+            case UnitType.TANK:\n+            case UnitType.PROTOMEK:\n+            case UnitType.VTOL:\n+                retVal.get(MapLocation.AllGroundTerrain).add(forceID);\n+                break;\n+            case UnitType.AERO:\n+                retVal.get(MapLocation.Space).add(forceID);\n+                // intentional fallthrough here, ASFs can go to atmospheric maps too\n+            case UnitType.CONV_FIGHTER:\n+                retVal.get(MapLocation.LowAtmosphere).add(forceID);\n+                break;\n+            }\n+        }\n+\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * Determine whether the user should be nagged about unresolved scenarios on AtB Stratcon tracks.\n+     * @param campaign Campaign to check.\n+     * @return An informative string containing the reasons the user was nagged.\n+     */\n+    public static String nagUnresolvedContacts(Campaign campaign) {\n+        StringBuilder sb = new StringBuilder();\n+\n+        // check every track attached to an active contract for unresolved scenarios\n+        // to which the player must deploy forces today\n+        for (AtBContract contract : campaign.getActiveAtBContracts()) {\n+            if (contract.getStratconCampaignState() == null) {\n+                continue;\n+            }\n+            \n+            for (StratconTrackState track : contract.getStratconCampaignState().getTracks()) {\n+                for (StratconScenario scenario : track.getScenarios().values()) {\n+                    if (scenario.getCurrentState() == ScenarioState.UNRESOLVED &&\n+                            campaign.getLocalDate().equals(scenario.getDeploymentDate())) {\n+                        // \"scenario name, track name\"\n+                        sb.append(String.format(\"%s, %s\\n\", scenario.getName(), track.getDisplayableName()));\n+                    }\n+                }\n+            }\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track.\n+     * Also registers it with the track and campaign.\n+     */\n+    private static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords) {\n+        int unitType = campaign.getForce(forceID).getPrimaryUnitType(campaign);\n+        ScenarioTemplate template = StratconScenarioFactory.getRandomScenario(unitType);\n+        // useful for debugging specific scenario types\n+        //ScenarioTemplate template = StratconScenarioFactory.getSpecificScenario(\"Hostile Facility.xml\");\n+\n+        return generateScenario(campaign, contract, track, forceID, coords, template);\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track,\n+     * using the given template. Also registers it with the campaign.\n+     */\n+    static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords, ScenarioTemplate template) {\n+        StratconScenario scenario = new StratconScenario();\n+        \n+        AtBDynamicScenario backingScenario = AtBDynamicScenarioFactory.initializeScenarioFromTemplate(template, contract, campaign);        \n+        scenario.setBackingScenario(backingScenario);\n+        scenario.setCoords(coords);\n+        \n+        // by default, certain conditions may make this bigger\n+        scenario.setRequiredPlayerLances(1);\n+\n+        // do an appropriate allied force if the contract calls for it\n+        // do any attached or integrated units\n+        setAlliedForceModifier(scenario, contract);\n+        setAttachedUnitsModifier(scenario, contract);\n+        applyFacilityModifiers(scenario, track, coords);\n+        applyGlobalModifiers(scenario, contract.getStratconCampaignState());\n+\n+        if ((contract.getCommandRights() == AtBContract.COM_HOUSE) ||\n+                (contract.getCommandRights() == AtBContract.COM_INTEGRATED)) {\n+            scenario.setRequiredScenario(true);\n+        }\n+\n+        AtBDynamicScenarioFactory.setScenarioModifiers(scenario.getBackingScenario());\n+        scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+        setScenarioDates(track, campaign, scenario);\n+        \n+        // the backing scenario ID must be updated after registering the backing scenario \n+        // with the campaign, so that the stratcon - backing scenario association is maintained\n+        // registering the scenario with the campaign should be done after setting\n+        // dates, otherwise, the report messages for new scenarios look weird\n+        campaign.addScenario(backingScenario, contract);\n+        scenario.setBackingScenarioID(backingScenario.getId());\n+        \n+        if (forceID > Force.FORCE_NONE) {\n+            scenario.addPrimaryForce(forceID);\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * Apply global scenario modifiers from campaign state to given scenario.\n+     */\n+    private static void applyGlobalModifiers(StratconScenario scenario, StratconCampaignState campaignState) {\n+        for (String modifierName : campaignState.getGlobalScenarioModifiers()) {\n+            AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierName);\n+\n+            if (modifier == null) {\n+                MekHQ.getLogger().error(String.format(\"Modifier %s not found; ignoring\", modifierName));\n+                continue;\n+            }\n+\n+            scenario.getBackingScenario().addScenarioModifier(modifier);\n+        }\n+    }\n+\n+    /**\n+     * Applies scenario modifiers from the current track to the given scenario.\n+     * @param scenario\n+     * @param track\n+     */\n+    private static void applyFacilityModifiers(StratconScenario scenario, StratconTrackState track, StratconCoords coords) {\n+        // loop through all the facilities on the track\n+        // if a facility has been revealed, then it has a 100% chance to apply its effect\n+        // if a facility has not been revealed, then it has a x% chance to apply its effect\n+        // if a facility is on the the scenario coordinates the it applies the local effects", "originalCommit": "b36d9fa6bf982c7b833b1ac0a0473d37f6e84760", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTE5MTgxNA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r615191814", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if(modifier == null) {\n          \n          \n            \n                            if (modifier == null) {", "author": "Windchild292", "createdAt": "2021-04-17T02:04:30Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1404 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.UUID;\n+\n+import megamek.common.Compute;\n+import megamek.common.Minefield;\n+import megamek.common.UnitType;\n+import megamek.common.annotations.Nullable;\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.Utilities;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.ResolveScenarioTracker;\n+import mekhq.campaign.againstTheBot.enums.AtBLanceRole;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.event.StratconDeploymentEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.force.Lance;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier.EventTiming;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconFacility.FacilityType;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.unit.Unit;\n+\n+/**\n+ * This class contains \"rules\" logic for the AtB-Stratcon state\n+ * @author NickAragua\n+ */\n+public class StratconRulesManager {\n+    /**\n+     * What makes a particular lance eligible to be reinforcements for a scenario\n+     */\n+    public enum ReinforcementEligibilityType {\n+        /**\n+         * Nothing\n+         */\n+        None,\n+\n+        /**\n+         * Lance is already deployed to the track\n+         */\n+        ChainedScenario,\n+\n+        /**\n+         * We pay a support point or convert a victory point to a support point\n+         */\n+        SupportPoint,\n+\n+        /**\n+         * The lance's deployment orders are \"Fight\"\n+         */\n+        FightLance\n+    }\n+\n+    /**\n+     * This function potentially generates non-player-initiated scenarios for the given track.\n+     */\n+    public static void generateScenariosForTrack(Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // maps scenarios to force IDs\n+        List<StratconScenario> generatedScenarios = new ArrayList<>();\n+        boolean autoAssignLances = contract.getCommandRights() == AtBContract.COM_INTEGRATED;\n+\n+        // get this list just so we have it available\n+        List<Integer> availableForceIDs = getAvailableForceIDs(campaign);\n+        Map<MapLocation, List<Integer>> sortedAvailableForceIDs = sortForcesByMapType(availableForceIDs, campaign);\n+\n+        // make X rolls, where X is the number of required lances for the track\n+        // that's the chance to spawn a scenario.\n+        // if a scenario occurs, then we pick a random non-deployed lance and use it to drive the opfor generation later\n+        // once we've determined that scenarios occur, we loop through the ones that we generated\n+        // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all\n+        for (int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            int targetNum = calculateScenarioOdds(track, contract, false);\n+            \n+            // if we haven't already used all the player forces and are required to randomly generate a scenario\n+            if (!availableForceIDs.isEmpty() && (Compute.randomInt(100) <= targetNum)) {\n+                // pick random coordinates and force to drive the scenario\n+                int x = Compute.randomInt(track.getWidth());\n+                int y = Compute.randomInt(track.getHeight());\n+\n+                StratconCoords scenarioCoords = new StratconCoords(x, y);\n+\n+                // if forces are already assigned to these coordinates, use those instead\n+                // of randomly-selected ones\n+                if (track.getAssignedCoordForces().containsKey(scenarioCoords)) {\n+                    StratconScenario scenario = generateScenarioForExistingForces(scenarioCoords,\n+                            track.getAssignedCoordForces().get(scenarioCoords), \n+                            contract, campaign, track);\n+                    generatedScenarios.add(scenario);\n+                    continue;\n+                }\n+                \n+                // otherwise, pick a random force from the avail\n+                int randomForceIndex = Compute.randomInt(availableForceIDs.size());\n+                int randomForceID = availableForceIDs.get(randomForceIndex);\n+                \n+                // remove the force from the available lists so we don't designate it as primary twice\n+                availableForceIDs.remove(randomForceIndex);\n+\n+                // we want to remove the actual int with the value, not the value at the index\n+                sortedAvailableForceIDs.get(MapLocation.AllGroundTerrain).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.LowAtmosphere).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.Space).remove((Integer) randomForceID);\n+\n+                // two scenarios on the same coordinates wind up increasing in size\n+                if (track.getScenarios().containsKey(scenarioCoords)) {\n+                    track.getScenarios().get(scenarioCoords).incrementRequiredPlayerLances();\n+                    assignAppropriateExtraForceToScenario(track.getScenarios().get(scenarioCoords), sortedAvailableForceIDs);\n+                    continue;\n+                }\n+\n+                StratconScenario scenario = setupScenario(scenarioCoords, randomForceID, campaign, contract, track);\n+                generatedScenarios.add(scenario);\n+\n+                // if we're auto-assigning lances, deploy the force to the track as well\n+                if (autoAssignLances) {\n+                    processForceDeployment(scenarioCoords, randomForceID, campaign, track, false);\n+                }\n+            }\n+        }\n+\n+        // if under liaison command, pick a random scenario from the ones generated\n+        // to set as required and attach liaison\n+        if (contract.getCommandRights() == AtBContract.COM_LIAISON) {\n+        \tStratconScenario randomScenario = Utilities.getRandomItem(generatedScenarios);\n+        \trandomScenario.setRequiredScenario(true);\n+            setAttachedUnitsModifier(randomScenario, contract);\n+        }\n+\n+        // now, we loop through all the scenarios we set up\n+        // and generate the opfors / events / etc\n+        // if not auto-assigning lances, we then back out the lance assignments.\n+        for (StratconScenario scenario : generatedScenarios) {\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+\n+            if(!autoAssignLances && !scenario.ignoreForceAutoAssignment()) {\n+                for(int forceID : scenario.getPlayerTemplateForceIDs()) {\n+                    scenario.getBackingScenario().removeForce(forceID);\n+                }\n+\n+                scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                track.addScenario(scenario);\n+            } else {\n+                commitPrimaryForces(campaign, scenario, track);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Given a set of force IDs and coordinates, generate a scenario\n+     * Useful for when we want to generate scenarios \n+     * for forces already deployed to a track\n+     */\n+    public static StratconScenario generateScenarioForExistingForces(StratconCoords scenarioCoords, \n+            Set<Integer> forceIDs, AtBContract contract, Campaign campaign, StratconTrackState track) {\n+        boolean firstForce = true;\n+        StratconScenario scenario = null;\n+        \n+        for (int forceID : forceIDs) {\n+            if (firstForce) {\n+                scenario = setupScenario(scenarioCoords, forceID, campaign, contract, track);\n+                firstForce = false;\n+            } else {\n+                scenario.incrementRequiredPlayerLances();\n+                scenario.addPrimaryForce(forceID);\n+            }\n+        }\n+        \n+        // this is theoretically possible if forceIDs is passed in as null - not likely in practice\n+        // but might as well, to future-proof.\n+        if (scenario != null) {\n+            scenario.setIgnoreForceAutoAssignment(true);\n+        }\n+        \n+        return scenario;\n+    }\n+\n+    /**\n+     * Deploys a force to the given coordinates on the given track as a result of explicit player action.\n+     */\n+    public static void deployForceToCoords(StratconCoords coords, int forceID, \n+            Campaign campaign, AtBContract contract, StratconTrackState track, boolean sticky) {\n+        // the following things should happen:\n+        // 1. call to \"process force deployment\", which reveals fog of war in or around the coords, depending on force role\n+        // 2. if coords are a hostile facility, we get a facility mission\n+        // 3. if coords are empty, we *may* get a mission\n+\n+        processForceDeployment(coords, forceID, campaign, track, sticky);\n+\n+        // don't create a scenario on top of allied facilities\n+        StratconFacility facility = track.getFacility(coords);\n+        boolean isNonAlliedFacility = (facility != null) && (facility.getOwner() != ForceAlignment.Allied);\n+        int targetNum = calculateScenarioOdds(track, contract, true);\n+        boolean spawnScenario = (facility == null) && (Compute.randomInt(100) <= targetNum);\n+\n+        if (isNonAlliedFacility || spawnScenario) {\n+            StratconScenario scenario = setupScenario(coords, forceID, campaign, contract, track);\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            commitPrimaryForces(campaign, scenario, track);\n+        }\n+    }\n+\n+    /**\n+     * Logic to set up a scenario\n+     */\n+    private static StratconScenario setupScenario(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        StratconScenario scenario = null;\n+\n+        if (track.getFacilities().containsKey(coords)) {\n+            StratconFacility facility = track.getFacility(coords);\n+            boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+            ScenarioTemplate template = StratconScenarioFactory.getFacilityScenario(alliedFacility);\n+            scenario = generateScenario(campaign, contract, track, forceID, coords, template);\n+            setupFacilityScenario(scenario, facility);\n+        } else {\n+            scenario = generateScenario(campaign, contract, track, forceID, coords);\n+\n+            // we may generate a facility scenario randomly - if so, do the facility-related stuff\n+            // and add a new facility to the track\n+            if (scenario.getBackingScenario().getTemplate().isFacilityScenario()) {\n+                StratconFacility facility = scenario.getBackingScenario().getTemplate().isHostileFacility() ?\n+                        StratconFacilityFactory.getRandomHostileFacility() : StratconFacilityFactory.getRandomAlliedFacility();\n+                facility.setVisible(true);\n+                track.addFacility(coords, facility);\n+                setupFacilityScenario(scenario, facility);\n+            }\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * carries out tasks relevant to facility scenarios\n+     */\n+    private static void setupFacilityScenario(StratconScenario scenario, StratconFacility facility) {\n+        // this includes:\n+        // for hostile facilities\n+        // - add a destroy objective (always the option to level the facility)\n+        // - add a capture objective (always the option to capture the facility)\n+        // - if so indicated by parameter, roll a random hostile facility objective and add it if not capture/destroy\n+        // for allied facilities\n+        // - add a defend objective (always the option to defend the facility)\n+        // - if so indicated by parameter, roll a random allied facility objective and add it if not defend\n+        AtBScenarioModifier objectiveModifier = null;\n+        boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+\n+        if (alliedFacility) {\n+            objectiveModifier = AtBScenarioModifier.getRandomAlliedFacilityModifier();\n+        } else {\n+            objectiveModifier = AtBScenarioModifier.getRandomHostileFacilityModifier();\n+        }\n+\n+        if (objectiveModifier != null) {\n+            scenario.getBackingScenario().addScenarioModifier(objectiveModifier);\n+            scenario.getBackingScenario().setName(String.format(\"%s - %s - %s\",\n+                    facility.getFacilityType(), alliedFacility ? \"Allied\" : \"Hostile\", objectiveModifier.getModifierName()));\n+        }\n+\n+        // add the \"fixed\" hostile facility modifiers after the primary ones\n+        if (!alliedFacility) {\n+            for(AtBScenarioModifier modifier : AtBScenarioModifier.getRequiredHostileFacilityModifiers()) {\n+                if(!scenario.getBackingScenario().alreadyHasModifier(modifier)) {\n+                    scenario.getBackingScenario().addScenarioModifier(modifier);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void processFacilityEffects(StratconTrackState track) {\n+        // TODO: these are \"weekly\"? effects that a stratcon facility has on the campaign/track state\n+        // currrently, that's\n+        // supply depot - allied - +1 sp\n+        // supply depot - hostile - +5% BV budget to all scenarios on track (shared modifier, so should be implemented there)\n+        // data center - allied - +1% star league cache contract (don't implement yet, but...)\n+        // data center - hostile - +5% scenario odds in track\n+        // industrial center - allied - all scenarios here have THIS IS COMING OUT OF YOUR PAYCHECK modifier\n+        // orbital defense - allied - sets 'no hostile aircraft' flag for track\n+        // orbital defense - hostile - sets 'no allied aircraft' flag for track\n+        // early warning system - allied - sets 'intercept allied base attacks' flag for track\n+        // early warning system - hostile - sets 'intercept hostile base attacks' flag for track\n+    }\n+\n+    /**\n+     * Process the deployment of a force to the given coordinates on the given track.\n+     */\n+    public static void processForceDeployment(StratconCoords coords, int forceID, \n+            Campaign campaign, StratconTrackState track, boolean sticky) {\n+        track.getRevealedCoords().add(coords);\n+        StratconFacility facility = track.getFacility(coords);\n+        if (facility != null) {\n+            facility.setVisible(true);\n+        }\n+\n+        if (campaign.getLances().get(forceID).getRole() == AtBLanceRole.SCOUTING) {\n+            for(int direction = 0; direction < 6; direction++) {\n+                StratconCoords checkCoords = coords.translate(direction);\n+\n+                facility = track.getFacility(checkCoords);\n+                if(facility != null) {\n+                    facility.setVisible(true);\n+                }\n+\n+                track.getRevealedCoords().add(coords.translate(direction));\n+            }\n+        }\n+\n+        // the force may be located in other places on the track - clear it out\n+        track.unassignForce(forceID);\n+        track.assignForce(forceID, coords, campaign.getLocalDate(), sticky);\n+        MekHQ.triggerEvent(new StratconDeploymentEvent(campaign.getForce(forceID)));\n+    }\n+\n+    /**\n+     * Worker function that processes the effects of deploying a reinforcement force to a scenario\n+     */\n+    public static boolean processReinforcementDeployment(ReinforcementEligibilityType reinforcementType,\n+            StratconCampaignState campaignState, StratconScenario scenario, Campaign campaign) {\n+        // if the force is already deployed to the track, we're done\n+        // if the force is a fight lance or we're using a support point\n+        // if there is an SP to burn, burn it and we're done\n+        // if there is a VP to burn, burn it and we're done\n+        // now, roll 2d6 + lance commander tactics\n+        // 9+ = deploy\n+        // 6+ = deploy, apply negative modifier to scenario\n+        // 2+ = fail to deploy, apply negative modifier to scenario; if fight lance, treat as 6+\n+\n+        if ((reinforcementType == ReinforcementEligibilityType.FightLance) ||\n+                (reinforcementType == ReinforcementEligibilityType.SupportPoint)) {\n+\n+            if (campaignState.getSupportPoints() > 0) {\n+                campaignState.useSupportPoint();\n+                return true;\n+            } else if (campaignState.getVictoryPoints() > 0) {\n+                campaignState.updateVictoryPoints(-1);\n+                return true;\n+            }\n+\n+            int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+            int roll = Compute.d6(2);\n+            int result = roll + tactics;\n+\n+            StringBuilder reportStatus = new StringBuilder();\n+            reportStatus.append(String.format(\"Attempting to reinforce scenario %s without SP/VP, roll 2d6 + %d: %d\",\n+                    scenario.getName(), tactics, result));\n+\n+            // fail to reinforce\n+            if ((result < 6) && (reinforcementType != ReinforcementEligibilityType.FightLance)) {\n+                reportStatus.append(\" - reinforcement attempt failed.\");\n+                campaign.addReport(reportStatus.toString());\n+                return false;\n+            // succeed but get an extra negative event added to the scenario\n+            } else if (result < 9) {\n+                MapLocation mapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+                AtBScenarioModifier scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+\n+                // keep rolling until we get an applicable one\n+                // TODO: have the AtBScenarioModifier sort these out instead for performance?\n+                while (scenarioModifier.getEventTiming() != EventTiming.PostForceGeneration) {\n+                    scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+                }\n+\n+                scenarioModifier.processModifier(scenario.getBackingScenario(), campaign, EventTiming.PostForceGeneration);\n+\n+                reportStatus.append(String.format(\" - reinforcement attempt succeeded; extra negative modifier (%s) applied to scenario.\",\n+                        scenarioModifier.getModifierName()));\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            // succeed without reservation\n+            } else {\n+                reportStatus.append(\" - reinforcement attempt succeeded;\");\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            }\n+        } else if (reinforcementType == ReinforcementEligibilityType.None) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Assigns a force to the scenario such that the majority of the force can be deployed\n+     */\n+    private static void assignAppropriateExtraForceToScenario(StratconScenario scenario,\n+            Map<MapLocation, List<Integer>> sortedAvailableForceIDs) {\n+        // the goal of this function is to avoid assigning ground units to air battles\n+        // and ground units/conventional fighters to space battle\n+\n+        List<MapLocation> mapLocations = new ArrayList<>();\n+        mapLocations.add(MapLocation.Space); // can always add ASFs\n+\n+        MapLocation scenarioMapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+\n+        if (scenarioMapLocation == MapLocation.LowAtmosphere) {\n+            mapLocations.add(MapLocation.LowAtmosphere); // can add conventional fighters to ground or low atmo battles\n+        }\n+\n+        if ((scenarioMapLocation == MapLocation.AllGroundTerrain) ||\n+                (scenarioMapLocation == MapLocation.SpecificGroundTerrain)) {\n+            mapLocations.add(MapLocation.AllGroundTerrain); // can only add ground units to ground battles\n+        }\n+\n+        MapLocation selectedLocation = mapLocations.get(Compute.randomInt(mapLocations.size()));\n+        List<Integer> forceIDs = sortedAvailableForceIDs.get(selectedLocation);\n+        int forceIndex = Compute.randomInt(forceIDs.size());\n+        int forceID = forceIDs.get(forceIndex);\n+        forceIDs.remove(forceIndex);\n+\n+        scenario.addPrimaryForce(forceID);\n+    }\n+\n+    /**\n+     * Worker function that \"locks in\" a scenario -\n+     * Adds it to the campaign so it's visible in the briefing room,\n+     * adds it to the track\n+     *\n+     */\n+    public static void commitPrimaryForces(Campaign campaign, StratconScenario scenario, StratconTrackState trackState) {\n+        trackState.addScenario(scenario);\n+\n+        // set up dates for the scenario if doesn't have them already\n+        if (scenario.getDeploymentDate() == null) {\n+            scenario.setDeploymentDate(campaign.getLocalDate());\n+        }\n+\n+        if (scenario.getActionDate() == null) {\n+            scenario.setActionDate(campaign.getLocalDate());\n+        }\n+\n+        if(scenario.getReturnDate() == null) {\n+            scenario.setReturnDate(campaign.getLocalDate().plusDays(trackState.getDeploymentTime()));\n+        }\n+\n+        // set the # of rerolls based on the actual lance assigned.\n+        int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+        scenario.getBackingScenario().setRerolls(tactics);\n+        // The number of defensive points available to a force entering a scenario is\n+        // 2 x tactics. By default, those points are spent on conventional minefields.\n+        if (commanderLanceHasDefensiveAssignment(scenario.getBackingScenario(), campaign)) {\n+            scenario.setNumDefensivePoints(tactics * 2);\n+            scenario.updateMinefieldCount(Minefield.TYPE_CONVENTIONAL, tactics * 2);\n+        }\n+\n+        for (int forceID : scenario.getPlayerTemplateForceIDs()) {\n+            Force force = campaign.getForce(forceID);\n+            force.clearScenarioIds(campaign, true);\n+            force.setScenarioId(scenario.getBackingScenarioID());\n+        }\n+\n+        scenario.commitPrimaryForces();\n+    }\n+\n+    /**\n+     * Utility method to determine if the current scenario's force commander\n+     * is on defence\n+     */\n+    private static boolean commanderLanceHasDefensiveAssignment(AtBDynamicScenario scenario, Campaign campaign) {\n+        Unit commanderUnit = scenario.getLanceCommander(campaign).getUnit();\n+        Lance lance = campaign.getLances().get(commanderUnit.getForceId());\n+\n+        if ((lance != null) && (lance.getRole() == AtBLanceRole.DEFENCE)) {\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * A hackish worker function that takes the given list of force IDs and\n+     * separates it into three sets;\n+     * one of forces that can be \"primary\" on a ground map\n+     * one of forces that can be \"primary\" on an atmospheric map\n+     * one of forces that can be \"primary\" in a space map\n+     * @param forceIDs List of force IDs to check\n+     * @return Sorted hash map\n+     */\n+    private static Map<MapLocation, List<Integer>> sortForcesByMapType(List<Integer> forceIDs, Campaign campaign) {\n+        Map<MapLocation, List<Integer>> retVal = new HashMap<>();\n+\n+        retVal.put(MapLocation.AllGroundTerrain, new ArrayList<>());\n+        retVal.put(MapLocation.LowAtmosphere, new ArrayList<>());\n+        retVal.put(MapLocation.Space, new ArrayList<>());\n+\n+        for (int forceID : forceIDs) {\n+            switch(campaign.getForce(forceID).getPrimaryUnitType(campaign)) {\n+            case UnitType.BATTLE_ARMOR:\n+            case UnitType.INFANTRY:\n+            case UnitType.MEK:\n+            case UnitType.TANK:\n+            case UnitType.PROTOMEK:\n+            case UnitType.VTOL:\n+                retVal.get(MapLocation.AllGroundTerrain).add(forceID);\n+                break;\n+            case UnitType.AERO:\n+                retVal.get(MapLocation.Space).add(forceID);\n+                // intentional fallthrough here, ASFs can go to atmospheric maps too\n+            case UnitType.CONV_FIGHTER:\n+                retVal.get(MapLocation.LowAtmosphere).add(forceID);\n+                break;\n+            }\n+        }\n+\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * Determine whether the user should be nagged about unresolved scenarios on AtB Stratcon tracks.\n+     * @param campaign Campaign to check.\n+     * @return An informative string containing the reasons the user was nagged.\n+     */\n+    public static String nagUnresolvedContacts(Campaign campaign) {\n+        StringBuilder sb = new StringBuilder();\n+\n+        // check every track attached to an active contract for unresolved scenarios\n+        // to which the player must deploy forces today\n+        for (AtBContract contract : campaign.getActiveAtBContracts()) {\n+            if (contract.getStratconCampaignState() == null) {\n+                continue;\n+            }\n+            \n+            for (StratconTrackState track : contract.getStratconCampaignState().getTracks()) {\n+                for (StratconScenario scenario : track.getScenarios().values()) {\n+                    if (scenario.getCurrentState() == ScenarioState.UNRESOLVED &&\n+                            campaign.getLocalDate().equals(scenario.getDeploymentDate())) {\n+                        // \"scenario name, track name\"\n+                        sb.append(String.format(\"%s, %s\\n\", scenario.getName(), track.getDisplayableName()));\n+                    }\n+                }\n+            }\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track.\n+     * Also registers it with the track and campaign.\n+     */\n+    private static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords) {\n+        int unitType = campaign.getForce(forceID).getPrimaryUnitType(campaign);\n+        ScenarioTemplate template = StratconScenarioFactory.getRandomScenario(unitType);\n+        // useful for debugging specific scenario types\n+        //ScenarioTemplate template = StratconScenarioFactory.getSpecificScenario(\"Hostile Facility.xml\");\n+\n+        return generateScenario(campaign, contract, track, forceID, coords, template);\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track,\n+     * using the given template. Also registers it with the campaign.\n+     */\n+    static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords, ScenarioTemplate template) {\n+        StratconScenario scenario = new StratconScenario();\n+        \n+        AtBDynamicScenario backingScenario = AtBDynamicScenarioFactory.initializeScenarioFromTemplate(template, contract, campaign);        \n+        scenario.setBackingScenario(backingScenario);\n+        scenario.setCoords(coords);\n+        \n+        // by default, certain conditions may make this bigger\n+        scenario.setRequiredPlayerLances(1);\n+\n+        // do an appropriate allied force if the contract calls for it\n+        // do any attached or integrated units\n+        setAlliedForceModifier(scenario, contract);\n+        setAttachedUnitsModifier(scenario, contract);\n+        applyFacilityModifiers(scenario, track, coords);\n+        applyGlobalModifiers(scenario, contract.getStratconCampaignState());\n+\n+        if ((contract.getCommandRights() == AtBContract.COM_HOUSE) ||\n+                (contract.getCommandRights() == AtBContract.COM_INTEGRATED)) {\n+            scenario.setRequiredScenario(true);\n+        }\n+\n+        AtBDynamicScenarioFactory.setScenarioModifiers(scenario.getBackingScenario());\n+        scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+        setScenarioDates(track, campaign, scenario);\n+        \n+        // the backing scenario ID must be updated after registering the backing scenario \n+        // with the campaign, so that the stratcon - backing scenario association is maintained\n+        // registering the scenario with the campaign should be done after setting\n+        // dates, otherwise, the report messages for new scenarios look weird\n+        campaign.addScenario(backingScenario, contract);\n+        scenario.setBackingScenarioID(backingScenario.getId());\n+        \n+        if (forceID > Force.FORCE_NONE) {\n+            scenario.addPrimaryForce(forceID);\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * Apply global scenario modifiers from campaign state to given scenario.\n+     */\n+    private static void applyGlobalModifiers(StratconScenario scenario, StratconCampaignState campaignState) {\n+        for (String modifierName : campaignState.getGlobalScenarioModifiers()) {\n+            AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierName);\n+\n+            if (modifier == null) {\n+                MekHQ.getLogger().error(String.format(\"Modifier %s not found; ignoring\", modifierName));\n+                continue;\n+            }\n+\n+            scenario.getBackingScenario().addScenarioModifier(modifier);\n+        }\n+    }\n+\n+    /**\n+     * Applies scenario modifiers from the current track to the given scenario.\n+     * @param scenario\n+     * @param track\n+     */\n+    private static void applyFacilityModifiers(StratconScenario scenario, StratconTrackState track, StratconCoords coords) {\n+        // loop through all the facilities on the track\n+        // if a facility has been revealed, then it has a 100% chance to apply its effect\n+        // if a facility has not been revealed, then it has a x% chance to apply its effect\n+        // if a facility is on the the scenario coordinates the it applies the local effects\n+        for (StratconCoords facilityCoords : track.getFacilities().keySet()) {\n+            boolean scenarioAtFacility = facilityCoords.equals(coords);\n+            StratconFacility facility = track.getFacilities().get(facilityCoords);\n+            List<String> modifierIDs = new ArrayList<>();\n+\n+            if (scenarioAtFacility) {\n+                modifierIDs = facility.getLocalModifiers();\n+            } else if (facility.isVisible() || (Compute.randomInt(100) <= facility.getAggroRating())) {\n+                modifierIDs = facility.getSharedModifiers();\n+            }\n+\n+            for (String modifierID : modifierIDs) {\n+                AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierID);\n+                if(modifier == null) {", "originalCommit": "b36d9fa6bf982c7b833b1ac0a0473d37f6e84760", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTE5MTgyOQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r615191829", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        switch(contract.getCommandRights()) {\n          \n          \n            \n                        switch (contract.getCommandRights()) {", "author": "Windchild292", "createdAt": "2021-04-17T02:04:38Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1404 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.UUID;\n+\n+import megamek.common.Compute;\n+import megamek.common.Minefield;\n+import megamek.common.UnitType;\n+import megamek.common.annotations.Nullable;\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.Utilities;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.ResolveScenarioTracker;\n+import mekhq.campaign.againstTheBot.enums.AtBLanceRole;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.event.StratconDeploymentEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.force.Lance;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier.EventTiming;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconFacility.FacilityType;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.unit.Unit;\n+\n+/**\n+ * This class contains \"rules\" logic for the AtB-Stratcon state\n+ * @author NickAragua\n+ */\n+public class StratconRulesManager {\n+    /**\n+     * What makes a particular lance eligible to be reinforcements for a scenario\n+     */\n+    public enum ReinforcementEligibilityType {\n+        /**\n+         * Nothing\n+         */\n+        None,\n+\n+        /**\n+         * Lance is already deployed to the track\n+         */\n+        ChainedScenario,\n+\n+        /**\n+         * We pay a support point or convert a victory point to a support point\n+         */\n+        SupportPoint,\n+\n+        /**\n+         * The lance's deployment orders are \"Fight\"\n+         */\n+        FightLance\n+    }\n+\n+    /**\n+     * This function potentially generates non-player-initiated scenarios for the given track.\n+     */\n+    public static void generateScenariosForTrack(Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // maps scenarios to force IDs\n+        List<StratconScenario> generatedScenarios = new ArrayList<>();\n+        boolean autoAssignLances = contract.getCommandRights() == AtBContract.COM_INTEGRATED;\n+\n+        // get this list just so we have it available\n+        List<Integer> availableForceIDs = getAvailableForceIDs(campaign);\n+        Map<MapLocation, List<Integer>> sortedAvailableForceIDs = sortForcesByMapType(availableForceIDs, campaign);\n+\n+        // make X rolls, where X is the number of required lances for the track\n+        // that's the chance to spawn a scenario.\n+        // if a scenario occurs, then we pick a random non-deployed lance and use it to drive the opfor generation later\n+        // once we've determined that scenarios occur, we loop through the ones that we generated\n+        // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all\n+        for (int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            int targetNum = calculateScenarioOdds(track, contract, false);\n+            \n+            // if we haven't already used all the player forces and are required to randomly generate a scenario\n+            if (!availableForceIDs.isEmpty() && (Compute.randomInt(100) <= targetNum)) {\n+                // pick random coordinates and force to drive the scenario\n+                int x = Compute.randomInt(track.getWidth());\n+                int y = Compute.randomInt(track.getHeight());\n+\n+                StratconCoords scenarioCoords = new StratconCoords(x, y);\n+\n+                // if forces are already assigned to these coordinates, use those instead\n+                // of randomly-selected ones\n+                if (track.getAssignedCoordForces().containsKey(scenarioCoords)) {\n+                    StratconScenario scenario = generateScenarioForExistingForces(scenarioCoords,\n+                            track.getAssignedCoordForces().get(scenarioCoords), \n+                            contract, campaign, track);\n+                    generatedScenarios.add(scenario);\n+                    continue;\n+                }\n+                \n+                // otherwise, pick a random force from the avail\n+                int randomForceIndex = Compute.randomInt(availableForceIDs.size());\n+                int randomForceID = availableForceIDs.get(randomForceIndex);\n+                \n+                // remove the force from the available lists so we don't designate it as primary twice\n+                availableForceIDs.remove(randomForceIndex);\n+\n+                // we want to remove the actual int with the value, not the value at the index\n+                sortedAvailableForceIDs.get(MapLocation.AllGroundTerrain).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.LowAtmosphere).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.Space).remove((Integer) randomForceID);\n+\n+                // two scenarios on the same coordinates wind up increasing in size\n+                if (track.getScenarios().containsKey(scenarioCoords)) {\n+                    track.getScenarios().get(scenarioCoords).incrementRequiredPlayerLances();\n+                    assignAppropriateExtraForceToScenario(track.getScenarios().get(scenarioCoords), sortedAvailableForceIDs);\n+                    continue;\n+                }\n+\n+                StratconScenario scenario = setupScenario(scenarioCoords, randomForceID, campaign, contract, track);\n+                generatedScenarios.add(scenario);\n+\n+                // if we're auto-assigning lances, deploy the force to the track as well\n+                if (autoAssignLances) {\n+                    processForceDeployment(scenarioCoords, randomForceID, campaign, track, false);\n+                }\n+            }\n+        }\n+\n+        // if under liaison command, pick a random scenario from the ones generated\n+        // to set as required and attach liaison\n+        if (contract.getCommandRights() == AtBContract.COM_LIAISON) {\n+        \tStratconScenario randomScenario = Utilities.getRandomItem(generatedScenarios);\n+        \trandomScenario.setRequiredScenario(true);\n+            setAttachedUnitsModifier(randomScenario, contract);\n+        }\n+\n+        // now, we loop through all the scenarios we set up\n+        // and generate the opfors / events / etc\n+        // if not auto-assigning lances, we then back out the lance assignments.\n+        for (StratconScenario scenario : generatedScenarios) {\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+\n+            if(!autoAssignLances && !scenario.ignoreForceAutoAssignment()) {\n+                for(int forceID : scenario.getPlayerTemplateForceIDs()) {\n+                    scenario.getBackingScenario().removeForce(forceID);\n+                }\n+\n+                scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                track.addScenario(scenario);\n+            } else {\n+                commitPrimaryForces(campaign, scenario, track);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Given a set of force IDs and coordinates, generate a scenario\n+     * Useful for when we want to generate scenarios \n+     * for forces already deployed to a track\n+     */\n+    public static StratconScenario generateScenarioForExistingForces(StratconCoords scenarioCoords, \n+            Set<Integer> forceIDs, AtBContract contract, Campaign campaign, StratconTrackState track) {\n+        boolean firstForce = true;\n+        StratconScenario scenario = null;\n+        \n+        for (int forceID : forceIDs) {\n+            if (firstForce) {\n+                scenario = setupScenario(scenarioCoords, forceID, campaign, contract, track);\n+                firstForce = false;\n+            } else {\n+                scenario.incrementRequiredPlayerLances();\n+                scenario.addPrimaryForce(forceID);\n+            }\n+        }\n+        \n+        // this is theoretically possible if forceIDs is passed in as null - not likely in practice\n+        // but might as well, to future-proof.\n+        if (scenario != null) {\n+            scenario.setIgnoreForceAutoAssignment(true);\n+        }\n+        \n+        return scenario;\n+    }\n+\n+    /**\n+     * Deploys a force to the given coordinates on the given track as a result of explicit player action.\n+     */\n+    public static void deployForceToCoords(StratconCoords coords, int forceID, \n+            Campaign campaign, AtBContract contract, StratconTrackState track, boolean sticky) {\n+        // the following things should happen:\n+        // 1. call to \"process force deployment\", which reveals fog of war in or around the coords, depending on force role\n+        // 2. if coords are a hostile facility, we get a facility mission\n+        // 3. if coords are empty, we *may* get a mission\n+\n+        processForceDeployment(coords, forceID, campaign, track, sticky);\n+\n+        // don't create a scenario on top of allied facilities\n+        StratconFacility facility = track.getFacility(coords);\n+        boolean isNonAlliedFacility = (facility != null) && (facility.getOwner() != ForceAlignment.Allied);\n+        int targetNum = calculateScenarioOdds(track, contract, true);\n+        boolean spawnScenario = (facility == null) && (Compute.randomInt(100) <= targetNum);\n+\n+        if (isNonAlliedFacility || spawnScenario) {\n+            StratconScenario scenario = setupScenario(coords, forceID, campaign, contract, track);\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            commitPrimaryForces(campaign, scenario, track);\n+        }\n+    }\n+\n+    /**\n+     * Logic to set up a scenario\n+     */\n+    private static StratconScenario setupScenario(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        StratconScenario scenario = null;\n+\n+        if (track.getFacilities().containsKey(coords)) {\n+            StratconFacility facility = track.getFacility(coords);\n+            boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+            ScenarioTemplate template = StratconScenarioFactory.getFacilityScenario(alliedFacility);\n+            scenario = generateScenario(campaign, contract, track, forceID, coords, template);\n+            setupFacilityScenario(scenario, facility);\n+        } else {\n+            scenario = generateScenario(campaign, contract, track, forceID, coords);\n+\n+            // we may generate a facility scenario randomly - if so, do the facility-related stuff\n+            // and add a new facility to the track\n+            if (scenario.getBackingScenario().getTemplate().isFacilityScenario()) {\n+                StratconFacility facility = scenario.getBackingScenario().getTemplate().isHostileFacility() ?\n+                        StratconFacilityFactory.getRandomHostileFacility() : StratconFacilityFactory.getRandomAlliedFacility();\n+                facility.setVisible(true);\n+                track.addFacility(coords, facility);\n+                setupFacilityScenario(scenario, facility);\n+            }\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * carries out tasks relevant to facility scenarios\n+     */\n+    private static void setupFacilityScenario(StratconScenario scenario, StratconFacility facility) {\n+        // this includes:\n+        // for hostile facilities\n+        // - add a destroy objective (always the option to level the facility)\n+        // - add a capture objective (always the option to capture the facility)\n+        // - if so indicated by parameter, roll a random hostile facility objective and add it if not capture/destroy\n+        // for allied facilities\n+        // - add a defend objective (always the option to defend the facility)\n+        // - if so indicated by parameter, roll a random allied facility objective and add it if not defend\n+        AtBScenarioModifier objectiveModifier = null;\n+        boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+\n+        if (alliedFacility) {\n+            objectiveModifier = AtBScenarioModifier.getRandomAlliedFacilityModifier();\n+        } else {\n+            objectiveModifier = AtBScenarioModifier.getRandomHostileFacilityModifier();\n+        }\n+\n+        if (objectiveModifier != null) {\n+            scenario.getBackingScenario().addScenarioModifier(objectiveModifier);\n+            scenario.getBackingScenario().setName(String.format(\"%s - %s - %s\",\n+                    facility.getFacilityType(), alliedFacility ? \"Allied\" : \"Hostile\", objectiveModifier.getModifierName()));\n+        }\n+\n+        // add the \"fixed\" hostile facility modifiers after the primary ones\n+        if (!alliedFacility) {\n+            for(AtBScenarioModifier modifier : AtBScenarioModifier.getRequiredHostileFacilityModifiers()) {\n+                if(!scenario.getBackingScenario().alreadyHasModifier(modifier)) {\n+                    scenario.getBackingScenario().addScenarioModifier(modifier);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void processFacilityEffects(StratconTrackState track) {\n+        // TODO: these are \"weekly\"? effects that a stratcon facility has on the campaign/track state\n+        // currrently, that's\n+        // supply depot - allied - +1 sp\n+        // supply depot - hostile - +5% BV budget to all scenarios on track (shared modifier, so should be implemented there)\n+        // data center - allied - +1% star league cache contract (don't implement yet, but...)\n+        // data center - hostile - +5% scenario odds in track\n+        // industrial center - allied - all scenarios here have THIS IS COMING OUT OF YOUR PAYCHECK modifier\n+        // orbital defense - allied - sets 'no hostile aircraft' flag for track\n+        // orbital defense - hostile - sets 'no allied aircraft' flag for track\n+        // early warning system - allied - sets 'intercept allied base attacks' flag for track\n+        // early warning system - hostile - sets 'intercept hostile base attacks' flag for track\n+    }\n+\n+    /**\n+     * Process the deployment of a force to the given coordinates on the given track.\n+     */\n+    public static void processForceDeployment(StratconCoords coords, int forceID, \n+            Campaign campaign, StratconTrackState track, boolean sticky) {\n+        track.getRevealedCoords().add(coords);\n+        StratconFacility facility = track.getFacility(coords);\n+        if (facility != null) {\n+            facility.setVisible(true);\n+        }\n+\n+        if (campaign.getLances().get(forceID).getRole() == AtBLanceRole.SCOUTING) {\n+            for(int direction = 0; direction < 6; direction++) {\n+                StratconCoords checkCoords = coords.translate(direction);\n+\n+                facility = track.getFacility(checkCoords);\n+                if(facility != null) {\n+                    facility.setVisible(true);\n+                }\n+\n+                track.getRevealedCoords().add(coords.translate(direction));\n+            }\n+        }\n+\n+        // the force may be located in other places on the track - clear it out\n+        track.unassignForce(forceID);\n+        track.assignForce(forceID, coords, campaign.getLocalDate(), sticky);\n+        MekHQ.triggerEvent(new StratconDeploymentEvent(campaign.getForce(forceID)));\n+    }\n+\n+    /**\n+     * Worker function that processes the effects of deploying a reinforcement force to a scenario\n+     */\n+    public static boolean processReinforcementDeployment(ReinforcementEligibilityType reinforcementType,\n+            StratconCampaignState campaignState, StratconScenario scenario, Campaign campaign) {\n+        // if the force is already deployed to the track, we're done\n+        // if the force is a fight lance or we're using a support point\n+        // if there is an SP to burn, burn it and we're done\n+        // if there is a VP to burn, burn it and we're done\n+        // now, roll 2d6 + lance commander tactics\n+        // 9+ = deploy\n+        // 6+ = deploy, apply negative modifier to scenario\n+        // 2+ = fail to deploy, apply negative modifier to scenario; if fight lance, treat as 6+\n+\n+        if ((reinforcementType == ReinforcementEligibilityType.FightLance) ||\n+                (reinforcementType == ReinforcementEligibilityType.SupportPoint)) {\n+\n+            if (campaignState.getSupportPoints() > 0) {\n+                campaignState.useSupportPoint();\n+                return true;\n+            } else if (campaignState.getVictoryPoints() > 0) {\n+                campaignState.updateVictoryPoints(-1);\n+                return true;\n+            }\n+\n+            int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+            int roll = Compute.d6(2);\n+            int result = roll + tactics;\n+\n+            StringBuilder reportStatus = new StringBuilder();\n+            reportStatus.append(String.format(\"Attempting to reinforce scenario %s without SP/VP, roll 2d6 + %d: %d\",\n+                    scenario.getName(), tactics, result));\n+\n+            // fail to reinforce\n+            if ((result < 6) && (reinforcementType != ReinforcementEligibilityType.FightLance)) {\n+                reportStatus.append(\" - reinforcement attempt failed.\");\n+                campaign.addReport(reportStatus.toString());\n+                return false;\n+            // succeed but get an extra negative event added to the scenario\n+            } else if (result < 9) {\n+                MapLocation mapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+                AtBScenarioModifier scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+\n+                // keep rolling until we get an applicable one\n+                // TODO: have the AtBScenarioModifier sort these out instead for performance?\n+                while (scenarioModifier.getEventTiming() != EventTiming.PostForceGeneration) {\n+                    scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+                }\n+\n+                scenarioModifier.processModifier(scenario.getBackingScenario(), campaign, EventTiming.PostForceGeneration);\n+\n+                reportStatus.append(String.format(\" - reinforcement attempt succeeded; extra negative modifier (%s) applied to scenario.\",\n+                        scenarioModifier.getModifierName()));\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            // succeed without reservation\n+            } else {\n+                reportStatus.append(\" - reinforcement attempt succeeded;\");\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            }\n+        } else if (reinforcementType == ReinforcementEligibilityType.None) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Assigns a force to the scenario such that the majority of the force can be deployed\n+     */\n+    private static void assignAppropriateExtraForceToScenario(StratconScenario scenario,\n+            Map<MapLocation, List<Integer>> sortedAvailableForceIDs) {\n+        // the goal of this function is to avoid assigning ground units to air battles\n+        // and ground units/conventional fighters to space battle\n+\n+        List<MapLocation> mapLocations = new ArrayList<>();\n+        mapLocations.add(MapLocation.Space); // can always add ASFs\n+\n+        MapLocation scenarioMapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+\n+        if (scenarioMapLocation == MapLocation.LowAtmosphere) {\n+            mapLocations.add(MapLocation.LowAtmosphere); // can add conventional fighters to ground or low atmo battles\n+        }\n+\n+        if ((scenarioMapLocation == MapLocation.AllGroundTerrain) ||\n+                (scenarioMapLocation == MapLocation.SpecificGroundTerrain)) {\n+            mapLocations.add(MapLocation.AllGroundTerrain); // can only add ground units to ground battles\n+        }\n+\n+        MapLocation selectedLocation = mapLocations.get(Compute.randomInt(mapLocations.size()));\n+        List<Integer> forceIDs = sortedAvailableForceIDs.get(selectedLocation);\n+        int forceIndex = Compute.randomInt(forceIDs.size());\n+        int forceID = forceIDs.get(forceIndex);\n+        forceIDs.remove(forceIndex);\n+\n+        scenario.addPrimaryForce(forceID);\n+    }\n+\n+    /**\n+     * Worker function that \"locks in\" a scenario -\n+     * Adds it to the campaign so it's visible in the briefing room,\n+     * adds it to the track\n+     *\n+     */\n+    public static void commitPrimaryForces(Campaign campaign, StratconScenario scenario, StratconTrackState trackState) {\n+        trackState.addScenario(scenario);\n+\n+        // set up dates for the scenario if doesn't have them already\n+        if (scenario.getDeploymentDate() == null) {\n+            scenario.setDeploymentDate(campaign.getLocalDate());\n+        }\n+\n+        if (scenario.getActionDate() == null) {\n+            scenario.setActionDate(campaign.getLocalDate());\n+        }\n+\n+        if(scenario.getReturnDate() == null) {\n+            scenario.setReturnDate(campaign.getLocalDate().plusDays(trackState.getDeploymentTime()));\n+        }\n+\n+        // set the # of rerolls based on the actual lance assigned.\n+        int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+        scenario.getBackingScenario().setRerolls(tactics);\n+        // The number of defensive points available to a force entering a scenario is\n+        // 2 x tactics. By default, those points are spent on conventional minefields.\n+        if (commanderLanceHasDefensiveAssignment(scenario.getBackingScenario(), campaign)) {\n+            scenario.setNumDefensivePoints(tactics * 2);\n+            scenario.updateMinefieldCount(Minefield.TYPE_CONVENTIONAL, tactics * 2);\n+        }\n+\n+        for (int forceID : scenario.getPlayerTemplateForceIDs()) {\n+            Force force = campaign.getForce(forceID);\n+            force.clearScenarioIds(campaign, true);\n+            force.setScenarioId(scenario.getBackingScenarioID());\n+        }\n+\n+        scenario.commitPrimaryForces();\n+    }\n+\n+    /**\n+     * Utility method to determine if the current scenario's force commander\n+     * is on defence\n+     */\n+    private static boolean commanderLanceHasDefensiveAssignment(AtBDynamicScenario scenario, Campaign campaign) {\n+        Unit commanderUnit = scenario.getLanceCommander(campaign).getUnit();\n+        Lance lance = campaign.getLances().get(commanderUnit.getForceId());\n+\n+        if ((lance != null) && (lance.getRole() == AtBLanceRole.DEFENCE)) {\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * A hackish worker function that takes the given list of force IDs and\n+     * separates it into three sets;\n+     * one of forces that can be \"primary\" on a ground map\n+     * one of forces that can be \"primary\" on an atmospheric map\n+     * one of forces that can be \"primary\" in a space map\n+     * @param forceIDs List of force IDs to check\n+     * @return Sorted hash map\n+     */\n+    private static Map<MapLocation, List<Integer>> sortForcesByMapType(List<Integer> forceIDs, Campaign campaign) {\n+        Map<MapLocation, List<Integer>> retVal = new HashMap<>();\n+\n+        retVal.put(MapLocation.AllGroundTerrain, new ArrayList<>());\n+        retVal.put(MapLocation.LowAtmosphere, new ArrayList<>());\n+        retVal.put(MapLocation.Space, new ArrayList<>());\n+\n+        for (int forceID : forceIDs) {\n+            switch(campaign.getForce(forceID).getPrimaryUnitType(campaign)) {\n+            case UnitType.BATTLE_ARMOR:\n+            case UnitType.INFANTRY:\n+            case UnitType.MEK:\n+            case UnitType.TANK:\n+            case UnitType.PROTOMEK:\n+            case UnitType.VTOL:\n+                retVal.get(MapLocation.AllGroundTerrain).add(forceID);\n+                break;\n+            case UnitType.AERO:\n+                retVal.get(MapLocation.Space).add(forceID);\n+                // intentional fallthrough here, ASFs can go to atmospheric maps too\n+            case UnitType.CONV_FIGHTER:\n+                retVal.get(MapLocation.LowAtmosphere).add(forceID);\n+                break;\n+            }\n+        }\n+\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * Determine whether the user should be nagged about unresolved scenarios on AtB Stratcon tracks.\n+     * @param campaign Campaign to check.\n+     * @return An informative string containing the reasons the user was nagged.\n+     */\n+    public static String nagUnresolvedContacts(Campaign campaign) {\n+        StringBuilder sb = new StringBuilder();\n+\n+        // check every track attached to an active contract for unresolved scenarios\n+        // to which the player must deploy forces today\n+        for (AtBContract contract : campaign.getActiveAtBContracts()) {\n+            if (contract.getStratconCampaignState() == null) {\n+                continue;\n+            }\n+            \n+            for (StratconTrackState track : contract.getStratconCampaignState().getTracks()) {\n+                for (StratconScenario scenario : track.getScenarios().values()) {\n+                    if (scenario.getCurrentState() == ScenarioState.UNRESOLVED &&\n+                            campaign.getLocalDate().equals(scenario.getDeploymentDate())) {\n+                        // \"scenario name, track name\"\n+                        sb.append(String.format(\"%s, %s\\n\", scenario.getName(), track.getDisplayableName()));\n+                    }\n+                }\n+            }\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track.\n+     * Also registers it with the track and campaign.\n+     */\n+    private static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords) {\n+        int unitType = campaign.getForce(forceID).getPrimaryUnitType(campaign);\n+        ScenarioTemplate template = StratconScenarioFactory.getRandomScenario(unitType);\n+        // useful for debugging specific scenario types\n+        //ScenarioTemplate template = StratconScenarioFactory.getSpecificScenario(\"Hostile Facility.xml\");\n+\n+        return generateScenario(campaign, contract, track, forceID, coords, template);\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track,\n+     * using the given template. Also registers it with the campaign.\n+     */\n+    static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords, ScenarioTemplate template) {\n+        StratconScenario scenario = new StratconScenario();\n+        \n+        AtBDynamicScenario backingScenario = AtBDynamicScenarioFactory.initializeScenarioFromTemplate(template, contract, campaign);        \n+        scenario.setBackingScenario(backingScenario);\n+        scenario.setCoords(coords);\n+        \n+        // by default, certain conditions may make this bigger\n+        scenario.setRequiredPlayerLances(1);\n+\n+        // do an appropriate allied force if the contract calls for it\n+        // do any attached or integrated units\n+        setAlliedForceModifier(scenario, contract);\n+        setAttachedUnitsModifier(scenario, contract);\n+        applyFacilityModifiers(scenario, track, coords);\n+        applyGlobalModifiers(scenario, contract.getStratconCampaignState());\n+\n+        if ((contract.getCommandRights() == AtBContract.COM_HOUSE) ||\n+                (contract.getCommandRights() == AtBContract.COM_INTEGRATED)) {\n+            scenario.setRequiredScenario(true);\n+        }\n+\n+        AtBDynamicScenarioFactory.setScenarioModifiers(scenario.getBackingScenario());\n+        scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+        setScenarioDates(track, campaign, scenario);\n+        \n+        // the backing scenario ID must be updated after registering the backing scenario \n+        // with the campaign, so that the stratcon - backing scenario association is maintained\n+        // registering the scenario with the campaign should be done after setting\n+        // dates, otherwise, the report messages for new scenarios look weird\n+        campaign.addScenario(backingScenario, contract);\n+        scenario.setBackingScenarioID(backingScenario.getId());\n+        \n+        if (forceID > Force.FORCE_NONE) {\n+            scenario.addPrimaryForce(forceID);\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * Apply global scenario modifiers from campaign state to given scenario.\n+     */\n+    private static void applyGlobalModifiers(StratconScenario scenario, StratconCampaignState campaignState) {\n+        for (String modifierName : campaignState.getGlobalScenarioModifiers()) {\n+            AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierName);\n+\n+            if (modifier == null) {\n+                MekHQ.getLogger().error(String.format(\"Modifier %s not found; ignoring\", modifierName));\n+                continue;\n+            }\n+\n+            scenario.getBackingScenario().addScenarioModifier(modifier);\n+        }\n+    }\n+\n+    /**\n+     * Applies scenario modifiers from the current track to the given scenario.\n+     * @param scenario\n+     * @param track\n+     */\n+    private static void applyFacilityModifiers(StratconScenario scenario, StratconTrackState track, StratconCoords coords) {\n+        // loop through all the facilities on the track\n+        // if a facility has been revealed, then it has a 100% chance to apply its effect\n+        // if a facility has not been revealed, then it has a x% chance to apply its effect\n+        // if a facility is on the the scenario coordinates the it applies the local effects\n+        for (StratconCoords facilityCoords : track.getFacilities().keySet()) {\n+            boolean scenarioAtFacility = facilityCoords.equals(coords);\n+            StratconFacility facility = track.getFacilities().get(facilityCoords);\n+            List<String> modifierIDs = new ArrayList<>();\n+\n+            if (scenarioAtFacility) {\n+                modifierIDs = facility.getLocalModifiers();\n+            } else if (facility.isVisible() || (Compute.randomInt(100) <= facility.getAggroRating())) {\n+                modifierIDs = facility.getSharedModifiers();\n+            }\n+\n+            for (String modifierID : modifierIDs) {\n+                AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierID);\n+                if(modifier == null) {\n+                    MekHQ.getLogger().error(String.format(\"Modifier %s not found for facility %s\", modifierID, facility.getFormattedDisplayableName()));\n+                    continue;\n+                }\n+\n+                scenario.getBackingScenario().addScenarioModifier(modifier);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set up the appropriate primary allied force modifier, if any\n+     * @param contract The scenario's contract.\n+     */\n+    private static void setAlliedForceModifier(StratconScenario scenario, AtBContract contract) {\n+        int alliedUnitOdds = 0;\n+\n+        // first, we determine the odds of having an allied unit present\n+        // TODO: move this override out to the contract definition\n+        if (contract.getMissionType() == AtBContract.MT_RELIEFDUTY) {\n+            alliedUnitOdds = 50;\n+        } else {\n+            switch(contract.getCommandRights()) {", "originalCommit": "b36d9fa6bf982c7b833b1ac0a0473d37f6e84760", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTE5MTg1Nw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r615191857", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if((backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n          \n          \n            \n                        if ((backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||", "author": "Windchild292", "createdAt": "2021-04-17T02:05:07Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1404 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.UUID;\n+\n+import megamek.common.Compute;\n+import megamek.common.Minefield;\n+import megamek.common.UnitType;\n+import megamek.common.annotations.Nullable;\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.Utilities;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.ResolveScenarioTracker;\n+import mekhq.campaign.againstTheBot.enums.AtBLanceRole;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.event.StratconDeploymentEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.force.Lance;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier.EventTiming;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconFacility.FacilityType;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.unit.Unit;\n+\n+/**\n+ * This class contains \"rules\" logic for the AtB-Stratcon state\n+ * @author NickAragua\n+ */\n+public class StratconRulesManager {\n+    /**\n+     * What makes a particular lance eligible to be reinforcements for a scenario\n+     */\n+    public enum ReinforcementEligibilityType {\n+        /**\n+         * Nothing\n+         */\n+        None,\n+\n+        /**\n+         * Lance is already deployed to the track\n+         */\n+        ChainedScenario,\n+\n+        /**\n+         * We pay a support point or convert a victory point to a support point\n+         */\n+        SupportPoint,\n+\n+        /**\n+         * The lance's deployment orders are \"Fight\"\n+         */\n+        FightLance\n+    }\n+\n+    /**\n+     * This function potentially generates non-player-initiated scenarios for the given track.\n+     */\n+    public static void generateScenariosForTrack(Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // maps scenarios to force IDs\n+        List<StratconScenario> generatedScenarios = new ArrayList<>();\n+        boolean autoAssignLances = contract.getCommandRights() == AtBContract.COM_INTEGRATED;\n+\n+        // get this list just so we have it available\n+        List<Integer> availableForceIDs = getAvailableForceIDs(campaign);\n+        Map<MapLocation, List<Integer>> sortedAvailableForceIDs = sortForcesByMapType(availableForceIDs, campaign);\n+\n+        // make X rolls, where X is the number of required lances for the track\n+        // that's the chance to spawn a scenario.\n+        // if a scenario occurs, then we pick a random non-deployed lance and use it to drive the opfor generation later\n+        // once we've determined that scenarios occur, we loop through the ones that we generated\n+        // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all\n+        for (int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            int targetNum = calculateScenarioOdds(track, contract, false);\n+            \n+            // if we haven't already used all the player forces and are required to randomly generate a scenario\n+            if (!availableForceIDs.isEmpty() && (Compute.randomInt(100) <= targetNum)) {\n+                // pick random coordinates and force to drive the scenario\n+                int x = Compute.randomInt(track.getWidth());\n+                int y = Compute.randomInt(track.getHeight());\n+\n+                StratconCoords scenarioCoords = new StratconCoords(x, y);\n+\n+                // if forces are already assigned to these coordinates, use those instead\n+                // of randomly-selected ones\n+                if (track.getAssignedCoordForces().containsKey(scenarioCoords)) {\n+                    StratconScenario scenario = generateScenarioForExistingForces(scenarioCoords,\n+                            track.getAssignedCoordForces().get(scenarioCoords), \n+                            contract, campaign, track);\n+                    generatedScenarios.add(scenario);\n+                    continue;\n+                }\n+                \n+                // otherwise, pick a random force from the avail\n+                int randomForceIndex = Compute.randomInt(availableForceIDs.size());\n+                int randomForceID = availableForceIDs.get(randomForceIndex);\n+                \n+                // remove the force from the available lists so we don't designate it as primary twice\n+                availableForceIDs.remove(randomForceIndex);\n+\n+                // we want to remove the actual int with the value, not the value at the index\n+                sortedAvailableForceIDs.get(MapLocation.AllGroundTerrain).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.LowAtmosphere).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.Space).remove((Integer) randomForceID);\n+\n+                // two scenarios on the same coordinates wind up increasing in size\n+                if (track.getScenarios().containsKey(scenarioCoords)) {\n+                    track.getScenarios().get(scenarioCoords).incrementRequiredPlayerLances();\n+                    assignAppropriateExtraForceToScenario(track.getScenarios().get(scenarioCoords), sortedAvailableForceIDs);\n+                    continue;\n+                }\n+\n+                StratconScenario scenario = setupScenario(scenarioCoords, randomForceID, campaign, contract, track);\n+                generatedScenarios.add(scenario);\n+\n+                // if we're auto-assigning lances, deploy the force to the track as well\n+                if (autoAssignLances) {\n+                    processForceDeployment(scenarioCoords, randomForceID, campaign, track, false);\n+                }\n+            }\n+        }\n+\n+        // if under liaison command, pick a random scenario from the ones generated\n+        // to set as required and attach liaison\n+        if (contract.getCommandRights() == AtBContract.COM_LIAISON) {\n+        \tStratconScenario randomScenario = Utilities.getRandomItem(generatedScenarios);\n+        \trandomScenario.setRequiredScenario(true);\n+            setAttachedUnitsModifier(randomScenario, contract);\n+        }\n+\n+        // now, we loop through all the scenarios we set up\n+        // and generate the opfors / events / etc\n+        // if not auto-assigning lances, we then back out the lance assignments.\n+        for (StratconScenario scenario : generatedScenarios) {\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+\n+            if(!autoAssignLances && !scenario.ignoreForceAutoAssignment()) {\n+                for(int forceID : scenario.getPlayerTemplateForceIDs()) {\n+                    scenario.getBackingScenario().removeForce(forceID);\n+                }\n+\n+                scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                track.addScenario(scenario);\n+            } else {\n+                commitPrimaryForces(campaign, scenario, track);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Given a set of force IDs and coordinates, generate a scenario\n+     * Useful for when we want to generate scenarios \n+     * for forces already deployed to a track\n+     */\n+    public static StratconScenario generateScenarioForExistingForces(StratconCoords scenarioCoords, \n+            Set<Integer> forceIDs, AtBContract contract, Campaign campaign, StratconTrackState track) {\n+        boolean firstForce = true;\n+        StratconScenario scenario = null;\n+        \n+        for (int forceID : forceIDs) {\n+            if (firstForce) {\n+                scenario = setupScenario(scenarioCoords, forceID, campaign, contract, track);\n+                firstForce = false;\n+            } else {\n+                scenario.incrementRequiredPlayerLances();\n+                scenario.addPrimaryForce(forceID);\n+            }\n+        }\n+        \n+        // this is theoretically possible if forceIDs is passed in as null - not likely in practice\n+        // but might as well, to future-proof.\n+        if (scenario != null) {\n+            scenario.setIgnoreForceAutoAssignment(true);\n+        }\n+        \n+        return scenario;\n+    }\n+\n+    /**\n+     * Deploys a force to the given coordinates on the given track as a result of explicit player action.\n+     */\n+    public static void deployForceToCoords(StratconCoords coords, int forceID, \n+            Campaign campaign, AtBContract contract, StratconTrackState track, boolean sticky) {\n+        // the following things should happen:\n+        // 1. call to \"process force deployment\", which reveals fog of war in or around the coords, depending on force role\n+        // 2. if coords are a hostile facility, we get a facility mission\n+        // 3. if coords are empty, we *may* get a mission\n+\n+        processForceDeployment(coords, forceID, campaign, track, sticky);\n+\n+        // don't create a scenario on top of allied facilities\n+        StratconFacility facility = track.getFacility(coords);\n+        boolean isNonAlliedFacility = (facility != null) && (facility.getOwner() != ForceAlignment.Allied);\n+        int targetNum = calculateScenarioOdds(track, contract, true);\n+        boolean spawnScenario = (facility == null) && (Compute.randomInt(100) <= targetNum);\n+\n+        if (isNonAlliedFacility || spawnScenario) {\n+            StratconScenario scenario = setupScenario(coords, forceID, campaign, contract, track);\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            commitPrimaryForces(campaign, scenario, track);\n+        }\n+    }\n+\n+    /**\n+     * Logic to set up a scenario\n+     */\n+    private static StratconScenario setupScenario(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        StratconScenario scenario = null;\n+\n+        if (track.getFacilities().containsKey(coords)) {\n+            StratconFacility facility = track.getFacility(coords);\n+            boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+            ScenarioTemplate template = StratconScenarioFactory.getFacilityScenario(alliedFacility);\n+            scenario = generateScenario(campaign, contract, track, forceID, coords, template);\n+            setupFacilityScenario(scenario, facility);\n+        } else {\n+            scenario = generateScenario(campaign, contract, track, forceID, coords);\n+\n+            // we may generate a facility scenario randomly - if so, do the facility-related stuff\n+            // and add a new facility to the track\n+            if (scenario.getBackingScenario().getTemplate().isFacilityScenario()) {\n+                StratconFacility facility = scenario.getBackingScenario().getTemplate().isHostileFacility() ?\n+                        StratconFacilityFactory.getRandomHostileFacility() : StratconFacilityFactory.getRandomAlliedFacility();\n+                facility.setVisible(true);\n+                track.addFacility(coords, facility);\n+                setupFacilityScenario(scenario, facility);\n+            }\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * carries out tasks relevant to facility scenarios\n+     */\n+    private static void setupFacilityScenario(StratconScenario scenario, StratconFacility facility) {\n+        // this includes:\n+        // for hostile facilities\n+        // - add a destroy objective (always the option to level the facility)\n+        // - add a capture objective (always the option to capture the facility)\n+        // - if so indicated by parameter, roll a random hostile facility objective and add it if not capture/destroy\n+        // for allied facilities\n+        // - add a defend objective (always the option to defend the facility)\n+        // - if so indicated by parameter, roll a random allied facility objective and add it if not defend\n+        AtBScenarioModifier objectiveModifier = null;\n+        boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+\n+        if (alliedFacility) {\n+            objectiveModifier = AtBScenarioModifier.getRandomAlliedFacilityModifier();\n+        } else {\n+            objectiveModifier = AtBScenarioModifier.getRandomHostileFacilityModifier();\n+        }\n+\n+        if (objectiveModifier != null) {\n+            scenario.getBackingScenario().addScenarioModifier(objectiveModifier);\n+            scenario.getBackingScenario().setName(String.format(\"%s - %s - %s\",\n+                    facility.getFacilityType(), alliedFacility ? \"Allied\" : \"Hostile\", objectiveModifier.getModifierName()));\n+        }\n+\n+        // add the \"fixed\" hostile facility modifiers after the primary ones\n+        if (!alliedFacility) {\n+            for(AtBScenarioModifier modifier : AtBScenarioModifier.getRequiredHostileFacilityModifiers()) {\n+                if(!scenario.getBackingScenario().alreadyHasModifier(modifier)) {\n+                    scenario.getBackingScenario().addScenarioModifier(modifier);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void processFacilityEffects(StratconTrackState track) {\n+        // TODO: these are \"weekly\"? effects that a stratcon facility has on the campaign/track state\n+        // currrently, that's\n+        // supply depot - allied - +1 sp\n+        // supply depot - hostile - +5% BV budget to all scenarios on track (shared modifier, so should be implemented there)\n+        // data center - allied - +1% star league cache contract (don't implement yet, but...)\n+        // data center - hostile - +5% scenario odds in track\n+        // industrial center - allied - all scenarios here have THIS IS COMING OUT OF YOUR PAYCHECK modifier\n+        // orbital defense - allied - sets 'no hostile aircraft' flag for track\n+        // orbital defense - hostile - sets 'no allied aircraft' flag for track\n+        // early warning system - allied - sets 'intercept allied base attacks' flag for track\n+        // early warning system - hostile - sets 'intercept hostile base attacks' flag for track\n+    }\n+\n+    /**\n+     * Process the deployment of a force to the given coordinates on the given track.\n+     */\n+    public static void processForceDeployment(StratconCoords coords, int forceID, \n+            Campaign campaign, StratconTrackState track, boolean sticky) {\n+        track.getRevealedCoords().add(coords);\n+        StratconFacility facility = track.getFacility(coords);\n+        if (facility != null) {\n+            facility.setVisible(true);\n+        }\n+\n+        if (campaign.getLances().get(forceID).getRole() == AtBLanceRole.SCOUTING) {\n+            for(int direction = 0; direction < 6; direction++) {\n+                StratconCoords checkCoords = coords.translate(direction);\n+\n+                facility = track.getFacility(checkCoords);\n+                if(facility != null) {\n+                    facility.setVisible(true);\n+                }\n+\n+                track.getRevealedCoords().add(coords.translate(direction));\n+            }\n+        }\n+\n+        // the force may be located in other places on the track - clear it out\n+        track.unassignForce(forceID);\n+        track.assignForce(forceID, coords, campaign.getLocalDate(), sticky);\n+        MekHQ.triggerEvent(new StratconDeploymentEvent(campaign.getForce(forceID)));\n+    }\n+\n+    /**\n+     * Worker function that processes the effects of deploying a reinforcement force to a scenario\n+     */\n+    public static boolean processReinforcementDeployment(ReinforcementEligibilityType reinforcementType,\n+            StratconCampaignState campaignState, StratconScenario scenario, Campaign campaign) {\n+        // if the force is already deployed to the track, we're done\n+        // if the force is a fight lance or we're using a support point\n+        // if there is an SP to burn, burn it and we're done\n+        // if there is a VP to burn, burn it and we're done\n+        // now, roll 2d6 + lance commander tactics\n+        // 9+ = deploy\n+        // 6+ = deploy, apply negative modifier to scenario\n+        // 2+ = fail to deploy, apply negative modifier to scenario; if fight lance, treat as 6+\n+\n+        if ((reinforcementType == ReinforcementEligibilityType.FightLance) ||\n+                (reinforcementType == ReinforcementEligibilityType.SupportPoint)) {\n+\n+            if (campaignState.getSupportPoints() > 0) {\n+                campaignState.useSupportPoint();\n+                return true;\n+            } else if (campaignState.getVictoryPoints() > 0) {\n+                campaignState.updateVictoryPoints(-1);\n+                return true;\n+            }\n+\n+            int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+            int roll = Compute.d6(2);\n+            int result = roll + tactics;\n+\n+            StringBuilder reportStatus = new StringBuilder();\n+            reportStatus.append(String.format(\"Attempting to reinforce scenario %s without SP/VP, roll 2d6 + %d: %d\",\n+                    scenario.getName(), tactics, result));\n+\n+            // fail to reinforce\n+            if ((result < 6) && (reinforcementType != ReinforcementEligibilityType.FightLance)) {\n+                reportStatus.append(\" - reinforcement attempt failed.\");\n+                campaign.addReport(reportStatus.toString());\n+                return false;\n+            // succeed but get an extra negative event added to the scenario\n+            } else if (result < 9) {\n+                MapLocation mapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+                AtBScenarioModifier scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+\n+                // keep rolling until we get an applicable one\n+                // TODO: have the AtBScenarioModifier sort these out instead for performance?\n+                while (scenarioModifier.getEventTiming() != EventTiming.PostForceGeneration) {\n+                    scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+                }\n+\n+                scenarioModifier.processModifier(scenario.getBackingScenario(), campaign, EventTiming.PostForceGeneration);\n+\n+                reportStatus.append(String.format(\" - reinforcement attempt succeeded; extra negative modifier (%s) applied to scenario.\",\n+                        scenarioModifier.getModifierName()));\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            // succeed without reservation\n+            } else {\n+                reportStatus.append(\" - reinforcement attempt succeeded;\");\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            }\n+        } else if (reinforcementType == ReinforcementEligibilityType.None) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Assigns a force to the scenario such that the majority of the force can be deployed\n+     */\n+    private static void assignAppropriateExtraForceToScenario(StratconScenario scenario,\n+            Map<MapLocation, List<Integer>> sortedAvailableForceIDs) {\n+        // the goal of this function is to avoid assigning ground units to air battles\n+        // and ground units/conventional fighters to space battle\n+\n+        List<MapLocation> mapLocations = new ArrayList<>();\n+        mapLocations.add(MapLocation.Space); // can always add ASFs\n+\n+        MapLocation scenarioMapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+\n+        if (scenarioMapLocation == MapLocation.LowAtmosphere) {\n+            mapLocations.add(MapLocation.LowAtmosphere); // can add conventional fighters to ground or low atmo battles\n+        }\n+\n+        if ((scenarioMapLocation == MapLocation.AllGroundTerrain) ||\n+                (scenarioMapLocation == MapLocation.SpecificGroundTerrain)) {\n+            mapLocations.add(MapLocation.AllGroundTerrain); // can only add ground units to ground battles\n+        }\n+\n+        MapLocation selectedLocation = mapLocations.get(Compute.randomInt(mapLocations.size()));\n+        List<Integer> forceIDs = sortedAvailableForceIDs.get(selectedLocation);\n+        int forceIndex = Compute.randomInt(forceIDs.size());\n+        int forceID = forceIDs.get(forceIndex);\n+        forceIDs.remove(forceIndex);\n+\n+        scenario.addPrimaryForce(forceID);\n+    }\n+\n+    /**\n+     * Worker function that \"locks in\" a scenario -\n+     * Adds it to the campaign so it's visible in the briefing room,\n+     * adds it to the track\n+     *\n+     */\n+    public static void commitPrimaryForces(Campaign campaign, StratconScenario scenario, StratconTrackState trackState) {\n+        trackState.addScenario(scenario);\n+\n+        // set up dates for the scenario if doesn't have them already\n+        if (scenario.getDeploymentDate() == null) {\n+            scenario.setDeploymentDate(campaign.getLocalDate());\n+        }\n+\n+        if (scenario.getActionDate() == null) {\n+            scenario.setActionDate(campaign.getLocalDate());\n+        }\n+\n+        if(scenario.getReturnDate() == null) {\n+            scenario.setReturnDate(campaign.getLocalDate().plusDays(trackState.getDeploymentTime()));\n+        }\n+\n+        // set the # of rerolls based on the actual lance assigned.\n+        int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+        scenario.getBackingScenario().setRerolls(tactics);\n+        // The number of defensive points available to a force entering a scenario is\n+        // 2 x tactics. By default, those points are spent on conventional minefields.\n+        if (commanderLanceHasDefensiveAssignment(scenario.getBackingScenario(), campaign)) {\n+            scenario.setNumDefensivePoints(tactics * 2);\n+            scenario.updateMinefieldCount(Minefield.TYPE_CONVENTIONAL, tactics * 2);\n+        }\n+\n+        for (int forceID : scenario.getPlayerTemplateForceIDs()) {\n+            Force force = campaign.getForce(forceID);\n+            force.clearScenarioIds(campaign, true);\n+            force.setScenarioId(scenario.getBackingScenarioID());\n+        }\n+\n+        scenario.commitPrimaryForces();\n+    }\n+\n+    /**\n+     * Utility method to determine if the current scenario's force commander\n+     * is on defence\n+     */\n+    private static boolean commanderLanceHasDefensiveAssignment(AtBDynamicScenario scenario, Campaign campaign) {\n+        Unit commanderUnit = scenario.getLanceCommander(campaign).getUnit();\n+        Lance lance = campaign.getLances().get(commanderUnit.getForceId());\n+\n+        if ((lance != null) && (lance.getRole() == AtBLanceRole.DEFENCE)) {\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * A hackish worker function that takes the given list of force IDs and\n+     * separates it into three sets;\n+     * one of forces that can be \"primary\" on a ground map\n+     * one of forces that can be \"primary\" on an atmospheric map\n+     * one of forces that can be \"primary\" in a space map\n+     * @param forceIDs List of force IDs to check\n+     * @return Sorted hash map\n+     */\n+    private static Map<MapLocation, List<Integer>> sortForcesByMapType(List<Integer> forceIDs, Campaign campaign) {\n+        Map<MapLocation, List<Integer>> retVal = new HashMap<>();\n+\n+        retVal.put(MapLocation.AllGroundTerrain, new ArrayList<>());\n+        retVal.put(MapLocation.LowAtmosphere, new ArrayList<>());\n+        retVal.put(MapLocation.Space, new ArrayList<>());\n+\n+        for (int forceID : forceIDs) {\n+            switch(campaign.getForce(forceID).getPrimaryUnitType(campaign)) {\n+            case UnitType.BATTLE_ARMOR:\n+            case UnitType.INFANTRY:\n+            case UnitType.MEK:\n+            case UnitType.TANK:\n+            case UnitType.PROTOMEK:\n+            case UnitType.VTOL:\n+                retVal.get(MapLocation.AllGroundTerrain).add(forceID);\n+                break;\n+            case UnitType.AERO:\n+                retVal.get(MapLocation.Space).add(forceID);\n+                // intentional fallthrough here, ASFs can go to atmospheric maps too\n+            case UnitType.CONV_FIGHTER:\n+                retVal.get(MapLocation.LowAtmosphere).add(forceID);\n+                break;\n+            }\n+        }\n+\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * Determine whether the user should be nagged about unresolved scenarios on AtB Stratcon tracks.\n+     * @param campaign Campaign to check.\n+     * @return An informative string containing the reasons the user was nagged.\n+     */\n+    public static String nagUnresolvedContacts(Campaign campaign) {\n+        StringBuilder sb = new StringBuilder();\n+\n+        // check every track attached to an active contract for unresolved scenarios\n+        // to which the player must deploy forces today\n+        for (AtBContract contract : campaign.getActiveAtBContracts()) {\n+            if (contract.getStratconCampaignState() == null) {\n+                continue;\n+            }\n+            \n+            for (StratconTrackState track : contract.getStratconCampaignState().getTracks()) {\n+                for (StratconScenario scenario : track.getScenarios().values()) {\n+                    if (scenario.getCurrentState() == ScenarioState.UNRESOLVED &&\n+                            campaign.getLocalDate().equals(scenario.getDeploymentDate())) {\n+                        // \"scenario name, track name\"\n+                        sb.append(String.format(\"%s, %s\\n\", scenario.getName(), track.getDisplayableName()));\n+                    }\n+                }\n+            }\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track.\n+     * Also registers it with the track and campaign.\n+     */\n+    private static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords) {\n+        int unitType = campaign.getForce(forceID).getPrimaryUnitType(campaign);\n+        ScenarioTemplate template = StratconScenarioFactory.getRandomScenario(unitType);\n+        // useful for debugging specific scenario types\n+        //ScenarioTemplate template = StratconScenarioFactory.getSpecificScenario(\"Hostile Facility.xml\");\n+\n+        return generateScenario(campaign, contract, track, forceID, coords, template);\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track,\n+     * using the given template. Also registers it with the campaign.\n+     */\n+    static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords, ScenarioTemplate template) {\n+        StratconScenario scenario = new StratconScenario();\n+        \n+        AtBDynamicScenario backingScenario = AtBDynamicScenarioFactory.initializeScenarioFromTemplate(template, contract, campaign);        \n+        scenario.setBackingScenario(backingScenario);\n+        scenario.setCoords(coords);\n+        \n+        // by default, certain conditions may make this bigger\n+        scenario.setRequiredPlayerLances(1);\n+\n+        // do an appropriate allied force if the contract calls for it\n+        // do any attached or integrated units\n+        setAlliedForceModifier(scenario, contract);\n+        setAttachedUnitsModifier(scenario, contract);\n+        applyFacilityModifiers(scenario, track, coords);\n+        applyGlobalModifiers(scenario, contract.getStratconCampaignState());\n+\n+        if ((contract.getCommandRights() == AtBContract.COM_HOUSE) ||\n+                (contract.getCommandRights() == AtBContract.COM_INTEGRATED)) {\n+            scenario.setRequiredScenario(true);\n+        }\n+\n+        AtBDynamicScenarioFactory.setScenarioModifiers(scenario.getBackingScenario());\n+        scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+        setScenarioDates(track, campaign, scenario);\n+        \n+        // the backing scenario ID must be updated after registering the backing scenario \n+        // with the campaign, so that the stratcon - backing scenario association is maintained\n+        // registering the scenario with the campaign should be done after setting\n+        // dates, otherwise, the report messages for new scenarios look weird\n+        campaign.addScenario(backingScenario, contract);\n+        scenario.setBackingScenarioID(backingScenario.getId());\n+        \n+        if (forceID > Force.FORCE_NONE) {\n+            scenario.addPrimaryForce(forceID);\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * Apply global scenario modifiers from campaign state to given scenario.\n+     */\n+    private static void applyGlobalModifiers(StratconScenario scenario, StratconCampaignState campaignState) {\n+        for (String modifierName : campaignState.getGlobalScenarioModifiers()) {\n+            AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierName);\n+\n+            if (modifier == null) {\n+                MekHQ.getLogger().error(String.format(\"Modifier %s not found; ignoring\", modifierName));\n+                continue;\n+            }\n+\n+            scenario.getBackingScenario().addScenarioModifier(modifier);\n+        }\n+    }\n+\n+    /**\n+     * Applies scenario modifiers from the current track to the given scenario.\n+     * @param scenario\n+     * @param track\n+     */\n+    private static void applyFacilityModifiers(StratconScenario scenario, StratconTrackState track, StratconCoords coords) {\n+        // loop through all the facilities on the track\n+        // if a facility has been revealed, then it has a 100% chance to apply its effect\n+        // if a facility has not been revealed, then it has a x% chance to apply its effect\n+        // if a facility is on the the scenario coordinates the it applies the local effects\n+        for (StratconCoords facilityCoords : track.getFacilities().keySet()) {\n+            boolean scenarioAtFacility = facilityCoords.equals(coords);\n+            StratconFacility facility = track.getFacilities().get(facilityCoords);\n+            List<String> modifierIDs = new ArrayList<>();\n+\n+            if (scenarioAtFacility) {\n+                modifierIDs = facility.getLocalModifiers();\n+            } else if (facility.isVisible() || (Compute.randomInt(100) <= facility.getAggroRating())) {\n+                modifierIDs = facility.getSharedModifiers();\n+            }\n+\n+            for (String modifierID : modifierIDs) {\n+                AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierID);\n+                if(modifier == null) {\n+                    MekHQ.getLogger().error(String.format(\"Modifier %s not found for facility %s\", modifierID, facility.getFormattedDisplayableName()));\n+                    continue;\n+                }\n+\n+                scenario.getBackingScenario().addScenarioModifier(modifier);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set up the appropriate primary allied force modifier, if any\n+     * @param contract The scenario's contract.\n+     */\n+    private static void setAlliedForceModifier(StratconScenario scenario, AtBContract contract) {\n+        int alliedUnitOdds = 0;\n+\n+        // first, we determine the odds of having an allied unit present\n+        // TODO: move this override out to the contract definition\n+        if (contract.getMissionType() == AtBContract.MT_RELIEFDUTY) {\n+            alliedUnitOdds = 50;\n+        } else {\n+            switch(contract.getCommandRights()) {\n+                case AtBContract.COM_INTEGRATED:\n+                    alliedUnitOdds = 50;\n+                    break;\n+                case AtBContract.COM_HOUSE:\n+                    alliedUnitOdds = 30;\n+                    break;\n+                case AtBContract.COM_LIAISON:\n+                    alliedUnitOdds = 10;\n+                    break;\n+            }\n+        }\n+\n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+\n+        // if an allied unit is present, then we want to make sure that it's ground units\n+        // for ground battles\n+        if (Compute.randomInt(100) <= alliedUnitOdds) {\n+            if((backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||", "originalCommit": "b36d9fa6bf982c7b833b1ac0a0473d37f6e84760", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTE5MTg2NA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r615191864", "bodyText": "indent", "author": "Windchild292", "createdAt": "2021-04-17T02:05:18Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1404 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.UUID;\n+\n+import megamek.common.Compute;\n+import megamek.common.Minefield;\n+import megamek.common.UnitType;\n+import megamek.common.annotations.Nullable;\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.Utilities;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.ResolveScenarioTracker;\n+import mekhq.campaign.againstTheBot.enums.AtBLanceRole;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.event.StratconDeploymentEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.force.Lance;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier.EventTiming;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconFacility.FacilityType;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.unit.Unit;\n+\n+/**\n+ * This class contains \"rules\" logic for the AtB-Stratcon state\n+ * @author NickAragua\n+ */\n+public class StratconRulesManager {\n+    /**\n+     * What makes a particular lance eligible to be reinforcements for a scenario\n+     */\n+    public enum ReinforcementEligibilityType {\n+        /**\n+         * Nothing\n+         */\n+        None,\n+\n+        /**\n+         * Lance is already deployed to the track\n+         */\n+        ChainedScenario,\n+\n+        /**\n+         * We pay a support point or convert a victory point to a support point\n+         */\n+        SupportPoint,\n+\n+        /**\n+         * The lance's deployment orders are \"Fight\"\n+         */\n+        FightLance\n+    }\n+\n+    /**\n+     * This function potentially generates non-player-initiated scenarios for the given track.\n+     */\n+    public static void generateScenariosForTrack(Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // maps scenarios to force IDs\n+        List<StratconScenario> generatedScenarios = new ArrayList<>();\n+        boolean autoAssignLances = contract.getCommandRights() == AtBContract.COM_INTEGRATED;\n+\n+        // get this list just so we have it available\n+        List<Integer> availableForceIDs = getAvailableForceIDs(campaign);\n+        Map<MapLocation, List<Integer>> sortedAvailableForceIDs = sortForcesByMapType(availableForceIDs, campaign);\n+\n+        // make X rolls, where X is the number of required lances for the track\n+        // that's the chance to spawn a scenario.\n+        // if a scenario occurs, then we pick a random non-deployed lance and use it to drive the opfor generation later\n+        // once we've determined that scenarios occur, we loop through the ones that we generated\n+        // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all\n+        for (int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            int targetNum = calculateScenarioOdds(track, contract, false);\n+            \n+            // if we haven't already used all the player forces and are required to randomly generate a scenario\n+            if (!availableForceIDs.isEmpty() && (Compute.randomInt(100) <= targetNum)) {\n+                // pick random coordinates and force to drive the scenario\n+                int x = Compute.randomInt(track.getWidth());\n+                int y = Compute.randomInt(track.getHeight());\n+\n+                StratconCoords scenarioCoords = new StratconCoords(x, y);\n+\n+                // if forces are already assigned to these coordinates, use those instead\n+                // of randomly-selected ones\n+                if (track.getAssignedCoordForces().containsKey(scenarioCoords)) {\n+                    StratconScenario scenario = generateScenarioForExistingForces(scenarioCoords,\n+                            track.getAssignedCoordForces().get(scenarioCoords), \n+                            contract, campaign, track);\n+                    generatedScenarios.add(scenario);\n+                    continue;\n+                }\n+                \n+                // otherwise, pick a random force from the avail\n+                int randomForceIndex = Compute.randomInt(availableForceIDs.size());\n+                int randomForceID = availableForceIDs.get(randomForceIndex);\n+                \n+                // remove the force from the available lists so we don't designate it as primary twice\n+                availableForceIDs.remove(randomForceIndex);\n+\n+                // we want to remove the actual int with the value, not the value at the index\n+                sortedAvailableForceIDs.get(MapLocation.AllGroundTerrain).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.LowAtmosphere).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.Space).remove((Integer) randomForceID);\n+\n+                // two scenarios on the same coordinates wind up increasing in size\n+                if (track.getScenarios().containsKey(scenarioCoords)) {\n+                    track.getScenarios().get(scenarioCoords).incrementRequiredPlayerLances();\n+                    assignAppropriateExtraForceToScenario(track.getScenarios().get(scenarioCoords), sortedAvailableForceIDs);\n+                    continue;\n+                }\n+\n+                StratconScenario scenario = setupScenario(scenarioCoords, randomForceID, campaign, contract, track);\n+                generatedScenarios.add(scenario);\n+\n+                // if we're auto-assigning lances, deploy the force to the track as well\n+                if (autoAssignLances) {\n+                    processForceDeployment(scenarioCoords, randomForceID, campaign, track, false);\n+                }\n+            }\n+        }\n+\n+        // if under liaison command, pick a random scenario from the ones generated\n+        // to set as required and attach liaison\n+        if (contract.getCommandRights() == AtBContract.COM_LIAISON) {\n+        \tStratconScenario randomScenario = Utilities.getRandomItem(generatedScenarios);\n+        \trandomScenario.setRequiredScenario(true);\n+            setAttachedUnitsModifier(randomScenario, contract);\n+        }\n+\n+        // now, we loop through all the scenarios we set up\n+        // and generate the opfors / events / etc\n+        // if not auto-assigning lances, we then back out the lance assignments.\n+        for (StratconScenario scenario : generatedScenarios) {\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+\n+            if(!autoAssignLances && !scenario.ignoreForceAutoAssignment()) {\n+                for(int forceID : scenario.getPlayerTemplateForceIDs()) {\n+                    scenario.getBackingScenario().removeForce(forceID);\n+                }\n+\n+                scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                track.addScenario(scenario);\n+            } else {\n+                commitPrimaryForces(campaign, scenario, track);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Given a set of force IDs and coordinates, generate a scenario\n+     * Useful for when we want to generate scenarios \n+     * for forces already deployed to a track\n+     */\n+    public static StratconScenario generateScenarioForExistingForces(StratconCoords scenarioCoords, \n+            Set<Integer> forceIDs, AtBContract contract, Campaign campaign, StratconTrackState track) {\n+        boolean firstForce = true;\n+        StratconScenario scenario = null;\n+        \n+        for (int forceID : forceIDs) {\n+            if (firstForce) {\n+                scenario = setupScenario(scenarioCoords, forceID, campaign, contract, track);\n+                firstForce = false;\n+            } else {\n+                scenario.incrementRequiredPlayerLances();\n+                scenario.addPrimaryForce(forceID);\n+            }\n+        }\n+        \n+        // this is theoretically possible if forceIDs is passed in as null - not likely in practice\n+        // but might as well, to future-proof.\n+        if (scenario != null) {\n+            scenario.setIgnoreForceAutoAssignment(true);\n+        }\n+        \n+        return scenario;\n+    }\n+\n+    /**\n+     * Deploys a force to the given coordinates on the given track as a result of explicit player action.\n+     */\n+    public static void deployForceToCoords(StratconCoords coords, int forceID, \n+            Campaign campaign, AtBContract contract, StratconTrackState track, boolean sticky) {\n+        // the following things should happen:\n+        // 1. call to \"process force deployment\", which reveals fog of war in or around the coords, depending on force role\n+        // 2. if coords are a hostile facility, we get a facility mission\n+        // 3. if coords are empty, we *may* get a mission\n+\n+        processForceDeployment(coords, forceID, campaign, track, sticky);\n+\n+        // don't create a scenario on top of allied facilities\n+        StratconFacility facility = track.getFacility(coords);\n+        boolean isNonAlliedFacility = (facility != null) && (facility.getOwner() != ForceAlignment.Allied);\n+        int targetNum = calculateScenarioOdds(track, contract, true);\n+        boolean spawnScenario = (facility == null) && (Compute.randomInt(100) <= targetNum);\n+\n+        if (isNonAlliedFacility || spawnScenario) {\n+            StratconScenario scenario = setupScenario(coords, forceID, campaign, contract, track);\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            commitPrimaryForces(campaign, scenario, track);\n+        }\n+    }\n+\n+    /**\n+     * Logic to set up a scenario\n+     */\n+    private static StratconScenario setupScenario(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        StratconScenario scenario = null;\n+\n+        if (track.getFacilities().containsKey(coords)) {\n+            StratconFacility facility = track.getFacility(coords);\n+            boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+            ScenarioTemplate template = StratconScenarioFactory.getFacilityScenario(alliedFacility);\n+            scenario = generateScenario(campaign, contract, track, forceID, coords, template);\n+            setupFacilityScenario(scenario, facility);\n+        } else {\n+            scenario = generateScenario(campaign, contract, track, forceID, coords);\n+\n+            // we may generate a facility scenario randomly - if so, do the facility-related stuff\n+            // and add a new facility to the track\n+            if (scenario.getBackingScenario().getTemplate().isFacilityScenario()) {\n+                StratconFacility facility = scenario.getBackingScenario().getTemplate().isHostileFacility() ?\n+                        StratconFacilityFactory.getRandomHostileFacility() : StratconFacilityFactory.getRandomAlliedFacility();\n+                facility.setVisible(true);\n+                track.addFacility(coords, facility);\n+                setupFacilityScenario(scenario, facility);\n+            }\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * carries out tasks relevant to facility scenarios\n+     */\n+    private static void setupFacilityScenario(StratconScenario scenario, StratconFacility facility) {\n+        // this includes:\n+        // for hostile facilities\n+        // - add a destroy objective (always the option to level the facility)\n+        // - add a capture objective (always the option to capture the facility)\n+        // - if so indicated by parameter, roll a random hostile facility objective and add it if not capture/destroy\n+        // for allied facilities\n+        // - add a defend objective (always the option to defend the facility)\n+        // - if so indicated by parameter, roll a random allied facility objective and add it if not defend\n+        AtBScenarioModifier objectiveModifier = null;\n+        boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+\n+        if (alliedFacility) {\n+            objectiveModifier = AtBScenarioModifier.getRandomAlliedFacilityModifier();\n+        } else {\n+            objectiveModifier = AtBScenarioModifier.getRandomHostileFacilityModifier();\n+        }\n+\n+        if (objectiveModifier != null) {\n+            scenario.getBackingScenario().addScenarioModifier(objectiveModifier);\n+            scenario.getBackingScenario().setName(String.format(\"%s - %s - %s\",\n+                    facility.getFacilityType(), alliedFacility ? \"Allied\" : \"Hostile\", objectiveModifier.getModifierName()));\n+        }\n+\n+        // add the \"fixed\" hostile facility modifiers after the primary ones\n+        if (!alliedFacility) {\n+            for(AtBScenarioModifier modifier : AtBScenarioModifier.getRequiredHostileFacilityModifiers()) {\n+                if(!scenario.getBackingScenario().alreadyHasModifier(modifier)) {\n+                    scenario.getBackingScenario().addScenarioModifier(modifier);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void processFacilityEffects(StratconTrackState track) {\n+        // TODO: these are \"weekly\"? effects that a stratcon facility has on the campaign/track state\n+        // currrently, that's\n+        // supply depot - allied - +1 sp\n+        // supply depot - hostile - +5% BV budget to all scenarios on track (shared modifier, so should be implemented there)\n+        // data center - allied - +1% star league cache contract (don't implement yet, but...)\n+        // data center - hostile - +5% scenario odds in track\n+        // industrial center - allied - all scenarios here have THIS IS COMING OUT OF YOUR PAYCHECK modifier\n+        // orbital defense - allied - sets 'no hostile aircraft' flag for track\n+        // orbital defense - hostile - sets 'no allied aircraft' flag for track\n+        // early warning system - allied - sets 'intercept allied base attacks' flag for track\n+        // early warning system - hostile - sets 'intercept hostile base attacks' flag for track\n+    }\n+\n+    /**\n+     * Process the deployment of a force to the given coordinates on the given track.\n+     */\n+    public static void processForceDeployment(StratconCoords coords, int forceID, \n+            Campaign campaign, StratconTrackState track, boolean sticky) {\n+        track.getRevealedCoords().add(coords);\n+        StratconFacility facility = track.getFacility(coords);\n+        if (facility != null) {\n+            facility.setVisible(true);\n+        }\n+\n+        if (campaign.getLances().get(forceID).getRole() == AtBLanceRole.SCOUTING) {\n+            for(int direction = 0; direction < 6; direction++) {\n+                StratconCoords checkCoords = coords.translate(direction);\n+\n+                facility = track.getFacility(checkCoords);\n+                if(facility != null) {\n+                    facility.setVisible(true);\n+                }\n+\n+                track.getRevealedCoords().add(coords.translate(direction));\n+            }\n+        }\n+\n+        // the force may be located in other places on the track - clear it out\n+        track.unassignForce(forceID);\n+        track.assignForce(forceID, coords, campaign.getLocalDate(), sticky);\n+        MekHQ.triggerEvent(new StratconDeploymentEvent(campaign.getForce(forceID)));\n+    }\n+\n+    /**\n+     * Worker function that processes the effects of deploying a reinforcement force to a scenario\n+     */\n+    public static boolean processReinforcementDeployment(ReinforcementEligibilityType reinforcementType,\n+            StratconCampaignState campaignState, StratconScenario scenario, Campaign campaign) {\n+        // if the force is already deployed to the track, we're done\n+        // if the force is a fight lance or we're using a support point\n+        // if there is an SP to burn, burn it and we're done\n+        // if there is a VP to burn, burn it and we're done\n+        // now, roll 2d6 + lance commander tactics\n+        // 9+ = deploy\n+        // 6+ = deploy, apply negative modifier to scenario\n+        // 2+ = fail to deploy, apply negative modifier to scenario; if fight lance, treat as 6+\n+\n+        if ((reinforcementType == ReinforcementEligibilityType.FightLance) ||\n+                (reinforcementType == ReinforcementEligibilityType.SupportPoint)) {\n+\n+            if (campaignState.getSupportPoints() > 0) {\n+                campaignState.useSupportPoint();\n+                return true;\n+            } else if (campaignState.getVictoryPoints() > 0) {\n+                campaignState.updateVictoryPoints(-1);\n+                return true;\n+            }\n+\n+            int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+            int roll = Compute.d6(2);\n+            int result = roll + tactics;\n+\n+            StringBuilder reportStatus = new StringBuilder();\n+            reportStatus.append(String.format(\"Attempting to reinforce scenario %s without SP/VP, roll 2d6 + %d: %d\",\n+                    scenario.getName(), tactics, result));\n+\n+            // fail to reinforce\n+            if ((result < 6) && (reinforcementType != ReinforcementEligibilityType.FightLance)) {\n+                reportStatus.append(\" - reinforcement attempt failed.\");\n+                campaign.addReport(reportStatus.toString());\n+                return false;\n+            // succeed but get an extra negative event added to the scenario\n+            } else if (result < 9) {\n+                MapLocation mapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+                AtBScenarioModifier scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+\n+                // keep rolling until we get an applicable one\n+                // TODO: have the AtBScenarioModifier sort these out instead for performance?\n+                while (scenarioModifier.getEventTiming() != EventTiming.PostForceGeneration) {\n+                    scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+                }\n+\n+                scenarioModifier.processModifier(scenario.getBackingScenario(), campaign, EventTiming.PostForceGeneration);\n+\n+                reportStatus.append(String.format(\" - reinforcement attempt succeeded; extra negative modifier (%s) applied to scenario.\",\n+                        scenarioModifier.getModifierName()));\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            // succeed without reservation\n+            } else {\n+                reportStatus.append(\" - reinforcement attempt succeeded;\");\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            }\n+        } else if (reinforcementType == ReinforcementEligibilityType.None) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Assigns a force to the scenario such that the majority of the force can be deployed\n+     */\n+    private static void assignAppropriateExtraForceToScenario(StratconScenario scenario,\n+            Map<MapLocation, List<Integer>> sortedAvailableForceIDs) {\n+        // the goal of this function is to avoid assigning ground units to air battles\n+        // and ground units/conventional fighters to space battle\n+\n+        List<MapLocation> mapLocations = new ArrayList<>();\n+        mapLocations.add(MapLocation.Space); // can always add ASFs\n+\n+        MapLocation scenarioMapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+\n+        if (scenarioMapLocation == MapLocation.LowAtmosphere) {\n+            mapLocations.add(MapLocation.LowAtmosphere); // can add conventional fighters to ground or low atmo battles\n+        }\n+\n+        if ((scenarioMapLocation == MapLocation.AllGroundTerrain) ||\n+                (scenarioMapLocation == MapLocation.SpecificGroundTerrain)) {\n+            mapLocations.add(MapLocation.AllGroundTerrain); // can only add ground units to ground battles\n+        }\n+\n+        MapLocation selectedLocation = mapLocations.get(Compute.randomInt(mapLocations.size()));\n+        List<Integer> forceIDs = sortedAvailableForceIDs.get(selectedLocation);\n+        int forceIndex = Compute.randomInt(forceIDs.size());\n+        int forceID = forceIDs.get(forceIndex);\n+        forceIDs.remove(forceIndex);\n+\n+        scenario.addPrimaryForce(forceID);\n+    }\n+\n+    /**\n+     * Worker function that \"locks in\" a scenario -\n+     * Adds it to the campaign so it's visible in the briefing room,\n+     * adds it to the track\n+     *\n+     */\n+    public static void commitPrimaryForces(Campaign campaign, StratconScenario scenario, StratconTrackState trackState) {\n+        trackState.addScenario(scenario);\n+\n+        // set up dates for the scenario if doesn't have them already\n+        if (scenario.getDeploymentDate() == null) {\n+            scenario.setDeploymentDate(campaign.getLocalDate());\n+        }\n+\n+        if (scenario.getActionDate() == null) {\n+            scenario.setActionDate(campaign.getLocalDate());\n+        }\n+\n+        if(scenario.getReturnDate() == null) {\n+            scenario.setReturnDate(campaign.getLocalDate().plusDays(trackState.getDeploymentTime()));\n+        }\n+\n+        // set the # of rerolls based on the actual lance assigned.\n+        int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+        scenario.getBackingScenario().setRerolls(tactics);\n+        // The number of defensive points available to a force entering a scenario is\n+        // 2 x tactics. By default, those points are spent on conventional minefields.\n+        if (commanderLanceHasDefensiveAssignment(scenario.getBackingScenario(), campaign)) {\n+            scenario.setNumDefensivePoints(tactics * 2);\n+            scenario.updateMinefieldCount(Minefield.TYPE_CONVENTIONAL, tactics * 2);\n+        }\n+\n+        for (int forceID : scenario.getPlayerTemplateForceIDs()) {\n+            Force force = campaign.getForce(forceID);\n+            force.clearScenarioIds(campaign, true);\n+            force.setScenarioId(scenario.getBackingScenarioID());\n+        }\n+\n+        scenario.commitPrimaryForces();\n+    }\n+\n+    /**\n+     * Utility method to determine if the current scenario's force commander\n+     * is on defence\n+     */\n+    private static boolean commanderLanceHasDefensiveAssignment(AtBDynamicScenario scenario, Campaign campaign) {\n+        Unit commanderUnit = scenario.getLanceCommander(campaign).getUnit();\n+        Lance lance = campaign.getLances().get(commanderUnit.getForceId());\n+\n+        if ((lance != null) && (lance.getRole() == AtBLanceRole.DEFENCE)) {\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * A hackish worker function that takes the given list of force IDs and\n+     * separates it into three sets;\n+     * one of forces that can be \"primary\" on a ground map\n+     * one of forces that can be \"primary\" on an atmospheric map\n+     * one of forces that can be \"primary\" in a space map\n+     * @param forceIDs List of force IDs to check\n+     * @return Sorted hash map\n+     */\n+    private static Map<MapLocation, List<Integer>> sortForcesByMapType(List<Integer> forceIDs, Campaign campaign) {\n+        Map<MapLocation, List<Integer>> retVal = new HashMap<>();\n+\n+        retVal.put(MapLocation.AllGroundTerrain, new ArrayList<>());\n+        retVal.put(MapLocation.LowAtmosphere, new ArrayList<>());\n+        retVal.put(MapLocation.Space, new ArrayList<>());\n+\n+        for (int forceID : forceIDs) {\n+            switch(campaign.getForce(forceID).getPrimaryUnitType(campaign)) {\n+            case UnitType.BATTLE_ARMOR:\n+            case UnitType.INFANTRY:\n+            case UnitType.MEK:\n+            case UnitType.TANK:\n+            case UnitType.PROTOMEK:\n+            case UnitType.VTOL:\n+                retVal.get(MapLocation.AllGroundTerrain).add(forceID);\n+                break;\n+            case UnitType.AERO:\n+                retVal.get(MapLocation.Space).add(forceID);\n+                // intentional fallthrough here, ASFs can go to atmospheric maps too\n+            case UnitType.CONV_FIGHTER:\n+                retVal.get(MapLocation.LowAtmosphere).add(forceID);\n+                break;\n+            }\n+        }\n+\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * Determine whether the user should be nagged about unresolved scenarios on AtB Stratcon tracks.\n+     * @param campaign Campaign to check.\n+     * @return An informative string containing the reasons the user was nagged.\n+     */\n+    public static String nagUnresolvedContacts(Campaign campaign) {\n+        StringBuilder sb = new StringBuilder();\n+\n+        // check every track attached to an active contract for unresolved scenarios\n+        // to which the player must deploy forces today\n+        for (AtBContract contract : campaign.getActiveAtBContracts()) {\n+            if (contract.getStratconCampaignState() == null) {\n+                continue;\n+            }\n+            \n+            for (StratconTrackState track : contract.getStratconCampaignState().getTracks()) {\n+                for (StratconScenario scenario : track.getScenarios().values()) {\n+                    if (scenario.getCurrentState() == ScenarioState.UNRESOLVED &&\n+                            campaign.getLocalDate().equals(scenario.getDeploymentDate())) {\n+                        // \"scenario name, track name\"\n+                        sb.append(String.format(\"%s, %s\\n\", scenario.getName(), track.getDisplayableName()));\n+                    }\n+                }\n+            }\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track.\n+     * Also registers it with the track and campaign.\n+     */\n+    private static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords) {\n+        int unitType = campaign.getForce(forceID).getPrimaryUnitType(campaign);\n+        ScenarioTemplate template = StratconScenarioFactory.getRandomScenario(unitType);\n+        // useful for debugging specific scenario types\n+        //ScenarioTemplate template = StratconScenarioFactory.getSpecificScenario(\"Hostile Facility.xml\");\n+\n+        return generateScenario(campaign, contract, track, forceID, coords, template);\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track,\n+     * using the given template. Also registers it with the campaign.\n+     */\n+    static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords, ScenarioTemplate template) {\n+        StratconScenario scenario = new StratconScenario();\n+        \n+        AtBDynamicScenario backingScenario = AtBDynamicScenarioFactory.initializeScenarioFromTemplate(template, contract, campaign);        \n+        scenario.setBackingScenario(backingScenario);\n+        scenario.setCoords(coords);\n+        \n+        // by default, certain conditions may make this bigger\n+        scenario.setRequiredPlayerLances(1);\n+\n+        // do an appropriate allied force if the contract calls for it\n+        // do any attached or integrated units\n+        setAlliedForceModifier(scenario, contract);\n+        setAttachedUnitsModifier(scenario, contract);\n+        applyFacilityModifiers(scenario, track, coords);\n+        applyGlobalModifiers(scenario, contract.getStratconCampaignState());\n+\n+        if ((contract.getCommandRights() == AtBContract.COM_HOUSE) ||\n+                (contract.getCommandRights() == AtBContract.COM_INTEGRATED)) {\n+            scenario.setRequiredScenario(true);\n+        }\n+\n+        AtBDynamicScenarioFactory.setScenarioModifiers(scenario.getBackingScenario());\n+        scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+        setScenarioDates(track, campaign, scenario);\n+        \n+        // the backing scenario ID must be updated after registering the backing scenario \n+        // with the campaign, so that the stratcon - backing scenario association is maintained\n+        // registering the scenario with the campaign should be done after setting\n+        // dates, otherwise, the report messages for new scenarios look weird\n+        campaign.addScenario(backingScenario, contract);\n+        scenario.setBackingScenarioID(backingScenario.getId());\n+        \n+        if (forceID > Force.FORCE_NONE) {\n+            scenario.addPrimaryForce(forceID);\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * Apply global scenario modifiers from campaign state to given scenario.\n+     */\n+    private static void applyGlobalModifiers(StratconScenario scenario, StratconCampaignState campaignState) {\n+        for (String modifierName : campaignState.getGlobalScenarioModifiers()) {\n+            AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierName);\n+\n+            if (modifier == null) {\n+                MekHQ.getLogger().error(String.format(\"Modifier %s not found; ignoring\", modifierName));\n+                continue;\n+            }\n+\n+            scenario.getBackingScenario().addScenarioModifier(modifier);\n+        }\n+    }\n+\n+    /**\n+     * Applies scenario modifiers from the current track to the given scenario.\n+     * @param scenario\n+     * @param track\n+     */\n+    private static void applyFacilityModifiers(StratconScenario scenario, StratconTrackState track, StratconCoords coords) {\n+        // loop through all the facilities on the track\n+        // if a facility has been revealed, then it has a 100% chance to apply its effect\n+        // if a facility has not been revealed, then it has a x% chance to apply its effect\n+        // if a facility is on the the scenario coordinates the it applies the local effects\n+        for (StratconCoords facilityCoords : track.getFacilities().keySet()) {\n+            boolean scenarioAtFacility = facilityCoords.equals(coords);\n+            StratconFacility facility = track.getFacilities().get(facilityCoords);\n+            List<String> modifierIDs = new ArrayList<>();\n+\n+            if (scenarioAtFacility) {\n+                modifierIDs = facility.getLocalModifiers();\n+            } else if (facility.isVisible() || (Compute.randomInt(100) <= facility.getAggroRating())) {\n+                modifierIDs = facility.getSharedModifiers();\n+            }\n+\n+            for (String modifierID : modifierIDs) {\n+                AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierID);\n+                if(modifier == null) {\n+                    MekHQ.getLogger().error(String.format(\"Modifier %s not found for facility %s\", modifierID, facility.getFormattedDisplayableName()));\n+                    continue;\n+                }\n+\n+                scenario.getBackingScenario().addScenarioModifier(modifier);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set up the appropriate primary allied force modifier, if any\n+     * @param contract The scenario's contract.\n+     */\n+    private static void setAlliedForceModifier(StratconScenario scenario, AtBContract contract) {\n+        int alliedUnitOdds = 0;\n+\n+        // first, we determine the odds of having an allied unit present\n+        // TODO: move this override out to the contract definition\n+        if (contract.getMissionType() == AtBContract.MT_RELIEFDUTY) {\n+            alliedUnitOdds = 50;\n+        } else {\n+            switch(contract.getCommandRights()) {\n+                case AtBContract.COM_INTEGRATED:\n+                    alliedUnitOdds = 50;\n+                    break;\n+                case AtBContract.COM_HOUSE:\n+                    alliedUnitOdds = 30;\n+                    break;\n+                case AtBContract.COM_LIAISON:\n+                    alliedUnitOdds = 10;\n+                    break;\n+            }\n+        }\n+\n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+\n+        // if an allied unit is present, then we want to make sure that it's ground units\n+        // for ground battles\n+        if (Compute.randomInt(100) <= alliedUnitOdds) {\n+            if((backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+               (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space)) {", "originalCommit": "b36d9fa6bf982c7b833b1ac0a0473d37f6e84760", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTE5MjA4Nw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r615192087", "bodyText": "Indent", "author": "Windchild292", "createdAt": "2021-04-17T02:06:59Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1404 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.UUID;\n+\n+import megamek.common.Compute;\n+import megamek.common.Minefield;\n+import megamek.common.UnitType;\n+import megamek.common.annotations.Nullable;\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.Utilities;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.ResolveScenarioTracker;\n+import mekhq.campaign.againstTheBot.enums.AtBLanceRole;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.event.StratconDeploymentEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.force.Lance;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier.EventTiming;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconFacility.FacilityType;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.unit.Unit;\n+\n+/**\n+ * This class contains \"rules\" logic for the AtB-Stratcon state\n+ * @author NickAragua\n+ */\n+public class StratconRulesManager {\n+    /**\n+     * What makes a particular lance eligible to be reinforcements for a scenario\n+     */\n+    public enum ReinforcementEligibilityType {\n+        /**\n+         * Nothing\n+         */\n+        None,\n+\n+        /**\n+         * Lance is already deployed to the track\n+         */\n+        ChainedScenario,\n+\n+        /**\n+         * We pay a support point or convert a victory point to a support point\n+         */\n+        SupportPoint,\n+\n+        /**\n+         * The lance's deployment orders are \"Fight\"\n+         */\n+        FightLance\n+    }\n+\n+    /**\n+     * This function potentially generates non-player-initiated scenarios for the given track.\n+     */\n+    public static void generateScenariosForTrack(Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // maps scenarios to force IDs\n+        List<StratconScenario> generatedScenarios = new ArrayList<>();\n+        boolean autoAssignLances = contract.getCommandRights() == AtBContract.COM_INTEGRATED;\n+\n+        // get this list just so we have it available\n+        List<Integer> availableForceIDs = getAvailableForceIDs(campaign);\n+        Map<MapLocation, List<Integer>> sortedAvailableForceIDs = sortForcesByMapType(availableForceIDs, campaign);\n+\n+        // make X rolls, where X is the number of required lances for the track\n+        // that's the chance to spawn a scenario.\n+        // if a scenario occurs, then we pick a random non-deployed lance and use it to drive the opfor generation later\n+        // once we've determined that scenarios occur, we loop through the ones that we generated\n+        // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all\n+        for (int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            int targetNum = calculateScenarioOdds(track, contract, false);\n+            \n+            // if we haven't already used all the player forces and are required to randomly generate a scenario\n+            if (!availableForceIDs.isEmpty() && (Compute.randomInt(100) <= targetNum)) {\n+                // pick random coordinates and force to drive the scenario\n+                int x = Compute.randomInt(track.getWidth());\n+                int y = Compute.randomInt(track.getHeight());\n+\n+                StratconCoords scenarioCoords = new StratconCoords(x, y);\n+\n+                // if forces are already assigned to these coordinates, use those instead\n+                // of randomly-selected ones\n+                if (track.getAssignedCoordForces().containsKey(scenarioCoords)) {\n+                    StratconScenario scenario = generateScenarioForExistingForces(scenarioCoords,\n+                            track.getAssignedCoordForces().get(scenarioCoords), \n+                            contract, campaign, track);\n+                    generatedScenarios.add(scenario);\n+                    continue;\n+                }\n+                \n+                // otherwise, pick a random force from the avail\n+                int randomForceIndex = Compute.randomInt(availableForceIDs.size());\n+                int randomForceID = availableForceIDs.get(randomForceIndex);\n+                \n+                // remove the force from the available lists so we don't designate it as primary twice\n+                availableForceIDs.remove(randomForceIndex);\n+\n+                // we want to remove the actual int with the value, not the value at the index\n+                sortedAvailableForceIDs.get(MapLocation.AllGroundTerrain).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.LowAtmosphere).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.Space).remove((Integer) randomForceID);\n+\n+                // two scenarios on the same coordinates wind up increasing in size\n+                if (track.getScenarios().containsKey(scenarioCoords)) {\n+                    track.getScenarios().get(scenarioCoords).incrementRequiredPlayerLances();\n+                    assignAppropriateExtraForceToScenario(track.getScenarios().get(scenarioCoords), sortedAvailableForceIDs);\n+                    continue;\n+                }\n+\n+                StratconScenario scenario = setupScenario(scenarioCoords, randomForceID, campaign, contract, track);\n+                generatedScenarios.add(scenario);\n+\n+                // if we're auto-assigning lances, deploy the force to the track as well\n+                if (autoAssignLances) {\n+                    processForceDeployment(scenarioCoords, randomForceID, campaign, track, false);\n+                }\n+            }\n+        }\n+\n+        // if under liaison command, pick a random scenario from the ones generated\n+        // to set as required and attach liaison\n+        if (contract.getCommandRights() == AtBContract.COM_LIAISON) {\n+        \tStratconScenario randomScenario = Utilities.getRandomItem(generatedScenarios);\n+        \trandomScenario.setRequiredScenario(true);\n+            setAttachedUnitsModifier(randomScenario, contract);\n+        }\n+\n+        // now, we loop through all the scenarios we set up\n+        // and generate the opfors / events / etc\n+        // if not auto-assigning lances, we then back out the lance assignments.\n+        for (StratconScenario scenario : generatedScenarios) {\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+\n+            if(!autoAssignLances && !scenario.ignoreForceAutoAssignment()) {\n+                for(int forceID : scenario.getPlayerTemplateForceIDs()) {\n+                    scenario.getBackingScenario().removeForce(forceID);\n+                }\n+\n+                scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                track.addScenario(scenario);\n+            } else {\n+                commitPrimaryForces(campaign, scenario, track);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Given a set of force IDs and coordinates, generate a scenario\n+     * Useful for when we want to generate scenarios \n+     * for forces already deployed to a track\n+     */\n+    public static StratconScenario generateScenarioForExistingForces(StratconCoords scenarioCoords, \n+            Set<Integer> forceIDs, AtBContract contract, Campaign campaign, StratconTrackState track) {\n+        boolean firstForce = true;\n+        StratconScenario scenario = null;\n+        \n+        for (int forceID : forceIDs) {\n+            if (firstForce) {\n+                scenario = setupScenario(scenarioCoords, forceID, campaign, contract, track);\n+                firstForce = false;\n+            } else {\n+                scenario.incrementRequiredPlayerLances();\n+                scenario.addPrimaryForce(forceID);\n+            }\n+        }\n+        \n+        // this is theoretically possible if forceIDs is passed in as null - not likely in practice\n+        // but might as well, to future-proof.\n+        if (scenario != null) {\n+            scenario.setIgnoreForceAutoAssignment(true);\n+        }\n+        \n+        return scenario;\n+    }\n+\n+    /**\n+     * Deploys a force to the given coordinates on the given track as a result of explicit player action.\n+     */\n+    public static void deployForceToCoords(StratconCoords coords, int forceID, \n+            Campaign campaign, AtBContract contract, StratconTrackState track, boolean sticky) {\n+        // the following things should happen:\n+        // 1. call to \"process force deployment\", which reveals fog of war in or around the coords, depending on force role\n+        // 2. if coords are a hostile facility, we get a facility mission\n+        // 3. if coords are empty, we *may* get a mission\n+\n+        processForceDeployment(coords, forceID, campaign, track, sticky);\n+\n+        // don't create a scenario on top of allied facilities\n+        StratconFacility facility = track.getFacility(coords);\n+        boolean isNonAlliedFacility = (facility != null) && (facility.getOwner() != ForceAlignment.Allied);\n+        int targetNum = calculateScenarioOdds(track, contract, true);\n+        boolean spawnScenario = (facility == null) && (Compute.randomInt(100) <= targetNum);\n+\n+        if (isNonAlliedFacility || spawnScenario) {\n+            StratconScenario scenario = setupScenario(coords, forceID, campaign, contract, track);\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            commitPrimaryForces(campaign, scenario, track);\n+        }\n+    }\n+\n+    /**\n+     * Logic to set up a scenario\n+     */\n+    private static StratconScenario setupScenario(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        StratconScenario scenario = null;\n+\n+        if (track.getFacilities().containsKey(coords)) {\n+            StratconFacility facility = track.getFacility(coords);\n+            boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+            ScenarioTemplate template = StratconScenarioFactory.getFacilityScenario(alliedFacility);\n+            scenario = generateScenario(campaign, contract, track, forceID, coords, template);\n+            setupFacilityScenario(scenario, facility);\n+        } else {\n+            scenario = generateScenario(campaign, contract, track, forceID, coords);\n+\n+            // we may generate a facility scenario randomly - if so, do the facility-related stuff\n+            // and add a new facility to the track\n+            if (scenario.getBackingScenario().getTemplate().isFacilityScenario()) {\n+                StratconFacility facility = scenario.getBackingScenario().getTemplate().isHostileFacility() ?\n+                        StratconFacilityFactory.getRandomHostileFacility() : StratconFacilityFactory.getRandomAlliedFacility();\n+                facility.setVisible(true);\n+                track.addFacility(coords, facility);\n+                setupFacilityScenario(scenario, facility);\n+            }\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * carries out tasks relevant to facility scenarios\n+     */\n+    private static void setupFacilityScenario(StratconScenario scenario, StratconFacility facility) {\n+        // this includes:\n+        // for hostile facilities\n+        // - add a destroy objective (always the option to level the facility)\n+        // - add a capture objective (always the option to capture the facility)\n+        // - if so indicated by parameter, roll a random hostile facility objective and add it if not capture/destroy\n+        // for allied facilities\n+        // - add a defend objective (always the option to defend the facility)\n+        // - if so indicated by parameter, roll a random allied facility objective and add it if not defend\n+        AtBScenarioModifier objectiveModifier = null;\n+        boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+\n+        if (alliedFacility) {\n+            objectiveModifier = AtBScenarioModifier.getRandomAlliedFacilityModifier();\n+        } else {\n+            objectiveModifier = AtBScenarioModifier.getRandomHostileFacilityModifier();\n+        }\n+\n+        if (objectiveModifier != null) {\n+            scenario.getBackingScenario().addScenarioModifier(objectiveModifier);\n+            scenario.getBackingScenario().setName(String.format(\"%s - %s - %s\",\n+                    facility.getFacilityType(), alliedFacility ? \"Allied\" : \"Hostile\", objectiveModifier.getModifierName()));\n+        }\n+\n+        // add the \"fixed\" hostile facility modifiers after the primary ones\n+        if (!alliedFacility) {\n+            for(AtBScenarioModifier modifier : AtBScenarioModifier.getRequiredHostileFacilityModifiers()) {\n+                if(!scenario.getBackingScenario().alreadyHasModifier(modifier)) {\n+                    scenario.getBackingScenario().addScenarioModifier(modifier);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void processFacilityEffects(StratconTrackState track) {\n+        // TODO: these are \"weekly\"? effects that a stratcon facility has on the campaign/track state\n+        // currrently, that's\n+        // supply depot - allied - +1 sp\n+        // supply depot - hostile - +5% BV budget to all scenarios on track (shared modifier, so should be implemented there)\n+        // data center - allied - +1% star league cache contract (don't implement yet, but...)\n+        // data center - hostile - +5% scenario odds in track\n+        // industrial center - allied - all scenarios here have THIS IS COMING OUT OF YOUR PAYCHECK modifier\n+        // orbital defense - allied - sets 'no hostile aircraft' flag for track\n+        // orbital defense - hostile - sets 'no allied aircraft' flag for track\n+        // early warning system - allied - sets 'intercept allied base attacks' flag for track\n+        // early warning system - hostile - sets 'intercept hostile base attacks' flag for track\n+    }\n+\n+    /**\n+     * Process the deployment of a force to the given coordinates on the given track.\n+     */\n+    public static void processForceDeployment(StratconCoords coords, int forceID, \n+            Campaign campaign, StratconTrackState track, boolean sticky) {\n+        track.getRevealedCoords().add(coords);\n+        StratconFacility facility = track.getFacility(coords);\n+        if (facility != null) {\n+            facility.setVisible(true);\n+        }\n+\n+        if (campaign.getLances().get(forceID).getRole() == AtBLanceRole.SCOUTING) {\n+            for(int direction = 0; direction < 6; direction++) {\n+                StratconCoords checkCoords = coords.translate(direction);\n+\n+                facility = track.getFacility(checkCoords);\n+                if(facility != null) {\n+                    facility.setVisible(true);\n+                }\n+\n+                track.getRevealedCoords().add(coords.translate(direction));\n+            }\n+        }\n+\n+        // the force may be located in other places on the track - clear it out\n+        track.unassignForce(forceID);\n+        track.assignForce(forceID, coords, campaign.getLocalDate(), sticky);\n+        MekHQ.triggerEvent(new StratconDeploymentEvent(campaign.getForce(forceID)));\n+    }\n+\n+    /**\n+     * Worker function that processes the effects of deploying a reinforcement force to a scenario\n+     */\n+    public static boolean processReinforcementDeployment(ReinforcementEligibilityType reinforcementType,\n+            StratconCampaignState campaignState, StratconScenario scenario, Campaign campaign) {\n+        // if the force is already deployed to the track, we're done\n+        // if the force is a fight lance or we're using a support point\n+        // if there is an SP to burn, burn it and we're done\n+        // if there is a VP to burn, burn it and we're done\n+        // now, roll 2d6 + lance commander tactics\n+        // 9+ = deploy\n+        // 6+ = deploy, apply negative modifier to scenario\n+        // 2+ = fail to deploy, apply negative modifier to scenario; if fight lance, treat as 6+\n+\n+        if ((reinforcementType == ReinforcementEligibilityType.FightLance) ||\n+                (reinforcementType == ReinforcementEligibilityType.SupportPoint)) {\n+\n+            if (campaignState.getSupportPoints() > 0) {\n+                campaignState.useSupportPoint();\n+                return true;\n+            } else if (campaignState.getVictoryPoints() > 0) {\n+                campaignState.updateVictoryPoints(-1);\n+                return true;\n+            }\n+\n+            int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+            int roll = Compute.d6(2);\n+            int result = roll + tactics;\n+\n+            StringBuilder reportStatus = new StringBuilder();\n+            reportStatus.append(String.format(\"Attempting to reinforce scenario %s without SP/VP, roll 2d6 + %d: %d\",\n+                    scenario.getName(), tactics, result));\n+\n+            // fail to reinforce\n+            if ((result < 6) && (reinforcementType != ReinforcementEligibilityType.FightLance)) {\n+                reportStatus.append(\" - reinforcement attempt failed.\");\n+                campaign.addReport(reportStatus.toString());\n+                return false;\n+            // succeed but get an extra negative event added to the scenario\n+            } else if (result < 9) {\n+                MapLocation mapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+                AtBScenarioModifier scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+\n+                // keep rolling until we get an applicable one\n+                // TODO: have the AtBScenarioModifier sort these out instead for performance?\n+                while (scenarioModifier.getEventTiming() != EventTiming.PostForceGeneration) {\n+                    scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+                }\n+\n+                scenarioModifier.processModifier(scenario.getBackingScenario(), campaign, EventTiming.PostForceGeneration);\n+\n+                reportStatus.append(String.format(\" - reinforcement attempt succeeded; extra negative modifier (%s) applied to scenario.\",\n+                        scenarioModifier.getModifierName()));\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            // succeed without reservation\n+            } else {\n+                reportStatus.append(\" - reinforcement attempt succeeded;\");\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            }\n+        } else if (reinforcementType == ReinforcementEligibilityType.None) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Assigns a force to the scenario such that the majority of the force can be deployed\n+     */\n+    private static void assignAppropriateExtraForceToScenario(StratconScenario scenario,\n+            Map<MapLocation, List<Integer>> sortedAvailableForceIDs) {\n+        // the goal of this function is to avoid assigning ground units to air battles\n+        // and ground units/conventional fighters to space battle\n+\n+        List<MapLocation> mapLocations = new ArrayList<>();\n+        mapLocations.add(MapLocation.Space); // can always add ASFs\n+\n+        MapLocation scenarioMapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+\n+        if (scenarioMapLocation == MapLocation.LowAtmosphere) {\n+            mapLocations.add(MapLocation.LowAtmosphere); // can add conventional fighters to ground or low atmo battles\n+        }\n+\n+        if ((scenarioMapLocation == MapLocation.AllGroundTerrain) ||\n+                (scenarioMapLocation == MapLocation.SpecificGroundTerrain)) {\n+            mapLocations.add(MapLocation.AllGroundTerrain); // can only add ground units to ground battles\n+        }\n+\n+        MapLocation selectedLocation = mapLocations.get(Compute.randomInt(mapLocations.size()));\n+        List<Integer> forceIDs = sortedAvailableForceIDs.get(selectedLocation);\n+        int forceIndex = Compute.randomInt(forceIDs.size());\n+        int forceID = forceIDs.get(forceIndex);\n+        forceIDs.remove(forceIndex);\n+\n+        scenario.addPrimaryForce(forceID);\n+    }\n+\n+    /**\n+     * Worker function that \"locks in\" a scenario -\n+     * Adds it to the campaign so it's visible in the briefing room,\n+     * adds it to the track\n+     *\n+     */\n+    public static void commitPrimaryForces(Campaign campaign, StratconScenario scenario, StratconTrackState trackState) {\n+        trackState.addScenario(scenario);\n+\n+        // set up dates for the scenario if doesn't have them already\n+        if (scenario.getDeploymentDate() == null) {\n+            scenario.setDeploymentDate(campaign.getLocalDate());\n+        }\n+\n+        if (scenario.getActionDate() == null) {\n+            scenario.setActionDate(campaign.getLocalDate());\n+        }\n+\n+        if(scenario.getReturnDate() == null) {\n+            scenario.setReturnDate(campaign.getLocalDate().plusDays(trackState.getDeploymentTime()));\n+        }\n+\n+        // set the # of rerolls based on the actual lance assigned.\n+        int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+        scenario.getBackingScenario().setRerolls(tactics);\n+        // The number of defensive points available to a force entering a scenario is\n+        // 2 x tactics. By default, those points are spent on conventional minefields.\n+        if (commanderLanceHasDefensiveAssignment(scenario.getBackingScenario(), campaign)) {\n+            scenario.setNumDefensivePoints(tactics * 2);\n+            scenario.updateMinefieldCount(Minefield.TYPE_CONVENTIONAL, tactics * 2);\n+        }\n+\n+        for (int forceID : scenario.getPlayerTemplateForceIDs()) {\n+            Force force = campaign.getForce(forceID);\n+            force.clearScenarioIds(campaign, true);\n+            force.setScenarioId(scenario.getBackingScenarioID());\n+        }\n+\n+        scenario.commitPrimaryForces();\n+    }\n+\n+    /**\n+     * Utility method to determine if the current scenario's force commander\n+     * is on defence\n+     */\n+    private static boolean commanderLanceHasDefensiveAssignment(AtBDynamicScenario scenario, Campaign campaign) {\n+        Unit commanderUnit = scenario.getLanceCommander(campaign).getUnit();\n+        Lance lance = campaign.getLances().get(commanderUnit.getForceId());\n+\n+        if ((lance != null) && (lance.getRole() == AtBLanceRole.DEFENCE)) {\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * A hackish worker function that takes the given list of force IDs and\n+     * separates it into three sets;\n+     * one of forces that can be \"primary\" on a ground map\n+     * one of forces that can be \"primary\" on an atmospheric map\n+     * one of forces that can be \"primary\" in a space map\n+     * @param forceIDs List of force IDs to check\n+     * @return Sorted hash map\n+     */\n+    private static Map<MapLocation, List<Integer>> sortForcesByMapType(List<Integer> forceIDs, Campaign campaign) {\n+        Map<MapLocation, List<Integer>> retVal = new HashMap<>();\n+\n+        retVal.put(MapLocation.AllGroundTerrain, new ArrayList<>());\n+        retVal.put(MapLocation.LowAtmosphere, new ArrayList<>());\n+        retVal.put(MapLocation.Space, new ArrayList<>());\n+\n+        for (int forceID : forceIDs) {\n+            switch(campaign.getForce(forceID).getPrimaryUnitType(campaign)) {\n+            case UnitType.BATTLE_ARMOR:\n+            case UnitType.INFANTRY:\n+            case UnitType.MEK:\n+            case UnitType.TANK:\n+            case UnitType.PROTOMEK:\n+            case UnitType.VTOL:\n+                retVal.get(MapLocation.AllGroundTerrain).add(forceID);\n+                break;\n+            case UnitType.AERO:\n+                retVal.get(MapLocation.Space).add(forceID);\n+                // intentional fallthrough here, ASFs can go to atmospheric maps too\n+            case UnitType.CONV_FIGHTER:\n+                retVal.get(MapLocation.LowAtmosphere).add(forceID);\n+                break;\n+            }\n+        }\n+\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * Determine whether the user should be nagged about unresolved scenarios on AtB Stratcon tracks.\n+     * @param campaign Campaign to check.\n+     * @return An informative string containing the reasons the user was nagged.\n+     */\n+    public static String nagUnresolvedContacts(Campaign campaign) {\n+        StringBuilder sb = new StringBuilder();\n+\n+        // check every track attached to an active contract for unresolved scenarios\n+        // to which the player must deploy forces today\n+        for (AtBContract contract : campaign.getActiveAtBContracts()) {\n+            if (contract.getStratconCampaignState() == null) {\n+                continue;\n+            }\n+            \n+            for (StratconTrackState track : contract.getStratconCampaignState().getTracks()) {\n+                for (StratconScenario scenario : track.getScenarios().values()) {\n+                    if (scenario.getCurrentState() == ScenarioState.UNRESOLVED &&\n+                            campaign.getLocalDate().equals(scenario.getDeploymentDate())) {\n+                        // \"scenario name, track name\"\n+                        sb.append(String.format(\"%s, %s\\n\", scenario.getName(), track.getDisplayableName()));\n+                    }\n+                }\n+            }\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track.\n+     * Also registers it with the track and campaign.\n+     */\n+    private static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords) {\n+        int unitType = campaign.getForce(forceID).getPrimaryUnitType(campaign);\n+        ScenarioTemplate template = StratconScenarioFactory.getRandomScenario(unitType);\n+        // useful for debugging specific scenario types\n+        //ScenarioTemplate template = StratconScenarioFactory.getSpecificScenario(\"Hostile Facility.xml\");\n+\n+        return generateScenario(campaign, contract, track, forceID, coords, template);\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track,\n+     * using the given template. Also registers it with the campaign.\n+     */\n+    static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords, ScenarioTemplate template) {\n+        StratconScenario scenario = new StratconScenario();\n+        \n+        AtBDynamicScenario backingScenario = AtBDynamicScenarioFactory.initializeScenarioFromTemplate(template, contract, campaign);        \n+        scenario.setBackingScenario(backingScenario);\n+        scenario.setCoords(coords);\n+        \n+        // by default, certain conditions may make this bigger\n+        scenario.setRequiredPlayerLances(1);\n+\n+        // do an appropriate allied force if the contract calls for it\n+        // do any attached or integrated units\n+        setAlliedForceModifier(scenario, contract);\n+        setAttachedUnitsModifier(scenario, contract);\n+        applyFacilityModifiers(scenario, track, coords);\n+        applyGlobalModifiers(scenario, contract.getStratconCampaignState());\n+\n+        if ((contract.getCommandRights() == AtBContract.COM_HOUSE) ||\n+                (contract.getCommandRights() == AtBContract.COM_INTEGRATED)) {\n+            scenario.setRequiredScenario(true);\n+        }\n+\n+        AtBDynamicScenarioFactory.setScenarioModifiers(scenario.getBackingScenario());\n+        scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+        setScenarioDates(track, campaign, scenario);\n+        \n+        // the backing scenario ID must be updated after registering the backing scenario \n+        // with the campaign, so that the stratcon - backing scenario association is maintained\n+        // registering the scenario with the campaign should be done after setting\n+        // dates, otherwise, the report messages for new scenarios look weird\n+        campaign.addScenario(backingScenario, contract);\n+        scenario.setBackingScenarioID(backingScenario.getId());\n+        \n+        if (forceID > Force.FORCE_NONE) {\n+            scenario.addPrimaryForce(forceID);\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * Apply global scenario modifiers from campaign state to given scenario.\n+     */\n+    private static void applyGlobalModifiers(StratconScenario scenario, StratconCampaignState campaignState) {\n+        for (String modifierName : campaignState.getGlobalScenarioModifiers()) {\n+            AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierName);\n+\n+            if (modifier == null) {\n+                MekHQ.getLogger().error(String.format(\"Modifier %s not found; ignoring\", modifierName));\n+                continue;\n+            }\n+\n+            scenario.getBackingScenario().addScenarioModifier(modifier);\n+        }\n+    }\n+\n+    /**\n+     * Applies scenario modifiers from the current track to the given scenario.\n+     * @param scenario\n+     * @param track\n+     */\n+    private static void applyFacilityModifiers(StratconScenario scenario, StratconTrackState track, StratconCoords coords) {\n+        // loop through all the facilities on the track\n+        // if a facility has been revealed, then it has a 100% chance to apply its effect\n+        // if a facility has not been revealed, then it has a x% chance to apply its effect\n+        // if a facility is on the the scenario coordinates the it applies the local effects\n+        for (StratconCoords facilityCoords : track.getFacilities().keySet()) {\n+            boolean scenarioAtFacility = facilityCoords.equals(coords);\n+            StratconFacility facility = track.getFacilities().get(facilityCoords);\n+            List<String> modifierIDs = new ArrayList<>();\n+\n+            if (scenarioAtFacility) {\n+                modifierIDs = facility.getLocalModifiers();\n+            } else if (facility.isVisible() || (Compute.randomInt(100) <= facility.getAggroRating())) {\n+                modifierIDs = facility.getSharedModifiers();\n+            }\n+\n+            for (String modifierID : modifierIDs) {\n+                AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierID);\n+                if(modifier == null) {\n+                    MekHQ.getLogger().error(String.format(\"Modifier %s not found for facility %s\", modifierID, facility.getFormattedDisplayableName()));\n+                    continue;\n+                }\n+\n+                scenario.getBackingScenario().addScenarioModifier(modifier);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set up the appropriate primary allied force modifier, if any\n+     * @param contract The scenario's contract.\n+     */\n+    private static void setAlliedForceModifier(StratconScenario scenario, AtBContract contract) {\n+        int alliedUnitOdds = 0;\n+\n+        // first, we determine the odds of having an allied unit present\n+        // TODO: move this override out to the contract definition\n+        if (contract.getMissionType() == AtBContract.MT_RELIEFDUTY) {\n+            alliedUnitOdds = 50;\n+        } else {\n+            switch(contract.getCommandRights()) {\n+                case AtBContract.COM_INTEGRATED:\n+                    alliedUnitOdds = 50;\n+                    break;\n+                case AtBContract.COM_HOUSE:\n+                    alliedUnitOdds = 30;\n+                    break;\n+                case AtBContract.COM_LIAISON:\n+                    alliedUnitOdds = 10;\n+                    break;\n+            }\n+        }\n+\n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+\n+        // if an allied unit is present, then we want to make sure that it's ground units\n+        // for ground battles\n+        if (Compute.randomInt(100) <= alliedUnitOdds) {\n+            if((backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+               (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space)) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_ALLIED_AIR_UNITS));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_ALLIED_GROUND_UNITS));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set the 'attached' units modifier for the current scenario (integrated, house, liaison),\n+     * and make sure we're not deploying ground units to an air scenario\n+     * @param contract The scenario's contract\n+     */\n+    public static void setAttachedUnitsModifier(StratconScenario scenario, AtBContract contract) {\n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+        boolean airBattle = (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+                (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space);\n+\n+        // if we're on cadre duty, we're getting three trainees, period\n+        if (contract.getMissionType() == AtBContract.MT_CADREDUTY) {\n+            if (airBattle) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_TRAINEES_AIR));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_TRAINEES_GROUND));\n+            }\n+            return;\n+        }\n+\n+        // if we're under non-independent command rights, a supervisor may come along\n+        switch (contract.getCommandRights()) {\n+            case AtBContract.COM_INTEGRATED:\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(airBattle \n+                        ? MekHqConstants.SCENARIO_MODIFIER_INTEGRATED_UNITS_AIR\n+                        : MekHqConstants.SCENARIO_MODIFIER_INTEGRATED_UNITS_GROUND));\n+                break;\n+            case AtBContract.COM_HOUSE:\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(airBattle \n+                        ? MekHqConstants.SCENARIO_MODIFIER_HOUSE_CO_AIR\n+                        : MekHqConstants.SCENARIO_MODIFIER_HOUSE_CO_GROUND));\n+                break;\n+            case AtBContract.COM_LIAISON:\n+                if (scenario.isRequiredScenario()) {\n+                    backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(airBattle \n+                            ? MekHqConstants.SCENARIO_MODIFIER_LIAISON_AIR\n+                            : MekHqConstants.SCENARIO_MODIFIER_LIAISON_GROUND));\n+                }\n+                break;\n+        }\n+    }\n+\n+    /**\n+     * Worker function that sets scenario deploy/battle/return dates based on the track's properties and current campaign date\n+     */\n+    private static void setScenarioDates(StratconTrackState track, Campaign campaign, StratconScenario scenario) {\n+     // set up deployment day, battle day, return day here", "originalCommit": "b36d9fa6bf982c7b833b1ac0a0473d37f6e84760", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTE5MjEwNQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r615192105", "bodyText": "Brackets", "author": "Windchild292", "createdAt": "2021-04-17T02:07:13Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1404 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.UUID;\n+\n+import megamek.common.Compute;\n+import megamek.common.Minefield;\n+import megamek.common.UnitType;\n+import megamek.common.annotations.Nullable;\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.Utilities;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.ResolveScenarioTracker;\n+import mekhq.campaign.againstTheBot.enums.AtBLanceRole;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.event.StratconDeploymentEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.force.Lance;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier.EventTiming;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconFacility.FacilityType;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.unit.Unit;\n+\n+/**\n+ * This class contains \"rules\" logic for the AtB-Stratcon state\n+ * @author NickAragua\n+ */\n+public class StratconRulesManager {\n+    /**\n+     * What makes a particular lance eligible to be reinforcements for a scenario\n+     */\n+    public enum ReinforcementEligibilityType {\n+        /**\n+         * Nothing\n+         */\n+        None,\n+\n+        /**\n+         * Lance is already deployed to the track\n+         */\n+        ChainedScenario,\n+\n+        /**\n+         * We pay a support point or convert a victory point to a support point\n+         */\n+        SupportPoint,\n+\n+        /**\n+         * The lance's deployment orders are \"Fight\"\n+         */\n+        FightLance\n+    }\n+\n+    /**\n+     * This function potentially generates non-player-initiated scenarios for the given track.\n+     */\n+    public static void generateScenariosForTrack(Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // maps scenarios to force IDs\n+        List<StratconScenario> generatedScenarios = new ArrayList<>();\n+        boolean autoAssignLances = contract.getCommandRights() == AtBContract.COM_INTEGRATED;\n+\n+        // get this list just so we have it available\n+        List<Integer> availableForceIDs = getAvailableForceIDs(campaign);\n+        Map<MapLocation, List<Integer>> sortedAvailableForceIDs = sortForcesByMapType(availableForceIDs, campaign);\n+\n+        // make X rolls, where X is the number of required lances for the track\n+        // that's the chance to spawn a scenario.\n+        // if a scenario occurs, then we pick a random non-deployed lance and use it to drive the opfor generation later\n+        // once we've determined that scenarios occur, we loop through the ones that we generated\n+        // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all\n+        for (int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            int targetNum = calculateScenarioOdds(track, contract, false);\n+            \n+            // if we haven't already used all the player forces and are required to randomly generate a scenario\n+            if (!availableForceIDs.isEmpty() && (Compute.randomInt(100) <= targetNum)) {\n+                // pick random coordinates and force to drive the scenario\n+                int x = Compute.randomInt(track.getWidth());\n+                int y = Compute.randomInt(track.getHeight());\n+\n+                StratconCoords scenarioCoords = new StratconCoords(x, y);\n+\n+                // if forces are already assigned to these coordinates, use those instead\n+                // of randomly-selected ones\n+                if (track.getAssignedCoordForces().containsKey(scenarioCoords)) {\n+                    StratconScenario scenario = generateScenarioForExistingForces(scenarioCoords,\n+                            track.getAssignedCoordForces().get(scenarioCoords), \n+                            contract, campaign, track);\n+                    generatedScenarios.add(scenario);\n+                    continue;\n+                }\n+                \n+                // otherwise, pick a random force from the avail\n+                int randomForceIndex = Compute.randomInt(availableForceIDs.size());\n+                int randomForceID = availableForceIDs.get(randomForceIndex);\n+                \n+                // remove the force from the available lists so we don't designate it as primary twice\n+                availableForceIDs.remove(randomForceIndex);\n+\n+                // we want to remove the actual int with the value, not the value at the index\n+                sortedAvailableForceIDs.get(MapLocation.AllGroundTerrain).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.LowAtmosphere).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.Space).remove((Integer) randomForceID);\n+\n+                // two scenarios on the same coordinates wind up increasing in size\n+                if (track.getScenarios().containsKey(scenarioCoords)) {\n+                    track.getScenarios().get(scenarioCoords).incrementRequiredPlayerLances();\n+                    assignAppropriateExtraForceToScenario(track.getScenarios().get(scenarioCoords), sortedAvailableForceIDs);\n+                    continue;\n+                }\n+\n+                StratconScenario scenario = setupScenario(scenarioCoords, randomForceID, campaign, contract, track);\n+                generatedScenarios.add(scenario);\n+\n+                // if we're auto-assigning lances, deploy the force to the track as well\n+                if (autoAssignLances) {\n+                    processForceDeployment(scenarioCoords, randomForceID, campaign, track, false);\n+                }\n+            }\n+        }\n+\n+        // if under liaison command, pick a random scenario from the ones generated\n+        // to set as required and attach liaison\n+        if (contract.getCommandRights() == AtBContract.COM_LIAISON) {\n+        \tStratconScenario randomScenario = Utilities.getRandomItem(generatedScenarios);\n+        \trandomScenario.setRequiredScenario(true);\n+            setAttachedUnitsModifier(randomScenario, contract);\n+        }\n+\n+        // now, we loop through all the scenarios we set up\n+        // and generate the opfors / events / etc\n+        // if not auto-assigning lances, we then back out the lance assignments.\n+        for (StratconScenario scenario : generatedScenarios) {\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+\n+            if(!autoAssignLances && !scenario.ignoreForceAutoAssignment()) {\n+                for(int forceID : scenario.getPlayerTemplateForceIDs()) {\n+                    scenario.getBackingScenario().removeForce(forceID);\n+                }\n+\n+                scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                track.addScenario(scenario);\n+            } else {\n+                commitPrimaryForces(campaign, scenario, track);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Given a set of force IDs and coordinates, generate a scenario\n+     * Useful for when we want to generate scenarios \n+     * for forces already deployed to a track\n+     */\n+    public static StratconScenario generateScenarioForExistingForces(StratconCoords scenarioCoords, \n+            Set<Integer> forceIDs, AtBContract contract, Campaign campaign, StratconTrackState track) {\n+        boolean firstForce = true;\n+        StratconScenario scenario = null;\n+        \n+        for (int forceID : forceIDs) {\n+            if (firstForce) {\n+                scenario = setupScenario(scenarioCoords, forceID, campaign, contract, track);\n+                firstForce = false;\n+            } else {\n+                scenario.incrementRequiredPlayerLances();\n+                scenario.addPrimaryForce(forceID);\n+            }\n+        }\n+        \n+        // this is theoretically possible if forceIDs is passed in as null - not likely in practice\n+        // but might as well, to future-proof.\n+        if (scenario != null) {\n+            scenario.setIgnoreForceAutoAssignment(true);\n+        }\n+        \n+        return scenario;\n+    }\n+\n+    /**\n+     * Deploys a force to the given coordinates on the given track as a result of explicit player action.\n+     */\n+    public static void deployForceToCoords(StratconCoords coords, int forceID, \n+            Campaign campaign, AtBContract contract, StratconTrackState track, boolean sticky) {\n+        // the following things should happen:\n+        // 1. call to \"process force deployment\", which reveals fog of war in or around the coords, depending on force role\n+        // 2. if coords are a hostile facility, we get a facility mission\n+        // 3. if coords are empty, we *may* get a mission\n+\n+        processForceDeployment(coords, forceID, campaign, track, sticky);\n+\n+        // don't create a scenario on top of allied facilities\n+        StratconFacility facility = track.getFacility(coords);\n+        boolean isNonAlliedFacility = (facility != null) && (facility.getOwner() != ForceAlignment.Allied);\n+        int targetNum = calculateScenarioOdds(track, contract, true);\n+        boolean spawnScenario = (facility == null) && (Compute.randomInt(100) <= targetNum);\n+\n+        if (isNonAlliedFacility || spawnScenario) {\n+            StratconScenario scenario = setupScenario(coords, forceID, campaign, contract, track);\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            commitPrimaryForces(campaign, scenario, track);\n+        }\n+    }\n+\n+    /**\n+     * Logic to set up a scenario\n+     */\n+    private static StratconScenario setupScenario(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        StratconScenario scenario = null;\n+\n+        if (track.getFacilities().containsKey(coords)) {\n+            StratconFacility facility = track.getFacility(coords);\n+            boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+            ScenarioTemplate template = StratconScenarioFactory.getFacilityScenario(alliedFacility);\n+            scenario = generateScenario(campaign, contract, track, forceID, coords, template);\n+            setupFacilityScenario(scenario, facility);\n+        } else {\n+            scenario = generateScenario(campaign, contract, track, forceID, coords);\n+\n+            // we may generate a facility scenario randomly - if so, do the facility-related stuff\n+            // and add a new facility to the track\n+            if (scenario.getBackingScenario().getTemplate().isFacilityScenario()) {\n+                StratconFacility facility = scenario.getBackingScenario().getTemplate().isHostileFacility() ?\n+                        StratconFacilityFactory.getRandomHostileFacility() : StratconFacilityFactory.getRandomAlliedFacility();\n+                facility.setVisible(true);\n+                track.addFacility(coords, facility);\n+                setupFacilityScenario(scenario, facility);\n+            }\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * carries out tasks relevant to facility scenarios\n+     */\n+    private static void setupFacilityScenario(StratconScenario scenario, StratconFacility facility) {\n+        // this includes:\n+        // for hostile facilities\n+        // - add a destroy objective (always the option to level the facility)\n+        // - add a capture objective (always the option to capture the facility)\n+        // - if so indicated by parameter, roll a random hostile facility objective and add it if not capture/destroy\n+        // for allied facilities\n+        // - add a defend objective (always the option to defend the facility)\n+        // - if so indicated by parameter, roll a random allied facility objective and add it if not defend\n+        AtBScenarioModifier objectiveModifier = null;\n+        boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+\n+        if (alliedFacility) {\n+            objectiveModifier = AtBScenarioModifier.getRandomAlliedFacilityModifier();\n+        } else {\n+            objectiveModifier = AtBScenarioModifier.getRandomHostileFacilityModifier();\n+        }\n+\n+        if (objectiveModifier != null) {\n+            scenario.getBackingScenario().addScenarioModifier(objectiveModifier);\n+            scenario.getBackingScenario().setName(String.format(\"%s - %s - %s\",\n+                    facility.getFacilityType(), alliedFacility ? \"Allied\" : \"Hostile\", objectiveModifier.getModifierName()));\n+        }\n+\n+        // add the \"fixed\" hostile facility modifiers after the primary ones\n+        if (!alliedFacility) {\n+            for(AtBScenarioModifier modifier : AtBScenarioModifier.getRequiredHostileFacilityModifiers()) {\n+                if(!scenario.getBackingScenario().alreadyHasModifier(modifier)) {\n+                    scenario.getBackingScenario().addScenarioModifier(modifier);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void processFacilityEffects(StratconTrackState track) {\n+        // TODO: these are \"weekly\"? effects that a stratcon facility has on the campaign/track state\n+        // currrently, that's\n+        // supply depot - allied - +1 sp\n+        // supply depot - hostile - +5% BV budget to all scenarios on track (shared modifier, so should be implemented there)\n+        // data center - allied - +1% star league cache contract (don't implement yet, but...)\n+        // data center - hostile - +5% scenario odds in track\n+        // industrial center - allied - all scenarios here have THIS IS COMING OUT OF YOUR PAYCHECK modifier\n+        // orbital defense - allied - sets 'no hostile aircraft' flag for track\n+        // orbital defense - hostile - sets 'no allied aircraft' flag for track\n+        // early warning system - allied - sets 'intercept allied base attacks' flag for track\n+        // early warning system - hostile - sets 'intercept hostile base attacks' flag for track\n+    }\n+\n+    /**\n+     * Process the deployment of a force to the given coordinates on the given track.\n+     */\n+    public static void processForceDeployment(StratconCoords coords, int forceID, \n+            Campaign campaign, StratconTrackState track, boolean sticky) {\n+        track.getRevealedCoords().add(coords);\n+        StratconFacility facility = track.getFacility(coords);\n+        if (facility != null) {\n+            facility.setVisible(true);\n+        }\n+\n+        if (campaign.getLances().get(forceID).getRole() == AtBLanceRole.SCOUTING) {\n+            for(int direction = 0; direction < 6; direction++) {\n+                StratconCoords checkCoords = coords.translate(direction);\n+\n+                facility = track.getFacility(checkCoords);\n+                if(facility != null) {\n+                    facility.setVisible(true);\n+                }\n+\n+                track.getRevealedCoords().add(coords.translate(direction));\n+            }\n+        }\n+\n+        // the force may be located in other places on the track - clear it out\n+        track.unassignForce(forceID);\n+        track.assignForce(forceID, coords, campaign.getLocalDate(), sticky);\n+        MekHQ.triggerEvent(new StratconDeploymentEvent(campaign.getForce(forceID)));\n+    }\n+\n+    /**\n+     * Worker function that processes the effects of deploying a reinforcement force to a scenario\n+     */\n+    public static boolean processReinforcementDeployment(ReinforcementEligibilityType reinforcementType,\n+            StratconCampaignState campaignState, StratconScenario scenario, Campaign campaign) {\n+        // if the force is already deployed to the track, we're done\n+        // if the force is a fight lance or we're using a support point\n+        // if there is an SP to burn, burn it and we're done\n+        // if there is a VP to burn, burn it and we're done\n+        // now, roll 2d6 + lance commander tactics\n+        // 9+ = deploy\n+        // 6+ = deploy, apply negative modifier to scenario\n+        // 2+ = fail to deploy, apply negative modifier to scenario; if fight lance, treat as 6+\n+\n+        if ((reinforcementType == ReinforcementEligibilityType.FightLance) ||\n+                (reinforcementType == ReinforcementEligibilityType.SupportPoint)) {\n+\n+            if (campaignState.getSupportPoints() > 0) {\n+                campaignState.useSupportPoint();\n+                return true;\n+            } else if (campaignState.getVictoryPoints() > 0) {\n+                campaignState.updateVictoryPoints(-1);\n+                return true;\n+            }\n+\n+            int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+            int roll = Compute.d6(2);\n+            int result = roll + tactics;\n+\n+            StringBuilder reportStatus = new StringBuilder();\n+            reportStatus.append(String.format(\"Attempting to reinforce scenario %s without SP/VP, roll 2d6 + %d: %d\",\n+                    scenario.getName(), tactics, result));\n+\n+            // fail to reinforce\n+            if ((result < 6) && (reinforcementType != ReinforcementEligibilityType.FightLance)) {\n+                reportStatus.append(\" - reinforcement attempt failed.\");\n+                campaign.addReport(reportStatus.toString());\n+                return false;\n+            // succeed but get an extra negative event added to the scenario\n+            } else if (result < 9) {\n+                MapLocation mapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+                AtBScenarioModifier scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+\n+                // keep rolling until we get an applicable one\n+                // TODO: have the AtBScenarioModifier sort these out instead for performance?\n+                while (scenarioModifier.getEventTiming() != EventTiming.PostForceGeneration) {\n+                    scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+                }\n+\n+                scenarioModifier.processModifier(scenario.getBackingScenario(), campaign, EventTiming.PostForceGeneration);\n+\n+                reportStatus.append(String.format(\" - reinforcement attempt succeeded; extra negative modifier (%s) applied to scenario.\",\n+                        scenarioModifier.getModifierName()));\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            // succeed without reservation\n+            } else {\n+                reportStatus.append(\" - reinforcement attempt succeeded;\");\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            }\n+        } else if (reinforcementType == ReinforcementEligibilityType.None) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Assigns a force to the scenario such that the majority of the force can be deployed\n+     */\n+    private static void assignAppropriateExtraForceToScenario(StratconScenario scenario,\n+            Map<MapLocation, List<Integer>> sortedAvailableForceIDs) {\n+        // the goal of this function is to avoid assigning ground units to air battles\n+        // and ground units/conventional fighters to space battle\n+\n+        List<MapLocation> mapLocations = new ArrayList<>();\n+        mapLocations.add(MapLocation.Space); // can always add ASFs\n+\n+        MapLocation scenarioMapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+\n+        if (scenarioMapLocation == MapLocation.LowAtmosphere) {\n+            mapLocations.add(MapLocation.LowAtmosphere); // can add conventional fighters to ground or low atmo battles\n+        }\n+\n+        if ((scenarioMapLocation == MapLocation.AllGroundTerrain) ||\n+                (scenarioMapLocation == MapLocation.SpecificGroundTerrain)) {\n+            mapLocations.add(MapLocation.AllGroundTerrain); // can only add ground units to ground battles\n+        }\n+\n+        MapLocation selectedLocation = mapLocations.get(Compute.randomInt(mapLocations.size()));\n+        List<Integer> forceIDs = sortedAvailableForceIDs.get(selectedLocation);\n+        int forceIndex = Compute.randomInt(forceIDs.size());\n+        int forceID = forceIDs.get(forceIndex);\n+        forceIDs.remove(forceIndex);\n+\n+        scenario.addPrimaryForce(forceID);\n+    }\n+\n+    /**\n+     * Worker function that \"locks in\" a scenario -\n+     * Adds it to the campaign so it's visible in the briefing room,\n+     * adds it to the track\n+     *\n+     */\n+    public static void commitPrimaryForces(Campaign campaign, StratconScenario scenario, StratconTrackState trackState) {\n+        trackState.addScenario(scenario);\n+\n+        // set up dates for the scenario if doesn't have them already\n+        if (scenario.getDeploymentDate() == null) {\n+            scenario.setDeploymentDate(campaign.getLocalDate());\n+        }\n+\n+        if (scenario.getActionDate() == null) {\n+            scenario.setActionDate(campaign.getLocalDate());\n+        }\n+\n+        if(scenario.getReturnDate() == null) {\n+            scenario.setReturnDate(campaign.getLocalDate().plusDays(trackState.getDeploymentTime()));\n+        }\n+\n+        // set the # of rerolls based on the actual lance assigned.\n+        int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+        scenario.getBackingScenario().setRerolls(tactics);\n+        // The number of defensive points available to a force entering a scenario is\n+        // 2 x tactics. By default, those points are spent on conventional minefields.\n+        if (commanderLanceHasDefensiveAssignment(scenario.getBackingScenario(), campaign)) {\n+            scenario.setNumDefensivePoints(tactics * 2);\n+            scenario.updateMinefieldCount(Minefield.TYPE_CONVENTIONAL, tactics * 2);\n+        }\n+\n+        for (int forceID : scenario.getPlayerTemplateForceIDs()) {\n+            Force force = campaign.getForce(forceID);\n+            force.clearScenarioIds(campaign, true);\n+            force.setScenarioId(scenario.getBackingScenarioID());\n+        }\n+\n+        scenario.commitPrimaryForces();\n+    }\n+\n+    /**\n+     * Utility method to determine if the current scenario's force commander\n+     * is on defence\n+     */\n+    private static boolean commanderLanceHasDefensiveAssignment(AtBDynamicScenario scenario, Campaign campaign) {\n+        Unit commanderUnit = scenario.getLanceCommander(campaign).getUnit();\n+        Lance lance = campaign.getLances().get(commanderUnit.getForceId());\n+\n+        if ((lance != null) && (lance.getRole() == AtBLanceRole.DEFENCE)) {\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * A hackish worker function that takes the given list of force IDs and\n+     * separates it into three sets;\n+     * one of forces that can be \"primary\" on a ground map\n+     * one of forces that can be \"primary\" on an atmospheric map\n+     * one of forces that can be \"primary\" in a space map\n+     * @param forceIDs List of force IDs to check\n+     * @return Sorted hash map\n+     */\n+    private static Map<MapLocation, List<Integer>> sortForcesByMapType(List<Integer> forceIDs, Campaign campaign) {\n+        Map<MapLocation, List<Integer>> retVal = new HashMap<>();\n+\n+        retVal.put(MapLocation.AllGroundTerrain, new ArrayList<>());\n+        retVal.put(MapLocation.LowAtmosphere, new ArrayList<>());\n+        retVal.put(MapLocation.Space, new ArrayList<>());\n+\n+        for (int forceID : forceIDs) {\n+            switch(campaign.getForce(forceID).getPrimaryUnitType(campaign)) {\n+            case UnitType.BATTLE_ARMOR:\n+            case UnitType.INFANTRY:\n+            case UnitType.MEK:\n+            case UnitType.TANK:\n+            case UnitType.PROTOMEK:\n+            case UnitType.VTOL:\n+                retVal.get(MapLocation.AllGroundTerrain).add(forceID);\n+                break;\n+            case UnitType.AERO:\n+                retVal.get(MapLocation.Space).add(forceID);\n+                // intentional fallthrough here, ASFs can go to atmospheric maps too\n+            case UnitType.CONV_FIGHTER:\n+                retVal.get(MapLocation.LowAtmosphere).add(forceID);\n+                break;\n+            }\n+        }\n+\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * Determine whether the user should be nagged about unresolved scenarios on AtB Stratcon tracks.\n+     * @param campaign Campaign to check.\n+     * @return An informative string containing the reasons the user was nagged.\n+     */\n+    public static String nagUnresolvedContacts(Campaign campaign) {\n+        StringBuilder sb = new StringBuilder();\n+\n+        // check every track attached to an active contract for unresolved scenarios\n+        // to which the player must deploy forces today\n+        for (AtBContract contract : campaign.getActiveAtBContracts()) {\n+            if (contract.getStratconCampaignState() == null) {\n+                continue;\n+            }\n+            \n+            for (StratconTrackState track : contract.getStratconCampaignState().getTracks()) {\n+                for (StratconScenario scenario : track.getScenarios().values()) {\n+                    if (scenario.getCurrentState() == ScenarioState.UNRESOLVED &&\n+                            campaign.getLocalDate().equals(scenario.getDeploymentDate())) {\n+                        // \"scenario name, track name\"\n+                        sb.append(String.format(\"%s, %s\\n\", scenario.getName(), track.getDisplayableName()));\n+                    }\n+                }\n+            }\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track.\n+     * Also registers it with the track and campaign.\n+     */\n+    private static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords) {\n+        int unitType = campaign.getForce(forceID).getPrimaryUnitType(campaign);\n+        ScenarioTemplate template = StratconScenarioFactory.getRandomScenario(unitType);\n+        // useful for debugging specific scenario types\n+        //ScenarioTemplate template = StratconScenarioFactory.getSpecificScenario(\"Hostile Facility.xml\");\n+\n+        return generateScenario(campaign, contract, track, forceID, coords, template);\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track,\n+     * using the given template. Also registers it with the campaign.\n+     */\n+    static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords, ScenarioTemplate template) {\n+        StratconScenario scenario = new StratconScenario();\n+        \n+        AtBDynamicScenario backingScenario = AtBDynamicScenarioFactory.initializeScenarioFromTemplate(template, contract, campaign);        \n+        scenario.setBackingScenario(backingScenario);\n+        scenario.setCoords(coords);\n+        \n+        // by default, certain conditions may make this bigger\n+        scenario.setRequiredPlayerLances(1);\n+\n+        // do an appropriate allied force if the contract calls for it\n+        // do any attached or integrated units\n+        setAlliedForceModifier(scenario, contract);\n+        setAttachedUnitsModifier(scenario, contract);\n+        applyFacilityModifiers(scenario, track, coords);\n+        applyGlobalModifiers(scenario, contract.getStratconCampaignState());\n+\n+        if ((contract.getCommandRights() == AtBContract.COM_HOUSE) ||\n+                (contract.getCommandRights() == AtBContract.COM_INTEGRATED)) {\n+            scenario.setRequiredScenario(true);\n+        }\n+\n+        AtBDynamicScenarioFactory.setScenarioModifiers(scenario.getBackingScenario());\n+        scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+        setScenarioDates(track, campaign, scenario);\n+        \n+        // the backing scenario ID must be updated after registering the backing scenario \n+        // with the campaign, so that the stratcon - backing scenario association is maintained\n+        // registering the scenario with the campaign should be done after setting\n+        // dates, otherwise, the report messages for new scenarios look weird\n+        campaign.addScenario(backingScenario, contract);\n+        scenario.setBackingScenarioID(backingScenario.getId());\n+        \n+        if (forceID > Force.FORCE_NONE) {\n+            scenario.addPrimaryForce(forceID);\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * Apply global scenario modifiers from campaign state to given scenario.\n+     */\n+    private static void applyGlobalModifiers(StratconScenario scenario, StratconCampaignState campaignState) {\n+        for (String modifierName : campaignState.getGlobalScenarioModifiers()) {\n+            AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierName);\n+\n+            if (modifier == null) {\n+                MekHQ.getLogger().error(String.format(\"Modifier %s not found; ignoring\", modifierName));\n+                continue;\n+            }\n+\n+            scenario.getBackingScenario().addScenarioModifier(modifier);\n+        }\n+    }\n+\n+    /**\n+     * Applies scenario modifiers from the current track to the given scenario.\n+     * @param scenario\n+     * @param track\n+     */\n+    private static void applyFacilityModifiers(StratconScenario scenario, StratconTrackState track, StratconCoords coords) {\n+        // loop through all the facilities on the track\n+        // if a facility has been revealed, then it has a 100% chance to apply its effect\n+        // if a facility has not been revealed, then it has a x% chance to apply its effect\n+        // if a facility is on the the scenario coordinates the it applies the local effects\n+        for (StratconCoords facilityCoords : track.getFacilities().keySet()) {\n+            boolean scenarioAtFacility = facilityCoords.equals(coords);\n+            StratconFacility facility = track.getFacilities().get(facilityCoords);\n+            List<String> modifierIDs = new ArrayList<>();\n+\n+            if (scenarioAtFacility) {\n+                modifierIDs = facility.getLocalModifiers();\n+            } else if (facility.isVisible() || (Compute.randomInt(100) <= facility.getAggroRating())) {\n+                modifierIDs = facility.getSharedModifiers();\n+            }\n+\n+            for (String modifierID : modifierIDs) {\n+                AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierID);\n+                if(modifier == null) {\n+                    MekHQ.getLogger().error(String.format(\"Modifier %s not found for facility %s\", modifierID, facility.getFormattedDisplayableName()));\n+                    continue;\n+                }\n+\n+                scenario.getBackingScenario().addScenarioModifier(modifier);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set up the appropriate primary allied force modifier, if any\n+     * @param contract The scenario's contract.\n+     */\n+    private static void setAlliedForceModifier(StratconScenario scenario, AtBContract contract) {\n+        int alliedUnitOdds = 0;\n+\n+        // first, we determine the odds of having an allied unit present\n+        // TODO: move this override out to the contract definition\n+        if (contract.getMissionType() == AtBContract.MT_RELIEFDUTY) {\n+            alliedUnitOdds = 50;\n+        } else {\n+            switch(contract.getCommandRights()) {\n+                case AtBContract.COM_INTEGRATED:\n+                    alliedUnitOdds = 50;\n+                    break;\n+                case AtBContract.COM_HOUSE:\n+                    alliedUnitOdds = 30;\n+                    break;\n+                case AtBContract.COM_LIAISON:\n+                    alliedUnitOdds = 10;\n+                    break;\n+            }\n+        }\n+\n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+\n+        // if an allied unit is present, then we want to make sure that it's ground units\n+        // for ground battles\n+        if (Compute.randomInt(100) <= alliedUnitOdds) {\n+            if((backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+               (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space)) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_ALLIED_AIR_UNITS));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_ALLIED_GROUND_UNITS));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set the 'attached' units modifier for the current scenario (integrated, house, liaison),\n+     * and make sure we're not deploying ground units to an air scenario\n+     * @param contract The scenario's contract\n+     */\n+    public static void setAttachedUnitsModifier(StratconScenario scenario, AtBContract contract) {\n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+        boolean airBattle = (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+                (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space);\n+\n+        // if we're on cadre duty, we're getting three trainees, period\n+        if (contract.getMissionType() == AtBContract.MT_CADREDUTY) {\n+            if (airBattle) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_TRAINEES_AIR));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_TRAINEES_GROUND));\n+            }\n+            return;\n+        }\n+\n+        // if we're under non-independent command rights, a supervisor may come along\n+        switch (contract.getCommandRights()) {\n+            case AtBContract.COM_INTEGRATED:\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(airBattle \n+                        ? MekHqConstants.SCENARIO_MODIFIER_INTEGRATED_UNITS_AIR\n+                        : MekHqConstants.SCENARIO_MODIFIER_INTEGRATED_UNITS_GROUND));\n+                break;\n+            case AtBContract.COM_HOUSE:\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(airBattle \n+                        ? MekHqConstants.SCENARIO_MODIFIER_HOUSE_CO_AIR\n+                        : MekHqConstants.SCENARIO_MODIFIER_HOUSE_CO_GROUND));\n+                break;\n+            case AtBContract.COM_LIAISON:\n+                if (scenario.isRequiredScenario()) {\n+                    backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(airBattle \n+                            ? MekHqConstants.SCENARIO_MODIFIER_LIAISON_AIR\n+                            : MekHqConstants.SCENARIO_MODIFIER_LIAISON_GROUND));\n+                }\n+                break;\n+        }\n+    }\n+\n+    /**\n+     * Worker function that sets scenario deploy/battle/return dates based on the track's properties and current campaign date\n+     */\n+    private static void setScenarioDates(StratconTrackState track, Campaign campaign, StratconScenario scenario) {\n+     // set up deployment day, battle day, return day here\n+        // safety code to prevent attempts to generate random int with upper bound of 0 which is apparently illegal\n+        int deploymentDay = track.getDeploymentTime() < 7 ? Compute.randomInt(7 - track.getDeploymentTime()) : 0;\n+        int battleDay = deploymentDay + (track.getDeploymentTime() > 0 ? Compute.randomInt(track.getDeploymentTime()) : 0);\n+        int returnDay = deploymentDay + track.getDeploymentTime();\n+\n+        LocalDate deploymentDate = campaign.getLocalDate();\n+        deploymentDate.plusDays(deploymentDay);\n+        LocalDate battleDate = campaign.getLocalDate();\n+        deploymentDate.plusDays(battleDay);\n+        LocalDate returnDate = campaign.getLocalDate();\n+        returnDate.plusDays(returnDay);\n+\n+        scenario.setDeploymentDate(deploymentDate);\n+        scenario.setActionDate(battleDate);\n+        scenario.setReturnDate(returnDate);\n+    }\n+\n+    /**\n+     * Helper function that determines if the unit type specified in the given scenario force template\n+     * would start out airborne on a ground map (hot dropped units aside)\n+     */\n+    private static boolean unitTypeIsAirborne(ScenarioForceTemplate template) {\n+        int unitType = template.getAllowedUnitType();\n+\n+        return (unitType == UnitType.AERO ||\n+                unitType == UnitType.CONV_FIGHTER ||\n+                unitType == UnitType.DROPSHIP ||\n+                unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_MIX) &&\n+                template.getStartingAltitude() > 0;", "originalCommit": "b36d9fa6bf982c7b833b1ac0a0473d37f6e84760", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTE5MjE2Nw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r615192167", "bodyText": "Brackets", "author": "Windchild292", "createdAt": "2021-04-17T02:07:40Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1404 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.UUID;\n+\n+import megamek.common.Compute;\n+import megamek.common.Minefield;\n+import megamek.common.UnitType;\n+import megamek.common.annotations.Nullable;\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.Utilities;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.ResolveScenarioTracker;\n+import mekhq.campaign.againstTheBot.enums.AtBLanceRole;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.event.StratconDeploymentEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.force.Lance;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier.EventTiming;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconFacility.FacilityType;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.unit.Unit;\n+\n+/**\n+ * This class contains \"rules\" logic for the AtB-Stratcon state\n+ * @author NickAragua\n+ */\n+public class StratconRulesManager {\n+    /**\n+     * What makes a particular lance eligible to be reinforcements for a scenario\n+     */\n+    public enum ReinforcementEligibilityType {\n+        /**\n+         * Nothing\n+         */\n+        None,\n+\n+        /**\n+         * Lance is already deployed to the track\n+         */\n+        ChainedScenario,\n+\n+        /**\n+         * We pay a support point or convert a victory point to a support point\n+         */\n+        SupportPoint,\n+\n+        /**\n+         * The lance's deployment orders are \"Fight\"\n+         */\n+        FightLance\n+    }\n+\n+    /**\n+     * This function potentially generates non-player-initiated scenarios for the given track.\n+     */\n+    public static void generateScenariosForTrack(Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // maps scenarios to force IDs\n+        List<StratconScenario> generatedScenarios = new ArrayList<>();\n+        boolean autoAssignLances = contract.getCommandRights() == AtBContract.COM_INTEGRATED;\n+\n+        // get this list just so we have it available\n+        List<Integer> availableForceIDs = getAvailableForceIDs(campaign);\n+        Map<MapLocation, List<Integer>> sortedAvailableForceIDs = sortForcesByMapType(availableForceIDs, campaign);\n+\n+        // make X rolls, where X is the number of required lances for the track\n+        // that's the chance to spawn a scenario.\n+        // if a scenario occurs, then we pick a random non-deployed lance and use it to drive the opfor generation later\n+        // once we've determined that scenarios occur, we loop through the ones that we generated\n+        // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all\n+        for (int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            int targetNum = calculateScenarioOdds(track, contract, false);\n+            \n+            // if we haven't already used all the player forces and are required to randomly generate a scenario\n+            if (!availableForceIDs.isEmpty() && (Compute.randomInt(100) <= targetNum)) {\n+                // pick random coordinates and force to drive the scenario\n+                int x = Compute.randomInt(track.getWidth());\n+                int y = Compute.randomInt(track.getHeight());\n+\n+                StratconCoords scenarioCoords = new StratconCoords(x, y);\n+\n+                // if forces are already assigned to these coordinates, use those instead\n+                // of randomly-selected ones\n+                if (track.getAssignedCoordForces().containsKey(scenarioCoords)) {\n+                    StratconScenario scenario = generateScenarioForExistingForces(scenarioCoords,\n+                            track.getAssignedCoordForces().get(scenarioCoords), \n+                            contract, campaign, track);\n+                    generatedScenarios.add(scenario);\n+                    continue;\n+                }\n+                \n+                // otherwise, pick a random force from the avail\n+                int randomForceIndex = Compute.randomInt(availableForceIDs.size());\n+                int randomForceID = availableForceIDs.get(randomForceIndex);\n+                \n+                // remove the force from the available lists so we don't designate it as primary twice\n+                availableForceIDs.remove(randomForceIndex);\n+\n+                // we want to remove the actual int with the value, not the value at the index\n+                sortedAvailableForceIDs.get(MapLocation.AllGroundTerrain).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.LowAtmosphere).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.Space).remove((Integer) randomForceID);\n+\n+                // two scenarios on the same coordinates wind up increasing in size\n+                if (track.getScenarios().containsKey(scenarioCoords)) {\n+                    track.getScenarios().get(scenarioCoords).incrementRequiredPlayerLances();\n+                    assignAppropriateExtraForceToScenario(track.getScenarios().get(scenarioCoords), sortedAvailableForceIDs);\n+                    continue;\n+                }\n+\n+                StratconScenario scenario = setupScenario(scenarioCoords, randomForceID, campaign, contract, track);\n+                generatedScenarios.add(scenario);\n+\n+                // if we're auto-assigning lances, deploy the force to the track as well\n+                if (autoAssignLances) {\n+                    processForceDeployment(scenarioCoords, randomForceID, campaign, track, false);\n+                }\n+            }\n+        }\n+\n+        // if under liaison command, pick a random scenario from the ones generated\n+        // to set as required and attach liaison\n+        if (contract.getCommandRights() == AtBContract.COM_LIAISON) {\n+        \tStratconScenario randomScenario = Utilities.getRandomItem(generatedScenarios);\n+        \trandomScenario.setRequiredScenario(true);\n+            setAttachedUnitsModifier(randomScenario, contract);\n+        }\n+\n+        // now, we loop through all the scenarios we set up\n+        // and generate the opfors / events / etc\n+        // if not auto-assigning lances, we then back out the lance assignments.\n+        for (StratconScenario scenario : generatedScenarios) {\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+\n+            if(!autoAssignLances && !scenario.ignoreForceAutoAssignment()) {\n+                for(int forceID : scenario.getPlayerTemplateForceIDs()) {\n+                    scenario.getBackingScenario().removeForce(forceID);\n+                }\n+\n+                scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                track.addScenario(scenario);\n+            } else {\n+                commitPrimaryForces(campaign, scenario, track);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Given a set of force IDs and coordinates, generate a scenario\n+     * Useful for when we want to generate scenarios \n+     * for forces already deployed to a track\n+     */\n+    public static StratconScenario generateScenarioForExistingForces(StratconCoords scenarioCoords, \n+            Set<Integer> forceIDs, AtBContract contract, Campaign campaign, StratconTrackState track) {\n+        boolean firstForce = true;\n+        StratconScenario scenario = null;\n+        \n+        for (int forceID : forceIDs) {\n+            if (firstForce) {\n+                scenario = setupScenario(scenarioCoords, forceID, campaign, contract, track);\n+                firstForce = false;\n+            } else {\n+                scenario.incrementRequiredPlayerLances();\n+                scenario.addPrimaryForce(forceID);\n+            }\n+        }\n+        \n+        // this is theoretically possible if forceIDs is passed in as null - not likely in practice\n+        // but might as well, to future-proof.\n+        if (scenario != null) {\n+            scenario.setIgnoreForceAutoAssignment(true);\n+        }\n+        \n+        return scenario;\n+    }\n+\n+    /**\n+     * Deploys a force to the given coordinates on the given track as a result of explicit player action.\n+     */\n+    public static void deployForceToCoords(StratconCoords coords, int forceID, \n+            Campaign campaign, AtBContract contract, StratconTrackState track, boolean sticky) {\n+        // the following things should happen:\n+        // 1. call to \"process force deployment\", which reveals fog of war in or around the coords, depending on force role\n+        // 2. if coords are a hostile facility, we get a facility mission\n+        // 3. if coords are empty, we *may* get a mission\n+\n+        processForceDeployment(coords, forceID, campaign, track, sticky);\n+\n+        // don't create a scenario on top of allied facilities\n+        StratconFacility facility = track.getFacility(coords);\n+        boolean isNonAlliedFacility = (facility != null) && (facility.getOwner() != ForceAlignment.Allied);\n+        int targetNum = calculateScenarioOdds(track, contract, true);\n+        boolean spawnScenario = (facility == null) && (Compute.randomInt(100) <= targetNum);\n+\n+        if (isNonAlliedFacility || spawnScenario) {\n+            StratconScenario scenario = setupScenario(coords, forceID, campaign, contract, track);\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            commitPrimaryForces(campaign, scenario, track);\n+        }\n+    }\n+\n+    /**\n+     * Logic to set up a scenario\n+     */\n+    private static StratconScenario setupScenario(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        StratconScenario scenario = null;\n+\n+        if (track.getFacilities().containsKey(coords)) {\n+            StratconFacility facility = track.getFacility(coords);\n+            boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+            ScenarioTemplate template = StratconScenarioFactory.getFacilityScenario(alliedFacility);\n+            scenario = generateScenario(campaign, contract, track, forceID, coords, template);\n+            setupFacilityScenario(scenario, facility);\n+        } else {\n+            scenario = generateScenario(campaign, contract, track, forceID, coords);\n+\n+            // we may generate a facility scenario randomly - if so, do the facility-related stuff\n+            // and add a new facility to the track\n+            if (scenario.getBackingScenario().getTemplate().isFacilityScenario()) {\n+                StratconFacility facility = scenario.getBackingScenario().getTemplate().isHostileFacility() ?\n+                        StratconFacilityFactory.getRandomHostileFacility() : StratconFacilityFactory.getRandomAlliedFacility();\n+                facility.setVisible(true);\n+                track.addFacility(coords, facility);\n+                setupFacilityScenario(scenario, facility);\n+            }\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * carries out tasks relevant to facility scenarios\n+     */\n+    private static void setupFacilityScenario(StratconScenario scenario, StratconFacility facility) {\n+        // this includes:\n+        // for hostile facilities\n+        // - add a destroy objective (always the option to level the facility)\n+        // - add a capture objective (always the option to capture the facility)\n+        // - if so indicated by parameter, roll a random hostile facility objective and add it if not capture/destroy\n+        // for allied facilities\n+        // - add a defend objective (always the option to defend the facility)\n+        // - if so indicated by parameter, roll a random allied facility objective and add it if not defend\n+        AtBScenarioModifier objectiveModifier = null;\n+        boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+\n+        if (alliedFacility) {\n+            objectiveModifier = AtBScenarioModifier.getRandomAlliedFacilityModifier();\n+        } else {\n+            objectiveModifier = AtBScenarioModifier.getRandomHostileFacilityModifier();\n+        }\n+\n+        if (objectiveModifier != null) {\n+            scenario.getBackingScenario().addScenarioModifier(objectiveModifier);\n+            scenario.getBackingScenario().setName(String.format(\"%s - %s - %s\",\n+                    facility.getFacilityType(), alliedFacility ? \"Allied\" : \"Hostile\", objectiveModifier.getModifierName()));\n+        }\n+\n+        // add the \"fixed\" hostile facility modifiers after the primary ones\n+        if (!alliedFacility) {\n+            for(AtBScenarioModifier modifier : AtBScenarioModifier.getRequiredHostileFacilityModifiers()) {\n+                if(!scenario.getBackingScenario().alreadyHasModifier(modifier)) {\n+                    scenario.getBackingScenario().addScenarioModifier(modifier);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void processFacilityEffects(StratconTrackState track) {\n+        // TODO: these are \"weekly\"? effects that a stratcon facility has on the campaign/track state\n+        // currrently, that's\n+        // supply depot - allied - +1 sp\n+        // supply depot - hostile - +5% BV budget to all scenarios on track (shared modifier, so should be implemented there)\n+        // data center - allied - +1% star league cache contract (don't implement yet, but...)\n+        // data center - hostile - +5% scenario odds in track\n+        // industrial center - allied - all scenarios here have THIS IS COMING OUT OF YOUR PAYCHECK modifier\n+        // orbital defense - allied - sets 'no hostile aircraft' flag for track\n+        // orbital defense - hostile - sets 'no allied aircraft' flag for track\n+        // early warning system - allied - sets 'intercept allied base attacks' flag for track\n+        // early warning system - hostile - sets 'intercept hostile base attacks' flag for track\n+    }\n+\n+    /**\n+     * Process the deployment of a force to the given coordinates on the given track.\n+     */\n+    public static void processForceDeployment(StratconCoords coords, int forceID, \n+            Campaign campaign, StratconTrackState track, boolean sticky) {\n+        track.getRevealedCoords().add(coords);\n+        StratconFacility facility = track.getFacility(coords);\n+        if (facility != null) {\n+            facility.setVisible(true);\n+        }\n+\n+        if (campaign.getLances().get(forceID).getRole() == AtBLanceRole.SCOUTING) {\n+            for(int direction = 0; direction < 6; direction++) {\n+                StratconCoords checkCoords = coords.translate(direction);\n+\n+                facility = track.getFacility(checkCoords);\n+                if(facility != null) {\n+                    facility.setVisible(true);\n+                }\n+\n+                track.getRevealedCoords().add(coords.translate(direction));\n+            }\n+        }\n+\n+        // the force may be located in other places on the track - clear it out\n+        track.unassignForce(forceID);\n+        track.assignForce(forceID, coords, campaign.getLocalDate(), sticky);\n+        MekHQ.triggerEvent(new StratconDeploymentEvent(campaign.getForce(forceID)));\n+    }\n+\n+    /**\n+     * Worker function that processes the effects of deploying a reinforcement force to a scenario\n+     */\n+    public static boolean processReinforcementDeployment(ReinforcementEligibilityType reinforcementType,\n+            StratconCampaignState campaignState, StratconScenario scenario, Campaign campaign) {\n+        // if the force is already deployed to the track, we're done\n+        // if the force is a fight lance or we're using a support point\n+        // if there is an SP to burn, burn it and we're done\n+        // if there is a VP to burn, burn it and we're done\n+        // now, roll 2d6 + lance commander tactics\n+        // 9+ = deploy\n+        // 6+ = deploy, apply negative modifier to scenario\n+        // 2+ = fail to deploy, apply negative modifier to scenario; if fight lance, treat as 6+\n+\n+        if ((reinforcementType == ReinforcementEligibilityType.FightLance) ||\n+                (reinforcementType == ReinforcementEligibilityType.SupportPoint)) {\n+\n+            if (campaignState.getSupportPoints() > 0) {\n+                campaignState.useSupportPoint();\n+                return true;\n+            } else if (campaignState.getVictoryPoints() > 0) {\n+                campaignState.updateVictoryPoints(-1);\n+                return true;\n+            }\n+\n+            int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+            int roll = Compute.d6(2);\n+            int result = roll + tactics;\n+\n+            StringBuilder reportStatus = new StringBuilder();\n+            reportStatus.append(String.format(\"Attempting to reinforce scenario %s without SP/VP, roll 2d6 + %d: %d\",\n+                    scenario.getName(), tactics, result));\n+\n+            // fail to reinforce\n+            if ((result < 6) && (reinforcementType != ReinforcementEligibilityType.FightLance)) {\n+                reportStatus.append(\" - reinforcement attempt failed.\");\n+                campaign.addReport(reportStatus.toString());\n+                return false;\n+            // succeed but get an extra negative event added to the scenario\n+            } else if (result < 9) {\n+                MapLocation mapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+                AtBScenarioModifier scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+\n+                // keep rolling until we get an applicable one\n+                // TODO: have the AtBScenarioModifier sort these out instead for performance?\n+                while (scenarioModifier.getEventTiming() != EventTiming.PostForceGeneration) {\n+                    scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+                }\n+\n+                scenarioModifier.processModifier(scenario.getBackingScenario(), campaign, EventTiming.PostForceGeneration);\n+\n+                reportStatus.append(String.format(\" - reinforcement attempt succeeded; extra negative modifier (%s) applied to scenario.\",\n+                        scenarioModifier.getModifierName()));\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            // succeed without reservation\n+            } else {\n+                reportStatus.append(\" - reinforcement attempt succeeded;\");\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            }\n+        } else if (reinforcementType == ReinforcementEligibilityType.None) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Assigns a force to the scenario such that the majority of the force can be deployed\n+     */\n+    private static void assignAppropriateExtraForceToScenario(StratconScenario scenario,\n+            Map<MapLocation, List<Integer>> sortedAvailableForceIDs) {\n+        // the goal of this function is to avoid assigning ground units to air battles\n+        // and ground units/conventional fighters to space battle\n+\n+        List<MapLocation> mapLocations = new ArrayList<>();\n+        mapLocations.add(MapLocation.Space); // can always add ASFs\n+\n+        MapLocation scenarioMapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+\n+        if (scenarioMapLocation == MapLocation.LowAtmosphere) {\n+            mapLocations.add(MapLocation.LowAtmosphere); // can add conventional fighters to ground or low atmo battles\n+        }\n+\n+        if ((scenarioMapLocation == MapLocation.AllGroundTerrain) ||\n+                (scenarioMapLocation == MapLocation.SpecificGroundTerrain)) {\n+            mapLocations.add(MapLocation.AllGroundTerrain); // can only add ground units to ground battles\n+        }\n+\n+        MapLocation selectedLocation = mapLocations.get(Compute.randomInt(mapLocations.size()));\n+        List<Integer> forceIDs = sortedAvailableForceIDs.get(selectedLocation);\n+        int forceIndex = Compute.randomInt(forceIDs.size());\n+        int forceID = forceIDs.get(forceIndex);\n+        forceIDs.remove(forceIndex);\n+\n+        scenario.addPrimaryForce(forceID);\n+    }\n+\n+    /**\n+     * Worker function that \"locks in\" a scenario -\n+     * Adds it to the campaign so it's visible in the briefing room,\n+     * adds it to the track\n+     *\n+     */\n+    public static void commitPrimaryForces(Campaign campaign, StratconScenario scenario, StratconTrackState trackState) {\n+        trackState.addScenario(scenario);\n+\n+        // set up dates for the scenario if doesn't have them already\n+        if (scenario.getDeploymentDate() == null) {\n+            scenario.setDeploymentDate(campaign.getLocalDate());\n+        }\n+\n+        if (scenario.getActionDate() == null) {\n+            scenario.setActionDate(campaign.getLocalDate());\n+        }\n+\n+        if(scenario.getReturnDate() == null) {\n+            scenario.setReturnDate(campaign.getLocalDate().plusDays(trackState.getDeploymentTime()));\n+        }\n+\n+        // set the # of rerolls based on the actual lance assigned.\n+        int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+        scenario.getBackingScenario().setRerolls(tactics);\n+        // The number of defensive points available to a force entering a scenario is\n+        // 2 x tactics. By default, those points are spent on conventional minefields.\n+        if (commanderLanceHasDefensiveAssignment(scenario.getBackingScenario(), campaign)) {\n+            scenario.setNumDefensivePoints(tactics * 2);\n+            scenario.updateMinefieldCount(Minefield.TYPE_CONVENTIONAL, tactics * 2);\n+        }\n+\n+        for (int forceID : scenario.getPlayerTemplateForceIDs()) {\n+            Force force = campaign.getForce(forceID);\n+            force.clearScenarioIds(campaign, true);\n+            force.setScenarioId(scenario.getBackingScenarioID());\n+        }\n+\n+        scenario.commitPrimaryForces();\n+    }\n+\n+    /**\n+     * Utility method to determine if the current scenario's force commander\n+     * is on defence\n+     */\n+    private static boolean commanderLanceHasDefensiveAssignment(AtBDynamicScenario scenario, Campaign campaign) {\n+        Unit commanderUnit = scenario.getLanceCommander(campaign).getUnit();\n+        Lance lance = campaign.getLances().get(commanderUnit.getForceId());\n+\n+        if ((lance != null) && (lance.getRole() == AtBLanceRole.DEFENCE)) {\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * A hackish worker function that takes the given list of force IDs and\n+     * separates it into three sets;\n+     * one of forces that can be \"primary\" on a ground map\n+     * one of forces that can be \"primary\" on an atmospheric map\n+     * one of forces that can be \"primary\" in a space map\n+     * @param forceIDs List of force IDs to check\n+     * @return Sorted hash map\n+     */\n+    private static Map<MapLocation, List<Integer>> sortForcesByMapType(List<Integer> forceIDs, Campaign campaign) {\n+        Map<MapLocation, List<Integer>> retVal = new HashMap<>();\n+\n+        retVal.put(MapLocation.AllGroundTerrain, new ArrayList<>());\n+        retVal.put(MapLocation.LowAtmosphere, new ArrayList<>());\n+        retVal.put(MapLocation.Space, new ArrayList<>());\n+\n+        for (int forceID : forceIDs) {\n+            switch(campaign.getForce(forceID).getPrimaryUnitType(campaign)) {\n+            case UnitType.BATTLE_ARMOR:\n+            case UnitType.INFANTRY:\n+            case UnitType.MEK:\n+            case UnitType.TANK:\n+            case UnitType.PROTOMEK:\n+            case UnitType.VTOL:\n+                retVal.get(MapLocation.AllGroundTerrain).add(forceID);\n+                break;\n+            case UnitType.AERO:\n+                retVal.get(MapLocation.Space).add(forceID);\n+                // intentional fallthrough here, ASFs can go to atmospheric maps too\n+            case UnitType.CONV_FIGHTER:\n+                retVal.get(MapLocation.LowAtmosphere).add(forceID);\n+                break;\n+            }\n+        }\n+\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * Determine whether the user should be nagged about unresolved scenarios on AtB Stratcon tracks.\n+     * @param campaign Campaign to check.\n+     * @return An informative string containing the reasons the user was nagged.\n+     */\n+    public static String nagUnresolvedContacts(Campaign campaign) {\n+        StringBuilder sb = new StringBuilder();\n+\n+        // check every track attached to an active contract for unresolved scenarios\n+        // to which the player must deploy forces today\n+        for (AtBContract contract : campaign.getActiveAtBContracts()) {\n+            if (contract.getStratconCampaignState() == null) {\n+                continue;\n+            }\n+            \n+            for (StratconTrackState track : contract.getStratconCampaignState().getTracks()) {\n+                for (StratconScenario scenario : track.getScenarios().values()) {\n+                    if (scenario.getCurrentState() == ScenarioState.UNRESOLVED &&\n+                            campaign.getLocalDate().equals(scenario.getDeploymentDate())) {\n+                        // \"scenario name, track name\"\n+                        sb.append(String.format(\"%s, %s\\n\", scenario.getName(), track.getDisplayableName()));\n+                    }\n+                }\n+            }\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track.\n+     * Also registers it with the track and campaign.\n+     */\n+    private static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords) {\n+        int unitType = campaign.getForce(forceID).getPrimaryUnitType(campaign);\n+        ScenarioTemplate template = StratconScenarioFactory.getRandomScenario(unitType);\n+        // useful for debugging specific scenario types\n+        //ScenarioTemplate template = StratconScenarioFactory.getSpecificScenario(\"Hostile Facility.xml\");\n+\n+        return generateScenario(campaign, contract, track, forceID, coords, template);\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track,\n+     * using the given template. Also registers it with the campaign.\n+     */\n+    static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords, ScenarioTemplate template) {\n+        StratconScenario scenario = new StratconScenario();\n+        \n+        AtBDynamicScenario backingScenario = AtBDynamicScenarioFactory.initializeScenarioFromTemplate(template, contract, campaign);        \n+        scenario.setBackingScenario(backingScenario);\n+        scenario.setCoords(coords);\n+        \n+        // by default, certain conditions may make this bigger\n+        scenario.setRequiredPlayerLances(1);\n+\n+        // do an appropriate allied force if the contract calls for it\n+        // do any attached or integrated units\n+        setAlliedForceModifier(scenario, contract);\n+        setAttachedUnitsModifier(scenario, contract);\n+        applyFacilityModifiers(scenario, track, coords);\n+        applyGlobalModifiers(scenario, contract.getStratconCampaignState());\n+\n+        if ((contract.getCommandRights() == AtBContract.COM_HOUSE) ||\n+                (contract.getCommandRights() == AtBContract.COM_INTEGRATED)) {\n+            scenario.setRequiredScenario(true);\n+        }\n+\n+        AtBDynamicScenarioFactory.setScenarioModifiers(scenario.getBackingScenario());\n+        scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+        setScenarioDates(track, campaign, scenario);\n+        \n+        // the backing scenario ID must be updated after registering the backing scenario \n+        // with the campaign, so that the stratcon - backing scenario association is maintained\n+        // registering the scenario with the campaign should be done after setting\n+        // dates, otherwise, the report messages for new scenarios look weird\n+        campaign.addScenario(backingScenario, contract);\n+        scenario.setBackingScenarioID(backingScenario.getId());\n+        \n+        if (forceID > Force.FORCE_NONE) {\n+            scenario.addPrimaryForce(forceID);\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * Apply global scenario modifiers from campaign state to given scenario.\n+     */\n+    private static void applyGlobalModifiers(StratconScenario scenario, StratconCampaignState campaignState) {\n+        for (String modifierName : campaignState.getGlobalScenarioModifiers()) {\n+            AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierName);\n+\n+            if (modifier == null) {\n+                MekHQ.getLogger().error(String.format(\"Modifier %s not found; ignoring\", modifierName));\n+                continue;\n+            }\n+\n+            scenario.getBackingScenario().addScenarioModifier(modifier);\n+        }\n+    }\n+\n+    /**\n+     * Applies scenario modifiers from the current track to the given scenario.\n+     * @param scenario\n+     * @param track\n+     */\n+    private static void applyFacilityModifiers(StratconScenario scenario, StratconTrackState track, StratconCoords coords) {\n+        // loop through all the facilities on the track\n+        // if a facility has been revealed, then it has a 100% chance to apply its effect\n+        // if a facility has not been revealed, then it has a x% chance to apply its effect\n+        // if a facility is on the the scenario coordinates the it applies the local effects\n+        for (StratconCoords facilityCoords : track.getFacilities().keySet()) {\n+            boolean scenarioAtFacility = facilityCoords.equals(coords);\n+            StratconFacility facility = track.getFacilities().get(facilityCoords);\n+            List<String> modifierIDs = new ArrayList<>();\n+\n+            if (scenarioAtFacility) {\n+                modifierIDs = facility.getLocalModifiers();\n+            } else if (facility.isVisible() || (Compute.randomInt(100) <= facility.getAggroRating())) {\n+                modifierIDs = facility.getSharedModifiers();\n+            }\n+\n+            for (String modifierID : modifierIDs) {\n+                AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierID);\n+                if(modifier == null) {\n+                    MekHQ.getLogger().error(String.format(\"Modifier %s not found for facility %s\", modifierID, facility.getFormattedDisplayableName()));\n+                    continue;\n+                }\n+\n+                scenario.getBackingScenario().addScenarioModifier(modifier);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set up the appropriate primary allied force modifier, if any\n+     * @param contract The scenario's contract.\n+     */\n+    private static void setAlliedForceModifier(StratconScenario scenario, AtBContract contract) {\n+        int alliedUnitOdds = 0;\n+\n+        // first, we determine the odds of having an allied unit present\n+        // TODO: move this override out to the contract definition\n+        if (contract.getMissionType() == AtBContract.MT_RELIEFDUTY) {\n+            alliedUnitOdds = 50;\n+        } else {\n+            switch(contract.getCommandRights()) {\n+                case AtBContract.COM_INTEGRATED:\n+                    alliedUnitOdds = 50;\n+                    break;\n+                case AtBContract.COM_HOUSE:\n+                    alliedUnitOdds = 30;\n+                    break;\n+                case AtBContract.COM_LIAISON:\n+                    alliedUnitOdds = 10;\n+                    break;\n+            }\n+        }\n+\n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+\n+        // if an allied unit is present, then we want to make sure that it's ground units\n+        // for ground battles\n+        if (Compute.randomInt(100) <= alliedUnitOdds) {\n+            if((backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+               (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space)) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_ALLIED_AIR_UNITS));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_ALLIED_GROUND_UNITS));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set the 'attached' units modifier for the current scenario (integrated, house, liaison),\n+     * and make sure we're not deploying ground units to an air scenario\n+     * @param contract The scenario's contract\n+     */\n+    public static void setAttachedUnitsModifier(StratconScenario scenario, AtBContract contract) {\n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+        boolean airBattle = (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+                (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space);\n+\n+        // if we're on cadre duty, we're getting three trainees, period\n+        if (contract.getMissionType() == AtBContract.MT_CADREDUTY) {\n+            if (airBattle) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_TRAINEES_AIR));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_TRAINEES_GROUND));\n+            }\n+            return;\n+        }\n+\n+        // if we're under non-independent command rights, a supervisor may come along\n+        switch (contract.getCommandRights()) {\n+            case AtBContract.COM_INTEGRATED:\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(airBattle \n+                        ? MekHqConstants.SCENARIO_MODIFIER_INTEGRATED_UNITS_AIR\n+                        : MekHqConstants.SCENARIO_MODIFIER_INTEGRATED_UNITS_GROUND));\n+                break;\n+            case AtBContract.COM_HOUSE:\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(airBattle \n+                        ? MekHqConstants.SCENARIO_MODIFIER_HOUSE_CO_AIR\n+                        : MekHqConstants.SCENARIO_MODIFIER_HOUSE_CO_GROUND));\n+                break;\n+            case AtBContract.COM_LIAISON:\n+                if (scenario.isRequiredScenario()) {\n+                    backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(airBattle \n+                            ? MekHqConstants.SCENARIO_MODIFIER_LIAISON_AIR\n+                            : MekHqConstants.SCENARIO_MODIFIER_LIAISON_GROUND));\n+                }\n+                break;\n+        }\n+    }\n+\n+    /**\n+     * Worker function that sets scenario deploy/battle/return dates based on the track's properties and current campaign date\n+     */\n+    private static void setScenarioDates(StratconTrackState track, Campaign campaign, StratconScenario scenario) {\n+     // set up deployment day, battle day, return day here\n+        // safety code to prevent attempts to generate random int with upper bound of 0 which is apparently illegal\n+        int deploymentDay = track.getDeploymentTime() < 7 ? Compute.randomInt(7 - track.getDeploymentTime()) : 0;\n+        int battleDay = deploymentDay + (track.getDeploymentTime() > 0 ? Compute.randomInt(track.getDeploymentTime()) : 0);\n+        int returnDay = deploymentDay + track.getDeploymentTime();\n+\n+        LocalDate deploymentDate = campaign.getLocalDate();\n+        deploymentDate.plusDays(deploymentDay);\n+        LocalDate battleDate = campaign.getLocalDate();\n+        deploymentDate.plusDays(battleDay);\n+        LocalDate returnDate = campaign.getLocalDate();\n+        returnDate.plusDays(returnDay);\n+\n+        scenario.setDeploymentDate(deploymentDate);\n+        scenario.setActionDate(battleDate);\n+        scenario.setReturnDate(returnDate);\n+    }\n+\n+    /**\n+     * Helper function that determines if the unit type specified in the given scenario force template\n+     * would start out airborne on a ground map (hot dropped units aside)\n+     */\n+    private static boolean unitTypeIsAirborne(ScenarioForceTemplate template) {\n+        int unitType = template.getAllowedUnitType();\n+\n+        return (unitType == UnitType.AERO ||\n+                unitType == UnitType.CONV_FIGHTER ||\n+                unitType == UnitType.DROPSHIP ||\n+                unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_MIX) &&\n+                template.getStartingAltitude() > 0;\n+    }\n+\n+    /**\n+     * Determines whether the force in question has the same primary unit type as the force template.\n+     * @return Whether or not the unit types match.\n+     */\n+    public static boolean forceCompositionMatchesDeclaredUnitType(int primaryUnitType, int unitType, boolean reinforcements) {\n+        // special cases are \"ATB_MIX\" and \"ATB_AERO_MIX\", which encompass multiple unit types\n+        if (unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_MIX) {\n+            // \"AtB mix\" is usually ground units, but air units can sub in\n+            return primaryUnitType == UnitType.MEK ||\n+                    primaryUnitType == UnitType.TANK ||\n+                    primaryUnitType == UnitType.INFANTRY ||\n+                    primaryUnitType == UnitType.BATTLE_ARMOR ||\n+                    primaryUnitType == UnitType.PROTOMEK ||\n+                    primaryUnitType == UnitType.VTOL ||\n+                    (primaryUnitType == UnitType.AERO) && reinforcements ||\n+                    (primaryUnitType == UnitType.CONV_FIGHTER) && reinforcements;", "originalCommit": "b36d9fa6bf982c7b833b1ac0a0473d37f6e84760", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTE5MjIwNQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r615192205", "bodyText": "Brackets", "author": "Windchild292", "createdAt": "2021-04-17T02:07:49Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1404 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.UUID;\n+\n+import megamek.common.Compute;\n+import megamek.common.Minefield;\n+import megamek.common.UnitType;\n+import megamek.common.annotations.Nullable;\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.Utilities;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.ResolveScenarioTracker;\n+import mekhq.campaign.againstTheBot.enums.AtBLanceRole;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.event.StratconDeploymentEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.force.Lance;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier.EventTiming;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconFacility.FacilityType;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.unit.Unit;\n+\n+/**\n+ * This class contains \"rules\" logic for the AtB-Stratcon state\n+ * @author NickAragua\n+ */\n+public class StratconRulesManager {\n+    /**\n+     * What makes a particular lance eligible to be reinforcements for a scenario\n+     */\n+    public enum ReinforcementEligibilityType {\n+        /**\n+         * Nothing\n+         */\n+        None,\n+\n+        /**\n+         * Lance is already deployed to the track\n+         */\n+        ChainedScenario,\n+\n+        /**\n+         * We pay a support point or convert a victory point to a support point\n+         */\n+        SupportPoint,\n+\n+        /**\n+         * The lance's deployment orders are \"Fight\"\n+         */\n+        FightLance\n+    }\n+\n+    /**\n+     * This function potentially generates non-player-initiated scenarios for the given track.\n+     */\n+    public static void generateScenariosForTrack(Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // maps scenarios to force IDs\n+        List<StratconScenario> generatedScenarios = new ArrayList<>();\n+        boolean autoAssignLances = contract.getCommandRights() == AtBContract.COM_INTEGRATED;\n+\n+        // get this list just so we have it available\n+        List<Integer> availableForceIDs = getAvailableForceIDs(campaign);\n+        Map<MapLocation, List<Integer>> sortedAvailableForceIDs = sortForcesByMapType(availableForceIDs, campaign);\n+\n+        // make X rolls, where X is the number of required lances for the track\n+        // that's the chance to spawn a scenario.\n+        // if a scenario occurs, then we pick a random non-deployed lance and use it to drive the opfor generation later\n+        // once we've determined that scenarios occur, we loop through the ones that we generated\n+        // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all\n+        for (int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            int targetNum = calculateScenarioOdds(track, contract, false);\n+            \n+            // if we haven't already used all the player forces and are required to randomly generate a scenario\n+            if (!availableForceIDs.isEmpty() && (Compute.randomInt(100) <= targetNum)) {\n+                // pick random coordinates and force to drive the scenario\n+                int x = Compute.randomInt(track.getWidth());\n+                int y = Compute.randomInt(track.getHeight());\n+\n+                StratconCoords scenarioCoords = new StratconCoords(x, y);\n+\n+                // if forces are already assigned to these coordinates, use those instead\n+                // of randomly-selected ones\n+                if (track.getAssignedCoordForces().containsKey(scenarioCoords)) {\n+                    StratconScenario scenario = generateScenarioForExistingForces(scenarioCoords,\n+                            track.getAssignedCoordForces().get(scenarioCoords), \n+                            contract, campaign, track);\n+                    generatedScenarios.add(scenario);\n+                    continue;\n+                }\n+                \n+                // otherwise, pick a random force from the avail\n+                int randomForceIndex = Compute.randomInt(availableForceIDs.size());\n+                int randomForceID = availableForceIDs.get(randomForceIndex);\n+                \n+                // remove the force from the available lists so we don't designate it as primary twice\n+                availableForceIDs.remove(randomForceIndex);\n+\n+                // we want to remove the actual int with the value, not the value at the index\n+                sortedAvailableForceIDs.get(MapLocation.AllGroundTerrain).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.LowAtmosphere).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.Space).remove((Integer) randomForceID);\n+\n+                // two scenarios on the same coordinates wind up increasing in size\n+                if (track.getScenarios().containsKey(scenarioCoords)) {\n+                    track.getScenarios().get(scenarioCoords).incrementRequiredPlayerLances();\n+                    assignAppropriateExtraForceToScenario(track.getScenarios().get(scenarioCoords), sortedAvailableForceIDs);\n+                    continue;\n+                }\n+\n+                StratconScenario scenario = setupScenario(scenarioCoords, randomForceID, campaign, contract, track);\n+                generatedScenarios.add(scenario);\n+\n+                // if we're auto-assigning lances, deploy the force to the track as well\n+                if (autoAssignLances) {\n+                    processForceDeployment(scenarioCoords, randomForceID, campaign, track, false);\n+                }\n+            }\n+        }\n+\n+        // if under liaison command, pick a random scenario from the ones generated\n+        // to set as required and attach liaison\n+        if (contract.getCommandRights() == AtBContract.COM_LIAISON) {\n+        \tStratconScenario randomScenario = Utilities.getRandomItem(generatedScenarios);\n+        \trandomScenario.setRequiredScenario(true);\n+            setAttachedUnitsModifier(randomScenario, contract);\n+        }\n+\n+        // now, we loop through all the scenarios we set up\n+        // and generate the opfors / events / etc\n+        // if not auto-assigning lances, we then back out the lance assignments.\n+        for (StratconScenario scenario : generatedScenarios) {\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+\n+            if(!autoAssignLances && !scenario.ignoreForceAutoAssignment()) {\n+                for(int forceID : scenario.getPlayerTemplateForceIDs()) {\n+                    scenario.getBackingScenario().removeForce(forceID);\n+                }\n+\n+                scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                track.addScenario(scenario);\n+            } else {\n+                commitPrimaryForces(campaign, scenario, track);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Given a set of force IDs and coordinates, generate a scenario\n+     * Useful for when we want to generate scenarios \n+     * for forces already deployed to a track\n+     */\n+    public static StratconScenario generateScenarioForExistingForces(StratconCoords scenarioCoords, \n+            Set<Integer> forceIDs, AtBContract contract, Campaign campaign, StratconTrackState track) {\n+        boolean firstForce = true;\n+        StratconScenario scenario = null;\n+        \n+        for (int forceID : forceIDs) {\n+            if (firstForce) {\n+                scenario = setupScenario(scenarioCoords, forceID, campaign, contract, track);\n+                firstForce = false;\n+            } else {\n+                scenario.incrementRequiredPlayerLances();\n+                scenario.addPrimaryForce(forceID);\n+            }\n+        }\n+        \n+        // this is theoretically possible if forceIDs is passed in as null - not likely in practice\n+        // but might as well, to future-proof.\n+        if (scenario != null) {\n+            scenario.setIgnoreForceAutoAssignment(true);\n+        }\n+        \n+        return scenario;\n+    }\n+\n+    /**\n+     * Deploys a force to the given coordinates on the given track as a result of explicit player action.\n+     */\n+    public static void deployForceToCoords(StratconCoords coords, int forceID, \n+            Campaign campaign, AtBContract contract, StratconTrackState track, boolean sticky) {\n+        // the following things should happen:\n+        // 1. call to \"process force deployment\", which reveals fog of war in or around the coords, depending on force role\n+        // 2. if coords are a hostile facility, we get a facility mission\n+        // 3. if coords are empty, we *may* get a mission\n+\n+        processForceDeployment(coords, forceID, campaign, track, sticky);\n+\n+        // don't create a scenario on top of allied facilities\n+        StratconFacility facility = track.getFacility(coords);\n+        boolean isNonAlliedFacility = (facility != null) && (facility.getOwner() != ForceAlignment.Allied);\n+        int targetNum = calculateScenarioOdds(track, contract, true);\n+        boolean spawnScenario = (facility == null) && (Compute.randomInt(100) <= targetNum);\n+\n+        if (isNonAlliedFacility || spawnScenario) {\n+            StratconScenario scenario = setupScenario(coords, forceID, campaign, contract, track);\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            commitPrimaryForces(campaign, scenario, track);\n+        }\n+    }\n+\n+    /**\n+     * Logic to set up a scenario\n+     */\n+    private static StratconScenario setupScenario(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        StratconScenario scenario = null;\n+\n+        if (track.getFacilities().containsKey(coords)) {\n+            StratconFacility facility = track.getFacility(coords);\n+            boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+            ScenarioTemplate template = StratconScenarioFactory.getFacilityScenario(alliedFacility);\n+            scenario = generateScenario(campaign, contract, track, forceID, coords, template);\n+            setupFacilityScenario(scenario, facility);\n+        } else {\n+            scenario = generateScenario(campaign, contract, track, forceID, coords);\n+\n+            // we may generate a facility scenario randomly - if so, do the facility-related stuff\n+            // and add a new facility to the track\n+            if (scenario.getBackingScenario().getTemplate().isFacilityScenario()) {\n+                StratconFacility facility = scenario.getBackingScenario().getTemplate().isHostileFacility() ?\n+                        StratconFacilityFactory.getRandomHostileFacility() : StratconFacilityFactory.getRandomAlliedFacility();\n+                facility.setVisible(true);\n+                track.addFacility(coords, facility);\n+                setupFacilityScenario(scenario, facility);\n+            }\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * carries out tasks relevant to facility scenarios\n+     */\n+    private static void setupFacilityScenario(StratconScenario scenario, StratconFacility facility) {\n+        // this includes:\n+        // for hostile facilities\n+        // - add a destroy objective (always the option to level the facility)\n+        // - add a capture objective (always the option to capture the facility)\n+        // - if so indicated by parameter, roll a random hostile facility objective and add it if not capture/destroy\n+        // for allied facilities\n+        // - add a defend objective (always the option to defend the facility)\n+        // - if so indicated by parameter, roll a random allied facility objective and add it if not defend\n+        AtBScenarioModifier objectiveModifier = null;\n+        boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+\n+        if (alliedFacility) {\n+            objectiveModifier = AtBScenarioModifier.getRandomAlliedFacilityModifier();\n+        } else {\n+            objectiveModifier = AtBScenarioModifier.getRandomHostileFacilityModifier();\n+        }\n+\n+        if (objectiveModifier != null) {\n+            scenario.getBackingScenario().addScenarioModifier(objectiveModifier);\n+            scenario.getBackingScenario().setName(String.format(\"%s - %s - %s\",\n+                    facility.getFacilityType(), alliedFacility ? \"Allied\" : \"Hostile\", objectiveModifier.getModifierName()));\n+        }\n+\n+        // add the \"fixed\" hostile facility modifiers after the primary ones\n+        if (!alliedFacility) {\n+            for(AtBScenarioModifier modifier : AtBScenarioModifier.getRequiredHostileFacilityModifiers()) {\n+                if(!scenario.getBackingScenario().alreadyHasModifier(modifier)) {\n+                    scenario.getBackingScenario().addScenarioModifier(modifier);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void processFacilityEffects(StratconTrackState track) {\n+        // TODO: these are \"weekly\"? effects that a stratcon facility has on the campaign/track state\n+        // currrently, that's\n+        // supply depot - allied - +1 sp\n+        // supply depot - hostile - +5% BV budget to all scenarios on track (shared modifier, so should be implemented there)\n+        // data center - allied - +1% star league cache contract (don't implement yet, but...)\n+        // data center - hostile - +5% scenario odds in track\n+        // industrial center - allied - all scenarios here have THIS IS COMING OUT OF YOUR PAYCHECK modifier\n+        // orbital defense - allied - sets 'no hostile aircraft' flag for track\n+        // orbital defense - hostile - sets 'no allied aircraft' flag for track\n+        // early warning system - allied - sets 'intercept allied base attacks' flag for track\n+        // early warning system - hostile - sets 'intercept hostile base attacks' flag for track\n+    }\n+\n+    /**\n+     * Process the deployment of a force to the given coordinates on the given track.\n+     */\n+    public static void processForceDeployment(StratconCoords coords, int forceID, \n+            Campaign campaign, StratconTrackState track, boolean sticky) {\n+        track.getRevealedCoords().add(coords);\n+        StratconFacility facility = track.getFacility(coords);\n+        if (facility != null) {\n+            facility.setVisible(true);\n+        }\n+\n+        if (campaign.getLances().get(forceID).getRole() == AtBLanceRole.SCOUTING) {\n+            for(int direction = 0; direction < 6; direction++) {\n+                StratconCoords checkCoords = coords.translate(direction);\n+\n+                facility = track.getFacility(checkCoords);\n+                if(facility != null) {\n+                    facility.setVisible(true);\n+                }\n+\n+                track.getRevealedCoords().add(coords.translate(direction));\n+            }\n+        }\n+\n+        // the force may be located in other places on the track - clear it out\n+        track.unassignForce(forceID);\n+        track.assignForce(forceID, coords, campaign.getLocalDate(), sticky);\n+        MekHQ.triggerEvent(new StratconDeploymentEvent(campaign.getForce(forceID)));\n+    }\n+\n+    /**\n+     * Worker function that processes the effects of deploying a reinforcement force to a scenario\n+     */\n+    public static boolean processReinforcementDeployment(ReinforcementEligibilityType reinforcementType,\n+            StratconCampaignState campaignState, StratconScenario scenario, Campaign campaign) {\n+        // if the force is already deployed to the track, we're done\n+        // if the force is a fight lance or we're using a support point\n+        // if there is an SP to burn, burn it and we're done\n+        // if there is a VP to burn, burn it and we're done\n+        // now, roll 2d6 + lance commander tactics\n+        // 9+ = deploy\n+        // 6+ = deploy, apply negative modifier to scenario\n+        // 2+ = fail to deploy, apply negative modifier to scenario; if fight lance, treat as 6+\n+\n+        if ((reinforcementType == ReinforcementEligibilityType.FightLance) ||\n+                (reinforcementType == ReinforcementEligibilityType.SupportPoint)) {\n+\n+            if (campaignState.getSupportPoints() > 0) {\n+                campaignState.useSupportPoint();\n+                return true;\n+            } else if (campaignState.getVictoryPoints() > 0) {\n+                campaignState.updateVictoryPoints(-1);\n+                return true;\n+            }\n+\n+            int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+            int roll = Compute.d6(2);\n+            int result = roll + tactics;\n+\n+            StringBuilder reportStatus = new StringBuilder();\n+            reportStatus.append(String.format(\"Attempting to reinforce scenario %s without SP/VP, roll 2d6 + %d: %d\",\n+                    scenario.getName(), tactics, result));\n+\n+            // fail to reinforce\n+            if ((result < 6) && (reinforcementType != ReinforcementEligibilityType.FightLance)) {\n+                reportStatus.append(\" - reinforcement attempt failed.\");\n+                campaign.addReport(reportStatus.toString());\n+                return false;\n+            // succeed but get an extra negative event added to the scenario\n+            } else if (result < 9) {\n+                MapLocation mapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+                AtBScenarioModifier scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+\n+                // keep rolling until we get an applicable one\n+                // TODO: have the AtBScenarioModifier sort these out instead for performance?\n+                while (scenarioModifier.getEventTiming() != EventTiming.PostForceGeneration) {\n+                    scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+                }\n+\n+                scenarioModifier.processModifier(scenario.getBackingScenario(), campaign, EventTiming.PostForceGeneration);\n+\n+                reportStatus.append(String.format(\" - reinforcement attempt succeeded; extra negative modifier (%s) applied to scenario.\",\n+                        scenarioModifier.getModifierName()));\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            // succeed without reservation\n+            } else {\n+                reportStatus.append(\" - reinforcement attempt succeeded;\");\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            }\n+        } else if (reinforcementType == ReinforcementEligibilityType.None) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Assigns a force to the scenario such that the majority of the force can be deployed\n+     */\n+    private static void assignAppropriateExtraForceToScenario(StratconScenario scenario,\n+            Map<MapLocation, List<Integer>> sortedAvailableForceIDs) {\n+        // the goal of this function is to avoid assigning ground units to air battles\n+        // and ground units/conventional fighters to space battle\n+\n+        List<MapLocation> mapLocations = new ArrayList<>();\n+        mapLocations.add(MapLocation.Space); // can always add ASFs\n+\n+        MapLocation scenarioMapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+\n+        if (scenarioMapLocation == MapLocation.LowAtmosphere) {\n+            mapLocations.add(MapLocation.LowAtmosphere); // can add conventional fighters to ground or low atmo battles\n+        }\n+\n+        if ((scenarioMapLocation == MapLocation.AllGroundTerrain) ||\n+                (scenarioMapLocation == MapLocation.SpecificGroundTerrain)) {\n+            mapLocations.add(MapLocation.AllGroundTerrain); // can only add ground units to ground battles\n+        }\n+\n+        MapLocation selectedLocation = mapLocations.get(Compute.randomInt(mapLocations.size()));\n+        List<Integer> forceIDs = sortedAvailableForceIDs.get(selectedLocation);\n+        int forceIndex = Compute.randomInt(forceIDs.size());\n+        int forceID = forceIDs.get(forceIndex);\n+        forceIDs.remove(forceIndex);\n+\n+        scenario.addPrimaryForce(forceID);\n+    }\n+\n+    /**\n+     * Worker function that \"locks in\" a scenario -\n+     * Adds it to the campaign so it's visible in the briefing room,\n+     * adds it to the track\n+     *\n+     */\n+    public static void commitPrimaryForces(Campaign campaign, StratconScenario scenario, StratconTrackState trackState) {\n+        trackState.addScenario(scenario);\n+\n+        // set up dates for the scenario if doesn't have them already\n+        if (scenario.getDeploymentDate() == null) {\n+            scenario.setDeploymentDate(campaign.getLocalDate());\n+        }\n+\n+        if (scenario.getActionDate() == null) {\n+            scenario.setActionDate(campaign.getLocalDate());\n+        }\n+\n+        if(scenario.getReturnDate() == null) {\n+            scenario.setReturnDate(campaign.getLocalDate().plusDays(trackState.getDeploymentTime()));\n+        }\n+\n+        // set the # of rerolls based on the actual lance assigned.\n+        int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+        scenario.getBackingScenario().setRerolls(tactics);\n+        // The number of defensive points available to a force entering a scenario is\n+        // 2 x tactics. By default, those points are spent on conventional minefields.\n+        if (commanderLanceHasDefensiveAssignment(scenario.getBackingScenario(), campaign)) {\n+            scenario.setNumDefensivePoints(tactics * 2);\n+            scenario.updateMinefieldCount(Minefield.TYPE_CONVENTIONAL, tactics * 2);\n+        }\n+\n+        for (int forceID : scenario.getPlayerTemplateForceIDs()) {\n+            Force force = campaign.getForce(forceID);\n+            force.clearScenarioIds(campaign, true);\n+            force.setScenarioId(scenario.getBackingScenarioID());\n+        }\n+\n+        scenario.commitPrimaryForces();\n+    }\n+\n+    /**\n+     * Utility method to determine if the current scenario's force commander\n+     * is on defence\n+     */\n+    private static boolean commanderLanceHasDefensiveAssignment(AtBDynamicScenario scenario, Campaign campaign) {\n+        Unit commanderUnit = scenario.getLanceCommander(campaign).getUnit();\n+        Lance lance = campaign.getLances().get(commanderUnit.getForceId());\n+\n+        if ((lance != null) && (lance.getRole() == AtBLanceRole.DEFENCE)) {\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * A hackish worker function that takes the given list of force IDs and\n+     * separates it into three sets;\n+     * one of forces that can be \"primary\" on a ground map\n+     * one of forces that can be \"primary\" on an atmospheric map\n+     * one of forces that can be \"primary\" in a space map\n+     * @param forceIDs List of force IDs to check\n+     * @return Sorted hash map\n+     */\n+    private static Map<MapLocation, List<Integer>> sortForcesByMapType(List<Integer> forceIDs, Campaign campaign) {\n+        Map<MapLocation, List<Integer>> retVal = new HashMap<>();\n+\n+        retVal.put(MapLocation.AllGroundTerrain, new ArrayList<>());\n+        retVal.put(MapLocation.LowAtmosphere, new ArrayList<>());\n+        retVal.put(MapLocation.Space, new ArrayList<>());\n+\n+        for (int forceID : forceIDs) {\n+            switch(campaign.getForce(forceID).getPrimaryUnitType(campaign)) {\n+            case UnitType.BATTLE_ARMOR:\n+            case UnitType.INFANTRY:\n+            case UnitType.MEK:\n+            case UnitType.TANK:\n+            case UnitType.PROTOMEK:\n+            case UnitType.VTOL:\n+                retVal.get(MapLocation.AllGroundTerrain).add(forceID);\n+                break;\n+            case UnitType.AERO:\n+                retVal.get(MapLocation.Space).add(forceID);\n+                // intentional fallthrough here, ASFs can go to atmospheric maps too\n+            case UnitType.CONV_FIGHTER:\n+                retVal.get(MapLocation.LowAtmosphere).add(forceID);\n+                break;\n+            }\n+        }\n+\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * Determine whether the user should be nagged about unresolved scenarios on AtB Stratcon tracks.\n+     * @param campaign Campaign to check.\n+     * @return An informative string containing the reasons the user was nagged.\n+     */\n+    public static String nagUnresolvedContacts(Campaign campaign) {\n+        StringBuilder sb = new StringBuilder();\n+\n+        // check every track attached to an active contract for unresolved scenarios\n+        // to which the player must deploy forces today\n+        for (AtBContract contract : campaign.getActiveAtBContracts()) {\n+            if (contract.getStratconCampaignState() == null) {\n+                continue;\n+            }\n+            \n+            for (StratconTrackState track : contract.getStratconCampaignState().getTracks()) {\n+                for (StratconScenario scenario : track.getScenarios().values()) {\n+                    if (scenario.getCurrentState() == ScenarioState.UNRESOLVED &&\n+                            campaign.getLocalDate().equals(scenario.getDeploymentDate())) {\n+                        // \"scenario name, track name\"\n+                        sb.append(String.format(\"%s, %s\\n\", scenario.getName(), track.getDisplayableName()));\n+                    }\n+                }\n+            }\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track.\n+     * Also registers it with the track and campaign.\n+     */\n+    private static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords) {\n+        int unitType = campaign.getForce(forceID).getPrimaryUnitType(campaign);\n+        ScenarioTemplate template = StratconScenarioFactory.getRandomScenario(unitType);\n+        // useful for debugging specific scenario types\n+        //ScenarioTemplate template = StratconScenarioFactory.getSpecificScenario(\"Hostile Facility.xml\");\n+\n+        return generateScenario(campaign, contract, track, forceID, coords, template);\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track,\n+     * using the given template. Also registers it with the campaign.\n+     */\n+    static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords, ScenarioTemplate template) {\n+        StratconScenario scenario = new StratconScenario();\n+        \n+        AtBDynamicScenario backingScenario = AtBDynamicScenarioFactory.initializeScenarioFromTemplate(template, contract, campaign);        \n+        scenario.setBackingScenario(backingScenario);\n+        scenario.setCoords(coords);\n+        \n+        // by default, certain conditions may make this bigger\n+        scenario.setRequiredPlayerLances(1);\n+\n+        // do an appropriate allied force if the contract calls for it\n+        // do any attached or integrated units\n+        setAlliedForceModifier(scenario, contract);\n+        setAttachedUnitsModifier(scenario, contract);\n+        applyFacilityModifiers(scenario, track, coords);\n+        applyGlobalModifiers(scenario, contract.getStratconCampaignState());\n+\n+        if ((contract.getCommandRights() == AtBContract.COM_HOUSE) ||\n+                (contract.getCommandRights() == AtBContract.COM_INTEGRATED)) {\n+            scenario.setRequiredScenario(true);\n+        }\n+\n+        AtBDynamicScenarioFactory.setScenarioModifiers(scenario.getBackingScenario());\n+        scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+        setScenarioDates(track, campaign, scenario);\n+        \n+        // the backing scenario ID must be updated after registering the backing scenario \n+        // with the campaign, so that the stratcon - backing scenario association is maintained\n+        // registering the scenario with the campaign should be done after setting\n+        // dates, otherwise, the report messages for new scenarios look weird\n+        campaign.addScenario(backingScenario, contract);\n+        scenario.setBackingScenarioID(backingScenario.getId());\n+        \n+        if (forceID > Force.FORCE_NONE) {\n+            scenario.addPrimaryForce(forceID);\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * Apply global scenario modifiers from campaign state to given scenario.\n+     */\n+    private static void applyGlobalModifiers(StratconScenario scenario, StratconCampaignState campaignState) {\n+        for (String modifierName : campaignState.getGlobalScenarioModifiers()) {\n+            AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierName);\n+\n+            if (modifier == null) {\n+                MekHQ.getLogger().error(String.format(\"Modifier %s not found; ignoring\", modifierName));\n+                continue;\n+            }\n+\n+            scenario.getBackingScenario().addScenarioModifier(modifier);\n+        }\n+    }\n+\n+    /**\n+     * Applies scenario modifiers from the current track to the given scenario.\n+     * @param scenario\n+     * @param track\n+     */\n+    private static void applyFacilityModifiers(StratconScenario scenario, StratconTrackState track, StratconCoords coords) {\n+        // loop through all the facilities on the track\n+        // if a facility has been revealed, then it has a 100% chance to apply its effect\n+        // if a facility has not been revealed, then it has a x% chance to apply its effect\n+        // if a facility is on the the scenario coordinates the it applies the local effects\n+        for (StratconCoords facilityCoords : track.getFacilities().keySet()) {\n+            boolean scenarioAtFacility = facilityCoords.equals(coords);\n+            StratconFacility facility = track.getFacilities().get(facilityCoords);\n+            List<String> modifierIDs = new ArrayList<>();\n+\n+            if (scenarioAtFacility) {\n+                modifierIDs = facility.getLocalModifiers();\n+            } else if (facility.isVisible() || (Compute.randomInt(100) <= facility.getAggroRating())) {\n+                modifierIDs = facility.getSharedModifiers();\n+            }\n+\n+            for (String modifierID : modifierIDs) {\n+                AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierID);\n+                if(modifier == null) {\n+                    MekHQ.getLogger().error(String.format(\"Modifier %s not found for facility %s\", modifierID, facility.getFormattedDisplayableName()));\n+                    continue;\n+                }\n+\n+                scenario.getBackingScenario().addScenarioModifier(modifier);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set up the appropriate primary allied force modifier, if any\n+     * @param contract The scenario's contract.\n+     */\n+    private static void setAlliedForceModifier(StratconScenario scenario, AtBContract contract) {\n+        int alliedUnitOdds = 0;\n+\n+        // first, we determine the odds of having an allied unit present\n+        // TODO: move this override out to the contract definition\n+        if (contract.getMissionType() == AtBContract.MT_RELIEFDUTY) {\n+            alliedUnitOdds = 50;\n+        } else {\n+            switch(contract.getCommandRights()) {\n+                case AtBContract.COM_INTEGRATED:\n+                    alliedUnitOdds = 50;\n+                    break;\n+                case AtBContract.COM_HOUSE:\n+                    alliedUnitOdds = 30;\n+                    break;\n+                case AtBContract.COM_LIAISON:\n+                    alliedUnitOdds = 10;\n+                    break;\n+            }\n+        }\n+\n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+\n+        // if an allied unit is present, then we want to make sure that it's ground units\n+        // for ground battles\n+        if (Compute.randomInt(100) <= alliedUnitOdds) {\n+            if((backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+               (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space)) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_ALLIED_AIR_UNITS));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_ALLIED_GROUND_UNITS));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set the 'attached' units modifier for the current scenario (integrated, house, liaison),\n+     * and make sure we're not deploying ground units to an air scenario\n+     * @param contract The scenario's contract\n+     */\n+    public static void setAttachedUnitsModifier(StratconScenario scenario, AtBContract contract) {\n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+        boolean airBattle = (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+                (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space);\n+\n+        // if we're on cadre duty, we're getting three trainees, period\n+        if (contract.getMissionType() == AtBContract.MT_CADREDUTY) {\n+            if (airBattle) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_TRAINEES_AIR));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_TRAINEES_GROUND));\n+            }\n+            return;\n+        }\n+\n+        // if we're under non-independent command rights, a supervisor may come along\n+        switch (contract.getCommandRights()) {\n+            case AtBContract.COM_INTEGRATED:\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(airBattle \n+                        ? MekHqConstants.SCENARIO_MODIFIER_INTEGRATED_UNITS_AIR\n+                        : MekHqConstants.SCENARIO_MODIFIER_INTEGRATED_UNITS_GROUND));\n+                break;\n+            case AtBContract.COM_HOUSE:\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(airBattle \n+                        ? MekHqConstants.SCENARIO_MODIFIER_HOUSE_CO_AIR\n+                        : MekHqConstants.SCENARIO_MODIFIER_HOUSE_CO_GROUND));\n+                break;\n+            case AtBContract.COM_LIAISON:\n+                if (scenario.isRequiredScenario()) {\n+                    backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(airBattle \n+                            ? MekHqConstants.SCENARIO_MODIFIER_LIAISON_AIR\n+                            : MekHqConstants.SCENARIO_MODIFIER_LIAISON_GROUND));\n+                }\n+                break;\n+        }\n+    }\n+\n+    /**\n+     * Worker function that sets scenario deploy/battle/return dates based on the track's properties and current campaign date\n+     */\n+    private static void setScenarioDates(StratconTrackState track, Campaign campaign, StratconScenario scenario) {\n+     // set up deployment day, battle day, return day here\n+        // safety code to prevent attempts to generate random int with upper bound of 0 which is apparently illegal\n+        int deploymentDay = track.getDeploymentTime() < 7 ? Compute.randomInt(7 - track.getDeploymentTime()) : 0;\n+        int battleDay = deploymentDay + (track.getDeploymentTime() > 0 ? Compute.randomInt(track.getDeploymentTime()) : 0);\n+        int returnDay = deploymentDay + track.getDeploymentTime();\n+\n+        LocalDate deploymentDate = campaign.getLocalDate();\n+        deploymentDate.plusDays(deploymentDay);\n+        LocalDate battleDate = campaign.getLocalDate();\n+        deploymentDate.plusDays(battleDay);\n+        LocalDate returnDate = campaign.getLocalDate();\n+        returnDate.plusDays(returnDay);\n+\n+        scenario.setDeploymentDate(deploymentDate);\n+        scenario.setActionDate(battleDate);\n+        scenario.setReturnDate(returnDate);\n+    }\n+\n+    /**\n+     * Helper function that determines if the unit type specified in the given scenario force template\n+     * would start out airborne on a ground map (hot dropped units aside)\n+     */\n+    private static boolean unitTypeIsAirborne(ScenarioForceTemplate template) {\n+        int unitType = template.getAllowedUnitType();\n+\n+        return (unitType == UnitType.AERO ||\n+                unitType == UnitType.CONV_FIGHTER ||\n+                unitType == UnitType.DROPSHIP ||\n+                unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_MIX) &&\n+                template.getStartingAltitude() > 0;\n+    }\n+\n+    /**\n+     * Determines whether the force in question has the same primary unit type as the force template.\n+     * @return Whether or not the unit types match.\n+     */\n+    public static boolean forceCompositionMatchesDeclaredUnitType(int primaryUnitType, int unitType, boolean reinforcements) {\n+        // special cases are \"ATB_MIX\" and \"ATB_AERO_MIX\", which encompass multiple unit types\n+        if (unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_MIX) {\n+            // \"AtB mix\" is usually ground units, but air units can sub in\n+            return primaryUnitType == UnitType.MEK ||\n+                    primaryUnitType == UnitType.TANK ||\n+                    primaryUnitType == UnitType.INFANTRY ||\n+                    primaryUnitType == UnitType.BATTLE_ARMOR ||\n+                    primaryUnitType == UnitType.PROTOMEK ||\n+                    primaryUnitType == UnitType.VTOL ||\n+                    (primaryUnitType == UnitType.AERO) && reinforcements ||\n+                    (primaryUnitType == UnitType.CONV_FIGHTER) && reinforcements;\n+        } else if (unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_AERO_MIX) {\n+            return primaryUnitType == UnitType.AERO ||\n+                    primaryUnitType == UnitType.CONV_FIGHTER;", "originalCommit": "b36d9fa6bf982c7b833b1ac0a0473d37f6e84760", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTE5MjI4MA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r615192280", "bodyText": "Campaign::getActiveAtBContracts would be far better", "author": "Windchild292", "createdAt": "2021-04-17T02:08:39Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1404 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.UUID;\n+\n+import megamek.common.Compute;\n+import megamek.common.Minefield;\n+import megamek.common.UnitType;\n+import megamek.common.annotations.Nullable;\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.Utilities;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.ResolveScenarioTracker;\n+import mekhq.campaign.againstTheBot.enums.AtBLanceRole;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.event.StratconDeploymentEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.force.Lance;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier.EventTiming;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconFacility.FacilityType;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.unit.Unit;\n+\n+/**\n+ * This class contains \"rules\" logic for the AtB-Stratcon state\n+ * @author NickAragua\n+ */\n+public class StratconRulesManager {\n+    /**\n+     * What makes a particular lance eligible to be reinforcements for a scenario\n+     */\n+    public enum ReinforcementEligibilityType {\n+        /**\n+         * Nothing\n+         */\n+        None,\n+\n+        /**\n+         * Lance is already deployed to the track\n+         */\n+        ChainedScenario,\n+\n+        /**\n+         * We pay a support point or convert a victory point to a support point\n+         */\n+        SupportPoint,\n+\n+        /**\n+         * The lance's deployment orders are \"Fight\"\n+         */\n+        FightLance\n+    }\n+\n+    /**\n+     * This function potentially generates non-player-initiated scenarios for the given track.\n+     */\n+    public static void generateScenariosForTrack(Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // maps scenarios to force IDs\n+        List<StratconScenario> generatedScenarios = new ArrayList<>();\n+        boolean autoAssignLances = contract.getCommandRights() == AtBContract.COM_INTEGRATED;\n+\n+        // get this list just so we have it available\n+        List<Integer> availableForceIDs = getAvailableForceIDs(campaign);\n+        Map<MapLocation, List<Integer>> sortedAvailableForceIDs = sortForcesByMapType(availableForceIDs, campaign);\n+\n+        // make X rolls, where X is the number of required lances for the track\n+        // that's the chance to spawn a scenario.\n+        // if a scenario occurs, then we pick a random non-deployed lance and use it to drive the opfor generation later\n+        // once we've determined that scenarios occur, we loop through the ones that we generated\n+        // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all\n+        for (int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            int targetNum = calculateScenarioOdds(track, contract, false);\n+            \n+            // if we haven't already used all the player forces and are required to randomly generate a scenario\n+            if (!availableForceIDs.isEmpty() && (Compute.randomInt(100) <= targetNum)) {\n+                // pick random coordinates and force to drive the scenario\n+                int x = Compute.randomInt(track.getWidth());\n+                int y = Compute.randomInt(track.getHeight());\n+\n+                StratconCoords scenarioCoords = new StratconCoords(x, y);\n+\n+                // if forces are already assigned to these coordinates, use those instead\n+                // of randomly-selected ones\n+                if (track.getAssignedCoordForces().containsKey(scenarioCoords)) {\n+                    StratconScenario scenario = generateScenarioForExistingForces(scenarioCoords,\n+                            track.getAssignedCoordForces().get(scenarioCoords), \n+                            contract, campaign, track);\n+                    generatedScenarios.add(scenario);\n+                    continue;\n+                }\n+                \n+                // otherwise, pick a random force from the avail\n+                int randomForceIndex = Compute.randomInt(availableForceIDs.size());\n+                int randomForceID = availableForceIDs.get(randomForceIndex);\n+                \n+                // remove the force from the available lists so we don't designate it as primary twice\n+                availableForceIDs.remove(randomForceIndex);\n+\n+                // we want to remove the actual int with the value, not the value at the index\n+                sortedAvailableForceIDs.get(MapLocation.AllGroundTerrain).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.LowAtmosphere).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.Space).remove((Integer) randomForceID);\n+\n+                // two scenarios on the same coordinates wind up increasing in size\n+                if (track.getScenarios().containsKey(scenarioCoords)) {\n+                    track.getScenarios().get(scenarioCoords).incrementRequiredPlayerLances();\n+                    assignAppropriateExtraForceToScenario(track.getScenarios().get(scenarioCoords), sortedAvailableForceIDs);\n+                    continue;\n+                }\n+\n+                StratconScenario scenario = setupScenario(scenarioCoords, randomForceID, campaign, contract, track);\n+                generatedScenarios.add(scenario);\n+\n+                // if we're auto-assigning lances, deploy the force to the track as well\n+                if (autoAssignLances) {\n+                    processForceDeployment(scenarioCoords, randomForceID, campaign, track, false);\n+                }\n+            }\n+        }\n+\n+        // if under liaison command, pick a random scenario from the ones generated\n+        // to set as required and attach liaison\n+        if (contract.getCommandRights() == AtBContract.COM_LIAISON) {\n+        \tStratconScenario randomScenario = Utilities.getRandomItem(generatedScenarios);\n+        \trandomScenario.setRequiredScenario(true);\n+            setAttachedUnitsModifier(randomScenario, contract);\n+        }\n+\n+        // now, we loop through all the scenarios we set up\n+        // and generate the opfors / events / etc\n+        // if not auto-assigning lances, we then back out the lance assignments.\n+        for (StratconScenario scenario : generatedScenarios) {\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+\n+            if(!autoAssignLances && !scenario.ignoreForceAutoAssignment()) {\n+                for(int forceID : scenario.getPlayerTemplateForceIDs()) {\n+                    scenario.getBackingScenario().removeForce(forceID);\n+                }\n+\n+                scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                track.addScenario(scenario);\n+            } else {\n+                commitPrimaryForces(campaign, scenario, track);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Given a set of force IDs and coordinates, generate a scenario\n+     * Useful for when we want to generate scenarios \n+     * for forces already deployed to a track\n+     */\n+    public static StratconScenario generateScenarioForExistingForces(StratconCoords scenarioCoords, \n+            Set<Integer> forceIDs, AtBContract contract, Campaign campaign, StratconTrackState track) {\n+        boolean firstForce = true;\n+        StratconScenario scenario = null;\n+        \n+        for (int forceID : forceIDs) {\n+            if (firstForce) {\n+                scenario = setupScenario(scenarioCoords, forceID, campaign, contract, track);\n+                firstForce = false;\n+            } else {\n+                scenario.incrementRequiredPlayerLances();\n+                scenario.addPrimaryForce(forceID);\n+            }\n+        }\n+        \n+        // this is theoretically possible if forceIDs is passed in as null - not likely in practice\n+        // but might as well, to future-proof.\n+        if (scenario != null) {\n+            scenario.setIgnoreForceAutoAssignment(true);\n+        }\n+        \n+        return scenario;\n+    }\n+\n+    /**\n+     * Deploys a force to the given coordinates on the given track as a result of explicit player action.\n+     */\n+    public static void deployForceToCoords(StratconCoords coords, int forceID, \n+            Campaign campaign, AtBContract contract, StratconTrackState track, boolean sticky) {\n+        // the following things should happen:\n+        // 1. call to \"process force deployment\", which reveals fog of war in or around the coords, depending on force role\n+        // 2. if coords are a hostile facility, we get a facility mission\n+        // 3. if coords are empty, we *may* get a mission\n+\n+        processForceDeployment(coords, forceID, campaign, track, sticky);\n+\n+        // don't create a scenario on top of allied facilities\n+        StratconFacility facility = track.getFacility(coords);\n+        boolean isNonAlliedFacility = (facility != null) && (facility.getOwner() != ForceAlignment.Allied);\n+        int targetNum = calculateScenarioOdds(track, contract, true);\n+        boolean spawnScenario = (facility == null) && (Compute.randomInt(100) <= targetNum);\n+\n+        if (isNonAlliedFacility || spawnScenario) {\n+            StratconScenario scenario = setupScenario(coords, forceID, campaign, contract, track);\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            commitPrimaryForces(campaign, scenario, track);\n+        }\n+    }\n+\n+    /**\n+     * Logic to set up a scenario\n+     */\n+    private static StratconScenario setupScenario(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        StratconScenario scenario = null;\n+\n+        if (track.getFacilities().containsKey(coords)) {\n+            StratconFacility facility = track.getFacility(coords);\n+            boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+            ScenarioTemplate template = StratconScenarioFactory.getFacilityScenario(alliedFacility);\n+            scenario = generateScenario(campaign, contract, track, forceID, coords, template);\n+            setupFacilityScenario(scenario, facility);\n+        } else {\n+            scenario = generateScenario(campaign, contract, track, forceID, coords);\n+\n+            // we may generate a facility scenario randomly - if so, do the facility-related stuff\n+            // and add a new facility to the track\n+            if (scenario.getBackingScenario().getTemplate().isFacilityScenario()) {\n+                StratconFacility facility = scenario.getBackingScenario().getTemplate().isHostileFacility() ?\n+                        StratconFacilityFactory.getRandomHostileFacility() : StratconFacilityFactory.getRandomAlliedFacility();\n+                facility.setVisible(true);\n+                track.addFacility(coords, facility);\n+                setupFacilityScenario(scenario, facility);\n+            }\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * carries out tasks relevant to facility scenarios\n+     */\n+    private static void setupFacilityScenario(StratconScenario scenario, StratconFacility facility) {\n+        // this includes:\n+        // for hostile facilities\n+        // - add a destroy objective (always the option to level the facility)\n+        // - add a capture objective (always the option to capture the facility)\n+        // - if so indicated by parameter, roll a random hostile facility objective and add it if not capture/destroy\n+        // for allied facilities\n+        // - add a defend objective (always the option to defend the facility)\n+        // - if so indicated by parameter, roll a random allied facility objective and add it if not defend\n+        AtBScenarioModifier objectiveModifier = null;\n+        boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+\n+        if (alliedFacility) {\n+            objectiveModifier = AtBScenarioModifier.getRandomAlliedFacilityModifier();\n+        } else {\n+            objectiveModifier = AtBScenarioModifier.getRandomHostileFacilityModifier();\n+        }\n+\n+        if (objectiveModifier != null) {\n+            scenario.getBackingScenario().addScenarioModifier(objectiveModifier);\n+            scenario.getBackingScenario().setName(String.format(\"%s - %s - %s\",\n+                    facility.getFacilityType(), alliedFacility ? \"Allied\" : \"Hostile\", objectiveModifier.getModifierName()));\n+        }\n+\n+        // add the \"fixed\" hostile facility modifiers after the primary ones\n+        if (!alliedFacility) {\n+            for(AtBScenarioModifier modifier : AtBScenarioModifier.getRequiredHostileFacilityModifiers()) {\n+                if(!scenario.getBackingScenario().alreadyHasModifier(modifier)) {\n+                    scenario.getBackingScenario().addScenarioModifier(modifier);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void processFacilityEffects(StratconTrackState track) {\n+        // TODO: these are \"weekly\"? effects that a stratcon facility has on the campaign/track state\n+        // currrently, that's\n+        // supply depot - allied - +1 sp\n+        // supply depot - hostile - +5% BV budget to all scenarios on track (shared modifier, so should be implemented there)\n+        // data center - allied - +1% star league cache contract (don't implement yet, but...)\n+        // data center - hostile - +5% scenario odds in track\n+        // industrial center - allied - all scenarios here have THIS IS COMING OUT OF YOUR PAYCHECK modifier\n+        // orbital defense - allied - sets 'no hostile aircraft' flag for track\n+        // orbital defense - hostile - sets 'no allied aircraft' flag for track\n+        // early warning system - allied - sets 'intercept allied base attacks' flag for track\n+        // early warning system - hostile - sets 'intercept hostile base attacks' flag for track\n+    }\n+\n+    /**\n+     * Process the deployment of a force to the given coordinates on the given track.\n+     */\n+    public static void processForceDeployment(StratconCoords coords, int forceID, \n+            Campaign campaign, StratconTrackState track, boolean sticky) {\n+        track.getRevealedCoords().add(coords);\n+        StratconFacility facility = track.getFacility(coords);\n+        if (facility != null) {\n+            facility.setVisible(true);\n+        }\n+\n+        if (campaign.getLances().get(forceID).getRole() == AtBLanceRole.SCOUTING) {\n+            for(int direction = 0; direction < 6; direction++) {\n+                StratconCoords checkCoords = coords.translate(direction);\n+\n+                facility = track.getFacility(checkCoords);\n+                if(facility != null) {\n+                    facility.setVisible(true);\n+                }\n+\n+                track.getRevealedCoords().add(coords.translate(direction));\n+            }\n+        }\n+\n+        // the force may be located in other places on the track - clear it out\n+        track.unassignForce(forceID);\n+        track.assignForce(forceID, coords, campaign.getLocalDate(), sticky);\n+        MekHQ.triggerEvent(new StratconDeploymentEvent(campaign.getForce(forceID)));\n+    }\n+\n+    /**\n+     * Worker function that processes the effects of deploying a reinforcement force to a scenario\n+     */\n+    public static boolean processReinforcementDeployment(ReinforcementEligibilityType reinforcementType,\n+            StratconCampaignState campaignState, StratconScenario scenario, Campaign campaign) {\n+        // if the force is already deployed to the track, we're done\n+        // if the force is a fight lance or we're using a support point\n+        // if there is an SP to burn, burn it and we're done\n+        // if there is a VP to burn, burn it and we're done\n+        // now, roll 2d6 + lance commander tactics\n+        // 9+ = deploy\n+        // 6+ = deploy, apply negative modifier to scenario\n+        // 2+ = fail to deploy, apply negative modifier to scenario; if fight lance, treat as 6+\n+\n+        if ((reinforcementType == ReinforcementEligibilityType.FightLance) ||\n+                (reinforcementType == ReinforcementEligibilityType.SupportPoint)) {\n+\n+            if (campaignState.getSupportPoints() > 0) {\n+                campaignState.useSupportPoint();\n+                return true;\n+            } else if (campaignState.getVictoryPoints() > 0) {\n+                campaignState.updateVictoryPoints(-1);\n+                return true;\n+            }\n+\n+            int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+            int roll = Compute.d6(2);\n+            int result = roll + tactics;\n+\n+            StringBuilder reportStatus = new StringBuilder();\n+            reportStatus.append(String.format(\"Attempting to reinforce scenario %s without SP/VP, roll 2d6 + %d: %d\",\n+                    scenario.getName(), tactics, result));\n+\n+            // fail to reinforce\n+            if ((result < 6) && (reinforcementType != ReinforcementEligibilityType.FightLance)) {\n+                reportStatus.append(\" - reinforcement attempt failed.\");\n+                campaign.addReport(reportStatus.toString());\n+                return false;\n+            // succeed but get an extra negative event added to the scenario\n+            } else if (result < 9) {\n+                MapLocation mapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+                AtBScenarioModifier scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+\n+                // keep rolling until we get an applicable one\n+                // TODO: have the AtBScenarioModifier sort these out instead for performance?\n+                while (scenarioModifier.getEventTiming() != EventTiming.PostForceGeneration) {\n+                    scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+                }\n+\n+                scenarioModifier.processModifier(scenario.getBackingScenario(), campaign, EventTiming.PostForceGeneration);\n+\n+                reportStatus.append(String.format(\" - reinforcement attempt succeeded; extra negative modifier (%s) applied to scenario.\",\n+                        scenarioModifier.getModifierName()));\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            // succeed without reservation\n+            } else {\n+                reportStatus.append(\" - reinforcement attempt succeeded;\");\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            }\n+        } else if (reinforcementType == ReinforcementEligibilityType.None) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Assigns a force to the scenario such that the majority of the force can be deployed\n+     */\n+    private static void assignAppropriateExtraForceToScenario(StratconScenario scenario,\n+            Map<MapLocation, List<Integer>> sortedAvailableForceIDs) {\n+        // the goal of this function is to avoid assigning ground units to air battles\n+        // and ground units/conventional fighters to space battle\n+\n+        List<MapLocation> mapLocations = new ArrayList<>();\n+        mapLocations.add(MapLocation.Space); // can always add ASFs\n+\n+        MapLocation scenarioMapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+\n+        if (scenarioMapLocation == MapLocation.LowAtmosphere) {\n+            mapLocations.add(MapLocation.LowAtmosphere); // can add conventional fighters to ground or low atmo battles\n+        }\n+\n+        if ((scenarioMapLocation == MapLocation.AllGroundTerrain) ||\n+                (scenarioMapLocation == MapLocation.SpecificGroundTerrain)) {\n+            mapLocations.add(MapLocation.AllGroundTerrain); // can only add ground units to ground battles\n+        }\n+\n+        MapLocation selectedLocation = mapLocations.get(Compute.randomInt(mapLocations.size()));\n+        List<Integer> forceIDs = sortedAvailableForceIDs.get(selectedLocation);\n+        int forceIndex = Compute.randomInt(forceIDs.size());\n+        int forceID = forceIDs.get(forceIndex);\n+        forceIDs.remove(forceIndex);\n+\n+        scenario.addPrimaryForce(forceID);\n+    }\n+\n+    /**\n+     * Worker function that \"locks in\" a scenario -\n+     * Adds it to the campaign so it's visible in the briefing room,\n+     * adds it to the track\n+     *\n+     */\n+    public static void commitPrimaryForces(Campaign campaign, StratconScenario scenario, StratconTrackState trackState) {\n+        trackState.addScenario(scenario);\n+\n+        // set up dates for the scenario if doesn't have them already\n+        if (scenario.getDeploymentDate() == null) {\n+            scenario.setDeploymentDate(campaign.getLocalDate());\n+        }\n+\n+        if (scenario.getActionDate() == null) {\n+            scenario.setActionDate(campaign.getLocalDate());\n+        }\n+\n+        if(scenario.getReturnDate() == null) {\n+            scenario.setReturnDate(campaign.getLocalDate().plusDays(trackState.getDeploymentTime()));\n+        }\n+\n+        // set the # of rerolls based on the actual lance assigned.\n+        int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+        scenario.getBackingScenario().setRerolls(tactics);\n+        // The number of defensive points available to a force entering a scenario is\n+        // 2 x tactics. By default, those points are spent on conventional minefields.\n+        if (commanderLanceHasDefensiveAssignment(scenario.getBackingScenario(), campaign)) {\n+            scenario.setNumDefensivePoints(tactics * 2);\n+            scenario.updateMinefieldCount(Minefield.TYPE_CONVENTIONAL, tactics * 2);\n+        }\n+\n+        for (int forceID : scenario.getPlayerTemplateForceIDs()) {\n+            Force force = campaign.getForce(forceID);\n+            force.clearScenarioIds(campaign, true);\n+            force.setScenarioId(scenario.getBackingScenarioID());\n+        }\n+\n+        scenario.commitPrimaryForces();\n+    }\n+\n+    /**\n+     * Utility method to determine if the current scenario's force commander\n+     * is on defence\n+     */\n+    private static boolean commanderLanceHasDefensiveAssignment(AtBDynamicScenario scenario, Campaign campaign) {\n+        Unit commanderUnit = scenario.getLanceCommander(campaign).getUnit();\n+        Lance lance = campaign.getLances().get(commanderUnit.getForceId());\n+\n+        if ((lance != null) && (lance.getRole() == AtBLanceRole.DEFENCE)) {\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * A hackish worker function that takes the given list of force IDs and\n+     * separates it into three sets;\n+     * one of forces that can be \"primary\" on a ground map\n+     * one of forces that can be \"primary\" on an atmospheric map\n+     * one of forces that can be \"primary\" in a space map\n+     * @param forceIDs List of force IDs to check\n+     * @return Sorted hash map\n+     */\n+    private static Map<MapLocation, List<Integer>> sortForcesByMapType(List<Integer> forceIDs, Campaign campaign) {\n+        Map<MapLocation, List<Integer>> retVal = new HashMap<>();\n+\n+        retVal.put(MapLocation.AllGroundTerrain, new ArrayList<>());\n+        retVal.put(MapLocation.LowAtmosphere, new ArrayList<>());\n+        retVal.put(MapLocation.Space, new ArrayList<>());\n+\n+        for (int forceID : forceIDs) {\n+            switch(campaign.getForce(forceID).getPrimaryUnitType(campaign)) {\n+            case UnitType.BATTLE_ARMOR:\n+            case UnitType.INFANTRY:\n+            case UnitType.MEK:\n+            case UnitType.TANK:\n+            case UnitType.PROTOMEK:\n+            case UnitType.VTOL:\n+                retVal.get(MapLocation.AllGroundTerrain).add(forceID);\n+                break;\n+            case UnitType.AERO:\n+                retVal.get(MapLocation.Space).add(forceID);\n+                // intentional fallthrough here, ASFs can go to atmospheric maps too\n+            case UnitType.CONV_FIGHTER:\n+                retVal.get(MapLocation.LowAtmosphere).add(forceID);\n+                break;\n+            }\n+        }\n+\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * Determine whether the user should be nagged about unresolved scenarios on AtB Stratcon tracks.\n+     * @param campaign Campaign to check.\n+     * @return An informative string containing the reasons the user was nagged.\n+     */\n+    public static String nagUnresolvedContacts(Campaign campaign) {\n+        StringBuilder sb = new StringBuilder();\n+\n+        // check every track attached to an active contract for unresolved scenarios\n+        // to which the player must deploy forces today\n+        for (AtBContract contract : campaign.getActiveAtBContracts()) {\n+            if (contract.getStratconCampaignState() == null) {\n+                continue;\n+            }\n+            \n+            for (StratconTrackState track : contract.getStratconCampaignState().getTracks()) {\n+                for (StratconScenario scenario : track.getScenarios().values()) {\n+                    if (scenario.getCurrentState() == ScenarioState.UNRESOLVED &&\n+                            campaign.getLocalDate().equals(scenario.getDeploymentDate())) {\n+                        // \"scenario name, track name\"\n+                        sb.append(String.format(\"%s, %s\\n\", scenario.getName(), track.getDisplayableName()));\n+                    }\n+                }\n+            }\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track.\n+     * Also registers it with the track and campaign.\n+     */\n+    private static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords) {\n+        int unitType = campaign.getForce(forceID).getPrimaryUnitType(campaign);\n+        ScenarioTemplate template = StratconScenarioFactory.getRandomScenario(unitType);\n+        // useful for debugging specific scenario types\n+        //ScenarioTemplate template = StratconScenarioFactory.getSpecificScenario(\"Hostile Facility.xml\");\n+\n+        return generateScenario(campaign, contract, track, forceID, coords, template);\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track,\n+     * using the given template. Also registers it with the campaign.\n+     */\n+    static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords, ScenarioTemplate template) {\n+        StratconScenario scenario = new StratconScenario();\n+        \n+        AtBDynamicScenario backingScenario = AtBDynamicScenarioFactory.initializeScenarioFromTemplate(template, contract, campaign);        \n+        scenario.setBackingScenario(backingScenario);\n+        scenario.setCoords(coords);\n+        \n+        // by default, certain conditions may make this bigger\n+        scenario.setRequiredPlayerLances(1);\n+\n+        // do an appropriate allied force if the contract calls for it\n+        // do any attached or integrated units\n+        setAlliedForceModifier(scenario, contract);\n+        setAttachedUnitsModifier(scenario, contract);\n+        applyFacilityModifiers(scenario, track, coords);\n+        applyGlobalModifiers(scenario, contract.getStratconCampaignState());\n+\n+        if ((contract.getCommandRights() == AtBContract.COM_HOUSE) ||\n+                (contract.getCommandRights() == AtBContract.COM_INTEGRATED)) {\n+            scenario.setRequiredScenario(true);\n+        }\n+\n+        AtBDynamicScenarioFactory.setScenarioModifiers(scenario.getBackingScenario());\n+        scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+        setScenarioDates(track, campaign, scenario);\n+        \n+        // the backing scenario ID must be updated after registering the backing scenario \n+        // with the campaign, so that the stratcon - backing scenario association is maintained\n+        // registering the scenario with the campaign should be done after setting\n+        // dates, otherwise, the report messages for new scenarios look weird\n+        campaign.addScenario(backingScenario, contract);\n+        scenario.setBackingScenarioID(backingScenario.getId());\n+        \n+        if (forceID > Force.FORCE_NONE) {\n+            scenario.addPrimaryForce(forceID);\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * Apply global scenario modifiers from campaign state to given scenario.\n+     */\n+    private static void applyGlobalModifiers(StratconScenario scenario, StratconCampaignState campaignState) {\n+        for (String modifierName : campaignState.getGlobalScenarioModifiers()) {\n+            AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierName);\n+\n+            if (modifier == null) {\n+                MekHQ.getLogger().error(String.format(\"Modifier %s not found; ignoring\", modifierName));\n+                continue;\n+            }\n+\n+            scenario.getBackingScenario().addScenarioModifier(modifier);\n+        }\n+    }\n+\n+    /**\n+     * Applies scenario modifiers from the current track to the given scenario.\n+     * @param scenario\n+     * @param track\n+     */\n+    private static void applyFacilityModifiers(StratconScenario scenario, StratconTrackState track, StratconCoords coords) {\n+        // loop through all the facilities on the track\n+        // if a facility has been revealed, then it has a 100% chance to apply its effect\n+        // if a facility has not been revealed, then it has a x% chance to apply its effect\n+        // if a facility is on the the scenario coordinates the it applies the local effects\n+        for (StratconCoords facilityCoords : track.getFacilities().keySet()) {\n+            boolean scenarioAtFacility = facilityCoords.equals(coords);\n+            StratconFacility facility = track.getFacilities().get(facilityCoords);\n+            List<String> modifierIDs = new ArrayList<>();\n+\n+            if (scenarioAtFacility) {\n+                modifierIDs = facility.getLocalModifiers();\n+            } else if (facility.isVisible() || (Compute.randomInt(100) <= facility.getAggroRating())) {\n+                modifierIDs = facility.getSharedModifiers();\n+            }\n+\n+            for (String modifierID : modifierIDs) {\n+                AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierID);\n+                if(modifier == null) {\n+                    MekHQ.getLogger().error(String.format(\"Modifier %s not found for facility %s\", modifierID, facility.getFormattedDisplayableName()));\n+                    continue;\n+                }\n+\n+                scenario.getBackingScenario().addScenarioModifier(modifier);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set up the appropriate primary allied force modifier, if any\n+     * @param contract The scenario's contract.\n+     */\n+    private static void setAlliedForceModifier(StratconScenario scenario, AtBContract contract) {\n+        int alliedUnitOdds = 0;\n+\n+        // first, we determine the odds of having an allied unit present\n+        // TODO: move this override out to the contract definition\n+        if (contract.getMissionType() == AtBContract.MT_RELIEFDUTY) {\n+            alliedUnitOdds = 50;\n+        } else {\n+            switch(contract.getCommandRights()) {\n+                case AtBContract.COM_INTEGRATED:\n+                    alliedUnitOdds = 50;\n+                    break;\n+                case AtBContract.COM_HOUSE:\n+                    alliedUnitOdds = 30;\n+                    break;\n+                case AtBContract.COM_LIAISON:\n+                    alliedUnitOdds = 10;\n+                    break;\n+            }\n+        }\n+\n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+\n+        // if an allied unit is present, then we want to make sure that it's ground units\n+        // for ground battles\n+        if (Compute.randomInt(100) <= alliedUnitOdds) {\n+            if((backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+               (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space)) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_ALLIED_AIR_UNITS));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_ALLIED_GROUND_UNITS));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set the 'attached' units modifier for the current scenario (integrated, house, liaison),\n+     * and make sure we're not deploying ground units to an air scenario\n+     * @param contract The scenario's contract\n+     */\n+    public static void setAttachedUnitsModifier(StratconScenario scenario, AtBContract contract) {\n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+        boolean airBattle = (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+                (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space);\n+\n+        // if we're on cadre duty, we're getting three trainees, period\n+        if (contract.getMissionType() == AtBContract.MT_CADREDUTY) {\n+            if (airBattle) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_TRAINEES_AIR));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_TRAINEES_GROUND));\n+            }\n+            return;\n+        }\n+\n+        // if we're under non-independent command rights, a supervisor may come along\n+        switch (contract.getCommandRights()) {\n+            case AtBContract.COM_INTEGRATED:\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(airBattle \n+                        ? MekHqConstants.SCENARIO_MODIFIER_INTEGRATED_UNITS_AIR\n+                        : MekHqConstants.SCENARIO_MODIFIER_INTEGRATED_UNITS_GROUND));\n+                break;\n+            case AtBContract.COM_HOUSE:\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(airBattle \n+                        ? MekHqConstants.SCENARIO_MODIFIER_HOUSE_CO_AIR\n+                        : MekHqConstants.SCENARIO_MODIFIER_HOUSE_CO_GROUND));\n+                break;\n+            case AtBContract.COM_LIAISON:\n+                if (scenario.isRequiredScenario()) {\n+                    backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(airBattle \n+                            ? MekHqConstants.SCENARIO_MODIFIER_LIAISON_AIR\n+                            : MekHqConstants.SCENARIO_MODIFIER_LIAISON_GROUND));\n+                }\n+                break;\n+        }\n+    }\n+\n+    /**\n+     * Worker function that sets scenario deploy/battle/return dates based on the track's properties and current campaign date\n+     */\n+    private static void setScenarioDates(StratconTrackState track, Campaign campaign, StratconScenario scenario) {\n+     // set up deployment day, battle day, return day here\n+        // safety code to prevent attempts to generate random int with upper bound of 0 which is apparently illegal\n+        int deploymentDay = track.getDeploymentTime() < 7 ? Compute.randomInt(7 - track.getDeploymentTime()) : 0;\n+        int battleDay = deploymentDay + (track.getDeploymentTime() > 0 ? Compute.randomInt(track.getDeploymentTime()) : 0);\n+        int returnDay = deploymentDay + track.getDeploymentTime();\n+\n+        LocalDate deploymentDate = campaign.getLocalDate();\n+        deploymentDate.plusDays(deploymentDay);\n+        LocalDate battleDate = campaign.getLocalDate();\n+        deploymentDate.plusDays(battleDay);\n+        LocalDate returnDate = campaign.getLocalDate();\n+        returnDate.plusDays(returnDay);\n+\n+        scenario.setDeploymentDate(deploymentDate);\n+        scenario.setActionDate(battleDate);\n+        scenario.setReturnDate(returnDate);\n+    }\n+\n+    /**\n+     * Helper function that determines if the unit type specified in the given scenario force template\n+     * would start out airborne on a ground map (hot dropped units aside)\n+     */\n+    private static boolean unitTypeIsAirborne(ScenarioForceTemplate template) {\n+        int unitType = template.getAllowedUnitType();\n+\n+        return (unitType == UnitType.AERO ||\n+                unitType == UnitType.CONV_FIGHTER ||\n+                unitType == UnitType.DROPSHIP ||\n+                unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_MIX) &&\n+                template.getStartingAltitude() > 0;\n+    }\n+\n+    /**\n+     * Determines whether the force in question has the same primary unit type as the force template.\n+     * @return Whether or not the unit types match.\n+     */\n+    public static boolean forceCompositionMatchesDeclaredUnitType(int primaryUnitType, int unitType, boolean reinforcements) {\n+        // special cases are \"ATB_MIX\" and \"ATB_AERO_MIX\", which encompass multiple unit types\n+        if (unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_MIX) {\n+            // \"AtB mix\" is usually ground units, but air units can sub in\n+            return primaryUnitType == UnitType.MEK ||\n+                    primaryUnitType == UnitType.TANK ||\n+                    primaryUnitType == UnitType.INFANTRY ||\n+                    primaryUnitType == UnitType.BATTLE_ARMOR ||\n+                    primaryUnitType == UnitType.PROTOMEK ||\n+                    primaryUnitType == UnitType.VTOL ||\n+                    (primaryUnitType == UnitType.AERO) && reinforcements ||\n+                    (primaryUnitType == UnitType.CONV_FIGHTER) && reinforcements;\n+        } else if (unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_AERO_MIX) {\n+            return primaryUnitType == UnitType.AERO ||\n+                    primaryUnitType == UnitType.CONV_FIGHTER;\n+        } else {\n+            return primaryUnitType == unitType;\n+        }\n+    }\n+\n+    /**\n+     * This is a set of all force IDs for forces that can be deployed to a scenario.\n+     * @param campaign Current campaign\n+     * @return Set of available force IDs.\n+     */\n+    public static List<Integer> getAvailableForceIDs(Campaign campaign) {\n+        List<Integer> retVal = new ArrayList<>();\n+\n+        // first, we gather a set of all forces that are already deployed to a track so we eliminate those later\n+        Set<Integer> forcesInTracks = new HashSet<>();\n+        for (Contract contract : campaign.getActiveContracts()) {", "originalCommit": "b36d9fa6bf982c7b833b1ac0a0473d37f6e84760", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTE5MjMyNg==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r615192326", "bodyText": "Campaign::getActiveAtBContracts would be far better", "author": "Windchild292", "createdAt": "2021-04-17T02:08:56Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1404 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.UUID;\n+\n+import megamek.common.Compute;\n+import megamek.common.Minefield;\n+import megamek.common.UnitType;\n+import megamek.common.annotations.Nullable;\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.Utilities;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.ResolveScenarioTracker;\n+import mekhq.campaign.againstTheBot.enums.AtBLanceRole;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.event.StratconDeploymentEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.force.Lance;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier.EventTiming;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconFacility.FacilityType;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.unit.Unit;\n+\n+/**\n+ * This class contains \"rules\" logic for the AtB-Stratcon state\n+ * @author NickAragua\n+ */\n+public class StratconRulesManager {\n+    /**\n+     * What makes a particular lance eligible to be reinforcements for a scenario\n+     */\n+    public enum ReinforcementEligibilityType {\n+        /**\n+         * Nothing\n+         */\n+        None,\n+\n+        /**\n+         * Lance is already deployed to the track\n+         */\n+        ChainedScenario,\n+\n+        /**\n+         * We pay a support point or convert a victory point to a support point\n+         */\n+        SupportPoint,\n+\n+        /**\n+         * The lance's deployment orders are \"Fight\"\n+         */\n+        FightLance\n+    }\n+\n+    /**\n+     * This function potentially generates non-player-initiated scenarios for the given track.\n+     */\n+    public static void generateScenariosForTrack(Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // maps scenarios to force IDs\n+        List<StratconScenario> generatedScenarios = new ArrayList<>();\n+        boolean autoAssignLances = contract.getCommandRights() == AtBContract.COM_INTEGRATED;\n+\n+        // get this list just so we have it available\n+        List<Integer> availableForceIDs = getAvailableForceIDs(campaign);\n+        Map<MapLocation, List<Integer>> sortedAvailableForceIDs = sortForcesByMapType(availableForceIDs, campaign);\n+\n+        // make X rolls, where X is the number of required lances for the track\n+        // that's the chance to spawn a scenario.\n+        // if a scenario occurs, then we pick a random non-deployed lance and use it to drive the opfor generation later\n+        // once we've determined that scenarios occur, we loop through the ones that we generated\n+        // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all\n+        for (int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            int targetNum = calculateScenarioOdds(track, contract, false);\n+            \n+            // if we haven't already used all the player forces and are required to randomly generate a scenario\n+            if (!availableForceIDs.isEmpty() && (Compute.randomInt(100) <= targetNum)) {\n+                // pick random coordinates and force to drive the scenario\n+                int x = Compute.randomInt(track.getWidth());\n+                int y = Compute.randomInt(track.getHeight());\n+\n+                StratconCoords scenarioCoords = new StratconCoords(x, y);\n+\n+                // if forces are already assigned to these coordinates, use those instead\n+                // of randomly-selected ones\n+                if (track.getAssignedCoordForces().containsKey(scenarioCoords)) {\n+                    StratconScenario scenario = generateScenarioForExistingForces(scenarioCoords,\n+                            track.getAssignedCoordForces().get(scenarioCoords), \n+                            contract, campaign, track);\n+                    generatedScenarios.add(scenario);\n+                    continue;\n+                }\n+                \n+                // otherwise, pick a random force from the avail\n+                int randomForceIndex = Compute.randomInt(availableForceIDs.size());\n+                int randomForceID = availableForceIDs.get(randomForceIndex);\n+                \n+                // remove the force from the available lists so we don't designate it as primary twice\n+                availableForceIDs.remove(randomForceIndex);\n+\n+                // we want to remove the actual int with the value, not the value at the index\n+                sortedAvailableForceIDs.get(MapLocation.AllGroundTerrain).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.LowAtmosphere).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.Space).remove((Integer) randomForceID);\n+\n+                // two scenarios on the same coordinates wind up increasing in size\n+                if (track.getScenarios().containsKey(scenarioCoords)) {\n+                    track.getScenarios().get(scenarioCoords).incrementRequiredPlayerLances();\n+                    assignAppropriateExtraForceToScenario(track.getScenarios().get(scenarioCoords), sortedAvailableForceIDs);\n+                    continue;\n+                }\n+\n+                StratconScenario scenario = setupScenario(scenarioCoords, randomForceID, campaign, contract, track);\n+                generatedScenarios.add(scenario);\n+\n+                // if we're auto-assigning lances, deploy the force to the track as well\n+                if (autoAssignLances) {\n+                    processForceDeployment(scenarioCoords, randomForceID, campaign, track, false);\n+                }\n+            }\n+        }\n+\n+        // if under liaison command, pick a random scenario from the ones generated\n+        // to set as required and attach liaison\n+        if (contract.getCommandRights() == AtBContract.COM_LIAISON) {\n+        \tStratconScenario randomScenario = Utilities.getRandomItem(generatedScenarios);\n+        \trandomScenario.setRequiredScenario(true);\n+            setAttachedUnitsModifier(randomScenario, contract);\n+        }\n+\n+        // now, we loop through all the scenarios we set up\n+        // and generate the opfors / events / etc\n+        // if not auto-assigning lances, we then back out the lance assignments.\n+        for (StratconScenario scenario : generatedScenarios) {\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+\n+            if(!autoAssignLances && !scenario.ignoreForceAutoAssignment()) {\n+                for(int forceID : scenario.getPlayerTemplateForceIDs()) {\n+                    scenario.getBackingScenario().removeForce(forceID);\n+                }\n+\n+                scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                track.addScenario(scenario);\n+            } else {\n+                commitPrimaryForces(campaign, scenario, track);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Given a set of force IDs and coordinates, generate a scenario\n+     * Useful for when we want to generate scenarios \n+     * for forces already deployed to a track\n+     */\n+    public static StratconScenario generateScenarioForExistingForces(StratconCoords scenarioCoords, \n+            Set<Integer> forceIDs, AtBContract contract, Campaign campaign, StratconTrackState track) {\n+        boolean firstForce = true;\n+        StratconScenario scenario = null;\n+        \n+        for (int forceID : forceIDs) {\n+            if (firstForce) {\n+                scenario = setupScenario(scenarioCoords, forceID, campaign, contract, track);\n+                firstForce = false;\n+            } else {\n+                scenario.incrementRequiredPlayerLances();\n+                scenario.addPrimaryForce(forceID);\n+            }\n+        }\n+        \n+        // this is theoretically possible if forceIDs is passed in as null - not likely in practice\n+        // but might as well, to future-proof.\n+        if (scenario != null) {\n+            scenario.setIgnoreForceAutoAssignment(true);\n+        }\n+        \n+        return scenario;\n+    }\n+\n+    /**\n+     * Deploys a force to the given coordinates on the given track as a result of explicit player action.\n+     */\n+    public static void deployForceToCoords(StratconCoords coords, int forceID, \n+            Campaign campaign, AtBContract contract, StratconTrackState track, boolean sticky) {\n+        // the following things should happen:\n+        // 1. call to \"process force deployment\", which reveals fog of war in or around the coords, depending on force role\n+        // 2. if coords are a hostile facility, we get a facility mission\n+        // 3. if coords are empty, we *may* get a mission\n+\n+        processForceDeployment(coords, forceID, campaign, track, sticky);\n+\n+        // don't create a scenario on top of allied facilities\n+        StratconFacility facility = track.getFacility(coords);\n+        boolean isNonAlliedFacility = (facility != null) && (facility.getOwner() != ForceAlignment.Allied);\n+        int targetNum = calculateScenarioOdds(track, contract, true);\n+        boolean spawnScenario = (facility == null) && (Compute.randomInt(100) <= targetNum);\n+\n+        if (isNonAlliedFacility || spawnScenario) {\n+            StratconScenario scenario = setupScenario(coords, forceID, campaign, contract, track);\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            commitPrimaryForces(campaign, scenario, track);\n+        }\n+    }\n+\n+    /**\n+     * Logic to set up a scenario\n+     */\n+    private static StratconScenario setupScenario(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        StratconScenario scenario = null;\n+\n+        if (track.getFacilities().containsKey(coords)) {\n+            StratconFacility facility = track.getFacility(coords);\n+            boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+            ScenarioTemplate template = StratconScenarioFactory.getFacilityScenario(alliedFacility);\n+            scenario = generateScenario(campaign, contract, track, forceID, coords, template);\n+            setupFacilityScenario(scenario, facility);\n+        } else {\n+            scenario = generateScenario(campaign, contract, track, forceID, coords);\n+\n+            // we may generate a facility scenario randomly - if so, do the facility-related stuff\n+            // and add a new facility to the track\n+            if (scenario.getBackingScenario().getTemplate().isFacilityScenario()) {\n+                StratconFacility facility = scenario.getBackingScenario().getTemplate().isHostileFacility() ?\n+                        StratconFacilityFactory.getRandomHostileFacility() : StratconFacilityFactory.getRandomAlliedFacility();\n+                facility.setVisible(true);\n+                track.addFacility(coords, facility);\n+                setupFacilityScenario(scenario, facility);\n+            }\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * carries out tasks relevant to facility scenarios\n+     */\n+    private static void setupFacilityScenario(StratconScenario scenario, StratconFacility facility) {\n+        // this includes:\n+        // for hostile facilities\n+        // - add a destroy objective (always the option to level the facility)\n+        // - add a capture objective (always the option to capture the facility)\n+        // - if so indicated by parameter, roll a random hostile facility objective and add it if not capture/destroy\n+        // for allied facilities\n+        // - add a defend objective (always the option to defend the facility)\n+        // - if so indicated by parameter, roll a random allied facility objective and add it if not defend\n+        AtBScenarioModifier objectiveModifier = null;\n+        boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+\n+        if (alliedFacility) {\n+            objectiveModifier = AtBScenarioModifier.getRandomAlliedFacilityModifier();\n+        } else {\n+            objectiveModifier = AtBScenarioModifier.getRandomHostileFacilityModifier();\n+        }\n+\n+        if (objectiveModifier != null) {\n+            scenario.getBackingScenario().addScenarioModifier(objectiveModifier);\n+            scenario.getBackingScenario().setName(String.format(\"%s - %s - %s\",\n+                    facility.getFacilityType(), alliedFacility ? \"Allied\" : \"Hostile\", objectiveModifier.getModifierName()));\n+        }\n+\n+        // add the \"fixed\" hostile facility modifiers after the primary ones\n+        if (!alliedFacility) {\n+            for(AtBScenarioModifier modifier : AtBScenarioModifier.getRequiredHostileFacilityModifiers()) {\n+                if(!scenario.getBackingScenario().alreadyHasModifier(modifier)) {\n+                    scenario.getBackingScenario().addScenarioModifier(modifier);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void processFacilityEffects(StratconTrackState track) {\n+        // TODO: these are \"weekly\"? effects that a stratcon facility has on the campaign/track state\n+        // currrently, that's\n+        // supply depot - allied - +1 sp\n+        // supply depot - hostile - +5% BV budget to all scenarios on track (shared modifier, so should be implemented there)\n+        // data center - allied - +1% star league cache contract (don't implement yet, but...)\n+        // data center - hostile - +5% scenario odds in track\n+        // industrial center - allied - all scenarios here have THIS IS COMING OUT OF YOUR PAYCHECK modifier\n+        // orbital defense - allied - sets 'no hostile aircraft' flag for track\n+        // orbital defense - hostile - sets 'no allied aircraft' flag for track\n+        // early warning system - allied - sets 'intercept allied base attacks' flag for track\n+        // early warning system - hostile - sets 'intercept hostile base attacks' flag for track\n+    }\n+\n+    /**\n+     * Process the deployment of a force to the given coordinates on the given track.\n+     */\n+    public static void processForceDeployment(StratconCoords coords, int forceID, \n+            Campaign campaign, StratconTrackState track, boolean sticky) {\n+        track.getRevealedCoords().add(coords);\n+        StratconFacility facility = track.getFacility(coords);\n+        if (facility != null) {\n+            facility.setVisible(true);\n+        }\n+\n+        if (campaign.getLances().get(forceID).getRole() == AtBLanceRole.SCOUTING) {\n+            for(int direction = 0; direction < 6; direction++) {\n+                StratconCoords checkCoords = coords.translate(direction);\n+\n+                facility = track.getFacility(checkCoords);\n+                if(facility != null) {\n+                    facility.setVisible(true);\n+                }\n+\n+                track.getRevealedCoords().add(coords.translate(direction));\n+            }\n+        }\n+\n+        // the force may be located in other places on the track - clear it out\n+        track.unassignForce(forceID);\n+        track.assignForce(forceID, coords, campaign.getLocalDate(), sticky);\n+        MekHQ.triggerEvent(new StratconDeploymentEvent(campaign.getForce(forceID)));\n+    }\n+\n+    /**\n+     * Worker function that processes the effects of deploying a reinforcement force to a scenario\n+     */\n+    public static boolean processReinforcementDeployment(ReinforcementEligibilityType reinforcementType,\n+            StratconCampaignState campaignState, StratconScenario scenario, Campaign campaign) {\n+        // if the force is already deployed to the track, we're done\n+        // if the force is a fight lance or we're using a support point\n+        // if there is an SP to burn, burn it and we're done\n+        // if there is a VP to burn, burn it and we're done\n+        // now, roll 2d6 + lance commander tactics\n+        // 9+ = deploy\n+        // 6+ = deploy, apply negative modifier to scenario\n+        // 2+ = fail to deploy, apply negative modifier to scenario; if fight lance, treat as 6+\n+\n+        if ((reinforcementType == ReinforcementEligibilityType.FightLance) ||\n+                (reinforcementType == ReinforcementEligibilityType.SupportPoint)) {\n+\n+            if (campaignState.getSupportPoints() > 0) {\n+                campaignState.useSupportPoint();\n+                return true;\n+            } else if (campaignState.getVictoryPoints() > 0) {\n+                campaignState.updateVictoryPoints(-1);\n+                return true;\n+            }\n+\n+            int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+            int roll = Compute.d6(2);\n+            int result = roll + tactics;\n+\n+            StringBuilder reportStatus = new StringBuilder();\n+            reportStatus.append(String.format(\"Attempting to reinforce scenario %s without SP/VP, roll 2d6 + %d: %d\",\n+                    scenario.getName(), tactics, result));\n+\n+            // fail to reinforce\n+            if ((result < 6) && (reinforcementType != ReinforcementEligibilityType.FightLance)) {\n+                reportStatus.append(\" - reinforcement attempt failed.\");\n+                campaign.addReport(reportStatus.toString());\n+                return false;\n+            // succeed but get an extra negative event added to the scenario\n+            } else if (result < 9) {\n+                MapLocation mapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+                AtBScenarioModifier scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+\n+                // keep rolling until we get an applicable one\n+                // TODO: have the AtBScenarioModifier sort these out instead for performance?\n+                while (scenarioModifier.getEventTiming() != EventTiming.PostForceGeneration) {\n+                    scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+                }\n+\n+                scenarioModifier.processModifier(scenario.getBackingScenario(), campaign, EventTiming.PostForceGeneration);\n+\n+                reportStatus.append(String.format(\" - reinforcement attempt succeeded; extra negative modifier (%s) applied to scenario.\",\n+                        scenarioModifier.getModifierName()));\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            // succeed without reservation\n+            } else {\n+                reportStatus.append(\" - reinforcement attempt succeeded;\");\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            }\n+        } else if (reinforcementType == ReinforcementEligibilityType.None) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Assigns a force to the scenario such that the majority of the force can be deployed\n+     */\n+    private static void assignAppropriateExtraForceToScenario(StratconScenario scenario,\n+            Map<MapLocation, List<Integer>> sortedAvailableForceIDs) {\n+        // the goal of this function is to avoid assigning ground units to air battles\n+        // and ground units/conventional fighters to space battle\n+\n+        List<MapLocation> mapLocations = new ArrayList<>();\n+        mapLocations.add(MapLocation.Space); // can always add ASFs\n+\n+        MapLocation scenarioMapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+\n+        if (scenarioMapLocation == MapLocation.LowAtmosphere) {\n+            mapLocations.add(MapLocation.LowAtmosphere); // can add conventional fighters to ground or low atmo battles\n+        }\n+\n+        if ((scenarioMapLocation == MapLocation.AllGroundTerrain) ||\n+                (scenarioMapLocation == MapLocation.SpecificGroundTerrain)) {\n+            mapLocations.add(MapLocation.AllGroundTerrain); // can only add ground units to ground battles\n+        }\n+\n+        MapLocation selectedLocation = mapLocations.get(Compute.randomInt(mapLocations.size()));\n+        List<Integer> forceIDs = sortedAvailableForceIDs.get(selectedLocation);\n+        int forceIndex = Compute.randomInt(forceIDs.size());\n+        int forceID = forceIDs.get(forceIndex);\n+        forceIDs.remove(forceIndex);\n+\n+        scenario.addPrimaryForce(forceID);\n+    }\n+\n+    /**\n+     * Worker function that \"locks in\" a scenario -\n+     * Adds it to the campaign so it's visible in the briefing room,\n+     * adds it to the track\n+     *\n+     */\n+    public static void commitPrimaryForces(Campaign campaign, StratconScenario scenario, StratconTrackState trackState) {\n+        trackState.addScenario(scenario);\n+\n+        // set up dates for the scenario if doesn't have them already\n+        if (scenario.getDeploymentDate() == null) {\n+            scenario.setDeploymentDate(campaign.getLocalDate());\n+        }\n+\n+        if (scenario.getActionDate() == null) {\n+            scenario.setActionDate(campaign.getLocalDate());\n+        }\n+\n+        if(scenario.getReturnDate() == null) {\n+            scenario.setReturnDate(campaign.getLocalDate().plusDays(trackState.getDeploymentTime()));\n+        }\n+\n+        // set the # of rerolls based on the actual lance assigned.\n+        int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+        scenario.getBackingScenario().setRerolls(tactics);\n+        // The number of defensive points available to a force entering a scenario is\n+        // 2 x tactics. By default, those points are spent on conventional minefields.\n+        if (commanderLanceHasDefensiveAssignment(scenario.getBackingScenario(), campaign)) {\n+            scenario.setNumDefensivePoints(tactics * 2);\n+            scenario.updateMinefieldCount(Minefield.TYPE_CONVENTIONAL, tactics * 2);\n+        }\n+\n+        for (int forceID : scenario.getPlayerTemplateForceIDs()) {\n+            Force force = campaign.getForce(forceID);\n+            force.clearScenarioIds(campaign, true);\n+            force.setScenarioId(scenario.getBackingScenarioID());\n+        }\n+\n+        scenario.commitPrimaryForces();\n+    }\n+\n+    /**\n+     * Utility method to determine if the current scenario's force commander\n+     * is on defence\n+     */\n+    private static boolean commanderLanceHasDefensiveAssignment(AtBDynamicScenario scenario, Campaign campaign) {\n+        Unit commanderUnit = scenario.getLanceCommander(campaign).getUnit();\n+        Lance lance = campaign.getLances().get(commanderUnit.getForceId());\n+\n+        if ((lance != null) && (lance.getRole() == AtBLanceRole.DEFENCE)) {\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * A hackish worker function that takes the given list of force IDs and\n+     * separates it into three sets;\n+     * one of forces that can be \"primary\" on a ground map\n+     * one of forces that can be \"primary\" on an atmospheric map\n+     * one of forces that can be \"primary\" in a space map\n+     * @param forceIDs List of force IDs to check\n+     * @return Sorted hash map\n+     */\n+    private static Map<MapLocation, List<Integer>> sortForcesByMapType(List<Integer> forceIDs, Campaign campaign) {\n+        Map<MapLocation, List<Integer>> retVal = new HashMap<>();\n+\n+        retVal.put(MapLocation.AllGroundTerrain, new ArrayList<>());\n+        retVal.put(MapLocation.LowAtmosphere, new ArrayList<>());\n+        retVal.put(MapLocation.Space, new ArrayList<>());\n+\n+        for (int forceID : forceIDs) {\n+            switch(campaign.getForce(forceID).getPrimaryUnitType(campaign)) {\n+            case UnitType.BATTLE_ARMOR:\n+            case UnitType.INFANTRY:\n+            case UnitType.MEK:\n+            case UnitType.TANK:\n+            case UnitType.PROTOMEK:\n+            case UnitType.VTOL:\n+                retVal.get(MapLocation.AllGroundTerrain).add(forceID);\n+                break;\n+            case UnitType.AERO:\n+                retVal.get(MapLocation.Space).add(forceID);\n+                // intentional fallthrough here, ASFs can go to atmospheric maps too\n+            case UnitType.CONV_FIGHTER:\n+                retVal.get(MapLocation.LowAtmosphere).add(forceID);\n+                break;\n+            }\n+        }\n+\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * Determine whether the user should be nagged about unresolved scenarios on AtB Stratcon tracks.\n+     * @param campaign Campaign to check.\n+     * @return An informative string containing the reasons the user was nagged.\n+     */\n+    public static String nagUnresolvedContacts(Campaign campaign) {\n+        StringBuilder sb = new StringBuilder();\n+\n+        // check every track attached to an active contract for unresolved scenarios\n+        // to which the player must deploy forces today\n+        for (AtBContract contract : campaign.getActiveAtBContracts()) {\n+            if (contract.getStratconCampaignState() == null) {\n+                continue;\n+            }\n+            \n+            for (StratconTrackState track : contract.getStratconCampaignState().getTracks()) {\n+                for (StratconScenario scenario : track.getScenarios().values()) {\n+                    if (scenario.getCurrentState() == ScenarioState.UNRESOLVED &&\n+                            campaign.getLocalDate().equals(scenario.getDeploymentDate())) {\n+                        // \"scenario name, track name\"\n+                        sb.append(String.format(\"%s, %s\\n\", scenario.getName(), track.getDisplayableName()));\n+                    }\n+                }\n+            }\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track.\n+     * Also registers it with the track and campaign.\n+     */\n+    private static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords) {\n+        int unitType = campaign.getForce(forceID).getPrimaryUnitType(campaign);\n+        ScenarioTemplate template = StratconScenarioFactory.getRandomScenario(unitType);\n+        // useful for debugging specific scenario types\n+        //ScenarioTemplate template = StratconScenarioFactory.getSpecificScenario(\"Hostile Facility.xml\");\n+\n+        return generateScenario(campaign, contract, track, forceID, coords, template);\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track,\n+     * using the given template. Also registers it with the campaign.\n+     */\n+    static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords, ScenarioTemplate template) {\n+        StratconScenario scenario = new StratconScenario();\n+        \n+        AtBDynamicScenario backingScenario = AtBDynamicScenarioFactory.initializeScenarioFromTemplate(template, contract, campaign);        \n+        scenario.setBackingScenario(backingScenario);\n+        scenario.setCoords(coords);\n+        \n+        // by default, certain conditions may make this bigger\n+        scenario.setRequiredPlayerLances(1);\n+\n+        // do an appropriate allied force if the contract calls for it\n+        // do any attached or integrated units\n+        setAlliedForceModifier(scenario, contract);\n+        setAttachedUnitsModifier(scenario, contract);\n+        applyFacilityModifiers(scenario, track, coords);\n+        applyGlobalModifiers(scenario, contract.getStratconCampaignState());\n+\n+        if ((contract.getCommandRights() == AtBContract.COM_HOUSE) ||\n+                (contract.getCommandRights() == AtBContract.COM_INTEGRATED)) {\n+            scenario.setRequiredScenario(true);\n+        }\n+\n+        AtBDynamicScenarioFactory.setScenarioModifiers(scenario.getBackingScenario());\n+        scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+        setScenarioDates(track, campaign, scenario);\n+        \n+        // the backing scenario ID must be updated after registering the backing scenario \n+        // with the campaign, so that the stratcon - backing scenario association is maintained\n+        // registering the scenario with the campaign should be done after setting\n+        // dates, otherwise, the report messages for new scenarios look weird\n+        campaign.addScenario(backingScenario, contract);\n+        scenario.setBackingScenarioID(backingScenario.getId());\n+        \n+        if (forceID > Force.FORCE_NONE) {\n+            scenario.addPrimaryForce(forceID);\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * Apply global scenario modifiers from campaign state to given scenario.\n+     */\n+    private static void applyGlobalModifiers(StratconScenario scenario, StratconCampaignState campaignState) {\n+        for (String modifierName : campaignState.getGlobalScenarioModifiers()) {\n+            AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierName);\n+\n+            if (modifier == null) {\n+                MekHQ.getLogger().error(String.format(\"Modifier %s not found; ignoring\", modifierName));\n+                continue;\n+            }\n+\n+            scenario.getBackingScenario().addScenarioModifier(modifier);\n+        }\n+    }\n+\n+    /**\n+     * Applies scenario modifiers from the current track to the given scenario.\n+     * @param scenario\n+     * @param track\n+     */\n+    private static void applyFacilityModifiers(StratconScenario scenario, StratconTrackState track, StratconCoords coords) {\n+        // loop through all the facilities on the track\n+        // if a facility has been revealed, then it has a 100% chance to apply its effect\n+        // if a facility has not been revealed, then it has a x% chance to apply its effect\n+        // if a facility is on the the scenario coordinates the it applies the local effects\n+        for (StratconCoords facilityCoords : track.getFacilities().keySet()) {\n+            boolean scenarioAtFacility = facilityCoords.equals(coords);\n+            StratconFacility facility = track.getFacilities().get(facilityCoords);\n+            List<String> modifierIDs = new ArrayList<>();\n+\n+            if (scenarioAtFacility) {\n+                modifierIDs = facility.getLocalModifiers();\n+            } else if (facility.isVisible() || (Compute.randomInt(100) <= facility.getAggroRating())) {\n+                modifierIDs = facility.getSharedModifiers();\n+            }\n+\n+            for (String modifierID : modifierIDs) {\n+                AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierID);\n+                if(modifier == null) {\n+                    MekHQ.getLogger().error(String.format(\"Modifier %s not found for facility %s\", modifierID, facility.getFormattedDisplayableName()));\n+                    continue;\n+                }\n+\n+                scenario.getBackingScenario().addScenarioModifier(modifier);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set up the appropriate primary allied force modifier, if any\n+     * @param contract The scenario's contract.\n+     */\n+    private static void setAlliedForceModifier(StratconScenario scenario, AtBContract contract) {\n+        int alliedUnitOdds = 0;\n+\n+        // first, we determine the odds of having an allied unit present\n+        // TODO: move this override out to the contract definition\n+        if (contract.getMissionType() == AtBContract.MT_RELIEFDUTY) {\n+            alliedUnitOdds = 50;\n+        } else {\n+            switch(contract.getCommandRights()) {\n+                case AtBContract.COM_INTEGRATED:\n+                    alliedUnitOdds = 50;\n+                    break;\n+                case AtBContract.COM_HOUSE:\n+                    alliedUnitOdds = 30;\n+                    break;\n+                case AtBContract.COM_LIAISON:\n+                    alliedUnitOdds = 10;\n+                    break;\n+            }\n+        }\n+\n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+\n+        // if an allied unit is present, then we want to make sure that it's ground units\n+        // for ground battles\n+        if (Compute.randomInt(100) <= alliedUnitOdds) {\n+            if((backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+               (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space)) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_ALLIED_AIR_UNITS));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_ALLIED_GROUND_UNITS));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set the 'attached' units modifier for the current scenario (integrated, house, liaison),\n+     * and make sure we're not deploying ground units to an air scenario\n+     * @param contract The scenario's contract\n+     */\n+    public static void setAttachedUnitsModifier(StratconScenario scenario, AtBContract contract) {\n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+        boolean airBattle = (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+                (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space);\n+\n+        // if we're on cadre duty, we're getting three trainees, period\n+        if (contract.getMissionType() == AtBContract.MT_CADREDUTY) {\n+            if (airBattle) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_TRAINEES_AIR));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_TRAINEES_GROUND));\n+            }\n+            return;\n+        }\n+\n+        // if we're under non-independent command rights, a supervisor may come along\n+        switch (contract.getCommandRights()) {\n+            case AtBContract.COM_INTEGRATED:\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(airBattle \n+                        ? MekHqConstants.SCENARIO_MODIFIER_INTEGRATED_UNITS_AIR\n+                        : MekHqConstants.SCENARIO_MODIFIER_INTEGRATED_UNITS_GROUND));\n+                break;\n+            case AtBContract.COM_HOUSE:\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(airBattle \n+                        ? MekHqConstants.SCENARIO_MODIFIER_HOUSE_CO_AIR\n+                        : MekHqConstants.SCENARIO_MODIFIER_HOUSE_CO_GROUND));\n+                break;\n+            case AtBContract.COM_LIAISON:\n+                if (scenario.isRequiredScenario()) {\n+                    backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(airBattle \n+                            ? MekHqConstants.SCENARIO_MODIFIER_LIAISON_AIR\n+                            : MekHqConstants.SCENARIO_MODIFIER_LIAISON_GROUND));\n+                }\n+                break;\n+        }\n+    }\n+\n+    /**\n+     * Worker function that sets scenario deploy/battle/return dates based on the track's properties and current campaign date\n+     */\n+    private static void setScenarioDates(StratconTrackState track, Campaign campaign, StratconScenario scenario) {\n+     // set up deployment day, battle day, return day here\n+        // safety code to prevent attempts to generate random int with upper bound of 0 which is apparently illegal\n+        int deploymentDay = track.getDeploymentTime() < 7 ? Compute.randomInt(7 - track.getDeploymentTime()) : 0;\n+        int battleDay = deploymentDay + (track.getDeploymentTime() > 0 ? Compute.randomInt(track.getDeploymentTime()) : 0);\n+        int returnDay = deploymentDay + track.getDeploymentTime();\n+\n+        LocalDate deploymentDate = campaign.getLocalDate();\n+        deploymentDate.plusDays(deploymentDay);\n+        LocalDate battleDate = campaign.getLocalDate();\n+        deploymentDate.plusDays(battleDay);\n+        LocalDate returnDate = campaign.getLocalDate();\n+        returnDate.plusDays(returnDay);\n+\n+        scenario.setDeploymentDate(deploymentDate);\n+        scenario.setActionDate(battleDate);\n+        scenario.setReturnDate(returnDate);\n+    }\n+\n+    /**\n+     * Helper function that determines if the unit type specified in the given scenario force template\n+     * would start out airborne on a ground map (hot dropped units aside)\n+     */\n+    private static boolean unitTypeIsAirborne(ScenarioForceTemplate template) {\n+        int unitType = template.getAllowedUnitType();\n+\n+        return (unitType == UnitType.AERO ||\n+                unitType == UnitType.CONV_FIGHTER ||\n+                unitType == UnitType.DROPSHIP ||\n+                unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_MIX) &&\n+                template.getStartingAltitude() > 0;\n+    }\n+\n+    /**\n+     * Determines whether the force in question has the same primary unit type as the force template.\n+     * @return Whether or not the unit types match.\n+     */\n+    public static boolean forceCompositionMatchesDeclaredUnitType(int primaryUnitType, int unitType, boolean reinforcements) {\n+        // special cases are \"ATB_MIX\" and \"ATB_AERO_MIX\", which encompass multiple unit types\n+        if (unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_MIX) {\n+            // \"AtB mix\" is usually ground units, but air units can sub in\n+            return primaryUnitType == UnitType.MEK ||\n+                    primaryUnitType == UnitType.TANK ||\n+                    primaryUnitType == UnitType.INFANTRY ||\n+                    primaryUnitType == UnitType.BATTLE_ARMOR ||\n+                    primaryUnitType == UnitType.PROTOMEK ||\n+                    primaryUnitType == UnitType.VTOL ||\n+                    (primaryUnitType == UnitType.AERO) && reinforcements ||\n+                    (primaryUnitType == UnitType.CONV_FIGHTER) && reinforcements;\n+        } else if (unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_AERO_MIX) {\n+            return primaryUnitType == UnitType.AERO ||\n+                    primaryUnitType == UnitType.CONV_FIGHTER;\n+        } else {\n+            return primaryUnitType == unitType;\n+        }\n+    }\n+\n+    /**\n+     * This is a set of all force IDs for forces that can be deployed to a scenario.\n+     * @param campaign Current campaign\n+     * @return Set of available force IDs.\n+     */\n+    public static List<Integer> getAvailableForceIDs(Campaign campaign) {\n+        List<Integer> retVal = new ArrayList<>();\n+\n+        // first, we gather a set of all forces that are already deployed to a track so we eliminate those later\n+        Set<Integer> forcesInTracks = new HashSet<>();\n+        for (Contract contract : campaign.getActiveContracts()) {\n+            if (contract instanceof AtBContract) {\n+                for (StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    forcesInTracks.addAll(track.getAssignedForceCoords().keySet());\n+                }\n+            }\n+        }\n+\n+        // now, we get all the forces that qualify as \"lances\", and filter out those that are\n+        // deployed to a scenario and not in a track already\n+        for (int key : campaign.getLances().keySet()) {\n+            Force force = campaign.getForce(key);\n+            if ((force != null) &&\n+                    !force.isDeployed() &&\n+                    !forcesInTracks.contains(force.getId())) {\n+                retVal.add(force.getId());\n+            }\n+        }\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * This is a list of all force IDs for forces that can be deployed to a scenario in the given force template\n+     * a) have not been assigned to a track\n+     * b) are combat-capable\n+     * c) are not deployed to a scenario\n+     * d) if attempting to deploy as reinforcements, haven't already failed to deploy\n+     */\n+    public static List<Integer> getAvailableForceIDs(int unitType, Campaign campaign, StratconTrackState currentTrack,\n+            boolean reinforcements, @Nullable StratconScenario currentScenario) {\n+        List<Integer> retVal = new ArrayList<>();\n+\n+        Set<Integer> forcesInTracks = new HashSet<>();\n+        // assemble a set of all force IDs that are currently assigned to tracks that are not this one\n+        for (Contract contract : campaign.getActiveContracts()) {", "originalCommit": "b36d9fa6bf982c7b833b1ac0a0473d37f6e84760", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTE5MjM5Nw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r615192397", "bodyText": "odd formatting", "author": "Windchild292", "createdAt": "2021-04-17T02:09:48Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1404 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.UUID;\n+\n+import megamek.common.Compute;\n+import megamek.common.Minefield;\n+import megamek.common.UnitType;\n+import megamek.common.annotations.Nullable;\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.Utilities;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.ResolveScenarioTracker;\n+import mekhq.campaign.againstTheBot.enums.AtBLanceRole;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.event.StratconDeploymentEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.force.Lance;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier.EventTiming;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconFacility.FacilityType;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.unit.Unit;\n+\n+/**\n+ * This class contains \"rules\" logic for the AtB-Stratcon state\n+ * @author NickAragua\n+ */\n+public class StratconRulesManager {\n+    /**\n+     * What makes a particular lance eligible to be reinforcements for a scenario\n+     */\n+    public enum ReinforcementEligibilityType {\n+        /**\n+         * Nothing\n+         */\n+        None,\n+\n+        /**\n+         * Lance is already deployed to the track\n+         */\n+        ChainedScenario,\n+\n+        /**\n+         * We pay a support point or convert a victory point to a support point\n+         */\n+        SupportPoint,\n+\n+        /**\n+         * The lance's deployment orders are \"Fight\"\n+         */\n+        FightLance\n+    }\n+\n+    /**\n+     * This function potentially generates non-player-initiated scenarios for the given track.\n+     */\n+    public static void generateScenariosForTrack(Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // maps scenarios to force IDs\n+        List<StratconScenario> generatedScenarios = new ArrayList<>();\n+        boolean autoAssignLances = contract.getCommandRights() == AtBContract.COM_INTEGRATED;\n+\n+        // get this list just so we have it available\n+        List<Integer> availableForceIDs = getAvailableForceIDs(campaign);\n+        Map<MapLocation, List<Integer>> sortedAvailableForceIDs = sortForcesByMapType(availableForceIDs, campaign);\n+\n+        // make X rolls, where X is the number of required lances for the track\n+        // that's the chance to spawn a scenario.\n+        // if a scenario occurs, then we pick a random non-deployed lance and use it to drive the opfor generation later\n+        // once we've determined that scenarios occur, we loop through the ones that we generated\n+        // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all\n+        for (int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            int targetNum = calculateScenarioOdds(track, contract, false);\n+            \n+            // if we haven't already used all the player forces and are required to randomly generate a scenario\n+            if (!availableForceIDs.isEmpty() && (Compute.randomInt(100) <= targetNum)) {\n+                // pick random coordinates and force to drive the scenario\n+                int x = Compute.randomInt(track.getWidth());\n+                int y = Compute.randomInt(track.getHeight());\n+\n+                StratconCoords scenarioCoords = new StratconCoords(x, y);\n+\n+                // if forces are already assigned to these coordinates, use those instead\n+                // of randomly-selected ones\n+                if (track.getAssignedCoordForces().containsKey(scenarioCoords)) {\n+                    StratconScenario scenario = generateScenarioForExistingForces(scenarioCoords,\n+                            track.getAssignedCoordForces().get(scenarioCoords), \n+                            contract, campaign, track);\n+                    generatedScenarios.add(scenario);\n+                    continue;\n+                }\n+                \n+                // otherwise, pick a random force from the avail\n+                int randomForceIndex = Compute.randomInt(availableForceIDs.size());\n+                int randomForceID = availableForceIDs.get(randomForceIndex);\n+                \n+                // remove the force from the available lists so we don't designate it as primary twice\n+                availableForceIDs.remove(randomForceIndex);\n+\n+                // we want to remove the actual int with the value, not the value at the index\n+                sortedAvailableForceIDs.get(MapLocation.AllGroundTerrain).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.LowAtmosphere).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.Space).remove((Integer) randomForceID);\n+\n+                // two scenarios on the same coordinates wind up increasing in size\n+                if (track.getScenarios().containsKey(scenarioCoords)) {\n+                    track.getScenarios().get(scenarioCoords).incrementRequiredPlayerLances();\n+                    assignAppropriateExtraForceToScenario(track.getScenarios().get(scenarioCoords), sortedAvailableForceIDs);\n+                    continue;\n+                }\n+\n+                StratconScenario scenario = setupScenario(scenarioCoords, randomForceID, campaign, contract, track);\n+                generatedScenarios.add(scenario);\n+\n+                // if we're auto-assigning lances, deploy the force to the track as well\n+                if (autoAssignLances) {\n+                    processForceDeployment(scenarioCoords, randomForceID, campaign, track, false);\n+                }\n+            }\n+        }\n+\n+        // if under liaison command, pick a random scenario from the ones generated\n+        // to set as required and attach liaison\n+        if (contract.getCommandRights() == AtBContract.COM_LIAISON) {\n+        \tStratconScenario randomScenario = Utilities.getRandomItem(generatedScenarios);\n+        \trandomScenario.setRequiredScenario(true);\n+            setAttachedUnitsModifier(randomScenario, contract);\n+        }\n+\n+        // now, we loop through all the scenarios we set up\n+        // and generate the opfors / events / etc\n+        // if not auto-assigning lances, we then back out the lance assignments.\n+        for (StratconScenario scenario : generatedScenarios) {\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+\n+            if(!autoAssignLances && !scenario.ignoreForceAutoAssignment()) {\n+                for(int forceID : scenario.getPlayerTemplateForceIDs()) {\n+                    scenario.getBackingScenario().removeForce(forceID);\n+                }\n+\n+                scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                track.addScenario(scenario);\n+            } else {\n+                commitPrimaryForces(campaign, scenario, track);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Given a set of force IDs and coordinates, generate a scenario\n+     * Useful for when we want to generate scenarios \n+     * for forces already deployed to a track\n+     */\n+    public static StratconScenario generateScenarioForExistingForces(StratconCoords scenarioCoords, \n+            Set<Integer> forceIDs, AtBContract contract, Campaign campaign, StratconTrackState track) {\n+        boolean firstForce = true;\n+        StratconScenario scenario = null;\n+        \n+        for (int forceID : forceIDs) {\n+            if (firstForce) {\n+                scenario = setupScenario(scenarioCoords, forceID, campaign, contract, track);\n+                firstForce = false;\n+            } else {\n+                scenario.incrementRequiredPlayerLances();\n+                scenario.addPrimaryForce(forceID);\n+            }\n+        }\n+        \n+        // this is theoretically possible if forceIDs is passed in as null - not likely in practice\n+        // but might as well, to future-proof.\n+        if (scenario != null) {\n+            scenario.setIgnoreForceAutoAssignment(true);\n+        }\n+        \n+        return scenario;\n+    }\n+\n+    /**\n+     * Deploys a force to the given coordinates on the given track as a result of explicit player action.\n+     */\n+    public static void deployForceToCoords(StratconCoords coords, int forceID, \n+            Campaign campaign, AtBContract contract, StratconTrackState track, boolean sticky) {\n+        // the following things should happen:\n+        // 1. call to \"process force deployment\", which reveals fog of war in or around the coords, depending on force role\n+        // 2. if coords are a hostile facility, we get a facility mission\n+        // 3. if coords are empty, we *may* get a mission\n+\n+        processForceDeployment(coords, forceID, campaign, track, sticky);\n+\n+        // don't create a scenario on top of allied facilities\n+        StratconFacility facility = track.getFacility(coords);\n+        boolean isNonAlliedFacility = (facility != null) && (facility.getOwner() != ForceAlignment.Allied);\n+        int targetNum = calculateScenarioOdds(track, contract, true);\n+        boolean spawnScenario = (facility == null) && (Compute.randomInt(100) <= targetNum);\n+\n+        if (isNonAlliedFacility || spawnScenario) {\n+            StratconScenario scenario = setupScenario(coords, forceID, campaign, contract, track);\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            commitPrimaryForces(campaign, scenario, track);\n+        }\n+    }\n+\n+    /**\n+     * Logic to set up a scenario\n+     */\n+    private static StratconScenario setupScenario(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        StratconScenario scenario = null;\n+\n+        if (track.getFacilities().containsKey(coords)) {\n+            StratconFacility facility = track.getFacility(coords);\n+            boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+            ScenarioTemplate template = StratconScenarioFactory.getFacilityScenario(alliedFacility);\n+            scenario = generateScenario(campaign, contract, track, forceID, coords, template);\n+            setupFacilityScenario(scenario, facility);\n+        } else {\n+            scenario = generateScenario(campaign, contract, track, forceID, coords);\n+\n+            // we may generate a facility scenario randomly - if so, do the facility-related stuff\n+            // and add a new facility to the track\n+            if (scenario.getBackingScenario().getTemplate().isFacilityScenario()) {\n+                StratconFacility facility = scenario.getBackingScenario().getTemplate().isHostileFacility() ?\n+                        StratconFacilityFactory.getRandomHostileFacility() : StratconFacilityFactory.getRandomAlliedFacility();\n+                facility.setVisible(true);\n+                track.addFacility(coords, facility);\n+                setupFacilityScenario(scenario, facility);\n+            }\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * carries out tasks relevant to facility scenarios\n+     */\n+    private static void setupFacilityScenario(StratconScenario scenario, StratconFacility facility) {\n+        // this includes:\n+        // for hostile facilities\n+        // - add a destroy objective (always the option to level the facility)\n+        // - add a capture objective (always the option to capture the facility)\n+        // - if so indicated by parameter, roll a random hostile facility objective and add it if not capture/destroy\n+        // for allied facilities\n+        // - add a defend objective (always the option to defend the facility)\n+        // - if so indicated by parameter, roll a random allied facility objective and add it if not defend\n+        AtBScenarioModifier objectiveModifier = null;\n+        boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+\n+        if (alliedFacility) {\n+            objectiveModifier = AtBScenarioModifier.getRandomAlliedFacilityModifier();\n+        } else {\n+            objectiveModifier = AtBScenarioModifier.getRandomHostileFacilityModifier();\n+        }\n+\n+        if (objectiveModifier != null) {\n+            scenario.getBackingScenario().addScenarioModifier(objectiveModifier);\n+            scenario.getBackingScenario().setName(String.format(\"%s - %s - %s\",\n+                    facility.getFacilityType(), alliedFacility ? \"Allied\" : \"Hostile\", objectiveModifier.getModifierName()));\n+        }\n+\n+        // add the \"fixed\" hostile facility modifiers after the primary ones\n+        if (!alliedFacility) {\n+            for(AtBScenarioModifier modifier : AtBScenarioModifier.getRequiredHostileFacilityModifiers()) {\n+                if(!scenario.getBackingScenario().alreadyHasModifier(modifier)) {\n+                    scenario.getBackingScenario().addScenarioModifier(modifier);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void processFacilityEffects(StratconTrackState track) {\n+        // TODO: these are \"weekly\"? effects that a stratcon facility has on the campaign/track state\n+        // currrently, that's\n+        // supply depot - allied - +1 sp\n+        // supply depot - hostile - +5% BV budget to all scenarios on track (shared modifier, so should be implemented there)\n+        // data center - allied - +1% star league cache contract (don't implement yet, but...)\n+        // data center - hostile - +5% scenario odds in track\n+        // industrial center - allied - all scenarios here have THIS IS COMING OUT OF YOUR PAYCHECK modifier\n+        // orbital defense - allied - sets 'no hostile aircraft' flag for track\n+        // orbital defense - hostile - sets 'no allied aircraft' flag for track\n+        // early warning system - allied - sets 'intercept allied base attacks' flag for track\n+        // early warning system - hostile - sets 'intercept hostile base attacks' flag for track\n+    }\n+\n+    /**\n+     * Process the deployment of a force to the given coordinates on the given track.\n+     */\n+    public static void processForceDeployment(StratconCoords coords, int forceID, \n+            Campaign campaign, StratconTrackState track, boolean sticky) {\n+        track.getRevealedCoords().add(coords);\n+        StratconFacility facility = track.getFacility(coords);\n+        if (facility != null) {\n+            facility.setVisible(true);\n+        }\n+\n+        if (campaign.getLances().get(forceID).getRole() == AtBLanceRole.SCOUTING) {\n+            for(int direction = 0; direction < 6; direction++) {\n+                StratconCoords checkCoords = coords.translate(direction);\n+\n+                facility = track.getFacility(checkCoords);\n+                if(facility != null) {\n+                    facility.setVisible(true);\n+                }\n+\n+                track.getRevealedCoords().add(coords.translate(direction));\n+            }\n+        }\n+\n+        // the force may be located in other places on the track - clear it out\n+        track.unassignForce(forceID);\n+        track.assignForce(forceID, coords, campaign.getLocalDate(), sticky);\n+        MekHQ.triggerEvent(new StratconDeploymentEvent(campaign.getForce(forceID)));\n+    }\n+\n+    /**\n+     * Worker function that processes the effects of deploying a reinforcement force to a scenario\n+     */\n+    public static boolean processReinforcementDeployment(ReinforcementEligibilityType reinforcementType,\n+            StratconCampaignState campaignState, StratconScenario scenario, Campaign campaign) {\n+        // if the force is already deployed to the track, we're done\n+        // if the force is a fight lance or we're using a support point\n+        // if there is an SP to burn, burn it and we're done\n+        // if there is a VP to burn, burn it and we're done\n+        // now, roll 2d6 + lance commander tactics\n+        // 9+ = deploy\n+        // 6+ = deploy, apply negative modifier to scenario\n+        // 2+ = fail to deploy, apply negative modifier to scenario; if fight lance, treat as 6+\n+\n+        if ((reinforcementType == ReinforcementEligibilityType.FightLance) ||\n+                (reinforcementType == ReinforcementEligibilityType.SupportPoint)) {\n+\n+            if (campaignState.getSupportPoints() > 0) {\n+                campaignState.useSupportPoint();\n+                return true;\n+            } else if (campaignState.getVictoryPoints() > 0) {\n+                campaignState.updateVictoryPoints(-1);\n+                return true;\n+            }\n+\n+            int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+            int roll = Compute.d6(2);\n+            int result = roll + tactics;\n+\n+            StringBuilder reportStatus = new StringBuilder();\n+            reportStatus.append(String.format(\"Attempting to reinforce scenario %s without SP/VP, roll 2d6 + %d: %d\",\n+                    scenario.getName(), tactics, result));\n+\n+            // fail to reinforce\n+            if ((result < 6) && (reinforcementType != ReinforcementEligibilityType.FightLance)) {\n+                reportStatus.append(\" - reinforcement attempt failed.\");\n+                campaign.addReport(reportStatus.toString());\n+                return false;\n+            // succeed but get an extra negative event added to the scenario\n+            } else if (result < 9) {\n+                MapLocation mapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+                AtBScenarioModifier scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+\n+                // keep rolling until we get an applicable one\n+                // TODO: have the AtBScenarioModifier sort these out instead for performance?\n+                while (scenarioModifier.getEventTiming() != EventTiming.PostForceGeneration) {\n+                    scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+                }\n+\n+                scenarioModifier.processModifier(scenario.getBackingScenario(), campaign, EventTiming.PostForceGeneration);\n+\n+                reportStatus.append(String.format(\" - reinforcement attempt succeeded; extra negative modifier (%s) applied to scenario.\",\n+                        scenarioModifier.getModifierName()));\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            // succeed without reservation\n+            } else {\n+                reportStatus.append(\" - reinforcement attempt succeeded;\");\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            }\n+        } else if (reinforcementType == ReinforcementEligibilityType.None) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Assigns a force to the scenario such that the majority of the force can be deployed\n+     */\n+    private static void assignAppropriateExtraForceToScenario(StratconScenario scenario,\n+            Map<MapLocation, List<Integer>> sortedAvailableForceIDs) {\n+        // the goal of this function is to avoid assigning ground units to air battles\n+        // and ground units/conventional fighters to space battle\n+\n+        List<MapLocation> mapLocations = new ArrayList<>();\n+        mapLocations.add(MapLocation.Space); // can always add ASFs\n+\n+        MapLocation scenarioMapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+\n+        if (scenarioMapLocation == MapLocation.LowAtmosphere) {\n+            mapLocations.add(MapLocation.LowAtmosphere); // can add conventional fighters to ground or low atmo battles\n+        }\n+\n+        if ((scenarioMapLocation == MapLocation.AllGroundTerrain) ||\n+                (scenarioMapLocation == MapLocation.SpecificGroundTerrain)) {\n+            mapLocations.add(MapLocation.AllGroundTerrain); // can only add ground units to ground battles\n+        }\n+\n+        MapLocation selectedLocation = mapLocations.get(Compute.randomInt(mapLocations.size()));\n+        List<Integer> forceIDs = sortedAvailableForceIDs.get(selectedLocation);\n+        int forceIndex = Compute.randomInt(forceIDs.size());\n+        int forceID = forceIDs.get(forceIndex);\n+        forceIDs.remove(forceIndex);\n+\n+        scenario.addPrimaryForce(forceID);\n+    }\n+\n+    /**\n+     * Worker function that \"locks in\" a scenario -\n+     * Adds it to the campaign so it's visible in the briefing room,\n+     * adds it to the track\n+     *\n+     */\n+    public static void commitPrimaryForces(Campaign campaign, StratconScenario scenario, StratconTrackState trackState) {\n+        trackState.addScenario(scenario);\n+\n+        // set up dates for the scenario if doesn't have them already\n+        if (scenario.getDeploymentDate() == null) {\n+            scenario.setDeploymentDate(campaign.getLocalDate());\n+        }\n+\n+        if (scenario.getActionDate() == null) {\n+            scenario.setActionDate(campaign.getLocalDate());\n+        }\n+\n+        if(scenario.getReturnDate() == null) {\n+            scenario.setReturnDate(campaign.getLocalDate().plusDays(trackState.getDeploymentTime()));\n+        }\n+\n+        // set the # of rerolls based on the actual lance assigned.\n+        int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+        scenario.getBackingScenario().setRerolls(tactics);\n+        // The number of defensive points available to a force entering a scenario is\n+        // 2 x tactics. By default, those points are spent on conventional minefields.\n+        if (commanderLanceHasDefensiveAssignment(scenario.getBackingScenario(), campaign)) {\n+            scenario.setNumDefensivePoints(tactics * 2);\n+            scenario.updateMinefieldCount(Minefield.TYPE_CONVENTIONAL, tactics * 2);\n+        }\n+\n+        for (int forceID : scenario.getPlayerTemplateForceIDs()) {\n+            Force force = campaign.getForce(forceID);\n+            force.clearScenarioIds(campaign, true);\n+            force.setScenarioId(scenario.getBackingScenarioID());\n+        }\n+\n+        scenario.commitPrimaryForces();\n+    }\n+\n+    /**\n+     * Utility method to determine if the current scenario's force commander\n+     * is on defence\n+     */\n+    private static boolean commanderLanceHasDefensiveAssignment(AtBDynamicScenario scenario, Campaign campaign) {\n+        Unit commanderUnit = scenario.getLanceCommander(campaign).getUnit();\n+        Lance lance = campaign.getLances().get(commanderUnit.getForceId());\n+\n+        if ((lance != null) && (lance.getRole() == AtBLanceRole.DEFENCE)) {\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * A hackish worker function that takes the given list of force IDs and\n+     * separates it into three sets;\n+     * one of forces that can be \"primary\" on a ground map\n+     * one of forces that can be \"primary\" on an atmospheric map\n+     * one of forces that can be \"primary\" in a space map\n+     * @param forceIDs List of force IDs to check\n+     * @return Sorted hash map\n+     */\n+    private static Map<MapLocation, List<Integer>> sortForcesByMapType(List<Integer> forceIDs, Campaign campaign) {\n+        Map<MapLocation, List<Integer>> retVal = new HashMap<>();\n+\n+        retVal.put(MapLocation.AllGroundTerrain, new ArrayList<>());\n+        retVal.put(MapLocation.LowAtmosphere, new ArrayList<>());\n+        retVal.put(MapLocation.Space, new ArrayList<>());\n+\n+        for (int forceID : forceIDs) {\n+            switch(campaign.getForce(forceID).getPrimaryUnitType(campaign)) {\n+            case UnitType.BATTLE_ARMOR:\n+            case UnitType.INFANTRY:\n+            case UnitType.MEK:\n+            case UnitType.TANK:\n+            case UnitType.PROTOMEK:\n+            case UnitType.VTOL:\n+                retVal.get(MapLocation.AllGroundTerrain).add(forceID);\n+                break;\n+            case UnitType.AERO:\n+                retVal.get(MapLocation.Space).add(forceID);\n+                // intentional fallthrough here, ASFs can go to atmospheric maps too\n+            case UnitType.CONV_FIGHTER:\n+                retVal.get(MapLocation.LowAtmosphere).add(forceID);\n+                break;\n+            }\n+        }\n+\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * Determine whether the user should be nagged about unresolved scenarios on AtB Stratcon tracks.\n+     * @param campaign Campaign to check.\n+     * @return An informative string containing the reasons the user was nagged.\n+     */\n+    public static String nagUnresolvedContacts(Campaign campaign) {\n+        StringBuilder sb = new StringBuilder();\n+\n+        // check every track attached to an active contract for unresolved scenarios\n+        // to which the player must deploy forces today\n+        for (AtBContract contract : campaign.getActiveAtBContracts()) {\n+            if (contract.getStratconCampaignState() == null) {\n+                continue;\n+            }\n+            \n+            for (StratconTrackState track : contract.getStratconCampaignState().getTracks()) {\n+                for (StratconScenario scenario : track.getScenarios().values()) {\n+                    if (scenario.getCurrentState() == ScenarioState.UNRESOLVED &&\n+                            campaign.getLocalDate().equals(scenario.getDeploymentDate())) {\n+                        // \"scenario name, track name\"\n+                        sb.append(String.format(\"%s, %s\\n\", scenario.getName(), track.getDisplayableName()));\n+                    }\n+                }\n+            }\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track.\n+     * Also registers it with the track and campaign.\n+     */\n+    private static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords) {\n+        int unitType = campaign.getForce(forceID).getPrimaryUnitType(campaign);\n+        ScenarioTemplate template = StratconScenarioFactory.getRandomScenario(unitType);\n+        // useful for debugging specific scenario types\n+        //ScenarioTemplate template = StratconScenarioFactory.getSpecificScenario(\"Hostile Facility.xml\");\n+\n+        return generateScenario(campaign, contract, track, forceID, coords, template);\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track,\n+     * using the given template. Also registers it with the campaign.\n+     */\n+    static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords, ScenarioTemplate template) {\n+        StratconScenario scenario = new StratconScenario();\n+        \n+        AtBDynamicScenario backingScenario = AtBDynamicScenarioFactory.initializeScenarioFromTemplate(template, contract, campaign);        \n+        scenario.setBackingScenario(backingScenario);\n+        scenario.setCoords(coords);\n+        \n+        // by default, certain conditions may make this bigger\n+        scenario.setRequiredPlayerLances(1);\n+\n+        // do an appropriate allied force if the contract calls for it\n+        // do any attached or integrated units\n+        setAlliedForceModifier(scenario, contract);\n+        setAttachedUnitsModifier(scenario, contract);\n+        applyFacilityModifiers(scenario, track, coords);\n+        applyGlobalModifiers(scenario, contract.getStratconCampaignState());\n+\n+        if ((contract.getCommandRights() == AtBContract.COM_HOUSE) ||\n+                (contract.getCommandRights() == AtBContract.COM_INTEGRATED)) {\n+            scenario.setRequiredScenario(true);\n+        }\n+\n+        AtBDynamicScenarioFactory.setScenarioModifiers(scenario.getBackingScenario());\n+        scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+        setScenarioDates(track, campaign, scenario);\n+        \n+        // the backing scenario ID must be updated after registering the backing scenario \n+        // with the campaign, so that the stratcon - backing scenario association is maintained\n+        // registering the scenario with the campaign should be done after setting\n+        // dates, otherwise, the report messages for new scenarios look weird\n+        campaign.addScenario(backingScenario, contract);\n+        scenario.setBackingScenarioID(backingScenario.getId());\n+        \n+        if (forceID > Force.FORCE_NONE) {\n+            scenario.addPrimaryForce(forceID);\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * Apply global scenario modifiers from campaign state to given scenario.\n+     */\n+    private static void applyGlobalModifiers(StratconScenario scenario, StratconCampaignState campaignState) {\n+        for (String modifierName : campaignState.getGlobalScenarioModifiers()) {\n+            AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierName);\n+\n+            if (modifier == null) {\n+                MekHQ.getLogger().error(String.format(\"Modifier %s not found; ignoring\", modifierName));\n+                continue;\n+            }\n+\n+            scenario.getBackingScenario().addScenarioModifier(modifier);\n+        }\n+    }\n+\n+    /**\n+     * Applies scenario modifiers from the current track to the given scenario.\n+     * @param scenario\n+     * @param track\n+     */\n+    private static void applyFacilityModifiers(StratconScenario scenario, StratconTrackState track, StratconCoords coords) {\n+        // loop through all the facilities on the track\n+        // if a facility has been revealed, then it has a 100% chance to apply its effect\n+        // if a facility has not been revealed, then it has a x% chance to apply its effect\n+        // if a facility is on the the scenario coordinates the it applies the local effects\n+        for (StratconCoords facilityCoords : track.getFacilities().keySet()) {\n+            boolean scenarioAtFacility = facilityCoords.equals(coords);\n+            StratconFacility facility = track.getFacilities().get(facilityCoords);\n+            List<String> modifierIDs = new ArrayList<>();\n+\n+            if (scenarioAtFacility) {\n+                modifierIDs = facility.getLocalModifiers();\n+            } else if (facility.isVisible() || (Compute.randomInt(100) <= facility.getAggroRating())) {\n+                modifierIDs = facility.getSharedModifiers();\n+            }\n+\n+            for (String modifierID : modifierIDs) {\n+                AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierID);\n+                if(modifier == null) {\n+                    MekHQ.getLogger().error(String.format(\"Modifier %s not found for facility %s\", modifierID, facility.getFormattedDisplayableName()));\n+                    continue;\n+                }\n+\n+                scenario.getBackingScenario().addScenarioModifier(modifier);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set up the appropriate primary allied force modifier, if any\n+     * @param contract The scenario's contract.\n+     */\n+    private static void setAlliedForceModifier(StratconScenario scenario, AtBContract contract) {\n+        int alliedUnitOdds = 0;\n+\n+        // first, we determine the odds of having an allied unit present\n+        // TODO: move this override out to the contract definition\n+        if (contract.getMissionType() == AtBContract.MT_RELIEFDUTY) {\n+            alliedUnitOdds = 50;\n+        } else {\n+            switch(contract.getCommandRights()) {\n+                case AtBContract.COM_INTEGRATED:\n+                    alliedUnitOdds = 50;\n+                    break;\n+                case AtBContract.COM_HOUSE:\n+                    alliedUnitOdds = 30;\n+                    break;\n+                case AtBContract.COM_LIAISON:\n+                    alliedUnitOdds = 10;\n+                    break;\n+            }\n+        }\n+\n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+\n+        // if an allied unit is present, then we want to make sure that it's ground units\n+        // for ground battles\n+        if (Compute.randomInt(100) <= alliedUnitOdds) {\n+            if((backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+               (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space)) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_ALLIED_AIR_UNITS));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_ALLIED_GROUND_UNITS));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set the 'attached' units modifier for the current scenario (integrated, house, liaison),\n+     * and make sure we're not deploying ground units to an air scenario\n+     * @param contract The scenario's contract\n+     */\n+    public static void setAttachedUnitsModifier(StratconScenario scenario, AtBContract contract) {\n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+        boolean airBattle = (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+                (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space);\n+\n+        // if we're on cadre duty, we're getting three trainees, period\n+        if (contract.getMissionType() == AtBContract.MT_CADREDUTY) {\n+            if (airBattle) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_TRAINEES_AIR));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_TRAINEES_GROUND));\n+            }\n+            return;\n+        }\n+\n+        // if we're under non-independent command rights, a supervisor may come along\n+        switch (contract.getCommandRights()) {\n+            case AtBContract.COM_INTEGRATED:\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(airBattle \n+                        ? MekHqConstants.SCENARIO_MODIFIER_INTEGRATED_UNITS_AIR\n+                        : MekHqConstants.SCENARIO_MODIFIER_INTEGRATED_UNITS_GROUND));\n+                break;\n+            case AtBContract.COM_HOUSE:\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(airBattle \n+                        ? MekHqConstants.SCENARIO_MODIFIER_HOUSE_CO_AIR\n+                        : MekHqConstants.SCENARIO_MODIFIER_HOUSE_CO_GROUND));\n+                break;\n+            case AtBContract.COM_LIAISON:\n+                if (scenario.isRequiredScenario()) {\n+                    backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(airBattle \n+                            ? MekHqConstants.SCENARIO_MODIFIER_LIAISON_AIR\n+                            : MekHqConstants.SCENARIO_MODIFIER_LIAISON_GROUND));\n+                }\n+                break;\n+        }\n+    }\n+\n+    /**\n+     * Worker function that sets scenario deploy/battle/return dates based on the track's properties and current campaign date\n+     */\n+    private static void setScenarioDates(StratconTrackState track, Campaign campaign, StratconScenario scenario) {\n+     // set up deployment day, battle day, return day here\n+        // safety code to prevent attempts to generate random int with upper bound of 0 which is apparently illegal\n+        int deploymentDay = track.getDeploymentTime() < 7 ? Compute.randomInt(7 - track.getDeploymentTime()) : 0;\n+        int battleDay = deploymentDay + (track.getDeploymentTime() > 0 ? Compute.randomInt(track.getDeploymentTime()) : 0);\n+        int returnDay = deploymentDay + track.getDeploymentTime();\n+\n+        LocalDate deploymentDate = campaign.getLocalDate();\n+        deploymentDate.plusDays(deploymentDay);\n+        LocalDate battleDate = campaign.getLocalDate();\n+        deploymentDate.plusDays(battleDay);\n+        LocalDate returnDate = campaign.getLocalDate();\n+        returnDate.plusDays(returnDay);\n+\n+        scenario.setDeploymentDate(deploymentDate);\n+        scenario.setActionDate(battleDate);\n+        scenario.setReturnDate(returnDate);\n+    }\n+\n+    /**\n+     * Helper function that determines if the unit type specified in the given scenario force template\n+     * would start out airborne on a ground map (hot dropped units aside)\n+     */\n+    private static boolean unitTypeIsAirborne(ScenarioForceTemplate template) {\n+        int unitType = template.getAllowedUnitType();\n+\n+        return (unitType == UnitType.AERO ||\n+                unitType == UnitType.CONV_FIGHTER ||\n+                unitType == UnitType.DROPSHIP ||\n+                unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_MIX) &&\n+                template.getStartingAltitude() > 0;\n+    }\n+\n+    /**\n+     * Determines whether the force in question has the same primary unit type as the force template.\n+     * @return Whether or not the unit types match.\n+     */\n+    public static boolean forceCompositionMatchesDeclaredUnitType(int primaryUnitType, int unitType, boolean reinforcements) {\n+        // special cases are \"ATB_MIX\" and \"ATB_AERO_MIX\", which encompass multiple unit types\n+        if (unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_MIX) {\n+            // \"AtB mix\" is usually ground units, but air units can sub in\n+            return primaryUnitType == UnitType.MEK ||\n+                    primaryUnitType == UnitType.TANK ||\n+                    primaryUnitType == UnitType.INFANTRY ||\n+                    primaryUnitType == UnitType.BATTLE_ARMOR ||\n+                    primaryUnitType == UnitType.PROTOMEK ||\n+                    primaryUnitType == UnitType.VTOL ||\n+                    (primaryUnitType == UnitType.AERO) && reinforcements ||\n+                    (primaryUnitType == UnitType.CONV_FIGHTER) && reinforcements;\n+        } else if (unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_AERO_MIX) {\n+            return primaryUnitType == UnitType.AERO ||\n+                    primaryUnitType == UnitType.CONV_FIGHTER;\n+        } else {\n+            return primaryUnitType == unitType;\n+        }\n+    }\n+\n+    /**\n+     * This is a set of all force IDs for forces that can be deployed to a scenario.\n+     * @param campaign Current campaign\n+     * @return Set of available force IDs.\n+     */\n+    public static List<Integer> getAvailableForceIDs(Campaign campaign) {\n+        List<Integer> retVal = new ArrayList<>();\n+\n+        // first, we gather a set of all forces that are already deployed to a track so we eliminate those later\n+        Set<Integer> forcesInTracks = new HashSet<>();\n+        for (Contract contract : campaign.getActiveContracts()) {\n+            if (contract instanceof AtBContract) {\n+                for (StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    forcesInTracks.addAll(track.getAssignedForceCoords().keySet());\n+                }\n+            }\n+        }\n+\n+        // now, we get all the forces that qualify as \"lances\", and filter out those that are\n+        // deployed to a scenario and not in a track already\n+        for (int key : campaign.getLances().keySet()) {\n+            Force force = campaign.getForce(key);\n+            if ((force != null) &&\n+                    !force.isDeployed() &&\n+                    !forcesInTracks.contains(force.getId())) {\n+                retVal.add(force.getId());\n+            }\n+        }\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * This is a list of all force IDs for forces that can be deployed to a scenario in the given force template\n+     * a) have not been assigned to a track\n+     * b) are combat-capable\n+     * c) are not deployed to a scenario\n+     * d) if attempting to deploy as reinforcements, haven't already failed to deploy\n+     */\n+    public static List<Integer> getAvailableForceIDs(int unitType, Campaign campaign, StratconTrackState currentTrack,\n+            boolean reinforcements, @Nullable StratconScenario currentScenario) {\n+        List<Integer> retVal = new ArrayList<>();\n+\n+        Set<Integer> forcesInTracks = new HashSet<>();\n+        // assemble a set of all force IDs that are currently assigned to tracks that are not this one\n+        for (Contract contract : campaign.getActiveContracts()) {\n+            if (contract instanceof AtBContract) {\n+                for (StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    if ((track != currentTrack) || !reinforcements) {\n+                        forcesInTracks.addAll(track.getAssignedForceCoords().keySet());\n+                    }\n+                }\n+            }\n+        }\n+        \n+        // if there's an existing scenario and we're doing reinforcements,\n+        // prevent forces that failed to deploy from trying to deploy again\n+        if (reinforcements && (currentScenario != null)) {\n+            forcesInTracks.addAll(currentScenario.getFailedReinforcements());\n+        }\n+\n+        for (int key : campaign.getLances().keySet()) {\n+            Force force = campaign.getForce(key);\n+\n+            if (force == null) {\n+                continue;\n+            }\n+\n+            int primaryUnitType = force.getPrimaryUnitType(campaign);\n+            if (!force.isDeployed() &&\n+                    (force.getScenarioId() <= 0) &&\n+                    !force.getUnits().isEmpty() &&\n+                    !forcesInTracks.contains(force.getId()) &&\n+                    forceCompositionMatchesDeclaredUnitType(primaryUnitType, unitType, reinforcements)) {\n+                retVal.add(force.getId());\n+            }\n+        }\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * Returns a list of individual units eligible for deployment in scenarios run by \"Defend\" lances\n+     * @return List of unit IDs.\n+     */\n+    public static List<Unit> getEligibleDefensiveUnits(Campaign campaign) {\n+        List<Unit> retVal = new ArrayList<>();\n+\n+        for (Unit u : campaign.getUnits()) {\n+            // \"defensive\" units are infantry, battle armor and (Weisman help you) gun emplacements\n+        \t// and also said unit should be intact/alive/etc\n+        \tboolean isEligibleInfantry = \n+        \t\t\t((u.getEntity().getUnitType() == UnitType.INFANTRY) ||\n+                    (u.getEntity().getUnitType() == UnitType.BATTLE_ARMOR)) &&\n+                    !u.isUnmanned();", "originalCommit": "b36d9fa6bf982c7b833b1ac0a0473d37f6e84760", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTE5MjQwNA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r615192404", "bodyText": "Odd formatting", "author": "Windchild292", "createdAt": "2021-04-17T02:09:59Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1404 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.UUID;\n+\n+import megamek.common.Compute;\n+import megamek.common.Minefield;\n+import megamek.common.UnitType;\n+import megamek.common.annotations.Nullable;\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.Utilities;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.ResolveScenarioTracker;\n+import mekhq.campaign.againstTheBot.enums.AtBLanceRole;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.event.StratconDeploymentEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.force.Lance;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier.EventTiming;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconFacility.FacilityType;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.unit.Unit;\n+\n+/**\n+ * This class contains \"rules\" logic for the AtB-Stratcon state\n+ * @author NickAragua\n+ */\n+public class StratconRulesManager {\n+    /**\n+     * What makes a particular lance eligible to be reinforcements for a scenario\n+     */\n+    public enum ReinforcementEligibilityType {\n+        /**\n+         * Nothing\n+         */\n+        None,\n+\n+        /**\n+         * Lance is already deployed to the track\n+         */\n+        ChainedScenario,\n+\n+        /**\n+         * We pay a support point or convert a victory point to a support point\n+         */\n+        SupportPoint,\n+\n+        /**\n+         * The lance's deployment orders are \"Fight\"\n+         */\n+        FightLance\n+    }\n+\n+    /**\n+     * This function potentially generates non-player-initiated scenarios for the given track.\n+     */\n+    public static void generateScenariosForTrack(Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // maps scenarios to force IDs\n+        List<StratconScenario> generatedScenarios = new ArrayList<>();\n+        boolean autoAssignLances = contract.getCommandRights() == AtBContract.COM_INTEGRATED;\n+\n+        // get this list just so we have it available\n+        List<Integer> availableForceIDs = getAvailableForceIDs(campaign);\n+        Map<MapLocation, List<Integer>> sortedAvailableForceIDs = sortForcesByMapType(availableForceIDs, campaign);\n+\n+        // make X rolls, where X is the number of required lances for the track\n+        // that's the chance to spawn a scenario.\n+        // if a scenario occurs, then we pick a random non-deployed lance and use it to drive the opfor generation later\n+        // once we've determined that scenarios occur, we loop through the ones that we generated\n+        // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all\n+        for (int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            int targetNum = calculateScenarioOdds(track, contract, false);\n+            \n+            // if we haven't already used all the player forces and are required to randomly generate a scenario\n+            if (!availableForceIDs.isEmpty() && (Compute.randomInt(100) <= targetNum)) {\n+                // pick random coordinates and force to drive the scenario\n+                int x = Compute.randomInt(track.getWidth());\n+                int y = Compute.randomInt(track.getHeight());\n+\n+                StratconCoords scenarioCoords = new StratconCoords(x, y);\n+\n+                // if forces are already assigned to these coordinates, use those instead\n+                // of randomly-selected ones\n+                if (track.getAssignedCoordForces().containsKey(scenarioCoords)) {\n+                    StratconScenario scenario = generateScenarioForExistingForces(scenarioCoords,\n+                            track.getAssignedCoordForces().get(scenarioCoords), \n+                            contract, campaign, track);\n+                    generatedScenarios.add(scenario);\n+                    continue;\n+                }\n+                \n+                // otherwise, pick a random force from the avail\n+                int randomForceIndex = Compute.randomInt(availableForceIDs.size());\n+                int randomForceID = availableForceIDs.get(randomForceIndex);\n+                \n+                // remove the force from the available lists so we don't designate it as primary twice\n+                availableForceIDs.remove(randomForceIndex);\n+\n+                // we want to remove the actual int with the value, not the value at the index\n+                sortedAvailableForceIDs.get(MapLocation.AllGroundTerrain).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.LowAtmosphere).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.Space).remove((Integer) randomForceID);\n+\n+                // two scenarios on the same coordinates wind up increasing in size\n+                if (track.getScenarios().containsKey(scenarioCoords)) {\n+                    track.getScenarios().get(scenarioCoords).incrementRequiredPlayerLances();\n+                    assignAppropriateExtraForceToScenario(track.getScenarios().get(scenarioCoords), sortedAvailableForceIDs);\n+                    continue;\n+                }\n+\n+                StratconScenario scenario = setupScenario(scenarioCoords, randomForceID, campaign, contract, track);\n+                generatedScenarios.add(scenario);\n+\n+                // if we're auto-assigning lances, deploy the force to the track as well\n+                if (autoAssignLances) {\n+                    processForceDeployment(scenarioCoords, randomForceID, campaign, track, false);\n+                }\n+            }\n+        }\n+\n+        // if under liaison command, pick a random scenario from the ones generated\n+        // to set as required and attach liaison\n+        if (contract.getCommandRights() == AtBContract.COM_LIAISON) {\n+        \tStratconScenario randomScenario = Utilities.getRandomItem(generatedScenarios);\n+        \trandomScenario.setRequiredScenario(true);\n+            setAttachedUnitsModifier(randomScenario, contract);\n+        }\n+\n+        // now, we loop through all the scenarios we set up\n+        // and generate the opfors / events / etc\n+        // if not auto-assigning lances, we then back out the lance assignments.\n+        for (StratconScenario scenario : generatedScenarios) {\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+\n+            if(!autoAssignLances && !scenario.ignoreForceAutoAssignment()) {\n+                for(int forceID : scenario.getPlayerTemplateForceIDs()) {\n+                    scenario.getBackingScenario().removeForce(forceID);\n+                }\n+\n+                scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                track.addScenario(scenario);\n+            } else {\n+                commitPrimaryForces(campaign, scenario, track);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Given a set of force IDs and coordinates, generate a scenario\n+     * Useful for when we want to generate scenarios \n+     * for forces already deployed to a track\n+     */\n+    public static StratconScenario generateScenarioForExistingForces(StratconCoords scenarioCoords, \n+            Set<Integer> forceIDs, AtBContract contract, Campaign campaign, StratconTrackState track) {\n+        boolean firstForce = true;\n+        StratconScenario scenario = null;\n+        \n+        for (int forceID : forceIDs) {\n+            if (firstForce) {\n+                scenario = setupScenario(scenarioCoords, forceID, campaign, contract, track);\n+                firstForce = false;\n+            } else {\n+                scenario.incrementRequiredPlayerLances();\n+                scenario.addPrimaryForce(forceID);\n+            }\n+        }\n+        \n+        // this is theoretically possible if forceIDs is passed in as null - not likely in practice\n+        // but might as well, to future-proof.\n+        if (scenario != null) {\n+            scenario.setIgnoreForceAutoAssignment(true);\n+        }\n+        \n+        return scenario;\n+    }\n+\n+    /**\n+     * Deploys a force to the given coordinates on the given track as a result of explicit player action.\n+     */\n+    public static void deployForceToCoords(StratconCoords coords, int forceID, \n+            Campaign campaign, AtBContract contract, StratconTrackState track, boolean sticky) {\n+        // the following things should happen:\n+        // 1. call to \"process force deployment\", which reveals fog of war in or around the coords, depending on force role\n+        // 2. if coords are a hostile facility, we get a facility mission\n+        // 3. if coords are empty, we *may* get a mission\n+\n+        processForceDeployment(coords, forceID, campaign, track, sticky);\n+\n+        // don't create a scenario on top of allied facilities\n+        StratconFacility facility = track.getFacility(coords);\n+        boolean isNonAlliedFacility = (facility != null) && (facility.getOwner() != ForceAlignment.Allied);\n+        int targetNum = calculateScenarioOdds(track, contract, true);\n+        boolean spawnScenario = (facility == null) && (Compute.randomInt(100) <= targetNum);\n+\n+        if (isNonAlliedFacility || spawnScenario) {\n+            StratconScenario scenario = setupScenario(coords, forceID, campaign, contract, track);\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            commitPrimaryForces(campaign, scenario, track);\n+        }\n+    }\n+\n+    /**\n+     * Logic to set up a scenario\n+     */\n+    private static StratconScenario setupScenario(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        StratconScenario scenario = null;\n+\n+        if (track.getFacilities().containsKey(coords)) {\n+            StratconFacility facility = track.getFacility(coords);\n+            boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+            ScenarioTemplate template = StratconScenarioFactory.getFacilityScenario(alliedFacility);\n+            scenario = generateScenario(campaign, contract, track, forceID, coords, template);\n+            setupFacilityScenario(scenario, facility);\n+        } else {\n+            scenario = generateScenario(campaign, contract, track, forceID, coords);\n+\n+            // we may generate a facility scenario randomly - if so, do the facility-related stuff\n+            // and add a new facility to the track\n+            if (scenario.getBackingScenario().getTemplate().isFacilityScenario()) {\n+                StratconFacility facility = scenario.getBackingScenario().getTemplate().isHostileFacility() ?\n+                        StratconFacilityFactory.getRandomHostileFacility() : StratconFacilityFactory.getRandomAlliedFacility();\n+                facility.setVisible(true);\n+                track.addFacility(coords, facility);\n+                setupFacilityScenario(scenario, facility);\n+            }\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * carries out tasks relevant to facility scenarios\n+     */\n+    private static void setupFacilityScenario(StratconScenario scenario, StratconFacility facility) {\n+        // this includes:\n+        // for hostile facilities\n+        // - add a destroy objective (always the option to level the facility)\n+        // - add a capture objective (always the option to capture the facility)\n+        // - if so indicated by parameter, roll a random hostile facility objective and add it if not capture/destroy\n+        // for allied facilities\n+        // - add a defend objective (always the option to defend the facility)\n+        // - if so indicated by parameter, roll a random allied facility objective and add it if not defend\n+        AtBScenarioModifier objectiveModifier = null;\n+        boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+\n+        if (alliedFacility) {\n+            objectiveModifier = AtBScenarioModifier.getRandomAlliedFacilityModifier();\n+        } else {\n+            objectiveModifier = AtBScenarioModifier.getRandomHostileFacilityModifier();\n+        }\n+\n+        if (objectiveModifier != null) {\n+            scenario.getBackingScenario().addScenarioModifier(objectiveModifier);\n+            scenario.getBackingScenario().setName(String.format(\"%s - %s - %s\",\n+                    facility.getFacilityType(), alliedFacility ? \"Allied\" : \"Hostile\", objectiveModifier.getModifierName()));\n+        }\n+\n+        // add the \"fixed\" hostile facility modifiers after the primary ones\n+        if (!alliedFacility) {\n+            for(AtBScenarioModifier modifier : AtBScenarioModifier.getRequiredHostileFacilityModifiers()) {\n+                if(!scenario.getBackingScenario().alreadyHasModifier(modifier)) {\n+                    scenario.getBackingScenario().addScenarioModifier(modifier);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void processFacilityEffects(StratconTrackState track) {\n+        // TODO: these are \"weekly\"? effects that a stratcon facility has on the campaign/track state\n+        // currrently, that's\n+        // supply depot - allied - +1 sp\n+        // supply depot - hostile - +5% BV budget to all scenarios on track (shared modifier, so should be implemented there)\n+        // data center - allied - +1% star league cache contract (don't implement yet, but...)\n+        // data center - hostile - +5% scenario odds in track\n+        // industrial center - allied - all scenarios here have THIS IS COMING OUT OF YOUR PAYCHECK modifier\n+        // orbital defense - allied - sets 'no hostile aircraft' flag for track\n+        // orbital defense - hostile - sets 'no allied aircraft' flag for track\n+        // early warning system - allied - sets 'intercept allied base attacks' flag for track\n+        // early warning system - hostile - sets 'intercept hostile base attacks' flag for track\n+    }\n+\n+    /**\n+     * Process the deployment of a force to the given coordinates on the given track.\n+     */\n+    public static void processForceDeployment(StratconCoords coords, int forceID, \n+            Campaign campaign, StratconTrackState track, boolean sticky) {\n+        track.getRevealedCoords().add(coords);\n+        StratconFacility facility = track.getFacility(coords);\n+        if (facility != null) {\n+            facility.setVisible(true);\n+        }\n+\n+        if (campaign.getLances().get(forceID).getRole() == AtBLanceRole.SCOUTING) {\n+            for(int direction = 0; direction < 6; direction++) {\n+                StratconCoords checkCoords = coords.translate(direction);\n+\n+                facility = track.getFacility(checkCoords);\n+                if(facility != null) {\n+                    facility.setVisible(true);\n+                }\n+\n+                track.getRevealedCoords().add(coords.translate(direction));\n+            }\n+        }\n+\n+        // the force may be located in other places on the track - clear it out\n+        track.unassignForce(forceID);\n+        track.assignForce(forceID, coords, campaign.getLocalDate(), sticky);\n+        MekHQ.triggerEvent(new StratconDeploymentEvent(campaign.getForce(forceID)));\n+    }\n+\n+    /**\n+     * Worker function that processes the effects of deploying a reinforcement force to a scenario\n+     */\n+    public static boolean processReinforcementDeployment(ReinforcementEligibilityType reinforcementType,\n+            StratconCampaignState campaignState, StratconScenario scenario, Campaign campaign) {\n+        // if the force is already deployed to the track, we're done\n+        // if the force is a fight lance or we're using a support point\n+        // if there is an SP to burn, burn it and we're done\n+        // if there is a VP to burn, burn it and we're done\n+        // now, roll 2d6 + lance commander tactics\n+        // 9+ = deploy\n+        // 6+ = deploy, apply negative modifier to scenario\n+        // 2+ = fail to deploy, apply negative modifier to scenario; if fight lance, treat as 6+\n+\n+        if ((reinforcementType == ReinforcementEligibilityType.FightLance) ||\n+                (reinforcementType == ReinforcementEligibilityType.SupportPoint)) {\n+\n+            if (campaignState.getSupportPoints() > 0) {\n+                campaignState.useSupportPoint();\n+                return true;\n+            } else if (campaignState.getVictoryPoints() > 0) {\n+                campaignState.updateVictoryPoints(-1);\n+                return true;\n+            }\n+\n+            int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+            int roll = Compute.d6(2);\n+            int result = roll + tactics;\n+\n+            StringBuilder reportStatus = new StringBuilder();\n+            reportStatus.append(String.format(\"Attempting to reinforce scenario %s without SP/VP, roll 2d6 + %d: %d\",\n+                    scenario.getName(), tactics, result));\n+\n+            // fail to reinforce\n+            if ((result < 6) && (reinforcementType != ReinforcementEligibilityType.FightLance)) {\n+                reportStatus.append(\" - reinforcement attempt failed.\");\n+                campaign.addReport(reportStatus.toString());\n+                return false;\n+            // succeed but get an extra negative event added to the scenario\n+            } else if (result < 9) {\n+                MapLocation mapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+                AtBScenarioModifier scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+\n+                // keep rolling until we get an applicable one\n+                // TODO: have the AtBScenarioModifier sort these out instead for performance?\n+                while (scenarioModifier.getEventTiming() != EventTiming.PostForceGeneration) {\n+                    scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+                }\n+\n+                scenarioModifier.processModifier(scenario.getBackingScenario(), campaign, EventTiming.PostForceGeneration);\n+\n+                reportStatus.append(String.format(\" - reinforcement attempt succeeded; extra negative modifier (%s) applied to scenario.\",\n+                        scenarioModifier.getModifierName()));\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            // succeed without reservation\n+            } else {\n+                reportStatus.append(\" - reinforcement attempt succeeded;\");\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            }\n+        } else if (reinforcementType == ReinforcementEligibilityType.None) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Assigns a force to the scenario such that the majority of the force can be deployed\n+     */\n+    private static void assignAppropriateExtraForceToScenario(StratconScenario scenario,\n+            Map<MapLocation, List<Integer>> sortedAvailableForceIDs) {\n+        // the goal of this function is to avoid assigning ground units to air battles\n+        // and ground units/conventional fighters to space battle\n+\n+        List<MapLocation> mapLocations = new ArrayList<>();\n+        mapLocations.add(MapLocation.Space); // can always add ASFs\n+\n+        MapLocation scenarioMapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+\n+        if (scenarioMapLocation == MapLocation.LowAtmosphere) {\n+            mapLocations.add(MapLocation.LowAtmosphere); // can add conventional fighters to ground or low atmo battles\n+        }\n+\n+        if ((scenarioMapLocation == MapLocation.AllGroundTerrain) ||\n+                (scenarioMapLocation == MapLocation.SpecificGroundTerrain)) {\n+            mapLocations.add(MapLocation.AllGroundTerrain); // can only add ground units to ground battles\n+        }\n+\n+        MapLocation selectedLocation = mapLocations.get(Compute.randomInt(mapLocations.size()));\n+        List<Integer> forceIDs = sortedAvailableForceIDs.get(selectedLocation);\n+        int forceIndex = Compute.randomInt(forceIDs.size());\n+        int forceID = forceIDs.get(forceIndex);\n+        forceIDs.remove(forceIndex);\n+\n+        scenario.addPrimaryForce(forceID);\n+    }\n+\n+    /**\n+     * Worker function that \"locks in\" a scenario -\n+     * Adds it to the campaign so it's visible in the briefing room,\n+     * adds it to the track\n+     *\n+     */\n+    public static void commitPrimaryForces(Campaign campaign, StratconScenario scenario, StratconTrackState trackState) {\n+        trackState.addScenario(scenario);\n+\n+        // set up dates for the scenario if doesn't have them already\n+        if (scenario.getDeploymentDate() == null) {\n+            scenario.setDeploymentDate(campaign.getLocalDate());\n+        }\n+\n+        if (scenario.getActionDate() == null) {\n+            scenario.setActionDate(campaign.getLocalDate());\n+        }\n+\n+        if(scenario.getReturnDate() == null) {\n+            scenario.setReturnDate(campaign.getLocalDate().plusDays(trackState.getDeploymentTime()));\n+        }\n+\n+        // set the # of rerolls based on the actual lance assigned.\n+        int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+        scenario.getBackingScenario().setRerolls(tactics);\n+        // The number of defensive points available to a force entering a scenario is\n+        // 2 x tactics. By default, those points are spent on conventional minefields.\n+        if (commanderLanceHasDefensiveAssignment(scenario.getBackingScenario(), campaign)) {\n+            scenario.setNumDefensivePoints(tactics * 2);\n+            scenario.updateMinefieldCount(Minefield.TYPE_CONVENTIONAL, tactics * 2);\n+        }\n+\n+        for (int forceID : scenario.getPlayerTemplateForceIDs()) {\n+            Force force = campaign.getForce(forceID);\n+            force.clearScenarioIds(campaign, true);\n+            force.setScenarioId(scenario.getBackingScenarioID());\n+        }\n+\n+        scenario.commitPrimaryForces();\n+    }\n+\n+    /**\n+     * Utility method to determine if the current scenario's force commander\n+     * is on defence\n+     */\n+    private static boolean commanderLanceHasDefensiveAssignment(AtBDynamicScenario scenario, Campaign campaign) {\n+        Unit commanderUnit = scenario.getLanceCommander(campaign).getUnit();\n+        Lance lance = campaign.getLances().get(commanderUnit.getForceId());\n+\n+        if ((lance != null) && (lance.getRole() == AtBLanceRole.DEFENCE)) {\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * A hackish worker function that takes the given list of force IDs and\n+     * separates it into three sets;\n+     * one of forces that can be \"primary\" on a ground map\n+     * one of forces that can be \"primary\" on an atmospheric map\n+     * one of forces that can be \"primary\" in a space map\n+     * @param forceIDs List of force IDs to check\n+     * @return Sorted hash map\n+     */\n+    private static Map<MapLocation, List<Integer>> sortForcesByMapType(List<Integer> forceIDs, Campaign campaign) {\n+        Map<MapLocation, List<Integer>> retVal = new HashMap<>();\n+\n+        retVal.put(MapLocation.AllGroundTerrain, new ArrayList<>());\n+        retVal.put(MapLocation.LowAtmosphere, new ArrayList<>());\n+        retVal.put(MapLocation.Space, new ArrayList<>());\n+\n+        for (int forceID : forceIDs) {\n+            switch(campaign.getForce(forceID).getPrimaryUnitType(campaign)) {\n+            case UnitType.BATTLE_ARMOR:\n+            case UnitType.INFANTRY:\n+            case UnitType.MEK:\n+            case UnitType.TANK:\n+            case UnitType.PROTOMEK:\n+            case UnitType.VTOL:\n+                retVal.get(MapLocation.AllGroundTerrain).add(forceID);\n+                break;\n+            case UnitType.AERO:\n+                retVal.get(MapLocation.Space).add(forceID);\n+                // intentional fallthrough here, ASFs can go to atmospheric maps too\n+            case UnitType.CONV_FIGHTER:\n+                retVal.get(MapLocation.LowAtmosphere).add(forceID);\n+                break;\n+            }\n+        }\n+\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * Determine whether the user should be nagged about unresolved scenarios on AtB Stratcon tracks.\n+     * @param campaign Campaign to check.\n+     * @return An informative string containing the reasons the user was nagged.\n+     */\n+    public static String nagUnresolvedContacts(Campaign campaign) {\n+        StringBuilder sb = new StringBuilder();\n+\n+        // check every track attached to an active contract for unresolved scenarios\n+        // to which the player must deploy forces today\n+        for (AtBContract contract : campaign.getActiveAtBContracts()) {\n+            if (contract.getStratconCampaignState() == null) {\n+                continue;\n+            }\n+            \n+            for (StratconTrackState track : contract.getStratconCampaignState().getTracks()) {\n+                for (StratconScenario scenario : track.getScenarios().values()) {\n+                    if (scenario.getCurrentState() == ScenarioState.UNRESOLVED &&\n+                            campaign.getLocalDate().equals(scenario.getDeploymentDate())) {\n+                        // \"scenario name, track name\"\n+                        sb.append(String.format(\"%s, %s\\n\", scenario.getName(), track.getDisplayableName()));\n+                    }\n+                }\n+            }\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track.\n+     * Also registers it with the track and campaign.\n+     */\n+    private static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords) {\n+        int unitType = campaign.getForce(forceID).getPrimaryUnitType(campaign);\n+        ScenarioTemplate template = StratconScenarioFactory.getRandomScenario(unitType);\n+        // useful for debugging specific scenario types\n+        //ScenarioTemplate template = StratconScenarioFactory.getSpecificScenario(\"Hostile Facility.xml\");\n+\n+        return generateScenario(campaign, contract, track, forceID, coords, template);\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track,\n+     * using the given template. Also registers it with the campaign.\n+     */\n+    static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords, ScenarioTemplate template) {\n+        StratconScenario scenario = new StratconScenario();\n+        \n+        AtBDynamicScenario backingScenario = AtBDynamicScenarioFactory.initializeScenarioFromTemplate(template, contract, campaign);        \n+        scenario.setBackingScenario(backingScenario);\n+        scenario.setCoords(coords);\n+        \n+        // by default, certain conditions may make this bigger\n+        scenario.setRequiredPlayerLances(1);\n+\n+        // do an appropriate allied force if the contract calls for it\n+        // do any attached or integrated units\n+        setAlliedForceModifier(scenario, contract);\n+        setAttachedUnitsModifier(scenario, contract);\n+        applyFacilityModifiers(scenario, track, coords);\n+        applyGlobalModifiers(scenario, contract.getStratconCampaignState());\n+\n+        if ((contract.getCommandRights() == AtBContract.COM_HOUSE) ||\n+                (contract.getCommandRights() == AtBContract.COM_INTEGRATED)) {\n+            scenario.setRequiredScenario(true);\n+        }\n+\n+        AtBDynamicScenarioFactory.setScenarioModifiers(scenario.getBackingScenario());\n+        scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+        setScenarioDates(track, campaign, scenario);\n+        \n+        // the backing scenario ID must be updated after registering the backing scenario \n+        // with the campaign, so that the stratcon - backing scenario association is maintained\n+        // registering the scenario with the campaign should be done after setting\n+        // dates, otherwise, the report messages for new scenarios look weird\n+        campaign.addScenario(backingScenario, contract);\n+        scenario.setBackingScenarioID(backingScenario.getId());\n+        \n+        if (forceID > Force.FORCE_NONE) {\n+            scenario.addPrimaryForce(forceID);\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * Apply global scenario modifiers from campaign state to given scenario.\n+     */\n+    private static void applyGlobalModifiers(StratconScenario scenario, StratconCampaignState campaignState) {\n+        for (String modifierName : campaignState.getGlobalScenarioModifiers()) {\n+            AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierName);\n+\n+            if (modifier == null) {\n+                MekHQ.getLogger().error(String.format(\"Modifier %s not found; ignoring\", modifierName));\n+                continue;\n+            }\n+\n+            scenario.getBackingScenario().addScenarioModifier(modifier);\n+        }\n+    }\n+\n+    /**\n+     * Applies scenario modifiers from the current track to the given scenario.\n+     * @param scenario\n+     * @param track\n+     */\n+    private static void applyFacilityModifiers(StratconScenario scenario, StratconTrackState track, StratconCoords coords) {\n+        // loop through all the facilities on the track\n+        // if a facility has been revealed, then it has a 100% chance to apply its effect\n+        // if a facility has not been revealed, then it has a x% chance to apply its effect\n+        // if a facility is on the the scenario coordinates the it applies the local effects\n+        for (StratconCoords facilityCoords : track.getFacilities().keySet()) {\n+            boolean scenarioAtFacility = facilityCoords.equals(coords);\n+            StratconFacility facility = track.getFacilities().get(facilityCoords);\n+            List<String> modifierIDs = new ArrayList<>();\n+\n+            if (scenarioAtFacility) {\n+                modifierIDs = facility.getLocalModifiers();\n+            } else if (facility.isVisible() || (Compute.randomInt(100) <= facility.getAggroRating())) {\n+                modifierIDs = facility.getSharedModifiers();\n+            }\n+\n+            for (String modifierID : modifierIDs) {\n+                AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierID);\n+                if(modifier == null) {\n+                    MekHQ.getLogger().error(String.format(\"Modifier %s not found for facility %s\", modifierID, facility.getFormattedDisplayableName()));\n+                    continue;\n+                }\n+\n+                scenario.getBackingScenario().addScenarioModifier(modifier);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set up the appropriate primary allied force modifier, if any\n+     * @param contract The scenario's contract.\n+     */\n+    private static void setAlliedForceModifier(StratconScenario scenario, AtBContract contract) {\n+        int alliedUnitOdds = 0;\n+\n+        // first, we determine the odds of having an allied unit present\n+        // TODO: move this override out to the contract definition\n+        if (contract.getMissionType() == AtBContract.MT_RELIEFDUTY) {\n+            alliedUnitOdds = 50;\n+        } else {\n+            switch(contract.getCommandRights()) {\n+                case AtBContract.COM_INTEGRATED:\n+                    alliedUnitOdds = 50;\n+                    break;\n+                case AtBContract.COM_HOUSE:\n+                    alliedUnitOdds = 30;\n+                    break;\n+                case AtBContract.COM_LIAISON:\n+                    alliedUnitOdds = 10;\n+                    break;\n+            }\n+        }\n+\n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+\n+        // if an allied unit is present, then we want to make sure that it's ground units\n+        // for ground battles\n+        if (Compute.randomInt(100) <= alliedUnitOdds) {\n+            if((backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+               (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space)) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_ALLIED_AIR_UNITS));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_ALLIED_GROUND_UNITS));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set the 'attached' units modifier for the current scenario (integrated, house, liaison),\n+     * and make sure we're not deploying ground units to an air scenario\n+     * @param contract The scenario's contract\n+     */\n+    public static void setAttachedUnitsModifier(StratconScenario scenario, AtBContract contract) {\n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+        boolean airBattle = (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+                (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space);\n+\n+        // if we're on cadre duty, we're getting three trainees, period\n+        if (contract.getMissionType() == AtBContract.MT_CADREDUTY) {\n+            if (airBattle) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_TRAINEES_AIR));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_TRAINEES_GROUND));\n+            }\n+            return;\n+        }\n+\n+        // if we're under non-independent command rights, a supervisor may come along\n+        switch (contract.getCommandRights()) {\n+            case AtBContract.COM_INTEGRATED:\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(airBattle \n+                        ? MekHqConstants.SCENARIO_MODIFIER_INTEGRATED_UNITS_AIR\n+                        : MekHqConstants.SCENARIO_MODIFIER_INTEGRATED_UNITS_GROUND));\n+                break;\n+            case AtBContract.COM_HOUSE:\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(airBattle \n+                        ? MekHqConstants.SCENARIO_MODIFIER_HOUSE_CO_AIR\n+                        : MekHqConstants.SCENARIO_MODIFIER_HOUSE_CO_GROUND));\n+                break;\n+            case AtBContract.COM_LIAISON:\n+                if (scenario.isRequiredScenario()) {\n+                    backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(airBattle \n+                            ? MekHqConstants.SCENARIO_MODIFIER_LIAISON_AIR\n+                            : MekHqConstants.SCENARIO_MODIFIER_LIAISON_GROUND));\n+                }\n+                break;\n+        }\n+    }\n+\n+    /**\n+     * Worker function that sets scenario deploy/battle/return dates based on the track's properties and current campaign date\n+     */\n+    private static void setScenarioDates(StratconTrackState track, Campaign campaign, StratconScenario scenario) {\n+     // set up deployment day, battle day, return day here\n+        // safety code to prevent attempts to generate random int with upper bound of 0 which is apparently illegal\n+        int deploymentDay = track.getDeploymentTime() < 7 ? Compute.randomInt(7 - track.getDeploymentTime()) : 0;\n+        int battleDay = deploymentDay + (track.getDeploymentTime() > 0 ? Compute.randomInt(track.getDeploymentTime()) : 0);\n+        int returnDay = deploymentDay + track.getDeploymentTime();\n+\n+        LocalDate deploymentDate = campaign.getLocalDate();\n+        deploymentDate.plusDays(deploymentDay);\n+        LocalDate battleDate = campaign.getLocalDate();\n+        deploymentDate.plusDays(battleDay);\n+        LocalDate returnDate = campaign.getLocalDate();\n+        returnDate.plusDays(returnDay);\n+\n+        scenario.setDeploymentDate(deploymentDate);\n+        scenario.setActionDate(battleDate);\n+        scenario.setReturnDate(returnDate);\n+    }\n+\n+    /**\n+     * Helper function that determines if the unit type specified in the given scenario force template\n+     * would start out airborne on a ground map (hot dropped units aside)\n+     */\n+    private static boolean unitTypeIsAirborne(ScenarioForceTemplate template) {\n+        int unitType = template.getAllowedUnitType();\n+\n+        return (unitType == UnitType.AERO ||\n+                unitType == UnitType.CONV_FIGHTER ||\n+                unitType == UnitType.DROPSHIP ||\n+                unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_MIX) &&\n+                template.getStartingAltitude() > 0;\n+    }\n+\n+    /**\n+     * Determines whether the force in question has the same primary unit type as the force template.\n+     * @return Whether or not the unit types match.\n+     */\n+    public static boolean forceCompositionMatchesDeclaredUnitType(int primaryUnitType, int unitType, boolean reinforcements) {\n+        // special cases are \"ATB_MIX\" and \"ATB_AERO_MIX\", which encompass multiple unit types\n+        if (unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_MIX) {\n+            // \"AtB mix\" is usually ground units, but air units can sub in\n+            return primaryUnitType == UnitType.MEK ||\n+                    primaryUnitType == UnitType.TANK ||\n+                    primaryUnitType == UnitType.INFANTRY ||\n+                    primaryUnitType == UnitType.BATTLE_ARMOR ||\n+                    primaryUnitType == UnitType.PROTOMEK ||\n+                    primaryUnitType == UnitType.VTOL ||\n+                    (primaryUnitType == UnitType.AERO) && reinforcements ||\n+                    (primaryUnitType == UnitType.CONV_FIGHTER) && reinforcements;\n+        } else if (unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_AERO_MIX) {\n+            return primaryUnitType == UnitType.AERO ||\n+                    primaryUnitType == UnitType.CONV_FIGHTER;\n+        } else {\n+            return primaryUnitType == unitType;\n+        }\n+    }\n+\n+    /**\n+     * This is a set of all force IDs for forces that can be deployed to a scenario.\n+     * @param campaign Current campaign\n+     * @return Set of available force IDs.\n+     */\n+    public static List<Integer> getAvailableForceIDs(Campaign campaign) {\n+        List<Integer> retVal = new ArrayList<>();\n+\n+        // first, we gather a set of all forces that are already deployed to a track so we eliminate those later\n+        Set<Integer> forcesInTracks = new HashSet<>();\n+        for (Contract contract : campaign.getActiveContracts()) {\n+            if (contract instanceof AtBContract) {\n+                for (StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    forcesInTracks.addAll(track.getAssignedForceCoords().keySet());\n+                }\n+            }\n+        }\n+\n+        // now, we get all the forces that qualify as \"lances\", and filter out those that are\n+        // deployed to a scenario and not in a track already\n+        for (int key : campaign.getLances().keySet()) {\n+            Force force = campaign.getForce(key);\n+            if ((force != null) &&\n+                    !force.isDeployed() &&\n+                    !forcesInTracks.contains(force.getId())) {\n+                retVal.add(force.getId());\n+            }\n+        }\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * This is a list of all force IDs for forces that can be deployed to a scenario in the given force template\n+     * a) have not been assigned to a track\n+     * b) are combat-capable\n+     * c) are not deployed to a scenario\n+     * d) if attempting to deploy as reinforcements, haven't already failed to deploy\n+     */\n+    public static List<Integer> getAvailableForceIDs(int unitType, Campaign campaign, StratconTrackState currentTrack,\n+            boolean reinforcements, @Nullable StratconScenario currentScenario) {\n+        List<Integer> retVal = new ArrayList<>();\n+\n+        Set<Integer> forcesInTracks = new HashSet<>();\n+        // assemble a set of all force IDs that are currently assigned to tracks that are not this one\n+        for (Contract contract : campaign.getActiveContracts()) {\n+            if (contract instanceof AtBContract) {\n+                for (StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    if ((track != currentTrack) || !reinforcements) {\n+                        forcesInTracks.addAll(track.getAssignedForceCoords().keySet());\n+                    }\n+                }\n+            }\n+        }\n+        \n+        // if there's an existing scenario and we're doing reinforcements,\n+        // prevent forces that failed to deploy from trying to deploy again\n+        if (reinforcements && (currentScenario != null)) {\n+            forcesInTracks.addAll(currentScenario.getFailedReinforcements());\n+        }\n+\n+        for (int key : campaign.getLances().keySet()) {\n+            Force force = campaign.getForce(key);\n+\n+            if (force == null) {\n+                continue;\n+            }\n+\n+            int primaryUnitType = force.getPrimaryUnitType(campaign);\n+            if (!force.isDeployed() &&\n+                    (force.getScenarioId() <= 0) &&\n+                    !force.getUnits().isEmpty() &&\n+                    !forcesInTracks.contains(force.getId()) &&\n+                    forceCompositionMatchesDeclaredUnitType(primaryUnitType, unitType, reinforcements)) {\n+                retVal.add(force.getId());\n+            }\n+        }\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * Returns a list of individual units eligible for deployment in scenarios run by \"Defend\" lances\n+     * @return List of unit IDs.\n+     */\n+    public static List<Unit> getEligibleDefensiveUnits(Campaign campaign) {\n+        List<Unit> retVal = new ArrayList<>();\n+\n+        for (Unit u : campaign.getUnits()) {\n+            // \"defensive\" units are infantry, battle armor and (Weisman help you) gun emplacements\n+        \t// and also said unit should be intact/alive/etc\n+        \tboolean isEligibleInfantry = \n+        \t\t\t((u.getEntity().getUnitType() == UnitType.INFANTRY) ||\n+                    (u.getEntity().getUnitType() == UnitType.BATTLE_ARMOR)) &&\n+                    !u.isUnmanned();\n+        \t\n+        \tboolean isEligibleGunEmplacement = u.getEntity().getUnitType() == UnitType.GUN_EMPLACEMENT;\n+        \t\n+        \tif ((isEligibleInfantry || isEligibleGunEmplacement) && \n+            \t\t!u.isDeployed() &&\n+                    !u.isMothballed() &&\n+                    u.isFunctional()) {", "originalCommit": "b36d9fa6bf982c7b833b1ac0a0473d37f6e84760", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTE5MjUzMg==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r615192532", "bodyText": "Stream would do this better.", "author": "Windchild292", "createdAt": "2021-04-17T02:11:24Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1404 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.UUID;\n+\n+import megamek.common.Compute;\n+import megamek.common.Minefield;\n+import megamek.common.UnitType;\n+import megamek.common.annotations.Nullable;\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.Utilities;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.ResolveScenarioTracker;\n+import mekhq.campaign.againstTheBot.enums.AtBLanceRole;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.event.StratconDeploymentEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.force.Lance;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier.EventTiming;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconFacility.FacilityType;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.unit.Unit;\n+\n+/**\n+ * This class contains \"rules\" logic for the AtB-Stratcon state\n+ * @author NickAragua\n+ */\n+public class StratconRulesManager {\n+    /**\n+     * What makes a particular lance eligible to be reinforcements for a scenario\n+     */\n+    public enum ReinforcementEligibilityType {\n+        /**\n+         * Nothing\n+         */\n+        None,\n+\n+        /**\n+         * Lance is already deployed to the track\n+         */\n+        ChainedScenario,\n+\n+        /**\n+         * We pay a support point or convert a victory point to a support point\n+         */\n+        SupportPoint,\n+\n+        /**\n+         * The lance's deployment orders are \"Fight\"\n+         */\n+        FightLance\n+    }\n+\n+    /**\n+     * This function potentially generates non-player-initiated scenarios for the given track.\n+     */\n+    public static void generateScenariosForTrack(Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // maps scenarios to force IDs\n+        List<StratconScenario> generatedScenarios = new ArrayList<>();\n+        boolean autoAssignLances = contract.getCommandRights() == AtBContract.COM_INTEGRATED;\n+\n+        // get this list just so we have it available\n+        List<Integer> availableForceIDs = getAvailableForceIDs(campaign);\n+        Map<MapLocation, List<Integer>> sortedAvailableForceIDs = sortForcesByMapType(availableForceIDs, campaign);\n+\n+        // make X rolls, where X is the number of required lances for the track\n+        // that's the chance to spawn a scenario.\n+        // if a scenario occurs, then we pick a random non-deployed lance and use it to drive the opfor generation later\n+        // once we've determined that scenarios occur, we loop through the ones that we generated\n+        // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all\n+        for (int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            int targetNum = calculateScenarioOdds(track, contract, false);\n+            \n+            // if we haven't already used all the player forces and are required to randomly generate a scenario\n+            if (!availableForceIDs.isEmpty() && (Compute.randomInt(100) <= targetNum)) {\n+                // pick random coordinates and force to drive the scenario\n+                int x = Compute.randomInt(track.getWidth());\n+                int y = Compute.randomInt(track.getHeight());\n+\n+                StratconCoords scenarioCoords = new StratconCoords(x, y);\n+\n+                // if forces are already assigned to these coordinates, use those instead\n+                // of randomly-selected ones\n+                if (track.getAssignedCoordForces().containsKey(scenarioCoords)) {\n+                    StratconScenario scenario = generateScenarioForExistingForces(scenarioCoords,\n+                            track.getAssignedCoordForces().get(scenarioCoords), \n+                            contract, campaign, track);\n+                    generatedScenarios.add(scenario);\n+                    continue;\n+                }\n+                \n+                // otherwise, pick a random force from the avail\n+                int randomForceIndex = Compute.randomInt(availableForceIDs.size());\n+                int randomForceID = availableForceIDs.get(randomForceIndex);\n+                \n+                // remove the force from the available lists so we don't designate it as primary twice\n+                availableForceIDs.remove(randomForceIndex);\n+\n+                // we want to remove the actual int with the value, not the value at the index\n+                sortedAvailableForceIDs.get(MapLocation.AllGroundTerrain).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.LowAtmosphere).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.Space).remove((Integer) randomForceID);\n+\n+                // two scenarios on the same coordinates wind up increasing in size\n+                if (track.getScenarios().containsKey(scenarioCoords)) {\n+                    track.getScenarios().get(scenarioCoords).incrementRequiredPlayerLances();\n+                    assignAppropriateExtraForceToScenario(track.getScenarios().get(scenarioCoords), sortedAvailableForceIDs);\n+                    continue;\n+                }\n+\n+                StratconScenario scenario = setupScenario(scenarioCoords, randomForceID, campaign, contract, track);\n+                generatedScenarios.add(scenario);\n+\n+                // if we're auto-assigning lances, deploy the force to the track as well\n+                if (autoAssignLances) {\n+                    processForceDeployment(scenarioCoords, randomForceID, campaign, track, false);\n+                }\n+            }\n+        }\n+\n+        // if under liaison command, pick a random scenario from the ones generated\n+        // to set as required and attach liaison\n+        if (contract.getCommandRights() == AtBContract.COM_LIAISON) {\n+        \tStratconScenario randomScenario = Utilities.getRandomItem(generatedScenarios);\n+        \trandomScenario.setRequiredScenario(true);\n+            setAttachedUnitsModifier(randomScenario, contract);\n+        }\n+\n+        // now, we loop through all the scenarios we set up\n+        // and generate the opfors / events / etc\n+        // if not auto-assigning lances, we then back out the lance assignments.\n+        for (StratconScenario scenario : generatedScenarios) {\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+\n+            if(!autoAssignLances && !scenario.ignoreForceAutoAssignment()) {\n+                for(int forceID : scenario.getPlayerTemplateForceIDs()) {\n+                    scenario.getBackingScenario().removeForce(forceID);\n+                }\n+\n+                scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                track.addScenario(scenario);\n+            } else {\n+                commitPrimaryForces(campaign, scenario, track);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Given a set of force IDs and coordinates, generate a scenario\n+     * Useful for when we want to generate scenarios \n+     * for forces already deployed to a track\n+     */\n+    public static StratconScenario generateScenarioForExistingForces(StratconCoords scenarioCoords, \n+            Set<Integer> forceIDs, AtBContract contract, Campaign campaign, StratconTrackState track) {\n+        boolean firstForce = true;\n+        StratconScenario scenario = null;\n+        \n+        for (int forceID : forceIDs) {\n+            if (firstForce) {\n+                scenario = setupScenario(scenarioCoords, forceID, campaign, contract, track);\n+                firstForce = false;\n+            } else {\n+                scenario.incrementRequiredPlayerLances();\n+                scenario.addPrimaryForce(forceID);\n+            }\n+        }\n+        \n+        // this is theoretically possible if forceIDs is passed in as null - not likely in practice\n+        // but might as well, to future-proof.\n+        if (scenario != null) {\n+            scenario.setIgnoreForceAutoAssignment(true);\n+        }\n+        \n+        return scenario;\n+    }\n+\n+    /**\n+     * Deploys a force to the given coordinates on the given track as a result of explicit player action.\n+     */\n+    public static void deployForceToCoords(StratconCoords coords, int forceID, \n+            Campaign campaign, AtBContract contract, StratconTrackState track, boolean sticky) {\n+        // the following things should happen:\n+        // 1. call to \"process force deployment\", which reveals fog of war in or around the coords, depending on force role\n+        // 2. if coords are a hostile facility, we get a facility mission\n+        // 3. if coords are empty, we *may* get a mission\n+\n+        processForceDeployment(coords, forceID, campaign, track, sticky);\n+\n+        // don't create a scenario on top of allied facilities\n+        StratconFacility facility = track.getFacility(coords);\n+        boolean isNonAlliedFacility = (facility != null) && (facility.getOwner() != ForceAlignment.Allied);\n+        int targetNum = calculateScenarioOdds(track, contract, true);\n+        boolean spawnScenario = (facility == null) && (Compute.randomInt(100) <= targetNum);\n+\n+        if (isNonAlliedFacility || spawnScenario) {\n+            StratconScenario scenario = setupScenario(coords, forceID, campaign, contract, track);\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            commitPrimaryForces(campaign, scenario, track);\n+        }\n+    }\n+\n+    /**\n+     * Logic to set up a scenario\n+     */\n+    private static StratconScenario setupScenario(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        StratconScenario scenario = null;\n+\n+        if (track.getFacilities().containsKey(coords)) {\n+            StratconFacility facility = track.getFacility(coords);\n+            boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+            ScenarioTemplate template = StratconScenarioFactory.getFacilityScenario(alliedFacility);\n+            scenario = generateScenario(campaign, contract, track, forceID, coords, template);\n+            setupFacilityScenario(scenario, facility);\n+        } else {\n+            scenario = generateScenario(campaign, contract, track, forceID, coords);\n+\n+            // we may generate a facility scenario randomly - if so, do the facility-related stuff\n+            // and add a new facility to the track\n+            if (scenario.getBackingScenario().getTemplate().isFacilityScenario()) {\n+                StratconFacility facility = scenario.getBackingScenario().getTemplate().isHostileFacility() ?\n+                        StratconFacilityFactory.getRandomHostileFacility() : StratconFacilityFactory.getRandomAlliedFacility();\n+                facility.setVisible(true);\n+                track.addFacility(coords, facility);\n+                setupFacilityScenario(scenario, facility);\n+            }\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * carries out tasks relevant to facility scenarios\n+     */\n+    private static void setupFacilityScenario(StratconScenario scenario, StratconFacility facility) {\n+        // this includes:\n+        // for hostile facilities\n+        // - add a destroy objective (always the option to level the facility)\n+        // - add a capture objective (always the option to capture the facility)\n+        // - if so indicated by parameter, roll a random hostile facility objective and add it if not capture/destroy\n+        // for allied facilities\n+        // - add a defend objective (always the option to defend the facility)\n+        // - if so indicated by parameter, roll a random allied facility objective and add it if not defend\n+        AtBScenarioModifier objectiveModifier = null;\n+        boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+\n+        if (alliedFacility) {\n+            objectiveModifier = AtBScenarioModifier.getRandomAlliedFacilityModifier();\n+        } else {\n+            objectiveModifier = AtBScenarioModifier.getRandomHostileFacilityModifier();\n+        }\n+\n+        if (objectiveModifier != null) {\n+            scenario.getBackingScenario().addScenarioModifier(objectiveModifier);\n+            scenario.getBackingScenario().setName(String.format(\"%s - %s - %s\",\n+                    facility.getFacilityType(), alliedFacility ? \"Allied\" : \"Hostile\", objectiveModifier.getModifierName()));\n+        }\n+\n+        // add the \"fixed\" hostile facility modifiers after the primary ones\n+        if (!alliedFacility) {\n+            for(AtBScenarioModifier modifier : AtBScenarioModifier.getRequiredHostileFacilityModifiers()) {\n+                if(!scenario.getBackingScenario().alreadyHasModifier(modifier)) {\n+                    scenario.getBackingScenario().addScenarioModifier(modifier);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void processFacilityEffects(StratconTrackState track) {\n+        // TODO: these are \"weekly\"? effects that a stratcon facility has on the campaign/track state\n+        // currrently, that's\n+        // supply depot - allied - +1 sp\n+        // supply depot - hostile - +5% BV budget to all scenarios on track (shared modifier, so should be implemented there)\n+        // data center - allied - +1% star league cache contract (don't implement yet, but...)\n+        // data center - hostile - +5% scenario odds in track\n+        // industrial center - allied - all scenarios here have THIS IS COMING OUT OF YOUR PAYCHECK modifier\n+        // orbital defense - allied - sets 'no hostile aircraft' flag for track\n+        // orbital defense - hostile - sets 'no allied aircraft' flag for track\n+        // early warning system - allied - sets 'intercept allied base attacks' flag for track\n+        // early warning system - hostile - sets 'intercept hostile base attacks' flag for track\n+    }\n+\n+    /**\n+     * Process the deployment of a force to the given coordinates on the given track.\n+     */\n+    public static void processForceDeployment(StratconCoords coords, int forceID, \n+            Campaign campaign, StratconTrackState track, boolean sticky) {\n+        track.getRevealedCoords().add(coords);\n+        StratconFacility facility = track.getFacility(coords);\n+        if (facility != null) {\n+            facility.setVisible(true);\n+        }\n+\n+        if (campaign.getLances().get(forceID).getRole() == AtBLanceRole.SCOUTING) {\n+            for(int direction = 0; direction < 6; direction++) {\n+                StratconCoords checkCoords = coords.translate(direction);\n+\n+                facility = track.getFacility(checkCoords);\n+                if(facility != null) {\n+                    facility.setVisible(true);\n+                }\n+\n+                track.getRevealedCoords().add(coords.translate(direction));\n+            }\n+        }\n+\n+        // the force may be located in other places on the track - clear it out\n+        track.unassignForce(forceID);\n+        track.assignForce(forceID, coords, campaign.getLocalDate(), sticky);\n+        MekHQ.triggerEvent(new StratconDeploymentEvent(campaign.getForce(forceID)));\n+    }\n+\n+    /**\n+     * Worker function that processes the effects of deploying a reinforcement force to a scenario\n+     */\n+    public static boolean processReinforcementDeployment(ReinforcementEligibilityType reinforcementType,\n+            StratconCampaignState campaignState, StratconScenario scenario, Campaign campaign) {\n+        // if the force is already deployed to the track, we're done\n+        // if the force is a fight lance or we're using a support point\n+        // if there is an SP to burn, burn it and we're done\n+        // if there is a VP to burn, burn it and we're done\n+        // now, roll 2d6 + lance commander tactics\n+        // 9+ = deploy\n+        // 6+ = deploy, apply negative modifier to scenario\n+        // 2+ = fail to deploy, apply negative modifier to scenario; if fight lance, treat as 6+\n+\n+        if ((reinforcementType == ReinforcementEligibilityType.FightLance) ||\n+                (reinforcementType == ReinforcementEligibilityType.SupportPoint)) {\n+\n+            if (campaignState.getSupportPoints() > 0) {\n+                campaignState.useSupportPoint();\n+                return true;\n+            } else if (campaignState.getVictoryPoints() > 0) {\n+                campaignState.updateVictoryPoints(-1);\n+                return true;\n+            }\n+\n+            int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+            int roll = Compute.d6(2);\n+            int result = roll + tactics;\n+\n+            StringBuilder reportStatus = new StringBuilder();\n+            reportStatus.append(String.format(\"Attempting to reinforce scenario %s without SP/VP, roll 2d6 + %d: %d\",\n+                    scenario.getName(), tactics, result));\n+\n+            // fail to reinforce\n+            if ((result < 6) && (reinforcementType != ReinforcementEligibilityType.FightLance)) {\n+                reportStatus.append(\" - reinforcement attempt failed.\");\n+                campaign.addReport(reportStatus.toString());\n+                return false;\n+            // succeed but get an extra negative event added to the scenario\n+            } else if (result < 9) {\n+                MapLocation mapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+                AtBScenarioModifier scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+\n+                // keep rolling until we get an applicable one\n+                // TODO: have the AtBScenarioModifier sort these out instead for performance?\n+                while (scenarioModifier.getEventTiming() != EventTiming.PostForceGeneration) {\n+                    scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+                }\n+\n+                scenarioModifier.processModifier(scenario.getBackingScenario(), campaign, EventTiming.PostForceGeneration);\n+\n+                reportStatus.append(String.format(\" - reinforcement attempt succeeded; extra negative modifier (%s) applied to scenario.\",\n+                        scenarioModifier.getModifierName()));\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            // succeed without reservation\n+            } else {\n+                reportStatus.append(\" - reinforcement attempt succeeded;\");\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            }\n+        } else if (reinforcementType == ReinforcementEligibilityType.None) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Assigns a force to the scenario such that the majority of the force can be deployed\n+     */\n+    private static void assignAppropriateExtraForceToScenario(StratconScenario scenario,\n+            Map<MapLocation, List<Integer>> sortedAvailableForceIDs) {\n+        // the goal of this function is to avoid assigning ground units to air battles\n+        // and ground units/conventional fighters to space battle\n+\n+        List<MapLocation> mapLocations = new ArrayList<>();\n+        mapLocations.add(MapLocation.Space); // can always add ASFs\n+\n+        MapLocation scenarioMapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+\n+        if (scenarioMapLocation == MapLocation.LowAtmosphere) {\n+            mapLocations.add(MapLocation.LowAtmosphere); // can add conventional fighters to ground or low atmo battles\n+        }\n+\n+        if ((scenarioMapLocation == MapLocation.AllGroundTerrain) ||\n+                (scenarioMapLocation == MapLocation.SpecificGroundTerrain)) {\n+            mapLocations.add(MapLocation.AllGroundTerrain); // can only add ground units to ground battles\n+        }\n+\n+        MapLocation selectedLocation = mapLocations.get(Compute.randomInt(mapLocations.size()));\n+        List<Integer> forceIDs = sortedAvailableForceIDs.get(selectedLocation);\n+        int forceIndex = Compute.randomInt(forceIDs.size());\n+        int forceID = forceIDs.get(forceIndex);\n+        forceIDs.remove(forceIndex);\n+\n+        scenario.addPrimaryForce(forceID);\n+    }\n+\n+    /**\n+     * Worker function that \"locks in\" a scenario -\n+     * Adds it to the campaign so it's visible in the briefing room,\n+     * adds it to the track\n+     *\n+     */\n+    public static void commitPrimaryForces(Campaign campaign, StratconScenario scenario, StratconTrackState trackState) {\n+        trackState.addScenario(scenario);\n+\n+        // set up dates for the scenario if doesn't have them already\n+        if (scenario.getDeploymentDate() == null) {\n+            scenario.setDeploymentDate(campaign.getLocalDate());\n+        }\n+\n+        if (scenario.getActionDate() == null) {\n+            scenario.setActionDate(campaign.getLocalDate());\n+        }\n+\n+        if(scenario.getReturnDate() == null) {\n+            scenario.setReturnDate(campaign.getLocalDate().plusDays(trackState.getDeploymentTime()));\n+        }\n+\n+        // set the # of rerolls based on the actual lance assigned.\n+        int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+        scenario.getBackingScenario().setRerolls(tactics);\n+        // The number of defensive points available to a force entering a scenario is\n+        // 2 x tactics. By default, those points are spent on conventional minefields.\n+        if (commanderLanceHasDefensiveAssignment(scenario.getBackingScenario(), campaign)) {\n+            scenario.setNumDefensivePoints(tactics * 2);\n+            scenario.updateMinefieldCount(Minefield.TYPE_CONVENTIONAL, tactics * 2);\n+        }\n+\n+        for (int forceID : scenario.getPlayerTemplateForceIDs()) {\n+            Force force = campaign.getForce(forceID);\n+            force.clearScenarioIds(campaign, true);\n+            force.setScenarioId(scenario.getBackingScenarioID());\n+        }\n+\n+        scenario.commitPrimaryForces();\n+    }\n+\n+    /**\n+     * Utility method to determine if the current scenario's force commander\n+     * is on defence\n+     */\n+    private static boolean commanderLanceHasDefensiveAssignment(AtBDynamicScenario scenario, Campaign campaign) {\n+        Unit commanderUnit = scenario.getLanceCommander(campaign).getUnit();\n+        Lance lance = campaign.getLances().get(commanderUnit.getForceId());\n+\n+        if ((lance != null) && (lance.getRole() == AtBLanceRole.DEFENCE)) {\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * A hackish worker function that takes the given list of force IDs and\n+     * separates it into three sets;\n+     * one of forces that can be \"primary\" on a ground map\n+     * one of forces that can be \"primary\" on an atmospheric map\n+     * one of forces that can be \"primary\" in a space map\n+     * @param forceIDs List of force IDs to check\n+     * @return Sorted hash map\n+     */\n+    private static Map<MapLocation, List<Integer>> sortForcesByMapType(List<Integer> forceIDs, Campaign campaign) {\n+        Map<MapLocation, List<Integer>> retVal = new HashMap<>();\n+\n+        retVal.put(MapLocation.AllGroundTerrain, new ArrayList<>());\n+        retVal.put(MapLocation.LowAtmosphere, new ArrayList<>());\n+        retVal.put(MapLocation.Space, new ArrayList<>());\n+\n+        for (int forceID : forceIDs) {\n+            switch(campaign.getForce(forceID).getPrimaryUnitType(campaign)) {\n+            case UnitType.BATTLE_ARMOR:\n+            case UnitType.INFANTRY:\n+            case UnitType.MEK:\n+            case UnitType.TANK:\n+            case UnitType.PROTOMEK:\n+            case UnitType.VTOL:\n+                retVal.get(MapLocation.AllGroundTerrain).add(forceID);\n+                break;\n+            case UnitType.AERO:\n+                retVal.get(MapLocation.Space).add(forceID);\n+                // intentional fallthrough here, ASFs can go to atmospheric maps too\n+            case UnitType.CONV_FIGHTER:\n+                retVal.get(MapLocation.LowAtmosphere).add(forceID);\n+                break;\n+            }\n+        }\n+\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * Determine whether the user should be nagged about unresolved scenarios on AtB Stratcon tracks.\n+     * @param campaign Campaign to check.\n+     * @return An informative string containing the reasons the user was nagged.\n+     */\n+    public static String nagUnresolvedContacts(Campaign campaign) {\n+        StringBuilder sb = new StringBuilder();\n+\n+        // check every track attached to an active contract for unresolved scenarios\n+        // to which the player must deploy forces today\n+        for (AtBContract contract : campaign.getActiveAtBContracts()) {\n+            if (contract.getStratconCampaignState() == null) {\n+                continue;\n+            }\n+            \n+            for (StratconTrackState track : contract.getStratconCampaignState().getTracks()) {\n+                for (StratconScenario scenario : track.getScenarios().values()) {\n+                    if (scenario.getCurrentState() == ScenarioState.UNRESOLVED &&\n+                            campaign.getLocalDate().equals(scenario.getDeploymentDate())) {\n+                        // \"scenario name, track name\"\n+                        sb.append(String.format(\"%s, %s\\n\", scenario.getName(), track.getDisplayableName()));\n+                    }\n+                }\n+            }\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track.\n+     * Also registers it with the track and campaign.\n+     */\n+    private static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords) {\n+        int unitType = campaign.getForce(forceID).getPrimaryUnitType(campaign);\n+        ScenarioTemplate template = StratconScenarioFactory.getRandomScenario(unitType);\n+        // useful for debugging specific scenario types\n+        //ScenarioTemplate template = StratconScenarioFactory.getSpecificScenario(\"Hostile Facility.xml\");\n+\n+        return generateScenario(campaign, contract, track, forceID, coords, template);\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track,\n+     * using the given template. Also registers it with the campaign.\n+     */\n+    static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords, ScenarioTemplate template) {\n+        StratconScenario scenario = new StratconScenario();\n+        \n+        AtBDynamicScenario backingScenario = AtBDynamicScenarioFactory.initializeScenarioFromTemplate(template, contract, campaign);        \n+        scenario.setBackingScenario(backingScenario);\n+        scenario.setCoords(coords);\n+        \n+        // by default, certain conditions may make this bigger\n+        scenario.setRequiredPlayerLances(1);\n+\n+        // do an appropriate allied force if the contract calls for it\n+        // do any attached or integrated units\n+        setAlliedForceModifier(scenario, contract);\n+        setAttachedUnitsModifier(scenario, contract);\n+        applyFacilityModifiers(scenario, track, coords);\n+        applyGlobalModifiers(scenario, contract.getStratconCampaignState());\n+\n+        if ((contract.getCommandRights() == AtBContract.COM_HOUSE) ||\n+                (contract.getCommandRights() == AtBContract.COM_INTEGRATED)) {\n+            scenario.setRequiredScenario(true);\n+        }\n+\n+        AtBDynamicScenarioFactory.setScenarioModifiers(scenario.getBackingScenario());\n+        scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+        setScenarioDates(track, campaign, scenario);\n+        \n+        // the backing scenario ID must be updated after registering the backing scenario \n+        // with the campaign, so that the stratcon - backing scenario association is maintained\n+        // registering the scenario with the campaign should be done after setting\n+        // dates, otherwise, the report messages for new scenarios look weird\n+        campaign.addScenario(backingScenario, contract);\n+        scenario.setBackingScenarioID(backingScenario.getId());\n+        \n+        if (forceID > Force.FORCE_NONE) {\n+            scenario.addPrimaryForce(forceID);\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * Apply global scenario modifiers from campaign state to given scenario.\n+     */\n+    private static void applyGlobalModifiers(StratconScenario scenario, StratconCampaignState campaignState) {\n+        for (String modifierName : campaignState.getGlobalScenarioModifiers()) {\n+            AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierName);\n+\n+            if (modifier == null) {\n+                MekHQ.getLogger().error(String.format(\"Modifier %s not found; ignoring\", modifierName));\n+                continue;\n+            }\n+\n+            scenario.getBackingScenario().addScenarioModifier(modifier);\n+        }\n+    }\n+\n+    /**\n+     * Applies scenario modifiers from the current track to the given scenario.\n+     * @param scenario\n+     * @param track\n+     */\n+    private static void applyFacilityModifiers(StratconScenario scenario, StratconTrackState track, StratconCoords coords) {\n+        // loop through all the facilities on the track\n+        // if a facility has been revealed, then it has a 100% chance to apply its effect\n+        // if a facility has not been revealed, then it has a x% chance to apply its effect\n+        // if a facility is on the the scenario coordinates the it applies the local effects\n+        for (StratconCoords facilityCoords : track.getFacilities().keySet()) {\n+            boolean scenarioAtFacility = facilityCoords.equals(coords);\n+            StratconFacility facility = track.getFacilities().get(facilityCoords);\n+            List<String> modifierIDs = new ArrayList<>();\n+\n+            if (scenarioAtFacility) {\n+                modifierIDs = facility.getLocalModifiers();\n+            } else if (facility.isVisible() || (Compute.randomInt(100) <= facility.getAggroRating())) {\n+                modifierIDs = facility.getSharedModifiers();\n+            }\n+\n+            for (String modifierID : modifierIDs) {\n+                AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierID);\n+                if(modifier == null) {\n+                    MekHQ.getLogger().error(String.format(\"Modifier %s not found for facility %s\", modifierID, facility.getFormattedDisplayableName()));\n+                    continue;\n+                }\n+\n+                scenario.getBackingScenario().addScenarioModifier(modifier);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set up the appropriate primary allied force modifier, if any\n+     * @param contract The scenario's contract.\n+     */\n+    private static void setAlliedForceModifier(StratconScenario scenario, AtBContract contract) {\n+        int alliedUnitOdds = 0;\n+\n+        // first, we determine the odds of having an allied unit present\n+        // TODO: move this override out to the contract definition\n+        if (contract.getMissionType() == AtBContract.MT_RELIEFDUTY) {\n+            alliedUnitOdds = 50;\n+        } else {\n+            switch(contract.getCommandRights()) {\n+                case AtBContract.COM_INTEGRATED:\n+                    alliedUnitOdds = 50;\n+                    break;\n+                case AtBContract.COM_HOUSE:\n+                    alliedUnitOdds = 30;\n+                    break;\n+                case AtBContract.COM_LIAISON:\n+                    alliedUnitOdds = 10;\n+                    break;\n+            }\n+        }\n+\n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+\n+        // if an allied unit is present, then we want to make sure that it's ground units\n+        // for ground battles\n+        if (Compute.randomInt(100) <= alliedUnitOdds) {\n+            if((backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+               (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space)) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_ALLIED_AIR_UNITS));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_ALLIED_GROUND_UNITS));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set the 'attached' units modifier for the current scenario (integrated, house, liaison),\n+     * and make sure we're not deploying ground units to an air scenario\n+     * @param contract The scenario's contract\n+     */\n+    public static void setAttachedUnitsModifier(StratconScenario scenario, AtBContract contract) {\n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+        boolean airBattle = (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+                (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space);\n+\n+        // if we're on cadre duty, we're getting three trainees, period\n+        if (contract.getMissionType() == AtBContract.MT_CADREDUTY) {\n+            if (airBattle) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_TRAINEES_AIR));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_TRAINEES_GROUND));\n+            }\n+            return;\n+        }\n+\n+        // if we're under non-independent command rights, a supervisor may come along\n+        switch (contract.getCommandRights()) {\n+            case AtBContract.COM_INTEGRATED:\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(airBattle \n+                        ? MekHqConstants.SCENARIO_MODIFIER_INTEGRATED_UNITS_AIR\n+                        : MekHqConstants.SCENARIO_MODIFIER_INTEGRATED_UNITS_GROUND));\n+                break;\n+            case AtBContract.COM_HOUSE:\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(airBattle \n+                        ? MekHqConstants.SCENARIO_MODIFIER_HOUSE_CO_AIR\n+                        : MekHqConstants.SCENARIO_MODIFIER_HOUSE_CO_GROUND));\n+                break;\n+            case AtBContract.COM_LIAISON:\n+                if (scenario.isRequiredScenario()) {\n+                    backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(airBattle \n+                            ? MekHqConstants.SCENARIO_MODIFIER_LIAISON_AIR\n+                            : MekHqConstants.SCENARIO_MODIFIER_LIAISON_GROUND));\n+                }\n+                break;\n+        }\n+    }\n+\n+    /**\n+     * Worker function that sets scenario deploy/battle/return dates based on the track's properties and current campaign date\n+     */\n+    private static void setScenarioDates(StratconTrackState track, Campaign campaign, StratconScenario scenario) {\n+     // set up deployment day, battle day, return day here\n+        // safety code to prevent attempts to generate random int with upper bound of 0 which is apparently illegal\n+        int deploymentDay = track.getDeploymentTime() < 7 ? Compute.randomInt(7 - track.getDeploymentTime()) : 0;\n+        int battleDay = deploymentDay + (track.getDeploymentTime() > 0 ? Compute.randomInt(track.getDeploymentTime()) : 0);\n+        int returnDay = deploymentDay + track.getDeploymentTime();\n+\n+        LocalDate deploymentDate = campaign.getLocalDate();\n+        deploymentDate.plusDays(deploymentDay);\n+        LocalDate battleDate = campaign.getLocalDate();\n+        deploymentDate.plusDays(battleDay);\n+        LocalDate returnDate = campaign.getLocalDate();\n+        returnDate.plusDays(returnDay);\n+\n+        scenario.setDeploymentDate(deploymentDate);\n+        scenario.setActionDate(battleDate);\n+        scenario.setReturnDate(returnDate);\n+    }\n+\n+    /**\n+     * Helper function that determines if the unit type specified in the given scenario force template\n+     * would start out airborne on a ground map (hot dropped units aside)\n+     */\n+    private static boolean unitTypeIsAirborne(ScenarioForceTemplate template) {\n+        int unitType = template.getAllowedUnitType();\n+\n+        return (unitType == UnitType.AERO ||\n+                unitType == UnitType.CONV_FIGHTER ||\n+                unitType == UnitType.DROPSHIP ||\n+                unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_MIX) &&\n+                template.getStartingAltitude() > 0;\n+    }\n+\n+    /**\n+     * Determines whether the force in question has the same primary unit type as the force template.\n+     * @return Whether or not the unit types match.\n+     */\n+    public static boolean forceCompositionMatchesDeclaredUnitType(int primaryUnitType, int unitType, boolean reinforcements) {\n+        // special cases are \"ATB_MIX\" and \"ATB_AERO_MIX\", which encompass multiple unit types\n+        if (unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_MIX) {\n+            // \"AtB mix\" is usually ground units, but air units can sub in\n+            return primaryUnitType == UnitType.MEK ||\n+                    primaryUnitType == UnitType.TANK ||\n+                    primaryUnitType == UnitType.INFANTRY ||\n+                    primaryUnitType == UnitType.BATTLE_ARMOR ||\n+                    primaryUnitType == UnitType.PROTOMEK ||\n+                    primaryUnitType == UnitType.VTOL ||\n+                    (primaryUnitType == UnitType.AERO) && reinforcements ||\n+                    (primaryUnitType == UnitType.CONV_FIGHTER) && reinforcements;\n+        } else if (unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_AERO_MIX) {\n+            return primaryUnitType == UnitType.AERO ||\n+                    primaryUnitType == UnitType.CONV_FIGHTER;\n+        } else {\n+            return primaryUnitType == unitType;\n+        }\n+    }\n+\n+    /**\n+     * This is a set of all force IDs for forces that can be deployed to a scenario.\n+     * @param campaign Current campaign\n+     * @return Set of available force IDs.\n+     */\n+    public static List<Integer> getAvailableForceIDs(Campaign campaign) {\n+        List<Integer> retVal = new ArrayList<>();\n+\n+        // first, we gather a set of all forces that are already deployed to a track so we eliminate those later\n+        Set<Integer> forcesInTracks = new HashSet<>();\n+        for (Contract contract : campaign.getActiveContracts()) {\n+            if (contract instanceof AtBContract) {\n+                for (StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    forcesInTracks.addAll(track.getAssignedForceCoords().keySet());\n+                }\n+            }\n+        }\n+\n+        // now, we get all the forces that qualify as \"lances\", and filter out those that are\n+        // deployed to a scenario and not in a track already\n+        for (int key : campaign.getLances().keySet()) {\n+            Force force = campaign.getForce(key);\n+            if ((force != null) &&\n+                    !force.isDeployed() &&\n+                    !forcesInTracks.contains(force.getId())) {\n+                retVal.add(force.getId());\n+            }\n+        }\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * This is a list of all force IDs for forces that can be deployed to a scenario in the given force template\n+     * a) have not been assigned to a track\n+     * b) are combat-capable\n+     * c) are not deployed to a scenario\n+     * d) if attempting to deploy as reinforcements, haven't already failed to deploy\n+     */\n+    public static List<Integer> getAvailableForceIDs(int unitType, Campaign campaign, StratconTrackState currentTrack,\n+            boolean reinforcements, @Nullable StratconScenario currentScenario) {\n+        List<Integer> retVal = new ArrayList<>();\n+\n+        Set<Integer> forcesInTracks = new HashSet<>();\n+        // assemble a set of all force IDs that are currently assigned to tracks that are not this one\n+        for (Contract contract : campaign.getActiveContracts()) {\n+            if (contract instanceof AtBContract) {\n+                for (StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    if ((track != currentTrack) || !reinforcements) {\n+                        forcesInTracks.addAll(track.getAssignedForceCoords().keySet());\n+                    }\n+                }\n+            }\n+        }\n+        \n+        // if there's an existing scenario and we're doing reinforcements,\n+        // prevent forces that failed to deploy from trying to deploy again\n+        if (reinforcements && (currentScenario != null)) {\n+            forcesInTracks.addAll(currentScenario.getFailedReinforcements());\n+        }\n+\n+        for (int key : campaign.getLances().keySet()) {\n+            Force force = campaign.getForce(key);\n+\n+            if (force == null) {\n+                continue;\n+            }\n+\n+            int primaryUnitType = force.getPrimaryUnitType(campaign);\n+            if (!force.isDeployed() &&\n+                    (force.getScenarioId() <= 0) &&\n+                    !force.getUnits().isEmpty() &&\n+                    !forcesInTracks.contains(force.getId()) &&\n+                    forceCompositionMatchesDeclaredUnitType(primaryUnitType, unitType, reinforcements)) {\n+                retVal.add(force.getId());\n+            }\n+        }\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * Returns a list of individual units eligible for deployment in scenarios run by \"Defend\" lances\n+     * @return List of unit IDs.\n+     */\n+    public static List<Unit> getEligibleDefensiveUnits(Campaign campaign) {\n+        List<Unit> retVal = new ArrayList<>();\n+\n+        for (Unit u : campaign.getUnits()) {\n+            // \"defensive\" units are infantry, battle armor and (Weisman help you) gun emplacements\n+        \t// and also said unit should be intact/alive/etc\n+        \tboolean isEligibleInfantry = \n+        \t\t\t((u.getEntity().getUnitType() == UnitType.INFANTRY) ||\n+                    (u.getEntity().getUnitType() == UnitType.BATTLE_ARMOR)) &&\n+                    !u.isUnmanned();\n+        \t\n+        \tboolean isEligibleGunEmplacement = u.getEntity().getUnitType() == UnitType.GUN_EMPLACEMENT;\n+        \t\n+        \tif ((isEligibleInfantry || isEligibleGunEmplacement) && \n+            \t\t!u.isDeployed() &&\n+                    !u.isMothballed() &&\n+                    u.isFunctional()) {\n+\n+                // this is a little inefficient, but probably there aren't too many active AtB contracts at a time\n+                for (AtBContract contract : campaign.getActiveAtBContracts()) {\n+                    if (contract.getStratconCampaignState().isForceDeployedHere(u.getForceId())) {\n+                        continue;\n+                    }\n+                }\n+\n+                retVal.add(u);\n+            }\n+        }\n+\n+        return retVal;\n+    }\n+    \n+    /**\n+     * Returns a list of individual units eligible for deployment in scenarios\n+     * that result from the lance leader having a leadership score\n+     * @return List of unit IDs.\n+     */\n+    public static List<Unit> getEligibleLeadershipUnits(Campaign campaign, Set<Integer> forceIDs) {\n+        List<Unit> retVal = new ArrayList<>();\n+\n+        // The criteria are as follows:\n+        // - unit is of a different unit type than the primary unit type of the force \n+        // - unit has a lower BV than the force's lowest BV unit\n+        \n+        Integer lowestBV = getLowestBV(campaign, forceIDs);\n+        \n+        // no units assigned, the rest is meaningless.\n+        if (lowestBV == null) {\n+            return retVal;\n+        }\n+        \n+        int primaryUnitType = getPrimaryUnitType(campaign, forceIDs);\n+        \n+        for (Unit u : campaign.getUnits()) {\n+            if ((primaryUnitType != u.getEntity().getUnitType()) &&\n+                    !u.isDeployed() &&\n+                    !u.isMothballed() &&\n+                    u.isFunctional() &&\n+                    (u.getEntity().calculateBattleValue() < lowestBV) &&\n+                    !isUnitDeployedToStratCon(u)) {\n+                retVal.add(u);\n+            }\n+        }\n+\n+        return retVal;\n+    }\n+    \n+    /**\n+     * Check if the unit's force (if one exists) has been deployed to a StratCon track\n+     */\n+    public static boolean isUnitDeployedToStratCon(Unit u) {\n+        if (!u.getCampaign().getCampaignOptions().getUseStratCon()) {\n+            return false;\n+        }\n+        \n+        //this is a little inefficient, but probably there aren't too many active AtB contracts at a time\n+        for (AtBContract contract : u.getCampaign().getActiveAtBContracts()) {\n+            if (contract.getStratconCampaignState().isForceDeployedHere(u.getForceId())) {\n+                return true;\n+            }\n+        }\n+        \n+        return false;", "originalCommit": "b36d9fa6bf982c7b833b1ac0a0473d37f6e84760", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTE5MjU1OQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r615192559", "bodyText": "Brackets", "author": "Windchild292", "createdAt": "2021-04-17T02:11:50Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1404 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.UUID;\n+\n+import megamek.common.Compute;\n+import megamek.common.Minefield;\n+import megamek.common.UnitType;\n+import megamek.common.annotations.Nullable;\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.Utilities;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.ResolveScenarioTracker;\n+import mekhq.campaign.againstTheBot.enums.AtBLanceRole;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.event.StratconDeploymentEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.force.Lance;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier.EventTiming;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconFacility.FacilityType;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.unit.Unit;\n+\n+/**\n+ * This class contains \"rules\" logic for the AtB-Stratcon state\n+ * @author NickAragua\n+ */\n+public class StratconRulesManager {\n+    /**\n+     * What makes a particular lance eligible to be reinforcements for a scenario\n+     */\n+    public enum ReinforcementEligibilityType {\n+        /**\n+         * Nothing\n+         */\n+        None,\n+\n+        /**\n+         * Lance is already deployed to the track\n+         */\n+        ChainedScenario,\n+\n+        /**\n+         * We pay a support point or convert a victory point to a support point\n+         */\n+        SupportPoint,\n+\n+        /**\n+         * The lance's deployment orders are \"Fight\"\n+         */\n+        FightLance\n+    }\n+\n+    /**\n+     * This function potentially generates non-player-initiated scenarios for the given track.\n+     */\n+    public static void generateScenariosForTrack(Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // maps scenarios to force IDs\n+        List<StratconScenario> generatedScenarios = new ArrayList<>();\n+        boolean autoAssignLances = contract.getCommandRights() == AtBContract.COM_INTEGRATED;\n+\n+        // get this list just so we have it available\n+        List<Integer> availableForceIDs = getAvailableForceIDs(campaign);\n+        Map<MapLocation, List<Integer>> sortedAvailableForceIDs = sortForcesByMapType(availableForceIDs, campaign);\n+\n+        // make X rolls, where X is the number of required lances for the track\n+        // that's the chance to spawn a scenario.\n+        // if a scenario occurs, then we pick a random non-deployed lance and use it to drive the opfor generation later\n+        // once we've determined that scenarios occur, we loop through the ones that we generated\n+        // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all\n+        for (int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            int targetNum = calculateScenarioOdds(track, contract, false);\n+            \n+            // if we haven't already used all the player forces and are required to randomly generate a scenario\n+            if (!availableForceIDs.isEmpty() && (Compute.randomInt(100) <= targetNum)) {\n+                // pick random coordinates and force to drive the scenario\n+                int x = Compute.randomInt(track.getWidth());\n+                int y = Compute.randomInt(track.getHeight());\n+\n+                StratconCoords scenarioCoords = new StratconCoords(x, y);\n+\n+                // if forces are already assigned to these coordinates, use those instead\n+                // of randomly-selected ones\n+                if (track.getAssignedCoordForces().containsKey(scenarioCoords)) {\n+                    StratconScenario scenario = generateScenarioForExistingForces(scenarioCoords,\n+                            track.getAssignedCoordForces().get(scenarioCoords), \n+                            contract, campaign, track);\n+                    generatedScenarios.add(scenario);\n+                    continue;\n+                }\n+                \n+                // otherwise, pick a random force from the avail\n+                int randomForceIndex = Compute.randomInt(availableForceIDs.size());\n+                int randomForceID = availableForceIDs.get(randomForceIndex);\n+                \n+                // remove the force from the available lists so we don't designate it as primary twice\n+                availableForceIDs.remove(randomForceIndex);\n+\n+                // we want to remove the actual int with the value, not the value at the index\n+                sortedAvailableForceIDs.get(MapLocation.AllGroundTerrain).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.LowAtmosphere).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.Space).remove((Integer) randomForceID);\n+\n+                // two scenarios on the same coordinates wind up increasing in size\n+                if (track.getScenarios().containsKey(scenarioCoords)) {\n+                    track.getScenarios().get(scenarioCoords).incrementRequiredPlayerLances();\n+                    assignAppropriateExtraForceToScenario(track.getScenarios().get(scenarioCoords), sortedAvailableForceIDs);\n+                    continue;\n+                }\n+\n+                StratconScenario scenario = setupScenario(scenarioCoords, randomForceID, campaign, contract, track);\n+                generatedScenarios.add(scenario);\n+\n+                // if we're auto-assigning lances, deploy the force to the track as well\n+                if (autoAssignLances) {\n+                    processForceDeployment(scenarioCoords, randomForceID, campaign, track, false);\n+                }\n+            }\n+        }\n+\n+        // if under liaison command, pick a random scenario from the ones generated\n+        // to set as required and attach liaison\n+        if (contract.getCommandRights() == AtBContract.COM_LIAISON) {\n+        \tStratconScenario randomScenario = Utilities.getRandomItem(generatedScenarios);\n+        \trandomScenario.setRequiredScenario(true);\n+            setAttachedUnitsModifier(randomScenario, contract);\n+        }\n+\n+        // now, we loop through all the scenarios we set up\n+        // and generate the opfors / events / etc\n+        // if not auto-assigning lances, we then back out the lance assignments.\n+        for (StratconScenario scenario : generatedScenarios) {\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+\n+            if(!autoAssignLances && !scenario.ignoreForceAutoAssignment()) {\n+                for(int forceID : scenario.getPlayerTemplateForceIDs()) {\n+                    scenario.getBackingScenario().removeForce(forceID);\n+                }\n+\n+                scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                track.addScenario(scenario);\n+            } else {\n+                commitPrimaryForces(campaign, scenario, track);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Given a set of force IDs and coordinates, generate a scenario\n+     * Useful for when we want to generate scenarios \n+     * for forces already deployed to a track\n+     */\n+    public static StratconScenario generateScenarioForExistingForces(StratconCoords scenarioCoords, \n+            Set<Integer> forceIDs, AtBContract contract, Campaign campaign, StratconTrackState track) {\n+        boolean firstForce = true;\n+        StratconScenario scenario = null;\n+        \n+        for (int forceID : forceIDs) {\n+            if (firstForce) {\n+                scenario = setupScenario(scenarioCoords, forceID, campaign, contract, track);\n+                firstForce = false;\n+            } else {\n+                scenario.incrementRequiredPlayerLances();\n+                scenario.addPrimaryForce(forceID);\n+            }\n+        }\n+        \n+        // this is theoretically possible if forceIDs is passed in as null - not likely in practice\n+        // but might as well, to future-proof.\n+        if (scenario != null) {\n+            scenario.setIgnoreForceAutoAssignment(true);\n+        }\n+        \n+        return scenario;\n+    }\n+\n+    /**\n+     * Deploys a force to the given coordinates on the given track as a result of explicit player action.\n+     */\n+    public static void deployForceToCoords(StratconCoords coords, int forceID, \n+            Campaign campaign, AtBContract contract, StratconTrackState track, boolean sticky) {\n+        // the following things should happen:\n+        // 1. call to \"process force deployment\", which reveals fog of war in or around the coords, depending on force role\n+        // 2. if coords are a hostile facility, we get a facility mission\n+        // 3. if coords are empty, we *may* get a mission\n+\n+        processForceDeployment(coords, forceID, campaign, track, sticky);\n+\n+        // don't create a scenario on top of allied facilities\n+        StratconFacility facility = track.getFacility(coords);\n+        boolean isNonAlliedFacility = (facility != null) && (facility.getOwner() != ForceAlignment.Allied);\n+        int targetNum = calculateScenarioOdds(track, contract, true);\n+        boolean spawnScenario = (facility == null) && (Compute.randomInt(100) <= targetNum);\n+\n+        if (isNonAlliedFacility || spawnScenario) {\n+            StratconScenario scenario = setupScenario(coords, forceID, campaign, contract, track);\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            commitPrimaryForces(campaign, scenario, track);\n+        }\n+    }\n+\n+    /**\n+     * Logic to set up a scenario\n+     */\n+    private static StratconScenario setupScenario(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        StratconScenario scenario = null;\n+\n+        if (track.getFacilities().containsKey(coords)) {\n+            StratconFacility facility = track.getFacility(coords);\n+            boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+            ScenarioTemplate template = StratconScenarioFactory.getFacilityScenario(alliedFacility);\n+            scenario = generateScenario(campaign, contract, track, forceID, coords, template);\n+            setupFacilityScenario(scenario, facility);\n+        } else {\n+            scenario = generateScenario(campaign, contract, track, forceID, coords);\n+\n+            // we may generate a facility scenario randomly - if so, do the facility-related stuff\n+            // and add a new facility to the track\n+            if (scenario.getBackingScenario().getTemplate().isFacilityScenario()) {\n+                StratconFacility facility = scenario.getBackingScenario().getTemplate().isHostileFacility() ?\n+                        StratconFacilityFactory.getRandomHostileFacility() : StratconFacilityFactory.getRandomAlliedFacility();\n+                facility.setVisible(true);\n+                track.addFacility(coords, facility);\n+                setupFacilityScenario(scenario, facility);\n+            }\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * carries out tasks relevant to facility scenarios\n+     */\n+    private static void setupFacilityScenario(StratconScenario scenario, StratconFacility facility) {\n+        // this includes:\n+        // for hostile facilities\n+        // - add a destroy objective (always the option to level the facility)\n+        // - add a capture objective (always the option to capture the facility)\n+        // - if so indicated by parameter, roll a random hostile facility objective and add it if not capture/destroy\n+        // for allied facilities\n+        // - add a defend objective (always the option to defend the facility)\n+        // - if so indicated by parameter, roll a random allied facility objective and add it if not defend\n+        AtBScenarioModifier objectiveModifier = null;\n+        boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+\n+        if (alliedFacility) {\n+            objectiveModifier = AtBScenarioModifier.getRandomAlliedFacilityModifier();\n+        } else {\n+            objectiveModifier = AtBScenarioModifier.getRandomHostileFacilityModifier();\n+        }\n+\n+        if (objectiveModifier != null) {\n+            scenario.getBackingScenario().addScenarioModifier(objectiveModifier);\n+            scenario.getBackingScenario().setName(String.format(\"%s - %s - %s\",\n+                    facility.getFacilityType(), alliedFacility ? \"Allied\" : \"Hostile\", objectiveModifier.getModifierName()));\n+        }\n+\n+        // add the \"fixed\" hostile facility modifiers after the primary ones\n+        if (!alliedFacility) {\n+            for(AtBScenarioModifier modifier : AtBScenarioModifier.getRequiredHostileFacilityModifiers()) {\n+                if(!scenario.getBackingScenario().alreadyHasModifier(modifier)) {\n+                    scenario.getBackingScenario().addScenarioModifier(modifier);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void processFacilityEffects(StratconTrackState track) {\n+        // TODO: these are \"weekly\"? effects that a stratcon facility has on the campaign/track state\n+        // currrently, that's\n+        // supply depot - allied - +1 sp\n+        // supply depot - hostile - +5% BV budget to all scenarios on track (shared modifier, so should be implemented there)\n+        // data center - allied - +1% star league cache contract (don't implement yet, but...)\n+        // data center - hostile - +5% scenario odds in track\n+        // industrial center - allied - all scenarios here have THIS IS COMING OUT OF YOUR PAYCHECK modifier\n+        // orbital defense - allied - sets 'no hostile aircraft' flag for track\n+        // orbital defense - hostile - sets 'no allied aircraft' flag for track\n+        // early warning system - allied - sets 'intercept allied base attacks' flag for track\n+        // early warning system - hostile - sets 'intercept hostile base attacks' flag for track\n+    }\n+\n+    /**\n+     * Process the deployment of a force to the given coordinates on the given track.\n+     */\n+    public static void processForceDeployment(StratconCoords coords, int forceID, \n+            Campaign campaign, StratconTrackState track, boolean sticky) {\n+        track.getRevealedCoords().add(coords);\n+        StratconFacility facility = track.getFacility(coords);\n+        if (facility != null) {\n+            facility.setVisible(true);\n+        }\n+\n+        if (campaign.getLances().get(forceID).getRole() == AtBLanceRole.SCOUTING) {\n+            for(int direction = 0; direction < 6; direction++) {\n+                StratconCoords checkCoords = coords.translate(direction);\n+\n+                facility = track.getFacility(checkCoords);\n+                if(facility != null) {\n+                    facility.setVisible(true);\n+                }\n+\n+                track.getRevealedCoords().add(coords.translate(direction));\n+            }\n+        }\n+\n+        // the force may be located in other places on the track - clear it out\n+        track.unassignForce(forceID);\n+        track.assignForce(forceID, coords, campaign.getLocalDate(), sticky);\n+        MekHQ.triggerEvent(new StratconDeploymentEvent(campaign.getForce(forceID)));\n+    }\n+\n+    /**\n+     * Worker function that processes the effects of deploying a reinforcement force to a scenario\n+     */\n+    public static boolean processReinforcementDeployment(ReinforcementEligibilityType reinforcementType,\n+            StratconCampaignState campaignState, StratconScenario scenario, Campaign campaign) {\n+        // if the force is already deployed to the track, we're done\n+        // if the force is a fight lance or we're using a support point\n+        // if there is an SP to burn, burn it and we're done\n+        // if there is a VP to burn, burn it and we're done\n+        // now, roll 2d6 + lance commander tactics\n+        // 9+ = deploy\n+        // 6+ = deploy, apply negative modifier to scenario\n+        // 2+ = fail to deploy, apply negative modifier to scenario; if fight lance, treat as 6+\n+\n+        if ((reinforcementType == ReinforcementEligibilityType.FightLance) ||\n+                (reinforcementType == ReinforcementEligibilityType.SupportPoint)) {\n+\n+            if (campaignState.getSupportPoints() > 0) {\n+                campaignState.useSupportPoint();\n+                return true;\n+            } else if (campaignState.getVictoryPoints() > 0) {\n+                campaignState.updateVictoryPoints(-1);\n+                return true;\n+            }\n+\n+            int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+            int roll = Compute.d6(2);\n+            int result = roll + tactics;\n+\n+            StringBuilder reportStatus = new StringBuilder();\n+            reportStatus.append(String.format(\"Attempting to reinforce scenario %s without SP/VP, roll 2d6 + %d: %d\",\n+                    scenario.getName(), tactics, result));\n+\n+            // fail to reinforce\n+            if ((result < 6) && (reinforcementType != ReinforcementEligibilityType.FightLance)) {\n+                reportStatus.append(\" - reinforcement attempt failed.\");\n+                campaign.addReport(reportStatus.toString());\n+                return false;\n+            // succeed but get an extra negative event added to the scenario\n+            } else if (result < 9) {\n+                MapLocation mapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+                AtBScenarioModifier scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+\n+                // keep rolling until we get an applicable one\n+                // TODO: have the AtBScenarioModifier sort these out instead for performance?\n+                while (scenarioModifier.getEventTiming() != EventTiming.PostForceGeneration) {\n+                    scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+                }\n+\n+                scenarioModifier.processModifier(scenario.getBackingScenario(), campaign, EventTiming.PostForceGeneration);\n+\n+                reportStatus.append(String.format(\" - reinforcement attempt succeeded; extra negative modifier (%s) applied to scenario.\",\n+                        scenarioModifier.getModifierName()));\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            // succeed without reservation\n+            } else {\n+                reportStatus.append(\" - reinforcement attempt succeeded;\");\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            }\n+        } else if (reinforcementType == ReinforcementEligibilityType.None) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Assigns a force to the scenario such that the majority of the force can be deployed\n+     */\n+    private static void assignAppropriateExtraForceToScenario(StratconScenario scenario,\n+            Map<MapLocation, List<Integer>> sortedAvailableForceIDs) {\n+        // the goal of this function is to avoid assigning ground units to air battles\n+        // and ground units/conventional fighters to space battle\n+\n+        List<MapLocation> mapLocations = new ArrayList<>();\n+        mapLocations.add(MapLocation.Space); // can always add ASFs\n+\n+        MapLocation scenarioMapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+\n+        if (scenarioMapLocation == MapLocation.LowAtmosphere) {\n+            mapLocations.add(MapLocation.LowAtmosphere); // can add conventional fighters to ground or low atmo battles\n+        }\n+\n+        if ((scenarioMapLocation == MapLocation.AllGroundTerrain) ||\n+                (scenarioMapLocation == MapLocation.SpecificGroundTerrain)) {\n+            mapLocations.add(MapLocation.AllGroundTerrain); // can only add ground units to ground battles\n+        }\n+\n+        MapLocation selectedLocation = mapLocations.get(Compute.randomInt(mapLocations.size()));\n+        List<Integer> forceIDs = sortedAvailableForceIDs.get(selectedLocation);\n+        int forceIndex = Compute.randomInt(forceIDs.size());\n+        int forceID = forceIDs.get(forceIndex);\n+        forceIDs.remove(forceIndex);\n+\n+        scenario.addPrimaryForce(forceID);\n+    }\n+\n+    /**\n+     * Worker function that \"locks in\" a scenario -\n+     * Adds it to the campaign so it's visible in the briefing room,\n+     * adds it to the track\n+     *\n+     */\n+    public static void commitPrimaryForces(Campaign campaign, StratconScenario scenario, StratconTrackState trackState) {\n+        trackState.addScenario(scenario);\n+\n+        // set up dates for the scenario if doesn't have them already\n+        if (scenario.getDeploymentDate() == null) {\n+            scenario.setDeploymentDate(campaign.getLocalDate());\n+        }\n+\n+        if (scenario.getActionDate() == null) {\n+            scenario.setActionDate(campaign.getLocalDate());\n+        }\n+\n+        if(scenario.getReturnDate() == null) {\n+            scenario.setReturnDate(campaign.getLocalDate().plusDays(trackState.getDeploymentTime()));\n+        }\n+\n+        // set the # of rerolls based on the actual lance assigned.\n+        int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+        scenario.getBackingScenario().setRerolls(tactics);\n+        // The number of defensive points available to a force entering a scenario is\n+        // 2 x tactics. By default, those points are spent on conventional minefields.\n+        if (commanderLanceHasDefensiveAssignment(scenario.getBackingScenario(), campaign)) {\n+            scenario.setNumDefensivePoints(tactics * 2);\n+            scenario.updateMinefieldCount(Minefield.TYPE_CONVENTIONAL, tactics * 2);\n+        }\n+\n+        for (int forceID : scenario.getPlayerTemplateForceIDs()) {\n+            Force force = campaign.getForce(forceID);\n+            force.clearScenarioIds(campaign, true);\n+            force.setScenarioId(scenario.getBackingScenarioID());\n+        }\n+\n+        scenario.commitPrimaryForces();\n+    }\n+\n+    /**\n+     * Utility method to determine if the current scenario's force commander\n+     * is on defence\n+     */\n+    private static boolean commanderLanceHasDefensiveAssignment(AtBDynamicScenario scenario, Campaign campaign) {\n+        Unit commanderUnit = scenario.getLanceCommander(campaign).getUnit();\n+        Lance lance = campaign.getLances().get(commanderUnit.getForceId());\n+\n+        if ((lance != null) && (lance.getRole() == AtBLanceRole.DEFENCE)) {\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * A hackish worker function that takes the given list of force IDs and\n+     * separates it into three sets;\n+     * one of forces that can be \"primary\" on a ground map\n+     * one of forces that can be \"primary\" on an atmospheric map\n+     * one of forces that can be \"primary\" in a space map\n+     * @param forceIDs List of force IDs to check\n+     * @return Sorted hash map\n+     */\n+    private static Map<MapLocation, List<Integer>> sortForcesByMapType(List<Integer> forceIDs, Campaign campaign) {\n+        Map<MapLocation, List<Integer>> retVal = new HashMap<>();\n+\n+        retVal.put(MapLocation.AllGroundTerrain, new ArrayList<>());\n+        retVal.put(MapLocation.LowAtmosphere, new ArrayList<>());\n+        retVal.put(MapLocation.Space, new ArrayList<>());\n+\n+        for (int forceID : forceIDs) {\n+            switch(campaign.getForce(forceID).getPrimaryUnitType(campaign)) {\n+            case UnitType.BATTLE_ARMOR:\n+            case UnitType.INFANTRY:\n+            case UnitType.MEK:\n+            case UnitType.TANK:\n+            case UnitType.PROTOMEK:\n+            case UnitType.VTOL:\n+                retVal.get(MapLocation.AllGroundTerrain).add(forceID);\n+                break;\n+            case UnitType.AERO:\n+                retVal.get(MapLocation.Space).add(forceID);\n+                // intentional fallthrough here, ASFs can go to atmospheric maps too\n+            case UnitType.CONV_FIGHTER:\n+                retVal.get(MapLocation.LowAtmosphere).add(forceID);\n+                break;\n+            }\n+        }\n+\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * Determine whether the user should be nagged about unresolved scenarios on AtB Stratcon tracks.\n+     * @param campaign Campaign to check.\n+     * @return An informative string containing the reasons the user was nagged.\n+     */\n+    public static String nagUnresolvedContacts(Campaign campaign) {\n+        StringBuilder sb = new StringBuilder();\n+\n+        // check every track attached to an active contract for unresolved scenarios\n+        // to which the player must deploy forces today\n+        for (AtBContract contract : campaign.getActiveAtBContracts()) {\n+            if (contract.getStratconCampaignState() == null) {\n+                continue;\n+            }\n+            \n+            for (StratconTrackState track : contract.getStratconCampaignState().getTracks()) {\n+                for (StratconScenario scenario : track.getScenarios().values()) {\n+                    if (scenario.getCurrentState() == ScenarioState.UNRESOLVED &&\n+                            campaign.getLocalDate().equals(scenario.getDeploymentDate())) {\n+                        // \"scenario name, track name\"\n+                        sb.append(String.format(\"%s, %s\\n\", scenario.getName(), track.getDisplayableName()));\n+                    }\n+                }\n+            }\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track.\n+     * Also registers it with the track and campaign.\n+     */\n+    private static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords) {\n+        int unitType = campaign.getForce(forceID).getPrimaryUnitType(campaign);\n+        ScenarioTemplate template = StratconScenarioFactory.getRandomScenario(unitType);\n+        // useful for debugging specific scenario types\n+        //ScenarioTemplate template = StratconScenarioFactory.getSpecificScenario(\"Hostile Facility.xml\");\n+\n+        return generateScenario(campaign, contract, track, forceID, coords, template);\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track,\n+     * using the given template. Also registers it with the campaign.\n+     */\n+    static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords, ScenarioTemplate template) {\n+        StratconScenario scenario = new StratconScenario();\n+        \n+        AtBDynamicScenario backingScenario = AtBDynamicScenarioFactory.initializeScenarioFromTemplate(template, contract, campaign);        \n+        scenario.setBackingScenario(backingScenario);\n+        scenario.setCoords(coords);\n+        \n+        // by default, certain conditions may make this bigger\n+        scenario.setRequiredPlayerLances(1);\n+\n+        // do an appropriate allied force if the contract calls for it\n+        // do any attached or integrated units\n+        setAlliedForceModifier(scenario, contract);\n+        setAttachedUnitsModifier(scenario, contract);\n+        applyFacilityModifiers(scenario, track, coords);\n+        applyGlobalModifiers(scenario, contract.getStratconCampaignState());\n+\n+        if ((contract.getCommandRights() == AtBContract.COM_HOUSE) ||\n+                (contract.getCommandRights() == AtBContract.COM_INTEGRATED)) {\n+            scenario.setRequiredScenario(true);\n+        }\n+\n+        AtBDynamicScenarioFactory.setScenarioModifiers(scenario.getBackingScenario());\n+        scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+        setScenarioDates(track, campaign, scenario);\n+        \n+        // the backing scenario ID must be updated after registering the backing scenario \n+        // with the campaign, so that the stratcon - backing scenario association is maintained\n+        // registering the scenario with the campaign should be done after setting\n+        // dates, otherwise, the report messages for new scenarios look weird\n+        campaign.addScenario(backingScenario, contract);\n+        scenario.setBackingScenarioID(backingScenario.getId());\n+        \n+        if (forceID > Force.FORCE_NONE) {\n+            scenario.addPrimaryForce(forceID);\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * Apply global scenario modifiers from campaign state to given scenario.\n+     */\n+    private static void applyGlobalModifiers(StratconScenario scenario, StratconCampaignState campaignState) {\n+        for (String modifierName : campaignState.getGlobalScenarioModifiers()) {\n+            AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierName);\n+\n+            if (modifier == null) {\n+                MekHQ.getLogger().error(String.format(\"Modifier %s not found; ignoring\", modifierName));\n+                continue;\n+            }\n+\n+            scenario.getBackingScenario().addScenarioModifier(modifier);\n+        }\n+    }\n+\n+    /**\n+     * Applies scenario modifiers from the current track to the given scenario.\n+     * @param scenario\n+     * @param track\n+     */\n+    private static void applyFacilityModifiers(StratconScenario scenario, StratconTrackState track, StratconCoords coords) {\n+        // loop through all the facilities on the track\n+        // if a facility has been revealed, then it has a 100% chance to apply its effect\n+        // if a facility has not been revealed, then it has a x% chance to apply its effect\n+        // if a facility is on the the scenario coordinates the it applies the local effects\n+        for (StratconCoords facilityCoords : track.getFacilities().keySet()) {\n+            boolean scenarioAtFacility = facilityCoords.equals(coords);\n+            StratconFacility facility = track.getFacilities().get(facilityCoords);\n+            List<String> modifierIDs = new ArrayList<>();\n+\n+            if (scenarioAtFacility) {\n+                modifierIDs = facility.getLocalModifiers();\n+            } else if (facility.isVisible() || (Compute.randomInt(100) <= facility.getAggroRating())) {\n+                modifierIDs = facility.getSharedModifiers();\n+            }\n+\n+            for (String modifierID : modifierIDs) {\n+                AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierID);\n+                if(modifier == null) {\n+                    MekHQ.getLogger().error(String.format(\"Modifier %s not found for facility %s\", modifierID, facility.getFormattedDisplayableName()));\n+                    continue;\n+                }\n+\n+                scenario.getBackingScenario().addScenarioModifier(modifier);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set up the appropriate primary allied force modifier, if any\n+     * @param contract The scenario's contract.\n+     */\n+    private static void setAlliedForceModifier(StratconScenario scenario, AtBContract contract) {\n+        int alliedUnitOdds = 0;\n+\n+        // first, we determine the odds of having an allied unit present\n+        // TODO: move this override out to the contract definition\n+        if (contract.getMissionType() == AtBContract.MT_RELIEFDUTY) {\n+            alliedUnitOdds = 50;\n+        } else {\n+            switch(contract.getCommandRights()) {\n+                case AtBContract.COM_INTEGRATED:\n+                    alliedUnitOdds = 50;\n+                    break;\n+                case AtBContract.COM_HOUSE:\n+                    alliedUnitOdds = 30;\n+                    break;\n+                case AtBContract.COM_LIAISON:\n+                    alliedUnitOdds = 10;\n+                    break;\n+            }\n+        }\n+\n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+\n+        // if an allied unit is present, then we want to make sure that it's ground units\n+        // for ground battles\n+        if (Compute.randomInt(100) <= alliedUnitOdds) {\n+            if((backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+               (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space)) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_ALLIED_AIR_UNITS));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_ALLIED_GROUND_UNITS));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set the 'attached' units modifier for the current scenario (integrated, house, liaison),\n+     * and make sure we're not deploying ground units to an air scenario\n+     * @param contract The scenario's contract\n+     */\n+    public static void setAttachedUnitsModifier(StratconScenario scenario, AtBContract contract) {\n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+        boolean airBattle = (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+                (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space);\n+\n+        // if we're on cadre duty, we're getting three trainees, period\n+        if (contract.getMissionType() == AtBContract.MT_CADREDUTY) {\n+            if (airBattle) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_TRAINEES_AIR));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_TRAINEES_GROUND));\n+            }\n+            return;\n+        }\n+\n+        // if we're under non-independent command rights, a supervisor may come along\n+        switch (contract.getCommandRights()) {\n+            case AtBContract.COM_INTEGRATED:\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(airBattle \n+                        ? MekHqConstants.SCENARIO_MODIFIER_INTEGRATED_UNITS_AIR\n+                        : MekHqConstants.SCENARIO_MODIFIER_INTEGRATED_UNITS_GROUND));\n+                break;\n+            case AtBContract.COM_HOUSE:\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(airBattle \n+                        ? MekHqConstants.SCENARIO_MODIFIER_HOUSE_CO_AIR\n+                        : MekHqConstants.SCENARIO_MODIFIER_HOUSE_CO_GROUND));\n+                break;\n+            case AtBContract.COM_LIAISON:\n+                if (scenario.isRequiredScenario()) {\n+                    backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(airBattle \n+                            ? MekHqConstants.SCENARIO_MODIFIER_LIAISON_AIR\n+                            : MekHqConstants.SCENARIO_MODIFIER_LIAISON_GROUND));\n+                }\n+                break;\n+        }\n+    }\n+\n+    /**\n+     * Worker function that sets scenario deploy/battle/return dates based on the track's properties and current campaign date\n+     */\n+    private static void setScenarioDates(StratconTrackState track, Campaign campaign, StratconScenario scenario) {\n+     // set up deployment day, battle day, return day here\n+        // safety code to prevent attempts to generate random int with upper bound of 0 which is apparently illegal\n+        int deploymentDay = track.getDeploymentTime() < 7 ? Compute.randomInt(7 - track.getDeploymentTime()) : 0;\n+        int battleDay = deploymentDay + (track.getDeploymentTime() > 0 ? Compute.randomInt(track.getDeploymentTime()) : 0);\n+        int returnDay = deploymentDay + track.getDeploymentTime();\n+\n+        LocalDate deploymentDate = campaign.getLocalDate();\n+        deploymentDate.plusDays(deploymentDay);\n+        LocalDate battleDate = campaign.getLocalDate();\n+        deploymentDate.plusDays(battleDay);\n+        LocalDate returnDate = campaign.getLocalDate();\n+        returnDate.plusDays(returnDay);\n+\n+        scenario.setDeploymentDate(deploymentDate);\n+        scenario.setActionDate(battleDate);\n+        scenario.setReturnDate(returnDate);\n+    }\n+\n+    /**\n+     * Helper function that determines if the unit type specified in the given scenario force template\n+     * would start out airborne on a ground map (hot dropped units aside)\n+     */\n+    private static boolean unitTypeIsAirborne(ScenarioForceTemplate template) {\n+        int unitType = template.getAllowedUnitType();\n+\n+        return (unitType == UnitType.AERO ||\n+                unitType == UnitType.CONV_FIGHTER ||\n+                unitType == UnitType.DROPSHIP ||\n+                unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_MIX) &&\n+                template.getStartingAltitude() > 0;\n+    }\n+\n+    /**\n+     * Determines whether the force in question has the same primary unit type as the force template.\n+     * @return Whether or not the unit types match.\n+     */\n+    public static boolean forceCompositionMatchesDeclaredUnitType(int primaryUnitType, int unitType, boolean reinforcements) {\n+        // special cases are \"ATB_MIX\" and \"ATB_AERO_MIX\", which encompass multiple unit types\n+        if (unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_MIX) {\n+            // \"AtB mix\" is usually ground units, but air units can sub in\n+            return primaryUnitType == UnitType.MEK ||\n+                    primaryUnitType == UnitType.TANK ||\n+                    primaryUnitType == UnitType.INFANTRY ||\n+                    primaryUnitType == UnitType.BATTLE_ARMOR ||\n+                    primaryUnitType == UnitType.PROTOMEK ||\n+                    primaryUnitType == UnitType.VTOL ||\n+                    (primaryUnitType == UnitType.AERO) && reinforcements ||\n+                    (primaryUnitType == UnitType.CONV_FIGHTER) && reinforcements;\n+        } else if (unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_AERO_MIX) {\n+            return primaryUnitType == UnitType.AERO ||\n+                    primaryUnitType == UnitType.CONV_FIGHTER;\n+        } else {\n+            return primaryUnitType == unitType;\n+        }\n+    }\n+\n+    /**\n+     * This is a set of all force IDs for forces that can be deployed to a scenario.\n+     * @param campaign Current campaign\n+     * @return Set of available force IDs.\n+     */\n+    public static List<Integer> getAvailableForceIDs(Campaign campaign) {\n+        List<Integer> retVal = new ArrayList<>();\n+\n+        // first, we gather a set of all forces that are already deployed to a track so we eliminate those later\n+        Set<Integer> forcesInTracks = new HashSet<>();\n+        for (Contract contract : campaign.getActiveContracts()) {\n+            if (contract instanceof AtBContract) {\n+                for (StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    forcesInTracks.addAll(track.getAssignedForceCoords().keySet());\n+                }\n+            }\n+        }\n+\n+        // now, we get all the forces that qualify as \"lances\", and filter out those that are\n+        // deployed to a scenario and not in a track already\n+        for (int key : campaign.getLances().keySet()) {\n+            Force force = campaign.getForce(key);\n+            if ((force != null) &&\n+                    !force.isDeployed() &&\n+                    !forcesInTracks.contains(force.getId())) {\n+                retVal.add(force.getId());\n+            }\n+        }\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * This is a list of all force IDs for forces that can be deployed to a scenario in the given force template\n+     * a) have not been assigned to a track\n+     * b) are combat-capable\n+     * c) are not deployed to a scenario\n+     * d) if attempting to deploy as reinforcements, haven't already failed to deploy\n+     */\n+    public static List<Integer> getAvailableForceIDs(int unitType, Campaign campaign, StratconTrackState currentTrack,\n+            boolean reinforcements, @Nullable StratconScenario currentScenario) {\n+        List<Integer> retVal = new ArrayList<>();\n+\n+        Set<Integer> forcesInTracks = new HashSet<>();\n+        // assemble a set of all force IDs that are currently assigned to tracks that are not this one\n+        for (Contract contract : campaign.getActiveContracts()) {\n+            if (contract instanceof AtBContract) {\n+                for (StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    if ((track != currentTrack) || !reinforcements) {\n+                        forcesInTracks.addAll(track.getAssignedForceCoords().keySet());\n+                    }\n+                }\n+            }\n+        }\n+        \n+        // if there's an existing scenario and we're doing reinforcements,\n+        // prevent forces that failed to deploy from trying to deploy again\n+        if (reinforcements && (currentScenario != null)) {\n+            forcesInTracks.addAll(currentScenario.getFailedReinforcements());\n+        }\n+\n+        for (int key : campaign.getLances().keySet()) {\n+            Force force = campaign.getForce(key);\n+\n+            if (force == null) {\n+                continue;\n+            }\n+\n+            int primaryUnitType = force.getPrimaryUnitType(campaign);\n+            if (!force.isDeployed() &&\n+                    (force.getScenarioId() <= 0) &&\n+                    !force.getUnits().isEmpty() &&\n+                    !forcesInTracks.contains(force.getId()) &&\n+                    forceCompositionMatchesDeclaredUnitType(primaryUnitType, unitType, reinforcements)) {\n+                retVal.add(force.getId());\n+            }\n+        }\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * Returns a list of individual units eligible for deployment in scenarios run by \"Defend\" lances\n+     * @return List of unit IDs.\n+     */\n+    public static List<Unit> getEligibleDefensiveUnits(Campaign campaign) {\n+        List<Unit> retVal = new ArrayList<>();\n+\n+        for (Unit u : campaign.getUnits()) {\n+            // \"defensive\" units are infantry, battle armor and (Weisman help you) gun emplacements\n+        \t// and also said unit should be intact/alive/etc\n+        \tboolean isEligibleInfantry = \n+        \t\t\t((u.getEntity().getUnitType() == UnitType.INFANTRY) ||\n+                    (u.getEntity().getUnitType() == UnitType.BATTLE_ARMOR)) &&\n+                    !u.isUnmanned();\n+        \t\n+        \tboolean isEligibleGunEmplacement = u.getEntity().getUnitType() == UnitType.GUN_EMPLACEMENT;\n+        \t\n+        \tif ((isEligibleInfantry || isEligibleGunEmplacement) && \n+            \t\t!u.isDeployed() &&\n+                    !u.isMothballed() &&\n+                    u.isFunctional()) {\n+\n+                // this is a little inefficient, but probably there aren't too many active AtB contracts at a time\n+                for (AtBContract contract : campaign.getActiveAtBContracts()) {\n+                    if (contract.getStratconCampaignState().isForceDeployedHere(u.getForceId())) {\n+                        continue;\n+                    }\n+                }\n+\n+                retVal.add(u);\n+            }\n+        }\n+\n+        return retVal;\n+    }\n+    \n+    /**\n+     * Returns a list of individual units eligible for deployment in scenarios\n+     * that result from the lance leader having a leadership score\n+     * @return List of unit IDs.\n+     */\n+    public static List<Unit> getEligibleLeadershipUnits(Campaign campaign, Set<Integer> forceIDs) {\n+        List<Unit> retVal = new ArrayList<>();\n+\n+        // The criteria are as follows:\n+        // - unit is of a different unit type than the primary unit type of the force \n+        // - unit has a lower BV than the force's lowest BV unit\n+        \n+        Integer lowestBV = getLowestBV(campaign, forceIDs);\n+        \n+        // no units assigned, the rest is meaningless.\n+        if (lowestBV == null) {\n+            return retVal;\n+        }\n+        \n+        int primaryUnitType = getPrimaryUnitType(campaign, forceIDs);\n+        \n+        for (Unit u : campaign.getUnits()) {\n+            if ((primaryUnitType != u.getEntity().getUnitType()) &&\n+                    !u.isDeployed() &&\n+                    !u.isMothballed() &&\n+                    u.isFunctional() &&\n+                    (u.getEntity().calculateBattleValue() < lowestBV) &&\n+                    !isUnitDeployedToStratCon(u)) {\n+                retVal.add(u);\n+            }\n+        }\n+\n+        return retVal;\n+    }\n+    \n+    /**\n+     * Check if the unit's force (if one exists) has been deployed to a StratCon track\n+     */\n+    public static boolean isUnitDeployedToStratCon(Unit u) {\n+        if (!u.getCampaign().getCampaignOptions().getUseStratCon()) {\n+            return false;\n+        }\n+        \n+        //this is a little inefficient, but probably there aren't too many active AtB contracts at a time\n+        for (AtBContract contract : u.getCampaign().getActiveAtBContracts()) {\n+            if (contract.getStratconCampaignState().isForceDeployedHere(u.getForceId())) {\n+                return true;\n+            }\n+        }\n+        \n+        return false;\n+    }\n+    \n+    /**\n+     * Given a campaign and a list of force IDs, calculate the unit with the lowest BV.\n+     */\n+    private static Integer getLowestBV(Campaign campaign, Set<Integer> forceIDs) {\n+        Integer lowestBV = null;\n+        \n+        for (int forceID : forceIDs) {\n+            Force force = campaign.getForce(forceID);\n+            if (force == null) {\n+                continue;\n+            }\n+            \n+            for (UUID id : force.getUnits()) {\n+                if (campaign.getUnit(id) == null) {\n+                    continue;\n+                }\n+                \n+                int currentBV = campaign.getUnit(id).getEntity().calculateBattleValue();\n+                \n+                if ((lowestBV == null) || (currentBV < lowestBV)) {\n+                    lowestBV = currentBV;\n+                }\n+            }\n+        }\n+        \n+        return lowestBV;\n+    }\n+    \n+    /**\n+     * Calculates the majority unit type for the forces given the IDs.\n+     */\n+    private static int getPrimaryUnitType(Campaign campaign, Set<Integer> forceIDs) {\n+        Map<Integer, Integer> unitTypeBuckets = new TreeMap<>();\n+        int biggestBucketID = -1;\n+        int biggestBucketCount = 0;\n+        \n+        for (int forceID : forceIDs) {\n+            Force force = campaign.getForce(forceID);\n+            if (force == null) {\n+                continue;\n+            }\n+        \n+            for (UUID id : force.getUnits()) {\n+                Unit unit = campaign.getUnit(id);\n+                if ((unit == null) || \n+                        (unit.getEntity() == null)) {\n+                    continue;\n+                }\n+                \n+                int unitType = unit.getEntity().getUnitType();\n+    \n+                unitTypeBuckets.merge(unitType, 1, (oldCount, value) -> oldCount + value);\n+                \n+                if (unitTypeBuckets.get(unitType) > biggestBucketCount) {\n+                    biggestBucketCount = unitTypeBuckets.get(unitType);\n+                    biggestBucketID = unitType;\n+                }\n+            }\n+        }\n+        \n+        return biggestBucketID;\n+    }\n+\n+    /**\n+     * Determines what rules to use when deploying a force for reinforcements to the given track.\n+     */\n+    public static ReinforcementEligibilityType getReinforcementType(int forceID,\n+            StratconTrackState trackState, Campaign campaign) {\n+        // if the force is currently deployed to the track, it'll be able to deploy \"for free\"\n+        if (trackState.isForceDeployed(forceID)) {\n+            return ReinforcementEligibilityType.ChainedScenario;\n+        }\n+\n+        // if the force is in 'fight' stance, it'll be able to deploy using 'fight lance' rules\n+        if (campaign.getLances().containsKey(forceID) &&\n+                campaign.getLances().get(forceID).getRole() == AtBLanceRole.FIGHTING) {", "originalCommit": "b36d9fa6bf982c7b833b1ac0a0473d37f6e84760", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTE5MjU3NQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r615192575", "bodyText": "Campaign::getActiveAtBContracts", "author": "Windchild292", "createdAt": "2021-04-17T02:12:09Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1404 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.UUID;\n+\n+import megamek.common.Compute;\n+import megamek.common.Minefield;\n+import megamek.common.UnitType;\n+import megamek.common.annotations.Nullable;\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.Utilities;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.ResolveScenarioTracker;\n+import mekhq.campaign.againstTheBot.enums.AtBLanceRole;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.event.StratconDeploymentEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.force.Lance;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier.EventTiming;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconFacility.FacilityType;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.unit.Unit;\n+\n+/**\n+ * This class contains \"rules\" logic for the AtB-Stratcon state\n+ * @author NickAragua\n+ */\n+public class StratconRulesManager {\n+    /**\n+     * What makes a particular lance eligible to be reinforcements for a scenario\n+     */\n+    public enum ReinforcementEligibilityType {\n+        /**\n+         * Nothing\n+         */\n+        None,\n+\n+        /**\n+         * Lance is already deployed to the track\n+         */\n+        ChainedScenario,\n+\n+        /**\n+         * We pay a support point or convert a victory point to a support point\n+         */\n+        SupportPoint,\n+\n+        /**\n+         * The lance's deployment orders are \"Fight\"\n+         */\n+        FightLance\n+    }\n+\n+    /**\n+     * This function potentially generates non-player-initiated scenarios for the given track.\n+     */\n+    public static void generateScenariosForTrack(Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // maps scenarios to force IDs\n+        List<StratconScenario> generatedScenarios = new ArrayList<>();\n+        boolean autoAssignLances = contract.getCommandRights() == AtBContract.COM_INTEGRATED;\n+\n+        // get this list just so we have it available\n+        List<Integer> availableForceIDs = getAvailableForceIDs(campaign);\n+        Map<MapLocation, List<Integer>> sortedAvailableForceIDs = sortForcesByMapType(availableForceIDs, campaign);\n+\n+        // make X rolls, where X is the number of required lances for the track\n+        // that's the chance to spawn a scenario.\n+        // if a scenario occurs, then we pick a random non-deployed lance and use it to drive the opfor generation later\n+        // once we've determined that scenarios occur, we loop through the ones that we generated\n+        // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all\n+        for (int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            int targetNum = calculateScenarioOdds(track, contract, false);\n+            \n+            // if we haven't already used all the player forces and are required to randomly generate a scenario\n+            if (!availableForceIDs.isEmpty() && (Compute.randomInt(100) <= targetNum)) {\n+                // pick random coordinates and force to drive the scenario\n+                int x = Compute.randomInt(track.getWidth());\n+                int y = Compute.randomInt(track.getHeight());\n+\n+                StratconCoords scenarioCoords = new StratconCoords(x, y);\n+\n+                // if forces are already assigned to these coordinates, use those instead\n+                // of randomly-selected ones\n+                if (track.getAssignedCoordForces().containsKey(scenarioCoords)) {\n+                    StratconScenario scenario = generateScenarioForExistingForces(scenarioCoords,\n+                            track.getAssignedCoordForces().get(scenarioCoords), \n+                            contract, campaign, track);\n+                    generatedScenarios.add(scenario);\n+                    continue;\n+                }\n+                \n+                // otherwise, pick a random force from the avail\n+                int randomForceIndex = Compute.randomInt(availableForceIDs.size());\n+                int randomForceID = availableForceIDs.get(randomForceIndex);\n+                \n+                // remove the force from the available lists so we don't designate it as primary twice\n+                availableForceIDs.remove(randomForceIndex);\n+\n+                // we want to remove the actual int with the value, not the value at the index\n+                sortedAvailableForceIDs.get(MapLocation.AllGroundTerrain).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.LowAtmosphere).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.Space).remove((Integer) randomForceID);\n+\n+                // two scenarios on the same coordinates wind up increasing in size\n+                if (track.getScenarios().containsKey(scenarioCoords)) {\n+                    track.getScenarios().get(scenarioCoords).incrementRequiredPlayerLances();\n+                    assignAppropriateExtraForceToScenario(track.getScenarios().get(scenarioCoords), sortedAvailableForceIDs);\n+                    continue;\n+                }\n+\n+                StratconScenario scenario = setupScenario(scenarioCoords, randomForceID, campaign, contract, track);\n+                generatedScenarios.add(scenario);\n+\n+                // if we're auto-assigning lances, deploy the force to the track as well\n+                if (autoAssignLances) {\n+                    processForceDeployment(scenarioCoords, randomForceID, campaign, track, false);\n+                }\n+            }\n+        }\n+\n+        // if under liaison command, pick a random scenario from the ones generated\n+        // to set as required and attach liaison\n+        if (contract.getCommandRights() == AtBContract.COM_LIAISON) {\n+        \tStratconScenario randomScenario = Utilities.getRandomItem(generatedScenarios);\n+        \trandomScenario.setRequiredScenario(true);\n+            setAttachedUnitsModifier(randomScenario, contract);\n+        }\n+\n+        // now, we loop through all the scenarios we set up\n+        // and generate the opfors / events / etc\n+        // if not auto-assigning lances, we then back out the lance assignments.\n+        for (StratconScenario scenario : generatedScenarios) {\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+\n+            if(!autoAssignLances && !scenario.ignoreForceAutoAssignment()) {\n+                for(int forceID : scenario.getPlayerTemplateForceIDs()) {\n+                    scenario.getBackingScenario().removeForce(forceID);\n+                }\n+\n+                scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                track.addScenario(scenario);\n+            } else {\n+                commitPrimaryForces(campaign, scenario, track);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Given a set of force IDs and coordinates, generate a scenario\n+     * Useful for when we want to generate scenarios \n+     * for forces already deployed to a track\n+     */\n+    public static StratconScenario generateScenarioForExistingForces(StratconCoords scenarioCoords, \n+            Set<Integer> forceIDs, AtBContract contract, Campaign campaign, StratconTrackState track) {\n+        boolean firstForce = true;\n+        StratconScenario scenario = null;\n+        \n+        for (int forceID : forceIDs) {\n+            if (firstForce) {\n+                scenario = setupScenario(scenarioCoords, forceID, campaign, contract, track);\n+                firstForce = false;\n+            } else {\n+                scenario.incrementRequiredPlayerLances();\n+                scenario.addPrimaryForce(forceID);\n+            }\n+        }\n+        \n+        // this is theoretically possible if forceIDs is passed in as null - not likely in practice\n+        // but might as well, to future-proof.\n+        if (scenario != null) {\n+            scenario.setIgnoreForceAutoAssignment(true);\n+        }\n+        \n+        return scenario;\n+    }\n+\n+    /**\n+     * Deploys a force to the given coordinates on the given track as a result of explicit player action.\n+     */\n+    public static void deployForceToCoords(StratconCoords coords, int forceID, \n+            Campaign campaign, AtBContract contract, StratconTrackState track, boolean sticky) {\n+        // the following things should happen:\n+        // 1. call to \"process force deployment\", which reveals fog of war in or around the coords, depending on force role\n+        // 2. if coords are a hostile facility, we get a facility mission\n+        // 3. if coords are empty, we *may* get a mission\n+\n+        processForceDeployment(coords, forceID, campaign, track, sticky);\n+\n+        // don't create a scenario on top of allied facilities\n+        StratconFacility facility = track.getFacility(coords);\n+        boolean isNonAlliedFacility = (facility != null) && (facility.getOwner() != ForceAlignment.Allied);\n+        int targetNum = calculateScenarioOdds(track, contract, true);\n+        boolean spawnScenario = (facility == null) && (Compute.randomInt(100) <= targetNum);\n+\n+        if (isNonAlliedFacility || spawnScenario) {\n+            StratconScenario scenario = setupScenario(coords, forceID, campaign, contract, track);\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            commitPrimaryForces(campaign, scenario, track);\n+        }\n+    }\n+\n+    /**\n+     * Logic to set up a scenario\n+     */\n+    private static StratconScenario setupScenario(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        StratconScenario scenario = null;\n+\n+        if (track.getFacilities().containsKey(coords)) {\n+            StratconFacility facility = track.getFacility(coords);\n+            boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+            ScenarioTemplate template = StratconScenarioFactory.getFacilityScenario(alliedFacility);\n+            scenario = generateScenario(campaign, contract, track, forceID, coords, template);\n+            setupFacilityScenario(scenario, facility);\n+        } else {\n+            scenario = generateScenario(campaign, contract, track, forceID, coords);\n+\n+            // we may generate a facility scenario randomly - if so, do the facility-related stuff\n+            // and add a new facility to the track\n+            if (scenario.getBackingScenario().getTemplate().isFacilityScenario()) {\n+                StratconFacility facility = scenario.getBackingScenario().getTemplate().isHostileFacility() ?\n+                        StratconFacilityFactory.getRandomHostileFacility() : StratconFacilityFactory.getRandomAlliedFacility();\n+                facility.setVisible(true);\n+                track.addFacility(coords, facility);\n+                setupFacilityScenario(scenario, facility);\n+            }\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * carries out tasks relevant to facility scenarios\n+     */\n+    private static void setupFacilityScenario(StratconScenario scenario, StratconFacility facility) {\n+        // this includes:\n+        // for hostile facilities\n+        // - add a destroy objective (always the option to level the facility)\n+        // - add a capture objective (always the option to capture the facility)\n+        // - if so indicated by parameter, roll a random hostile facility objective and add it if not capture/destroy\n+        // for allied facilities\n+        // - add a defend objective (always the option to defend the facility)\n+        // - if so indicated by parameter, roll a random allied facility objective and add it if not defend\n+        AtBScenarioModifier objectiveModifier = null;\n+        boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+\n+        if (alliedFacility) {\n+            objectiveModifier = AtBScenarioModifier.getRandomAlliedFacilityModifier();\n+        } else {\n+            objectiveModifier = AtBScenarioModifier.getRandomHostileFacilityModifier();\n+        }\n+\n+        if (objectiveModifier != null) {\n+            scenario.getBackingScenario().addScenarioModifier(objectiveModifier);\n+            scenario.getBackingScenario().setName(String.format(\"%s - %s - %s\",\n+                    facility.getFacilityType(), alliedFacility ? \"Allied\" : \"Hostile\", objectiveModifier.getModifierName()));\n+        }\n+\n+        // add the \"fixed\" hostile facility modifiers after the primary ones\n+        if (!alliedFacility) {\n+            for(AtBScenarioModifier modifier : AtBScenarioModifier.getRequiredHostileFacilityModifiers()) {\n+                if(!scenario.getBackingScenario().alreadyHasModifier(modifier)) {\n+                    scenario.getBackingScenario().addScenarioModifier(modifier);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void processFacilityEffects(StratconTrackState track) {\n+        // TODO: these are \"weekly\"? effects that a stratcon facility has on the campaign/track state\n+        // currrently, that's\n+        // supply depot - allied - +1 sp\n+        // supply depot - hostile - +5% BV budget to all scenarios on track (shared modifier, so should be implemented there)\n+        // data center - allied - +1% star league cache contract (don't implement yet, but...)\n+        // data center - hostile - +5% scenario odds in track\n+        // industrial center - allied - all scenarios here have THIS IS COMING OUT OF YOUR PAYCHECK modifier\n+        // orbital defense - allied - sets 'no hostile aircraft' flag for track\n+        // orbital defense - hostile - sets 'no allied aircraft' flag for track\n+        // early warning system - allied - sets 'intercept allied base attacks' flag for track\n+        // early warning system - hostile - sets 'intercept hostile base attacks' flag for track\n+    }\n+\n+    /**\n+     * Process the deployment of a force to the given coordinates on the given track.\n+     */\n+    public static void processForceDeployment(StratconCoords coords, int forceID, \n+            Campaign campaign, StratconTrackState track, boolean sticky) {\n+        track.getRevealedCoords().add(coords);\n+        StratconFacility facility = track.getFacility(coords);\n+        if (facility != null) {\n+            facility.setVisible(true);\n+        }\n+\n+        if (campaign.getLances().get(forceID).getRole() == AtBLanceRole.SCOUTING) {\n+            for(int direction = 0; direction < 6; direction++) {\n+                StratconCoords checkCoords = coords.translate(direction);\n+\n+                facility = track.getFacility(checkCoords);\n+                if(facility != null) {\n+                    facility.setVisible(true);\n+                }\n+\n+                track.getRevealedCoords().add(coords.translate(direction));\n+            }\n+        }\n+\n+        // the force may be located in other places on the track - clear it out\n+        track.unassignForce(forceID);\n+        track.assignForce(forceID, coords, campaign.getLocalDate(), sticky);\n+        MekHQ.triggerEvent(new StratconDeploymentEvent(campaign.getForce(forceID)));\n+    }\n+\n+    /**\n+     * Worker function that processes the effects of deploying a reinforcement force to a scenario\n+     */\n+    public static boolean processReinforcementDeployment(ReinforcementEligibilityType reinforcementType,\n+            StratconCampaignState campaignState, StratconScenario scenario, Campaign campaign) {\n+        // if the force is already deployed to the track, we're done\n+        // if the force is a fight lance or we're using a support point\n+        // if there is an SP to burn, burn it and we're done\n+        // if there is a VP to burn, burn it and we're done\n+        // now, roll 2d6 + lance commander tactics\n+        // 9+ = deploy\n+        // 6+ = deploy, apply negative modifier to scenario\n+        // 2+ = fail to deploy, apply negative modifier to scenario; if fight lance, treat as 6+\n+\n+        if ((reinforcementType == ReinforcementEligibilityType.FightLance) ||\n+                (reinforcementType == ReinforcementEligibilityType.SupportPoint)) {\n+\n+            if (campaignState.getSupportPoints() > 0) {\n+                campaignState.useSupportPoint();\n+                return true;\n+            } else if (campaignState.getVictoryPoints() > 0) {\n+                campaignState.updateVictoryPoints(-1);\n+                return true;\n+            }\n+\n+            int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+            int roll = Compute.d6(2);\n+            int result = roll + tactics;\n+\n+            StringBuilder reportStatus = new StringBuilder();\n+            reportStatus.append(String.format(\"Attempting to reinforce scenario %s without SP/VP, roll 2d6 + %d: %d\",\n+                    scenario.getName(), tactics, result));\n+\n+            // fail to reinforce\n+            if ((result < 6) && (reinforcementType != ReinforcementEligibilityType.FightLance)) {\n+                reportStatus.append(\" - reinforcement attempt failed.\");\n+                campaign.addReport(reportStatus.toString());\n+                return false;\n+            // succeed but get an extra negative event added to the scenario\n+            } else if (result < 9) {\n+                MapLocation mapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+                AtBScenarioModifier scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+\n+                // keep rolling until we get an applicable one\n+                // TODO: have the AtBScenarioModifier sort these out instead for performance?\n+                while (scenarioModifier.getEventTiming() != EventTiming.PostForceGeneration) {\n+                    scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+                }\n+\n+                scenarioModifier.processModifier(scenario.getBackingScenario(), campaign, EventTiming.PostForceGeneration);\n+\n+                reportStatus.append(String.format(\" - reinforcement attempt succeeded; extra negative modifier (%s) applied to scenario.\",\n+                        scenarioModifier.getModifierName()));\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            // succeed without reservation\n+            } else {\n+                reportStatus.append(\" - reinforcement attempt succeeded;\");\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            }\n+        } else if (reinforcementType == ReinforcementEligibilityType.None) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Assigns a force to the scenario such that the majority of the force can be deployed\n+     */\n+    private static void assignAppropriateExtraForceToScenario(StratconScenario scenario,\n+            Map<MapLocation, List<Integer>> sortedAvailableForceIDs) {\n+        // the goal of this function is to avoid assigning ground units to air battles\n+        // and ground units/conventional fighters to space battle\n+\n+        List<MapLocation> mapLocations = new ArrayList<>();\n+        mapLocations.add(MapLocation.Space); // can always add ASFs\n+\n+        MapLocation scenarioMapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+\n+        if (scenarioMapLocation == MapLocation.LowAtmosphere) {\n+            mapLocations.add(MapLocation.LowAtmosphere); // can add conventional fighters to ground or low atmo battles\n+        }\n+\n+        if ((scenarioMapLocation == MapLocation.AllGroundTerrain) ||\n+                (scenarioMapLocation == MapLocation.SpecificGroundTerrain)) {\n+            mapLocations.add(MapLocation.AllGroundTerrain); // can only add ground units to ground battles\n+        }\n+\n+        MapLocation selectedLocation = mapLocations.get(Compute.randomInt(mapLocations.size()));\n+        List<Integer> forceIDs = sortedAvailableForceIDs.get(selectedLocation);\n+        int forceIndex = Compute.randomInt(forceIDs.size());\n+        int forceID = forceIDs.get(forceIndex);\n+        forceIDs.remove(forceIndex);\n+\n+        scenario.addPrimaryForce(forceID);\n+    }\n+\n+    /**\n+     * Worker function that \"locks in\" a scenario -\n+     * Adds it to the campaign so it's visible in the briefing room,\n+     * adds it to the track\n+     *\n+     */\n+    public static void commitPrimaryForces(Campaign campaign, StratconScenario scenario, StratconTrackState trackState) {\n+        trackState.addScenario(scenario);\n+\n+        // set up dates for the scenario if doesn't have them already\n+        if (scenario.getDeploymentDate() == null) {\n+            scenario.setDeploymentDate(campaign.getLocalDate());\n+        }\n+\n+        if (scenario.getActionDate() == null) {\n+            scenario.setActionDate(campaign.getLocalDate());\n+        }\n+\n+        if(scenario.getReturnDate() == null) {\n+            scenario.setReturnDate(campaign.getLocalDate().plusDays(trackState.getDeploymentTime()));\n+        }\n+\n+        // set the # of rerolls based on the actual lance assigned.\n+        int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+        scenario.getBackingScenario().setRerolls(tactics);\n+        // The number of defensive points available to a force entering a scenario is\n+        // 2 x tactics. By default, those points are spent on conventional minefields.\n+        if (commanderLanceHasDefensiveAssignment(scenario.getBackingScenario(), campaign)) {\n+            scenario.setNumDefensivePoints(tactics * 2);\n+            scenario.updateMinefieldCount(Minefield.TYPE_CONVENTIONAL, tactics * 2);\n+        }\n+\n+        for (int forceID : scenario.getPlayerTemplateForceIDs()) {\n+            Force force = campaign.getForce(forceID);\n+            force.clearScenarioIds(campaign, true);\n+            force.setScenarioId(scenario.getBackingScenarioID());\n+        }\n+\n+        scenario.commitPrimaryForces();\n+    }\n+\n+    /**\n+     * Utility method to determine if the current scenario's force commander\n+     * is on defence\n+     */\n+    private static boolean commanderLanceHasDefensiveAssignment(AtBDynamicScenario scenario, Campaign campaign) {\n+        Unit commanderUnit = scenario.getLanceCommander(campaign).getUnit();\n+        Lance lance = campaign.getLances().get(commanderUnit.getForceId());\n+\n+        if ((lance != null) && (lance.getRole() == AtBLanceRole.DEFENCE)) {\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * A hackish worker function that takes the given list of force IDs and\n+     * separates it into three sets;\n+     * one of forces that can be \"primary\" on a ground map\n+     * one of forces that can be \"primary\" on an atmospheric map\n+     * one of forces that can be \"primary\" in a space map\n+     * @param forceIDs List of force IDs to check\n+     * @return Sorted hash map\n+     */\n+    private static Map<MapLocation, List<Integer>> sortForcesByMapType(List<Integer> forceIDs, Campaign campaign) {\n+        Map<MapLocation, List<Integer>> retVal = new HashMap<>();\n+\n+        retVal.put(MapLocation.AllGroundTerrain, new ArrayList<>());\n+        retVal.put(MapLocation.LowAtmosphere, new ArrayList<>());\n+        retVal.put(MapLocation.Space, new ArrayList<>());\n+\n+        for (int forceID : forceIDs) {\n+            switch(campaign.getForce(forceID).getPrimaryUnitType(campaign)) {\n+            case UnitType.BATTLE_ARMOR:\n+            case UnitType.INFANTRY:\n+            case UnitType.MEK:\n+            case UnitType.TANK:\n+            case UnitType.PROTOMEK:\n+            case UnitType.VTOL:\n+                retVal.get(MapLocation.AllGroundTerrain).add(forceID);\n+                break;\n+            case UnitType.AERO:\n+                retVal.get(MapLocation.Space).add(forceID);\n+                // intentional fallthrough here, ASFs can go to atmospheric maps too\n+            case UnitType.CONV_FIGHTER:\n+                retVal.get(MapLocation.LowAtmosphere).add(forceID);\n+                break;\n+            }\n+        }\n+\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * Determine whether the user should be nagged about unresolved scenarios on AtB Stratcon tracks.\n+     * @param campaign Campaign to check.\n+     * @return An informative string containing the reasons the user was nagged.\n+     */\n+    public static String nagUnresolvedContacts(Campaign campaign) {\n+        StringBuilder sb = new StringBuilder();\n+\n+        // check every track attached to an active contract for unresolved scenarios\n+        // to which the player must deploy forces today\n+        for (AtBContract contract : campaign.getActiveAtBContracts()) {\n+            if (contract.getStratconCampaignState() == null) {\n+                continue;\n+            }\n+            \n+            for (StratconTrackState track : contract.getStratconCampaignState().getTracks()) {\n+                for (StratconScenario scenario : track.getScenarios().values()) {\n+                    if (scenario.getCurrentState() == ScenarioState.UNRESOLVED &&\n+                            campaign.getLocalDate().equals(scenario.getDeploymentDate())) {\n+                        // \"scenario name, track name\"\n+                        sb.append(String.format(\"%s, %s\\n\", scenario.getName(), track.getDisplayableName()));\n+                    }\n+                }\n+            }\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track.\n+     * Also registers it with the track and campaign.\n+     */\n+    private static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords) {\n+        int unitType = campaign.getForce(forceID).getPrimaryUnitType(campaign);\n+        ScenarioTemplate template = StratconScenarioFactory.getRandomScenario(unitType);\n+        // useful for debugging specific scenario types\n+        //ScenarioTemplate template = StratconScenarioFactory.getSpecificScenario(\"Hostile Facility.xml\");\n+\n+        return generateScenario(campaign, contract, track, forceID, coords, template);\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track,\n+     * using the given template. Also registers it with the campaign.\n+     */\n+    static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords, ScenarioTemplate template) {\n+        StratconScenario scenario = new StratconScenario();\n+        \n+        AtBDynamicScenario backingScenario = AtBDynamicScenarioFactory.initializeScenarioFromTemplate(template, contract, campaign);        \n+        scenario.setBackingScenario(backingScenario);\n+        scenario.setCoords(coords);\n+        \n+        // by default, certain conditions may make this bigger\n+        scenario.setRequiredPlayerLances(1);\n+\n+        // do an appropriate allied force if the contract calls for it\n+        // do any attached or integrated units\n+        setAlliedForceModifier(scenario, contract);\n+        setAttachedUnitsModifier(scenario, contract);\n+        applyFacilityModifiers(scenario, track, coords);\n+        applyGlobalModifiers(scenario, contract.getStratconCampaignState());\n+\n+        if ((contract.getCommandRights() == AtBContract.COM_HOUSE) ||\n+                (contract.getCommandRights() == AtBContract.COM_INTEGRATED)) {\n+            scenario.setRequiredScenario(true);\n+        }\n+\n+        AtBDynamicScenarioFactory.setScenarioModifiers(scenario.getBackingScenario());\n+        scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+        setScenarioDates(track, campaign, scenario);\n+        \n+        // the backing scenario ID must be updated after registering the backing scenario \n+        // with the campaign, so that the stratcon - backing scenario association is maintained\n+        // registering the scenario with the campaign should be done after setting\n+        // dates, otherwise, the report messages for new scenarios look weird\n+        campaign.addScenario(backingScenario, contract);\n+        scenario.setBackingScenarioID(backingScenario.getId());\n+        \n+        if (forceID > Force.FORCE_NONE) {\n+            scenario.addPrimaryForce(forceID);\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * Apply global scenario modifiers from campaign state to given scenario.\n+     */\n+    private static void applyGlobalModifiers(StratconScenario scenario, StratconCampaignState campaignState) {\n+        for (String modifierName : campaignState.getGlobalScenarioModifiers()) {\n+            AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierName);\n+\n+            if (modifier == null) {\n+                MekHQ.getLogger().error(String.format(\"Modifier %s not found; ignoring\", modifierName));\n+                continue;\n+            }\n+\n+            scenario.getBackingScenario().addScenarioModifier(modifier);\n+        }\n+    }\n+\n+    /**\n+     * Applies scenario modifiers from the current track to the given scenario.\n+     * @param scenario\n+     * @param track\n+     */\n+    private static void applyFacilityModifiers(StratconScenario scenario, StratconTrackState track, StratconCoords coords) {\n+        // loop through all the facilities on the track\n+        // if a facility has been revealed, then it has a 100% chance to apply its effect\n+        // if a facility has not been revealed, then it has a x% chance to apply its effect\n+        // if a facility is on the the scenario coordinates the it applies the local effects\n+        for (StratconCoords facilityCoords : track.getFacilities().keySet()) {\n+            boolean scenarioAtFacility = facilityCoords.equals(coords);\n+            StratconFacility facility = track.getFacilities().get(facilityCoords);\n+            List<String> modifierIDs = new ArrayList<>();\n+\n+            if (scenarioAtFacility) {\n+                modifierIDs = facility.getLocalModifiers();\n+            } else if (facility.isVisible() || (Compute.randomInt(100) <= facility.getAggroRating())) {\n+                modifierIDs = facility.getSharedModifiers();\n+            }\n+\n+            for (String modifierID : modifierIDs) {\n+                AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierID);\n+                if(modifier == null) {\n+                    MekHQ.getLogger().error(String.format(\"Modifier %s not found for facility %s\", modifierID, facility.getFormattedDisplayableName()));\n+                    continue;\n+                }\n+\n+                scenario.getBackingScenario().addScenarioModifier(modifier);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set up the appropriate primary allied force modifier, if any\n+     * @param contract The scenario's contract.\n+     */\n+    private static void setAlliedForceModifier(StratconScenario scenario, AtBContract contract) {\n+        int alliedUnitOdds = 0;\n+\n+        // first, we determine the odds of having an allied unit present\n+        // TODO: move this override out to the contract definition\n+        if (contract.getMissionType() == AtBContract.MT_RELIEFDUTY) {\n+            alliedUnitOdds = 50;\n+        } else {\n+            switch(contract.getCommandRights()) {\n+                case AtBContract.COM_INTEGRATED:\n+                    alliedUnitOdds = 50;\n+                    break;\n+                case AtBContract.COM_HOUSE:\n+                    alliedUnitOdds = 30;\n+                    break;\n+                case AtBContract.COM_LIAISON:\n+                    alliedUnitOdds = 10;\n+                    break;\n+            }\n+        }\n+\n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+\n+        // if an allied unit is present, then we want to make sure that it's ground units\n+        // for ground battles\n+        if (Compute.randomInt(100) <= alliedUnitOdds) {\n+            if((backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+               (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space)) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_ALLIED_AIR_UNITS));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_ALLIED_GROUND_UNITS));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set the 'attached' units modifier for the current scenario (integrated, house, liaison),\n+     * and make sure we're not deploying ground units to an air scenario\n+     * @param contract The scenario's contract\n+     */\n+    public static void setAttachedUnitsModifier(StratconScenario scenario, AtBContract contract) {\n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+        boolean airBattle = (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+                (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space);\n+\n+        // if we're on cadre duty, we're getting three trainees, period\n+        if (contract.getMissionType() == AtBContract.MT_CADREDUTY) {\n+            if (airBattle) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_TRAINEES_AIR));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_TRAINEES_GROUND));\n+            }\n+            return;\n+        }\n+\n+        // if we're under non-independent command rights, a supervisor may come along\n+        switch (contract.getCommandRights()) {\n+            case AtBContract.COM_INTEGRATED:\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(airBattle \n+                        ? MekHqConstants.SCENARIO_MODIFIER_INTEGRATED_UNITS_AIR\n+                        : MekHqConstants.SCENARIO_MODIFIER_INTEGRATED_UNITS_GROUND));\n+                break;\n+            case AtBContract.COM_HOUSE:\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(airBattle \n+                        ? MekHqConstants.SCENARIO_MODIFIER_HOUSE_CO_AIR\n+                        : MekHqConstants.SCENARIO_MODIFIER_HOUSE_CO_GROUND));\n+                break;\n+            case AtBContract.COM_LIAISON:\n+                if (scenario.isRequiredScenario()) {\n+                    backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(airBattle \n+                            ? MekHqConstants.SCENARIO_MODIFIER_LIAISON_AIR\n+                            : MekHqConstants.SCENARIO_MODIFIER_LIAISON_GROUND));\n+                }\n+                break;\n+        }\n+    }\n+\n+    /**\n+     * Worker function that sets scenario deploy/battle/return dates based on the track's properties and current campaign date\n+     */\n+    private static void setScenarioDates(StratconTrackState track, Campaign campaign, StratconScenario scenario) {\n+     // set up deployment day, battle day, return day here\n+        // safety code to prevent attempts to generate random int with upper bound of 0 which is apparently illegal\n+        int deploymentDay = track.getDeploymentTime() < 7 ? Compute.randomInt(7 - track.getDeploymentTime()) : 0;\n+        int battleDay = deploymentDay + (track.getDeploymentTime() > 0 ? Compute.randomInt(track.getDeploymentTime()) : 0);\n+        int returnDay = deploymentDay + track.getDeploymentTime();\n+\n+        LocalDate deploymentDate = campaign.getLocalDate();\n+        deploymentDate.plusDays(deploymentDay);\n+        LocalDate battleDate = campaign.getLocalDate();\n+        deploymentDate.plusDays(battleDay);\n+        LocalDate returnDate = campaign.getLocalDate();\n+        returnDate.plusDays(returnDay);\n+\n+        scenario.setDeploymentDate(deploymentDate);\n+        scenario.setActionDate(battleDate);\n+        scenario.setReturnDate(returnDate);\n+    }\n+\n+    /**\n+     * Helper function that determines if the unit type specified in the given scenario force template\n+     * would start out airborne on a ground map (hot dropped units aside)\n+     */\n+    private static boolean unitTypeIsAirborne(ScenarioForceTemplate template) {\n+        int unitType = template.getAllowedUnitType();\n+\n+        return (unitType == UnitType.AERO ||\n+                unitType == UnitType.CONV_FIGHTER ||\n+                unitType == UnitType.DROPSHIP ||\n+                unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_MIX) &&\n+                template.getStartingAltitude() > 0;\n+    }\n+\n+    /**\n+     * Determines whether the force in question has the same primary unit type as the force template.\n+     * @return Whether or not the unit types match.\n+     */\n+    public static boolean forceCompositionMatchesDeclaredUnitType(int primaryUnitType, int unitType, boolean reinforcements) {\n+        // special cases are \"ATB_MIX\" and \"ATB_AERO_MIX\", which encompass multiple unit types\n+        if (unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_MIX) {\n+            // \"AtB mix\" is usually ground units, but air units can sub in\n+            return primaryUnitType == UnitType.MEK ||\n+                    primaryUnitType == UnitType.TANK ||\n+                    primaryUnitType == UnitType.INFANTRY ||\n+                    primaryUnitType == UnitType.BATTLE_ARMOR ||\n+                    primaryUnitType == UnitType.PROTOMEK ||\n+                    primaryUnitType == UnitType.VTOL ||\n+                    (primaryUnitType == UnitType.AERO) && reinforcements ||\n+                    (primaryUnitType == UnitType.CONV_FIGHTER) && reinforcements;\n+        } else if (unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_AERO_MIX) {\n+            return primaryUnitType == UnitType.AERO ||\n+                    primaryUnitType == UnitType.CONV_FIGHTER;\n+        } else {\n+            return primaryUnitType == unitType;\n+        }\n+    }\n+\n+    /**\n+     * This is a set of all force IDs for forces that can be deployed to a scenario.\n+     * @param campaign Current campaign\n+     * @return Set of available force IDs.\n+     */\n+    public static List<Integer> getAvailableForceIDs(Campaign campaign) {\n+        List<Integer> retVal = new ArrayList<>();\n+\n+        // first, we gather a set of all forces that are already deployed to a track so we eliminate those later\n+        Set<Integer> forcesInTracks = new HashSet<>();\n+        for (Contract contract : campaign.getActiveContracts()) {\n+            if (contract instanceof AtBContract) {\n+                for (StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    forcesInTracks.addAll(track.getAssignedForceCoords().keySet());\n+                }\n+            }\n+        }\n+\n+        // now, we get all the forces that qualify as \"lances\", and filter out those that are\n+        // deployed to a scenario and not in a track already\n+        for (int key : campaign.getLances().keySet()) {\n+            Force force = campaign.getForce(key);\n+            if ((force != null) &&\n+                    !force.isDeployed() &&\n+                    !forcesInTracks.contains(force.getId())) {\n+                retVal.add(force.getId());\n+            }\n+        }\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * This is a list of all force IDs for forces that can be deployed to a scenario in the given force template\n+     * a) have not been assigned to a track\n+     * b) are combat-capable\n+     * c) are not deployed to a scenario\n+     * d) if attempting to deploy as reinforcements, haven't already failed to deploy\n+     */\n+    public static List<Integer> getAvailableForceIDs(int unitType, Campaign campaign, StratconTrackState currentTrack,\n+            boolean reinforcements, @Nullable StratconScenario currentScenario) {\n+        List<Integer> retVal = new ArrayList<>();\n+\n+        Set<Integer> forcesInTracks = new HashSet<>();\n+        // assemble a set of all force IDs that are currently assigned to tracks that are not this one\n+        for (Contract contract : campaign.getActiveContracts()) {\n+            if (contract instanceof AtBContract) {\n+                for (StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    if ((track != currentTrack) || !reinforcements) {\n+                        forcesInTracks.addAll(track.getAssignedForceCoords().keySet());\n+                    }\n+                }\n+            }\n+        }\n+        \n+        // if there's an existing scenario and we're doing reinforcements,\n+        // prevent forces that failed to deploy from trying to deploy again\n+        if (reinforcements && (currentScenario != null)) {\n+            forcesInTracks.addAll(currentScenario.getFailedReinforcements());\n+        }\n+\n+        for (int key : campaign.getLances().keySet()) {\n+            Force force = campaign.getForce(key);\n+\n+            if (force == null) {\n+                continue;\n+            }\n+\n+            int primaryUnitType = force.getPrimaryUnitType(campaign);\n+            if (!force.isDeployed() &&\n+                    (force.getScenarioId() <= 0) &&\n+                    !force.getUnits().isEmpty() &&\n+                    !forcesInTracks.contains(force.getId()) &&\n+                    forceCompositionMatchesDeclaredUnitType(primaryUnitType, unitType, reinforcements)) {\n+                retVal.add(force.getId());\n+            }\n+        }\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * Returns a list of individual units eligible for deployment in scenarios run by \"Defend\" lances\n+     * @return List of unit IDs.\n+     */\n+    public static List<Unit> getEligibleDefensiveUnits(Campaign campaign) {\n+        List<Unit> retVal = new ArrayList<>();\n+\n+        for (Unit u : campaign.getUnits()) {\n+            // \"defensive\" units are infantry, battle armor and (Weisman help you) gun emplacements\n+        \t// and also said unit should be intact/alive/etc\n+        \tboolean isEligibleInfantry = \n+        \t\t\t((u.getEntity().getUnitType() == UnitType.INFANTRY) ||\n+                    (u.getEntity().getUnitType() == UnitType.BATTLE_ARMOR)) &&\n+                    !u.isUnmanned();\n+        \t\n+        \tboolean isEligibleGunEmplacement = u.getEntity().getUnitType() == UnitType.GUN_EMPLACEMENT;\n+        \t\n+        \tif ((isEligibleInfantry || isEligibleGunEmplacement) && \n+            \t\t!u.isDeployed() &&\n+                    !u.isMothballed() &&\n+                    u.isFunctional()) {\n+\n+                // this is a little inefficient, but probably there aren't too many active AtB contracts at a time\n+                for (AtBContract contract : campaign.getActiveAtBContracts()) {\n+                    if (contract.getStratconCampaignState().isForceDeployedHere(u.getForceId())) {\n+                        continue;\n+                    }\n+                }\n+\n+                retVal.add(u);\n+            }\n+        }\n+\n+        return retVal;\n+    }\n+    \n+    /**\n+     * Returns a list of individual units eligible for deployment in scenarios\n+     * that result from the lance leader having a leadership score\n+     * @return List of unit IDs.\n+     */\n+    public static List<Unit> getEligibleLeadershipUnits(Campaign campaign, Set<Integer> forceIDs) {\n+        List<Unit> retVal = new ArrayList<>();\n+\n+        // The criteria are as follows:\n+        // - unit is of a different unit type than the primary unit type of the force \n+        // - unit has a lower BV than the force's lowest BV unit\n+        \n+        Integer lowestBV = getLowestBV(campaign, forceIDs);\n+        \n+        // no units assigned, the rest is meaningless.\n+        if (lowestBV == null) {\n+            return retVal;\n+        }\n+        \n+        int primaryUnitType = getPrimaryUnitType(campaign, forceIDs);\n+        \n+        for (Unit u : campaign.getUnits()) {\n+            if ((primaryUnitType != u.getEntity().getUnitType()) &&\n+                    !u.isDeployed() &&\n+                    !u.isMothballed() &&\n+                    u.isFunctional() &&\n+                    (u.getEntity().calculateBattleValue() < lowestBV) &&\n+                    !isUnitDeployedToStratCon(u)) {\n+                retVal.add(u);\n+            }\n+        }\n+\n+        return retVal;\n+    }\n+    \n+    /**\n+     * Check if the unit's force (if one exists) has been deployed to a StratCon track\n+     */\n+    public static boolean isUnitDeployedToStratCon(Unit u) {\n+        if (!u.getCampaign().getCampaignOptions().getUseStratCon()) {\n+            return false;\n+        }\n+        \n+        //this is a little inefficient, but probably there aren't too many active AtB contracts at a time\n+        for (AtBContract contract : u.getCampaign().getActiveAtBContracts()) {\n+            if (contract.getStratconCampaignState().isForceDeployedHere(u.getForceId())) {\n+                return true;\n+            }\n+        }\n+        \n+        return false;\n+    }\n+    \n+    /**\n+     * Given a campaign and a list of force IDs, calculate the unit with the lowest BV.\n+     */\n+    private static Integer getLowestBV(Campaign campaign, Set<Integer> forceIDs) {\n+        Integer lowestBV = null;\n+        \n+        for (int forceID : forceIDs) {\n+            Force force = campaign.getForce(forceID);\n+            if (force == null) {\n+                continue;\n+            }\n+            \n+            for (UUID id : force.getUnits()) {\n+                if (campaign.getUnit(id) == null) {\n+                    continue;\n+                }\n+                \n+                int currentBV = campaign.getUnit(id).getEntity().calculateBattleValue();\n+                \n+                if ((lowestBV == null) || (currentBV < lowestBV)) {\n+                    lowestBV = currentBV;\n+                }\n+            }\n+        }\n+        \n+        return lowestBV;\n+    }\n+    \n+    /**\n+     * Calculates the majority unit type for the forces given the IDs.\n+     */\n+    private static int getPrimaryUnitType(Campaign campaign, Set<Integer> forceIDs) {\n+        Map<Integer, Integer> unitTypeBuckets = new TreeMap<>();\n+        int biggestBucketID = -1;\n+        int biggestBucketCount = 0;\n+        \n+        for (int forceID : forceIDs) {\n+            Force force = campaign.getForce(forceID);\n+            if (force == null) {\n+                continue;\n+            }\n+        \n+            for (UUID id : force.getUnits()) {\n+                Unit unit = campaign.getUnit(id);\n+                if ((unit == null) || \n+                        (unit.getEntity() == null)) {\n+                    continue;\n+                }\n+                \n+                int unitType = unit.getEntity().getUnitType();\n+    \n+                unitTypeBuckets.merge(unitType, 1, (oldCount, value) -> oldCount + value);\n+                \n+                if (unitTypeBuckets.get(unitType) > biggestBucketCount) {\n+                    biggestBucketCount = unitTypeBuckets.get(unitType);\n+                    biggestBucketID = unitType;\n+                }\n+            }\n+        }\n+        \n+        return biggestBucketID;\n+    }\n+\n+    /**\n+     * Determines what rules to use when deploying a force for reinforcements to the given track.\n+     */\n+    public static ReinforcementEligibilityType getReinforcementType(int forceID,\n+            StratconTrackState trackState, Campaign campaign) {\n+        // if the force is currently deployed to the track, it'll be able to deploy \"for free\"\n+        if (trackState.isForceDeployed(forceID)) {\n+            return ReinforcementEligibilityType.ChainedScenario;\n+        }\n+\n+        // if the force is in 'fight' stance, it'll be able to deploy using 'fight lance' rules\n+        if (campaign.getLances().containsKey(forceID) &&\n+                campaign.getLances().get(forceID).getRole() == AtBLanceRole.FIGHTING) {\n+            return ReinforcementEligibilityType.FightLance;\n+        }\n+\n+        // if the force is deployed elsewhere, it cannot be deployed as reinforcements\n+        for (Contract contract : campaign.getActiveContracts()) {", "originalCommit": "b36d9fa6bf982c7b833b1ac0a0473d37f6e84760", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTE5MjU5MA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r615192590", "bodyText": "And spaces...", "author": "Windchild292", "createdAt": "2021-04-17T02:12:19Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1404 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.UUID;\n+\n+import megamek.common.Compute;\n+import megamek.common.Minefield;\n+import megamek.common.UnitType;\n+import megamek.common.annotations.Nullable;\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.Utilities;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.ResolveScenarioTracker;\n+import mekhq.campaign.againstTheBot.enums.AtBLanceRole;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.event.StratconDeploymentEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.force.Lance;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier.EventTiming;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconFacility.FacilityType;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.unit.Unit;\n+\n+/**\n+ * This class contains \"rules\" logic for the AtB-Stratcon state\n+ * @author NickAragua\n+ */\n+public class StratconRulesManager {\n+    /**\n+     * What makes a particular lance eligible to be reinforcements for a scenario\n+     */\n+    public enum ReinforcementEligibilityType {\n+        /**\n+         * Nothing\n+         */\n+        None,\n+\n+        /**\n+         * Lance is already deployed to the track\n+         */\n+        ChainedScenario,\n+\n+        /**\n+         * We pay a support point or convert a victory point to a support point\n+         */\n+        SupportPoint,\n+\n+        /**\n+         * The lance's deployment orders are \"Fight\"\n+         */\n+        FightLance\n+    }\n+\n+    /**\n+     * This function potentially generates non-player-initiated scenarios for the given track.\n+     */\n+    public static void generateScenariosForTrack(Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // maps scenarios to force IDs\n+        List<StratconScenario> generatedScenarios = new ArrayList<>();\n+        boolean autoAssignLances = contract.getCommandRights() == AtBContract.COM_INTEGRATED;\n+\n+        // get this list just so we have it available\n+        List<Integer> availableForceIDs = getAvailableForceIDs(campaign);\n+        Map<MapLocation, List<Integer>> sortedAvailableForceIDs = sortForcesByMapType(availableForceIDs, campaign);\n+\n+        // make X rolls, where X is the number of required lances for the track\n+        // that's the chance to spawn a scenario.\n+        // if a scenario occurs, then we pick a random non-deployed lance and use it to drive the opfor generation later\n+        // once we've determined that scenarios occur, we loop through the ones that we generated\n+        // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all\n+        for (int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            int targetNum = calculateScenarioOdds(track, contract, false);\n+            \n+            // if we haven't already used all the player forces and are required to randomly generate a scenario\n+            if (!availableForceIDs.isEmpty() && (Compute.randomInt(100) <= targetNum)) {\n+                // pick random coordinates and force to drive the scenario\n+                int x = Compute.randomInt(track.getWidth());\n+                int y = Compute.randomInt(track.getHeight());\n+\n+                StratconCoords scenarioCoords = new StratconCoords(x, y);\n+\n+                // if forces are already assigned to these coordinates, use those instead\n+                // of randomly-selected ones\n+                if (track.getAssignedCoordForces().containsKey(scenarioCoords)) {\n+                    StratconScenario scenario = generateScenarioForExistingForces(scenarioCoords,\n+                            track.getAssignedCoordForces().get(scenarioCoords), \n+                            contract, campaign, track);\n+                    generatedScenarios.add(scenario);\n+                    continue;\n+                }\n+                \n+                // otherwise, pick a random force from the avail\n+                int randomForceIndex = Compute.randomInt(availableForceIDs.size());\n+                int randomForceID = availableForceIDs.get(randomForceIndex);\n+                \n+                // remove the force from the available lists so we don't designate it as primary twice\n+                availableForceIDs.remove(randomForceIndex);\n+\n+                // we want to remove the actual int with the value, not the value at the index\n+                sortedAvailableForceIDs.get(MapLocation.AllGroundTerrain).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.LowAtmosphere).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.Space).remove((Integer) randomForceID);\n+\n+                // two scenarios on the same coordinates wind up increasing in size\n+                if (track.getScenarios().containsKey(scenarioCoords)) {\n+                    track.getScenarios().get(scenarioCoords).incrementRequiredPlayerLances();\n+                    assignAppropriateExtraForceToScenario(track.getScenarios().get(scenarioCoords), sortedAvailableForceIDs);\n+                    continue;\n+                }\n+\n+                StratconScenario scenario = setupScenario(scenarioCoords, randomForceID, campaign, contract, track);\n+                generatedScenarios.add(scenario);\n+\n+                // if we're auto-assigning lances, deploy the force to the track as well\n+                if (autoAssignLances) {\n+                    processForceDeployment(scenarioCoords, randomForceID, campaign, track, false);\n+                }\n+            }\n+        }\n+\n+        // if under liaison command, pick a random scenario from the ones generated\n+        // to set as required and attach liaison\n+        if (contract.getCommandRights() == AtBContract.COM_LIAISON) {\n+        \tStratconScenario randomScenario = Utilities.getRandomItem(generatedScenarios);\n+        \trandomScenario.setRequiredScenario(true);\n+            setAttachedUnitsModifier(randomScenario, contract);\n+        }\n+\n+        // now, we loop through all the scenarios we set up\n+        // and generate the opfors / events / etc\n+        // if not auto-assigning lances, we then back out the lance assignments.\n+        for (StratconScenario scenario : generatedScenarios) {\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+\n+            if(!autoAssignLances && !scenario.ignoreForceAutoAssignment()) {\n+                for(int forceID : scenario.getPlayerTemplateForceIDs()) {\n+                    scenario.getBackingScenario().removeForce(forceID);\n+                }\n+\n+                scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                track.addScenario(scenario);\n+            } else {\n+                commitPrimaryForces(campaign, scenario, track);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Given a set of force IDs and coordinates, generate a scenario\n+     * Useful for when we want to generate scenarios \n+     * for forces already deployed to a track\n+     */\n+    public static StratconScenario generateScenarioForExistingForces(StratconCoords scenarioCoords, \n+            Set<Integer> forceIDs, AtBContract contract, Campaign campaign, StratconTrackState track) {\n+        boolean firstForce = true;\n+        StratconScenario scenario = null;\n+        \n+        for (int forceID : forceIDs) {\n+            if (firstForce) {\n+                scenario = setupScenario(scenarioCoords, forceID, campaign, contract, track);\n+                firstForce = false;\n+            } else {\n+                scenario.incrementRequiredPlayerLances();\n+                scenario.addPrimaryForce(forceID);\n+            }\n+        }\n+        \n+        // this is theoretically possible if forceIDs is passed in as null - not likely in practice\n+        // but might as well, to future-proof.\n+        if (scenario != null) {\n+            scenario.setIgnoreForceAutoAssignment(true);\n+        }\n+        \n+        return scenario;\n+    }\n+\n+    /**\n+     * Deploys a force to the given coordinates on the given track as a result of explicit player action.\n+     */\n+    public static void deployForceToCoords(StratconCoords coords, int forceID, \n+            Campaign campaign, AtBContract contract, StratconTrackState track, boolean sticky) {\n+        // the following things should happen:\n+        // 1. call to \"process force deployment\", which reveals fog of war in or around the coords, depending on force role\n+        // 2. if coords are a hostile facility, we get a facility mission\n+        // 3. if coords are empty, we *may* get a mission\n+\n+        processForceDeployment(coords, forceID, campaign, track, sticky);\n+\n+        // don't create a scenario on top of allied facilities\n+        StratconFacility facility = track.getFacility(coords);\n+        boolean isNonAlliedFacility = (facility != null) && (facility.getOwner() != ForceAlignment.Allied);\n+        int targetNum = calculateScenarioOdds(track, contract, true);\n+        boolean spawnScenario = (facility == null) && (Compute.randomInt(100) <= targetNum);\n+\n+        if (isNonAlliedFacility || spawnScenario) {\n+            StratconScenario scenario = setupScenario(coords, forceID, campaign, contract, track);\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            commitPrimaryForces(campaign, scenario, track);\n+        }\n+    }\n+\n+    /**\n+     * Logic to set up a scenario\n+     */\n+    private static StratconScenario setupScenario(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        StratconScenario scenario = null;\n+\n+        if (track.getFacilities().containsKey(coords)) {\n+            StratconFacility facility = track.getFacility(coords);\n+            boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+            ScenarioTemplate template = StratconScenarioFactory.getFacilityScenario(alliedFacility);\n+            scenario = generateScenario(campaign, contract, track, forceID, coords, template);\n+            setupFacilityScenario(scenario, facility);\n+        } else {\n+            scenario = generateScenario(campaign, contract, track, forceID, coords);\n+\n+            // we may generate a facility scenario randomly - if so, do the facility-related stuff\n+            // and add a new facility to the track\n+            if (scenario.getBackingScenario().getTemplate().isFacilityScenario()) {\n+                StratconFacility facility = scenario.getBackingScenario().getTemplate().isHostileFacility() ?\n+                        StratconFacilityFactory.getRandomHostileFacility() : StratconFacilityFactory.getRandomAlliedFacility();\n+                facility.setVisible(true);\n+                track.addFacility(coords, facility);\n+                setupFacilityScenario(scenario, facility);\n+            }\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * carries out tasks relevant to facility scenarios\n+     */\n+    private static void setupFacilityScenario(StratconScenario scenario, StratconFacility facility) {\n+        // this includes:\n+        // for hostile facilities\n+        // - add a destroy objective (always the option to level the facility)\n+        // - add a capture objective (always the option to capture the facility)\n+        // - if so indicated by parameter, roll a random hostile facility objective and add it if not capture/destroy\n+        // for allied facilities\n+        // - add a defend objective (always the option to defend the facility)\n+        // - if so indicated by parameter, roll a random allied facility objective and add it if not defend\n+        AtBScenarioModifier objectiveModifier = null;\n+        boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+\n+        if (alliedFacility) {\n+            objectiveModifier = AtBScenarioModifier.getRandomAlliedFacilityModifier();\n+        } else {\n+            objectiveModifier = AtBScenarioModifier.getRandomHostileFacilityModifier();\n+        }\n+\n+        if (objectiveModifier != null) {\n+            scenario.getBackingScenario().addScenarioModifier(objectiveModifier);\n+            scenario.getBackingScenario().setName(String.format(\"%s - %s - %s\",\n+                    facility.getFacilityType(), alliedFacility ? \"Allied\" : \"Hostile\", objectiveModifier.getModifierName()));\n+        }\n+\n+        // add the \"fixed\" hostile facility modifiers after the primary ones\n+        if (!alliedFacility) {\n+            for(AtBScenarioModifier modifier : AtBScenarioModifier.getRequiredHostileFacilityModifiers()) {\n+                if(!scenario.getBackingScenario().alreadyHasModifier(modifier)) {\n+                    scenario.getBackingScenario().addScenarioModifier(modifier);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void processFacilityEffects(StratconTrackState track) {\n+        // TODO: these are \"weekly\"? effects that a stratcon facility has on the campaign/track state\n+        // currrently, that's\n+        // supply depot - allied - +1 sp\n+        // supply depot - hostile - +5% BV budget to all scenarios on track (shared modifier, so should be implemented there)\n+        // data center - allied - +1% star league cache contract (don't implement yet, but...)\n+        // data center - hostile - +5% scenario odds in track\n+        // industrial center - allied - all scenarios here have THIS IS COMING OUT OF YOUR PAYCHECK modifier\n+        // orbital defense - allied - sets 'no hostile aircraft' flag for track\n+        // orbital defense - hostile - sets 'no allied aircraft' flag for track\n+        // early warning system - allied - sets 'intercept allied base attacks' flag for track\n+        // early warning system - hostile - sets 'intercept hostile base attacks' flag for track\n+    }\n+\n+    /**\n+     * Process the deployment of a force to the given coordinates on the given track.\n+     */\n+    public static void processForceDeployment(StratconCoords coords, int forceID, \n+            Campaign campaign, StratconTrackState track, boolean sticky) {\n+        track.getRevealedCoords().add(coords);\n+        StratconFacility facility = track.getFacility(coords);\n+        if (facility != null) {\n+            facility.setVisible(true);\n+        }\n+\n+        if (campaign.getLances().get(forceID).getRole() == AtBLanceRole.SCOUTING) {\n+            for(int direction = 0; direction < 6; direction++) {\n+                StratconCoords checkCoords = coords.translate(direction);\n+\n+                facility = track.getFacility(checkCoords);\n+                if(facility != null) {\n+                    facility.setVisible(true);\n+                }\n+\n+                track.getRevealedCoords().add(coords.translate(direction));\n+            }\n+        }\n+\n+        // the force may be located in other places on the track - clear it out\n+        track.unassignForce(forceID);\n+        track.assignForce(forceID, coords, campaign.getLocalDate(), sticky);\n+        MekHQ.triggerEvent(new StratconDeploymentEvent(campaign.getForce(forceID)));\n+    }\n+\n+    /**\n+     * Worker function that processes the effects of deploying a reinforcement force to a scenario\n+     */\n+    public static boolean processReinforcementDeployment(ReinforcementEligibilityType reinforcementType,\n+            StratconCampaignState campaignState, StratconScenario scenario, Campaign campaign) {\n+        // if the force is already deployed to the track, we're done\n+        // if the force is a fight lance or we're using a support point\n+        // if there is an SP to burn, burn it and we're done\n+        // if there is a VP to burn, burn it and we're done\n+        // now, roll 2d6 + lance commander tactics\n+        // 9+ = deploy\n+        // 6+ = deploy, apply negative modifier to scenario\n+        // 2+ = fail to deploy, apply negative modifier to scenario; if fight lance, treat as 6+\n+\n+        if ((reinforcementType == ReinforcementEligibilityType.FightLance) ||\n+                (reinforcementType == ReinforcementEligibilityType.SupportPoint)) {\n+\n+            if (campaignState.getSupportPoints() > 0) {\n+                campaignState.useSupportPoint();\n+                return true;\n+            } else if (campaignState.getVictoryPoints() > 0) {\n+                campaignState.updateVictoryPoints(-1);\n+                return true;\n+            }\n+\n+            int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+            int roll = Compute.d6(2);\n+            int result = roll + tactics;\n+\n+            StringBuilder reportStatus = new StringBuilder();\n+            reportStatus.append(String.format(\"Attempting to reinforce scenario %s without SP/VP, roll 2d6 + %d: %d\",\n+                    scenario.getName(), tactics, result));\n+\n+            // fail to reinforce\n+            if ((result < 6) && (reinforcementType != ReinforcementEligibilityType.FightLance)) {\n+                reportStatus.append(\" - reinforcement attempt failed.\");\n+                campaign.addReport(reportStatus.toString());\n+                return false;\n+            // succeed but get an extra negative event added to the scenario\n+            } else if (result < 9) {\n+                MapLocation mapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+                AtBScenarioModifier scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+\n+                // keep rolling until we get an applicable one\n+                // TODO: have the AtBScenarioModifier sort these out instead for performance?\n+                while (scenarioModifier.getEventTiming() != EventTiming.PostForceGeneration) {\n+                    scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+                }\n+\n+                scenarioModifier.processModifier(scenario.getBackingScenario(), campaign, EventTiming.PostForceGeneration);\n+\n+                reportStatus.append(String.format(\" - reinforcement attempt succeeded; extra negative modifier (%s) applied to scenario.\",\n+                        scenarioModifier.getModifierName()));\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            // succeed without reservation\n+            } else {\n+                reportStatus.append(\" - reinforcement attempt succeeded;\");\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            }\n+        } else if (reinforcementType == ReinforcementEligibilityType.None) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Assigns a force to the scenario such that the majority of the force can be deployed\n+     */\n+    private static void assignAppropriateExtraForceToScenario(StratconScenario scenario,\n+            Map<MapLocation, List<Integer>> sortedAvailableForceIDs) {\n+        // the goal of this function is to avoid assigning ground units to air battles\n+        // and ground units/conventional fighters to space battle\n+\n+        List<MapLocation> mapLocations = new ArrayList<>();\n+        mapLocations.add(MapLocation.Space); // can always add ASFs\n+\n+        MapLocation scenarioMapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+\n+        if (scenarioMapLocation == MapLocation.LowAtmosphere) {\n+            mapLocations.add(MapLocation.LowAtmosphere); // can add conventional fighters to ground or low atmo battles\n+        }\n+\n+        if ((scenarioMapLocation == MapLocation.AllGroundTerrain) ||\n+                (scenarioMapLocation == MapLocation.SpecificGroundTerrain)) {\n+            mapLocations.add(MapLocation.AllGroundTerrain); // can only add ground units to ground battles\n+        }\n+\n+        MapLocation selectedLocation = mapLocations.get(Compute.randomInt(mapLocations.size()));\n+        List<Integer> forceIDs = sortedAvailableForceIDs.get(selectedLocation);\n+        int forceIndex = Compute.randomInt(forceIDs.size());\n+        int forceID = forceIDs.get(forceIndex);\n+        forceIDs.remove(forceIndex);\n+\n+        scenario.addPrimaryForce(forceID);\n+    }\n+\n+    /**\n+     * Worker function that \"locks in\" a scenario -\n+     * Adds it to the campaign so it's visible in the briefing room,\n+     * adds it to the track\n+     *\n+     */\n+    public static void commitPrimaryForces(Campaign campaign, StratconScenario scenario, StratconTrackState trackState) {\n+        trackState.addScenario(scenario);\n+\n+        // set up dates for the scenario if doesn't have them already\n+        if (scenario.getDeploymentDate() == null) {\n+            scenario.setDeploymentDate(campaign.getLocalDate());\n+        }\n+\n+        if (scenario.getActionDate() == null) {\n+            scenario.setActionDate(campaign.getLocalDate());\n+        }\n+\n+        if(scenario.getReturnDate() == null) {\n+            scenario.setReturnDate(campaign.getLocalDate().plusDays(trackState.getDeploymentTime()));\n+        }\n+\n+        // set the # of rerolls based on the actual lance assigned.\n+        int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+        scenario.getBackingScenario().setRerolls(tactics);\n+        // The number of defensive points available to a force entering a scenario is\n+        // 2 x tactics. By default, those points are spent on conventional minefields.\n+        if (commanderLanceHasDefensiveAssignment(scenario.getBackingScenario(), campaign)) {\n+            scenario.setNumDefensivePoints(tactics * 2);\n+            scenario.updateMinefieldCount(Minefield.TYPE_CONVENTIONAL, tactics * 2);\n+        }\n+\n+        for (int forceID : scenario.getPlayerTemplateForceIDs()) {\n+            Force force = campaign.getForce(forceID);\n+            force.clearScenarioIds(campaign, true);\n+            force.setScenarioId(scenario.getBackingScenarioID());\n+        }\n+\n+        scenario.commitPrimaryForces();\n+    }\n+\n+    /**\n+     * Utility method to determine if the current scenario's force commander\n+     * is on defence\n+     */\n+    private static boolean commanderLanceHasDefensiveAssignment(AtBDynamicScenario scenario, Campaign campaign) {\n+        Unit commanderUnit = scenario.getLanceCommander(campaign).getUnit();\n+        Lance lance = campaign.getLances().get(commanderUnit.getForceId());\n+\n+        if ((lance != null) && (lance.getRole() == AtBLanceRole.DEFENCE)) {\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * A hackish worker function that takes the given list of force IDs and\n+     * separates it into three sets;\n+     * one of forces that can be \"primary\" on a ground map\n+     * one of forces that can be \"primary\" on an atmospheric map\n+     * one of forces that can be \"primary\" in a space map\n+     * @param forceIDs List of force IDs to check\n+     * @return Sorted hash map\n+     */\n+    private static Map<MapLocation, List<Integer>> sortForcesByMapType(List<Integer> forceIDs, Campaign campaign) {\n+        Map<MapLocation, List<Integer>> retVal = new HashMap<>();\n+\n+        retVal.put(MapLocation.AllGroundTerrain, new ArrayList<>());\n+        retVal.put(MapLocation.LowAtmosphere, new ArrayList<>());\n+        retVal.put(MapLocation.Space, new ArrayList<>());\n+\n+        for (int forceID : forceIDs) {\n+            switch(campaign.getForce(forceID).getPrimaryUnitType(campaign)) {\n+            case UnitType.BATTLE_ARMOR:\n+            case UnitType.INFANTRY:\n+            case UnitType.MEK:\n+            case UnitType.TANK:\n+            case UnitType.PROTOMEK:\n+            case UnitType.VTOL:\n+                retVal.get(MapLocation.AllGroundTerrain).add(forceID);\n+                break;\n+            case UnitType.AERO:\n+                retVal.get(MapLocation.Space).add(forceID);\n+                // intentional fallthrough here, ASFs can go to atmospheric maps too\n+            case UnitType.CONV_FIGHTER:\n+                retVal.get(MapLocation.LowAtmosphere).add(forceID);\n+                break;\n+            }\n+        }\n+\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * Determine whether the user should be nagged about unresolved scenarios on AtB Stratcon tracks.\n+     * @param campaign Campaign to check.\n+     * @return An informative string containing the reasons the user was nagged.\n+     */\n+    public static String nagUnresolvedContacts(Campaign campaign) {\n+        StringBuilder sb = new StringBuilder();\n+\n+        // check every track attached to an active contract for unresolved scenarios\n+        // to which the player must deploy forces today\n+        for (AtBContract contract : campaign.getActiveAtBContracts()) {\n+            if (contract.getStratconCampaignState() == null) {\n+                continue;\n+            }\n+            \n+            for (StratconTrackState track : contract.getStratconCampaignState().getTracks()) {\n+                for (StratconScenario scenario : track.getScenarios().values()) {\n+                    if (scenario.getCurrentState() == ScenarioState.UNRESOLVED &&\n+                            campaign.getLocalDate().equals(scenario.getDeploymentDate())) {\n+                        // \"scenario name, track name\"\n+                        sb.append(String.format(\"%s, %s\\n\", scenario.getName(), track.getDisplayableName()));\n+                    }\n+                }\n+            }\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track.\n+     * Also registers it with the track and campaign.\n+     */\n+    private static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords) {\n+        int unitType = campaign.getForce(forceID).getPrimaryUnitType(campaign);\n+        ScenarioTemplate template = StratconScenarioFactory.getRandomScenario(unitType);\n+        // useful for debugging specific scenario types\n+        //ScenarioTemplate template = StratconScenarioFactory.getSpecificScenario(\"Hostile Facility.xml\");\n+\n+        return generateScenario(campaign, contract, track, forceID, coords, template);\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track,\n+     * using the given template. Also registers it with the campaign.\n+     */\n+    static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords, ScenarioTemplate template) {\n+        StratconScenario scenario = new StratconScenario();\n+        \n+        AtBDynamicScenario backingScenario = AtBDynamicScenarioFactory.initializeScenarioFromTemplate(template, contract, campaign);        \n+        scenario.setBackingScenario(backingScenario);\n+        scenario.setCoords(coords);\n+        \n+        // by default, certain conditions may make this bigger\n+        scenario.setRequiredPlayerLances(1);\n+\n+        // do an appropriate allied force if the contract calls for it\n+        // do any attached or integrated units\n+        setAlliedForceModifier(scenario, contract);\n+        setAttachedUnitsModifier(scenario, contract);\n+        applyFacilityModifiers(scenario, track, coords);\n+        applyGlobalModifiers(scenario, contract.getStratconCampaignState());\n+\n+        if ((contract.getCommandRights() == AtBContract.COM_HOUSE) ||\n+                (contract.getCommandRights() == AtBContract.COM_INTEGRATED)) {\n+            scenario.setRequiredScenario(true);\n+        }\n+\n+        AtBDynamicScenarioFactory.setScenarioModifiers(scenario.getBackingScenario());\n+        scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+        setScenarioDates(track, campaign, scenario);\n+        \n+        // the backing scenario ID must be updated after registering the backing scenario \n+        // with the campaign, so that the stratcon - backing scenario association is maintained\n+        // registering the scenario with the campaign should be done after setting\n+        // dates, otherwise, the report messages for new scenarios look weird\n+        campaign.addScenario(backingScenario, contract);\n+        scenario.setBackingScenarioID(backingScenario.getId());\n+        \n+        if (forceID > Force.FORCE_NONE) {\n+            scenario.addPrimaryForce(forceID);\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * Apply global scenario modifiers from campaign state to given scenario.\n+     */\n+    private static void applyGlobalModifiers(StratconScenario scenario, StratconCampaignState campaignState) {\n+        for (String modifierName : campaignState.getGlobalScenarioModifiers()) {\n+            AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierName);\n+\n+            if (modifier == null) {\n+                MekHQ.getLogger().error(String.format(\"Modifier %s not found; ignoring\", modifierName));\n+                continue;\n+            }\n+\n+            scenario.getBackingScenario().addScenarioModifier(modifier);\n+        }\n+    }\n+\n+    /**\n+     * Applies scenario modifiers from the current track to the given scenario.\n+     * @param scenario\n+     * @param track\n+     */\n+    private static void applyFacilityModifiers(StratconScenario scenario, StratconTrackState track, StratconCoords coords) {\n+        // loop through all the facilities on the track\n+        // if a facility has been revealed, then it has a 100% chance to apply its effect\n+        // if a facility has not been revealed, then it has a x% chance to apply its effect\n+        // if a facility is on the the scenario coordinates the it applies the local effects\n+        for (StratconCoords facilityCoords : track.getFacilities().keySet()) {\n+            boolean scenarioAtFacility = facilityCoords.equals(coords);\n+            StratconFacility facility = track.getFacilities().get(facilityCoords);\n+            List<String> modifierIDs = new ArrayList<>();\n+\n+            if (scenarioAtFacility) {\n+                modifierIDs = facility.getLocalModifiers();\n+            } else if (facility.isVisible() || (Compute.randomInt(100) <= facility.getAggroRating())) {\n+                modifierIDs = facility.getSharedModifiers();\n+            }\n+\n+            for (String modifierID : modifierIDs) {\n+                AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierID);\n+                if(modifier == null) {\n+                    MekHQ.getLogger().error(String.format(\"Modifier %s not found for facility %s\", modifierID, facility.getFormattedDisplayableName()));\n+                    continue;\n+                }\n+\n+                scenario.getBackingScenario().addScenarioModifier(modifier);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set up the appropriate primary allied force modifier, if any\n+     * @param contract The scenario's contract.\n+     */\n+    private static void setAlliedForceModifier(StratconScenario scenario, AtBContract contract) {\n+        int alliedUnitOdds = 0;\n+\n+        // first, we determine the odds of having an allied unit present\n+        // TODO: move this override out to the contract definition\n+        if (contract.getMissionType() == AtBContract.MT_RELIEFDUTY) {\n+            alliedUnitOdds = 50;\n+        } else {\n+            switch(contract.getCommandRights()) {\n+                case AtBContract.COM_INTEGRATED:\n+                    alliedUnitOdds = 50;\n+                    break;\n+                case AtBContract.COM_HOUSE:\n+                    alliedUnitOdds = 30;\n+                    break;\n+                case AtBContract.COM_LIAISON:\n+                    alliedUnitOdds = 10;\n+                    break;\n+            }\n+        }\n+\n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+\n+        // if an allied unit is present, then we want to make sure that it's ground units\n+        // for ground battles\n+        if (Compute.randomInt(100) <= alliedUnitOdds) {\n+            if((backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+               (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space)) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_ALLIED_AIR_UNITS));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_ALLIED_GROUND_UNITS));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set the 'attached' units modifier for the current scenario (integrated, house, liaison),\n+     * and make sure we're not deploying ground units to an air scenario\n+     * @param contract The scenario's contract\n+     */\n+    public static void setAttachedUnitsModifier(StratconScenario scenario, AtBContract contract) {\n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+        boolean airBattle = (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+                (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space);\n+\n+        // if we're on cadre duty, we're getting three trainees, period\n+        if (contract.getMissionType() == AtBContract.MT_CADREDUTY) {\n+            if (airBattle) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_TRAINEES_AIR));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_TRAINEES_GROUND));\n+            }\n+            return;\n+        }\n+\n+        // if we're under non-independent command rights, a supervisor may come along\n+        switch (contract.getCommandRights()) {\n+            case AtBContract.COM_INTEGRATED:\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(airBattle \n+                        ? MekHqConstants.SCENARIO_MODIFIER_INTEGRATED_UNITS_AIR\n+                        : MekHqConstants.SCENARIO_MODIFIER_INTEGRATED_UNITS_GROUND));\n+                break;\n+            case AtBContract.COM_HOUSE:\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(airBattle \n+                        ? MekHqConstants.SCENARIO_MODIFIER_HOUSE_CO_AIR\n+                        : MekHqConstants.SCENARIO_MODIFIER_HOUSE_CO_GROUND));\n+                break;\n+            case AtBContract.COM_LIAISON:\n+                if (scenario.isRequiredScenario()) {\n+                    backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(airBattle \n+                            ? MekHqConstants.SCENARIO_MODIFIER_LIAISON_AIR\n+                            : MekHqConstants.SCENARIO_MODIFIER_LIAISON_GROUND));\n+                }\n+                break;\n+        }\n+    }\n+\n+    /**\n+     * Worker function that sets scenario deploy/battle/return dates based on the track's properties and current campaign date\n+     */\n+    private static void setScenarioDates(StratconTrackState track, Campaign campaign, StratconScenario scenario) {\n+     // set up deployment day, battle day, return day here\n+        // safety code to prevent attempts to generate random int with upper bound of 0 which is apparently illegal\n+        int deploymentDay = track.getDeploymentTime() < 7 ? Compute.randomInt(7 - track.getDeploymentTime()) : 0;\n+        int battleDay = deploymentDay + (track.getDeploymentTime() > 0 ? Compute.randomInt(track.getDeploymentTime()) : 0);\n+        int returnDay = deploymentDay + track.getDeploymentTime();\n+\n+        LocalDate deploymentDate = campaign.getLocalDate();\n+        deploymentDate.plusDays(deploymentDay);\n+        LocalDate battleDate = campaign.getLocalDate();\n+        deploymentDate.plusDays(battleDay);\n+        LocalDate returnDate = campaign.getLocalDate();\n+        returnDate.plusDays(returnDay);\n+\n+        scenario.setDeploymentDate(deploymentDate);\n+        scenario.setActionDate(battleDate);\n+        scenario.setReturnDate(returnDate);\n+    }\n+\n+    /**\n+     * Helper function that determines if the unit type specified in the given scenario force template\n+     * would start out airborne on a ground map (hot dropped units aside)\n+     */\n+    private static boolean unitTypeIsAirborne(ScenarioForceTemplate template) {\n+        int unitType = template.getAllowedUnitType();\n+\n+        return (unitType == UnitType.AERO ||\n+                unitType == UnitType.CONV_FIGHTER ||\n+                unitType == UnitType.DROPSHIP ||\n+                unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_MIX) &&\n+                template.getStartingAltitude() > 0;\n+    }\n+\n+    /**\n+     * Determines whether the force in question has the same primary unit type as the force template.\n+     * @return Whether or not the unit types match.\n+     */\n+    public static boolean forceCompositionMatchesDeclaredUnitType(int primaryUnitType, int unitType, boolean reinforcements) {\n+        // special cases are \"ATB_MIX\" and \"ATB_AERO_MIX\", which encompass multiple unit types\n+        if (unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_MIX) {\n+            // \"AtB mix\" is usually ground units, but air units can sub in\n+            return primaryUnitType == UnitType.MEK ||\n+                    primaryUnitType == UnitType.TANK ||\n+                    primaryUnitType == UnitType.INFANTRY ||\n+                    primaryUnitType == UnitType.BATTLE_ARMOR ||\n+                    primaryUnitType == UnitType.PROTOMEK ||\n+                    primaryUnitType == UnitType.VTOL ||\n+                    (primaryUnitType == UnitType.AERO) && reinforcements ||\n+                    (primaryUnitType == UnitType.CONV_FIGHTER) && reinforcements;\n+        } else if (unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_AERO_MIX) {\n+            return primaryUnitType == UnitType.AERO ||\n+                    primaryUnitType == UnitType.CONV_FIGHTER;\n+        } else {\n+            return primaryUnitType == unitType;\n+        }\n+    }\n+\n+    /**\n+     * This is a set of all force IDs for forces that can be deployed to a scenario.\n+     * @param campaign Current campaign\n+     * @return Set of available force IDs.\n+     */\n+    public static List<Integer> getAvailableForceIDs(Campaign campaign) {\n+        List<Integer> retVal = new ArrayList<>();\n+\n+        // first, we gather a set of all forces that are already deployed to a track so we eliminate those later\n+        Set<Integer> forcesInTracks = new HashSet<>();\n+        for (Contract contract : campaign.getActiveContracts()) {\n+            if (contract instanceof AtBContract) {\n+                for (StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    forcesInTracks.addAll(track.getAssignedForceCoords().keySet());\n+                }\n+            }\n+        }\n+\n+        // now, we get all the forces that qualify as \"lances\", and filter out those that are\n+        // deployed to a scenario and not in a track already\n+        for (int key : campaign.getLances().keySet()) {\n+            Force force = campaign.getForce(key);\n+            if ((force != null) &&\n+                    !force.isDeployed() &&\n+                    !forcesInTracks.contains(force.getId())) {\n+                retVal.add(force.getId());\n+            }\n+        }\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * This is a list of all force IDs for forces that can be deployed to a scenario in the given force template\n+     * a) have not been assigned to a track\n+     * b) are combat-capable\n+     * c) are not deployed to a scenario\n+     * d) if attempting to deploy as reinforcements, haven't already failed to deploy\n+     */\n+    public static List<Integer> getAvailableForceIDs(int unitType, Campaign campaign, StratconTrackState currentTrack,\n+            boolean reinforcements, @Nullable StratconScenario currentScenario) {\n+        List<Integer> retVal = new ArrayList<>();\n+\n+        Set<Integer> forcesInTracks = new HashSet<>();\n+        // assemble a set of all force IDs that are currently assigned to tracks that are not this one\n+        for (Contract contract : campaign.getActiveContracts()) {\n+            if (contract instanceof AtBContract) {\n+                for (StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    if ((track != currentTrack) || !reinforcements) {\n+                        forcesInTracks.addAll(track.getAssignedForceCoords().keySet());\n+                    }\n+                }\n+            }\n+        }\n+        \n+        // if there's an existing scenario and we're doing reinforcements,\n+        // prevent forces that failed to deploy from trying to deploy again\n+        if (reinforcements && (currentScenario != null)) {\n+            forcesInTracks.addAll(currentScenario.getFailedReinforcements());\n+        }\n+\n+        for (int key : campaign.getLances().keySet()) {\n+            Force force = campaign.getForce(key);\n+\n+            if (force == null) {\n+                continue;\n+            }\n+\n+            int primaryUnitType = force.getPrimaryUnitType(campaign);\n+            if (!force.isDeployed() &&\n+                    (force.getScenarioId() <= 0) &&\n+                    !force.getUnits().isEmpty() &&\n+                    !forcesInTracks.contains(force.getId()) &&\n+                    forceCompositionMatchesDeclaredUnitType(primaryUnitType, unitType, reinforcements)) {\n+                retVal.add(force.getId());\n+            }\n+        }\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * Returns a list of individual units eligible for deployment in scenarios run by \"Defend\" lances\n+     * @return List of unit IDs.\n+     */\n+    public static List<Unit> getEligibleDefensiveUnits(Campaign campaign) {\n+        List<Unit> retVal = new ArrayList<>();\n+\n+        for (Unit u : campaign.getUnits()) {\n+            // \"defensive\" units are infantry, battle armor and (Weisman help you) gun emplacements\n+        \t// and also said unit should be intact/alive/etc\n+        \tboolean isEligibleInfantry = \n+        \t\t\t((u.getEntity().getUnitType() == UnitType.INFANTRY) ||\n+                    (u.getEntity().getUnitType() == UnitType.BATTLE_ARMOR)) &&\n+                    !u.isUnmanned();\n+        \t\n+        \tboolean isEligibleGunEmplacement = u.getEntity().getUnitType() == UnitType.GUN_EMPLACEMENT;\n+        \t\n+        \tif ((isEligibleInfantry || isEligibleGunEmplacement) && \n+            \t\t!u.isDeployed() &&\n+                    !u.isMothballed() &&\n+                    u.isFunctional()) {\n+\n+                // this is a little inefficient, but probably there aren't too many active AtB contracts at a time\n+                for (AtBContract contract : campaign.getActiveAtBContracts()) {\n+                    if (contract.getStratconCampaignState().isForceDeployedHere(u.getForceId())) {\n+                        continue;\n+                    }\n+                }\n+\n+                retVal.add(u);\n+            }\n+        }\n+\n+        return retVal;\n+    }\n+    \n+    /**\n+     * Returns a list of individual units eligible for deployment in scenarios\n+     * that result from the lance leader having a leadership score\n+     * @return List of unit IDs.\n+     */\n+    public static List<Unit> getEligibleLeadershipUnits(Campaign campaign, Set<Integer> forceIDs) {\n+        List<Unit> retVal = new ArrayList<>();\n+\n+        // The criteria are as follows:\n+        // - unit is of a different unit type than the primary unit type of the force \n+        // - unit has a lower BV than the force's lowest BV unit\n+        \n+        Integer lowestBV = getLowestBV(campaign, forceIDs);\n+        \n+        // no units assigned, the rest is meaningless.\n+        if (lowestBV == null) {\n+            return retVal;\n+        }\n+        \n+        int primaryUnitType = getPrimaryUnitType(campaign, forceIDs);\n+        \n+        for (Unit u : campaign.getUnits()) {\n+            if ((primaryUnitType != u.getEntity().getUnitType()) &&\n+                    !u.isDeployed() &&\n+                    !u.isMothballed() &&\n+                    u.isFunctional() &&\n+                    (u.getEntity().calculateBattleValue() < lowestBV) &&\n+                    !isUnitDeployedToStratCon(u)) {\n+                retVal.add(u);\n+            }\n+        }\n+\n+        return retVal;\n+    }\n+    \n+    /**\n+     * Check if the unit's force (if one exists) has been deployed to a StratCon track\n+     */\n+    public static boolean isUnitDeployedToStratCon(Unit u) {\n+        if (!u.getCampaign().getCampaignOptions().getUseStratCon()) {\n+            return false;\n+        }\n+        \n+        //this is a little inefficient, but probably there aren't too many active AtB contracts at a time\n+        for (AtBContract contract : u.getCampaign().getActiveAtBContracts()) {\n+            if (contract.getStratconCampaignState().isForceDeployedHere(u.getForceId())) {\n+                return true;\n+            }\n+        }\n+        \n+        return false;\n+    }\n+    \n+    /**\n+     * Given a campaign and a list of force IDs, calculate the unit with the lowest BV.\n+     */\n+    private static Integer getLowestBV(Campaign campaign, Set<Integer> forceIDs) {\n+        Integer lowestBV = null;\n+        \n+        for (int forceID : forceIDs) {\n+            Force force = campaign.getForce(forceID);\n+            if (force == null) {\n+                continue;\n+            }\n+            \n+            for (UUID id : force.getUnits()) {\n+                if (campaign.getUnit(id) == null) {\n+                    continue;\n+                }\n+                \n+                int currentBV = campaign.getUnit(id).getEntity().calculateBattleValue();\n+                \n+                if ((lowestBV == null) || (currentBV < lowestBV)) {\n+                    lowestBV = currentBV;\n+                }\n+            }\n+        }\n+        \n+        return lowestBV;\n+    }\n+    \n+    /**\n+     * Calculates the majority unit type for the forces given the IDs.\n+     */\n+    private static int getPrimaryUnitType(Campaign campaign, Set<Integer> forceIDs) {\n+        Map<Integer, Integer> unitTypeBuckets = new TreeMap<>();\n+        int biggestBucketID = -1;\n+        int biggestBucketCount = 0;\n+        \n+        for (int forceID : forceIDs) {\n+            Force force = campaign.getForce(forceID);\n+            if (force == null) {\n+                continue;\n+            }\n+        \n+            for (UUID id : force.getUnits()) {\n+                Unit unit = campaign.getUnit(id);\n+                if ((unit == null) || \n+                        (unit.getEntity() == null)) {\n+                    continue;\n+                }\n+                \n+                int unitType = unit.getEntity().getUnitType();\n+    \n+                unitTypeBuckets.merge(unitType, 1, (oldCount, value) -> oldCount + value);\n+                \n+                if (unitTypeBuckets.get(unitType) > biggestBucketCount) {\n+                    biggestBucketCount = unitTypeBuckets.get(unitType);\n+                    biggestBucketID = unitType;\n+                }\n+            }\n+        }\n+        \n+        return biggestBucketID;\n+    }\n+\n+    /**\n+     * Determines what rules to use when deploying a force for reinforcements to the given track.\n+     */\n+    public static ReinforcementEligibilityType getReinforcementType(int forceID,\n+            StratconTrackState trackState, Campaign campaign) {\n+        // if the force is currently deployed to the track, it'll be able to deploy \"for free\"\n+        if (trackState.isForceDeployed(forceID)) {\n+            return ReinforcementEligibilityType.ChainedScenario;\n+        }\n+\n+        // if the force is in 'fight' stance, it'll be able to deploy using 'fight lance' rules\n+        if (campaign.getLances().containsKey(forceID) &&\n+                campaign.getLances().get(forceID).getRole() == AtBLanceRole.FIGHTING) {\n+            return ReinforcementEligibilityType.FightLance;\n+        }\n+\n+        // if the force is deployed elsewhere, it cannot be deployed as reinforcements\n+        for (Contract contract : campaign.getActiveContracts()) {\n+            if(contract instanceof AtBContract) {\n+                for(StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    if(track != trackState && track.getAssignedForceCoords().containsKey(forceID)) {", "originalCommit": "b36d9fa6bf982c7b833b1ac0a0473d37f6e84760", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTE5MjY0NA==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r615192644", "bodyText": "Suggested change", "author": "Windchild292", "createdAt": "2021-04-17T02:12:59Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1404 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.UUID;\n+\n+import megamek.common.Compute;\n+import megamek.common.Minefield;\n+import megamek.common.UnitType;\n+import megamek.common.annotations.Nullable;\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.Utilities;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.ResolveScenarioTracker;\n+import mekhq.campaign.againstTheBot.enums.AtBLanceRole;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.event.StratconDeploymentEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.force.Lance;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier.EventTiming;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconFacility.FacilityType;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.unit.Unit;\n+\n+/**\n+ * This class contains \"rules\" logic for the AtB-Stratcon state\n+ * @author NickAragua\n+ */\n+public class StratconRulesManager {\n+    /**\n+     * What makes a particular lance eligible to be reinforcements for a scenario\n+     */\n+    public enum ReinforcementEligibilityType {\n+        /**\n+         * Nothing\n+         */\n+        None,\n+\n+        /**\n+         * Lance is already deployed to the track\n+         */\n+        ChainedScenario,\n+\n+        /**\n+         * We pay a support point or convert a victory point to a support point\n+         */\n+        SupportPoint,\n+\n+        /**\n+         * The lance's deployment orders are \"Fight\"\n+         */\n+        FightLance\n+    }\n+\n+    /**\n+     * This function potentially generates non-player-initiated scenarios for the given track.\n+     */\n+    public static void generateScenariosForTrack(Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // maps scenarios to force IDs\n+        List<StratconScenario> generatedScenarios = new ArrayList<>();\n+        boolean autoAssignLances = contract.getCommandRights() == AtBContract.COM_INTEGRATED;\n+\n+        // get this list just so we have it available\n+        List<Integer> availableForceIDs = getAvailableForceIDs(campaign);\n+        Map<MapLocation, List<Integer>> sortedAvailableForceIDs = sortForcesByMapType(availableForceIDs, campaign);\n+\n+        // make X rolls, where X is the number of required lances for the track\n+        // that's the chance to spawn a scenario.\n+        // if a scenario occurs, then we pick a random non-deployed lance and use it to drive the opfor generation later\n+        // once we've determined that scenarios occur, we loop through the ones that we generated\n+        // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all\n+        for (int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            int targetNum = calculateScenarioOdds(track, contract, false);\n+            \n+            // if we haven't already used all the player forces and are required to randomly generate a scenario\n+            if (!availableForceIDs.isEmpty() && (Compute.randomInt(100) <= targetNum)) {\n+                // pick random coordinates and force to drive the scenario\n+                int x = Compute.randomInt(track.getWidth());\n+                int y = Compute.randomInt(track.getHeight());\n+\n+                StratconCoords scenarioCoords = new StratconCoords(x, y);\n+\n+                // if forces are already assigned to these coordinates, use those instead\n+                // of randomly-selected ones\n+                if (track.getAssignedCoordForces().containsKey(scenarioCoords)) {\n+                    StratconScenario scenario = generateScenarioForExistingForces(scenarioCoords,\n+                            track.getAssignedCoordForces().get(scenarioCoords), \n+                            contract, campaign, track);\n+                    generatedScenarios.add(scenario);\n+                    continue;\n+                }\n+                \n+                // otherwise, pick a random force from the avail\n+                int randomForceIndex = Compute.randomInt(availableForceIDs.size());\n+                int randomForceID = availableForceIDs.get(randomForceIndex);\n+                \n+                // remove the force from the available lists so we don't designate it as primary twice\n+                availableForceIDs.remove(randomForceIndex);\n+\n+                // we want to remove the actual int with the value, not the value at the index\n+                sortedAvailableForceIDs.get(MapLocation.AllGroundTerrain).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.LowAtmosphere).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.Space).remove((Integer) randomForceID);\n+\n+                // two scenarios on the same coordinates wind up increasing in size\n+                if (track.getScenarios().containsKey(scenarioCoords)) {\n+                    track.getScenarios().get(scenarioCoords).incrementRequiredPlayerLances();\n+                    assignAppropriateExtraForceToScenario(track.getScenarios().get(scenarioCoords), sortedAvailableForceIDs);\n+                    continue;\n+                }\n+\n+                StratconScenario scenario = setupScenario(scenarioCoords, randomForceID, campaign, contract, track);\n+                generatedScenarios.add(scenario);\n+\n+                // if we're auto-assigning lances, deploy the force to the track as well\n+                if (autoAssignLances) {\n+                    processForceDeployment(scenarioCoords, randomForceID, campaign, track, false);\n+                }\n+            }\n+        }\n+\n+        // if under liaison command, pick a random scenario from the ones generated\n+        // to set as required and attach liaison\n+        if (contract.getCommandRights() == AtBContract.COM_LIAISON) {\n+        \tStratconScenario randomScenario = Utilities.getRandomItem(generatedScenarios);\n+        \trandomScenario.setRequiredScenario(true);\n+            setAttachedUnitsModifier(randomScenario, contract);\n+        }\n+\n+        // now, we loop through all the scenarios we set up\n+        // and generate the opfors / events / etc\n+        // if not auto-assigning lances, we then back out the lance assignments.\n+        for (StratconScenario scenario : generatedScenarios) {\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+\n+            if(!autoAssignLances && !scenario.ignoreForceAutoAssignment()) {\n+                for(int forceID : scenario.getPlayerTemplateForceIDs()) {\n+                    scenario.getBackingScenario().removeForce(forceID);\n+                }\n+\n+                scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                track.addScenario(scenario);\n+            } else {\n+                commitPrimaryForces(campaign, scenario, track);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Given a set of force IDs and coordinates, generate a scenario\n+     * Useful for when we want to generate scenarios \n+     * for forces already deployed to a track\n+     */\n+    public static StratconScenario generateScenarioForExistingForces(StratconCoords scenarioCoords, \n+            Set<Integer> forceIDs, AtBContract contract, Campaign campaign, StratconTrackState track) {\n+        boolean firstForce = true;\n+        StratconScenario scenario = null;\n+        \n+        for (int forceID : forceIDs) {\n+            if (firstForce) {\n+                scenario = setupScenario(scenarioCoords, forceID, campaign, contract, track);\n+                firstForce = false;\n+            } else {\n+                scenario.incrementRequiredPlayerLances();\n+                scenario.addPrimaryForce(forceID);\n+            }\n+        }\n+        \n+        // this is theoretically possible if forceIDs is passed in as null - not likely in practice\n+        // but might as well, to future-proof.\n+        if (scenario != null) {\n+            scenario.setIgnoreForceAutoAssignment(true);\n+        }\n+        \n+        return scenario;\n+    }\n+\n+    /**\n+     * Deploys a force to the given coordinates on the given track as a result of explicit player action.\n+     */\n+    public static void deployForceToCoords(StratconCoords coords, int forceID, \n+            Campaign campaign, AtBContract contract, StratconTrackState track, boolean sticky) {\n+        // the following things should happen:\n+        // 1. call to \"process force deployment\", which reveals fog of war in or around the coords, depending on force role\n+        // 2. if coords are a hostile facility, we get a facility mission\n+        // 3. if coords are empty, we *may* get a mission\n+\n+        processForceDeployment(coords, forceID, campaign, track, sticky);\n+\n+        // don't create a scenario on top of allied facilities\n+        StratconFacility facility = track.getFacility(coords);\n+        boolean isNonAlliedFacility = (facility != null) && (facility.getOwner() != ForceAlignment.Allied);\n+        int targetNum = calculateScenarioOdds(track, contract, true);\n+        boolean spawnScenario = (facility == null) && (Compute.randomInt(100) <= targetNum);\n+\n+        if (isNonAlliedFacility || spawnScenario) {\n+            StratconScenario scenario = setupScenario(coords, forceID, campaign, contract, track);\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            commitPrimaryForces(campaign, scenario, track);\n+        }\n+    }\n+\n+    /**\n+     * Logic to set up a scenario\n+     */\n+    private static StratconScenario setupScenario(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        StratconScenario scenario = null;\n+\n+        if (track.getFacilities().containsKey(coords)) {\n+            StratconFacility facility = track.getFacility(coords);\n+            boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+            ScenarioTemplate template = StratconScenarioFactory.getFacilityScenario(alliedFacility);\n+            scenario = generateScenario(campaign, contract, track, forceID, coords, template);\n+            setupFacilityScenario(scenario, facility);\n+        } else {\n+            scenario = generateScenario(campaign, contract, track, forceID, coords);\n+\n+            // we may generate a facility scenario randomly - if so, do the facility-related stuff\n+            // and add a new facility to the track\n+            if (scenario.getBackingScenario().getTemplate().isFacilityScenario()) {\n+                StratconFacility facility = scenario.getBackingScenario().getTemplate().isHostileFacility() ?\n+                        StratconFacilityFactory.getRandomHostileFacility() : StratconFacilityFactory.getRandomAlliedFacility();\n+                facility.setVisible(true);\n+                track.addFacility(coords, facility);\n+                setupFacilityScenario(scenario, facility);\n+            }\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * carries out tasks relevant to facility scenarios\n+     */\n+    private static void setupFacilityScenario(StratconScenario scenario, StratconFacility facility) {\n+        // this includes:\n+        // for hostile facilities\n+        // - add a destroy objective (always the option to level the facility)\n+        // - add a capture objective (always the option to capture the facility)\n+        // - if so indicated by parameter, roll a random hostile facility objective and add it if not capture/destroy\n+        // for allied facilities\n+        // - add a defend objective (always the option to defend the facility)\n+        // - if so indicated by parameter, roll a random allied facility objective and add it if not defend\n+        AtBScenarioModifier objectiveModifier = null;\n+        boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+\n+        if (alliedFacility) {\n+            objectiveModifier = AtBScenarioModifier.getRandomAlliedFacilityModifier();\n+        } else {\n+            objectiveModifier = AtBScenarioModifier.getRandomHostileFacilityModifier();\n+        }\n+\n+        if (objectiveModifier != null) {\n+            scenario.getBackingScenario().addScenarioModifier(objectiveModifier);\n+            scenario.getBackingScenario().setName(String.format(\"%s - %s - %s\",\n+                    facility.getFacilityType(), alliedFacility ? \"Allied\" : \"Hostile\", objectiveModifier.getModifierName()));\n+        }\n+\n+        // add the \"fixed\" hostile facility modifiers after the primary ones\n+        if (!alliedFacility) {\n+            for(AtBScenarioModifier modifier : AtBScenarioModifier.getRequiredHostileFacilityModifiers()) {\n+                if(!scenario.getBackingScenario().alreadyHasModifier(modifier)) {\n+                    scenario.getBackingScenario().addScenarioModifier(modifier);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void processFacilityEffects(StratconTrackState track) {\n+        // TODO: these are \"weekly\"? effects that a stratcon facility has on the campaign/track state\n+        // currrently, that's\n+        // supply depot - allied - +1 sp\n+        // supply depot - hostile - +5% BV budget to all scenarios on track (shared modifier, so should be implemented there)\n+        // data center - allied - +1% star league cache contract (don't implement yet, but...)\n+        // data center - hostile - +5% scenario odds in track\n+        // industrial center - allied - all scenarios here have THIS IS COMING OUT OF YOUR PAYCHECK modifier\n+        // orbital defense - allied - sets 'no hostile aircraft' flag for track\n+        // orbital defense - hostile - sets 'no allied aircraft' flag for track\n+        // early warning system - allied - sets 'intercept allied base attacks' flag for track\n+        // early warning system - hostile - sets 'intercept hostile base attacks' flag for track\n+    }\n+\n+    /**\n+     * Process the deployment of a force to the given coordinates on the given track.\n+     */\n+    public static void processForceDeployment(StratconCoords coords, int forceID, \n+            Campaign campaign, StratconTrackState track, boolean sticky) {\n+        track.getRevealedCoords().add(coords);\n+        StratconFacility facility = track.getFacility(coords);\n+        if (facility != null) {\n+            facility.setVisible(true);\n+        }\n+\n+        if (campaign.getLances().get(forceID).getRole() == AtBLanceRole.SCOUTING) {\n+            for(int direction = 0; direction < 6; direction++) {\n+                StratconCoords checkCoords = coords.translate(direction);\n+\n+                facility = track.getFacility(checkCoords);\n+                if(facility != null) {\n+                    facility.setVisible(true);\n+                }\n+\n+                track.getRevealedCoords().add(coords.translate(direction));\n+            }\n+        }\n+\n+        // the force may be located in other places on the track - clear it out\n+        track.unassignForce(forceID);\n+        track.assignForce(forceID, coords, campaign.getLocalDate(), sticky);\n+        MekHQ.triggerEvent(new StratconDeploymentEvent(campaign.getForce(forceID)));\n+    }\n+\n+    /**\n+     * Worker function that processes the effects of deploying a reinforcement force to a scenario\n+     */\n+    public static boolean processReinforcementDeployment(ReinforcementEligibilityType reinforcementType,\n+            StratconCampaignState campaignState, StratconScenario scenario, Campaign campaign) {\n+        // if the force is already deployed to the track, we're done\n+        // if the force is a fight lance or we're using a support point\n+        // if there is an SP to burn, burn it and we're done\n+        // if there is a VP to burn, burn it and we're done\n+        // now, roll 2d6 + lance commander tactics\n+        // 9+ = deploy\n+        // 6+ = deploy, apply negative modifier to scenario\n+        // 2+ = fail to deploy, apply negative modifier to scenario; if fight lance, treat as 6+\n+\n+        if ((reinforcementType == ReinforcementEligibilityType.FightLance) ||\n+                (reinforcementType == ReinforcementEligibilityType.SupportPoint)) {\n+\n+            if (campaignState.getSupportPoints() > 0) {\n+                campaignState.useSupportPoint();\n+                return true;\n+            } else if (campaignState.getVictoryPoints() > 0) {\n+                campaignState.updateVictoryPoints(-1);\n+                return true;\n+            }\n+\n+            int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+            int roll = Compute.d6(2);\n+            int result = roll + tactics;\n+\n+            StringBuilder reportStatus = new StringBuilder();\n+            reportStatus.append(String.format(\"Attempting to reinforce scenario %s without SP/VP, roll 2d6 + %d: %d\",\n+                    scenario.getName(), tactics, result));\n+\n+            // fail to reinforce\n+            if ((result < 6) && (reinforcementType != ReinforcementEligibilityType.FightLance)) {\n+                reportStatus.append(\" - reinforcement attempt failed.\");\n+                campaign.addReport(reportStatus.toString());\n+                return false;\n+            // succeed but get an extra negative event added to the scenario\n+            } else if (result < 9) {\n+                MapLocation mapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+                AtBScenarioModifier scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+\n+                // keep rolling until we get an applicable one\n+                // TODO: have the AtBScenarioModifier sort these out instead for performance?\n+                while (scenarioModifier.getEventTiming() != EventTiming.PostForceGeneration) {\n+                    scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+                }\n+\n+                scenarioModifier.processModifier(scenario.getBackingScenario(), campaign, EventTiming.PostForceGeneration);\n+\n+                reportStatus.append(String.format(\" - reinforcement attempt succeeded; extra negative modifier (%s) applied to scenario.\",\n+                        scenarioModifier.getModifierName()));\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            // succeed without reservation\n+            } else {\n+                reportStatus.append(\" - reinforcement attempt succeeded;\");\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            }\n+        } else if (reinforcementType == ReinforcementEligibilityType.None) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Assigns a force to the scenario such that the majority of the force can be deployed\n+     */\n+    private static void assignAppropriateExtraForceToScenario(StratconScenario scenario,\n+            Map<MapLocation, List<Integer>> sortedAvailableForceIDs) {\n+        // the goal of this function is to avoid assigning ground units to air battles\n+        // and ground units/conventional fighters to space battle\n+\n+        List<MapLocation> mapLocations = new ArrayList<>();\n+        mapLocations.add(MapLocation.Space); // can always add ASFs\n+\n+        MapLocation scenarioMapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+\n+        if (scenarioMapLocation == MapLocation.LowAtmosphere) {\n+            mapLocations.add(MapLocation.LowAtmosphere); // can add conventional fighters to ground or low atmo battles\n+        }\n+\n+        if ((scenarioMapLocation == MapLocation.AllGroundTerrain) ||\n+                (scenarioMapLocation == MapLocation.SpecificGroundTerrain)) {\n+            mapLocations.add(MapLocation.AllGroundTerrain); // can only add ground units to ground battles\n+        }\n+\n+        MapLocation selectedLocation = mapLocations.get(Compute.randomInt(mapLocations.size()));\n+        List<Integer> forceIDs = sortedAvailableForceIDs.get(selectedLocation);\n+        int forceIndex = Compute.randomInt(forceIDs.size());\n+        int forceID = forceIDs.get(forceIndex);\n+        forceIDs.remove(forceIndex);\n+\n+        scenario.addPrimaryForce(forceID);\n+    }\n+\n+    /**\n+     * Worker function that \"locks in\" a scenario -\n+     * Adds it to the campaign so it's visible in the briefing room,\n+     * adds it to the track\n+     *\n+     */\n+    public static void commitPrimaryForces(Campaign campaign, StratconScenario scenario, StratconTrackState trackState) {\n+        trackState.addScenario(scenario);\n+\n+        // set up dates for the scenario if doesn't have them already\n+        if (scenario.getDeploymentDate() == null) {\n+            scenario.setDeploymentDate(campaign.getLocalDate());\n+        }\n+\n+        if (scenario.getActionDate() == null) {\n+            scenario.setActionDate(campaign.getLocalDate());\n+        }\n+\n+        if(scenario.getReturnDate() == null) {\n+            scenario.setReturnDate(campaign.getLocalDate().plusDays(trackState.getDeploymentTime()));\n+        }\n+\n+        // set the # of rerolls based on the actual lance assigned.\n+        int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+        scenario.getBackingScenario().setRerolls(tactics);\n+        // The number of defensive points available to a force entering a scenario is\n+        // 2 x tactics. By default, those points are spent on conventional minefields.\n+        if (commanderLanceHasDefensiveAssignment(scenario.getBackingScenario(), campaign)) {\n+            scenario.setNumDefensivePoints(tactics * 2);\n+            scenario.updateMinefieldCount(Minefield.TYPE_CONVENTIONAL, tactics * 2);\n+        }\n+\n+        for (int forceID : scenario.getPlayerTemplateForceIDs()) {\n+            Force force = campaign.getForce(forceID);\n+            force.clearScenarioIds(campaign, true);\n+            force.setScenarioId(scenario.getBackingScenarioID());\n+        }\n+\n+        scenario.commitPrimaryForces();\n+    }\n+\n+    /**\n+     * Utility method to determine if the current scenario's force commander\n+     * is on defence\n+     */\n+    private static boolean commanderLanceHasDefensiveAssignment(AtBDynamicScenario scenario, Campaign campaign) {\n+        Unit commanderUnit = scenario.getLanceCommander(campaign).getUnit();\n+        Lance lance = campaign.getLances().get(commanderUnit.getForceId());\n+\n+        if ((lance != null) && (lance.getRole() == AtBLanceRole.DEFENCE)) {\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * A hackish worker function that takes the given list of force IDs and\n+     * separates it into three sets;\n+     * one of forces that can be \"primary\" on a ground map\n+     * one of forces that can be \"primary\" on an atmospheric map\n+     * one of forces that can be \"primary\" in a space map\n+     * @param forceIDs List of force IDs to check\n+     * @return Sorted hash map\n+     */\n+    private static Map<MapLocation, List<Integer>> sortForcesByMapType(List<Integer> forceIDs, Campaign campaign) {\n+        Map<MapLocation, List<Integer>> retVal = new HashMap<>();\n+\n+        retVal.put(MapLocation.AllGroundTerrain, new ArrayList<>());\n+        retVal.put(MapLocation.LowAtmosphere, new ArrayList<>());\n+        retVal.put(MapLocation.Space, new ArrayList<>());\n+\n+        for (int forceID : forceIDs) {\n+            switch(campaign.getForce(forceID).getPrimaryUnitType(campaign)) {\n+            case UnitType.BATTLE_ARMOR:\n+            case UnitType.INFANTRY:\n+            case UnitType.MEK:\n+            case UnitType.TANK:\n+            case UnitType.PROTOMEK:\n+            case UnitType.VTOL:\n+                retVal.get(MapLocation.AllGroundTerrain).add(forceID);\n+                break;\n+            case UnitType.AERO:\n+                retVal.get(MapLocation.Space).add(forceID);\n+                // intentional fallthrough here, ASFs can go to atmospheric maps too\n+            case UnitType.CONV_FIGHTER:\n+                retVal.get(MapLocation.LowAtmosphere).add(forceID);\n+                break;\n+            }\n+        }\n+\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * Determine whether the user should be nagged about unresolved scenarios on AtB Stratcon tracks.\n+     * @param campaign Campaign to check.\n+     * @return An informative string containing the reasons the user was nagged.\n+     */\n+    public static String nagUnresolvedContacts(Campaign campaign) {\n+        StringBuilder sb = new StringBuilder();\n+\n+        // check every track attached to an active contract for unresolved scenarios\n+        // to which the player must deploy forces today\n+        for (AtBContract contract : campaign.getActiveAtBContracts()) {\n+            if (contract.getStratconCampaignState() == null) {\n+                continue;\n+            }\n+            \n+            for (StratconTrackState track : contract.getStratconCampaignState().getTracks()) {\n+                for (StratconScenario scenario : track.getScenarios().values()) {\n+                    if (scenario.getCurrentState() == ScenarioState.UNRESOLVED &&\n+                            campaign.getLocalDate().equals(scenario.getDeploymentDate())) {\n+                        // \"scenario name, track name\"\n+                        sb.append(String.format(\"%s, %s\\n\", scenario.getName(), track.getDisplayableName()));\n+                    }\n+                }\n+            }\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track.\n+     * Also registers it with the track and campaign.\n+     */\n+    private static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords) {\n+        int unitType = campaign.getForce(forceID).getPrimaryUnitType(campaign);\n+        ScenarioTemplate template = StratconScenarioFactory.getRandomScenario(unitType);\n+        // useful for debugging specific scenario types\n+        //ScenarioTemplate template = StratconScenarioFactory.getSpecificScenario(\"Hostile Facility.xml\");\n+\n+        return generateScenario(campaign, contract, track, forceID, coords, template);\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track,\n+     * using the given template. Also registers it with the campaign.\n+     */\n+    static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords, ScenarioTemplate template) {\n+        StratconScenario scenario = new StratconScenario();\n+        \n+        AtBDynamicScenario backingScenario = AtBDynamicScenarioFactory.initializeScenarioFromTemplate(template, contract, campaign);        \n+        scenario.setBackingScenario(backingScenario);\n+        scenario.setCoords(coords);\n+        \n+        // by default, certain conditions may make this bigger\n+        scenario.setRequiredPlayerLances(1);\n+\n+        // do an appropriate allied force if the contract calls for it\n+        // do any attached or integrated units\n+        setAlliedForceModifier(scenario, contract);\n+        setAttachedUnitsModifier(scenario, contract);\n+        applyFacilityModifiers(scenario, track, coords);\n+        applyGlobalModifiers(scenario, contract.getStratconCampaignState());\n+\n+        if ((contract.getCommandRights() == AtBContract.COM_HOUSE) ||\n+                (contract.getCommandRights() == AtBContract.COM_INTEGRATED)) {\n+            scenario.setRequiredScenario(true);\n+        }\n+\n+        AtBDynamicScenarioFactory.setScenarioModifiers(scenario.getBackingScenario());\n+        scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+        setScenarioDates(track, campaign, scenario);\n+        \n+        // the backing scenario ID must be updated after registering the backing scenario \n+        // with the campaign, so that the stratcon - backing scenario association is maintained\n+        // registering the scenario with the campaign should be done after setting\n+        // dates, otherwise, the report messages for new scenarios look weird\n+        campaign.addScenario(backingScenario, contract);\n+        scenario.setBackingScenarioID(backingScenario.getId());\n+        \n+        if (forceID > Force.FORCE_NONE) {\n+            scenario.addPrimaryForce(forceID);\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * Apply global scenario modifiers from campaign state to given scenario.\n+     */\n+    private static void applyGlobalModifiers(StratconScenario scenario, StratconCampaignState campaignState) {\n+        for (String modifierName : campaignState.getGlobalScenarioModifiers()) {\n+            AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierName);\n+\n+            if (modifier == null) {\n+                MekHQ.getLogger().error(String.format(\"Modifier %s not found; ignoring\", modifierName));\n+                continue;\n+            }\n+\n+            scenario.getBackingScenario().addScenarioModifier(modifier);\n+        }\n+    }\n+\n+    /**\n+     * Applies scenario modifiers from the current track to the given scenario.\n+     * @param scenario\n+     * @param track\n+     */\n+    private static void applyFacilityModifiers(StratconScenario scenario, StratconTrackState track, StratconCoords coords) {\n+        // loop through all the facilities on the track\n+        // if a facility has been revealed, then it has a 100% chance to apply its effect\n+        // if a facility has not been revealed, then it has a x% chance to apply its effect\n+        // if a facility is on the the scenario coordinates the it applies the local effects\n+        for (StratconCoords facilityCoords : track.getFacilities().keySet()) {\n+            boolean scenarioAtFacility = facilityCoords.equals(coords);\n+            StratconFacility facility = track.getFacilities().get(facilityCoords);\n+            List<String> modifierIDs = new ArrayList<>();\n+\n+            if (scenarioAtFacility) {\n+                modifierIDs = facility.getLocalModifiers();\n+            } else if (facility.isVisible() || (Compute.randomInt(100) <= facility.getAggroRating())) {\n+                modifierIDs = facility.getSharedModifiers();\n+            }\n+\n+            for (String modifierID : modifierIDs) {\n+                AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierID);\n+                if(modifier == null) {\n+                    MekHQ.getLogger().error(String.format(\"Modifier %s not found for facility %s\", modifierID, facility.getFormattedDisplayableName()));\n+                    continue;\n+                }\n+\n+                scenario.getBackingScenario().addScenarioModifier(modifier);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set up the appropriate primary allied force modifier, if any\n+     * @param contract The scenario's contract.\n+     */\n+    private static void setAlliedForceModifier(StratconScenario scenario, AtBContract contract) {\n+        int alliedUnitOdds = 0;\n+\n+        // first, we determine the odds of having an allied unit present\n+        // TODO: move this override out to the contract definition\n+        if (contract.getMissionType() == AtBContract.MT_RELIEFDUTY) {\n+            alliedUnitOdds = 50;\n+        } else {\n+            switch(contract.getCommandRights()) {\n+                case AtBContract.COM_INTEGRATED:\n+                    alliedUnitOdds = 50;\n+                    break;\n+                case AtBContract.COM_HOUSE:\n+                    alliedUnitOdds = 30;\n+                    break;\n+                case AtBContract.COM_LIAISON:\n+                    alliedUnitOdds = 10;\n+                    break;\n+            }\n+        }\n+\n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+\n+        // if an allied unit is present, then we want to make sure that it's ground units\n+        // for ground battles\n+        if (Compute.randomInt(100) <= alliedUnitOdds) {\n+            if((backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+               (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space)) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_ALLIED_AIR_UNITS));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_ALLIED_GROUND_UNITS));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set the 'attached' units modifier for the current scenario (integrated, house, liaison),\n+     * and make sure we're not deploying ground units to an air scenario\n+     * @param contract The scenario's contract\n+     */\n+    public static void setAttachedUnitsModifier(StratconScenario scenario, AtBContract contract) {\n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+        boolean airBattle = (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+                (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space);\n+\n+        // if we're on cadre duty, we're getting three trainees, period\n+        if (contract.getMissionType() == AtBContract.MT_CADREDUTY) {\n+            if (airBattle) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_TRAINEES_AIR));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_TRAINEES_GROUND));\n+            }\n+            return;\n+        }\n+\n+        // if we're under non-independent command rights, a supervisor may come along\n+        switch (contract.getCommandRights()) {\n+            case AtBContract.COM_INTEGRATED:\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(airBattle \n+                        ? MekHqConstants.SCENARIO_MODIFIER_INTEGRATED_UNITS_AIR\n+                        : MekHqConstants.SCENARIO_MODIFIER_INTEGRATED_UNITS_GROUND));\n+                break;\n+            case AtBContract.COM_HOUSE:\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(airBattle \n+                        ? MekHqConstants.SCENARIO_MODIFIER_HOUSE_CO_AIR\n+                        : MekHqConstants.SCENARIO_MODIFIER_HOUSE_CO_GROUND));\n+                break;\n+            case AtBContract.COM_LIAISON:\n+                if (scenario.isRequiredScenario()) {\n+                    backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(airBattle \n+                            ? MekHqConstants.SCENARIO_MODIFIER_LIAISON_AIR\n+                            : MekHqConstants.SCENARIO_MODIFIER_LIAISON_GROUND));\n+                }\n+                break;\n+        }\n+    }\n+\n+    /**\n+     * Worker function that sets scenario deploy/battle/return dates based on the track's properties and current campaign date\n+     */\n+    private static void setScenarioDates(StratconTrackState track, Campaign campaign, StratconScenario scenario) {\n+     // set up deployment day, battle day, return day here\n+        // safety code to prevent attempts to generate random int with upper bound of 0 which is apparently illegal\n+        int deploymentDay = track.getDeploymentTime() < 7 ? Compute.randomInt(7 - track.getDeploymentTime()) : 0;\n+        int battleDay = deploymentDay + (track.getDeploymentTime() > 0 ? Compute.randomInt(track.getDeploymentTime()) : 0);\n+        int returnDay = deploymentDay + track.getDeploymentTime();\n+\n+        LocalDate deploymentDate = campaign.getLocalDate();\n+        deploymentDate.plusDays(deploymentDay);\n+        LocalDate battleDate = campaign.getLocalDate();\n+        deploymentDate.plusDays(battleDay);\n+        LocalDate returnDate = campaign.getLocalDate();\n+        returnDate.plusDays(returnDay);\n+\n+        scenario.setDeploymentDate(deploymentDate);\n+        scenario.setActionDate(battleDate);\n+        scenario.setReturnDate(returnDate);\n+    }\n+\n+    /**\n+     * Helper function that determines if the unit type specified in the given scenario force template\n+     * would start out airborne on a ground map (hot dropped units aside)\n+     */\n+    private static boolean unitTypeIsAirborne(ScenarioForceTemplate template) {\n+        int unitType = template.getAllowedUnitType();\n+\n+        return (unitType == UnitType.AERO ||\n+                unitType == UnitType.CONV_FIGHTER ||\n+                unitType == UnitType.DROPSHIP ||\n+                unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_MIX) &&\n+                template.getStartingAltitude() > 0;\n+    }\n+\n+    /**\n+     * Determines whether the force in question has the same primary unit type as the force template.\n+     * @return Whether or not the unit types match.\n+     */\n+    public static boolean forceCompositionMatchesDeclaredUnitType(int primaryUnitType, int unitType, boolean reinforcements) {\n+        // special cases are \"ATB_MIX\" and \"ATB_AERO_MIX\", which encompass multiple unit types\n+        if (unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_MIX) {\n+            // \"AtB mix\" is usually ground units, but air units can sub in\n+            return primaryUnitType == UnitType.MEK ||\n+                    primaryUnitType == UnitType.TANK ||\n+                    primaryUnitType == UnitType.INFANTRY ||\n+                    primaryUnitType == UnitType.BATTLE_ARMOR ||\n+                    primaryUnitType == UnitType.PROTOMEK ||\n+                    primaryUnitType == UnitType.VTOL ||\n+                    (primaryUnitType == UnitType.AERO) && reinforcements ||\n+                    (primaryUnitType == UnitType.CONV_FIGHTER) && reinforcements;\n+        } else if (unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_AERO_MIX) {\n+            return primaryUnitType == UnitType.AERO ||\n+                    primaryUnitType == UnitType.CONV_FIGHTER;\n+        } else {\n+            return primaryUnitType == unitType;\n+        }\n+    }\n+\n+    /**\n+     * This is a set of all force IDs for forces that can be deployed to a scenario.\n+     * @param campaign Current campaign\n+     * @return Set of available force IDs.\n+     */\n+    public static List<Integer> getAvailableForceIDs(Campaign campaign) {\n+        List<Integer> retVal = new ArrayList<>();\n+\n+        // first, we gather a set of all forces that are already deployed to a track so we eliminate those later\n+        Set<Integer> forcesInTracks = new HashSet<>();\n+        for (Contract contract : campaign.getActiveContracts()) {\n+            if (contract instanceof AtBContract) {\n+                for (StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    forcesInTracks.addAll(track.getAssignedForceCoords().keySet());\n+                }\n+            }\n+        }\n+\n+        // now, we get all the forces that qualify as \"lances\", and filter out those that are\n+        // deployed to a scenario and not in a track already\n+        for (int key : campaign.getLances().keySet()) {\n+            Force force = campaign.getForce(key);\n+            if ((force != null) &&\n+                    !force.isDeployed() &&\n+                    !forcesInTracks.contains(force.getId())) {\n+                retVal.add(force.getId());\n+            }\n+        }\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * This is a list of all force IDs for forces that can be deployed to a scenario in the given force template\n+     * a) have not been assigned to a track\n+     * b) are combat-capable\n+     * c) are not deployed to a scenario\n+     * d) if attempting to deploy as reinforcements, haven't already failed to deploy\n+     */\n+    public static List<Integer> getAvailableForceIDs(int unitType, Campaign campaign, StratconTrackState currentTrack,\n+            boolean reinforcements, @Nullable StratconScenario currentScenario) {\n+        List<Integer> retVal = new ArrayList<>();\n+\n+        Set<Integer> forcesInTracks = new HashSet<>();\n+        // assemble a set of all force IDs that are currently assigned to tracks that are not this one\n+        for (Contract contract : campaign.getActiveContracts()) {\n+            if (contract instanceof AtBContract) {\n+                for (StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    if ((track != currentTrack) || !reinforcements) {\n+                        forcesInTracks.addAll(track.getAssignedForceCoords().keySet());\n+                    }\n+                }\n+            }\n+        }\n+        \n+        // if there's an existing scenario and we're doing reinforcements,\n+        // prevent forces that failed to deploy from trying to deploy again\n+        if (reinforcements && (currentScenario != null)) {\n+            forcesInTracks.addAll(currentScenario.getFailedReinforcements());\n+        }\n+\n+        for (int key : campaign.getLances().keySet()) {\n+            Force force = campaign.getForce(key);\n+\n+            if (force == null) {\n+                continue;\n+            }\n+\n+            int primaryUnitType = force.getPrimaryUnitType(campaign);\n+            if (!force.isDeployed() &&\n+                    (force.getScenarioId() <= 0) &&\n+                    !force.getUnits().isEmpty() &&\n+                    !forcesInTracks.contains(force.getId()) &&\n+                    forceCompositionMatchesDeclaredUnitType(primaryUnitType, unitType, reinforcements)) {\n+                retVal.add(force.getId());\n+            }\n+        }\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * Returns a list of individual units eligible for deployment in scenarios run by \"Defend\" lances\n+     * @return List of unit IDs.\n+     */\n+    public static List<Unit> getEligibleDefensiveUnits(Campaign campaign) {\n+        List<Unit> retVal = new ArrayList<>();\n+\n+        for (Unit u : campaign.getUnits()) {\n+            // \"defensive\" units are infantry, battle armor and (Weisman help you) gun emplacements\n+        \t// and also said unit should be intact/alive/etc\n+        \tboolean isEligibleInfantry = \n+        \t\t\t((u.getEntity().getUnitType() == UnitType.INFANTRY) ||\n+                    (u.getEntity().getUnitType() == UnitType.BATTLE_ARMOR)) &&\n+                    !u.isUnmanned();\n+        \t\n+        \tboolean isEligibleGunEmplacement = u.getEntity().getUnitType() == UnitType.GUN_EMPLACEMENT;\n+        \t\n+        \tif ((isEligibleInfantry || isEligibleGunEmplacement) && \n+            \t\t!u.isDeployed() &&\n+                    !u.isMothballed() &&\n+                    u.isFunctional()) {\n+\n+                // this is a little inefficient, but probably there aren't too many active AtB contracts at a time\n+                for (AtBContract contract : campaign.getActiveAtBContracts()) {\n+                    if (contract.getStratconCampaignState().isForceDeployedHere(u.getForceId())) {\n+                        continue;\n+                    }\n+                }\n+\n+                retVal.add(u);\n+            }\n+        }\n+\n+        return retVal;\n+    }\n+    \n+    /**\n+     * Returns a list of individual units eligible for deployment in scenarios\n+     * that result from the lance leader having a leadership score\n+     * @return List of unit IDs.\n+     */\n+    public static List<Unit> getEligibleLeadershipUnits(Campaign campaign, Set<Integer> forceIDs) {\n+        List<Unit> retVal = new ArrayList<>();\n+\n+        // The criteria are as follows:\n+        // - unit is of a different unit type than the primary unit type of the force \n+        // - unit has a lower BV than the force's lowest BV unit\n+        \n+        Integer lowestBV = getLowestBV(campaign, forceIDs);\n+        \n+        // no units assigned, the rest is meaningless.\n+        if (lowestBV == null) {\n+            return retVal;\n+        }\n+        \n+        int primaryUnitType = getPrimaryUnitType(campaign, forceIDs);\n+        \n+        for (Unit u : campaign.getUnits()) {\n+            if ((primaryUnitType != u.getEntity().getUnitType()) &&\n+                    !u.isDeployed() &&\n+                    !u.isMothballed() &&\n+                    u.isFunctional() &&\n+                    (u.getEntity().calculateBattleValue() < lowestBV) &&\n+                    !isUnitDeployedToStratCon(u)) {\n+                retVal.add(u);\n+            }\n+        }\n+\n+        return retVal;\n+    }\n+    \n+    /**\n+     * Check if the unit's force (if one exists) has been deployed to a StratCon track\n+     */\n+    public static boolean isUnitDeployedToStratCon(Unit u) {\n+        if (!u.getCampaign().getCampaignOptions().getUseStratCon()) {\n+            return false;\n+        }\n+        \n+        //this is a little inefficient, but probably there aren't too many active AtB contracts at a time\n+        for (AtBContract contract : u.getCampaign().getActiveAtBContracts()) {\n+            if (contract.getStratconCampaignState().isForceDeployedHere(u.getForceId())) {\n+                return true;\n+            }\n+        }\n+        \n+        return false;\n+    }\n+    \n+    /**\n+     * Given a campaign and a list of force IDs, calculate the unit with the lowest BV.\n+     */\n+    private static Integer getLowestBV(Campaign campaign, Set<Integer> forceIDs) {\n+        Integer lowestBV = null;\n+        \n+        for (int forceID : forceIDs) {\n+            Force force = campaign.getForce(forceID);\n+            if (force == null) {\n+                continue;\n+            }\n+            \n+            for (UUID id : force.getUnits()) {\n+                if (campaign.getUnit(id) == null) {\n+                    continue;\n+                }\n+                \n+                int currentBV = campaign.getUnit(id).getEntity().calculateBattleValue();\n+                \n+                if ((lowestBV == null) || (currentBV < lowestBV)) {\n+                    lowestBV = currentBV;\n+                }\n+            }\n+        }\n+        \n+        return lowestBV;\n+    }\n+    \n+    /**\n+     * Calculates the majority unit type for the forces given the IDs.\n+     */\n+    private static int getPrimaryUnitType(Campaign campaign, Set<Integer> forceIDs) {\n+        Map<Integer, Integer> unitTypeBuckets = new TreeMap<>();\n+        int biggestBucketID = -1;\n+        int biggestBucketCount = 0;\n+        \n+        for (int forceID : forceIDs) {\n+            Force force = campaign.getForce(forceID);\n+            if (force == null) {\n+                continue;\n+            }\n+        \n+            for (UUID id : force.getUnits()) {\n+                Unit unit = campaign.getUnit(id);\n+                if ((unit == null) || \n+                        (unit.getEntity() == null)) {\n+                    continue;\n+                }\n+                \n+                int unitType = unit.getEntity().getUnitType();\n+    \n+                unitTypeBuckets.merge(unitType, 1, (oldCount, value) -> oldCount + value);\n+                \n+                if (unitTypeBuckets.get(unitType) > biggestBucketCount) {\n+                    biggestBucketCount = unitTypeBuckets.get(unitType);\n+                    biggestBucketID = unitType;\n+                }\n+            }\n+        }\n+        \n+        return biggestBucketID;\n+    }\n+\n+    /**\n+     * Determines what rules to use when deploying a force for reinforcements to the given track.\n+     */\n+    public static ReinforcementEligibilityType getReinforcementType(int forceID,\n+            StratconTrackState trackState, Campaign campaign) {\n+        // if the force is currently deployed to the track, it'll be able to deploy \"for free\"\n+        if (trackState.isForceDeployed(forceID)) {\n+            return ReinforcementEligibilityType.ChainedScenario;\n+        }\n+\n+        // if the force is in 'fight' stance, it'll be able to deploy using 'fight lance' rules\n+        if (campaign.getLances().containsKey(forceID) &&\n+                campaign.getLances().get(forceID).getRole() == AtBLanceRole.FIGHTING) {\n+            return ReinforcementEligibilityType.FightLance;\n+        }\n+\n+        // if the force is deployed elsewhere, it cannot be deployed as reinforcements\n+        for (Contract contract : campaign.getActiveContracts()) {\n+            if(contract instanceof AtBContract) {\n+                for(StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    if(track != trackState && track.getAssignedForceCoords().containsKey(forceID)) {\n+                        return ReinforcementEligibilityType.None;\n+                    }\n+                }\n+            }\n+        }\n+\n+        // otherwise, the force requires support points / vps to deploy\n+        return ReinforcementEligibilityType.SupportPoint;\n+    }\n+    \n+    /**\n+     * Given a track and the current campaign state, and if the player is deploying\n+     * a force or not, figure out the odds of a scenario occuring.\n+     */\n+    public static int calculateScenarioOdds(StratconTrackState track, \n+            AtBContract contract, boolean playerDeployingForce) {\n+        // rules:\n+        // rout morale: 0%\n+        // very low morale: -10% when deploying forces to track, 0% attack\n+        // low morale: -5%\n+        // high morale: +5%\n+        // invincible: special case, let's do +10% for now\n+        int moraleModifier = 0;\n+        \n+        switch (contract.getMoraleLevel()) {\n+            case AtBContract.MORALE_ROUT:\n+                return 0;\n+            case AtBContract.MORALE_VERYLOW:\n+                if (playerDeployingForce) {\n+                    moraleModifier = -10;\n+                } else {\n+                    return 0;\n+                }\n+                break;\n+            case AtBContract.MORALE_LOW:\n+                moraleModifier = -5;\n+                break;\n+            case AtBContract.MORALE_HIGH:\n+                moraleModifier = 5;\n+                break;\n+            case AtBContract.MORALE_INVINCIBLE:\n+                moraleModifier = 10;\n+                break;\n+        }\n+        \n+        // facilities: for each hostile data center, add +5%\n+        // for each allied data center, subtract 5\n+        int dataCenterModifier = 0;\n+        for (StratconFacility facility : track.getFacilities().values()) {\n+            if (facility.getFacilityType() == FacilityType.DataCenter) {\n+                dataCenterModifier += facility.getOwner() == ForceAlignment.Allied ? -5 : 5;\n+            }\n+        }\n+            \n+        return track.getScenarioOdds() + moraleModifier + dataCenterModifier;\n+    }\n+\n+    /**\n+     * Removes the facility associated with the given scenario from the relevant track/\n+     */\n+    public static void updateFacilityForScenario(AtBScenario scenario, AtBContract contract, boolean destroy, boolean capture) {\n+        if (contract.getStratconCampaignState() == null) {\n+            return;\n+        }\n+\n+        // this is kind of kludgy, but there's currently no way to link a scenario back to its backing scenario\n+        // TODO: introduce mapping in contract or at least trackstate\n+        // basically, we're looping through all scenarios on all the contract's tracks\n+        // if we find one with the same ID as the one being resolved, that's our facility: get rid of it.\n+        for (StratconTrackState trackState : contract.getStratconCampaignState().getTracks()) {\n+            for (StratconCoords coords : trackState.getScenarios().keySet()) {\n+                StratconScenario potentialScenario = trackState.getScenario(coords);\n+                if (potentialScenario.getBackingScenarioID() == scenario.getId()) {\n+", "originalCommit": "b36d9fa6bf982c7b833b1ac0a0473d37f6e84760", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTE5Mjc3Ng==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r615192776", "bodyText": "? - especially the commented out code", "author": "Windchild292", "createdAt": "2021-04-17T02:14:38Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1404 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.UUID;\n+\n+import megamek.common.Compute;\n+import megamek.common.Minefield;\n+import megamek.common.UnitType;\n+import megamek.common.annotations.Nullable;\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.Utilities;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.ResolveScenarioTracker;\n+import mekhq.campaign.againstTheBot.enums.AtBLanceRole;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.event.StratconDeploymentEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.force.Lance;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier.EventTiming;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconFacility.FacilityType;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.unit.Unit;\n+\n+/**\n+ * This class contains \"rules\" logic for the AtB-Stratcon state\n+ * @author NickAragua\n+ */\n+public class StratconRulesManager {\n+    /**\n+     * What makes a particular lance eligible to be reinforcements for a scenario\n+     */\n+    public enum ReinforcementEligibilityType {\n+        /**\n+         * Nothing\n+         */\n+        None,\n+\n+        /**\n+         * Lance is already deployed to the track\n+         */\n+        ChainedScenario,\n+\n+        /**\n+         * We pay a support point or convert a victory point to a support point\n+         */\n+        SupportPoint,\n+\n+        /**\n+         * The lance's deployment orders are \"Fight\"\n+         */\n+        FightLance\n+    }\n+\n+    /**\n+     * This function potentially generates non-player-initiated scenarios for the given track.\n+     */\n+    public static void generateScenariosForTrack(Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // maps scenarios to force IDs\n+        List<StratconScenario> generatedScenarios = new ArrayList<>();\n+        boolean autoAssignLances = contract.getCommandRights() == AtBContract.COM_INTEGRATED;\n+\n+        // get this list just so we have it available\n+        List<Integer> availableForceIDs = getAvailableForceIDs(campaign);\n+        Map<MapLocation, List<Integer>> sortedAvailableForceIDs = sortForcesByMapType(availableForceIDs, campaign);\n+\n+        // make X rolls, where X is the number of required lances for the track\n+        // that's the chance to spawn a scenario.\n+        // if a scenario occurs, then we pick a random non-deployed lance and use it to drive the opfor generation later\n+        // once we've determined that scenarios occur, we loop through the ones that we generated\n+        // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all\n+        for (int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            int targetNum = calculateScenarioOdds(track, contract, false);\n+            \n+            // if we haven't already used all the player forces and are required to randomly generate a scenario\n+            if (!availableForceIDs.isEmpty() && (Compute.randomInt(100) <= targetNum)) {\n+                // pick random coordinates and force to drive the scenario\n+                int x = Compute.randomInt(track.getWidth());\n+                int y = Compute.randomInt(track.getHeight());\n+\n+                StratconCoords scenarioCoords = new StratconCoords(x, y);\n+\n+                // if forces are already assigned to these coordinates, use those instead\n+                // of randomly-selected ones\n+                if (track.getAssignedCoordForces().containsKey(scenarioCoords)) {\n+                    StratconScenario scenario = generateScenarioForExistingForces(scenarioCoords,\n+                            track.getAssignedCoordForces().get(scenarioCoords), \n+                            contract, campaign, track);\n+                    generatedScenarios.add(scenario);\n+                    continue;\n+                }\n+                \n+                // otherwise, pick a random force from the avail\n+                int randomForceIndex = Compute.randomInt(availableForceIDs.size());\n+                int randomForceID = availableForceIDs.get(randomForceIndex);\n+                \n+                // remove the force from the available lists so we don't designate it as primary twice\n+                availableForceIDs.remove(randomForceIndex);\n+\n+                // we want to remove the actual int with the value, not the value at the index\n+                sortedAvailableForceIDs.get(MapLocation.AllGroundTerrain).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.LowAtmosphere).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.Space).remove((Integer) randomForceID);\n+\n+                // two scenarios on the same coordinates wind up increasing in size\n+                if (track.getScenarios().containsKey(scenarioCoords)) {\n+                    track.getScenarios().get(scenarioCoords).incrementRequiredPlayerLances();\n+                    assignAppropriateExtraForceToScenario(track.getScenarios().get(scenarioCoords), sortedAvailableForceIDs);\n+                    continue;\n+                }\n+\n+                StratconScenario scenario = setupScenario(scenarioCoords, randomForceID, campaign, contract, track);\n+                generatedScenarios.add(scenario);\n+\n+                // if we're auto-assigning lances, deploy the force to the track as well\n+                if (autoAssignLances) {\n+                    processForceDeployment(scenarioCoords, randomForceID, campaign, track, false);\n+                }\n+            }\n+        }\n+\n+        // if under liaison command, pick a random scenario from the ones generated\n+        // to set as required and attach liaison\n+        if (contract.getCommandRights() == AtBContract.COM_LIAISON) {\n+        \tStratconScenario randomScenario = Utilities.getRandomItem(generatedScenarios);\n+        \trandomScenario.setRequiredScenario(true);\n+            setAttachedUnitsModifier(randomScenario, contract);\n+        }\n+\n+        // now, we loop through all the scenarios we set up\n+        // and generate the opfors / events / etc\n+        // if not auto-assigning lances, we then back out the lance assignments.\n+        for (StratconScenario scenario : generatedScenarios) {\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+\n+            if(!autoAssignLances && !scenario.ignoreForceAutoAssignment()) {\n+                for(int forceID : scenario.getPlayerTemplateForceIDs()) {\n+                    scenario.getBackingScenario().removeForce(forceID);\n+                }\n+\n+                scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                track.addScenario(scenario);\n+            } else {\n+                commitPrimaryForces(campaign, scenario, track);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Given a set of force IDs and coordinates, generate a scenario\n+     * Useful for when we want to generate scenarios \n+     * for forces already deployed to a track\n+     */\n+    public static StratconScenario generateScenarioForExistingForces(StratconCoords scenarioCoords, \n+            Set<Integer> forceIDs, AtBContract contract, Campaign campaign, StratconTrackState track) {\n+        boolean firstForce = true;\n+        StratconScenario scenario = null;\n+        \n+        for (int forceID : forceIDs) {\n+            if (firstForce) {\n+                scenario = setupScenario(scenarioCoords, forceID, campaign, contract, track);\n+                firstForce = false;\n+            } else {\n+                scenario.incrementRequiredPlayerLances();\n+                scenario.addPrimaryForce(forceID);\n+            }\n+        }\n+        \n+        // this is theoretically possible if forceIDs is passed in as null - not likely in practice\n+        // but might as well, to future-proof.\n+        if (scenario != null) {\n+            scenario.setIgnoreForceAutoAssignment(true);\n+        }\n+        \n+        return scenario;\n+    }\n+\n+    /**\n+     * Deploys a force to the given coordinates on the given track as a result of explicit player action.\n+     */\n+    public static void deployForceToCoords(StratconCoords coords, int forceID, \n+            Campaign campaign, AtBContract contract, StratconTrackState track, boolean sticky) {\n+        // the following things should happen:\n+        // 1. call to \"process force deployment\", which reveals fog of war in or around the coords, depending on force role\n+        // 2. if coords are a hostile facility, we get a facility mission\n+        // 3. if coords are empty, we *may* get a mission\n+\n+        processForceDeployment(coords, forceID, campaign, track, sticky);\n+\n+        // don't create a scenario on top of allied facilities\n+        StratconFacility facility = track.getFacility(coords);\n+        boolean isNonAlliedFacility = (facility != null) && (facility.getOwner() != ForceAlignment.Allied);\n+        int targetNum = calculateScenarioOdds(track, contract, true);\n+        boolean spawnScenario = (facility == null) && (Compute.randomInt(100) <= targetNum);\n+\n+        if (isNonAlliedFacility || spawnScenario) {\n+            StratconScenario scenario = setupScenario(coords, forceID, campaign, contract, track);\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            commitPrimaryForces(campaign, scenario, track);\n+        }\n+    }\n+\n+    /**\n+     * Logic to set up a scenario\n+     */\n+    private static StratconScenario setupScenario(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        StratconScenario scenario = null;\n+\n+        if (track.getFacilities().containsKey(coords)) {\n+            StratconFacility facility = track.getFacility(coords);\n+            boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+            ScenarioTemplate template = StratconScenarioFactory.getFacilityScenario(alliedFacility);\n+            scenario = generateScenario(campaign, contract, track, forceID, coords, template);\n+            setupFacilityScenario(scenario, facility);\n+        } else {\n+            scenario = generateScenario(campaign, contract, track, forceID, coords);\n+\n+            // we may generate a facility scenario randomly - if so, do the facility-related stuff\n+            // and add a new facility to the track\n+            if (scenario.getBackingScenario().getTemplate().isFacilityScenario()) {\n+                StratconFacility facility = scenario.getBackingScenario().getTemplate().isHostileFacility() ?\n+                        StratconFacilityFactory.getRandomHostileFacility() : StratconFacilityFactory.getRandomAlliedFacility();\n+                facility.setVisible(true);\n+                track.addFacility(coords, facility);\n+                setupFacilityScenario(scenario, facility);\n+            }\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * carries out tasks relevant to facility scenarios\n+     */\n+    private static void setupFacilityScenario(StratconScenario scenario, StratconFacility facility) {\n+        // this includes:\n+        // for hostile facilities\n+        // - add a destroy objective (always the option to level the facility)\n+        // - add a capture objective (always the option to capture the facility)\n+        // - if so indicated by parameter, roll a random hostile facility objective and add it if not capture/destroy\n+        // for allied facilities\n+        // - add a defend objective (always the option to defend the facility)\n+        // - if so indicated by parameter, roll a random allied facility objective and add it if not defend\n+        AtBScenarioModifier objectiveModifier = null;\n+        boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+\n+        if (alliedFacility) {\n+            objectiveModifier = AtBScenarioModifier.getRandomAlliedFacilityModifier();\n+        } else {\n+            objectiveModifier = AtBScenarioModifier.getRandomHostileFacilityModifier();\n+        }\n+\n+        if (objectiveModifier != null) {\n+            scenario.getBackingScenario().addScenarioModifier(objectiveModifier);\n+            scenario.getBackingScenario().setName(String.format(\"%s - %s - %s\",\n+                    facility.getFacilityType(), alliedFacility ? \"Allied\" : \"Hostile\", objectiveModifier.getModifierName()));\n+        }\n+\n+        // add the \"fixed\" hostile facility modifiers after the primary ones\n+        if (!alliedFacility) {\n+            for(AtBScenarioModifier modifier : AtBScenarioModifier.getRequiredHostileFacilityModifiers()) {\n+                if(!scenario.getBackingScenario().alreadyHasModifier(modifier)) {\n+                    scenario.getBackingScenario().addScenarioModifier(modifier);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void processFacilityEffects(StratconTrackState track) {\n+        // TODO: these are \"weekly\"? effects that a stratcon facility has on the campaign/track state\n+        // currrently, that's\n+        // supply depot - allied - +1 sp\n+        // supply depot - hostile - +5% BV budget to all scenarios on track (shared modifier, so should be implemented there)\n+        // data center - allied - +1% star league cache contract (don't implement yet, but...)\n+        // data center - hostile - +5% scenario odds in track\n+        // industrial center - allied - all scenarios here have THIS IS COMING OUT OF YOUR PAYCHECK modifier\n+        // orbital defense - allied - sets 'no hostile aircraft' flag for track\n+        // orbital defense - hostile - sets 'no allied aircraft' flag for track\n+        // early warning system - allied - sets 'intercept allied base attacks' flag for track\n+        // early warning system - hostile - sets 'intercept hostile base attacks' flag for track\n+    }\n+\n+    /**\n+     * Process the deployment of a force to the given coordinates on the given track.\n+     */\n+    public static void processForceDeployment(StratconCoords coords, int forceID, \n+            Campaign campaign, StratconTrackState track, boolean sticky) {\n+        track.getRevealedCoords().add(coords);\n+        StratconFacility facility = track.getFacility(coords);\n+        if (facility != null) {\n+            facility.setVisible(true);\n+        }\n+\n+        if (campaign.getLances().get(forceID).getRole() == AtBLanceRole.SCOUTING) {\n+            for(int direction = 0; direction < 6; direction++) {\n+                StratconCoords checkCoords = coords.translate(direction);\n+\n+                facility = track.getFacility(checkCoords);\n+                if(facility != null) {\n+                    facility.setVisible(true);\n+                }\n+\n+                track.getRevealedCoords().add(coords.translate(direction));\n+            }\n+        }\n+\n+        // the force may be located in other places on the track - clear it out\n+        track.unassignForce(forceID);\n+        track.assignForce(forceID, coords, campaign.getLocalDate(), sticky);\n+        MekHQ.triggerEvent(new StratconDeploymentEvent(campaign.getForce(forceID)));\n+    }\n+\n+    /**\n+     * Worker function that processes the effects of deploying a reinforcement force to a scenario\n+     */\n+    public static boolean processReinforcementDeployment(ReinforcementEligibilityType reinforcementType,\n+            StratconCampaignState campaignState, StratconScenario scenario, Campaign campaign) {\n+        // if the force is already deployed to the track, we're done\n+        // if the force is a fight lance or we're using a support point\n+        // if there is an SP to burn, burn it and we're done\n+        // if there is a VP to burn, burn it and we're done\n+        // now, roll 2d6 + lance commander tactics\n+        // 9+ = deploy\n+        // 6+ = deploy, apply negative modifier to scenario\n+        // 2+ = fail to deploy, apply negative modifier to scenario; if fight lance, treat as 6+\n+\n+        if ((reinforcementType == ReinforcementEligibilityType.FightLance) ||\n+                (reinforcementType == ReinforcementEligibilityType.SupportPoint)) {\n+\n+            if (campaignState.getSupportPoints() > 0) {\n+                campaignState.useSupportPoint();\n+                return true;\n+            } else if (campaignState.getVictoryPoints() > 0) {\n+                campaignState.updateVictoryPoints(-1);\n+                return true;\n+            }\n+\n+            int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+            int roll = Compute.d6(2);\n+            int result = roll + tactics;\n+\n+            StringBuilder reportStatus = new StringBuilder();\n+            reportStatus.append(String.format(\"Attempting to reinforce scenario %s without SP/VP, roll 2d6 + %d: %d\",\n+                    scenario.getName(), tactics, result));\n+\n+            // fail to reinforce\n+            if ((result < 6) && (reinforcementType != ReinforcementEligibilityType.FightLance)) {\n+                reportStatus.append(\" - reinforcement attempt failed.\");\n+                campaign.addReport(reportStatus.toString());\n+                return false;\n+            // succeed but get an extra negative event added to the scenario\n+            } else if (result < 9) {\n+                MapLocation mapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+                AtBScenarioModifier scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+\n+                // keep rolling until we get an applicable one\n+                // TODO: have the AtBScenarioModifier sort these out instead for performance?\n+                while (scenarioModifier.getEventTiming() != EventTiming.PostForceGeneration) {\n+                    scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+                }\n+\n+                scenarioModifier.processModifier(scenario.getBackingScenario(), campaign, EventTiming.PostForceGeneration);\n+\n+                reportStatus.append(String.format(\" - reinforcement attempt succeeded; extra negative modifier (%s) applied to scenario.\",\n+                        scenarioModifier.getModifierName()));\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            // succeed without reservation\n+            } else {\n+                reportStatus.append(\" - reinforcement attempt succeeded;\");\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            }\n+        } else if (reinforcementType == ReinforcementEligibilityType.None) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Assigns a force to the scenario such that the majority of the force can be deployed\n+     */\n+    private static void assignAppropriateExtraForceToScenario(StratconScenario scenario,\n+            Map<MapLocation, List<Integer>> sortedAvailableForceIDs) {\n+        // the goal of this function is to avoid assigning ground units to air battles\n+        // and ground units/conventional fighters to space battle\n+\n+        List<MapLocation> mapLocations = new ArrayList<>();\n+        mapLocations.add(MapLocation.Space); // can always add ASFs\n+\n+        MapLocation scenarioMapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+\n+        if (scenarioMapLocation == MapLocation.LowAtmosphere) {\n+            mapLocations.add(MapLocation.LowAtmosphere); // can add conventional fighters to ground or low atmo battles\n+        }\n+\n+        if ((scenarioMapLocation == MapLocation.AllGroundTerrain) ||\n+                (scenarioMapLocation == MapLocation.SpecificGroundTerrain)) {\n+            mapLocations.add(MapLocation.AllGroundTerrain); // can only add ground units to ground battles\n+        }\n+\n+        MapLocation selectedLocation = mapLocations.get(Compute.randomInt(mapLocations.size()));\n+        List<Integer> forceIDs = sortedAvailableForceIDs.get(selectedLocation);\n+        int forceIndex = Compute.randomInt(forceIDs.size());\n+        int forceID = forceIDs.get(forceIndex);\n+        forceIDs.remove(forceIndex);\n+\n+        scenario.addPrimaryForce(forceID);\n+    }\n+\n+    /**\n+     * Worker function that \"locks in\" a scenario -\n+     * Adds it to the campaign so it's visible in the briefing room,\n+     * adds it to the track\n+     *\n+     */\n+    public static void commitPrimaryForces(Campaign campaign, StratconScenario scenario, StratconTrackState trackState) {\n+        trackState.addScenario(scenario);\n+\n+        // set up dates for the scenario if doesn't have them already\n+        if (scenario.getDeploymentDate() == null) {\n+            scenario.setDeploymentDate(campaign.getLocalDate());\n+        }\n+\n+        if (scenario.getActionDate() == null) {\n+            scenario.setActionDate(campaign.getLocalDate());\n+        }\n+\n+        if(scenario.getReturnDate() == null) {\n+            scenario.setReturnDate(campaign.getLocalDate().plusDays(trackState.getDeploymentTime()));\n+        }\n+\n+        // set the # of rerolls based on the actual lance assigned.\n+        int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+        scenario.getBackingScenario().setRerolls(tactics);\n+        // The number of defensive points available to a force entering a scenario is\n+        // 2 x tactics. By default, those points are spent on conventional minefields.\n+        if (commanderLanceHasDefensiveAssignment(scenario.getBackingScenario(), campaign)) {\n+            scenario.setNumDefensivePoints(tactics * 2);\n+            scenario.updateMinefieldCount(Minefield.TYPE_CONVENTIONAL, tactics * 2);\n+        }\n+\n+        for (int forceID : scenario.getPlayerTemplateForceIDs()) {\n+            Force force = campaign.getForce(forceID);\n+            force.clearScenarioIds(campaign, true);\n+            force.setScenarioId(scenario.getBackingScenarioID());\n+        }\n+\n+        scenario.commitPrimaryForces();\n+    }\n+\n+    /**\n+     * Utility method to determine if the current scenario's force commander\n+     * is on defence\n+     */\n+    private static boolean commanderLanceHasDefensiveAssignment(AtBDynamicScenario scenario, Campaign campaign) {\n+        Unit commanderUnit = scenario.getLanceCommander(campaign).getUnit();\n+        Lance lance = campaign.getLances().get(commanderUnit.getForceId());\n+\n+        if ((lance != null) && (lance.getRole() == AtBLanceRole.DEFENCE)) {\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * A hackish worker function that takes the given list of force IDs and\n+     * separates it into three sets;\n+     * one of forces that can be \"primary\" on a ground map\n+     * one of forces that can be \"primary\" on an atmospheric map\n+     * one of forces that can be \"primary\" in a space map\n+     * @param forceIDs List of force IDs to check\n+     * @return Sorted hash map\n+     */\n+    private static Map<MapLocation, List<Integer>> sortForcesByMapType(List<Integer> forceIDs, Campaign campaign) {\n+        Map<MapLocation, List<Integer>> retVal = new HashMap<>();\n+\n+        retVal.put(MapLocation.AllGroundTerrain, new ArrayList<>());\n+        retVal.put(MapLocation.LowAtmosphere, new ArrayList<>());\n+        retVal.put(MapLocation.Space, new ArrayList<>());\n+\n+        for (int forceID : forceIDs) {\n+            switch(campaign.getForce(forceID).getPrimaryUnitType(campaign)) {\n+            case UnitType.BATTLE_ARMOR:\n+            case UnitType.INFANTRY:\n+            case UnitType.MEK:\n+            case UnitType.TANK:\n+            case UnitType.PROTOMEK:\n+            case UnitType.VTOL:\n+                retVal.get(MapLocation.AllGroundTerrain).add(forceID);\n+                break;\n+            case UnitType.AERO:\n+                retVal.get(MapLocation.Space).add(forceID);\n+                // intentional fallthrough here, ASFs can go to atmospheric maps too\n+            case UnitType.CONV_FIGHTER:\n+                retVal.get(MapLocation.LowAtmosphere).add(forceID);\n+                break;\n+            }\n+        }\n+\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * Determine whether the user should be nagged about unresolved scenarios on AtB Stratcon tracks.\n+     * @param campaign Campaign to check.\n+     * @return An informative string containing the reasons the user was nagged.\n+     */\n+    public static String nagUnresolvedContacts(Campaign campaign) {\n+        StringBuilder sb = new StringBuilder();\n+\n+        // check every track attached to an active contract for unresolved scenarios\n+        // to which the player must deploy forces today\n+        for (AtBContract contract : campaign.getActiveAtBContracts()) {\n+            if (contract.getStratconCampaignState() == null) {\n+                continue;\n+            }\n+            \n+            for (StratconTrackState track : contract.getStratconCampaignState().getTracks()) {\n+                for (StratconScenario scenario : track.getScenarios().values()) {\n+                    if (scenario.getCurrentState() == ScenarioState.UNRESOLVED &&\n+                            campaign.getLocalDate().equals(scenario.getDeploymentDate())) {\n+                        // \"scenario name, track name\"\n+                        sb.append(String.format(\"%s, %s\\n\", scenario.getName(), track.getDisplayableName()));\n+                    }\n+                }\n+            }\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track.\n+     * Also registers it with the track and campaign.\n+     */\n+    private static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords) {\n+        int unitType = campaign.getForce(forceID).getPrimaryUnitType(campaign);\n+        ScenarioTemplate template = StratconScenarioFactory.getRandomScenario(unitType);\n+        // useful for debugging specific scenario types\n+        //ScenarioTemplate template = StratconScenarioFactory.getSpecificScenario(\"Hostile Facility.xml\");\n+\n+        return generateScenario(campaign, contract, track, forceID, coords, template);\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track,\n+     * using the given template. Also registers it with the campaign.\n+     */\n+    static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords, ScenarioTemplate template) {\n+        StratconScenario scenario = new StratconScenario();\n+        \n+        AtBDynamicScenario backingScenario = AtBDynamicScenarioFactory.initializeScenarioFromTemplate(template, contract, campaign);        \n+        scenario.setBackingScenario(backingScenario);\n+        scenario.setCoords(coords);\n+        \n+        // by default, certain conditions may make this bigger\n+        scenario.setRequiredPlayerLances(1);\n+\n+        // do an appropriate allied force if the contract calls for it\n+        // do any attached or integrated units\n+        setAlliedForceModifier(scenario, contract);\n+        setAttachedUnitsModifier(scenario, contract);\n+        applyFacilityModifiers(scenario, track, coords);\n+        applyGlobalModifiers(scenario, contract.getStratconCampaignState());\n+\n+        if ((contract.getCommandRights() == AtBContract.COM_HOUSE) ||\n+                (contract.getCommandRights() == AtBContract.COM_INTEGRATED)) {\n+            scenario.setRequiredScenario(true);\n+        }\n+\n+        AtBDynamicScenarioFactory.setScenarioModifiers(scenario.getBackingScenario());\n+        scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+        setScenarioDates(track, campaign, scenario);\n+        \n+        // the backing scenario ID must be updated after registering the backing scenario \n+        // with the campaign, so that the stratcon - backing scenario association is maintained\n+        // registering the scenario with the campaign should be done after setting\n+        // dates, otherwise, the report messages for new scenarios look weird\n+        campaign.addScenario(backingScenario, contract);\n+        scenario.setBackingScenarioID(backingScenario.getId());\n+        \n+        if (forceID > Force.FORCE_NONE) {\n+            scenario.addPrimaryForce(forceID);\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * Apply global scenario modifiers from campaign state to given scenario.\n+     */\n+    private static void applyGlobalModifiers(StratconScenario scenario, StratconCampaignState campaignState) {\n+        for (String modifierName : campaignState.getGlobalScenarioModifiers()) {\n+            AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierName);\n+\n+            if (modifier == null) {\n+                MekHQ.getLogger().error(String.format(\"Modifier %s not found; ignoring\", modifierName));\n+                continue;\n+            }\n+\n+            scenario.getBackingScenario().addScenarioModifier(modifier);\n+        }\n+    }\n+\n+    /**\n+     * Applies scenario modifiers from the current track to the given scenario.\n+     * @param scenario\n+     * @param track\n+     */\n+    private static void applyFacilityModifiers(StratconScenario scenario, StratconTrackState track, StratconCoords coords) {\n+        // loop through all the facilities on the track\n+        // if a facility has been revealed, then it has a 100% chance to apply its effect\n+        // if a facility has not been revealed, then it has a x% chance to apply its effect\n+        // if a facility is on the the scenario coordinates the it applies the local effects\n+        for (StratconCoords facilityCoords : track.getFacilities().keySet()) {\n+            boolean scenarioAtFacility = facilityCoords.equals(coords);\n+            StratconFacility facility = track.getFacilities().get(facilityCoords);\n+            List<String> modifierIDs = new ArrayList<>();\n+\n+            if (scenarioAtFacility) {\n+                modifierIDs = facility.getLocalModifiers();\n+            } else if (facility.isVisible() || (Compute.randomInt(100) <= facility.getAggroRating())) {\n+                modifierIDs = facility.getSharedModifiers();\n+            }\n+\n+            for (String modifierID : modifierIDs) {\n+                AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierID);\n+                if(modifier == null) {\n+                    MekHQ.getLogger().error(String.format(\"Modifier %s not found for facility %s\", modifierID, facility.getFormattedDisplayableName()));\n+                    continue;\n+                }\n+\n+                scenario.getBackingScenario().addScenarioModifier(modifier);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set up the appropriate primary allied force modifier, if any\n+     * @param contract The scenario's contract.\n+     */\n+    private static void setAlliedForceModifier(StratconScenario scenario, AtBContract contract) {\n+        int alliedUnitOdds = 0;\n+\n+        // first, we determine the odds of having an allied unit present\n+        // TODO: move this override out to the contract definition\n+        if (contract.getMissionType() == AtBContract.MT_RELIEFDUTY) {\n+            alliedUnitOdds = 50;\n+        } else {\n+            switch(contract.getCommandRights()) {\n+                case AtBContract.COM_INTEGRATED:\n+                    alliedUnitOdds = 50;\n+                    break;\n+                case AtBContract.COM_HOUSE:\n+                    alliedUnitOdds = 30;\n+                    break;\n+                case AtBContract.COM_LIAISON:\n+                    alliedUnitOdds = 10;\n+                    break;\n+            }\n+        }\n+\n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+\n+        // if an allied unit is present, then we want to make sure that it's ground units\n+        // for ground battles\n+        if (Compute.randomInt(100) <= alliedUnitOdds) {\n+            if((backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+               (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space)) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_ALLIED_AIR_UNITS));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_ALLIED_GROUND_UNITS));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set the 'attached' units modifier for the current scenario (integrated, house, liaison),\n+     * and make sure we're not deploying ground units to an air scenario\n+     * @param contract The scenario's contract\n+     */\n+    public static void setAttachedUnitsModifier(StratconScenario scenario, AtBContract contract) {\n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+        boolean airBattle = (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+                (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space);\n+\n+        // if we're on cadre duty, we're getting three trainees, period\n+        if (contract.getMissionType() == AtBContract.MT_CADREDUTY) {\n+            if (airBattle) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_TRAINEES_AIR));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_TRAINEES_GROUND));\n+            }\n+            return;\n+        }\n+\n+        // if we're under non-independent command rights, a supervisor may come along\n+        switch (contract.getCommandRights()) {\n+            case AtBContract.COM_INTEGRATED:\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(airBattle \n+                        ? MekHqConstants.SCENARIO_MODIFIER_INTEGRATED_UNITS_AIR\n+                        : MekHqConstants.SCENARIO_MODIFIER_INTEGRATED_UNITS_GROUND));\n+                break;\n+            case AtBContract.COM_HOUSE:\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(airBattle \n+                        ? MekHqConstants.SCENARIO_MODIFIER_HOUSE_CO_AIR\n+                        : MekHqConstants.SCENARIO_MODIFIER_HOUSE_CO_GROUND));\n+                break;\n+            case AtBContract.COM_LIAISON:\n+                if (scenario.isRequiredScenario()) {\n+                    backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(airBattle \n+                            ? MekHqConstants.SCENARIO_MODIFIER_LIAISON_AIR\n+                            : MekHqConstants.SCENARIO_MODIFIER_LIAISON_GROUND));\n+                }\n+                break;\n+        }\n+    }\n+\n+    /**\n+     * Worker function that sets scenario deploy/battle/return dates based on the track's properties and current campaign date\n+     */\n+    private static void setScenarioDates(StratconTrackState track, Campaign campaign, StratconScenario scenario) {\n+     // set up deployment day, battle day, return day here\n+        // safety code to prevent attempts to generate random int with upper bound of 0 which is apparently illegal\n+        int deploymentDay = track.getDeploymentTime() < 7 ? Compute.randomInt(7 - track.getDeploymentTime()) : 0;\n+        int battleDay = deploymentDay + (track.getDeploymentTime() > 0 ? Compute.randomInt(track.getDeploymentTime()) : 0);\n+        int returnDay = deploymentDay + track.getDeploymentTime();\n+\n+        LocalDate deploymentDate = campaign.getLocalDate();\n+        deploymentDate.plusDays(deploymentDay);\n+        LocalDate battleDate = campaign.getLocalDate();\n+        deploymentDate.plusDays(battleDay);\n+        LocalDate returnDate = campaign.getLocalDate();\n+        returnDate.plusDays(returnDay);\n+\n+        scenario.setDeploymentDate(deploymentDate);\n+        scenario.setActionDate(battleDate);\n+        scenario.setReturnDate(returnDate);\n+    }\n+\n+    /**\n+     * Helper function that determines if the unit type specified in the given scenario force template\n+     * would start out airborne on a ground map (hot dropped units aside)\n+     */\n+    private static boolean unitTypeIsAirborne(ScenarioForceTemplate template) {\n+        int unitType = template.getAllowedUnitType();\n+\n+        return (unitType == UnitType.AERO ||\n+                unitType == UnitType.CONV_FIGHTER ||\n+                unitType == UnitType.DROPSHIP ||\n+                unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_MIX) &&\n+                template.getStartingAltitude() > 0;\n+    }\n+\n+    /**\n+     * Determines whether the force in question has the same primary unit type as the force template.\n+     * @return Whether or not the unit types match.\n+     */\n+    public static boolean forceCompositionMatchesDeclaredUnitType(int primaryUnitType, int unitType, boolean reinforcements) {\n+        // special cases are \"ATB_MIX\" and \"ATB_AERO_MIX\", which encompass multiple unit types\n+        if (unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_MIX) {\n+            // \"AtB mix\" is usually ground units, but air units can sub in\n+            return primaryUnitType == UnitType.MEK ||\n+                    primaryUnitType == UnitType.TANK ||\n+                    primaryUnitType == UnitType.INFANTRY ||\n+                    primaryUnitType == UnitType.BATTLE_ARMOR ||\n+                    primaryUnitType == UnitType.PROTOMEK ||\n+                    primaryUnitType == UnitType.VTOL ||\n+                    (primaryUnitType == UnitType.AERO) && reinforcements ||\n+                    (primaryUnitType == UnitType.CONV_FIGHTER) && reinforcements;\n+        } else if (unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_AERO_MIX) {\n+            return primaryUnitType == UnitType.AERO ||\n+                    primaryUnitType == UnitType.CONV_FIGHTER;\n+        } else {\n+            return primaryUnitType == unitType;\n+        }\n+    }\n+\n+    /**\n+     * This is a set of all force IDs for forces that can be deployed to a scenario.\n+     * @param campaign Current campaign\n+     * @return Set of available force IDs.\n+     */\n+    public static List<Integer> getAvailableForceIDs(Campaign campaign) {\n+        List<Integer> retVal = new ArrayList<>();\n+\n+        // first, we gather a set of all forces that are already deployed to a track so we eliminate those later\n+        Set<Integer> forcesInTracks = new HashSet<>();\n+        for (Contract contract : campaign.getActiveContracts()) {\n+            if (contract instanceof AtBContract) {\n+                for (StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    forcesInTracks.addAll(track.getAssignedForceCoords().keySet());\n+                }\n+            }\n+        }\n+\n+        // now, we get all the forces that qualify as \"lances\", and filter out those that are\n+        // deployed to a scenario and not in a track already\n+        for (int key : campaign.getLances().keySet()) {\n+            Force force = campaign.getForce(key);\n+            if ((force != null) &&\n+                    !force.isDeployed() &&\n+                    !forcesInTracks.contains(force.getId())) {\n+                retVal.add(force.getId());\n+            }\n+        }\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * This is a list of all force IDs for forces that can be deployed to a scenario in the given force template\n+     * a) have not been assigned to a track\n+     * b) are combat-capable\n+     * c) are not deployed to a scenario\n+     * d) if attempting to deploy as reinforcements, haven't already failed to deploy\n+     */\n+    public static List<Integer> getAvailableForceIDs(int unitType, Campaign campaign, StratconTrackState currentTrack,\n+            boolean reinforcements, @Nullable StratconScenario currentScenario) {\n+        List<Integer> retVal = new ArrayList<>();\n+\n+        Set<Integer> forcesInTracks = new HashSet<>();\n+        // assemble a set of all force IDs that are currently assigned to tracks that are not this one\n+        for (Contract contract : campaign.getActiveContracts()) {\n+            if (contract instanceof AtBContract) {\n+                for (StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    if ((track != currentTrack) || !reinforcements) {\n+                        forcesInTracks.addAll(track.getAssignedForceCoords().keySet());\n+                    }\n+                }\n+            }\n+        }\n+        \n+        // if there's an existing scenario and we're doing reinforcements,\n+        // prevent forces that failed to deploy from trying to deploy again\n+        if (reinforcements && (currentScenario != null)) {\n+            forcesInTracks.addAll(currentScenario.getFailedReinforcements());\n+        }\n+\n+        for (int key : campaign.getLances().keySet()) {\n+            Force force = campaign.getForce(key);\n+\n+            if (force == null) {\n+                continue;\n+            }\n+\n+            int primaryUnitType = force.getPrimaryUnitType(campaign);\n+            if (!force.isDeployed() &&\n+                    (force.getScenarioId() <= 0) &&\n+                    !force.getUnits().isEmpty() &&\n+                    !forcesInTracks.contains(force.getId()) &&\n+                    forceCompositionMatchesDeclaredUnitType(primaryUnitType, unitType, reinforcements)) {\n+                retVal.add(force.getId());\n+            }\n+        }\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * Returns a list of individual units eligible for deployment in scenarios run by \"Defend\" lances\n+     * @return List of unit IDs.\n+     */\n+    public static List<Unit> getEligibleDefensiveUnits(Campaign campaign) {\n+        List<Unit> retVal = new ArrayList<>();\n+\n+        for (Unit u : campaign.getUnits()) {\n+            // \"defensive\" units are infantry, battle armor and (Weisman help you) gun emplacements\n+        \t// and also said unit should be intact/alive/etc\n+        \tboolean isEligibleInfantry = \n+        \t\t\t((u.getEntity().getUnitType() == UnitType.INFANTRY) ||\n+                    (u.getEntity().getUnitType() == UnitType.BATTLE_ARMOR)) &&\n+                    !u.isUnmanned();\n+        \t\n+        \tboolean isEligibleGunEmplacement = u.getEntity().getUnitType() == UnitType.GUN_EMPLACEMENT;\n+        \t\n+        \tif ((isEligibleInfantry || isEligibleGunEmplacement) && \n+            \t\t!u.isDeployed() &&\n+                    !u.isMothballed() &&\n+                    u.isFunctional()) {\n+\n+                // this is a little inefficient, but probably there aren't too many active AtB contracts at a time\n+                for (AtBContract contract : campaign.getActiveAtBContracts()) {\n+                    if (contract.getStratconCampaignState().isForceDeployedHere(u.getForceId())) {\n+                        continue;\n+                    }\n+                }\n+\n+                retVal.add(u);\n+            }\n+        }\n+\n+        return retVal;\n+    }\n+    \n+    /**\n+     * Returns a list of individual units eligible for deployment in scenarios\n+     * that result from the lance leader having a leadership score\n+     * @return List of unit IDs.\n+     */\n+    public static List<Unit> getEligibleLeadershipUnits(Campaign campaign, Set<Integer> forceIDs) {\n+        List<Unit> retVal = new ArrayList<>();\n+\n+        // The criteria are as follows:\n+        // - unit is of a different unit type than the primary unit type of the force \n+        // - unit has a lower BV than the force's lowest BV unit\n+        \n+        Integer lowestBV = getLowestBV(campaign, forceIDs);\n+        \n+        // no units assigned, the rest is meaningless.\n+        if (lowestBV == null) {\n+            return retVal;\n+        }\n+        \n+        int primaryUnitType = getPrimaryUnitType(campaign, forceIDs);\n+        \n+        for (Unit u : campaign.getUnits()) {\n+            if ((primaryUnitType != u.getEntity().getUnitType()) &&\n+                    !u.isDeployed() &&\n+                    !u.isMothballed() &&\n+                    u.isFunctional() &&\n+                    (u.getEntity().calculateBattleValue() < lowestBV) &&\n+                    !isUnitDeployedToStratCon(u)) {\n+                retVal.add(u);\n+            }\n+        }\n+\n+        return retVal;\n+    }\n+    \n+    /**\n+     * Check if the unit's force (if one exists) has been deployed to a StratCon track\n+     */\n+    public static boolean isUnitDeployedToStratCon(Unit u) {\n+        if (!u.getCampaign().getCampaignOptions().getUseStratCon()) {\n+            return false;\n+        }\n+        \n+        //this is a little inefficient, but probably there aren't too many active AtB contracts at a time\n+        for (AtBContract contract : u.getCampaign().getActiveAtBContracts()) {\n+            if (contract.getStratconCampaignState().isForceDeployedHere(u.getForceId())) {\n+                return true;\n+            }\n+        }\n+        \n+        return false;\n+    }\n+    \n+    /**\n+     * Given a campaign and a list of force IDs, calculate the unit with the lowest BV.\n+     */\n+    private static Integer getLowestBV(Campaign campaign, Set<Integer> forceIDs) {\n+        Integer lowestBV = null;\n+        \n+        for (int forceID : forceIDs) {\n+            Force force = campaign.getForce(forceID);\n+            if (force == null) {\n+                continue;\n+            }\n+            \n+            for (UUID id : force.getUnits()) {\n+                if (campaign.getUnit(id) == null) {\n+                    continue;\n+                }\n+                \n+                int currentBV = campaign.getUnit(id).getEntity().calculateBattleValue();\n+                \n+                if ((lowestBV == null) || (currentBV < lowestBV)) {\n+                    lowestBV = currentBV;\n+                }\n+            }\n+        }\n+        \n+        return lowestBV;\n+    }\n+    \n+    /**\n+     * Calculates the majority unit type for the forces given the IDs.\n+     */\n+    private static int getPrimaryUnitType(Campaign campaign, Set<Integer> forceIDs) {\n+        Map<Integer, Integer> unitTypeBuckets = new TreeMap<>();\n+        int biggestBucketID = -1;\n+        int biggestBucketCount = 0;\n+        \n+        for (int forceID : forceIDs) {\n+            Force force = campaign.getForce(forceID);\n+            if (force == null) {\n+                continue;\n+            }\n+        \n+            for (UUID id : force.getUnits()) {\n+                Unit unit = campaign.getUnit(id);\n+                if ((unit == null) || \n+                        (unit.getEntity() == null)) {\n+                    continue;\n+                }\n+                \n+                int unitType = unit.getEntity().getUnitType();\n+    \n+                unitTypeBuckets.merge(unitType, 1, (oldCount, value) -> oldCount + value);\n+                \n+                if (unitTypeBuckets.get(unitType) > biggestBucketCount) {\n+                    biggestBucketCount = unitTypeBuckets.get(unitType);\n+                    biggestBucketID = unitType;\n+                }\n+            }\n+        }\n+        \n+        return biggestBucketID;\n+    }\n+\n+    /**\n+     * Determines what rules to use when deploying a force for reinforcements to the given track.\n+     */\n+    public static ReinforcementEligibilityType getReinforcementType(int forceID,\n+            StratconTrackState trackState, Campaign campaign) {\n+        // if the force is currently deployed to the track, it'll be able to deploy \"for free\"\n+        if (trackState.isForceDeployed(forceID)) {\n+            return ReinforcementEligibilityType.ChainedScenario;\n+        }\n+\n+        // if the force is in 'fight' stance, it'll be able to deploy using 'fight lance' rules\n+        if (campaign.getLances().containsKey(forceID) &&\n+                campaign.getLances().get(forceID).getRole() == AtBLanceRole.FIGHTING) {\n+            return ReinforcementEligibilityType.FightLance;\n+        }\n+\n+        // if the force is deployed elsewhere, it cannot be deployed as reinforcements\n+        for (Contract contract : campaign.getActiveContracts()) {\n+            if(contract instanceof AtBContract) {\n+                for(StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    if(track != trackState && track.getAssignedForceCoords().containsKey(forceID)) {\n+                        return ReinforcementEligibilityType.None;\n+                    }\n+                }\n+            }\n+        }\n+\n+        // otherwise, the force requires support points / vps to deploy\n+        return ReinforcementEligibilityType.SupportPoint;\n+    }\n+    \n+    /**\n+     * Given a track and the current campaign state, and if the player is deploying\n+     * a force or not, figure out the odds of a scenario occuring.\n+     */\n+    public static int calculateScenarioOdds(StratconTrackState track, \n+            AtBContract contract, boolean playerDeployingForce) {\n+        // rules:\n+        // rout morale: 0%\n+        // very low morale: -10% when deploying forces to track, 0% attack\n+        // low morale: -5%\n+        // high morale: +5%\n+        // invincible: special case, let's do +10% for now\n+        int moraleModifier = 0;\n+        \n+        switch (contract.getMoraleLevel()) {\n+            case AtBContract.MORALE_ROUT:\n+                return 0;\n+            case AtBContract.MORALE_VERYLOW:\n+                if (playerDeployingForce) {\n+                    moraleModifier = -10;\n+                } else {\n+                    return 0;\n+                }\n+                break;\n+            case AtBContract.MORALE_LOW:\n+                moraleModifier = -5;\n+                break;\n+            case AtBContract.MORALE_HIGH:\n+                moraleModifier = 5;\n+                break;\n+            case AtBContract.MORALE_INVINCIBLE:\n+                moraleModifier = 10;\n+                break;\n+        }\n+        \n+        // facilities: for each hostile data center, add +5%\n+        // for each allied data center, subtract 5\n+        int dataCenterModifier = 0;\n+        for (StratconFacility facility : track.getFacilities().values()) {\n+            if (facility.getFacilityType() == FacilityType.DataCenter) {\n+                dataCenterModifier += facility.getOwner() == ForceAlignment.Allied ? -5 : 5;\n+            }\n+        }\n+            \n+        return track.getScenarioOdds() + moraleModifier + dataCenterModifier;\n+    }\n+\n+    /**\n+     * Removes the facility associated with the given scenario from the relevant track/\n+     */\n+    public static void updateFacilityForScenario(AtBScenario scenario, AtBContract contract, boolean destroy, boolean capture) {\n+        if (contract.getStratconCampaignState() == null) {\n+            return;\n+        }\n+\n+        // this is kind of kludgy, but there's currently no way to link a scenario back to its backing scenario\n+        // TODO: introduce mapping in contract or at least trackstate\n+        // basically, we're looping through all scenarios on all the contract's tracks\n+        // if we find one with the same ID as the one being resolved, that's our facility: get rid of it.\n+        for (StratconTrackState trackState : contract.getStratconCampaignState().getTracks()) {\n+            for (StratconCoords coords : trackState.getScenarios().keySet()) {\n+                StratconScenario potentialScenario = trackState.getScenario(coords);\n+                if (potentialScenario.getBackingScenarioID() == scenario.getId()) {\n+\n+                    if (destroy) {\n+                        trackState.removeFacility(coords);\n+                    } else {\n+                        StratconFacility facility = trackState.getFacility(coords);\n+\n+                        if (facility == null) {\n+                            continue;\n+                        }\n+\n+                        if (capture) {\n+                            facility.incrementOwnershipChangeScore();\n+                        } else {\n+                            facility.decrementOwnershipChangeScore();\n+                        }\n+                    }\n+\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Processes completion of a Stratcon scenario, if the given tracker is associated\n+     * with a stratcon-enabled mission. Intended to be called after ResolveScenarioTracker.finish() has been invoked.\n+     */\n+    public static void processScenarioCompletion(ResolveScenarioTracker rst) {\n+        if (rst.getMission() instanceof AtBContract) {\n+            StratconCampaignState campaignState = ((AtBContract) rst.getMission()).getStratconCampaignState();\n+            if (campaignState == null) {\n+                return;\n+            }\n+\n+            for (StratconTrackState track : campaignState.getTracks()) {\n+                if (track.getBackingScenariosMap().containsKey(rst.getScenario().getId())) {\n+                    // things that may potentially happen:\n+                    // scenario is removed from track - implemented\n+                    // track gets remaining forces added to reinforcement pool\n+                    // facility gets remaining forces stored in reinforcement pool\n+                    // process VP and SO\n+\n+                    StratconScenario scenario = track.getBackingScenariosMap().get(rst.getScenario().getId());\n+\n+\n+                    StratconFacility facility = track.getFacility(scenario.getCoords());\n+\n+                    if ((facility != null) && (facility.getOwnershipChangeScore() > 0)) {\n+                        if (facility.getOwner() == ForceAlignment.Allied) {\n+                            facility.setOwner(ForceAlignment.Opposing);\n+                        } else {\n+                            facility.setOwner(ForceAlignment.Allied);\n+                        }\n+                    }\n+\n+                    boolean victory = rst.getScenario().getStatus() == Scenario.S_VICTORY ||\n+                            rst.getScenario().getStatus() == Scenario.S_MVICTORY;\n+\n+                    if (scenario.isRequiredScenario()) {\n+                        campaignState.updateVictoryPoints(victory ? 1 : -1);\n+                    }\n+\n+                    if (scenario.isStrategicObjective()) {\n+                        if (campaignState.strategicObjectivesBehaveAsVPs()) {\n+                            campaignState.updateVictoryPoints(victory ? 1 : -1);\n+                        } else {\n+                            campaignState.incrementStrategicObjectiveCompletedCount();\n+                        }\n+                    }\n+\n+                    processTrackForceReturnDates(track, rst.getCampaign().getLocalDate());\n+\n+                    track.removeScenario(scenario);\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Worker function that goes through a track and undeploys any forces where the\n+     * return date is on or before the given date.\n+     */\n+    public static void processTrackForceReturnDates(StratconTrackState track, LocalDate date) {\n+        List<Integer> forcesToUndeploy = new ArrayList<>();\n+\n+        // for each force on the track, if the return date is today or in the past,\n+        // \"return to base\", unless it's been told to stay in the field\n+        for (int forceID : track.getAssignedForceReturnDates().keySet()) {\n+            if ((track.getAssignedForceReturnDates().get(forceID).equals(date) ||\n+                    track.getAssignedForceReturnDates().get(forceID).isBefore(date)) &&\n+                    !track.getStickyForces().contains(forceID)) {\n+                forcesToUndeploy.add(forceID);\n+            }\n+        }\n+\n+        for (int forceID : forcesToUndeploy) {\n+            track.unassignForce(forceID);\n+        }\n+    }\n+    \n+    /**\n+     * Processes an ignored dynamic scenario - locates it on one of the tracks\n+     * and calls the standared 'ignored scenario' routine.\n+     * @return Whether or not we also need to get rid of the backing scenario from the campaign\n+     */\n+    public static boolean processIgnoredScenario(AtBDynamicScenario scenario, StratconCampaignState campaignState) {\n+        for (StratconTrackState track : campaignState.getTracks()) {\n+            if (track.getBackingScenariosMap().containsKey(scenario.getId())) {\n+                return processIgnoredScenario(track.getBackingScenariosMap().get(scenario.getId()), campaignState);\n+            }\n+        }\n+        \n+        return true;\n+    }\n+    \n+\n+    /**\n+     * Processes an ignored Stratcon scenario\n+     * @return Whether or not we also need to get rid of the backing scenario from the campaign\n+     */\n+    public static boolean processIgnoredScenario(StratconScenario scenario, StratconCampaignState campaignState) {\n+        for (StratconTrackState track : campaignState.getTracks()) {\n+            if (track.getScenarios().containsKey(scenario.getCoords())) {\n+                // subtract VP if scenario is 'required'\n+                if (scenario.isRequiredScenario()) {\n+                    campaignState.updateVictoryPoints(-1);\n+                }\n+                \n+                track.removeScenario(scenario);\n+\n+                StratconFacility localFacility = track.getFacility(scenario.getCoords());\n+                if (localFacility != null) {\n+                    // if the ignored scenario was on top of an allied facility\n+                    // then it'll get captured, and the player will possibly lose a SO\n+                    if (localFacility.getOwner() == ForceAlignment.Allied) {\n+                        localFacility.setOwner(ForceAlignment.Opposing);\n+\n+                        if (localFacility.isStrategicObjective()) {\n+                            campaignState.decrementStrategicObjectiveCompletedCount();\n+                        }\n+                    }\n+                    \n+                    return true;\n+                } else {\n+                    // if it's an open-field\n+                    // move scenario towards nearest allied facility\n+                    StratconCoords closestAlliedFacilityCoords = track.findClosestAlliedFacilityCoords(scenario.getCoords());\n+\n+                    if (closestAlliedFacilityCoords != null) {\n+                        StratconCoords newCoords = scenario.getCoords().translate(scenario.getCoords().direction(closestAlliedFacilityCoords));\n+                        scenario.setCoords(newCoords);\n+                        \n+                        int daysForward = Math.min(1, track.getDeploymentTime());\n+                        \n+                        scenario.setDeploymentDate(scenario.getDeploymentDate().plusDays(daysForward));\n+                        scenario.setActionDate(scenario.getActionDate().plusDays(daysForward));\n+                        scenario.setReturnDate(scenario.getReturnDate().plusDays(daysForward));\n+                        \n+                        // refresh the scenario's position on the track\n+                        track.addScenario(scenario);\n+                        \n+                        // TODO: Write some functionality to \"copy\" a scenario's \n+                        // bot forces over\n+                        /*StratconFacility facility = track.getFacility(newCoords);\n+\n+                        if (facility != null) {\n+                            ScenarioTemplate template = StratconScenarioFactory.getFacilityScenario(true);\n+                            scenario = generateScenario(campaignState.getCa, contract, track, forceID, coords, template);\n+                            setupFacilityScenario(scenario, facility);\n+                        }*/\n+\n+                        // TODO: if the allied facility is in the new coords, replace this scenario\n+                        // with a facility defense, with the opfor coming directly from all hostiles assigned to this scenario", "originalCommit": "b36d9fa6bf982c7b833b1ac0a0473d37f6e84760", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTE5Mjg0Mg==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r615192842", "bodyText": "Spacing", "author": "Windchild292", "createdAt": "2021-04-17T02:15:20Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1404 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.UUID;\n+\n+import megamek.common.Compute;\n+import megamek.common.Minefield;\n+import megamek.common.UnitType;\n+import megamek.common.annotations.Nullable;\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.Utilities;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.ResolveScenarioTracker;\n+import mekhq.campaign.againstTheBot.enums.AtBLanceRole;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.event.StratconDeploymentEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.force.Lance;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier.EventTiming;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconFacility.FacilityType;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.unit.Unit;\n+\n+/**\n+ * This class contains \"rules\" logic for the AtB-Stratcon state\n+ * @author NickAragua\n+ */\n+public class StratconRulesManager {\n+    /**\n+     * What makes a particular lance eligible to be reinforcements for a scenario\n+     */\n+    public enum ReinforcementEligibilityType {\n+        /**\n+         * Nothing\n+         */\n+        None,\n+\n+        /**\n+         * Lance is already deployed to the track\n+         */\n+        ChainedScenario,\n+\n+        /**\n+         * We pay a support point or convert a victory point to a support point\n+         */\n+        SupportPoint,\n+\n+        /**\n+         * The lance's deployment orders are \"Fight\"\n+         */\n+        FightLance\n+    }\n+\n+    /**\n+     * This function potentially generates non-player-initiated scenarios for the given track.\n+     */\n+    public static void generateScenariosForTrack(Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // maps scenarios to force IDs\n+        List<StratconScenario> generatedScenarios = new ArrayList<>();\n+        boolean autoAssignLances = contract.getCommandRights() == AtBContract.COM_INTEGRATED;\n+\n+        // get this list just so we have it available\n+        List<Integer> availableForceIDs = getAvailableForceIDs(campaign);\n+        Map<MapLocation, List<Integer>> sortedAvailableForceIDs = sortForcesByMapType(availableForceIDs, campaign);\n+\n+        // make X rolls, where X is the number of required lances for the track\n+        // that's the chance to spawn a scenario.\n+        // if a scenario occurs, then we pick a random non-deployed lance and use it to drive the opfor generation later\n+        // once we've determined that scenarios occur, we loop through the ones that we generated\n+        // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all\n+        for (int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            int targetNum = calculateScenarioOdds(track, contract, false);\n+            \n+            // if we haven't already used all the player forces and are required to randomly generate a scenario\n+            if (!availableForceIDs.isEmpty() && (Compute.randomInt(100) <= targetNum)) {\n+                // pick random coordinates and force to drive the scenario\n+                int x = Compute.randomInt(track.getWidth());\n+                int y = Compute.randomInt(track.getHeight());\n+\n+                StratconCoords scenarioCoords = new StratconCoords(x, y);\n+\n+                // if forces are already assigned to these coordinates, use those instead\n+                // of randomly-selected ones\n+                if (track.getAssignedCoordForces().containsKey(scenarioCoords)) {\n+                    StratconScenario scenario = generateScenarioForExistingForces(scenarioCoords,\n+                            track.getAssignedCoordForces().get(scenarioCoords), \n+                            contract, campaign, track);\n+                    generatedScenarios.add(scenario);\n+                    continue;\n+                }\n+                \n+                // otherwise, pick a random force from the avail\n+                int randomForceIndex = Compute.randomInt(availableForceIDs.size());\n+                int randomForceID = availableForceIDs.get(randomForceIndex);\n+                \n+                // remove the force from the available lists so we don't designate it as primary twice\n+                availableForceIDs.remove(randomForceIndex);\n+\n+                // we want to remove the actual int with the value, not the value at the index\n+                sortedAvailableForceIDs.get(MapLocation.AllGroundTerrain).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.LowAtmosphere).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.Space).remove((Integer) randomForceID);\n+\n+                // two scenarios on the same coordinates wind up increasing in size\n+                if (track.getScenarios().containsKey(scenarioCoords)) {\n+                    track.getScenarios().get(scenarioCoords).incrementRequiredPlayerLances();\n+                    assignAppropriateExtraForceToScenario(track.getScenarios().get(scenarioCoords), sortedAvailableForceIDs);\n+                    continue;\n+                }\n+\n+                StratconScenario scenario = setupScenario(scenarioCoords, randomForceID, campaign, contract, track);\n+                generatedScenarios.add(scenario);\n+\n+                // if we're auto-assigning lances, deploy the force to the track as well\n+                if (autoAssignLances) {\n+                    processForceDeployment(scenarioCoords, randomForceID, campaign, track, false);\n+                }\n+            }\n+        }\n+\n+        // if under liaison command, pick a random scenario from the ones generated\n+        // to set as required and attach liaison\n+        if (contract.getCommandRights() == AtBContract.COM_LIAISON) {\n+        \tStratconScenario randomScenario = Utilities.getRandomItem(generatedScenarios);\n+        \trandomScenario.setRequiredScenario(true);\n+            setAttachedUnitsModifier(randomScenario, contract);\n+        }\n+\n+        // now, we loop through all the scenarios we set up\n+        // and generate the opfors / events / etc\n+        // if not auto-assigning lances, we then back out the lance assignments.\n+        for (StratconScenario scenario : generatedScenarios) {\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+\n+            if(!autoAssignLances && !scenario.ignoreForceAutoAssignment()) {\n+                for(int forceID : scenario.getPlayerTemplateForceIDs()) {\n+                    scenario.getBackingScenario().removeForce(forceID);\n+                }\n+\n+                scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                track.addScenario(scenario);\n+            } else {\n+                commitPrimaryForces(campaign, scenario, track);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Given a set of force IDs and coordinates, generate a scenario\n+     * Useful for when we want to generate scenarios \n+     * for forces already deployed to a track\n+     */\n+    public static StratconScenario generateScenarioForExistingForces(StratconCoords scenarioCoords, \n+            Set<Integer> forceIDs, AtBContract contract, Campaign campaign, StratconTrackState track) {\n+        boolean firstForce = true;\n+        StratconScenario scenario = null;\n+        \n+        for (int forceID : forceIDs) {\n+            if (firstForce) {\n+                scenario = setupScenario(scenarioCoords, forceID, campaign, contract, track);\n+                firstForce = false;\n+            } else {\n+                scenario.incrementRequiredPlayerLances();\n+                scenario.addPrimaryForce(forceID);\n+            }\n+        }\n+        \n+        // this is theoretically possible if forceIDs is passed in as null - not likely in practice\n+        // but might as well, to future-proof.\n+        if (scenario != null) {\n+            scenario.setIgnoreForceAutoAssignment(true);\n+        }\n+        \n+        return scenario;\n+    }\n+\n+    /**\n+     * Deploys a force to the given coordinates on the given track as a result of explicit player action.\n+     */\n+    public static void deployForceToCoords(StratconCoords coords, int forceID, \n+            Campaign campaign, AtBContract contract, StratconTrackState track, boolean sticky) {\n+        // the following things should happen:\n+        // 1. call to \"process force deployment\", which reveals fog of war in or around the coords, depending on force role\n+        // 2. if coords are a hostile facility, we get a facility mission\n+        // 3. if coords are empty, we *may* get a mission\n+\n+        processForceDeployment(coords, forceID, campaign, track, sticky);\n+\n+        // don't create a scenario on top of allied facilities\n+        StratconFacility facility = track.getFacility(coords);\n+        boolean isNonAlliedFacility = (facility != null) && (facility.getOwner() != ForceAlignment.Allied);\n+        int targetNum = calculateScenarioOdds(track, contract, true);\n+        boolean spawnScenario = (facility == null) && (Compute.randomInt(100) <= targetNum);\n+\n+        if (isNonAlliedFacility || spawnScenario) {\n+            StratconScenario scenario = setupScenario(coords, forceID, campaign, contract, track);\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            commitPrimaryForces(campaign, scenario, track);\n+        }\n+    }\n+\n+    /**\n+     * Logic to set up a scenario\n+     */\n+    private static StratconScenario setupScenario(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        StratconScenario scenario = null;\n+\n+        if (track.getFacilities().containsKey(coords)) {\n+            StratconFacility facility = track.getFacility(coords);\n+            boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+            ScenarioTemplate template = StratconScenarioFactory.getFacilityScenario(alliedFacility);\n+            scenario = generateScenario(campaign, contract, track, forceID, coords, template);\n+            setupFacilityScenario(scenario, facility);\n+        } else {\n+            scenario = generateScenario(campaign, contract, track, forceID, coords);\n+\n+            // we may generate a facility scenario randomly - if so, do the facility-related stuff\n+            // and add a new facility to the track\n+            if (scenario.getBackingScenario().getTemplate().isFacilityScenario()) {\n+                StratconFacility facility = scenario.getBackingScenario().getTemplate().isHostileFacility() ?\n+                        StratconFacilityFactory.getRandomHostileFacility() : StratconFacilityFactory.getRandomAlliedFacility();\n+                facility.setVisible(true);\n+                track.addFacility(coords, facility);\n+                setupFacilityScenario(scenario, facility);\n+            }\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * carries out tasks relevant to facility scenarios\n+     */\n+    private static void setupFacilityScenario(StratconScenario scenario, StratconFacility facility) {\n+        // this includes:\n+        // for hostile facilities\n+        // - add a destroy objective (always the option to level the facility)\n+        // - add a capture objective (always the option to capture the facility)\n+        // - if so indicated by parameter, roll a random hostile facility objective and add it if not capture/destroy\n+        // for allied facilities\n+        // - add a defend objective (always the option to defend the facility)\n+        // - if so indicated by parameter, roll a random allied facility objective and add it if not defend\n+        AtBScenarioModifier objectiveModifier = null;\n+        boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+\n+        if (alliedFacility) {\n+            objectiveModifier = AtBScenarioModifier.getRandomAlliedFacilityModifier();\n+        } else {\n+            objectiveModifier = AtBScenarioModifier.getRandomHostileFacilityModifier();\n+        }\n+\n+        if (objectiveModifier != null) {\n+            scenario.getBackingScenario().addScenarioModifier(objectiveModifier);\n+            scenario.getBackingScenario().setName(String.format(\"%s - %s - %s\",\n+                    facility.getFacilityType(), alliedFacility ? \"Allied\" : \"Hostile\", objectiveModifier.getModifierName()));\n+        }\n+\n+        // add the \"fixed\" hostile facility modifiers after the primary ones\n+        if (!alliedFacility) {\n+            for(AtBScenarioModifier modifier : AtBScenarioModifier.getRequiredHostileFacilityModifiers()) {\n+                if(!scenario.getBackingScenario().alreadyHasModifier(modifier)) {\n+                    scenario.getBackingScenario().addScenarioModifier(modifier);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void processFacilityEffects(StratconTrackState track) {\n+        // TODO: these are \"weekly\"? effects that a stratcon facility has on the campaign/track state\n+        // currrently, that's\n+        // supply depot - allied - +1 sp\n+        // supply depot - hostile - +5% BV budget to all scenarios on track (shared modifier, so should be implemented there)\n+        // data center - allied - +1% star league cache contract (don't implement yet, but...)\n+        // data center - hostile - +5% scenario odds in track\n+        // industrial center - allied - all scenarios here have THIS IS COMING OUT OF YOUR PAYCHECK modifier\n+        // orbital defense - allied - sets 'no hostile aircraft' flag for track\n+        // orbital defense - hostile - sets 'no allied aircraft' flag for track\n+        // early warning system - allied - sets 'intercept allied base attacks' flag for track\n+        // early warning system - hostile - sets 'intercept hostile base attacks' flag for track\n+    }\n+\n+    /**\n+     * Process the deployment of a force to the given coordinates on the given track.\n+     */\n+    public static void processForceDeployment(StratconCoords coords, int forceID, \n+            Campaign campaign, StratconTrackState track, boolean sticky) {\n+        track.getRevealedCoords().add(coords);\n+        StratconFacility facility = track.getFacility(coords);\n+        if (facility != null) {\n+            facility.setVisible(true);\n+        }\n+\n+        if (campaign.getLances().get(forceID).getRole() == AtBLanceRole.SCOUTING) {\n+            for(int direction = 0; direction < 6; direction++) {\n+                StratconCoords checkCoords = coords.translate(direction);\n+\n+                facility = track.getFacility(checkCoords);\n+                if(facility != null) {\n+                    facility.setVisible(true);\n+                }\n+\n+                track.getRevealedCoords().add(coords.translate(direction));\n+            }\n+        }\n+\n+        // the force may be located in other places on the track - clear it out\n+        track.unassignForce(forceID);\n+        track.assignForce(forceID, coords, campaign.getLocalDate(), sticky);\n+        MekHQ.triggerEvent(new StratconDeploymentEvent(campaign.getForce(forceID)));\n+    }\n+\n+    /**\n+     * Worker function that processes the effects of deploying a reinforcement force to a scenario\n+     */\n+    public static boolean processReinforcementDeployment(ReinforcementEligibilityType reinforcementType,\n+            StratconCampaignState campaignState, StratconScenario scenario, Campaign campaign) {\n+        // if the force is already deployed to the track, we're done\n+        // if the force is a fight lance or we're using a support point\n+        // if there is an SP to burn, burn it and we're done\n+        // if there is a VP to burn, burn it and we're done\n+        // now, roll 2d6 + lance commander tactics\n+        // 9+ = deploy\n+        // 6+ = deploy, apply negative modifier to scenario\n+        // 2+ = fail to deploy, apply negative modifier to scenario; if fight lance, treat as 6+\n+\n+        if ((reinforcementType == ReinforcementEligibilityType.FightLance) ||\n+                (reinforcementType == ReinforcementEligibilityType.SupportPoint)) {\n+\n+            if (campaignState.getSupportPoints() > 0) {\n+                campaignState.useSupportPoint();\n+                return true;\n+            } else if (campaignState.getVictoryPoints() > 0) {\n+                campaignState.updateVictoryPoints(-1);\n+                return true;\n+            }\n+\n+            int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+            int roll = Compute.d6(2);\n+            int result = roll + tactics;\n+\n+            StringBuilder reportStatus = new StringBuilder();\n+            reportStatus.append(String.format(\"Attempting to reinforce scenario %s without SP/VP, roll 2d6 + %d: %d\",\n+                    scenario.getName(), tactics, result));\n+\n+            // fail to reinforce\n+            if ((result < 6) && (reinforcementType != ReinforcementEligibilityType.FightLance)) {\n+                reportStatus.append(\" - reinforcement attempt failed.\");\n+                campaign.addReport(reportStatus.toString());\n+                return false;\n+            // succeed but get an extra negative event added to the scenario\n+            } else if (result < 9) {\n+                MapLocation mapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+                AtBScenarioModifier scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+\n+                // keep rolling until we get an applicable one\n+                // TODO: have the AtBScenarioModifier sort these out instead for performance?\n+                while (scenarioModifier.getEventTiming() != EventTiming.PostForceGeneration) {\n+                    scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+                }\n+\n+                scenarioModifier.processModifier(scenario.getBackingScenario(), campaign, EventTiming.PostForceGeneration);\n+\n+                reportStatus.append(String.format(\" - reinforcement attempt succeeded; extra negative modifier (%s) applied to scenario.\",\n+                        scenarioModifier.getModifierName()));\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            // succeed without reservation\n+            } else {\n+                reportStatus.append(\" - reinforcement attempt succeeded;\");\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            }\n+        } else if (reinforcementType == ReinforcementEligibilityType.None) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Assigns a force to the scenario such that the majority of the force can be deployed\n+     */\n+    private static void assignAppropriateExtraForceToScenario(StratconScenario scenario,\n+            Map<MapLocation, List<Integer>> sortedAvailableForceIDs) {\n+        // the goal of this function is to avoid assigning ground units to air battles\n+        // and ground units/conventional fighters to space battle\n+\n+        List<MapLocation> mapLocations = new ArrayList<>();\n+        mapLocations.add(MapLocation.Space); // can always add ASFs\n+\n+        MapLocation scenarioMapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+\n+        if (scenarioMapLocation == MapLocation.LowAtmosphere) {\n+            mapLocations.add(MapLocation.LowAtmosphere); // can add conventional fighters to ground or low atmo battles\n+        }\n+\n+        if ((scenarioMapLocation == MapLocation.AllGroundTerrain) ||\n+                (scenarioMapLocation == MapLocation.SpecificGroundTerrain)) {\n+            mapLocations.add(MapLocation.AllGroundTerrain); // can only add ground units to ground battles\n+        }\n+\n+        MapLocation selectedLocation = mapLocations.get(Compute.randomInt(mapLocations.size()));\n+        List<Integer> forceIDs = sortedAvailableForceIDs.get(selectedLocation);\n+        int forceIndex = Compute.randomInt(forceIDs.size());\n+        int forceID = forceIDs.get(forceIndex);\n+        forceIDs.remove(forceIndex);\n+\n+        scenario.addPrimaryForce(forceID);\n+    }\n+\n+    /**\n+     * Worker function that \"locks in\" a scenario -\n+     * Adds it to the campaign so it's visible in the briefing room,\n+     * adds it to the track\n+     *\n+     */\n+    public static void commitPrimaryForces(Campaign campaign, StratconScenario scenario, StratconTrackState trackState) {\n+        trackState.addScenario(scenario);\n+\n+        // set up dates for the scenario if doesn't have them already\n+        if (scenario.getDeploymentDate() == null) {\n+            scenario.setDeploymentDate(campaign.getLocalDate());\n+        }\n+\n+        if (scenario.getActionDate() == null) {\n+            scenario.setActionDate(campaign.getLocalDate());\n+        }\n+\n+        if(scenario.getReturnDate() == null) {\n+            scenario.setReturnDate(campaign.getLocalDate().plusDays(trackState.getDeploymentTime()));\n+        }\n+\n+        // set the # of rerolls based on the actual lance assigned.\n+        int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+        scenario.getBackingScenario().setRerolls(tactics);\n+        // The number of defensive points available to a force entering a scenario is\n+        // 2 x tactics. By default, those points are spent on conventional minefields.\n+        if (commanderLanceHasDefensiveAssignment(scenario.getBackingScenario(), campaign)) {\n+            scenario.setNumDefensivePoints(tactics * 2);\n+            scenario.updateMinefieldCount(Minefield.TYPE_CONVENTIONAL, tactics * 2);\n+        }\n+\n+        for (int forceID : scenario.getPlayerTemplateForceIDs()) {\n+            Force force = campaign.getForce(forceID);\n+            force.clearScenarioIds(campaign, true);\n+            force.setScenarioId(scenario.getBackingScenarioID());\n+        }\n+\n+        scenario.commitPrimaryForces();\n+    }\n+\n+    /**\n+     * Utility method to determine if the current scenario's force commander\n+     * is on defence\n+     */\n+    private static boolean commanderLanceHasDefensiveAssignment(AtBDynamicScenario scenario, Campaign campaign) {\n+        Unit commanderUnit = scenario.getLanceCommander(campaign).getUnit();\n+        Lance lance = campaign.getLances().get(commanderUnit.getForceId());\n+\n+        if ((lance != null) && (lance.getRole() == AtBLanceRole.DEFENCE)) {\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * A hackish worker function that takes the given list of force IDs and\n+     * separates it into three sets;\n+     * one of forces that can be \"primary\" on a ground map\n+     * one of forces that can be \"primary\" on an atmospheric map\n+     * one of forces that can be \"primary\" in a space map\n+     * @param forceIDs List of force IDs to check\n+     * @return Sorted hash map\n+     */\n+    private static Map<MapLocation, List<Integer>> sortForcesByMapType(List<Integer> forceIDs, Campaign campaign) {\n+        Map<MapLocation, List<Integer>> retVal = new HashMap<>();\n+\n+        retVal.put(MapLocation.AllGroundTerrain, new ArrayList<>());\n+        retVal.put(MapLocation.LowAtmosphere, new ArrayList<>());\n+        retVal.put(MapLocation.Space, new ArrayList<>());\n+\n+        for (int forceID : forceIDs) {\n+            switch(campaign.getForce(forceID).getPrimaryUnitType(campaign)) {\n+            case UnitType.BATTLE_ARMOR:\n+            case UnitType.INFANTRY:\n+            case UnitType.MEK:\n+            case UnitType.TANK:\n+            case UnitType.PROTOMEK:\n+            case UnitType.VTOL:\n+                retVal.get(MapLocation.AllGroundTerrain).add(forceID);\n+                break;\n+            case UnitType.AERO:\n+                retVal.get(MapLocation.Space).add(forceID);\n+                // intentional fallthrough here, ASFs can go to atmospheric maps too\n+            case UnitType.CONV_FIGHTER:\n+                retVal.get(MapLocation.LowAtmosphere).add(forceID);\n+                break;\n+            }\n+        }\n+\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * Determine whether the user should be nagged about unresolved scenarios on AtB Stratcon tracks.\n+     * @param campaign Campaign to check.\n+     * @return An informative string containing the reasons the user was nagged.\n+     */\n+    public static String nagUnresolvedContacts(Campaign campaign) {\n+        StringBuilder sb = new StringBuilder();\n+\n+        // check every track attached to an active contract for unresolved scenarios\n+        // to which the player must deploy forces today\n+        for (AtBContract contract : campaign.getActiveAtBContracts()) {\n+            if (contract.getStratconCampaignState() == null) {\n+                continue;\n+            }\n+            \n+            for (StratconTrackState track : contract.getStratconCampaignState().getTracks()) {\n+                for (StratconScenario scenario : track.getScenarios().values()) {\n+                    if (scenario.getCurrentState() == ScenarioState.UNRESOLVED &&\n+                            campaign.getLocalDate().equals(scenario.getDeploymentDate())) {\n+                        // \"scenario name, track name\"\n+                        sb.append(String.format(\"%s, %s\\n\", scenario.getName(), track.getDisplayableName()));\n+                    }\n+                }\n+            }\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track.\n+     * Also registers it with the track and campaign.\n+     */\n+    private static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords) {\n+        int unitType = campaign.getForce(forceID).getPrimaryUnitType(campaign);\n+        ScenarioTemplate template = StratconScenarioFactory.getRandomScenario(unitType);\n+        // useful for debugging specific scenario types\n+        //ScenarioTemplate template = StratconScenarioFactory.getSpecificScenario(\"Hostile Facility.xml\");\n+\n+        return generateScenario(campaign, contract, track, forceID, coords, template);\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track,\n+     * using the given template. Also registers it with the campaign.\n+     */\n+    static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords, ScenarioTemplate template) {\n+        StratconScenario scenario = new StratconScenario();\n+        \n+        AtBDynamicScenario backingScenario = AtBDynamicScenarioFactory.initializeScenarioFromTemplate(template, contract, campaign);        \n+        scenario.setBackingScenario(backingScenario);\n+        scenario.setCoords(coords);\n+        \n+        // by default, certain conditions may make this bigger\n+        scenario.setRequiredPlayerLances(1);\n+\n+        // do an appropriate allied force if the contract calls for it\n+        // do any attached or integrated units\n+        setAlliedForceModifier(scenario, contract);\n+        setAttachedUnitsModifier(scenario, contract);\n+        applyFacilityModifiers(scenario, track, coords);\n+        applyGlobalModifiers(scenario, contract.getStratconCampaignState());\n+\n+        if ((contract.getCommandRights() == AtBContract.COM_HOUSE) ||\n+                (contract.getCommandRights() == AtBContract.COM_INTEGRATED)) {\n+            scenario.setRequiredScenario(true);\n+        }\n+\n+        AtBDynamicScenarioFactory.setScenarioModifiers(scenario.getBackingScenario());\n+        scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+        setScenarioDates(track, campaign, scenario);\n+        \n+        // the backing scenario ID must be updated after registering the backing scenario \n+        // with the campaign, so that the stratcon - backing scenario association is maintained\n+        // registering the scenario with the campaign should be done after setting\n+        // dates, otherwise, the report messages for new scenarios look weird\n+        campaign.addScenario(backingScenario, contract);\n+        scenario.setBackingScenarioID(backingScenario.getId());\n+        \n+        if (forceID > Force.FORCE_NONE) {\n+            scenario.addPrimaryForce(forceID);\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * Apply global scenario modifiers from campaign state to given scenario.\n+     */\n+    private static void applyGlobalModifiers(StratconScenario scenario, StratconCampaignState campaignState) {\n+        for (String modifierName : campaignState.getGlobalScenarioModifiers()) {\n+            AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierName);\n+\n+            if (modifier == null) {\n+                MekHQ.getLogger().error(String.format(\"Modifier %s not found; ignoring\", modifierName));\n+                continue;\n+            }\n+\n+            scenario.getBackingScenario().addScenarioModifier(modifier);\n+        }\n+    }\n+\n+    /**\n+     * Applies scenario modifiers from the current track to the given scenario.\n+     * @param scenario\n+     * @param track\n+     */\n+    private static void applyFacilityModifiers(StratconScenario scenario, StratconTrackState track, StratconCoords coords) {\n+        // loop through all the facilities on the track\n+        // if a facility has been revealed, then it has a 100% chance to apply its effect\n+        // if a facility has not been revealed, then it has a x% chance to apply its effect\n+        // if a facility is on the the scenario coordinates the it applies the local effects\n+        for (StratconCoords facilityCoords : track.getFacilities().keySet()) {\n+            boolean scenarioAtFacility = facilityCoords.equals(coords);\n+            StratconFacility facility = track.getFacilities().get(facilityCoords);\n+            List<String> modifierIDs = new ArrayList<>();\n+\n+            if (scenarioAtFacility) {\n+                modifierIDs = facility.getLocalModifiers();\n+            } else if (facility.isVisible() || (Compute.randomInt(100) <= facility.getAggroRating())) {\n+                modifierIDs = facility.getSharedModifiers();\n+            }\n+\n+            for (String modifierID : modifierIDs) {\n+                AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierID);\n+                if(modifier == null) {\n+                    MekHQ.getLogger().error(String.format(\"Modifier %s not found for facility %s\", modifierID, facility.getFormattedDisplayableName()));\n+                    continue;\n+                }\n+\n+                scenario.getBackingScenario().addScenarioModifier(modifier);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set up the appropriate primary allied force modifier, if any\n+     * @param contract The scenario's contract.\n+     */\n+    private static void setAlliedForceModifier(StratconScenario scenario, AtBContract contract) {\n+        int alliedUnitOdds = 0;\n+\n+        // first, we determine the odds of having an allied unit present\n+        // TODO: move this override out to the contract definition\n+        if (contract.getMissionType() == AtBContract.MT_RELIEFDUTY) {\n+            alliedUnitOdds = 50;\n+        } else {\n+            switch(contract.getCommandRights()) {\n+                case AtBContract.COM_INTEGRATED:\n+                    alliedUnitOdds = 50;\n+                    break;\n+                case AtBContract.COM_HOUSE:\n+                    alliedUnitOdds = 30;\n+                    break;\n+                case AtBContract.COM_LIAISON:\n+                    alliedUnitOdds = 10;\n+                    break;\n+            }\n+        }\n+\n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+\n+        // if an allied unit is present, then we want to make sure that it's ground units\n+        // for ground battles\n+        if (Compute.randomInt(100) <= alliedUnitOdds) {\n+            if((backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+               (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space)) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_ALLIED_AIR_UNITS));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_ALLIED_GROUND_UNITS));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set the 'attached' units modifier for the current scenario (integrated, house, liaison),\n+     * and make sure we're not deploying ground units to an air scenario\n+     * @param contract The scenario's contract\n+     */\n+    public static void setAttachedUnitsModifier(StratconScenario scenario, AtBContract contract) {\n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+        boolean airBattle = (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+                (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space);\n+\n+        // if we're on cadre duty, we're getting three trainees, period\n+        if (contract.getMissionType() == AtBContract.MT_CADREDUTY) {\n+            if (airBattle) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_TRAINEES_AIR));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_TRAINEES_GROUND));\n+            }\n+            return;\n+        }\n+\n+        // if we're under non-independent command rights, a supervisor may come along\n+        switch (contract.getCommandRights()) {\n+            case AtBContract.COM_INTEGRATED:\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(airBattle \n+                        ? MekHqConstants.SCENARIO_MODIFIER_INTEGRATED_UNITS_AIR\n+                        : MekHqConstants.SCENARIO_MODIFIER_INTEGRATED_UNITS_GROUND));\n+                break;\n+            case AtBContract.COM_HOUSE:\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(airBattle \n+                        ? MekHqConstants.SCENARIO_MODIFIER_HOUSE_CO_AIR\n+                        : MekHqConstants.SCENARIO_MODIFIER_HOUSE_CO_GROUND));\n+                break;\n+            case AtBContract.COM_LIAISON:\n+                if (scenario.isRequiredScenario()) {\n+                    backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(airBattle \n+                            ? MekHqConstants.SCENARIO_MODIFIER_LIAISON_AIR\n+                            : MekHqConstants.SCENARIO_MODIFIER_LIAISON_GROUND));\n+                }\n+                break;\n+        }\n+    }\n+\n+    /**\n+     * Worker function that sets scenario deploy/battle/return dates based on the track's properties and current campaign date\n+     */\n+    private static void setScenarioDates(StratconTrackState track, Campaign campaign, StratconScenario scenario) {\n+     // set up deployment day, battle day, return day here\n+        // safety code to prevent attempts to generate random int with upper bound of 0 which is apparently illegal\n+        int deploymentDay = track.getDeploymentTime() < 7 ? Compute.randomInt(7 - track.getDeploymentTime()) : 0;\n+        int battleDay = deploymentDay + (track.getDeploymentTime() > 0 ? Compute.randomInt(track.getDeploymentTime()) : 0);\n+        int returnDay = deploymentDay + track.getDeploymentTime();\n+\n+        LocalDate deploymentDate = campaign.getLocalDate();\n+        deploymentDate.plusDays(deploymentDay);\n+        LocalDate battleDate = campaign.getLocalDate();\n+        deploymentDate.plusDays(battleDay);\n+        LocalDate returnDate = campaign.getLocalDate();\n+        returnDate.plusDays(returnDay);\n+\n+        scenario.setDeploymentDate(deploymentDate);\n+        scenario.setActionDate(battleDate);\n+        scenario.setReturnDate(returnDate);\n+    }\n+\n+    /**\n+     * Helper function that determines if the unit type specified in the given scenario force template\n+     * would start out airborne on a ground map (hot dropped units aside)\n+     */\n+    private static boolean unitTypeIsAirborne(ScenarioForceTemplate template) {\n+        int unitType = template.getAllowedUnitType();\n+\n+        return (unitType == UnitType.AERO ||\n+                unitType == UnitType.CONV_FIGHTER ||\n+                unitType == UnitType.DROPSHIP ||\n+                unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_MIX) &&\n+                template.getStartingAltitude() > 0;\n+    }\n+\n+    /**\n+     * Determines whether the force in question has the same primary unit type as the force template.\n+     * @return Whether or not the unit types match.\n+     */\n+    public static boolean forceCompositionMatchesDeclaredUnitType(int primaryUnitType, int unitType, boolean reinforcements) {\n+        // special cases are \"ATB_MIX\" and \"ATB_AERO_MIX\", which encompass multiple unit types\n+        if (unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_MIX) {\n+            // \"AtB mix\" is usually ground units, but air units can sub in\n+            return primaryUnitType == UnitType.MEK ||\n+                    primaryUnitType == UnitType.TANK ||\n+                    primaryUnitType == UnitType.INFANTRY ||\n+                    primaryUnitType == UnitType.BATTLE_ARMOR ||\n+                    primaryUnitType == UnitType.PROTOMEK ||\n+                    primaryUnitType == UnitType.VTOL ||\n+                    (primaryUnitType == UnitType.AERO) && reinforcements ||\n+                    (primaryUnitType == UnitType.CONV_FIGHTER) && reinforcements;\n+        } else if (unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_AERO_MIX) {\n+            return primaryUnitType == UnitType.AERO ||\n+                    primaryUnitType == UnitType.CONV_FIGHTER;\n+        } else {\n+            return primaryUnitType == unitType;\n+        }\n+    }\n+\n+    /**\n+     * This is a set of all force IDs for forces that can be deployed to a scenario.\n+     * @param campaign Current campaign\n+     * @return Set of available force IDs.\n+     */\n+    public static List<Integer> getAvailableForceIDs(Campaign campaign) {\n+        List<Integer> retVal = new ArrayList<>();\n+\n+        // first, we gather a set of all forces that are already deployed to a track so we eliminate those later\n+        Set<Integer> forcesInTracks = new HashSet<>();\n+        for (Contract contract : campaign.getActiveContracts()) {\n+            if (contract instanceof AtBContract) {\n+                for (StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    forcesInTracks.addAll(track.getAssignedForceCoords().keySet());\n+                }\n+            }\n+        }\n+\n+        // now, we get all the forces that qualify as \"lances\", and filter out those that are\n+        // deployed to a scenario and not in a track already\n+        for (int key : campaign.getLances().keySet()) {\n+            Force force = campaign.getForce(key);\n+            if ((force != null) &&\n+                    !force.isDeployed() &&\n+                    !forcesInTracks.contains(force.getId())) {\n+                retVal.add(force.getId());\n+            }\n+        }\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * This is a list of all force IDs for forces that can be deployed to a scenario in the given force template\n+     * a) have not been assigned to a track\n+     * b) are combat-capable\n+     * c) are not deployed to a scenario\n+     * d) if attempting to deploy as reinforcements, haven't already failed to deploy\n+     */\n+    public static List<Integer> getAvailableForceIDs(int unitType, Campaign campaign, StratconTrackState currentTrack,\n+            boolean reinforcements, @Nullable StratconScenario currentScenario) {\n+        List<Integer> retVal = new ArrayList<>();\n+\n+        Set<Integer> forcesInTracks = new HashSet<>();\n+        // assemble a set of all force IDs that are currently assigned to tracks that are not this one\n+        for (Contract contract : campaign.getActiveContracts()) {\n+            if (contract instanceof AtBContract) {\n+                for (StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    if ((track != currentTrack) || !reinforcements) {\n+                        forcesInTracks.addAll(track.getAssignedForceCoords().keySet());\n+                    }\n+                }\n+            }\n+        }\n+        \n+        // if there's an existing scenario and we're doing reinforcements,\n+        // prevent forces that failed to deploy from trying to deploy again\n+        if (reinforcements && (currentScenario != null)) {\n+            forcesInTracks.addAll(currentScenario.getFailedReinforcements());\n+        }\n+\n+        for (int key : campaign.getLances().keySet()) {\n+            Force force = campaign.getForce(key);\n+\n+            if (force == null) {\n+                continue;\n+            }\n+\n+            int primaryUnitType = force.getPrimaryUnitType(campaign);\n+            if (!force.isDeployed() &&\n+                    (force.getScenarioId() <= 0) &&\n+                    !force.getUnits().isEmpty() &&\n+                    !forcesInTracks.contains(force.getId()) &&\n+                    forceCompositionMatchesDeclaredUnitType(primaryUnitType, unitType, reinforcements)) {\n+                retVal.add(force.getId());\n+            }\n+        }\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * Returns a list of individual units eligible for deployment in scenarios run by \"Defend\" lances\n+     * @return List of unit IDs.\n+     */\n+    public static List<Unit> getEligibleDefensiveUnits(Campaign campaign) {\n+        List<Unit> retVal = new ArrayList<>();\n+\n+        for (Unit u : campaign.getUnits()) {\n+            // \"defensive\" units are infantry, battle armor and (Weisman help you) gun emplacements\n+        \t// and also said unit should be intact/alive/etc\n+        \tboolean isEligibleInfantry = \n+        \t\t\t((u.getEntity().getUnitType() == UnitType.INFANTRY) ||\n+                    (u.getEntity().getUnitType() == UnitType.BATTLE_ARMOR)) &&\n+                    !u.isUnmanned();\n+        \t\n+        \tboolean isEligibleGunEmplacement = u.getEntity().getUnitType() == UnitType.GUN_EMPLACEMENT;\n+        \t\n+        \tif ((isEligibleInfantry || isEligibleGunEmplacement) && \n+            \t\t!u.isDeployed() &&\n+                    !u.isMothballed() &&\n+                    u.isFunctional()) {\n+\n+                // this is a little inefficient, but probably there aren't too many active AtB contracts at a time\n+                for (AtBContract contract : campaign.getActiveAtBContracts()) {\n+                    if (contract.getStratconCampaignState().isForceDeployedHere(u.getForceId())) {\n+                        continue;\n+                    }\n+                }\n+\n+                retVal.add(u);\n+            }\n+        }\n+\n+        return retVal;\n+    }\n+    \n+    /**\n+     * Returns a list of individual units eligible for deployment in scenarios\n+     * that result from the lance leader having a leadership score\n+     * @return List of unit IDs.\n+     */\n+    public static List<Unit> getEligibleLeadershipUnits(Campaign campaign, Set<Integer> forceIDs) {\n+        List<Unit> retVal = new ArrayList<>();\n+\n+        // The criteria are as follows:\n+        // - unit is of a different unit type than the primary unit type of the force \n+        // - unit has a lower BV than the force's lowest BV unit\n+        \n+        Integer lowestBV = getLowestBV(campaign, forceIDs);\n+        \n+        // no units assigned, the rest is meaningless.\n+        if (lowestBV == null) {\n+            return retVal;\n+        }\n+        \n+        int primaryUnitType = getPrimaryUnitType(campaign, forceIDs);\n+        \n+        for (Unit u : campaign.getUnits()) {\n+            if ((primaryUnitType != u.getEntity().getUnitType()) &&\n+                    !u.isDeployed() &&\n+                    !u.isMothballed() &&\n+                    u.isFunctional() &&\n+                    (u.getEntity().calculateBattleValue() < lowestBV) &&\n+                    !isUnitDeployedToStratCon(u)) {\n+                retVal.add(u);\n+            }\n+        }\n+\n+        return retVal;\n+    }\n+    \n+    /**\n+     * Check if the unit's force (if one exists) has been deployed to a StratCon track\n+     */\n+    public static boolean isUnitDeployedToStratCon(Unit u) {\n+        if (!u.getCampaign().getCampaignOptions().getUseStratCon()) {\n+            return false;\n+        }\n+        \n+        //this is a little inefficient, but probably there aren't too many active AtB contracts at a time\n+        for (AtBContract contract : u.getCampaign().getActiveAtBContracts()) {\n+            if (contract.getStratconCampaignState().isForceDeployedHere(u.getForceId())) {\n+                return true;\n+            }\n+        }\n+        \n+        return false;\n+    }\n+    \n+    /**\n+     * Given a campaign and a list of force IDs, calculate the unit with the lowest BV.\n+     */\n+    private static Integer getLowestBV(Campaign campaign, Set<Integer> forceIDs) {\n+        Integer lowestBV = null;\n+        \n+        for (int forceID : forceIDs) {\n+            Force force = campaign.getForce(forceID);\n+            if (force == null) {\n+                continue;\n+            }\n+            \n+            for (UUID id : force.getUnits()) {\n+                if (campaign.getUnit(id) == null) {\n+                    continue;\n+                }\n+                \n+                int currentBV = campaign.getUnit(id).getEntity().calculateBattleValue();\n+                \n+                if ((lowestBV == null) || (currentBV < lowestBV)) {\n+                    lowestBV = currentBV;\n+                }\n+            }\n+        }\n+        \n+        return lowestBV;\n+    }\n+    \n+    /**\n+     * Calculates the majority unit type for the forces given the IDs.\n+     */\n+    private static int getPrimaryUnitType(Campaign campaign, Set<Integer> forceIDs) {\n+        Map<Integer, Integer> unitTypeBuckets = new TreeMap<>();\n+        int biggestBucketID = -1;\n+        int biggestBucketCount = 0;\n+        \n+        for (int forceID : forceIDs) {\n+            Force force = campaign.getForce(forceID);\n+            if (force == null) {\n+                continue;\n+            }\n+        \n+            for (UUID id : force.getUnits()) {\n+                Unit unit = campaign.getUnit(id);\n+                if ((unit == null) || \n+                        (unit.getEntity() == null)) {\n+                    continue;\n+                }\n+                \n+                int unitType = unit.getEntity().getUnitType();\n+    \n+                unitTypeBuckets.merge(unitType, 1, (oldCount, value) -> oldCount + value);\n+                \n+                if (unitTypeBuckets.get(unitType) > biggestBucketCount) {\n+                    biggestBucketCount = unitTypeBuckets.get(unitType);\n+                    biggestBucketID = unitType;\n+                }\n+            }\n+        }\n+        \n+        return biggestBucketID;\n+    }\n+\n+    /**\n+     * Determines what rules to use when deploying a force for reinforcements to the given track.\n+     */\n+    public static ReinforcementEligibilityType getReinforcementType(int forceID,\n+            StratconTrackState trackState, Campaign campaign) {\n+        // if the force is currently deployed to the track, it'll be able to deploy \"for free\"\n+        if (trackState.isForceDeployed(forceID)) {\n+            return ReinforcementEligibilityType.ChainedScenario;\n+        }\n+\n+        // if the force is in 'fight' stance, it'll be able to deploy using 'fight lance' rules\n+        if (campaign.getLances().containsKey(forceID) &&\n+                campaign.getLances().get(forceID).getRole() == AtBLanceRole.FIGHTING) {\n+            return ReinforcementEligibilityType.FightLance;\n+        }\n+\n+        // if the force is deployed elsewhere, it cannot be deployed as reinforcements\n+        for (Contract contract : campaign.getActiveContracts()) {\n+            if(contract instanceof AtBContract) {\n+                for(StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    if(track != trackState && track.getAssignedForceCoords().containsKey(forceID)) {\n+                        return ReinforcementEligibilityType.None;\n+                    }\n+                }\n+            }\n+        }\n+\n+        // otherwise, the force requires support points / vps to deploy\n+        return ReinforcementEligibilityType.SupportPoint;\n+    }\n+    \n+    /**\n+     * Given a track and the current campaign state, and if the player is deploying\n+     * a force or not, figure out the odds of a scenario occuring.\n+     */\n+    public static int calculateScenarioOdds(StratconTrackState track, \n+            AtBContract contract, boolean playerDeployingForce) {\n+        // rules:\n+        // rout morale: 0%\n+        // very low morale: -10% when deploying forces to track, 0% attack\n+        // low morale: -5%\n+        // high morale: +5%\n+        // invincible: special case, let's do +10% for now\n+        int moraleModifier = 0;\n+        \n+        switch (contract.getMoraleLevel()) {\n+            case AtBContract.MORALE_ROUT:\n+                return 0;\n+            case AtBContract.MORALE_VERYLOW:\n+                if (playerDeployingForce) {\n+                    moraleModifier = -10;\n+                } else {\n+                    return 0;\n+                }\n+                break;\n+            case AtBContract.MORALE_LOW:\n+                moraleModifier = -5;\n+                break;\n+            case AtBContract.MORALE_HIGH:\n+                moraleModifier = 5;\n+                break;\n+            case AtBContract.MORALE_INVINCIBLE:\n+                moraleModifier = 10;\n+                break;\n+        }\n+        \n+        // facilities: for each hostile data center, add +5%\n+        // for each allied data center, subtract 5\n+        int dataCenterModifier = 0;\n+        for (StratconFacility facility : track.getFacilities().values()) {\n+            if (facility.getFacilityType() == FacilityType.DataCenter) {\n+                dataCenterModifier += facility.getOwner() == ForceAlignment.Allied ? -5 : 5;\n+            }\n+        }\n+            \n+        return track.getScenarioOdds() + moraleModifier + dataCenterModifier;\n+    }\n+\n+    /**\n+     * Removes the facility associated with the given scenario from the relevant track/\n+     */\n+    public static void updateFacilityForScenario(AtBScenario scenario, AtBContract contract, boolean destroy, boolean capture) {\n+        if (contract.getStratconCampaignState() == null) {\n+            return;\n+        }\n+\n+        // this is kind of kludgy, but there's currently no way to link a scenario back to its backing scenario\n+        // TODO: introduce mapping in contract or at least trackstate\n+        // basically, we're looping through all scenarios on all the contract's tracks\n+        // if we find one with the same ID as the one being resolved, that's our facility: get rid of it.\n+        for (StratconTrackState trackState : contract.getStratconCampaignState().getTracks()) {\n+            for (StratconCoords coords : trackState.getScenarios().keySet()) {\n+                StratconScenario potentialScenario = trackState.getScenario(coords);\n+                if (potentialScenario.getBackingScenarioID() == scenario.getId()) {\n+\n+                    if (destroy) {\n+                        trackState.removeFacility(coords);\n+                    } else {\n+                        StratconFacility facility = trackState.getFacility(coords);\n+\n+                        if (facility == null) {\n+                            continue;\n+                        }\n+\n+                        if (capture) {\n+                            facility.incrementOwnershipChangeScore();\n+                        } else {\n+                            facility.decrementOwnershipChangeScore();\n+                        }\n+                    }\n+\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Processes completion of a Stratcon scenario, if the given tracker is associated\n+     * with a stratcon-enabled mission. Intended to be called after ResolveScenarioTracker.finish() has been invoked.\n+     */\n+    public static void processScenarioCompletion(ResolveScenarioTracker rst) {\n+        if (rst.getMission() instanceof AtBContract) {\n+            StratconCampaignState campaignState = ((AtBContract) rst.getMission()).getStratconCampaignState();\n+            if (campaignState == null) {\n+                return;\n+            }\n+\n+            for (StratconTrackState track : campaignState.getTracks()) {\n+                if (track.getBackingScenariosMap().containsKey(rst.getScenario().getId())) {\n+                    // things that may potentially happen:\n+                    // scenario is removed from track - implemented\n+                    // track gets remaining forces added to reinforcement pool\n+                    // facility gets remaining forces stored in reinforcement pool\n+                    // process VP and SO\n+\n+                    StratconScenario scenario = track.getBackingScenariosMap().get(rst.getScenario().getId());\n+\n+\n+                    StratconFacility facility = track.getFacility(scenario.getCoords());\n+\n+                    if ((facility != null) && (facility.getOwnershipChangeScore() > 0)) {\n+                        if (facility.getOwner() == ForceAlignment.Allied) {\n+                            facility.setOwner(ForceAlignment.Opposing);\n+                        } else {\n+                            facility.setOwner(ForceAlignment.Allied);\n+                        }\n+                    }\n+\n+                    boolean victory = rst.getScenario().getStatus() == Scenario.S_VICTORY ||\n+                            rst.getScenario().getStatus() == Scenario.S_MVICTORY;\n+\n+                    if (scenario.isRequiredScenario()) {\n+                        campaignState.updateVictoryPoints(victory ? 1 : -1);\n+                    }\n+\n+                    if (scenario.isStrategicObjective()) {\n+                        if (campaignState.strategicObjectivesBehaveAsVPs()) {\n+                            campaignState.updateVictoryPoints(victory ? 1 : -1);\n+                        } else {\n+                            campaignState.incrementStrategicObjectiveCompletedCount();\n+                        }\n+                    }\n+\n+                    processTrackForceReturnDates(track, rst.getCampaign().getLocalDate());\n+\n+                    track.removeScenario(scenario);\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Worker function that goes through a track and undeploys any forces where the\n+     * return date is on or before the given date.\n+     */\n+    public static void processTrackForceReturnDates(StratconTrackState track, LocalDate date) {\n+        List<Integer> forcesToUndeploy = new ArrayList<>();\n+\n+        // for each force on the track, if the return date is today or in the past,\n+        // \"return to base\", unless it's been told to stay in the field\n+        for (int forceID : track.getAssignedForceReturnDates().keySet()) {\n+            if ((track.getAssignedForceReturnDates().get(forceID).equals(date) ||\n+                    track.getAssignedForceReturnDates().get(forceID).isBefore(date)) &&\n+                    !track.getStickyForces().contains(forceID)) {\n+                forcesToUndeploy.add(forceID);\n+            }\n+        }\n+\n+        for (int forceID : forcesToUndeploy) {\n+            track.unassignForce(forceID);\n+        }\n+    }\n+    \n+    /**\n+     * Processes an ignored dynamic scenario - locates it on one of the tracks\n+     * and calls the standared 'ignored scenario' routine.\n+     * @return Whether or not we also need to get rid of the backing scenario from the campaign\n+     */\n+    public static boolean processIgnoredScenario(AtBDynamicScenario scenario, StratconCampaignState campaignState) {\n+        for (StratconTrackState track : campaignState.getTracks()) {\n+            if (track.getBackingScenariosMap().containsKey(scenario.getId())) {\n+                return processIgnoredScenario(track.getBackingScenariosMap().get(scenario.getId()), campaignState);\n+            }\n+        }\n+        \n+        return true;\n+    }\n+    \n+\n+    /**\n+     * Processes an ignored Stratcon scenario\n+     * @return Whether or not we also need to get rid of the backing scenario from the campaign\n+     */\n+    public static boolean processIgnoredScenario(StratconScenario scenario, StratconCampaignState campaignState) {\n+        for (StratconTrackState track : campaignState.getTracks()) {\n+            if (track.getScenarios().containsKey(scenario.getCoords())) {\n+                // subtract VP if scenario is 'required'\n+                if (scenario.isRequiredScenario()) {\n+                    campaignState.updateVictoryPoints(-1);\n+                }\n+                \n+                track.removeScenario(scenario);\n+\n+                StratconFacility localFacility = track.getFacility(scenario.getCoords());\n+                if (localFacility != null) {\n+                    // if the ignored scenario was on top of an allied facility\n+                    // then it'll get captured, and the player will possibly lose a SO\n+                    if (localFacility.getOwner() == ForceAlignment.Allied) {\n+                        localFacility.setOwner(ForceAlignment.Opposing);\n+\n+                        if (localFacility.isStrategicObjective()) {\n+                            campaignState.decrementStrategicObjectiveCompletedCount();\n+                        }\n+                    }\n+                    \n+                    return true;\n+                } else {\n+                    // if it's an open-field\n+                    // move scenario towards nearest allied facility\n+                    StratconCoords closestAlliedFacilityCoords = track.findClosestAlliedFacilityCoords(scenario.getCoords());\n+\n+                    if (closestAlliedFacilityCoords != null) {\n+                        StratconCoords newCoords = scenario.getCoords().translate(scenario.getCoords().direction(closestAlliedFacilityCoords));\n+                        scenario.setCoords(newCoords);\n+                        \n+                        int daysForward = Math.min(1, track.getDeploymentTime());\n+                        \n+                        scenario.setDeploymentDate(scenario.getDeploymentDate().plusDays(daysForward));\n+                        scenario.setActionDate(scenario.getActionDate().plusDays(daysForward));\n+                        scenario.setReturnDate(scenario.getReturnDate().plusDays(daysForward));\n+                        \n+                        // refresh the scenario's position on the track\n+                        track.addScenario(scenario);\n+                        \n+                        // TODO: Write some functionality to \"copy\" a scenario's \n+                        // bot forces over\n+                        /*StratconFacility facility = track.getFacility(newCoords);\n+\n+                        if (facility != null) {\n+                            ScenarioTemplate template = StratconScenarioFactory.getFacilityScenario(true);\n+                            scenario = generateScenario(campaignState.getCa, contract, track, forceID, coords, template);\n+                            setupFacilityScenario(scenario, facility);\n+                        }*/\n+\n+                        // TODO: if the allied facility is in the new coords, replace this scenario\n+                        // with a facility defense, with the opfor coming directly from all hostiles assigned to this scenario\n+\n+                        scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                        return false;\n+                    } else {\n+                        // TODO: if there's no allied facilities here, add its forces to track reinforcement pool\n+                        return true;\n+                    }\n+                }\n+            }\n+        }\n+        \n+        // if we couldn't find the scenario on any tracks, then let's just \n+        // rid of any underlying AtB scenarios as well\n+        return true;\n+    }\n+\n+    public void startup() {\n+        MekHQ.registerHandler(this);\n+    }\n+\n+    /**\n+     * Event handler for the new day event.\n+     */\n+    @Subscribe\n+    public void handleNewDay(NewDayEvent ev) {\n+    \t// don't do any of this if StratCon isn't turned on\n+    \tif (!ev.getCampaign().getCampaignOptions().getUseStratCon()) {\n+    \t\treturn;", "originalCommit": "b36d9fa6bf982c7b833b1ac0a0473d37f6e84760", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTE5Mjg1Mg==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r615192852", "bodyText": "Suggested change", "author": "Windchild292", "createdAt": "2021-04-17T02:15:27Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1404 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.UUID;\n+\n+import megamek.common.Compute;\n+import megamek.common.Minefield;\n+import megamek.common.UnitType;\n+import megamek.common.annotations.Nullable;\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.Utilities;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.ResolveScenarioTracker;\n+import mekhq.campaign.againstTheBot.enums.AtBLanceRole;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.event.StratconDeploymentEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.force.Lance;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier.EventTiming;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconFacility.FacilityType;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.unit.Unit;\n+\n+/**\n+ * This class contains \"rules\" logic for the AtB-Stratcon state\n+ * @author NickAragua\n+ */\n+public class StratconRulesManager {\n+    /**\n+     * What makes a particular lance eligible to be reinforcements for a scenario\n+     */\n+    public enum ReinforcementEligibilityType {\n+        /**\n+         * Nothing\n+         */\n+        None,\n+\n+        /**\n+         * Lance is already deployed to the track\n+         */\n+        ChainedScenario,\n+\n+        /**\n+         * We pay a support point or convert a victory point to a support point\n+         */\n+        SupportPoint,\n+\n+        /**\n+         * The lance's deployment orders are \"Fight\"\n+         */\n+        FightLance\n+    }\n+\n+    /**\n+     * This function potentially generates non-player-initiated scenarios for the given track.\n+     */\n+    public static void generateScenariosForTrack(Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // maps scenarios to force IDs\n+        List<StratconScenario> generatedScenarios = new ArrayList<>();\n+        boolean autoAssignLances = contract.getCommandRights() == AtBContract.COM_INTEGRATED;\n+\n+        // get this list just so we have it available\n+        List<Integer> availableForceIDs = getAvailableForceIDs(campaign);\n+        Map<MapLocation, List<Integer>> sortedAvailableForceIDs = sortForcesByMapType(availableForceIDs, campaign);\n+\n+        // make X rolls, where X is the number of required lances for the track\n+        // that's the chance to spawn a scenario.\n+        // if a scenario occurs, then we pick a random non-deployed lance and use it to drive the opfor generation later\n+        // once we've determined that scenarios occur, we loop through the ones that we generated\n+        // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all\n+        for (int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            int targetNum = calculateScenarioOdds(track, contract, false);\n+            \n+            // if we haven't already used all the player forces and are required to randomly generate a scenario\n+            if (!availableForceIDs.isEmpty() && (Compute.randomInt(100) <= targetNum)) {\n+                // pick random coordinates and force to drive the scenario\n+                int x = Compute.randomInt(track.getWidth());\n+                int y = Compute.randomInt(track.getHeight());\n+\n+                StratconCoords scenarioCoords = new StratconCoords(x, y);\n+\n+                // if forces are already assigned to these coordinates, use those instead\n+                // of randomly-selected ones\n+                if (track.getAssignedCoordForces().containsKey(scenarioCoords)) {\n+                    StratconScenario scenario = generateScenarioForExistingForces(scenarioCoords,\n+                            track.getAssignedCoordForces().get(scenarioCoords), \n+                            contract, campaign, track);\n+                    generatedScenarios.add(scenario);\n+                    continue;\n+                }\n+                \n+                // otherwise, pick a random force from the avail\n+                int randomForceIndex = Compute.randomInt(availableForceIDs.size());\n+                int randomForceID = availableForceIDs.get(randomForceIndex);\n+                \n+                // remove the force from the available lists so we don't designate it as primary twice\n+                availableForceIDs.remove(randomForceIndex);\n+\n+                // we want to remove the actual int with the value, not the value at the index\n+                sortedAvailableForceIDs.get(MapLocation.AllGroundTerrain).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.LowAtmosphere).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.Space).remove((Integer) randomForceID);\n+\n+                // two scenarios on the same coordinates wind up increasing in size\n+                if (track.getScenarios().containsKey(scenarioCoords)) {\n+                    track.getScenarios().get(scenarioCoords).incrementRequiredPlayerLances();\n+                    assignAppropriateExtraForceToScenario(track.getScenarios().get(scenarioCoords), sortedAvailableForceIDs);\n+                    continue;\n+                }\n+\n+                StratconScenario scenario = setupScenario(scenarioCoords, randomForceID, campaign, contract, track);\n+                generatedScenarios.add(scenario);\n+\n+                // if we're auto-assigning lances, deploy the force to the track as well\n+                if (autoAssignLances) {\n+                    processForceDeployment(scenarioCoords, randomForceID, campaign, track, false);\n+                }\n+            }\n+        }\n+\n+        // if under liaison command, pick a random scenario from the ones generated\n+        // to set as required and attach liaison\n+        if (contract.getCommandRights() == AtBContract.COM_LIAISON) {\n+        \tStratconScenario randomScenario = Utilities.getRandomItem(generatedScenarios);\n+        \trandomScenario.setRequiredScenario(true);\n+            setAttachedUnitsModifier(randomScenario, contract);\n+        }\n+\n+        // now, we loop through all the scenarios we set up\n+        // and generate the opfors / events / etc\n+        // if not auto-assigning lances, we then back out the lance assignments.\n+        for (StratconScenario scenario : generatedScenarios) {\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+\n+            if(!autoAssignLances && !scenario.ignoreForceAutoAssignment()) {\n+                for(int forceID : scenario.getPlayerTemplateForceIDs()) {\n+                    scenario.getBackingScenario().removeForce(forceID);\n+                }\n+\n+                scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                track.addScenario(scenario);\n+            } else {\n+                commitPrimaryForces(campaign, scenario, track);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Given a set of force IDs and coordinates, generate a scenario\n+     * Useful for when we want to generate scenarios \n+     * for forces already deployed to a track\n+     */\n+    public static StratconScenario generateScenarioForExistingForces(StratconCoords scenarioCoords, \n+            Set<Integer> forceIDs, AtBContract contract, Campaign campaign, StratconTrackState track) {\n+        boolean firstForce = true;\n+        StratconScenario scenario = null;\n+        \n+        for (int forceID : forceIDs) {\n+            if (firstForce) {\n+                scenario = setupScenario(scenarioCoords, forceID, campaign, contract, track);\n+                firstForce = false;\n+            } else {\n+                scenario.incrementRequiredPlayerLances();\n+                scenario.addPrimaryForce(forceID);\n+            }\n+        }\n+        \n+        // this is theoretically possible if forceIDs is passed in as null - not likely in practice\n+        // but might as well, to future-proof.\n+        if (scenario != null) {\n+            scenario.setIgnoreForceAutoAssignment(true);\n+        }\n+        \n+        return scenario;\n+    }\n+\n+    /**\n+     * Deploys a force to the given coordinates on the given track as a result of explicit player action.\n+     */\n+    public static void deployForceToCoords(StratconCoords coords, int forceID, \n+            Campaign campaign, AtBContract contract, StratconTrackState track, boolean sticky) {\n+        // the following things should happen:\n+        // 1. call to \"process force deployment\", which reveals fog of war in or around the coords, depending on force role\n+        // 2. if coords are a hostile facility, we get a facility mission\n+        // 3. if coords are empty, we *may* get a mission\n+\n+        processForceDeployment(coords, forceID, campaign, track, sticky);\n+\n+        // don't create a scenario on top of allied facilities\n+        StratconFacility facility = track.getFacility(coords);\n+        boolean isNonAlliedFacility = (facility != null) && (facility.getOwner() != ForceAlignment.Allied);\n+        int targetNum = calculateScenarioOdds(track, contract, true);\n+        boolean spawnScenario = (facility == null) && (Compute.randomInt(100) <= targetNum);\n+\n+        if (isNonAlliedFacility || spawnScenario) {\n+            StratconScenario scenario = setupScenario(coords, forceID, campaign, contract, track);\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            commitPrimaryForces(campaign, scenario, track);\n+        }\n+    }\n+\n+    /**\n+     * Logic to set up a scenario\n+     */\n+    private static StratconScenario setupScenario(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        StratconScenario scenario = null;\n+\n+        if (track.getFacilities().containsKey(coords)) {\n+            StratconFacility facility = track.getFacility(coords);\n+            boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+            ScenarioTemplate template = StratconScenarioFactory.getFacilityScenario(alliedFacility);\n+            scenario = generateScenario(campaign, contract, track, forceID, coords, template);\n+            setupFacilityScenario(scenario, facility);\n+        } else {\n+            scenario = generateScenario(campaign, contract, track, forceID, coords);\n+\n+            // we may generate a facility scenario randomly - if so, do the facility-related stuff\n+            // and add a new facility to the track\n+            if (scenario.getBackingScenario().getTemplate().isFacilityScenario()) {\n+                StratconFacility facility = scenario.getBackingScenario().getTemplate().isHostileFacility() ?\n+                        StratconFacilityFactory.getRandomHostileFacility() : StratconFacilityFactory.getRandomAlliedFacility();\n+                facility.setVisible(true);\n+                track.addFacility(coords, facility);\n+                setupFacilityScenario(scenario, facility);\n+            }\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * carries out tasks relevant to facility scenarios\n+     */\n+    private static void setupFacilityScenario(StratconScenario scenario, StratconFacility facility) {\n+        // this includes:\n+        // for hostile facilities\n+        // - add a destroy objective (always the option to level the facility)\n+        // - add a capture objective (always the option to capture the facility)\n+        // - if so indicated by parameter, roll a random hostile facility objective and add it if not capture/destroy\n+        // for allied facilities\n+        // - add a defend objective (always the option to defend the facility)\n+        // - if so indicated by parameter, roll a random allied facility objective and add it if not defend\n+        AtBScenarioModifier objectiveModifier = null;\n+        boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+\n+        if (alliedFacility) {\n+            objectiveModifier = AtBScenarioModifier.getRandomAlliedFacilityModifier();\n+        } else {\n+            objectiveModifier = AtBScenarioModifier.getRandomHostileFacilityModifier();\n+        }\n+\n+        if (objectiveModifier != null) {\n+            scenario.getBackingScenario().addScenarioModifier(objectiveModifier);\n+            scenario.getBackingScenario().setName(String.format(\"%s - %s - %s\",\n+                    facility.getFacilityType(), alliedFacility ? \"Allied\" : \"Hostile\", objectiveModifier.getModifierName()));\n+        }\n+\n+        // add the \"fixed\" hostile facility modifiers after the primary ones\n+        if (!alliedFacility) {\n+            for(AtBScenarioModifier modifier : AtBScenarioModifier.getRequiredHostileFacilityModifiers()) {\n+                if(!scenario.getBackingScenario().alreadyHasModifier(modifier)) {\n+                    scenario.getBackingScenario().addScenarioModifier(modifier);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void processFacilityEffects(StratconTrackState track) {\n+        // TODO: these are \"weekly\"? effects that a stratcon facility has on the campaign/track state\n+        // currrently, that's\n+        // supply depot - allied - +1 sp\n+        // supply depot - hostile - +5% BV budget to all scenarios on track (shared modifier, so should be implemented there)\n+        // data center - allied - +1% star league cache contract (don't implement yet, but...)\n+        // data center - hostile - +5% scenario odds in track\n+        // industrial center - allied - all scenarios here have THIS IS COMING OUT OF YOUR PAYCHECK modifier\n+        // orbital defense - allied - sets 'no hostile aircraft' flag for track\n+        // orbital defense - hostile - sets 'no allied aircraft' flag for track\n+        // early warning system - allied - sets 'intercept allied base attacks' flag for track\n+        // early warning system - hostile - sets 'intercept hostile base attacks' flag for track\n+    }\n+\n+    /**\n+     * Process the deployment of a force to the given coordinates on the given track.\n+     */\n+    public static void processForceDeployment(StratconCoords coords, int forceID, \n+            Campaign campaign, StratconTrackState track, boolean sticky) {\n+        track.getRevealedCoords().add(coords);\n+        StratconFacility facility = track.getFacility(coords);\n+        if (facility != null) {\n+            facility.setVisible(true);\n+        }\n+\n+        if (campaign.getLances().get(forceID).getRole() == AtBLanceRole.SCOUTING) {\n+            for(int direction = 0; direction < 6; direction++) {\n+                StratconCoords checkCoords = coords.translate(direction);\n+\n+                facility = track.getFacility(checkCoords);\n+                if(facility != null) {\n+                    facility.setVisible(true);\n+                }\n+\n+                track.getRevealedCoords().add(coords.translate(direction));\n+            }\n+        }\n+\n+        // the force may be located in other places on the track - clear it out\n+        track.unassignForce(forceID);\n+        track.assignForce(forceID, coords, campaign.getLocalDate(), sticky);\n+        MekHQ.triggerEvent(new StratconDeploymentEvent(campaign.getForce(forceID)));\n+    }\n+\n+    /**\n+     * Worker function that processes the effects of deploying a reinforcement force to a scenario\n+     */\n+    public static boolean processReinforcementDeployment(ReinforcementEligibilityType reinforcementType,\n+            StratconCampaignState campaignState, StratconScenario scenario, Campaign campaign) {\n+        // if the force is already deployed to the track, we're done\n+        // if the force is a fight lance or we're using a support point\n+        // if there is an SP to burn, burn it and we're done\n+        // if there is a VP to burn, burn it and we're done\n+        // now, roll 2d6 + lance commander tactics\n+        // 9+ = deploy\n+        // 6+ = deploy, apply negative modifier to scenario\n+        // 2+ = fail to deploy, apply negative modifier to scenario; if fight lance, treat as 6+\n+\n+        if ((reinforcementType == ReinforcementEligibilityType.FightLance) ||\n+                (reinforcementType == ReinforcementEligibilityType.SupportPoint)) {\n+\n+            if (campaignState.getSupportPoints() > 0) {\n+                campaignState.useSupportPoint();\n+                return true;\n+            } else if (campaignState.getVictoryPoints() > 0) {\n+                campaignState.updateVictoryPoints(-1);\n+                return true;\n+            }\n+\n+            int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+            int roll = Compute.d6(2);\n+            int result = roll + tactics;\n+\n+            StringBuilder reportStatus = new StringBuilder();\n+            reportStatus.append(String.format(\"Attempting to reinforce scenario %s without SP/VP, roll 2d6 + %d: %d\",\n+                    scenario.getName(), tactics, result));\n+\n+            // fail to reinforce\n+            if ((result < 6) && (reinforcementType != ReinforcementEligibilityType.FightLance)) {\n+                reportStatus.append(\" - reinforcement attempt failed.\");\n+                campaign.addReport(reportStatus.toString());\n+                return false;\n+            // succeed but get an extra negative event added to the scenario\n+            } else if (result < 9) {\n+                MapLocation mapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+                AtBScenarioModifier scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+\n+                // keep rolling until we get an applicable one\n+                // TODO: have the AtBScenarioModifier sort these out instead for performance?\n+                while (scenarioModifier.getEventTiming() != EventTiming.PostForceGeneration) {\n+                    scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+                }\n+\n+                scenarioModifier.processModifier(scenario.getBackingScenario(), campaign, EventTiming.PostForceGeneration);\n+\n+                reportStatus.append(String.format(\" - reinforcement attempt succeeded; extra negative modifier (%s) applied to scenario.\",\n+                        scenarioModifier.getModifierName()));\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            // succeed without reservation\n+            } else {\n+                reportStatus.append(\" - reinforcement attempt succeeded;\");\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            }\n+        } else if (reinforcementType == ReinforcementEligibilityType.None) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Assigns a force to the scenario such that the majority of the force can be deployed\n+     */\n+    private static void assignAppropriateExtraForceToScenario(StratconScenario scenario,\n+            Map<MapLocation, List<Integer>> sortedAvailableForceIDs) {\n+        // the goal of this function is to avoid assigning ground units to air battles\n+        // and ground units/conventional fighters to space battle\n+\n+        List<MapLocation> mapLocations = new ArrayList<>();\n+        mapLocations.add(MapLocation.Space); // can always add ASFs\n+\n+        MapLocation scenarioMapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+\n+        if (scenarioMapLocation == MapLocation.LowAtmosphere) {\n+            mapLocations.add(MapLocation.LowAtmosphere); // can add conventional fighters to ground or low atmo battles\n+        }\n+\n+        if ((scenarioMapLocation == MapLocation.AllGroundTerrain) ||\n+                (scenarioMapLocation == MapLocation.SpecificGroundTerrain)) {\n+            mapLocations.add(MapLocation.AllGroundTerrain); // can only add ground units to ground battles\n+        }\n+\n+        MapLocation selectedLocation = mapLocations.get(Compute.randomInt(mapLocations.size()));\n+        List<Integer> forceIDs = sortedAvailableForceIDs.get(selectedLocation);\n+        int forceIndex = Compute.randomInt(forceIDs.size());\n+        int forceID = forceIDs.get(forceIndex);\n+        forceIDs.remove(forceIndex);\n+\n+        scenario.addPrimaryForce(forceID);\n+    }\n+\n+    /**\n+     * Worker function that \"locks in\" a scenario -\n+     * Adds it to the campaign so it's visible in the briefing room,\n+     * adds it to the track\n+     *\n+     */\n+    public static void commitPrimaryForces(Campaign campaign, StratconScenario scenario, StratconTrackState trackState) {\n+        trackState.addScenario(scenario);\n+\n+        // set up dates for the scenario if doesn't have them already\n+        if (scenario.getDeploymentDate() == null) {\n+            scenario.setDeploymentDate(campaign.getLocalDate());\n+        }\n+\n+        if (scenario.getActionDate() == null) {\n+            scenario.setActionDate(campaign.getLocalDate());\n+        }\n+\n+        if(scenario.getReturnDate() == null) {\n+            scenario.setReturnDate(campaign.getLocalDate().plusDays(trackState.getDeploymentTime()));\n+        }\n+\n+        // set the # of rerolls based on the actual lance assigned.\n+        int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+        scenario.getBackingScenario().setRerolls(tactics);\n+        // The number of defensive points available to a force entering a scenario is\n+        // 2 x tactics. By default, those points are spent on conventional minefields.\n+        if (commanderLanceHasDefensiveAssignment(scenario.getBackingScenario(), campaign)) {\n+            scenario.setNumDefensivePoints(tactics * 2);\n+            scenario.updateMinefieldCount(Minefield.TYPE_CONVENTIONAL, tactics * 2);\n+        }\n+\n+        for (int forceID : scenario.getPlayerTemplateForceIDs()) {\n+            Force force = campaign.getForce(forceID);\n+            force.clearScenarioIds(campaign, true);\n+            force.setScenarioId(scenario.getBackingScenarioID());\n+        }\n+\n+        scenario.commitPrimaryForces();\n+    }\n+\n+    /**\n+     * Utility method to determine if the current scenario's force commander\n+     * is on defence\n+     */\n+    private static boolean commanderLanceHasDefensiveAssignment(AtBDynamicScenario scenario, Campaign campaign) {\n+        Unit commanderUnit = scenario.getLanceCommander(campaign).getUnit();\n+        Lance lance = campaign.getLances().get(commanderUnit.getForceId());\n+\n+        if ((lance != null) && (lance.getRole() == AtBLanceRole.DEFENCE)) {\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * A hackish worker function that takes the given list of force IDs and\n+     * separates it into three sets;\n+     * one of forces that can be \"primary\" on a ground map\n+     * one of forces that can be \"primary\" on an atmospheric map\n+     * one of forces that can be \"primary\" in a space map\n+     * @param forceIDs List of force IDs to check\n+     * @return Sorted hash map\n+     */\n+    private static Map<MapLocation, List<Integer>> sortForcesByMapType(List<Integer> forceIDs, Campaign campaign) {\n+        Map<MapLocation, List<Integer>> retVal = new HashMap<>();\n+\n+        retVal.put(MapLocation.AllGroundTerrain, new ArrayList<>());\n+        retVal.put(MapLocation.LowAtmosphere, new ArrayList<>());\n+        retVal.put(MapLocation.Space, new ArrayList<>());\n+\n+        for (int forceID : forceIDs) {\n+            switch(campaign.getForce(forceID).getPrimaryUnitType(campaign)) {\n+            case UnitType.BATTLE_ARMOR:\n+            case UnitType.INFANTRY:\n+            case UnitType.MEK:\n+            case UnitType.TANK:\n+            case UnitType.PROTOMEK:\n+            case UnitType.VTOL:\n+                retVal.get(MapLocation.AllGroundTerrain).add(forceID);\n+                break;\n+            case UnitType.AERO:\n+                retVal.get(MapLocation.Space).add(forceID);\n+                // intentional fallthrough here, ASFs can go to atmospheric maps too\n+            case UnitType.CONV_FIGHTER:\n+                retVal.get(MapLocation.LowAtmosphere).add(forceID);\n+                break;\n+            }\n+        }\n+\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * Determine whether the user should be nagged about unresolved scenarios on AtB Stratcon tracks.\n+     * @param campaign Campaign to check.\n+     * @return An informative string containing the reasons the user was nagged.\n+     */\n+    public static String nagUnresolvedContacts(Campaign campaign) {\n+        StringBuilder sb = new StringBuilder();\n+\n+        // check every track attached to an active contract for unresolved scenarios\n+        // to which the player must deploy forces today\n+        for (AtBContract contract : campaign.getActiveAtBContracts()) {\n+            if (contract.getStratconCampaignState() == null) {\n+                continue;\n+            }\n+            \n+            for (StratconTrackState track : contract.getStratconCampaignState().getTracks()) {\n+                for (StratconScenario scenario : track.getScenarios().values()) {\n+                    if (scenario.getCurrentState() == ScenarioState.UNRESOLVED &&\n+                            campaign.getLocalDate().equals(scenario.getDeploymentDate())) {\n+                        // \"scenario name, track name\"\n+                        sb.append(String.format(\"%s, %s\\n\", scenario.getName(), track.getDisplayableName()));\n+                    }\n+                }\n+            }\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track.\n+     * Also registers it with the track and campaign.\n+     */\n+    private static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords) {\n+        int unitType = campaign.getForce(forceID).getPrimaryUnitType(campaign);\n+        ScenarioTemplate template = StratconScenarioFactory.getRandomScenario(unitType);\n+        // useful for debugging specific scenario types\n+        //ScenarioTemplate template = StratconScenarioFactory.getSpecificScenario(\"Hostile Facility.xml\");\n+\n+        return generateScenario(campaign, contract, track, forceID, coords, template);\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track,\n+     * using the given template. Also registers it with the campaign.\n+     */\n+    static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords, ScenarioTemplate template) {\n+        StratconScenario scenario = new StratconScenario();\n+        \n+        AtBDynamicScenario backingScenario = AtBDynamicScenarioFactory.initializeScenarioFromTemplate(template, contract, campaign);        \n+        scenario.setBackingScenario(backingScenario);\n+        scenario.setCoords(coords);\n+        \n+        // by default, certain conditions may make this bigger\n+        scenario.setRequiredPlayerLances(1);\n+\n+        // do an appropriate allied force if the contract calls for it\n+        // do any attached or integrated units\n+        setAlliedForceModifier(scenario, contract);\n+        setAttachedUnitsModifier(scenario, contract);\n+        applyFacilityModifiers(scenario, track, coords);\n+        applyGlobalModifiers(scenario, contract.getStratconCampaignState());\n+\n+        if ((contract.getCommandRights() == AtBContract.COM_HOUSE) ||\n+                (contract.getCommandRights() == AtBContract.COM_INTEGRATED)) {\n+            scenario.setRequiredScenario(true);\n+        }\n+\n+        AtBDynamicScenarioFactory.setScenarioModifiers(scenario.getBackingScenario());\n+        scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+        setScenarioDates(track, campaign, scenario);\n+        \n+        // the backing scenario ID must be updated after registering the backing scenario \n+        // with the campaign, so that the stratcon - backing scenario association is maintained\n+        // registering the scenario with the campaign should be done after setting\n+        // dates, otherwise, the report messages for new scenarios look weird\n+        campaign.addScenario(backingScenario, contract);\n+        scenario.setBackingScenarioID(backingScenario.getId());\n+        \n+        if (forceID > Force.FORCE_NONE) {\n+            scenario.addPrimaryForce(forceID);\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * Apply global scenario modifiers from campaign state to given scenario.\n+     */\n+    private static void applyGlobalModifiers(StratconScenario scenario, StratconCampaignState campaignState) {\n+        for (String modifierName : campaignState.getGlobalScenarioModifiers()) {\n+            AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierName);\n+\n+            if (modifier == null) {\n+                MekHQ.getLogger().error(String.format(\"Modifier %s not found; ignoring\", modifierName));\n+                continue;\n+            }\n+\n+            scenario.getBackingScenario().addScenarioModifier(modifier);\n+        }\n+    }\n+\n+    /**\n+     * Applies scenario modifiers from the current track to the given scenario.\n+     * @param scenario\n+     * @param track\n+     */\n+    private static void applyFacilityModifiers(StratconScenario scenario, StratconTrackState track, StratconCoords coords) {\n+        // loop through all the facilities on the track\n+        // if a facility has been revealed, then it has a 100% chance to apply its effect\n+        // if a facility has not been revealed, then it has a x% chance to apply its effect\n+        // if a facility is on the the scenario coordinates the it applies the local effects\n+        for (StratconCoords facilityCoords : track.getFacilities().keySet()) {\n+            boolean scenarioAtFacility = facilityCoords.equals(coords);\n+            StratconFacility facility = track.getFacilities().get(facilityCoords);\n+            List<String> modifierIDs = new ArrayList<>();\n+\n+            if (scenarioAtFacility) {\n+                modifierIDs = facility.getLocalModifiers();\n+            } else if (facility.isVisible() || (Compute.randomInt(100) <= facility.getAggroRating())) {\n+                modifierIDs = facility.getSharedModifiers();\n+            }\n+\n+            for (String modifierID : modifierIDs) {\n+                AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierID);\n+                if(modifier == null) {\n+                    MekHQ.getLogger().error(String.format(\"Modifier %s not found for facility %s\", modifierID, facility.getFormattedDisplayableName()));\n+                    continue;\n+                }\n+\n+                scenario.getBackingScenario().addScenarioModifier(modifier);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set up the appropriate primary allied force modifier, if any\n+     * @param contract The scenario's contract.\n+     */\n+    private static void setAlliedForceModifier(StratconScenario scenario, AtBContract contract) {\n+        int alliedUnitOdds = 0;\n+\n+        // first, we determine the odds of having an allied unit present\n+        // TODO: move this override out to the contract definition\n+        if (contract.getMissionType() == AtBContract.MT_RELIEFDUTY) {\n+            alliedUnitOdds = 50;\n+        } else {\n+            switch(contract.getCommandRights()) {\n+                case AtBContract.COM_INTEGRATED:\n+                    alliedUnitOdds = 50;\n+                    break;\n+                case AtBContract.COM_HOUSE:\n+                    alliedUnitOdds = 30;\n+                    break;\n+                case AtBContract.COM_LIAISON:\n+                    alliedUnitOdds = 10;\n+                    break;\n+            }\n+        }\n+\n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+\n+        // if an allied unit is present, then we want to make sure that it's ground units\n+        // for ground battles\n+        if (Compute.randomInt(100) <= alliedUnitOdds) {\n+            if((backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+               (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space)) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_ALLIED_AIR_UNITS));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_ALLIED_GROUND_UNITS));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set the 'attached' units modifier for the current scenario (integrated, house, liaison),\n+     * and make sure we're not deploying ground units to an air scenario\n+     * @param contract The scenario's contract\n+     */\n+    public static void setAttachedUnitsModifier(StratconScenario scenario, AtBContract contract) {\n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+        boolean airBattle = (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+                (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space);\n+\n+        // if we're on cadre duty, we're getting three trainees, period\n+        if (contract.getMissionType() == AtBContract.MT_CADREDUTY) {\n+            if (airBattle) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_TRAINEES_AIR));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_TRAINEES_GROUND));\n+            }\n+            return;\n+        }\n+\n+        // if we're under non-independent command rights, a supervisor may come along\n+        switch (contract.getCommandRights()) {\n+            case AtBContract.COM_INTEGRATED:\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(airBattle \n+                        ? MekHqConstants.SCENARIO_MODIFIER_INTEGRATED_UNITS_AIR\n+                        : MekHqConstants.SCENARIO_MODIFIER_INTEGRATED_UNITS_GROUND));\n+                break;\n+            case AtBContract.COM_HOUSE:\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(airBattle \n+                        ? MekHqConstants.SCENARIO_MODIFIER_HOUSE_CO_AIR\n+                        : MekHqConstants.SCENARIO_MODIFIER_HOUSE_CO_GROUND));\n+                break;\n+            case AtBContract.COM_LIAISON:\n+                if (scenario.isRequiredScenario()) {\n+                    backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(airBattle \n+                            ? MekHqConstants.SCENARIO_MODIFIER_LIAISON_AIR\n+                            : MekHqConstants.SCENARIO_MODIFIER_LIAISON_GROUND));\n+                }\n+                break;\n+        }\n+    }\n+\n+    /**\n+     * Worker function that sets scenario deploy/battle/return dates based on the track's properties and current campaign date\n+     */\n+    private static void setScenarioDates(StratconTrackState track, Campaign campaign, StratconScenario scenario) {\n+     // set up deployment day, battle day, return day here\n+        // safety code to prevent attempts to generate random int with upper bound of 0 which is apparently illegal\n+        int deploymentDay = track.getDeploymentTime() < 7 ? Compute.randomInt(7 - track.getDeploymentTime()) : 0;\n+        int battleDay = deploymentDay + (track.getDeploymentTime() > 0 ? Compute.randomInt(track.getDeploymentTime()) : 0);\n+        int returnDay = deploymentDay + track.getDeploymentTime();\n+\n+        LocalDate deploymentDate = campaign.getLocalDate();\n+        deploymentDate.plusDays(deploymentDay);\n+        LocalDate battleDate = campaign.getLocalDate();\n+        deploymentDate.plusDays(battleDay);\n+        LocalDate returnDate = campaign.getLocalDate();\n+        returnDate.plusDays(returnDay);\n+\n+        scenario.setDeploymentDate(deploymentDate);\n+        scenario.setActionDate(battleDate);\n+        scenario.setReturnDate(returnDate);\n+    }\n+\n+    /**\n+     * Helper function that determines if the unit type specified in the given scenario force template\n+     * would start out airborne on a ground map (hot dropped units aside)\n+     */\n+    private static boolean unitTypeIsAirborne(ScenarioForceTemplate template) {\n+        int unitType = template.getAllowedUnitType();\n+\n+        return (unitType == UnitType.AERO ||\n+                unitType == UnitType.CONV_FIGHTER ||\n+                unitType == UnitType.DROPSHIP ||\n+                unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_MIX) &&\n+                template.getStartingAltitude() > 0;\n+    }\n+\n+    /**\n+     * Determines whether the force in question has the same primary unit type as the force template.\n+     * @return Whether or not the unit types match.\n+     */\n+    public static boolean forceCompositionMatchesDeclaredUnitType(int primaryUnitType, int unitType, boolean reinforcements) {\n+        // special cases are \"ATB_MIX\" and \"ATB_AERO_MIX\", which encompass multiple unit types\n+        if (unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_MIX) {\n+            // \"AtB mix\" is usually ground units, but air units can sub in\n+            return primaryUnitType == UnitType.MEK ||\n+                    primaryUnitType == UnitType.TANK ||\n+                    primaryUnitType == UnitType.INFANTRY ||\n+                    primaryUnitType == UnitType.BATTLE_ARMOR ||\n+                    primaryUnitType == UnitType.PROTOMEK ||\n+                    primaryUnitType == UnitType.VTOL ||\n+                    (primaryUnitType == UnitType.AERO) && reinforcements ||\n+                    (primaryUnitType == UnitType.CONV_FIGHTER) && reinforcements;\n+        } else if (unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_AERO_MIX) {\n+            return primaryUnitType == UnitType.AERO ||\n+                    primaryUnitType == UnitType.CONV_FIGHTER;\n+        } else {\n+            return primaryUnitType == unitType;\n+        }\n+    }\n+\n+    /**\n+     * This is a set of all force IDs for forces that can be deployed to a scenario.\n+     * @param campaign Current campaign\n+     * @return Set of available force IDs.\n+     */\n+    public static List<Integer> getAvailableForceIDs(Campaign campaign) {\n+        List<Integer> retVal = new ArrayList<>();\n+\n+        // first, we gather a set of all forces that are already deployed to a track so we eliminate those later\n+        Set<Integer> forcesInTracks = new HashSet<>();\n+        for (Contract contract : campaign.getActiveContracts()) {\n+            if (contract instanceof AtBContract) {\n+                for (StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    forcesInTracks.addAll(track.getAssignedForceCoords().keySet());\n+                }\n+            }\n+        }\n+\n+        // now, we get all the forces that qualify as \"lances\", and filter out those that are\n+        // deployed to a scenario and not in a track already\n+        for (int key : campaign.getLances().keySet()) {\n+            Force force = campaign.getForce(key);\n+            if ((force != null) &&\n+                    !force.isDeployed() &&\n+                    !forcesInTracks.contains(force.getId())) {\n+                retVal.add(force.getId());\n+            }\n+        }\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * This is a list of all force IDs for forces that can be deployed to a scenario in the given force template\n+     * a) have not been assigned to a track\n+     * b) are combat-capable\n+     * c) are not deployed to a scenario\n+     * d) if attempting to deploy as reinforcements, haven't already failed to deploy\n+     */\n+    public static List<Integer> getAvailableForceIDs(int unitType, Campaign campaign, StratconTrackState currentTrack,\n+            boolean reinforcements, @Nullable StratconScenario currentScenario) {\n+        List<Integer> retVal = new ArrayList<>();\n+\n+        Set<Integer> forcesInTracks = new HashSet<>();\n+        // assemble a set of all force IDs that are currently assigned to tracks that are not this one\n+        for (Contract contract : campaign.getActiveContracts()) {\n+            if (contract instanceof AtBContract) {\n+                for (StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    if ((track != currentTrack) || !reinforcements) {\n+                        forcesInTracks.addAll(track.getAssignedForceCoords().keySet());\n+                    }\n+                }\n+            }\n+        }\n+        \n+        // if there's an existing scenario and we're doing reinforcements,\n+        // prevent forces that failed to deploy from trying to deploy again\n+        if (reinforcements && (currentScenario != null)) {\n+            forcesInTracks.addAll(currentScenario.getFailedReinforcements());\n+        }\n+\n+        for (int key : campaign.getLances().keySet()) {\n+            Force force = campaign.getForce(key);\n+\n+            if (force == null) {\n+                continue;\n+            }\n+\n+            int primaryUnitType = force.getPrimaryUnitType(campaign);\n+            if (!force.isDeployed() &&\n+                    (force.getScenarioId() <= 0) &&\n+                    !force.getUnits().isEmpty() &&\n+                    !forcesInTracks.contains(force.getId()) &&\n+                    forceCompositionMatchesDeclaredUnitType(primaryUnitType, unitType, reinforcements)) {\n+                retVal.add(force.getId());\n+            }\n+        }\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * Returns a list of individual units eligible for deployment in scenarios run by \"Defend\" lances\n+     * @return List of unit IDs.\n+     */\n+    public static List<Unit> getEligibleDefensiveUnits(Campaign campaign) {\n+        List<Unit> retVal = new ArrayList<>();\n+\n+        for (Unit u : campaign.getUnits()) {\n+            // \"defensive\" units are infantry, battle armor and (Weisman help you) gun emplacements\n+        \t// and also said unit should be intact/alive/etc\n+        \tboolean isEligibleInfantry = \n+        \t\t\t((u.getEntity().getUnitType() == UnitType.INFANTRY) ||\n+                    (u.getEntity().getUnitType() == UnitType.BATTLE_ARMOR)) &&\n+                    !u.isUnmanned();\n+        \t\n+        \tboolean isEligibleGunEmplacement = u.getEntity().getUnitType() == UnitType.GUN_EMPLACEMENT;\n+        \t\n+        \tif ((isEligibleInfantry || isEligibleGunEmplacement) && \n+            \t\t!u.isDeployed() &&\n+                    !u.isMothballed() &&\n+                    u.isFunctional()) {\n+\n+                // this is a little inefficient, but probably there aren't too many active AtB contracts at a time\n+                for (AtBContract contract : campaign.getActiveAtBContracts()) {\n+                    if (contract.getStratconCampaignState().isForceDeployedHere(u.getForceId())) {\n+                        continue;\n+                    }\n+                }\n+\n+                retVal.add(u);\n+            }\n+        }\n+\n+        return retVal;\n+    }\n+    \n+    /**\n+     * Returns a list of individual units eligible for deployment in scenarios\n+     * that result from the lance leader having a leadership score\n+     * @return List of unit IDs.\n+     */\n+    public static List<Unit> getEligibleLeadershipUnits(Campaign campaign, Set<Integer> forceIDs) {\n+        List<Unit> retVal = new ArrayList<>();\n+\n+        // The criteria are as follows:\n+        // - unit is of a different unit type than the primary unit type of the force \n+        // - unit has a lower BV than the force's lowest BV unit\n+        \n+        Integer lowestBV = getLowestBV(campaign, forceIDs);\n+        \n+        // no units assigned, the rest is meaningless.\n+        if (lowestBV == null) {\n+            return retVal;\n+        }\n+        \n+        int primaryUnitType = getPrimaryUnitType(campaign, forceIDs);\n+        \n+        for (Unit u : campaign.getUnits()) {\n+            if ((primaryUnitType != u.getEntity().getUnitType()) &&\n+                    !u.isDeployed() &&\n+                    !u.isMothballed() &&\n+                    u.isFunctional() &&\n+                    (u.getEntity().calculateBattleValue() < lowestBV) &&\n+                    !isUnitDeployedToStratCon(u)) {\n+                retVal.add(u);\n+            }\n+        }\n+\n+        return retVal;\n+    }\n+    \n+    /**\n+     * Check if the unit's force (if one exists) has been deployed to a StratCon track\n+     */\n+    public static boolean isUnitDeployedToStratCon(Unit u) {\n+        if (!u.getCampaign().getCampaignOptions().getUseStratCon()) {\n+            return false;\n+        }\n+        \n+        //this is a little inefficient, but probably there aren't too many active AtB contracts at a time\n+        for (AtBContract contract : u.getCampaign().getActiveAtBContracts()) {\n+            if (contract.getStratconCampaignState().isForceDeployedHere(u.getForceId())) {\n+                return true;\n+            }\n+        }\n+        \n+        return false;\n+    }\n+    \n+    /**\n+     * Given a campaign and a list of force IDs, calculate the unit with the lowest BV.\n+     */\n+    private static Integer getLowestBV(Campaign campaign, Set<Integer> forceIDs) {\n+        Integer lowestBV = null;\n+        \n+        for (int forceID : forceIDs) {\n+            Force force = campaign.getForce(forceID);\n+            if (force == null) {\n+                continue;\n+            }\n+            \n+            for (UUID id : force.getUnits()) {\n+                if (campaign.getUnit(id) == null) {\n+                    continue;\n+                }\n+                \n+                int currentBV = campaign.getUnit(id).getEntity().calculateBattleValue();\n+                \n+                if ((lowestBV == null) || (currentBV < lowestBV)) {\n+                    lowestBV = currentBV;\n+                }\n+            }\n+        }\n+        \n+        return lowestBV;\n+    }\n+    \n+    /**\n+     * Calculates the majority unit type for the forces given the IDs.\n+     */\n+    private static int getPrimaryUnitType(Campaign campaign, Set<Integer> forceIDs) {\n+        Map<Integer, Integer> unitTypeBuckets = new TreeMap<>();\n+        int biggestBucketID = -1;\n+        int biggestBucketCount = 0;\n+        \n+        for (int forceID : forceIDs) {\n+            Force force = campaign.getForce(forceID);\n+            if (force == null) {\n+                continue;\n+            }\n+        \n+            for (UUID id : force.getUnits()) {\n+                Unit unit = campaign.getUnit(id);\n+                if ((unit == null) || \n+                        (unit.getEntity() == null)) {\n+                    continue;\n+                }\n+                \n+                int unitType = unit.getEntity().getUnitType();\n+    \n+                unitTypeBuckets.merge(unitType, 1, (oldCount, value) -> oldCount + value);\n+                \n+                if (unitTypeBuckets.get(unitType) > biggestBucketCount) {\n+                    biggestBucketCount = unitTypeBuckets.get(unitType);\n+                    biggestBucketID = unitType;\n+                }\n+            }\n+        }\n+        \n+        return biggestBucketID;\n+    }\n+\n+    /**\n+     * Determines what rules to use when deploying a force for reinforcements to the given track.\n+     */\n+    public static ReinforcementEligibilityType getReinforcementType(int forceID,\n+            StratconTrackState trackState, Campaign campaign) {\n+        // if the force is currently deployed to the track, it'll be able to deploy \"for free\"\n+        if (trackState.isForceDeployed(forceID)) {\n+            return ReinforcementEligibilityType.ChainedScenario;\n+        }\n+\n+        // if the force is in 'fight' stance, it'll be able to deploy using 'fight lance' rules\n+        if (campaign.getLances().containsKey(forceID) &&\n+                campaign.getLances().get(forceID).getRole() == AtBLanceRole.FIGHTING) {\n+            return ReinforcementEligibilityType.FightLance;\n+        }\n+\n+        // if the force is deployed elsewhere, it cannot be deployed as reinforcements\n+        for (Contract contract : campaign.getActiveContracts()) {\n+            if(contract instanceof AtBContract) {\n+                for(StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    if(track != trackState && track.getAssignedForceCoords().containsKey(forceID)) {\n+                        return ReinforcementEligibilityType.None;\n+                    }\n+                }\n+            }\n+        }\n+\n+        // otherwise, the force requires support points / vps to deploy\n+        return ReinforcementEligibilityType.SupportPoint;\n+    }\n+    \n+    /**\n+     * Given a track and the current campaign state, and if the player is deploying\n+     * a force or not, figure out the odds of a scenario occuring.\n+     */\n+    public static int calculateScenarioOdds(StratconTrackState track, \n+            AtBContract contract, boolean playerDeployingForce) {\n+        // rules:\n+        // rout morale: 0%\n+        // very low morale: -10% when deploying forces to track, 0% attack\n+        // low morale: -5%\n+        // high morale: +5%\n+        // invincible: special case, let's do +10% for now\n+        int moraleModifier = 0;\n+        \n+        switch (contract.getMoraleLevel()) {\n+            case AtBContract.MORALE_ROUT:\n+                return 0;\n+            case AtBContract.MORALE_VERYLOW:\n+                if (playerDeployingForce) {\n+                    moraleModifier = -10;\n+                } else {\n+                    return 0;\n+                }\n+                break;\n+            case AtBContract.MORALE_LOW:\n+                moraleModifier = -5;\n+                break;\n+            case AtBContract.MORALE_HIGH:\n+                moraleModifier = 5;\n+                break;\n+            case AtBContract.MORALE_INVINCIBLE:\n+                moraleModifier = 10;\n+                break;\n+        }\n+        \n+        // facilities: for each hostile data center, add +5%\n+        // for each allied data center, subtract 5\n+        int dataCenterModifier = 0;\n+        for (StratconFacility facility : track.getFacilities().values()) {\n+            if (facility.getFacilityType() == FacilityType.DataCenter) {\n+                dataCenterModifier += facility.getOwner() == ForceAlignment.Allied ? -5 : 5;\n+            }\n+        }\n+            \n+        return track.getScenarioOdds() + moraleModifier + dataCenterModifier;\n+    }\n+\n+    /**\n+     * Removes the facility associated with the given scenario from the relevant track/\n+     */\n+    public static void updateFacilityForScenario(AtBScenario scenario, AtBContract contract, boolean destroy, boolean capture) {\n+        if (contract.getStratconCampaignState() == null) {\n+            return;\n+        }\n+\n+        // this is kind of kludgy, but there's currently no way to link a scenario back to its backing scenario\n+        // TODO: introduce mapping in contract or at least trackstate\n+        // basically, we're looping through all scenarios on all the contract's tracks\n+        // if we find one with the same ID as the one being resolved, that's our facility: get rid of it.\n+        for (StratconTrackState trackState : contract.getStratconCampaignState().getTracks()) {\n+            for (StratconCoords coords : trackState.getScenarios().keySet()) {\n+                StratconScenario potentialScenario = trackState.getScenario(coords);\n+                if (potentialScenario.getBackingScenarioID() == scenario.getId()) {\n+\n+                    if (destroy) {\n+                        trackState.removeFacility(coords);\n+                    } else {\n+                        StratconFacility facility = trackState.getFacility(coords);\n+\n+                        if (facility == null) {\n+                            continue;\n+                        }\n+\n+                        if (capture) {\n+                            facility.incrementOwnershipChangeScore();\n+                        } else {\n+                            facility.decrementOwnershipChangeScore();\n+                        }\n+                    }\n+\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Processes completion of a Stratcon scenario, if the given tracker is associated\n+     * with a stratcon-enabled mission. Intended to be called after ResolveScenarioTracker.finish() has been invoked.\n+     */\n+    public static void processScenarioCompletion(ResolveScenarioTracker rst) {\n+        if (rst.getMission() instanceof AtBContract) {\n+            StratconCampaignState campaignState = ((AtBContract) rst.getMission()).getStratconCampaignState();\n+            if (campaignState == null) {\n+                return;\n+            }\n+\n+            for (StratconTrackState track : campaignState.getTracks()) {\n+                if (track.getBackingScenariosMap().containsKey(rst.getScenario().getId())) {\n+                    // things that may potentially happen:\n+                    // scenario is removed from track - implemented\n+                    // track gets remaining forces added to reinforcement pool\n+                    // facility gets remaining forces stored in reinforcement pool\n+                    // process VP and SO\n+\n+                    StratconScenario scenario = track.getBackingScenariosMap().get(rst.getScenario().getId());\n+\n+\n+                    StratconFacility facility = track.getFacility(scenario.getCoords());\n+\n+                    if ((facility != null) && (facility.getOwnershipChangeScore() > 0)) {\n+                        if (facility.getOwner() == ForceAlignment.Allied) {\n+                            facility.setOwner(ForceAlignment.Opposing);\n+                        } else {\n+                            facility.setOwner(ForceAlignment.Allied);\n+                        }\n+                    }\n+\n+                    boolean victory = rst.getScenario().getStatus() == Scenario.S_VICTORY ||\n+                            rst.getScenario().getStatus() == Scenario.S_MVICTORY;\n+\n+                    if (scenario.isRequiredScenario()) {\n+                        campaignState.updateVictoryPoints(victory ? 1 : -1);\n+                    }\n+\n+                    if (scenario.isStrategicObjective()) {\n+                        if (campaignState.strategicObjectivesBehaveAsVPs()) {\n+                            campaignState.updateVictoryPoints(victory ? 1 : -1);\n+                        } else {\n+                            campaignState.incrementStrategicObjectiveCompletedCount();\n+                        }\n+                    }\n+\n+                    processTrackForceReturnDates(track, rst.getCampaign().getLocalDate());\n+\n+                    track.removeScenario(scenario);\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Worker function that goes through a track and undeploys any forces where the\n+     * return date is on or before the given date.\n+     */\n+    public static void processTrackForceReturnDates(StratconTrackState track, LocalDate date) {\n+        List<Integer> forcesToUndeploy = new ArrayList<>();\n+\n+        // for each force on the track, if the return date is today or in the past,\n+        // \"return to base\", unless it's been told to stay in the field\n+        for (int forceID : track.getAssignedForceReturnDates().keySet()) {\n+            if ((track.getAssignedForceReturnDates().get(forceID).equals(date) ||\n+                    track.getAssignedForceReturnDates().get(forceID).isBefore(date)) &&\n+                    !track.getStickyForces().contains(forceID)) {\n+                forcesToUndeploy.add(forceID);\n+            }\n+        }\n+\n+        for (int forceID : forcesToUndeploy) {\n+            track.unassignForce(forceID);\n+        }\n+    }\n+    \n+    /**\n+     * Processes an ignored dynamic scenario - locates it on one of the tracks\n+     * and calls the standared 'ignored scenario' routine.\n+     * @return Whether or not we also need to get rid of the backing scenario from the campaign\n+     */\n+    public static boolean processIgnoredScenario(AtBDynamicScenario scenario, StratconCampaignState campaignState) {\n+        for (StratconTrackState track : campaignState.getTracks()) {\n+            if (track.getBackingScenariosMap().containsKey(scenario.getId())) {\n+                return processIgnoredScenario(track.getBackingScenariosMap().get(scenario.getId()), campaignState);\n+            }\n+        }\n+        \n+        return true;\n+    }\n+    \n+\n+    /**\n+     * Processes an ignored Stratcon scenario\n+     * @return Whether or not we also need to get rid of the backing scenario from the campaign\n+     */\n+    public static boolean processIgnoredScenario(StratconScenario scenario, StratconCampaignState campaignState) {\n+        for (StratconTrackState track : campaignState.getTracks()) {\n+            if (track.getScenarios().containsKey(scenario.getCoords())) {\n+                // subtract VP if scenario is 'required'\n+                if (scenario.isRequiredScenario()) {\n+                    campaignState.updateVictoryPoints(-1);\n+                }\n+                \n+                track.removeScenario(scenario);\n+\n+                StratconFacility localFacility = track.getFacility(scenario.getCoords());\n+                if (localFacility != null) {\n+                    // if the ignored scenario was on top of an allied facility\n+                    // then it'll get captured, and the player will possibly lose a SO\n+                    if (localFacility.getOwner() == ForceAlignment.Allied) {\n+                        localFacility.setOwner(ForceAlignment.Opposing);\n+\n+                        if (localFacility.isStrategicObjective()) {\n+                            campaignState.decrementStrategicObjectiveCompletedCount();\n+                        }\n+                    }\n+                    \n+                    return true;\n+                } else {\n+                    // if it's an open-field\n+                    // move scenario towards nearest allied facility\n+                    StratconCoords closestAlliedFacilityCoords = track.findClosestAlliedFacilityCoords(scenario.getCoords());\n+\n+                    if (closestAlliedFacilityCoords != null) {\n+                        StratconCoords newCoords = scenario.getCoords().translate(scenario.getCoords().direction(closestAlliedFacilityCoords));\n+                        scenario.setCoords(newCoords);\n+                        \n+                        int daysForward = Math.min(1, track.getDeploymentTime());\n+                        \n+                        scenario.setDeploymentDate(scenario.getDeploymentDate().plusDays(daysForward));\n+                        scenario.setActionDate(scenario.getActionDate().plusDays(daysForward));\n+                        scenario.setReturnDate(scenario.getReturnDate().plusDays(daysForward));\n+                        \n+                        // refresh the scenario's position on the track\n+                        track.addScenario(scenario);\n+                        \n+                        // TODO: Write some functionality to \"copy\" a scenario's \n+                        // bot forces over\n+                        /*StratconFacility facility = track.getFacility(newCoords);\n+\n+                        if (facility != null) {\n+                            ScenarioTemplate template = StratconScenarioFactory.getFacilityScenario(true);\n+                            scenario = generateScenario(campaignState.getCa, contract, track, forceID, coords, template);\n+                            setupFacilityScenario(scenario, facility);\n+                        }*/\n+\n+                        // TODO: if the allied facility is in the new coords, replace this scenario\n+                        // with a facility defense, with the opfor coming directly from all hostiles assigned to this scenario\n+\n+                        scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                        return false;\n+                    } else {\n+                        // TODO: if there's no allied facilities here, add its forces to track reinforcement pool\n+                        return true;\n+                    }\n+                }\n+            }\n+        }\n+        \n+        // if we couldn't find the scenario on any tracks, then let's just \n+        // rid of any underlying AtB scenarios as well\n+        return true;\n+    }\n+\n+    public void startup() {\n+        MekHQ.registerHandler(this);\n+    }\n+\n+    /**\n+     * Event handler for the new day event.\n+     */\n+    @Subscribe\n+    public void handleNewDay(NewDayEvent ev) {\n+    \t// don't do any of this if StratCon isn't turned on\n+    \tif (!ev.getCampaign().getCampaignOptions().getUseStratCon()) {\n+    \t\treturn;\n+    \t}\n+    \t\n+        boolean isMonday = ev.getCampaign().getLocalDate().getDayOfWeek() == DayOfWeek.MONDAY;\n+", "originalCommit": "b36d9fa6bf982c7b833b1ac0a0473d37f6e84760", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTE5Mjg5Nw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r615192897", "bodyText": "Useless cast", "author": "Windchild292", "createdAt": "2021-04-17T02:15:46Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1404 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.UUID;\n+\n+import megamek.common.Compute;\n+import megamek.common.Minefield;\n+import megamek.common.UnitType;\n+import megamek.common.annotations.Nullable;\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.Utilities;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.ResolveScenarioTracker;\n+import mekhq.campaign.againstTheBot.enums.AtBLanceRole;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.event.StratconDeploymentEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.force.Lance;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier.EventTiming;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconFacility.FacilityType;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.unit.Unit;\n+\n+/**\n+ * This class contains \"rules\" logic for the AtB-Stratcon state\n+ * @author NickAragua\n+ */\n+public class StratconRulesManager {\n+    /**\n+     * What makes a particular lance eligible to be reinforcements for a scenario\n+     */\n+    public enum ReinforcementEligibilityType {\n+        /**\n+         * Nothing\n+         */\n+        None,\n+\n+        /**\n+         * Lance is already deployed to the track\n+         */\n+        ChainedScenario,\n+\n+        /**\n+         * We pay a support point or convert a victory point to a support point\n+         */\n+        SupportPoint,\n+\n+        /**\n+         * The lance's deployment orders are \"Fight\"\n+         */\n+        FightLance\n+    }\n+\n+    /**\n+     * This function potentially generates non-player-initiated scenarios for the given track.\n+     */\n+    public static void generateScenariosForTrack(Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // maps scenarios to force IDs\n+        List<StratconScenario> generatedScenarios = new ArrayList<>();\n+        boolean autoAssignLances = contract.getCommandRights() == AtBContract.COM_INTEGRATED;\n+\n+        // get this list just so we have it available\n+        List<Integer> availableForceIDs = getAvailableForceIDs(campaign);\n+        Map<MapLocation, List<Integer>> sortedAvailableForceIDs = sortForcesByMapType(availableForceIDs, campaign);\n+\n+        // make X rolls, where X is the number of required lances for the track\n+        // that's the chance to spawn a scenario.\n+        // if a scenario occurs, then we pick a random non-deployed lance and use it to drive the opfor generation later\n+        // once we've determined that scenarios occur, we loop through the ones that we generated\n+        // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all\n+        for (int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            int targetNum = calculateScenarioOdds(track, contract, false);\n+            \n+            // if we haven't already used all the player forces and are required to randomly generate a scenario\n+            if (!availableForceIDs.isEmpty() && (Compute.randomInt(100) <= targetNum)) {\n+                // pick random coordinates and force to drive the scenario\n+                int x = Compute.randomInt(track.getWidth());\n+                int y = Compute.randomInt(track.getHeight());\n+\n+                StratconCoords scenarioCoords = new StratconCoords(x, y);\n+\n+                // if forces are already assigned to these coordinates, use those instead\n+                // of randomly-selected ones\n+                if (track.getAssignedCoordForces().containsKey(scenarioCoords)) {\n+                    StratconScenario scenario = generateScenarioForExistingForces(scenarioCoords,\n+                            track.getAssignedCoordForces().get(scenarioCoords), \n+                            contract, campaign, track);\n+                    generatedScenarios.add(scenario);\n+                    continue;\n+                }\n+                \n+                // otherwise, pick a random force from the avail\n+                int randomForceIndex = Compute.randomInt(availableForceIDs.size());\n+                int randomForceID = availableForceIDs.get(randomForceIndex);\n+                \n+                // remove the force from the available lists so we don't designate it as primary twice\n+                availableForceIDs.remove(randomForceIndex);\n+\n+                // we want to remove the actual int with the value, not the value at the index\n+                sortedAvailableForceIDs.get(MapLocation.AllGroundTerrain).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.LowAtmosphere).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.Space).remove((Integer) randomForceID);\n+\n+                // two scenarios on the same coordinates wind up increasing in size\n+                if (track.getScenarios().containsKey(scenarioCoords)) {\n+                    track.getScenarios().get(scenarioCoords).incrementRequiredPlayerLances();\n+                    assignAppropriateExtraForceToScenario(track.getScenarios().get(scenarioCoords), sortedAvailableForceIDs);\n+                    continue;\n+                }\n+\n+                StratconScenario scenario = setupScenario(scenarioCoords, randomForceID, campaign, contract, track);\n+                generatedScenarios.add(scenario);\n+\n+                // if we're auto-assigning lances, deploy the force to the track as well\n+                if (autoAssignLances) {\n+                    processForceDeployment(scenarioCoords, randomForceID, campaign, track, false);\n+                }\n+            }\n+        }\n+\n+        // if under liaison command, pick a random scenario from the ones generated\n+        // to set as required and attach liaison\n+        if (contract.getCommandRights() == AtBContract.COM_LIAISON) {\n+        \tStratconScenario randomScenario = Utilities.getRandomItem(generatedScenarios);\n+        \trandomScenario.setRequiredScenario(true);\n+            setAttachedUnitsModifier(randomScenario, contract);\n+        }\n+\n+        // now, we loop through all the scenarios we set up\n+        // and generate the opfors / events / etc\n+        // if not auto-assigning lances, we then back out the lance assignments.\n+        for (StratconScenario scenario : generatedScenarios) {\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+\n+            if(!autoAssignLances && !scenario.ignoreForceAutoAssignment()) {\n+                for(int forceID : scenario.getPlayerTemplateForceIDs()) {\n+                    scenario.getBackingScenario().removeForce(forceID);\n+                }\n+\n+                scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                track.addScenario(scenario);\n+            } else {\n+                commitPrimaryForces(campaign, scenario, track);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Given a set of force IDs and coordinates, generate a scenario\n+     * Useful for when we want to generate scenarios \n+     * for forces already deployed to a track\n+     */\n+    public static StratconScenario generateScenarioForExistingForces(StratconCoords scenarioCoords, \n+            Set<Integer> forceIDs, AtBContract contract, Campaign campaign, StratconTrackState track) {\n+        boolean firstForce = true;\n+        StratconScenario scenario = null;\n+        \n+        for (int forceID : forceIDs) {\n+            if (firstForce) {\n+                scenario = setupScenario(scenarioCoords, forceID, campaign, contract, track);\n+                firstForce = false;\n+            } else {\n+                scenario.incrementRequiredPlayerLances();\n+                scenario.addPrimaryForce(forceID);\n+            }\n+        }\n+        \n+        // this is theoretically possible if forceIDs is passed in as null - not likely in practice\n+        // but might as well, to future-proof.\n+        if (scenario != null) {\n+            scenario.setIgnoreForceAutoAssignment(true);\n+        }\n+        \n+        return scenario;\n+    }\n+\n+    /**\n+     * Deploys a force to the given coordinates on the given track as a result of explicit player action.\n+     */\n+    public static void deployForceToCoords(StratconCoords coords, int forceID, \n+            Campaign campaign, AtBContract contract, StratconTrackState track, boolean sticky) {\n+        // the following things should happen:\n+        // 1. call to \"process force deployment\", which reveals fog of war in or around the coords, depending on force role\n+        // 2. if coords are a hostile facility, we get a facility mission\n+        // 3. if coords are empty, we *may* get a mission\n+\n+        processForceDeployment(coords, forceID, campaign, track, sticky);\n+\n+        // don't create a scenario on top of allied facilities\n+        StratconFacility facility = track.getFacility(coords);\n+        boolean isNonAlliedFacility = (facility != null) && (facility.getOwner() != ForceAlignment.Allied);\n+        int targetNum = calculateScenarioOdds(track, contract, true);\n+        boolean spawnScenario = (facility == null) && (Compute.randomInt(100) <= targetNum);\n+\n+        if (isNonAlliedFacility || spawnScenario) {\n+            StratconScenario scenario = setupScenario(coords, forceID, campaign, contract, track);\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            commitPrimaryForces(campaign, scenario, track);\n+        }\n+    }\n+\n+    /**\n+     * Logic to set up a scenario\n+     */\n+    private static StratconScenario setupScenario(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        StratconScenario scenario = null;\n+\n+        if (track.getFacilities().containsKey(coords)) {\n+            StratconFacility facility = track.getFacility(coords);\n+            boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+            ScenarioTemplate template = StratconScenarioFactory.getFacilityScenario(alliedFacility);\n+            scenario = generateScenario(campaign, contract, track, forceID, coords, template);\n+            setupFacilityScenario(scenario, facility);\n+        } else {\n+            scenario = generateScenario(campaign, contract, track, forceID, coords);\n+\n+            // we may generate a facility scenario randomly - if so, do the facility-related stuff\n+            // and add a new facility to the track\n+            if (scenario.getBackingScenario().getTemplate().isFacilityScenario()) {\n+                StratconFacility facility = scenario.getBackingScenario().getTemplate().isHostileFacility() ?\n+                        StratconFacilityFactory.getRandomHostileFacility() : StratconFacilityFactory.getRandomAlliedFacility();\n+                facility.setVisible(true);\n+                track.addFacility(coords, facility);\n+                setupFacilityScenario(scenario, facility);\n+            }\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * carries out tasks relevant to facility scenarios\n+     */\n+    private static void setupFacilityScenario(StratconScenario scenario, StratconFacility facility) {\n+        // this includes:\n+        // for hostile facilities\n+        // - add a destroy objective (always the option to level the facility)\n+        // - add a capture objective (always the option to capture the facility)\n+        // - if so indicated by parameter, roll a random hostile facility objective and add it if not capture/destroy\n+        // for allied facilities\n+        // - add a defend objective (always the option to defend the facility)\n+        // - if so indicated by parameter, roll a random allied facility objective and add it if not defend\n+        AtBScenarioModifier objectiveModifier = null;\n+        boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+\n+        if (alliedFacility) {\n+            objectiveModifier = AtBScenarioModifier.getRandomAlliedFacilityModifier();\n+        } else {\n+            objectiveModifier = AtBScenarioModifier.getRandomHostileFacilityModifier();\n+        }\n+\n+        if (objectiveModifier != null) {\n+            scenario.getBackingScenario().addScenarioModifier(objectiveModifier);\n+            scenario.getBackingScenario().setName(String.format(\"%s - %s - %s\",\n+                    facility.getFacilityType(), alliedFacility ? \"Allied\" : \"Hostile\", objectiveModifier.getModifierName()));\n+        }\n+\n+        // add the \"fixed\" hostile facility modifiers after the primary ones\n+        if (!alliedFacility) {\n+            for(AtBScenarioModifier modifier : AtBScenarioModifier.getRequiredHostileFacilityModifiers()) {\n+                if(!scenario.getBackingScenario().alreadyHasModifier(modifier)) {\n+                    scenario.getBackingScenario().addScenarioModifier(modifier);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void processFacilityEffects(StratconTrackState track) {\n+        // TODO: these are \"weekly\"? effects that a stratcon facility has on the campaign/track state\n+        // currrently, that's\n+        // supply depot - allied - +1 sp\n+        // supply depot - hostile - +5% BV budget to all scenarios on track (shared modifier, so should be implemented there)\n+        // data center - allied - +1% star league cache contract (don't implement yet, but...)\n+        // data center - hostile - +5% scenario odds in track\n+        // industrial center - allied - all scenarios here have THIS IS COMING OUT OF YOUR PAYCHECK modifier\n+        // orbital defense - allied - sets 'no hostile aircraft' flag for track\n+        // orbital defense - hostile - sets 'no allied aircraft' flag for track\n+        // early warning system - allied - sets 'intercept allied base attacks' flag for track\n+        // early warning system - hostile - sets 'intercept hostile base attacks' flag for track\n+    }\n+\n+    /**\n+     * Process the deployment of a force to the given coordinates on the given track.\n+     */\n+    public static void processForceDeployment(StratconCoords coords, int forceID, \n+            Campaign campaign, StratconTrackState track, boolean sticky) {\n+        track.getRevealedCoords().add(coords);\n+        StratconFacility facility = track.getFacility(coords);\n+        if (facility != null) {\n+            facility.setVisible(true);\n+        }\n+\n+        if (campaign.getLances().get(forceID).getRole() == AtBLanceRole.SCOUTING) {\n+            for(int direction = 0; direction < 6; direction++) {\n+                StratconCoords checkCoords = coords.translate(direction);\n+\n+                facility = track.getFacility(checkCoords);\n+                if(facility != null) {\n+                    facility.setVisible(true);\n+                }\n+\n+                track.getRevealedCoords().add(coords.translate(direction));\n+            }\n+        }\n+\n+        // the force may be located in other places on the track - clear it out\n+        track.unassignForce(forceID);\n+        track.assignForce(forceID, coords, campaign.getLocalDate(), sticky);\n+        MekHQ.triggerEvent(new StratconDeploymentEvent(campaign.getForce(forceID)));\n+    }\n+\n+    /**\n+     * Worker function that processes the effects of deploying a reinforcement force to a scenario\n+     */\n+    public static boolean processReinforcementDeployment(ReinforcementEligibilityType reinforcementType,\n+            StratconCampaignState campaignState, StratconScenario scenario, Campaign campaign) {\n+        // if the force is already deployed to the track, we're done\n+        // if the force is a fight lance or we're using a support point\n+        // if there is an SP to burn, burn it and we're done\n+        // if there is a VP to burn, burn it and we're done\n+        // now, roll 2d6 + lance commander tactics\n+        // 9+ = deploy\n+        // 6+ = deploy, apply negative modifier to scenario\n+        // 2+ = fail to deploy, apply negative modifier to scenario; if fight lance, treat as 6+\n+\n+        if ((reinforcementType == ReinforcementEligibilityType.FightLance) ||\n+                (reinforcementType == ReinforcementEligibilityType.SupportPoint)) {\n+\n+            if (campaignState.getSupportPoints() > 0) {\n+                campaignState.useSupportPoint();\n+                return true;\n+            } else if (campaignState.getVictoryPoints() > 0) {\n+                campaignState.updateVictoryPoints(-1);\n+                return true;\n+            }\n+\n+            int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+            int roll = Compute.d6(2);\n+            int result = roll + tactics;\n+\n+            StringBuilder reportStatus = new StringBuilder();\n+            reportStatus.append(String.format(\"Attempting to reinforce scenario %s without SP/VP, roll 2d6 + %d: %d\",\n+                    scenario.getName(), tactics, result));\n+\n+            // fail to reinforce\n+            if ((result < 6) && (reinforcementType != ReinforcementEligibilityType.FightLance)) {\n+                reportStatus.append(\" - reinforcement attempt failed.\");\n+                campaign.addReport(reportStatus.toString());\n+                return false;\n+            // succeed but get an extra negative event added to the scenario\n+            } else if (result < 9) {\n+                MapLocation mapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+                AtBScenarioModifier scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+\n+                // keep rolling until we get an applicable one\n+                // TODO: have the AtBScenarioModifier sort these out instead for performance?\n+                while (scenarioModifier.getEventTiming() != EventTiming.PostForceGeneration) {\n+                    scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+                }\n+\n+                scenarioModifier.processModifier(scenario.getBackingScenario(), campaign, EventTiming.PostForceGeneration);\n+\n+                reportStatus.append(String.format(\" - reinforcement attempt succeeded; extra negative modifier (%s) applied to scenario.\",\n+                        scenarioModifier.getModifierName()));\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            // succeed without reservation\n+            } else {\n+                reportStatus.append(\" - reinforcement attempt succeeded;\");\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            }\n+        } else if (reinforcementType == ReinforcementEligibilityType.None) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Assigns a force to the scenario such that the majority of the force can be deployed\n+     */\n+    private static void assignAppropriateExtraForceToScenario(StratconScenario scenario,\n+            Map<MapLocation, List<Integer>> sortedAvailableForceIDs) {\n+        // the goal of this function is to avoid assigning ground units to air battles\n+        // and ground units/conventional fighters to space battle\n+\n+        List<MapLocation> mapLocations = new ArrayList<>();\n+        mapLocations.add(MapLocation.Space); // can always add ASFs\n+\n+        MapLocation scenarioMapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+\n+        if (scenarioMapLocation == MapLocation.LowAtmosphere) {\n+            mapLocations.add(MapLocation.LowAtmosphere); // can add conventional fighters to ground or low atmo battles\n+        }\n+\n+        if ((scenarioMapLocation == MapLocation.AllGroundTerrain) ||\n+                (scenarioMapLocation == MapLocation.SpecificGroundTerrain)) {\n+            mapLocations.add(MapLocation.AllGroundTerrain); // can only add ground units to ground battles\n+        }\n+\n+        MapLocation selectedLocation = mapLocations.get(Compute.randomInt(mapLocations.size()));\n+        List<Integer> forceIDs = sortedAvailableForceIDs.get(selectedLocation);\n+        int forceIndex = Compute.randomInt(forceIDs.size());\n+        int forceID = forceIDs.get(forceIndex);\n+        forceIDs.remove(forceIndex);\n+\n+        scenario.addPrimaryForce(forceID);\n+    }\n+\n+    /**\n+     * Worker function that \"locks in\" a scenario -\n+     * Adds it to the campaign so it's visible in the briefing room,\n+     * adds it to the track\n+     *\n+     */\n+    public static void commitPrimaryForces(Campaign campaign, StratconScenario scenario, StratconTrackState trackState) {\n+        trackState.addScenario(scenario);\n+\n+        // set up dates for the scenario if doesn't have them already\n+        if (scenario.getDeploymentDate() == null) {\n+            scenario.setDeploymentDate(campaign.getLocalDate());\n+        }\n+\n+        if (scenario.getActionDate() == null) {\n+            scenario.setActionDate(campaign.getLocalDate());\n+        }\n+\n+        if(scenario.getReturnDate() == null) {\n+            scenario.setReturnDate(campaign.getLocalDate().plusDays(trackState.getDeploymentTime()));\n+        }\n+\n+        // set the # of rerolls based on the actual lance assigned.\n+        int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+        scenario.getBackingScenario().setRerolls(tactics);\n+        // The number of defensive points available to a force entering a scenario is\n+        // 2 x tactics. By default, those points are spent on conventional minefields.\n+        if (commanderLanceHasDefensiveAssignment(scenario.getBackingScenario(), campaign)) {\n+            scenario.setNumDefensivePoints(tactics * 2);\n+            scenario.updateMinefieldCount(Minefield.TYPE_CONVENTIONAL, tactics * 2);\n+        }\n+\n+        for (int forceID : scenario.getPlayerTemplateForceIDs()) {\n+            Force force = campaign.getForce(forceID);\n+            force.clearScenarioIds(campaign, true);\n+            force.setScenarioId(scenario.getBackingScenarioID());\n+        }\n+\n+        scenario.commitPrimaryForces();\n+    }\n+\n+    /**\n+     * Utility method to determine if the current scenario's force commander\n+     * is on defence\n+     */\n+    private static boolean commanderLanceHasDefensiveAssignment(AtBDynamicScenario scenario, Campaign campaign) {\n+        Unit commanderUnit = scenario.getLanceCommander(campaign).getUnit();\n+        Lance lance = campaign.getLances().get(commanderUnit.getForceId());\n+\n+        if ((lance != null) && (lance.getRole() == AtBLanceRole.DEFENCE)) {\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * A hackish worker function that takes the given list of force IDs and\n+     * separates it into three sets;\n+     * one of forces that can be \"primary\" on a ground map\n+     * one of forces that can be \"primary\" on an atmospheric map\n+     * one of forces that can be \"primary\" in a space map\n+     * @param forceIDs List of force IDs to check\n+     * @return Sorted hash map\n+     */\n+    private static Map<MapLocation, List<Integer>> sortForcesByMapType(List<Integer> forceIDs, Campaign campaign) {\n+        Map<MapLocation, List<Integer>> retVal = new HashMap<>();\n+\n+        retVal.put(MapLocation.AllGroundTerrain, new ArrayList<>());\n+        retVal.put(MapLocation.LowAtmosphere, new ArrayList<>());\n+        retVal.put(MapLocation.Space, new ArrayList<>());\n+\n+        for (int forceID : forceIDs) {\n+            switch(campaign.getForce(forceID).getPrimaryUnitType(campaign)) {\n+            case UnitType.BATTLE_ARMOR:\n+            case UnitType.INFANTRY:\n+            case UnitType.MEK:\n+            case UnitType.TANK:\n+            case UnitType.PROTOMEK:\n+            case UnitType.VTOL:\n+                retVal.get(MapLocation.AllGroundTerrain).add(forceID);\n+                break;\n+            case UnitType.AERO:\n+                retVal.get(MapLocation.Space).add(forceID);\n+                // intentional fallthrough here, ASFs can go to atmospheric maps too\n+            case UnitType.CONV_FIGHTER:\n+                retVal.get(MapLocation.LowAtmosphere).add(forceID);\n+                break;\n+            }\n+        }\n+\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * Determine whether the user should be nagged about unresolved scenarios on AtB Stratcon tracks.\n+     * @param campaign Campaign to check.\n+     * @return An informative string containing the reasons the user was nagged.\n+     */\n+    public static String nagUnresolvedContacts(Campaign campaign) {\n+        StringBuilder sb = new StringBuilder();\n+\n+        // check every track attached to an active contract for unresolved scenarios\n+        // to which the player must deploy forces today\n+        for (AtBContract contract : campaign.getActiveAtBContracts()) {\n+            if (contract.getStratconCampaignState() == null) {\n+                continue;\n+            }\n+            \n+            for (StratconTrackState track : contract.getStratconCampaignState().getTracks()) {\n+                for (StratconScenario scenario : track.getScenarios().values()) {\n+                    if (scenario.getCurrentState() == ScenarioState.UNRESOLVED &&\n+                            campaign.getLocalDate().equals(scenario.getDeploymentDate())) {\n+                        // \"scenario name, track name\"\n+                        sb.append(String.format(\"%s, %s\\n\", scenario.getName(), track.getDisplayableName()));\n+                    }\n+                }\n+            }\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track.\n+     * Also registers it with the track and campaign.\n+     */\n+    private static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords) {\n+        int unitType = campaign.getForce(forceID).getPrimaryUnitType(campaign);\n+        ScenarioTemplate template = StratconScenarioFactory.getRandomScenario(unitType);\n+        // useful for debugging specific scenario types\n+        //ScenarioTemplate template = StratconScenarioFactory.getSpecificScenario(\"Hostile Facility.xml\");\n+\n+        return generateScenario(campaign, contract, track, forceID, coords, template);\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track,\n+     * using the given template. Also registers it with the campaign.\n+     */\n+    static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords, ScenarioTemplate template) {\n+        StratconScenario scenario = new StratconScenario();\n+        \n+        AtBDynamicScenario backingScenario = AtBDynamicScenarioFactory.initializeScenarioFromTemplate(template, contract, campaign);        \n+        scenario.setBackingScenario(backingScenario);\n+        scenario.setCoords(coords);\n+        \n+        // by default, certain conditions may make this bigger\n+        scenario.setRequiredPlayerLances(1);\n+\n+        // do an appropriate allied force if the contract calls for it\n+        // do any attached or integrated units\n+        setAlliedForceModifier(scenario, contract);\n+        setAttachedUnitsModifier(scenario, contract);\n+        applyFacilityModifiers(scenario, track, coords);\n+        applyGlobalModifiers(scenario, contract.getStratconCampaignState());\n+\n+        if ((contract.getCommandRights() == AtBContract.COM_HOUSE) ||\n+                (contract.getCommandRights() == AtBContract.COM_INTEGRATED)) {\n+            scenario.setRequiredScenario(true);\n+        }\n+\n+        AtBDynamicScenarioFactory.setScenarioModifiers(scenario.getBackingScenario());\n+        scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+        setScenarioDates(track, campaign, scenario);\n+        \n+        // the backing scenario ID must be updated after registering the backing scenario \n+        // with the campaign, so that the stratcon - backing scenario association is maintained\n+        // registering the scenario with the campaign should be done after setting\n+        // dates, otherwise, the report messages for new scenarios look weird\n+        campaign.addScenario(backingScenario, contract);\n+        scenario.setBackingScenarioID(backingScenario.getId());\n+        \n+        if (forceID > Force.FORCE_NONE) {\n+            scenario.addPrimaryForce(forceID);\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * Apply global scenario modifiers from campaign state to given scenario.\n+     */\n+    private static void applyGlobalModifiers(StratconScenario scenario, StratconCampaignState campaignState) {\n+        for (String modifierName : campaignState.getGlobalScenarioModifiers()) {\n+            AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierName);\n+\n+            if (modifier == null) {\n+                MekHQ.getLogger().error(String.format(\"Modifier %s not found; ignoring\", modifierName));\n+                continue;\n+            }\n+\n+            scenario.getBackingScenario().addScenarioModifier(modifier);\n+        }\n+    }\n+\n+    /**\n+     * Applies scenario modifiers from the current track to the given scenario.\n+     * @param scenario\n+     * @param track\n+     */\n+    private static void applyFacilityModifiers(StratconScenario scenario, StratconTrackState track, StratconCoords coords) {\n+        // loop through all the facilities on the track\n+        // if a facility has been revealed, then it has a 100% chance to apply its effect\n+        // if a facility has not been revealed, then it has a x% chance to apply its effect\n+        // if a facility is on the the scenario coordinates the it applies the local effects\n+        for (StratconCoords facilityCoords : track.getFacilities().keySet()) {\n+            boolean scenarioAtFacility = facilityCoords.equals(coords);\n+            StratconFacility facility = track.getFacilities().get(facilityCoords);\n+            List<String> modifierIDs = new ArrayList<>();\n+\n+            if (scenarioAtFacility) {\n+                modifierIDs = facility.getLocalModifiers();\n+            } else if (facility.isVisible() || (Compute.randomInt(100) <= facility.getAggroRating())) {\n+                modifierIDs = facility.getSharedModifiers();\n+            }\n+\n+            for (String modifierID : modifierIDs) {\n+                AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierID);\n+                if(modifier == null) {\n+                    MekHQ.getLogger().error(String.format(\"Modifier %s not found for facility %s\", modifierID, facility.getFormattedDisplayableName()));\n+                    continue;\n+                }\n+\n+                scenario.getBackingScenario().addScenarioModifier(modifier);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set up the appropriate primary allied force modifier, if any\n+     * @param contract The scenario's contract.\n+     */\n+    private static void setAlliedForceModifier(StratconScenario scenario, AtBContract contract) {\n+        int alliedUnitOdds = 0;\n+\n+        // first, we determine the odds of having an allied unit present\n+        // TODO: move this override out to the contract definition\n+        if (contract.getMissionType() == AtBContract.MT_RELIEFDUTY) {\n+            alliedUnitOdds = 50;\n+        } else {\n+            switch(contract.getCommandRights()) {\n+                case AtBContract.COM_INTEGRATED:\n+                    alliedUnitOdds = 50;\n+                    break;\n+                case AtBContract.COM_HOUSE:\n+                    alliedUnitOdds = 30;\n+                    break;\n+                case AtBContract.COM_LIAISON:\n+                    alliedUnitOdds = 10;\n+                    break;\n+            }\n+        }\n+\n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+\n+        // if an allied unit is present, then we want to make sure that it's ground units\n+        // for ground battles\n+        if (Compute.randomInt(100) <= alliedUnitOdds) {\n+            if((backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+               (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space)) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_ALLIED_AIR_UNITS));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_ALLIED_GROUND_UNITS));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set the 'attached' units modifier for the current scenario (integrated, house, liaison),\n+     * and make sure we're not deploying ground units to an air scenario\n+     * @param contract The scenario's contract\n+     */\n+    public static void setAttachedUnitsModifier(StratconScenario scenario, AtBContract contract) {\n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+        boolean airBattle = (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+                (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space);\n+\n+        // if we're on cadre duty, we're getting three trainees, period\n+        if (contract.getMissionType() == AtBContract.MT_CADREDUTY) {\n+            if (airBattle) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_TRAINEES_AIR));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_TRAINEES_GROUND));\n+            }\n+            return;\n+        }\n+\n+        // if we're under non-independent command rights, a supervisor may come along\n+        switch (contract.getCommandRights()) {\n+            case AtBContract.COM_INTEGRATED:\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(airBattle \n+                        ? MekHqConstants.SCENARIO_MODIFIER_INTEGRATED_UNITS_AIR\n+                        : MekHqConstants.SCENARIO_MODIFIER_INTEGRATED_UNITS_GROUND));\n+                break;\n+            case AtBContract.COM_HOUSE:\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(airBattle \n+                        ? MekHqConstants.SCENARIO_MODIFIER_HOUSE_CO_AIR\n+                        : MekHqConstants.SCENARIO_MODIFIER_HOUSE_CO_GROUND));\n+                break;\n+            case AtBContract.COM_LIAISON:\n+                if (scenario.isRequiredScenario()) {\n+                    backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(airBattle \n+                            ? MekHqConstants.SCENARIO_MODIFIER_LIAISON_AIR\n+                            : MekHqConstants.SCENARIO_MODIFIER_LIAISON_GROUND));\n+                }\n+                break;\n+        }\n+    }\n+\n+    /**\n+     * Worker function that sets scenario deploy/battle/return dates based on the track's properties and current campaign date\n+     */\n+    private static void setScenarioDates(StratconTrackState track, Campaign campaign, StratconScenario scenario) {\n+     // set up deployment day, battle day, return day here\n+        // safety code to prevent attempts to generate random int with upper bound of 0 which is apparently illegal\n+        int deploymentDay = track.getDeploymentTime() < 7 ? Compute.randomInt(7 - track.getDeploymentTime()) : 0;\n+        int battleDay = deploymentDay + (track.getDeploymentTime() > 0 ? Compute.randomInt(track.getDeploymentTime()) : 0);\n+        int returnDay = deploymentDay + track.getDeploymentTime();\n+\n+        LocalDate deploymentDate = campaign.getLocalDate();\n+        deploymentDate.plusDays(deploymentDay);\n+        LocalDate battleDate = campaign.getLocalDate();\n+        deploymentDate.plusDays(battleDay);\n+        LocalDate returnDate = campaign.getLocalDate();\n+        returnDate.plusDays(returnDay);\n+\n+        scenario.setDeploymentDate(deploymentDate);\n+        scenario.setActionDate(battleDate);\n+        scenario.setReturnDate(returnDate);\n+    }\n+\n+    /**\n+     * Helper function that determines if the unit type specified in the given scenario force template\n+     * would start out airborne on a ground map (hot dropped units aside)\n+     */\n+    private static boolean unitTypeIsAirborne(ScenarioForceTemplate template) {\n+        int unitType = template.getAllowedUnitType();\n+\n+        return (unitType == UnitType.AERO ||\n+                unitType == UnitType.CONV_FIGHTER ||\n+                unitType == UnitType.DROPSHIP ||\n+                unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_MIX) &&\n+                template.getStartingAltitude() > 0;\n+    }\n+\n+    /**\n+     * Determines whether the force in question has the same primary unit type as the force template.\n+     * @return Whether or not the unit types match.\n+     */\n+    public static boolean forceCompositionMatchesDeclaredUnitType(int primaryUnitType, int unitType, boolean reinforcements) {\n+        // special cases are \"ATB_MIX\" and \"ATB_AERO_MIX\", which encompass multiple unit types\n+        if (unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_MIX) {\n+            // \"AtB mix\" is usually ground units, but air units can sub in\n+            return primaryUnitType == UnitType.MEK ||\n+                    primaryUnitType == UnitType.TANK ||\n+                    primaryUnitType == UnitType.INFANTRY ||\n+                    primaryUnitType == UnitType.BATTLE_ARMOR ||\n+                    primaryUnitType == UnitType.PROTOMEK ||\n+                    primaryUnitType == UnitType.VTOL ||\n+                    (primaryUnitType == UnitType.AERO) && reinforcements ||\n+                    (primaryUnitType == UnitType.CONV_FIGHTER) && reinforcements;\n+        } else if (unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_AERO_MIX) {\n+            return primaryUnitType == UnitType.AERO ||\n+                    primaryUnitType == UnitType.CONV_FIGHTER;\n+        } else {\n+            return primaryUnitType == unitType;\n+        }\n+    }\n+\n+    /**\n+     * This is a set of all force IDs for forces that can be deployed to a scenario.\n+     * @param campaign Current campaign\n+     * @return Set of available force IDs.\n+     */\n+    public static List<Integer> getAvailableForceIDs(Campaign campaign) {\n+        List<Integer> retVal = new ArrayList<>();\n+\n+        // first, we gather a set of all forces that are already deployed to a track so we eliminate those later\n+        Set<Integer> forcesInTracks = new HashSet<>();\n+        for (Contract contract : campaign.getActiveContracts()) {\n+            if (contract instanceof AtBContract) {\n+                for (StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    forcesInTracks.addAll(track.getAssignedForceCoords().keySet());\n+                }\n+            }\n+        }\n+\n+        // now, we get all the forces that qualify as \"lances\", and filter out those that are\n+        // deployed to a scenario and not in a track already\n+        for (int key : campaign.getLances().keySet()) {\n+            Force force = campaign.getForce(key);\n+            if ((force != null) &&\n+                    !force.isDeployed() &&\n+                    !forcesInTracks.contains(force.getId())) {\n+                retVal.add(force.getId());\n+            }\n+        }\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * This is a list of all force IDs for forces that can be deployed to a scenario in the given force template\n+     * a) have not been assigned to a track\n+     * b) are combat-capable\n+     * c) are not deployed to a scenario\n+     * d) if attempting to deploy as reinforcements, haven't already failed to deploy\n+     */\n+    public static List<Integer> getAvailableForceIDs(int unitType, Campaign campaign, StratconTrackState currentTrack,\n+            boolean reinforcements, @Nullable StratconScenario currentScenario) {\n+        List<Integer> retVal = new ArrayList<>();\n+\n+        Set<Integer> forcesInTracks = new HashSet<>();\n+        // assemble a set of all force IDs that are currently assigned to tracks that are not this one\n+        for (Contract contract : campaign.getActiveContracts()) {\n+            if (contract instanceof AtBContract) {\n+                for (StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    if ((track != currentTrack) || !reinforcements) {\n+                        forcesInTracks.addAll(track.getAssignedForceCoords().keySet());\n+                    }\n+                }\n+            }\n+        }\n+        \n+        // if there's an existing scenario and we're doing reinforcements,\n+        // prevent forces that failed to deploy from trying to deploy again\n+        if (reinforcements && (currentScenario != null)) {\n+            forcesInTracks.addAll(currentScenario.getFailedReinforcements());\n+        }\n+\n+        for (int key : campaign.getLances().keySet()) {\n+            Force force = campaign.getForce(key);\n+\n+            if (force == null) {\n+                continue;\n+            }\n+\n+            int primaryUnitType = force.getPrimaryUnitType(campaign);\n+            if (!force.isDeployed() &&\n+                    (force.getScenarioId() <= 0) &&\n+                    !force.getUnits().isEmpty() &&\n+                    !forcesInTracks.contains(force.getId()) &&\n+                    forceCompositionMatchesDeclaredUnitType(primaryUnitType, unitType, reinforcements)) {\n+                retVal.add(force.getId());\n+            }\n+        }\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * Returns a list of individual units eligible for deployment in scenarios run by \"Defend\" lances\n+     * @return List of unit IDs.\n+     */\n+    public static List<Unit> getEligibleDefensiveUnits(Campaign campaign) {\n+        List<Unit> retVal = new ArrayList<>();\n+\n+        for (Unit u : campaign.getUnits()) {\n+            // \"defensive\" units are infantry, battle armor and (Weisman help you) gun emplacements\n+        \t// and also said unit should be intact/alive/etc\n+        \tboolean isEligibleInfantry = \n+        \t\t\t((u.getEntity().getUnitType() == UnitType.INFANTRY) ||\n+                    (u.getEntity().getUnitType() == UnitType.BATTLE_ARMOR)) &&\n+                    !u.isUnmanned();\n+        \t\n+        \tboolean isEligibleGunEmplacement = u.getEntity().getUnitType() == UnitType.GUN_EMPLACEMENT;\n+        \t\n+        \tif ((isEligibleInfantry || isEligibleGunEmplacement) && \n+            \t\t!u.isDeployed() &&\n+                    !u.isMothballed() &&\n+                    u.isFunctional()) {\n+\n+                // this is a little inefficient, but probably there aren't too many active AtB contracts at a time\n+                for (AtBContract contract : campaign.getActiveAtBContracts()) {\n+                    if (contract.getStratconCampaignState().isForceDeployedHere(u.getForceId())) {\n+                        continue;\n+                    }\n+                }\n+\n+                retVal.add(u);\n+            }\n+        }\n+\n+        return retVal;\n+    }\n+    \n+    /**\n+     * Returns a list of individual units eligible for deployment in scenarios\n+     * that result from the lance leader having a leadership score\n+     * @return List of unit IDs.\n+     */\n+    public static List<Unit> getEligibleLeadershipUnits(Campaign campaign, Set<Integer> forceIDs) {\n+        List<Unit> retVal = new ArrayList<>();\n+\n+        // The criteria are as follows:\n+        // - unit is of a different unit type than the primary unit type of the force \n+        // - unit has a lower BV than the force's lowest BV unit\n+        \n+        Integer lowestBV = getLowestBV(campaign, forceIDs);\n+        \n+        // no units assigned, the rest is meaningless.\n+        if (lowestBV == null) {\n+            return retVal;\n+        }\n+        \n+        int primaryUnitType = getPrimaryUnitType(campaign, forceIDs);\n+        \n+        for (Unit u : campaign.getUnits()) {\n+            if ((primaryUnitType != u.getEntity().getUnitType()) &&\n+                    !u.isDeployed() &&\n+                    !u.isMothballed() &&\n+                    u.isFunctional() &&\n+                    (u.getEntity().calculateBattleValue() < lowestBV) &&\n+                    !isUnitDeployedToStratCon(u)) {\n+                retVal.add(u);\n+            }\n+        }\n+\n+        return retVal;\n+    }\n+    \n+    /**\n+     * Check if the unit's force (if one exists) has been deployed to a StratCon track\n+     */\n+    public static boolean isUnitDeployedToStratCon(Unit u) {\n+        if (!u.getCampaign().getCampaignOptions().getUseStratCon()) {\n+            return false;\n+        }\n+        \n+        //this is a little inefficient, but probably there aren't too many active AtB contracts at a time\n+        for (AtBContract contract : u.getCampaign().getActiveAtBContracts()) {\n+            if (contract.getStratconCampaignState().isForceDeployedHere(u.getForceId())) {\n+                return true;\n+            }\n+        }\n+        \n+        return false;\n+    }\n+    \n+    /**\n+     * Given a campaign and a list of force IDs, calculate the unit with the lowest BV.\n+     */\n+    private static Integer getLowestBV(Campaign campaign, Set<Integer> forceIDs) {\n+        Integer lowestBV = null;\n+        \n+        for (int forceID : forceIDs) {\n+            Force force = campaign.getForce(forceID);\n+            if (force == null) {\n+                continue;\n+            }\n+            \n+            for (UUID id : force.getUnits()) {\n+                if (campaign.getUnit(id) == null) {\n+                    continue;\n+                }\n+                \n+                int currentBV = campaign.getUnit(id).getEntity().calculateBattleValue();\n+                \n+                if ((lowestBV == null) || (currentBV < lowestBV)) {\n+                    lowestBV = currentBV;\n+                }\n+            }\n+        }\n+        \n+        return lowestBV;\n+    }\n+    \n+    /**\n+     * Calculates the majority unit type for the forces given the IDs.\n+     */\n+    private static int getPrimaryUnitType(Campaign campaign, Set<Integer> forceIDs) {\n+        Map<Integer, Integer> unitTypeBuckets = new TreeMap<>();\n+        int biggestBucketID = -1;\n+        int biggestBucketCount = 0;\n+        \n+        for (int forceID : forceIDs) {\n+            Force force = campaign.getForce(forceID);\n+            if (force == null) {\n+                continue;\n+            }\n+        \n+            for (UUID id : force.getUnits()) {\n+                Unit unit = campaign.getUnit(id);\n+                if ((unit == null) || \n+                        (unit.getEntity() == null)) {\n+                    continue;\n+                }\n+                \n+                int unitType = unit.getEntity().getUnitType();\n+    \n+                unitTypeBuckets.merge(unitType, 1, (oldCount, value) -> oldCount + value);\n+                \n+                if (unitTypeBuckets.get(unitType) > biggestBucketCount) {\n+                    biggestBucketCount = unitTypeBuckets.get(unitType);\n+                    biggestBucketID = unitType;\n+                }\n+            }\n+        }\n+        \n+        return biggestBucketID;\n+    }\n+\n+    /**\n+     * Determines what rules to use when deploying a force for reinforcements to the given track.\n+     */\n+    public static ReinforcementEligibilityType getReinforcementType(int forceID,\n+            StratconTrackState trackState, Campaign campaign) {\n+        // if the force is currently deployed to the track, it'll be able to deploy \"for free\"\n+        if (trackState.isForceDeployed(forceID)) {\n+            return ReinforcementEligibilityType.ChainedScenario;\n+        }\n+\n+        // if the force is in 'fight' stance, it'll be able to deploy using 'fight lance' rules\n+        if (campaign.getLances().containsKey(forceID) &&\n+                campaign.getLances().get(forceID).getRole() == AtBLanceRole.FIGHTING) {\n+            return ReinforcementEligibilityType.FightLance;\n+        }\n+\n+        // if the force is deployed elsewhere, it cannot be deployed as reinforcements\n+        for (Contract contract : campaign.getActiveContracts()) {\n+            if(contract instanceof AtBContract) {\n+                for(StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    if(track != trackState && track.getAssignedForceCoords().containsKey(forceID)) {\n+                        return ReinforcementEligibilityType.None;\n+                    }\n+                }\n+            }\n+        }\n+\n+        // otherwise, the force requires support points / vps to deploy\n+        return ReinforcementEligibilityType.SupportPoint;\n+    }\n+    \n+    /**\n+     * Given a track and the current campaign state, and if the player is deploying\n+     * a force or not, figure out the odds of a scenario occuring.\n+     */\n+    public static int calculateScenarioOdds(StratconTrackState track, \n+            AtBContract contract, boolean playerDeployingForce) {\n+        // rules:\n+        // rout morale: 0%\n+        // very low morale: -10% when deploying forces to track, 0% attack\n+        // low morale: -5%\n+        // high morale: +5%\n+        // invincible: special case, let's do +10% for now\n+        int moraleModifier = 0;\n+        \n+        switch (contract.getMoraleLevel()) {\n+            case AtBContract.MORALE_ROUT:\n+                return 0;\n+            case AtBContract.MORALE_VERYLOW:\n+                if (playerDeployingForce) {\n+                    moraleModifier = -10;\n+                } else {\n+                    return 0;\n+                }\n+                break;\n+            case AtBContract.MORALE_LOW:\n+                moraleModifier = -5;\n+                break;\n+            case AtBContract.MORALE_HIGH:\n+                moraleModifier = 5;\n+                break;\n+            case AtBContract.MORALE_INVINCIBLE:\n+                moraleModifier = 10;\n+                break;\n+        }\n+        \n+        // facilities: for each hostile data center, add +5%\n+        // for each allied data center, subtract 5\n+        int dataCenterModifier = 0;\n+        for (StratconFacility facility : track.getFacilities().values()) {\n+            if (facility.getFacilityType() == FacilityType.DataCenter) {\n+                dataCenterModifier += facility.getOwner() == ForceAlignment.Allied ? -5 : 5;\n+            }\n+        }\n+            \n+        return track.getScenarioOdds() + moraleModifier + dataCenterModifier;\n+    }\n+\n+    /**\n+     * Removes the facility associated with the given scenario from the relevant track/\n+     */\n+    public static void updateFacilityForScenario(AtBScenario scenario, AtBContract contract, boolean destroy, boolean capture) {\n+        if (contract.getStratconCampaignState() == null) {\n+            return;\n+        }\n+\n+        // this is kind of kludgy, but there's currently no way to link a scenario back to its backing scenario\n+        // TODO: introduce mapping in contract or at least trackstate\n+        // basically, we're looping through all scenarios on all the contract's tracks\n+        // if we find one with the same ID as the one being resolved, that's our facility: get rid of it.\n+        for (StratconTrackState trackState : contract.getStratconCampaignState().getTracks()) {\n+            for (StratconCoords coords : trackState.getScenarios().keySet()) {\n+                StratconScenario potentialScenario = trackState.getScenario(coords);\n+                if (potentialScenario.getBackingScenarioID() == scenario.getId()) {\n+\n+                    if (destroy) {\n+                        trackState.removeFacility(coords);\n+                    } else {\n+                        StratconFacility facility = trackState.getFacility(coords);\n+\n+                        if (facility == null) {\n+                            continue;\n+                        }\n+\n+                        if (capture) {\n+                            facility.incrementOwnershipChangeScore();\n+                        } else {\n+                            facility.decrementOwnershipChangeScore();\n+                        }\n+                    }\n+\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Processes completion of a Stratcon scenario, if the given tracker is associated\n+     * with a stratcon-enabled mission. Intended to be called after ResolveScenarioTracker.finish() has been invoked.\n+     */\n+    public static void processScenarioCompletion(ResolveScenarioTracker rst) {\n+        if (rst.getMission() instanceof AtBContract) {\n+            StratconCampaignState campaignState = ((AtBContract) rst.getMission()).getStratconCampaignState();\n+            if (campaignState == null) {\n+                return;\n+            }\n+\n+            for (StratconTrackState track : campaignState.getTracks()) {\n+                if (track.getBackingScenariosMap().containsKey(rst.getScenario().getId())) {\n+                    // things that may potentially happen:\n+                    // scenario is removed from track - implemented\n+                    // track gets remaining forces added to reinforcement pool\n+                    // facility gets remaining forces stored in reinforcement pool\n+                    // process VP and SO\n+\n+                    StratconScenario scenario = track.getBackingScenariosMap().get(rst.getScenario().getId());\n+\n+\n+                    StratconFacility facility = track.getFacility(scenario.getCoords());\n+\n+                    if ((facility != null) && (facility.getOwnershipChangeScore() > 0)) {\n+                        if (facility.getOwner() == ForceAlignment.Allied) {\n+                            facility.setOwner(ForceAlignment.Opposing);\n+                        } else {\n+                            facility.setOwner(ForceAlignment.Allied);\n+                        }\n+                    }\n+\n+                    boolean victory = rst.getScenario().getStatus() == Scenario.S_VICTORY ||\n+                            rst.getScenario().getStatus() == Scenario.S_MVICTORY;\n+\n+                    if (scenario.isRequiredScenario()) {\n+                        campaignState.updateVictoryPoints(victory ? 1 : -1);\n+                    }\n+\n+                    if (scenario.isStrategicObjective()) {\n+                        if (campaignState.strategicObjectivesBehaveAsVPs()) {\n+                            campaignState.updateVictoryPoints(victory ? 1 : -1);\n+                        } else {\n+                            campaignState.incrementStrategicObjectiveCompletedCount();\n+                        }\n+                    }\n+\n+                    processTrackForceReturnDates(track, rst.getCampaign().getLocalDate());\n+\n+                    track.removeScenario(scenario);\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Worker function that goes through a track and undeploys any forces where the\n+     * return date is on or before the given date.\n+     */\n+    public static void processTrackForceReturnDates(StratconTrackState track, LocalDate date) {\n+        List<Integer> forcesToUndeploy = new ArrayList<>();\n+\n+        // for each force on the track, if the return date is today or in the past,\n+        // \"return to base\", unless it's been told to stay in the field\n+        for (int forceID : track.getAssignedForceReturnDates().keySet()) {\n+            if ((track.getAssignedForceReturnDates().get(forceID).equals(date) ||\n+                    track.getAssignedForceReturnDates().get(forceID).isBefore(date)) &&\n+                    !track.getStickyForces().contains(forceID)) {\n+                forcesToUndeploy.add(forceID);\n+            }\n+        }\n+\n+        for (int forceID : forcesToUndeploy) {\n+            track.unassignForce(forceID);\n+        }\n+    }\n+    \n+    /**\n+     * Processes an ignored dynamic scenario - locates it on one of the tracks\n+     * and calls the standared 'ignored scenario' routine.\n+     * @return Whether or not we also need to get rid of the backing scenario from the campaign\n+     */\n+    public static boolean processIgnoredScenario(AtBDynamicScenario scenario, StratconCampaignState campaignState) {\n+        for (StratconTrackState track : campaignState.getTracks()) {\n+            if (track.getBackingScenariosMap().containsKey(scenario.getId())) {\n+                return processIgnoredScenario(track.getBackingScenariosMap().get(scenario.getId()), campaignState);\n+            }\n+        }\n+        \n+        return true;\n+    }\n+    \n+\n+    /**\n+     * Processes an ignored Stratcon scenario\n+     * @return Whether or not we also need to get rid of the backing scenario from the campaign\n+     */\n+    public static boolean processIgnoredScenario(StratconScenario scenario, StratconCampaignState campaignState) {\n+        for (StratconTrackState track : campaignState.getTracks()) {\n+            if (track.getScenarios().containsKey(scenario.getCoords())) {\n+                // subtract VP if scenario is 'required'\n+                if (scenario.isRequiredScenario()) {\n+                    campaignState.updateVictoryPoints(-1);\n+                }\n+                \n+                track.removeScenario(scenario);\n+\n+                StratconFacility localFacility = track.getFacility(scenario.getCoords());\n+                if (localFacility != null) {\n+                    // if the ignored scenario was on top of an allied facility\n+                    // then it'll get captured, and the player will possibly lose a SO\n+                    if (localFacility.getOwner() == ForceAlignment.Allied) {\n+                        localFacility.setOwner(ForceAlignment.Opposing);\n+\n+                        if (localFacility.isStrategicObjective()) {\n+                            campaignState.decrementStrategicObjectiveCompletedCount();\n+                        }\n+                    }\n+                    \n+                    return true;\n+                } else {\n+                    // if it's an open-field\n+                    // move scenario towards nearest allied facility\n+                    StratconCoords closestAlliedFacilityCoords = track.findClosestAlliedFacilityCoords(scenario.getCoords());\n+\n+                    if (closestAlliedFacilityCoords != null) {\n+                        StratconCoords newCoords = scenario.getCoords().translate(scenario.getCoords().direction(closestAlliedFacilityCoords));\n+                        scenario.setCoords(newCoords);\n+                        \n+                        int daysForward = Math.min(1, track.getDeploymentTime());\n+                        \n+                        scenario.setDeploymentDate(scenario.getDeploymentDate().plusDays(daysForward));\n+                        scenario.setActionDate(scenario.getActionDate().plusDays(daysForward));\n+                        scenario.setReturnDate(scenario.getReturnDate().plusDays(daysForward));\n+                        \n+                        // refresh the scenario's position on the track\n+                        track.addScenario(scenario);\n+                        \n+                        // TODO: Write some functionality to \"copy\" a scenario's \n+                        // bot forces over\n+                        /*StratconFacility facility = track.getFacility(newCoords);\n+\n+                        if (facility != null) {\n+                            ScenarioTemplate template = StratconScenarioFactory.getFacilityScenario(true);\n+                            scenario = generateScenario(campaignState.getCa, contract, track, forceID, coords, template);\n+                            setupFacilityScenario(scenario, facility);\n+                        }*/\n+\n+                        // TODO: if the allied facility is in the new coords, replace this scenario\n+                        // with a facility defense, with the opfor coming directly from all hostiles assigned to this scenario\n+\n+                        scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                        return false;\n+                    } else {\n+                        // TODO: if there's no allied facilities here, add its forces to track reinforcement pool\n+                        return true;\n+                    }\n+                }\n+            }\n+        }\n+        \n+        // if we couldn't find the scenario on any tracks, then let's just \n+        // rid of any underlying AtB scenarios as well\n+        return true;\n+    }\n+\n+    public void startup() {\n+        MekHQ.registerHandler(this);\n+    }\n+\n+    /**\n+     * Event handler for the new day event.\n+     */\n+    @Subscribe\n+    public void handleNewDay(NewDayEvent ev) {\n+    \t// don't do any of this if StratCon isn't turned on\n+    \tif (!ev.getCampaign().getCampaignOptions().getUseStratCon()) {\n+    \t\treturn;\n+    \t}\n+    \t\n+        boolean isMonday = ev.getCampaign().getLocalDate().getDayOfWeek() == DayOfWeek.MONDAY;\n+\n+\n+        // run scenario generation routine for every track attached to an active contract\n+        for (AtBContract contract : ev.getCampaign().getActiveAtBContracts()) {\n+            StratconCampaignState campaignState = ((AtBContract) contract).getStratconCampaignState();", "originalCommit": "b36d9fa6bf982c7b833b1ac0a0473d37f6e84760", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTE5Mjk0MQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r615192941", "bodyText": "?", "author": "Windchild292", "createdAt": "2021-04-17T02:16:00Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1404 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.UUID;\n+\n+import megamek.common.Compute;\n+import megamek.common.Minefield;\n+import megamek.common.UnitType;\n+import megamek.common.annotations.Nullable;\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.Utilities;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.ResolveScenarioTracker;\n+import mekhq.campaign.againstTheBot.enums.AtBLanceRole;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.event.StratconDeploymentEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.force.Lance;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier.EventTiming;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconFacility.FacilityType;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.unit.Unit;\n+\n+/**\n+ * This class contains \"rules\" logic for the AtB-Stratcon state\n+ * @author NickAragua\n+ */\n+public class StratconRulesManager {\n+    /**\n+     * What makes a particular lance eligible to be reinforcements for a scenario\n+     */\n+    public enum ReinforcementEligibilityType {\n+        /**\n+         * Nothing\n+         */\n+        None,\n+\n+        /**\n+         * Lance is already deployed to the track\n+         */\n+        ChainedScenario,\n+\n+        /**\n+         * We pay a support point or convert a victory point to a support point\n+         */\n+        SupportPoint,\n+\n+        /**\n+         * The lance's deployment orders are \"Fight\"\n+         */\n+        FightLance\n+    }\n+\n+    /**\n+     * This function potentially generates non-player-initiated scenarios for the given track.\n+     */\n+    public static void generateScenariosForTrack(Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // maps scenarios to force IDs\n+        List<StratconScenario> generatedScenarios = new ArrayList<>();\n+        boolean autoAssignLances = contract.getCommandRights() == AtBContract.COM_INTEGRATED;\n+\n+        // get this list just so we have it available\n+        List<Integer> availableForceIDs = getAvailableForceIDs(campaign);\n+        Map<MapLocation, List<Integer>> sortedAvailableForceIDs = sortForcesByMapType(availableForceIDs, campaign);\n+\n+        // make X rolls, where X is the number of required lances for the track\n+        // that's the chance to spawn a scenario.\n+        // if a scenario occurs, then we pick a random non-deployed lance and use it to drive the opfor generation later\n+        // once we've determined that scenarios occur, we loop through the ones that we generated\n+        // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all\n+        for (int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            int targetNum = calculateScenarioOdds(track, contract, false);\n+            \n+            // if we haven't already used all the player forces and are required to randomly generate a scenario\n+            if (!availableForceIDs.isEmpty() && (Compute.randomInt(100) <= targetNum)) {\n+                // pick random coordinates and force to drive the scenario\n+                int x = Compute.randomInt(track.getWidth());\n+                int y = Compute.randomInt(track.getHeight());\n+\n+                StratconCoords scenarioCoords = new StratconCoords(x, y);\n+\n+                // if forces are already assigned to these coordinates, use those instead\n+                // of randomly-selected ones\n+                if (track.getAssignedCoordForces().containsKey(scenarioCoords)) {\n+                    StratconScenario scenario = generateScenarioForExistingForces(scenarioCoords,\n+                            track.getAssignedCoordForces().get(scenarioCoords), \n+                            contract, campaign, track);\n+                    generatedScenarios.add(scenario);\n+                    continue;\n+                }\n+                \n+                // otherwise, pick a random force from the avail\n+                int randomForceIndex = Compute.randomInt(availableForceIDs.size());\n+                int randomForceID = availableForceIDs.get(randomForceIndex);\n+                \n+                // remove the force from the available lists so we don't designate it as primary twice\n+                availableForceIDs.remove(randomForceIndex);\n+\n+                // we want to remove the actual int with the value, not the value at the index\n+                sortedAvailableForceIDs.get(MapLocation.AllGroundTerrain).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.LowAtmosphere).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.Space).remove((Integer) randomForceID);\n+\n+                // two scenarios on the same coordinates wind up increasing in size\n+                if (track.getScenarios().containsKey(scenarioCoords)) {\n+                    track.getScenarios().get(scenarioCoords).incrementRequiredPlayerLances();\n+                    assignAppropriateExtraForceToScenario(track.getScenarios().get(scenarioCoords), sortedAvailableForceIDs);\n+                    continue;\n+                }\n+\n+                StratconScenario scenario = setupScenario(scenarioCoords, randomForceID, campaign, contract, track);\n+                generatedScenarios.add(scenario);\n+\n+                // if we're auto-assigning lances, deploy the force to the track as well\n+                if (autoAssignLances) {\n+                    processForceDeployment(scenarioCoords, randomForceID, campaign, track, false);\n+                }\n+            }\n+        }\n+\n+        // if under liaison command, pick a random scenario from the ones generated\n+        // to set as required and attach liaison\n+        if (contract.getCommandRights() == AtBContract.COM_LIAISON) {\n+        \tStratconScenario randomScenario = Utilities.getRandomItem(generatedScenarios);\n+        \trandomScenario.setRequiredScenario(true);\n+            setAttachedUnitsModifier(randomScenario, contract);\n+        }\n+\n+        // now, we loop through all the scenarios we set up\n+        // and generate the opfors / events / etc\n+        // if not auto-assigning lances, we then back out the lance assignments.\n+        for (StratconScenario scenario : generatedScenarios) {\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+\n+            if(!autoAssignLances && !scenario.ignoreForceAutoAssignment()) {\n+                for(int forceID : scenario.getPlayerTemplateForceIDs()) {\n+                    scenario.getBackingScenario().removeForce(forceID);\n+                }\n+\n+                scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                track.addScenario(scenario);\n+            } else {\n+                commitPrimaryForces(campaign, scenario, track);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Given a set of force IDs and coordinates, generate a scenario\n+     * Useful for when we want to generate scenarios \n+     * for forces already deployed to a track\n+     */\n+    public static StratconScenario generateScenarioForExistingForces(StratconCoords scenarioCoords, \n+            Set<Integer> forceIDs, AtBContract contract, Campaign campaign, StratconTrackState track) {\n+        boolean firstForce = true;\n+        StratconScenario scenario = null;\n+        \n+        for (int forceID : forceIDs) {\n+            if (firstForce) {\n+                scenario = setupScenario(scenarioCoords, forceID, campaign, contract, track);\n+                firstForce = false;\n+            } else {\n+                scenario.incrementRequiredPlayerLances();\n+                scenario.addPrimaryForce(forceID);\n+            }\n+        }\n+        \n+        // this is theoretically possible if forceIDs is passed in as null - not likely in practice\n+        // but might as well, to future-proof.\n+        if (scenario != null) {\n+            scenario.setIgnoreForceAutoAssignment(true);\n+        }\n+        \n+        return scenario;\n+    }\n+\n+    /**\n+     * Deploys a force to the given coordinates on the given track as a result of explicit player action.\n+     */\n+    public static void deployForceToCoords(StratconCoords coords, int forceID, \n+            Campaign campaign, AtBContract contract, StratconTrackState track, boolean sticky) {\n+        // the following things should happen:\n+        // 1. call to \"process force deployment\", which reveals fog of war in or around the coords, depending on force role\n+        // 2. if coords are a hostile facility, we get a facility mission\n+        // 3. if coords are empty, we *may* get a mission\n+\n+        processForceDeployment(coords, forceID, campaign, track, sticky);\n+\n+        // don't create a scenario on top of allied facilities\n+        StratconFacility facility = track.getFacility(coords);\n+        boolean isNonAlliedFacility = (facility != null) && (facility.getOwner() != ForceAlignment.Allied);\n+        int targetNum = calculateScenarioOdds(track, contract, true);\n+        boolean spawnScenario = (facility == null) && (Compute.randomInt(100) <= targetNum);\n+\n+        if (isNonAlliedFacility || spawnScenario) {\n+            StratconScenario scenario = setupScenario(coords, forceID, campaign, contract, track);\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            commitPrimaryForces(campaign, scenario, track);\n+        }\n+    }\n+\n+    /**\n+     * Logic to set up a scenario\n+     */\n+    private static StratconScenario setupScenario(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        StratconScenario scenario = null;\n+\n+        if (track.getFacilities().containsKey(coords)) {\n+            StratconFacility facility = track.getFacility(coords);\n+            boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+            ScenarioTemplate template = StratconScenarioFactory.getFacilityScenario(alliedFacility);\n+            scenario = generateScenario(campaign, contract, track, forceID, coords, template);\n+            setupFacilityScenario(scenario, facility);\n+        } else {\n+            scenario = generateScenario(campaign, contract, track, forceID, coords);\n+\n+            // we may generate a facility scenario randomly - if so, do the facility-related stuff\n+            // and add a new facility to the track\n+            if (scenario.getBackingScenario().getTemplate().isFacilityScenario()) {\n+                StratconFacility facility = scenario.getBackingScenario().getTemplate().isHostileFacility() ?\n+                        StratconFacilityFactory.getRandomHostileFacility() : StratconFacilityFactory.getRandomAlliedFacility();\n+                facility.setVisible(true);\n+                track.addFacility(coords, facility);\n+                setupFacilityScenario(scenario, facility);\n+            }\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * carries out tasks relevant to facility scenarios\n+     */\n+    private static void setupFacilityScenario(StratconScenario scenario, StratconFacility facility) {\n+        // this includes:\n+        // for hostile facilities\n+        // - add a destroy objective (always the option to level the facility)\n+        // - add a capture objective (always the option to capture the facility)\n+        // - if so indicated by parameter, roll a random hostile facility objective and add it if not capture/destroy\n+        // for allied facilities\n+        // - add a defend objective (always the option to defend the facility)\n+        // - if so indicated by parameter, roll a random allied facility objective and add it if not defend\n+        AtBScenarioModifier objectiveModifier = null;\n+        boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+\n+        if (alliedFacility) {\n+            objectiveModifier = AtBScenarioModifier.getRandomAlliedFacilityModifier();\n+        } else {\n+            objectiveModifier = AtBScenarioModifier.getRandomHostileFacilityModifier();\n+        }\n+\n+        if (objectiveModifier != null) {\n+            scenario.getBackingScenario().addScenarioModifier(objectiveModifier);\n+            scenario.getBackingScenario().setName(String.format(\"%s - %s - %s\",\n+                    facility.getFacilityType(), alliedFacility ? \"Allied\" : \"Hostile\", objectiveModifier.getModifierName()));\n+        }\n+\n+        // add the \"fixed\" hostile facility modifiers after the primary ones\n+        if (!alliedFacility) {\n+            for(AtBScenarioModifier modifier : AtBScenarioModifier.getRequiredHostileFacilityModifiers()) {\n+                if(!scenario.getBackingScenario().alreadyHasModifier(modifier)) {\n+                    scenario.getBackingScenario().addScenarioModifier(modifier);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void processFacilityEffects(StratconTrackState track) {\n+        // TODO: these are \"weekly\"? effects that a stratcon facility has on the campaign/track state\n+        // currrently, that's\n+        // supply depot - allied - +1 sp\n+        // supply depot - hostile - +5% BV budget to all scenarios on track (shared modifier, so should be implemented there)\n+        // data center - allied - +1% star league cache contract (don't implement yet, but...)\n+        // data center - hostile - +5% scenario odds in track\n+        // industrial center - allied - all scenarios here have THIS IS COMING OUT OF YOUR PAYCHECK modifier\n+        // orbital defense - allied - sets 'no hostile aircraft' flag for track\n+        // orbital defense - hostile - sets 'no allied aircraft' flag for track\n+        // early warning system - allied - sets 'intercept allied base attacks' flag for track\n+        // early warning system - hostile - sets 'intercept hostile base attacks' flag for track\n+    }\n+\n+    /**\n+     * Process the deployment of a force to the given coordinates on the given track.\n+     */\n+    public static void processForceDeployment(StratconCoords coords, int forceID, \n+            Campaign campaign, StratconTrackState track, boolean sticky) {\n+        track.getRevealedCoords().add(coords);\n+        StratconFacility facility = track.getFacility(coords);\n+        if (facility != null) {\n+            facility.setVisible(true);\n+        }\n+\n+        if (campaign.getLances().get(forceID).getRole() == AtBLanceRole.SCOUTING) {\n+            for(int direction = 0; direction < 6; direction++) {\n+                StratconCoords checkCoords = coords.translate(direction);\n+\n+                facility = track.getFacility(checkCoords);\n+                if(facility != null) {\n+                    facility.setVisible(true);\n+                }\n+\n+                track.getRevealedCoords().add(coords.translate(direction));\n+            }\n+        }\n+\n+        // the force may be located in other places on the track - clear it out\n+        track.unassignForce(forceID);\n+        track.assignForce(forceID, coords, campaign.getLocalDate(), sticky);\n+        MekHQ.triggerEvent(new StratconDeploymentEvent(campaign.getForce(forceID)));\n+    }\n+\n+    /**\n+     * Worker function that processes the effects of deploying a reinforcement force to a scenario\n+     */\n+    public static boolean processReinforcementDeployment(ReinforcementEligibilityType reinforcementType,\n+            StratconCampaignState campaignState, StratconScenario scenario, Campaign campaign) {\n+        // if the force is already deployed to the track, we're done\n+        // if the force is a fight lance or we're using a support point\n+        // if there is an SP to burn, burn it and we're done\n+        // if there is a VP to burn, burn it and we're done\n+        // now, roll 2d6 + lance commander tactics\n+        // 9+ = deploy\n+        // 6+ = deploy, apply negative modifier to scenario\n+        // 2+ = fail to deploy, apply negative modifier to scenario; if fight lance, treat as 6+\n+\n+        if ((reinforcementType == ReinforcementEligibilityType.FightLance) ||\n+                (reinforcementType == ReinforcementEligibilityType.SupportPoint)) {\n+\n+            if (campaignState.getSupportPoints() > 0) {\n+                campaignState.useSupportPoint();\n+                return true;\n+            } else if (campaignState.getVictoryPoints() > 0) {\n+                campaignState.updateVictoryPoints(-1);\n+                return true;\n+            }\n+\n+            int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+            int roll = Compute.d6(2);\n+            int result = roll + tactics;\n+\n+            StringBuilder reportStatus = new StringBuilder();\n+            reportStatus.append(String.format(\"Attempting to reinforce scenario %s without SP/VP, roll 2d6 + %d: %d\",\n+                    scenario.getName(), tactics, result));\n+\n+            // fail to reinforce\n+            if ((result < 6) && (reinforcementType != ReinforcementEligibilityType.FightLance)) {\n+                reportStatus.append(\" - reinforcement attempt failed.\");\n+                campaign.addReport(reportStatus.toString());\n+                return false;\n+            // succeed but get an extra negative event added to the scenario\n+            } else if (result < 9) {\n+                MapLocation mapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+                AtBScenarioModifier scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+\n+                // keep rolling until we get an applicable one\n+                // TODO: have the AtBScenarioModifier sort these out instead for performance?\n+                while (scenarioModifier.getEventTiming() != EventTiming.PostForceGeneration) {\n+                    scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+                }\n+\n+                scenarioModifier.processModifier(scenario.getBackingScenario(), campaign, EventTiming.PostForceGeneration);\n+\n+                reportStatus.append(String.format(\" - reinforcement attempt succeeded; extra negative modifier (%s) applied to scenario.\",\n+                        scenarioModifier.getModifierName()));\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            // succeed without reservation\n+            } else {\n+                reportStatus.append(\" - reinforcement attempt succeeded;\");\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            }\n+        } else if (reinforcementType == ReinforcementEligibilityType.None) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Assigns a force to the scenario such that the majority of the force can be deployed\n+     */\n+    private static void assignAppropriateExtraForceToScenario(StratconScenario scenario,\n+            Map<MapLocation, List<Integer>> sortedAvailableForceIDs) {\n+        // the goal of this function is to avoid assigning ground units to air battles\n+        // and ground units/conventional fighters to space battle\n+\n+        List<MapLocation> mapLocations = new ArrayList<>();\n+        mapLocations.add(MapLocation.Space); // can always add ASFs\n+\n+        MapLocation scenarioMapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+\n+        if (scenarioMapLocation == MapLocation.LowAtmosphere) {\n+            mapLocations.add(MapLocation.LowAtmosphere); // can add conventional fighters to ground or low atmo battles\n+        }\n+\n+        if ((scenarioMapLocation == MapLocation.AllGroundTerrain) ||\n+                (scenarioMapLocation == MapLocation.SpecificGroundTerrain)) {\n+            mapLocations.add(MapLocation.AllGroundTerrain); // can only add ground units to ground battles\n+        }\n+\n+        MapLocation selectedLocation = mapLocations.get(Compute.randomInt(mapLocations.size()));\n+        List<Integer> forceIDs = sortedAvailableForceIDs.get(selectedLocation);\n+        int forceIndex = Compute.randomInt(forceIDs.size());\n+        int forceID = forceIDs.get(forceIndex);\n+        forceIDs.remove(forceIndex);\n+\n+        scenario.addPrimaryForce(forceID);\n+    }\n+\n+    /**\n+     * Worker function that \"locks in\" a scenario -\n+     * Adds it to the campaign so it's visible in the briefing room,\n+     * adds it to the track\n+     *\n+     */\n+    public static void commitPrimaryForces(Campaign campaign, StratconScenario scenario, StratconTrackState trackState) {\n+        trackState.addScenario(scenario);\n+\n+        // set up dates for the scenario if doesn't have them already\n+        if (scenario.getDeploymentDate() == null) {\n+            scenario.setDeploymentDate(campaign.getLocalDate());\n+        }\n+\n+        if (scenario.getActionDate() == null) {\n+            scenario.setActionDate(campaign.getLocalDate());\n+        }\n+\n+        if(scenario.getReturnDate() == null) {\n+            scenario.setReturnDate(campaign.getLocalDate().plusDays(trackState.getDeploymentTime()));\n+        }\n+\n+        // set the # of rerolls based on the actual lance assigned.\n+        int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+        scenario.getBackingScenario().setRerolls(tactics);\n+        // The number of defensive points available to a force entering a scenario is\n+        // 2 x tactics. By default, those points are spent on conventional minefields.\n+        if (commanderLanceHasDefensiveAssignment(scenario.getBackingScenario(), campaign)) {\n+            scenario.setNumDefensivePoints(tactics * 2);\n+            scenario.updateMinefieldCount(Minefield.TYPE_CONVENTIONAL, tactics * 2);\n+        }\n+\n+        for (int forceID : scenario.getPlayerTemplateForceIDs()) {\n+            Force force = campaign.getForce(forceID);\n+            force.clearScenarioIds(campaign, true);\n+            force.setScenarioId(scenario.getBackingScenarioID());\n+        }\n+\n+        scenario.commitPrimaryForces();\n+    }\n+\n+    /**\n+     * Utility method to determine if the current scenario's force commander\n+     * is on defence\n+     */\n+    private static boolean commanderLanceHasDefensiveAssignment(AtBDynamicScenario scenario, Campaign campaign) {\n+        Unit commanderUnit = scenario.getLanceCommander(campaign).getUnit();\n+        Lance lance = campaign.getLances().get(commanderUnit.getForceId());\n+\n+        if ((lance != null) && (lance.getRole() == AtBLanceRole.DEFENCE)) {\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * A hackish worker function that takes the given list of force IDs and\n+     * separates it into three sets;\n+     * one of forces that can be \"primary\" on a ground map\n+     * one of forces that can be \"primary\" on an atmospheric map\n+     * one of forces that can be \"primary\" in a space map\n+     * @param forceIDs List of force IDs to check\n+     * @return Sorted hash map\n+     */\n+    private static Map<MapLocation, List<Integer>> sortForcesByMapType(List<Integer> forceIDs, Campaign campaign) {\n+        Map<MapLocation, List<Integer>> retVal = new HashMap<>();\n+\n+        retVal.put(MapLocation.AllGroundTerrain, new ArrayList<>());\n+        retVal.put(MapLocation.LowAtmosphere, new ArrayList<>());\n+        retVal.put(MapLocation.Space, new ArrayList<>());\n+\n+        for (int forceID : forceIDs) {\n+            switch(campaign.getForce(forceID).getPrimaryUnitType(campaign)) {\n+            case UnitType.BATTLE_ARMOR:\n+            case UnitType.INFANTRY:\n+            case UnitType.MEK:\n+            case UnitType.TANK:\n+            case UnitType.PROTOMEK:\n+            case UnitType.VTOL:\n+                retVal.get(MapLocation.AllGroundTerrain).add(forceID);\n+                break;\n+            case UnitType.AERO:\n+                retVal.get(MapLocation.Space).add(forceID);\n+                // intentional fallthrough here, ASFs can go to atmospheric maps too\n+            case UnitType.CONV_FIGHTER:\n+                retVal.get(MapLocation.LowAtmosphere).add(forceID);\n+                break;\n+            }\n+        }\n+\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * Determine whether the user should be nagged about unresolved scenarios on AtB Stratcon tracks.\n+     * @param campaign Campaign to check.\n+     * @return An informative string containing the reasons the user was nagged.\n+     */\n+    public static String nagUnresolvedContacts(Campaign campaign) {\n+        StringBuilder sb = new StringBuilder();\n+\n+        // check every track attached to an active contract for unresolved scenarios\n+        // to which the player must deploy forces today\n+        for (AtBContract contract : campaign.getActiveAtBContracts()) {\n+            if (contract.getStratconCampaignState() == null) {\n+                continue;\n+            }\n+            \n+            for (StratconTrackState track : contract.getStratconCampaignState().getTracks()) {\n+                for (StratconScenario scenario : track.getScenarios().values()) {\n+                    if (scenario.getCurrentState() == ScenarioState.UNRESOLVED &&\n+                            campaign.getLocalDate().equals(scenario.getDeploymentDate())) {\n+                        // \"scenario name, track name\"\n+                        sb.append(String.format(\"%s, %s\\n\", scenario.getName(), track.getDisplayableName()));\n+                    }\n+                }\n+            }\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track.\n+     * Also registers it with the track and campaign.\n+     */\n+    private static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords) {\n+        int unitType = campaign.getForce(forceID).getPrimaryUnitType(campaign);\n+        ScenarioTemplate template = StratconScenarioFactory.getRandomScenario(unitType);\n+        // useful for debugging specific scenario types\n+        //ScenarioTemplate template = StratconScenarioFactory.getSpecificScenario(\"Hostile Facility.xml\");\n+\n+        return generateScenario(campaign, contract, track, forceID, coords, template);\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track,\n+     * using the given template. Also registers it with the campaign.\n+     */\n+    static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords, ScenarioTemplate template) {\n+        StratconScenario scenario = new StratconScenario();\n+        \n+        AtBDynamicScenario backingScenario = AtBDynamicScenarioFactory.initializeScenarioFromTemplate(template, contract, campaign);        \n+        scenario.setBackingScenario(backingScenario);\n+        scenario.setCoords(coords);\n+        \n+        // by default, certain conditions may make this bigger\n+        scenario.setRequiredPlayerLances(1);\n+\n+        // do an appropriate allied force if the contract calls for it\n+        // do any attached or integrated units\n+        setAlliedForceModifier(scenario, contract);\n+        setAttachedUnitsModifier(scenario, contract);\n+        applyFacilityModifiers(scenario, track, coords);\n+        applyGlobalModifiers(scenario, contract.getStratconCampaignState());\n+\n+        if ((contract.getCommandRights() == AtBContract.COM_HOUSE) ||\n+                (contract.getCommandRights() == AtBContract.COM_INTEGRATED)) {\n+            scenario.setRequiredScenario(true);\n+        }\n+\n+        AtBDynamicScenarioFactory.setScenarioModifiers(scenario.getBackingScenario());\n+        scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+        setScenarioDates(track, campaign, scenario);\n+        \n+        // the backing scenario ID must be updated after registering the backing scenario \n+        // with the campaign, so that the stratcon - backing scenario association is maintained\n+        // registering the scenario with the campaign should be done after setting\n+        // dates, otherwise, the report messages for new scenarios look weird\n+        campaign.addScenario(backingScenario, contract);\n+        scenario.setBackingScenarioID(backingScenario.getId());\n+        \n+        if (forceID > Force.FORCE_NONE) {\n+            scenario.addPrimaryForce(forceID);\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * Apply global scenario modifiers from campaign state to given scenario.\n+     */\n+    private static void applyGlobalModifiers(StratconScenario scenario, StratconCampaignState campaignState) {\n+        for (String modifierName : campaignState.getGlobalScenarioModifiers()) {\n+            AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierName);\n+\n+            if (modifier == null) {\n+                MekHQ.getLogger().error(String.format(\"Modifier %s not found; ignoring\", modifierName));\n+                continue;\n+            }\n+\n+            scenario.getBackingScenario().addScenarioModifier(modifier);\n+        }\n+    }\n+\n+    /**\n+     * Applies scenario modifiers from the current track to the given scenario.\n+     * @param scenario\n+     * @param track\n+     */\n+    private static void applyFacilityModifiers(StratconScenario scenario, StratconTrackState track, StratconCoords coords) {\n+        // loop through all the facilities on the track\n+        // if a facility has been revealed, then it has a 100% chance to apply its effect\n+        // if a facility has not been revealed, then it has a x% chance to apply its effect\n+        // if a facility is on the the scenario coordinates the it applies the local effects\n+        for (StratconCoords facilityCoords : track.getFacilities().keySet()) {\n+            boolean scenarioAtFacility = facilityCoords.equals(coords);\n+            StratconFacility facility = track.getFacilities().get(facilityCoords);\n+            List<String> modifierIDs = new ArrayList<>();\n+\n+            if (scenarioAtFacility) {\n+                modifierIDs = facility.getLocalModifiers();\n+            } else if (facility.isVisible() || (Compute.randomInt(100) <= facility.getAggroRating())) {\n+                modifierIDs = facility.getSharedModifiers();\n+            }\n+\n+            for (String modifierID : modifierIDs) {\n+                AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierID);\n+                if(modifier == null) {\n+                    MekHQ.getLogger().error(String.format(\"Modifier %s not found for facility %s\", modifierID, facility.getFormattedDisplayableName()));\n+                    continue;\n+                }\n+\n+                scenario.getBackingScenario().addScenarioModifier(modifier);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set up the appropriate primary allied force modifier, if any\n+     * @param contract The scenario's contract.\n+     */\n+    private static void setAlliedForceModifier(StratconScenario scenario, AtBContract contract) {\n+        int alliedUnitOdds = 0;\n+\n+        // first, we determine the odds of having an allied unit present\n+        // TODO: move this override out to the contract definition\n+        if (contract.getMissionType() == AtBContract.MT_RELIEFDUTY) {\n+            alliedUnitOdds = 50;\n+        } else {\n+            switch(contract.getCommandRights()) {\n+                case AtBContract.COM_INTEGRATED:\n+                    alliedUnitOdds = 50;\n+                    break;\n+                case AtBContract.COM_HOUSE:\n+                    alliedUnitOdds = 30;\n+                    break;\n+                case AtBContract.COM_LIAISON:\n+                    alliedUnitOdds = 10;\n+                    break;\n+            }\n+        }\n+\n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+\n+        // if an allied unit is present, then we want to make sure that it's ground units\n+        // for ground battles\n+        if (Compute.randomInt(100) <= alliedUnitOdds) {\n+            if((backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+               (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space)) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_ALLIED_AIR_UNITS));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_ALLIED_GROUND_UNITS));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set the 'attached' units modifier for the current scenario (integrated, house, liaison),\n+     * and make sure we're not deploying ground units to an air scenario\n+     * @param contract The scenario's contract\n+     */\n+    public static void setAttachedUnitsModifier(StratconScenario scenario, AtBContract contract) {\n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+        boolean airBattle = (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+                (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space);\n+\n+        // if we're on cadre duty, we're getting three trainees, period\n+        if (contract.getMissionType() == AtBContract.MT_CADREDUTY) {\n+            if (airBattle) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_TRAINEES_AIR));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_TRAINEES_GROUND));\n+            }\n+            return;\n+        }\n+\n+        // if we're under non-independent command rights, a supervisor may come along\n+        switch (contract.getCommandRights()) {\n+            case AtBContract.COM_INTEGRATED:\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(airBattle \n+                        ? MekHqConstants.SCENARIO_MODIFIER_INTEGRATED_UNITS_AIR\n+                        : MekHqConstants.SCENARIO_MODIFIER_INTEGRATED_UNITS_GROUND));\n+                break;\n+            case AtBContract.COM_HOUSE:\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(airBattle \n+                        ? MekHqConstants.SCENARIO_MODIFIER_HOUSE_CO_AIR\n+                        : MekHqConstants.SCENARIO_MODIFIER_HOUSE_CO_GROUND));\n+                break;\n+            case AtBContract.COM_LIAISON:\n+                if (scenario.isRequiredScenario()) {\n+                    backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(airBattle \n+                            ? MekHqConstants.SCENARIO_MODIFIER_LIAISON_AIR\n+                            : MekHqConstants.SCENARIO_MODIFIER_LIAISON_GROUND));\n+                }\n+                break;\n+        }\n+    }\n+\n+    /**\n+     * Worker function that sets scenario deploy/battle/return dates based on the track's properties and current campaign date\n+     */\n+    private static void setScenarioDates(StratconTrackState track, Campaign campaign, StratconScenario scenario) {\n+     // set up deployment day, battle day, return day here\n+        // safety code to prevent attempts to generate random int with upper bound of 0 which is apparently illegal\n+        int deploymentDay = track.getDeploymentTime() < 7 ? Compute.randomInt(7 - track.getDeploymentTime()) : 0;\n+        int battleDay = deploymentDay + (track.getDeploymentTime() > 0 ? Compute.randomInt(track.getDeploymentTime()) : 0);\n+        int returnDay = deploymentDay + track.getDeploymentTime();\n+\n+        LocalDate deploymentDate = campaign.getLocalDate();\n+        deploymentDate.plusDays(deploymentDay);\n+        LocalDate battleDate = campaign.getLocalDate();\n+        deploymentDate.plusDays(battleDay);\n+        LocalDate returnDate = campaign.getLocalDate();\n+        returnDate.plusDays(returnDay);\n+\n+        scenario.setDeploymentDate(deploymentDate);\n+        scenario.setActionDate(battleDate);\n+        scenario.setReturnDate(returnDate);\n+    }\n+\n+    /**\n+     * Helper function that determines if the unit type specified in the given scenario force template\n+     * would start out airborne on a ground map (hot dropped units aside)\n+     */\n+    private static boolean unitTypeIsAirborne(ScenarioForceTemplate template) {\n+        int unitType = template.getAllowedUnitType();\n+\n+        return (unitType == UnitType.AERO ||\n+                unitType == UnitType.CONV_FIGHTER ||\n+                unitType == UnitType.DROPSHIP ||\n+                unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_MIX) &&\n+                template.getStartingAltitude() > 0;\n+    }\n+\n+    /**\n+     * Determines whether the force in question has the same primary unit type as the force template.\n+     * @return Whether or not the unit types match.\n+     */\n+    public static boolean forceCompositionMatchesDeclaredUnitType(int primaryUnitType, int unitType, boolean reinforcements) {\n+        // special cases are \"ATB_MIX\" and \"ATB_AERO_MIX\", which encompass multiple unit types\n+        if (unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_MIX) {\n+            // \"AtB mix\" is usually ground units, but air units can sub in\n+            return primaryUnitType == UnitType.MEK ||\n+                    primaryUnitType == UnitType.TANK ||\n+                    primaryUnitType == UnitType.INFANTRY ||\n+                    primaryUnitType == UnitType.BATTLE_ARMOR ||\n+                    primaryUnitType == UnitType.PROTOMEK ||\n+                    primaryUnitType == UnitType.VTOL ||\n+                    (primaryUnitType == UnitType.AERO) && reinforcements ||\n+                    (primaryUnitType == UnitType.CONV_FIGHTER) && reinforcements;\n+        } else if (unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_AERO_MIX) {\n+            return primaryUnitType == UnitType.AERO ||\n+                    primaryUnitType == UnitType.CONV_FIGHTER;\n+        } else {\n+            return primaryUnitType == unitType;\n+        }\n+    }\n+\n+    /**\n+     * This is a set of all force IDs for forces that can be deployed to a scenario.\n+     * @param campaign Current campaign\n+     * @return Set of available force IDs.\n+     */\n+    public static List<Integer> getAvailableForceIDs(Campaign campaign) {\n+        List<Integer> retVal = new ArrayList<>();\n+\n+        // first, we gather a set of all forces that are already deployed to a track so we eliminate those later\n+        Set<Integer> forcesInTracks = new HashSet<>();\n+        for (Contract contract : campaign.getActiveContracts()) {\n+            if (contract instanceof AtBContract) {\n+                for (StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    forcesInTracks.addAll(track.getAssignedForceCoords().keySet());\n+                }\n+            }\n+        }\n+\n+        // now, we get all the forces that qualify as \"lances\", and filter out those that are\n+        // deployed to a scenario and not in a track already\n+        for (int key : campaign.getLances().keySet()) {\n+            Force force = campaign.getForce(key);\n+            if ((force != null) &&\n+                    !force.isDeployed() &&\n+                    !forcesInTracks.contains(force.getId())) {\n+                retVal.add(force.getId());\n+            }\n+        }\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * This is a list of all force IDs for forces that can be deployed to a scenario in the given force template\n+     * a) have not been assigned to a track\n+     * b) are combat-capable\n+     * c) are not deployed to a scenario\n+     * d) if attempting to deploy as reinforcements, haven't already failed to deploy\n+     */\n+    public static List<Integer> getAvailableForceIDs(int unitType, Campaign campaign, StratconTrackState currentTrack,\n+            boolean reinforcements, @Nullable StratconScenario currentScenario) {\n+        List<Integer> retVal = new ArrayList<>();\n+\n+        Set<Integer> forcesInTracks = new HashSet<>();\n+        // assemble a set of all force IDs that are currently assigned to tracks that are not this one\n+        for (Contract contract : campaign.getActiveContracts()) {\n+            if (contract instanceof AtBContract) {\n+                for (StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    if ((track != currentTrack) || !reinforcements) {\n+                        forcesInTracks.addAll(track.getAssignedForceCoords().keySet());\n+                    }\n+                }\n+            }\n+        }\n+        \n+        // if there's an existing scenario and we're doing reinforcements,\n+        // prevent forces that failed to deploy from trying to deploy again\n+        if (reinforcements && (currentScenario != null)) {\n+            forcesInTracks.addAll(currentScenario.getFailedReinforcements());\n+        }\n+\n+        for (int key : campaign.getLances().keySet()) {\n+            Force force = campaign.getForce(key);\n+\n+            if (force == null) {\n+                continue;\n+            }\n+\n+            int primaryUnitType = force.getPrimaryUnitType(campaign);\n+            if (!force.isDeployed() &&\n+                    (force.getScenarioId() <= 0) &&\n+                    !force.getUnits().isEmpty() &&\n+                    !forcesInTracks.contains(force.getId()) &&\n+                    forceCompositionMatchesDeclaredUnitType(primaryUnitType, unitType, reinforcements)) {\n+                retVal.add(force.getId());\n+            }\n+        }\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * Returns a list of individual units eligible for deployment in scenarios run by \"Defend\" lances\n+     * @return List of unit IDs.\n+     */\n+    public static List<Unit> getEligibleDefensiveUnits(Campaign campaign) {\n+        List<Unit> retVal = new ArrayList<>();\n+\n+        for (Unit u : campaign.getUnits()) {\n+            // \"defensive\" units are infantry, battle armor and (Weisman help you) gun emplacements\n+        \t// and also said unit should be intact/alive/etc\n+        \tboolean isEligibleInfantry = \n+        \t\t\t((u.getEntity().getUnitType() == UnitType.INFANTRY) ||\n+                    (u.getEntity().getUnitType() == UnitType.BATTLE_ARMOR)) &&\n+                    !u.isUnmanned();\n+        \t\n+        \tboolean isEligibleGunEmplacement = u.getEntity().getUnitType() == UnitType.GUN_EMPLACEMENT;\n+        \t\n+        \tif ((isEligibleInfantry || isEligibleGunEmplacement) && \n+            \t\t!u.isDeployed() &&\n+                    !u.isMothballed() &&\n+                    u.isFunctional()) {\n+\n+                // this is a little inefficient, but probably there aren't too many active AtB contracts at a time\n+                for (AtBContract contract : campaign.getActiveAtBContracts()) {\n+                    if (contract.getStratconCampaignState().isForceDeployedHere(u.getForceId())) {\n+                        continue;\n+                    }\n+                }\n+\n+                retVal.add(u);\n+            }\n+        }\n+\n+        return retVal;\n+    }\n+    \n+    /**\n+     * Returns a list of individual units eligible for deployment in scenarios\n+     * that result from the lance leader having a leadership score\n+     * @return List of unit IDs.\n+     */\n+    public static List<Unit> getEligibleLeadershipUnits(Campaign campaign, Set<Integer> forceIDs) {\n+        List<Unit> retVal = new ArrayList<>();\n+\n+        // The criteria are as follows:\n+        // - unit is of a different unit type than the primary unit type of the force \n+        // - unit has a lower BV than the force's lowest BV unit\n+        \n+        Integer lowestBV = getLowestBV(campaign, forceIDs);\n+        \n+        // no units assigned, the rest is meaningless.\n+        if (lowestBV == null) {\n+            return retVal;\n+        }\n+        \n+        int primaryUnitType = getPrimaryUnitType(campaign, forceIDs);\n+        \n+        for (Unit u : campaign.getUnits()) {\n+            if ((primaryUnitType != u.getEntity().getUnitType()) &&\n+                    !u.isDeployed() &&\n+                    !u.isMothballed() &&\n+                    u.isFunctional() &&\n+                    (u.getEntity().calculateBattleValue() < lowestBV) &&\n+                    !isUnitDeployedToStratCon(u)) {\n+                retVal.add(u);\n+            }\n+        }\n+\n+        return retVal;\n+    }\n+    \n+    /**\n+     * Check if the unit's force (if one exists) has been deployed to a StratCon track\n+     */\n+    public static boolean isUnitDeployedToStratCon(Unit u) {\n+        if (!u.getCampaign().getCampaignOptions().getUseStratCon()) {\n+            return false;\n+        }\n+        \n+        //this is a little inefficient, but probably there aren't too many active AtB contracts at a time\n+        for (AtBContract contract : u.getCampaign().getActiveAtBContracts()) {\n+            if (contract.getStratconCampaignState().isForceDeployedHere(u.getForceId())) {\n+                return true;\n+            }\n+        }\n+        \n+        return false;\n+    }\n+    \n+    /**\n+     * Given a campaign and a list of force IDs, calculate the unit with the lowest BV.\n+     */\n+    private static Integer getLowestBV(Campaign campaign, Set<Integer> forceIDs) {\n+        Integer lowestBV = null;\n+        \n+        for (int forceID : forceIDs) {\n+            Force force = campaign.getForce(forceID);\n+            if (force == null) {\n+                continue;\n+            }\n+            \n+            for (UUID id : force.getUnits()) {\n+                if (campaign.getUnit(id) == null) {\n+                    continue;\n+                }\n+                \n+                int currentBV = campaign.getUnit(id).getEntity().calculateBattleValue();\n+                \n+                if ((lowestBV == null) || (currentBV < lowestBV)) {\n+                    lowestBV = currentBV;\n+                }\n+            }\n+        }\n+        \n+        return lowestBV;\n+    }\n+    \n+    /**\n+     * Calculates the majority unit type for the forces given the IDs.\n+     */\n+    private static int getPrimaryUnitType(Campaign campaign, Set<Integer> forceIDs) {\n+        Map<Integer, Integer> unitTypeBuckets = new TreeMap<>();\n+        int biggestBucketID = -1;\n+        int biggestBucketCount = 0;\n+        \n+        for (int forceID : forceIDs) {\n+            Force force = campaign.getForce(forceID);\n+            if (force == null) {\n+                continue;\n+            }\n+        \n+            for (UUID id : force.getUnits()) {\n+                Unit unit = campaign.getUnit(id);\n+                if ((unit == null) || \n+                        (unit.getEntity() == null)) {\n+                    continue;\n+                }\n+                \n+                int unitType = unit.getEntity().getUnitType();\n+    \n+                unitTypeBuckets.merge(unitType, 1, (oldCount, value) -> oldCount + value);\n+                \n+                if (unitTypeBuckets.get(unitType) > biggestBucketCount) {\n+                    biggestBucketCount = unitTypeBuckets.get(unitType);\n+                    biggestBucketID = unitType;\n+                }\n+            }\n+        }\n+        \n+        return biggestBucketID;\n+    }\n+\n+    /**\n+     * Determines what rules to use when deploying a force for reinforcements to the given track.\n+     */\n+    public static ReinforcementEligibilityType getReinforcementType(int forceID,\n+            StratconTrackState trackState, Campaign campaign) {\n+        // if the force is currently deployed to the track, it'll be able to deploy \"for free\"\n+        if (trackState.isForceDeployed(forceID)) {\n+            return ReinforcementEligibilityType.ChainedScenario;\n+        }\n+\n+        // if the force is in 'fight' stance, it'll be able to deploy using 'fight lance' rules\n+        if (campaign.getLances().containsKey(forceID) &&\n+                campaign.getLances().get(forceID).getRole() == AtBLanceRole.FIGHTING) {\n+            return ReinforcementEligibilityType.FightLance;\n+        }\n+\n+        // if the force is deployed elsewhere, it cannot be deployed as reinforcements\n+        for (Contract contract : campaign.getActiveContracts()) {\n+            if(contract instanceof AtBContract) {\n+                for(StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    if(track != trackState && track.getAssignedForceCoords().containsKey(forceID)) {\n+                        return ReinforcementEligibilityType.None;\n+                    }\n+                }\n+            }\n+        }\n+\n+        // otherwise, the force requires support points / vps to deploy\n+        return ReinforcementEligibilityType.SupportPoint;\n+    }\n+    \n+    /**\n+     * Given a track and the current campaign state, and if the player is deploying\n+     * a force or not, figure out the odds of a scenario occuring.\n+     */\n+    public static int calculateScenarioOdds(StratconTrackState track, \n+            AtBContract contract, boolean playerDeployingForce) {\n+        // rules:\n+        // rout morale: 0%\n+        // very low morale: -10% when deploying forces to track, 0% attack\n+        // low morale: -5%\n+        // high morale: +5%\n+        // invincible: special case, let's do +10% for now\n+        int moraleModifier = 0;\n+        \n+        switch (contract.getMoraleLevel()) {\n+            case AtBContract.MORALE_ROUT:\n+                return 0;\n+            case AtBContract.MORALE_VERYLOW:\n+                if (playerDeployingForce) {\n+                    moraleModifier = -10;\n+                } else {\n+                    return 0;\n+                }\n+                break;\n+            case AtBContract.MORALE_LOW:\n+                moraleModifier = -5;\n+                break;\n+            case AtBContract.MORALE_HIGH:\n+                moraleModifier = 5;\n+                break;\n+            case AtBContract.MORALE_INVINCIBLE:\n+                moraleModifier = 10;\n+                break;\n+        }\n+        \n+        // facilities: for each hostile data center, add +5%\n+        // for each allied data center, subtract 5\n+        int dataCenterModifier = 0;\n+        for (StratconFacility facility : track.getFacilities().values()) {\n+            if (facility.getFacilityType() == FacilityType.DataCenter) {\n+                dataCenterModifier += facility.getOwner() == ForceAlignment.Allied ? -5 : 5;\n+            }\n+        }\n+            \n+        return track.getScenarioOdds() + moraleModifier + dataCenterModifier;\n+    }\n+\n+    /**\n+     * Removes the facility associated with the given scenario from the relevant track/\n+     */\n+    public static void updateFacilityForScenario(AtBScenario scenario, AtBContract contract, boolean destroy, boolean capture) {\n+        if (contract.getStratconCampaignState() == null) {\n+            return;\n+        }\n+\n+        // this is kind of kludgy, but there's currently no way to link a scenario back to its backing scenario\n+        // TODO: introduce mapping in contract or at least trackstate\n+        // basically, we're looping through all scenarios on all the contract's tracks\n+        // if we find one with the same ID as the one being resolved, that's our facility: get rid of it.\n+        for (StratconTrackState trackState : contract.getStratconCampaignState().getTracks()) {\n+            for (StratconCoords coords : trackState.getScenarios().keySet()) {\n+                StratconScenario potentialScenario = trackState.getScenario(coords);\n+                if (potentialScenario.getBackingScenarioID() == scenario.getId()) {\n+\n+                    if (destroy) {\n+                        trackState.removeFacility(coords);\n+                    } else {\n+                        StratconFacility facility = trackState.getFacility(coords);\n+\n+                        if (facility == null) {\n+                            continue;\n+                        }\n+\n+                        if (capture) {\n+                            facility.incrementOwnershipChangeScore();\n+                        } else {\n+                            facility.decrementOwnershipChangeScore();\n+                        }\n+                    }\n+\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Processes completion of a Stratcon scenario, if the given tracker is associated\n+     * with a stratcon-enabled mission. Intended to be called after ResolveScenarioTracker.finish() has been invoked.\n+     */\n+    public static void processScenarioCompletion(ResolveScenarioTracker rst) {\n+        if (rst.getMission() instanceof AtBContract) {\n+            StratconCampaignState campaignState = ((AtBContract) rst.getMission()).getStratconCampaignState();\n+            if (campaignState == null) {\n+                return;\n+            }\n+\n+            for (StratconTrackState track : campaignState.getTracks()) {\n+                if (track.getBackingScenariosMap().containsKey(rst.getScenario().getId())) {\n+                    // things that may potentially happen:\n+                    // scenario is removed from track - implemented\n+                    // track gets remaining forces added to reinforcement pool\n+                    // facility gets remaining forces stored in reinforcement pool\n+                    // process VP and SO\n+\n+                    StratconScenario scenario = track.getBackingScenariosMap().get(rst.getScenario().getId());\n+\n+\n+                    StratconFacility facility = track.getFacility(scenario.getCoords());\n+\n+                    if ((facility != null) && (facility.getOwnershipChangeScore() > 0)) {\n+                        if (facility.getOwner() == ForceAlignment.Allied) {\n+                            facility.setOwner(ForceAlignment.Opposing);\n+                        } else {\n+                            facility.setOwner(ForceAlignment.Allied);\n+                        }\n+                    }\n+\n+                    boolean victory = rst.getScenario().getStatus() == Scenario.S_VICTORY ||\n+                            rst.getScenario().getStatus() == Scenario.S_MVICTORY;\n+\n+                    if (scenario.isRequiredScenario()) {\n+                        campaignState.updateVictoryPoints(victory ? 1 : -1);\n+                    }\n+\n+                    if (scenario.isStrategicObjective()) {\n+                        if (campaignState.strategicObjectivesBehaveAsVPs()) {\n+                            campaignState.updateVictoryPoints(victory ? 1 : -1);\n+                        } else {\n+                            campaignState.incrementStrategicObjectiveCompletedCount();\n+                        }\n+                    }\n+\n+                    processTrackForceReturnDates(track, rst.getCampaign().getLocalDate());\n+\n+                    track.removeScenario(scenario);\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Worker function that goes through a track and undeploys any forces where the\n+     * return date is on or before the given date.\n+     */\n+    public static void processTrackForceReturnDates(StratconTrackState track, LocalDate date) {\n+        List<Integer> forcesToUndeploy = new ArrayList<>();\n+\n+        // for each force on the track, if the return date is today or in the past,\n+        // \"return to base\", unless it's been told to stay in the field\n+        for (int forceID : track.getAssignedForceReturnDates().keySet()) {\n+            if ((track.getAssignedForceReturnDates().get(forceID).equals(date) ||\n+                    track.getAssignedForceReturnDates().get(forceID).isBefore(date)) &&\n+                    !track.getStickyForces().contains(forceID)) {\n+                forcesToUndeploy.add(forceID);\n+            }\n+        }\n+\n+        for (int forceID : forcesToUndeploy) {\n+            track.unassignForce(forceID);\n+        }\n+    }\n+    \n+    /**\n+     * Processes an ignored dynamic scenario - locates it on one of the tracks\n+     * and calls the standared 'ignored scenario' routine.\n+     * @return Whether or not we also need to get rid of the backing scenario from the campaign\n+     */\n+    public static boolean processIgnoredScenario(AtBDynamicScenario scenario, StratconCampaignState campaignState) {\n+        for (StratconTrackState track : campaignState.getTracks()) {\n+            if (track.getBackingScenariosMap().containsKey(scenario.getId())) {\n+                return processIgnoredScenario(track.getBackingScenariosMap().get(scenario.getId()), campaignState);\n+            }\n+        }\n+        \n+        return true;\n+    }\n+    \n+\n+    /**\n+     * Processes an ignored Stratcon scenario\n+     * @return Whether or not we also need to get rid of the backing scenario from the campaign\n+     */\n+    public static boolean processIgnoredScenario(StratconScenario scenario, StratconCampaignState campaignState) {\n+        for (StratconTrackState track : campaignState.getTracks()) {\n+            if (track.getScenarios().containsKey(scenario.getCoords())) {\n+                // subtract VP if scenario is 'required'\n+                if (scenario.isRequiredScenario()) {\n+                    campaignState.updateVictoryPoints(-1);\n+                }\n+                \n+                track.removeScenario(scenario);\n+\n+                StratconFacility localFacility = track.getFacility(scenario.getCoords());\n+                if (localFacility != null) {\n+                    // if the ignored scenario was on top of an allied facility\n+                    // then it'll get captured, and the player will possibly lose a SO\n+                    if (localFacility.getOwner() == ForceAlignment.Allied) {\n+                        localFacility.setOwner(ForceAlignment.Opposing);\n+\n+                        if (localFacility.isStrategicObjective()) {\n+                            campaignState.decrementStrategicObjectiveCompletedCount();\n+                        }\n+                    }\n+                    \n+                    return true;\n+                } else {\n+                    // if it's an open-field\n+                    // move scenario towards nearest allied facility\n+                    StratconCoords closestAlliedFacilityCoords = track.findClosestAlliedFacilityCoords(scenario.getCoords());\n+\n+                    if (closestAlliedFacilityCoords != null) {\n+                        StratconCoords newCoords = scenario.getCoords().translate(scenario.getCoords().direction(closestAlliedFacilityCoords));\n+                        scenario.setCoords(newCoords);\n+                        \n+                        int daysForward = Math.min(1, track.getDeploymentTime());\n+                        \n+                        scenario.setDeploymentDate(scenario.getDeploymentDate().plusDays(daysForward));\n+                        scenario.setActionDate(scenario.getActionDate().plusDays(daysForward));\n+                        scenario.setReturnDate(scenario.getReturnDate().plusDays(daysForward));\n+                        \n+                        // refresh the scenario's position on the track\n+                        track.addScenario(scenario);\n+                        \n+                        // TODO: Write some functionality to \"copy\" a scenario's \n+                        // bot forces over\n+                        /*StratconFacility facility = track.getFacility(newCoords);\n+\n+                        if (facility != null) {\n+                            ScenarioTemplate template = StratconScenarioFactory.getFacilityScenario(true);\n+                            scenario = generateScenario(campaignState.getCa, contract, track, forceID, coords, template);\n+                            setupFacilityScenario(scenario, facility);\n+                        }*/\n+\n+                        // TODO: if the allied facility is in the new coords, replace this scenario\n+                        // with a facility defense, with the opfor coming directly from all hostiles assigned to this scenario\n+\n+                        scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                        return false;\n+                    } else {\n+                        // TODO: if there's no allied facilities here, add its forces to track reinforcement pool\n+                        return true;\n+                    }\n+                }\n+            }\n+        }\n+        \n+        // if we couldn't find the scenario on any tracks, then let's just \n+        // rid of any underlying AtB scenarios as well\n+        return true;\n+    }\n+\n+    public void startup() {\n+        MekHQ.registerHandler(this);\n+    }\n+\n+    /**\n+     * Event handler for the new day event.\n+     */\n+    @Subscribe\n+    public void handleNewDay(NewDayEvent ev) {\n+    \t// don't do any of this if StratCon isn't turned on\n+    \tif (!ev.getCampaign().getCampaignOptions().getUseStratCon()) {\n+    \t\treturn;\n+    \t}\n+    \t\n+        boolean isMonday = ev.getCampaign().getLocalDate().getDayOfWeek() == DayOfWeek.MONDAY;\n+\n+\n+        // run scenario generation routine for every track attached to an active contract\n+        for (AtBContract contract : ev.getCampaign().getActiveAtBContracts()) {\n+            StratconCampaignState campaignState = ((AtBContract) contract).getStratconCampaignState();\n+\n+            if (campaignState != null) {\n+                for (StratconTrackState track : contract.getStratconCampaignState().getTracks()) {\n+                    cleanupPhantomScenarios(track);\n+                    \n+                    // loop through scenarios - if we haven't deployed in time, fail it and apply consequences\n+                    for (StratconScenario scenario : track.getScenarios().values()) {\n+                        if (scenario.getDeploymentDate().isBefore(ev.getCampaign().getLocalDate())) {\n+                            processIgnoredScenario(scenario, campaignState);\n+                        }\n+                    }\n+\n+                    // on monday, generate new scenarios and decay modifiers\n+                    if (isMonday) {\n+                        generateScenariosForTrack(ev.getCampaign(), (AtBContract) contract, track);\n+\n+                        //", "originalCommit": "b36d9fa6bf982c7b833b1ac0a0473d37f6e84760", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTE5Mjk2Mw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r615192963", "bodyText": "Useless cast", "author": "Windchild292", "createdAt": "2021-04-17T02:16:21Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -0,0 +1,1404 @@\n+/*\n+* MegaMek - Copyright (C) 2020 - The MegaMek Team\n+*\n+* This program is free software; you can redistribute it and/or modify it under\n+* the terms of the GNU General Public License as published by the Free Software\n+* Foundation; either version 2 of the License, or (at your option) any later\n+* version.\n+*\n+* This program is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+* FOR A PARTICULAR PURPOSE. See the GNU General Public License for more\n+* details.\n+*/\n+\n+package mekhq.campaign.stratcon;\n+\n+import java.time.DayOfWeek;\n+import java.time.LocalDate;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.UUID;\n+\n+import megamek.common.Compute;\n+import megamek.common.Minefield;\n+import megamek.common.UnitType;\n+import megamek.common.annotations.Nullable;\n+import megamek.common.event.Subscribe;\n+import mekhq.MekHQ;\n+import mekhq.MekHqConstants;\n+import mekhq.Utilities;\n+import mekhq.campaign.Campaign;\n+import mekhq.campaign.ResolveScenarioTracker;\n+import mekhq.campaign.againstTheBot.enums.AtBLanceRole;\n+import mekhq.campaign.event.NewDayEvent;\n+import mekhq.campaign.event.StratconDeploymentEvent;\n+import mekhq.campaign.force.Force;\n+import mekhq.campaign.force.Lance;\n+import mekhq.campaign.mission.AtBContract;\n+import mekhq.campaign.mission.AtBDynamicScenario;\n+import mekhq.campaign.mission.AtBDynamicScenarioFactory;\n+import mekhq.campaign.mission.AtBScenario;\n+import mekhq.campaign.mission.Contract;\n+import mekhq.campaign.mission.Scenario;\n+import mekhq.campaign.mission.ScenarioForceTemplate;\n+import mekhq.campaign.mission.ScenarioMapParameters.MapLocation;\n+import mekhq.campaign.mission.ScenarioTemplate;\n+import mekhq.campaign.mission.ScenarioForceTemplate.ForceAlignment;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier;\n+import mekhq.campaign.mission.atb.AtBScenarioModifier.EventTiming;\n+import mekhq.campaign.personnel.SkillType;\n+import mekhq.campaign.stratcon.StratconFacility.FacilityType;\n+import mekhq.campaign.stratcon.StratconScenario.ScenarioState;\n+import mekhq.campaign.unit.Unit;\n+\n+/**\n+ * This class contains \"rules\" logic for the AtB-Stratcon state\n+ * @author NickAragua\n+ */\n+public class StratconRulesManager {\n+    /**\n+     * What makes a particular lance eligible to be reinforcements for a scenario\n+     */\n+    public enum ReinforcementEligibilityType {\n+        /**\n+         * Nothing\n+         */\n+        None,\n+\n+        /**\n+         * Lance is already deployed to the track\n+         */\n+        ChainedScenario,\n+\n+        /**\n+         * We pay a support point or convert a victory point to a support point\n+         */\n+        SupportPoint,\n+\n+        /**\n+         * The lance's deployment orders are \"Fight\"\n+         */\n+        FightLance\n+    }\n+\n+    /**\n+     * This function potentially generates non-player-initiated scenarios for the given track.\n+     */\n+    public static void generateScenariosForTrack(Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        // maps scenarios to force IDs\n+        List<StratconScenario> generatedScenarios = new ArrayList<>();\n+        boolean autoAssignLances = contract.getCommandRights() == AtBContract.COM_INTEGRATED;\n+\n+        // get this list just so we have it available\n+        List<Integer> availableForceIDs = getAvailableForceIDs(campaign);\n+        Map<MapLocation, List<Integer>> sortedAvailableForceIDs = sortForcesByMapType(availableForceIDs, campaign);\n+\n+        // make X rolls, where X is the number of required lances for the track\n+        // that's the chance to spawn a scenario.\n+        // if a scenario occurs, then we pick a random non-deployed lance and use it to drive the opfor generation later\n+        // once we've determined that scenarios occur, we loop through the ones that we generated\n+        // and use the random force to drive opfor generation (#required lances multiplies the BV budget of all\n+        for (int scenarioIndex = 0; scenarioIndex < track.getRequiredLanceCount(); scenarioIndex++) {\n+            int targetNum = calculateScenarioOdds(track, contract, false);\n+            \n+            // if we haven't already used all the player forces and are required to randomly generate a scenario\n+            if (!availableForceIDs.isEmpty() && (Compute.randomInt(100) <= targetNum)) {\n+                // pick random coordinates and force to drive the scenario\n+                int x = Compute.randomInt(track.getWidth());\n+                int y = Compute.randomInt(track.getHeight());\n+\n+                StratconCoords scenarioCoords = new StratconCoords(x, y);\n+\n+                // if forces are already assigned to these coordinates, use those instead\n+                // of randomly-selected ones\n+                if (track.getAssignedCoordForces().containsKey(scenarioCoords)) {\n+                    StratconScenario scenario = generateScenarioForExistingForces(scenarioCoords,\n+                            track.getAssignedCoordForces().get(scenarioCoords), \n+                            contract, campaign, track);\n+                    generatedScenarios.add(scenario);\n+                    continue;\n+                }\n+                \n+                // otherwise, pick a random force from the avail\n+                int randomForceIndex = Compute.randomInt(availableForceIDs.size());\n+                int randomForceID = availableForceIDs.get(randomForceIndex);\n+                \n+                // remove the force from the available lists so we don't designate it as primary twice\n+                availableForceIDs.remove(randomForceIndex);\n+\n+                // we want to remove the actual int with the value, not the value at the index\n+                sortedAvailableForceIDs.get(MapLocation.AllGroundTerrain).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.LowAtmosphere).remove((Integer) randomForceID);\n+                sortedAvailableForceIDs.get(MapLocation.Space).remove((Integer) randomForceID);\n+\n+                // two scenarios on the same coordinates wind up increasing in size\n+                if (track.getScenarios().containsKey(scenarioCoords)) {\n+                    track.getScenarios().get(scenarioCoords).incrementRequiredPlayerLances();\n+                    assignAppropriateExtraForceToScenario(track.getScenarios().get(scenarioCoords), sortedAvailableForceIDs);\n+                    continue;\n+                }\n+\n+                StratconScenario scenario = setupScenario(scenarioCoords, randomForceID, campaign, contract, track);\n+                generatedScenarios.add(scenario);\n+\n+                // if we're auto-assigning lances, deploy the force to the track as well\n+                if (autoAssignLances) {\n+                    processForceDeployment(scenarioCoords, randomForceID, campaign, track, false);\n+                }\n+            }\n+        }\n+\n+        // if under liaison command, pick a random scenario from the ones generated\n+        // to set as required and attach liaison\n+        if (contract.getCommandRights() == AtBContract.COM_LIAISON) {\n+        \tStratconScenario randomScenario = Utilities.getRandomItem(generatedScenarios);\n+        \trandomScenario.setRequiredScenario(true);\n+            setAttachedUnitsModifier(randomScenario, contract);\n+        }\n+\n+        // now, we loop through all the scenarios we set up\n+        // and generate the opfors / events / etc\n+        // if not auto-assigning lances, we then back out the lance assignments.\n+        for (StratconScenario scenario : generatedScenarios) {\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+\n+            if(!autoAssignLances && !scenario.ignoreForceAutoAssignment()) {\n+                for(int forceID : scenario.getPlayerTemplateForceIDs()) {\n+                    scenario.getBackingScenario().removeForce(forceID);\n+                }\n+\n+                scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                track.addScenario(scenario);\n+            } else {\n+                commitPrimaryForces(campaign, scenario, track);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Given a set of force IDs and coordinates, generate a scenario\n+     * Useful for when we want to generate scenarios \n+     * for forces already deployed to a track\n+     */\n+    public static StratconScenario generateScenarioForExistingForces(StratconCoords scenarioCoords, \n+            Set<Integer> forceIDs, AtBContract contract, Campaign campaign, StratconTrackState track) {\n+        boolean firstForce = true;\n+        StratconScenario scenario = null;\n+        \n+        for (int forceID : forceIDs) {\n+            if (firstForce) {\n+                scenario = setupScenario(scenarioCoords, forceID, campaign, contract, track);\n+                firstForce = false;\n+            } else {\n+                scenario.incrementRequiredPlayerLances();\n+                scenario.addPrimaryForce(forceID);\n+            }\n+        }\n+        \n+        // this is theoretically possible if forceIDs is passed in as null - not likely in practice\n+        // but might as well, to future-proof.\n+        if (scenario != null) {\n+            scenario.setIgnoreForceAutoAssignment(true);\n+        }\n+        \n+        return scenario;\n+    }\n+\n+    /**\n+     * Deploys a force to the given coordinates on the given track as a result of explicit player action.\n+     */\n+    public static void deployForceToCoords(StratconCoords coords, int forceID, \n+            Campaign campaign, AtBContract contract, StratconTrackState track, boolean sticky) {\n+        // the following things should happen:\n+        // 1. call to \"process force deployment\", which reveals fog of war in or around the coords, depending on force role\n+        // 2. if coords are a hostile facility, we get a facility mission\n+        // 3. if coords are empty, we *may* get a mission\n+\n+        processForceDeployment(coords, forceID, campaign, track, sticky);\n+\n+        // don't create a scenario on top of allied facilities\n+        StratconFacility facility = track.getFacility(coords);\n+        boolean isNonAlliedFacility = (facility != null) && (facility.getOwner() != ForceAlignment.Allied);\n+        int targetNum = calculateScenarioOdds(track, contract, true);\n+        boolean spawnScenario = (facility == null) && (Compute.randomInt(100) <= targetNum);\n+\n+        if (isNonAlliedFacility || spawnScenario) {\n+            StratconScenario scenario = setupScenario(coords, forceID, campaign, contract, track);\n+            AtBDynamicScenarioFactory.finalizeScenario(scenario.getBackingScenario(), contract, campaign);\n+            commitPrimaryForces(campaign, scenario, track);\n+        }\n+    }\n+\n+    /**\n+     * Logic to set up a scenario\n+     */\n+    private static StratconScenario setupScenario(StratconCoords coords, int forceID, Campaign campaign, AtBContract contract, StratconTrackState track) {\n+        StratconScenario scenario = null;\n+\n+        if (track.getFacilities().containsKey(coords)) {\n+            StratconFacility facility = track.getFacility(coords);\n+            boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+            ScenarioTemplate template = StratconScenarioFactory.getFacilityScenario(alliedFacility);\n+            scenario = generateScenario(campaign, contract, track, forceID, coords, template);\n+            setupFacilityScenario(scenario, facility);\n+        } else {\n+            scenario = generateScenario(campaign, contract, track, forceID, coords);\n+\n+            // we may generate a facility scenario randomly - if so, do the facility-related stuff\n+            // and add a new facility to the track\n+            if (scenario.getBackingScenario().getTemplate().isFacilityScenario()) {\n+                StratconFacility facility = scenario.getBackingScenario().getTemplate().isHostileFacility() ?\n+                        StratconFacilityFactory.getRandomHostileFacility() : StratconFacilityFactory.getRandomAlliedFacility();\n+                facility.setVisible(true);\n+                track.addFacility(coords, facility);\n+                setupFacilityScenario(scenario, facility);\n+            }\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * carries out tasks relevant to facility scenarios\n+     */\n+    private static void setupFacilityScenario(StratconScenario scenario, StratconFacility facility) {\n+        // this includes:\n+        // for hostile facilities\n+        // - add a destroy objective (always the option to level the facility)\n+        // - add a capture objective (always the option to capture the facility)\n+        // - if so indicated by parameter, roll a random hostile facility objective and add it if not capture/destroy\n+        // for allied facilities\n+        // - add a defend objective (always the option to defend the facility)\n+        // - if so indicated by parameter, roll a random allied facility objective and add it if not defend\n+        AtBScenarioModifier objectiveModifier = null;\n+        boolean alliedFacility = facility.getOwner() == ForceAlignment.Allied;\n+\n+        if (alliedFacility) {\n+            objectiveModifier = AtBScenarioModifier.getRandomAlliedFacilityModifier();\n+        } else {\n+            objectiveModifier = AtBScenarioModifier.getRandomHostileFacilityModifier();\n+        }\n+\n+        if (objectiveModifier != null) {\n+            scenario.getBackingScenario().addScenarioModifier(objectiveModifier);\n+            scenario.getBackingScenario().setName(String.format(\"%s - %s - %s\",\n+                    facility.getFacilityType(), alliedFacility ? \"Allied\" : \"Hostile\", objectiveModifier.getModifierName()));\n+        }\n+\n+        // add the \"fixed\" hostile facility modifiers after the primary ones\n+        if (!alliedFacility) {\n+            for(AtBScenarioModifier modifier : AtBScenarioModifier.getRequiredHostileFacilityModifiers()) {\n+                if(!scenario.getBackingScenario().alreadyHasModifier(modifier)) {\n+                    scenario.getBackingScenario().addScenarioModifier(modifier);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void processFacilityEffects(StratconTrackState track) {\n+        // TODO: these are \"weekly\"? effects that a stratcon facility has on the campaign/track state\n+        // currrently, that's\n+        // supply depot - allied - +1 sp\n+        // supply depot - hostile - +5% BV budget to all scenarios on track (shared modifier, so should be implemented there)\n+        // data center - allied - +1% star league cache contract (don't implement yet, but...)\n+        // data center - hostile - +5% scenario odds in track\n+        // industrial center - allied - all scenarios here have THIS IS COMING OUT OF YOUR PAYCHECK modifier\n+        // orbital defense - allied - sets 'no hostile aircraft' flag for track\n+        // orbital defense - hostile - sets 'no allied aircraft' flag for track\n+        // early warning system - allied - sets 'intercept allied base attacks' flag for track\n+        // early warning system - hostile - sets 'intercept hostile base attacks' flag for track\n+    }\n+\n+    /**\n+     * Process the deployment of a force to the given coordinates on the given track.\n+     */\n+    public static void processForceDeployment(StratconCoords coords, int forceID, \n+            Campaign campaign, StratconTrackState track, boolean sticky) {\n+        track.getRevealedCoords().add(coords);\n+        StratconFacility facility = track.getFacility(coords);\n+        if (facility != null) {\n+            facility.setVisible(true);\n+        }\n+\n+        if (campaign.getLances().get(forceID).getRole() == AtBLanceRole.SCOUTING) {\n+            for(int direction = 0; direction < 6; direction++) {\n+                StratconCoords checkCoords = coords.translate(direction);\n+\n+                facility = track.getFacility(checkCoords);\n+                if(facility != null) {\n+                    facility.setVisible(true);\n+                }\n+\n+                track.getRevealedCoords().add(coords.translate(direction));\n+            }\n+        }\n+\n+        // the force may be located in other places on the track - clear it out\n+        track.unassignForce(forceID);\n+        track.assignForce(forceID, coords, campaign.getLocalDate(), sticky);\n+        MekHQ.triggerEvent(new StratconDeploymentEvent(campaign.getForce(forceID)));\n+    }\n+\n+    /**\n+     * Worker function that processes the effects of deploying a reinforcement force to a scenario\n+     */\n+    public static boolean processReinforcementDeployment(ReinforcementEligibilityType reinforcementType,\n+            StratconCampaignState campaignState, StratconScenario scenario, Campaign campaign) {\n+        // if the force is already deployed to the track, we're done\n+        // if the force is a fight lance or we're using a support point\n+        // if there is an SP to burn, burn it and we're done\n+        // if there is a VP to burn, burn it and we're done\n+        // now, roll 2d6 + lance commander tactics\n+        // 9+ = deploy\n+        // 6+ = deploy, apply negative modifier to scenario\n+        // 2+ = fail to deploy, apply negative modifier to scenario; if fight lance, treat as 6+\n+\n+        if ((reinforcementType == ReinforcementEligibilityType.FightLance) ||\n+                (reinforcementType == ReinforcementEligibilityType.SupportPoint)) {\n+\n+            if (campaignState.getSupportPoints() > 0) {\n+                campaignState.useSupportPoint();\n+                return true;\n+            } else if (campaignState.getVictoryPoints() > 0) {\n+                campaignState.updateVictoryPoints(-1);\n+                return true;\n+            }\n+\n+            int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+            int roll = Compute.d6(2);\n+            int result = roll + tactics;\n+\n+            StringBuilder reportStatus = new StringBuilder();\n+            reportStatus.append(String.format(\"Attempting to reinforce scenario %s without SP/VP, roll 2d6 + %d: %d\",\n+                    scenario.getName(), tactics, result));\n+\n+            // fail to reinforce\n+            if ((result < 6) && (reinforcementType != ReinforcementEligibilityType.FightLance)) {\n+                reportStatus.append(\" - reinforcement attempt failed.\");\n+                campaign.addReport(reportStatus.toString());\n+                return false;\n+            // succeed but get an extra negative event added to the scenario\n+            } else if (result < 9) {\n+                MapLocation mapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+                AtBScenarioModifier scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+\n+                // keep rolling until we get an applicable one\n+                // TODO: have the AtBScenarioModifier sort these out instead for performance?\n+                while (scenarioModifier.getEventTiming() != EventTiming.PostForceGeneration) {\n+                    scenarioModifier = AtBScenarioModifier.getRandomBattleModifier(mapLocation, false);\n+                }\n+\n+                scenarioModifier.processModifier(scenario.getBackingScenario(), campaign, EventTiming.PostForceGeneration);\n+\n+                reportStatus.append(String.format(\" - reinforcement attempt succeeded; extra negative modifier (%s) applied to scenario.\",\n+                        scenarioModifier.getModifierName()));\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            // succeed without reservation\n+            } else {\n+                reportStatus.append(\" - reinforcement attempt succeeded;\");\n+                campaign.addReport(reportStatus.toString());\n+                return true;\n+            }\n+        } else if (reinforcementType == ReinforcementEligibilityType.None) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Assigns a force to the scenario such that the majority of the force can be deployed\n+     */\n+    private static void assignAppropriateExtraForceToScenario(StratconScenario scenario,\n+            Map<MapLocation, List<Integer>> sortedAvailableForceIDs) {\n+        // the goal of this function is to avoid assigning ground units to air battles\n+        // and ground units/conventional fighters to space battle\n+\n+        List<MapLocation> mapLocations = new ArrayList<>();\n+        mapLocations.add(MapLocation.Space); // can always add ASFs\n+\n+        MapLocation scenarioMapLocation = scenario.getScenarioTemplate().mapParameters.getMapLocation();\n+\n+        if (scenarioMapLocation == MapLocation.LowAtmosphere) {\n+            mapLocations.add(MapLocation.LowAtmosphere); // can add conventional fighters to ground or low atmo battles\n+        }\n+\n+        if ((scenarioMapLocation == MapLocation.AllGroundTerrain) ||\n+                (scenarioMapLocation == MapLocation.SpecificGroundTerrain)) {\n+            mapLocations.add(MapLocation.AllGroundTerrain); // can only add ground units to ground battles\n+        }\n+\n+        MapLocation selectedLocation = mapLocations.get(Compute.randomInt(mapLocations.size()));\n+        List<Integer> forceIDs = sortedAvailableForceIDs.get(selectedLocation);\n+        int forceIndex = Compute.randomInt(forceIDs.size());\n+        int forceID = forceIDs.get(forceIndex);\n+        forceIDs.remove(forceIndex);\n+\n+        scenario.addPrimaryForce(forceID);\n+    }\n+\n+    /**\n+     * Worker function that \"locks in\" a scenario -\n+     * Adds it to the campaign so it's visible in the briefing room,\n+     * adds it to the track\n+     *\n+     */\n+    public static void commitPrimaryForces(Campaign campaign, StratconScenario scenario, StratconTrackState trackState) {\n+        trackState.addScenario(scenario);\n+\n+        // set up dates for the scenario if doesn't have them already\n+        if (scenario.getDeploymentDate() == null) {\n+            scenario.setDeploymentDate(campaign.getLocalDate());\n+        }\n+\n+        if (scenario.getActionDate() == null) {\n+            scenario.setActionDate(campaign.getLocalDate());\n+        }\n+\n+        if(scenario.getReturnDate() == null) {\n+            scenario.setReturnDate(campaign.getLocalDate().plusDays(trackState.getDeploymentTime()));\n+        }\n+\n+        // set the # of rerolls based on the actual lance assigned.\n+        int tactics = scenario.getBackingScenario().getLanceCommanderSkill(SkillType.S_TACTICS, campaign);\n+        scenario.getBackingScenario().setRerolls(tactics);\n+        // The number of defensive points available to a force entering a scenario is\n+        // 2 x tactics. By default, those points are spent on conventional minefields.\n+        if (commanderLanceHasDefensiveAssignment(scenario.getBackingScenario(), campaign)) {\n+            scenario.setNumDefensivePoints(tactics * 2);\n+            scenario.updateMinefieldCount(Minefield.TYPE_CONVENTIONAL, tactics * 2);\n+        }\n+\n+        for (int forceID : scenario.getPlayerTemplateForceIDs()) {\n+            Force force = campaign.getForce(forceID);\n+            force.clearScenarioIds(campaign, true);\n+            force.setScenarioId(scenario.getBackingScenarioID());\n+        }\n+\n+        scenario.commitPrimaryForces();\n+    }\n+\n+    /**\n+     * Utility method to determine if the current scenario's force commander\n+     * is on defence\n+     */\n+    private static boolean commanderLanceHasDefensiveAssignment(AtBDynamicScenario scenario, Campaign campaign) {\n+        Unit commanderUnit = scenario.getLanceCommander(campaign).getUnit();\n+        Lance lance = campaign.getLances().get(commanderUnit.getForceId());\n+\n+        if ((lance != null) && (lance.getRole() == AtBLanceRole.DEFENCE)) {\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    /**\n+     * A hackish worker function that takes the given list of force IDs and\n+     * separates it into three sets;\n+     * one of forces that can be \"primary\" on a ground map\n+     * one of forces that can be \"primary\" on an atmospheric map\n+     * one of forces that can be \"primary\" in a space map\n+     * @param forceIDs List of force IDs to check\n+     * @return Sorted hash map\n+     */\n+    private static Map<MapLocation, List<Integer>> sortForcesByMapType(List<Integer> forceIDs, Campaign campaign) {\n+        Map<MapLocation, List<Integer>> retVal = new HashMap<>();\n+\n+        retVal.put(MapLocation.AllGroundTerrain, new ArrayList<>());\n+        retVal.put(MapLocation.LowAtmosphere, new ArrayList<>());\n+        retVal.put(MapLocation.Space, new ArrayList<>());\n+\n+        for (int forceID : forceIDs) {\n+            switch(campaign.getForce(forceID).getPrimaryUnitType(campaign)) {\n+            case UnitType.BATTLE_ARMOR:\n+            case UnitType.INFANTRY:\n+            case UnitType.MEK:\n+            case UnitType.TANK:\n+            case UnitType.PROTOMEK:\n+            case UnitType.VTOL:\n+                retVal.get(MapLocation.AllGroundTerrain).add(forceID);\n+                break;\n+            case UnitType.AERO:\n+                retVal.get(MapLocation.Space).add(forceID);\n+                // intentional fallthrough here, ASFs can go to atmospheric maps too\n+            case UnitType.CONV_FIGHTER:\n+                retVal.get(MapLocation.LowAtmosphere).add(forceID);\n+                break;\n+            }\n+        }\n+\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * Determine whether the user should be nagged about unresolved scenarios on AtB Stratcon tracks.\n+     * @param campaign Campaign to check.\n+     * @return An informative string containing the reasons the user was nagged.\n+     */\n+    public static String nagUnresolvedContacts(Campaign campaign) {\n+        StringBuilder sb = new StringBuilder();\n+\n+        // check every track attached to an active contract for unresolved scenarios\n+        // to which the player must deploy forces today\n+        for (AtBContract contract : campaign.getActiveAtBContracts()) {\n+            if (contract.getStratconCampaignState() == null) {\n+                continue;\n+            }\n+            \n+            for (StratconTrackState track : contract.getStratconCampaignState().getTracks()) {\n+                for (StratconScenario scenario : track.getScenarios().values()) {\n+                    if (scenario.getCurrentState() == ScenarioState.UNRESOLVED &&\n+                            campaign.getLocalDate().equals(scenario.getDeploymentDate())) {\n+                        // \"scenario name, track name\"\n+                        sb.append(String.format(\"%s, %s\\n\", scenario.getName(), track.getDisplayableName()));\n+                    }\n+                }\n+            }\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track.\n+     * Also registers it with the track and campaign.\n+     */\n+    private static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords) {\n+        int unitType = campaign.getForce(forceID).getPrimaryUnitType(campaign);\n+        ScenarioTemplate template = StratconScenarioFactory.getRandomScenario(unitType);\n+        // useful for debugging specific scenario types\n+        //ScenarioTemplate template = StratconScenarioFactory.getSpecificScenario(\"Hostile Facility.xml\");\n+\n+        return generateScenario(campaign, contract, track, forceID, coords, template);\n+    }\n+\n+    /**\n+     * Worker function that generates stratcon scenario at the given coords, for the given force, on the given track,\n+     * using the given template. Also registers it with the campaign.\n+     */\n+    static StratconScenario generateScenario(Campaign campaign, AtBContract contract, StratconTrackState track,\n+            int forceID, StratconCoords coords, ScenarioTemplate template) {\n+        StratconScenario scenario = new StratconScenario();\n+        \n+        AtBDynamicScenario backingScenario = AtBDynamicScenarioFactory.initializeScenarioFromTemplate(template, contract, campaign);        \n+        scenario.setBackingScenario(backingScenario);\n+        scenario.setCoords(coords);\n+        \n+        // by default, certain conditions may make this bigger\n+        scenario.setRequiredPlayerLances(1);\n+\n+        // do an appropriate allied force if the contract calls for it\n+        // do any attached or integrated units\n+        setAlliedForceModifier(scenario, contract);\n+        setAttachedUnitsModifier(scenario, contract);\n+        applyFacilityModifiers(scenario, track, coords);\n+        applyGlobalModifiers(scenario, contract.getStratconCampaignState());\n+\n+        if ((contract.getCommandRights() == AtBContract.COM_HOUSE) ||\n+                (contract.getCommandRights() == AtBContract.COM_INTEGRATED)) {\n+            scenario.setRequiredScenario(true);\n+        }\n+\n+        AtBDynamicScenarioFactory.setScenarioModifiers(scenario.getBackingScenario());\n+        scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+        setScenarioDates(track, campaign, scenario);\n+        \n+        // the backing scenario ID must be updated after registering the backing scenario \n+        // with the campaign, so that the stratcon - backing scenario association is maintained\n+        // registering the scenario with the campaign should be done after setting\n+        // dates, otherwise, the report messages for new scenarios look weird\n+        campaign.addScenario(backingScenario, contract);\n+        scenario.setBackingScenarioID(backingScenario.getId());\n+        \n+        if (forceID > Force.FORCE_NONE) {\n+            scenario.addPrimaryForce(forceID);\n+        }\n+\n+        return scenario;\n+    }\n+\n+    /**\n+     * Apply global scenario modifiers from campaign state to given scenario.\n+     */\n+    private static void applyGlobalModifiers(StratconScenario scenario, StratconCampaignState campaignState) {\n+        for (String modifierName : campaignState.getGlobalScenarioModifiers()) {\n+            AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierName);\n+\n+            if (modifier == null) {\n+                MekHQ.getLogger().error(String.format(\"Modifier %s not found; ignoring\", modifierName));\n+                continue;\n+            }\n+\n+            scenario.getBackingScenario().addScenarioModifier(modifier);\n+        }\n+    }\n+\n+    /**\n+     * Applies scenario modifiers from the current track to the given scenario.\n+     * @param scenario\n+     * @param track\n+     */\n+    private static void applyFacilityModifiers(StratconScenario scenario, StratconTrackState track, StratconCoords coords) {\n+        // loop through all the facilities on the track\n+        // if a facility has been revealed, then it has a 100% chance to apply its effect\n+        // if a facility has not been revealed, then it has a x% chance to apply its effect\n+        // if a facility is on the the scenario coordinates the it applies the local effects\n+        for (StratconCoords facilityCoords : track.getFacilities().keySet()) {\n+            boolean scenarioAtFacility = facilityCoords.equals(coords);\n+            StratconFacility facility = track.getFacilities().get(facilityCoords);\n+            List<String> modifierIDs = new ArrayList<>();\n+\n+            if (scenarioAtFacility) {\n+                modifierIDs = facility.getLocalModifiers();\n+            } else if (facility.isVisible() || (Compute.randomInt(100) <= facility.getAggroRating())) {\n+                modifierIDs = facility.getSharedModifiers();\n+            }\n+\n+            for (String modifierID : modifierIDs) {\n+                AtBScenarioModifier modifier = AtBScenarioModifier.getScenarioModifier(modifierID);\n+                if(modifier == null) {\n+                    MekHQ.getLogger().error(String.format(\"Modifier %s not found for facility %s\", modifierID, facility.getFormattedDisplayableName()));\n+                    continue;\n+                }\n+\n+                scenario.getBackingScenario().addScenarioModifier(modifier);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set up the appropriate primary allied force modifier, if any\n+     * @param contract The scenario's contract.\n+     */\n+    private static void setAlliedForceModifier(StratconScenario scenario, AtBContract contract) {\n+        int alliedUnitOdds = 0;\n+\n+        // first, we determine the odds of having an allied unit present\n+        // TODO: move this override out to the contract definition\n+        if (contract.getMissionType() == AtBContract.MT_RELIEFDUTY) {\n+            alliedUnitOdds = 50;\n+        } else {\n+            switch(contract.getCommandRights()) {\n+                case AtBContract.COM_INTEGRATED:\n+                    alliedUnitOdds = 50;\n+                    break;\n+                case AtBContract.COM_HOUSE:\n+                    alliedUnitOdds = 30;\n+                    break;\n+                case AtBContract.COM_LIAISON:\n+                    alliedUnitOdds = 10;\n+                    break;\n+            }\n+        }\n+\n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+\n+        // if an allied unit is present, then we want to make sure that it's ground units\n+        // for ground battles\n+        if (Compute.randomInt(100) <= alliedUnitOdds) {\n+            if((backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+               (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space)) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_ALLIED_AIR_UNITS));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_ALLIED_GROUND_UNITS));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Set the 'attached' units modifier for the current scenario (integrated, house, liaison),\n+     * and make sure we're not deploying ground units to an air scenario\n+     * @param contract The scenario's contract\n+     */\n+    public static void setAttachedUnitsModifier(StratconScenario scenario, AtBContract contract) {\n+        AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n+        boolean airBattle = (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n+                (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space);\n+\n+        // if we're on cadre duty, we're getting three trainees, period\n+        if (contract.getMissionType() == AtBContract.MT_CADREDUTY) {\n+            if (airBattle) {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_TRAINEES_AIR));\n+            } else {\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_TRAINEES_GROUND));\n+            }\n+            return;\n+        }\n+\n+        // if we're under non-independent command rights, a supervisor may come along\n+        switch (contract.getCommandRights()) {\n+            case AtBContract.COM_INTEGRATED:\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(airBattle \n+                        ? MekHqConstants.SCENARIO_MODIFIER_INTEGRATED_UNITS_AIR\n+                        : MekHqConstants.SCENARIO_MODIFIER_INTEGRATED_UNITS_GROUND));\n+                break;\n+            case AtBContract.COM_HOUSE:\n+                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(airBattle \n+                        ? MekHqConstants.SCENARIO_MODIFIER_HOUSE_CO_AIR\n+                        : MekHqConstants.SCENARIO_MODIFIER_HOUSE_CO_GROUND));\n+                break;\n+            case AtBContract.COM_LIAISON:\n+                if (scenario.isRequiredScenario()) {\n+                    backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(airBattle \n+                            ? MekHqConstants.SCENARIO_MODIFIER_LIAISON_AIR\n+                            : MekHqConstants.SCENARIO_MODIFIER_LIAISON_GROUND));\n+                }\n+                break;\n+        }\n+    }\n+\n+    /**\n+     * Worker function that sets scenario deploy/battle/return dates based on the track's properties and current campaign date\n+     */\n+    private static void setScenarioDates(StratconTrackState track, Campaign campaign, StratconScenario scenario) {\n+     // set up deployment day, battle day, return day here\n+        // safety code to prevent attempts to generate random int with upper bound of 0 which is apparently illegal\n+        int deploymentDay = track.getDeploymentTime() < 7 ? Compute.randomInt(7 - track.getDeploymentTime()) : 0;\n+        int battleDay = deploymentDay + (track.getDeploymentTime() > 0 ? Compute.randomInt(track.getDeploymentTime()) : 0);\n+        int returnDay = deploymentDay + track.getDeploymentTime();\n+\n+        LocalDate deploymentDate = campaign.getLocalDate();\n+        deploymentDate.plusDays(deploymentDay);\n+        LocalDate battleDate = campaign.getLocalDate();\n+        deploymentDate.plusDays(battleDay);\n+        LocalDate returnDate = campaign.getLocalDate();\n+        returnDate.plusDays(returnDay);\n+\n+        scenario.setDeploymentDate(deploymentDate);\n+        scenario.setActionDate(battleDate);\n+        scenario.setReturnDate(returnDate);\n+    }\n+\n+    /**\n+     * Helper function that determines if the unit type specified in the given scenario force template\n+     * would start out airborne on a ground map (hot dropped units aside)\n+     */\n+    private static boolean unitTypeIsAirborne(ScenarioForceTemplate template) {\n+        int unitType = template.getAllowedUnitType();\n+\n+        return (unitType == UnitType.AERO ||\n+                unitType == UnitType.CONV_FIGHTER ||\n+                unitType == UnitType.DROPSHIP ||\n+                unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_MIX) &&\n+                template.getStartingAltitude() > 0;\n+    }\n+\n+    /**\n+     * Determines whether the force in question has the same primary unit type as the force template.\n+     * @return Whether or not the unit types match.\n+     */\n+    public static boolean forceCompositionMatchesDeclaredUnitType(int primaryUnitType, int unitType, boolean reinforcements) {\n+        // special cases are \"ATB_MIX\" and \"ATB_AERO_MIX\", which encompass multiple unit types\n+        if (unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_MIX) {\n+            // \"AtB mix\" is usually ground units, but air units can sub in\n+            return primaryUnitType == UnitType.MEK ||\n+                    primaryUnitType == UnitType.TANK ||\n+                    primaryUnitType == UnitType.INFANTRY ||\n+                    primaryUnitType == UnitType.BATTLE_ARMOR ||\n+                    primaryUnitType == UnitType.PROTOMEK ||\n+                    primaryUnitType == UnitType.VTOL ||\n+                    (primaryUnitType == UnitType.AERO) && reinforcements ||\n+                    (primaryUnitType == UnitType.CONV_FIGHTER) && reinforcements;\n+        } else if (unitType == ScenarioForceTemplate.SPECIAL_UNIT_TYPE_ATB_AERO_MIX) {\n+            return primaryUnitType == UnitType.AERO ||\n+                    primaryUnitType == UnitType.CONV_FIGHTER;\n+        } else {\n+            return primaryUnitType == unitType;\n+        }\n+    }\n+\n+    /**\n+     * This is a set of all force IDs for forces that can be deployed to a scenario.\n+     * @param campaign Current campaign\n+     * @return Set of available force IDs.\n+     */\n+    public static List<Integer> getAvailableForceIDs(Campaign campaign) {\n+        List<Integer> retVal = new ArrayList<>();\n+\n+        // first, we gather a set of all forces that are already deployed to a track so we eliminate those later\n+        Set<Integer> forcesInTracks = new HashSet<>();\n+        for (Contract contract : campaign.getActiveContracts()) {\n+            if (contract instanceof AtBContract) {\n+                for (StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    forcesInTracks.addAll(track.getAssignedForceCoords().keySet());\n+                }\n+            }\n+        }\n+\n+        // now, we get all the forces that qualify as \"lances\", and filter out those that are\n+        // deployed to a scenario and not in a track already\n+        for (int key : campaign.getLances().keySet()) {\n+            Force force = campaign.getForce(key);\n+            if ((force != null) &&\n+                    !force.isDeployed() &&\n+                    !forcesInTracks.contains(force.getId())) {\n+                retVal.add(force.getId());\n+            }\n+        }\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * This is a list of all force IDs for forces that can be deployed to a scenario in the given force template\n+     * a) have not been assigned to a track\n+     * b) are combat-capable\n+     * c) are not deployed to a scenario\n+     * d) if attempting to deploy as reinforcements, haven't already failed to deploy\n+     */\n+    public static List<Integer> getAvailableForceIDs(int unitType, Campaign campaign, StratconTrackState currentTrack,\n+            boolean reinforcements, @Nullable StratconScenario currentScenario) {\n+        List<Integer> retVal = new ArrayList<>();\n+\n+        Set<Integer> forcesInTracks = new HashSet<>();\n+        // assemble a set of all force IDs that are currently assigned to tracks that are not this one\n+        for (Contract contract : campaign.getActiveContracts()) {\n+            if (contract instanceof AtBContract) {\n+                for (StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    if ((track != currentTrack) || !reinforcements) {\n+                        forcesInTracks.addAll(track.getAssignedForceCoords().keySet());\n+                    }\n+                }\n+            }\n+        }\n+        \n+        // if there's an existing scenario and we're doing reinforcements,\n+        // prevent forces that failed to deploy from trying to deploy again\n+        if (reinforcements && (currentScenario != null)) {\n+            forcesInTracks.addAll(currentScenario.getFailedReinforcements());\n+        }\n+\n+        for (int key : campaign.getLances().keySet()) {\n+            Force force = campaign.getForce(key);\n+\n+            if (force == null) {\n+                continue;\n+            }\n+\n+            int primaryUnitType = force.getPrimaryUnitType(campaign);\n+            if (!force.isDeployed() &&\n+                    (force.getScenarioId() <= 0) &&\n+                    !force.getUnits().isEmpty() &&\n+                    !forcesInTracks.contains(force.getId()) &&\n+                    forceCompositionMatchesDeclaredUnitType(primaryUnitType, unitType, reinforcements)) {\n+                retVal.add(force.getId());\n+            }\n+        }\n+\n+        return retVal;\n+    }\n+\n+    /**\n+     * Returns a list of individual units eligible for deployment in scenarios run by \"Defend\" lances\n+     * @return List of unit IDs.\n+     */\n+    public static List<Unit> getEligibleDefensiveUnits(Campaign campaign) {\n+        List<Unit> retVal = new ArrayList<>();\n+\n+        for (Unit u : campaign.getUnits()) {\n+            // \"defensive\" units are infantry, battle armor and (Weisman help you) gun emplacements\n+        \t// and also said unit should be intact/alive/etc\n+        \tboolean isEligibleInfantry = \n+        \t\t\t((u.getEntity().getUnitType() == UnitType.INFANTRY) ||\n+                    (u.getEntity().getUnitType() == UnitType.BATTLE_ARMOR)) &&\n+                    !u.isUnmanned();\n+        \t\n+        \tboolean isEligibleGunEmplacement = u.getEntity().getUnitType() == UnitType.GUN_EMPLACEMENT;\n+        \t\n+        \tif ((isEligibleInfantry || isEligibleGunEmplacement) && \n+            \t\t!u.isDeployed() &&\n+                    !u.isMothballed() &&\n+                    u.isFunctional()) {\n+\n+                // this is a little inefficient, but probably there aren't too many active AtB contracts at a time\n+                for (AtBContract contract : campaign.getActiveAtBContracts()) {\n+                    if (contract.getStratconCampaignState().isForceDeployedHere(u.getForceId())) {\n+                        continue;\n+                    }\n+                }\n+\n+                retVal.add(u);\n+            }\n+        }\n+\n+        return retVal;\n+    }\n+    \n+    /**\n+     * Returns a list of individual units eligible for deployment in scenarios\n+     * that result from the lance leader having a leadership score\n+     * @return List of unit IDs.\n+     */\n+    public static List<Unit> getEligibleLeadershipUnits(Campaign campaign, Set<Integer> forceIDs) {\n+        List<Unit> retVal = new ArrayList<>();\n+\n+        // The criteria are as follows:\n+        // - unit is of a different unit type than the primary unit type of the force \n+        // - unit has a lower BV than the force's lowest BV unit\n+        \n+        Integer lowestBV = getLowestBV(campaign, forceIDs);\n+        \n+        // no units assigned, the rest is meaningless.\n+        if (lowestBV == null) {\n+            return retVal;\n+        }\n+        \n+        int primaryUnitType = getPrimaryUnitType(campaign, forceIDs);\n+        \n+        for (Unit u : campaign.getUnits()) {\n+            if ((primaryUnitType != u.getEntity().getUnitType()) &&\n+                    !u.isDeployed() &&\n+                    !u.isMothballed() &&\n+                    u.isFunctional() &&\n+                    (u.getEntity().calculateBattleValue() < lowestBV) &&\n+                    !isUnitDeployedToStratCon(u)) {\n+                retVal.add(u);\n+            }\n+        }\n+\n+        return retVal;\n+    }\n+    \n+    /**\n+     * Check if the unit's force (if one exists) has been deployed to a StratCon track\n+     */\n+    public static boolean isUnitDeployedToStratCon(Unit u) {\n+        if (!u.getCampaign().getCampaignOptions().getUseStratCon()) {\n+            return false;\n+        }\n+        \n+        //this is a little inefficient, but probably there aren't too many active AtB contracts at a time\n+        for (AtBContract contract : u.getCampaign().getActiveAtBContracts()) {\n+            if (contract.getStratconCampaignState().isForceDeployedHere(u.getForceId())) {\n+                return true;\n+            }\n+        }\n+        \n+        return false;\n+    }\n+    \n+    /**\n+     * Given a campaign and a list of force IDs, calculate the unit with the lowest BV.\n+     */\n+    private static Integer getLowestBV(Campaign campaign, Set<Integer> forceIDs) {\n+        Integer lowestBV = null;\n+        \n+        for (int forceID : forceIDs) {\n+            Force force = campaign.getForce(forceID);\n+            if (force == null) {\n+                continue;\n+            }\n+            \n+            for (UUID id : force.getUnits()) {\n+                if (campaign.getUnit(id) == null) {\n+                    continue;\n+                }\n+                \n+                int currentBV = campaign.getUnit(id).getEntity().calculateBattleValue();\n+                \n+                if ((lowestBV == null) || (currentBV < lowestBV)) {\n+                    lowestBV = currentBV;\n+                }\n+            }\n+        }\n+        \n+        return lowestBV;\n+    }\n+    \n+    /**\n+     * Calculates the majority unit type for the forces given the IDs.\n+     */\n+    private static int getPrimaryUnitType(Campaign campaign, Set<Integer> forceIDs) {\n+        Map<Integer, Integer> unitTypeBuckets = new TreeMap<>();\n+        int biggestBucketID = -1;\n+        int biggestBucketCount = 0;\n+        \n+        for (int forceID : forceIDs) {\n+            Force force = campaign.getForce(forceID);\n+            if (force == null) {\n+                continue;\n+            }\n+        \n+            for (UUID id : force.getUnits()) {\n+                Unit unit = campaign.getUnit(id);\n+                if ((unit == null) || \n+                        (unit.getEntity() == null)) {\n+                    continue;\n+                }\n+                \n+                int unitType = unit.getEntity().getUnitType();\n+    \n+                unitTypeBuckets.merge(unitType, 1, (oldCount, value) -> oldCount + value);\n+                \n+                if (unitTypeBuckets.get(unitType) > biggestBucketCount) {\n+                    biggestBucketCount = unitTypeBuckets.get(unitType);\n+                    biggestBucketID = unitType;\n+                }\n+            }\n+        }\n+        \n+        return biggestBucketID;\n+    }\n+\n+    /**\n+     * Determines what rules to use when deploying a force for reinforcements to the given track.\n+     */\n+    public static ReinforcementEligibilityType getReinforcementType(int forceID,\n+            StratconTrackState trackState, Campaign campaign) {\n+        // if the force is currently deployed to the track, it'll be able to deploy \"for free\"\n+        if (trackState.isForceDeployed(forceID)) {\n+            return ReinforcementEligibilityType.ChainedScenario;\n+        }\n+\n+        // if the force is in 'fight' stance, it'll be able to deploy using 'fight lance' rules\n+        if (campaign.getLances().containsKey(forceID) &&\n+                campaign.getLances().get(forceID).getRole() == AtBLanceRole.FIGHTING) {\n+            return ReinforcementEligibilityType.FightLance;\n+        }\n+\n+        // if the force is deployed elsewhere, it cannot be deployed as reinforcements\n+        for (Contract contract : campaign.getActiveContracts()) {\n+            if(contract instanceof AtBContract) {\n+                for(StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n+                    if(track != trackState && track.getAssignedForceCoords().containsKey(forceID)) {\n+                        return ReinforcementEligibilityType.None;\n+                    }\n+                }\n+            }\n+        }\n+\n+        // otherwise, the force requires support points / vps to deploy\n+        return ReinforcementEligibilityType.SupportPoint;\n+    }\n+    \n+    /**\n+     * Given a track and the current campaign state, and if the player is deploying\n+     * a force or not, figure out the odds of a scenario occuring.\n+     */\n+    public static int calculateScenarioOdds(StratconTrackState track, \n+            AtBContract contract, boolean playerDeployingForce) {\n+        // rules:\n+        // rout morale: 0%\n+        // very low morale: -10% when deploying forces to track, 0% attack\n+        // low morale: -5%\n+        // high morale: +5%\n+        // invincible: special case, let's do +10% for now\n+        int moraleModifier = 0;\n+        \n+        switch (contract.getMoraleLevel()) {\n+            case AtBContract.MORALE_ROUT:\n+                return 0;\n+            case AtBContract.MORALE_VERYLOW:\n+                if (playerDeployingForce) {\n+                    moraleModifier = -10;\n+                } else {\n+                    return 0;\n+                }\n+                break;\n+            case AtBContract.MORALE_LOW:\n+                moraleModifier = -5;\n+                break;\n+            case AtBContract.MORALE_HIGH:\n+                moraleModifier = 5;\n+                break;\n+            case AtBContract.MORALE_INVINCIBLE:\n+                moraleModifier = 10;\n+                break;\n+        }\n+        \n+        // facilities: for each hostile data center, add +5%\n+        // for each allied data center, subtract 5\n+        int dataCenterModifier = 0;\n+        for (StratconFacility facility : track.getFacilities().values()) {\n+            if (facility.getFacilityType() == FacilityType.DataCenter) {\n+                dataCenterModifier += facility.getOwner() == ForceAlignment.Allied ? -5 : 5;\n+            }\n+        }\n+            \n+        return track.getScenarioOdds() + moraleModifier + dataCenterModifier;\n+    }\n+\n+    /**\n+     * Removes the facility associated with the given scenario from the relevant track/\n+     */\n+    public static void updateFacilityForScenario(AtBScenario scenario, AtBContract contract, boolean destroy, boolean capture) {\n+        if (contract.getStratconCampaignState() == null) {\n+            return;\n+        }\n+\n+        // this is kind of kludgy, but there's currently no way to link a scenario back to its backing scenario\n+        // TODO: introduce mapping in contract or at least trackstate\n+        // basically, we're looping through all scenarios on all the contract's tracks\n+        // if we find one with the same ID as the one being resolved, that's our facility: get rid of it.\n+        for (StratconTrackState trackState : contract.getStratconCampaignState().getTracks()) {\n+            for (StratconCoords coords : trackState.getScenarios().keySet()) {\n+                StratconScenario potentialScenario = trackState.getScenario(coords);\n+                if (potentialScenario.getBackingScenarioID() == scenario.getId()) {\n+\n+                    if (destroy) {\n+                        trackState.removeFacility(coords);\n+                    } else {\n+                        StratconFacility facility = trackState.getFacility(coords);\n+\n+                        if (facility == null) {\n+                            continue;\n+                        }\n+\n+                        if (capture) {\n+                            facility.incrementOwnershipChangeScore();\n+                        } else {\n+                            facility.decrementOwnershipChangeScore();\n+                        }\n+                    }\n+\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Processes completion of a Stratcon scenario, if the given tracker is associated\n+     * with a stratcon-enabled mission. Intended to be called after ResolveScenarioTracker.finish() has been invoked.\n+     */\n+    public static void processScenarioCompletion(ResolveScenarioTracker rst) {\n+        if (rst.getMission() instanceof AtBContract) {\n+            StratconCampaignState campaignState = ((AtBContract) rst.getMission()).getStratconCampaignState();\n+            if (campaignState == null) {\n+                return;\n+            }\n+\n+            for (StratconTrackState track : campaignState.getTracks()) {\n+                if (track.getBackingScenariosMap().containsKey(rst.getScenario().getId())) {\n+                    // things that may potentially happen:\n+                    // scenario is removed from track - implemented\n+                    // track gets remaining forces added to reinforcement pool\n+                    // facility gets remaining forces stored in reinforcement pool\n+                    // process VP and SO\n+\n+                    StratconScenario scenario = track.getBackingScenariosMap().get(rst.getScenario().getId());\n+\n+\n+                    StratconFacility facility = track.getFacility(scenario.getCoords());\n+\n+                    if ((facility != null) && (facility.getOwnershipChangeScore() > 0)) {\n+                        if (facility.getOwner() == ForceAlignment.Allied) {\n+                            facility.setOwner(ForceAlignment.Opposing);\n+                        } else {\n+                            facility.setOwner(ForceAlignment.Allied);\n+                        }\n+                    }\n+\n+                    boolean victory = rst.getScenario().getStatus() == Scenario.S_VICTORY ||\n+                            rst.getScenario().getStatus() == Scenario.S_MVICTORY;\n+\n+                    if (scenario.isRequiredScenario()) {\n+                        campaignState.updateVictoryPoints(victory ? 1 : -1);\n+                    }\n+\n+                    if (scenario.isStrategicObjective()) {\n+                        if (campaignState.strategicObjectivesBehaveAsVPs()) {\n+                            campaignState.updateVictoryPoints(victory ? 1 : -1);\n+                        } else {\n+                            campaignState.incrementStrategicObjectiveCompletedCount();\n+                        }\n+                    }\n+\n+                    processTrackForceReturnDates(track, rst.getCampaign().getLocalDate());\n+\n+                    track.removeScenario(scenario);\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Worker function that goes through a track and undeploys any forces where the\n+     * return date is on or before the given date.\n+     */\n+    public static void processTrackForceReturnDates(StratconTrackState track, LocalDate date) {\n+        List<Integer> forcesToUndeploy = new ArrayList<>();\n+\n+        // for each force on the track, if the return date is today or in the past,\n+        // \"return to base\", unless it's been told to stay in the field\n+        for (int forceID : track.getAssignedForceReturnDates().keySet()) {\n+            if ((track.getAssignedForceReturnDates().get(forceID).equals(date) ||\n+                    track.getAssignedForceReturnDates().get(forceID).isBefore(date)) &&\n+                    !track.getStickyForces().contains(forceID)) {\n+                forcesToUndeploy.add(forceID);\n+            }\n+        }\n+\n+        for (int forceID : forcesToUndeploy) {\n+            track.unassignForce(forceID);\n+        }\n+    }\n+    \n+    /**\n+     * Processes an ignored dynamic scenario - locates it on one of the tracks\n+     * and calls the standared 'ignored scenario' routine.\n+     * @return Whether or not we also need to get rid of the backing scenario from the campaign\n+     */\n+    public static boolean processIgnoredScenario(AtBDynamicScenario scenario, StratconCampaignState campaignState) {\n+        for (StratconTrackState track : campaignState.getTracks()) {\n+            if (track.getBackingScenariosMap().containsKey(scenario.getId())) {\n+                return processIgnoredScenario(track.getBackingScenariosMap().get(scenario.getId()), campaignState);\n+            }\n+        }\n+        \n+        return true;\n+    }\n+    \n+\n+    /**\n+     * Processes an ignored Stratcon scenario\n+     * @return Whether or not we also need to get rid of the backing scenario from the campaign\n+     */\n+    public static boolean processIgnoredScenario(StratconScenario scenario, StratconCampaignState campaignState) {\n+        for (StratconTrackState track : campaignState.getTracks()) {\n+            if (track.getScenarios().containsKey(scenario.getCoords())) {\n+                // subtract VP if scenario is 'required'\n+                if (scenario.isRequiredScenario()) {\n+                    campaignState.updateVictoryPoints(-1);\n+                }\n+                \n+                track.removeScenario(scenario);\n+\n+                StratconFacility localFacility = track.getFacility(scenario.getCoords());\n+                if (localFacility != null) {\n+                    // if the ignored scenario was on top of an allied facility\n+                    // then it'll get captured, and the player will possibly lose a SO\n+                    if (localFacility.getOwner() == ForceAlignment.Allied) {\n+                        localFacility.setOwner(ForceAlignment.Opposing);\n+\n+                        if (localFacility.isStrategicObjective()) {\n+                            campaignState.decrementStrategicObjectiveCompletedCount();\n+                        }\n+                    }\n+                    \n+                    return true;\n+                } else {\n+                    // if it's an open-field\n+                    // move scenario towards nearest allied facility\n+                    StratconCoords closestAlliedFacilityCoords = track.findClosestAlliedFacilityCoords(scenario.getCoords());\n+\n+                    if (closestAlliedFacilityCoords != null) {\n+                        StratconCoords newCoords = scenario.getCoords().translate(scenario.getCoords().direction(closestAlliedFacilityCoords));\n+                        scenario.setCoords(newCoords);\n+                        \n+                        int daysForward = Math.min(1, track.getDeploymentTime());\n+                        \n+                        scenario.setDeploymentDate(scenario.getDeploymentDate().plusDays(daysForward));\n+                        scenario.setActionDate(scenario.getActionDate().plusDays(daysForward));\n+                        scenario.setReturnDate(scenario.getReturnDate().plusDays(daysForward));\n+                        \n+                        // refresh the scenario's position on the track\n+                        track.addScenario(scenario);\n+                        \n+                        // TODO: Write some functionality to \"copy\" a scenario's \n+                        // bot forces over\n+                        /*StratconFacility facility = track.getFacility(newCoords);\n+\n+                        if (facility != null) {\n+                            ScenarioTemplate template = StratconScenarioFactory.getFacilityScenario(true);\n+                            scenario = generateScenario(campaignState.getCa, contract, track, forceID, coords, template);\n+                            setupFacilityScenario(scenario, facility);\n+                        }*/\n+\n+                        // TODO: if the allied facility is in the new coords, replace this scenario\n+                        // with a facility defense, with the opfor coming directly from all hostiles assigned to this scenario\n+\n+                        scenario.setCurrentState(ScenarioState.UNRESOLVED);\n+                        return false;\n+                    } else {\n+                        // TODO: if there's no allied facilities here, add its forces to track reinforcement pool\n+                        return true;\n+                    }\n+                }\n+            }\n+        }\n+        \n+        // if we couldn't find the scenario on any tracks, then let's just \n+        // rid of any underlying AtB scenarios as well\n+        return true;\n+    }\n+\n+    public void startup() {\n+        MekHQ.registerHandler(this);\n+    }\n+\n+    /**\n+     * Event handler for the new day event.\n+     */\n+    @Subscribe\n+    public void handleNewDay(NewDayEvent ev) {\n+    \t// don't do any of this if StratCon isn't turned on\n+    \tif (!ev.getCampaign().getCampaignOptions().getUseStratCon()) {\n+    \t\treturn;\n+    \t}\n+    \t\n+        boolean isMonday = ev.getCampaign().getLocalDate().getDayOfWeek() == DayOfWeek.MONDAY;\n+\n+\n+        // run scenario generation routine for every track attached to an active contract\n+        for (AtBContract contract : ev.getCampaign().getActiveAtBContracts()) {\n+            StratconCampaignState campaignState = ((AtBContract) contract).getStratconCampaignState();\n+\n+            if (campaignState != null) {\n+                for (StratconTrackState track : contract.getStratconCampaignState().getTracks()) {\n+                    cleanupPhantomScenarios(track);\n+                    \n+                    // loop through scenarios - if we haven't deployed in time, fail it and apply consequences\n+                    for (StratconScenario scenario : track.getScenarios().values()) {\n+                        if (scenario.getDeploymentDate().isBefore(ev.getCampaign().getLocalDate())) {\n+                            processIgnoredScenario(scenario, campaignState);\n+                        }\n+                    }\n+\n+                    // on monday, generate new scenarios and decay modifiers\n+                    if (isMonday) {\n+                        generateScenariosForTrack(ev.getCampaign(), (AtBContract) contract, track);", "originalCommit": "b36d9fa6bf982c7b833b1ac0a0473d37f6e84760", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "becffdc94075004fa3890bb36799389a48105c33", "url": "https://github.com/MegaMek/mekhq/commit/becffdc94075004fa3890bb36799389a48105c33", "message": "code review changes; data fix; stop nagging once user hits 'no' once", "committedDate": "2021-04-17T03:10:50Z", "type": "commit"}, {"oid": "a6a4efce4b27c89c9febf341c81592ee88787cf8", "url": "https://github.com/MegaMek/mekhq/commit/a6a4efce4b27c89c9febf341c81592ee88787cf8", "message": "Update MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java\n\nCo-authored-by: Justin Bowen <39067288+Windchild292@users.noreply.github.com>", "committedDate": "2021-04-17T03:53:31Z", "type": "commit"}, {"oid": "42b305cbb0d715d722da819a31eb237e14ed0a10", "url": "https://github.com/MegaMek/mekhq/commit/42b305cbb0d715d722da819a31eb237e14ed0a10", "message": "Update MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java\n\nCo-authored-by: Justin Bowen <39067288+Windchild292@users.noreply.github.com>", "committedDate": "2021-04-17T03:53:43Z", "type": "commit"}, {"oid": "93299a0dd5c6e125c53ce8dc1d567ce0c0f3698e", "url": "https://github.com/MegaMek/mekhq/commit/93299a0dd5c6e125c53ce8dc1d567ce0c0f3698e", "message": "Update MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java\n\nCo-authored-by: Justin Bowen <39067288+Windchild292@users.noreply.github.com>", "committedDate": "2021-04-17T03:57:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTMwMzQwNw==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r615303407", "bodyText": "Spelling of empty", "author": "Windchild292", "createdAt": "2021-04-17T20:55:44Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -200,23 +203,25 @@ public static StratconScenario generateScenarioForExistingForces(StratconCoords\n                 scenario.addPrimaryForce(forceID);\n             }\n         }\n-        \n-        // this is theoretically possible if forceIDs is passed in as null - not likely in practice\n+\n+        // this is theoretically possible if forceIDs is empy - not likely in practice", "originalCommit": "becffdc94075004fa3890bb36799389a48105c33", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5d41cf620c66d5c182617d9f87fbf3c6e955a8dd", "url": "https://github.com/MegaMek/mekhq/commit/5d41cf620c66d5c182617d9f87fbf3c6e955a8dd", "message": "last code review change; properly initialize and update strategic objective count", "committedDate": "2021-04-18T03:13:55Z", "type": "commit"}, {"oid": "4b7ca452bb9b31d0d4bdad79bf23d2fd1ccf17fb", "url": "https://github.com/MegaMek/mekhq/commit/4b7ca452bb9b31d0d4bdad79bf23d2fd1ccf17fb", "message": "fix operator precedence to avoid NPE", "committedDate": "2021-04-18T22:16:17Z", "type": "commit"}, {"oid": "00ed93ab915ff2ce2aa308583a7511706e46151b", "url": "https://github.com/MegaMek/mekhq/commit/00ed93ab915ff2ce2aa308583a7511706e46151b", "message": "more NPE protection", "committedDate": "2021-04-19T23:10:37Z", "type": "commit"}, {"oid": "c4f072fa1b346d244a7d682f0872ce7034f5d6f3", "url": "https://github.com/MegaMek/mekhq/commit/c4f072fa1b346d244a7d682f0872ce7034f5d6f3", "message": "fix scenario dates; facility generation", "committedDate": "2021-04-20T15:49:05Z", "type": "commit"}, {"oid": "430dcc10a7a51ac34fc883c6433562909a7f4822", "url": "https://github.com/MegaMek/mekhq/commit/430dcc10a7a51ac34fc883c6433562909a7f4822", "message": "remove attacker/defender from dynamic scenario description", "committedDate": "2021-04-20T15:53:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjk0MjM0OQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r616942349", "bodyText": "Just noticed that this says \"the the\"", "author": "Windchild292", "createdAt": "2021-04-20T18:34:34Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -645,14 +655,14 @@ private static void applyGlobalModifiers(StratconScenario scenario, StratconCamp\n \n     /**\n      * Applies scenario modifiers from the current track to the given scenario.\n-     * @param scenario\n-     * @param track\n      */\n-    private static void applyFacilityModifiers(StratconScenario scenario, StratconTrackState track, StratconCoords coords) {\n+    private static void applyFacilityModifiers(StratconScenario scenario, StratconTrackState track,\n+            StratconCoords coords) {\n         // loop through all the facilities on the track\n         // if a facility has been revealed, then it has a 100% chance to apply its effect\n         // if a facility has not been revealed, then it has a x% chance to apply its effect\n-        // if a facility is on the the scenario coordinates the it applies the local effects\n+        //          where x is the current \"aggro rating\"\n+        // if a facility is on the the scenario coordinates, then it applies the local effects", "originalCommit": "becffdc94075004fa3890bb36799389a48105c33", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjk0MjkxMQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r616942911", "bodyText": "This switch was indented nicely, and is no longer", "author": "Windchild292", "createdAt": "2021-04-20T18:35:27Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -703,68 +715,76 @@ private static void setAlliedForceModifier(StratconScenario scenario, AtBContrac\n \n         AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n \n-        // if an allied unit is present, then we want to make sure that it's ground units\n-        // for ground battles\n+        // if an allied unit is present, then we want to make sure that \n+        // it's ground units for ground battles\n         if (Compute.randomInt(100) <= alliedUnitOdds) {\n-            if((backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n-               (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space)) {\n-                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_ALLIED_AIR_UNITS));\n+            if ((backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere)\n+                    || (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space)) {\n+                backingScenario.addScenarioModifier(\n+                        AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_ALLIED_AIR_UNITS));\n             } else {\n-                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_ALLIED_GROUND_UNITS));\n+                backingScenario.addScenarioModifier(\n+                        AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_ALLIED_GROUND_UNITS));\n             }\n         }\n     }\n \n     /**\n-     * Set the 'attached' units modifier for the current scenario (integrated, house, liaison),\n-     * and make sure we're not deploying ground units to an air scenario\n+     * Set the 'attached' units modifier for the current scenario (integrated, house, liaison), and make\n+     * sure we're not deploying ground units to an air scenario\n+     * \n      * @param contract The scenario's contract\n      */\n     public static void setAttachedUnitsModifier(StratconScenario scenario, AtBContract contract) {\n         AtBDynamicScenario backingScenario = scenario.getBackingScenario();\n-        boolean airBattle = (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere) ||\n-                (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space);\n+        boolean airBattle = (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.LowAtmosphere)\n+                || (backingScenario.getTemplate().mapParameters.getMapLocation() == MapLocation.Space);\n \n         // if we're on cadre duty, we're getting three trainees, period\n         if (contract.getMissionType() == AtBContract.MT_CADREDUTY) {\n             if (airBattle) {\n-                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_TRAINEES_AIR));\n+                backingScenario.addScenarioModifier(\n+                        AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_TRAINEES_AIR));\n             } else {\n-                backingScenario.addScenarioModifier(AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_TRAINEES_GROUND));\n+                backingScenario.addScenarioModifier(\n+                        AtBScenarioModifier.getScenarioModifier(MekHqConstants.SCENARIO_MODIFIER_TRAINEES_GROUND));\n             }\n             return;\n         }\n \n         // if we're under non-independent command rights, a supervisor may come along\n         switch (contract.getCommandRights()) {", "originalCommit": "becffdc94075004fa3890bb36799389a48105c33", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjk0NDc4OQ==", "url": "https://github.com/MegaMek/mekhq/pull/2144#discussion_r616944789", "bodyText": "Case was nicely indented and is no longer", "author": "Windchild292", "createdAt": "2021-04-20T18:38:21Z", "path": "MekHQ/src/mekhq/campaign/stratcon/StratconRulesManager.java", "diffHunk": "@@ -933,189 +945,180 @@ public static boolean forceCompositionMatchesDeclaredUnitType(int primaryUnitTyp\n \n         return retVal;\n     }\n-    \n+\n     /**\n-     * Returns a list of individual units eligible for deployment in scenarios\n-     * that result from the lance leader having a leadership score\n+     * Returns a list of individual units eligible for deployment in scenarios that result from the\n+     * lance leader having a leadership score\n+     * \n      * @return List of unit IDs.\n      */\n     public static List<Unit> getEligibleLeadershipUnits(Campaign campaign, Set<Integer> forceIDs) {\n         List<Unit> retVal = new ArrayList<>();\n \n         // The criteria are as follows:\n-        // - unit is of a different unit type than the primary unit type of the force \n+        // - unit is of a different unit type than the primary unit type of the force\n         // - unit has a lower BV than the force's lowest BV unit\n-        \n+\n         Integer lowestBV = getLowestBV(campaign, forceIDs);\n-        \n+\n         // no units assigned, the rest is meaningless.\n         if (lowestBV == null) {\n             return retVal;\n         }\n-        \n+\n         int primaryUnitType = getPrimaryUnitType(campaign, forceIDs);\n-        \n+\n         for (Unit u : campaign.getUnits()) {\n-            if ((primaryUnitType != u.getEntity().getUnitType()) &&\n-                    !u.isDeployed() &&\n-                    !u.isMothballed() &&\n-                    u.isFunctional() &&\n-                    (u.getEntity().calculateBattleValue() < lowestBV) &&\n-                    !isUnitDeployedToStratCon(u)) {\n+            if ((primaryUnitType != u.getEntity().getUnitType()) && !u.isDeployed() && !u.isMothballed()\n+                    && u.isFunctional() && (u.getEntity().calculateBattleValue() < lowestBV)\n+                    && !isUnitDeployedToStratCon(u)) {\n                 retVal.add(u);\n             }\n         }\n \n         return retVal;\n     }\n-    \n+\n     /**\n      * Check if the unit's force (if one exists) has been deployed to a StratCon track\n      */\n     public static boolean isUnitDeployedToStratCon(Unit u) {\n         if (!u.getCampaign().getCampaignOptions().getUseStratCon()) {\n             return false;\n         }\n-        \n-        //this is a little inefficient, but probably there aren't too many active AtB contracts at a time\n-        for (AtBContract contract : u.getCampaign().getActiveAtBContracts()) {\n-            if (contract.getStratconCampaignState().isForceDeployedHere(u.getForceId())) {\n-                return true;\n-            }\n-        }\n-        \n-        return false;\n+\n+        // this is a little inefficient, but probably there aren't too many active AtB\n+        // contracts at a time\n+        return u.getCampaign().getActiveAtBContracts().stream().\n+            anyMatch(contract -> contract.getStratconCampaignState().isForceDeployedHere(u.getForceId()));\n     }\n-    \n+\n     /**\n      * Given a campaign and a list of force IDs, calculate the unit with the lowest BV.\n      */\n     private static Integer getLowestBV(Campaign campaign, Set<Integer> forceIDs) {\n         Integer lowestBV = null;\n-        \n+\n         for (int forceID : forceIDs) {\n             Force force = campaign.getForce(forceID);\n             if (force == null) {\n                 continue;\n             }\n-            \n+\n             for (UUID id : force.getUnits()) {\n                 if (campaign.getUnit(id) == null) {\n                     continue;\n                 }\n-                \n+\n                 int currentBV = campaign.getUnit(id).getEntity().calculateBattleValue();\n-                \n+\n                 if ((lowestBV == null) || (currentBV < lowestBV)) {\n                     lowestBV = currentBV;\n                 }\n             }\n         }\n-        \n+\n         return lowestBV;\n     }\n-    \n+\n     /**\n      * Calculates the majority unit type for the forces given the IDs.\n      */\n     private static int getPrimaryUnitType(Campaign campaign, Set<Integer> forceIDs) {\n         Map<Integer, Integer> unitTypeBuckets = new TreeMap<>();\n         int biggestBucketID = -1;\n         int biggestBucketCount = 0;\n-        \n+\n         for (int forceID : forceIDs) {\n             Force force = campaign.getForce(forceID);\n             if (force == null) {\n                 continue;\n             }\n-        \n+\n             for (UUID id : force.getUnits()) {\n                 Unit unit = campaign.getUnit(id);\n-                if ((unit == null) || \n-                        (unit.getEntity() == null)) {\n+                if ((unit == null) || (unit.getEntity() == null)) {\n                     continue;\n                 }\n-                \n+\n                 int unitType = unit.getEntity().getUnitType();\n-    \n+\n                 unitTypeBuckets.merge(unitType, 1, (oldCount, value) -> oldCount + value);\n-                \n+\n                 if (unitTypeBuckets.get(unitType) > biggestBucketCount) {\n                     biggestBucketCount = unitTypeBuckets.get(unitType);\n                     biggestBucketID = unitType;\n                 }\n             }\n         }\n-        \n+\n         return biggestBucketID;\n     }\n \n     /**\n      * Determines what rules to use when deploying a force for reinforcements to the given track.\n      */\n-    public static ReinforcementEligibilityType getReinforcementType(int forceID,\n-            StratconTrackState trackState, Campaign campaign) {\n+    public static ReinforcementEligibilityType getReinforcementType(int forceID, StratconTrackState trackState,\n+            Campaign campaign) {\n         // if the force is currently deployed to the track, it'll be able to deploy \"for free\"\n         if (trackState.isForceDeployed(forceID)) {\n             return ReinforcementEligibilityType.ChainedScenario;\n         }\n \n         // if the force is in 'fight' stance, it'll be able to deploy using 'fight lance' rules\n-        if (campaign.getLances().containsKey(forceID) &&\n-                campaign.getLances().get(forceID).getRole() == AtBLanceRole.FIGHTING) {\n+        if (campaign.getLances().containsKey(forceID)\n+                && (campaign.getLances().get(forceID).getRole() == AtBLanceRole.FIGHTING)) {\n             return ReinforcementEligibilityType.FightLance;\n         }\n \n         // if the force is deployed elsewhere, it cannot be deployed as reinforcements\n-        for (Contract contract : campaign.getActiveContracts()) {\n-            if(contract instanceof AtBContract) {\n-                for(StratconTrackState track : ((AtBContract) contract).getStratconCampaignState().getTracks()) {\n-                    if(track != trackState && track.getAssignedForceCoords().containsKey(forceID)) {\n-                        return ReinforcementEligibilityType.None;\n-                    }\n+        for (AtBContract contract : campaign.getActiveAtBContracts()) {\n+            for (StratconTrackState track : contract.getStratconCampaignState().getTracks()) {\n+                if (track != trackState && track.getAssignedForceCoords().containsKey(forceID)) {\n+                    return ReinforcementEligibilityType.None;\n                 }\n             }\n         }\n \n         // otherwise, the force requires support points / vps to deploy\n         return ReinforcementEligibilityType.SupportPoint;\n     }\n-    \n+\n     /**\n-     * Given a track and the current campaign state, and if the player is deploying\n-     * a force or not, figure out the odds of a scenario occuring.\n+     * Given a track and the current campaign state, and if the player is deploying a force or not,\n+     * figure out the odds of a scenario occuring.\n      */\n-    public static int calculateScenarioOdds(StratconTrackState track, \n-            AtBContract contract, boolean playerDeployingForce) {\n+    public static int calculateScenarioOdds(StratconTrackState track, AtBContract contract,\n+            boolean playerDeployingForce) {\n         // rules:\n         // rout morale: 0%\n         // very low morale: -10% when deploying forces to track, 0% attack\n         // low morale: -5%\n         // high morale: +5%\n         // invincible: special case, let's do +10% for now\n         int moraleModifier = 0;\n-        \n+\n         switch (contract.getMoraleLevel()) {\n-            case AtBContract.MORALE_ROUT:\n+        case AtBContract.MORALE_ROUT:", "originalCommit": "becffdc94075004fa3890bb36799389a48105c33", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8f2b011e6fcb788a9acc3415d7de07adb15093f5", "url": "https://github.com/MegaMek/mekhq/commit/8f2b011e6fcb788a9acc3415d7de07adb15093f5", "message": "start of conversion work;traitors modifier", "committedDate": "2019-02-04T03:23:36Z", "type": "commit"}, {"oid": "2b006fe4c490c19e970559d0c9846f1f6d07b512", "url": "https://github.com/MegaMek/mekhq/commit/2b006fe4c490c19e970559d0c9846f1f6d07b512", "message": "re-organization of map parameters editor GUI elements", "committedDate": "2019-02-04T04:21:11Z", "type": "commit"}, {"oid": "d39d775c7934976b08a81a1d2edbb9e20a9407f2", "url": "https://github.com/MegaMek/mekhq/commit/d39d775c7934976b08a81a1d2edbb9e20a9407f2", "message": "bring back the GUI", "committedDate": "2019-02-09T02:34:30Z", "type": "commit"}, {"oid": "ed100193cc650f5ac04c56a7abb8e3c0e9287a31", "url": "https://github.com/MegaMek/mekhq/commit/ed100193cc650f5ac04c56a7abb8e3c0e9287a31", "message": "some kind of changes", "committedDate": "2019-02-20T04:21:23Z", "type": "commit"}, {"oid": "beff8d6e16e3ebf35b43018966c79d7266cd2e9e", "url": "https://github.com/MegaMek/mekhq/commit/beff8d6e16e3ebf35b43018966c79d7266cd2e9e", "message": "xml file", "committedDate": "2019-02-20T04:23:05Z", "type": "commit"}, {"oid": "a0c1cbf9746ed9486f08ce4aa2376828e846c786", "url": "https://github.com/MegaMek/mekhq/commit/a0c1cbf9746ed9486f08ce4aa2376828e846c786", "message": "merge", "committedDate": "2019-02-27T02:45:56Z", "type": "commit"}, {"oid": "3002e321d67f944da3a051a049f0706c0e353aa0", "url": "https://github.com/MegaMek/mekhq/commit/3002e321d67f944da3a051a049f0706c0e353aa0", "message": "merge from upstream", "committedDate": "2019-03-05T01:50:34Z", "type": "commit"}, {"oid": "da85b156e4ab3f5e4b1bd3783ac33eb9e9061692", "url": "https://github.com/MegaMek/mekhq/commit/da85b156e4ab3f5e4b1bd3783ac33eb9e9061692", "message": "data structure work", "committedDate": "2019-03-06T02:36:04Z", "type": "commit"}, {"oid": "02eaa59b26a6918c85c6a0f8bc0c4c61b8c4be44", "url": "https://github.com/MegaMek/mekhq/commit/02eaa59b26a6918c85c6a0f8bc0c4c61b8c4be44", "message": "work on generating scenarios for specific track", "committedDate": "2019-03-11T04:00:10Z", "type": "commit"}, {"oid": "1361faac1a1638f4fed4180a9b8c3da7ec858600", "url": "https://github.com/MegaMek/mekhq/commit/1361faac1a1638f4fed4180a9b8c3da7ec858600", "message": "hook it up, kind of", "committedDate": "2019-03-12T02:39:04Z", "type": "commit"}, {"oid": "d9c015f7eebb7fcb878ab224ef7cdb333c40c082", "url": "https://github.com/MegaMek/mekhq/commit/d9c015f7eebb7fcb878ab224ef7cdb333c40c082", "message": "force assignment UI prototype", "committedDate": "2019-03-14T03:34:41Z", "type": "commit"}, {"oid": "7ffb5e0f83c012cad73876bf150ef32f56c76b73", "url": "https://github.com/MegaMek/mekhq/commit/7ffb5e0f83c012cad73876bf150ef32f56c76b73", "message": "modifiers cleanup; template definitions;", "committedDate": "2019-03-16T20:47:25Z", "type": "commit"}, {"oid": "6c2482610d2a11cccdfe72c9606ee194e49402c9", "url": "https://github.com/MegaMek/mekhq/commit/6c2482610d2a11cccdfe72c9606ee194e49402c9", "message": "scenario generation work", "committedDate": "2019-03-16T20:48:10Z", "type": "commit"}, {"oid": "1f6a53e6a3f47800520f360cc265677d76482452", "url": "https://github.com/MegaMek/mekhq/commit/1f6a53e6a3f47800520f360cc265677d76482452", "message": "fix a few bugs; status display work", "committedDate": "2019-03-19T01:53:58Z", "type": "commit"}, {"oid": "2a512ee2ea5770ee5929e2575199a867d1c9bc53", "url": "https://github.com/MegaMek/mekhq/commit/2a512ee2ea5770ee5929e2575199a867d1c9bc53", "message": "merge from upstream", "committedDate": "2019-03-26T20:01:46Z", "type": "commit"}, {"oid": "00c8977dd68492ebb7402b34ec7191536b938e42", "url": "https://github.com/MegaMek/mekhq/commit/00c8977dd68492ebb7402b34ec7191536b938e42", "message": "continued scenario lance assignment work", "committedDate": "2019-03-26T20:23:10Z", "type": "commit"}, {"oid": "75b54ef0067943db752205cc1ca52243fc434bcf", "url": "https://github.com/MegaMek/mekhq/commit/75b54ef0067943db752205cc1ca52243fc434bcf", "message": "merge from upstream again", "committedDate": "2019-03-29T01:36:20Z", "type": "commit"}, {"oid": "9219265f88e5c6026a2fdd88f4f7a751dfaae7dc", "url": "https://github.com/MegaMek/mekhq/commit/9219265f88e5c6026a2fdd88f4f7a751dfaae7dc", "message": "scenarios can be generated and populated in campaign", "committedDate": "2019-03-29T02:47:27Z", "type": "commit"}, {"oid": "2c2de0142671ba13541316a77fe8a12af646cecd", "url": "https://github.com/MegaMek/mekhq/commit/2c2de0142671ba13541316a77fe8a12af646cecd", "message": "initial map generation and facilities", "committedDate": "2019-04-04T01:26:12Z", "type": "commit"}, {"oid": "0067a4f142adedaa83b8e2769d97e3c0f1c29ebb", "url": "https://github.com/MegaMek/mekhq/commit/0067a4f142adedaa83b8e2769d97e3c0f1c29ebb", "message": "introduce scrolling", "committedDate": "2019-04-04T02:46:01Z", "type": "commit"}, {"oid": "6ea9e04272831dbc115c41697b52b1eb3390705b", "url": "https://github.com/MegaMek/mekhq/commit/6ea9e04272831dbc115c41697b52b1eb3390705b", "message": "minor bugfixes", "committedDate": "2019-04-07T04:16:30Z", "type": "commit"}, {"oid": "05f3bd0c91af4b7f527f00dde4136f498dc5bc72", "url": "https://github.com/MegaMek/mekhq/commit/05f3bd0c91af4b7f527f00dde4136f498dc5bc72", "message": "proper clicked hex detection", "committedDate": "2019-04-08T03:36:22Z", "type": "commit"}, {"oid": "34f5dfffab4318e94903fece9dbf49dd1ee475c7", "url": "https://github.com/MegaMek/mekhq/commit/34f5dfffab4318e94903fece9dbf49dd1ee475c7", "message": "continues work on track gui and rules", "committedDate": "2019-04-24T02:53:00Z", "type": "commit"}, {"oid": "b1c2e0f95fc8ad45080d9962da602d5fe815c34b", "url": "https://github.com/MegaMek/mekhq/commit/b1c2e0f95fc8ad45080d9962da602d5fe815c34b", "message": "hook up stratcon rules manager to mekhq event bus", "committedDate": "2019-04-27T02:02:27Z", "type": "commit"}, {"oid": "b096ba273a611ad2e3598c6a06bc1af06ea4d0de", "url": "https://github.com/MegaMek/mekhq/commit/b096ba273a611ad2e3598c6a06bc1af06ea4d0de", "message": "stratcon UI hookup, opfor gen tweak", "committedDate": "2019-04-30T01:36:50Z", "type": "commit"}, {"oid": "010c98666e4ac607bc3b88f20162d7cb3681c9da", "url": "https://github.com/MegaMek/mekhq/commit/010c98666e4ac607bc3b88f20162d7cb3681c9da", "message": "remove force gen files from tracking - we're not there yet", "committedDate": "2019-04-30T01:38:34Z", "type": "commit"}, {"oid": "ce41cc5131062d618beaa7a2187c850d6ceafd33", "url": "https://github.com/MegaMek/mekhq/commit/ce41cc5131062d618beaa7a2187c850d6ceafd33", "message": "undo misguided PR cleanup attempt", "committedDate": "2019-04-30T01:45:37Z", "type": "commit"}, {"oid": "40d913c50565266806a55edff963dee320cc818a", "url": "https://github.com/MegaMek/mekhq/commit/40d913c50565266806a55edff963dee320cc818a", "message": "fill transports feature", "committedDate": "2019-05-02T04:25:55Z", "type": "commit"}, {"oid": "b314c9237116b73f9577ba07cdc0395549d034c5", "url": "https://github.com/MegaMek/mekhq/commit/b314c9237116b73f9577ba07cdc0395549d034c5", "message": "branch switch commit", "committedDate": "2019-05-04T15:57:28Z", "type": "commit"}, {"oid": "6f180f04dabdd9901dc392b093561514eb2e84cc", "url": "https://github.com/MegaMek/mekhq/commit/6f180f04dabdd9901dc392b093561514eb2e84cc", "message": "merge from upstream", "committedDate": "2019-05-04T16:17:55Z", "type": "commit"}, {"oid": "1eb5e5e68a3e2dc18e45bbcbf389ced95adfe26a", "url": "https://github.com/MegaMek/mekhq/commit/1eb5e5e68a3e2dc18e45bbcbf389ced95adfe26a", "message": "save campaign/track state; wreck force assignment", "committedDate": "2019-05-04T20:23:17Z", "type": "commit"}, {"oid": "119ff411ebb80f91b83b3fe139bb911a79048b3d", "url": "https://github.com/MegaMek/mekhq/commit/119ff411ebb80f91b83b3fe139bb911a79048b3d", "message": "scenario setup work", "committedDate": "2019-05-12T19:48:11Z", "type": "commit"}, {"oid": "d8e5bc6c41ffe84e44589aae3aebe25c1f17b351", "url": "https://github.com/MegaMek/mekhq/commit/d8e5bc6c41ffe84e44589aae3aebe25c1f17b351", "message": "scenario revision", "committedDate": "2019-05-12T19:49:21Z", "type": "commit"}, {"oid": "e3730251c13d09bc7590f51ec188ac65ab389930", "url": "https://github.com/MegaMek/mekhq/commit/e3730251c13d09bc7590f51ec188ac65ab389930", "message": "work on scenario-force assignment UI", "committedDate": "2019-05-22T04:14:43Z", "type": "commit"}, {"oid": "51c97445bff743f816ff18c06a7673499594d6c3", "url": "https://github.com/MegaMek/mekhq/commit/51c97445bff743f816ff18c06a7673499594d6c3", "message": "continued work on scenario management UI", "committedDate": "2019-05-25T02:44:26Z", "type": "commit"}, {"oid": "60e60c9ba5f632271cc33add4d8ace6dcfe6d045", "url": "https://github.com/MegaMek/mekhq/commit/60e60c9ba5f632271cc33add4d8ace6dcfe6d045", "message": "continued work on scenario setup wizard", "committedDate": "2019-05-28T02:55:28Z", "type": "commit"}, {"oid": "dab956974e7055371c0020f9d1d54c3aaf61911f", "url": "https://github.com/MegaMek/mekhq/commit/dab956974e7055371c0020f9d1d54c3aaf61911f", "message": "reworked track scenario generation mechanism", "committedDate": "2019-06-03T04:05:09Z", "type": "commit"}, {"oid": "c26e5e0db0c52cfa91a3d5bdab811460a4fb1308", "url": "https://github.com/MegaMek/mekhq/commit/c26e5e0db0c52cfa91a3d5bdab811460a4fb1308", "message": "continued work on scenario wizard", "committedDate": "2019-06-04T03:41:26Z", "type": "commit"}, {"oid": "cbf0f560af31182b951cdbe06998547e3136ba62", "url": "https://github.com/MegaMek/mekhq/commit/cbf0f560af31182b951cdbe06998547e3136ba62", "message": "continued work on scenario UI, force assignment UI", "committedDate": "2019-06-10T03:17:50Z", "type": "commit"}, {"oid": "53ee7e4c34af94d47e00e768fdd3ed809c5574c7", "url": "https://github.com/MegaMek/mekhq/commit/53ee7e4c34af94d47e00e768fdd3ed809c5574c7", "message": "continued scenario initiation work", "committedDate": "2019-06-12T01:46:33Z", "type": "commit"}, {"oid": "cb18b864aa1050d347304d2322226aeea2e041a8", "url": "https://github.com/MegaMek/mekhq/commit/cb18b864aa1050d347304d2322226aeea2e041a8", "message": "merge from upstream", "committedDate": "2019-06-12T01:46:56Z", "type": "commit"}, {"oid": "d510c6b6a30f16e360636e792d18d3becf837886", "url": "https://github.com/MegaMek/mekhq/commit/d510c6b6a30f16e360636e792d18d3becf837886", "message": "minor refactoring", "committedDate": "2019-06-14T02:48:14Z", "type": "commit"}, {"oid": "2548381ed541547a775bb8c96fd53802087ec9aa", "url": "https://github.com/MegaMek/mekhq/commit/2548381ed541547a775bb8c96fd53802087ec9aa", "message": "merge from upstream", "committedDate": "2019-06-21T03:58:58Z", "type": "commit"}, {"oid": "7cee4084438dfdf568a92b27466a5a84a5cb181e", "url": "https://github.com/MegaMek/mekhq/commit/7cee4084438dfdf568a92b27466a5a84a5cb181e", "message": "higher rated units get nastier opposing force", "committedDate": "2019-06-21T04:08:06Z", "type": "commit"}, {"oid": "c05d07e4dc8673c7df8d71eef88c89e0387c95ba", "url": "https://github.com/MegaMek/mekhq/commit/c05d07e4dc8673c7df8d71eef88c89e0387c95ba", "message": "fix unit test error", "committedDate": "2019-06-21T04:22:36Z", "type": "commit"}, {"oid": "b6220b4c3043256a1f32bf9955f039f7263b84bf", "url": "https://github.com/MegaMek/mekhq/commit/b6220b4c3043256a1f32bf9955f039f7263b84bf", "message": "facility detection and fog of war rendering", "committedDate": "2019-06-22T03:28:18Z", "type": "commit"}, {"oid": "5c411e38ff5dd0b4942d32be2643122f1b1bf581", "url": "https://github.com/MegaMek/mekhq/commit/5c411e38ff5dd0b4942d32be2643122f1b1bf581", "message": "facility effects on scenarios", "committedDate": "2019-06-27T01:40:10Z", "type": "commit"}, {"oid": "ed6a5c015aa33d0bffdcd3297b9482ce600eb146", "url": "https://github.com/MegaMek/mekhq/commit/ed6a5c015aa33d0bffdcd3297b9482ce600eb146", "message": "merge from upstream", "committedDate": "2020-04-12T02:33:14Z", "type": "commit"}, {"oid": "c5f485755e2c65d1d1f3db2c00d2d9f7142a3bf0", "url": "https://github.com/MegaMek/mekhq/commit/c5f485755e2c65d1d1f3db2c00d2d9f7142a3bf0", "message": "merge changes", "committedDate": "2020-04-18T02:57:27Z", "type": "commit"}, {"oid": "ca46ea5005775f38ad56f98bfb8899a187571e49", "url": "https://github.com/MegaMek/mekhq/commit/ca46ea5005775f38ad56f98bfb8899a187571e49", "message": "merge from upstream", "committedDate": "2020-06-03T15:30:19Z", "type": "commit"}, {"oid": "90b1edef6bca6a34a61905e876e1a9ccc99f1d90", "url": "https://github.com/MegaMek/mekhq/commit/90b1edef6bca6a34a61905e876e1a9ccc99f1d90", "message": "scenario info display", "committedDate": "2020-06-04T02:47:31Z", "type": "commit"}, {"oid": "b2f014d250be5b4b75ed3f765f10ee1781ab96ae", "url": "https://github.com/MegaMek/mekhq/commit/b2f014d250be5b4b75ed3f765f10ee1781ab96ae", "message": "merge from upstream", "committedDate": "2020-06-24T02:21:32Z", "type": "commit"}, {"oid": "40c89f94b058acf8796c4731c39b8f833d7c6383", "url": "https://github.com/MegaMek/mekhq/commit/40c89f94b058acf8796c4731c39b8f833d7c6383", "message": "facility serialization/deserialization", "committedDate": "2020-06-24T03:56:49Z", "type": "commit"}, {"oid": "2bd7638ed4cc2ad5bc80e4b1bc78ff091c318a87", "url": "https://github.com/MegaMek/mekhq/commit/2bd7638ed4cc2ad5bc80e4b1bc78ff091c318a87", "message": "merge from upstream", "committedDate": "2020-07-13T04:06:30Z", "type": "commit"}, {"oid": "d4f035c262d3d9ea7b7f5e935a5807bf5275aa91", "url": "https://github.com/MegaMek/mekhq/commit/d4f035c262d3d9ea7b7f5e935a5807bf5275aa91", "message": "merge from upstream", "committedDate": "2020-08-09T03:08:38Z", "type": "commit"}, {"oid": "47bdb33a424d625cbc21f118fb2cbbb991a3a534", "url": "https://github.com/MegaMek/mekhq/commit/47bdb33a424d625cbc21f118fb2cbbb991a3a534", "message": "adapt to LocalDate", "committedDate": "2020-08-09T03:19:28Z", "type": "commit"}, {"oid": "04c2cab223fc0bfcd7133038b424e66fc757c42a", "url": "https://github.com/MegaMek/mekhq/commit/04c2cab223fc0bfcd7133038b424e66fc757c42a", "message": "facilities work", "committedDate": "2020-08-10T04:18:26Z", "type": "commit"}, {"oid": "7d75eb4397f10e70ac200c41756a1f773684df7f", "url": "https://github.com/MegaMek/mekhq/commit/7d75eb4397f10e70ac200c41756a1f773684df7f", "message": "facilities work", "committedDate": "2020-08-10T04:19:25Z", "type": "commit"}, {"oid": "f5bdaa45729f60badc36f970dd525e48664e3f22", "url": "https://github.com/MegaMek/mekhq/commit/f5bdaa45729f60badc36f970dd525e48664e3f22", "message": "facility definitions", "committedDate": "2020-08-13T15:28:33Z", "type": "commit"}, {"oid": "5830ebef6d2f671d0b152f328436ab36bcddacf4", "url": "https://github.com/MegaMek/mekhq/commit/5830ebef6d2f671d0b152f328436ab36bcddacf4", "message": "merge from upstream", "committedDate": "2020-08-25T00:32:16Z", "type": "commit"}, {"oid": "1d2b3930a61dc792dea1b5f36d9ac4af2e323a13", "url": "https://github.com/MegaMek/mekhq/commit/1d2b3930a61dc792dea1b5f36d9ac4af2e323a13", "message": "merge from upstream", "committedDate": "2020-08-25T00:32:31Z", "type": "commit"}, {"oid": "c8622590fef59265a5a8c4f68676a4a628d0fc0a", "url": "https://github.com/MegaMek/mekhq/commit/c8622590fef59265a5a8c4f68676a4a628d0fc0a", "message": "multiple bug fixes and hookup to actual campaign", "committedDate": "2020-08-27T03:17:49Z", "type": "commit"}, {"oid": "7c1cd7308506e3cfa39c65651559e1b1ae757fc3", "url": "https://github.com/MegaMek/mekhq/commit/7c1cd7308506e3cfa39c65651559e1b1ae757fc3", "message": "base attack turret fix", "committedDate": "2020-08-29T02:13:44Z", "type": "commit"}, {"oid": "72a6f700191fc36aa736859540341f7f878bf7c0", "url": "https://github.com/MegaMek/mekhq/commit/72a6f700191fc36aa736859540341f7f878bf7c0", "message": "facility work", "committedDate": "2020-08-29T02:14:22Z", "type": "commit"}, {"oid": "338875e93808bca372b7bf799729c5feee2a0805", "url": "https://github.com/MegaMek/mekhq/commit/338875e93808bca372b7bf799729c5feee2a0805", "message": "modifier sorting; pirates", "committedDate": "2020-09-03T03:34:18Z", "type": "commit"}, {"oid": "5954e05bf453b23de7df73fd15a20f2109f07411", "url": "https://github.com/MegaMek/mekhq/commit/5954e05bf453b23de7df73fd15a20f2109f07411", "message": "Facility display details", "committedDate": "2020-09-03T03:58:14Z", "type": "commit"}, {"oid": "3b8d31674d03c41607269e6cd4ebdf291913517e", "url": "https://github.com/MegaMek/mekhq/commit/3b8d31674d03c41607269e6cd4ebdf291913517e", "message": "logic shuffling for better scenario generation", "committedDate": "2020-09-05T05:09:48Z", "type": "commit"}, {"oid": "8f7cacb26f1b55e7dcb1fac49cbd8d64460ea0dd", "url": "https://github.com/MegaMek/mekhq/commit/8f7cacb26f1b55e7dcb1fac49cbd8d64460ea0dd", "message": "scenario resolution processing; facility work", "committedDate": "2020-09-09T04:02:01Z", "type": "commit"}, {"oid": "935339ac1b799e58664d736142b2a1fa0d9e4263", "url": "https://github.com/MegaMek/mekhq/commit/935339ac1b799e58664d736142b2a1fa0d9e4263", "message": "merge from upstream", "committedDate": "2020-09-09T04:06:07Z", "type": "commit"}, {"oid": "b5f62207ac027d7857fae4cc73ce2dff6a3e7986", "url": "https://github.com/MegaMek/mekhq/commit/b5f62207ac027d7857fae4cc73ce2dff6a3e7986", "message": "data fixes; force undeployment by date;", "committedDate": "2020-09-11T05:09:19Z", "type": "commit"}, {"oid": "1122e2fe046c853f40e1110c6093f0eefdde1984", "url": "https://github.com/MegaMek/mekhq/commit/1122e2fe046c853f40e1110c6093f0eefdde1984", "message": "facility capture logic;data adjustments", "committedDate": "2020-09-13T04:36:55Z", "type": "commit"}, {"oid": "a8da6abdf7b238e9c31360c563b546454dfa6932", "url": "https://github.com/MegaMek/mekhq/commit/a8da6abdf7b238e9c31360c563b546454dfa6932", "message": "merge from upstream", "committedDate": "2020-09-13T04:40:57Z", "type": "commit"}, {"oid": "dd96cc44c302577c273d7217bcf9cf3ce4ba60d2", "url": "https://github.com/MegaMek/mekhq/commit/dd96cc44c302577c273d7217bcf9cf3ce4ba60d2", "message": "crew skill upgrader fix", "committedDate": "2020-09-16T04:34:18Z", "type": "commit"}, {"oid": "d1381bb1817578d6d5f66c4c4b5edab6a14f6a92", "url": "https://github.com/MegaMek/mekhq/commit/d1381bb1817578d6d5f66c4c4b5edab6a14f6a92", "message": "UI status updates; 'business' logic for scenario completion", "committedDate": "2020-09-16T04:34:59Z", "type": "commit"}, {"oid": "98a91fa604e9ca1916f3ec874b625e4c7daa0acd", "url": "https://github.com/MegaMek/mekhq/commit/98a91fa604e9ca1916f3ec874b625e4c7daa0acd", "message": "merge from upstream", "committedDate": "2020-09-17T01:27:25Z", "type": "commit"}, {"oid": "1f90f88f35da48f7e4989bbafe2d1cfb3422691f", "url": "https://github.com/MegaMek/mekhq/commit/1f90f88f35da48f7e4989bbafe2d1cfb3422691f", "message": "contract def data structure", "committedDate": "2020-09-18T04:17:37Z", "type": "commit"}, {"oid": "0b9be5a0621a7ae6487c99c7283b8a56156382f5", "url": "https://github.com/MegaMek/mekhq/commit/0b9be5a0621a7ae6487c99c7283b8a56156382f5", "message": "pre-merge commit", "committedDate": "2020-10-07T01:37:18Z", "type": "commit"}, {"oid": "525709d116eff593d4f59f282e8c3987f2874ca0", "url": "https://github.com/MegaMek/mekhq/commit/525709d116eff593d4f59f282e8c3987f2874ca0", "message": "pre-merge commit #2", "committedDate": "2020-10-07T01:37:49Z", "type": "commit"}, {"oid": "04f10ee4b7f5bf57284109439ec1ab178b15857e", "url": "https://github.com/MegaMek/mekhq/commit/04f10ee4b7f5bf57284109439ec1ab178b15857e", "message": "merge from upstream", "committedDate": "2020-10-07T01:41:18Z", "type": "commit"}, {"oid": "9b2480ab8a6dae907cb39e7bc26c14d58008a29e", "url": "https://github.com/MegaMek/mekhq/commit/9b2480ab8a6dae907cb39e7bc26c14d58008a29e", "message": "save point", "committedDate": "2020-10-11T04:42:38Z", "type": "commit"}, {"oid": "8a0fc7ed3dbcebdfc4fb2f1568103826f13e547f", "url": "https://github.com/MegaMek/mekhq/commit/8a0fc7ed3dbcebdfc4fb2f1568103826f13e547f", "message": "enough of this is not api bullcrap", "committedDate": "2020-10-11T04:43:12Z", "type": "commit"}, {"oid": "811836628b1ff80c8c86ef6abc9391e4d87c8d6c", "url": "https://github.com/MegaMek/mekhq/commit/811836628b1ff80c8c86ef6abc9391e4d87c8d6c", "message": "initial implementation of objective/facility seeding", "committedDate": "2020-10-13T02:54:38Z", "type": "commit"}, {"oid": "c226cc5a53f38e58e8b048be85dccb533736798f", "url": "https://github.com/MegaMek/mekhq/commit/c226cc5a53f38e58e8b048be85dccb533736798f", "message": "objective/facility seeding; ui polish", "committedDate": "2020-10-14T05:02:21Z", "type": "commit"}, {"oid": "c05474e28b7ab5a902b2fb355a3e6426ac7e2b6b", "url": "https://github.com/MegaMek/mekhq/commit/c05474e28b7ab5a902b2fb355a3e6426ac7e2b6b", "message": "contract definitions;polish;bugfixes", "committedDate": "2020-10-16T03:22:26Z", "type": "commit"}, {"oid": "998ab0faf85804f17cc7444ae1b46c2591b5db1f", "url": "https://github.com/MegaMek/mekhq/commit/998ab0faf85804f17cc7444ae1b46c2591b5db1f", "message": "merge from upstream", "committedDate": "2020-10-16T03:34:03Z", "type": "commit"}, {"oid": "684430e9f6ce53a568f213ae32f086a32ab91637", "url": "https://github.com/MegaMek/mekhq/commit/684430e9f6ce53a568f213ae32f086a32ab91637", "message": "Delete unitQuirksOverride.xml\n\nIncorrectly added file", "committedDate": "2020-10-16T03:59:45Z", "type": "commit"}, {"oid": "1a8ba7ed6bc7fd6819faf37a4188d64c91627e5b", "url": "https://github.com/MegaMek/mekhq/commit/1a8ba7ed6bc7fd6819faf37a4188d64c91627e5b", "message": "gm-reveal map; fixes for save/loading showstopper", "committedDate": "2020-10-17T04:50:20Z", "type": "commit"}, {"oid": "7d274efef720f911457bc888276130468cfafd1d", "url": "https://github.com/MegaMek/mekhq/commit/7d274efef720f911457bc888276130468cfafd1d", "message": "merge from upstream?", "committedDate": "2020-10-17T04:50:52Z", "type": "commit"}, {"oid": "bd14ef000557e09968a47bd114523b63c2eb980d", "url": "https://github.com/MegaMek/mekhq/commit/bd14ef000557e09968a47bd114523b63c2eb980d", "message": "reroll population from actual lance; minefields; facility data fixes", "committedDate": "2020-10-20T02:52:24Z", "type": "commit"}, {"oid": "2eec6da85e021ce0398fd3d715071b7b625855ba", "url": "https://github.com/MegaMek/mekhq/commit/2eec6da85e021ce0398fd3d715071b7b625855ba", "message": "merge from upstream", "committedDate": "2020-10-23T03:15:38Z", "type": "commit"}, {"oid": "7fdf85eb07da90c2d38ddbdc33371816d0e6cd83", "url": "https://github.com/MegaMek/mekhq/commit/7fdf85eb07da90c2d38ddbdc33371816d0e6cd83", "message": "fix force assignment save bug; facility name lengthening", "committedDate": "2020-10-24T02:24:26Z", "type": "commit"}, {"oid": "644f1771b327f32c892b9254698b4e45f1c185fe", "url": "https://github.com/MegaMek/mekhq/commit/644f1771b327f32c892b9254698b4e45f1c185fe", "message": "address some lgtm issues", "committedDate": "2020-10-24T03:33:32Z", "type": "commit"}, {"oid": "da4960f3f74426d8b7fac101e5947a7f91e281e4", "url": "https://github.com/MegaMek/mekhq/commit/da4960f3f74426d8b7fac101e5947a7f91e281e4", "message": "template fixes; modifier application fixes; deployment return check fix; improved force deployment visibility", "committedDate": "2020-10-25T05:15:05Z", "type": "commit"}, {"oid": "dfca32fc2a15a2908cd4f1277261d416fcad1f00", "url": "https://github.com/MegaMek/mekhq/commit/dfca32fc2a15a2908cd4f1277261d416fcad1f00", "message": "merge from upstream", "committedDate": "2020-10-28T01:14:06Z", "type": "commit"}, {"oid": "b9e6b9df3069d1ec2579f74a54cbfb175e2a19b7", "url": "https://github.com/MegaMek/mekhq/commit/b9e6b9df3069d1ec2579f74a54cbfb175e2a19b7", "message": "stop modifier doubling", "committedDate": "2020-10-28T01:15:01Z", "type": "commit"}, {"oid": "05d025d9f01b9a070f8f630adc10441d58429381", "url": "https://github.com/MegaMek/mekhq/commit/05d025d9f01b9a070f8f630adc10441d58429381", "message": "data fixes; hook up missed scenario method", "committedDate": "2020-10-28T02:19:24Z", "type": "commit"}, {"oid": "93020d1d72af448bc71977f8839da19ae34336ef", "url": "https://github.com/MegaMek/mekhq/commit/93020d1d72af448bc71977f8839da19ae34336ef", "message": "tokenization; other stuff I don't remember", "committedDate": "2020-11-03T03:02:30Z", "type": "commit"}, {"oid": "24c2199bd396e7e059f3a3123c060fce92c04726", "url": "https://github.com/MegaMek/mekhq/commit/24c2199bd396e7e059f3a3123c060fce92c04726", "message": "merge from upstream", "committedDate": "2020-12-01T02:41:10Z", "type": "commit"}, {"oid": "6fe11ed3dea3b240bc594dd3153526f8fa1efcd1", "url": "https://github.com/MegaMek/mekhq/commit/6fe11ed3dea3b240bc594dd3153526f8fa1efcd1", "message": "merge from upstream", "committedDate": "2020-12-22T22:15:50Z", "type": "commit"}]}