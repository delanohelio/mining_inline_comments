{"pr_number": 5007, "pr_title": "FISH-788 Support sub-directories for MPCONFIG SecretDirConfigSource. #5006", "pr_createdAt": "2020-11-25T14:33:33Z", "pr_url": "https://github.com/payara/Payara/pull/5007", "timeline": [{"oid": "f2795e2a87b59f7d53772f2996d2611f92f5f5c1", "url": "https://github.com/payara/Payara/commit/f2795e2a87b59f7d53772f2996d2611f92f5f5c1", "message": "Support sub-directories for MPCONFIG SecretDirConfigSource. #5006\n\nThis adds support for mounting your secrets in subdirectories to create scopes.\nThe relative path is used as the property name. A secret file \"SECRET_DIR/foo/bar/secret\"\nwill be available as MPCONFIG value \"foo.bar.secret\".\n\nYou can still put a file \"foo.bar.secret\" in \"SECRET_DIR\" and have the same value available.\nIf both are present, the topmost file will be picked.\n\nMix'n'match isn't supported. Retrieving \"foo.bar.secret\" from \"SECRET_DIR/foo/bar.secret\"\nwill not work reliably when added at runtime.", "committedDate": "2020-11-25T14:28:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUxNjYwNg==", "url": "https://github.com/payara/Payara/pull/5007#discussion_r530516606", "bodyText": "Personally, I would avoid using wildcard imports - however, I'll leave it to a consensus", "author": "AlanRoth", "createdAt": "2020-11-25T16:52:11Z", "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/SecretsDirConfigSource.java", "diffHunk": "@@ -43,12 +43,10 @@\n \n import java.io.File;\n import java.io.IOException;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n+import java.nio.file.*;", "originalCommit": "f2795e2a87b59f7d53772f2996d2611f92f5f5c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDYxMjAzNA==", "url": "https://github.com/payara/Payara/pull/5007#discussion_r530612034", "bodyText": "Oh that was IntelliJ automagic. Happy to switch back again.", "author": "poikilotherm", "createdAt": "2020-11-25T19:55:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUxNjYwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDk3OTAyOA==", "url": "https://github.com/payara/Payara/pull/5007#discussion_r530979028", "bodyText": "Done with 74288cb", "author": "poikilotherm", "createdAt": "2020-11-26T11:57:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUxNjYwNg=="}], "type": "inlineReview"}, {"oid": "74288cbe744d64f82088a717663c822dcf8462f6", "url": "https://github.com/payara/Payara/commit/74288cbe744d64f82088a717663c822dcf8462f6", "message": "Revert glob import from java.nio and java.util introduced in f2795e2a.", "committedDate": "2020-11-26T11:56:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTExMzc5OQ==", "url": "https://github.com/payara/Payara/pull/5007#discussion_r531113799", "bodyText": "I might be mistaken but I think proper thread-safety would require using a single map with an entry class holding the three fields. Otherwise the individual maps could be updated inconsistently. At the very least this makes it very hard to reason about if this would still be correct.", "author": "jbee", "createdAt": "2020-11-26T15:49:17Z", "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/SecretsDirConfigSource.java", "diffHunk": "@@ -65,9 +70,10 @@\n     private Path secretsDir;\n     private ConcurrentHashMap<String, String> properties;\n     private ConcurrentHashMap<String, FileTime> storedModifiedTimes;\n+    private ConcurrentHashMap<String, Path> storedPaths;", "originalCommit": "74288cbe744d64f82088a717663c822dcf8462f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQzNTgxNg==", "url": "https://github.com/payara/Payara/pull/5007#discussion_r531435816", "bodyText": "Ok, will create a small inner class for this.\nCurious: why should this be more thread safe?", "author": "poikilotherm", "createdAt": "2020-11-27T08:01:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTExMzc5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTYyOTg1NQ==", "url": "https://github.com/payara/Payara/pull/5007#discussion_r531629855", "bodyText": "The concurrent map only makes updating entries an atomic operation. So you can update map1 while another thread is reading map1 (updated) and map2 (not yet updated) so the picture this thread sees is only partially updated and generally must be considered inconsistent. In most cases such inconsistencies are exactly what we cannot have and avoiding it is what we mean when we say it is thread-safe. If we have one map with an entry with 3 fields updating these 3 is \"atomic\" and no other thread can observe one field already updated while the other fields have not been updated yet (given we don't mutate in place but work with immutable entry instances). For the same reason get + put isn't a good idea as essentially in the meantime the situation you did read might no longer be valid. This disappears when using compute or computeIfAbsent.", "author": "jbee", "createdAt": "2020-11-27T14:22:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTExMzc5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzgzNzEwMA==", "url": "https://github.com/payara/Payara/pull/5007#discussion_r563837100", "bodyText": "This has been taken care of.", "author": "poikilotherm", "createdAt": "2021-01-25T15:59:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTExMzc5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTExNjMyOA==", "url": "https://github.com/payara/Payara/pull/5007#discussion_r531116328", "bodyText": "As this would run every time a miss occurs and continue to do so in case such a property does indeed not exist I wonder if this should not leave an \"empty\" entry behind so we do remember this is a miss. In connection with making it a map of a record with 3 fields such \"empty\" entries are simply entries where the value is null and where time modified is the moment we insert the entry for the first time.", "author": "jbee", "createdAt": "2020-11-26T15:53:39Z", "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/SecretsDirConfigSource.java", "diffHunk": "@@ -97,28 +103,32 @@ public String getValue(String property) {\n         String result = properties.get(property);\n         if (result != null) {\n             try {\n-                // check the last modified time\n+                // check existence (secret mount might have gone away) and the last modified time\n                 FileTime ft = storedModifiedTimes.get(property);\n-                Path path = Paths.get(secretsDir.toString(), property);\n+                Path path = storedPaths.get(property);\n                 if (Files.exists(path) && Files.getLastModifiedTime(path).compareTo(ft) > 0) {\n-                    // file  has been modified since last check\n-                    result = readFile(property);\n+                    // file has been modified since last check, re-read content\n+                    result = readFile(path);\n                     storedModifiedTimes.put(property, Files.getLastModifiedTime(path));\n                     properties.put(property, result);\n                 }\n             } catch (IOException ex) {\n-                Logger.getLogger(SecretsDirConfigSource.class.getName()).log(Level.SEVERE, null, ex);\n+                Logger.getLogger(SecretsDirConfigSource.class.getName()).log(Level.SEVERE, \"Unable to read file in the directory\", ex);\n             }\n         } else {\n             // check whether there is a file there now as there wasn't before\n-            Path path = Paths.get(secretsDir.toString(), property);\n-            if (Files.exists(path) && Files.isRegularFile(path) && Files.isReadable(path)) {\n+            // --> the list of possible paths is used \"first match, first serve\".", "originalCommit": "74288cbe744d64f82088a717663c822dcf8462f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQzODA2Mg==", "url": "https://github.com/payara/Payara/pull/5007#discussion_r531438062", "bodyText": "I'm not sure what you are trying to do with that information. A value that had no property file on disk before is always a miss in the map cache, returning null, leading to execution of this else branch.", "author": "poikilotherm", "createdAt": "2020-11-27T08:07:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTExNjMyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTYzNTIxNg==", "url": "https://github.com/payara/Payara/pull/5007#discussion_r531635216", "bodyText": "Yeah it depends on what we want. If we want to make sure we \"see\" added files as soon as they are written we need to check for it which makes me think that the best way to do update at all is not checking but registering a file watcher that is watching the secret dir directory for changes and updates the map as they occur. No per request checks needed any more reducing the file IO to just the IO actually needed.", "author": "jbee", "createdAt": "2020-11-27T14:33:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTExNjMyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzgzNzY1Mg==", "url": "https://github.com/payara/Payara/pull/5007#discussion_r563837652", "bodyText": "The file watcher has been implemented.", "author": "poikilotherm", "createdAt": "2021-01-25T16:00:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTExNjMyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTExODk3Mg==", "url": "https://github.com/payara/Payara/pull/5007#discussion_r531118972", "bodyText": "I don't think that updating individual entries \"on demand\" should their origin file be modified is a good way to update. It is hard to reason about, inefficient and potentially creates \"phantom entries\" in case an entry was removed from a file. I think this kind of works but is yet another constellation to reason about. I'd much prefer updating all properties of a file as soon as we detect that the file is outdated.", "author": "jbee", "createdAt": "2020-11-26T15:58:06Z", "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/SecretsDirConfigSource.java", "diffHunk": "@@ -97,28 +103,32 @@ public String getValue(String property) {\n         String result = properties.get(property);\n         if (result != null) {\n             try {\n-                // check the last modified time\n+                // check existence (secret mount might have gone away) and the last modified time\n                 FileTime ft = storedModifiedTimes.get(property);\n-                Path path = Paths.get(secretsDir.toString(), property);\n+                Path path = storedPaths.get(property);\n                 if (Files.exists(path) && Files.getLastModifiedTime(path).compareTo(ft) > 0) {\n-                    // file  has been modified since last check\n-                    result = readFile(property);\n+                    // file has been modified since last check, re-read content\n+                    result = readFile(path);\n                     storedModifiedTimes.put(property, Files.getLastModifiedTime(path));\n                     properties.put(property, result);", "originalCommit": "74288cbe744d64f82088a717663c822dcf8462f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQyOTQ0OQ==", "url": "https://github.com/payara/Payara/pull/5007#discussion_r531429449", "bodyText": "Left this comment before I realised that each file is a single property and forgot to remove it later.", "author": "jbee", "createdAt": "2020-11-27T07:46:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTExODk3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQzNjI4MQ==", "url": "https://github.com/payara/Payara/pull/5007#discussion_r531436281", "bodyText": "OK I'll resolve this comment then.", "author": "poikilotherm", "createdAt": "2020-11-27T08:02:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTExODk3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTEyMjI5OA==", "url": "https://github.com/payara/Payara/pull/5007#discussion_r531122298", "bodyText": "This should use Files.readAllBytes to create a new String", "author": "jbee", "createdAt": "2020-11-26T16:04:08Z", "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/SecretsDirConfigSource.java", "diffHunk": "@@ -143,39 +153,49 @@ private void findFile() {\n         }\n     }\n \n-    private String readFile(String name) {\n+    private String readFile(Path file) throws IOException {\n         String result = null;\n-        if (Files.exists(secretsDir) && Files.isDirectory(secretsDir) && Files.isReadable(secretsDir)) {\n-            try {\n-                Path file = Paths.get(secretsDir.toString(), name);\n-                if (Files.exists(file) && Files.isReadable(file)) {\n-                    StringBuilder collector = new StringBuilder();\n-                    for (String line : Files.readAllLines(file)) {\n-                        collector.append(line);\n-                    }\n-                    result = collector.toString();\n-                }\n-            } catch (IOException ex) {\n-                Logger.getLogger(SecretsDirConfigSource.class.getName()).log(Level.SEVERE, null, ex);\n+        if (Files.exists(file) && Files.isRegularFile(file) && Files.isReadable(file)) {\n+            StringBuilder collector = new StringBuilder();\n+            for (String line : Files.readAllLines(file)) {\n+                collector.append(line);\n             }\n+            result = collector.toString();", "originalCommit": "74288cbe744d64f82088a717663c822dcf8462f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQzODUyMQ==", "url": "https://github.com/payara/Payara/pull/5007#discussion_r531438521", "bodyText": "OK will look into it. \ud83d\ude3a", "author": "poikilotherm", "createdAt": "2020-11-27T08:08:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTEyMjI5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzgzODAxMw==", "url": "https://github.com/payara/Payara/pull/5007#discussion_r563838013", "bodyText": "This has been taken care of.", "author": "poikilotherm", "createdAt": "2021-01-25T16:00:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTEyMjI5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTEyMzU1Mw==", "url": "https://github.com/payara/Payara/pull/5007#discussion_r531123553", "bodyText": "to be thread-safe get should be avoided and computeIfAbseent should take its place.", "author": "jbee", "createdAt": "2020-11-26T16:06:35Z", "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/SecretsDirConfigSource.java", "diffHunk": "@@ -97,28 +103,32 @@ public String getValue(String property) {\n         String result = properties.get(property);\n         if (result != null) {\n             try {\n-                // check the last modified time\n+                // check existence (secret mount might have gone away) and the last modified time\n                 FileTime ft = storedModifiedTimes.get(property);\n-                Path path = Paths.get(secretsDir.toString(), property);\n+                Path path = storedPaths.get(property);", "originalCommit": "74288cbe744d64f82088a717663c822dcf8462f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQzNjEwMw==", "url": "https://github.com/payara/Payara/pull/5007#discussion_r531436103", "bodyText": "\"Noice\". Didn't knew about computeIfAbsent.", "author": "poikilotherm", "createdAt": "2020-11-27T08:02:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTEyMzU1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzgzOTIyNw==", "url": "https://github.com/payara/Payara/pull/5007#discussion_r563839227", "bodyText": "Outdated, as the properties are stored in an inner class now.", "author": "poikilotherm", "createdAt": "2021-01-25T16:02:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTEyMzU1Mw=="}], "type": "inlineReview"}, {"oid": "2a6f8c385456c0482079a5948fe1ac964c95071f", "url": "https://github.com/payara/Payara/commit/2a6f8c385456c0482079a5948fe1ac964c95071f", "message": "Add first draft of complete rewrite of the SecretsDirConfigSource moving to DirConfigSource. #5006", "committedDate": "2020-11-30T18:35:06Z", "type": "commit"}, {"oid": "dceb4c70a8b5242849c9ef044d79103f22b21f49", "url": "https://github.com/payara/Payara/commit/dceb4c70a8b5242849c9ef044d79103f22b21f49", "message": "Remove SecretsDirConfigSource, replaced with DirConfigSource. #5006", "committedDate": "2020-11-30T18:36:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgxNjY5Ng==", "url": "https://github.com/payara/Payara/pull/5007#discussion_r532816696", "bodyText": "This might as well be moved to an anonymous definition inside initializePropertiesFromPath(). Had been moved here for potential reuse, but didn't happen.", "author": "poikilotherm", "createdAt": "2020-11-30T18:40:37Z", "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.microprofile.config.source;\n+\n+import fish.payara.nucleus.executorservice.PayaraExecutorService;\n+import org.eclipse.microprofile.config.spi.ConfigSource;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.*;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.FileTime;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Collections.unmodifiableMap;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;\n+\n+/**\n+ * Config Source that reads properties from files from a directory\n+ * where filename is the property name and file contents is the property value.\n+ * @since 5.2020.7\n+ */\n+public class DirConfigSource extends PayaraConfigSource implements ConfigSource {\n+\n+    class DirProperty {\n+        String property;\n+        FileTime lastModifiedTime;\n+        Path path;\n+        int pathDepth;\n+        \n+        DirProperty(String property, FileTime lastModifiedTime, Path path, int pathDepth) {\n+            this.property = property;\n+            this.lastModifiedTime = lastModifiedTime;\n+            this.path = path;\n+            this.pathDepth = pathDepth;\n+        }\n+    }\n+    \n+    class DirPropertyWatcher implements Runnable {\n+    \n+        private Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n+        WatchService watcher = FileSystems.getDefault().newWatchService();\n+        ConcurrentHashMap<WatchKey, Path> keys = new ConcurrentHashMap<>();\n+        \n+        DirPropertyWatcher(Path topmostDir) throws IOException {\n+            if (Files.exists(topmostDir) && Files.isDirectory(topmostDir) && Files.isReadable(topmostDir)) {\n+                registerAll(topmostDir);\n+            } else {\n+                throw new IOException(\"Given directory '\"+topmostDir+\"' is no directory or cannot be read.\");\n+            }\n+        }\n+        \n+        void registerAll(Path dir) throws IOException {\n+            // register file watchers recursively (they don't attach to subdirs...)\n+            Files.walkFileTree(dir, new SimpleFileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException\n+                {\n+                    register(dir);\n+                    return FileVisitResult.CONTINUE;\n+                }\n+            });\n+        }\n+        \n+        void register(Path dir) throws IOException {\n+            WatchKey key = dir.register(watcher, ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY);\n+            keys.putIfAbsent(key, dir);\n+        }\n+        \n+        @Override\n+        public void run() {\n+            while (true) {\n+                // wait infinitely until we receive an event (or the executor is shutting down)\n+                WatchKey key;\n+                try {\n+                    key = watcher.take();\n+                } catch (InterruptedException ex) {\n+                    return;\n+                }\n+                \n+                Path workDir = keys.get(key);\n+                for (WatchEvent<?> event : key.pollEvents()) {\n+                    WatchEvent.Kind<?> kind = event.kind();\n+            \n+                    @SuppressWarnings(\"unchecked\")\n+                    WatchEvent<Path> ev = (WatchEvent<Path>) event;\n+                    Path fileName = ev.context();\n+                    Path path = workDir.resolve(fileName);\n+            \n+                    try {\n+                        // new directory to be watched and traversed\n+                        if (kind == ENTRY_CREATE && Files.isDirectory(path) && !Files.isHidden(path) && Files.isReadable(path)) {\n+                            registerAll(path);\n+                            initializePropertiesFromPath(path);\n+                        }\n+                        // new or updated file found\n+                        if (Files.isRegularFile(path) && (kind == ENTRY_CREATE || kind == ENTRY_MODIFY)) {\n+                            updatePropertyFromPath(path, Files.readAttributes(path, BasicFileAttributes.class));\n+                        }\n+                        if (Files.isRegularFile(path) && (kind == ENTRY_DELETE)) {\n+                            properties.remove(parsePropertyNameFromPath(path));\n+                        }\n+                    } catch (IOException e) {\n+                        logger.log(Level.SEVERE, \"Could not process event '\"+kind+\"' on '\"+path+\"'\", e);\n+                    }\n+                }\n+    \n+                // Reset key (obligatory) and remove from set if directory no longer accessible\n+                boolean valid = key.reset();\n+                if (!valid) {\n+                    keys.remove(key);\n+                    \n+                    // all directories became inaccessible, even topmostDir!\n+                    if (keys.isEmpty()) break;\n+                }\n+            }\n+        }\n+    }\n+    \n+    class DirConfigFileVisitor extends SimpleFileVisitor<Path> {\n+        /**\n+         * Ignore hidden directories\n+         */\n+        @Override\n+        public FileVisitResult preVisitDirectory(java.nio.file.Path dir, BasicFileAttributes attrs) throws IOException {\n+            return dir.toFile().isHidden() ? FileVisitResult.SKIP_SUBTREE : FileVisitResult.CONTINUE;\n+        }\n+    \n+        @Override\n+        public FileVisitResult visitFile(Path path, BasicFileAttributes mainAtts) throws IOException {\n+            updatePropertyFromPath(path, mainAtts);\n+            return FileVisitResult.CONTINUE;\n+        }\n+    }", "originalCommit": "dceb4c70a8b5242849c9ef044d79103f22b21f49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0b3233a9421f57328d191b59bdc64e40be99e160", "url": "https://github.com/payara/Payara/commit/0b3233a9421f57328d191b59bdc64e40be99e160", "message": "DirConfigSource: fix imports, add equals() and hashCode() to DirProperty. #5006", "committedDate": "2020-11-30T20:44:44Z", "type": "commit"}, {"oid": "a76cdb4428ef048916ea11b8f269044f8b89f813", "url": "https://github.com/payara/Payara/commit/a76cdb4428ef048916ea11b8f269044f8b89f813", "message": "DirConfigSource: move initial tree walker to anonymous declaration.", "committedDate": "2020-11-30T20:48:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg0ODQ5NQ==", "url": "https://github.com/payara/Payara/pull/5007#discussion_r532848495", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                class DirProperty {\n          \n          \n            \n                private static final class DirProperty {", "author": "jbee", "createdAt": "2020-11-30T19:34:24Z", "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.microprofile.config.source;\n+\n+import fish.payara.nucleus.executorservice.PayaraExecutorService;\n+import org.eclipse.microprofile.config.spi.ConfigSource;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.*;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.FileTime;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Collections.unmodifiableMap;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;\n+\n+/**\n+ * Config Source that reads properties from files from a directory\n+ * where filename is the property name and file contents is the property value.\n+ * @since 5.2020.7\n+ */\n+public class DirConfigSource extends PayaraConfigSource implements ConfigSource {\n+\n+    class DirProperty {", "originalCommit": "dceb4c70a8b5242849c9ef044d79103f22b21f49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQxMjcyOA==", "url": "https://github.com/payara/Payara/pull/5007#discussion_r537412728", "bodyText": "Done, but still scope package to allow easier testing.", "author": "poikilotherm", "createdAt": "2020-12-07T10:56:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg0ODQ5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg0ODgzNA==", "url": "https://github.com/payara/Payara/pull/5007#discussion_r532848834", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                class DirPropertyWatcher implements Runnable {\n          \n          \n            \n                private static final class DirPropertyWatcher implements Runnable {", "author": "jbee", "createdAt": "2020-11-30T19:34:56Z", "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.microprofile.config.source;\n+\n+import fish.payara.nucleus.executorservice.PayaraExecutorService;\n+import org.eclipse.microprofile.config.spi.ConfigSource;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.*;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.FileTime;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Collections.unmodifiableMap;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;\n+\n+/**\n+ * Config Source that reads properties from files from a directory\n+ * where filename is the property name and file contents is the property value.\n+ * @since 5.2020.7\n+ */\n+public class DirConfigSource extends PayaraConfigSource implements ConfigSource {\n+\n+    class DirProperty {\n+        String property;\n+        FileTime lastModifiedTime;\n+        Path path;\n+        int pathDepth;\n+        \n+        DirProperty(String property, FileTime lastModifiedTime, Path path, int pathDepth) {\n+            this.property = property;\n+            this.lastModifiedTime = lastModifiedTime;\n+            this.path = path;\n+            this.pathDepth = pathDepth;\n+        }\n+    }\n+    \n+    class DirPropertyWatcher implements Runnable {", "originalCommit": "dceb4c70a8b5242849c9ef044d79103f22b21f49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQxNDAyMQ==", "url": "https://github.com/payara/Payara/pull/5007#discussion_r537414021", "bodyText": "Final ok, but remain in package scope and non-static. Package makes testing easier. Static wouldn't allow us to access the update methods or the DirConfigSource class attributes.", "author": "poikilotherm", "createdAt": "2020-12-07T10:58:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg0ODgzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzgzOTYxOQ==", "url": "https://github.com/payara/Payara/pull/5007#discussion_r563839619", "bodyText": "Done as described.", "author": "poikilotherm", "createdAt": "2021-01-25T16:03:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg0ODgzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg0OTA1Mw==", "url": "https://github.com/payara/Payara/pull/5007#discussion_r532849053", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    private Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n          \n          \n            \n                    private static final Logger logger = Logger.getLogger(DirConfigSource.class.getName());", "author": "jbee", "createdAt": "2020-11-30T19:35:16Z", "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.microprofile.config.source;\n+\n+import fish.payara.nucleus.executorservice.PayaraExecutorService;\n+import org.eclipse.microprofile.config.spi.ConfigSource;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.*;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.FileTime;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Collections.unmodifiableMap;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;\n+\n+/**\n+ * Config Source that reads properties from files from a directory\n+ * where filename is the property name and file contents is the property value.\n+ * @since 5.2020.7\n+ */\n+public class DirConfigSource extends PayaraConfigSource implements ConfigSource {\n+\n+    class DirProperty {\n+        String property;\n+        FileTime lastModifiedTime;\n+        Path path;\n+        int pathDepth;\n+        \n+        DirProperty(String property, FileTime lastModifiedTime, Path path, int pathDepth) {\n+            this.property = property;\n+            this.lastModifiedTime = lastModifiedTime;\n+            this.path = path;\n+            this.pathDepth = pathDepth;\n+        }\n+    }\n+    \n+    class DirPropertyWatcher implements Runnable {\n+    \n+        private Logger logger = Logger.getLogger(DirConfigSource.class.getName());", "originalCommit": "dceb4c70a8b5242849c9ef044d79103f22b21f49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQxNDM5Mw==", "url": "https://github.com/payara/Payara/pull/5007#discussion_r537414393", "bodyText": "Final OK. Static: can't do that in non-static inner class.", "author": "poikilotherm", "createdAt": "2020-12-07T10:58:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg0OTA1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzgzOTc5OQ==", "url": "https://github.com/payara/Payara/pull/5007#discussion_r563839799", "bodyText": "Done as described.", "author": "poikilotherm", "createdAt": "2021-01-25T16:03:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg0OTA1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg1MTI4MQ==", "url": "https://github.com/payara/Payara/pull/5007#discussion_r532851281", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    WatchService watcher = FileSystems.getDefault().newWatchService();\n          \n          \n            \n                    private final WatchService watcher = FileSystems.getDefault().newWatchService();", "author": "jbee", "createdAt": "2020-11-30T19:39:01Z", "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.microprofile.config.source;\n+\n+import fish.payara.nucleus.executorservice.PayaraExecutorService;\n+import org.eclipse.microprofile.config.spi.ConfigSource;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.*;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.FileTime;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Collections.unmodifiableMap;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;\n+\n+/**\n+ * Config Source that reads properties from files from a directory\n+ * where filename is the property name and file contents is the property value.\n+ * @since 5.2020.7\n+ */\n+public class DirConfigSource extends PayaraConfigSource implements ConfigSource {\n+\n+    class DirProperty {\n+        String property;\n+        FileTime lastModifiedTime;\n+        Path path;\n+        int pathDepth;\n+        \n+        DirProperty(String property, FileTime lastModifiedTime, Path path, int pathDepth) {\n+            this.property = property;\n+            this.lastModifiedTime = lastModifiedTime;\n+            this.path = path;\n+            this.pathDepth = pathDepth;\n+        }\n+    }\n+    \n+    class DirPropertyWatcher implements Runnable {\n+    \n+        private Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n+        WatchService watcher = FileSystems.getDefault().newWatchService();", "originalCommit": "dceb4c70a8b5242849c9ef044d79103f22b21f49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg1MTM5MQ==", "url": "https://github.com/payara/Payara/pull/5007#discussion_r532851391", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    ConcurrentHashMap<WatchKey, Path> keys = new ConcurrentHashMap<>();\n          \n          \n            \n                    private final ConcurrentHashMap<WatchKey, Path> keys = new ConcurrentHashMap<>();", "author": "jbee", "createdAt": "2020-11-30T19:39:16Z", "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.microprofile.config.source;\n+\n+import fish.payara.nucleus.executorservice.PayaraExecutorService;\n+import org.eclipse.microprofile.config.spi.ConfigSource;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.*;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.FileTime;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Collections.unmodifiableMap;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;\n+\n+/**\n+ * Config Source that reads properties from files from a directory\n+ * where filename is the property name and file contents is the property value.\n+ * @since 5.2020.7\n+ */\n+public class DirConfigSource extends PayaraConfigSource implements ConfigSource {\n+\n+    class DirProperty {\n+        String property;\n+        FileTime lastModifiedTime;\n+        Path path;\n+        int pathDepth;\n+        \n+        DirProperty(String property, FileTime lastModifiedTime, Path path, int pathDepth) {\n+            this.property = property;\n+            this.lastModifiedTime = lastModifiedTime;\n+            this.path = path;\n+            this.pathDepth = pathDepth;\n+        }\n+    }\n+    \n+    class DirPropertyWatcher implements Runnable {\n+    \n+        private Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n+        WatchService watcher = FileSystems.getDefault().newWatchService();\n+        ConcurrentHashMap<WatchKey, Path> keys = new ConcurrentHashMap<>();", "originalCommit": "dceb4c70a8b5242849c9ef044d79103f22b21f49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg1MzAzOQ==", "url": "https://github.com/payara/Payara/pull/5007#discussion_r532853039", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    String property;\n          \n          \n            \n                    FileTime lastModifiedTime;\n          \n          \n            \n                    Path path;\n          \n          \n            \n                    int pathDepth;\n          \n          \n            \n                    final String property;\n          \n          \n            \n                    final FileTime lastModifiedTime;\n          \n          \n            \n                    final Path path;\n          \n          \n            \n                    final int pathDepth;", "author": "jbee", "createdAt": "2020-11-30T19:42:06Z", "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.microprofile.config.source;\n+\n+import fish.payara.nucleus.executorservice.PayaraExecutorService;\n+import org.eclipse.microprofile.config.spi.ConfigSource;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.*;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.FileTime;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Collections.unmodifiableMap;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;\n+\n+/**\n+ * Config Source that reads properties from files from a directory\n+ * where filename is the property name and file contents is the property value.\n+ * @since 5.2020.7\n+ */\n+public class DirConfigSource extends PayaraConfigSource implements ConfigSource {\n+\n+    class DirProperty {\n+        String property;\n+        FileTime lastModifiedTime;\n+        Path path;\n+        int pathDepth;", "originalCommit": "dceb4c70a8b5242849c9ef044d79103f22b21f49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg1NjI2Nw==", "url": "https://github.com/payara/Payara/pull/5007#discussion_r532856267", "bodyText": "just keys is a bit generic, maybe watchedFiles (by keys)?", "author": "jbee", "createdAt": "2020-11-30T19:47:17Z", "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.microprofile.config.source;\n+\n+import fish.payara.nucleus.executorservice.PayaraExecutorService;\n+import org.eclipse.microprofile.config.spi.ConfigSource;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.*;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.FileTime;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Collections.unmodifiableMap;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;\n+\n+/**\n+ * Config Source that reads properties from files from a directory\n+ * where filename is the property name and file contents is the property value.\n+ * @since 5.2020.7\n+ */\n+public class DirConfigSource extends PayaraConfigSource implements ConfigSource {\n+\n+    class DirProperty {\n+        String property;\n+        FileTime lastModifiedTime;\n+        Path path;\n+        int pathDepth;\n+        \n+        DirProperty(String property, FileTime lastModifiedTime, Path path, int pathDepth) {\n+            this.property = property;\n+            this.lastModifiedTime = lastModifiedTime;\n+            this.path = path;\n+            this.pathDepth = pathDepth;\n+        }\n+    }\n+    \n+    class DirPropertyWatcher implements Runnable {\n+    \n+        private Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n+        WatchService watcher = FileSystems.getDefault().newWatchService();\n+        ConcurrentHashMap<WatchKey, Path> keys = new ConcurrentHashMap<>();", "originalCommit": "dceb4c70a8b5242849c9ef044d79103f22b21f49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQxNDkzOA==", "url": "https://github.com/payara/Payara/pull/5007#discussion_r537414938", "bodyText": "\"watchedFileKeys\"", "author": "poikilotherm", "createdAt": "2020-12-07T10:59:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg1NjI2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg2MjUwMA==", "url": "https://github.com/payara/Payara/pull/5007#discussion_r532862500", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                class DirConfigFileVisitor extends SimpleFileVisitor<Path> {\n          \n          \n            \n                private static final class DirConfigFileVisitor extends SimpleFileVisitor<Path> {", "author": "jbee", "createdAt": "2020-11-30T19:52:44Z", "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.microprofile.config.source;\n+\n+import fish.payara.nucleus.executorservice.PayaraExecutorService;\n+import org.eclipse.microprofile.config.spi.ConfigSource;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.*;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.FileTime;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Collections.unmodifiableMap;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;\n+\n+/**\n+ * Config Source that reads properties from files from a directory\n+ * where filename is the property name and file contents is the property value.\n+ * @since 5.2020.7\n+ */\n+public class DirConfigSource extends PayaraConfigSource implements ConfigSource {\n+\n+    class DirProperty {\n+        String property;\n+        FileTime lastModifiedTime;\n+        Path path;\n+        int pathDepth;\n+        \n+        DirProperty(String property, FileTime lastModifiedTime, Path path, int pathDepth) {\n+            this.property = property;\n+            this.lastModifiedTime = lastModifiedTime;\n+            this.path = path;\n+            this.pathDepth = pathDepth;\n+        }\n+    }\n+    \n+    class DirPropertyWatcher implements Runnable {\n+    \n+        private Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n+        WatchService watcher = FileSystems.getDefault().newWatchService();\n+        ConcurrentHashMap<WatchKey, Path> keys = new ConcurrentHashMap<>();\n+        \n+        DirPropertyWatcher(Path topmostDir) throws IOException {\n+            if (Files.exists(topmostDir) && Files.isDirectory(topmostDir) && Files.isReadable(topmostDir)) {\n+                registerAll(topmostDir);\n+            } else {\n+                throw new IOException(\"Given directory '\"+topmostDir+\"' is no directory or cannot be read.\");\n+            }\n+        }\n+        \n+        void registerAll(Path dir) throws IOException {\n+            // register file watchers recursively (they don't attach to subdirs...)\n+            Files.walkFileTree(dir, new SimpleFileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException\n+                {\n+                    register(dir);\n+                    return FileVisitResult.CONTINUE;\n+                }\n+            });\n+        }\n+        \n+        void register(Path dir) throws IOException {\n+            WatchKey key = dir.register(watcher, ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY);\n+            keys.putIfAbsent(key, dir);\n+        }\n+        \n+        @Override\n+        public void run() {\n+            while (true) {\n+                // wait infinitely until we receive an event (or the executor is shutting down)\n+                WatchKey key;\n+                try {\n+                    key = watcher.take();\n+                } catch (InterruptedException ex) {\n+                    return;\n+                }\n+                \n+                Path workDir = keys.get(key);\n+                for (WatchEvent<?> event : key.pollEvents()) {\n+                    WatchEvent.Kind<?> kind = event.kind();\n+            \n+                    @SuppressWarnings(\"unchecked\")\n+                    WatchEvent<Path> ev = (WatchEvent<Path>) event;\n+                    Path fileName = ev.context();\n+                    Path path = workDir.resolve(fileName);\n+            \n+                    try {\n+                        // new directory to be watched and traversed\n+                        if (kind == ENTRY_CREATE && Files.isDirectory(path) && !Files.isHidden(path) && Files.isReadable(path)) {\n+                            registerAll(path);\n+                            initializePropertiesFromPath(path);\n+                        }\n+                        // new or updated file found\n+                        if (Files.isRegularFile(path) && (kind == ENTRY_CREATE || kind == ENTRY_MODIFY)) {\n+                            updatePropertyFromPath(path, Files.readAttributes(path, BasicFileAttributes.class));\n+                        }\n+                        if (Files.isRegularFile(path) && (kind == ENTRY_DELETE)) {\n+                            properties.remove(parsePropertyNameFromPath(path));\n+                        }\n+                    } catch (IOException e) {\n+                        logger.log(Level.SEVERE, \"Could not process event '\"+kind+\"' on '\"+path+\"'\", e);\n+                    }\n+                }\n+    \n+                // Reset key (obligatory) and remove from set if directory no longer accessible\n+                boolean valid = key.reset();\n+                if (!valid) {\n+                    keys.remove(key);\n+                    \n+                    // all directories became inaccessible, even topmostDir!\n+                    if (keys.isEmpty()) break;\n+                }\n+            }\n+        }\n+    }\n+    \n+    class DirConfigFileVisitor extends SimpleFileVisitor<Path> {", "originalCommit": "dceb4c70a8b5242849c9ef044d79103f22b21f49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mzg1NjY0NA==", "url": "https://github.com/payara/Payara/pull/5007#discussion_r563856644", "bodyText": "This is outdated, as the visitor has been moved to anonymous definition.", "author": "poikilotherm", "createdAt": "2021-01-25T16:25:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg2MjUwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM4MjY1Mw==", "url": "https://github.com/payara/Payara/pull/5007#discussion_r533382653", "bodyText": "Better to return the found dir instead of initialising the field so this method becomes independent of the class.\nIt might become a method elsewhere or a static method that accepts a Config (from MPConfig) returning the dir which then can be passed as constructor argument to initialise this class. This allows to use this class with directory coming from MP config or any other source. Normally testing would be another candidate that then uses this parameter. You could think about moving the watcher part out of the constructor into a method that is called after constructing the instance passing in the executor service.\nvoid updateUsingFileWatcher(PayaraExecutorService executorService) {\n    //...\n    executorService.submit(new DirPropertyWatcher(this.directory));\n    //...\n}\nThis would allow to not trigger this in tests while you use it when creating the list of config sources.", "author": "jbee", "createdAt": "2020-12-01T12:48:43Z", "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "diffHunk": "@@ -0,0 +1,377 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.microprofile.config.source;\n+\n+import fish.payara.nucleus.executorservice.PayaraExecutorService;\n+import org.eclipse.microprofile.config.spi.ConfigSource;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.WatchEvent;\n+import java.nio.file.WatchKey;\n+import java.nio.file.WatchService;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.FileTime;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Collections.unmodifiableMap;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;\n+\n+/**\n+ * Config Source that reads properties from files from a directory\n+ * where filename is the property name and file contents is the property value.\n+ * @since 5.2020.7\n+ */\n+public class DirConfigSource extends PayaraConfigSource implements ConfigSource {\n+\n+    class DirProperty {\n+        String property;\n+        FileTime lastModifiedTime;\n+        Path path;\n+        int pathDepth;\n+        \n+        DirProperty(String property, FileTime lastModifiedTime, Path path, int pathDepth) {\n+            this.property = property;\n+            this.lastModifiedTime = lastModifiedTime;\n+            this.path = path;\n+            this.pathDepth = pathDepth;\n+        }\n+    \n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            DirProperty that = (DirProperty) o;\n+            return pathDepth == that.pathDepth &&\n+                property.equals(that.property) &&\n+                lastModifiedTime.equals(that.lastModifiedTime) &&\n+                path.equals(that.path);\n+        }\n+    \n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(property, lastModifiedTime, path, pathDepth);\n+        }\n+    }\n+    \n+    class DirPropertyWatcher implements Runnable {\n+    \n+        private Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n+        WatchService watcher = FileSystems.getDefault().newWatchService();\n+        ConcurrentHashMap<WatchKey, Path> keys = new ConcurrentHashMap<>();\n+        \n+        DirPropertyWatcher(Path topmostDir) throws IOException {\n+            if (Files.exists(topmostDir) && Files.isDirectory(topmostDir) && Files.isReadable(topmostDir)) {\n+                registerAll(topmostDir);\n+            } else {\n+                throw new IOException(\"Given directory '\"+topmostDir+\"' is no directory or cannot be read.\");\n+            }\n+        }\n+        \n+        void registerAll(Path dir) throws IOException {\n+            // register file watchers recursively (they don't attach to subdirs...)\n+            Files.walkFileTree(dir, new SimpleFileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException\n+                {\n+                    register(dir);\n+                    return FileVisitResult.CONTINUE;\n+                }\n+            });\n+        }\n+        \n+        void register(Path dir) throws IOException {\n+            WatchKey key = dir.register(watcher, ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY);\n+            keys.putIfAbsent(key, dir);\n+        }\n+        \n+        @Override\n+        public void run() {\n+            while (true) {\n+                // wait infinitely until we receive an event (or the executor is shutting down)\n+                WatchKey key;\n+                try {\n+                    key = watcher.take();\n+                } catch (InterruptedException ex) {\n+                    return;\n+                }\n+                \n+                Path workDir = keys.get(key);\n+                for (WatchEvent<?> event : key.pollEvents()) {\n+                    WatchEvent.Kind<?> kind = event.kind();\n+            \n+                    @SuppressWarnings(\"unchecked\")\n+                    WatchEvent<Path> ev = (WatchEvent<Path>) event;\n+                    Path fileName = ev.context();\n+                    Path path = workDir.resolve(fileName);\n+            \n+                    try {\n+                        // new directory to be watched and traversed\n+                        if (kind == ENTRY_CREATE && Files.isDirectory(path) && !Files.isHidden(path) && Files.isReadable(path)) {\n+                            registerAll(path);\n+                            initializePropertiesFromPath(path);\n+                        }\n+                        // new or updated file found\n+                        if (Files.isRegularFile(path) && (kind == ENTRY_CREATE || kind == ENTRY_MODIFY)) {\n+                            updatePropertyFromPath(path, Files.readAttributes(path, BasicFileAttributes.class));\n+                        }\n+                        if (Files.isRegularFile(path) && (kind == ENTRY_DELETE)) {\n+                            properties.remove(parsePropertyNameFromPath(path));\n+                        }\n+                    } catch (IOException e) {\n+                        logger.log(Level.SEVERE, \"Could not process event '\"+kind+\"' on '\"+path+\"'\", e);\n+                    }\n+                }\n+    \n+                // Reset key (obligatory) and remove from set if directory no longer accessible\n+                boolean valid = key.reset();\n+                if (!valid) {\n+                    keys.remove(key);\n+                    \n+                    // all directories became inaccessible, even topmostDir!\n+                    if (keys.isEmpty()) break;\n+                }\n+            }\n+        }\n+    }\n+    \n+    private Path directory;\n+    private ConcurrentHashMap<String, DirProperty> properties = new ConcurrentHashMap<>();\n+    private static Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n+    \n+    public DirConfigSource(PayaraExecutorService executorService) {\n+        // get the directory from the app server config\n+        findDir();\n+        \n+        try {\n+            // create the watcher for the directory\n+            executorService.submit(new DirPropertyWatcher(this.directory));\n+            // initial loading\n+            initializePropertiesFromPath(this.directory);\n+        } catch (IOException e) {\n+            logger.log(Level.SEVERE, \"Error during setup of MicroProfile Config Directory Source\", e);\n+        }\n+    }\n+\n+    // Used for testing only with explicit dependency injection\n+    DirConfigSource(Path directory, PayaraExecutorService executorService) {\n+        super(true);\n+        this.directory = directory;\n+        try {\n+            initializePropertiesFromPath(this.directory);\n+        } catch (IOException e) {\n+            logger.log(Level.SEVERE, \"Error during setup of MicroProfile Config Directory Source\", e);\n+        }\n+    }\n+\n+    @Override\n+    public Map<String, String> getProperties() {\n+        return unmodifiableMap(properties\n+                                    .entrySet()\n+                                    .stream()\n+                                    .collect(\n+                                        Collectors.toMap(Map.Entry::getKey, e -> e.getValue().property)\n+                                    ));\n+    }\n+\n+    @Override\n+    public Set<String> getPropertyNames() {\n+        return properties.keySet();\n+    }\n+\n+    @Override\n+    public int getOrdinal() {\n+        return Integer.parseInt(configService.getMPConfig().getSecretDirOrdinality());\n+    }\n+\n+    @Override\n+    public String getValue(String property) {\n+        DirProperty result = properties.get(property);\n+        return result == null ? null : result.property;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"Directory\";\n+    }\n+\n+    private void findDir() {", "originalCommit": "a76cdb4428ef048916ea11b8f269044f8b89f813", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDExNTMxNw==", "url": "https://github.com/payara/Payara/pull/5007#discussion_r564115317", "bodyText": "I think this is done as you intended. Please feel free to re-open if not.", "author": "poikilotherm", "createdAt": "2021-01-25T23:35:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM4MjY1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM4MzI1NA==", "url": "https://github.com/payara/Payara/pull/5007#discussion_r533383254", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Path directory;\n          \n          \n            \n                private ConcurrentHashMap<String, DirProperty> properties = new ConcurrentHashMap<>();\n          \n          \n            \n                private static Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n          \n          \n            \n                private static final Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n          \n          \n            \n            \n          \n          \n            \n                private final Path directory;\n          \n          \n            \n                private final ConcurrentHashMap<String, DirProperty> properties = new ConcurrentHashMap<>();", "author": "jbee", "createdAt": "2020-12-01T12:49:40Z", "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "diffHunk": "@@ -0,0 +1,377 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.microprofile.config.source;\n+\n+import fish.payara.nucleus.executorservice.PayaraExecutorService;\n+import org.eclipse.microprofile.config.spi.ConfigSource;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.WatchEvent;\n+import java.nio.file.WatchKey;\n+import java.nio.file.WatchService;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.FileTime;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Collections.unmodifiableMap;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;\n+\n+/**\n+ * Config Source that reads properties from files from a directory\n+ * where filename is the property name and file contents is the property value.\n+ * @since 5.2020.7\n+ */\n+public class DirConfigSource extends PayaraConfigSource implements ConfigSource {\n+\n+    class DirProperty {\n+        String property;\n+        FileTime lastModifiedTime;\n+        Path path;\n+        int pathDepth;\n+        \n+        DirProperty(String property, FileTime lastModifiedTime, Path path, int pathDepth) {\n+            this.property = property;\n+            this.lastModifiedTime = lastModifiedTime;\n+            this.path = path;\n+            this.pathDepth = pathDepth;\n+        }\n+    \n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            DirProperty that = (DirProperty) o;\n+            return pathDepth == that.pathDepth &&\n+                property.equals(that.property) &&\n+                lastModifiedTime.equals(that.lastModifiedTime) &&\n+                path.equals(that.path);\n+        }\n+    \n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(property, lastModifiedTime, path, pathDepth);\n+        }\n+    }\n+    \n+    class DirPropertyWatcher implements Runnable {\n+    \n+        private Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n+        WatchService watcher = FileSystems.getDefault().newWatchService();\n+        ConcurrentHashMap<WatchKey, Path> keys = new ConcurrentHashMap<>();\n+        \n+        DirPropertyWatcher(Path topmostDir) throws IOException {\n+            if (Files.exists(topmostDir) && Files.isDirectory(topmostDir) && Files.isReadable(topmostDir)) {\n+                registerAll(topmostDir);\n+            } else {\n+                throw new IOException(\"Given directory '\"+topmostDir+\"' is no directory or cannot be read.\");\n+            }\n+        }\n+        \n+        void registerAll(Path dir) throws IOException {\n+            // register file watchers recursively (they don't attach to subdirs...)\n+            Files.walkFileTree(dir, new SimpleFileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException\n+                {\n+                    register(dir);\n+                    return FileVisitResult.CONTINUE;\n+                }\n+            });\n+        }\n+        \n+        void register(Path dir) throws IOException {\n+            WatchKey key = dir.register(watcher, ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY);\n+            keys.putIfAbsent(key, dir);\n+        }\n+        \n+        @Override\n+        public void run() {\n+            while (true) {\n+                // wait infinitely until we receive an event (or the executor is shutting down)\n+                WatchKey key;\n+                try {\n+                    key = watcher.take();\n+                } catch (InterruptedException ex) {\n+                    return;\n+                }\n+                \n+                Path workDir = keys.get(key);\n+                for (WatchEvent<?> event : key.pollEvents()) {\n+                    WatchEvent.Kind<?> kind = event.kind();\n+            \n+                    @SuppressWarnings(\"unchecked\")\n+                    WatchEvent<Path> ev = (WatchEvent<Path>) event;\n+                    Path fileName = ev.context();\n+                    Path path = workDir.resolve(fileName);\n+            \n+                    try {\n+                        // new directory to be watched and traversed\n+                        if (kind == ENTRY_CREATE && Files.isDirectory(path) && !Files.isHidden(path) && Files.isReadable(path)) {\n+                            registerAll(path);\n+                            initializePropertiesFromPath(path);\n+                        }\n+                        // new or updated file found\n+                        if (Files.isRegularFile(path) && (kind == ENTRY_CREATE || kind == ENTRY_MODIFY)) {\n+                            updatePropertyFromPath(path, Files.readAttributes(path, BasicFileAttributes.class));\n+                        }\n+                        if (Files.isRegularFile(path) && (kind == ENTRY_DELETE)) {\n+                            properties.remove(parsePropertyNameFromPath(path));\n+                        }\n+                    } catch (IOException e) {\n+                        logger.log(Level.SEVERE, \"Could not process event '\"+kind+\"' on '\"+path+\"'\", e);\n+                    }\n+                }\n+    \n+                // Reset key (obligatory) and remove from set if directory no longer accessible\n+                boolean valid = key.reset();\n+                if (!valid) {\n+                    keys.remove(key);\n+                    \n+                    // all directories became inaccessible, even topmostDir!\n+                    if (keys.isEmpty()) break;\n+                }\n+            }\n+        }\n+    }\n+    \n+    private Path directory;\n+    private ConcurrentHashMap<String, DirProperty> properties = new ConcurrentHashMap<>();\n+    private static Logger logger = Logger.getLogger(DirConfigSource.class.getName());", "originalCommit": "a76cdb4428ef048916ea11b8f269044f8b89f813", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mzg1NzYzMQ==", "url": "https://github.com/payara/Payara/pull/5007#discussion_r563857631", "bodyText": "Almost done like this. Kept directory non-final to be able to change outside of constructor.", "author": "poikilotherm", "createdAt": "2021-01-25T16:26:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM4MzI1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM4NzExNQ==", "url": "https://github.com/payara/Payara/pull/5007#discussion_r533387115", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return unmodifiableMap(properties\n          \n          \n            \n                                                .entrySet()\n          \n          \n            \n                                                .stream()\n          \n          \n            \n                                                .collect(\n          \n          \n            \n                                                    Collectors.toMap(Map.Entry::getKey, e -> e.getValue().property)\n          \n          \n            \n                                                ));\n          \n          \n            \n                    return unmodifiableMap(properties.entrySet().stream().collect(\n          \n          \n            \n                        toMap(Map.Entry::getKey, e -> e.getValue().property)));\n          \n      \n    \n    \n  \n\nneeds toMap being imported statically", "author": "jbee", "createdAt": "2020-12-01T12:56:39Z", "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "diffHunk": "@@ -0,0 +1,377 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.microprofile.config.source;\n+\n+import fish.payara.nucleus.executorservice.PayaraExecutorService;\n+import org.eclipse.microprofile.config.spi.ConfigSource;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.WatchEvent;\n+import java.nio.file.WatchKey;\n+import java.nio.file.WatchService;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.FileTime;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Collections.unmodifiableMap;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;\n+\n+/**\n+ * Config Source that reads properties from files from a directory\n+ * where filename is the property name and file contents is the property value.\n+ * @since 5.2020.7\n+ */\n+public class DirConfigSource extends PayaraConfigSource implements ConfigSource {\n+\n+    class DirProperty {\n+        String property;\n+        FileTime lastModifiedTime;\n+        Path path;\n+        int pathDepth;\n+        \n+        DirProperty(String property, FileTime lastModifiedTime, Path path, int pathDepth) {\n+            this.property = property;\n+            this.lastModifiedTime = lastModifiedTime;\n+            this.path = path;\n+            this.pathDepth = pathDepth;\n+        }\n+    \n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            DirProperty that = (DirProperty) o;\n+            return pathDepth == that.pathDepth &&\n+                property.equals(that.property) &&\n+                lastModifiedTime.equals(that.lastModifiedTime) &&\n+                path.equals(that.path);\n+        }\n+    \n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(property, lastModifiedTime, path, pathDepth);\n+        }\n+    }\n+    \n+    class DirPropertyWatcher implements Runnable {\n+    \n+        private Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n+        WatchService watcher = FileSystems.getDefault().newWatchService();\n+        ConcurrentHashMap<WatchKey, Path> keys = new ConcurrentHashMap<>();\n+        \n+        DirPropertyWatcher(Path topmostDir) throws IOException {\n+            if (Files.exists(topmostDir) && Files.isDirectory(topmostDir) && Files.isReadable(topmostDir)) {\n+                registerAll(topmostDir);\n+            } else {\n+                throw new IOException(\"Given directory '\"+topmostDir+\"' is no directory or cannot be read.\");\n+            }\n+        }\n+        \n+        void registerAll(Path dir) throws IOException {\n+            // register file watchers recursively (they don't attach to subdirs...)\n+            Files.walkFileTree(dir, new SimpleFileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException\n+                {\n+                    register(dir);\n+                    return FileVisitResult.CONTINUE;\n+                }\n+            });\n+        }\n+        \n+        void register(Path dir) throws IOException {\n+            WatchKey key = dir.register(watcher, ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY);\n+            keys.putIfAbsent(key, dir);\n+        }\n+        \n+        @Override\n+        public void run() {\n+            while (true) {\n+                // wait infinitely until we receive an event (or the executor is shutting down)\n+                WatchKey key;\n+                try {\n+                    key = watcher.take();\n+                } catch (InterruptedException ex) {\n+                    return;\n+                }\n+                \n+                Path workDir = keys.get(key);\n+                for (WatchEvent<?> event : key.pollEvents()) {\n+                    WatchEvent.Kind<?> kind = event.kind();\n+            \n+                    @SuppressWarnings(\"unchecked\")\n+                    WatchEvent<Path> ev = (WatchEvent<Path>) event;\n+                    Path fileName = ev.context();\n+                    Path path = workDir.resolve(fileName);\n+            \n+                    try {\n+                        // new directory to be watched and traversed\n+                        if (kind == ENTRY_CREATE && Files.isDirectory(path) && !Files.isHidden(path) && Files.isReadable(path)) {\n+                            registerAll(path);\n+                            initializePropertiesFromPath(path);\n+                        }\n+                        // new or updated file found\n+                        if (Files.isRegularFile(path) && (kind == ENTRY_CREATE || kind == ENTRY_MODIFY)) {\n+                            updatePropertyFromPath(path, Files.readAttributes(path, BasicFileAttributes.class));\n+                        }\n+                        if (Files.isRegularFile(path) && (kind == ENTRY_DELETE)) {\n+                            properties.remove(parsePropertyNameFromPath(path));\n+                        }\n+                    } catch (IOException e) {\n+                        logger.log(Level.SEVERE, \"Could not process event '\"+kind+\"' on '\"+path+\"'\", e);\n+                    }\n+                }\n+    \n+                // Reset key (obligatory) and remove from set if directory no longer accessible\n+                boolean valid = key.reset();\n+                if (!valid) {\n+                    keys.remove(key);\n+                    \n+                    // all directories became inaccessible, even topmostDir!\n+                    if (keys.isEmpty()) break;\n+                }\n+            }\n+        }\n+    }\n+    \n+    private Path directory;\n+    private ConcurrentHashMap<String, DirProperty> properties = new ConcurrentHashMap<>();\n+    private static Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n+    \n+    public DirConfigSource(PayaraExecutorService executorService) {\n+        // get the directory from the app server config\n+        findDir();\n+        \n+        try {\n+            // create the watcher for the directory\n+            executorService.submit(new DirPropertyWatcher(this.directory));\n+            // initial loading\n+            initializePropertiesFromPath(this.directory);\n+        } catch (IOException e) {\n+            logger.log(Level.SEVERE, \"Error during setup of MicroProfile Config Directory Source\", e);\n+        }\n+    }\n+\n+    // Used for testing only with explicit dependency injection\n+    DirConfigSource(Path directory, PayaraExecutorService executorService) {\n+        super(true);\n+        this.directory = directory;\n+        try {\n+            initializePropertiesFromPath(this.directory);\n+        } catch (IOException e) {\n+            logger.log(Level.SEVERE, \"Error during setup of MicroProfile Config Directory Source\", e);\n+        }\n+    }\n+\n+    @Override\n+    public Map<String, String> getProperties() {\n+        return unmodifiableMap(properties\n+                                    .entrySet()\n+                                    .stream()\n+                                    .collect(\n+                                        Collectors.toMap(Map.Entry::getKey, e -> e.getValue().property)\n+                                    ));", "originalCommit": "a76cdb4428ef048916ea11b8f269044f8b89f813", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDk4OTY0NQ==", "url": "https://github.com/payara/Payara/pull/5007#discussion_r534989645", "bodyText": "I think you want to specify the encoding explicitly here.", "author": "jbee", "createdAt": "2020-12-03T09:20:54Z", "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "diffHunk": "@@ -0,0 +1,377 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.microprofile.config.source;\n+\n+import fish.payara.nucleus.executorservice.PayaraExecutorService;\n+import org.eclipse.microprofile.config.spi.ConfigSource;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.WatchEvent;\n+import java.nio.file.WatchKey;\n+import java.nio.file.WatchService;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.FileTime;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Collections.unmodifiableMap;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;\n+\n+/**\n+ * Config Source that reads properties from files from a directory\n+ * where filename is the property name and file contents is the property value.\n+ * @since 5.2020.7\n+ */\n+public class DirConfigSource extends PayaraConfigSource implements ConfigSource {\n+\n+    class DirProperty {\n+        String property;\n+        FileTime lastModifiedTime;\n+        Path path;\n+        int pathDepth;\n+        \n+        DirProperty(String property, FileTime lastModifiedTime, Path path, int pathDepth) {\n+            this.property = property;\n+            this.lastModifiedTime = lastModifiedTime;\n+            this.path = path;\n+            this.pathDepth = pathDepth;\n+        }\n+    \n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            DirProperty that = (DirProperty) o;\n+            return pathDepth == that.pathDepth &&\n+                property.equals(that.property) &&\n+                lastModifiedTime.equals(that.lastModifiedTime) &&\n+                path.equals(that.path);\n+        }\n+    \n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(property, lastModifiedTime, path, pathDepth);\n+        }\n+    }\n+    \n+    class DirPropertyWatcher implements Runnable {\n+    \n+        private Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n+        WatchService watcher = FileSystems.getDefault().newWatchService();\n+        ConcurrentHashMap<WatchKey, Path> keys = new ConcurrentHashMap<>();\n+        \n+        DirPropertyWatcher(Path topmostDir) throws IOException {\n+            if (Files.exists(topmostDir) && Files.isDirectory(topmostDir) && Files.isReadable(topmostDir)) {\n+                registerAll(topmostDir);\n+            } else {\n+                throw new IOException(\"Given directory '\"+topmostDir+\"' is no directory or cannot be read.\");\n+            }\n+        }\n+        \n+        void registerAll(Path dir) throws IOException {\n+            // register file watchers recursively (they don't attach to subdirs...)\n+            Files.walkFileTree(dir, new SimpleFileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException\n+                {\n+                    register(dir);\n+                    return FileVisitResult.CONTINUE;\n+                }\n+            });\n+        }\n+        \n+        void register(Path dir) throws IOException {\n+            WatchKey key = dir.register(watcher, ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY);\n+            keys.putIfAbsent(key, dir);\n+        }\n+        \n+        @Override\n+        public void run() {\n+            while (true) {\n+                // wait infinitely until we receive an event (or the executor is shutting down)\n+                WatchKey key;\n+                try {\n+                    key = watcher.take();\n+                } catch (InterruptedException ex) {\n+                    return;\n+                }\n+                \n+                Path workDir = keys.get(key);\n+                for (WatchEvent<?> event : key.pollEvents()) {\n+                    WatchEvent.Kind<?> kind = event.kind();\n+            \n+                    @SuppressWarnings(\"unchecked\")\n+                    WatchEvent<Path> ev = (WatchEvent<Path>) event;\n+                    Path fileName = ev.context();\n+                    Path path = workDir.resolve(fileName);\n+            \n+                    try {\n+                        // new directory to be watched and traversed\n+                        if (kind == ENTRY_CREATE && Files.isDirectory(path) && !Files.isHidden(path) && Files.isReadable(path)) {\n+                            registerAll(path);\n+                            initializePropertiesFromPath(path);\n+                        }\n+                        // new or updated file found\n+                        if (Files.isRegularFile(path) && (kind == ENTRY_CREATE || kind == ENTRY_MODIFY)) {\n+                            updatePropertyFromPath(path, Files.readAttributes(path, BasicFileAttributes.class));\n+                        }\n+                        if (Files.isRegularFile(path) && (kind == ENTRY_DELETE)) {\n+                            properties.remove(parsePropertyNameFromPath(path));\n+                        }\n+                    } catch (IOException e) {\n+                        logger.log(Level.SEVERE, \"Could not process event '\"+kind+\"' on '\"+path+\"'\", e);\n+                    }\n+                }\n+    \n+                // Reset key (obligatory) and remove from set if directory no longer accessible\n+                boolean valid = key.reset();\n+                if (!valid) {\n+                    keys.remove(key);\n+                    \n+                    // all directories became inaccessible, even topmostDir!\n+                    if (keys.isEmpty()) break;\n+                }\n+            }\n+        }\n+    }\n+    \n+    private Path directory;\n+    private ConcurrentHashMap<String, DirProperty> properties = new ConcurrentHashMap<>();\n+    private static Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n+    \n+    public DirConfigSource(PayaraExecutorService executorService) {\n+        // get the directory from the app server config\n+        findDir();\n+        \n+        try {\n+            // create the watcher for the directory\n+            executorService.submit(new DirPropertyWatcher(this.directory));\n+            // initial loading\n+            initializePropertiesFromPath(this.directory);\n+        } catch (IOException e) {\n+            logger.log(Level.SEVERE, \"Error during setup of MicroProfile Config Directory Source\", e);\n+        }\n+    }\n+\n+    // Used for testing only with explicit dependency injection\n+    DirConfigSource(Path directory, PayaraExecutorService executorService) {\n+        super(true);\n+        this.directory = directory;\n+        try {\n+            initializePropertiesFromPath(this.directory);\n+        } catch (IOException e) {\n+            logger.log(Level.SEVERE, \"Error during setup of MicroProfile Config Directory Source\", e);\n+        }\n+    }\n+\n+    @Override\n+    public Map<String, String> getProperties() {\n+        return unmodifiableMap(properties\n+                                    .entrySet()\n+                                    .stream()\n+                                    .collect(\n+                                        Collectors.toMap(Map.Entry::getKey, e -> e.getValue().property)\n+                                    ));\n+    }\n+\n+    @Override\n+    public Set<String> getPropertyNames() {\n+        return properties.keySet();\n+    }\n+\n+    @Override\n+    public int getOrdinal() {\n+        return Integer.parseInt(configService.getMPConfig().getSecretDirOrdinality());\n+    }\n+\n+    @Override\n+    public String getValue(String property) {\n+        DirProperty result = properties.get(property);\n+        return result == null ? null : result.property;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"Directory\";\n+    }\n+\n+    private void findDir() {\n+        List<Path> candidates = Arrays.asList(\n+                                    Paths.get(configService.getMPConfig().getSecretDir()),\n+                                    // let's try it relative to server environment root\n+                                    Paths.get(System.getProperty(\"com.sun.aas.instanceRoot\"), configService.getMPConfig().getSecretDir())\n+                                );\n+        for (Path candidate : candidates) {\n+            if (Files.exists(candidate) || Files.isDirectory(candidate) || Files.isReadable(candidate)) {\n+                this.directory = candidate;\n+                return;\n+            }\n+        }\n+    }\n+    \n+    void initializePropertiesFromPath(Path topmostDir) throws IOException {\n+        if (Files.exists(topmostDir) && Files.isDirectory(topmostDir) && Files.isReadable(topmostDir)) {\n+            // initialize properties on first run\n+            Files.walkFileTree(topmostDir, new SimpleFileVisitor<Path>() {\n+                // Ignore hidden directories\n+                @Override\n+                public FileVisitResult preVisitDirectory(java.nio.file.Path dir, BasicFileAttributes attrs) throws IOException {\n+                    return dir.toFile().isHidden() ? FileVisitResult.SKIP_SUBTREE : FileVisitResult.CONTINUE;\n+                }\n+    \n+                // Read and ingest all files and dirs present\n+                @Override\n+                public FileVisitResult visitFile(Path path, BasicFileAttributes mainAtts) throws IOException {\n+                    updatePropertyFromPath(path, mainAtts);\n+                    return FileVisitResult.CONTINUE;\n+                }\n+            });\n+        } else {\n+            throw new IOException(\"Given directory '\"+topmostDir+\"' is no directory or cannot be read.\");\n+        }\n+    }\n+    \n+    void updatePropertyFromPath(Path path, BasicFileAttributes mainAtts) throws IOException {\n+        // do not read hidden files, as K8s Secret filenames are symlinks to hidden files with data.\n+        // also ignore files > 512KB, as they are most likely no text config files...\n+        if (Files.isRegularFile(path) && ! Files.isHidden(path) && Files.isReadable(path) && mainAtts.size() < 512*1024) {\n+            // retrieve the property name from the file path\n+            String property = parsePropertyNameFromPath(path);\n+            \n+            // Conflict handling:\n+            // When this property is already present, check how to solve the conflict.\n+            // This property file will be skipped if the file we already have is deeper in the file tree...\n+            if (checkLongestMatchForPath(property, path)) {\n+                return;\n+            }\n+            \n+            properties.put(property, readPropertyFromPath(path, mainAtts));\n+        }\n+    }\n+    \n+    void removePropertyFromPath(Path path) {\n+        String property = parsePropertyNameFromPath(path);\n+    \n+        // not present? go away silently.\n+        if (! properties.containsKey(property)) return;\n+    \n+        // only delete from the map if the file that has been deleted is the same as the one stored in the map\n+        // -> deleting a file less specific but matching a property should not remove from the map\n+        // -> deleting a file more specific than in map shouldn't occur (it had to slip through longest match check then).\n+        if (path.equals(properties.get(property).path)) {\n+            properties.remove(property);\n+        }\n+        \n+    }\n+    \n+    String parsePropertyNameFromPath(Path path) {\n+        // 1. get relative path based on the config dir (\"/config\"),\n+        String property = directory.relativize(path.getParent()).toString();\n+        // 2. ignore all file suffixes after last dot\n+        property += path.getFileName().toString().substring(0, path.getFileName().toString().lastIndexOf('.')-1);\n+        // 3. replace all path seps with a \".\",\n+        property = property.replace(File.separatorChar, '.');\n+        // so \"/config/foo/bar/test/one.txt\" becomes \"foo/bar/test/one.txt\" becomes \"foo.bar.test.one\" property name\n+        return property;\n+    }\n+    \n+    /**\n+     * Check if the path given is a more specific path to a value for the given property\n+     * @param property\n+     * @param path\n+     * @return true if more specific, false if not\n+     */\n+    boolean checkLongestMatchForPath(String property, Path path) {\n+        // Make path relative to config directory\n+        // NOTE: we will never have a path containing \"..\", as our tree walkers are always inside this \"root\".\n+        Path relativePath = directory.relativize(path);\n+        \n+        // No property -> path is new and more specific\n+        if (! properties.containsKey(property))\n+            return true;\n+        DirProperty old = properties.get(property);\n+        \n+        // Check if this element has a higher path depth (longest match)\n+        // Example: \"foo.bar/test/one.txt\" (depth 2) wins over \"foo.bar.test.one.txt\" (depth 0)\n+        boolean depth = old.pathDepth > relativePath.getNameCount();\n+        \n+        // In case that both pathes have the same depth, we need to check on the position of dots.\n+        // Example: /config/foo.bar/test/one.txt is less specific than /config/foo/bar.test/one.txt\n+        if (old.pathDepth == relativePath.getNameCount()) {\n+            String oldPath = old.path.toString();\n+            String newPath = path.toAbsolutePath().toString();\n+            int offset = 0;\n+            while (offset > -1) {\n+                if (newPath.indexOf(\".\", offset) > oldPath.indexOf(\".\", offset)) return true;\n+                offset = oldPath.indexOf(\".\", offset + 1);\n+            }\n+        }\n+        return depth;\n+    }\n+    \n+    DirProperty readPropertyFromPath(Path path, BasicFileAttributes mainAtts) throws IOException {\n+        if (Files.exists(path) && Files.isRegularFile(path) && Files.isReadable(path)) {\n+            return new DirProperty(\n+                new String(Files.readAllBytes(path)),", "originalCommit": "a76cdb4428ef048916ea11b8f269044f8b89f813", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQyODM2OA==", "url": "https://github.com/payara/Payara/pull/5007#discussion_r537428368", "bodyText": "Using UTF-8.", "author": "poikilotherm", "createdAt": "2020-12-07T11:21:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDk4OTY0NQ=="}], "type": "inlineReview"}, {"oid": "ccde673deae9a9cab5e102ef4409c34de6a4f25c", "url": "https://github.com/payara/Payara/commit/ccde673deae9a9cab5e102ef4409c34de6a4f25c", "message": "Refactor after review by @jbee. Mostly scope and naming changes. #5006", "committedDate": "2020-12-07T11:31:56Z", "type": "commit"}, {"oid": "763f400bae4ff473a181d8367b8c709974d24d38", "url": "https://github.com/payara/Payara/commit/763f400bae4ff473a181d8367b8c709974d24d38", "message": "Make DirConfigSource retrieve the executor from the global ConfigProviderResolverImpl instead of explicit dep inject. #5006", "committedDate": "2020-12-07T12:03:30Z", "type": "commit"}, {"oid": "7601c8d90169d94c7818506adf311f1a741a79b3", "url": "https://github.com/payara/Payara/commit/7601c8d90169d94c7818506adf311f1a741a79b3", "message": "Add initial test DirConfigSourceTest and remove SecretDirConfigSourceTest", "committedDate": "2020-12-07T14:38:18Z", "type": "commit"}, {"oid": "4234a68b0294fb300026bc330fdb84baceea5520", "url": "https://github.com/payara/Payara/commit/4234a68b0294fb300026bc330fdb84baceea5520", "message": "Fix DirConfigSource.parsePropertyNameFromPath() to fix failing tests.", "committedDate": "2020-12-07T14:40:59Z", "type": "commit"}, {"oid": "eb622fca8dd8cb6b5e35fa87862407e470fa3feb", "url": "https://github.com/payara/Payara/commit/eb622fca8dd8cb6b5e35fa87862407e470fa3feb", "message": "Refactor DirConfigSource.DirProperty and test longest match. #5006", "committedDate": "2020-12-07T16:30:51Z", "type": "commit"}, {"oid": "8e86e89a8aa4a06018bc247d3824b7bb0eb21eb2", "url": "https://github.com/payara/Payara/commit/8e86e89a8aa4a06018bc247d3824b7bb0eb21eb2", "message": "Rename DirConfigSource.checkLongestMatchForPath() to isLongerMatchForPath() to be more readable and fix check if property needs update. Adding more tests.", "committedDate": "2020-12-07T17:14:41Z", "type": "commit"}, {"oid": "a277be5c6ffa8de5cb695dfbf981c2bcb8770a6d", "url": "https://github.com/payara/Payara/commit/a277be5c6ffa8de5cb695dfbf981c2bcb8770a6d", "message": "Add more test for initial read of property files in DirConfigSource", "committedDate": "2020-12-07T18:33:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE3MDk0MA==", "url": "https://github.com/payara/Payara/pull/5007#discussion_r544170940", "bodyText": "PayaraExecutorService tries to terminate gracefully via awaitTermination first. This loop therefore delays shutdown of the server by 5 seconds.\nConsider scheduling single take every few seconds instead, or polling synchronously during get.", "author": "pdudits", "createdAt": "2020-12-16T10:08:42Z", "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "diffHunk": "@@ -0,0 +1,387 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.microprofile.config.source;\n+\n+import fish.payara.nucleus.executorservice.PayaraExecutorService;\n+import org.eclipse.microprofile.config.spi.ConfigSource;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.WatchEvent;\n+import java.nio.file.WatchKey;\n+import java.nio.file.WatchService;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.FileTime;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import static java.util.Collections.unmodifiableMap;\n+import static java.util.stream.Collectors.toMap;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;\n+\n+/**\n+ * Config Source that reads properties from files from a directory\n+ * where filename is the property name and file contents is the property value.\n+ * @since 5.2020.7\n+ */\n+public class DirConfigSource extends PayaraConfigSource implements ConfigSource {\n+\n+    static final class DirProperty {\n+        final String propertyValue;\n+        final FileTime lastModifiedTime;\n+        final Path path;\n+        final int pathDepth;\n+        \n+        DirProperty(String propertyValue, FileTime lastModifiedTime, Path path, Path rootPath) {\n+            this.propertyValue = propertyValue;\n+            this.lastModifiedTime = lastModifiedTime;\n+            this.path = path;\n+            this.pathDepth = rootPath.relativize(path).getNameCount();\n+        }\n+    \n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            DirProperty that = (DirProperty) o;\n+            return pathDepth == that.pathDepth &&\n+                propertyValue.equals(that.propertyValue) &&\n+                lastModifiedTime.equals(that.lastModifiedTime) &&\n+                path.equals(that.path);\n+        }\n+    \n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(propertyValue, lastModifiedTime, path, pathDepth);\n+        }\n+    }\n+    \n+    final class DirPropertyWatcher implements Runnable {\n+    \n+        private final Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n+        private final WatchService watcher = FileSystems.getDefault().newWatchService();\n+        private final ConcurrentHashMap<WatchKey, Path> watchedFileKeys = new ConcurrentHashMap<>();\n+        \n+        DirPropertyWatcher(Path topmostDir) throws IOException {\n+            if (Files.exists(topmostDir) && Files.isDirectory(topmostDir) && Files.isReadable(topmostDir)) {\n+                registerAll(topmostDir);\n+            } else {\n+                throw new IOException(\"Given directory '\"+topmostDir+\"' is no directory or cannot be read.\");\n+            }\n+        }\n+        \n+        void registerAll(Path dir) throws IOException {\n+            // register file watchers recursively (they don't attach to subdirs...)\n+            Files.walkFileTree(dir, new SimpleFileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException\n+                {\n+                    register(dir);\n+                    return FileVisitResult.CONTINUE;\n+                }\n+            });\n+        }\n+        \n+        void register(Path dir) throws IOException {\n+            WatchKey key = dir.register(watcher, ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY);\n+            watchedFileKeys.putIfAbsent(key, dir);\n+        }\n+        \n+        @Override\n+        public void run() {\n+            while (true) {\n+                // wait infinitely until we receive an event (or the executor is shutting down)", "originalCommit": "a277be5c6ffa8de5cb695dfbf981c2bcb8770a6d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzgzNTczMA==", "url": "https://github.com/payara/Payara/pull/5007#discussion_r563835730", "bodyText": "This issue has been taken care of.", "author": "poikilotherm", "createdAt": "2021-01-25T15:58:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE3MDk0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE3NDM0MQ==", "url": "https://github.com/payara/Payara/pull/5007#discussion_r544174341", "bodyText": "This fails on Windows, because it has different condition for a hidden file. Consider explicit check for dot at start rather than isHidden.", "author": "pdudits", "createdAt": "2020-12-16T10:13:40Z", "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/test/java/fish/payara/nucleus/microprofile/config/source/DirConfigSourceTest.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) 2017-2020 Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.microprofile.config.source;\n+\n+import org.junit.*;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.attribute.FileAttribute;\n+import java.nio.file.attribute.FileTime;\n+import java.time.Instant;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Arrays.asList;\n+import static org.junit.Assert.*;\n+\n+public class DirConfigSourceTest {\n+\n+    private static Path testDirectory;\n+    private static DirConfigSource source;\n+    \n+    @BeforeClass\n+    public static void setUp() throws IOException {\n+        testDirectory = Files.createTempDirectory(\"microprofile-config-test-\");\n+        // create & load\n+        source = new DirConfigSource(testDirectory);\n+    }\n+\n+    @AfterClass\n+    public static void tearDown() throws IOException {\n+        Files.walk(testDirectory)\n+            .sorted(Comparator.reverseOrder())\n+            .map(Path::toFile)\n+            .forEach(File::delete);\n+    }\n+    \n+    @Test\n+    public void testParsePropertyNameFromPath() {\n+        // given\n+        Map<Path,String> examples = new HashMap<>();\n+        examples.put(Paths.get(testDirectory.toString(), \"foo/bar/test/ex\"), \"foo.bar.test.ex\");\n+        examples.put(Paths.get(testDirectory.toString(), \"foo.bar.test/ex\"), \"foo.bar.test.ex\");\n+        examples.put(Paths.get(testDirectory.toString(), \"foo/bar.test/ex\"), \"foo.bar.test.ex\");\n+        examples.put(Paths.get(testDirectory.toString(), \"foo.bar/test/ex\"), \"foo.bar.test.ex\");\n+        \n+        // we ignore the last file extension. always. this might lead to unexpected behaviour for a user.\n+        // best advice: do not use dots in filename, only in directory names.\n+        examples.put(Paths.get(testDirectory.toString(), \"foo/bar/test/ex.txt\"), \"foo.bar.test.ex\");\n+        examples.put(Paths.get(testDirectory.toString(), \"foo/bar/test/ex.tar.gz\"), \"foo.bar.test.ex.tar\");\n+        examples.put(Paths.get(testDirectory.toString(), \"foo.bar/test.ex\"), \"foo.bar.test\");\n+        examples.put(Paths.get(testDirectory.toString(), \"foo/bar.test.ex\"), \"foo.bar.test\");\n+        examples.put(Paths.get(testDirectory.toString(), \"foo.bar.test.ex\"), \"foo.bar.test\");\n+        examples.put(Paths.get(testDirectory.toString(), \"foo/bar/test.ex\"), \"foo.bar.test\");\n+        \n+        // when & then\n+        for (Map.Entry<Path, String> ex : examples.entrySet()) {\n+            System.out.println(ex.getKey()+\" = \"+ex.getValue());\n+            assertEquals(ex.getValue(), source.parsePropertyNameFromPath(ex.getKey()));\n+        }\n+    }\n+    \n+    @Test\n+    public void testCheckLongestMatchForPath_PathDepthLessSpecific() {\n+        // given\n+        Map<String,DirConfigSource.DirProperty> props = new HashMap<>();\n+        // a property with a most specific path\n+        String property = \"foo.bar.test.ex\";\n+        props.put(property,\n+                  new DirConfigSource.DirProperty(\n+                      \"test\", FileTime.from(Instant.now()),\n+                      Paths.get(testDirectory.toString(), \"foo/bar/test/ex\"),\n+                      testDirectory));\n+        source.setProperties(props);\n+        \n+        // when & then\n+        assertFalse(source.isLongerMatchForPath(property, Paths.get(testDirectory.toString(), \"foo/bar.test/ex\")));\n+    }\n+    \n+    @Test\n+    public void testCheckLongestMatchForPath_PathDepthMoreSpecific() {\n+        // given\n+        Map<String,DirConfigSource.DirProperty> props = new HashMap<>();\n+        // a property with a most specific path\n+        String property = \"foo.bar.test.ex\";\n+        props.put(property,\n+            new DirConfigSource.DirProperty(\n+                \"test\", FileTime.from(Instant.now()),\n+                Paths.get(testDirectory.toString(), \"foo.bar/test/ex\"),\n+                testDirectory));\n+        source.setProperties(props);\n+        \n+        // when & then\n+        assertTrue(source.isLongerMatchForPath(property, Paths.get(testDirectory.toString(), \"foo/bar/test/ex\")));\n+    }\n+    \n+    @Test\n+    public void testCheckLongestMatchForPath_PathDepthEqualMoreSpecific() {\n+        // given\n+        Map<String,DirConfigSource.DirProperty> props = new HashMap<>();\n+        // a property with a most specific path\n+        String property = \"foo.bar.test.ex.one\";\n+        props.put(property,\n+            new DirConfigSource.DirProperty(\n+                \"test\", FileTime.from(Instant.now()),\n+                Paths.get(testDirectory.toString(), \"foo.bar/test.ex/one\"),\n+                testDirectory));\n+        source.setProperties(props);\n+        \n+        // when & then\n+        assertTrue(source.isLongerMatchForPath(property, Paths.get(testDirectory.toString(), \"foo.bar/test/ex.one.txt\")));\n+    }\n+    \n+    @Test\n+    public void testCheckLongestMatchForPath_PropNotPresent() {\n+        // given\n+        Map<String,DirConfigSource.DirProperty> props = new HashMap<>();\n+        // a property with a most specific path\n+        String property = \"foo.bar.test.ex.one\";\n+        props.put(property,\n+            new DirConfigSource.DirProperty(\n+                \"test\", FileTime.from(Instant.now()),\n+                Paths.get(testDirectory.toString(), \"foo.bar/test.ex/one\"),\n+                testDirectory));\n+        source.setProperties(props);\n+        \n+        // when & then\n+        assertTrue(source.isLongerMatchForPath(\"foo.bar.test.ex.two\", Paths.get(testDirectory.toString(), \"foo.bar/test/ex.two.txt\")));\n+    }\n+    \n+    @Test\n+    public void testRemovePropertyFromPath() {\n+        // given\n+        Map<String,DirConfigSource.DirProperty> props = new HashMap<>();\n+        // a property with a most specific path\n+        String property = \"foo.bar.test\";\n+        props.put(property,\n+            new DirConfigSource.DirProperty(\n+                \"test\", FileTime.from(Instant.now()),\n+                Paths.get(testDirectory.toString(), \"foo/bar/test\"),\n+                testDirectory));\n+        source.setProperties(props);\n+        assertEquals(\"test\", source.getValue(property));\n+        \n+        // when\n+        source.removePropertyFromPath(Paths.get(testDirectory.toString(), \"foo/bar/test\"));\n+        // then\n+        assertTrue(source.getValue(property) == null);\n+        \n+    }\n+\n+    @Test\n+    public void testInitializeProperties_SimpleFiles() throws IOException {\n+        // given\n+        // only the most specific should be picked up (=test3)\n+        writeFile(testDirectory, \"foo.bar.test\", \"test\");\n+        writeFile(testDirectory, \"foo.bar/test\", \"test2\");\n+        writeFile(testDirectory, \"foo/bar/test\", \"test3\");\n+        \n+        //when\n+        source.initializePropertiesFromPath(testDirectory);\n+        \n+        //then\n+        assertEquals(\"test3\", source.getValue(\"foo.bar.test\"));\n+    }\n+    \n+    @Test\n+    public void testInitializeProperties_IgnoreHidden() throws IOException {\n+        // given\n+        // none of these should be picked up (hidden file or dir)\n+        writeFile(testDirectory, \".hidden.bar.test\", \"test\");\n+        writeFile(testDirectory, \".hidden/bar.test\", \"test\");\n+        //when\n+        source.initializePropertiesFromPath(testDirectory);\n+        //then\n+        assertEquals(null, source.getValue(\"hidden.bar.test\"));", "originalCommit": "a277be5c6ffa8de5cb695dfbf981c2bcb8770a6d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDExNTU5OQ==", "url": "https://github.com/payara/Payara/pull/5007#discussion_r564115599", "bodyText": "Done. It should work now.", "author": "poikilotherm", "createdAt": "2021-01-25T23:36:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE3NDM0MQ=="}], "type": "inlineReview"}, {"oid": "9bda0ae1dcbf6f0a653f7d453383885da631bf57", "url": "https://github.com/payara/Payara/commit/9bda0ae1dcbf6f0a653f7d453383885da631bf57", "message": "refactor(mpconfig): incorporate review comments by @jbee and @pdudits #5006\n\nThis is kinda major refactoring, including code tested in sample project to ensure this runs on K8s.\n\nIt's still lacking tests! This is a commit to save the status.", "committedDate": "2021-01-25T18:16:05Z", "type": "commit"}, {"oid": "a50ad85f504ea43b75174fc4f9e56ba4511ee1ad", "url": "https://github.com/payara/Payara/commit/a50ad85f504ea43b75174fc4f9e56ba4511ee1ad", "message": "fix(mpconfig): make dirconfigsource match same pathes on update and fix IOE when deleting. #5006", "committedDate": "2021-01-25T23:27:55Z", "type": "commit"}, {"oid": "e8af024ff0e301a1590b160f288aa4ca23167d88", "url": "https://github.com/payara/Payara/commit/e8af024ff0e301a1590b160f288aa4ca23167d88", "message": "refactor(mpconfig): Add unit tests for DirConfigSource. #5006", "committedDate": "2021-01-25T23:28:26Z", "type": "commit"}, {"oid": "91a07ca4a5a26d0976a0a6250d5b3519ffdbe26f", "url": "https://github.com/payara/Payara/commit/91a07ca4a5a26d0976a0a6250d5b3519ffdbe26f", "message": "test(mpconfig): fix wrong file size test for DirSourceConfig", "committedDate": "2021-01-25T23:59:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDQ4MjUxNQ==", "url": "https://github.com/payara/Payara/pull/5007#discussion_r564482515", "bodyText": "Another Windows FS-related trap here when configured with absolute path, this happens:\njava.nio.file.InvalidPathException: Illegal char <:> at index 100: C:\\src\\payara\\Payara\\appserver\\distributions\\payara\\target\\stage\\payara5\\glassfish\\domains\\domain1\\C:\\src\\payara\\Payara\\appserver\\distributions\\payara\\target\\stage\\payara5\\glassfish\\domains\\domain1\\config\\secrets\n\nSo you might want to be more specific here, checking if Path.isAbsolute before constructing relative one", "author": "pdudits", "createdAt": "2021-01-26T12:44:53Z", "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/source/DirConfigSource.java", "diffHunk": "@@ -0,0 +1,448 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.microprofile.config.source;\n+\n+import org.eclipse.microprofile.config.spi.ConfigSource;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.WatchEvent;\n+import java.nio.file.WatchKey;\n+import java.nio.file.WatchService;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.FileTime;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Logger;\n+\n+import static java.util.Collections.unmodifiableMap;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static java.util.logging.Level.SEVERE;\n+import static java.util.logging.Level.WARNING;\n+import static java.util.stream.Collectors.toMap;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;\n+import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;\n+\n+/**\n+ * Config Source that reads properties from files from a directory\n+ * where filename is the property name and file contents is the property value.\n+ * @since 5.2020.7\n+ */\n+public class DirConfigSource extends PayaraConfigSource implements ConfigSource {\n+\n+    static final class DirProperty {\n+        final String propertyValue;\n+        final FileTime lastModifiedTime;\n+        final Path path;\n+        final int pathDepth;\n+        \n+        DirProperty(String propertyValue, FileTime lastModifiedTime, Path path, int pathDepth) {\n+            this.propertyValue = propertyValue;\n+            this.lastModifiedTime = lastModifiedTime;\n+            this.path = path;\n+            this.pathDepth = pathDepth;\n+        }\n+    \n+        DirProperty(String propertyValue, FileTime lastModifiedTime, Path path, Path rootPath) {\n+            this(propertyValue, lastModifiedTime, path, rootPath.relativize(path).getNameCount());\n+        }\n+    \n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            DirProperty that = (DirProperty) o;\n+            return pathDepth == that.pathDepth &&\n+                propertyValue.equals(that.propertyValue) &&\n+                lastModifiedTime.equals(that.lastModifiedTime) &&\n+                path.equals(that.path);\n+        }\n+    \n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(propertyValue, lastModifiedTime, path, pathDepth);\n+        }\n+    }\n+    \n+    final class DirPropertyWatcher implements Runnable {\n+    \n+        private final Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n+        private final WatchService watcher = FileSystems.getDefault().newWatchService();\n+        private final ConcurrentHashMap<WatchKey, Path> watchedFileKeys = new ConcurrentHashMap<>();\n+        \n+        DirPropertyWatcher(Path topmostDir) throws IOException {\n+            if (Files.exists(topmostDir) && Files.isDirectory(topmostDir) && Files.isReadable(topmostDir)) {\n+                registerAll(topmostDir);\n+            } else {\n+                throw new IOException(\"Given directory '\"+topmostDir+\"' is no directory or cannot be read.\");\n+            }\n+        }\n+    \n+        /**\n+         * Register file watchers recursively (as they don't attach themselfs to sub directories...)\n+         * and initialize values from files present and suitable.\n+         * @param dir Topmost directory to start recursive traversal from\n+         * @throws IOException\n+         */\n+        final void registerAll(Path dir) throws IOException {\n+            Files.walkFileTree(dir, new SimpleFileVisitor<Path>() {\n+                @Override\n+                public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException\n+                {\n+                    // only register subdirectories if the directory itself is suitable.\n+                    if ( isAptDir(dir) ) {\n+                        register(dir);\n+                        return FileVisitResult.CONTINUE;\n+                    }\n+                    return FileVisitResult.SKIP_SUBTREE;\n+                }\n+    \n+                // Read and ingest all files and dirs present\n+                @Override\n+                public FileVisitResult visitFile(Path path, BasicFileAttributes mainAtts) throws IOException {\n+                    // file will be checked before upserting.\n+                    upsertPropertyFromPath(path, mainAtts);\n+                    return FileVisitResult.CONTINUE;\n+                }\n+            });\n+        }\n+        \n+        final void register(Path dir) throws IOException {\n+            WatchKey key = dir.register(watcher, ENTRY_CREATE, ENTRY_DELETE, ENTRY_MODIFY);\n+            watchedFileKeys.putIfAbsent(key, dir);\n+            logger.finer(\"MPCONFIG DirConfigSource: registered \\\"\"+dir+\"\\\" as key \\\"\"+key+\"\\\".\");\n+        }\n+        \n+        @Override\n+        public final void run() {\n+            // wait infinitely until we receive an event (or the executor is shutting down)\n+            WatchKey key;\n+            try {\n+                key = watcher.take();\n+            } catch (InterruptedException ex) {\n+                logger.info(\"MPCONFIG DirConfigSource: shutting down watcher thread.\");\n+                return;\n+            }\n+            \n+            Path workDir = watchedFileKeys.get(key);\n+            for (WatchEvent<?> event : key.pollEvents()) {\n+                WatchEvent.Kind<?> kind = event.kind();\n+        \n+                @SuppressWarnings(\"unchecked\")\n+                WatchEvent<Path> ev = (WatchEvent<Path>) event;\n+                Path fileName = ev.context();\n+                Path path = workDir.resolve(fileName);\n+\n+                logger.finer(\"MPCONFIG DirConfigSource: detected change: \"+fileName.toString()+\" : \"+kind.toString());\n+        \n+                try {\n+                    // new directory to be watched and traversed\n+                    if (kind == ENTRY_CREATE && isAptDir(path)) {\n+                        logger.finer(\"MPCONFIG DirConfigSource: registering new paths.\");\n+                        registerAll(path);\n+                    }\n+                    // new or updated file found (new = create + modify on content save)\n+                    // or new symlink found (symlinks are create only!) (also, aptness of file is checked inside update routine)\n+                    if ( kind == ENTRY_MODIFY || (kind == ENTRY_CREATE && Files.isSymbolicLink(path)) ) {\n+                        logger.finer(\"MPCONFIG DirConfigSource: processing new or updated file \\\"\"+path.toString()+\"\\\".\");\n+                        BasicFileAttributes atts = Files.readAttributes(path, BasicFileAttributes.class);\n+                        upsertPropertyFromPath(path, atts);\n+                    }\n+                    if (Files.notExists(path) && ! watchedFileKeys.containsValue(path) && kind == ENTRY_DELETE) {\n+                        logger.finer(\"MPCONFIG DirConfigSource: removing deleted file \\\"\"+path.toString()+\"\\\".\");\n+                        removePropertyFromPath(path);\n+                    }\n+                } catch (IOException e) {\n+                    logger.log(WARNING, \"MPCONFIG DirConfigSource: could not process event '\"+kind+\"' on '\"+path+\"'\", e);\n+                }\n+            }\n+\n+            // Reset key (obligatory) and remove from set if directory no longer accessible\n+            boolean valid = key.reset();\n+            if (!valid) {\n+                logger.finer(\"MPCONFIG DirConfigSource: removing watcher for key \\\"\"+key+\"\\\".\");\n+                watchedFileKeys.remove(key);\n+            }\n+        }\n+    }\n+    \n+    private static final Logger logger = Logger.getLogger(DirConfigSource.class.getName());\n+    private Path directory;\n+    private final ConcurrentHashMap<String, DirProperty> properties = new ConcurrentHashMap<>();\n+    \n+    public DirConfigSource() {\n+        try {\n+            // get the directory from the app server config\n+            this.directory = findDir();\n+            // create the watcher for the directory\n+            configService.getExecutor().scheduleWithFixedDelay(createWatcher(this.directory), 0, 1, SECONDS);\n+        } catch (IOException e) {\n+            logger.log(SEVERE, \"MPCONFIG DirConfigSource: error during setup.\", e);\n+        }\n+    }\n+\n+    // Used for testing only with explicit dependency injection\n+    DirConfigSource(Path directory) {\n+        super(true);\n+        this.directory = directory;\n+    }\n+    \n+    // Used for testing only\n+    DirPropertyWatcher createWatcher(Path topmostDirectory) throws IOException {\n+        return new DirPropertyWatcher(topmostDirectory);\n+    }\n+\n+    @Override\n+    public Map<String, String> getProperties() {\n+        return unmodifiableMap(properties.entrySet().stream()\n+                                    .collect(toMap(Map.Entry::getKey, e -> e.getValue().propertyValue)));\n+    }\n+    \n+    // Used for testing only\n+    void setProperties(Map<String, DirProperty> properties) {\n+        this.properties.clear();\n+        this.properties.putAll(properties);\n+    }\n+\n+    @Override\n+    public Set<String> getPropertyNames() {\n+        return properties.keySet();\n+    }\n+\n+    @Override\n+    public int getOrdinal() {\n+        return Integer.parseInt(configService.getMPConfig().getSecretDirOrdinality());\n+    }\n+\n+    @Override\n+    public String getValue(String property) {\n+        DirProperty result = properties.get(property);\n+        return result == null ? null : result.propertyValue;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"Directory\";\n+    }\n+\n+    private Path findDir() throws IOException {\n+        String path = configService.getMPConfig().getSecretDir();\n+        List<Path> candidates = Arrays.asList(\n+                                    Paths.get(path),\n+                                    // let's try it relative to server environment root\n+                                    Paths.get(System.getProperty(\"com.sun.aas.instanceRoot\"), path)\n+                                );", "originalCommit": "91a07ca4a5a26d0976a0a6250d5b3519ffdbe26f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTI0NzI2MA==", "url": "https://github.com/payara/Payara/pull/5007#discussion_r565247260", "bodyText": "Addressed this in dc78c29. Also added unit tests to make sure this fails early. Going to resolve this, but if this isn't working properly on Windows, please reopen or create a new review.", "author": "poikilotherm", "createdAt": "2021-01-27T11:50:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDQ4MjUxNQ=="}], "type": "inlineReview"}, {"oid": "dc78c29891f616ce5ef9a9b68579a982e75c715a", "url": "https://github.com/payara/Payara/commit/dc78c29891f616ce5ef9a9b68579a982e75c715a", "message": "fix(mpconfig): Check for absolute pathes in DirConfigSource.findDir()\n\nThis avoids pathes on Windows being invalid, because concatenating\ntwo absolute pathes is not possible on Windows.\n\nPart of a solution for #5006", "committedDate": "2021-01-27T11:45:03Z", "type": "commit"}, {"oid": "f7c2046cca0eb6de842d038f6fb8fb13b029723d", "url": "https://github.com/payara/Payara/commit/f7c2046cca0eb6de842d038f6fb8fb13b029723d", "message": "test(mpconfig): Have DirConfigSource.findDir() covered by tests.\n\nIntroducing some mocks to enable unit testing of findDir().\nNeeded to extend the base class constructors to be able to inject the mock.\n\nRelates to #5006\n\nP.S. Crossing fingers this runs on Windoze.", "committedDate": "2021-01-27T11:45:55Z", "type": "commit"}, {"oid": "784995fc5fffe5423fdf9a1783c1ed937f9cf8e0", "url": "https://github.com/payara/Payara/commit/784995fc5fffe5423fdf9a1783c1ed937f9cf8e0", "message": "refactor(mpconfig): Make DirConfigSource.isLongestMatch() more testable and use less memory\n\nThis commits make the logic part of isLongestMatch() a static function,\nmuch easier to unit test. The lookup part checking if the path is already\npresent somewhere is handled in a non-static function, so staying compatible\nwith using this config source for multiple locations.\n\nIt also refactored the inner DirProperty class to avoid saving the path depth\nand compute it instead, reducing the waste of resources.\n\nRelates to #5006", "committedDate": "2021-01-27T17:26:56Z", "type": "commit"}, {"oid": "401555dc167bc9ab319e2b35839073360f0e061a", "url": "https://github.com/payara/Payara/commit/401555dc167bc9ab319e2b35839073360f0e061a", "message": "feat(mpconfig): Make DirConfigSource ignore files with certains extensions\n\nIgnore *.properties, *.yaml, *.yml, *.xml, *.json files, as those are likely\nto contain more complex structures used for other config sources.\n\nRemember: the file name compiles to the property name (up to three letter\nendings silently cut off) and might contain whatever. If you put a\nfile with any of these extensions in the directory on purpose, it should not\nbe used with this config source.\n\n- Relates to #5006\n- Based on request from @pdudits in #5007", "committedDate": "2021-01-27T18:25:50Z", "type": "commit"}, {"oid": "ce30d87d4c05366db7451beee69e581b449fafcc", "url": "https://github.com/payara/Payara/commit/ce30d87d4c05366db7451beee69e581b449fafcc", "message": "revert(mpconfig): by request from @pdudits, this isn't necessary for now.\n\nThis reverts commit 401555dc167bc9ab319e2b35839073360f0e061a.", "committedDate": "2021-01-27T18:41:16Z", "type": "commit"}, {"oid": "45d7a33ca55b6237f175f3dcac5c605dbe675a13", "url": "https://github.com/payara/Payara/commit/45d7a33ca55b6237f175f3dcac5c605dbe675a13", "message": "fix(mpconfig): Do not cutoff file extensions for property names in DirConfigSource\n\nAs requested by @pdudits, do not cut off file extensions silently.\nPeople on Windows can deal with text files without a file extension,\nbetter stay consistent.\n\nRelates to #5006", "committedDate": "2021-01-27T18:46:11Z", "type": "commit"}]}