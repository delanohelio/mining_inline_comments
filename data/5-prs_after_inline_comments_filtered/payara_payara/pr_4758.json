{"pr_number": 4758, "pr_title": "FISH-161 OpenAPI Class Data Reading using HK2 Class Model API ", "pr_createdAt": "2020-07-02T07:53:58Z", "pr_url": "https://github.com/payara/Payara/pull/4758", "timeline": [{"oid": "a6103232b2200276346068985e89cf089975d363", "url": "https://github.com/payara/Payara/commit/a6103232b2200276346068985e89cf089975d363", "message": "Merge branch 'master' of git://github.com/payara/Payara", "committedDate": "2020-06-01T04:56:23Z", "type": "commit"}, {"oid": "7bb0df61768af0c6abb2fde4cc0e00214858bba4", "url": "https://github.com/payara/Payara/commit/7bb0df61768af0c6abb2fde4cc0e00214858bba4", "message": "Merge branch 'master' of git://github.com/payara/Payara", "committedDate": "2020-06-11T10:17:50Z", "type": "commit"}, {"oid": "2cd8f6729714ece76426acc6c58d1268a416dd4e", "url": "https://github.com/payara/Payara/commit/2cd8f6729714ece76426acc6c58d1268a416dd4e", "message": "Merge branch 'master' of git://github.com/payara/Payara", "committedDate": "2020-07-02T04:51:55Z", "type": "commit"}, {"oid": "f491727a90f87230faa0a45a256b9ebf979dcf82", "url": "https://github.com/payara/Payara/commit/f491727a90f87230faa0a45a256b9ebf979dcf82", "message": "FISH-161 OpenAPI Class Data Reading using HK2 Class Model API\n\nSigned-off-by: Gaurav Gupta <gaurav.gupta@payara.fish>", "committedDate": "2020-07-02T07:48:40Z", "type": "commit"}, {"oid": "180bf0753d9ccc938438c4af2e5e6df151e55c19", "url": "https://github.com/payara/Payara/commit/180bf0753d9ccc938438c4af2e5e6df151e55c19", "message": "FISH-161 Polish annotation getValue function usage", "committedDate": "2020-07-02T09:21:44Z", "type": "commit"}, {"oid": "3a8286944293ce6336db578f05e8a5b58a2ef4d7", "url": "https://github.com/payara/Payara/commit/3a8286944293ce6336db578f05e8a5b58a2ef4d7", "message": "FISH-161/FISH-70 JsonArray as return type breaks the OpenAPI document generation", "committedDate": "2020-07-02T10:49:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODkzOTE5Ng==", "url": "https://github.com/payara/Payara/pull/4758#discussion_r448939196", "bodyText": "Could this really be types other then Class types? As they get loaded from a String I'd assume in the end there is a Class.forName call behind it. In that case I see no reason to use Type here as it creates an unnecessary burden on the caller of the API to deal with all kinds of types.", "author": "jbee", "createdAt": "2020-07-02T11:38:45Z", "path": "appserver/payara-appserver-modules/microprofile/openapi/src/main/java/fish/payara/microprofile/openapi/api/visitor/ApiContext.java", "diffHunk": "@@ -67,7 +68,19 @@\n \n     /**\n      * @param type any class, not null\n-     * @return true, if the give type is a known type in this context, else false\n+     * @return true, if the give type is a known type in this context, else\n+     * false\n      */\n-    boolean isApplicationType(Class<?> type);\n-}\n\\ No newline at end of file\n+    boolean isApplicationType(String type);\n+\n+    /**\n+     * @param type any class, not null\n+     * @return type, if the give type is a known type in this context, else null\n+     */\n+    Type getType(String type);", "originalCommit": "3a8286944293ce6336db578f05e8a5b58a2ef4d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk3OTg1Nw==", "url": "https://github.com/payara/Payara/pull/4758#discussion_r448979857", "bodyText": "org.glassfish.hk2.classmodel.reflect.Type HK2 API wrapped the ASM object and underling all processing is done with the ASM Visitor API by processing the bytecode of classes hence Class.forName is never called.", "author": "jGauravGupta", "createdAt": "2020-07-02T12:54:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODkzOTE5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk0NDQ3NA==", "url": "https://github.com/payara/Payara/pull/4758#discussion_r448944474", "bodyText": "Looks to me like a repeating pattern that can be extracted, rough sketch:\n<T> List<AnnotationModel> extractAnnotationsModelFrom(AnnotationModel annotation, String type, Map<String, T> map, Function<AnnotationModel, T> factory);", "author": "jbee", "createdAt": "2020-07-02T11:49:49Z", "path": "appserver/payara-appserver-modules/microprofile/openapi/src/main/java/fish/payara/microprofile/openapi/impl/model/ComponentsImpl.java", "diffHunk": "@@ -76,6 +76,97 @@\n     protected Map<String, Link> links = new TreeMap<>();\n     protected Map<String, Callback> callbacks = new TreeMap<>();\n \n+    public static Components createInstance(AnnotationModel annotation, ApiContext context) {\n+        Components from = new ComponentsImpl();\n+\n+        List<AnnotationModel> schemas = annotation.getValue(\"schemas\", List.class);\n+        if (schemas != null) {\n+            for (AnnotationModel schema : schemas) {\n+                from.getSchemas().put(\n+                        schema.getValue(\"name\", String.class),\n+                        SchemaImpl.createInstance(schema, context)\n+                );\n+            }\n+        }\n+        List<AnnotationModel> responses = annotation.getValue(\"responses\", List.class);\n+        if (responses != null) {\n+            for (AnnotationModel response : responses) {\n+                from.getResponses().put(\n+                        response.getValue(\"name\", String.class),\n+                        APIResponseImpl.createInstance(response, context)\n+                );\n+            }\n+        }\n+        List<AnnotationModel> parameters = annotation.getValue(\"parameters\", List.class);\n+        if (parameters != null) {\n+            for (AnnotationModel parameter : parameters) {\n+                from.getParameters().put(\n+                        parameter.getValue(\"name\", String.class),\n+                        ParameterImpl.createInstance(parameter, context)\n+                );\n+            }\n+        }\n+        List<AnnotationModel> examples = annotation.getValue(\"examples\", List.class);\n+        if (examples != null) {\n+            for (AnnotationModel example : examples) {\n+                from.getExamples().put(\n+                        example.getValue(\"name\", String.class),\n+                        ExampleImpl.createInstance(example)\n+                );\n+            }\n+        }\n+        List<AnnotationModel> requestBodies = annotation.getValue(\"requestBodies\", List.class);\n+        if (requestBodies != null) {\n+            for (AnnotationModel requestBody : requestBodies) {\n+                from.getRequestBodies().put(\n+                        requestBody.getValue(\"name\", String.class),\n+                        RequestBodyImpl.createInstance(requestBody, context)\n+                );\n+            }\n+        }\n+        List<AnnotationModel> headers = annotation.getValue(\"headers\", List.class);\n+        if (headers != null) {\n+            for (AnnotationModel header : headers) {\n+                String headerName = header.getValue(\"name\", String.class);\n+                if(headerName == null) {\n+                    headerName = header.getValue(\"ref\", String.class);\n+                }\n+                from.getHeaders().put(\n+                        headerName,\n+                        HeaderImpl.createInstance(header, context)\n+                );\n+            }\n+        }\n+        List<AnnotationModel> securitySchemes = annotation.getValue(\"securitySchemes\", List.class);\n+        if (securitySchemes != null) {\n+            for (AnnotationModel securityScheme : securitySchemes) {\n+                from.getSecuritySchemes().put(\n+                        securityScheme.getValue(\"securitySchemeName\", String.class),\n+                        SecuritySchemeImpl.createInstance(securityScheme)\n+                );\n+            }\n+        }\n+        List<AnnotationModel> links = annotation.getValue(\"links\", List.class);\n+        if (links != null) {\n+            for (AnnotationModel link : links) {\n+                from.getLinks().put(\n+                        link.getValue(\"name\", String.class),\n+                        LinkImpl.createInstance(link)\n+                );\n+            }\n+        }\n+        List<AnnotationModel> callbacks = annotation.getValue(\"callbacks\", List.class);\n+        if (callbacks != null) {\n+            for (AnnotationModel callback : callbacks) {\n+                from.getCallbacks().put(\n+                        callback.getValue(\"name\", String.class),\n+                        CallbackImpl.createInstance(callback, context)\n+                );\n+            }\n+        }", "originalCommit": "3a8286944293ce6336db578f05e8a5b58a2ef4d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk0NTUzNA==", "url": "https://github.com/payara/Payara/pull/4758#discussion_r448945534", "bodyText": "Can't really see why this would need to be Object. Don't we know more about the from at this point?\nAlso this seems to break the pattern used for the other model types where the merge methods accepts two objects of the same type to merge and has a createInstance method to create one of them from the annotation model. I think that pattern helps to understand it and keeps the steps separated nicely so I'd like to see it applied here as well.", "author": "jbee", "createdAt": "2020-07-02T11:51:46Z", "path": "appserver/payara-appserver-modules/microprofile/openapi/src/main/java/fish/payara/microprofile/openapi/impl/model/ExtensibleImpl.java", "diffHunk": "@@ -94,22 +90,22 @@ public void setExtensions(Map<String, Object> extensions) {\n     public static String extensionName(String name) {\n         if (name != null && !name.startsWith(\"x-\")) {\n             //NB. MP group decided that extension names should not be corrected\n-            LOGGER.warning(\"extension name not starting with `x-` cause invalid Open API documents: \" + name);\n+            LOGGER.log(Level.WARNING, \"extension name not starting with `x-` cause invalid Open API documents: {0}\", name);\n         }\n         return name;\n     }\n \n-    public static void merge(Extension from, Extensible<?> to, boolean override) {\n-        if (isAnnotationNull(from)) {\n+    public static void merge(String extensionName, Object from, Extensible<?> to, boolean override) {", "originalCommit": "3a8286944293ce6336db578f05e8a5b58a2ef4d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk0ODg0NA==", "url": "https://github.com/payara/Payara/pull/4758#discussion_r448948844", "bodyText": "This seems to be a pattern that is needed often here and also in createInstance methods of other model types. Would be nice if this became more readable and less duplicating and maybe even more typed by extracting the pattern to a utility function.", "author": "jbee", "createdAt": "2020-07-02T11:58:14Z", "path": "appserver/payara-appserver-modules/microprofile/openapi/src/main/java/fish/payara/microprofile/openapi/impl/model/OpenAPIImpl.java", "diffHunk": "@@ -72,6 +69,41 @@\n     protected Paths paths = new PathsImpl();\n     protected Components components = new ComponentsImpl();\n \n+    public static OpenAPI createInstance(AnnotationModel annotation, ApiContext context) {\n+        OpenAPI from = new OpenAPIImpl();\n+        AnnotationModel info = annotation.getValue(\"info\", AnnotationModel.class);\n+        if (info != null) {\n+            from.setInfo(InfoImpl.createInstance(info));\n+        }\n+        AnnotationModel externalDocs = annotation.getValue(\"externalDocs\", AnnotationModel.class);\n+        if (externalDocs != null) {\n+            from.setExternalDocs(ExternalDocumentationImpl.createInstance(externalDocs));\n+        }\n+        List<AnnotationModel> servers = annotation.getValue(\"servers\", List.class);\n+        if (servers != null) {\n+            for (AnnotationModel server : servers) {\n+                from.getServers().add(ServerImpl.createInstance(server));\n+            }\n+        }\n+        List<AnnotationModel> securityElements = annotation.getValue(\"security\", List.class);\n+        if (securityElements != null) {\n+            for (AnnotationModel security : securityElements) {\n+                from.getSecurity().add(SecurityRequirementImpl.createInstance(security));\n+            }\n+        }\n+        List<AnnotationModel> tags = annotation.getValue(\"tags\", List.class);\n+        if (tags != null) {\n+            for (AnnotationModel tag : tags) {\n+                from.getTags().add(TagImpl.createInstance(tag));\n+            }\n+        }\n+        AnnotationModel components = annotation.getValue(\"components\", AnnotationModel.class);\n+        if (components != null) {\n+            from.setComponents(ComponentsImpl.createInstance(components, context));\n+        }", "originalCommit": "3a8286944293ce6336db578f05e8a5b58a2ef4d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTM5MTQ2Mg==", "url": "https://github.com/payara/Payara/pull/4758#discussion_r449391462", "bodyText": "Added util function for List/Map attributes annotation mapping.", "author": "jGauravGupta", "createdAt": "2020-07-03T06:03:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk0ODg0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk1MDU3OQ==", "url": "https://github.com/payara/Payara/pull/4758#discussion_r448950579", "bodyText": "I am surprised to see addition of these fields. Is this adding a feature that wasn't there before?\nCC @MattGill98", "author": "jbee", "createdAt": "2020-07-02T12:01:29Z", "path": "appserver/payara-appserver-modules/microprofile/openapi/src/main/java/fish/payara/microprofile/openapi/impl/model/callbacks/CallbackImpl.java", "diffHunk": "@@ -39,29 +39,52 @@\n  */\n package fish.payara.microprofile.openapi.impl.model.callbacks;\n \n+import fish.payara.microprofile.openapi.api.visitor.ApiContext;\n+import fish.payara.microprofile.openapi.impl.model.ExtensibleTreeMap;\n+import fish.payara.microprofile.openapi.impl.model.OperationImpl;\n+import fish.payara.microprofile.openapi.impl.model.PathItemImpl;\n import static fish.payara.microprofile.openapi.impl.model.util.ModelUtils.applyReference;\n import static fish.payara.microprofile.openapi.impl.model.util.ModelUtils.getHttpMethod;\n import static fish.payara.microprofile.openapi.impl.model.util.ModelUtils.getOrCreateOperation;\n-import static fish.payara.microprofile.openapi.impl.model.util.ModelUtils.isAnnotationNull;\n-\n+import java.util.ArrayList;\n+import java.util.List;\n import java.util.Map;\n-\n-import org.eclipse.microprofile.openapi.annotations.callbacks.CallbackOperation;\n import org.eclipse.microprofile.openapi.models.Operation;\n import org.eclipse.microprofile.openapi.models.PathItem;\n import org.eclipse.microprofile.openapi.models.PathItem.HttpMethod;\n import org.eclipse.microprofile.openapi.models.callbacks.Callback;\n-import org.eclipse.microprofile.openapi.models.media.Schema;\n-\n-import fish.payara.microprofile.openapi.impl.model.ExtensibleTreeMap;\n-import fish.payara.microprofile.openapi.impl.model.OperationImpl;\n-import fish.payara.microprofile.openapi.impl.model.PathItemImpl;\n+import org.glassfish.hk2.classmodel.reflect.AnnotationModel;\n \n public class CallbackImpl extends ExtensibleTreeMap<PathItem, Callback> implements Callback {\n \n     private static final long serialVersionUID = 5549098533131353142L;\n \n     private String ref;\n+    \n+    private String urlExpression;\n+\n+    private List<Operation> operations;", "originalCommit": "3a8286944293ce6336db578f05e8a5b58a2ef4d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTM5MzkyMw==", "url": "https://github.com/payara/Payara/pull/4758#discussion_r449393923", "bodyText": "Few OpenAPI Annotations and Models class  (e.g Callback, Content, etc) differ in attributes but not the end results.\nAs earlier merge operation performed from Annotation (from) instance to Model (to), these attributes storage is not required. But with this PR HK2 types converted to Model (from) and merge operation is performed, hence locally these additional attributes are required.", "author": "jGauravGupta", "createdAt": "2020-07-03T06:12:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk1MDU3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk1Mzg2OQ==", "url": "https://github.com/payara/Payara/pull/4758#discussion_r448953869", "bodyText": "If this method only works with ContentImpl passed it maybe should demand it in is signature? If createInstance would return ContentImpl the caller joining the two maybe has all necessary type data?", "author": "jbee", "createdAt": "2020-07-02T12:07:40Z", "path": "appserver/payara-appserver-modules/microprofile/openapi/src/main/java/fish/payara/microprofile/openapi/impl/model/media/ContentImpl.java", "diffHunk": "@@ -88,42 +120,49 @@ public void setMediaTypes(Map<String, MediaType> mediaTypes) {\n         putAll(mediaTypes);\n     }\n \n-    public static void merge(org.eclipse.microprofile.openapi.annotations.media.Content from, Content to,\n-            boolean override, Map<String, Schema> currentSchemas) {\n+    public static void merge(Content from, Content to,", "originalCommit": "3a8286944293ce6336db578f05e8a5b58a2ef4d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk1NTQxMg==", "url": "https://github.com/payara/Payara/pull/4758#discussion_r448955412", "bodyText": "return avoids mutable state", "author": "jbee", "createdAt": "2020-07-02T12:10:35Z", "path": "appserver/payara-appserver-modules/microprofile/openapi/src/main/java/fish/payara/microprofile/openapi/impl/model/media/SchemaImpl.java", "diffHunk": "@@ -108,6 +110,133 @@\n \n     private Object additionalProperties;\n     private Schema items;\n+    private String implementation;\n+\n+    public static Schema createInstance(AnnotationModel annotation, ApiContext context) {\n+        SchemaImpl from = new SchemaImpl();\n+        from.setDefaultValue(annotation.getValue(\"defaultValue\", Object.class));\n+        from.setTitle(annotation.getValue(\"title\", String.class));\n+        Double multipleOf = annotation.getValue(\"multipleOf\", Double.class);\n+        if (multipleOf != null) {\n+            from.setMultipleOf(BigDecimal.valueOf(multipleOf));\n+        }\n+        String maximum = annotation.getValue(\"maximum\", String.class);\n+        if (maximum != null && !maximum.isEmpty()) {\n+            from.setMaximum(new BigDecimal(maximum));\n+        }\n+        from.setExclusiveMaximum(annotation.getValue(\"exclusiveMaximum\", Boolean.class));\n+        String minimum = annotation.getValue(\"minimum\", String.class);\n+        if (minimum != null && !minimum.isEmpty()) {\n+            from.setMinimum(new BigDecimal(minimum));\n+        }\n+        from.setExclusiveMinimum(annotation.getValue(\"exclusiveMinimum\", Boolean.class));\n+        from.setMaxLength(annotation.getValue(\"maxLength\", Integer.class));\n+        from.setMinLength(annotation.getValue(\"minLength\", Integer.class));\n+        from.setPattern(annotation.getValue(\"pattern\", String.class));\n+        from.setMaxItems(annotation.getValue(\"maxItems\", Integer.class));\n+        from.setMinItems(annotation.getValue(\"minItems\", Integer.class));\n+        from.setUniqueItems(annotation.getValue(\"uniqueItems\", Boolean.class));\n+        from.setMaxProperties(annotation.getValue(\"maxProperties\", Integer.class));\n+        from.setMinProperties(annotation.getValue(\"minProperties\", Integer.class));\n+        from.setRequired(annotation.getValue(\"requiredProperties\", List.class));\n+        EnumModel typeEnum = annotation.getValue(\"type\", EnumModel.class);\n+        if (typeEnum != null) {\n+            from.setType(SchemaType.valueOf(typeEnum.getValue()));\n+        }\n+        from.setDescription(annotation.getValue(\"description\", String.class));\n+        from.setFormat(annotation.getValue(\"format\", String.class));\n+        String ref = annotation.getValue(\"ref\", String.class);\n+        if (ref != null && !ref.isEmpty()) {\n+            from.setRef(ref);\n+        }\n+        from.setNullable(annotation.getValue(\"nullable\", Boolean.class));\n+        from.setReadOnly(annotation.getValue(\"readOnly\", Boolean.class));\n+        from.setWriteOnly(annotation.getValue(\"writeOnly\", Boolean.class));\n+        from.setExample(annotation.getValue(\"example\", Object.class));\n+        AnnotationModel externalDocs = annotation.getValue(\"externalDocs\", AnnotationModel.class);\n+        if (externalDocs != null) {\n+            from.setExternalDocs(ExternalDocumentationImpl.createInstance(externalDocs));\n+        }\n+        from.setDeprecated(annotation.getValue(\"deprecated\", Boolean.class));\n+        from.setEnumeration(annotation.getValue(\"enumeration\", List.class));\n+        String discriminatorProperty = annotation.getValue(\"discriminatorProperty\", String.class);\n+        List<AnnotationModel> discriminatorMapping = annotation.getValue(\"discriminatorMapping\", List.class);\n+        if (discriminatorMapping != null && !discriminatorProperty.isEmpty()) {\n+            DiscriminatorImpl discriminator = new DiscriminatorImpl();\n+            discriminator.setPropertyName(discriminatorProperty);\n+            for (AnnotationModel mapping : discriminatorMapping) {\n+                String value = mapping.getValue(\"value\", String.class);\n+                String schema = mapping.getValue(\"schema\", String.class);\n+                discriminator.addMapping(value, ModelUtils.getSimpleName(schema));\n+            }\n+            from.setDiscriminator(discriminator);\n+        }\n+\n+        String not = annotation.getValue(\"not\", String.class);\n+        if (not != null) {\n+            Schema schema = from.getSchemaInstance(not, context);\n+            if (schema != null) {\n+                from.setNot(schema);\n+            }\n+        }\n+        List<String> anyOf = annotation.getValue(\"anyOf\", List.class);\n+        if (anyOf != null) {\n+            if (from.getAnyOf() == null) {\n+                from.setAnyOf(new ArrayList<>());\n+            }\n+            from.getAnyOf().addAll(from.getSchemaInstances(anyOf, context));\n+        }\n+        List<String> allOf = annotation.getValue(\"allOf\", List.class);\n+        if (allOf != null) {\n+            if (from.getAllOf() == null) {\n+                from.setAllOf(new ArrayList<>());\n+            }\n+            from.getAllOf().addAll(from.getSchemaInstances(allOf, context));\n+        }\n+        List<String> oneOf = annotation.getValue(\"oneOf\", List.class);\n+        if (oneOf != null) {\n+            if (from.getOneOf() == null) {\n+                from.setOneOf(new ArrayList<>());\n+            }\n+            from.getOneOf().addAll(from.getSchemaInstances(oneOf, context));\n+        }\n+\n+        from.setImplementation(annotation.getValue(\"implementation\", String.class));\n+        return from;\n+    }\n+\n+    private List<Schema> getSchemaInstances(List<String> fromList, ApiContext context) {\n+        List<Schema> to = new ArrayList<>();\n+        if (fromList != null) {\n+            for (String from : fromList) {\n+                Schema schema = getSchemaInstance(from, context);\n+                if (schema != null) {\n+                    to.add(schema);\n+                }\n+            }\n+        }\n+        return to;\n+    }\n+\n+    private Schema getSchemaInstance(String schemaClassName, ApiContext context) {\n+        Schema to = null;\n+        if (schemaClassName != null\n+                && !schemaClassName.equals(\"java.lang.Void\")) {\n+            Type schemaType = context.getType(schemaClassName);\n+            if (schemaType instanceof ClassModel) {\n+                ClassModel schemaClassModel = (ClassModel) schemaType;\n+                if (schemaClassModel.isInstanceOf(Schema.class.getName())) {\n+                    try {\n+                        Class<?> oneOfClass = context.getApplicationClassLoader().loadClass(schemaClassName);\n+                        to = (Schema) oneOfClass.newInstance();", "originalCommit": "3a8286944293ce6336db578f05e8a5b58a2ef4d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk1NTc3MQ==", "url": "https://github.com/payara/Payara/pull/4758#discussion_r448955771", "bodyText": "Would it hurt to instead initialise the properties field with an empty map?", "author": "jbee", "createdAt": "2020-07-02T12:11:18Z", "path": "appserver/payara-appserver-modules/microprofile/openapi/src/main/java/fish/payara/microprofile/openapi/impl/model/media/SchemaImpl.java", "diffHunk": "@@ -346,6 +475,9 @@ public void setProperties(Map<String, Schema> properties) {\n \n     @Override\n     public Schema addProperty(String key, Schema propertiesItem) {\n+        if (this.properties == null) {\n+            this.properties = new HashMap<>();", "originalCommit": "3a8286944293ce6336db578f05e8a5b58a2ef4d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk2NDk2MQ==", "url": "https://github.com/payara/Payara/pull/4758#discussion_r448964961", "bodyText": "ExtensibleType<?> I think", "author": "jbee", "createdAt": "2020-07-02T12:28:49Z", "path": "appserver/payara-appserver-modules/microprofile/openapi/src/main/java/fish/payara/microprofile/openapi/impl/model/util/AnnotationInfo.java", "diffHunk": "@@ -40,53 +40,61 @@\n package fish.payara.microprofile.openapi.impl.model.util;\n \n import java.lang.annotation.Annotation;\n-import java.lang.reflect.AnnotatedElement;\n-import java.lang.reflect.Executable;\n import java.lang.reflect.Field;\n import java.lang.reflect.Method;\n-import java.lang.reflect.Parameter;\n+import java.util.Collection;\n import java.util.Map;\n import java.util.concurrent.ConcurrentHashMap;\n+import org.glassfish.hk2.classmodel.reflect.AnnotatedElement;\n+import org.glassfish.hk2.classmodel.reflect.AnnotationModel;\n+import org.glassfish.hk2.classmodel.reflect.ClassModel;\n+import org.glassfish.hk2.classmodel.reflect.ExtensibleType;\n+import org.glassfish.hk2.classmodel.reflect.FieldModel;\n+import org.glassfish.hk2.classmodel.reflect.InterfaceModel;\n+import org.glassfish.hk2.classmodel.reflect.MethodModel;\n+import org.glassfish.hk2.classmodel.reflect.Parameter;\n \n /**\n  * Represents the aggregated annotations on a type, its fields and methods including annotations \"inherited\" from\n  * super-classes and implemented interfaces. Should a field or method from a super-class be overridden the\n  * {@link Annotation} closest to the represented type (the overriding one) is kept.\n  */\n-public final class AnnotationInfo<T> {\n+public final class AnnotationInfo {\n \n-    private static final Map<Class<?>, AnnotationInfo<?>> TYPES = new ConcurrentHashMap<>();\n+    private static final Map<ExtensibleType, AnnotationInfo> TYPES = new ConcurrentHashMap<>();", "originalCommit": "3a8286944293ce6336db578f05e8a5b58a2ef4d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk2NzE0NA==", "url": "https://github.com/payara/Payara/pull/4758#discussion_r448967144", "bodyText": "Moving from Class to String does take away a lot of the context. Maybe this should be using a wrapper type on String to become more typed again.", "author": "jbee", "createdAt": "2020-07-02T12:32:53Z", "path": "appserver/payara-appserver-modules/microprofile/openapi/src/main/java/fish/payara/microprofile/openapi/impl/model/util/ModelUtils.java", "diffHunk": "@@ -552,30 +577,44 @@ public static String getResourcePath(GenericDeclaration declaration, Map<String,\n         return null;\n     }\n \n-    private static String getResourcePath(Class<?> clazz, Map<String, Set<Class<?>>> resourceMapping) {\n+    public static String getResourcePath(Type declaration, Map<String, Set<String>> resourceMapping) {\n+        if (declaration instanceof MethodModel) {\n+            return getResourcePath((MethodModel) declaration, resourceMapping);\n+        } else if (declaration instanceof ClassModel) {\n+            return getResourcePath((ClassModel) declaration, resourceMapping);\n+        }\n+        return null;\n+    }\n+\n+    public static String getResourcePath(ClassModel clazz, Map<String, Set<String>> resourceMapping) {\n         // If the class is a resource and contains a mapping\n-        AnnotationInfo<?> annotations = AnnotationInfo.valueOf(clazz);\n+        AnnotationInfo annotations = AnnotationInfo.valueOf(clazz);\n         if (annotations.isAnnotationPresent(Path.class)) {\n-            for (Map.Entry<String, Set<Class<?>>> entry : resourceMapping.entrySet()) {\n-                if (entry.getValue() != null && entry.getValue().contains(clazz)) {\n-                    return normaliseUrl(entry.getKey() + \"/\" + annotations.getAnnotation(Path.class).value());\n+            for (Map.Entry<String, Set<String>> entry : resourceMapping.entrySet()) {\n+                if (entry.getValue() != null && entry.getValue().contains(clazz.getName())) {\n+                    return normaliseUrl(entry.getKey() + \"/\" + annotations.getAnnotationValue(Path.class));\n                 }\n             }\n         }\n         return null;\n     }\n \n-    private static String getResourcePath(Method method, Map<String, Set<Class<?>>> resourceMapping) {\n-        AnnotationInfo<?> annotations = AnnotationInfo.valueOf(method.getDeclaringClass());\n+    public static String getResourcePath(MethodModel method, Map<String, Set<String>> resourceMapping) {", "originalCommit": "3a8286944293ce6336db578f05e8a5b58a2ef4d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk2NzY0OQ==", "url": "https://github.com/payara/Payara/pull/4758#discussion_r448967649", "bodyText": "Should use the other constructor to set the fields.", "author": "jbee", "createdAt": "2020-07-02T12:33:54Z", "path": "appserver/payara-appserver-modules/microprofile/openapi/src/main/java/fish/payara/microprofile/openapi/impl/processor/ApplicationProcessor.java", "diffHunk": "@@ -141,29 +114,65 @@\n     /**\n      * A list of all classes in the given application.\n      */\n-    private final Set<Class<?>> classes;\n+    private final Set<Type> types;\n \n     /**\n+     * A list of allowed classes for scanning\n+     */\n+    private final Set<Type> allowedTypes;\n+\n+    private final ClassLoader appClassLoader;\n+\n+    public ApplicationProcessor(ApplicationInfo appInfo) {\n+        this.types = new HashSet<>(appInfo.getTypes().getAllTypes());", "originalCommit": "3a8286944293ce6336db578f05e8a5b58a2ef4d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk3Mzk2NQ==", "url": "https://github.com/payara/Payara/pull/4758#discussion_r448973965", "bodyText": "This should be lazily done on demand. If OpenAPI is requesting the types we still could compute this data from the sources used here or am I missing something?", "author": "jbee", "createdAt": "2020-07-02T12:45:08Z", "path": "nucleus/core/kernel/src/main/java/com/sun/enterprise/v3/server/ApplicationLifecycle.java", "diffHunk": "@@ -548,6 +548,7 @@ public void actOn(Logger logger) {\n             // first, then register the real one\n             appRegistry.remove(appName);\n             appInfo.setIsJavaEEApp(sortedEngineInfos);\n+            appInfo.setTypes(context.getTransientAppMetaData(Types.class.getName(), Types.class));", "originalCommit": "3a8286944293ce6336db578f05e8a5b58a2ef4d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk4NDQxOA==", "url": "https://github.com/payara/Payara/pull/4758#discussion_r448984418", "bodyText": "org.glassfish.hk2.classmodel.reflect.Types data was always created and loaded during application deployment and removed after deployments completed.\nNow Types info is stored in the ApplicationInfo for further processing by other modules like OpneAPI.", "author": "jGauravGupta", "createdAt": "2020-07-02T13:01:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk3Mzk2NQ=="}], "type": "inlineReview"}, {"oid": "461d3c20ff3640a99211272af53195dd5e401721", "url": "https://github.com/payara/Payara/commit/461d3c20ff3640a99211272af53195dd5e401721", "message": "FISH-161 PR review changes", "committedDate": "2020-07-02T13:43:34Z", "type": "commit"}, {"oid": "b95e214d625edd981bd1573a36a1e647f3103f2f", "url": "https://github.com/payara/Payara/commit/b95e214d625edd981bd1573a36a1e647f3103f2f", "message": "PR review changes - extractAnnotations util", "committedDate": "2020-07-03T05:09:21Z", "type": "commit"}, {"oid": "208365812ca5db89d15166db35b3e2a3f59bbb13", "url": "https://github.com/payara/Payara/commit/208365812ca5db89d15166db35b3e2a3f59bbb13", "message": "FISH-161 PR review changes - typed resource mapping", "committedDate": "2020-07-03T06:00:16Z", "type": "commit"}, {"oid": "96dda2aa6a1903768f99e7f747e00655bf5788df", "url": "https://github.com/payara/Payara/commit/96dda2aa6a1903768f99e7f747e00655bf5788df", "message": "FISH-161 Upgrade HK2 to 2.6.1.payara-p2\n\nSigned-off-by: Gaurav Gupta <gaurav.gupta@payara.fish>", "committedDate": "2020-07-06T09:41:28Z", "type": "commit"}]}