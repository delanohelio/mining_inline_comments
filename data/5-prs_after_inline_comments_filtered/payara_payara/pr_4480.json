{"pr_number": 4480, "pr_title": "CUSTCOM-135 Fixed race condition on ConfigProviderResolver initialization", "pr_createdAt": "2020-02-10T12:57:45Z", "pr_url": "https://github.com/payara/Payara/pull/4480", "timeline": [{"oid": "e4a4c75bee34a532efd0a75300be0d25eaa4c6e9", "url": "https://github.com/payara/Payara/commit/e4a4c75bee34a532efd0a75300be0d25eaa4c6e9", "message": "CUSTCOM-135 Fixed race condition on ConfigProviderResolver initialization\n\n- instane() is synchronized\n- setInstance is NOT synchronized, so it ignores any locks\n- preferring @Inject over ConfigProvider in HealthCheckService\n- using @ContractsProvided to allow both @Inject target types\n- more logging, but only when configured\n- tested in extremely slowed TestContainers docker container", "committedDate": "2020-02-10T12:52:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzA3OTY4MA==", "url": "https://github.com/payara/Payara/pull/4480#discussion_r377079680", "bodyText": ".yield() is a hint, which means that control isn't necessarily  passed on to another Thread.  A sleep with very small amount should be used.", "author": "rdebusscher", "createdAt": "2020-02-10T14:02:20Z", "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/spi/ConfigProviderResolverSync.java", "diffHunk": "@@ -96,4 +95,17 @@ public void registerConfig(Config config, ClassLoader classLoader) {\n     public void releaseConfig(Config config) {\n         await().releaseConfig(config);\n     }\n+\n+\n+    private ConfigProviderResolver await() {\n+        LOG.log(Level.WARNING, \"Payara Microprofile Config requested too early, the HK2 service is not initialized yet.\"\n+            + \" Waiting until it will be active.\");\n+        while (true) {\n+            final ConfigProviderResolver resolver = instance();\n+            if (resolver != null && resolver != this) {\n+                return resolver;\n+            }\n+            Thread.yield();", "originalCommit": "e4a4c75bee34a532efd0a75300be0d25eaa4c6e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzExMjU1OA==", "url": "https://github.com/payara/Payara/pull/4480#discussion_r377112558", "bodyText": "I used it on Linux+Intel/AMD and on Solaris/SPARC, even old versions, and it always worked (lower CPU load because it is not so aggressive as while loop, but fast, because it does not sleep).\nAlso it is only few time blocks after startup, so it does not slow down the Payara Startup. Sleep is unnecessary overkill, because I don't need to sleep running thread, I only tell the scheduler \"at this moment I have nothing to do, but if other threads have some work, they can\".\nhttps://www.geeksforgeeks.org/java-concurrency-yield-sleep-and-join-methods/", "author": "dmatej", "createdAt": "2020-02-10T14:56:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzA3OTY4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzEzMDU2OQ==", "url": "https://github.com/payara/Payara/pull/4480#discussion_r377130569", "bodyText": "instance() also has synchronized block, so there's another yield point there, so I believe this might be correct.\nBut still, I trust CountDownLatch more, but might be overkill for 1 producer to 1 consumer scenario.", "author": "pdudits", "createdAt": "2020-02-10T15:25:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzA3OTY4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzA4MTcxMA==", "url": "https://github.com/payara/Payara/pull/4480#discussion_r377081710", "bodyText": "This is executed too early if you ask me. The current instance is set as value BEFORE the instance is completely setup as HK2 service. So MP config calls can get routed to this class before HK2 is finished processing, resulting in errors (NPE since the @Inject isn't processed?)", "author": "rdebusscher", "createdAt": "2020-02-10T14:06:08Z", "path": "nucleus/payara-modules/nucleus-microprofile/config-service/src/main/java/fish/payara/nucleus/microprofile/config/spi/ConfigProviderResolverImpl.java", "diffHunk": "@@ -129,31 +126,34 @@\n \n     // Gives access to deployed applications\n     @Inject\n-    ApplicationRegistry applicationRegistry;\n-    \n+    private ApplicationRegistry applicationRegistry;\n+\n     // This injects the configuration from the domain.xml magically\n     // and for the correct server configuation\n     @Inject\n     @Named(ServerEnvironment.DEFAULT_INSTANCE_NAME)\n     @Optional // PAYARA-2255 make optional due to race condition writing a missing entry into domain.xml\n-    MicroprofileConfigConfiguration configuration;\n+    private MicroprofileConfigConfiguration configuration;\n \n     // a config used at the server level when there is no application associated with the thread\n     private Config serverLevelConfig;\n \n+    /**\n+     * Sets the global {@link ConfigProviderResolver#instance()} to this instance.\n+     */\n     public ConfigProviderResolverImpl() {\n+        LOG.finest(\"ConfigProviderResolverImpl()\");\n+        // the setInstance is not synchronized, but instance() method body is.\n+        // this will block possible concurrent access.\n+        synchronized (ConfigProviderResolver.class) {\n+            LOG.log(Level.CONFIG, \"Setting global ConfigProviderResolver instance to {0}\", this);\n+            ConfigProviderResolver.setInstance(this);", "originalCommit": "e4a4c75bee34a532efd0a75300be0d25eaa4c6e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzExODMzNQ==", "url": "https://github.com/payara/Payara/pull/4480#discussion_r377118335", "bodyText": "I agree, I was a bit too agressive and this is an antipattern (providing this before finishing constructor). But ... if we don't have other possibility, isn't the @PostConstruct method same situation?\nFrom what I tested, @Inject will not cause NPE here, because HK2 will block any injection until it finishes PostConstruct method (constructor already finished). Bigger problem is programmatic usage of Globals class.", "author": "dmatej", "createdAt": "2020-02-10T15:05:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzA4MTcxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzE2Nzk4NA==", "url": "https://github.com/payara/Payara/pull/4480#discussion_r377167984", "bodyText": "Semantics of postconstruct guarantees that fields are set. The situation we're dealing with here is that someone triggered mp config API before this service was initialised. Postconstruct is therefore almost proper time as it is considered initialized after the method exits\nInjections of this class via globals is indeed wrong. But it is used by config sources, and those are created by this service. Plain constructor parameter would be better here.", "author": "pdudits", "createdAt": "2020-02-10T16:22:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzA4MTcxMA=="}], "type": "inlineReview"}, {"oid": "a12e0db31c6f5c86e782fbe2effae6822a5972bb", "url": "https://github.com/payara/Payara/commit/a12e0db31c6f5c86e782fbe2effae6822a5972bb", "message": "CUSTCOM-135 Code moved from constructor to postConstruct method\n\n- safer, all fields should be set here.", "committedDate": "2020-02-10T17:57:39Z", "type": "commit"}]}