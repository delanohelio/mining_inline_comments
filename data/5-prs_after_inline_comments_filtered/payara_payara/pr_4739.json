{"pr_number": 4739, "pr_title": "FISH-205 Implement Dynamic Micro Logging Properties", "pr_createdAt": "2020-06-23T10:46:03Z", "pr_url": "https://github.com/payara/Payara/pull/4739", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAwMTM1Ng==", "url": "https://github.com/payara/Payara/pull/4739#discussion_r447001356", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    if (event.kind() == StandardWatchEventKinds.OVERFLOW) continue;\n          \n          \n            \n                                    if (event.kind() == StandardWatchEventKinds.OVERFLOW) {\n          \n          \n            \n                                        continue;\n          \n          \n            \n                                    }\n          \n      \n    \n    \n  \n\n(\u256f\u00b0\u25a1\u00b0\uff09\u256f\ufe35 \u253b\u2501\u253b", "author": "Pandrex247", "createdAt": "2020-06-29T14:10:43Z", "path": "nucleus/payara-modules/payara-executor-service/src/main/java/fish/payara/nucleus/executorservice/PayaraFileWatcher.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.executorservice;\n+\n+import static java.lang.String.format;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static java.util.logging.Level.WARNING;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Path;\n+import java.nio.file.StandardWatchEventKinds;\n+import java.nio.file.WatchEvent;\n+import java.nio.file.WatchKey;\n+import java.nio.file.WatchService;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.logging.Logger;\n+\n+import javax.annotation.PostConstruct;\n+import javax.annotation.PreDestroy;\n+import javax.inject.Inject;\n+\n+import org.glassfish.api.StartupRunLevel;\n+import org.glassfish.api.event.EventListener;\n+import org.glassfish.api.event.EventTypes;\n+import org.glassfish.api.event.Events;\n+import org.glassfish.hk2.runlevel.RunLevel;\n+import org.glassfish.internal.deployment.Deployment;\n+import org.jvnet.hk2.annotations.Service;\n+\n+@Service(name = \"payara-file-watcher\")\n+@RunLevel(StartupRunLevel.VAL)\n+public class PayaraFileWatcher implements EventListener {\n+\n+    private static final Logger LOGGER = Logger.getLogger(PayaraFileWatcher.class.getName());\n+\n+    private static final Map<Path, Runnable> LISTENER_MAP = new HashMap<>();\n+    private static final Set<Path> PATHS_TO_WATCH = new HashSet<>();\n+\n+    private volatile boolean running;\n+\n+    private WatchService watcher;\n+\n+    @Inject\n+    private Events events;\n+\n+    @Inject\n+    private PayaraExecutorService executor;\n+\n+    public static void watch(Path path, Runnable runnable) {\n+        PATHS_TO_WATCH.add(path);\n+        LISTENER_MAP.put(path, runnable);\n+    }\n+\n+    /**\n+     * Empty the map of file listeners, registering each one with the watch service\n+     */\n+    private void registerQueuedPaths() {\n+        if (!PATHS_TO_WATCH.isEmpty()) {\n+\n+            // Iterate through paths\n+            Iterator<Path> pathIterator = PATHS_TO_WATCH.iterator();\n+            while (pathIterator.hasNext()) {\n+\n+                // Get the directory of a registered path\n+                Path path = pathIterator.next();\n+                if (path.toFile().isFile()) {\n+                    path = path.getParent();\n+                }\n+\n+                try {\n+                    path.register(watcher, StandardWatchEventKinds.ENTRY_MODIFY, StandardWatchEventKinds.ENTRY_DELETE);\n+                    LOGGER.fine(format(\"Watching path: %s\", path));\n+                } catch (IOException ex) {\n+                    LOGGER.log(WARNING, format(\"Failed to register path %s with the watch service\", path), ex);\n+                }\n+\n+                pathIterator.remove();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * The event loop method\n+     */\n+    private void run() {\n+        registerQueuedPaths();\n+        try {\n+            // Block, waiting for an event on a watched file\n+            WatchKey key = watcher.take();\n+\n+            // Loop through the events\n+            for (WatchEvent<?> event : key.pollEvents()) {\n+                // Find the absolute path of the modified file\n+                final Path modifiedPath = ((Path) key.watchable()).resolve((Path) event.context());\n+\n+                // Loop through the watched paths to find the action associated with it\n+                Iterator<Entry<Path, Runnable>> watchIterator = LISTENER_MAP.entrySet().iterator();\n+                while (watchIterator.hasNext()) {\n+                    Entry<Path, Runnable> watchEntry = watchIterator.next();\n+\n+                    // If this entry corresponds to the modified file\n+                    if (modifiedPath.endsWith(watchEntry.getKey())) {\n+                        // Ignore overflow events\n+                        if (event.kind() == StandardWatchEventKinds.OVERFLOW) continue;", "originalCommit": "0ce320e47187c4efd76f1deda6ae435ca3fc52f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA4Mjk1Nw==", "url": "https://github.com/payara/Payara/pull/4739#discussion_r447082957", "bodyText": "Could these not be at the top?\nThis is edging dangerously close to the mindset of class variables being declared at the bottom, and that's an abyss that's swallowed many a good developer.\nSeriously though they're at the top in most other classes.", "author": "Pandrex247", "createdAt": "2020-06-29T16:03:16Z", "path": "nucleus/payara-modules/payara-executor-service/src/main/java/fish/payara/nucleus/executorservice/PayaraFileWatcher.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.nucleus.executorservice;\n+\n+import static java.lang.String.format;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static java.util.logging.Level.WARNING;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Path;\n+import java.nio.file.StandardWatchEventKinds;\n+import java.nio.file.WatchEvent;\n+import java.nio.file.WatchKey;\n+import java.nio.file.WatchService;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.logging.Logger;\n+\n+import javax.annotation.PostConstruct;\n+import javax.annotation.PreDestroy;\n+import javax.inject.Inject;\n+\n+import org.glassfish.api.StartupRunLevel;\n+import org.glassfish.api.event.EventListener;\n+import org.glassfish.api.event.EventTypes;\n+import org.glassfish.api.event.Events;\n+import org.glassfish.hk2.runlevel.RunLevel;\n+import org.glassfish.internal.deployment.Deployment;\n+import org.jvnet.hk2.annotations.Service;\n+\n+@Service(name = \"payara-file-watcher\")\n+@RunLevel(StartupRunLevel.VAL)\n+public class PayaraFileWatcher implements EventListener {\n+\n+    private static final Logger LOGGER = Logger.getLogger(PayaraFileWatcher.class.getName());\n+\n+    private static final Map<Path, Runnable> LISTENER_MAP = new HashMap<>();\n+    private static final Set<Path> PATHS_TO_WATCH = new HashSet<>();\n+\n+    private volatile boolean running;\n+\n+    private WatchService watcher;\n+\n+    @Inject\n+    private Events events;\n+\n+    @Inject\n+    private PayaraExecutorService executor;\n+\n+    public static void watch(Path path, Runnable runnable) {\n+        PATHS_TO_WATCH.add(path);\n+        LISTENER_MAP.put(path, runnable);\n+    }\n+\n+    /**\n+     * Empty the map of file listeners, registering each one with the watch service\n+     */\n+    private void registerQueuedPaths() {\n+        if (!PATHS_TO_WATCH.isEmpty()) {\n+\n+            // Iterate through paths\n+            Iterator<Path> pathIterator = PATHS_TO_WATCH.iterator();\n+            while (pathIterator.hasNext()) {\n+\n+                // Get the directory of a registered path\n+                Path path = pathIterator.next();\n+                if (path.toFile().isFile()) {\n+                    path = path.getParent();\n+                }\n+\n+                try {\n+                    path.register(watcher, StandardWatchEventKinds.ENTRY_MODIFY, StandardWatchEventKinds.ENTRY_DELETE);\n+                    LOGGER.fine(format(\"Watching path: %s\", path));\n+                } catch (IOException ex) {\n+                    LOGGER.log(WARNING, format(\"Failed to register path %s with the watch service\", path), ex);\n+                }\n+\n+                pathIterator.remove();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * The event loop method\n+     */\n+    private void run() {\n+        registerQueuedPaths();\n+        try {\n+            // Block, waiting for an event on a watched file\n+            WatchKey key = watcher.take();\n+\n+            // Loop through the events\n+            for (WatchEvent<?> event : key.pollEvents()) {\n+                // Find the absolute path of the modified file\n+                final Path modifiedPath = ((Path) key.watchable()).resolve((Path) event.context());\n+\n+                // Loop through the watched paths to find the action associated with it\n+                Iterator<Entry<Path, Runnable>> watchIterator = LISTENER_MAP.entrySet().iterator();\n+                while (watchIterator.hasNext()) {\n+                    Entry<Path, Runnable> watchEntry = watchIterator.next();\n+\n+                    // If this entry corresponds to the modified file\n+                    if (modifiedPath.endsWith(watchEntry.getKey())) {\n+                        // Ignore overflow events\n+                        if (event.kind() == StandardWatchEventKinds.OVERFLOW) continue;\n+\n+                        File modifiedFile = modifiedPath.toFile();\n+\n+                        // If it's been deleted, remove the file watcher\n+                        if (event.kind() == StandardWatchEventKinds.ENTRY_DELETE && !modifiedFile.exists()) {\n+                            LOGGER.info(format(\"Watched file %s was deleted; removing the file watcher\", modifiedPath));\n+                            watchIterator.remove();\n+                        } else if (event.kind() == StandardWatchEventKinds.ENTRY_MODIFY && modifiedFile.length() > 0) {\n+                            // Run the associated action\n+                            LOGGER.fine(format(\"Watched file %s modified, running the listener\", modifiedPath));\n+                            watchEntry.getValue().run();\n+                        }\n+                    }\n+                }\n+            }\n+            key.reset();\n+        } catch (InterruptedException ex) {\n+            LOGGER.log(WARNING, \"The file watcher thread was interrupted\", ex);\n+        }\n+    }\n+\n+    private synchronized void initialise() {\n+        if (!running && !PATHS_TO_WATCH.isEmpty()) {\n+            try {\n+                watcher = FileSystems.getDefault().newWatchService();\n+                executor.scheduleWithFixedDelay(this::run, 0, 1, SECONDS);\n+                running = true;\n+                LOGGER.info(\"Initialised the file watcher service\");\n+            } catch (IOException ex) {\n+                LOGGER.log(WARNING, \"Failed to initialise the watch service\", ex);\n+            }\n+        }\n+    }\n+\n+\n+    private synchronized void terminate() {\n+        if (running) {\n+            try {\n+                watcher.close();\n+                running = false;\n+                LOGGER.info(\"Terminated the file watcher service\");\n+            } catch (IOException ex) {\n+                LOGGER.log(WARNING, \"Failed to terminate the watch service\", ex);\n+            }\n+        }\n+    }\n+\n+    // Lifecycle methods", "originalCommit": "0ce320e47187c4efd76f1deda6ae435ca3fc52f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUwNDY0OQ==", "url": "https://github.com/payara/Payara/pull/4739#discussion_r447504649", "bodyText": "I haven't seen it explicitly declared in any of our code styling comments so I assumed it was open to interpretation! To me, these methods belong at the back, but I'm happy to move them to the top", "author": "MattGill98", "createdAt": "2020-06-30T08:26:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA4Mjk1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODIzNTI4Ng==", "url": "https://github.com/payara/Payara/pull/4739#discussion_r448235286", "bodyText": "You're right they don't seem to be mentioned in the Sun code conventions (or if they are they're not where I expect them to be).\nI'd still prefer it if PostConstruct at least was at the top though - in most occurrences it seems to be near the top (PreDestroy is all over the place lol).\nI tend to count lifecycle methods in a similar vein to constructors, if anything a constructor is also a lifecycle method.\nPostConstruct I'd always expect to find at the top - when reading the code (and debugging) it means you don't start at the top, jump to the bottom, then go back to the top again.", "author": "Pandrex247", "createdAt": "2020-07-01T09:25:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA4Mjk1Nw=="}], "type": "inlineReview"}, {"oid": "b13fe4b88dca52f3cc7212e91880a505dfc19ea5", "url": "https://github.com/payara/Payara/commit/b13fe4b88dca52f3cc7212e91880a505dfc19ea5", "message": "FISH-205 Create File Watcher Service\n\nCreated a file watching service that can be interacted with statically\nto allow the Payara Micro boot sequence to queue up paths to watch\nbefore HK2 starts. Works by allowing any classto register actions to\ncomplete when a specific file or path is modified.\n\nThe static methods will still work post-startup as the loop checks the\nstatic list.\n\nSigned-off-by: Matthew Gill <matthew.gill@live.co.uk>", "committedDate": "2020-07-02T08:32:30Z", "type": "commit"}, {"oid": "b9989b8016757936b9a72602a84a557a5f939e76", "url": "https://github.com/payara/Payara/commit/b9989b8016757936b9a72602a84a557a5f939e76", "message": "FISH-205 Add enableDynamicLogging Micro flag\n\nThe flag isn't currently linked to anything, but whilst its\nnon-functional the groundwork should still be in place to work properly\nin Payara Micro.\n\nSigned-off-by: Matthew Gill <matthew.gill@live.co.uk>", "committedDate": "2020-07-02T08:32:36Z", "type": "commit"}, {"oid": "b41215f69850e06cc9fbf311cd3c56b6bd306bf9", "url": "https://github.com/payara/Payara/commit/b41215f69850e06cc9fbf311cd3c56b6bd306bf9", "message": "FISH-205 Implement dynamic logging functionality\n\nThe --enableDynamicLogging option now makes use of the file watcher\nservice to dynamically update logging properties.\n\nSigned-off-by: Matthew Gill <matthew.gill@live.co.uk>", "committedDate": "2020-07-02T08:32:36Z", "type": "commit"}, {"oid": "b41215f69850e06cc9fbf311cd3c56b6bd306bf9", "url": "https://github.com/payara/Payara/commit/b41215f69850e06cc9fbf311cd3c56b6bd306bf9", "message": "FISH-205 Implement dynamic logging functionality\n\nThe --enableDynamicLogging option now makes use of the file watcher\nservice to dynamically update logging properties.\n\nSigned-off-by: Matthew Gill <matthew.gill@live.co.uk>", "committedDate": "2020-07-02T08:32:36Z", "type": "forcePushed"}]}