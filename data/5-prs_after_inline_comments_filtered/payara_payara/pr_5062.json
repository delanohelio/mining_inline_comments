{"pr_number": 5062, "pr_title": "FISH-868 JWT public key is cached for a configurable amount of time.", "pr_createdAt": "2020-12-18T04:53:32Z", "pr_url": "https://github.com/payara/Payara/pull/5062", "timeline": [{"oid": "55bab85e5c465bd70ad473950073a46219e2bbc3", "url": "https://github.com/payara/Payara/commit/55bab85e5c465bd70ad473950073a46219e2bbc3", "message": "FISH-868 JWT public key is cached for a configurable amount of time.", "committedDate": "2020-12-18T04:06:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ1NjM3OA==", "url": "https://github.com/payara/Payara/pull/5062#discussion_r546456378", "bodyText": "Does it make sense to read the HTTP cache headers here and use an eventually provided TTL for caching? Just as an override to the configured one. Especially if there is none configured.", "author": "svendiedrichsen", "createdAt": "2020-12-21T00:06:54Z", "path": "appserver/payara-appserver-modules/microprofile/jwt-auth/src/main/java/fish/payara/microprofile/jwtauth/eesecurity/JwtPublicKeyStore.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.microprofile.jwtauth.eesecurity;\n+\n+import static java.lang.Thread.currentThread;\n+import static org.eclipse.microprofile.jwt.config.Names.VERIFIER_PUBLIC_KEY;\n+import static org.eclipse.microprofile.jwt.config.Names.VERIFIER_PUBLIC_KEY_LOCATION;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.StringReader;\n+import java.math.BigInteger;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.Charset;\n+import java.nio.charset.IllegalCharsetNameException;\n+import java.security.KeyFactory;\n+import java.security.PublicKey;\n+import java.security.spec.RSAPublicKeySpec;\n+import java.security.spec.X509EncodedKeySpec;\n+import java.util.Base64;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import javax.enterprise.inject.spi.DeploymentException;\n+import javax.json.Json;\n+import javax.json.JsonArray;\n+import javax.json.JsonObject;\n+import javax.json.JsonReader;\n+import javax.json.JsonValue;\n+\n+import org.eclipse.microprofile.config.Config;\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.glassfish.grizzly.http.util.ContentType;\n+\n+class JwtPublicKeyStore {\n+    \n+    private static final Logger LOGGER = Logger.getLogger(JwtPublicKeyStore.class.getName());\n+    private static final String RSA_ALGORITHM = \"RSA\";\n+        \n+    private final Config config;\n+    private final Supplier<Optional<String>> cache;\n+    \n+    /**\n+     * @param cacheTTL Public key cache TTL in seconds\n+     */\n+    public JwtPublicKeyStore(Long cacheTTL) {\n+        this.config = ConfigProvider.getConfig();\n+        if(cacheTTL > 0)\n+            cache = new PublicKeyLoadingCache(cacheTTL, this::readRawPublicKey)::get;\n+        else\n+            cache = this::readRawPublicKey;\n+    }\n+\n+    /**\n+     * \n+     * @param keyID The JWT key ID or null if no key ID was provided\n+     * @return Public key that can be used to verify the JWT\n+     * @throws IllegalStateException if no public key was found\n+     */\n+    public PublicKey getPublicKey(String keyID) {\n+        return cache.get()\n+            .map(key -> createPublicKey(key, keyID))\n+            .orElseThrow(() -> new IllegalStateException(\"No PublicKey found\"));\n+    }\n+    \n+    private Optional<String> readRawPublicKey() {\n+        Optional<String> publicKey = readDefaultPublicKey();\n+        \n+        if (!publicKey.isPresent()) {\n+            publicKey = readMPEmbeddedPublicKey();\n+        }\n+        if (!publicKey.isPresent()) {\n+            publicKey = readMPPublicKeyFromLocation();\n+        }\n+        return publicKey;\n+    }\n+    \n+    private Optional<String> readDefaultPublicKey() {\n+        return readPublicKeyFromLocation(\"/publicKey.pem\");\n+    }\n+\n+    private Optional<String> readMPEmbeddedPublicKey() {\n+        return config.getOptionalValue(VERIFIER_PUBLIC_KEY, String.class);\n+    }\n+\n+    private Optional<String> readMPPublicKeyFromLocation() {\n+        Optional<String> locationOpt = config.getOptionalValue(VERIFIER_PUBLIC_KEY_LOCATION, String.class);\n+\n+        if (!locationOpt.isPresent()) {\n+            return Optional.empty();\n+        }\n+\n+        String publicKeyLocation = locationOpt.get();\n+\n+        return readPublicKeyFromLocation(publicKeyLocation);\n+    }\n+    \n+    private Optional<String> readPublicKeyFromLocation(String publicKeyLocation) {\n+\n+        URL publicKeyURL = currentThread().getContextClassLoader().getResource(publicKeyLocation);\n+\n+        if (publicKeyURL == null) {\n+            try {\n+                publicKeyURL = new URL(publicKeyLocation);\n+            } catch (MalformedURLException ex) {\n+                publicKeyURL = null;\n+            }\n+        }\n+        if (publicKeyURL == null) {\n+            return Optional.empty();\n+        }\n+        \n+        try { \n+            return readPublicKeyFromURL(publicKeyURL);\n+        } catch(IOException ex) {\n+            throw new IllegalStateException(\"Failed to read public key.\", ex);\n+        }\n+    }\n+    \n+    private Optional<String> readPublicKeyFromURL(URL publicKeyURL) throws IOException {\n+        \n+        URLConnection urlConnection = publicKeyURL.openConnection();\n+        Charset charset = Charset.defaultCharset();\n+        ContentType contentType = ContentType.newContentType(urlConnection.getContentType());\n+        if(contentType != null) {\n+            String charEncoding = contentType.getCharacterEncoding();\n+            if(charEncoding != null) {\n+                try {\n+                    if (!Charset.isSupported(charEncoding)) {\n+                        LOGGER.warning(\"Charset \" + charEncoding + \" for remote public key not supported, using default charset instead\");\n+                    } else {\n+                        charset = Charset.forName(contentType.getCharacterEncoding());\n+                    }\n+                }catch (IllegalCharsetNameException ex){\n+                    LOGGER.severe(\"Charset \" + ex.getCharsetName() + \" for remote public key not support, Cause: \" + ex.getMessage());\n+                }\n+            }\n+        }\n+        try (InputStream inputStream = urlConnection.getInputStream();\n+            BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream, charset))){", "originalCommit": "55bab85e5c465bd70ad473950073a46219e2bbc3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ4NjY2Mw==", "url": "https://github.com/payara/Payara/pull/5062#discussion_r546486663", "bodyText": "I like that. Assuming we keep the TTL configurable in payara-mp-jwt.properties does this priority sound ok for determining the effective TTL? The HTTP headers would be preferred unless the developer overrides it in the configuration.\n\nTTL specified in payara-mp-jwt.properties. Disabled if set to 0.\nCache headers from an HttpURLConnection\nStandard default of n minutes", "author": "ghunteranderson", "createdAt": "2020-12-21T03:03:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ1NjM3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzIyNDE1MA==", "url": "https://github.com/payara/Payara/pull/5062#discussion_r547224150", "bodyText": "I wonder if its better to switch priorities 1 and 2. Thus honouring the HTTP header TTL the most although the configured TTL may be set differently. This allows the source of the public key to define the TTL which IMHO is the owner of the public key. Only if the source does not define any TTL the client/user of the public key may have its own rules for caching.", "author": "svendiedrichsen", "createdAt": "2020-12-22T11:27:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ1NjM3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzQyMDgxNw==", "url": "https://github.com/payara/Payara/pull/5062#discussion_r547420817", "bodyText": "My only hesitation with switching 1 and 2 was that the developer is powerless to override the cache headers. I'd hope that the HTTP cache headers are reasonable but we can't guarantee that will be the case. Perhaps unreasonable cache headers isn't a problem Payara should be trying to solve. I'm torn.\nI'll get to work on this with the approach you suggested. I need to think through a good way to change the TTL at key load time. If we change our minds on priority, it should be an easy switch \ud83d\ude42 .\nThanks for the feedback!", "author": "ghunteranderson", "createdAt": "2020-12-22T18:01:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ1NjM3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzQ0ODcxMw==", "url": "https://github.com/payara/Payara/pull/5062#discussion_r547448713", "bodyText": "Maybe just avoid unreasonable TTL header values which are too short lived or too long. Whatever this is. ;)", "author": "svendiedrichsen", "createdAt": "2020-12-22T18:55:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ1NjM3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzQ2MDcyOA==", "url": "https://github.com/payara/Payara/pull/5062#discussion_r547460728", "bodyText": "I suppose \"unreasonable\" is pretty arbitrary \ud83d\ude05. I'll begin making those changes as soon as I can. I won't be as available with the holidays approaching but I should be able to push an update before the year ends.", "author": "ghunteranderson", "createdAt": "2020-12-22T19:20:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ1NjM3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzg0MjAwOA==", "url": "https://github.com/payara/Payara/pull/5062#discussion_r547842008", "bodyText": "Sure. Happy holidays!", "author": "svendiedrichsen", "createdAt": "2020-12-23T09:15:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ1NjM3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg2NjYzNQ==", "url": "https://github.com/payara/Payara/pull/5062#discussion_r556866635", "bodyText": "@ghunteranderson, will you make the changes to consider the TTL in the cache headers of the response then?", "author": "fturizo", "createdAt": "2021-01-13T21:48:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ1NjM3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjkyOTMwMw==", "url": "https://github.com/payara/Payara/pull/5062#discussion_r556929303", "bodyText": "Hello @fturizo. Thanks for the feedback \ud83d\ude42  I'll make these changes including the HTTP one. It's taken me a little bit longer than I expect to get back to this.", "author": "ghunteranderson", "createdAt": "2021-01-13T22:48:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ1NjM3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTAyNzQ3NQ==", "url": "https://github.com/payara/Payara/pull/5062#discussion_r559027475", "bodyText": "I've added support for reading the max-age header and using that as an override for the cache TTL. It's ready for review whenever you are.", "author": "ghunteranderson", "createdAt": "2021-01-16T19:59:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjQ1NjM3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjgyNzkyMw==", "url": "https://github.com/payara/Payara/pull/5062#discussion_r556827923", "bodyText": "Add the brackets to these statements for consistent code.", "author": "fturizo", "createdAt": "2021-01-13T21:06:04Z", "path": "appserver/payara-appserver-modules/microprofile/jwt-auth/src/main/java/fish/payara/microprofile/jwtauth/eesecurity/JwtPublicKeyStore.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.microprofile.jwtauth.eesecurity;\n+\n+import static java.lang.Thread.currentThread;\n+import static org.eclipse.microprofile.jwt.config.Names.VERIFIER_PUBLIC_KEY;\n+import static org.eclipse.microprofile.jwt.config.Names.VERIFIER_PUBLIC_KEY_LOCATION;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.StringReader;\n+import java.math.BigInteger;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.Charset;\n+import java.nio.charset.IllegalCharsetNameException;\n+import java.security.KeyFactory;\n+import java.security.PublicKey;\n+import java.security.spec.RSAPublicKeySpec;\n+import java.security.spec.X509EncodedKeySpec;\n+import java.util.Base64;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import javax.enterprise.inject.spi.DeploymentException;\n+import javax.json.Json;\n+import javax.json.JsonArray;\n+import javax.json.JsonObject;\n+import javax.json.JsonReader;\n+import javax.json.JsonValue;\n+\n+import org.eclipse.microprofile.config.Config;\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.glassfish.grizzly.http.util.ContentType;\n+\n+class JwtPublicKeyStore {\n+    \n+    private static final Logger LOGGER = Logger.getLogger(JwtPublicKeyStore.class.getName());\n+    private static final String RSA_ALGORITHM = \"RSA\";\n+        \n+    private final Config config;\n+    private final Supplier<Optional<String>> cache;\n+    \n+    /**\n+     * @param cacheTTL Public key cache TTL in seconds\n+     */\n+    public JwtPublicKeyStore(Long cacheTTL) {\n+        this.config = ConfigProvider.getConfig();\n+        if(cacheTTL > 0)", "originalCommit": "55bab85e5c465bd70ad473950073a46219e2bbc3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjgyOTQwMg==", "url": "https://github.com/payara/Payara/pull/5062#discussion_r556829402", "bodyText": "Missing brackets.", "author": "fturizo", "createdAt": "2021-01-13T21:08:44Z", "path": "appserver/payara-appserver-modules/microprofile/jwt-auth/src/main/java/fish/payara/microprofile/jwtauth/eesecurity/JwtPublicKeyStore.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.microprofile.jwtauth.eesecurity;\n+\n+import static java.lang.Thread.currentThread;\n+import static org.eclipse.microprofile.jwt.config.Names.VERIFIER_PUBLIC_KEY;\n+import static org.eclipse.microprofile.jwt.config.Names.VERIFIER_PUBLIC_KEY_LOCATION;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.StringReader;\n+import java.math.BigInteger;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.Charset;\n+import java.nio.charset.IllegalCharsetNameException;\n+import java.security.KeyFactory;\n+import java.security.PublicKey;\n+import java.security.spec.RSAPublicKeySpec;\n+import java.security.spec.X509EncodedKeySpec;\n+import java.util.Base64;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import javax.enterprise.inject.spi.DeploymentException;\n+import javax.json.Json;\n+import javax.json.JsonArray;\n+import javax.json.JsonObject;\n+import javax.json.JsonReader;\n+import javax.json.JsonValue;\n+\n+import org.eclipse.microprofile.config.Config;\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.glassfish.grizzly.http.util.ContentType;\n+\n+class JwtPublicKeyStore {\n+    \n+    private static final Logger LOGGER = Logger.getLogger(JwtPublicKeyStore.class.getName());\n+    private static final String RSA_ALGORITHM = \"RSA\";\n+        \n+    private final Config config;\n+    private final Supplier<Optional<String>> cache;\n+    \n+    /**\n+     * @param cacheTTL Public key cache TTL in seconds\n+     */\n+    public JwtPublicKeyStore(Long cacheTTL) {\n+        this.config = ConfigProvider.getConfig();\n+        if(cacheTTL > 0)\n+            cache = new PublicKeyLoadingCache(cacheTTL, this::readRawPublicKey)::get;\n+        else\n+            cache = this::readRawPublicKey;\n+    }\n+\n+    /**\n+     * \n+     * @param keyID The JWT key ID or null if no key ID was provided\n+     * @return Public key that can be used to verify the JWT\n+     * @throws IllegalStateException if no public key was found\n+     */\n+    public PublicKey getPublicKey(String keyID) {\n+        return cache.get()\n+            .map(key -> createPublicKey(key, keyID))\n+            .orElseThrow(() -> new IllegalStateException(\"No PublicKey found\"));\n+    }\n+    \n+    private Optional<String> readRawPublicKey() {\n+        Optional<String> publicKey = readDefaultPublicKey();\n+        \n+        if (!publicKey.isPresent()) {\n+            publicKey = readMPEmbeddedPublicKey();\n+        }\n+        if (!publicKey.isPresent()) {\n+            publicKey = readMPPublicKeyFromLocation();\n+        }\n+        return publicKey;\n+    }\n+    \n+    private Optional<String> readDefaultPublicKey() {\n+        return readPublicKeyFromLocation(\"/publicKey.pem\");\n+    }\n+\n+    private Optional<String> readMPEmbeddedPublicKey() {\n+        return config.getOptionalValue(VERIFIER_PUBLIC_KEY, String.class);\n+    }\n+\n+    private Optional<String> readMPPublicKeyFromLocation() {\n+        Optional<String> locationOpt = config.getOptionalValue(VERIFIER_PUBLIC_KEY_LOCATION, String.class);\n+\n+        if (!locationOpt.isPresent()) {\n+            return Optional.empty();\n+        }\n+\n+        String publicKeyLocation = locationOpt.get();\n+\n+        return readPublicKeyFromLocation(publicKeyLocation);\n+    }\n+    \n+    private Optional<String> readPublicKeyFromLocation(String publicKeyLocation) {\n+\n+        URL publicKeyURL = currentThread().getContextClassLoader().getResource(publicKeyLocation);\n+\n+        if (publicKeyURL == null) {\n+            try {\n+                publicKeyURL = new URL(publicKeyLocation);\n+            } catch (MalformedURLException ex) {\n+                publicKeyURL = null;\n+            }\n+        }\n+        if (publicKeyURL == null) {\n+            return Optional.empty();\n+        }\n+        \n+        try { \n+            return readPublicKeyFromURL(publicKeyURL);\n+        } catch(IOException ex) {\n+            throw new IllegalStateException(\"Failed to read public key.\", ex);\n+        }\n+    }\n+    \n+    private Optional<String> readPublicKeyFromURL(URL publicKeyURL) throws IOException {\n+        \n+        URLConnection urlConnection = publicKeyURL.openConnection();\n+        Charset charset = Charset.defaultCharset();\n+        ContentType contentType = ContentType.newContentType(urlConnection.getContentType());\n+        if(contentType != null) {\n+            String charEncoding = contentType.getCharacterEncoding();\n+            if(charEncoding != null) {\n+                try {\n+                    if (!Charset.isSupported(charEncoding)) {\n+                        LOGGER.warning(\"Charset \" + charEncoding + \" for remote public key not supported, using default charset instead\");\n+                    } else {\n+                        charset = Charset.forName(contentType.getCharacterEncoding());\n+                    }\n+                }catch (IllegalCharsetNameException ex){\n+                    LOGGER.severe(\"Charset \" + ex.getCharsetName() + \" for remote public key not support, Cause: \" + ex.getMessage());\n+                }\n+            }\n+        }\n+        try (InputStream inputStream = urlConnection.getInputStream();\n+            BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream, charset))){\n+            String keyContents = reader.lines().collect(Collectors.joining(System.lineSeparator()));\n+            return Optional.of(keyContents);\n+        }\n+        \n+    }\n+\n+    private PublicKey createPublicKey(String key, String keyID) {\n+        try {\n+            return createPublicKeyFromPem(key);\n+        } catch (Exception pemEx) {\n+            try {\n+                return createPublicKeyFromJWKS(key, keyID);\n+            } catch (Exception jwksEx) {\n+                throw new DeploymentException(jwksEx);\n+            }\n+        }\n+    }\n+\n+    private PublicKey createPublicKeyFromPem(String key) throws Exception {\n+        key = key.replaceAll(\"-----BEGIN (.*)-----\", \"\")\n+                .replaceAll(\"-----END (.*)----\", \"\")\n+                .replaceAll(\"\\r\\n\", \"\")\n+                .replaceAll(\"\\n\", \"\")\n+                .trim();\n+\n+        byte[] keyBytes = Base64.getDecoder().decode(key);\n+        X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(keyBytes);\n+        return KeyFactory.getInstance(RSA_ALGORITHM)\n+                .generatePublic(publicKeySpec);\n+\n+    }\n+\n+    private PublicKey createPublicKeyFromJWKS(String jwksValue, String keyID) throws Exception {\n+        JsonObject jwks = parseJwks(jwksValue);\n+        JsonArray keys = jwks.getJsonArray(\"keys\");\n+        JsonObject jwk = keys != null ? findJwk(keys, keyID) : jwks;\n+\n+        // the public exponent\n+        byte[] exponentBytes = Base64.getUrlDecoder().decode(jwk.getString(\"e\"));\n+        BigInteger exponent = new BigInteger(1, exponentBytes);\n+\n+        // the modulus\n+        byte[] modulusBytes = Base64.getUrlDecoder().decode(jwk.getString(\"n\"));\n+        BigInteger modulus = new BigInteger(1, modulusBytes);\n+\n+        RSAPublicKeySpec publicKeySpec = new RSAPublicKeySpec(modulus, exponent);\n+        return KeyFactory.getInstance(RSA_ALGORITHM)\n+                .generatePublic(publicKeySpec);\n+    }\n+\n+    private JsonObject parseJwks(String jwksValue) throws Exception {\n+        JsonObject jwks;\n+        try (JsonReader reader = Json.createReader(new StringReader(jwksValue))) {\n+            jwks = reader.readObject();\n+        } catch (Exception ex) {\n+            // if jwks is encoded\n+            byte[] jwksDecodedValue = Base64.getDecoder().decode(jwksValue);\n+            try (InputStream jwksStream = new ByteArrayInputStream(jwksDecodedValue);\n+                    JsonReader reader = Json.createReader(jwksStream)) {\n+                jwks = reader.readObject();\n+            }\n+        }\n+        return jwks;\n+    }\n+\n+    private JsonObject findJwk(JsonArray keys, String keyID) {\n+        if (Objects.isNull(keyID) && keys.size() > 0) {\n+            return keys.getJsonObject(0);\n+        }\n+\n+        for (JsonValue value : keys) {\n+            JsonObject jwk = value.asJsonObject();\n+            if (Objects.equals(keyID, jwk.getString(\"kid\"))) {\n+                return jwk;\n+            }\n+        }\n+\n+        throw new IllegalStateException(\"No matching JWK for KeyID.\");\n+    }\n+    \n+    private static class PublicKeyLoadingCache {\n+        \n+        private final long ttl;\n+        private final Supplier<Optional<String>> loadingFunction;\n+        private long lastUpdated;\n+        private Optional<String> publicKey;\n+        \n+        \n+        public PublicKeyLoadingCache(long ttl, Supplier<Optional<String>> loadingFunction) {\n+            this.ttl = ttl;\n+            this.loadingFunction = loadingFunction;\n+            this.lastUpdated = 0;\n+        }\n+        \n+        public Optional<String> get() {\n+            long now = System.currentTimeMillis();\n+            if(now - lastUpdated > ttl)", "originalCommit": "55bab85e5c465bd70ad473950073a46219e2bbc3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg1MjY5OA==", "url": "https://github.com/payara/Payara/pull/5062#discussion_r556852698", "bodyText": "It is a bit confusing that this variable is named cache since it is not technically a cache. Better to name it to cacheSupplier.", "author": "fturizo", "createdAt": "2021-01-13T21:35:35Z", "path": "appserver/payara-appserver-modules/microprofile/jwt-auth/src/main/java/fish/payara/microprofile/jwtauth/eesecurity/JwtPublicKeyStore.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.microprofile.jwtauth.eesecurity;\n+\n+import static java.lang.Thread.currentThread;\n+import static org.eclipse.microprofile.jwt.config.Names.VERIFIER_PUBLIC_KEY;\n+import static org.eclipse.microprofile.jwt.config.Names.VERIFIER_PUBLIC_KEY_LOCATION;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.StringReader;\n+import java.math.BigInteger;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.Charset;\n+import java.nio.charset.IllegalCharsetNameException;\n+import java.security.KeyFactory;\n+import java.security.PublicKey;\n+import java.security.spec.RSAPublicKeySpec;\n+import java.security.spec.X509EncodedKeySpec;\n+import java.util.Base64;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import javax.enterprise.inject.spi.DeploymentException;\n+import javax.json.Json;\n+import javax.json.JsonArray;\n+import javax.json.JsonObject;\n+import javax.json.JsonReader;\n+import javax.json.JsonValue;\n+\n+import org.eclipse.microprofile.config.Config;\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.glassfish.grizzly.http.util.ContentType;\n+\n+class JwtPublicKeyStore {\n+    \n+    private static final Logger LOGGER = Logger.getLogger(JwtPublicKeyStore.class.getName());\n+    private static final String RSA_ALGORITHM = \"RSA\";\n+        \n+    private final Config config;\n+    private final Supplier<Optional<String>> cache;", "originalCommit": "55bab85e5c465bd70ad473950073a46219e2bbc3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg1NzM2NQ==", "url": "https://github.com/payara/Payara/pull/5062#discussion_r556857365", "bodyText": "Better to rename this class field to keySupplier instead to keep the consistency of the class.", "author": "fturizo", "createdAt": "2021-01-13T21:39:56Z", "path": "appserver/payara-appserver-modules/microprofile/jwt-auth/src/main/java/fish/payara/microprofile/jwtauth/eesecurity/JwtPublicKeyStore.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.microprofile.jwtauth.eesecurity;\n+\n+import static java.lang.Thread.currentThread;\n+import static org.eclipse.microprofile.jwt.config.Names.VERIFIER_PUBLIC_KEY;\n+import static org.eclipse.microprofile.jwt.config.Names.VERIFIER_PUBLIC_KEY_LOCATION;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.StringReader;\n+import java.math.BigInteger;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.Charset;\n+import java.nio.charset.IllegalCharsetNameException;\n+import java.security.KeyFactory;\n+import java.security.PublicKey;\n+import java.security.spec.RSAPublicKeySpec;\n+import java.security.spec.X509EncodedKeySpec;\n+import java.util.Base64;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import javax.enterprise.inject.spi.DeploymentException;\n+import javax.json.Json;\n+import javax.json.JsonArray;\n+import javax.json.JsonObject;\n+import javax.json.JsonReader;\n+import javax.json.JsonValue;\n+\n+import org.eclipse.microprofile.config.Config;\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.glassfish.grizzly.http.util.ContentType;\n+\n+class JwtPublicKeyStore {\n+    \n+    private static final Logger LOGGER = Logger.getLogger(JwtPublicKeyStore.class.getName());\n+    private static final String RSA_ALGORITHM = \"RSA\";\n+        \n+    private final Config config;\n+    private final Supplier<Optional<String>> cache;\n+    \n+    /**\n+     * @param cacheTTL Public key cache TTL in seconds\n+     */\n+    public JwtPublicKeyStore(Long cacheTTL) {\n+        this.config = ConfigProvider.getConfig();\n+        if(cacheTTL > 0)\n+            cache = new PublicKeyLoadingCache(cacheTTL, this::readRawPublicKey)::get;\n+        else\n+            cache = this::readRawPublicKey;\n+    }\n+\n+    /**\n+     * \n+     * @param keyID The JWT key ID or null if no key ID was provided\n+     * @return Public key that can be used to verify the JWT\n+     * @throws IllegalStateException if no public key was found\n+     */\n+    public PublicKey getPublicKey(String keyID) {\n+        return cache.get()\n+            .map(key -> createPublicKey(key, keyID))\n+            .orElseThrow(() -> new IllegalStateException(\"No PublicKey found\"));\n+    }\n+    \n+    private Optional<String> readRawPublicKey() {\n+        Optional<String> publicKey = readDefaultPublicKey();\n+        \n+        if (!publicKey.isPresent()) {\n+            publicKey = readMPEmbeddedPublicKey();\n+        }\n+        if (!publicKey.isPresent()) {\n+            publicKey = readMPPublicKeyFromLocation();\n+        }\n+        return publicKey;\n+    }\n+    \n+    private Optional<String> readDefaultPublicKey() {\n+        return readPublicKeyFromLocation(\"/publicKey.pem\");\n+    }\n+\n+    private Optional<String> readMPEmbeddedPublicKey() {\n+        return config.getOptionalValue(VERIFIER_PUBLIC_KEY, String.class);\n+    }\n+\n+    private Optional<String> readMPPublicKeyFromLocation() {\n+        Optional<String> locationOpt = config.getOptionalValue(VERIFIER_PUBLIC_KEY_LOCATION, String.class);\n+\n+        if (!locationOpt.isPresent()) {\n+            return Optional.empty();\n+        }\n+\n+        String publicKeyLocation = locationOpt.get();\n+\n+        return readPublicKeyFromLocation(publicKeyLocation);\n+    }\n+    \n+    private Optional<String> readPublicKeyFromLocation(String publicKeyLocation) {\n+\n+        URL publicKeyURL = currentThread().getContextClassLoader().getResource(publicKeyLocation);\n+\n+        if (publicKeyURL == null) {\n+            try {\n+                publicKeyURL = new URL(publicKeyLocation);\n+            } catch (MalformedURLException ex) {\n+                publicKeyURL = null;\n+            }\n+        }\n+        if (publicKeyURL == null) {\n+            return Optional.empty();\n+        }\n+        \n+        try { \n+            return readPublicKeyFromURL(publicKeyURL);\n+        } catch(IOException ex) {\n+            throw new IllegalStateException(\"Failed to read public key.\", ex);\n+        }\n+    }\n+    \n+    private Optional<String> readPublicKeyFromURL(URL publicKeyURL) throws IOException {\n+        \n+        URLConnection urlConnection = publicKeyURL.openConnection();\n+        Charset charset = Charset.defaultCharset();\n+        ContentType contentType = ContentType.newContentType(urlConnection.getContentType());\n+        if(contentType != null) {\n+            String charEncoding = contentType.getCharacterEncoding();\n+            if(charEncoding != null) {\n+                try {\n+                    if (!Charset.isSupported(charEncoding)) {\n+                        LOGGER.warning(\"Charset \" + charEncoding + \" for remote public key not supported, using default charset instead\");\n+                    } else {\n+                        charset = Charset.forName(contentType.getCharacterEncoding());\n+                    }\n+                }catch (IllegalCharsetNameException ex){\n+                    LOGGER.severe(\"Charset \" + ex.getCharsetName() + \" for remote public key not support, Cause: \" + ex.getMessage());\n+                }\n+            }\n+        }\n+        try (InputStream inputStream = urlConnection.getInputStream();\n+            BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream, charset))){\n+            String keyContents = reader.lines().collect(Collectors.joining(System.lineSeparator()));\n+            return Optional.of(keyContents);\n+        }\n+        \n+    }\n+\n+    private PublicKey createPublicKey(String key, String keyID) {\n+        try {\n+            return createPublicKeyFromPem(key);\n+        } catch (Exception pemEx) {\n+            try {\n+                return createPublicKeyFromJWKS(key, keyID);\n+            } catch (Exception jwksEx) {\n+                throw new DeploymentException(jwksEx);\n+            }\n+        }\n+    }\n+\n+    private PublicKey createPublicKeyFromPem(String key) throws Exception {\n+        key = key.replaceAll(\"-----BEGIN (.*)-----\", \"\")\n+                .replaceAll(\"-----END (.*)----\", \"\")\n+                .replaceAll(\"\\r\\n\", \"\")\n+                .replaceAll(\"\\n\", \"\")\n+                .trim();\n+\n+        byte[] keyBytes = Base64.getDecoder().decode(key);\n+        X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(keyBytes);\n+        return KeyFactory.getInstance(RSA_ALGORITHM)\n+                .generatePublic(publicKeySpec);\n+\n+    }\n+\n+    private PublicKey createPublicKeyFromJWKS(String jwksValue, String keyID) throws Exception {\n+        JsonObject jwks = parseJwks(jwksValue);\n+        JsonArray keys = jwks.getJsonArray(\"keys\");\n+        JsonObject jwk = keys != null ? findJwk(keys, keyID) : jwks;\n+\n+        // the public exponent\n+        byte[] exponentBytes = Base64.getUrlDecoder().decode(jwk.getString(\"e\"));\n+        BigInteger exponent = new BigInteger(1, exponentBytes);\n+\n+        // the modulus\n+        byte[] modulusBytes = Base64.getUrlDecoder().decode(jwk.getString(\"n\"));\n+        BigInteger modulus = new BigInteger(1, modulusBytes);\n+\n+        RSAPublicKeySpec publicKeySpec = new RSAPublicKeySpec(modulus, exponent);\n+        return KeyFactory.getInstance(RSA_ALGORITHM)\n+                .generatePublic(publicKeySpec);\n+    }\n+\n+    private JsonObject parseJwks(String jwksValue) throws Exception {\n+        JsonObject jwks;\n+        try (JsonReader reader = Json.createReader(new StringReader(jwksValue))) {\n+            jwks = reader.readObject();\n+        } catch (Exception ex) {\n+            // if jwks is encoded\n+            byte[] jwksDecodedValue = Base64.getDecoder().decode(jwksValue);\n+            try (InputStream jwksStream = new ByteArrayInputStream(jwksDecodedValue);\n+                    JsonReader reader = Json.createReader(jwksStream)) {\n+                jwks = reader.readObject();\n+            }\n+        }\n+        return jwks;\n+    }\n+\n+    private JsonObject findJwk(JsonArray keys, String keyID) {\n+        if (Objects.isNull(keyID) && keys.size() > 0) {\n+            return keys.getJsonObject(0);\n+        }\n+\n+        for (JsonValue value : keys) {\n+            JsonObject jwk = value.asJsonObject();\n+            if (Objects.equals(keyID, jwk.getString(\"kid\"))) {\n+                return jwk;\n+            }\n+        }\n+\n+        throw new IllegalStateException(\"No matching JWK for KeyID.\");\n+    }\n+    \n+    private static class PublicKeyLoadingCache {\n+        \n+        private final long ttl;\n+        private final Supplier<Optional<String>> loadingFunction;", "originalCommit": "55bab85e5c465bd70ad473950073a46219e2bbc3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg1ODY3MA==", "url": "https://github.com/payara/Payara/pull/5062#discussion_r556858670", "bodyText": "This statement is redundant since the value has been already initialized to 0.", "author": "fturizo", "createdAt": "2021-01-13T21:41:10Z", "path": "appserver/payara-appserver-modules/microprofile/jwt-auth/src/main/java/fish/payara/microprofile/jwtauth/eesecurity/JwtPublicKeyStore.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) [2017-2020] Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.microprofile.jwtauth.eesecurity;\n+\n+import static java.lang.Thread.currentThread;\n+import static org.eclipse.microprofile.jwt.config.Names.VERIFIER_PUBLIC_KEY;\n+import static org.eclipse.microprofile.jwt.config.Names.VERIFIER_PUBLIC_KEY_LOCATION;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.StringReader;\n+import java.math.BigInteger;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.nio.charset.Charset;\n+import java.nio.charset.IllegalCharsetNameException;\n+import java.security.KeyFactory;\n+import java.security.PublicKey;\n+import java.security.spec.RSAPublicKeySpec;\n+import java.security.spec.X509EncodedKeySpec;\n+import java.util.Base64;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+import javax.enterprise.inject.spi.DeploymentException;\n+import javax.json.Json;\n+import javax.json.JsonArray;\n+import javax.json.JsonObject;\n+import javax.json.JsonReader;\n+import javax.json.JsonValue;\n+\n+import org.eclipse.microprofile.config.Config;\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.glassfish.grizzly.http.util.ContentType;\n+\n+class JwtPublicKeyStore {\n+    \n+    private static final Logger LOGGER = Logger.getLogger(JwtPublicKeyStore.class.getName());\n+    private static final String RSA_ALGORITHM = \"RSA\";\n+        \n+    private final Config config;\n+    private final Supplier<Optional<String>> cache;\n+    \n+    /**\n+     * @param cacheTTL Public key cache TTL in seconds\n+     */\n+    public JwtPublicKeyStore(Long cacheTTL) {\n+        this.config = ConfigProvider.getConfig();\n+        if(cacheTTL > 0)\n+            cache = new PublicKeyLoadingCache(cacheTTL, this::readRawPublicKey)::get;\n+        else\n+            cache = this::readRawPublicKey;\n+    }\n+\n+    /**\n+     * \n+     * @param keyID The JWT key ID or null if no key ID was provided\n+     * @return Public key that can be used to verify the JWT\n+     * @throws IllegalStateException if no public key was found\n+     */\n+    public PublicKey getPublicKey(String keyID) {\n+        return cache.get()\n+            .map(key -> createPublicKey(key, keyID))\n+            .orElseThrow(() -> new IllegalStateException(\"No PublicKey found\"));\n+    }\n+    \n+    private Optional<String> readRawPublicKey() {\n+        Optional<String> publicKey = readDefaultPublicKey();\n+        \n+        if (!publicKey.isPresent()) {\n+            publicKey = readMPEmbeddedPublicKey();\n+        }\n+        if (!publicKey.isPresent()) {\n+            publicKey = readMPPublicKeyFromLocation();\n+        }\n+        return publicKey;\n+    }\n+    \n+    private Optional<String> readDefaultPublicKey() {\n+        return readPublicKeyFromLocation(\"/publicKey.pem\");\n+    }\n+\n+    private Optional<String> readMPEmbeddedPublicKey() {\n+        return config.getOptionalValue(VERIFIER_PUBLIC_KEY, String.class);\n+    }\n+\n+    private Optional<String> readMPPublicKeyFromLocation() {\n+        Optional<String> locationOpt = config.getOptionalValue(VERIFIER_PUBLIC_KEY_LOCATION, String.class);\n+\n+        if (!locationOpt.isPresent()) {\n+            return Optional.empty();\n+        }\n+\n+        String publicKeyLocation = locationOpt.get();\n+\n+        return readPublicKeyFromLocation(publicKeyLocation);\n+    }\n+    \n+    private Optional<String> readPublicKeyFromLocation(String publicKeyLocation) {\n+\n+        URL publicKeyURL = currentThread().getContextClassLoader().getResource(publicKeyLocation);\n+\n+        if (publicKeyURL == null) {\n+            try {\n+                publicKeyURL = new URL(publicKeyLocation);\n+            } catch (MalformedURLException ex) {\n+                publicKeyURL = null;\n+            }\n+        }\n+        if (publicKeyURL == null) {\n+            return Optional.empty();\n+        }\n+        \n+        try { \n+            return readPublicKeyFromURL(publicKeyURL);\n+        } catch(IOException ex) {\n+            throw new IllegalStateException(\"Failed to read public key.\", ex);\n+        }\n+    }\n+    \n+    private Optional<String> readPublicKeyFromURL(URL publicKeyURL) throws IOException {\n+        \n+        URLConnection urlConnection = publicKeyURL.openConnection();\n+        Charset charset = Charset.defaultCharset();\n+        ContentType contentType = ContentType.newContentType(urlConnection.getContentType());\n+        if(contentType != null) {\n+            String charEncoding = contentType.getCharacterEncoding();\n+            if(charEncoding != null) {\n+                try {\n+                    if (!Charset.isSupported(charEncoding)) {\n+                        LOGGER.warning(\"Charset \" + charEncoding + \" for remote public key not supported, using default charset instead\");\n+                    } else {\n+                        charset = Charset.forName(contentType.getCharacterEncoding());\n+                    }\n+                }catch (IllegalCharsetNameException ex){\n+                    LOGGER.severe(\"Charset \" + ex.getCharsetName() + \" for remote public key not support, Cause: \" + ex.getMessage());\n+                }\n+            }\n+        }\n+        try (InputStream inputStream = urlConnection.getInputStream();\n+            BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream, charset))){\n+            String keyContents = reader.lines().collect(Collectors.joining(System.lineSeparator()));\n+            return Optional.of(keyContents);\n+        }\n+        \n+    }\n+\n+    private PublicKey createPublicKey(String key, String keyID) {\n+        try {\n+            return createPublicKeyFromPem(key);\n+        } catch (Exception pemEx) {\n+            try {\n+                return createPublicKeyFromJWKS(key, keyID);\n+            } catch (Exception jwksEx) {\n+                throw new DeploymentException(jwksEx);\n+            }\n+        }\n+    }\n+\n+    private PublicKey createPublicKeyFromPem(String key) throws Exception {\n+        key = key.replaceAll(\"-----BEGIN (.*)-----\", \"\")\n+                .replaceAll(\"-----END (.*)----\", \"\")\n+                .replaceAll(\"\\r\\n\", \"\")\n+                .replaceAll(\"\\n\", \"\")\n+                .trim();\n+\n+        byte[] keyBytes = Base64.getDecoder().decode(key);\n+        X509EncodedKeySpec publicKeySpec = new X509EncodedKeySpec(keyBytes);\n+        return KeyFactory.getInstance(RSA_ALGORITHM)\n+                .generatePublic(publicKeySpec);\n+\n+    }\n+\n+    private PublicKey createPublicKeyFromJWKS(String jwksValue, String keyID) throws Exception {\n+        JsonObject jwks = parseJwks(jwksValue);\n+        JsonArray keys = jwks.getJsonArray(\"keys\");\n+        JsonObject jwk = keys != null ? findJwk(keys, keyID) : jwks;\n+\n+        // the public exponent\n+        byte[] exponentBytes = Base64.getUrlDecoder().decode(jwk.getString(\"e\"));\n+        BigInteger exponent = new BigInteger(1, exponentBytes);\n+\n+        // the modulus\n+        byte[] modulusBytes = Base64.getUrlDecoder().decode(jwk.getString(\"n\"));\n+        BigInteger modulus = new BigInteger(1, modulusBytes);\n+\n+        RSAPublicKeySpec publicKeySpec = new RSAPublicKeySpec(modulus, exponent);\n+        return KeyFactory.getInstance(RSA_ALGORITHM)\n+                .generatePublic(publicKeySpec);\n+    }\n+\n+    private JsonObject parseJwks(String jwksValue) throws Exception {\n+        JsonObject jwks;\n+        try (JsonReader reader = Json.createReader(new StringReader(jwksValue))) {\n+            jwks = reader.readObject();\n+        } catch (Exception ex) {\n+            // if jwks is encoded\n+            byte[] jwksDecodedValue = Base64.getDecoder().decode(jwksValue);\n+            try (InputStream jwksStream = new ByteArrayInputStream(jwksDecodedValue);\n+                    JsonReader reader = Json.createReader(jwksStream)) {\n+                jwks = reader.readObject();\n+            }\n+        }\n+        return jwks;\n+    }\n+\n+    private JsonObject findJwk(JsonArray keys, String keyID) {\n+        if (Objects.isNull(keyID) && keys.size() > 0) {\n+            return keys.getJsonObject(0);\n+        }\n+\n+        for (JsonValue value : keys) {\n+            JsonObject jwk = value.asJsonObject();\n+            if (Objects.equals(keyID, jwk.getString(\"kid\"))) {\n+                return jwk;\n+            }\n+        }\n+\n+        throw new IllegalStateException(\"No matching JWK for KeyID.\");\n+    }\n+    \n+    private static class PublicKeyLoadingCache {\n+        \n+        private final long ttl;\n+        private final Supplier<Optional<String>> loadingFunction;\n+        private long lastUpdated;\n+        private Optional<String> publicKey;\n+        \n+        \n+        public PublicKeyLoadingCache(long ttl, Supplier<Optional<String>> loadingFunction) {\n+            this.ttl = ttl;\n+            this.loadingFunction = loadingFunction;\n+            this.lastUpdated = 0;", "originalCommit": "55bab85e5c465bd70ad473950073a46219e2bbc3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg2NDk1Mw==", "url": "https://github.com/payara/Payara/pull/5062#discussion_r556864953", "bodyText": "Shouldn't this value be in milliseconds? The code in the PublicKeyLoadingCache class treats the TTL as milliseconds on its calculations for the refresh method. Either convert the value to milliseconds here or specify that the publicKey.cache.ttl property needs to be described in milliseconds.", "author": "fturizo", "createdAt": "2021-01-13T21:47:02Z", "path": "appserver/payara-appserver-modules/microprofile/jwt-auth/src/main/java/fish/payara/microprofile/jwtauth/eesecurity/SignedJWTIdentityStore.java", "diffHunk": "@@ -179,141 +151,13 @@ public CredentialValidationResult validate(SignedJWTCredential signedJWTCredenti\n     private Optional<Boolean> readDisableTypeVerification(Optional<Properties> properties) {\n         return properties.isPresent() ? Optional.ofNullable(Boolean.valueOf(properties.get().getProperty(\"disable.type.verification\", \"false\"))) : Optional.empty();\n     }\n-\n-    private Optional<PublicKey> readDefaultPublicKey() throws Exception {\n-        return readPublicKeyFromLocation(\"/publicKey.pem\", null);\n-    }\n-\n-    private Optional<PublicKey> readMPEmbeddedPublicKey(String keyID) throws Exception {\n-        Optional<String> key = config.getOptionalValue(VERIFIER_PUBLIC_KEY, String.class);\n-        if (!key.isPresent()) {\n-            return Optional.empty();\n-        }\n-        return createPublicKey(key.get(), keyID);\n-    }\n-\n-    private Optional<PublicKey> readMPPublicKeyFromLocation(String keyID) throws Exception {\n-        Optional<String> locationOpt = config.getOptionalValue(VERIFIER_PUBLIC_KEY_LOCATION, String.class);\n-\n-        if (!locationOpt.isPresent()) {\n-            return Optional.empty();\n-        }\n-\n-        String publicKeyLocation = locationOpt.get();\n-\n-        return readPublicKeyFromLocation(publicKeyLocation, keyID);\n-    }\n-\n-    private Optional<PublicKey> readPublicKeyFromLocation(String publicKeyLocation, String keyID) throws Exception {\n-\n-        URL publicKeyURL = currentThread().getContextClassLoader().getResource(publicKeyLocation);\n-\n-        if (publicKeyURL == null) {\n-            try {\n-                publicKeyURL = new URL(publicKeyLocation);\n-            } catch (MalformedURLException ex) {\n-                publicKeyURL = null;\n-            }\n-        }\n-        if (publicKeyURL == null) {\n-            return Optional.empty();\n-        }\n-\n-        URLConnection urlConnection = publicKeyURL.openConnection();\n-        Charset charset = Charset.defaultCharset();\n-        ContentType contentType = ContentType.newContentType(urlConnection.getContentType());\n-        if(contentType != null) {\n-            String charEncoding = contentType.getCharacterEncoding();\n-            if(charEncoding != null) {\n-                try {\n-                    if (!Charset.isSupported(charEncoding)) {\n-                        LOGGER.warning(\"Charset \" + charEncoding + \" for remote public key not supported, using default charset instead\");\n-                    } else {\n-                        charset = Charset.forName(contentType.getCharacterEncoding());\n-                    }\n-                }catch (IllegalCharsetNameException ex){\n-                    LOGGER.severe(\"Charset \" + ex.getCharsetName() + \" for remote public key not support, Cause: \" + ex.getMessage());\n-                }\n-            }\n-        }\n-        try (InputStream inputStream = urlConnection.getInputStream();\n-             BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream, charset))){\n-            String keyContents = reader.lines().collect(Collectors.joining(System.lineSeparator()));\n-            return createPublicKey(keyContents, keyID);\n-        }\n+    \n+    private Long readPublicKeyCacheTTL(Optional<Properties> properties) {\n+        return properties\n+        \t\t.map(props -> props.getProperty(\"publicKey.cache.ttl\"))\n+        \t\t.map(Long::valueOf)\n+        \t\t.orElseGet( () -> TimeUnit.SECONDS.convert(5, TimeUnit.MINUTES));", "originalCommit": "55bab85e5c465bd70ad473950073a46219e2bbc3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjkzMDQ0MQ==", "url": "https://github.com/payara/Payara/pull/5062#discussion_r556930441", "bodyText": "I'm all over the place on this one. Good catch! Will fix.", "author": "ghunteranderson", "createdAt": "2021-01-13T22:51:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njg2NDk1Mw=="}], "type": "inlineReview"}, {"oid": "2276d6a1ac047be2dd18a764bf482960961b7fba", "url": "https://github.com/payara/Payara/commit/2276d6a1ac047be2dd18a764bf482960961b7fba", "message": "FISH-868 Fixing a few styling and naming inconsistencies.", "committedDate": "2021-01-16T15:26:47Z", "type": "commit"}, {"oid": "6bd8fb3c3cafd1837667a1bfb0fd1a63169af494", "url": "https://github.com/payara/Payara/commit/6bd8fb3c3cafd1837667a1bfb0fd1a63169af494", "message": "FISH-868 JWT public key cache TTL can be set by HTTP header max-age.", "committedDate": "2021-01-16T18:37:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTAwMzQ4NQ==", "url": "https://github.com/payara/Payara/pull/5062#discussion_r559003485", "bodyText": "@fturizo To fix the time unit discrepancies, I change the type from long to java.time.Duration.\nI left the unit of publicKey.cache.ttl as milliseconds but I could see an argument for using seconds instead. Let me know if you have any thoughts on that.", "author": "ghunteranderson", "createdAt": "2021-01-16T18:52:34Z", "path": "appserver/payara-appserver-modules/microprofile/jwt-auth/src/main/java/fish/payara/microprofile/jwtauth/eesecurity/SignedJWTIdentityStore.java", "diffHunk": "@@ -179,141 +151,14 @@ public CredentialValidationResult validate(SignedJWTCredential signedJWTCredenti\n     private Optional<Boolean> readDisableTypeVerification(Optional<Properties> properties) {\n         return properties.isPresent() ? Optional.ofNullable(Boolean.valueOf(properties.get().getProperty(\"disable.type.verification\", \"false\"))) : Optional.empty();\n     }\n-\n-    private Optional<PublicKey> readDefaultPublicKey() throws Exception {\n-        return readPublicKeyFromLocation(\"/publicKey.pem\", null);\n-    }\n-\n-    private Optional<PublicKey> readMPEmbeddedPublicKey(String keyID) throws Exception {\n-        Optional<String> key = config.getOptionalValue(VERIFIER_PUBLIC_KEY, String.class);\n-        if (!key.isPresent()) {\n-            return Optional.empty();\n-        }\n-        return createPublicKey(key.get(), keyID);\n-    }\n-\n-    private Optional<PublicKey> readMPPublicKeyFromLocation(String keyID) throws Exception {\n-        Optional<String> locationOpt = config.getOptionalValue(VERIFIER_PUBLIC_KEY_LOCATION, String.class);\n-\n-        if (!locationOpt.isPresent()) {\n-            return Optional.empty();\n-        }\n-\n-        String publicKeyLocation = locationOpt.get();\n-\n-        return readPublicKeyFromLocation(publicKeyLocation, keyID);\n-    }\n-\n-    private Optional<PublicKey> readPublicKeyFromLocation(String publicKeyLocation, String keyID) throws Exception {\n-\n-        URL publicKeyURL = currentThread().getContextClassLoader().getResource(publicKeyLocation);\n-\n-        if (publicKeyURL == null) {\n-            try {\n-                publicKeyURL = new URL(publicKeyLocation);\n-            } catch (MalformedURLException ex) {\n-                publicKeyURL = null;\n-            }\n-        }\n-        if (publicKeyURL == null) {\n-            return Optional.empty();\n-        }\n-\n-        URLConnection urlConnection = publicKeyURL.openConnection();\n-        Charset charset = Charset.defaultCharset();\n-        ContentType contentType = ContentType.newContentType(urlConnection.getContentType());\n-        if(contentType != null) {\n-            String charEncoding = contentType.getCharacterEncoding();\n-            if(charEncoding != null) {\n-                try {\n-                    if (!Charset.isSupported(charEncoding)) {\n-                        LOGGER.warning(\"Charset \" + charEncoding + \" for remote public key not supported, using default charset instead\");\n-                    } else {\n-                        charset = Charset.forName(contentType.getCharacterEncoding());\n-                    }\n-                }catch (IllegalCharsetNameException ex){\n-                    LOGGER.severe(\"Charset \" + ex.getCharsetName() + \" for remote public key not support, Cause: \" + ex.getMessage());\n-                }\n-            }\n-        }\n-        try (InputStream inputStream = urlConnection.getInputStream();\n-             BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream, charset))){\n-            String keyContents = reader.lines().collect(Collectors.joining(System.lineSeparator()));\n-            return createPublicKey(keyContents, keyID);\n-        }\n+    \n+    private Duration readPublicKeyCacheTTL(Optional<Properties> properties) {\n+        return properties\n+        \t\t.map(props -> props.getProperty(\"publicKey.cache.ttl\"))\n+        \t\t.map(Long::valueOf)\n+        \t\t.map(Duration::ofMillis)\n+        \t\t.orElseGet( () -> Duration.ofMinutes(5));", "originalCommit": "6bd8fb3c3cafd1837667a1bfb0fd1a63169af494", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTczNjAxNg==", "url": "https://github.com/payara/Payara/pull/5062#discussion_r559736016", "bodyText": "As long as it is consistent, you can keep the unit in milliseconds.", "author": "fturizo", "createdAt": "2021-01-18T18:18:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTAwMzQ4NQ=="}], "type": "inlineReview"}]}