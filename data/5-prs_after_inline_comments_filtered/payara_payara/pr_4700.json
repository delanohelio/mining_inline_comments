{"pr_number": 4700, "pr_title": "APPSERV-151 Command to Generate a CSR", "pr_createdAt": "2020-06-05T10:23:39Z", "pr_url": "https://github.com/payara/Payara/pull/4700", "timeline": [{"oid": "c4a0140a9b17a01e5be17cdce195aae85c6ae4d5", "url": "https://github.com/payara/Payara/commit/c4a0140a9b17a01e5be17cdce195aae85c6ae4d5", "message": "APPSERV-151 add manual page", "committedDate": "2020-06-05T11:13:28Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg1NDY1MQ==", "url": "https://github.com/payara/Payara/pull/4700#discussion_r435854651", "bodyText": "header", "author": "jbee", "createdAt": "2020-06-05T11:15:57Z", "path": "appserver/extras/certificate-management/src/main/java/fish/payara/certificate/management/CertificateManagementKeytoolCommands.java", "diffHunk": "@@ -0,0 +1,93 @@\n+package fish.payara.certificate.management;", "originalCommit": "c4a0140a9b17a01e5be17cdce195aae85c6ae4d5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg1NjE4Ng==", "url": "https://github.com/payara/Payara/pull/4700#discussion_r435856186", "bodyText": "Better to compute the value and then assign it to the array. Keeps the array out of the value computation.", "author": "jbee", "createdAt": "2020-06-05T11:19:52Z", "path": "appserver/extras/certificate-management/src/main/java/fish/payara/certificate/management/CertificateManagementKeytoolCommands.java", "diffHunk": "@@ -0,0 +1,93 @@\n+package fish.payara.certificate.management;\n+\n+import java.io.File;\n+\n+public class CertificateManagementKeytoolCommands {\n+\n+    /**\n+     * Constructs the command to pass to keytool for creating a self-signed cert\n+     *\n+     * @param keystore The key store to add the certificate to\n+     * @param password The password for the key store\n+     * @param alias    The alias of the certificate\n+     * @param dname    The distinguished name of the certificate\n+     * @param altnames The alternative names of the certificate\n+     * @return A String array to pass to {@link com.sun.enterprise.admin.servermgmt.KeystoreManager.KeytoolExecutor}\n+     */\n+    public static String[] constructGenerateCertKeytoolCommand(File keystore, char[] password,\n+            String alias, String dname, String[] altnames) {\n+        String[] keytoolCmd = new String[]{\"-genkeypair\", \"-keyalg\", \"RSA\", \"-keystore\", keystore.getAbsolutePath(),\n+                \"-alias\", alias, \"-dname\", dname,\n+                \"-validity\", \"365\", \"-keypass\", new String(password), \"-storepass\", new String(password)};\n+\n+        if (altnames != null && altnames.length != 0) {\n+            keytoolCmd = addSubjectAlternativeNames(keytoolCmd, altnames);\n+        }\n+\n+        return keytoolCmd;\n+    }\n+\n+    /**\n+     * Helper method that formats the String array of alternative names into the format that the keytool expects.\n+     *\n+     * @param keytoolCmd       The String array containing the keytool command before alternative names have been added.\n+     * @param alternativeNames The String array containing the alternatives names\n+     * @return A String array of the original keytool command with the alternative names added\n+     */\n+    public static String[] addSubjectAlternativeNames(String[] keytoolCmd, String[] alternativeNames) {\n+        // Create a new array to make room for the extra commands\n+        String[] expandedKeytoolCmd = new String[keytoolCmd.length + 2];\n+        System.arraycopy(keytoolCmd, 0, expandedKeytoolCmd, 0, keytoolCmd.length);\n+\n+        int i = keytoolCmd.length;\n+        expandedKeytoolCmd[i] = \"-ext\";\n+        expandedKeytoolCmd[i + 1] = \"SAN=\";\n+\n+        for (String altName : alternativeNames) {\n+            // Check if the altname was provided without any additional info, assuming it's DNS if so\n+            if (!altName.contains(\",\") && !altName.contains(\":\")) {\n+                expandedKeytoolCmd[i + 1] += \"DNS:\" + altName;\n+            } else {\n+                expandedKeytoolCmd[i + 1] += altName;\n+            }\n+            expandedKeytoolCmd[i + 1] += \",\";\n+        }\n+\n+        // Remove trailing comma\n+        expandedKeytoolCmd[i + 1] = expandedKeytoolCmd[i + 1].substring(0, expandedKeytoolCmd[i + 1].length() - 1);", "originalCommit": "c4a0140a9b17a01e5be17cdce195aae85c6ae4d5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg1NjY0MQ==", "url": "https://github.com/payara/Payara/pull/4700#discussion_r435856641", "bodyText": "I would not mind if the other commands are formatted like here where each pair is on its own line.", "author": "jbee", "createdAt": "2020-06-05T11:20:56Z", "path": "appserver/extras/certificate-management/src/main/java/fish/payara/certificate/management/CertificateManagementKeytoolCommands.java", "diffHunk": "@@ -0,0 +1,93 @@\n+package fish.payara.certificate.management;\n+\n+import java.io.File;\n+\n+public class CertificateManagementKeytoolCommands {\n+\n+    /**\n+     * Constructs the command to pass to keytool for creating a self-signed cert\n+     *\n+     * @param keystore The key store to add the certificate to\n+     * @param password The password for the key store\n+     * @param alias    The alias of the certificate\n+     * @param dname    The distinguished name of the certificate\n+     * @param altnames The alternative names of the certificate\n+     * @return A String array to pass to {@link com.sun.enterprise.admin.servermgmt.KeystoreManager.KeytoolExecutor}\n+     */\n+    public static String[] constructGenerateCertKeytoolCommand(File keystore, char[] password,\n+            String alias, String dname, String[] altnames) {\n+        String[] keytoolCmd = new String[]{\"-genkeypair\", \"-keyalg\", \"RSA\", \"-keystore\", keystore.getAbsolutePath(),\n+                \"-alias\", alias, \"-dname\", dname,\n+                \"-validity\", \"365\", \"-keypass\", new String(password), \"-storepass\", new String(password)};\n+\n+        if (altnames != null && altnames.length != 0) {\n+            keytoolCmd = addSubjectAlternativeNames(keytoolCmd, altnames);\n+        }\n+\n+        return keytoolCmd;\n+    }\n+\n+    /**\n+     * Helper method that formats the String array of alternative names into the format that the keytool expects.\n+     *\n+     * @param keytoolCmd       The String array containing the keytool command before alternative names have been added.\n+     * @param alternativeNames The String array containing the alternatives names\n+     * @return A String array of the original keytool command with the alternative names added\n+     */\n+    public static String[] addSubjectAlternativeNames(String[] keytoolCmd, String[] alternativeNames) {\n+        // Create a new array to make room for the extra commands\n+        String[] expandedKeytoolCmd = new String[keytoolCmd.length + 2];\n+        System.arraycopy(keytoolCmd, 0, expandedKeytoolCmd, 0, keytoolCmd.length);\n+\n+        int i = keytoolCmd.length;\n+        expandedKeytoolCmd[i] = \"-ext\";\n+        expandedKeytoolCmd[i + 1] = \"SAN=\";\n+\n+        for (String altName : alternativeNames) {\n+            // Check if the altname was provided without any additional info, assuming it's DNS if so\n+            if (!altName.contains(\",\") && !altName.contains(\":\")) {\n+                expandedKeytoolCmd[i + 1] += \"DNS:\" + altName;\n+            } else {\n+                expandedKeytoolCmd[i + 1] += altName;\n+            }\n+            expandedKeytoolCmd[i + 1] += \",\";\n+        }\n+\n+        // Remove trailing comma\n+        expandedKeytoolCmd[i + 1] = expandedKeytoolCmd[i + 1].substring(0, expandedKeytoolCmd[i + 1].length() - 1);\n+\n+        return expandedKeytoolCmd;\n+    }\n+\n+    /**\n+     * Constructs the command to pass to keytool for adding the self-signed cert to the trust store\n+     *\n+     * @param keystore           The target key store that the certificate was added to\n+     * @param truststore         The target trust store to add the certificate to\n+     * @param keystorePassword   The password for the key store\n+     * @param truststorePassword The password for the trust store\n+     * @param alias              The alias of the certificate\n+     * @return A String array to pass to {@link com.sun.enterprise.admin.servermgmt.KeystoreManager.KeytoolExecutor}\n+     */\n+    public static String[] constructImportCertKeytoolCommand(File keystore, File truststore, char[] keystorePassword,\n+            char[] truststorePassword, String alias) {\n+        String[] keytoolCmd = new String[]{\"-importkeystore\", \"-srckeystore\", keystore.getAbsolutePath(),\n+                \"-destkeystore\", truststore.getAbsolutePath(), \"-srcalias\", alias, \"-destalias\", alias,\n+                \"-srcstorepass\", new String(keystorePassword), \"-deststorepass\", new String(truststorePassword),\n+                \"-srckeypass\", new String(keystorePassword), \"-destkeypass\", new String(truststorePassword),\n+                \"-noprompt\"};\n+\n+        return keytoolCmd;\n+    }\n+\n+    public static String[] constructGenerateCertRequestKeytoolCommand(File keystore, char[] password,\n+            File outputFile, String alias) {\n+        String[] keytoolCmd = new String[]{\"-certreq\", \"-keystore\", keystore.getAbsolutePath(),\n+                \"-alias\", alias,\n+                \"-storepass\", new String(password),\n+                \"-keypass\", new String(password),\n+                \"-noprompt\", \"-file\", outputFile.getAbsolutePath()};", "originalCommit": "c4a0140a9b17a01e5be17cdce195aae85c6ae4d5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg1OTAzNg==", "url": "https://github.com/payara/Payara/pull/4700#discussion_r435859036", "bodyText": "At some point it would be nice to move all the XML processing to one place. Maybe not now.", "author": "jbee", "createdAt": "2020-06-05T11:26:49Z", "path": "appserver/extras/certificate-management/src/main/java/fish/payara/certificate/management/admin/GenerateCsrCommand.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/*\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n+ *\n+ * Copyright (c) 2020 Payara Foundation and/or its affiliates. All rights reserved.\n+ *\n+ * The contents of this file are subject to the terms of either the GNU\n+ * General Public License Version 2 only (\"GPL\") or the Common Development\n+ * and Distribution License(\"CDDL\") (collectively, the \"License\").  You\n+ * may not use this file except in compliance with the License.  You can\n+ * obtain a copy of the License at\n+ * https://github.com/payara/Payara/blob/master/LICENSE.txt\n+ * See the License for the specific\n+ * language governing permissions and limitations under the License.\n+ *\n+ * When distributing the software, include this License Header Notice in each\n+ * file and include the License file at glassfish/legal/LICENSE.txt.\n+ *\n+ * GPL Classpath Exception:\n+ * The Payara Foundation designates this particular file as subject to the \"Classpath\"\n+ * exception as provided by the Payara Foundation in the GPL Version 2 section of the License\n+ * file that accompanied this code.\n+ *\n+ * Modifications:\n+ * If applicable, add the following below the License Header, with the fields\n+ * enclosed by brackets [] replaced by your own identifying information:\n+ * \"Portions Copyright [year] [name of copyright owner]\"\n+ *\n+ * Contributor(s):\n+ * If you wish your version of this file to be governed by only the CDDL or\n+ * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n+ * elects to include this software in this distribution under the [CDDL or GPL\n+ * Version 2] license.\"  If you don't indicate a single choice of license, a\n+ * recipient has the option to distribute your version of this file under\n+ * either the CDDL, the GPL Version 2 or to extend the choice of license to\n+ * its licensees as provided above.  However, if you add GPL Version 2 code\n+ * and therefore, elected the GPL Version 2 license, then the option applies\n+ * only if the new code is made subject to such option by the copyright\n+ * holder.\n+ */\n+package fish.payara.certificate.management.admin;\n+\n+import com.sun.enterprise.admin.cli.CLIConstants;\n+import com.sun.enterprise.admin.cli.Environment;\n+import com.sun.enterprise.admin.cli.ProgramOptions;\n+import com.sun.enterprise.admin.cli.cluster.SynchronizeInstanceCommand;\n+import com.sun.enterprise.admin.servermgmt.KeystoreManager;\n+import com.sun.enterprise.admin.servermgmt.RepositoryException;\n+import com.sun.enterprise.admin.servermgmt.cli.LocalDomainCommand;\n+import com.sun.enterprise.universal.xml.MiniXmlParser;\n+import com.sun.enterprise.universal.xml.MiniXmlParserException;\n+import com.sun.enterprise.util.SystemPropertyConstants;\n+import fish.payara.certificate.management.CertificateManagementKeytoolCommands;\n+import fish.payara.certificate.management.CertificateManagementUtils;\n+import org.glassfish.api.Param;\n+import org.glassfish.api.admin.CommandException;\n+import org.glassfish.config.support.TranslatedConfigView;\n+import org.glassfish.hk2.api.PerLookup;\n+import org.jvnet.hk2.annotations.Service;\n+\n+import java.io.File;\n+\n+@Service(name = \"generate-csr\")\n+@PerLookup\n+public class GenerateCsrCommand extends LocalDomainCommand {\n+\n+    @Param(name = \"domain_name\", optional = true)\n+    private String domainName0;\n+\n+    @Param(name = \"listener\", optional = true)\n+    private String listener;\n+\n+    @Param(name = \"target\", optional = true, defaultValue = SystemPropertyConstants.DAS_SERVER_NAME)\n+    private String target;\n+\n+    @Param(name = \"alias\", primary = true)\n+    private String alias;\n+\n+    private File keystore;\n+    private char[] keystorePassword;\n+    private char[] masterPassword;\n+\n+    @Override\n+    protected void validate() throws CommandException {\n+        setDomainName(domainName0);\n+        super.validate();\n+    }\n+\n+    @Override\n+    protected int executeCommand() throws CommandException {\n+        // If we're targetting an instance that isn't the DAS, use a different command\n+        if (target != null && !target.equals(SystemPropertyConstants.DAS_SERVER_NAME)) {\n+            GenerateCsrLocalInstanceCommand localInstanceCommand =\n+                    new GenerateCsrLocalInstanceCommand(programOpts, env);\n+            localInstanceCommand.validate();\n+            return localInstanceCommand.executeCommand();\n+        }\n+\n+        // Parse the location of the key store, and the password required to access it\n+        try {\n+            MiniXmlParser parser = new MiniXmlParser(getDomainXml(), target);\n+            keystore = CertificateManagementUtils.resolveKeyStore(parser, listener, getDomainRootDir());\n+            getStorePasswords(parser, listener, getDomainRootDir());\n+        } catch (MiniXmlParserException miniXmlParserException) {\n+            throw new CommandException(\"Error parsing domain.xml\", miniXmlParserException);\n+        }\n+\n+        // Run keytool command to generate CSR and place in csrLocation\n+        try {\n+            generateCsr();\n+        } catch (CommandException ce) {\n+            return CLIConstants.ERROR;\n+        }\n+\n+        return CLIConstants.SUCCESS;\n+    }\n+\n+    /**\n+     * Generates a CSR\n+     *\n+     * @throws CommandException If there's an issue adding the certificate to the key store\n+     */\n+    private void generateCsr() throws CommandException {\n+        // Get CSR install dir and ensure it actually exists\n+        File csrLocation = new File(getInstallRootPath() + File.separator + \"tls\");\n+        if (!csrLocation.exists()) {\n+            csrLocation.mkdir();\n+        }\n+\n+        // Run keytool command to generate self-signed cert\n+        KeystoreManager.KeytoolExecutor keytoolExecutor = new KeystoreManager.KeytoolExecutor(\n+                CertificateManagementKeytoolCommands.constructGenerateCertRequestKeytoolCommand(\n+                        keystore, keystorePassword,\n+                        new File(csrLocation.getAbsolutePath() + File.separator + alias + \".csr\"),\n+                        alias),\n+                60);\n+\n+        try {\n+            keytoolExecutor.execute(\"csrNotCreated\", keystore);\n+        } catch (RepositoryException re) {\n+            logger.severe(re.getCause().getMessage()\n+                    .replace(\"keytool error: java.lang.Exception: \", \"\")\n+                    .replace(\"keytool error: java.io.IOException: \", \"\"));\n+            throw new CommandException(re);\n+        }\n+    }\n+\n+    /**\n+     * Gets the passwords for the key and trust store.\n+     *\n+     * @param parser    The {@link MiniXmlParser} for extracting info from the domain.xml\n+     * @param listener  The name of the HTTP or IIOP listener to get the key or trust store passwords from. Can be null.\n+     * @param serverDir The directory of the target instance, used for accessing the domain-passwords store\n+     * @throws MiniXmlParserException If there's an issue reading the domain.xml\n+     * @throws CommandException       If there's an issue getting the master password\n+     */\n+    private void getStorePasswords(MiniXmlParser parser, String listener, File serverDir)", "originalCommit": "c4a0140a9b17a01e5be17cdce195aae85c6ae4d5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7d571b74b23672311b643fa6616f23f8922be6d7", "url": "https://github.com/payara/Payara/commit/7d571b74b23672311b643fa6616f23f8922be6d7", "message": "APPSERV-151 Add command to generate CSR and some minor refactors", "committedDate": "2020-06-23T09:57:31Z", "type": "commit"}, {"oid": "0c02bb2e5f7e0c5b3839cd5b5d35d92d70d5fb29", "url": "https://github.com/payara/Payara/commit/0c02bb2e5f7e0c5b3839cd5b5d35d92d70d5fb29", "message": "APPSERV-151 Create TLS directory if it doesn't exist", "committedDate": "2020-06-23T09:57:31Z", "type": "commit"}, {"oid": "f738d6d18c13070d7c685ab6e444e941fda008f0", "url": "https://github.com/payara/Payara/commit/f738d6d18c13070d7c685ab6e444e941fda008f0", "message": "APPSERV-151 add manual page", "committedDate": "2020-06-23T09:57:31Z", "type": "commit"}, {"oid": "9876ffd8fd57ba5d20f9896e2952865fb6a2e1e1", "url": "https://github.com/payara/Payara/commit/9876ffd8fd57ba5d20f9896e2952865fb6a2e1e1", "message": "APPSERV-151 review comments", "committedDate": "2020-06-23T09:57:31Z", "type": "commit"}, {"oid": "9876ffd8fd57ba5d20f9896e2952865fb6a2e1e1", "url": "https://github.com/payara/Payara/commit/9876ffd8fd57ba5d20f9896e2952865fb6a2e1e1", "message": "APPSERV-151 review comments", "committedDate": "2020-06-23T09:57:31Z", "type": "forcePushed"}]}