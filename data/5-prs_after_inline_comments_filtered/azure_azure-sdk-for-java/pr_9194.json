{"pr_number": 9194, "pr_title": "Add APIs to Log Checked Exceptions as Warning and Error", "pr_createdAt": "2020-03-18T19:08:14Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/9194", "timeline": [{"oid": "ed2227d5d6c3178e8ac469311143a28a59e09ae4", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ed2227d5d6c3178e8ac469311143a28a59e09ae4", "message": "Add APIs to log checked exceptions as warning or errors", "committedDate": "2020-03-17T23:15:06Z", "type": "commit"}, {"oid": "2a449baea071c7d7debb3f8c2ae54fc588c003cd", "url": "https://github.com/Azure/azure-sdk-for-java/commit/2a449baea071c7d7debb3f8c2ae54fc588c003cd", "message": "Merge branch 'master' into AzCore_EnhanceClientLogger", "committedDate": "2020-03-18T16:17:45Z", "type": "commit"}, {"oid": "d0a5174257d1ad764ea0435febbe8e03f220040c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d0a5174257d1ad764ea0435febbe8e03f220040c", "message": "Enhanced tests, added '5' as a valid LogLevel environment configuration to support 'NOT_SET'", "committedDate": "2020-03-18T19:01:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU4MTExMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9194#discussion_r394581110", "bodyText": "Can this be changed to catch IOException instead?", "author": "srnagar", "createdAt": "2020-03-18T19:13:24Z", "path": "sdk/core/azure-core/src/test/java/com/azure/core/util/logging/ClientLoggerTests.java", "diffHunk": "@@ -57,233 +58,167 @@ public void revertLoggingConfiguration() throws Exception {\n         logCaptureStream.close();\n     }\n \n-    private void setPropertyToOriginalOrClear(String propertyName, String originalValue) {\n-        if (CoreUtils.isNullOrEmpty(originalValue)) {\n-            System.clearProperty(propertyName);\n-        } else {\n-            System.setProperty(propertyName, originalValue);\n-        }\n-    }\n-\n     /**\n-     * Tests that logging at the same level as the environment logging level will log.\n-     *\n-     * @param logLevel Logging level to log a message\n+     * Test whether the logger supports a given log level based on its configured log level.\n      */\n-    @ParameterizedTest(name = PARAMETERIZED_TEST_NAME_TEMPLATE)\n-    @ValueSource(ints = { 1, 2, 3, 4 })\n-    public void logAtSupportedLevel(int logLevel) {\n-        String logMessage = \"This is a test\";\n-\n-        String originalLogLevel = setupLogLevel(logLevel);\n-        logMessage(new ClientLogger(ClientLoggerTests.class), logLevel, logMessage);\n-\n-        setPropertyToOriginalOrClear(Configuration.PROPERTY_AZURE_LOG_LEVEL, originalLogLevel);\n-\n-        String logValues = new String(logCaptureStream.toByteArray(), StandardCharsets.UTF_8);\n-        assertTrue(logValues.contains(logMessage));\n+    @ParameterizedTest\n+    @MethodSource(\"singleLevelCheckSupplier\")\n+    public void canLogAtLevel(LogLevel logLevelToConfigure, LogLevel logLevelToValidate, boolean expected) {\n+        setupLogLevel(logLevelToConfigure.getLogLevel());\n+        assertEquals(expected, new ClientLogger(ClientLoggerTests.class).canLogAtLevel(logLevelToValidate));\n     }\n \n     /**\n-     * Tests that logging at a level that is less than the environment logging level doesn't log anything.\n-     *\n-     * @param logLevel Logging level to log a message\n+     * Test whether a log will be captured when the ClientLogger and message are configured to the passed log levels.\n      */\n-    @ParameterizedTest(name = PARAMETERIZED_TEST_NAME_TEMPLATE)\n-    @ValueSource(ints = { 1, 2, 3 })\n-    public void logAtUnsupportedLevel(int logLevel) {\n+    @ParameterizedTest\n+    @MethodSource(\"singleLevelCheckSupplier\")\n+    public void log(LogLevel logLevelToConfigure, LogLevel logLevelToUse, boolean logContainsMessage) {\n         String logMessage = \"This is a test\";\n \n-        String originalLogLevel = setupLogLevel(logLevel + 1);\n-        logMessage(new ClientLogger(ClientLoggerTests.class), logLevel, logMessage);\n-        setPropertyToOriginalOrClear(Configuration.PROPERTY_AZURE_LOG_LEVEL, originalLogLevel);\n-\n-        String logValues = new String(logCaptureStream.toByteArray(), StandardCharsets.UTF_8);\n-        assertFalse(logValues.contains(logMessage));\n-    }\n-\n-    /**\n-     * Tests that logging when the environment log level is disabled nothing is logged.\n-     */\n-    @Test\n-    public void logWhenLoggingNotSet() {\n-        assertEquals(LogLevel.NOT_SET, LogLevel.fromString(null));\n-    }\n-\n-    /**\n-     * Tests that logging an exception when the log level isn't VERBOSE only log the exception message.\n-     */\n-    @Test\n-    public void onlyLogExceptionMessage() {\n-        String logMessage = \"This is an exception\";\n-        String exceptionMessage = \"An exception message\";\n-        RuntimeException runtimeException = createRuntimeException(exceptionMessage);\n-\n-        String originalLogLevel = setupLogLevel(2);\n-        logMessage(new ClientLogger(ClientLoggerTests.class), 3, logMessage, runtimeException);\n-        setPropertyToOriginalOrClear(Configuration.PROPERTY_AZURE_LOG_LEVEL, originalLogLevel);\n-\n-        String logValues = new String(logCaptureStream.toByteArray(), StandardCharsets.UTF_8);\n-        assertTrue(logValues.contains(logMessage + System.lineSeparator() + runtimeException.getMessage()));\n-        assertFalse(logValues.contains(runtimeException.getStackTrace()[0].toString()));\n-    }\n-\n-    /**\n-     * Tests that logging an exception when the log level is VERBOSE the stack trace is logged.\n-     */\n-    @Test\n-    public void logExceptionStackTrace() {\n-        String logMessage = \"This is an exception fdsafdafdomcklamfd fdsafdafmlkdfmalsf fdsafdcacdalmd\";\n-        String exceptionMessage = \"An exception message\";\n-        RuntimeException runtimeException = createRuntimeException(exceptionMessage);\n+        String originalLogLevel = setupLogLevel(logLevelToConfigure.getLogLevel());\n+        logMessage(new ClientLogger(ClientLoggerTests.class), logLevelToUse, logMessage);\n \n-        String originalLogLevel = setupLogLevel(1);\n-        logMessage(new ClientLogger(ClientLoggerTests.class), 3, logMessage, runtimeException);\n-        setPropertyToOriginalOrClear(Configuration.PROPERTY_AZURE_LOG_LEVEL, originalLogLevel);\n+        setPropertyToOriginalOrClear(originalLogLevel);\n \n         String logValues = new String(logCaptureStream.toByteArray(), StandardCharsets.UTF_8);\n-        assertTrue(logValues.contains(logMessage + System.lineSeparator() + runtimeException.getMessage()));\n-        assertTrue(logValues.contains(runtimeException.getStackTrace()[0].toString()));\n+        assertEquals(logContainsMessage, logValues.contains(logMessage));\n     }\n \n     /**\n-     * Tests that logging an exception when the log level is ERROR the stack trace is logged.\n+     * Tests whether a log will contain the exception message when the ClientLogger and message are configured to the\n+     * passed log levels.\n      */\n-    @Test\n-    public void logExceptionStackTraceWithErrorLevel() {\n+    @ParameterizedTest\n+    @MethodSource(\"multiLevelCheckSupplier\")\n+    public void logException(LogLevel logLevelToConfigure, LogLevel logLevelToUse, boolean logContainsMessage,\n+        boolean logContainsStackTrace) {\n         String logMessage = \"This is an exception\";\n         String exceptionMessage = \"An exception message\";\n-        RuntimeException runtimeException = createRuntimeException(exceptionMessage);\n+        RuntimeException runtimeException = createIllegalStateException(exceptionMessage);\n \n-        String originalLogLevel = setupLogLevel(1);\n-        logMessage(new ClientLogger(ClientLoggerTests.class), 4, logMessage, runtimeException);\n-        setPropertyToOriginalOrClear(Configuration.PROPERTY_AZURE_LOG_LEVEL, originalLogLevel);\n+        String originalLogLevel = setupLogLevel(logLevelToConfigure.getLogLevel());\n+        logMessage(new ClientLogger(ClientLoggerTests.class), logLevelToUse, logMessage, runtimeException);\n+        setPropertyToOriginalOrClear(originalLogLevel);\n \n         String logValues = new String(logCaptureStream.toByteArray(), StandardCharsets.UTF_8);\n-        assertTrue(logValues.contains(logMessage + System.lineSeparator() + runtimeException.getMessage()));\n-        assertTrue(logValues.contains(runtimeException.getStackTrace()[0].toString()));\n+        assertEquals(logContainsMessage, logValues.contains(logMessage + System.lineSeparator() + runtimeException.getMessage()));\n+        assertEquals(logContainsStackTrace, logValues.contains(runtimeException.getStackTrace()[0].toString()));\n     }\n \n-\n     /**\n-     * Tests that logging an exception when the log level is ERROR the stack trace is logged.\n+     * Tests that logging a RuntimeException as warning will log a message and stack trace appropriately based on the\n+     * configured log level.\n      */\n-    @Test\n-    public void logExceptionStackTraceWithNoLogLevel() {\n-        String logMessage = \"This is an exception\";\n+    @ParameterizedTest\n+    @MethodSource(\"logExceptionAsWarningSupplier\")\n+    public void logExceptionAsWarning(LogLevel logLevelToConfigure, boolean logContainsMessage,\n+        boolean logContainsStackTrace) {\n         String exceptionMessage = \"An exception message\";\n-        RuntimeException runtimeException = createRuntimeException(exceptionMessage);\n+        IllegalStateException illegalStateException = createIllegalStateException(exceptionMessage);\n \n-        String originalLogLevel = setupLogLevel(1);\n-        logMessage(new ClientLogger(ClientLoggerTests.class), 5, logMessage, runtimeException);\n-        setPropertyToOriginalOrClear(Configuration.PROPERTY_AZURE_LOG_LEVEL, originalLogLevel);\n+        String originalLogLevel = setupLogLevel(logLevelToConfigure.getLogLevel());\n+        try {\n+            throw new ClientLogger(ClientLoggerTests.class).logExceptionAsWarning(illegalStateException);\n+        } catch (RuntimeException exception) {\n+            assertTrue(exception instanceof IllegalStateException);\n+        }\n+        setPropertyToOriginalOrClear(originalLogLevel);\n \n         String logValues = new String(logCaptureStream.toByteArray(), StandardCharsets.UTF_8);\n-        assertTrue(logValues.isEmpty());\n+        assertEquals(logContainsMessage, logValues.contains(exceptionMessage + System.lineSeparator()));\n+        assertEquals(logContainsStackTrace, logValues.contains(illegalStateException.getStackTrace()[0].toString()));\n     }\n \n     /**\n-     * Tests that logging an exception when the log level is ERROR the stack trace is logged.\n+     * Tests that logging a Throwable as warning will log a message and stack trace appropriately based on the\n+     * configured log level.\n      */\n-    @Test\n-    public void logExceptionWithInvalidLogLevel() {\n-        String logMessage = \"This is an exception\";\n-        Object runtimeException = new Object();\n+    @ParameterizedTest\n+    @MethodSource(\"logExceptionAsWarningSupplier\")\n+    public void logCheckedExceptionAsWarning(LogLevel logLevelToConfigure, boolean logContainsMessage,\n+        boolean logContainsStackTrace) {\n+        String exceptionMessage = \"An exception message\";\n+        IOException ioException = createIOException(exceptionMessage);\n \n-        String originalLogLevel = setupLogLevel(1);\n-        logMessage(new ClientLogger(ClientLoggerTests.class), 3, logMessage, runtimeException);\n-        setPropertyToOriginalOrClear(Configuration.PROPERTY_AZURE_LOG_LEVEL, originalLogLevel);\n+        String originalLogLevel = setupLogLevel(logLevelToConfigure.getLogLevel());\n+        try {\n+            throw new ClientLogger(ClientLoggerTests.class).logCheckedExceptionAsWarning(ioException);\n+        } catch (Throwable throwable) {\n+            assertTrue(throwable instanceof IOException);\n+        }\n+        setPropertyToOriginalOrClear(originalLogLevel);\n \n         String logValues = new String(logCaptureStream.toByteArray(), StandardCharsets.UTF_8);\n-        assertTrue(logValues.contains(logMessage));\n+        assertEquals(logContainsMessage, logValues.contains(exceptionMessage + System.lineSeparator()));\n+        assertEquals(logContainsStackTrace, logValues.contains(ioException.getStackTrace()[0].toString()));\n     }\n \n     /**\n-     * Tests that logging an exception as warning won't include the stack trace when the environment log level isn't\n-     * VERBOSE. Additionally, this tests that the exception message isn't logged twice as logging an exception uses\n-     * the exception message as the format string.\n+     * Tests that logging a RuntimeException as error will log a message and stack trace appropriately based on the\n+     * configured log level.\n      */\n-    @Test\n-    public void logExceptionAsWarningOnlyExceptionMessage() {\n+    @ParameterizedTest\n+    @MethodSource(\"logExceptionAsErrorSupplier\")\n+    public void logExceptionAsError(LogLevel logLevelToConfigure, boolean logContainsMessage,\n+        boolean logContainsStackTrace) {\n         String exceptionMessage = \"An exception message\";\n-        RuntimeException runtimeException = createRuntimeException(exceptionMessage);\n+        IllegalStateException illegalStateException = createIllegalStateException(exceptionMessage);\n \n-        String originalLogLevel = setupLogLevel(2);\n-        new ClientLogger(ClientLoggerTests.class).logExceptionAsWarning(runtimeException);\n-        setPropertyToOriginalOrClear(Configuration.PROPERTY_AZURE_LOG_LEVEL, originalLogLevel);\n+        String originalLogLevel = setupLogLevel(logLevelToConfigure.getLogLevel());\n+        try {\n+            throw new ClientLogger(ClientLoggerTests.class).logExceptionAsError(illegalStateException);\n+        } catch (RuntimeException exception) {\n+            assertTrue(exception instanceof IllegalStateException);\n+        }\n+        setPropertyToOriginalOrClear(originalLogLevel);\n \n         String logValues = new String(logCaptureStream.toByteArray(), StandardCharsets.UTF_8);\n-        assertTrue(logValues.contains(exceptionMessage + System.lineSeparator()));\n-        assertFalse(logValues.contains(runtimeException.getStackTrace()[0].toString()));\n+        assertEquals(logContainsMessage, logValues.contains(exceptionMessage + System.lineSeparator()));\n+        assertEquals(logContainsStackTrace, logValues.contains(illegalStateException.getStackTrace()[0].toString()));\n     }\n \n     /**\n-     * Tests that logging an exception as warning will include the stack trace when the environment log level is set to\n-     * VERBOSE.\n+     * Tests that logging a Throwable as error will log a message and stack trace appropriately based on the\n+     * configured log level.\n      */\n-    @Test\n-    public void logExceptionAsWarningStackTrace() {\n+    @ParameterizedTest\n+    @MethodSource(\"logExceptionAsErrorSupplier\")\n+    public void logCheckedExceptionAsError(LogLevel logLevelToConfigure, boolean logContainsMessage,\n+        boolean logContainsStackTrace) {\n         String exceptionMessage = \"An exception message\";\n-        RuntimeException runtimeException = createRuntimeException(exceptionMessage);\n+        IOException ioException = createIOException(exceptionMessage);\n \n-        String originalLogLevel = setupLogLevel(1);\n-        new ClientLogger(ClientLoggerTests.class).logExceptionAsWarning(runtimeException);\n-        setPropertyToOriginalOrClear(Configuration.PROPERTY_AZURE_LOG_LEVEL, originalLogLevel);\n+        String originalLogLevel = setupLogLevel(logLevelToConfigure.getLogLevel());\n+        try {\n+            throw new ClientLogger(ClientLoggerTests.class).logCheckedExceptionAsError(ioException);\n+        } catch (Throwable throwable) {", "originalCommit": "d0a5174257d1ad764ea0435febbe8e03f220040c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU4Njg1OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9194#discussion_r394586859", "bodyText": "I was looking to catch the generic type to ensure that instanceof it would be what is expected.", "author": "alzimmermsft", "createdAt": "2020-03-18T19:24:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU4MTExMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU4Mjk3MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9194#discussion_r394582971", "bodyText": "Since this applies to all throwables, we can name this logThrowableAsError", "author": "srnagar", "createdAt": "2020-03-18T19:17:03Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/logging/ClientLogger.java", "diffHunk": "@@ -134,37 +135,76 @@ public void error(String format, Object... args) {\n \n     /**\n      * Logs the {@link RuntimeException} at the warning level and returns it to be thrown.\n+     * <p>\n+     * This API covers the cases where a runtime exception type needs to be thrown and logged. If a {@link Throwable} is\n+     * being logged use {@link #logCheckedExceptionAsWarning(Throwable)} instead.\n      *\n      * @param runtimeException RuntimeException to be logged and returned.\n-     * @return The passed {@code RuntimeException}.\n+     * @return The passed {@link RuntimeException}.\n      * @throws NullPointerException If {@code runtimeException} is {@code null}.\n      */\n     public RuntimeException logExceptionAsWarning(RuntimeException runtimeException) {\n         Objects.requireNonNull(runtimeException, \"'runtimeException' cannot be null.\");\n+\n+        return logCheckedExceptionAsWarning(runtimeException);\n+    }\n+\n+    /**\n+     * Logs the {@link Throwable} at the warning level and returns it to be thrown.\n+     * <p>\n+     * This API covers the cases where a checked exception type needs to be thrown and logged. If a {@link\n+     * RuntimeException} is being logged use {@link #logExceptionAsWarning(RuntimeException)} instead.\n+     *\n+     * @param checkedException Throwable to be logged and returned.\n+     * @param <T> Type of the Throwable being logged.\n+     * @return The passed {@link Throwable}.\n+     * @throws NullPointerException If {@code checkedException} is {@code null}.\n+     */\n+    public <T extends Throwable> T logCheckedExceptionAsWarning(T checkedException) {\n+        Objects.requireNonNull(checkedException, \"'checkedException' cannot be null.\");\n         if (!logger.isWarnEnabled()) {\n-            return runtimeException;\n+            return checkedException;\n         }\n \n-        performLogging(LogLevel.WARNING, true, runtimeException.getMessage(), runtimeException);\n-        return runtimeException;\n+        performLogging(LogLevel.WARNING, true, checkedException.getMessage(), checkedException);\n+        return checkedException;\n     }\n \n     /**\n      * Logs the {@link RuntimeException} at the error level and returns it to be thrown.\n+     * <p>\n+     * This API covers the cases where a runtime exception type needs to be thrown and logged. If a {@link Throwable} is\n+     * being logged use {@link #logCheckedExceptionAsError(Throwable)} instead.\n      *\n      * @param runtimeException RuntimeException to be logged and returned.\n      * @return The passed {@code RuntimeException}.\n      * @throws NullPointerException If {@code runtimeException} is {@code null}.\n      */\n     public RuntimeException logExceptionAsError(RuntimeException runtimeException) {\n         Objects.requireNonNull(runtimeException, \"'runtimeException' cannot be null.\");\n+\n+        return logCheckedExceptionAsError(runtimeException);\n+    }\n+\n+    /**\n+     * Logs the {@link Throwable} at the error level and returns it to be thrown.\n+     * <p>\n+     * This API covers the cases where a checked exception type needs to be thrown and logged. If a {@link\n+     * RuntimeException} is being logged use {@link #logExceptionAsError(RuntimeException)} instead.\n+     *\n+     * @param checkedException Throwable to be logged and returned.\n+     * @param <T> Type of the Throwable being logged.\n+     * @return The passed {@link Throwable}.\n+     * @throws NullPointerException If {@code checkedException} is {@code null}.\n+     */\n+    public <T extends Throwable> T logCheckedExceptionAsError(T checkedException) {", "originalCommit": "d0a5174257d1ad764ea0435febbe8e03f220040c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU5NTQ1Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9194#discussion_r394595452", "bodyText": "Renamed", "author": "alzimmermsft", "createdAt": "2020-03-18T19:40:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU4Mjk3MQ=="}], "type": "inlineReview"}, {"oid": "05f35e4188b54b5c470d4c218d70c57588b715c0", "url": "https://github.com/Azure/azure-sdk-for-java/commit/05f35e4188b54b5c470d4c218d70c57588b715c0", "message": "Rename new APIs to something better, add opens for logging package, added missing property reset", "committedDate": "2020-03-18T19:33:58Z", "type": "commit"}, {"oid": "e9fa6ad49644228454940e228ff7b0b6797ac06c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/e9fa6ad49644228454940e228ff7b0b6797ac06c", "message": "Merge branch 'master' into AzCore_EnhanceClientLogger", "committedDate": "2020-03-18T19:49:19Z", "type": "commit"}, {"oid": "0cfd97169027587356b48074ba340420a714e4df", "url": "https://github.com/Azure/azure-sdk-for-java/commit/0cfd97169027587356b48074ba340420a714e4df", "message": "Merge branch 'master' into AzCore_EnhanceClientLogger", "committedDate": "2020-03-18T20:36:16Z", "type": "commit"}, {"oid": "ffd5a2e92505883f18fff50103d505cef614c70e", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ffd5a2e92505883f18fff50103d505cef614c70e", "message": "Additional logging changes", "committedDate": "2020-03-18T20:57:23Z", "type": "commit"}, {"oid": "c905f865eacc09c26a08e1cd05bdae9dae34cf9f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/c905f865eacc09c26a08e1cd05bdae9dae34cf9f", "message": "Update logging tests to mutate global configuration", "committedDate": "2020-03-18T23:03:56Z", "type": "commit"}]}