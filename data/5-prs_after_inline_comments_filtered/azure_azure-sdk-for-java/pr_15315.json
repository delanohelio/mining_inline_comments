{"pr_number": 15315, "pr_title": "RNTBDChannelPool design notes", "pr_createdAt": "2020-09-17T08:51:18Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/15315", "timeline": [{"oid": "09e4d27698579c074cd7c05dcf3c57915f0490ee", "url": "https://github.com/Azure/azure-sdk-for-java/commit/09e4d27698579c074cd7c05dcf3c57915f0490ee", "message": "First draft of notes", "committedDate": "2020-09-17T08:49:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDA4MDc4OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15315#discussion_r490080788", "bodyText": "Guess these are IntelliJ style default style changes.\nPlease help on how to use the common style.", "author": "kirankumarkolli", "createdAt": "2020-09-17T08:53:37Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/directconnectivity/rntbd/RntbdClientChannelPool.java", "diffHunk": "@@ -131,7 +169,7 @@\n         Comparator.comparingLong((task) -> task.originalPromise.getExpiryTimeInNanos()));\n \n     private final ScheduledFuture<?> pendingAcquisitionExpirationFuture;\n-    ", "originalCommit": "09e4d27698579c074cd7c05dcf3c57915f0490ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDA4MTA2OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15315#discussion_r490081068", "bodyText": "This is my understanding, lets please validate.", "author": "kirankumarkolli", "createdAt": "2020-09-17T08:54:01Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/directconnectivity/rntbd/RntbdClientChannelPool.java", "diffHunk": "@@ -58,6 +58,44 @@\n \n /**\n  * A {@link ChannelPool} implementation that enforces a maximum number of concurrent direct TCP Cosmos connections.\n+ *\n+ * RntbdClientChannelPool: Actors\n+ * \t- acquire (RntbdServiceEndpoint): acquire a channel to use\n+ * \t- release (RntbdServiceEndpoint): channel usage is complete and returning it back to pool\n+ * \t- Channel.closeChannel() Future: Event handling notifying the channel termination to refresh bookkeeping\n+ * \t- acquisitionTimeoutTimer: channel acquisition wait-out handler\n+ * \t- monitoring (through RntbdServiceEndpoint): get monitoring metrics\n+ *\n+ * \tBehaviors/Expectations:\n+ * \t    - Bounds: MAX_CHANNELS_PER_ENDPOINT * MAX_REQUESTS_ENDPOINT (NOT A GUARANTEE)", "originalCommit": "09e4d27698579c074cd7c05dcf3c57915f0490ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDA4MjAxOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15315#discussion_r490082019", "bodyText": "This coupled with serial connection creation might be a possible reason for high start-up latency at load for a single endpoint if-any.  Thoughts?", "author": "kirankumarkolli", "createdAt": "2020-09-17T08:55:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDA4MTA2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDE0ODczMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15315#discussion_r490148730", "bodyText": "Bounds:\n\nPendingAcquisition queue: default --> Max(10_000, MAX_CHANNELS_PER_ENDPOINT * MAX_REQUESTS_ENDPOINT)\nExecutor's event loop task queue: MAX_CHANNELS_PER_ENDPOINT * MAX_REQUESTS_ENDPOINT\nAvailableChannels.size()  + AcquiredChannels.size() <= MAX_CHANNELS_PER_ENDPOINT", "author": "FabianMeiswinkel", "createdAt": "2020-09-17T10:48:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDA4MTA2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDMyMTM2NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15315#discussion_r490321364", "bodyText": "Each acquisition also will be queued right, max tasks = #ENDPOINTS * MAX_CHANNELS_PER_ENDPOINT * MAX_REQUESTS_ENDPOINT + newAcquisitions (not yet in pendingAcquisitions)", "author": "kirankumarkolli", "createdAt": "2020-09-17T14:58:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDA4MTA2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDE0NjQ1NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15315#discussion_r490146454", "bodyText": "timeout", "author": "FabianMeiswinkel", "createdAt": "2020-09-17T10:43:34Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/directconnectivity/rntbd/RntbdClientChannelPool.java", "diffHunk": "@@ -58,6 +58,44 @@\n \n /**\n  * A {@link ChannelPool} implementation that enforces a maximum number of concurrent direct TCP Cosmos connections.\n+ *\n+ * RntbdClientChannelPool: Actors\n+ * \t- acquire (RntbdServiceEndpoint): acquire a channel to use\n+ * \t- release (RntbdServiceEndpoint): channel usage is complete and returning it back to pool\n+ * \t- Channel.closeChannel() Future: Event handling notifying the channel termination to refresh bookkeeping\n+ * \t- acquisitionTimeoutTimer: channel acquisition wait-out handler", "originalCommit": "09e4d27698579c074cd7c05dcf3c57915f0490ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDE0OTgyMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15315#discussion_r490149823", "bodyText": "I would argue this is by design - impossible to guarantee max TCP connections per endpoint without accepting that you might have to throw away newly created connections - establishing a connection is expensive - for both client and service. Usage scenarios don't need to be optimized for cold-start latency - CosmosDB prime time is for high load /throughput scenarios", "author": "FabianMeiswinkel", "createdAt": "2020-09-17T10:50:24Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/directconnectivity/rntbd/RntbdClientChannelPool.java", "diffHunk": "@@ -58,6 +58,44 @@\n \n /**\n  * A {@link ChannelPool} implementation that enforces a maximum number of concurrent direct TCP Cosmos connections.\n+ *\n+ * RntbdClientChannelPool: Actors\n+ * \t- acquire (RntbdServiceEndpoint): acquire a channel to use\n+ * \t- release (RntbdServiceEndpoint): channel usage is complete and returning it back to pool\n+ * \t- Channel.closeChannel() Future: Event handling notifying the channel termination to refresh bookkeeping\n+ * \t- acquisitionTimeoutTimer: channel acquisition wait-out handler\n+ * \t- monitoring (through RntbdServiceEndpoint): get monitoring metrics\n+ *\n+ * \tBehaviors/Expectations:\n+ * \t    - Bounds: MAX_CHANNELS_PER_ENDPOINT * MAX_REQUESTS_ENDPOINT (NOT A GUARANTEE)\n+ * \t    - NewChannel vs ReUseChannel:\n+ * \t        - NewChannels are serially created (current state NOT by-design)", "originalCommit": "09e4d27698579c074cd7c05dcf3c57915f0490ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDMyMTE3OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15315#discussion_r490321179", "bodyText": "On Max TCP connections part: Optimistically can be on done through Semaphore (with tryAcquire).\nI do agree that creating all connection is unnecessary and also counter productive on resources (as you mentioned). With OOB 130 connections are neither in great shape there. This needs revisit.\nWill update the text on NOT by-design part.", "author": "kirankumarkolli", "createdAt": "2020-09-17T14:58:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDE0OTgyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDE1MDQwNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15315#discussion_r490150404", "bodyText": "True if load factor < 90%. If LoadFactor > 90% we always choose the channel with the least number of pending requests - so fairness is attempted.", "author": "FabianMeiswinkel", "createdAt": "2020-09-17T10:51:36Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/directconnectivity/rntbd/RntbdClientChannelPool.java", "diffHunk": "@@ -58,6 +58,44 @@\n \n /**\n  * A {@link ChannelPool} implementation that enforces a maximum number of concurrent direct TCP Cosmos connections.\n+ *\n+ * RntbdClientChannelPool: Actors\n+ * \t- acquire (RntbdServiceEndpoint): acquire a channel to use\n+ * \t- release (RntbdServiceEndpoint): channel usage is complete and returning it back to pool\n+ * \t- Channel.closeChannel() Future: Event handling notifying the channel termination to refresh bookkeeping\n+ * \t- acquisitionTimeoutTimer: channel acquisition wait-out handler\n+ * \t- monitoring (through RntbdServiceEndpoint): get monitoring metrics\n+ *\n+ * \tBehaviors/Expectations:\n+ * \t    - Bounds: MAX_CHANNELS_PER_ENDPOINT * MAX_REQUESTS_ENDPOINT (NOT A GUARANTEE)\n+ * \t    - NewChannel vs ReUseChannel:\n+ * \t        - NewChannels are serially created (current state NOT by-design)\n+ * \t        - Will re-use an existing channel when possible (with MAX_REQUESTS_ENDPOINT constraint)\n+ * \t        - No guarantees on fairness per channel with-in bounds of MAX_REQUESTS_ENDPOINT. I.e. some channel might have high request concurrency compared to others", "originalCommit": "09e4d27698579c074cd7c05dcf3c57915f0490ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDE1MDkxMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15315#discussion_r490150911", "bodyText": "pendingAcquisitions is a ConcurrentQueue - no need to constrain to evetLoop", "author": "FabianMeiswinkel", "createdAt": "2020-09-17T10:52:44Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/directconnectivity/rntbd/RntbdClientChannelPool.java", "diffHunk": "@@ -58,6 +58,44 @@\n \n /**\n  * A {@link ChannelPool} implementation that enforces a maximum number of concurrent direct TCP Cosmos connections.\n+ *\n+ * RntbdClientChannelPool: Actors\n+ * \t- acquire (RntbdServiceEndpoint): acquire a channel to use\n+ * \t- release (RntbdServiceEndpoint): channel usage is complete and returning it back to pool\n+ * \t- Channel.closeChannel() Future: Event handling notifying the channel termination to refresh bookkeeping\n+ * \t- acquisitionTimeoutTimer: channel acquisition wait-out handler\n+ * \t- monitoring (through RntbdServiceEndpoint): get monitoring metrics\n+ *\n+ * \tBehaviors/Expectations:\n+ * \t    - Bounds: MAX_CHANNELS_PER_ENDPOINT * MAX_REQUESTS_ENDPOINT (NOT A GUARANTEE)\n+ * \t    - NewChannel vs ReUseChannel:\n+ * \t        - NewChannels are serially created (current state NOT by-design)\n+ * \t        - Will re-use an existing channel when possible (with MAX_REQUESTS_ENDPOINT constraint)\n+ * \t        - No guarantees on fairness per channel with-in bounds of MAX_REQUESTS_ENDPOINT. I.e. some channel might have high request concurrency compared to others\n+ * \t    - Channel serving guarantees:\n+ * \t        - Ordered delivery is not guaranteed (by-design)\n+ * \t        - Fairness is attempted but not a guarantee\n+ * \t        - [UNRELATED TO CHANNEL-POOL] [CURRENT DESIGN]: RntbdServiceEndpoint.write releases Channel before its usage -> acquisition order and channel user order might differ.\n+ * \t    - AcquisitionTimeout: if not can't be served in an expected time, fails gracefully\n+ * \t    - Metrics: are approximations and might be in-consistent(by-design) as well\n+ *\n+ * \tDesign Notes:\n+ * \t    - channelPool.eventLoop{@Link executor}: (executes on a single & same thread, serially)\n+ * \t        - Schedule only when it can be served immediately\n+ * \t        - Updates to below data structures should be done only when inside eventLoop\n+ * \t            - {@Link acquiredChannels}\n+ * \t            - {@Link availableChannels}\n+ * \t            - {@Link pendingAcquisitions}", "originalCommit": "09e4d27698579c074cd7c05dcf3c57915f0490ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDE1MTIyNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15315#discussion_r490151226", "bodyText": "Updates and reads that depend on \"strong consistency\" - like whether to create a new connection or not.", "author": "FabianMeiswinkel", "createdAt": "2020-09-17T10:53:25Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/directconnectivity/rntbd/RntbdClientChannelPool.java", "diffHunk": "@@ -58,6 +58,44 @@\n \n /**\n  * A {@link ChannelPool} implementation that enforces a maximum number of concurrent direct TCP Cosmos connections.\n+ *\n+ * RntbdClientChannelPool: Actors\n+ * \t- acquire (RntbdServiceEndpoint): acquire a channel to use\n+ * \t- release (RntbdServiceEndpoint): channel usage is complete and returning it back to pool\n+ * \t- Channel.closeChannel() Future: Event handling notifying the channel termination to refresh bookkeeping\n+ * \t- acquisitionTimeoutTimer: channel acquisition wait-out handler\n+ * \t- monitoring (through RntbdServiceEndpoint): get monitoring metrics\n+ *\n+ * \tBehaviors/Expectations:\n+ * \t    - Bounds: MAX_CHANNELS_PER_ENDPOINT * MAX_REQUESTS_ENDPOINT (NOT A GUARANTEE)\n+ * \t    - NewChannel vs ReUseChannel:\n+ * \t        - NewChannels are serially created (current state NOT by-design)\n+ * \t        - Will re-use an existing channel when possible (with MAX_REQUESTS_ENDPOINT constraint)\n+ * \t        - No guarantees on fairness per channel with-in bounds of MAX_REQUESTS_ENDPOINT. I.e. some channel might have high request concurrency compared to others\n+ * \t    - Channel serving guarantees:\n+ * \t        - Ordered delivery is not guaranteed (by-design)\n+ * \t        - Fairness is attempted but not a guarantee\n+ * \t        - [UNRELATED TO CHANNEL-POOL] [CURRENT DESIGN]: RntbdServiceEndpoint.write releases Channel before its usage -> acquisition order and channel user order might differ.\n+ * \t    - AcquisitionTimeout: if not can't be served in an expected time, fails gracefully\n+ * \t    - Metrics: are approximations and might be in-consistent(by-design) as well\n+ *\n+ * \tDesign Notes:\n+ * \t    - channelPool.eventLoop{@Link executor}: (executes on a single & same thread, serially)\n+ * \t        - Schedule only when it can be served immediately\n+ * \t        - Updates to below data structures should be done only when inside eventLoop", "originalCommit": "09e4d27698579c074cd7c05dcf3c57915f0490ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ee9eb66ddc45a25adf7c9d9814196f90d918961e", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ee9eb66ddc45a25adf7c9d9814196f90d918961e", "message": "Addressing the comments.", "committedDate": "2020-09-19T11:46:15Z", "type": "commit"}, {"oid": "248d110d53e000a60ce6cefd95c1ab4685cdd57d", "url": "https://github.com/Azure/azure-sdk-for-java/commit/248d110d53e000a60ce6cefd95c1ab4685cdd57d", "message": "Some more", "committedDate": "2020-09-19T12:15:56Z", "type": "commit"}, {"oid": "19dd4198a184ae4acf395599a62ab224b3b8c482", "url": "https://github.com/Azure/azure-sdk-for-java/commit/19dd4198a184ae4acf395599a62ab224b3b8c482", "message": "Some more freshed of the notes.", "committedDate": "2020-09-21T16:02:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5ODY5Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15315#discussion_r492298692", "bodyText": "AvailableChannels.size() + AcquiredChannels.size() + (connections in connecting state, i.e., connecting.get())  <= MAX_CHANNELS_PER_ENDPOINT", "author": "moderakh", "createdAt": "2020-09-21T19:33:32Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/directconnectivity/rntbd/RntbdClientChannelPool.java", "diffHunk": "@@ -58,6 +58,58 @@\n \n /**\n  * A {@link ChannelPool} implementation that enforces a maximum number of concurrent direct TCP Cosmos connections.\n+ *\n+ * RntbdClientChannelPool: Actors\n+ * \t- acquire (RntbdServiceEndpoint): acquire a channel to use\n+ * \t- release (RntbdServiceEndpoint): channel usage is complete and returning it back to pool\n+ * \t- Channel.closeChannel() Future: Event handling notifying the channel termination to refresh bookkeeping\n+ * \t- acquisitionTimeoutTimer: channel acquisition time-out handler\n+ * \t- monitoring (through RntbdServiceEndpoint): get monitoring metrics\n+ *\n+ * \tBehaviors/Expectations:\n+ * \t    - Bounds:\n+ * \t        - max requests in-flight per channelPool: MAX_CHANNELS_PER_ENDPOINT * MAX_REQUESTS_ENDPOINT (NOT A GUARANTEE)\n+ * \t        - AvailableChannels.size() + AcquiredChannels.size() <= MAX_CHANNELS_PER_ENDPOINT", "originalCommit": "19dd4198a184ae4acf395599a62ab224b3b8c482", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMxMTMyNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15315#discussion_r492311324", "bodyText": "Done.", "author": "kirankumarkolli", "createdAt": "2020-09-21T19:58:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5ODY5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5OTM0NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15315#discussion_r492299344", "bodyText": "how did we come up with the math?\nI might be missing something not sure on the accuracy of this one, could you please validate?", "author": "moderakh", "createdAt": "2020-09-21T19:34:52Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/directconnectivity/rntbd/RntbdClientChannelPool.java", "diffHunk": "@@ -58,6 +58,58 @@\n \n /**\n  * A {@link ChannelPool} implementation that enforces a maximum number of concurrent direct TCP Cosmos connections.\n+ *\n+ * RntbdClientChannelPool: Actors\n+ * \t- acquire (RntbdServiceEndpoint): acquire a channel to use\n+ * \t- release (RntbdServiceEndpoint): channel usage is complete and returning it back to pool\n+ * \t- Channel.closeChannel() Future: Event handling notifying the channel termination to refresh bookkeeping\n+ * \t- acquisitionTimeoutTimer: channel acquisition time-out handler\n+ * \t- monitoring (through RntbdServiceEndpoint): get monitoring metrics\n+ *\n+ * \tBehaviors/Expectations:\n+ * \t    - Bounds:\n+ * \t        - max requests in-flight per channelPool: MAX_CHANNELS_PER_ENDPOINT * MAX_REQUESTS_ENDPOINT (NOT A GUARANTEE)\n+ * \t        - AvailableChannels.size() + AcquiredChannels.size() <= MAX_CHANNELS_PER_ENDPOINT\n+ * \t        - PendingAcquisition queue default-size: Max(10_000, MAX_CHANNELS_PER_ENDPOINT * MAX_REQUESTS_ENDPOINT)\n+ * \t        - ChannelPool executor event-loop task queue length: MAX_CHANNELS_PER_ENDPOINT * MAX_REQUESTS_ENDPOINT + newInFlightAcquisitions (not yet in pendingAcquisitionQueue)", "originalCommit": "19dd4198a184ae4acf395599a62ab224b3b8c482", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMwOTMwNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15315#discussion_r492309304", "bodyText": "Closed it offline.", "author": "kirankumarkolli", "createdAt": "2020-09-21T19:54:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5OTM0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMwMjMzNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15315#discussion_r492302336", "bodyText": "strong consistency does this refer to cosmos db consistency?\nThe reason the access to internal fields need to happen on event-loop is to prevent race condition. I cannot see how \"cosmos strong consistency\" is relevant here.", "author": "moderakh", "createdAt": "2020-09-21T19:40:36Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/directconnectivity/rntbd/RntbdClientChannelPool.java", "diffHunk": "@@ -58,6 +58,58 @@\n \n /**\n  * A {@link ChannelPool} implementation that enforces a maximum number of concurrent direct TCP Cosmos connections.\n+ *\n+ * RntbdClientChannelPool: Actors\n+ * \t- acquire (RntbdServiceEndpoint): acquire a channel to use\n+ * \t- release (RntbdServiceEndpoint): channel usage is complete and returning it back to pool\n+ * \t- Channel.closeChannel() Future: Event handling notifying the channel termination to refresh bookkeeping\n+ * \t- acquisitionTimeoutTimer: channel acquisition time-out handler\n+ * \t- monitoring (through RntbdServiceEndpoint): get monitoring metrics\n+ *\n+ * \tBehaviors/Expectations:\n+ * \t    - Bounds:\n+ * \t        - max requests in-flight per channelPool: MAX_CHANNELS_PER_ENDPOINT * MAX_REQUESTS_ENDPOINT (NOT A GUARANTEE)\n+ * \t        - AvailableChannels.size() + AcquiredChannels.size() <= MAX_CHANNELS_PER_ENDPOINT\n+ * \t        - PendingAcquisition queue default-size: Max(10_000, MAX_CHANNELS_PER_ENDPOINT * MAX_REQUESTS_ENDPOINT)\n+ * \t        - ChannelPool executor event-loop task queue length: MAX_CHANNELS_PER_ENDPOINT * MAX_REQUESTS_ENDPOINT + newInFlightAcquisitions (not yet in pendingAcquisitionQueue)\n+ * \t            - newInFlightAcquisitions: is expected to very very short. Hard-bound to ADMINSSON_CONTROL (upstream in RntbdServiceEndpoint)\n+ * \t    - NewChannel vs ReUseChannel:\n+ * \t        - NewChannels are serially created (reasonable current state, possible future change, upstream please DON'T TAKE any dependency)\n+ * \t        - Will re-use an existing channel when possible (with MAX_REQUESTS_ENDPOINT attempt not GUARANTEED)\n+ * \t        - Channel usage fairness: fairness is attempted but not guaranteed\n+ * \t            - When loadFactor is > 90%, fairness is attempted by selecting Channel with less concurrency\n+ * \t            - Otherwise no guarantees on fairness per channel with-in bounds of MAX_REQUESTS_ENDPOINT. I.e. some channel might have high request concurrency compared to others\n+ * \t    - Channel serving guarantees:\n+ * \t        - Ordered delivery is not guaranteed (by-design)\n+ * \t        - Fairness is attempted but not a guarantee\n+ * \t        - [UNRELATED TO CHANNEL-POOL] [CURRENT DESIGN]: RntbdServiceEndpoint.write releases Channel before its usage -> acquisition order and channel user order might differ.\n+ * \t    - AcquisitionTimeout: if not can't be served in an expected time, fails gracefully\n+ * \t    - Metrics: are approximations and might be in-consistent(by-design) as well\n+ * \t    - EventLoop\n+ * \t        - ChannelPool executor might be shared across ChannelPools or Channel\n+ *\n+ * \tDesign Notes:\n+ * \t    - channelPool.eventLoop{@Link executor}: (executes on a single & same thread, serially)\n+ * \t        - Each channelPool gets an EventLoop (selection is round-robin)\n+ * \t        - Schedule only when it can be served immediately\n+ * \t        - Updates and reads that depend on \"strong consistency\" - like whether to create a new connection or not.", "originalCommit": "19dd4198a184ae4acf395599a62ab224b3b8c482", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMxMTQzNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15315#discussion_r492311435", "bodyText": "Closed offline", "author": "kirankumarkolli", "createdAt": "2020-09-21T19:58:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMwMjMzNg=="}], "type": "inlineReview"}, {"oid": "825e1713a136bbe4d76b15d840d2bd5c1991f7bd", "url": "https://github.com/Azure/azure-sdk-for-java/commit/825e1713a136bbe4d76b15d840d2bd5c1991f7bd", "message": "Refreshing it with comments", "committedDate": "2020-09-21T19:59:22Z", "type": "commit"}]}