{"pr_number": 15646, "pr_title": "Decouple PagedIterable and PagedFlux to Prevent Background Page Requests", "pr_createdAt": "2020-09-24T22:57:54Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/15646", "timeline": [{"oid": "711370567289b06187c69d84053f98c77c587a66", "url": "https://github.com/Azure/azure-sdk-for-java/commit/711370567289b06187c69d84053f98c77c587a66", "message": "Reproduction of PagedIterable eagerly consuming entire paged sequence", "committedDate": "2020-09-24T22:57:14Z", "type": "commit"}, {"oid": "7839f44350b8b6a9e1de79b43d3357759aca4dd1", "url": "https://github.com/Azure/azure-sdk-for-java/commit/7839f44350b8b6a9e1de79b43d3357759aca4dd1", "message": "Example of operator that properly handles reactively requesting pages", "committedDate": "2020-09-25T17:58:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE4ODU0Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15646#discussion_r495188543", "bodyText": "I think the latch.await() is something we have to be cautious about.\nOur \"drain + subscribe + latch.await\" could gets executes in the context of a non-blocking Thread. As an example, say app is running in a single thread, thread_0:\nthe drain() is executing in thread_0.\nsubscribe() results in queueing a n/w call and return.\nlatch.await() executed in thread_0, blocking it for the result.\nscheduled n/w call cannot be completed as thread_0 is waiting it\u2019s a deadlock.\nReactor marks some threads as non-blocking https://projectreactor.io/docs/core/release/api/reactor/core/scheduler/NonBlocking.html.", "author": "anuchandy", "createdAt": "2020-09-25T19:26:07Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/paging/ContinuablePagedFluxCore.java", "diffHunk": "@@ -228,4 +230,179 @@ boolean isDone() {\n             return this.isDone;\n         }\n     }\n+\n+    private static abstract class BaseSubscription<C, T, P extends ContinuablePage<C, T>, U, V>\n+        implements Subscription {\n+        private final Subscriber<? super U> subscriber;\n+        private final ContinuationState<C> continuationState;\n+        private final PageRetriever<C, P> pageRetriever;\n+        private final Integer defaultPageSize;\n+\n+        volatile boolean done;\n+        volatile V next;\n+        private Throwable error;\n+        private volatile boolean cancelled;\n+\n+        volatile int wip;\n+        @SuppressWarnings(\"rawtypes\")\n+        static final AtomicIntegerFieldUpdater<BaseSubscription> WIP =\n+            AtomicIntegerFieldUpdater.newUpdater(BaseSubscription.class, \"wip\");\n+\n+        volatile long requested;\n+        @SuppressWarnings(\"rawtypes\")\n+        static final AtomicLongFieldUpdater<BaseSubscription> REQUESTED =\n+            AtomicLongFieldUpdater.newUpdater(BaseSubscription.class, \"requested\");\n+\n+        BaseSubscription(Subscriber<? super U> subscriber, ContinuationState<C> continuationState,\n+            PageRetriever<C, P> pageRetriever, Integer defaultPageSize) {\n+            this.subscriber = subscriber;\n+            this.continuationState = continuationState;\n+            this.pageRetriever = pageRetriever;\n+            this.defaultPageSize = defaultPageSize;\n+        }\n+\n+        @Override\n+        public void request(long l) {\n+            if (Operators.validate(l)) {\n+                Operators.addCap(REQUESTED, this, l);\n+                drain();\n+            }\n+        }\n+\n+        private void drain() {\n+            if (WIP.getAndIncrement(this) != 0) {\n+                return;\n+            }\n+\n+            // On the first request or once the iterator is consumed request a page.\n+            if (needToRequestPage()) {\n+                requestPage();\n+            }\n+\n+            int missed = 1;\n+            while (true) {\n+                if (cancelled) {\n+                    return;\n+                }\n+\n+                if (REQUESTED.get(this) > 0) {\n+                    boolean emitted = false;\n+                    // read d before next to avoid race\n+                    boolean d = done;\n+                    if (hasNext()) {\n+                        subscriber.onNext(getNext());\n+                        emitted = true;\n+                    }\n+\n+                    if (d) {\n+                        if (error != null) {\n+                            subscriber.onError(error);\n+                        } else {\n+                            subscriber.onComplete();\n+                        }\n+\n+                        // exit without reducing wip so that further drains will be NOOP\n+                        return;\n+                    }\n+\n+                    if (emitted) {\n+                        // do this after checking d to avoid calling read\n+                        // when done\n+                        Operators.produced(REQUESTED, this, 1);\n+                    }\n+                }\n+\n+                missed = WIP.addAndGet(this, -missed);\n+                if (missed == 0) {\n+                    return;\n+                }\n+            }\n+        }\n+\n+        abstract boolean needToRequestPage();\n+        abstract boolean hasNext();\n+        abstract U getNext();\n+\n+        private void requestPage() {\n+            CountDownLatch countDownLatch = new CountDownLatch(1);\n+            pageRetriever.get(continuationState.getLastContinuationToken(), defaultPageSize)\n+                .singleOrEmpty()\n+                .subscribe(this::setNext, this::setError, countDownLatch::countDown);\n+\n+            try {\n+                countDownLatch.await();", "originalCommit": "7839f44350b8b6a9e1de79b43d3357759aca4dd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkzMTY0Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15646#discussion_r496931646", "bodyText": "Made it so only PagedIterable instances will use the blocking calling.", "author": "alzimmermsft", "createdAt": "2020-09-29T17:55:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTE4ODU0Mw=="}], "type": "inlineReview"}, {"oid": "85aab67d7db58ab25232098082f7ed7eb33bd12e", "url": "https://github.com/Azure/azure-sdk-for-java/commit/85aab67d7db58ab25232098082f7ed7eb33bd12e", "message": "Additional fixes and updates to Subscriber implementations, added tests for PagedFlux", "committedDate": "2020-09-25T23:37:02Z", "type": "commit"}, {"oid": "f124ec2e679139c1df72536dba3a80e6b7308ed9", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f124ec2e679139c1df72536dba3a80e6b7308ed9", "message": "Only have ContinuablePagedIterable use the synchronous page retrieving subscription", "committedDate": "2020-09-26T03:00:53Z", "type": "commit"}, {"oid": "a3a7a1ccb4ac112ae9aaafb904cc42a3565b8572", "url": "https://github.com/Azure/azure-sdk-for-java/commit/a3a7a1ccb4ac112ae9aaafb904cc42a3565b8572", "message": "Merge branch 'master' into AzCore_InvestigatePagedIterable", "committedDate": "2020-09-28T16:09:20Z", "type": "commit"}, {"oid": "3344457a2fec9cf0564aa284d8d2e9dd94d393d6", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3344457a2fec9cf0564aa284d8d2e9dd94d393d6", "message": "Updated logic to check if by item subscription has another element to emit", "committedDate": "2020-09-28T16:35:06Z", "type": "commit"}, {"oid": "ed9c589045cdba01a7b19987f303fb03539fb79a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ed9c589045cdba01a7b19987f303fb03539fb79a", "message": "Changes to when last page is signalled and updating the work in progress tracker", "committedDate": "2020-09-28T18:48:35Z", "type": "commit"}, {"oid": "3f501d7174ec3e7b97836c6aca46f86bdbb6b9bc", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3f501d7174ec3e7b97836c6aca46f86bdbb6b9bc", "message": "Merge branch 'master' into AzCore_InvestigatePagedIterable", "committedDate": "2020-09-28T19:46:04Z", "type": "commit"}, {"oid": "4b24d53d4f27c65745142aa59ec4565ac2be3dfc", "url": "https://github.com/Azure/azure-sdk-for-java/commit/4b24d53d4f27c65745142aa59ec4565ac2be3dfc", "message": "Merge branch 'master' into AzCore_InvestigatePagedIterable", "committedDate": "2020-09-29T01:08:33Z", "type": "commit"}, {"oid": "5819d1baa06bc4f419ea6e1a349b9b6f6dc28a53", "url": "https://github.com/Azure/azure-sdk-for-java/commit/5819d1baa06bc4f419ea6e1a349b9b6f6dc28a53", "message": "Move latch countdown to prevent race condition", "committedDate": "2020-09-29T03:03:41Z", "type": "commit"}, {"oid": "83c42f1a78793463c5ecc93e7c3c829295679adc", "url": "https://github.com/Azure/azure-sdk-for-java/commit/83c42f1a78793463c5ecc93e7c3c829295679adc", "message": "Merge branch 'master' into AzCore_InvestigatePagedIterable", "committedDate": "2020-09-29T18:11:44Z", "type": "commit"}, {"oid": "996c4c8b26db9b7dc2831a1660fe64d9e31c7fcb", "url": "https://github.com/Azure/azure-sdk-for-java/commit/996c4c8b26db9b7dc2831a1660fe64d9e31c7fcb", "message": "Add iterator implementation that backs PagedIterable", "committedDate": "2020-09-29T20:34:10Z", "type": "commit"}, {"oid": "416380a374df31d7f8e6d508895a1e50b3be6549", "url": "https://github.com/Azure/azure-sdk-for-java/commit/416380a374df31d7f8e6d508895a1e50b3be6549", "message": "Update pattern to use block instead of locking subscription", "committedDate": "2020-09-29T21:59:16Z", "type": "commit"}, {"oid": "d43e6d7bd005e331ede66d6e19795f04f598430f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d43e6d7bd005e331ede66d6e19795f04f598430f", "message": "Fix IndexOutOfBounds exceptions", "committedDate": "2020-09-29T22:21:48Z", "type": "commit"}, {"oid": "ed6c397f4aea5f749045684f847d399b3dc78cd8", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ed6c397f4aea5f749045684f847d399b3dc78cd8", "message": "Remove synchronized keyword to prevent deadlock", "committedDate": "2020-09-30T00:37:55Z", "type": "commit"}, {"oid": "39f753c997be3526747dd59b20fcffbcb74f585c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/39f753c997be3526747dd59b20fcffbcb74f585c", "message": "Fix edge case when pages with zero elements are returned to the by item iterator, updated test recording given the eager first page retrieval change when getting an iterator, updated construction of the iterable when using non-ContinuablePagedFluxCore based implementation", "committedDate": "2020-09-30T05:14:35Z", "type": "commit"}, {"oid": "17dc022be88013b00efe80e2fa99953aa01e8564", "url": "https://github.com/Azure/azure-sdk-for-java/commit/17dc022be88013b00efe80e2fa99953aa01e8564", "message": "Add missing playback file update", "committedDate": "2020-09-30T15:16:10Z", "type": "commit"}, {"oid": "a4c054f6d50f60edf52715059f2a486d9547e5c1", "url": "https://github.com/Azure/azure-sdk-for-java/commit/a4c054f6d50f60edf52715059f2a486d9547e5c1", "message": "Removed subcription based prototype", "committedDate": "2020-09-30T16:39:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc3MDgyOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15646#discussion_r497770828", "bodyText": "I would add some guard/assertion to all these new tests that makes sure that there's actually more than one page in the underlying data source. Otherwise it's easy to make this test worthless if someone changes underlying data source to have just one page. (btw. it's not that easy for me to trace data flow in these tests so I can't tell whether source has one or more pages... some check would be great.)", "author": "kasobol-msft", "createdAt": "2020-09-30T20:09:26Z", "path": "sdk/core/azure-core/src/test/java/com/azure/core/http/rest/PagedFluxTest.java", "diffHunk": "@@ -284,15 +284,63 @@ public void testPagedFluxWithContext() throws Exception {\n             return Mono.empty();\n         }\n \n-        return Mono.just(pagedResponses.get(Integer.valueOf(continuationToken)));\n+        int parsedToken = Integer.parseInt(continuationToken);\n+        if (parsedToken >= pagedResponses.size()) {\n+            return Mono.empty();\n+        }\n+\n+        return Mono.just(pagedResponses.get(parsedToken));\n     }\n \n     private List<Integer> getItems(Integer i) {\n         return IntStream.range(i * 3, i * 3 + 3).boxed().collect(Collectors.toList());\n     }\n \n     private List<String> getStringItems(Integer i) {\n-        return IntStream.range(i * 3, i * 3 + 3).boxed().map(val -> String.valueOf(val)).collect(Collectors.toList());\n+        return IntStream.range(i * 3, i * 3 + 3).boxed().map(String::valueOf).collect(Collectors.toList());\n     }\n \n+    @Test\n+    public void streamFindFirstOnlyRetrievesOnePage() throws InterruptedException {\n+        OnlyOnePageRetriever pageRetriever = new OnlyOnePageRetriever();\n+        Integer next = new OnlyOnePagedFlux(() -> pageRetriever).blockFirst();\n+\n+        Thread.sleep(2000);\n+\n+        assertEquals(1, pageRetriever.getGetCount());\n+    }", "originalCommit": "a4c054f6d50f60edf52715059f2a486d9547e5c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc4MDQyNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15646#discussion_r497780425", "bodyText": "OnlyOnePageRetriever should return 5 pages when consumed to completion. In each of the new tests I'll add an initial verification that OnlyOnePagedFlux/OnlyOnePagedIterable using collect toList is greater than one element.", "author": "alzimmermsft", "createdAt": "2020-09-30T20:27:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc3MDgyOA=="}], "type": "inlineReview"}, {"oid": "e27799b6c11535dc63a36a933b0da8a7f9e348b4", "url": "https://github.com/Azure/azure-sdk-for-java/commit/e27799b6c11535dc63a36a933b0da8a7f9e348b4", "message": "Merge branch 'master' into AzCore_InvestigatePagedIterable", "committedDate": "2020-10-01T00:31:56Z", "type": "commit"}, {"oid": "8373c2e41396f04e7b914fc503f58e58e5ae334d", "url": "https://github.com/Azure/azure-sdk-for-java/commit/8373c2e41396f04e7b914fc503f58e58e5ae334d", "message": "Add validation that PagedIterable/PagedFlux have more than one page before testing lazy consumption", "committedDate": "2020-10-01T00:49:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM3Nzk1NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15646#discussion_r498377954", "bodyText": "should we add a test for using pagedIterable.stream().parallel() and iteration on output of parallel? just double confirming our iterable impl is stream safe.", "author": "anuchandy", "createdAt": "2020-10-01T16:37:19Z", "path": "sdk/core/azure-core/src/test/java/com/azure/core/http/rest/PagedIterableTest.java", "diffHunk": "@@ -250,4 +256,90 @@ int getNextPageRetrievals() {\n             return nextPageRetrievals;\n         }\n     }\n+\n+    @Test\n+    public void streamFindFirstOnlyRetrievesOnePage() throws InterruptedException {\n+        OnlyOnePageRetriever pageRetriever = new OnlyOnePageRetriever();\n+        OnlyOnePagedIterable pagedIterable = new OnlyOnePagedIterable(new OnlyOnePagedFlux(() -> pageRetriever));\n+\n+        // Validation that there is more than one paged in the full return.\n+        pagedIterable.stream().count();\n+        int fullPageCount = pageRetriever.getGetCount();\n+        assertTrue(fullPageCount > 1);\n+\n+        Integer next = pagedIterable.stream().findFirst().get();\n+\n+        Thread.sleep(2000);\n+\n+        /*\n+         * Given that each page contains more than one element we are able to only retrieve a single page.\n+         */\n+        assertEquals(1, pageRetriever.getGetCount() - fullPageCount);\n+    }", "originalCommit": "8373c2e41396f04e7b914fc503f58e58e5ae334d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM4Nzk2MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15646#discussion_r498387961", "bodyText": "Will add tests for these", "author": "alzimmermsft", "createdAt": "2020-10-01T16:55:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM3Nzk1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM4NzA2MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15646#discussion_r498387060", "bodyText": "Is then() required here since you have a block() after this?", "author": "srnagar", "createdAt": "2020-10-01T16:53:48Z", "path": "sdk/core/azure-core/src/main/java/com/azure/core/util/paging/ContinuablePagedByIteratorBase.java", "diffHunk": "@@ -0,0 +1,100 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.core.util.paging;\n+\n+import com.azure.core.util.logging.ClientLogger;\n+\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * Internal class that is a blocking iterator base class.\n+ * <p>\n+ * This class manages retrieving and maintaining previously retrieve page/pages in a synchronous fashion. It will ensure\n+ * the minimum number of pages are retrieved from a service by checking if any additional items/pages could be emitted\n+ * before requesting additional ones from the service.\n+ *\n+ * @param <C> The continuation token type.\n+ * @param <T> The item type.\n+ * @param <P> The page type.\n+ * @param <E> The type that the {@link ContinuablePagedIterable} will emit.\n+ */\n+abstract class ContinuablePagedByIteratorBase<C, T, P extends ContinuablePage<C, T>, E> implements Iterator<E> {\n+    private final PageRetriever<C, P> pageRetriever;\n+    private final ContinuationState<C> continuationState;\n+    private final Integer defaultPageSize;\n+    private final ClientLogger logger;\n+\n+    private volatile boolean done;\n+\n+    ContinuablePagedByIteratorBase(PageRetriever<C, P> pageRetriever, ContinuationState<C> continuationState,\n+        Integer defaultPageSize, ClientLogger logger) {\n+        this.continuationState = continuationState;\n+        this.pageRetriever = pageRetriever;\n+        this.defaultPageSize = defaultPageSize;\n+        this.logger = logger;\n+    }\n+\n+    @Override\n+    public E next() {\n+        if (!hasNext()) {\n+            throw logger.logExceptionAsError(new NoSuchElementException(\"Iterator contains no more elements.\"));\n+        }\n+\n+        return getNext();\n+    }\n+\n+    @Override\n+    public boolean hasNext() {\n+        // Request next pages in a loop in case we are returned empty pages for the by item implementation.\n+        while (!done && needToRequestPage()) {\n+            requestPage();\n+        }\n+\n+        return isNextAvailable();\n+    }\n+\n+    /*\n+     * Indicates if a page needs to be requested.\n+     */\n+    abstract boolean needToRequestPage();\n+\n+    /*\n+     * Indicates if another element is available.\n+     */\n+    abstract boolean isNextAvailable();\n+\n+    /*\n+     * Gets the next element to be emitted.\n+     */\n+    abstract E getNext();\n+\n+    synchronized void requestPage() {\n+        AtomicBoolean receivedPages = new AtomicBoolean(false);\n+        pageRetriever.get(continuationState.getLastContinuationToken(), defaultPageSize)\n+            .map(page -> {\n+                receivedPages.set(true);\n+                addPage(page);\n+\n+                continuationState.setLastContinuationToken(page.getContinuationToken());\n+                this.done = continuationState.isDone();\n+\n+                return page;\n+            })\n+            .then()", "originalCommit": "8373c2e41396f04e7b914fc503f58e58e5ae334d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ2NjA2Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/15646#discussion_r498466063", "bodyText": "Will change this toblockLast()", "author": "alzimmermsft", "createdAt": "2020-10-01T19:24:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM4NzA2MA=="}], "type": "inlineReview"}, {"oid": "40452b17c9cbc8c82d01727dedec4ebbc5213875", "url": "https://github.com/Azure/azure-sdk-for-java/commit/40452b17c9cbc8c82d01727dedec4ebbc5213875", "message": "Merge branch 'master' into AzCore_InvestigatePagedIterable", "committedDate": "2020-10-01T19:19:39Z", "type": "commit"}, {"oid": "4938f57f9cdcec3ee087bb3755fe103d2e263d9c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/4938f57f9cdcec3ee087bb3755fe103d2e263d9c", "message": "Add guard for requesting more pages than needed, added Stream.parallel tests to ensure the correct number of pages are requested", "committedDate": "2020-10-01T20:23:23Z", "type": "commit"}]}