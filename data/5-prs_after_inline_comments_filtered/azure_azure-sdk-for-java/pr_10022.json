{"pr_number": 10022, "pr_title": "Add support for receiving from Subscription", "pr_createdAt": "2020-04-09T17:35:09Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/10022", "timeline": [{"oid": "79c670bede4b5c37c5c7a70bd66219ad8e792a2a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/79c670bede4b5c37c5c7a70bd66219ad8e792a2a", "message": "Remembering to clear receive queues.", "committedDate": "2020-04-10T00:20:39Z", "type": "forcePushed"}, {"oid": "dc91291afd5d646a385d8d5126a7446f09831bb0", "url": "https://github.com/Azure/azure-sdk-for-java/commit/dc91291afd5d646a385d8d5126a7446f09831bb0", "message": "Fix tests.", "committedDate": "2020-04-10T00:26:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgyNjgwNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10022#discussion_r406826806", "bodyText": "It is confusing to call it SUBSCRIPTION in sender. But I understand why you have done it.", "author": "hemanttanwar", "createdAt": "2020-04-10T16:09:55Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusClientBuilder.java", "diffHunk": "@@ -432,7 +433,7 @@ public ServiceBusSenderAsyncClient buildAsyncClient() {\n                 case QUEUE:\n                     entityName = queueName;\n                     break;\n-                case TOPIC:\n+                case SUBSCRIPTION:\n                     entityName = topicName;", "originalCommit": "dc91291afd5d646a385d8d5126a7446f09831bb0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjk0MTI5OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10022#discussion_r406941298", "bodyText": "Yes. To match the entity type passed to Service Bus.", "author": "conniey", "createdAt": "2020-04-10T20:58:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgyNjgwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgzMDAwNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10022#discussion_r406830007", "bodyText": "Did you miss using sendMessage(messageToSend) here  and  adding timeout?", "author": "hemanttanwar", "createdAt": "2020-04-10T16:17:23Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClientIntegrationTest.java", "diffHunk": "@@ -476,11 +523,14 @@ void sendReceiveMessageWithVariousPropertyTypes() {\n         sentProperties.put(\"UUIDProperty\", UUID.randomUUID());\n         sentProperties.put(\"StringProperty\", \"string\");\n \n-        sender.send(messageToSend).block(TIMEOUT);\n+        sender.send(messageToSend);\n ", "originalCommit": "dc91291afd5d646a385d8d5126a7446f09831bb0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgzMzYxNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10022#discussion_r406833616", "bodyText": "I can see that quickly we will have to change this to include other input parameters, for example\nqueuename / topic names , sessionId for receivers . So instead of taking taking just one parameters entityType, it should take a bag of things and  use that  bag to create receivers.", "author": "hemanttanwar", "createdAt": "2020-04-10T16:25:58Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusSenderClientIntegrationTest.java", "diffHunk": "@@ -62,6 +96,47 @@ void nonSessionMessageBatch() {\n         for (ServiceBusMessage message : messages) {\n             Assertions.assertTrue(batch.tryAdd(message));\n         }\n+\n         sender.send(batch);\n+\n+        for (int i = 0; i < messages.size(); i++) {\n+            messagesPending.incrementAndGet();\n+        }\n+    }\n+\n+    void setSenderAndReceiver(MessagingEntityType entityType) {", "originalCommit": "dc91291afd5d646a385d8d5126a7446f09831bb0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjg1MjgyNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10022#discussion_r406852824", "bodyText": "This is for sender. There are not many properties. And the receiver will always be the same so that we can clean up the messaging entity in the case of a failure.\nIn receiver, there is an overload that takes: Function<ServiceBusReceiverClientBuilder, ServiceBusReceiverClientBuilder> onCreate, where you can apply any other custom modifications.", "author": "conniey", "createdAt": "2020-04-10T17:11:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgzMzYxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgzNTc0MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10022#discussion_r406835741", "bodyText": "Why we are not using TIMEOUT ?", "author": "hemanttanwar", "createdAt": "2020-04-10T16:31:09Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClientIntegrationTest.java", "diffHunk": "@@ -22,178 +24,165 @@\n import java.util.UUID;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n import java.util.stream.Stream;\n \n+import static com.azure.messaging.servicebus.TestUtils.MESSAGE_POSITION_ID;\n import static com.azure.messaging.servicebus.TestUtils.MESSAGE_TRACKING_ID;\n import static com.azure.messaging.servicebus.TestUtils.getServiceBusMessage;\n import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.assertNotNull;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n \n+/**\n+ * Integration tests for {@link ServiceBusReceiverAsyncClient} from queues or subscriptions.\n+ */\n class ServiceBusReceiverAsyncClientIntegrationTest extends IntegrationTestBase {\n-    private static final String CONTENTS = \"Test-contents\";\n+    private static final byte[] CONTENTS_BYTES = \"Some-contents\".getBytes(StandardCharsets.UTF_8);\n     private final ClientLogger logger = new ClientLogger(ServiceBusReceiverAsyncClientIntegrationTest.class);\n+    private final AtomicInteger messagesPending = new AtomicInteger();\n \n     private ServiceBusReceiverAsyncClient receiver;\n-    private ServiceBusReceiverAsyncClient receiveDeleteModeReceiver;\n+    private ServiceBusReceiverAsyncClient receiveAndDeleteReceiver;\n     private ServiceBusSenderAsyncClient sender;\n \n     ServiceBusReceiverAsyncClientIntegrationTest() {\n         super(new ClientLogger(ServiceBusReceiverAsyncClientIntegrationTest.class));\n     }\n \n     @Override\n-    protected void beforeTest() {\n-        final String queueName = getQueueName();\n-        assertNotNull(queueName, \"'queueName' cannot be null.\");\n-\n-        sender = createBuilder().sender().queueName(queueName).buildAsyncClient();\n-        receiver = createBuilder()\n-            .receiver()\n-            .queueName(queueName)\n-            .buildAsyncClient();\n-\n-        receiveDeleteModeReceiver = createBuilder()\n-            .receiver()\n-            .queueName(queueName)\n-            .receiveMode(ReceiveMode.RECEIVE_AND_DELETE)\n-            .buildAsyncClient();\n+    protected void afterTest() {\n+        if (messagesPending.get() == 0) {\n+            dispose(receiver, sender, receiveAndDeleteReceiver);\n+            return;\n+        }\n+\n+        // In the case that this test failed... we're going to drain the queue or subscription.\n+        try {\n+            receiveAndDeleteReceiver.receive(new ReceiveAsyncOptions().setEnableAutoComplete(false))\n+                .take(messagesPending.get())\n+                .map(message -> {\n+                    logger.info(\"Message received: {}\", message.getSequenceNumber());\n+                    return message;\n+                })\n+                .timeout(Duration.ofSeconds(5), Mono.empty())\n+                .blockLast();\n+        } catch (Exception e) {\n+            logger.warning(\"Error occurred when draining queue.\", e);\n+        } finally {\n+            dispose(receiver, sender, receiveAndDeleteReceiver);\n+        }\n     }\n \n-    @Override\n-    protected void afterTest() {\n-        dispose(receiver, receiveDeleteModeReceiver, sender);\n+    static Stream<Arguments> receiverTypesProvider() {\n+        return Stream.of(\n+            Arguments.of(MessagingEntityType.QUEUE),\n+            Arguments.of(MessagingEntityType.SUBSCRIPTION)\n+        );\n     }\n \n     /**\n      * Verifies that we can send and receive two messages.\n      */\n     @Disabled(\"Problem when receiving two messages. Link is closed prematurely.\")\n-    @Test\n-    void receiveTwoMessagesAutoComplete() {\n+    @MethodSource(\"receiverTypesProvider\")\n+    @ParameterizedTest\n+    void receiveTwoMessagesAutoComplete(MessagingEntityType entityType) {\n         // Arrange\n+        setSenderAndReceiver(entityType);\n+\n         final String messageId = UUID.randomUUID().toString();\n-        final ServiceBusMessage message = TestUtils.getServiceBusMessage(CONTENTS, messageId, 0);\n-        final ReceiveAsyncOptions options = new ReceiveAsyncOptions().setEnableAutoComplete(false);\n+        final int position = 10;\n+        final ServiceBusMessage message = TestUtils.getServiceBusMessage(CONTENTS_BYTES, messageId, position);\n+\n+        Mono.when(sendMessage(message), sendMessage(message)).block();\n \n         // Assert & Act\n-        StepVerifier.create(sender.send(message).then(sender.send(message))\n-            .thenMany(receiver.receive(options)))\n-            .assertNext(receivedMessage ->\n-                assertTrue(receivedMessage.getProperties().containsKey(MESSAGE_TRACKING_ID)))\n-            .assertNext(receivedMessage ->\n-                assertTrue(receivedMessage.getProperties().containsKey(MESSAGE_TRACKING_ID)))\n+        StepVerifier.create(receiver.receive())\n+            .assertNext(receivedMessage -> assertMessageEquals(receivedMessage, CONTENTS_BYTES, messageId, position))\n+            .assertNext(receivedMessage -> assertMessageEquals(receivedMessage, CONTENTS_BYTES, messageId, position))\n             .thenCancel()\n             .verify();\n     }\n \n     /**\n      * Verifies that we can send and receive a message.\n      */\n-    @Test\n-    void receiveMessageAutoComplete() {\n+    @MethodSource(\"receiverTypesProvider\")\n+    @ParameterizedTest\n+    void receiveMessageAutoComplete(MessagingEntityType entityType) {\n         // Arrange\n+        setSenderAndReceiver(entityType);\n+\n         final String messageId = UUID.randomUUID().toString();\n-        final ServiceBusMessage message = TestUtils.getServiceBusMessage(CONTENTS, messageId, 0);\n-        final ReceiveAsyncOptions options = new ReceiveAsyncOptions().setEnableAutoComplete(false);\n+        final ServiceBusMessage message = TestUtils.getServiceBusMessage(CONTENTS_BYTES, messageId, 0);\n+\n+        sendMessage(message).block();\n \n         // Assert & Act\n-        StepVerifier.create(sender.send(message).thenMany(receiver.receive(options)))\n-            .assertNext(receivedMessage ->\n-                assertTrue(receivedMessage.getProperties().containsKey(MESSAGE_TRACKING_ID)))\n+        StepVerifier.create(receiver.receive())\n+            .assertNext(receivedMessage -> assertMessageEquals(receivedMessage, CONTENTS_BYTES, messageId, 0))\n             .thenCancel()\n             .verify();\n     }\n \n     /**\n      * Verifies that we can send and peek a message.\n      */\n-    @Test\n-    void peekMessage() {\n+    @MethodSource(\"receiverTypesProvider\")\n+    @ParameterizedTest\n+    void peekMessage(MessagingEntityType entityType) {\n         // Arrange\n+        setSenderAndReceiver(entityType);\n+\n         final String messageId = UUID.randomUUID().toString();\n-        final ServiceBusMessage message = TestUtils.getServiceBusMessage(CONTENTS, messageId, 0);\n+        final ServiceBusMessage message = TestUtils.getServiceBusMessage(CONTENTS_BYTES, messageId, 0);\n+\n+        sendMessage(message).block();\n \n         // Assert & Act\n-        StepVerifier.create(sender.send(message).then(receiver.peek()))\n-            .assertNext(receivedMessage -> assertTrue(receivedMessage.getProperties().containsKey(MESSAGE_TRACKING_ID)))\n+        StepVerifier.create(receiver.peek())\n+            .assertNext(receivedMessage -> assertMessageEquals(receivedMessage, CONTENTS_BYTES, messageId, 0))\n             .verifyComplete();\n     }\n \n     /**\n      * Verifies that we can schedule and receive a message.\n      */\n-    @Test\n-    void sendScheduledMessageAndReceive() {\n+    @MethodSource(\"receiverTypesProvider\")\n+    @ParameterizedTest\n+    void sendScheduledMessageAndReceive(MessagingEntityType entityType) {\n         // Arrange\n+        setSenderAndReceiver(entityType);\n+\n         final String messageId = UUID.randomUUID().toString();\n-        final String contents = \"Some-contents\";\n-        final ServiceBusMessage message = TestUtils.getServiceBusMessage(contents, messageId, 0);\n+        final ServiceBusMessage message = TestUtils.getServiceBusMessage(CONTENTS_BYTES, messageId, 0);\n         final Instant scheduledEnqueueTime = Instant.now().plusSeconds(2);\n-\n-        sender.scheduleMessage(message, scheduledEnqueueTime)\n-            .delaySubscription(Duration.ofSeconds(3))\n-            .block();\n-\n-        // Assert & Act\n-        StepVerifier.create(receiver.receive().take(1))\n-            .assertNext(receivedMessage -> {\n-                assertArrayEquals(contents.getBytes(), receivedMessage.getBody());\n-                assertTrue(receivedMessage.getProperties().containsKey(MESSAGE_TRACKING_ID));\n-            })\n-            .verifyComplete();\n-    }\n-\n-    /**\n-     * Verifies that we can schedule and receive multiple messages.\n-     */\n-    @Test\n-    void sendMultipleScheduledMessageAndReceive() {\n-        // Arrange\n-        final String messageId1 = UUID.randomUUID().toString();\n-        final String messageId2 = UUID.randomUUID().toString();\n-        final ServiceBusMessage message1 = TestUtils.getServiceBusMessage(CONTENTS, messageId1, 0);\n-        final ServiceBusMessage message2 = TestUtils.getServiceBusMessage(CONTENTS, messageId2, 0);\n-        final Duration duration = Duration.ofSeconds(10);\n-        final Instant scheduledEnqueueTime = Instant.now().plus(duration);\n         final ReceiveAsyncOptions options = new ReceiveAsyncOptions().setEnableAutoComplete(false);\n \n-        sender.scheduleMessage(message1, scheduledEnqueueTime)\n-            .block(TIMEOUT);\n-        sender.scheduleMessage(message2, scheduledEnqueueTime)\n-            .block(TIMEOUT);\n+        sender.scheduleMessage(message, scheduledEnqueueTime).block();\n ", "originalCommit": "dc91291afd5d646a385d8d5126a7446f09831bb0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjg1NDAyMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10022#discussion_r406854021", "bodyText": "In IntegrationTestBase, we set the StepVerifier.setDefaultTimeout(), so it'll use that. Practically, we can remove all the .block(TIMEOUT).", "author": "conniey", "createdAt": "2020-04-10T17:14:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjgzNTc0MQ=="}], "type": "inlineReview"}, {"oid": "315f0058e4ef0ee815d121bfbb9d33ee0675af3d", "url": "https://github.com/Azure/azure-sdk-for-java/commit/315f0058e4ef0ee815d121bfbb9d33ee0675af3d", "message": "Adding support for subscribing to a topic.", "committedDate": "2020-04-11T03:47:42Z", "type": "commit"}, {"oid": "3a2f3cf451d19c930dfe67db01a2ef6a674803cc", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3a2f3cf451d19c930dfe67db01a2ef6a674803cc", "message": "Adding test cases for topics.", "committedDate": "2020-04-11T03:47:42Z", "type": "commit"}, {"oid": "a0b59c5b501fddc39f2dde530f4ee78f66515b86", "url": "https://github.com/Azure/azure-sdk-for-java/commit/a0b59c5b501fddc39f2dde530f4ee78f66515b86", "message": "Update tests.", "committedDate": "2020-04-11T03:48:54Z", "type": "commit"}, {"oid": "6bb2f6088c573766df2a9dac54b7e26444575f82", "url": "https://github.com/Azure/azure-sdk-for-java/commit/6bb2f6088c573766df2a9dac54b7e26444575f82", "message": "Fixing integration tests.", "committedDate": "2020-04-11T03:49:21Z", "type": "commit"}, {"oid": "08717ca45a6e30df76e2a4b43d70cc49d79f5fd4", "url": "https://github.com/Azure/azure-sdk-for-java/commit/08717ca45a6e30df76e2a4b43d70cc49d79f5fd4", "message": "Remembering to clear receive queues.", "committedDate": "2020-04-11T03:49:22Z", "type": "commit"}, {"oid": "ad7c459eac5a702f48b1b2f9d2df63ab9791e1ac", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ad7c459eac5a702f48b1b2f9d2df63ab9791e1ac", "message": "Fix tests.", "committedDate": "2020-04-11T03:49:22Z", "type": "commit"}, {"oid": "82a156c48e9257d2353d364428e76f70fe6e488f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/82a156c48e9257d2353d364428e76f70fe6e488f", "message": "Clean up tests.", "committedDate": "2020-04-11T03:49:23Z", "type": "commit"}, {"oid": "82a156c48e9257d2353d364428e76f70fe6e488f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/82a156c48e9257d2353d364428e76f70fe6e488f", "message": "Clean up tests.", "committedDate": "2020-04-11T03:49:23Z", "type": "forcePushed"}, {"oid": "83dfb41da3927af33e1d5fb71b196aa48afa00df", "url": "https://github.com/Azure/azure-sdk-for-java/commit/83dfb41da3927af33e1d5fb71b196aa48afa00df", "message": "Adding support for subscription sessions.", "committedDate": "2020-04-11T05:10:01Z", "type": "commit"}, {"oid": "28f5ed895524a1842036e5fdcd0c6578d4d52bb4", "url": "https://github.com/Azure/azure-sdk-for-java/commit/28f5ed895524a1842036e5fdcd0c6578d4d52bb4", "message": "Update tests.yml creation.", "committedDate": "2020-04-11T05:10:10Z", "type": "commit"}, {"oid": "bb3ecabc57fa94809a9e319cbef4fd473750c3cb", "url": "https://github.com/Azure/azure-sdk-for-java/commit/bb3ecabc57fa94809a9e319cbef4fd473750c3cb", "message": "Clean up test methods.", "committedDate": "2020-04-12T18:43:15Z", "type": "commit"}, {"oid": "d66b9b7a953ba7816187264edd03f3bbbf54e70b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d66b9b7a953ba7816187264edd03f3bbbf54e70b", "message": "Cleaning up receiver and sender tests.", "committedDate": "2020-04-12T21:44:00Z", "type": "commit"}, {"oid": "d66b9b7a953ba7816187264edd03f3bbbf54e70b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d66b9b7a953ba7816187264edd03f3bbbf54e70b", "message": "Cleaning up receiver and sender tests.", "committedDate": "2020-04-12T21:44:00Z", "type": "forcePushed"}, {"oid": "29241fd222adfdd6b73e82121bb7a58bb24372eb", "url": "https://github.com/Azure/azure-sdk-for-java/commit/29241fd222adfdd6b73e82121bb7a58bb24372eb", "message": "Fixing session support.", "committedDate": "2020-04-13T04:37:11Z", "type": "commit"}, {"oid": "4222da87a7081245b8a53cda07c4b1b354b323d0", "url": "https://github.com/Azure/azure-sdk-for-java/commit/4222da87a7081245b8a53cda07c4b1b354b323d0", "message": "Clean up management constants and management channel methods.", "committedDate": "2020-04-13T06:12:19Z", "type": "commit"}, {"oid": "f35df908a2d2c7afef2bcfac11fc9fd09cf8c100", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f35df908a2d2c7afef2bcfac11fc9fd09cf8c100", "message": "Fix renewMessageLock for a session message.", "committedDate": "2020-04-13T06:17:49Z", "type": "commit"}, {"oid": "a7550e6620c490ef6f0e4858e0752f8d231e105a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/a7550e6620c490ef6f0e4858e0752f8d231e105a", "message": "Fixing tests.", "committedDate": "2020-04-13T07:37:01Z", "type": "commit"}, {"oid": "a7550e6620c490ef6f0e4858e0752f8d231e105a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/a7550e6620c490ef6f0e4858e0752f8d231e105a", "message": "Fixing tests.", "committedDate": "2020-04-13T07:37:01Z", "type": "forcePushed"}]}