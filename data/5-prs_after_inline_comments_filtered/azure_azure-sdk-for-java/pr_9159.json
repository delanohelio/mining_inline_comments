{"pr_number": 9159, "pr_title": "ServiceBus Track2 - Message lock renew  by user", "pr_createdAt": "2020-03-17T06:59:20Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/9159", "timeline": [{"oid": "10eef267af63b85187ff5a7f31becd7399914352", "url": "https://github.com/Azure/azure-sdk-for-java/commit/10eef267af63b85187ff5a7f31becd7399914352", "message": "renew lock by user", "committedDate": "2020-03-17T06:57:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY3ODU2Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9159#discussion_r393678566", "bodyText": "You don't need this override, calling the management node method with a lock token is sufficient.", "author": "conniey", "createdAt": "2020-03-17T13:28:58Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java", "diffHunk": "@@ -87,6 +96,27 @@\n         }));\n     }\n \n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Mono<Instant> renewMessageLock(ServiceBusReceivedMessage messageForLockRenew) {", "originalCommit": "10eef267af63b85187ff5a7f31becd7399914352", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY4MDU5Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9159#discussion_r393680593", "bodyText": "I don't know if this is the correct operator, what if there are multiple instants? .single() would throw an exception if there were more than one element.", "author": "conniey", "createdAt": "2020-03-17T13:32:06Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java", "diffHunk": "@@ -87,6 +96,27 @@\n         }));\n     }\n \n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Mono<Instant> renewMessageLock(ServiceBusReceivedMessage messageForLockRenew) {\n+        return renewMessageLock(new UUID[]{messageForLockRenew.getLockToken()})\n+            .last()\n+            .publishOn(scheduler);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Mono<Instant> renewMessageLock(UUID lockToken) {\n+        return renewMessageLock(new UUID[]{lockToken})\n+            .last()", "originalCommit": "10eef267af63b85187ff5a7f31becd7399914352", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzc5MjQ2MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9159#discussion_r393792461", "bodyText": "Normally service would return one because we are sending one lock token . But  in track1 also , they are using same logic since AMQP message comes as array in case of one lock token.", "author": "hemanttanwar", "createdAt": "2020-03-17T16:05:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY4MDU5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ1MjM1Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9159#discussion_r394452357", "bodyText": "Yes, and using .single() would force it to throw if there was more than one element in the flux. why not use .next() rather than .last() then? If the stream had 10000 elements, this would not complete until 9999 elements had been emitted.", "author": "conniey", "createdAt": "2020-03-18T15:51:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY4MDU5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU0NDQ1Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9159#discussion_r394544452", "bodyText": "that should be fine I guess.", "author": "hemanttanwar", "createdAt": "2020-03-18T18:08:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY4MDU5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY4MDg1MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9159#discussion_r393680850", "bodyText": "Is there a reason you're creating another array with the same content?", "author": "conniey", "createdAt": "2020-03-17T13:32:31Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java", "diffHunk": "@@ -202,6 +232,39 @@ private Message createDispositionMessage(UUID[] lockTokens, DispositionStatus di\n         return message;\n     }\n \n+    private Flux<Instant> renewMessageLock(UUID[] renewLockList) {\n+\n+        return  isAuthorized(PEEK_OPERATION_VALUE).thenMany(createRequestResponse.flatMap(channel -> {\n+            UUID[] lockTokens = Arrays.stream(renewLockList)\n+                //.map(ServiceBusReceivedMessage::getLockToken)", "originalCommit": "10eef267af63b85187ff5a7f31becd7399914352", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzcxOTQ0Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9159#discussion_r393719446", "bodyText": "removing it.", "author": "hemanttanwar", "createdAt": "2020-03-17T14:27:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY4MDg1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY4MTA2OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9159#discussion_r393681069", "bodyText": "REQUEST_RESPONSE_RENEWLOCK_OPERATION -> REQUEST_RESPONSE_RENEW_LOCK_OPERATION", "author": "conniey", "createdAt": "2020-03-17T13:32:52Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java", "diffHunk": "@@ -202,6 +232,39 @@ private Message createDispositionMessage(UUID[] lockTokens, DispositionStatus di\n         return message;\n     }\n \n+    private Flux<Instant> renewMessageLock(UUID[] renewLockList) {\n+\n+        return  isAuthorized(PEEK_OPERATION_VALUE).thenMany(createRequestResponse.flatMap(channel -> {\n+            UUID[] lockTokens = Arrays.stream(renewLockList)\n+                //.map(ServiceBusReceivedMessage::getLockToken)\n+                .toArray(UUID[]::new);\n+\n+            Message requestMessage = createManagementMessage(REQUEST_RESPONSE_RENEWLOCK_OPERATION,", "originalCommit": "10eef267af63b85187ff5a7f31becd7399914352", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY4MTc3OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9159#discussion_r393681778", "bodyText": "Prefixing these constants with request_response isn't necessary. It was because all their message constants were in the same file. Ones relevant to Management are in the ManagementConstants file.", "author": "conniey", "createdAt": "2020-03-17T13:33:52Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java", "diffHunk": "@@ -38,6 +43,10 @@\n import static com.azure.messaging.servicebus.implementation.ManagementConstants.REQUEST_RESPONSE_MESSAGE_COUNT;\n import static com.azure.messaging.servicebus.implementation.ManagementConstants.SERVER_TIMEOUT;\n import static com.azure.messaging.servicebus.implementation.ManagementConstants.UPDATE_DISPOSITION_OPERATION;\n+import static com.azure.messaging.servicebus.implementation.ManagementConstants.REQUEST_RESPONSE_LOCKTOKENS;", "originalCommit": "10eef267af63b85187ff5a7f31becd7399914352", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY4MTkzNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9159#discussion_r393681934", "bodyText": "LOCKTOKENS -> LOCK_TOKENS", "author": "conniey", "createdAt": "2020-03-17T13:34:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY4MTc3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY4MjU5Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9159#discussion_r393682596", "bodyText": "What if the status isn't OK? We should return an error.", "author": "conniey", "createdAt": "2020-03-17T13:35:04Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java", "diffHunk": "@@ -202,6 +232,39 @@ private Message createDispositionMessage(UUID[] lockTokens, DispositionStatus di\n         return message;\n     }\n \n+    private Flux<Instant> renewMessageLock(UUID[] renewLockList) {\n+\n+        return  isAuthorized(PEEK_OPERATION_VALUE).thenMany(createRequestResponse.flatMap(channel -> {\n+            UUID[] lockTokens = Arrays.stream(renewLockList)\n+                //.map(ServiceBusReceivedMessage::getLockToken)\n+                .toArray(UUID[]::new);\n+\n+            Message requestMessage = createManagementMessage(REQUEST_RESPONSE_RENEWLOCK_OPERATION,\n+                channel.getReceiveLinkName());\n+\n+            requestMessage.setBody(new AmqpValue(Collections.singletonMap(REQUEST_RESPONSE_LOCKTOKENS, lockTokens)));\n+            return channel.sendWithAck(requestMessage);\n+        }).flatMapMany(responseMessage -> {\n+            int statusCode = RequestResponseUtils.getResponseStatusCode(responseMessage);\n+            List<Instant> expirationsForLocks = new ArrayList<>();\n+            if (statusCode ==  REQUEST_RESPONSE_OK_STATUS_CODE) {", "originalCommit": "10eef267af63b85187ff5a7f31becd7399914352", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY4Mjk2Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9159#discussion_r393682963", "bodyText": "You need to run Alt+Shift+L to reformat the code. There is incorrect spacing on a few lines.", "author": "conniey", "createdAt": "2020-03-17T13:35:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY4MjU5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY4Mzk3NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9159#discussion_r393683975", "bodyText": "All this logic can be moved to MessageSerializer.", "author": "conniey", "createdAt": "2020-03-17T13:37:05Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java", "diffHunk": "@@ -202,6 +232,39 @@ private Message createDispositionMessage(UUID[] lockTokens, DispositionStatus di\n         return message;\n     }\n \n+    private Flux<Instant> renewMessageLock(UUID[] renewLockList) {\n+\n+        return  isAuthorized(PEEK_OPERATION_VALUE).thenMany(createRequestResponse.flatMap(channel -> {\n+            UUID[] lockTokens = Arrays.stream(renewLockList)\n+                //.map(ServiceBusReceivedMessage::getLockToken)\n+                .toArray(UUID[]::new);\n+\n+            Message requestMessage = createManagementMessage(REQUEST_RESPONSE_RENEWLOCK_OPERATION,\n+                channel.getReceiveLinkName());\n+\n+            requestMessage.setBody(new AmqpValue(Collections.singletonMap(REQUEST_RESPONSE_LOCKTOKENS, lockTokens)));\n+            return channel.sendWithAck(requestMessage);\n+        }).flatMapMany(responseMessage -> {\n+            int statusCode = RequestResponseUtils.getResponseStatusCode(responseMessage);", "originalCommit": "10eef267af63b85187ff5a7f31becd7399914352", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA4OTUzMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9159#discussion_r394089531", "bodyText": "moved to serializer.", "author": "hemanttanwar", "createdAt": "2020-03-18T03:36:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY4Mzk3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY4NDM4Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9159#discussion_r393684382", "bodyText": "This unchecked cast makes me nervous. I would be more defensive about casting (ie. checking instanceof).", "author": "conniey", "createdAt": "2020-03-17T13:37:43Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java", "diffHunk": "@@ -202,6 +232,39 @@ private Message createDispositionMessage(UUID[] lockTokens, DispositionStatus di\n         return message;\n     }\n \n+    private Flux<Instant> renewMessageLock(UUID[] renewLockList) {\n+\n+        return  isAuthorized(PEEK_OPERATION_VALUE).thenMany(createRequestResponse.flatMap(channel -> {\n+            UUID[] lockTokens = Arrays.stream(renewLockList)\n+                //.map(ServiceBusReceivedMessage::getLockToken)\n+                .toArray(UUID[]::new);\n+\n+            Message requestMessage = createManagementMessage(REQUEST_RESPONSE_RENEWLOCK_OPERATION,\n+                channel.getReceiveLinkName());\n+\n+            requestMessage.setBody(new AmqpValue(Collections.singletonMap(REQUEST_RESPONSE_LOCKTOKENS, lockTokens)));\n+            return channel.sendWithAck(requestMessage);\n+        }).flatMapMany(responseMessage -> {\n+            int statusCode = RequestResponseUtils.getResponseStatusCode(responseMessage);\n+            List<Instant> expirationsForLocks = new ArrayList<>();\n+            if (statusCode ==  REQUEST_RESPONSE_OK_STATUS_CODE) {\n+                @SuppressWarnings(\"unchecked\")\n+                Map<String, Object> responseBody = (Map<String, Object>) ((AmqpValue) responseMessage", "originalCommit": "10eef267af63b85187ff5a7f31becd7399914352", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY4NDg4NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9159#discussion_r393684884", "bodyText": "This variable creation isn't necessary if you're going to pass it immediately to the next line.", "author": "conniey", "createdAt": "2020-03-17T13:38:25Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java", "diffHunk": "@@ -202,6 +232,39 @@ private Message createDispositionMessage(UUID[] lockTokens, DispositionStatus di\n         return message;\n     }\n \n+    private Flux<Instant> renewMessageLock(UUID[] renewLockList) {\n+\n+        return  isAuthorized(PEEK_OPERATION_VALUE).thenMany(createRequestResponse.flatMap(channel -> {\n+            UUID[] lockTokens = Arrays.stream(renewLockList)\n+                //.map(ServiceBusReceivedMessage::getLockToken)\n+                .toArray(UUID[]::new);\n+\n+            Message requestMessage = createManagementMessage(REQUEST_RESPONSE_RENEWLOCK_OPERATION,\n+                channel.getReceiveLinkName());\n+\n+            requestMessage.setBody(new AmqpValue(Collections.singletonMap(REQUEST_RESPONSE_LOCKTOKENS, lockTokens)));\n+            return channel.sendWithAck(requestMessage);\n+        }).flatMapMany(responseMessage -> {\n+            int statusCode = RequestResponseUtils.getResponseStatusCode(responseMessage);\n+            List<Instant> expirationsForLocks = new ArrayList<>();\n+            if (statusCode ==  REQUEST_RESPONSE_OK_STATUS_CODE) {\n+                @SuppressWarnings(\"unchecked\")\n+                Map<String, Object> responseBody = (Map<String, Object>) ((AmqpValue) responseMessage\n+                    .getBody()).getValue();\n+                Object expirationListObj = responseBody.get(REQUEST_RESPONSE_EXPIRATIONS);\n+\n+                if (expirationListObj instanceof  Date[]) {\n+                    Date[] expirations = (Date[]) expirationListObj;", "originalCommit": "10eef267af63b85187ff5a7f31becd7399914352", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY4NTQ5Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9159#discussion_r393685492", "bodyText": "Instead of returning Flux.fromIterable, you could have kept it as a stream instead of collecting it twice and using fromStream", "author": "conniey", "createdAt": "2020-03-17T13:39:25Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java", "diffHunk": "@@ -202,6 +232,39 @@ private Message createDispositionMessage(UUID[] lockTokens, DispositionStatus di\n         return message;\n     }\n \n+    private Flux<Instant> renewMessageLock(UUID[] renewLockList) {\n+\n+        return  isAuthorized(PEEK_OPERATION_VALUE).thenMany(createRequestResponse.flatMap(channel -> {\n+            UUID[] lockTokens = Arrays.stream(renewLockList)\n+                //.map(ServiceBusReceivedMessage::getLockToken)\n+                .toArray(UUID[]::new);\n+\n+            Message requestMessage = createManagementMessage(REQUEST_RESPONSE_RENEWLOCK_OPERATION,\n+                channel.getReceiveLinkName());\n+\n+            requestMessage.setBody(new AmqpValue(Collections.singletonMap(REQUEST_RESPONSE_LOCKTOKENS, lockTokens)));\n+            return channel.sendWithAck(requestMessage);\n+        }).flatMapMany(responseMessage -> {\n+            int statusCode = RequestResponseUtils.getResponseStatusCode(responseMessage);\n+            List<Instant> expirationsForLocks = new ArrayList<>();\n+            if (statusCode ==  REQUEST_RESPONSE_OK_STATUS_CODE) {\n+                @SuppressWarnings(\"unchecked\")\n+                Map<String, Object> responseBody = (Map<String, Object>) ((AmqpValue) responseMessage\n+                    .getBody()).getValue();\n+                Object expirationListObj = responseBody.get(REQUEST_RESPONSE_EXPIRATIONS);\n+\n+                if (expirationListObj instanceof  Date[]) {\n+                    Date[] expirations = (Date[]) expirationListObj;\n+                    expirationsForLocks =  Arrays.stream(expirations)\n+                        .map(Date::toInstant)\n+                        .collect(Collectors.toList());\n+                }\n+            }\n+            return Flux.fromIterable(expirationsForLocks);", "originalCommit": "10eef267af63b85187ff5a7f31becd7399914352", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY4NTYxOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9159#discussion_r393685618", "bodyText": "This already exists in AmqpResponseCode.", "author": "conniey", "createdAt": "2020-03-17T13:39:36Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementConstants.java", "diffHunk": "@@ -40,4 +40,8 @@\n     static final String REQUEST_RESPONSE_VIA_PARTITION_KEY = \"via-partition-key\";\n     static final String REQUEST_RESPONSE_SCHEDULE_MESSAGE_OPERATION = AmqpConstants.VENDOR + \":schedule-message\";\n     static final String REQUEST_RESPONSE_ASSOCIATED_LINK_NAME = \"associated-link-name\";\n+    static final String REQUEST_RESPONSE_LOCKTOKENS = \"lock-tokens\";\n+    static final String REQUEST_RESPONSE_RENEWLOCK_OPERATION = AmqpConstants.VENDOR + \":renew-lock\";\n+    static final int REQUEST_RESPONSE_OK_STATUS_CODE = 200;", "originalCommit": "10eef267af63b85187ff5a7f31becd7399914352", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY4NTg0NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9159#discussion_r393685844", "bodyText": "Remove these commented lines", "author": "conniey", "createdAt": "2020-03-17T13:39:59Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/samples/java/com/azure/messaging/servicebus/ReceiveMessageAndExtendLockSample.java", "diffHunk": "@@ -0,0 +1,130 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.AmqpEndpointState;\n+import com.azure.core.amqp.AmqpShutdownSignal;\n+import com.azure.core.amqp.implementation.AmqpReceiveLink;\n+import com.azure.core.util.logging.ClientLogger;\n+import org.apache.qpid.proton.message.Message;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+import reactor.core.Disposable;\n+import reactor.core.publisher.DirectProcessor;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Schedulers;\n+import reactor.test.StepVerifier;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+import static org.mockito.Mockito.when;\n+\n+public class ReceiveMessageAndExtendLockSample {\n+\n+    private static final String PAYLOAD = \"hello\";\n+    private static final byte[] PAYLOAD_BYTES = PAYLOAD.getBytes(UTF_8);\n+    private static final int PREFETCH = 1;\n+\n+    private final ClientLogger logger = new ClientLogger(MessageReceiverAsyncClient.class);\n+    private final String messageTrackingUUID = UUID.randomUUID().toString();\n+    private final DirectProcessor<Message> messageProcessor = DirectProcessor.create();\n+    private final DirectProcessor<Throwable> errorProcessor = DirectProcessor.create();\n+    private final DirectProcessor<AmqpEndpointState> endpointProcessor = DirectProcessor.create();\n+    private final DirectProcessor<AmqpShutdownSignal> shutdownProcessor = DirectProcessor.create();\n+\n+    @Mock\n+    private AmqpReceiveLink amqpReceiveLink;\n+\n+    @Captor\n+    private ArgumentCaptor<Supplier<Integer>> creditSupplier;\n+\n+    private Mono<AmqpReceiveLink> receiveLinkMono;\n+    private List<Message> messages = new ArrayList<>();\n+\n+    private ServiceBusReceiverAsyncClient consumer;\n+\n+\n+    @BeforeEach\n+    public void setup() {\n+        MockitoAnnotations.initMocks(this);\n+        receiveLinkMono = Mono.fromCallable(() -> amqpReceiveLink);\n+\n+        when(amqpReceiveLink.receive()).thenReturn(messageProcessor);\n+        //when(amqpReceiveLink.getErrors()).thenReturn(errorProcessor);", "originalCommit": "10eef267af63b85187ff5a7f31becd7399914352", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY4NjEyNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9159#discussion_r393686124", "bodyText": "Why not use a fake connection string rather than reading from the environment.", "author": "conniey", "createdAt": "2020-03-17T13:40:25Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/samples/java/com/azure/messaging/servicebus/ReceiveMessageAndExtendLockSample.java", "diffHunk": "@@ -0,0 +1,130 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.AmqpEndpointState;\n+import com.azure.core.amqp.AmqpShutdownSignal;\n+import com.azure.core.amqp.implementation.AmqpReceiveLink;\n+import com.azure.core.util.logging.ClientLogger;\n+import org.apache.qpid.proton.message.Message;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+import reactor.core.Disposable;\n+import reactor.core.publisher.DirectProcessor;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Schedulers;\n+import reactor.test.StepVerifier;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+import static org.mockito.Mockito.when;\n+\n+public class ReceiveMessageAndExtendLockSample {\n+\n+    private static final String PAYLOAD = \"hello\";\n+    private static final byte[] PAYLOAD_BYTES = PAYLOAD.getBytes(UTF_8);\n+    private static final int PREFETCH = 1;\n+\n+    private final ClientLogger logger = new ClientLogger(MessageReceiverAsyncClient.class);\n+    private final String messageTrackingUUID = UUID.randomUUID().toString();\n+    private final DirectProcessor<Message> messageProcessor = DirectProcessor.create();\n+    private final DirectProcessor<Throwable> errorProcessor = DirectProcessor.create();\n+    private final DirectProcessor<AmqpEndpointState> endpointProcessor = DirectProcessor.create();\n+    private final DirectProcessor<AmqpShutdownSignal> shutdownProcessor = DirectProcessor.create();\n+\n+    @Mock\n+    private AmqpReceiveLink amqpReceiveLink;\n+\n+    @Captor\n+    private ArgumentCaptor<Supplier<Integer>> creditSupplier;\n+\n+    private Mono<AmqpReceiveLink> receiveLinkMono;\n+    private List<Message> messages = new ArrayList<>();\n+\n+    private ServiceBusReceiverAsyncClient consumer;\n+\n+\n+    @BeforeEach\n+    public void setup() {\n+        MockitoAnnotations.initMocks(this);\n+        receiveLinkMono = Mono.fromCallable(() -> amqpReceiveLink);\n+\n+        when(amqpReceiveLink.receive()).thenReturn(messageProcessor);\n+        //when(amqpReceiveLink.getErrors()).thenReturn(errorProcessor);\n+        //when(amqpReceiveLink.getConnectionStates()).thenReturn(endpointProcessor);\n+        //when(amqpReceiveLink.getShutdownSignals()).thenReturn(shutdownProcessor);\n+\n+        String connectionString = System.getenv(\"AZURE_SERVICEBUS_CONNECTION_STRING\")", "originalCommit": "10eef267af63b85187ff5a7f31becd7399914352", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY4NjcxOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9159#discussion_r393686719", "bodyText": "Asserts are for checking if the message you received is correct. You are doing a lot more logic here.\nConsider using .then(Runnable)", "author": "conniey", "createdAt": "2020-03-17T13:41:16Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/samples/java/com/azure/messaging/servicebus/ReceiveMessageAndExtendLockSample.java", "diffHunk": "@@ -0,0 +1,130 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.AmqpEndpointState;\n+import com.azure.core.amqp.AmqpShutdownSignal;\n+import com.azure.core.amqp.implementation.AmqpReceiveLink;\n+import com.azure.core.util.logging.ClientLogger;\n+import org.apache.qpid.proton.message.Message;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+import reactor.core.Disposable;\n+import reactor.core.publisher.DirectProcessor;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Schedulers;\n+import reactor.test.StepVerifier;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+import static org.mockito.Mockito.when;\n+\n+public class ReceiveMessageAndExtendLockSample {\n+\n+    private static final String PAYLOAD = \"hello\";\n+    private static final byte[] PAYLOAD_BYTES = PAYLOAD.getBytes(UTF_8);\n+    private static final int PREFETCH = 1;\n+\n+    private final ClientLogger logger = new ClientLogger(MessageReceiverAsyncClient.class);\n+    private final String messageTrackingUUID = UUID.randomUUID().toString();\n+    private final DirectProcessor<Message> messageProcessor = DirectProcessor.create();\n+    private final DirectProcessor<Throwable> errorProcessor = DirectProcessor.create();\n+    private final DirectProcessor<AmqpEndpointState> endpointProcessor = DirectProcessor.create();\n+    private final DirectProcessor<AmqpShutdownSignal> shutdownProcessor = DirectProcessor.create();\n+\n+    @Mock\n+    private AmqpReceiveLink amqpReceiveLink;\n+\n+    @Captor\n+    private ArgumentCaptor<Supplier<Integer>> creditSupplier;\n+\n+    private Mono<AmqpReceiveLink> receiveLinkMono;\n+    private List<Message> messages = new ArrayList<>();\n+\n+    private ServiceBusReceiverAsyncClient consumer;\n+\n+\n+    @BeforeEach\n+    public void setup() {\n+        MockitoAnnotations.initMocks(this);\n+        receiveLinkMono = Mono.fromCallable(() -> amqpReceiveLink);\n+\n+        when(amqpReceiveLink.receive()).thenReturn(messageProcessor);\n+        //when(amqpReceiveLink.getErrors()).thenReturn(errorProcessor);\n+        //when(amqpReceiveLink.getConnectionStates()).thenReturn(endpointProcessor);\n+        //when(amqpReceiveLink.getShutdownSignals()).thenReturn(shutdownProcessor);\n+\n+        String connectionString = System.getenv(\"AZURE_SERVICEBUS_CONNECTION_STRING\")\n+            + \";EntityPath=hemant-test1\";\n+\n+        // Instantiate a client that will be used to call the service.\n+\n+        consumer = new ServiceBusClientBuilder()\n+            .connectionString(connectionString)\n+            .scheduler(Schedulers.elastic())\n+            .buildAsyncReceiverClient();\n+    }\n+\n+    @AfterEach\n+    public void teardown() {\n+        messages.clear();\n+        Mockito.framework().clearInlineMocks();\n+        consumer.close();\n+    }\n+\n+    @Test\n+    public void receiveAndExtendLockMessage() {\n+\n+        // Arrange\n+        final int numberOfEvents = 1;\n+\n+        // Act & Assert\n+        StepVerifier.create(\n+            consumer.receive()\n+                .take(numberOfEvents))\n+            .assertNext(receivedMessage -> {\n+                AtomicReference<Instant> timeToRefresh = new AtomicReference<>(receivedMessage.getLockedUntil());", "originalCommit": "10eef267af63b85187ff5a7f31becd7399914352", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY4NzM4MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9159#discussion_r393687381", "bodyText": "We shouldn't be using Thread.sleep() to test or wait. StepVerifier was created so it could wrap the async operations and wait correctly.", "author": "conniey", "createdAt": "2020-03-17T13:42:17Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/samples/java/com/azure/messaging/servicebus/ReceiveMessageAndExtendLockSample.java", "diffHunk": "@@ -0,0 +1,130 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.AmqpEndpointState;\n+import com.azure.core.amqp.AmqpShutdownSignal;\n+import com.azure.core.amqp.implementation.AmqpReceiveLink;\n+import com.azure.core.util.logging.ClientLogger;\n+import org.apache.qpid.proton.message.Message;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+import reactor.core.Disposable;\n+import reactor.core.publisher.DirectProcessor;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Schedulers;\n+import reactor.test.StepVerifier;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+import static org.mockito.Mockito.when;\n+\n+public class ReceiveMessageAndExtendLockSample {\n+\n+    private static final String PAYLOAD = \"hello\";\n+    private static final byte[] PAYLOAD_BYTES = PAYLOAD.getBytes(UTF_8);\n+    private static final int PREFETCH = 1;\n+\n+    private final ClientLogger logger = new ClientLogger(MessageReceiverAsyncClient.class);\n+    private final String messageTrackingUUID = UUID.randomUUID().toString();\n+    private final DirectProcessor<Message> messageProcessor = DirectProcessor.create();\n+    private final DirectProcessor<Throwable> errorProcessor = DirectProcessor.create();\n+    private final DirectProcessor<AmqpEndpointState> endpointProcessor = DirectProcessor.create();\n+    private final DirectProcessor<AmqpShutdownSignal> shutdownProcessor = DirectProcessor.create();\n+\n+    @Mock\n+    private AmqpReceiveLink amqpReceiveLink;\n+\n+    @Captor\n+    private ArgumentCaptor<Supplier<Integer>> creditSupplier;\n+\n+    private Mono<AmqpReceiveLink> receiveLinkMono;\n+    private List<Message> messages = new ArrayList<>();\n+\n+    private ServiceBusReceiverAsyncClient consumer;\n+\n+\n+    @BeforeEach\n+    public void setup() {\n+        MockitoAnnotations.initMocks(this);\n+        receiveLinkMono = Mono.fromCallable(() -> amqpReceiveLink);\n+\n+        when(amqpReceiveLink.receive()).thenReturn(messageProcessor);\n+        //when(amqpReceiveLink.getErrors()).thenReturn(errorProcessor);\n+        //when(amqpReceiveLink.getConnectionStates()).thenReturn(endpointProcessor);\n+        //when(amqpReceiveLink.getShutdownSignals()).thenReturn(shutdownProcessor);\n+\n+        String connectionString = System.getenv(\"AZURE_SERVICEBUS_CONNECTION_STRING\")\n+            + \";EntityPath=hemant-test1\";\n+\n+        // Instantiate a client that will be used to call the service.\n+\n+        consumer = new ServiceBusClientBuilder()\n+            .connectionString(connectionString)\n+            .scheduler(Schedulers.elastic())\n+            .buildAsyncReceiverClient();\n+    }\n+\n+    @AfterEach\n+    public void teardown() {\n+        messages.clear();\n+        Mockito.framework().clearInlineMocks();\n+        consumer.close();\n+    }\n+\n+    @Test\n+    public void receiveAndExtendLockMessage() {\n+\n+        // Arrange\n+        final int numberOfEvents = 1;\n+\n+        // Act & Assert\n+        StepVerifier.create(\n+            consumer.receive()\n+                .take(numberOfEvents))\n+            .assertNext(receivedMessage -> {\n+                AtomicReference<Instant> timeToRefresh = new AtomicReference<>(receivedMessage.getLockedUntil());\n+                log(\" Got message time to refresh in \" + receivedMessage.getLockedUntil());\n+                Disposable renewDisposable = consumer.renewMessageLock(receivedMessage)\n+                    .repeat(() -> true)\n+                    .delayElements(Duration.ofSeconds(1))\n+                    .subscribe(instant -> {\n+                        log(\" New time instant:\" + instant);\n+                        timeToRefresh.set(instant);\n+                    });\n+\n+                // processing the messaging\n+                int count = 0;\n+                while (count < 15) {\n+                    ++count;\n+                    log(count + \". processing message \");\n+                    try {\n+                        Thread.sleep(1000);", "originalCommit": "10eef267af63b85187ff5a7f31becd7399914352", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzY4NzQ2Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9159#discussion_r393687463", "bodyText": "Use clientlogger", "author": "conniey", "createdAt": "2020-03-17T13:42:24Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/samples/java/com/azure/messaging/servicebus/ReceiveMessageAndExtendLockSample.java", "diffHunk": "@@ -0,0 +1,130 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import com.azure.core.amqp.AmqpEndpointState;\n+import com.azure.core.amqp.AmqpShutdownSignal;\n+import com.azure.core.amqp.implementation.AmqpReceiveLink;\n+import com.azure.core.util.logging.ClientLogger;\n+import org.apache.qpid.proton.message.Message;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+import reactor.core.Disposable;\n+import reactor.core.publisher.DirectProcessor;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Schedulers;\n+import reactor.test.StepVerifier;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+import static org.mockito.Mockito.when;\n+\n+public class ReceiveMessageAndExtendLockSample {\n+\n+    private static final String PAYLOAD = \"hello\";\n+    private static final byte[] PAYLOAD_BYTES = PAYLOAD.getBytes(UTF_8);\n+    private static final int PREFETCH = 1;\n+\n+    private final ClientLogger logger = new ClientLogger(MessageReceiverAsyncClient.class);\n+    private final String messageTrackingUUID = UUID.randomUUID().toString();\n+    private final DirectProcessor<Message> messageProcessor = DirectProcessor.create();\n+    private final DirectProcessor<Throwable> errorProcessor = DirectProcessor.create();\n+    private final DirectProcessor<AmqpEndpointState> endpointProcessor = DirectProcessor.create();\n+    private final DirectProcessor<AmqpShutdownSignal> shutdownProcessor = DirectProcessor.create();\n+\n+    @Mock\n+    private AmqpReceiveLink amqpReceiveLink;\n+\n+    @Captor\n+    private ArgumentCaptor<Supplier<Integer>> creditSupplier;\n+\n+    private Mono<AmqpReceiveLink> receiveLinkMono;\n+    private List<Message> messages = new ArrayList<>();\n+\n+    private ServiceBusReceiverAsyncClient consumer;\n+\n+\n+    @BeforeEach\n+    public void setup() {\n+        MockitoAnnotations.initMocks(this);\n+        receiveLinkMono = Mono.fromCallable(() -> amqpReceiveLink);\n+\n+        when(amqpReceiveLink.receive()).thenReturn(messageProcessor);\n+        //when(amqpReceiveLink.getErrors()).thenReturn(errorProcessor);\n+        //when(amqpReceiveLink.getConnectionStates()).thenReturn(endpointProcessor);\n+        //when(amqpReceiveLink.getShutdownSignals()).thenReturn(shutdownProcessor);\n+\n+        String connectionString = System.getenv(\"AZURE_SERVICEBUS_CONNECTION_STRING\")\n+            + \";EntityPath=hemant-test1\";\n+\n+        // Instantiate a client that will be used to call the service.\n+\n+        consumer = new ServiceBusClientBuilder()\n+            .connectionString(connectionString)\n+            .scheduler(Schedulers.elastic())\n+            .buildAsyncReceiverClient();\n+    }\n+\n+    @AfterEach\n+    public void teardown() {\n+        messages.clear();\n+        Mockito.framework().clearInlineMocks();\n+        consumer.close();\n+    }\n+\n+    @Test\n+    public void receiveAndExtendLockMessage() {\n+\n+        // Arrange\n+        final int numberOfEvents = 1;\n+\n+        // Act & Assert\n+        StepVerifier.create(\n+            consumer.receive()\n+                .take(numberOfEvents))\n+            .assertNext(receivedMessage -> {\n+                AtomicReference<Instant> timeToRefresh = new AtomicReference<>(receivedMessage.getLockedUntil());\n+                log(\" Got message time to refresh in \" + receivedMessage.getLockedUntil());\n+                Disposable renewDisposable = consumer.renewMessageLock(receivedMessage)\n+                    .repeat(() -> true)\n+                    .delayElements(Duration.ofSeconds(1))\n+                    .subscribe(instant -> {\n+                        log(\" New time instant:\" + instant);\n+                        timeToRefresh.set(instant);\n+                    });\n+\n+                // processing the messaging\n+                int count = 0;\n+                while (count < 15) {\n+                    ++count;\n+                    log(count + \". processing message \");\n+                    try {\n+                        Thread.sleep(1000);\n+                    } catch (Exception ignored) {\n+\n+                    }\n+                }\n+                log(\"processing done\");\n+                renewDisposable.dispose();\n+            }).verifyComplete();\n+    }\n+\n+    private void log(String message) {\n+        System.out.println(message);", "originalCommit": "10eef267af63b85187ff5a7f31becd7399914352", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "dada26a7f88755325967a3b29074d502fb934494", "url": "https://github.com/Azure/azure-sdk-for-java/commit/dada26a7f88755325967a3b29074d502fb934494", "message": "review comments", "committedDate": "2020-03-17T15:30:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzc3MjY0Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9159#discussion_r393772643", "bodyText": "This is a test. it should be in the test folder.", "author": "conniey", "createdAt": "2020-03-17T15:39:20Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/samples/java/com/azure/messaging/servicebus/ReceiveMessageAndExtendLockSample.java", "diffHunk": "@@ -0,0 +1,140 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.messaging.servicebus;\n+\n+import reactor.core.Disposable;\n+import reactor.core.scheduler.Schedulers;\n+import reactor.test.StepVerifier;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+public class ReceiveMessageAndExtendLockSample {\n+    private static final Duration OPERATION_TIMEOUT = Duration.ofSeconds(20);\n+\n+    /**\n+     * Main method to invoke this demo on how to send an {@link ServiceBusMessage} to an Azure Service Bus\n+     * Queue or Topic.\n+     *\n+     * @param args Unused arguments to the program.\n+     */\n+    public static void main1(String[] args) {\n+\n+        // Arrange\n+        final int numberOfEvents = 1;\n+\n+        // The connection string value can be obtained by:\n+        // 1. Going to your Service Bus namespace in Azure Portal.\n+        // 2. Creating an Queue instance.\n+        // 3. Creating a \"Shared access policy\" for your Queue instance.\n+        // 4. Copying the connection string from the policy's properties.\n+        String connectionString = \"<< CONNECTION STRING FOR THE SERVICE BUS QUEUE or TOPIC >>\";\n+        connectionString = \"Endpoint=sb://sbtrack2-hemanttest-prototype.servicebus.windows.net/;SharedAccessKeyName=manage;SharedAccessKey=T3wSc5Zp91BC1kw2bnLlNJYiBogrKRe+eBO0ST9ejCY=;EntityPath=hemant-test1\";\n+        ServiceBusReceiverAsyncClient consumer = new ServiceBusClientBuilder()\n+            .connectionString(connectionString)\n+            .scheduler(Schedulers.elastic())\n+            .buildAsyncReceiverClient();\n+\n+        // Act & Assert\n+        StepVerifier.create(", "originalCommit": "dada26a7f88755325967a3b29074d502fb934494", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b96c77338f5b956953f117a61cac14c539af35b1", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b96c77338f5b956953f117a61cac14c539af35b1", "message": "review comments", "committedDate": "2020-03-17T15:40:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzc3NDM2NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9159#discussion_r393774365", "bodyText": "Undo this reformat. The parameters are all mushed against the right margin. I have it set in intellij not to align it.", "author": "conniey", "createdAt": "2020-03-17T15:41:35Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ServiceBusAsyncConsumer.java", "diffHunk": "@@ -20,13 +21,15 @@\n     private final ServiceBusReceiveLinkProcessor amqpReceiveLinkProcessor;\n     private final MessageSerializer messageSerializer;\n     private final ServiceBusMessageProcessor processor;\n+    private final Scheduler scheduler;\n \n     public ServiceBusAsyncConsumer(ServiceBusReceiveLinkProcessor amqpReceiveLinkProcessor,\n-        MessageSerializer messageSerializer, boolean isAutoComplete,\n-        Function<ServiceBusReceivedMessage, Mono<Void>> onComplete,\n-        Function<ServiceBusReceivedMessage, Mono<Void>> onAbandon) {\n+                                   MessageSerializer messageSerializer, boolean isAutoComplete,", "originalCommit": "dada26a7f88755325967a3b29074d502fb934494", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "06b4a3c65ecf89538ac8cd81ff1dc7235eb6ea68", "url": "https://github.com/Azure/azure-sdk-for-java/commit/06b4a3c65ecf89538ac8cd81ff1dc7235eb6ea68", "message": "more review comments", "committedDate": "2020-03-17T16:07:46Z", "type": "commit"}, {"oid": "e6fde8ec5beaf56d04809d8429d3a1631f1d014a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/e6fde8ec5beaf56d04809d8429d3a1631f1d014a", "message": "Review comments", "committedDate": "2020-03-17T19:32:13Z", "type": "commit"}, {"oid": "4830fd35ab6a303b7ab26b0f014b30d7f06f07ea", "url": "https://github.com/Azure/azure-sdk-for-java/commit/4830fd35ab6a303b7ab26b0f014b30d7f06f07ea", "message": "Merge branch 'master' into servicebus-track2-userrenewlock-8746", "committedDate": "2020-03-17T20:01:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzkzNzE5OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9159#discussion_r393937198", "bodyText": "is this what they do in track 1? update the actual parameter object itself? Since we want to make ServicebusReceivedMessage immutable, id expect a clone to be created.", "author": "conniey", "createdAt": "2020-03-17T20:03:56Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClient.java", "diffHunk": "@@ -194,6 +194,46 @@ public String getServiceBusResourceName() {\n         return defer(message, null);\n     }\n \n+    /**\n+     * Asynchronously renews the lock on the message specified by the lock token. The lock will be renewed based on the\n+     * setting specified on the entity. When a message is received in {@link ReceiveMode#PEEK_LOCK} mode, the message is\n+     * locked on the server for this receiver instance for a duration as specified during the Queue creation\n+     * (LockDuration). If processing of the message requires longer than this duration, the lock needs to be renewed.\n+     * For each renewal, the lock is reset to the entity's LockDuration value.\n+     *\n+     * @param messageLock The {@link UUID} value of the message lock to renew.\n+     *\n+     * @return The {@link Mono} the finishes this operation on service bus resource.\n+     */\n+    public Mono<Instant> renewMessageLock(UUID messageLock) {\n+        return connectionProcessor\n+            .flatMap(connection -> connection.getManagementNode(entityPath, entityType))\n+            .flatMap(serviceBusManagementNode -> serviceBusManagementNode\n+                .renewMessageLock(messageLock));\n+    }\n+\n+    /**\n+     * Asynchronously renews the lock on the specified message. The lock will be renewed based on the\n+     * setting specified on the entity. When a message is received in {@link ReceiveMode#PEEK_LOCK} mode, the message is\n+     * locked on the server for this receiver instance for a duration as specified during the Queue creation\n+     * (LockDuration). If processing of the message requires longer than this duration, the lock needs to be renewed.\n+     * For each renewal, the lock is reset to the entity's LockDuration value.\n+     *\n+     * @param receivedMessage to be used to renew.\n+     *\n+     * @return The {@link Mono} the finishes this operation on service bus resource.\n+     */\n+    public Mono<Instant> renewMessageLock(ServiceBusReceivedMessage receivedMessage) {\n+        return connectionProcessor\n+            .flatMap(connection -> connection.getManagementNode(entityPath, entityType))\n+            .flatMap(serviceBusManagementNode -> serviceBusManagementNode\n+                .renewMessageLock(receivedMessage.getLockToken())\n+                .map(instant -> {\n+                    receivedMessage.setLockedUntil(instant);", "originalCommit": "e6fde8ec5beaf56d04809d8429d3a1631f1d014a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA4OTIzNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9159#discussion_r394089235", "bodyText": "Track 1: They update same object in this way.", "author": "hemanttanwar", "createdAt": "2020-03-18T03:34:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzkzNzE5OA=="}], "type": "inlineReview"}, {"oid": "059f3802b84bffc4c756eed823a429c7c1f0c900", "url": "https://github.com/Azure/azure-sdk-for-java/commit/059f3802b84bffc4c756eed823a429c7c1f0c900", "message": "changed the integration test based on review", "committedDate": "2020-03-18T03:17:41Z", "type": "commit"}, {"oid": "9d4ca5e2177adae5a2afc9586e235705b03982ac", "url": "https://github.com/Azure/azure-sdk-for-java/commit/9d4ca5e2177adae5a2afc9586e235705b03982ac", "message": "changed the integration test based on review", "committedDate": "2020-03-18T03:54:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ1MDQzNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9159#discussion_r394450437", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (expirationListObj instanceof  Date[]) {\n          \n          \n            \n                            if (expirationListObj instanceof Date[]) {", "author": "conniey", "createdAt": "2020-03-18T15:49:10Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageSerializer.java", "diffHunk": "@@ -184,12 +188,33 @@ public int getSize(Message amqpMessage) {\n     public <T> List<T> deserializeList(Message message, Class<T> clazz) {\n         if (clazz == ServiceBusReceivedMessage.class) {\n             return (List<T>) deserializeListOfMessages(message);\n+        } else if (clazz == Instant.class) {\n+            return (List<T>) deserializeListOfInstant(message);\n         } else {\n             throw logger.logExceptionAsError(new IllegalArgumentException(\n                 \"Deserialization only supports ServiceBusReceivedMessage.\"));\n         }\n     }\n \n+    private List<Instant> deserializeListOfInstant(Message amqpMessage) {\n+        List<Instant> listInstant = new ArrayList<>();\n+\n+        if (amqpMessage.getBody() instanceof AmqpValue) {\n+            AmqpValue amqpValue = ((AmqpValue) amqpMessage.getBody());\n+            if (amqpValue.getValue() instanceof  Map) {\n+                @SuppressWarnings(\"unchecked\")\n+                Map<String, Object> responseBody = (Map<String, Object>) amqpValue.getValue();\n+                Object expirationListObj = responseBody.get(REQUEST_RESPONSE_EXPIRATIONS);\n+\n+                if (expirationListObj instanceof  Date[]) {", "originalCommit": "9d4ca5e2177adae5a2afc9586e235705b03982ac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ1MTA2Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9159#discussion_r394451067", "bodyText": "You don't need this variable because you reassign it later anyways. Return a collections.emptylist in the other cases.", "author": "conniey", "createdAt": "2020-03-18T15:49:55Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/ServiceBusMessageSerializer.java", "diffHunk": "@@ -184,12 +188,33 @@ public int getSize(Message amqpMessage) {\n     public <T> List<T> deserializeList(Message message, Class<T> clazz) {\n         if (clazz == ServiceBusReceivedMessage.class) {\n             return (List<T>) deserializeListOfMessages(message);\n+        } else if (clazz == Instant.class) {\n+            return (List<T>) deserializeListOfInstant(message);\n         } else {\n             throw logger.logExceptionAsError(new IllegalArgumentException(\n                 \"Deserialization only supports ServiceBusReceivedMessage.\"));\n         }\n     }\n \n+    private List<Instant> deserializeListOfInstant(Message amqpMessage) {\n+        List<Instant> listInstant = new ArrayList<>();", "originalCommit": "9d4ca5e2177adae5a2afc9586e235705b03982ac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ1MjgxOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9159#discussion_r394452819", "bodyText": "Empty message? RE: \"\"", "author": "conniey", "createdAt": "2020-03-18T15:52:02Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ManagementChannel.java", "diffHunk": "@@ -202,6 +216,25 @@ private Message createDispositionMessage(UUID[] lockTokens, DispositionStatus di\n         return message;\n     }\n \n+    private Flux<Instant> renewMessageLock(UUID[] renewLockList) {\n+\n+        return  isAuthorized(PEEK_OPERATION_VALUE).thenMany(createRequestResponse.flatMap(channel -> {\n+\n+            Message requestMessage = createManagementMessage(RENEW_LOCK_OPERATION,\n+                channel.getReceiveLinkName());\n+\n+            requestMessage.setBody(new AmqpValue(Collections.singletonMap(LOCK_TOKENS, renewLockList)));\n+            return channel.sendWithAck(requestMessage);\n+        }).flatMapMany(responseMessage -> {\n+            int statusCode = RequestResponseUtils.getResponseStatusCode(responseMessage);\n+            if (statusCode !=  AmqpResponseCode.OK.getValue()) {\n+                return Mono.error(ExceptionUtil.amqpResponseCodeToException(statusCode, \"\", getErrorContext()));", "originalCommit": "9d4ca5e2177adae5a2afc9586e235705b03982ac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ1NDcwNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9159#discussion_r394454705", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param messageLock The {@link UUID} of the mesage {@link ServiceBusReceivedMessage} to be renewed.\n          \n          \n            \n                * @param messageLock The {@link UUID} of the {@link ServiceBusReceivedMessage} to be renewed.", "author": "conniey", "createdAt": "2020-03-18T15:54:21Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/main/java/com/azure/messaging/servicebus/implementation/ServiceBusManagementNode.java", "diffHunk": "@@ -51,6 +52,18 @@\n      */\n     Flux<ServiceBusReceivedMessage> peekBatch(int maxMessages);\n \n+    /**\n+     * Asynchronously renews the lock on the message specified by the lock token. The lock will be renewed based on\n+     * the setting specified on the entity. When a message is received in {@link ReceiveMode#PEEK_LOCK} mode,\n+     * the message is locked on the server for this receiver instance for a duration as specified during the\n+     * Queue/Subscription creation (LockDuration). If processing of the message requires longer than this duration,\n+     * the lock needs to be renewed. For each renewal, the lock is reset to the entity's LockDuration value.\n+     *\n+     * @param messageLock The {@link UUID} of the mesage {@link ServiceBusReceivedMessage} to be renewed.", "originalCommit": "9d4ca5e2177adae5a2afc9586e235705b03982ac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ1NTM3Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9159#discussion_r394455373", "bodyText": "This is never disposed of in @After", "author": "conniey", "createdAt": "2020-03-18T15:55:08Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClientIntegrationTest.java", "diffHunk": "@@ -30,6 +36,10 @@ protected void beforeTest() {\n         receiver = createBuilder()\n             .receiveMessageOptions(receiveMessageOptions)\n             .buildAsyncReceiverClient();\n+\n+        receiverManual = createBuilder()", "originalCommit": "9d4ca5e2177adae5a2afc9586e235705b03982ac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ1Njk3MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9159#discussion_r394456971", "bodyText": "Like I said, according to the spec this will never be null.", "author": "conniey", "createdAt": "2020-03-18T15:57:02Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClientIntegrationTest.java", "diffHunk": "@@ -131,4 +141,50 @@ void peekBatchMessagesFromSequence() {\n             .expectNextCount(maxMessages)\n             .verifyComplete();\n     }\n+\n+    /**\n+     * Verifies that we can renew message lock.\n+     */\n+    @Test\n+    void renewMessageLock() {\n+        // Arrange\n+        Duration renewAfterSeconds = Duration.ofSeconds(1);\n+        long takeTimeToProcessMessageMillis = 10000;\n+        final String contents = \"Some-contents\";\n+        final ServiceBusMessage message = TestUtils.getServiceBusMessage(contents, \"id-1\", 0);\n+\n+        AtomicReference<Integer> renewMessageLockCounter = new AtomicReference<>(0);\n+        // Assert & Act\n+        StepVerifier.create(sender.send(message).thenMany(receiverManual.receive()\n+            .take(1)\n+            .delayElements(renewAfterSeconds)\n+            .map(receivedMessage -> {\n+                //  keep renewing the lock whole you process the message.\n+                Disposable disposable = receiverManual.renewMessageLock(receivedMessage.getLockToken())\n+                    .repeat(() -> true)\n+                    .delayElements(renewAfterSeconds)\n+                    .doOnNext(instant -> {\n+                        // This will ensure that we are getting valid refresh time\n+                        if (instant != null) {\n+                            logger.info(\" Received new refresh time \" + instant);\n+                            renewMessageLockCounter.set(renewMessageLockCounter.get() + 1);\n+                        }\n+                    })\n+                    .subscribe();\n+\n+                // This just shows that user is taking time to process.\n+                // Real production code will not have sleep in it will have message processing code instead.\n+                try {\n+                    Thread.sleep(takeTimeToProcessMessageMillis);\n+                } catch (InterruptedException ignored) {\n+\n+                }\n+                disposable.dispose();\n+                return receivedMessage;\n+            })))\n+            .assertNext(Assertions::assertNotNull)", "originalCommit": "9d4ca5e2177adae5a2afc9586e235705b03982ac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ5MzkxMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9159#discussion_r394493913", "bodyText": "I know you added comments and it doesn't make it reactive nor does it use StepVerifier correctly.\n\nYou've only hooked up the doOnNext, which is used for side effects like logging, but you use it for validation. the first overload of subscribe is a better fit.\nWhat if the renewal fails? There is no handling of any error cases to fail the test\nWhat if the operation never emits a value because it was hung? You don't handle that case either.\n\nSince we are pressed for time, can you create an issue to write tests for this?", "author": "conniey", "createdAt": "2020-03-18T16:49:17Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClientIntegrationTest.java", "diffHunk": "@@ -131,4 +141,50 @@ void peekBatchMessagesFromSequence() {\n             .expectNextCount(maxMessages)\n             .verifyComplete();\n     }\n+\n+    /**\n+     * Verifies that we can renew message lock.\n+     */\n+    @Test\n+    void renewMessageLock() {\n+        // Arrange\n+        Duration renewAfterSeconds = Duration.ofSeconds(1);\n+        long takeTimeToProcessMessageMillis = 10000;\n+        final String contents = \"Some-contents\";\n+        final ServiceBusMessage message = TestUtils.getServiceBusMessage(contents, \"id-1\", 0);\n+\n+        AtomicReference<Integer> renewMessageLockCounter = new AtomicReference<>(0);\n+        // Assert & Act\n+        StepVerifier.create(sender.send(message).thenMany(receiverManual.receive()\n+            .take(1)\n+            .delayElements(renewAfterSeconds)\n+            .map(receivedMessage -> {\n+                //  keep renewing the lock whole you process the message.\n+                Disposable disposable = receiverManual.renewMessageLock(receivedMessage.getLockToken())", "originalCommit": "9d4ca5e2177adae5a2afc9586e235705b03982ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU2MzM0Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9159#discussion_r394563347", "bodyText": "#9193", "author": "hemanttanwar", "createdAt": "2020-03-18T18:41:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ5MzkxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ5NDc4Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/9159#discussion_r394494782", "bodyText": "You could have used. repeat() here.", "author": "conniey", "createdAt": "2020-03-18T16:50:32Z", "path": "sdk/servicebus/azure-messaging-servicebus/src/test/java/com/azure/messaging/servicebus/ServiceBusReceiverAsyncClientIntegrationTest.java", "diffHunk": "@@ -131,4 +141,50 @@ void peekBatchMessagesFromSequence() {\n             .expectNextCount(maxMessages)\n             .verifyComplete();\n     }\n+\n+    /**\n+     * Verifies that we can renew message lock.\n+     */\n+    @Test\n+    void renewMessageLock() {\n+        // Arrange\n+        Duration renewAfterSeconds = Duration.ofSeconds(1);\n+        long takeTimeToProcessMessageMillis = 10000;\n+        final String contents = \"Some-contents\";\n+        final ServiceBusMessage message = TestUtils.getServiceBusMessage(contents, \"id-1\", 0);\n+\n+        AtomicReference<Integer> renewMessageLockCounter = new AtomicReference<>(0);\n+        // Assert & Act\n+        StepVerifier.create(sender.send(message).thenMany(receiverManual.receive()\n+            .take(1)\n+            .delayElements(renewAfterSeconds)\n+            .map(receivedMessage -> {\n+                //  keep renewing the lock whole you process the message.\n+                Disposable disposable = receiverManual.renewMessageLock(receivedMessage.getLockToken())\n+                    .repeat(() -> true)", "originalCommit": "9d4ca5e2177adae5a2afc9586e235705b03982ac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "073806b6651a7d1e07d05e711f5474a09e31c9b0", "url": "https://github.com/Azure/azure-sdk-for-java/commit/073806b6651a7d1e07d05e711f5474a09e31c9b0", "message": "Review comments", "committedDate": "2020-03-18T18:41:17Z", "type": "commit"}]}