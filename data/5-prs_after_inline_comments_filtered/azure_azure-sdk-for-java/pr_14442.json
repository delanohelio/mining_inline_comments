{"pr_number": 14442, "pr_title": "Add convenience layer to generated code for Event Grid Track 2", "pr_createdAt": "2020-08-25T23:03:57Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/14442", "timeline": [{"oid": "ff8f42720c8c19945b20a40e2764630c23439925", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ff8f42720c8c19945b20a40e2764630c23439925", "message": "Regenerate SDK from Autorest v4\n\nAutorest regenerated using up to date version for track 2\npom file incorporated to jacoco and dependencies for module handled\nissue around capitalization of etag discrepancy fixed\nno test coverage yet", "committedDate": "2020-07-01T21:32:14Z", "type": "commit"}, {"oid": "12bf02a14a17935eedc451005cb9dfffb2b84de7", "url": "https://github.com/Azure/azure-sdk-for-java/commit/12bf02a14a17935eedc451005cb9dfffb2b84de7", "message": "Regenerate SDK from Autorest v4\n\nAutorest regenerated using up to date version for track 2\npom file incorporated to jacoco and dependencies for module handled\nissue around capitalization of etag discrepancy fixed\nno test coverage yet", "committedDate": "2020-07-01T21:32:22Z", "type": "commit"}, {"oid": "9327f4c135fd0f2ea65dc4609277ea142574518e", "url": "https://github.com/Azure/azure-sdk-for-java/commit/9327f4c135fd0f2ea65dc4609277ea142574518e", "message": "Merge branch 'master' of https://github.com/Azure/azure-sdk-for-java", "committedDate": "2020-08-25T20:13:25Z", "type": "commit"}, {"oid": "c24cc38c8562964e71b6e8e19ee9b590aeaf8899", "url": "https://github.com/Azure/azure-sdk-for-java/commit/c24cc38c8562964e71b6e8e19ee9b590aeaf8899", "message": "EventGrid Track 2 Autogenerated\n\nAutogenerate EventGrid track 2 classes using the swagger. All files except EventGridPublisherImplTests.java, pom.xml, and the swagger readme.md are autogenerated.", "committedDate": "2020-08-25T21:58:29Z", "type": "commit"}, {"oid": "51b59089a3618b0ad96e7922ccada6a7cd4cc4e7", "url": "https://github.com/Azure/azure-sdk-for-java/commit/51b59089a3618b0ad96e7922ccada6a7cd4cc4e7", "message": "EventGrid Track 2 written code\n\nConvenience layer for EventGrid Track 2 on top of autogenerated code.", "committedDate": "2020-08-25T22:35:51Z", "type": "commit"}, {"oid": "d76ebbe45d068751fe0ed87e3f63564350d3daae", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d76ebbe45d068751fe0ed87e3f63564350d3daae", "message": "Add Javadoc comments\n\nAdd a few missing javadoc comments and remove a few comments from private methods.", "committedDate": "2020-08-26T18:36:41Z", "type": "commit"}, {"oid": "153a22e9434562399a04cce1711dc58cf959ab4a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/153a22e9434562399a04cce1711dc58cf959ab4a", "message": "Merge in changes from autogenerated PR\n\ntest and pom edits mostly", "committedDate": "2020-08-27T16:46:56Z", "type": "commit"}, {"oid": "b247b8ef8fc275e39877d6594c89e9f157f8274c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b247b8ef8fc275e39877d6594c89e9f157f8274c", "message": "Fix tests\n\nRename methods and use StepVerifier instead of blocking", "committedDate": "2020-08-27T17:52:46Z", "type": "commit"}, {"oid": "ecb6fe259d7342a9728c70d20aa3c3b5bbdf7952", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ecb6fe259d7342a9728c70d20aa3c3b5bbdf7952", "message": "Add Changelog", "committedDate": "2020-08-27T18:37:46Z", "type": "commit"}, {"oid": "ecb6fe259d7342a9728c70d20aa3c3b5bbdf7952", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ecb6fe259d7342a9728c70d20aa3c3b5bbdf7952", "message": "Add Changelog", "committedDate": "2020-08-27T18:37:46Z", "type": "forcePushed"}, {"oid": "339867e438349062df35da8e933b890510f08e8d", "url": "https://github.com/Azure/azure-sdk-for-java/commit/339867e438349062df35da8e933b890510f08e8d", "message": "Rework CloudEvent serialization\n\nDrop explicit support for non-JSON data. Modify/fix tests slightly.", "committedDate": "2020-08-28T19:10:03Z", "type": "commit"}, {"oid": "3927dfb99bef27267138019ea16cd55350aed78f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3927dfb99bef27267138019ea16cd55350aed78f", "message": "Abbreviate SAS\n\nSharedAccessSignature -> SAS, refactor methods and classes", "committedDate": "2020-08-28T23:10:41Z", "type": "commit"}, {"oid": "b586b2b73a08d71661fdd813b66164653c5a35e2", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b586b2b73a08d71661fdd813b66164653c5a35e2", "message": "Small formatting changes", "committedDate": "2020-09-01T16:52:54Z", "type": "commit"}, {"oid": "177d8593ca8cda0c8b47c6355ca2805c8a7e5f6a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/177d8593ca8cda0c8b47c6355ca2805c8a7e5f6a", "message": "Pull autogenerated PR from master\n\nNow fewer files should be changed in this written pr", "committedDate": "2020-09-01T17:08:33Z", "type": "commit"}, {"oid": "0dbab7b4a47fd68183b3710aba9101a0a2ff50a9", "url": "https://github.com/Azure/azure-sdk-for-java/commit/0dbab7b4a47fd68183b3710aba9101a0a2ff50a9", "message": "Readme and changelog formatting issues\n\nMaven artifact not included since it hasn't published yet, some github links are broken since they point to folders that are included in this commit, however they should work once the changes are merged.", "committedDate": "2020-09-01T22:58:27Z", "type": "commit"}, {"oid": "1d5ef375e3442a5c8c1e0c8ed54b21410a6197a5", "url": "https://github.com/Azure/azure-sdk-for-java/commit/1d5ef375e3442a5c8c1e0c8ed54b21410a6197a5", "message": "Changed CustomEvent test\n\nconforms to live test expected custom event properties", "committedDate": "2020-09-03T23:40:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzgzODIwMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14442#discussion_r483838200", "bodyText": "We should consider adding async overloads for these since dataDeserializer supports async deserialization.", "author": "srnagar", "createdAt": "2020-09-04T20:49:13Z", "path": "sdk/eventgrid/azure-messaging-eventgrid/src/main/java/com/azure/messaging/eventgrid/EventGridEvent.java", "diffHunk": "@@ -0,0 +1,257 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License. See License.txt in the project root for\n+// license information.\n+//\n+// Code generated by Microsoft (R) AutoRest Code Generator.\n+\n+package com.azure.messaging.eventgrid;\n+\n+import com.azure.core.annotation.Fluent;\n+import com.azure.core.serializer.json.jackson.JacksonJsonSerializerBuilder;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.serializer.JacksonAdapter;\n+import com.azure.core.util.serializer.JsonSerializer;\n+import com.azure.core.util.serializer.TypeReference;\n+import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;\n+import reactor.core.publisher.Flux;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.time.OffsetDateTime;\n+import java.util.List;\n+import java.util.UUID;\n+\n+/**\n+ * The EventGridEvent model. This represents events in the EventGrid schema to be used with the EventGrid service.\n+ * @see EventGridPublisherAsyncClient\n+ * @see EventGridPublisherClient\n+ **/\n+@Fluent\n+public final class EventGridEvent {\n+\n+    private final com.azure.messaging.eventgrid.implementation.models.EventGridEvent event;\n+\n+    private boolean parsed = false;\n+\n+    private static final JsonSerializer deserializer = new JacksonJsonSerializerBuilder()\n+        .serializer(new JacksonAdapter().serializer() // this is a workaround to get the FlatteningDeserializer\n+            .registerModule(new JavaTimeModule())) // probably also change this to DateTimeDeserializer when/if it\n+        .build();                                  // becomes public in core\n+\n+    /**\n+     * Create a new instance of the EventGridEvent, with the given required fields.\n+     * @param subject     the subject of the event.\n+     * @param eventType   the type of the event, e.g. \"Contoso.Items.ItemReceived\".\n+     * @param dataVersion the version of the data sent along with the event.\n+     */\n+    public EventGridEvent(String subject, String eventType, String dataVersion) {\n+        if (CoreUtils.isNullOrEmpty(subject)) {\n+            throw new IllegalArgumentException(\"subject cannot be null or empty\");\n+        } else if (CoreUtils.isNullOrEmpty(eventType)) {\n+            throw new IllegalArgumentException(\"event type cannot be null or empty\");\n+        } else if (CoreUtils.isNullOrEmpty(dataVersion)) {\n+            throw new IllegalArgumentException(\"data version cannot be null or empty\");\n+        }\n+\n+        this.event = new com.azure.messaging.eventgrid.implementation.models.EventGridEvent()\n+            .setEventTime(OffsetDateTime.now())\n+            .setId(UUID.randomUUID().toString())\n+            .setSubject(subject)\n+            .setEventType(eventType)\n+            .setDataVersion(dataVersion);\n+    }\n+\n+    /**\n+     * Parse the EventGrid Event from a JSON string. This can be used to interpret the event at the event destination\n+     * from raw JSON into rich event(s).\n+     * @param json the JSON payload containing one or more events.\n+     *\n+     * @return all of the events in the payload parsed as CloudEvents.\n+     */\n+    public static List<EventGridEvent> parse(String json) {\n+        return Flux.fromArray(deserializer\n+            .deserialize(new ByteArrayInputStream(json.getBytes(StandardCharsets.UTF_8)),\n+                TypeReference.createInstance(com.azure.messaging.eventgrid.implementation.models.EventGridEvent[].class))\n+        )\n+            .map(event1 -> {\n+                if (event1.getData() == null) {\n+                    return new EventGridEvent(event1);\n+                }\n+                ByteArrayOutputStream stream = new ByteArrayOutputStream();\n+                deserializer.serialize(stream, event1.getData());\n+                return new EventGridEvent(event1).setData(stream.toByteArray()); // use BinaryData instead?\n+            })\n+            .collectList()\n+            .block();\n+    }\n+\n+\n+    /**\n+     * Get the unique id associated with this event.\n+     * @return the id.\n+     */\n+    public String getId() {\n+        return this.event.getId();\n+    }\n+\n+    /**\n+     * Set the unique id of the event. Note that a random id has already been set by default.\n+     * @param id the unique id to set.\n+     *\n+     * @return the event itself.\n+     */\n+    public EventGridEvent setId(String id) {\n+        if (CoreUtils.isNullOrEmpty(id)) {\n+            throw new IllegalArgumentException(\"id cannot be null or empty\");\n+        }\n+        this.event.setId(id);\n+        return this;\n+    }\n+\n+    /**\n+     * Get the topic associated with this event if it is associated with a domain.\n+     * @return the topic, or null if the topic is not set (i.e. the event came from or is going to a domain).\n+     */\n+    public String getTopic() {\n+        return this.event.getTopic();\n+    }\n+\n+    /**\n+     * Set the topic associated with this event. Used to route events from domain endpoints.\n+     * @param topic the topic to set.\n+     *\n+     * @return the event itself.\n+     */\n+    public EventGridEvent setTopic(String topic) {\n+        this.event.setTopic(topic);\n+        return this;\n+    }\n+\n+    /**\n+     * Get the subject associated with this event.\n+     * @return the subject.\n+     */\n+    public String getSubject() {\n+        return this.event.getSubject();\n+    }\n+\n+\n+    /**\n+     * Get the data associated with this event. For use in a parsed event only.\n+     * @return If the event was parsed from a Json, this method will return the rich\n+     * system event data if it is a system event, and a {@code byte[]} otherwise, such as in the case of custom event\n+     * data.\n+     * @throws IllegalStateException If the event was not created through {@link EventGridEvent#parse(String)}.\n+     */\n+    public Object getData() {\n+        if (!parsed) {\n+            // data was set instead of parsed, throw error\n+            throw new IllegalStateException(\"This method should only be called on events created through the parse method\");\n+        }\n+        String eventType = SystemEventMappings.canonicalizeEventType(event.getEventType());\n+        if (SystemEventMappings.getSystemEventMappings().containsKey(eventType)) {\n+            // system event\n+            return deserializer.deserialize(new ByteArrayInputStream((byte[]) this.event.getData()),\n+                TypeReference.createInstance(SystemEventMappings.getSystemEventMappings().get(eventType)));\n+        }\n+        return event.getData();\n+    }\n+\n+    /**\n+     * Get the deserialized data property from the parsed event. The behavior is undefined if this method is called\n+     * on an event that was not created through the parse method.\n+     * @param clazz the class of the type to deserialize the data into.\n+     * @param <T>   the type to deserialize the data into.\n+     *\n+     * @return the data deserialized into the given type using a default deserializer.\n+     */\n+    public <T> T getData(Class<T> clazz) {\n+        return getData(clazz, deserializer);\n+    }\n+\n+    /**\n+     * Get the deserialized data property from the parsed event.\n+     * @param clazz            the class of the type to deserialize the data into.\n+     * @param dataDeserializer the deserializer to use.\n+     * @param <T>              the type to deserialize the data into.\n+     *\n+     * @return the data deserialized into the given type using the given deserializer.\n+     * @throws IllegalStateException If the event was not created through {@link EventGridEvent#parse(String)}.\n+     */\n+    public <T> T getData(Class<T> clazz, JsonSerializer dataDeserializer) {\n+        if (!parsed) {\n+            // data was set instead of parsed, throw exception because we don't know how the data relates to clazz\n+            throw new IllegalStateException(\"This method should only be called on events created through the parse method\");\n+        }\n+\n+        return dataDeserializer.deserialize(new ByteArrayInputStream((byte[]) this.event.getData()),\n+            TypeReference.createInstance(clazz));\n+    }", "originalCommit": "1d5ef375e3442a5c8c1e0c8ed54b21410a6197a5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzgzOTE2NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14442#discussion_r483839165", "bodyText": "Instead of hardcoding the version here, the builder (since the builder should have a setter for service version) should pass this to the constructor and the client should use that as an instance variable that will be returned here.", "author": "srnagar", "createdAt": "2020-09-04T20:52:06Z", "path": "sdk/eventgrid/azure-messaging-eventgrid/src/main/java/com/azure/messaging/eventgrid/EventGridPublisherAsyncClient.java", "diffHunk": "@@ -0,0 +1,171 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License. See License.txt in the project root for\n+// license information.\n+\n+package com.azure.messaging.eventgrid;\n+\n+import com.azure.core.annotation.ReturnType;\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.annotation.ServiceMethod;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.http.rest.Response;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.serializer.SerializerAdapter;\n+import com.azure.messaging.eventgrid.implementation.EventGridPublisherClientImpl;\n+import com.azure.messaging.eventgrid.implementation.EventGridPublisherClientImplBuilder;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static com.azure.core.util.FluxUtil.withContext;\n+\n+/**\n+ * A service client that publishes events to an EventGrid topic or domain. Use {@link EventGridPublisherClientBuilder}\n+ * to create an instance of this client. This uses Project Reactor (https://projectreactor.io/) to handle asynchronous\n+ * programming.\n+ * @see EventGridEvent\n+ * @see CloudEvent\n+ */\n+@ServiceClient(builder = EventGridPublisherClientBuilder.class, isAsync = true)\n+public final class EventGridPublisherAsyncClient {\n+\n+    private final String hostname;\n+\n+    private final EventGridPublisherClientImpl impl;\n+\n+    EventGridPublisherAsyncClient(HttpPipeline pipeline, String hostname, SerializerAdapter serializerAdapter) {\n+        this.impl = new EventGridPublisherClientImplBuilder()\n+            .pipeline(pipeline)\n+            .serializerAdapter(serializerAdapter)\n+            .buildClient();\n+\n+        this.hostname = hostname;\n+    }\n+\n+    /**\n+     * Get the service version of the Rest API.\n+     * @return the Service version of the rest API\n+     */\n+    public EventGridServiceVersion getServiceVersion() {\n+        return EventGridServiceVersion.V2018_01_01;\n+    }", "originalCommit": "1d5ef375e3442a5c8c1e0c8ed54b21410a6197a5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzgzOTgzNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14442#discussion_r483839837", "bodyText": "Why is this called publish? It's better to use the same terminology even for non-public methods.", "author": "srnagar", "createdAt": "2020-09-04T20:54:08Z", "path": "sdk/eventgrid/azure-messaging-eventgrid/src/main/java/com/azure/messaging/eventgrid/EventGridPublisherAsyncClient.java", "diffHunk": "@@ -0,0 +1,171 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License. See License.txt in the project root for\n+// license information.\n+\n+package com.azure.messaging.eventgrid;\n+\n+import com.azure.core.annotation.ReturnType;\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.annotation.ServiceMethod;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.http.rest.Response;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.serializer.SerializerAdapter;\n+import com.azure.messaging.eventgrid.implementation.EventGridPublisherClientImpl;\n+import com.azure.messaging.eventgrid.implementation.EventGridPublisherClientImplBuilder;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static com.azure.core.util.FluxUtil.withContext;\n+\n+/**\n+ * A service client that publishes events to an EventGrid topic or domain. Use {@link EventGridPublisherClientBuilder}\n+ * to create an instance of this client. This uses Project Reactor (https://projectreactor.io/) to handle asynchronous\n+ * programming.\n+ * @see EventGridEvent\n+ * @see CloudEvent\n+ */\n+@ServiceClient(builder = EventGridPublisherClientBuilder.class, isAsync = true)\n+public final class EventGridPublisherAsyncClient {\n+\n+    private final String hostname;\n+\n+    private final EventGridPublisherClientImpl impl;\n+\n+    EventGridPublisherAsyncClient(HttpPipeline pipeline, String hostname, SerializerAdapter serializerAdapter) {\n+        this.impl = new EventGridPublisherClientImplBuilder()\n+            .pipeline(pipeline)\n+            .serializerAdapter(serializerAdapter)\n+            .buildClient();\n+\n+        this.hostname = hostname;\n+    }\n+\n+    /**\n+     * Get the service version of the Rest API.\n+     * @return the Service version of the rest API\n+     */\n+    public EventGridServiceVersion getServiceVersion() {\n+        return EventGridServiceVersion.V2018_01_01;\n+    }\n+\n+    /**\n+     * Publishes the given EventGrid events to the set topic or domain.\n+     * @param events the EventGrid events to publish.\n+     *\n+     * @return the completion.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public Mono<Void> sendEvents(Iterable<EventGridEvent> events) {\n+        return withContext(context -> publishEvents(events, context));\n+    }\n+\n+    Mono<Void> publishEvents(Iterable<EventGridEvent> events, Context context) {", "originalCommit": "1d5ef375e3442a5c8c1e0c8ed54b21410a6197a5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg0MDM3Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14442#discussion_r483840377", "bodyText": "Converting to inner types should happen lazily when the Mono is subscribed. Do the same at other places too where the list operations are performed eagerly.", "author": "srnagar", "createdAt": "2020-09-04T20:55:39Z", "path": "sdk/eventgrid/azure-messaging-eventgrid/src/main/java/com/azure/messaging/eventgrid/EventGridPublisherAsyncClient.java", "diffHunk": "@@ -0,0 +1,171 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License. See License.txt in the project root for\n+// license information.\n+\n+package com.azure.messaging.eventgrid;\n+\n+import com.azure.core.annotation.ReturnType;\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.annotation.ServiceMethod;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.http.rest.Response;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.serializer.SerializerAdapter;\n+import com.azure.messaging.eventgrid.implementation.EventGridPublisherClientImpl;\n+import com.azure.messaging.eventgrid.implementation.EventGridPublisherClientImplBuilder;\n+import reactor.core.publisher.Mono;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static com.azure.core.util.FluxUtil.withContext;\n+\n+/**\n+ * A service client that publishes events to an EventGrid topic or domain. Use {@link EventGridPublisherClientBuilder}\n+ * to create an instance of this client. This uses Project Reactor (https://projectreactor.io/) to handle asynchronous\n+ * programming.\n+ * @see EventGridEvent\n+ * @see CloudEvent\n+ */\n+@ServiceClient(builder = EventGridPublisherClientBuilder.class, isAsync = true)\n+public final class EventGridPublisherAsyncClient {\n+\n+    private final String hostname;\n+\n+    private final EventGridPublisherClientImpl impl;\n+\n+    EventGridPublisherAsyncClient(HttpPipeline pipeline, String hostname, SerializerAdapter serializerAdapter) {\n+        this.impl = new EventGridPublisherClientImplBuilder()\n+            .pipeline(pipeline)\n+            .serializerAdapter(serializerAdapter)\n+            .buildClient();\n+\n+        this.hostname = hostname;\n+    }\n+\n+    /**\n+     * Get the service version of the Rest API.\n+     * @return the Service version of the rest API\n+     */\n+    public EventGridServiceVersion getServiceVersion() {\n+        return EventGridServiceVersion.V2018_01_01;\n+    }\n+\n+    /**\n+     * Publishes the given EventGrid events to the set topic or domain.\n+     * @param events the EventGrid events to publish.\n+     *\n+     * @return the completion.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public Mono<Void> sendEvents(Iterable<EventGridEvent> events) {\n+        return withContext(context -> publishEvents(events, context));\n+    }\n+\n+    Mono<Void> publishEvents(Iterable<EventGridEvent> events, Context context) {\n+        List<com.azure.messaging.eventgrid.implementation.models.EventGridEvent> implList = new ArrayList<>();\n+        for (EventGridEvent event : events) {\n+            implList.add(event.toImpl());\n+        }\n+        return impl.publishEventsAsync(hostname, implList, context);\n+    }\n+\n+    /**\n+     * Publishes the given cloud events to the set topic or domain.\n+     * @param events the cloud events to publish.\n+     *\n+     * @return the completion.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public Mono<Void> sendCloudEvents(Iterable<CloudEvent> events) {\n+        return withContext(context -> publishCloudEvents(events, context));\n+    }\n+\n+    Mono<Void> publishCloudEvents(Iterable<CloudEvent> events, Context context) {\n+        List<com.azure.messaging.eventgrid.implementation.models.CloudEvent> implList = new ArrayList<>();\n+        for (CloudEvent event : events) {\n+            implList.add(event.toImpl());\n+        }", "originalCommit": "1d5ef375e3442a5c8c1e0c8ed54b21410a6197a5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg0MTI0MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14442#discussion_r483841241", "bodyText": "Builder should not have @Fluent annotation.", "author": "srnagar", "createdAt": "2020-09-04T20:58:20Z", "path": "sdk/eventgrid/azure-messaging-eventgrid/src/main/java/com/azure/messaging/eventgrid/EventGridPublisherClientBuilder.java", "diffHunk": "@@ -0,0 +1,273 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License. See License.txt in the project root for\n+// license information.\n+\n+package com.azure.messaging.eventgrid;\n+\n+import com.azure.core.annotation.Fluent;\n+import com.azure.core.annotation.ServiceClientBuilder;\n+import com.azure.core.credential.AzureKeyCredential;\n+import com.azure.core.http.*;\n+import com.azure.core.http.policy.*;\n+import com.azure.core.util.Configuration;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.core.util.serializer.JacksonAdapter;\n+import com.azure.core.util.serializer.SerializerAdapter;\n+\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * A Builder class to create service clients that can publish events to EventGrid.\n+ * @see EventGridPublisherAsyncClient\n+ * @see EventGridEvent\n+ * @see CloudEvent\n+ */\n+@ServiceClientBuilder(serviceClients = {EventGridPublisherClient.class, EventGridPublisherAsyncClient.class})\n+@Fluent", "originalCommit": "1d5ef375e3442a5c8c1e0c8ed54b21410a6197a5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg0MTg3NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14442#discussion_r483841875", "bodyText": "The method should be named credential to be consistent with other SDK builders.", "author": "srnagar", "createdAt": "2020-09-04T21:00:06Z", "path": "sdk/eventgrid/azure-messaging-eventgrid/src/main/java/com/azure/messaging/eventgrid/EventGridPublisherClientBuilder.java", "diffHunk": "@@ -0,0 +1,273 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License. See License.txt in the project root for\n+// license information.\n+\n+package com.azure.messaging.eventgrid;\n+\n+import com.azure.core.annotation.Fluent;\n+import com.azure.core.annotation.ServiceClientBuilder;\n+import com.azure.core.credential.AzureKeyCredential;\n+import com.azure.core.http.*;\n+import com.azure.core.http.policy.*;\n+import com.azure.core.util.Configuration;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.core.util.serializer.JacksonAdapter;\n+import com.azure.core.util.serializer.SerializerAdapter;\n+\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * A Builder class to create service clients that can publish events to EventGrid.\n+ * @see EventGridPublisherAsyncClient\n+ * @see EventGridEvent\n+ * @see CloudEvent\n+ */\n+@ServiceClientBuilder(serviceClients = {EventGridPublisherClient.class, EventGridPublisherAsyncClient.class})\n+@Fluent\n+public final class EventGridPublisherClientBuilder {\n+\n+    private static final String AEG_SAS_KEY = \"aeg-sas-key\";\n+\n+    private static final String AEG_SAS_TOKEN = \"aeg-sas-token\";\n+\n+    private static final String EVENTGRID_PROPERTIES = \"azure-messaging-eventgrid.properties\";\n+    private static final String NAME = \"name\";\n+    private static final String VERSION = \"version\";\n+\n+    private final String clientName;\n+\n+    private final String clientVersion;\n+\n+    private final ClientLogger logger = new ClientLogger(EventGridPublisherClientBuilder.class);\n+\n+    private final List<HttpPipelinePolicy> policies = new ArrayList<>();\n+\n+    private Configuration configuration;\n+\n+    private AzureKeyCredential keyCredential;\n+\n+    private EventGridSasCredential sasToken;\n+\n+    private String endpoint;\n+\n+    private HttpClient httpClient;\n+\n+    private HttpLogOptions httpLogOptions;\n+\n+    private HttpPipeline httpPipeline;\n+\n+    private RetryPolicy retryPolicy;\n+\n+    private SerializerAdapter serializer;\n+\n+    /**\n+     * Construct a new instance with default building settings. The endpoint and one credential method must be set\n+     * in order for the client to be built.\n+     */\n+    public EventGridPublisherClientBuilder() {\n+        this.httpLogOptions = new HttpLogOptions();\n+        Map<String, String> properties = CoreUtils.getProperties(EVENTGRID_PROPERTIES);\n+        clientName = properties.getOrDefault(NAME, \"UnknownName\");\n+        clientVersion = properties.getOrDefault(VERSION, \"UnknownVersion\");\n+    }\n+\n+\n+    /**\n+     * Build a publisher client with asynchronous publishing methods and the current settings. An endpoint must be set,\n+     * and either a pipeline with correct authentication must be set, or a credential must be set in the form of\n+     * an {@link EventGridSasCredential} or a {@link AzureKeyCredential} at the respective methods.\n+     * All other settings have defaults and are optional.\n+     * @return a publisher client with asynchronous publishing methods.\n+     */\n+    public EventGridPublisherAsyncClient buildAsyncClient() {\n+        String hostname;\n+        try {\n+            hostname = new URL(Objects.requireNonNull(endpoint, \"endpoint cannot be null\")).getHost();\n+        } catch (MalformedURLException e) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\"Cannot parse endpoint\"));\n+        }\n+\n+        SerializerAdapter buildSerializer = serializer == null ?\n+            JacksonAdapter.createDefaultSerializerAdapter() :\n+            serializer;\n+\n+        if (httpPipeline != null) {\n+            return new EventGridPublisherAsyncClient(httpPipeline, hostname, buildSerializer);\n+        }\n+\n+        Configuration buildConfiguration = (configuration == null)\n+            ? Configuration.getGlobalConfiguration()\n+            : configuration;\n+\n+        // Closest to API goes first, closest to wire goes last.\n+        final List<HttpPipelinePolicy> httpPipelinePolicies = new ArrayList<>();\n+\n+        httpPipelinePolicies.add(new UserAgentPolicy(httpLogOptions.getApplicationId(), clientName, clientVersion,\n+            buildConfiguration));\n+        httpPipelinePolicies.add(new RequestIdPolicy());\n+\n+        HttpPolicyProviders.addBeforeRetryPolicies(httpPipelinePolicies);\n+        httpPipelinePolicies.add(retryPolicy == null ? new RetryPolicy() : retryPolicy);\n+\n+        httpPipelinePolicies.add(new AddDatePolicy());\n+\n+        // Using token before key if both are set\n+        if (sasToken != null) {\n+            httpPipelinePolicies.add((context, next) -> {\n+                context.getHttpRequest().getHeaders().put(AEG_SAS_TOKEN, sasToken.getSas());\n+                return next.process();\n+            });\n+        } else {\n+            httpPipelinePolicies.add(new AzureKeyCredentialPolicy(AEG_SAS_KEY, keyCredential));\n+        }\n+\n+        httpPipelinePolicies.addAll(policies);\n+\n+        HttpPolicyProviders.addAfterRetryPolicies(httpPipelinePolicies);\n+\n+        httpPipelinePolicies.add(new HttpLoggingPolicy(httpLogOptions));\n+\n+        HttpPipeline buildPipeline = new HttpPipelineBuilder()\n+            .httpClient(httpClient)\n+            .policies(httpPipelinePolicies.toArray(new HttpPipelinePolicy[0]))\n+            .build();\n+\n+\n+        return new EventGridPublisherAsyncClient(buildPipeline, hostname, buildSerializer);\n+    }\n+\n+    /**\n+     * Build a publisher client with synchronous publishing methods and the current settings. Endpoint and a credential\n+     * must be set (either keyCredential or sharedAccessSignatureCredential), all other settings have defaults and/or are optional.\n+     * Note that currently the asynchronous client created by the method above is the recommended version for higher\n+     * performance, as the synchronous client simply blocks on the same asynchronous calls.\n+     * @return a publisher client with synchronous publishing methods.\n+     */\n+    public EventGridPublisherClient buildClient() {\n+        return new EventGridPublisherClient(buildAsyncClient());\n+    }\n+\n+    /**\n+     * Add a policy to the current pipeline.\n+     * @param httpPipelinePolicy the policy to add.\n+     *\n+     * @return the builder itself.\n+     */\n+    public EventGridPublisherClientBuilder addPolicy(HttpPipelinePolicy httpPipelinePolicy) {\n+        this.policies.add(Objects.requireNonNull(httpPipelinePolicy));\n+        return this;\n+    }\n+\n+    /**\n+     * Add a custom retry policy to the pipeline. The default is {@link RetryPolicy#RetryPolicy()}\n+     * @param retryPolicy the retry policy to add.\n+     *\n+     * @return the builder itself.\n+     */\n+    public EventGridPublisherClientBuilder retryPolicy(RetryPolicy retryPolicy) {\n+        this.retryPolicy = retryPolicy;\n+        return this;\n+    }\n+\n+    /**\n+     * Set the configuration of HTTP and Azure values. A default is already set.\n+     * @param configuration the configuration to use.\n+     *\n+     * @return the builder itself.\n+     */\n+    public EventGridPublisherClientBuilder configuration(Configuration configuration) {\n+        this.configuration = configuration;\n+        return this;\n+    }\n+\n+    /**\n+     * Set the domain or topic authentication using a key obtained from Azure CLI, Azure portal, or the ARM SDKs.\n+     * @param credential the key credential to use to authorize the publisher client.\n+     *\n+     * @return the builder itself.\n+     */\n+    public EventGridPublisherClientBuilder keyCredential(AzureKeyCredential credential) {", "originalCommit": "1d5ef375e3442a5c8c1e0c8ed54b21410a6197a5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg0MjI2NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14442#discussion_r483842265", "bodyText": "Use logs instead of e.printStackTrace().", "author": "srnagar", "createdAt": "2020-09-04T21:01:13Z", "path": "sdk/eventgrid/azure-messaging-eventgrid/src/main/java/com/azure/messaging/eventgrid/EventGridSasCredential.java", "diffHunk": "@@ -0,0 +1,98 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License. See License.txt in the project root for\n+// license information.\n+\n+package com.azure.messaging.eventgrid;\n+\n+import com.azure.core.credential.AzureKeyCredential;\n+import com.azure.core.util.CoreUtils;\n+\n+import javax.crypto.Mac;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.time.OffsetDateTime;\n+import java.time.ZoneOffset;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Base64;\n+\n+/**\n+ * A way to use a generated shared access signature as a credential to publish events to a topic through a client.\n+ */\n+public final class EventGridSasCredential {\n+\n+    private String sas;\n+\n+    /**\n+     * Generate a shared access signature to provide time-limited authentication for requests to the Event Grid\n+     * service.\n+     * @param endpoint       the endpoint of the Event Grid topic or domain.\n+     * @param expirationTime the time in which the signature should expire, no longer providing authentication.\n+     * @param keyCredential  the access key obtained from the Event Grid topic or domain.\n+     *\n+     * @return the shared access signature string which can be used to construct an instance of\n+     * {@link EventGridSasCredential}.\n+     */\n+    public static String createSas(String endpoint, OffsetDateTime expirationTime,\n+                                   AzureKeyCredential keyCredential) {\n+        try {\n+            String resKey = \"r\";\n+            String expKey = \"e\";\n+            String signKey = \"s\";\n+\n+            Charset charset = StandardCharsets.UTF_8;\n+            String encodedResource = URLEncoder.encode(endpoint, charset.name());\n+            String encodedExpiration = URLEncoder.encode(expirationTime.atZoneSameInstant(ZoneOffset.UTC).format(\n+                DateTimeFormatter.ofPattern(\"M/d/yyyy h:m:s a\")),\n+                charset.name());\n+\n+            String unsignedSas = String.format(\"%s=%s&%s=%s\", resKey, encodedResource, expKey, encodedExpiration);\n+\n+            Mac hmac = Mac.getInstance(\"hmacSHA256\");\n+            hmac.init(new SecretKeySpec(Base64.getDecoder().decode(keyCredential.getKey()), \"hmacSHA256\"));\n+            String signature = new String(Base64.getEncoder().encode(\n+                hmac.doFinal(unsignedSas.getBytes(charset))),\n+                charset);\n+\n+            String encodedSignature = URLEncoder.encode(signature, charset.name());\n+\n+            return String.format(\"%s&%s=%s\", unsignedSas, signKey, encodedSignature);\n+\n+        } catch (NoSuchAlgorithmException | UnsupportedEncodingException | InvalidKeyException e) {\n+            e.printStackTrace();", "originalCommit": "1d5ef375e3442a5c8c1e0c8ed54b21410a6197a5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg0MjMzNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14442#discussion_r483842337", "bodyText": "Log and throw.", "author": "srnagar", "createdAt": "2020-09-04T21:01:29Z", "path": "sdk/eventgrid/azure-messaging-eventgrid/src/main/java/com/azure/messaging/eventgrid/EventGridSasCredential.java", "diffHunk": "@@ -0,0 +1,98 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License. See License.txt in the project root for\n+// license information.\n+\n+package com.azure.messaging.eventgrid;\n+\n+import com.azure.core.credential.AzureKeyCredential;\n+import com.azure.core.util.CoreUtils;\n+\n+import javax.crypto.Mac;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.time.OffsetDateTime;\n+import java.time.ZoneOffset;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Base64;\n+\n+/**\n+ * A way to use a generated shared access signature as a credential to publish events to a topic through a client.\n+ */\n+public final class EventGridSasCredential {\n+\n+    private String sas;\n+\n+    /**\n+     * Generate a shared access signature to provide time-limited authentication for requests to the Event Grid\n+     * service.\n+     * @param endpoint       the endpoint of the Event Grid topic or domain.\n+     * @param expirationTime the time in which the signature should expire, no longer providing authentication.\n+     * @param keyCredential  the access key obtained from the Event Grid topic or domain.\n+     *\n+     * @return the shared access signature string which can be used to construct an instance of\n+     * {@link EventGridSasCredential}.\n+     */\n+    public static String createSas(String endpoint, OffsetDateTime expirationTime,\n+                                   AzureKeyCredential keyCredential) {\n+        try {\n+            String resKey = \"r\";\n+            String expKey = \"e\";\n+            String signKey = \"s\";\n+\n+            Charset charset = StandardCharsets.UTF_8;\n+            String encodedResource = URLEncoder.encode(endpoint, charset.name());\n+            String encodedExpiration = URLEncoder.encode(expirationTime.atZoneSameInstant(ZoneOffset.UTC).format(\n+                DateTimeFormatter.ofPattern(\"M/d/yyyy h:m:s a\")),\n+                charset.name());\n+\n+            String unsignedSas = String.format(\"%s=%s&%s=%s\", resKey, encodedResource, expKey, encodedExpiration);\n+\n+            Mac hmac = Mac.getInstance(\"hmacSHA256\");\n+            hmac.init(new SecretKeySpec(Base64.getDecoder().decode(keyCredential.getKey()), \"hmacSHA256\"));\n+            String signature = new String(Base64.getEncoder().encode(\n+                hmac.doFinal(unsignedSas.getBytes(charset))),\n+                charset);\n+\n+            String encodedSignature = URLEncoder.encode(signature, charset.name());\n+\n+            return String.format(\"%s&%s=%s\", unsignedSas, signKey, encodedSignature);\n+\n+        } catch (NoSuchAlgorithmException | UnsupportedEncodingException | InvalidKeyException e) {\n+            e.printStackTrace();\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Create an instance of this object to authenticate calls to the EventGrid service.\n+     * @param sas the shared access signature to use.\n+     */\n+    public EventGridSasCredential(String sas) {\n+        if (CoreUtils.isNullOrEmpty(sas)) {\n+            throw new IllegalArgumentException(\"the access signature cannot be null or empty\");", "originalCommit": "1d5ef375e3442a5c8c1e0c8ed54b21410a6197a5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg0MjU3OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14442#discussion_r483842578", "bodyText": "Missing javadoc.", "author": "srnagar", "createdAt": "2020-09-04T21:02:15Z", "path": "sdk/eventgrid/azure-messaging-eventgrid/src/main/java/com/azure/messaging/eventgrid/SystemEventMappings.java", "diffHunk": "@@ -0,0 +1,382 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License. See License.txt in the project root for\n+// license information.\n+\n+package com.azure.messaging.eventgrid;\n+\n+import com.azure.messaging.eventgrid.systemevents.*;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+\n+public final class SystemEventMappings {", "originalCommit": "1d5ef375e3442a5c8c1e0c8ed54b21410a6197a5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg0Mjg0Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14442#discussion_r483842843", "bodyText": "Add javadocs for all samples to explain what the sample does.", "author": "srnagar", "createdAt": "2020-09-04T21:03:02Z", "path": "sdk/eventgrid/azure-messaging-eventgrid/src/samples/java/com/azure/messaging/eventgrid/ClassTime.java", "diffHunk": "@@ -0,0 +1,55 @@\n+package com.azure.messaging.eventgrid;\n+\n+import java.time.LocalDate;\n+import java.time.LocalTime;\n+import java.time.OffsetDateTime;\n+import java.time.ZoneOffset;\n+import java.util.Random;\n+\n+public class ClassTime {", "originalCommit": "1d5ef375e3442a5c8c1e0c8ed54b21410a6197a5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg2NzQ5Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14442#discussion_r483867496", "bodyText": "Generally I think we try to avoid * imports, I know I had to go dive into IntelliJ settings to make it stop doing this by default:\nSettings > Editor > Code Style > Java > set both count to use import with '*' settings to 99.", "author": "bsiegel", "createdAt": "2020-09-04T22:25:22Z", "path": "sdk/eventgrid/azure-messaging-eventgrid/src/main/java/com/azure/messaging/eventgrid/CloudEvent.java", "diffHunk": "@@ -0,0 +1,325 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License. See License.txt in the project root for\n+// license information.\n+//\n+// Code generated by Microsoft (R) AutoRest Code Generator.\n+\n+package com.azure.messaging.eventgrid;\n+\n+import com.azure.core.annotation.Fluent;\n+import com.azure.core.serializer.json.jackson.JacksonJsonSerializerBuilder;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.serializer.*;", "originalCommit": "1d5ef375e3442a5c8c1e0c8ed54b21410a6197a5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg2ODAxOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14442#discussion_r483868018", "bodyText": "I think Srikanta already called this out, but instead of throwing directly, we should get a ClientLogger instance and call throw logger.logExceptionAsWarning/Error(...) instead.", "author": "bsiegel", "createdAt": "2020-09-04T22:27:43Z", "path": "sdk/eventgrid/azure-messaging-eventgrid/src/main/java/com/azure/messaging/eventgrid/CloudEvent.java", "diffHunk": "@@ -0,0 +1,325 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License. See License.txt in the project root for\n+// license information.\n+//\n+// Code generated by Microsoft (R) AutoRest Code Generator.\n+\n+package com.azure.messaging.eventgrid;\n+\n+import com.azure.core.annotation.Fluent;\n+import com.azure.core.serializer.json.jackson.JacksonJsonSerializerBuilder;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.serializer.*;\n+import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;\n+import reactor.core.publisher.Flux;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.time.OffsetDateTime;\n+import java.util.*;\n+\n+/**\n+ * The CloudEvent model. This represents a cloud event as specified by the CNCF, for sending event based data.\n+ * @see EventGridPublisherAsyncClient\n+ * @see EventGridPublisherClient\n+ **/\n+@Fluent\n+public final class CloudEvent {\n+\n+    private static final String SPEC_VERSION = \"1.0\";\n+\n+    private final com.azure.messaging.eventgrid.implementation.models.CloudEvent cloudEvent;\n+\n+    private boolean parsed = false;\n+\n+    private static final JsonSerializer deserializer = new JacksonJsonSerializerBuilder()\n+        .serializer(new JacksonAdapter().serializer() // this is a workaround to get the FlatteningDeserializer\n+            .registerModule(new JavaTimeModule())) // probably also change this to DateTimeDeserializer when/if it\n+        .build();                                  // becomes public in core\n+\n+    /**\n+     * Create an instance of a CloudEvent. The source and type are required fields to publish.\n+     * @param source a URI identifying the origin of the event.\n+     * @param type   the type of event, e.g. \"Contoso.Items.ItemReceived\".\n+     */\n+    public CloudEvent(String source, String type) {\n+        if (CoreUtils.isNullOrEmpty(source)) {\n+            throw new IllegalArgumentException(\"Source cannot be null or empty\");\n+        } else if (CoreUtils.isNullOrEmpty(type)) {\n+            throw new IllegalArgumentException(\"type cannot be null or empty\");\n+        }\n+\n+        this.cloudEvent = new com.azure.messaging.eventgrid.implementation.models.CloudEvent()\n+            .setId(UUID.randomUUID().toString())\n+            .setSource(source)\n+            .setType(type)\n+            .setSpecversion(SPEC_VERSION);\n+    }\n+\n+    /**\n+     * Parse the Cloud Event from a JSON string. This can be used to interpret the event at the event destination\n+     * from raw JSON into rich event(s).\n+     * @param json the JSON payload containing one or more events.\n+     *\n+     * @return all of the events in the payload parsed as CloudEvents.\n+     */\n+    public static List<CloudEvent> parse(String json) {\n+        return Flux.fromArray(deserializer\n+            .deserialize(new ByteArrayInputStream(json.getBytes(StandardCharsets.UTF_8)),\n+                TypeReference.createInstance(com.azure.messaging.eventgrid.implementation.models.CloudEvent[].class))\n+        )\n+            .map(event1 -> {\n+                if (event1.getData() != null) {\n+                    ByteArrayOutputStream stream = new ByteArrayOutputStream();\n+                    deserializer.serialize(stream, event1.getData());\n+                    return new CloudEvent(event1).setData(stream.toByteArray()); // use BinaryData instead?\n+                } else { // both null, don't set data and keep null\n+                    return new CloudEvent(event1);\n+                }\n+            })\n+            .collectList()\n+            .block();\n+    }\n+\n+    /**\n+     * Get the id of the cloud event.\n+     * @return the id.\n+     */\n+    public String getId() {\n+        return this.cloudEvent.getId();\n+    }\n+\n+    /**\n+     * Set a custom id. Note that a random id is already set by default.\n+     * @param id the id to set.\n+     *\n+     * @return the cloud event itself.\n+     */\n+    public CloudEvent setId(String id) {\n+        if (CoreUtils.isNullOrEmpty(id)) {\n+            throw new IllegalArgumentException(\"id cannot be null or empty\");\n+        }\n+        this.cloudEvent.setId(id);\n+        return this;\n+    }\n+\n+    /**\n+     * Get the URI source of the event.\n+     * @return the source.\n+     */\n+    public String getSource() {\n+        return this.cloudEvent.getSource();\n+    }\n+\n+    /**\n+     * Get the data associated with this event. For use in a parsed event only.\n+     * @return If the event was parsed from a Json, this method will return the rich\n+     * system event data if it is a system event, and a {@code byte[]} otherwise, such as in the case of custom event\n+     * data, including data set through {@link CloudEvent#setData(byte[], String)}.\n+     * @throws IllegalStateException If the event was not created through {@link EventGridEvent#parse(String)}.\n+     */\n+    public Object getData() {\n+        if (!parsed) {\n+            // data was set instead of parsed, throw error\n+            throw new IllegalStateException(\"This method should only be called on events created through the parse method\");", "originalCommit": "1d5ef375e3442a5c8c1e0c8ed54b21410a6197a5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg2OTIwMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14442#discussion_r483869200", "bodyText": "Make sure all source files have the copyright & license header.", "author": "bsiegel", "createdAt": "2020-09-04T22:33:23Z", "path": "sdk/eventgrid/azure-messaging-eventgrid/src/samples/java/com/azure/messaging/eventgrid/ClassTime.java", "diffHunk": "@@ -0,0 +1,55 @@\n+package com.azure.messaging.eventgrid;", "originalCommit": "1d5ef375e3442a5c8c1e0c8ed54b21410a6197a5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f5ae4ad3b07604409b24f75f2dfc1bfd5d9ec8e3", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f5ae4ad3b07604409b24f75f2dfc1bfd5d9ec8e3", "message": "Address review comments\n\nVariety of changes, major ones include:\n- Async methods on generic getData\n- Lazy list creation for send methods\n- Credential methods both renamed to `credential`\n- Logging errors instead of throwing\n- Additional missing javadoc comments", "committedDate": "2020-09-04T23:03:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg3NzY1MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14442#discussion_r483877650", "bodyText": "Enumerate all imports instead of using *.  Wonder why this is happening on generated code though. Is this how autorest generated? If that's the case, let me know. I will take a look.", "author": "srnagar", "createdAt": "2020-09-04T23:16:49Z", "path": "sdk/eventgrid/azure-messaging-eventgrid/src/main/java/com/azure/messaging/eventgrid/CloudEvent.java", "diffHunk": "@@ -0,0 +1,361 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License. See License.txt in the project root for\n+// license information.\n+//\n+// Code generated by Microsoft (R) AutoRest Code Generator.\n+\n+package com.azure.messaging.eventgrid;\n+\n+import com.azure.core.annotation.Fluent;\n+import com.azure.core.serializer.json.jackson.JacksonJsonSerializerBuilder;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.core.util.serializer.JacksonAdapter;\n+import com.azure.core.util.serializer.JsonSerializer;\n+import com.azure.core.util.serializer.TypeReference;\n+import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.time.OffsetDateTime;\n+import java.util.*;", "originalCommit": "f5ae4ad3b07604409b24f75f2dfc1bfd5d9ec8e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg4Mjc5MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14442#discussion_r483882790", "bodyText": "I believe this has to do with my IntelliJ settings, because this is code written over the autogenerated model in implementation. Brandon mentioned this in a different file as well but my settings should be fixed now.", "author": "Soreloser2", "createdAt": "2020-09-04T23:45:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg3NzY1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg3ODIxOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14442#discussion_r483878218", "bodyText": "For async methods, exceptions should be passed through the publisher. Use FluxUtil.monoError().", "author": "srnagar", "createdAt": "2020-09-04T23:19:35Z", "path": "sdk/eventgrid/azure-messaging-eventgrid/src/main/java/com/azure/messaging/eventgrid/EventGridEvent.java", "diffHunk": "@@ -0,0 +1,291 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License. See License.txt in the project root for\n+// license information.\n+//\n+// Code generated by Microsoft (R) AutoRest Code Generator.\n+\n+package com.azure.messaging.eventgrid;\n+\n+import com.azure.core.annotation.Fluent;\n+import com.azure.core.serializer.json.jackson.JacksonJsonSerializerBuilder;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.core.util.serializer.JacksonAdapter;\n+import com.azure.core.util.serializer.JsonSerializer;\n+import com.azure.core.util.serializer.TypeReference;\n+import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.time.OffsetDateTime;\n+import java.util.List;\n+import java.util.UUID;\n+\n+/**\n+ * The EventGridEvent model. This represents events in the EventGrid schema to be used with the EventGrid service.\n+ * @see EventGridPublisherAsyncClient\n+ * @see EventGridPublisherClient\n+ **/\n+@Fluent\n+public final class EventGridEvent {\n+\n+    private final com.azure.messaging.eventgrid.implementation.models.EventGridEvent event;\n+\n+    private static final ClientLogger logger = new ClientLogger(EventGridEvent.class);\n+\n+    private boolean parsed = false;\n+\n+    private static final JsonSerializer deserializer = new JacksonJsonSerializerBuilder()\n+        .serializer(new JacksonAdapter().serializer() // this is a workaround to get the FlatteningDeserializer\n+            .registerModule(new JavaTimeModule())) // probably also change this to DateTimeDeserializer when/if it\n+        .build();                                  // becomes public in core\n+\n+    /**\n+     * Create a new instance of the EventGridEvent, with the given required fields.\n+     * @param subject     the subject of the event.\n+     * @param eventType   the type of the event, e.g. \"Contoso.Items.ItemReceived\".\n+     * @param dataVersion the version of the data sent along with the event.\n+     */\n+    public EventGridEvent(String subject, String eventType, String dataVersion) {\n+        if (CoreUtils.isNullOrEmpty(subject)) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\"subject cannot be null or empty\"));\n+        } else if (CoreUtils.isNullOrEmpty(eventType)) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\"event type cannot be null or empty\"));\n+        } else if (CoreUtils.isNullOrEmpty(dataVersion)) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\"data version cannot be null or empty\"));\n+        }\n+\n+        this.event = new com.azure.messaging.eventgrid.implementation.models.EventGridEvent()\n+            .setEventTime(OffsetDateTime.now())\n+            .setId(UUID.randomUUID().toString())\n+            .setSubject(subject)\n+            .setEventType(eventType)\n+            .setDataVersion(dataVersion);\n+    }\n+\n+    /**\n+     * Parse the EventGrid Event from a JSON string. This can be used to interpret the event at the event destination\n+     * from raw JSON into rich event(s).\n+     * @param json the JSON payload containing one or more events.\n+     *\n+     * @return all of the events in the payload parsed as CloudEvents.\n+     */\n+    public static List<EventGridEvent> parse(String json) {\n+        return Flux.fromArray(deserializer\n+            .deserialize(new ByteArrayInputStream(json.getBytes(StandardCharsets.UTF_8)),\n+                TypeReference.createInstance(com.azure.messaging.eventgrid.implementation.models.EventGridEvent[].class))\n+            )\n+            .map(event1 -> {\n+                if (event1.getData() == null) {\n+                    return new EventGridEvent(event1);\n+                }\n+                ByteArrayOutputStream stream = new ByteArrayOutputStream();\n+                deserializer.serialize(stream, event1.getData());\n+                return new EventGridEvent(event1).setData(stream.toByteArray()); // use BinaryData instead?\n+            })\n+            .collectList()\n+            .block();\n+    }\n+\n+\n+    /**\n+     * Get the unique id associated with this event.\n+     * @return the id.\n+     */\n+    public String getId() {\n+        return this.event.getId();\n+    }\n+\n+    /**\n+     * Set the unique id of the event. Note that a random id has already been set by default.\n+     * @param id the unique id to set.\n+     *\n+     * @return the event itself.\n+     */\n+    public EventGridEvent setId(String id) {\n+        if (CoreUtils.isNullOrEmpty(id)) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\"id cannot be null or empty\"));\n+        }\n+        this.event.setId(id);\n+        return this;\n+    }\n+\n+    /**\n+     * Get the topic associated with this event if it is associated with a domain.\n+     * @return the topic, or null if the topic is not set (i.e. the event came from or is going to a domain).\n+     */\n+    public String getTopic() {\n+        return this.event.getTopic();\n+    }\n+\n+    /**\n+     * Set the topic associated with this event. Used to route events from domain endpoints.\n+     * @param topic the topic to set.\n+     *\n+     * @return the event itself.\n+     */\n+    public EventGridEvent setTopic(String topic) {\n+        this.event.setTopic(topic);\n+        return this;\n+    }\n+\n+    /**\n+     * Get the subject associated with this event.\n+     * @return the subject.\n+     */\n+    public String getSubject() {\n+        return this.event.getSubject();\n+    }\n+\n+\n+    /**\n+     * Get the data associated with this event. For use in a parsed event only.\n+     * @return If the event was parsed from a Json, this method will return the rich\n+     * system event data if it is a system event, and a {@code byte[]} otherwise, such as in the case of custom event\n+     * data.\n+     * @throws IllegalStateException If the event was not created through {@link EventGridEvent#parse(String)}.\n+     */\n+    public Object getData() {\n+        if (!parsed) {\n+            // data was set instead of parsed, throw error\n+            throw logger.logExceptionAsError(new IllegalStateException(\n+                \"This method should only be called on events created through the parse method\"));\n+        }\n+        String eventType = SystemEventMappings.canonicalizeEventType(event.getEventType());\n+        if (SystemEventMappings.getSystemEventMappings().containsKey(eventType)) {\n+            // system event\n+            return deserializer.deserialize(new ByteArrayInputStream((byte[]) this.event.getData()),\n+                TypeReference.createInstance(SystemEventMappings.getSystemEventMappings().get(eventType)));\n+        }\n+        return event.getData();\n+    }\n+\n+    /**\n+     * Get the deserialized data property from the parsed event. The behavior is undefined if this method is called\n+     * on an event that was not created through the parse method.\n+     * @param clazz the class of the type to deserialize the data into.\n+     * @param <T>   the type to deserialize the data into.\n+     *\n+     * @return the data deserialized into the given type using a default deserializer.\n+     * @throws IllegalStateException If the event was not created through {@link EventGridEvent#parse(String)}.\n+     */\n+    public <T> T getData(Class<T> clazz) {\n+        return getDataAsync(clazz, deserializer).block();\n+    }\n+\n+    /**\n+     * Get the deserialized data property from the parsed event.\n+     * @param clazz the class of the type to deserialize the data into.\n+     * @param <T>   the type to deserialize the data into.\n+     *\n+     * @return the data deserialized into the given type using a default deserializer, delivered asynchronously through\n+     * a {@link Mono}.\n+     * @throws IllegalStateException If the event was not created through {@link EventGridEvent#parse(String)}.\n+     */\n+    public <T> Mono<T> getDataAsync(Class<T> clazz) {\n+        return getDataAsync(clazz, deserializer);\n+    }\n+\n+    /**\n+     * Get the deserialized data property from the parsed event.\n+     * @param clazz            the class of the type to deserialize the data into.\n+     * @param dataDeserializer the deserializer to use.\n+     * @param <T>              the type to deserialize the data into.\n+     *\n+     * @return the data deserialized into the given type using the given deserializer.\n+     * @throws IllegalStateException If the event was not created through {@link EventGridEvent#parse(String)}.\n+     */\n+    public <T> T getData(Class<T> clazz, JsonSerializer dataDeserializer) {\n+        return getDataAsync(clazz, dataDeserializer).block();\n+    }\n+\n+    /**\n+     * Get the deserialized data property from the parsed event.\n+     * @param clazz            the class of the type to deserialize the data into.\n+     * @param dataDeserializer the deserializer to use.\n+     * @param <T>              the type to deserialize the data into.\n+     *\n+     * @return the data deserialized into the given type using the given deserializer, delivered asynchronously through\n+     * a {@link Mono}.\n+     * @throws IllegalStateException If the event was not created through {@link EventGridEvent#parse(String)}.\n+     */\n+    public <T> Mono<T> getDataAsync(Class<T> clazz, JsonSerializer dataDeserializer) {\n+        if (!parsed) {\n+            // data was set instead of parsed, throw exception because we don't know how the data relates to clazz\n+            throw logger.logExceptionAsError(new IllegalStateException(", "originalCommit": "f5ae4ad3b07604409b24f75f2dfc1bfd5d9ec8e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg3OTQxOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14442#discussion_r483879418", "bodyText": "Unfortunately, we'll have to iterate through the collection twice - once to convert Iterable to list and then when serializing. This impacts performance. Not sure, if we can avoid this without changing the API to take a List instead.", "author": "srnagar", "createdAt": "2020-09-04T23:25:34Z", "path": "sdk/eventgrid/azure-messaging-eventgrid/src/main/java/com/azure/messaging/eventgrid/EventGridPublisherAsyncClient.java", "diffHunk": "@@ -0,0 +1,164 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License. See License.txt in the project root for\n+// license information.\n+\n+package com.azure.messaging.eventgrid;\n+\n+import com.azure.core.annotation.ReturnType;\n+import com.azure.core.annotation.ServiceClient;\n+import com.azure.core.annotation.ServiceMethod;\n+import com.azure.core.http.HttpPipeline;\n+import com.azure.core.http.rest.Response;\n+import com.azure.core.util.Context;\n+import com.azure.core.util.serializer.SerializerAdapter;\n+import com.azure.messaging.eventgrid.implementation.EventGridPublisherClientImpl;\n+import com.azure.messaging.eventgrid.implementation.EventGridPublisherClientImplBuilder;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+import static com.azure.core.util.FluxUtil.withContext;\n+\n+/**\n+ * A service client that publishes events to an EventGrid topic or domain. Use {@link EventGridPublisherClientBuilder}\n+ * to create an instance of this client. This uses Project Reactor (https://projectreactor.io/) to handle asynchronous\n+ * programming.\n+ * @see EventGridEvent\n+ * @see CloudEvent\n+ */\n+@ServiceClient(builder = EventGridPublisherClientBuilder.class, isAsync = true)\n+public final class EventGridPublisherAsyncClient {\n+\n+    private final String hostname;\n+\n+    private final EventGridPublisherClientImpl impl;\n+\n+    private final EventGridServiceVersion serviceVersion;\n+\n+    EventGridPublisherAsyncClient(HttpPipeline pipeline, String hostname, SerializerAdapter serializerAdapter,\n+                                  EventGridServiceVersion serviceVersion) {\n+        this.impl = new EventGridPublisherClientImplBuilder()\n+            .pipeline(pipeline)\n+            .serializerAdapter(serializerAdapter)\n+            .buildClient();\n+\n+        // currently the service version is hardcoded into the Impl client, but once another service version gets\n+        // released we should add this to the impl builder options\n+        this.serviceVersion = serviceVersion;\n+\n+        this.hostname = hostname;\n+    }\n+\n+    /**\n+     * Get the service version of the Rest API.\n+     * @return the Service version of the rest API\n+     */\n+    public EventGridServiceVersion getServiceVersion() {\n+        return this.serviceVersion;\n+    }\n+\n+    /**\n+     * Publishes the given EventGrid events to the set topic or domain.\n+     * @param events the EventGrid events to publish.\n+     *\n+     * @return the completion.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public Mono<Void> sendEvents(Iterable<EventGridEvent> events) {\n+        return withContext(context -> sendEvents(events, context));\n+    }\n+\n+    Mono<Void> sendEvents(Iterable<EventGridEvent> events, Context context) {\n+        return Flux.fromIterable(events)\n+            .map(EventGridEvent::toImpl)\n+            .collectList()\n+            .flatMap(list -> this.impl.publishEventsAsync(this.hostname, list, context));\n+    }\n+\n+    /**\n+     * Publishes the given cloud events to the set topic or domain.\n+     * @param events the cloud events to publish.\n+     *\n+     * @return the completion.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public Mono<Void> sendCloudEvents(Iterable<CloudEvent> events) {\n+        return withContext(context -> sendCloudEvents(events, context));\n+    }\n+\n+    Mono<Void> sendCloudEvents(Iterable<CloudEvent> events, Context context) {\n+        return Flux.fromIterable(events)\n+            .map(CloudEvent::toImpl)\n+            .collectList()\n+            .flatMap(list -> this.impl.publishCloudEventEventsAsync(this.hostname, list, context));\n+    }\n+\n+    /**\n+     * Publishes the given custom events to the set topic or domain.\n+     * @param events the custom events to publish.\n+     *\n+     * @return the completion.\n+     */\n+    @ServiceMethod(returns = ReturnType.SINGLE)\n+    public Mono<Void> sendCustomEvents(Iterable<Object> events) {\n+        return withContext(context -> sendCustomEvents(events, context));\n+    }\n+\n+    Mono<Void> sendCustomEvents(Iterable<Object> events, Context context) {\n+        return Flux.fromIterable(events)\n+            .collectList()\n+            .flatMap(list -> this.impl.publishCustomEventEventsAsync(this.hostname, list, context));", "originalCommit": "f5ae4ad3b07604409b24f75f2dfc1bfd5d9ec8e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg3OTY3OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14442#discussion_r483879678", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new RuntimeException(logger.logThrowableAsError(e));\n          \n          \n            \n                        throw logger.logThrowableAsError(new RuntimeException(e));", "author": "srnagar", "createdAt": "2020-09-04T23:26:59Z", "path": "sdk/eventgrid/azure-messaging-eventgrid/src/main/java/com/azure/messaging/eventgrid/EventGridSasCredential.java", "diffHunk": "@@ -0,0 +1,100 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License. See License.txt in the project root for\n+// license information.\n+\n+package com.azure.messaging.eventgrid;\n+\n+import com.azure.core.credential.AzureKeyCredential;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+\n+import javax.crypto.Mac;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.time.OffsetDateTime;\n+import java.time.ZoneOffset;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Base64;\n+\n+/**\n+ * A way to use a generated shared access signature as a credential to publish events to a topic through a client.\n+ */\n+public final class EventGridSasCredential {\n+\n+    private String sas;\n+\n+    private static final ClientLogger logger = new ClientLogger(EventGridSasCredential.class);\n+\n+    /**\n+     * Generate a shared access signature to provide time-limited authentication for requests to the Event Grid\n+     * service.\n+     * @param endpoint       the endpoint of the Event Grid topic or domain.\n+     * @param expirationTime the time in which the signature should expire, no longer providing authentication.\n+     * @param keyCredential  the access key obtained from the Event Grid topic or domain.\n+     *\n+     * @return the shared access signature string which can be used to construct an instance of\n+     * {@link EventGridSasCredential}.\n+     */\n+    public static String createSas(String endpoint, OffsetDateTime expirationTime,\n+                                   AzureKeyCredential keyCredential) {\n+        try {\n+            String resKey = \"r\";\n+            String expKey = \"e\";\n+            String signKey = \"s\";\n+\n+            Charset charset = StandardCharsets.UTF_8;\n+            String encodedResource = URLEncoder.encode(endpoint, charset.name());\n+            String encodedExpiration = URLEncoder.encode(expirationTime.atZoneSameInstant(ZoneOffset.UTC).format(\n+                DateTimeFormatter.ofPattern(\"M/d/yyyy h:m:s a\")),\n+                charset.name());\n+\n+            String unsignedSas = String.format(\"%s=%s&%s=%s\", resKey, encodedResource, expKey, encodedExpiration);\n+\n+            Mac hmac = Mac.getInstance(\"hmacSHA256\");\n+            hmac.init(new SecretKeySpec(Base64.getDecoder().decode(keyCredential.getKey()), \"hmacSHA256\"));\n+            String signature = new String(Base64.getEncoder().encode(\n+                hmac.doFinal(unsignedSas.getBytes(charset))),\n+                charset);\n+\n+            String encodedSignature = URLEncoder.encode(signature, charset.name());\n+\n+            return String.format(\"%s&%s=%s\", unsignedSas, signKey, encodedSignature);\n+\n+        } catch (NoSuchAlgorithmException | UnsupportedEncodingException | InvalidKeyException e) {\n+            throw new RuntimeException(logger.logThrowableAsError(e));", "originalCommit": "f5ae4ad3b07604409b24f75f2dfc1bfd5d9ec8e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg4MDA2MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14442#discussion_r483880061", "bodyText": "https://azure.github.io/azure-sdk/java_implementation.html#java-errors-system-errors\nSplit the exception into NPE and IllegalArgumentException when the input is null and empty respectively.", "author": "srnagar", "createdAt": "2020-09-04T23:29:30Z", "path": "sdk/eventgrid/azure-messaging-eventgrid/src/main/java/com/azure/messaging/eventgrid/EventGridSasCredential.java", "diffHunk": "@@ -0,0 +1,100 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License. See License.txt in the project root for\n+// license information.\n+\n+package com.azure.messaging.eventgrid;\n+\n+import com.azure.core.credential.AzureKeyCredential;\n+import com.azure.core.util.CoreUtils;\n+import com.azure.core.util.logging.ClientLogger;\n+\n+import javax.crypto.Mac;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.time.OffsetDateTime;\n+import java.time.ZoneOffset;\n+import java.time.format.DateTimeFormatter;\n+import java.util.Base64;\n+\n+/**\n+ * A way to use a generated shared access signature as a credential to publish events to a topic through a client.\n+ */\n+public final class EventGridSasCredential {\n+\n+    private String sas;\n+\n+    private static final ClientLogger logger = new ClientLogger(EventGridSasCredential.class);\n+\n+    /**\n+     * Generate a shared access signature to provide time-limited authentication for requests to the Event Grid\n+     * service.\n+     * @param endpoint       the endpoint of the Event Grid topic or domain.\n+     * @param expirationTime the time in which the signature should expire, no longer providing authentication.\n+     * @param keyCredential  the access key obtained from the Event Grid topic or domain.\n+     *\n+     * @return the shared access signature string which can be used to construct an instance of\n+     * {@link EventGridSasCredential}.\n+     */\n+    public static String createSas(String endpoint, OffsetDateTime expirationTime,\n+                                   AzureKeyCredential keyCredential) {\n+        try {\n+            String resKey = \"r\";\n+            String expKey = \"e\";\n+            String signKey = \"s\";\n+\n+            Charset charset = StandardCharsets.UTF_8;\n+            String encodedResource = URLEncoder.encode(endpoint, charset.name());\n+            String encodedExpiration = URLEncoder.encode(expirationTime.atZoneSameInstant(ZoneOffset.UTC).format(\n+                DateTimeFormatter.ofPattern(\"M/d/yyyy h:m:s a\")),\n+                charset.name());\n+\n+            String unsignedSas = String.format(\"%s=%s&%s=%s\", resKey, encodedResource, expKey, encodedExpiration);\n+\n+            Mac hmac = Mac.getInstance(\"hmacSHA256\");\n+            hmac.init(new SecretKeySpec(Base64.getDecoder().decode(keyCredential.getKey()), \"hmacSHA256\"));\n+            String signature = new String(Base64.getEncoder().encode(\n+                hmac.doFinal(unsignedSas.getBytes(charset))),\n+                charset);\n+\n+            String encodedSignature = URLEncoder.encode(signature, charset.name());\n+\n+            return String.format(\"%s&%s=%s\", unsignedSas, signKey, encodedSignature);\n+\n+        } catch (NoSuchAlgorithmException | UnsupportedEncodingException | InvalidKeyException e) {\n+            throw new RuntimeException(logger.logThrowableAsError(e));\n+        }\n+    }\n+\n+    /**\n+     * Create an instance of this object to authenticate calls to the EventGrid service.\n+     * @param sas the shared access signature to use.\n+     */\n+    public EventGridSasCredential(String sas) {\n+        if (CoreUtils.isNullOrEmpty(sas)) {\n+            throw logger.logExceptionAsError(new IllegalArgumentException(\"the access signature cannot be null or empty\"));\n+        }", "originalCommit": "f5ae4ad3b07604409b24f75f2dfc1bfd5d9ec8e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg4MDYzMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/14442#discussion_r483880633", "bodyText": "License headers should be the following in all Java files:\nhttps://docs.opensource.microsoft.com/content/releasing/copyright-headers.html#java\n// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the MIT License.", "author": "srnagar", "createdAt": "2020-09-04T23:32:43Z", "path": "sdk/eventgrid/azure-messaging-eventgrid/src/main/java/com/azure/messaging/eventgrid/EventGridPublisherClientBuilder.java", "diffHunk": "@@ -0,0 +1,298 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License. See License.txt in the project root for\n+// license information.", "originalCommit": "f5ae4ad3b07604409b24f75f2dfc1bfd5d9ec8e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "655825bbf153e37072c0b824760c0090b52e9a6a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/655825bbf153e37072c0b824760c0090b52e9a6a", "message": "Final set of review comments\n\nmostly minor changes, except a small license change to all source files, including generated ones.", "committedDate": "2020-09-05T00:06:39Z", "type": "commit"}]}