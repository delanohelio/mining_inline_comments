{"pr_number": 16822, "pr_title": "Adding client telemetry", "pr_createdAt": "2020-10-26T20:33:04Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/16822", "timeline": [{"oid": "0bef5c252d45d4aee650e42fa381913f1430e212", "url": "https://github.com/Azure/azure-sdk-for-java/commit/0bef5c252d45d4aee650e42fa381913f1430e212", "message": "client telemetry changes", "committedDate": "2020-10-09T21:14:07Z", "type": "commit"}, {"oid": "078f8b14ad24d9a90feb6502da48fe2698425805", "url": "https://github.com/Azure/azure-sdk-for-java/commit/078f8b14ad24d9a90feb6502da48fe2698425805", "message": "build fix", "committedDate": "2020-10-09T21:30:02Z", "type": "commit"}, {"oid": "623cf696789255583db90e6665ab5c4d3b08c925", "url": "https://github.com/Azure/azure-sdk-for-java/commit/623cf696789255583db90e6665ab5c4d3b08c925", "message": "adding incremental change for client telemetry", "committedDate": "2020-10-19T19:11:23Z", "type": "commit"}, {"oid": "e214000ec233da19a95da8405c68ab2931e04f24", "url": "https://github.com/Azure/azure-sdk-for-java/commit/e214000ec233da19a95da8405c68ab2931e04f24", "message": "adding incremental change for client telemetry", "committedDate": "2020-10-19T19:13:30Z", "type": "commit"}, {"oid": "68cd2ee8c418dd7d1cbf92d0a305c668a954b312", "url": "https://github.com/Azure/azure-sdk-for-java/commit/68cd2ee8c418dd7d1cbf92d0a305c668a954b312", "message": "adding incremental change for client telemetry", "committedDate": "2020-10-19T19:22:31Z", "type": "commit"}, {"oid": "6ac5a0f9983e0caa62e58602c9f0db722a69a917", "url": "https://github.com/Azure/azure-sdk-for-java/commit/6ac5a0f9983e0caa62e58602c9f0db722a69a917", "message": "merge with masrer", "committedDate": "2020-10-19T19:25:42Z", "type": "commit"}, {"oid": "96e650bc88e383ea45a5792dc73caf77955aff63", "url": "https://github.com/Azure/azure-sdk-for-java/commit/96e650bc88e383ea45a5792dc73caf77955aff63", "message": "incremental check in", "committedDate": "2020-10-20T17:53:48Z", "type": "commit"}, {"oid": "561849ee8eeb9a7b8f39a7cd7ad9fc8aa3e43e8c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/561849ee8eeb9a7b8f39a7cd7ad9fc8aa3e43e8c", "message": "Incremental work", "committedDate": "2020-10-26T19:04:15Z", "type": "commit"}, {"oid": "df827ea09879f2f5c4d6afa85bce17fb5f7dc3d0", "url": "https://github.com/Azure/azure-sdk-for-java/commit/df827ea09879f2f5c4d6afa85bce17fb5f7dc3d0", "message": "Merge branch 'latest-master' into users/nakumar/clientTelemetry", "committedDate": "2020-10-26T19:09:18Z", "type": "commit"}, {"oid": "e38fa29b01ab1b95f6fa75f5eb957c626cf01bf7", "url": "https://github.com/Azure/azure-sdk-for-java/commit/e38fa29b01ab1b95f6fa75f5eb957c626cf01bf7", "message": "Incremental work", "committedDate": "2020-10-26T20:21:37Z", "type": "commit"}, {"oid": "f96b243b10963f2e18fd0bf0ec99550897a6bfae", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f96b243b10963f2e18fd0bf0ec99550897a6bfae", "message": "incremental work", "committedDate": "2020-10-26T20:25:06Z", "type": "commit"}, {"oid": "a8c1f509176246306664dc0bbbf07c7240c2fa42", "url": "https://github.com/Azure/azure-sdk-for-java/commit/a8c1f509176246306664dc0bbbf07c7240c2fa42", "message": "adding setAutoResize on cpu and memory", "committedDate": "2020-10-26T22:45:30Z", "type": "commit"}, {"oid": "f087a988ec3bc8836d432b1113365d84173a3096", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f087a988ec3bc8836d432b1113365d84173a3096", "message": "adding useragent in serialization", "committedDate": "2020-10-27T18:53:12Z", "type": "commit"}, {"oid": "60b2e6c0ee9888856e16ac427390e82e06c9cda6", "url": "https://github.com/Azure/azure-sdk-for-java/commit/60b2e6c0ee9888856e16ac427390e82e06c9cda6", "message": "Adding test file", "committedDate": "2020-10-29T16:07:04Z", "type": "commit"}, {"oid": "6c8da63c311ebbada183cb99019bcf55bb06eea4", "url": "https://github.com/Azure/azure-sdk-for-java/commit/6c8da63c311ebbada183cb99019bcf55bb06eea4", "message": "Merge branch 'latest-master' into users/nakumar/clientTelemetry", "committedDate": "2020-10-29T16:41:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQzMTgyMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r514431823", "bodyText": "I got this hashing from our existing partition key class, I could have done without (hash * 397) , thoughts ?", "author": "simplynaveen20", "createdAt": "2020-10-29T17:17:31Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ReportPayload.java", "diffHunk": "@@ -0,0 +1,143 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+import com.azure.cosmos.ConsistencyLevel;\n+import com.azure.cosmos.implementation.OperationType;\n+import com.azure.cosmos.implementation.ResourceType;\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+\n+import static com.azure.cosmos.implementation.Utils.as;\n+\n+@JsonInclude(JsonInclude.Include.NON_NULL)\n+public class ReportPayload {\n+    private String regionsContacted;\n+    private Boolean greaterThan1Kb;\n+    private ConsistencyLevel consistency;\n+    private String databasesName;\n+    private String containerName;\n+    private OperationType operation;\n+    private ResourceType resource;\n+    private Integer statusCode;\n+    private String operationId;\n+    private MetricInfo metricInfo;\n+\n+    public ReportPayload(String metricInfoName, String unitName) {\n+        metricInfo = new MetricInfo(metricInfoName, unitName);\n+    }\n+\n+    public String getRegionsContacted() {\n+        return regionsContacted;\n+    }\n+\n+    public void setRegionsContacted(String regionsContacted) {\n+        this.regionsContacted = regionsContacted;\n+    }\n+\n+    public Boolean getGreaterThan1Kb() {\n+        return greaterThan1Kb;\n+    }\n+\n+    public void setGreaterThan1Kb(Boolean greaterThan1Kb) {\n+        this.greaterThan1Kb = greaterThan1Kb;\n+    }\n+\n+    public ConsistencyLevel getConsistency() {\n+        return consistency;\n+    }\n+\n+    public void setConsistency(ConsistencyLevel consistency) {\n+        this.consistency = consistency;\n+    }\n+\n+    public String getDatabasesName() {\n+        return databasesName;\n+    }\n+\n+    public void setDatabasesName(String databasesName) {\n+        this.databasesName = databasesName;\n+    }\n+\n+    public String getContainerName() {\n+        return containerName;\n+    }\n+\n+    public void setContainerName(String containerName) {\n+        this.containerName = containerName;\n+    }\n+\n+    public OperationType getOperation() {\n+        return operation;\n+    }\n+\n+    public void setOperation(OperationType operation) {\n+        this.operation = operation;\n+    }\n+\n+    public ResourceType getResource() {\n+        return resource;\n+    }\n+\n+    public void setResource(ResourceType resource) {\n+        this.resource = resource;\n+    }\n+\n+    public Integer getStatusCode() {\n+        return statusCode;\n+    }\n+\n+    public void setStatusCode(Integer statusCode) {\n+        this.statusCode = statusCode;\n+    }\n+\n+    public String getOperationId() {\n+        return operationId;\n+    }\n+\n+    public void setOperationId(String operationId) {\n+        this.operationId = operationId;\n+    }\n+\n+    public MetricInfo getMetricInfo() {\n+        return metricInfo;\n+    }\n+\n+    public void setMetricInfo(MetricInfo metricInfo) {\n+        this.metricInfo = metricInfo;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        ReportPayload reportPayload = as(obj, ReportPayload.class);\n+        if (reportPayload == null) {\n+            return false;\n+        }\n+        if (((reportPayload.regionsContacted == null && this.regionsContacted == null) || (reportPayload.regionsContacted != null && reportPayload.regionsContacted.equals(this.regionsContacted))) &&\n+            ((reportPayload.greaterThan1Kb == null && this.greaterThan1Kb == null) || (reportPayload.greaterThan1Kb != null && reportPayload.greaterThan1Kb.equals(this.greaterThan1Kb))) &&\n+            ((reportPayload.consistency == null && this.consistency == null) || (reportPayload.consistency != null && reportPayload.consistency.equals(this.consistency))) &&\n+            ((reportPayload.databasesName == null && this.databasesName == null) || (reportPayload.databasesName != null && reportPayload.databasesName.equals(this.databasesName))) &&\n+            ((reportPayload.containerName == null && this.containerName == null) || (reportPayload.containerName != null && reportPayload.containerName.equals(this.containerName))) &&\n+            ((reportPayload.operation == null && this.operation == null) || (reportPayload.operation != null && reportPayload.operation.equals(this.operation))) &&\n+            ((reportPayload.resource == null && this.resource == null) || (reportPayload.resource != null && reportPayload.resource.equals(this.resource))) &&\n+            ((reportPayload.statusCode == null && this.statusCode == null) || (reportPayload.statusCode != null && reportPayload.statusCode.equals(this.statusCode))) &&\n+            ((reportPayload.metricInfo.getMetricsName() == null && this.metricInfo.getMetricsName() == null) || (reportPayload.metricInfo.getMetricsName() != null && reportPayload.metricInfo.getMetricsName().equals(this.metricInfo.getMetricsName())))) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int hash = 0;\n+        hash = (hash * 397) ^ (this.regionsContacted == null ? 0 : this.regionsContacted.hashCode());", "originalCommit": "6c8da63c311ebbada183cb99019bcf55bb06eea4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODMwMDM5NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518300395", "bodyText": "The notion of 397 is - usually in hashCode() we take a prime number and then use that to generate hashCode.\nI will suggest to keep it.\nCan you also please check what IntelliJ generates when you generate the hashCode with it ?", "author": "kushagraThapar", "createdAt": "2020-11-05T19:17:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQzMTgyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc1NDM0Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520754343", "bodyText": "Oh I see, intellij with hash 397 generated 1474114674 and without it 1390251919. As you rightly mentioned it will help in better distribution of hash. So we are good with this.", "author": "simplynaveen20", "createdAt": "2020-11-10T17:48:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQzMTgyMw=="}], "type": "inlineReview"}, {"oid": "3687c02c8e112d392357bd04d36bcd902aff6005", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3687c02c8e112d392357bd04d36bcd902aff6005", "message": "adding suprression for reportpayload equals method", "committedDate": "2020-10-29T17:44:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY0MjQxOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r514642419", "bodyText": "Please add java documentation to this.", "author": "kushagraThapar", "createdAt": "2020-10-30T00:32:11Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosClientBuilder.java", "diffHunk": "@@ -579,6 +580,11 @@ public CosmosClientBuilder multipleWriteRegionsEnabled(boolean multipleWriteRegi\n         return this;\n     }\n \n+    public CosmosClientBuilder clientTelemetryEnabled(boolean clientTelemetryEnabled) {", "originalCommit": "3687c02c8e112d392357bd04d36bcd902aff6005", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk1MjM2OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r516952369", "bodyText": "Thanks for this, done", "author": "simplynaveen20", "createdAt": "2020-11-03T21:00:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY0MjQxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY0MjcwNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r514642704", "bodyText": "This is great, thank you!\nPlease mention this issue in the PR as this API solves the github issue ask: #13488", "author": "kushagraThapar", "createdAt": "2020-10-30T00:33:28Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosException.java", "diffHunk": "@@ -281,6 +281,22 @@ CosmosException setDiagnostics(CosmosDiagnostics cosmosDiagnostics) {\n         return this;\n     }\n \n+    /**\n+     * Gets the request charge as request units (RU) consumed by the operation.\n+     * <p>\n+     * For more information about the RU and factors that can impact the effective charges please visit\n+     * <a href=\"https://docs.microsoft.com/en-us/azure/cosmos-db/request-units\">Request Units in Azure Cosmos DB</a>\n+     *\n+     * @return the request charge.\n+     */\n+    public double getRequestCharge() {", "originalCommit": "3687c02c8e112d392357bd04d36bcd902aff6005", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk1MjI5Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r516952293", "bodyText": "Done", "author": "simplynaveen20", "createdAt": "2020-11-03T21:00:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY0MjcwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY0Mjg0Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r514642843", "bodyText": "It is every 600 seconds / 10 minutes ?", "author": "kushagraThapar", "createdAt": "2020-10-30T00:34:04Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/Configs.java", "diffHunk": "@@ -41,7 +41,10 @@\n     private static final String HTTP_RESPONSE_TIMEOUT_IN_SECONDS = \"COSMOS.HTTP_RESPONSE_TIMEOUT_IN_SECONDS\";\n     private static final String QUERY_PLAN_RESPONSE_TIMEOUT_IN_SECONDS = \"COSMOS.QUERY_PLAN_RESPONSE_TIMEOUT_IN_SECONDS\";\n     private static final String ADDRESS_REFRESH_RESPONSE_TIMEOUT_IN_SECONDS = \"COSMOS.ADDRESS_REFRESH_RESPONSE_TIMEOUT_IN_SECONDS\";\n+    private static final String CLIENT_TELEMETRY_ENABLED = \"COSMOS.CLIENT_TELEMETRY_ENABLED\";\n+    private static final String CLIENT_TELEMETRY_SCHEDULING_IN_SECONDS = \"COSMOS.CLIENT_TELEMETRY_SCHEDULING_IN_SECONDS\";\n \n+    private static final int DEFAULT_CLIENT_TELEMETRY_SCHEDULING_IN_SECONDS = 10 * 60;", "originalCommit": "3687c02c8e112d392357bd04d36bcd902aff6005", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk1Mjc5MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r516952791", "bodyText": "yes it is 10 min , representation 10*60 is more readable and i followed the existing model", "author": "simplynaveen20", "createdAt": "2020-11-03T21:01:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY0Mjg0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI4NDY2MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518284661", "bodyText": "Makes sense, thanks!", "author": "kushagraThapar", "createdAt": "2020-11-05T18:51:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY0Mjg0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY0MzQ1MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r514643450", "bodyText": "nit: What if the val is not a boolean value - this will throw an exception and might stop the application. Instead we should try catch it and just log the error and move forward with default value.\nAlso, this is an issue with other API as well - getIntValue()", "author": "kushagraThapar", "createdAt": "2020-10-30T00:36:12Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/Configs.java", "diffHunk": "@@ -230,11 +241,24 @@ private static int getJVMConfigAsInt(String propName, int defaultValue) {\n         return getIntValue(propValue, defaultValue);\n     }\n \n+    private static boolean getJVMConfigAsBoolean(String propName, boolean defaultValue) {\n+        String propValue = System.getProperty(propName);\n+        return getBooleanValue(propValue, defaultValue);\n+    }\n+\n     private static int getIntValue(String val, int defaultValue) {\n         if (StringUtils.isEmpty(val)) {\n             return defaultValue;\n         } else {\n             return Integer.valueOf(val);\n         }\n     }\n+\n+    private static boolean getBooleanValue(String val, boolean defaultValue) {\n+        if (StringUtils.isEmpty(val)) {\n+            return defaultValue;\n+        } else {\n+            return Boolean.valueOf(val);", "originalCommit": "3687c02c8e112d392357bd04d36bcd902aff6005", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk1Mzk0OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r516953949", "bodyText": "If we pass any thing apart from true and false , it will return false. Below code from from Boolean class\n    public static Boolean valueOf(String s) { return parseBoolean(s) ? TRUE : FALSE; }\n public static boolean parseBoolean(String s) { return \"true\".equalsIgnoreCase(s); }", "author": "simplynaveen20", "createdAt": "2020-11-03T21:03:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY0MzQ1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI4NDg5MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518284890", "bodyText": "I see, cool, thanks!", "author": "kushagraThapar", "createdAt": "2020-11-05T18:51:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY0MzQ1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY0MzU3Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r514643572", "bodyText": "Please include clientTelemetryEnabled in toString() API", "author": "kushagraThapar", "createdAt": "2020-10-30T00:36:47Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/ConnectionPolicy.java", "diffHunk": "@@ -497,6 +500,14 @@ public ConnectionPolicy setMaxRequestsPerConnection(int maxRequestsPerConnection\n         return this;\n     }\n \n+    public boolean isClientTelemetryEnabled() {\n+        return clientTelemetryEnabled;\n+    }\n+\n+    public void setClientTelemetryEnabled(boolean clientTelemetryEnabled) {\n+        this.clientTelemetryEnabled = clientTelemetryEnabled;\n+    }\n+\n     @Override\n     public String toString() {\n         return \"ConnectionPolicy{\" +", "originalCommit": "3687c02c8e112d392357bd04d36bcd902aff6005", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk1NDM4Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r516954386", "bodyText": "Good catch , thanks", "author": "simplynaveen20", "createdAt": "2020-11-03T21:04:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY0MzU3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY0Mzc4NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r514643785", "bodyText": "Why are we changing the scope of this API ?", "author": "kushagraThapar", "createdAt": "2020-10-30T00:37:39Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -121,18 +129,28 @@ public Context startSpan(String methodName, String databaseId, String endpoint,\n     public <T> Mono<CosmosItemResponse<T>> traceEnabledCosmosItemResponsePublisher(Mono<CosmosItemResponse<T>> resultPublisher,\n                                                                                    Context context,\n                                                                                    String spanName,\n+                                                                                   String containerId,\n                                                                                    String databaseId,\n-                                                                                   String endpoint) {\n-        return traceEnabledPublisher(resultPublisher, context, spanName, databaseId, endpoint,\n+                                                                                   CosmosAsyncClient client,\n+                                                                                   ConsistencyLevel consistencyLevel,\n+                                                                                   OperationType operationType,\n+                                                                                   ResourceType resourceType) {\n+\n+        return publisherWithClientTelemetry(resultPublisher, context, spanName, containerId, databaseId,\n+            BridgeInternal.getServiceEndpoint(client),\n+            client,\n+            consistencyLevel,\n+            operationType,\n+            resourceType,\n             CosmosItemResponse::getStatusCode);\n     }\n \n-    public <T> Mono<T> traceEnabledPublisher(Mono<T> resultPublisher,\n-                                             Context context,\n-                                             String spanName,\n-                                             String databaseId,\n-                                             String endpoint,\n-                                             Function<T, Integer> statusCodeFunc) {\n+    private <T> Mono<T> traceEnabledPublisher(Mono<T> resultPublisher,", "originalCommit": "3687c02c8e112d392357bd04d36bcd902aff6005", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk1NDgwNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r516954804", "bodyText": "This must be left public my mistake , not getting called from outside", "author": "simplynaveen20", "createdAt": "2020-11-03T21:05:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDY0Mzc4NQ=="}], "type": "inlineReview"}, {"oid": "bae66233a06f0f68824ca52ee35c46be9a704e3c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/bae66233a06f0f68824ca52ee35c46be9a704e3c", "message": "Merge branch 'latest-master' into users/nakumar/clientTelemetry", "committedDate": "2020-11-03T20:01:51Z", "type": "commit"}, {"oid": "252850bb53ec1a08ece93613b302abeb547a161b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/252850bb53ec1a08ece93613b302abeb547a161b", "message": "performance turning and resolving comments", "committedDate": "2020-11-03T20:59:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI4NjIwMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518286200", "bodyText": "when checking for throwable instanceof CosmosException, shouldn't we try to unwrap the exception in case the exception is of type ReactiveException ?\nSame for other places where we are checking throwable in doOnError blocks.", "author": "kushagraThapar", "createdAt": "2020-11-05T18:53:42Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -153,11 +171,117 @@ public Context startSpan(String methodName, String databaseId, String endpoint,\n             });\n     }\n \n+    private <T> Mono<T> publisherWithClientTelemetry(Mono<T> resultPublisher,\n+                                                     Context context,\n+                                                     String spanName,\n+                                                     String containerId,\n+                                                     String databaseId,\n+                                                     String endpoint,\n+                                                     CosmosAsyncClient client,\n+                                                     ConsistencyLevel consistencyLevel,\n+                                                     OperationType operationType,\n+                                                     ResourceType resourceType,\n+                                                     Function<T, Integer> statusCodeFunc) {\n+        Mono<T> tracerMono = traceEnabledPublisher(resultPublisher, context, spanName, databaseId, endpoint, statusCodeFunc);\n+        return tracerMono\n+            .doOnSuccess(response -> {\n+                if (Configs.isClientTelemetryEnabled(BridgeInternal.isClientTelemetryEnabled(client)) && response instanceof CosmosItemResponse) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    CosmosItemResponse<T> itemResponse = (CosmosItemResponse<T>) response;\n+                    fillClientTelemetry(client, itemResponse.getDiagnostics(), itemResponse.getStatusCode(),\n+                        ModelBridgeInternal.getPayloadLength(itemResponse), containerId,\n+                        databaseId, operationType, resourceType, consistencyLevel,\n+                        (float) itemResponse.getRequestCharge());\n+                }\n+            }).doOnError(throwable -> {\n+                if (Configs.isClientTelemetryEnabled(BridgeInternal.isClientTelemetryEnabled(client)) && throwable instanceof CosmosException) {", "originalCommit": "252850bb53ec1a08ece93613b302abeb547a161b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc1NTYyNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520755624", "bodyText": "Idea here is to log the telemetry on every cosmos exception, irrespective of inner cause.", "author": "simplynaveen20", "createdAt": "2020-11-10T17:50:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI4NjIwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgxMjEwMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520812102", "bodyText": "I see, sounds good.", "author": "kushagraThapar", "createdAt": "2020-11-10T19:14:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI4NjIwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI4NzYxOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518287619", "bodyText": "We also treat HttpConstants.StatusCodes.NOT_MODIFIED as success code in other places in the code. Shouldn't we include that here ?", "author": "kushagraThapar", "createdAt": "2020-11-05T18:56:10Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -153,11 +171,117 @@ public Context startSpan(String methodName, String databaseId, String endpoint,\n             });\n     }\n \n+    private <T> Mono<T> publisherWithClientTelemetry(Mono<T> resultPublisher,\n+                                                     Context context,\n+                                                     String spanName,\n+                                                     String containerId,\n+                                                     String databaseId,\n+                                                     String endpoint,\n+                                                     CosmosAsyncClient client,\n+                                                     ConsistencyLevel consistencyLevel,\n+                                                     OperationType operationType,\n+                                                     ResourceType resourceType,\n+                                                     Function<T, Integer> statusCodeFunc) {\n+        Mono<T> tracerMono = traceEnabledPublisher(resultPublisher, context, spanName, databaseId, endpoint, statusCodeFunc);\n+        return tracerMono\n+            .doOnSuccess(response -> {\n+                if (Configs.isClientTelemetryEnabled(BridgeInternal.isClientTelemetryEnabled(client)) && response instanceof CosmosItemResponse) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    CosmosItemResponse<T> itemResponse = (CosmosItemResponse<T>) response;\n+                    fillClientTelemetry(client, itemResponse.getDiagnostics(), itemResponse.getStatusCode(),\n+                        ModelBridgeInternal.getPayloadLength(itemResponse), containerId,\n+                        databaseId, operationType, resourceType, consistencyLevel,\n+                        (float) itemResponse.getRequestCharge());\n+                }\n+            }).doOnError(throwable -> {\n+                if (Configs.isClientTelemetryEnabled(BridgeInternal.isClientTelemetryEnabled(client)) && throwable instanceof CosmosException) {\n+                    CosmosException cosmosException = (CosmosException) throwable;\n+                    fillClientTelemetry(client, cosmosException.getDiagnostics(), cosmosException.getStatusCode(),\n+                        null, containerId,\n+                        databaseId, operationType, resourceType, consistencyLevel,\n+                        (float) cosmosException.getRequestCharge());\n+                }\n+            });\n+    }\n+\n     private void end(int statusCode, Throwable throwable, Context context) {\n         if (throwable != null) {\n             tracer.setAttribute(TracerProvider.ERROR_MSG, throwable.getMessage(), context);\n             tracer.setAttribute(TracerProvider.ERROR_TYPE, throwable.getClass().getName(), context);\n         }\n         tracer.end(statusCode, throwable, context);\n     }\n+\n+    public void fillClientTelemetry(CosmosAsyncClient cosmosAsyncClient,\n+                                    CosmosDiagnostics cosmosDiagnostics,\n+                                    int statusCode,\n+                                    Integer objectSize,\n+                                    String containerId,\n+                                    String databaseId,\n+                                    OperationType operationType,\n+                                    ResourceType resourceType,\n+                                    ConsistencyLevel consistencyLevel,\n+                                    float requestCharge) {\n+        ClientTelemetry telemetry = BridgeInternal.getContextClient(cosmosAsyncClient).getClientTelemetry();\n+        ReportPayload reportPayloadLatency = createReportPayload(cosmosAsyncClient, cosmosDiagnostics,\n+            statusCode, objectSize, containerId, databaseId\n+            , operationType, resourceType, consistencyLevel, ClientTelemetry.REQUEST_LATENCY_NAME,\n+            ClientTelemetry.REQUEST_LATENCY_UNIT);\n+        ConcurrentDoubleHistogram latencyHistogram = telemetry.getClientTelemetryInfo().getOperationInfoMap().get(reportPayloadLatency);\n+        if (latencyHistogram != null) {\n+            ClientTelemetry.recordValue(latencyHistogram, cosmosDiagnostics.getDuration().toNanos()/1000);\n+        } else {\n+            if (statusCode == HttpConstants.StatusCodes.OK || statusCode == HttpConstants.StatusCodes.CREATED) {", "originalCommit": "252850bb53ec1a08ece93613b302abeb547a161b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc1Njk4Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520756982", "bodyText": "TracerProvider file will log only point operation, and 304 is for feed operation. So it will be redundant check. In cosmos page flux we create our own status code base on success and failure , it is not needed there also.", "author": "simplynaveen20", "createdAt": "2020-11-10T17:52:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI4NzYxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI4OTY3MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518289671", "bodyText": "nit : This could be a private class if not used outside, if used outside, may be Compute can be its own class outside.", "author": "kushagraThapar", "createdAt": "2020-11-05T18:59:43Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/AzureVMMetadata.java", "diffHunk": "@@ -0,0 +1,30 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+public class AzureVMMetadata {\n+    private Compute compute;\n+    public String getLocation() {\n+        return compute != null ? compute.getLocation() : null;\n+    }\n+\n+    public Compute getCompute() {\n+        return compute;\n+    }\n+\n+    public void setCompute(Compute compute) {\n+        this.compute = compute;\n+    }\n+\n+    static class Compute{", "originalCommit": "252850bb53ec1a08ece93613b302abeb547a161b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc1NzQ0OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520757448", "bodyText": "Done, if in future we will use Compute exclusively , we will change it back to package private", "author": "simplynaveen20", "createdAt": "2020-11-10T17:53:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI4OTY3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI5MDM2NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518290364", "bodyText": "Can you please add units to the name of this constant ?", "author": "kushagraThapar", "createdAt": "2020-11-05T19:00:51Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java", "diffHunk": "@@ -0,0 +1,230 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+import com.azure.cosmos.ConnectionMode;\n+import com.azure.cosmos.implementation.Configs;\n+import com.azure.cosmos.implementation.GlobalEndpointManager;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.cpu.CpuMemoryMonitor;\n+import com.azure.cosmos.implementation.http.HttpClient;\n+import com.azure.cosmos.implementation.http.HttpHeaders;\n+import com.azure.cosmos.implementation.http.HttpRequest;\n+import com.azure.cosmos.implementation.http.HttpResponse;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpMethod;\n+import org.HdrHistogram.ConcurrentDoubleHistogram;\n+import org.HdrHistogram.DoubleHistogram;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+public class ClientTelemetry {\n+    public final static int REQUEST_LATENCY_MAX = 300000000;", "originalCommit": "252850bb53ec1a08ece93613b302abeb547a161b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc1NzU4Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520757586", "bodyText": "Done", "author": "simplynaveen20", "createdAt": "2020-11-10T17:53:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI5MDM2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI5MDYwNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518290607", "bodyText": "Please add unit to the name of the constant.", "author": "kushagraThapar", "createdAt": "2020-11-05T19:01:15Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java", "diffHunk": "@@ -0,0 +1,230 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+import com.azure.cosmos.ConnectionMode;\n+import com.azure.cosmos.implementation.Configs;\n+import com.azure.cosmos.implementation.GlobalEndpointManager;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.cpu.CpuMemoryMonitor;\n+import com.azure.cosmos.implementation.http.HttpClient;\n+import com.azure.cosmos.implementation.http.HttpHeaders;\n+import com.azure.cosmos.implementation.http.HttpRequest;\n+import com.azure.cosmos.implementation.http.HttpResponse;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpMethod;\n+import org.HdrHistogram.ConcurrentDoubleHistogram;\n+import org.HdrHistogram.DoubleHistogram;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+public class ClientTelemetry {\n+    public final static int REQUEST_LATENCY_MAX = 300000000;\n+    public final static int REQUEST_LATENCY_SUCCESS_PRECISION = 4;\n+    public final static int REQUEST_LATENCY_FAILURE_PRECISION = 2;\n+    public final static String REQUEST_LATENCY_NAME = \"RequestLatency\";\n+    public final static String REQUEST_LATENCY_UNIT = \"MicroSec\";\n+\n+    public final static int REQUEST_CHARGE_MAX = 10000;\n+    public final static int REQUEST_CHARGE_PRECISION = 2;\n+    public final static String REQUEST_CHARGE_NAME = \"RequestCharge\";\n+    public final static String REQUEST_CHARGE_UNIT = \"RU\";\n+\n+    public final static int CPU_MAX = 100;\n+    public final static int CPU_PRECISION = 2;\n+    private final static String CPU_NAME = \"CPU\";\n+    private final static String CPU_UNIT = \"Percentage\";\n+\n+    public final static int MEMORY_MAX = 102400;", "originalCommit": "252850bb53ec1a08ece93613b302abeb547a161b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc1NzY1OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520757658", "bodyText": "Done", "author": "simplynaveen20", "createdAt": "2020-11-10T17:53:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI5MDYwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI5MzUxNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518293515", "bodyText": "I see, this is trace logging, while others are warning and info, is there a reason for this?", "author": "kushagraThapar", "createdAt": "2020-11-05T19:06:30Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java", "diffHunk": "@@ -0,0 +1,230 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+import com.azure.cosmos.ConnectionMode;\n+import com.azure.cosmos.implementation.Configs;\n+import com.azure.cosmos.implementation.GlobalEndpointManager;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.cpu.CpuMemoryMonitor;\n+import com.azure.cosmos.implementation.http.HttpClient;\n+import com.azure.cosmos.implementation.http.HttpHeaders;\n+import com.azure.cosmos.implementation.http.HttpRequest;\n+import com.azure.cosmos.implementation.http.HttpResponse;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpMethod;\n+import org.HdrHistogram.ConcurrentDoubleHistogram;\n+import org.HdrHistogram.DoubleHistogram;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+public class ClientTelemetry {\n+    public final static int REQUEST_LATENCY_MAX = 300000000;\n+    public final static int REQUEST_LATENCY_SUCCESS_PRECISION = 4;\n+    public final static int REQUEST_LATENCY_FAILURE_PRECISION = 2;\n+    public final static String REQUEST_LATENCY_NAME = \"RequestLatency\";\n+    public final static String REQUEST_LATENCY_UNIT = \"MicroSec\";\n+\n+    public final static int REQUEST_CHARGE_MAX = 10000;\n+    public final static int REQUEST_CHARGE_PRECISION = 2;\n+    public final static String REQUEST_CHARGE_NAME = \"RequestCharge\";\n+    public final static String REQUEST_CHARGE_UNIT = \"RU\";\n+\n+    public final static int CPU_MAX = 100;\n+    public final static int CPU_PRECISION = 2;\n+    private final static String CPU_NAME = \"CPU\";\n+    private final static String CPU_UNIT = \"Percentage\";\n+\n+    public final static int MEMORY_MAX = 102400;\n+    public final static int MEMORY_PRECISION = 2;\n+    private final static String MEMORY_NAME = \"MemoryRemaining\";\n+    private final static String MEMORY_UNIT = \"MB\";\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+    private ClientTelemetryInfo clientTelemetryInfo;\n+    private HttpClient httpClient;\n+    private final ExecutorService executor = Executors.newSingleThreadExecutor();\n+    private final Scheduler scheduler = Schedulers.fromExecutor(executor);\n+    private static final Logger logger = LoggerFactory.getLogger(GlobalEndpointManager.class);\n+    private volatile boolean isClosed;\n+    private volatile boolean isClientTelemetryEnabled;\n+    private static String AZURE_VM_METADATA = \"http://169.254.169.254:80/metadata/instance?api-version=2020-06-01\";\n+\n+    private static final double PERCENTILE_50 = 50.0;\n+    private static final double PERCENTILE_90 = 90.0;\n+    private static final double PERCENTILE_95 = 95.0;\n+    private static final double PERCENTILE_99 = 99.0;\n+    private static final double PERCENTILE_999 = 99.9;\n+    private final int clientTelemetrySchedulingSec;\n+\n+    public ClientTelemetry(Boolean acceleratedNetworking,\n+                           String clientId,\n+                           String processId,\n+                           String userAgent,\n+                           ConnectionMode connectionMode,\n+                           String globalDatabaseAccountName,\n+                           String applicationRegion,\n+                           String hostEnvInfo,\n+                           HttpClient httpClient,\n+                           boolean isClientTelemetryEnabled\n+    ) {\n+        clientTelemetryInfo = new ClientTelemetryInfo(clientId, processId, userAgent, connectionMode,\n+            globalDatabaseAccountName, applicationRegion, hostEnvInfo, acceleratedNetworking);\n+        this.isClosed = false;\n+        this.httpClient = httpClient;\n+        this.isClientTelemetryEnabled = isClientTelemetryEnabled;\n+        this.clientTelemetrySchedulingSec = Configs.getClientTelemetrySchedulingInSec();\n+    }\n+\n+    public ClientTelemetryInfo getClientTelemetryInfo() {\n+        return clientTelemetryInfo;\n+    }\n+\n+    public static void recordValue(DoubleHistogram doubleHistogram, long value) {\n+        try {\n+            doubleHistogram.recordValue(value);\n+        } catch (Exception ex) {\n+            logger.warn(\"Error while recording value for client telemetry\", ex.getMessage());\n+        }\n+    }\n+\n+    public static void recordValue(DoubleHistogram doubleHistogram, double value) {\n+        try {\n+            doubleHistogram.recordValue(value);\n+        } catch (Exception ex) {\n+            logger.warn(\"Error while recording value for client telemetry\", ex.getMessage());\n+        }\n+    }\n+\n+    public void init() {\n+        loadAzureVmMetaData();\n+        sendClientTelemetry().subscribe();\n+    }\n+\n+    public void close() {\n+        this.isClosed = true;\n+        this.executor.shutdown();\n+        logger.debug(\"GlobalEndpointManager closed.\");\n+    }\n+\n+    private Mono<Void> sendClientTelemetry() {\n+        return Mono.delay(Duration.ofSeconds(clientTelemetrySchedulingSec))\n+            .flatMap(t -> {\n+                if (this.isClosed) {\n+                    logger.warn(\"client already closed\");\n+                    return Mono.empty();\n+                }\n+\n+                if(!Configs.isClientTelemetryEnabled(this.isClientTelemetryEnabled)) {\n+                    logger.trace(\"client telemetry not enabled\");", "originalCommit": "252850bb53ec1a08ece93613b302abeb547a161b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc2MTY1OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520761659", "bodyText": "This is done intentionally, till the time we enable telemetry by default i don't want cx to get this log. Otherwise every customer will be getting this every 10 min , and might create a cri with question.", "author": "simplynaveen20", "createdAt": "2020-11-10T17:59:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI5MzUxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI5NTU0OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518295548", "bodyText": "Are we doing recursion inside flatMap ?\nThere could be a better way to do this instead of doing it though flatMap- please take a look at expand operation from project reactor.", "author": "kushagraThapar", "createdAt": "2020-11-05T19:09:59Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java", "diffHunk": "@@ -0,0 +1,230 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+import com.azure.cosmos.ConnectionMode;\n+import com.azure.cosmos.implementation.Configs;\n+import com.azure.cosmos.implementation.GlobalEndpointManager;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.cpu.CpuMemoryMonitor;\n+import com.azure.cosmos.implementation.http.HttpClient;\n+import com.azure.cosmos.implementation.http.HttpHeaders;\n+import com.azure.cosmos.implementation.http.HttpRequest;\n+import com.azure.cosmos.implementation.http.HttpResponse;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpMethod;\n+import org.HdrHistogram.ConcurrentDoubleHistogram;\n+import org.HdrHistogram.DoubleHistogram;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+public class ClientTelemetry {\n+    public final static int REQUEST_LATENCY_MAX = 300000000;\n+    public final static int REQUEST_LATENCY_SUCCESS_PRECISION = 4;\n+    public final static int REQUEST_LATENCY_FAILURE_PRECISION = 2;\n+    public final static String REQUEST_LATENCY_NAME = \"RequestLatency\";\n+    public final static String REQUEST_LATENCY_UNIT = \"MicroSec\";\n+\n+    public final static int REQUEST_CHARGE_MAX = 10000;\n+    public final static int REQUEST_CHARGE_PRECISION = 2;\n+    public final static String REQUEST_CHARGE_NAME = \"RequestCharge\";\n+    public final static String REQUEST_CHARGE_UNIT = \"RU\";\n+\n+    public final static int CPU_MAX = 100;\n+    public final static int CPU_PRECISION = 2;\n+    private final static String CPU_NAME = \"CPU\";\n+    private final static String CPU_UNIT = \"Percentage\";\n+\n+    public final static int MEMORY_MAX = 102400;\n+    public final static int MEMORY_PRECISION = 2;\n+    private final static String MEMORY_NAME = \"MemoryRemaining\";\n+    private final static String MEMORY_UNIT = \"MB\";\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+    private ClientTelemetryInfo clientTelemetryInfo;\n+    private HttpClient httpClient;\n+    private final ExecutorService executor = Executors.newSingleThreadExecutor();\n+    private final Scheduler scheduler = Schedulers.fromExecutor(executor);\n+    private static final Logger logger = LoggerFactory.getLogger(GlobalEndpointManager.class);\n+    private volatile boolean isClosed;\n+    private volatile boolean isClientTelemetryEnabled;\n+    private static String AZURE_VM_METADATA = \"http://169.254.169.254:80/metadata/instance?api-version=2020-06-01\";\n+\n+    private static final double PERCENTILE_50 = 50.0;\n+    private static final double PERCENTILE_90 = 90.0;\n+    private static final double PERCENTILE_95 = 95.0;\n+    private static final double PERCENTILE_99 = 99.0;\n+    private static final double PERCENTILE_999 = 99.9;\n+    private final int clientTelemetrySchedulingSec;\n+\n+    public ClientTelemetry(Boolean acceleratedNetworking,\n+                           String clientId,\n+                           String processId,\n+                           String userAgent,\n+                           ConnectionMode connectionMode,\n+                           String globalDatabaseAccountName,\n+                           String applicationRegion,\n+                           String hostEnvInfo,\n+                           HttpClient httpClient,\n+                           boolean isClientTelemetryEnabled\n+    ) {\n+        clientTelemetryInfo = new ClientTelemetryInfo(clientId, processId, userAgent, connectionMode,\n+            globalDatabaseAccountName, applicationRegion, hostEnvInfo, acceleratedNetworking);\n+        this.isClosed = false;\n+        this.httpClient = httpClient;\n+        this.isClientTelemetryEnabled = isClientTelemetryEnabled;\n+        this.clientTelemetrySchedulingSec = Configs.getClientTelemetrySchedulingInSec();\n+    }\n+\n+    public ClientTelemetryInfo getClientTelemetryInfo() {\n+        return clientTelemetryInfo;\n+    }\n+\n+    public static void recordValue(DoubleHistogram doubleHistogram, long value) {\n+        try {\n+            doubleHistogram.recordValue(value);\n+        } catch (Exception ex) {\n+            logger.warn(\"Error while recording value for client telemetry\", ex.getMessage());\n+        }\n+    }\n+\n+    public static void recordValue(DoubleHistogram doubleHistogram, double value) {\n+        try {\n+            doubleHistogram.recordValue(value);\n+        } catch (Exception ex) {\n+            logger.warn(\"Error while recording value for client telemetry\", ex.getMessage());\n+        }\n+    }\n+\n+    public void init() {\n+        loadAzureVmMetaData();\n+        sendClientTelemetry().subscribe();\n+    }\n+\n+    public void close() {\n+        this.isClosed = true;\n+        this.executor.shutdown();\n+        logger.debug(\"GlobalEndpointManager closed.\");\n+    }\n+\n+    private Mono<Void> sendClientTelemetry() {\n+        return Mono.delay(Duration.ofSeconds(clientTelemetrySchedulingSec))\n+            .flatMap(t -> {\n+                if (this.isClosed) {\n+                    logger.warn(\"client already closed\");\n+                    return Mono.empty();\n+                }\n+\n+                if(!Configs.isClientTelemetryEnabled(this.isClientTelemetryEnabled)) {\n+                    logger.trace(\"client telemetry not enabled\");\n+                    return Mono.empty();\n+                }\n+\n+                readHistogram();\n+                try {\n+                    logger.info(\"ClientTelemetry {}\", OBJECT_MAPPER.writeValueAsString(this.clientTelemetryInfo));\n+                } catch (JsonProcessingException e) {\n+                    e.printStackTrace();\n+                }\n+                clearDataForNextRun();\n+                return this.sendClientTelemetry();", "originalCommit": "252850bb53ec1a08ece93613b302abeb547a161b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc1ODc0NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520758745", "bodyText": "This is in line with what we do in GlobalEndpointManager. Also expand is more applicable where we have values in stream and we want to do breath first or depth first recursion. In our case it is mono void.", "author": "simplynaveen20", "createdAt": "2020-11-10T17:55:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI5NTU0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgxMjMxOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520812319", "bodyText": "Makes sense, thanks.", "author": "kushagraThapar", "createdAt": "2020-11-10T19:14:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI5NTU0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI5ODkxMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518298911", "bodyText": "where is that validation happening ?\nMay be worth mentioning here ?\nAlso, how do we plan to validate the keys specially in the set API for percentiles ?", "author": "kushagraThapar", "createdAt": "2020-11-05T19:15:44Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/MetricInfo.java", "diffHunk": "@@ -0,0 +1,77 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class MetricInfo {\n+    private String metricsName;\n+    private String unitName;\n+    private double mean;\n+    private long count;\n+    private double min;\n+    private double max;\n+    private Map<Double, Double> percentiles = new HashMap<>();//strict contract, ,  validation on key required", "originalCommit": "252850bb53ec1a08ece93613b302abeb547a161b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc1OTY0Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520759646", "bodyText": "Removed the comment, it was the leftover from the initial contract discussion, it was more for BE service to validate the contract. Already passed this information to Vignesh", "author": "simplynaveen20", "createdAt": "2020-11-10T17:56:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI5ODkxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM4MzE1Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518383157", "bodyText": "why can't we keep it double?", "author": "kushagraThapar", "createdAt": "2020-11-05T21:36:19Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/cpu/CpuMemoryReader.java", "diffHunk": "@@ -9,44 +9,56 @@\n \n import java.lang.management.ManagementFactory;\n \n-public class CpuReader {\n-    private final static Logger logger = LoggerFactory.getLogger(CpuReader.class);\n+public class CpuMemoryReader {\n+    private final static Logger logger = LoggerFactory.getLogger(CpuMemoryReader.class);\n     private final com.sun.management.OperatingSystemMXBean operatingSystemMXBean;\n \n-    public CpuReader() {\n+    public CpuMemoryReader() {\n         java.lang.management.OperatingSystemMXBean mxBean = null;\n         try {\n             mxBean =\n                 ManagementFactory.getOperatingSystemMXBean();\n         } catch (Throwable t) {\n-            logger.error(\"failed to initialized CpuReader\", t);\n+            logger.error(\"failed to initialized CpuMemoryReader\", t);\n         }\n \n         this.operatingSystemMXBean = tryGetAs(mxBean,\n             com.sun.management.OperatingSystemMXBean.class);\n     }\n \n-    public double getSystemWideCpuUsage() {\n+    public float getSystemWideCpuUsage() {\n         try {\n             if (operatingSystemMXBean != null) {\n-                double val = operatingSystemMXBean.getSystemCpuLoad();\n+                float val = (float) operatingSystemMXBean.getSystemCpuLoad();", "originalCommit": "252850bb53ec1a08ece93613b302abeb547a161b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc2MDI3MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520760271", "bodyText": "We want to keep the size as low as possible, float give 6 to 7 place of decimal value , more than enough for us to measure cpu percentage.", "author": "simplynaveen20", "createdAt": "2020-11-10T17:57:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM4MzE1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM4NDU0NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518384544", "bodyText": "I wonder why we can't keep it double in the client telemetry as well ?", "author": "kushagraThapar", "createdAt": "2020-11-05T21:38:59Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/util/CosmosPagedFlux.java", "diffHunk": "@@ -125,11 +139,103 @@ public void subscribe(CoreSubscriber<? super T> coreSubscriber) {\n                 pagedFluxOptions.getTracerProvider().endSpan(parentContext.get(), Signal.error(throwable),\n                     TracerProvider.ERROR_CODE);\n             }\n+\n+            if (pagedFluxOptions.getCosmosAsyncClient() != null &&\n+                Configs.isClientTelemetryEnabled(BridgeInternal.isClientTelemetryEnabled(pagedFluxOptions.getCosmosAsyncClient())) &&\n+                throwable instanceof CosmosException) {\n+                CosmosException cosmosException = (CosmosException) throwable;\n+                fillClientTelemetry(pagedFluxOptions.getCosmosAsyncClient(), 0, pagedFluxOptions.getContainerId(),\n+                    pagedFluxOptions.getDatabaseId(),\n+                    pagedFluxOptions.getOperationType(), pagedFluxOptions.getResourceType(),\n+                    BridgeInternal.getContextClient(pagedFluxOptions.getCosmosAsyncClient()).getConsistencyLevel(),\n+                    (float) cosmosException.getRequestCharge(), Duration.between(startTime.get(), Instant.now()));", "originalCommit": "252850bb53ec1a08ece93613b302abeb547a161b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc2MDU0OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520760549", "bodyText": "We want to keep the size as low as possible, float give 6 to 7 place of decimal value , more than enough for us to measure request charge.", "author": "simplynaveen20", "createdAt": "2020-11-10T17:58:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM4NDU0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI2MTU5NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r512261595", "bodyText": "why aren't we capturing the exception stacktace?", "author": "moderakh", "createdAt": "2020-10-26T20:54:14Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java", "diffHunk": "@@ -0,0 +1,227 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+import com.azure.cosmos.ConnectionMode;\n+import com.azure.cosmos.implementation.Configs;\n+import com.azure.cosmos.implementation.GlobalEndpointManager;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.cpu.CpuMemoryMonitor;\n+import com.azure.cosmos.implementation.http.HttpClient;\n+import com.azure.cosmos.implementation.http.HttpHeaders;\n+import com.azure.cosmos.implementation.http.HttpRequest;\n+import com.azure.cosmos.implementation.http.HttpResponse;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpMethod;\n+import org.HdrHistogram.DoubleHistogram;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+public class ClientTelemetry {\n+    public final static int REQUEST_LATENCY_MAX = 300000000;\n+    public final static int REQUEST_LATENCY_SUCCESS_PRECISION = 4;\n+    public final static int REQUEST_LATENCY_FAILURE_PRECISION = 2;\n+    public final static String REQUEST_LATENCY_NAME = \"RequestLatency\";\n+    public final static String REQUEST_LATENCY_UNIT = \"MicroSec\";\n+\n+    public final static int REQUEST_CHARGE_MAX = 10000;\n+    public final static int REQUEST_CHARGE_PRECISION = 2;\n+    public final static String REQUEST_CHARGE_NAME = \"RequestCharge\";\n+    public final static String REQUEST_CHARGE_UNIT = \"RU\";\n+\n+    public final static int CPU_MAX = 100;\n+    public final static int CPU_PRECISION = 2;\n+    private final static String CPU_NAME = \"CPU\";\n+    private final static String CPU_UNIT = \"Percentage\";\n+\n+    public final static int MEMORY_MAX = 102400;\n+    public final static int MEMORY_PRECISION = 2;\n+    private final static String MEMORY_NAME = \"MemoryRemaining\";\n+    private final static String MEMORY_UNIT = \"MB\";\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+    private ClientTelemetryInfo clientTelemetryInfo;\n+    private HttpClient httpClient;\n+    private final ExecutorService executor = Executors.newSingleThreadExecutor();\n+    private final Scheduler scheduler = Schedulers.fromExecutor(executor);\n+    private static final Logger logger = LoggerFactory.getLogger(GlobalEndpointManager.class);\n+    private volatile boolean isClosed;\n+    private volatile boolean isClientTelemetryEnabled;\n+    private static String AZURE_VM_METADATA = \"http://169.254.169.254:80/metadata/instance?api-version=2020-06-01\";\n+\n+    private static final double PERCENTILE_50 = 50.0;\n+    private static final double PERCENTILE_90 = 90.0;\n+    private static final double PERCENTILE_95 = 95.0;\n+    private static final double PERCENTILE_99 = 99.0;\n+    private static final double PERCENTILE_999 = 99.9;\n+    private final int clientTelemetrySchedulingSec;\n+\n+    public ClientTelemetry(Boolean acceleratedNetworking,\n+                           String clientId,\n+                           String processId,\n+                           String userAgent,\n+                           ConnectionMode connectionMode,\n+                           String globalDatabaseAccountName,\n+                           String applicationRegion,\n+                           String hostEnvInfo,\n+                           HttpClient httpClient,\n+                           boolean isClientTelemetryEnabled\n+    ) {\n+        clientTelemetryInfo = new ClientTelemetryInfo(clientId, processId, userAgent, connectionMode,\n+            globalDatabaseAccountName, applicationRegion, hostEnvInfo, acceleratedNetworking);\n+        this.isClosed = false;\n+        this.httpClient = httpClient;\n+        this.isClientTelemetryEnabled = isClientTelemetryEnabled;\n+        this.clientTelemetrySchedulingSec = Configs.getClientTelemetrySchedulingInSec();\n+    }\n+\n+    public ClientTelemetryInfo getClientTelemetryInfo() {\n+        return clientTelemetryInfo;\n+    }\n+\n+    public static void recordValue(DoubleHistogram doubleHistogram, long value) {\n+        try {\n+            doubleHistogram.recordValue(value);\n+        } catch (Exception ex) {\n+            logger.warn(\"Error while recording value for client telemetry\", ex.getMessage());", "originalCommit": "f96b243b10963f2e18fd0bf0ec99550897a6bfae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc2Mzk5Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520763997", "bodyText": "done", "author": "simplynaveen20", "createdAt": "2020-11-10T18:03:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI2MTU5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI2MTY4MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r512261680", "bodyText": "ditto", "author": "moderakh", "createdAt": "2020-10-26T20:54:21Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java", "diffHunk": "@@ -0,0 +1,227 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+import com.azure.cosmos.ConnectionMode;\n+import com.azure.cosmos.implementation.Configs;\n+import com.azure.cosmos.implementation.GlobalEndpointManager;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.cpu.CpuMemoryMonitor;\n+import com.azure.cosmos.implementation.http.HttpClient;\n+import com.azure.cosmos.implementation.http.HttpHeaders;\n+import com.azure.cosmos.implementation.http.HttpRequest;\n+import com.azure.cosmos.implementation.http.HttpResponse;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpMethod;\n+import org.HdrHistogram.DoubleHistogram;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+public class ClientTelemetry {\n+    public final static int REQUEST_LATENCY_MAX = 300000000;\n+    public final static int REQUEST_LATENCY_SUCCESS_PRECISION = 4;\n+    public final static int REQUEST_LATENCY_FAILURE_PRECISION = 2;\n+    public final static String REQUEST_LATENCY_NAME = \"RequestLatency\";\n+    public final static String REQUEST_LATENCY_UNIT = \"MicroSec\";\n+\n+    public final static int REQUEST_CHARGE_MAX = 10000;\n+    public final static int REQUEST_CHARGE_PRECISION = 2;\n+    public final static String REQUEST_CHARGE_NAME = \"RequestCharge\";\n+    public final static String REQUEST_CHARGE_UNIT = \"RU\";\n+\n+    public final static int CPU_MAX = 100;\n+    public final static int CPU_PRECISION = 2;\n+    private final static String CPU_NAME = \"CPU\";\n+    private final static String CPU_UNIT = \"Percentage\";\n+\n+    public final static int MEMORY_MAX = 102400;\n+    public final static int MEMORY_PRECISION = 2;\n+    private final static String MEMORY_NAME = \"MemoryRemaining\";\n+    private final static String MEMORY_UNIT = \"MB\";\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+    private ClientTelemetryInfo clientTelemetryInfo;\n+    private HttpClient httpClient;\n+    private final ExecutorService executor = Executors.newSingleThreadExecutor();\n+    private final Scheduler scheduler = Schedulers.fromExecutor(executor);\n+    private static final Logger logger = LoggerFactory.getLogger(GlobalEndpointManager.class);\n+    private volatile boolean isClosed;\n+    private volatile boolean isClientTelemetryEnabled;\n+    private static String AZURE_VM_METADATA = \"http://169.254.169.254:80/metadata/instance?api-version=2020-06-01\";\n+\n+    private static final double PERCENTILE_50 = 50.0;\n+    private static final double PERCENTILE_90 = 90.0;\n+    private static final double PERCENTILE_95 = 95.0;\n+    private static final double PERCENTILE_99 = 99.0;\n+    private static final double PERCENTILE_999 = 99.9;\n+    private final int clientTelemetrySchedulingSec;\n+\n+    public ClientTelemetry(Boolean acceleratedNetworking,\n+                           String clientId,\n+                           String processId,\n+                           String userAgent,\n+                           ConnectionMode connectionMode,\n+                           String globalDatabaseAccountName,\n+                           String applicationRegion,\n+                           String hostEnvInfo,\n+                           HttpClient httpClient,\n+                           boolean isClientTelemetryEnabled\n+    ) {\n+        clientTelemetryInfo = new ClientTelemetryInfo(clientId, processId, userAgent, connectionMode,\n+            globalDatabaseAccountName, applicationRegion, hostEnvInfo, acceleratedNetworking);\n+        this.isClosed = false;\n+        this.httpClient = httpClient;\n+        this.isClientTelemetryEnabled = isClientTelemetryEnabled;\n+        this.clientTelemetrySchedulingSec = Configs.getClientTelemetrySchedulingInSec();\n+    }\n+\n+    public ClientTelemetryInfo getClientTelemetryInfo() {\n+        return clientTelemetryInfo;\n+    }\n+\n+    public static void recordValue(DoubleHistogram doubleHistogram, long value) {\n+        try {\n+            doubleHistogram.recordValue(value);\n+        } catch (Exception ex) {\n+            logger.warn(\"Error while recording value for client telemetry\", ex.getMessage());\n+        }\n+    }\n+\n+    public static void recordValue(DoubleHistogram doubleHistogram, double value) {\n+        try {\n+            doubleHistogram.recordValue(value);\n+        } catch (Exception ex) {\n+            logger.warn(\"Error while recording value for client telemetry\", ex.getMessage());", "originalCommit": "f96b243b10963f2e18fd0bf0ec99550897a6bfae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc2Mzg4MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520763881", "bodyText": "done", "author": "simplynaveen20", "createdAt": "2020-11-10T18:03:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI2MTY4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI2MzY0OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r512263648", "bodyText": "you are capturing the exception message twice.", "author": "moderakh", "createdAt": "2020-10-26T20:57:54Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java", "diffHunk": "@@ -0,0 +1,227 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+import com.azure.cosmos.ConnectionMode;\n+import com.azure.cosmos.implementation.Configs;\n+import com.azure.cosmos.implementation.GlobalEndpointManager;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.cpu.CpuMemoryMonitor;\n+import com.azure.cosmos.implementation.http.HttpClient;\n+import com.azure.cosmos.implementation.http.HttpHeaders;\n+import com.azure.cosmos.implementation.http.HttpRequest;\n+import com.azure.cosmos.implementation.http.HttpResponse;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpMethod;\n+import org.HdrHistogram.DoubleHistogram;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+public class ClientTelemetry {\n+    public final static int REQUEST_LATENCY_MAX = 300000000;\n+    public final static int REQUEST_LATENCY_SUCCESS_PRECISION = 4;\n+    public final static int REQUEST_LATENCY_FAILURE_PRECISION = 2;\n+    public final static String REQUEST_LATENCY_NAME = \"RequestLatency\";\n+    public final static String REQUEST_LATENCY_UNIT = \"MicroSec\";\n+\n+    public final static int REQUEST_CHARGE_MAX = 10000;\n+    public final static int REQUEST_CHARGE_PRECISION = 2;\n+    public final static String REQUEST_CHARGE_NAME = \"RequestCharge\";\n+    public final static String REQUEST_CHARGE_UNIT = \"RU\";\n+\n+    public final static int CPU_MAX = 100;\n+    public final static int CPU_PRECISION = 2;\n+    private final static String CPU_NAME = \"CPU\";\n+    private final static String CPU_UNIT = \"Percentage\";\n+\n+    public final static int MEMORY_MAX = 102400;\n+    public final static int MEMORY_PRECISION = 2;\n+    private final static String MEMORY_NAME = \"MemoryRemaining\";\n+    private final static String MEMORY_UNIT = \"MB\";\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+    private ClientTelemetryInfo clientTelemetryInfo;\n+    private HttpClient httpClient;\n+    private final ExecutorService executor = Executors.newSingleThreadExecutor();\n+    private final Scheduler scheduler = Schedulers.fromExecutor(executor);\n+    private static final Logger logger = LoggerFactory.getLogger(GlobalEndpointManager.class);\n+    private volatile boolean isClosed;\n+    private volatile boolean isClientTelemetryEnabled;\n+    private static String AZURE_VM_METADATA = \"http://169.254.169.254:80/metadata/instance?api-version=2020-06-01\";\n+\n+    private static final double PERCENTILE_50 = 50.0;\n+    private static final double PERCENTILE_90 = 90.0;\n+    private static final double PERCENTILE_95 = 95.0;\n+    private static final double PERCENTILE_99 = 99.0;\n+    private static final double PERCENTILE_999 = 99.9;\n+    private final int clientTelemetrySchedulingSec;\n+\n+    public ClientTelemetry(Boolean acceleratedNetworking,\n+                           String clientId,\n+                           String processId,\n+                           String userAgent,\n+                           ConnectionMode connectionMode,\n+                           String globalDatabaseAccountName,\n+                           String applicationRegion,\n+                           String hostEnvInfo,\n+                           HttpClient httpClient,\n+                           boolean isClientTelemetryEnabled\n+    ) {\n+        clientTelemetryInfo = new ClientTelemetryInfo(clientId, processId, userAgent, connectionMode,\n+            globalDatabaseAccountName, applicationRegion, hostEnvInfo, acceleratedNetworking);\n+        this.isClosed = false;\n+        this.httpClient = httpClient;\n+        this.isClientTelemetryEnabled = isClientTelemetryEnabled;\n+        this.clientTelemetrySchedulingSec = Configs.getClientTelemetrySchedulingInSec();\n+    }\n+\n+    public ClientTelemetryInfo getClientTelemetryInfo() {\n+        return clientTelemetryInfo;\n+    }\n+\n+    public static void recordValue(DoubleHistogram doubleHistogram, long value) {\n+        try {\n+            doubleHistogram.recordValue(value);\n+        } catch (Exception ex) {\n+            logger.warn(\"Error while recording value for client telemetry\", ex.getMessage());\n+        }\n+    }\n+\n+    public static void recordValue(DoubleHistogram doubleHistogram, double value) {\n+        try {\n+            doubleHistogram.recordValue(value);\n+        } catch (Exception ex) {\n+            logger.warn(\"Error while recording value for client telemetry\", ex.getMessage());\n+        }\n+    }\n+\n+    public void init() {\n+        loadAzureVmMetaData();\n+        sendClientTelemetry().subscribe();\n+    }\n+\n+    public void close() {\n+        this.isClosed = true;\n+        this.executor.shutdown();\n+        logger.debug(\"GlobalEndpointManager closed.\");\n+    }\n+\n+    private Mono<Void> sendClientTelemetry() {\n+        return Mono.delay(Duration.ofSeconds(clientTelemetrySchedulingSec))\n+            .flatMap(t -> {\n+                if (this.isClosed) {\n+                    logger.warn(\"client already closed\");\n+                    return Mono.empty();\n+                }\n+\n+                if(!Configs.isClientTelemetryEnabled(this.isClientTelemetryEnabled)) {\n+                    logger.trace(\"client telemetry not enabled\");\n+                    return Mono.empty();\n+                }\n+\n+                readHistogram();\n+                try {\n+                    logger.info(\"ClientTelemetry {}\", OBJECT_MAPPER.writeValueAsString(this.clientTelemetryInfo));\n+                } catch (JsonProcessingException e) {\n+                    e.printStackTrace();\n+                }\n+                clearDataForNextRun();\n+                return this.sendClientTelemetry();\n+            }).onErrorResume(ex -> {\n+                logger.error(\"sendClientTelemetry() - Unable to send client telemetry\" +\n+                    \". Exception: {}\", ex.toString(), ex);", "originalCommit": "f96b243b10963f2e18fd0bf0ec99550897a6bfae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc2Mzc0Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520763742", "bodyText": "removed extra message", "author": "simplynaveen20", "createdAt": "2020-11-10T18:03:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjI2MzY0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ1NzUyMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518457521", "bodyText": "is this accessed from multiple threads?", "author": "moderakh", "createdAt": "2020-11-06T00:46:02Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/MetricInfo.java", "diffHunk": "@@ -0,0 +1,77 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class MetricInfo {\n+    private String metricsName;\n+    private String unitName;\n+    private double mean;\n+    private long count;\n+    private double min;\n+    private double max;\n+    private Map<Double, Double> percentiles = new HashMap<>();//strict contract, ,  validation on key required", "originalCommit": "252850bb53ec1a08ece93613b302abeb547a161b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc2MzU4Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520763582", "bodyText": "removed the object creation from here. This is getting created in a single thread every 10 min in client telemetry, so we don't need concurrency.", "author": "simplynaveen20", "createdAt": "2020-11-10T18:02:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ1NzUyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ1ODEwMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518458103", "bodyText": "please use log instead of e.printSTackTrace", "author": "moderakh", "createdAt": "2020-11-06T00:47:50Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java", "diffHunk": "@@ -0,0 +1,230 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+import com.azure.cosmos.ConnectionMode;\n+import com.azure.cosmos.implementation.Configs;\n+import com.azure.cosmos.implementation.GlobalEndpointManager;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.cpu.CpuMemoryMonitor;\n+import com.azure.cosmos.implementation.http.HttpClient;\n+import com.azure.cosmos.implementation.http.HttpHeaders;\n+import com.azure.cosmos.implementation.http.HttpRequest;\n+import com.azure.cosmos.implementation.http.HttpResponse;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpMethod;\n+import org.HdrHistogram.ConcurrentDoubleHistogram;\n+import org.HdrHistogram.DoubleHistogram;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+public class ClientTelemetry {\n+    public final static int REQUEST_LATENCY_MAX = 300000000;\n+    public final static int REQUEST_LATENCY_SUCCESS_PRECISION = 4;\n+    public final static int REQUEST_LATENCY_FAILURE_PRECISION = 2;\n+    public final static String REQUEST_LATENCY_NAME = \"RequestLatency\";\n+    public final static String REQUEST_LATENCY_UNIT = \"MicroSec\";\n+\n+    public final static int REQUEST_CHARGE_MAX = 10000;\n+    public final static int REQUEST_CHARGE_PRECISION = 2;\n+    public final static String REQUEST_CHARGE_NAME = \"RequestCharge\";\n+    public final static String REQUEST_CHARGE_UNIT = \"RU\";\n+\n+    public final static int CPU_MAX = 100;\n+    public final static int CPU_PRECISION = 2;\n+    private final static String CPU_NAME = \"CPU\";\n+    private final static String CPU_UNIT = \"Percentage\";\n+\n+    public final static int MEMORY_MAX = 102400;\n+    public final static int MEMORY_PRECISION = 2;\n+    private final static String MEMORY_NAME = \"MemoryRemaining\";\n+    private final static String MEMORY_UNIT = \"MB\";\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+    private ClientTelemetryInfo clientTelemetryInfo;\n+    private HttpClient httpClient;\n+    private final ExecutorService executor = Executors.newSingleThreadExecutor();\n+    private final Scheduler scheduler = Schedulers.fromExecutor(executor);\n+    private static final Logger logger = LoggerFactory.getLogger(GlobalEndpointManager.class);\n+    private volatile boolean isClosed;\n+    private volatile boolean isClientTelemetryEnabled;\n+    private static String AZURE_VM_METADATA = \"http://169.254.169.254:80/metadata/instance?api-version=2020-06-01\";\n+\n+    private static final double PERCENTILE_50 = 50.0;\n+    private static final double PERCENTILE_90 = 90.0;\n+    private static final double PERCENTILE_95 = 95.0;\n+    private static final double PERCENTILE_99 = 99.0;\n+    private static final double PERCENTILE_999 = 99.9;\n+    private final int clientTelemetrySchedulingSec;\n+\n+    public ClientTelemetry(Boolean acceleratedNetworking,\n+                           String clientId,\n+                           String processId,\n+                           String userAgent,\n+                           ConnectionMode connectionMode,\n+                           String globalDatabaseAccountName,\n+                           String applicationRegion,\n+                           String hostEnvInfo,\n+                           HttpClient httpClient,\n+                           boolean isClientTelemetryEnabled\n+    ) {\n+        clientTelemetryInfo = new ClientTelemetryInfo(clientId, processId, userAgent, connectionMode,\n+            globalDatabaseAccountName, applicationRegion, hostEnvInfo, acceleratedNetworking);\n+        this.isClosed = false;\n+        this.httpClient = httpClient;\n+        this.isClientTelemetryEnabled = isClientTelemetryEnabled;\n+        this.clientTelemetrySchedulingSec = Configs.getClientTelemetrySchedulingInSec();\n+    }\n+\n+    public ClientTelemetryInfo getClientTelemetryInfo() {\n+        return clientTelemetryInfo;\n+    }\n+\n+    public static void recordValue(DoubleHistogram doubleHistogram, long value) {\n+        try {\n+            doubleHistogram.recordValue(value);\n+        } catch (Exception ex) {\n+            logger.warn(\"Error while recording value for client telemetry\", ex.getMessage());\n+        }\n+    }\n+\n+    public static void recordValue(DoubleHistogram doubleHistogram, double value) {\n+        try {\n+            doubleHistogram.recordValue(value);\n+        } catch (Exception ex) {\n+            logger.warn(\"Error while recording value for client telemetry\", ex.getMessage());\n+        }\n+    }\n+\n+    public void init() {\n+        loadAzureVmMetaData();\n+        sendClientTelemetry().subscribe();\n+    }\n+\n+    public void close() {\n+        this.isClosed = true;\n+        this.executor.shutdown();\n+        logger.debug(\"GlobalEndpointManager closed.\");\n+    }\n+\n+    private Mono<Void> sendClientTelemetry() {\n+        return Mono.delay(Duration.ofSeconds(clientTelemetrySchedulingSec))\n+            .flatMap(t -> {\n+                if (this.isClosed) {\n+                    logger.warn(\"client already closed\");\n+                    return Mono.empty();\n+                }\n+\n+                if(!Configs.isClientTelemetryEnabled(this.isClientTelemetryEnabled)) {\n+                    logger.trace(\"client telemetry not enabled\");\n+                    return Mono.empty();\n+                }\n+\n+                readHistogram();\n+                try {\n+                    logger.info(\"ClientTelemetry {}\", OBJECT_MAPPER.writeValueAsString(this.clientTelemetryInfo));\n+                } catch (JsonProcessingException e) {\n+                    e.printStackTrace();", "originalCommit": "252850bb53ec1a08ece93613b302abeb547a161b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc2MjEwNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520762104", "bodyText": "done", "author": "simplynaveen20", "createdAt": "2020-11-10T18:00:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ1ODEwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ1ODY0NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518458644", "bodyText": "ideally we should use daemon threads otherwise if executor is not shutdown correctly JVM will not terminate.\nTake a look at how rntbd sets up its daemon IO threads.", "author": "moderakh", "createdAt": "2020-11-06T00:49:42Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/ClientTelemetry.java", "diffHunk": "@@ -0,0 +1,230 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+import com.azure.cosmos.ConnectionMode;\n+import com.azure.cosmos.implementation.Configs;\n+import com.azure.cosmos.implementation.GlobalEndpointManager;\n+import com.azure.cosmos.implementation.Utils;\n+import com.azure.cosmos.implementation.cpu.CpuMemoryMonitor;\n+import com.azure.cosmos.implementation.http.HttpClient;\n+import com.azure.cosmos.implementation.http.HttpHeaders;\n+import com.azure.cosmos.implementation.http.HttpRequest;\n+import com.azure.cosmos.implementation.http.HttpResponse;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import io.netty.handler.codec.http.HttpMethod;\n+import org.HdrHistogram.ConcurrentDoubleHistogram;\n+import org.HdrHistogram.DoubleHistogram;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+public class ClientTelemetry {\n+    public final static int REQUEST_LATENCY_MAX = 300000000;\n+    public final static int REQUEST_LATENCY_SUCCESS_PRECISION = 4;\n+    public final static int REQUEST_LATENCY_FAILURE_PRECISION = 2;\n+    public final static String REQUEST_LATENCY_NAME = \"RequestLatency\";\n+    public final static String REQUEST_LATENCY_UNIT = \"MicroSec\";\n+\n+    public final static int REQUEST_CHARGE_MAX = 10000;\n+    public final static int REQUEST_CHARGE_PRECISION = 2;\n+    public final static String REQUEST_CHARGE_NAME = \"RequestCharge\";\n+    public final static String REQUEST_CHARGE_UNIT = \"RU\";\n+\n+    public final static int CPU_MAX = 100;\n+    public final static int CPU_PRECISION = 2;\n+    private final static String CPU_NAME = \"CPU\";\n+    private final static String CPU_UNIT = \"Percentage\";\n+\n+    public final static int MEMORY_MAX = 102400;\n+    public final static int MEMORY_PRECISION = 2;\n+    private final static String MEMORY_NAME = \"MemoryRemaining\";\n+    private final static String MEMORY_UNIT = \"MB\";\n+\n+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+    private ClientTelemetryInfo clientTelemetryInfo;\n+    private HttpClient httpClient;\n+    private final ExecutorService executor = Executors.newSingleThreadExecutor();", "originalCommit": "252850bb53ec1a08ece93613b302abeb547a161b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc2MTk4OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520761988", "bodyText": "done", "author": "simplynaveen20", "createdAt": "2020-11-10T18:00:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ1ODY0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ1OTAxNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r518459015", "bodyText": "constant?", "author": "moderakh", "createdAt": "2020-11-06T00:50:55Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -153,11 +171,117 @@ public Context startSpan(String methodName, String databaseId, String endpoint,\n             });\n     }\n \n+    private <T> Mono<T> publisherWithClientTelemetry(Mono<T> resultPublisher,\n+                                                     Context context,\n+                                                     String spanName,\n+                                                     String containerId,\n+                                                     String databaseId,\n+                                                     String endpoint,\n+                                                     CosmosAsyncClient client,\n+                                                     ConsistencyLevel consistencyLevel,\n+                                                     OperationType operationType,\n+                                                     ResourceType resourceType,\n+                                                     Function<T, Integer> statusCodeFunc) {\n+        Mono<T> tracerMono = traceEnabledPublisher(resultPublisher, context, spanName, databaseId, endpoint, statusCodeFunc);\n+        return tracerMono\n+            .doOnSuccess(response -> {\n+                if (Configs.isClientTelemetryEnabled(BridgeInternal.isClientTelemetryEnabled(client)) && response instanceof CosmosItemResponse) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    CosmosItemResponse<T> itemResponse = (CosmosItemResponse<T>) response;\n+                    fillClientTelemetry(client, itemResponse.getDiagnostics(), itemResponse.getStatusCode(),\n+                        ModelBridgeInternal.getPayloadLength(itemResponse), containerId,\n+                        databaseId, operationType, resourceType, consistencyLevel,\n+                        (float) itemResponse.getRequestCharge());\n+                }\n+            }).doOnError(throwable -> {\n+                if (Configs.isClientTelemetryEnabled(BridgeInternal.isClientTelemetryEnabled(client)) && throwable instanceof CosmosException) {\n+                    CosmosException cosmosException = (CosmosException) throwable;\n+                    fillClientTelemetry(client, cosmosException.getDiagnostics(), cosmosException.getStatusCode(),\n+                        null, containerId,\n+                        databaseId, operationType, resourceType, consistencyLevel,\n+                        (float) cosmosException.getRequestCharge());\n+                }\n+            });\n+    }\n+\n     private void end(int statusCode, Throwable throwable, Context context) {\n         if (throwable != null) {\n             tracer.setAttribute(TracerProvider.ERROR_MSG, throwable.getMessage(), context);\n             tracer.setAttribute(TracerProvider.ERROR_TYPE, throwable.getClass().getName(), context);\n         }\n         tracer.end(statusCode, throwable, context);\n     }\n+\n+    public void fillClientTelemetry(CosmosAsyncClient cosmosAsyncClient,\n+                                    CosmosDiagnostics cosmosDiagnostics,\n+                                    int statusCode,\n+                                    Integer objectSize,\n+                                    String containerId,\n+                                    String databaseId,\n+                                    OperationType operationType,\n+                                    ResourceType resourceType,\n+                                    ConsistencyLevel consistencyLevel,\n+                                    float requestCharge) {\n+        ClientTelemetry telemetry = BridgeInternal.getContextClient(cosmosAsyncClient).getClientTelemetry();\n+        ReportPayload reportPayloadLatency = createReportPayload(cosmosAsyncClient, cosmosDiagnostics,\n+            statusCode, objectSize, containerId, databaseId\n+            , operationType, resourceType, consistencyLevel, ClientTelemetry.REQUEST_LATENCY_NAME,\n+            ClientTelemetry.REQUEST_LATENCY_UNIT);\n+        ConcurrentDoubleHistogram latencyHistogram = telemetry.getClientTelemetryInfo().getOperationInfoMap().get(reportPayloadLatency);\n+        if (latencyHistogram != null) {\n+            ClientTelemetry.recordValue(latencyHistogram, cosmosDiagnostics.getDuration().toNanos()/1000);\n+        } else {\n+            if (statusCode == HttpConstants.StatusCodes.OK || statusCode == HttpConstants.StatusCodes.CREATED) {\n+                latencyHistogram = new ConcurrentDoubleHistogram(ClientTelemetry.REQUEST_LATENCY_MAX, ClientTelemetry.REQUEST_LATENCY_SUCCESS_PRECISION);\n+            } else {\n+                latencyHistogram = new ConcurrentDoubleHistogram(ClientTelemetry.REQUEST_LATENCY_MAX, ClientTelemetry.REQUEST_LATENCY_FAILURE_PRECISION);\n+            }\n+\n+            latencyHistogram.setAutoResize(true);\n+            ClientTelemetry.recordValue(latencyHistogram, cosmosDiagnostics.getDuration().toNanos()/1000);\n+            telemetry.getClientTelemetryInfo().getOperationInfoMap().put(reportPayloadLatency, latencyHistogram);\n+        }\n+\n+        ReportPayload reportPayloadRequestCharge = createReportPayload(cosmosAsyncClient, cosmosDiagnostics,\n+            statusCode, objectSize, containerId, databaseId\n+            , operationType, resourceType, consistencyLevel, ClientTelemetry.REQUEST_CHARGE_NAME, ClientTelemetry.REQUEST_CHARGE_UNIT);\n+        ConcurrentDoubleHistogram requestChargeHistogram = telemetry.getClientTelemetryInfo().getOperationInfoMap().get(reportPayloadRequestCharge);\n+        if (requestChargeHistogram != null) {\n+            ClientTelemetry.recordValue(requestChargeHistogram, requestCharge);\n+        } else {\n+            requestChargeHistogram = new ConcurrentDoubleHistogram(ClientTelemetry.REQUEST_CHARGE_MAX, ClientTelemetry.REQUEST_CHARGE_PRECISION);\n+            requestChargeHistogram.setAutoResize(true);\n+            ClientTelemetry.recordValue(requestChargeHistogram, requestCharge);\n+            telemetry.getClientTelemetryInfo().getOperationInfoMap().put(reportPayloadRequestCharge,\n+                requestChargeHistogram);\n+        }\n+    }\n+\n+    private ReportPayload createReportPayload(CosmosAsyncClient cosmosAsyncClient,\n+                                              CosmosDiagnostics cosmosDiagnostics,\n+                                              int statusCode,\n+                                              Integer objectSize,\n+                                              String containerId,\n+                                              String databaseId,\n+                                              OperationType operationType,\n+                                              ResourceType resourceType,\n+                                              ConsistencyLevel consistencyLevel,\n+                                              String metricsName,\n+                                              String unitName) {\n+        ReportPayload reportPayload = new ReportPayload(metricsName, unitName);\n+        reportPayload.setRegionsContacted(BridgeInternal.getRegionContacted(cosmosDiagnostics).toString());\n+        reportPayload.setConsistency(consistencyLevel == null ?\n+            BridgeInternal.getContextClient(cosmosAsyncClient).getConsistencyLevel() :\n+            consistencyLevel);\n+        if (objectSize != null) {\n+            reportPayload.setGreaterThan1Kb(objectSize > 1024);", "originalCommit": "252850bb53ec1a08ece93613b302abeb547a161b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc2MTkyMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520761920", "bodyText": "done", "author": "simplynaveen20", "createdAt": "2020-11-10T18:00:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQ1OTAxNQ=="}], "type": "inlineReview"}, {"oid": "80b2d75f73f2058994b5e1b5608f5a6da9438340", "url": "https://github.com/Azure/azure-sdk-for-java/commit/80b2d75f73f2058994b5e1b5608f5a6da9438340", "message": "Merge branch 'latest-master' into users/nakumar/clientTelemetry", "committedDate": "2020-11-10T17:32:49Z", "type": "commit"}, {"oid": "e5af7f8436afff8ba02cbfde6f4cdb3bf2f237cf", "url": "https://github.com/Azure/azure-sdk-for-java/commit/e5af7f8436afff8ba02cbfde6f4cdb3bf2f237cf", "message": "resolving comments and merge with latest", "committedDate": "2020-11-10T17:40:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkxNTY1Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520915653", "bodyText": "Should be getRegionsContacted?", "author": "FabianMeiswinkel", "createdAt": "2020-11-10T22:30:37Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/BridgeInternal.java", "diffHunk": "@@ -70,6 +73,26 @@ public static CosmosDiagnostics createCosmosDiagnostics(DiagnosticsClientContext\n         return new CosmosDiagnostics(diagnosticsClientContext);\n     }\n \n+    @Warning(value = INTERNAL_USE_ONLY_WARNING)\n+    public static Set<URI> getRegionContacted(CosmosDiagnostics cosmosDiagnostics) {", "originalCommit": "e5af7f8436afff8ba02cbfde6f4cdb3bf2f237cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA0NDM2NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r523044365", "bodyText": "Done", "author": "simplynaveen20", "createdAt": "2020-11-13T16:00:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkxNTY1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkyMzM0NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520923344", "bodyText": "300 instead - to stick with 5 minutes which we used everywhere else? We can adjust if needed - but why not start with the default that works reasonably well in other places?", "author": "FabianMeiswinkel", "createdAt": "2020-11-10T22:47:52Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/Configs.java", "diffHunk": "@@ -41,7 +41,10 @@\n     private static final String HTTP_RESPONSE_TIMEOUT_IN_SECONDS = \"COSMOS.HTTP_RESPONSE_TIMEOUT_IN_SECONDS\";\n     private static final String QUERY_PLAN_RESPONSE_TIMEOUT_IN_SECONDS = \"COSMOS.QUERY_PLAN_RESPONSE_TIMEOUT_IN_SECONDS\";\n     private static final String ADDRESS_REFRESH_RESPONSE_TIMEOUT_IN_SECONDS = \"COSMOS.ADDRESS_REFRESH_RESPONSE_TIMEOUT_IN_SECONDS\";\n+    private static final String CLIENT_TELEMETRY_ENABLED = \"COSMOS.CLIENT_TELEMETRY_ENABLED\";\n+    private static final String CLIENT_TELEMETRY_SCHEDULING_IN_SECONDS = \"COSMOS.CLIENT_TELEMETRY_SCHEDULING_IN_SECONDS\";\n \n+    private static final int DEFAULT_CLIENT_TELEMETRY_SCHEDULING_IN_SECONDS = 10 * 60;", "originalCommit": "e5af7f8436afff8ba02cbfde6f4cdb3bf2f237cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA0NDI0NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r523044244", "bodyText": "Discussed offline, will go with 10 minutes , and eventually will move to 5 min when we have answer where will be the endpoint", "author": "simplynaveen20", "createdAt": "2020-11-13T16:00:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkyMzM0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkyNTcwOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520925708", "bodyText": "I think the right groups here are\n200 - 299 --> success\n400 - 499 --> client_failure\n\n= 500 --> service failure", "author": "FabianMeiswinkel", "createdAt": "2020-11-10T22:53:22Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -153,11 +171,117 @@ public Context startSpan(String methodName, String databaseId, String endpoint,\n             });\n     }\n \n+    private <T> Mono<T> publisherWithClientTelemetry(Mono<T> resultPublisher,\n+                                                     Context context,\n+                                                     String spanName,\n+                                                     String containerId,\n+                                                     String databaseId,\n+                                                     String endpoint,\n+                                                     CosmosAsyncClient client,\n+                                                     ConsistencyLevel consistencyLevel,\n+                                                     OperationType operationType,\n+                                                     ResourceType resourceType,\n+                                                     Function<T, Integer> statusCodeFunc) {\n+        Mono<T> tracerMono = traceEnabledPublisher(resultPublisher, context, spanName, databaseId, endpoint, statusCodeFunc);\n+        return tracerMono\n+            .doOnSuccess(response -> {\n+                if (Configs.isClientTelemetryEnabled(BridgeInternal.isClientTelemetryEnabled(client)) && response instanceof CosmosItemResponse) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    CosmosItemResponse<T> itemResponse = (CosmosItemResponse<T>) response;\n+                    fillClientTelemetry(client, itemResponse.getDiagnostics(), itemResponse.getStatusCode(),\n+                        ModelBridgeInternal.getPayloadLength(itemResponse), containerId,\n+                        databaseId, operationType, resourceType, consistencyLevel,\n+                        (float) itemResponse.getRequestCharge());\n+                }\n+            }).doOnError(throwable -> {\n+                if (Configs.isClientTelemetryEnabled(BridgeInternal.isClientTelemetryEnabled(client)) && throwable instanceof CosmosException) {\n+                    CosmosException cosmosException = (CosmosException) throwable;\n+                    fillClientTelemetry(client, cosmosException.getDiagnostics(), cosmosException.getStatusCode(),\n+                        null, containerId,\n+                        databaseId, operationType, resourceType, consistencyLevel,\n+                        (float) cosmosException.getRequestCharge());\n+                }\n+            });\n+    }\n+\n     private void end(int statusCode, Throwable throwable, Context context) {\n         if (throwable != null) {\n             tracer.setAttribute(TracerProvider.ERROR_MSG, throwable.getMessage(), context);\n             tracer.setAttribute(TracerProvider.ERROR_TYPE, throwable.getClass().getName(), context);\n         }\n         tracer.end(statusCode, throwable, context);\n     }\n+\n+    public void fillClientTelemetry(CosmosAsyncClient cosmosAsyncClient,\n+                                    CosmosDiagnostics cosmosDiagnostics,\n+                                    int statusCode,\n+                                    Integer objectSize,\n+                                    String containerId,\n+                                    String databaseId,\n+                                    OperationType operationType,\n+                                    ResourceType resourceType,\n+                                    ConsistencyLevel consistencyLevel,\n+                                    float requestCharge) {\n+        ClientTelemetry telemetry = BridgeInternal.getContextClient(cosmosAsyncClient).getClientTelemetry();\n+        ReportPayload reportPayloadLatency = createReportPayload(cosmosAsyncClient, cosmosDiagnostics,\n+            statusCode, objectSize, containerId, databaseId\n+            , operationType, resourceType, consistencyLevel, ClientTelemetry.REQUEST_LATENCY_NAME,\n+            ClientTelemetry.REQUEST_LATENCY_UNIT);\n+        ConcurrentDoubleHistogram latencyHistogram = telemetry.getClientTelemetryInfo().getOperationInfoMap().get(reportPayloadLatency);\n+        if (latencyHistogram != null) {\n+            ClientTelemetry.recordValue(latencyHistogram, cosmosDiagnostics.getDuration().toNanos()/1000);\n+        } else {\n+            if (statusCode == HttpConstants.StatusCodes.OK || statusCode == HttpConstants.StatusCodes.CREATED) {\n+                latencyHistogram = new ConcurrentDoubleHistogram(ClientTelemetry.REQUEST_LATENCY_MAX_MICRO_SEC, ClientTelemetry.REQUEST_LATENCY_SUCCESS_PRECISION);\n+            } else {", "originalCommit": "e5af7f8436afff8ba02cbfde6f4cdb3bf2f237cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA0Mzc2NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r523043764", "bodyText": "Discussed offline, changed success scenario to cover status code between 200-299", "author": "simplynaveen20", "createdAt": "2020-11-13T15:59:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkyNTcwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkyNTkxMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520925913", "bodyText": "NIT ',' at teh end of the line", "author": "FabianMeiswinkel", "createdAt": "2020-11-10T22:53:51Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -153,11 +171,117 @@ public Context startSpan(String methodName, String databaseId, String endpoint,\n             });\n     }\n \n+    private <T> Mono<T> publisherWithClientTelemetry(Mono<T> resultPublisher,\n+                                                     Context context,\n+                                                     String spanName,\n+                                                     String containerId,\n+                                                     String databaseId,\n+                                                     String endpoint,\n+                                                     CosmosAsyncClient client,\n+                                                     ConsistencyLevel consistencyLevel,\n+                                                     OperationType operationType,\n+                                                     ResourceType resourceType,\n+                                                     Function<T, Integer> statusCodeFunc) {\n+        Mono<T> tracerMono = traceEnabledPublisher(resultPublisher, context, spanName, databaseId, endpoint, statusCodeFunc);\n+        return tracerMono\n+            .doOnSuccess(response -> {\n+                if (Configs.isClientTelemetryEnabled(BridgeInternal.isClientTelemetryEnabled(client)) && response instanceof CosmosItemResponse) {\n+                    @SuppressWarnings(\"unchecked\")\n+                    CosmosItemResponse<T> itemResponse = (CosmosItemResponse<T>) response;\n+                    fillClientTelemetry(client, itemResponse.getDiagnostics(), itemResponse.getStatusCode(),\n+                        ModelBridgeInternal.getPayloadLength(itemResponse), containerId,\n+                        databaseId, operationType, resourceType, consistencyLevel,\n+                        (float) itemResponse.getRequestCharge());\n+                }\n+            }).doOnError(throwable -> {\n+                if (Configs.isClientTelemetryEnabled(BridgeInternal.isClientTelemetryEnabled(client)) && throwable instanceof CosmosException) {\n+                    CosmosException cosmosException = (CosmosException) throwable;\n+                    fillClientTelemetry(client, cosmosException.getDiagnostics(), cosmosException.getStatusCode(),\n+                        null, containerId,\n+                        databaseId, operationType, resourceType, consistencyLevel,\n+                        (float) cosmosException.getRequestCharge());\n+                }\n+            });\n+    }\n+\n     private void end(int statusCode, Throwable throwable, Context context) {\n         if (throwable != null) {\n             tracer.setAttribute(TracerProvider.ERROR_MSG, throwable.getMessage(), context);\n             tracer.setAttribute(TracerProvider.ERROR_TYPE, throwable.getClass().getName(), context);\n         }\n         tracer.end(statusCode, throwable, context);\n     }\n+\n+    public void fillClientTelemetry(CosmosAsyncClient cosmosAsyncClient,\n+                                    CosmosDiagnostics cosmosDiagnostics,\n+                                    int statusCode,\n+                                    Integer objectSize,\n+                                    String containerId,\n+                                    String databaseId,\n+                                    OperationType operationType,\n+                                    ResourceType resourceType,\n+                                    ConsistencyLevel consistencyLevel,\n+                                    float requestCharge) {\n+        ClientTelemetry telemetry = BridgeInternal.getContextClient(cosmosAsyncClient).getClientTelemetry();\n+        ReportPayload reportPayloadLatency = createReportPayload(cosmosAsyncClient, cosmosDiagnostics,\n+            statusCode, objectSize, containerId, databaseId\n+            , operationType, resourceType, consistencyLevel, ClientTelemetry.REQUEST_LATENCY_NAME,\n+            ClientTelemetry.REQUEST_LATENCY_UNIT);\n+        ConcurrentDoubleHistogram latencyHistogram = telemetry.getClientTelemetryInfo().getOperationInfoMap().get(reportPayloadLatency);\n+        if (latencyHistogram != null) {\n+            ClientTelemetry.recordValue(latencyHistogram, cosmosDiagnostics.getDuration().toNanos()/1000);\n+        } else {\n+            if (statusCode == HttpConstants.StatusCodes.OK || statusCode == HttpConstants.StatusCodes.CREATED) {\n+                latencyHistogram = new ConcurrentDoubleHistogram(ClientTelemetry.REQUEST_LATENCY_MAX_MICRO_SEC, ClientTelemetry.REQUEST_LATENCY_SUCCESS_PRECISION);\n+            } else {\n+                latencyHistogram = new ConcurrentDoubleHistogram(ClientTelemetry.REQUEST_LATENCY_MAX_MICRO_SEC, ClientTelemetry.REQUEST_LATENCY_FAILURE_PRECISION);\n+            }\n+\n+            latencyHistogram.setAutoResize(true);\n+            ClientTelemetry.recordValue(latencyHistogram, cosmosDiagnostics.getDuration().toNanos()/1000);\n+            telemetry.getClientTelemetryInfo().getOperationInfoMap().put(reportPayloadLatency, latencyHistogram);\n+        }\n+\n+        ReportPayload reportPayloadRequestCharge = createReportPayload(cosmosAsyncClient, cosmosDiagnostics,\n+            statusCode, objectSize, containerId, databaseId", "originalCommit": "e5af7f8436afff8ba02cbfde6f4cdb3bf2f237cf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkyNjYzNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r520926635", "bodyText": "VM SKU woudl be very helpful as well?", "author": "FabianMeiswinkel", "createdAt": "2020-11-10T22:55:31Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/clientTelemetry/AzureVMMetadata.java", "diffHunk": "@@ -0,0 +1,30 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation.clientTelemetry;\n+\n+public class AzureVMMetadata {", "originalCommit": "e5af7f8436afff8ba02cbfde6f4cdb3bf2f237cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA0MzM0OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16822#discussion_r523043349", "bodyText": "Discussed offline , added hostEnvInfo in format \"Linux|18.04-LTS|Standard_F4s|AzurePublicCloud\"", "author": "simplynaveen20", "createdAt": "2020-11-13T15:59:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDkyNjYzNQ=="}], "type": "inlineReview"}, {"oid": "096a55afd9559b20be0169c9ee9c7c1858f2813a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/096a55afd9559b20be0169c9ee9c7c1858f2813a", "message": "resolving comments", "committedDate": "2020-11-13T15:54:49Z", "type": "commit"}, {"oid": "00cadd2d4b6535811e3d6f3447387831a84ebe11", "url": "https://github.com/Azure/azure-sdk-for-java/commit/00cadd2d4b6535811e3d6f3447387831a84ebe11", "message": "Merge branch 'latest-master' into users/nakumar/clientTelemetry", "committedDate": "2020-11-13T15:56:16Z", "type": "commit"}, {"oid": "b9fc1870497e155351c762b0bf9a7b56f14c71f2", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b9fc1870497e155351c762b0bf9a7b56f14c71f2", "message": "fixing build error", "committedDate": "2020-11-13T16:06:34Z", "type": "commit"}, {"oid": "06cfe0d223b216ae53212eed965da9b5f0dbe268", "url": "https://github.com/Azure/azure-sdk-for-java/commit/06cfe0d223b216ae53212eed965da9b5f0dbe268", "message": "resolving build error", "committedDate": "2020-11-13T16:23:20Z", "type": "commit"}, {"oid": "17b829eca5ff981b6352625f526490923e03a7b9", "url": "https://github.com/Azure/azure-sdk-for-java/commit/17b829eca5ff981b6352625f526490923e03a7b9", "message": "moving before and after from simple to emulator for telemetry", "committedDate": "2020-11-13T16:36:44Z", "type": "commit"}, {"oid": "071f928e47bb7945ed473a391320309b96032421", "url": "https://github.com/Azure/azure-sdk-for-java/commit/071f928e47bb7945ed473a391320309b96032421", "message": "Merge branch 'latest-master' into users/nakumar/clientTelemetry", "committedDate": "2020-11-19T21:43:17Z", "type": "commit"}, {"oid": "c89136519b6fcb5bc91babbcc2e6a5b54c6a7480", "url": "https://github.com/Azure/azure-sdk-for-java/commit/c89136519b6fcb5bc91babbcc2e6a5b54c6a7480", "message": "merge with master and changing database field name in report payload", "committedDate": "2020-11-19T21:45:17Z", "type": "commit"}]}