{"pr_number": 13371, "pr_title": "Mgmt Container Instance migration and update", "pr_createdAt": "2020-07-21T06:52:58Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/13371", "timeline": [{"oid": "d6c0a1abebb15a5352d3583e1a54ebdf02a52160", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d6c0a1abebb15a5352d3583e1a54ebdf02a52160", "message": "move aci from azure-libraries", "committedDate": "2020-07-15T02:55:58Z", "type": "commit"}, {"oid": "a648e2fab7d0d1b73a8c73c2f772a56be448c86f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/a648e2fab7d0d1b73a8c73c2f772a56be448c86f", "message": "update pom", "committedDate": "2020-07-15T05:27:57Z", "type": "commit"}, {"oid": "218de0060c23ed4afb74a12189da1cd60445eaee", "url": "https://github.com/Azure/azure-sdk-for-java/commit/218de0060c23ed4afb74a12189da1cd60445eaee", "message": "refactor namespace", "committedDate": "2020-07-15T05:33:21Z", "type": "commit"}, {"oid": "fc1f959d1795e8999754f6323fe12726aab15708", "url": "https://github.com/Azure/azure-sdk-for-java/commit/fc1f959d1795e8999754f6323fe12726aab15708", "message": "update api-specs", "committedDate": "2020-07-15T05:34:15Z", "type": "commit"}, {"oid": "61d548ba0842be6949c9c341332afc1fe234d563", "url": "https://github.com/Azure/azure-sdk-for-java/commit/61d548ba0842be6949c9c341332afc1fe234d563", "message": "regen aci", "committedDate": "2020-07-15T05:37:31Z", "type": "commit"}, {"oid": "261550fa701eda1f0e569ddcd99ecbc93d51c619", "url": "https://github.com/Azure/azure-sdk-for-java/commit/261550fa701eda1f0e569ddcd99ecbc93d51c619", "message": "refactor manager", "committedDate": "2020-07-15T05:38:14Z", "type": "commit"}, {"oid": "b4dc7d874a0d9bac4dd0c8e377b03bce2b79b69b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b4dc7d874a0d9bac4dd0c8e377b03bce2b79b69b", "message": "remove method beta", "committedDate": "2020-07-16T07:24:08Z", "type": "commit"}, {"oid": "df7696e4287f6860b6c13505115df812a87541c7", "url": "https://github.com/Azure/azure-sdk-for-java/commit/df7696e4287f6860b6c13505115df812a87541c7", "message": "fix models type", "committedDate": "2020-07-16T07:27:59Z", "type": "commit"}, {"oid": "66b13268251bed2da8742a1cfa93a8f84ed0777d", "url": "https://github.com/Azure/azure-sdk-for-java/commit/66b13268251bed2da8742a1cfa93a8f84ed0777d", "message": "fix manager and some import error", "committedDate": "2020-07-16T07:37:11Z", "type": "commit"}, {"oid": "400f49a4b7df00f70732baddccd648bc104c79b6", "url": "https://github.com/Azure/azure-sdk-for-java/commit/400f49a4b7df00f70732baddccd648bc104c79b6", "message": "fix compile error", "committedDate": "2020-07-17T02:52:20Z", "type": "commit"}, {"oid": "2d2b97ebdf353bb84d6a088c51ca8b7ca9f8d5f1", "url": "https://github.com/Azure/azure-sdk-for-java/commit/2d2b97ebdf353bb84d6a088c51ca8b7ca9f8d5f1", "message": "add aci in azure", "committedDate": "2020-07-17T03:08:16Z", "type": "commit"}, {"oid": "fb62cb8b4b6863cbcc1c62b5c73a1128197c915f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/fb62cb8b4b6863cbcc1c62b5c73a1128197c915f", "message": "fix compile error", "committedDate": "2020-07-17T03:20:17Z", "type": "commit"}, {"oid": "33063cf97d6f31203c60e905b8aa1248afd4b8ac", "url": "https://github.com/Azure/azure-sdk-for-java/commit/33063cf97d6f31203c60e905b8aa1248afd4b8ac", "message": "move sample", "committedDate": "2020-07-17T05:27:34Z", "type": "commit"}, {"oid": "024f1c648aeaccffb900c919e702648f46cdefe4", "url": "https://github.com/Azure/azure-sdk-for-java/commit/024f1c648aeaccffb900c919e702648f46cdefe4", "message": "fix compile error", "committedDate": "2020-07-17T05:58:34Z", "type": "commit"}, {"oid": "27cc3b1b90e5c780c55147582e6bbc7abfc63e97", "url": "https://github.com/Azure/azure-sdk-for-java/commit/27cc3b1b90e5c780c55147582e6bbc7abfc63e97", "message": "update api version", "committedDate": "2020-07-17T06:06:21Z", "type": "commit"}, {"oid": "1a89032c7a5d7878435e82a7c869a18c00a002fe", "url": "https://github.com/Azure/azure-sdk-for-java/commit/1a89032c7a5d7878435e82a7c869a18c00a002fe", "message": "regen", "committedDate": "2020-07-17T06:07:57Z", "type": "commit"}, {"oid": "17007513cc3f884ae60b91fe5108c468e9b7f1de", "url": "https://github.com/Azure/azure-sdk-for-java/commit/17007513cc3f884ae60b91fe5108c468e9b7f1de", "message": "update manager dependency", "committedDate": "2020-07-17T08:01:25Z", "type": "commit"}, {"oid": "fc19912bcae4b2dbeb00e6c01b8da99b77cdd8c5", "url": "https://github.com/Azure/azure-sdk-for-java/commit/fc19912bcae4b2dbeb00e6c01b8da99b77cdd8c5", "message": "remove inner", "committedDate": "2020-07-17T08:02:33Z", "type": "commit"}, {"oid": "259e41d167c651b349c54262d32c2977be6eef34", "url": "https://github.com/Azure/azure-sdk-for-java/commit/259e41d167c651b349c54262d32c2977be6eef34", "message": "regen", "committedDate": "2020-07-17T08:03:52Z", "type": "commit"}, {"oid": "426d79002d168fc91f1173716e9587fdb8458c46", "url": "https://github.com/Azure/azure-sdk-for-java/commit/426d79002d168fc91f1173716e9587fdb8458c46", "message": "fix compile error", "committedDate": "2020-07-17T08:06:25Z", "type": "commit"}, {"oid": "c6f5cde07a9f36ecf059f79ae1cc5478b7d5e5b3", "url": "https://github.com/Azure/azure-sdk-for-java/commit/c6f5cde07a9f36ecf059f79ae1cc5478b7d5e5b3", "message": "add subnet delegation", "committedDate": "2020-07-20T08:11:14Z", "type": "commit"}, {"oid": "62e71beda883d29fca73272d9ddde9eec6bdb334", "url": "https://github.com/Azure/azure-sdk-for-java/commit/62e71beda883d29fca73272d9ddde9eec6bdb334", "message": "add virtual network interface", "committedDate": "2020-07-20T08:12:23Z", "type": "commit"}, {"oid": "df51955fbc5e9f43a3147640dbcc9adbe28dd5e8", "url": "https://github.com/Azure/azure-sdk-for-java/commit/df51955fbc5e9f43a3147640dbcc9adbe28dd5e8", "message": "add test for virtual network", "committedDate": "2020-07-20T08:53:12Z", "type": "commit"}, {"oid": "8ff546dcd8437e2f12ea6e90f1bf0c3282380e72", "url": "https://github.com/Azure/azure-sdk-for-java/commit/8ff546dcd8437e2f12ea6e90f1bf0c3282380e72", "message": "add session record for virtual network", "committedDate": "2020-07-20T08:53:15Z", "type": "commit"}, {"oid": "d36e781d1c8d9e93de3f031d034a001e94e7c327", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d36e781d1c8d9e93de3f031d034a001e94e7c327", "message": "fix test error", "committedDate": "2020-07-21T05:22:11Z", "type": "commit"}, {"oid": "05a8d8a1a7ed56960002226e4f780f8791a5546f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/05a8d8a1a7ed56960002226e4f780f8791a5546f", "message": "update session-record", "committedDate": "2020-07-21T05:36:18Z", "type": "commit"}, {"oid": "49dd380d39c323aa0468b3f3bc952a5cce8d1d8c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/49dd380d39c323aa0468b3f3bc952a5cce8d1d8c", "message": "format", "committedDate": "2020-07-21T05:47:16Z", "type": "commit"}, {"oid": "47d906a33ff462b149de6eb6de172efecd9a184a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/47d906a33ff462b149de6eb6de172efecd9a184a", "message": "format azure package", "committedDate": "2020-07-21T05:55:20Z", "type": "commit"}, {"oid": "663fd4459fc2f7dbeb552ed80fa5256568cfb211", "url": "https://github.com/Azure/azure-sdk-for-java/commit/663fd4459fc2f7dbeb552ed80fa5256568cfb211", "message": "auto fix some checkstyle", "committedDate": "2020-07-21T06:10:38Z", "type": "commit"}, {"oid": "2fff63b14095400606dab7ca68c774dbfccb229c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/2fff63b14095400606dab7ca68c774dbfccb229c", "message": "fix verify error", "committedDate": "2020-07-21T06:52:04Z", "type": "commit"}, {"oid": "a8d2e3c0c10181ecbedebac1c264f9536c9922aa", "url": "https://github.com/Azure/azure-sdk-for-java/commit/a8d2e3c0c10181ecbedebac1c264f9536c9922aa", "message": "change sample test to live only", "committedDate": "2020-07-21T07:38:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg4OTI3Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13371#discussion_r457889277", "bodyText": "Should we provide a method with full id (if network profile got a full id)? And should we call it withExistingNetworkProfile?", "author": "weidongxu-microsoft", "createdAt": "2020-07-21T07:22:24Z", "path": "sdk/containerinstance/mgmt/src/main/java/com/azure/resourcemanager/containerinstance/models/ContainerGroup.java", "diffHunk": "@@ -0,0 +1,1118 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.resourcemanager.containerinstance.models;\n+\n+import com.azure.core.annotation.Fluent;\n+import com.azure.core.implementation.annotation.Beta;\n+import com.azure.resourcemanager.authorization.models.BuiltInRole;\n+import com.azure.resourcemanager.containerinstance.ContainerInstanceManager;\n+import com.azure.resourcemanager.containerinstance.fluent.inner.ContainerGroupInner;\n+import com.azure.resourcemanager.msi.models.Identity;\n+import com.azure.resourcemanager.resources.fluentcore.arm.models.GroupableResource;\n+import com.azure.resourcemanager.resources.fluentcore.arm.models.Resource;\n+import com.azure.resourcemanager.resources.fluentcore.model.Appliable;\n+import com.azure.resourcemanager.resources.fluentcore.model.Attachable;\n+import com.azure.resourcemanager.resources.fluentcore.model.Creatable;\n+import com.azure.resourcemanager.resources.fluentcore.model.Refreshable;\n+import com.azure.resourcemanager.resources.fluentcore.model.Updatable;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import reactor.core.publisher.Mono;\n+\n+/** An immutable client-side representation of an Azure Container Group. */\n+@Fluent\n+@Beta\n+public interface ContainerGroup\n+    extends GroupableResource<ContainerInstanceManager, ContainerGroupInner>,\n+        Refreshable<ContainerGroup>,\n+        Updatable<ContainerGroup.Update> {\n+\n+    /***********************************************************\n+     * Getters\n+     ***********************************************************/\n+\n+    /** @return the container instances in this container group */\n+    Map<String, Container> containers();\n+\n+    /** @return all the ports publicly exposed for this container group */\n+    Set<Port> externalPorts();\n+\n+    /** @return the TCP ports publicly exposed for this container group */\n+    int[] externalTcpPorts();\n+\n+    /** @return the UDP ports publicly exposed for this container group */\n+    int[] externalUdpPorts();\n+\n+    /** @return the volumes for this container group */\n+    Map<String, Volume> volumes();\n+\n+    /** @return the Docker image registry servers by which the container group is created from */\n+    Collection<String> imageRegistryServers();\n+\n+    /** @return the container group restart policy */\n+    ContainerGroupRestartPolicy restartPolicy();\n+\n+    /** @return the DNS prefix which was specified at creation time */\n+    String dnsPrefix();\n+\n+    /** @return the FQDN for the container group */\n+    String fqdn();\n+\n+    /** @return the IP address */\n+    String ipAddress();\n+\n+    /** @return true if IP address is public */\n+    boolean isIPAddressPublic();\n+\n+    /** @return true if IP address is private */\n+    boolean isIPAddressPrivate();\n+\n+    /** @return the base level OS type required by the containers in the group */\n+    OperatingSystemTypes osType();\n+\n+    /** @return the state of the container group; only valid in response */\n+    String state();\n+\n+    /** @return the provisioningState of the container group */\n+    String provisioningState();\n+\n+    /** @return the container group events */\n+    Set<Event> events();\n+\n+    /** @return the DNS configuration for the container group */\n+    DnsConfiguration dnsConfig();\n+\n+    /** @return the id of the network profile for the container group */\n+    String networkProfileId();\n+\n+    /** @return whether managed service identity is enabled for the container group */\n+    boolean isManagedServiceIdentityEnabled();\n+\n+    /**\n+     * @return the tenant id of the system assigned managed service identity. Null if managed service identity is not\n+     *     configured.\n+     */\n+    String systemAssignedManagedServiceIdentityTenantId();\n+\n+    /**\n+     * @return the principal id of the system assigned managed service identity. Null if managed service identity is not\n+     *     configured.\n+     */\n+    String systemAssignedManagedServiceIdentityPrincipalId();\n+\n+    /** @return whether managed service identity is system assigned, user assigned, both, or neither */\n+    ResourceIdentityType managedServiceIdentityType();\n+\n+    /** @return the ids of the user assigned managed service identities. Returns an empty set if no MSIs are set. */\n+    Set<String> userAssignedManagedServiceIdentityIds();\n+\n+    /** @return the log analytics information of the container group. */\n+    LogAnalytics logAnalytics();\n+\n+    /***********************************************************\n+     * Actions\n+     ***********************************************************/\n+\n+    /**\n+     * Restarts all containers in a container group in place. If container image has updates, new image will be\n+     * downloaded.\n+     */\n+    void restart();\n+\n+    /**\n+     * Restarts all containers in a container group in place asynchronously. If container image has updates, new image\n+     * will be downloaded.\n+     *\n+     * @return a representation of the deferred computation of this call\n+     */\n+    Mono<Void> restartAsync();\n+\n+    /** Stops all containers in a container group. Compute resources will be de-allocated and billing will stop. */\n+    void stop();\n+\n+    /**\n+     * Stops all containers in a container group asynchronously. Compute resources will be de-allocated and billing will\n+     * stop.\n+     *\n+     * @return a representation of the deferred computation of this call\n+     */\n+    Mono<Void> stopAsync();\n+\n+    /**\n+     * Get the log content for the specified container instance within the container group.\n+     *\n+     * @param containerName the container instance name\n+     * @throws IllegalArgumentException thrown if parameters fail the validation\n+     * @return all available log lines\n+     */\n+    String getLogContent(String containerName);\n+\n+    /**\n+     * Get the log content for the specified container instance within the container group.\n+     *\n+     * @param containerName the container instance name\n+     * @param tailLineCount only get the last log lines up to this\n+     * @throws IllegalArgumentException thrown if parameters fail the validation\n+     * @return the log lines from the end, up to the number specified\n+     */\n+    String getLogContent(String containerName, int tailLineCount);\n+\n+    /**\n+     * Get the log content for the specified container instance within the container group.\n+     *\n+     * @param containerName the container instance name\n+     * @throws IllegalArgumentException thrown if parameters fail the validation\n+     * @return a representation of the future computation of this call\n+     */\n+    Mono<String> getLogContentAsync(String containerName);\n+\n+    /**\n+     * Get the log content for the specified container instance within the container group.\n+     *\n+     * @param containerName the container instance name\n+     * @param tailLineCount only get the last log lines up to this\n+     * @throws IllegalArgumentException thrown if parameters fail the validation\n+     * @return a representation of the future computation of this call\n+     */\n+    Mono<String> getLogContentAsync(String containerName, int tailLineCount);\n+\n+    /**\n+     * Starts the exec command for a specific container instance.\n+     *\n+     * @param containerName the container instance name\n+     * @param command the command to be executed\n+     * @param row the row size of the terminal\n+     * @param column the column size of the terminal\n+     * @throws IllegalArgumentException thrown if parameters fail the validation\n+     * @return the log lines from the end, up to the number specified\n+     */\n+    ContainerExecResponse executeCommand(String containerName, String command, int row, int column);\n+\n+    /**\n+     * Starts the exec command for a specific container instance within the container group.\n+     *\n+     * @param containerName the container instance name\n+     * @param command the command to be executed\n+     * @param row the row size of the terminal\n+     * @param column the column size of the terminal\n+     * @throws IllegalArgumentException thrown if parameters fail the validation\n+     * @return a representation of the future computation of this call\n+     */\n+    Mono<ContainerExecResponse> executeCommandAsync(String containerName, String command, int row, int column);\n+\n+    /** Starts the exec command for a specific container instance within the current group asynchronously. */\n+    interface Definition\n+        extends DefinitionStages.Blank,\n+            DefinitionStages.WithGroup,\n+            DefinitionStages.WithOsType,\n+            DefinitionStages.WithPublicOrPrivateImageRegistry,\n+            DefinitionStages.WithPrivateImageRegistryOrVolume,\n+            DefinitionStages.WithVolume,\n+            DefinitionStages.WithFirstContainerInstance,\n+            DefinitionStages.WithSystemAssignedManagedServiceIdentity,\n+            DefinitionStages.WithSystemAssignedIdentityBasedAccessOrCreate,\n+            DefinitionStages.WithNextContainerInstance,\n+            DefinitionStages.DnsConfigFork,\n+            DefinitionStages.WithCreate {\n+    }\n+\n+    /** Grouping of the container group definition stages. */\n+    interface DefinitionStages {\n+        /** The first stage of the container group definition. */\n+        interface Blank extends GroupableResource.DefinitionWithRegion<WithGroup> {\n+        }\n+\n+        /** The stage of the container group definition allowing to specify the resource group. */\n+        interface WithGroup extends GroupableResource.DefinitionStages.WithGroup<DefinitionStages.WithOsType> {\n+        }\n+\n+        /** The stage of the container group definition allowing to specify the OS type. */\n+        interface WithOsType {\n+            /**\n+             * Specifies this is a Linux container group.\n+             *\n+             * @return the next stage of the definition\n+             */\n+            WithPublicOrPrivateImageRegistry withLinux();\n+\n+            /**\n+             * Specifies this is a Windows container group.\n+             *\n+             * @return the next stage of the definition\n+             */\n+            WithPublicOrPrivateImageRegistry withWindows();\n+        }\n+\n+        /** The stage of the container group definition allowing to specify a public only or private image registry. */\n+        interface WithPublicOrPrivateImageRegistry extends WithPublicImageRegistryOnly, WithPrivateImageRegistry {\n+        }\n+\n+        /** The stage of the container group definition allowing to skip the private image registry. */\n+        interface WithPublicImageRegistryOnly {\n+            /**\n+             * Only public container image repository will be used to create the container instances in the container\n+             * group.\n+             *\n+             * @return the next stage of the definition\n+             */\n+            WithPrivateImageRegistryOrVolume withPublicImageRegistryOnly();\n+        }\n+\n+        /** The stage of the container group definition allowing to specify a private image registry. */\n+        interface WithPrivateImageRegistry {\n+            /**\n+             * Specifies the private container image registry server login for the container group.\n+             *\n+             * @param server Docker image registry server, without protocol such as \"http\" and \"https\"\n+             * @param username the username for the private registry\n+             * @param password the password for the private registry\n+             * @return the next stage of the definition\n+             */\n+            WithPrivateImageRegistryOrVolume withPrivateImageRegistry(String server, String username, String password);\n+        }\n+\n+        /** The stage of the container group definition allowing to specify a private image registry or a volume. */\n+        interface WithPrivateImageRegistryOrVolume extends WithPrivateImageRegistry {\n+            /**\n+             * Skips the definition of volumes to be shared by the container instances.\n+             *\n+             * <p>An IllegalArgumentException will be thrown if a container instance attempts to define a volume\n+             * mounting.\n+             *\n+             * @return the next stage of the definition\n+             */\n+            WithFirstContainerInstance withoutVolume();\n+\n+            /**\n+             * Specifies a new Azure file share name to be created.\n+             *\n+             * @param volumeName the name of the volume\n+             * @param shareName the Azure file share name to be created\n+             * @return the next stage of the definition\n+             */\n+            WithFirstContainerInstance withNewAzureFileShareVolume(String volumeName, String shareName);\n+\n+            /**\n+             * Specifies an empty directory volume that can be shared by the container instances in the container group.\n+             *\n+             * @param name the name of the empty directory volume\n+             * @return the next stage of the definition\n+             */\n+            WithFirstContainerInstance withEmptyDirectoryVolume(String name);\n+\n+            /**\n+             * Begins the definition of a volume that can be shared by the container instances in the container group.\n+             *\n+             * <p>The definition must be completed with a call to {@link\n+             * VolumeDefinitionStages.WithVolumeAttach#attach()}\n+             *\n+             * @param name the name of the volume\n+             * @return the next stage of the definition\n+             */\n+            VolumeDefinitionStages.VolumeDefinitionBlank<WithVolume> defineVolume(String name);\n+        }\n+\n+        /**\n+         * The stage of the container group definition allowing to specify a volume that can be mounted by a container\n+         * instance.\n+         */\n+        interface WithVolume extends WithFirstContainerInstance {\n+            /**\n+             * Begins the definition of a volume that can be shared by the container instances in the container group.\n+             *\n+             * <p>The definition must be completed with a call to {@link\n+             * VolumeDefinitionStages.WithVolumeAttach#attach()}\n+             *\n+             * @param name the name of the volume\n+             * @return the next stage of the definition\n+             */\n+            VolumeDefinitionStages.VolumeDefinitionBlank<WithVolume> defineVolume(String name);\n+        }\n+\n+        /** Grouping of volume definition stages. */\n+        interface VolumeDefinitionStages {\n+            /**\n+             * The first stage of the volume definition.\n+             *\n+             * @param <ParentT> the stage of the parent definition to return to after attaching this definition\n+             */\n+            interface VolumeDefinitionBlank<ParentT> extends WithAzureFileShare<ParentT> {\n+            }\n+\n+            /**\n+             * The stage of the volume definition allowing to specify a read only Azure File Share name.\n+             *\n+             * @param <ParentT> the stage of the parent definition to return to after attaching this definition\n+             */\n+            interface WithAzureFileShare<ParentT> {\n+                /**\n+                 * Specifies an existing Azure file share name.\n+                 *\n+                 * @param shareName an existing Azure file share name\n+                 * @return the next stage of the definition\n+                 */\n+                WithStorageAccountName<ParentT> withExistingReadWriteAzureFileShare(String shareName);\n+\n+                /**\n+                 * Specifies an existing Azure file share name.\n+                 *\n+                 * @param shareName an existing Azure file share name\n+                 * @return the next stage of the definition\n+                 */\n+                WithStorageAccountName<ParentT> withExistingReadOnlyAzureFileShare(String shareName);\n+            }\n+\n+            /**\n+             * The stage of the volume definition allowing to specify the storage account name to access to the Azure\n+             * file.\n+             *\n+             * @param <ParentT> the stage of the parent definition to return to after attaching this definition\n+             */\n+            interface WithStorageAccountName<ParentT> {\n+                /**\n+                 * Specifies the storage account name to access to the Azure file.\n+                 *\n+                 * @param storageAccountName the storage account name\n+                 * @return the next stage of the definition\n+                 */\n+                WithStorageAccountKey<ParentT> withStorageAccountName(String storageAccountName);\n+            }\n+\n+            /**\n+             * The stage of the volume definition allowing to specify the storage account key to access to the Azure\n+             * file.\n+             *\n+             * @param <ParentT> the stage of the parent definition to return to after attaching this definition\n+             */\n+            interface WithStorageAccountKey<ParentT> {\n+                /**\n+                 * Specifies the storage account key to access to the Azure file.\n+                 *\n+                 * @param storageAccountKey the storage account key\n+                 * @return the next stage of the definition\n+                 */\n+                WithVolumeAttach<ParentT> withStorageAccountKey(String storageAccountKey);\n+            }\n+\n+            /**\n+             * The stage of the volume definition allowing to specify the secrets map.\n+             *\n+             * @param <ParentT> the stage of the parent definition to return to after attaching this definition\n+             */\n+            interface WithSecretsMap<ParentT> {\n+                /**\n+                 * Specifies the secrets map.\n+                 *\n+                 * <p>The secret value must be specified in Base64 encoding\n+                 *\n+                 * @param secrets the new volume secrets map; value must be in Base64 encoding\n+                 * @return the next stage of the definition\n+                 */\n+                WithVolumeAttach<ParentT> withSecrets(Map<String, String> secrets);\n+            }\n+\n+            /**\n+             * The stage of the volume definition allowing to specify the Git URL mappings.\n+             *\n+             * @param <ParentT> the stage of the parent definition to return to after attaching this definition\n+             */\n+            interface WithGitUrl<ParentT> {\n+                /**\n+                 * Specifies the Git URL for the new volume.\n+                 *\n+                 * @param gitUrl the Git URL for the new volume\n+                 * @return the next stage of the definition\n+                 */\n+                WithGitDirectoryName<ParentT> withGitUrl(String gitUrl);\n+            }\n+\n+            /**\n+             * The stage of the volume definition allowing to specify the Git target directory name mappings.\n+             *\n+             * @param <ParentT> the stage of the parent definition to return to after attaching this definition\n+             */\n+            interface WithGitDirectoryName<ParentT> extends WithGitRevision<ParentT> {\n+                /**\n+                 * Specifies the Git target directory name for the new volume.\n+                 *\n+                 * <p>Must not contain or start with '..'. If '.' is supplied, the volume directory will be the git\n+                 * repository. Otherwise, if specified, the volume will contain the git repository in the subdirectory\n+                 * with the given name.\n+                 *\n+                 * @param gitDirectoryName the Git target directory name for the new volume\n+                 * @return the next stage of the definition\n+                 */\n+                WithGitRevision<ParentT> withGitDirectoryName(String gitDirectoryName);\n+            }\n+\n+            /**\n+             * The stage of the volume definition allowing to specify the Git revision.\n+             *\n+             * @param <ParentT> the stage of the parent definition to return to after attaching this definition\n+             */\n+            interface WithGitRevision<ParentT> extends WithVolumeAttach<ParentT> {\n+                /**\n+                 * Specifies the Git revision for the new volume.\n+                 *\n+                 * @param gitRevision the Git revision for the new volume\n+                 * @return the next stage of the definition\n+                 */\n+                WithVolumeAttach<ParentT> withGitRevision(String gitRevision);\n+            }\n+\n+            /**\n+             * The final stage of the volume definition.\n+             *\n+             * <p>At this stage, any remaining optional settings can be specified, or the subnet definition can be\n+             * attached to the parent virtual network definition.\n+             *\n+             * @param <ParentT> the stage of the parent definition to return to after attaching this definition\n+             */\n+            interface WithVolumeAttach<ParentT> extends Attachable.InDefinition<ParentT> {\n+            }\n+\n+            /** Grouping of the container group's volume definition stages. */\n+            interface VolumeDefinition<ParentT>\n+                extends VolumeDefinitionBlank<ParentT>,\n+                    WithAzureFileShare<ParentT>,\n+                    WithStorageAccountName<ParentT>,\n+                    WithStorageAccountKey<ParentT>,\n+                    WithSecretsMap<ParentT>,\n+                    WithGitUrl<ParentT>,\n+                    WithGitDirectoryName<ParentT>,\n+                    WithGitRevision<ParentT>,\n+                    WithVolumeAttach<ParentT> {\n+            }\n+        }\n+\n+        /** The stage of the container group definition allowing to specify first required container instance. */\n+        interface WithFirstContainerInstance {\n+            /**\n+             * Begins the definition of a container instance.\n+             *\n+             * @param name the name of the container instance\n+             * @return the next stage of the definition\n+             */\n+            ContainerInstanceDefinitionStages.ContainerInstanceDefinitionBlank<WithNextContainerInstance>\n+                defineContainerInstance(String name);\n+\n+            /**\n+             * Defines one container instance for the specified image with one CPU count and 1.5 GB memory, with TCP\n+             * port 80 opened externally.\n+             *\n+             * @param imageName the name of the container image\n+             * @return the next stage of the definition\n+             */\n+            WithCreate withContainerInstance(String imageName);\n+\n+            /**\n+             * Defines one container instance for the specified image with one CPU count and 1.5 GB memory, with a\n+             * custom TCP port opened externally.\n+             *\n+             * @param imageName the name of the container image\n+             * @param port the external port to be opened\n+             * @return the next stage of the definition\n+             */\n+            WithCreate withContainerInstance(String imageName, int port);\n+        }\n+\n+        /** The stage of the container group definition allowing to specify a container instance. */\n+        interface WithNextContainerInstance extends WithCreate {\n+            /**\n+             * Begins the definition of a container instance.\n+             *\n+             * @param name the name of the volume\n+             * @return the next stage of the definition\n+             */\n+            ContainerInstanceDefinitionStages.ContainerInstanceDefinitionBlank<WithNextContainerInstance>\n+                defineContainerInstance(String name);\n+        }\n+\n+        /** Grouping of volume definition stages. */\n+        interface ContainerInstanceDefinitionStages {\n+            /**\n+             * The first stage of the container instance definition.\n+             *\n+             * @param <ParentT> the stage of the parent definition to return to after attaching this definition\n+             */\n+            interface ContainerInstanceDefinitionBlank<ParentT> extends WithImage<ParentT> {\n+            }\n+\n+            /**\n+             * The stage of the container instance definition allowing to specify the container image.\n+             *\n+             * @param <ParentT> the stage of the parent definition to return to after attaching this definition\n+             */\n+            interface WithImage<ParentT> {\n+                /**\n+                 * Specifies the container image to be used.\n+                 *\n+                 * @param imageName the container image\n+                 * @return the next stage of the definition\n+                 */\n+                WithOrWithoutPorts<ParentT> withImage(String imageName);\n+            }\n+\n+            /**\n+             * The stage of the container instance definition allowing to specify (or not) the container ports.\n+             *\n+             * @param <ParentT> the stage of the parent definition to return to after attaching this definition\n+             */\n+            interface WithOrWithoutPorts<ParentT> extends WithPorts<ParentT>, WithoutPorts<ParentT> {\n+            }\n+\n+            /**\n+             * The stage of the container instance definition allowing not to specify any container ports internal or\n+             * external.\n+             *\n+             * @param <ParentT> the stage of the parent definition to return to after attaching this definition\n+             */\n+            interface WithoutPorts<ParentT> {\n+                /**\n+                 * Specifies that not ports will be opened internally or externally for this container instance.\n+                 *\n+                 * @return the next stage of the definition\n+                 */\n+                WithContainerInstanceAttach<ParentT> withoutPorts();\n+            }\n+\n+            /**\n+             * The stage of the container instance definition allowing to specify one or more container ports.\n+             *\n+             * @param <ParentT> the stage of the parent definition to return to after attaching this definition\n+             */\n+            interface WithPortsOrContainerInstanceAttach<ParentT>\n+                extends WithPorts<ParentT>, WithContainerInstanceAttach<ParentT> {\n+            }\n+\n+            /**\n+             * The stage of the container instance definition allowing to specify the container ports.\n+             *\n+             * @param <ParentT> the stage of the parent definition to return to after attaching this definition\n+             */\n+            interface WithPorts<ParentT> {\n+                /**\n+                 * Specifies the container's TCP ports available to external clients.\n+                 *\n+                 * <p>A public IP address will be create to allow external clients to reach the containers within the\n+                 * group. To enable external clients to reach a container within the group, you must expose the port on\n+                 * the IP address and from the container. Because containers within the group share a port namespace,\n+                 * port mapping is not supported.\n+                 *\n+                 * @param ports array of TCP ports to be exposed externally\n+                 * @return the next stage of the definition\n+                 */\n+                WithPortsOrContainerInstanceAttach<ParentT> withExternalTcpPorts(int... ports);\n+\n+                /**\n+                 * Specifies the container's TCP port available to external clients.\n+                 *\n+                 * <p>A public IP address will be create to allow external clients to reach the containers within the\n+                 * group. To enable external clients to reach a container within the group, you must expose the port on\n+                 * the IP address and from the container. Because containers within the group share a port namespace,\n+                 * port mapping is not supported.\n+                 *\n+                 * @param port TCP port to be exposed externally\n+                 * @return the next stage of the definition\n+                 */\n+                WithPortsOrContainerInstanceAttach<ParentT> withExternalTcpPort(int port);\n+\n+                /**\n+                 * Specifies the container's UDP ports available to external clients.\n+                 *\n+                 * <p>A public IP address will be create to allow external clients to reach the containers within the\n+                 * group. To enable external clients to reach a container within the group, you must expose the port on\n+                 * the IP address and from the container. Because containers within the group share a port namespace,\n+                 * port mapping is not supported.\n+                 *\n+                 * @param ports array of UDP ports to be exposed externally\n+                 * @return the next stage of the definition\n+                 */\n+                WithPortsOrContainerInstanceAttach<ParentT> withExternalUdpPorts(int... ports);\n+\n+                /**\n+                 * Specifies the container's UDP port available to external clients.\n+                 *\n+                 * <p>A public IP address will be create to allow external clients to reach the containers within the\n+                 * group. To enable external clients to reach a container within the group, you must expose the port on\n+                 * the IP address and from the container. Because containers within the group share a port namespace,\n+                 * port mapping is not supported.\n+                 *\n+                 * @param port UDP port to be exposed externally\n+                 * @return the next stage of the definition\n+                 */\n+                WithPortsOrContainerInstanceAttach<ParentT> withExternalUdpPort(int port);\n+\n+                /**\n+                 * Specifies the container's TCP ports are available to internal clients only (other container instances\n+                 * within the container group).\n+                 *\n+                 * <p>Containers within a group can reach each other via localhost on the ports that they have exposed,\n+                 * even if those ports are not exposed externally on the group's IP address.\n+                 *\n+                 * @param ports array of TCP ports to be exposed internally\n+                 * @return the next stage of the definition\n+                 */\n+                WithPortsOrContainerInstanceAttach<ParentT> withInternalTcpPorts(int... ports);\n+\n+                /**\n+                 * Specifies the container's Udp ports are available to internal clients only (other container instances\n+                 * within the container group).\n+                 *\n+                 * <p>Containers within a group can reach each other via localhost on the ports that they have exposed,\n+                 * even if those ports are not exposed externally on the group's IP address.\n+                 *\n+                 * @param ports array of UDP ports to be exposed internally\n+                 * @return the next stage of the definition\n+                 */\n+                WithPortsOrContainerInstanceAttach<ParentT> withInternalUdpPorts(int... ports);\n+\n+                /**\n+                 * Specifies the container's TCP port is available to internal clients only (other container instances\n+                 * within the container group).\n+                 *\n+                 * <p>Containers within a group can reach each other via localhost on the ports that they have exposed,\n+                 * even if those ports are not exposed externally on the group's IP address.\n+                 *\n+                 * @param port TCP port to be exposed internally\n+                 * @return the next stage of the definition\n+                 */\n+                WithPortsOrContainerInstanceAttach<ParentT> withInternalTcpPort(int port);\n+\n+                /**\n+                 * Specifies the container's UDP port is available to internal clients only (other container instances\n+                 * within the container group).\n+                 *\n+                 * <p>Containers within a group can reach each other via localhost on the ports that they have exposed,\n+                 * even if those ports are not exposed externally on the group's IP address.\n+                 *\n+                 * @param port UDP port to be exposed internally\n+                 * @return the next stage of the definition\n+                 */\n+                WithPortsOrContainerInstanceAttach<ParentT> withInternalUdpPort(int port);\n+            }\n+\n+            /**\n+             * The stage of the container instance definition allowing to specify the number of CPU cores.\n+             *\n+             * <p>The CPU cores can be specified as a fraction, i.e. 1.5 represents one and a half atomic CPU cores will\n+             * be assigned to this container instance.\n+             *\n+             * @param <ParentT> the stage of the parent definition to return to after attaching this definition\n+             */\n+            interface WithCpuCoreCount<ParentT> {\n+                /**\n+                 * Specifies the number of CPU cores assigned to this container instance.\n+                 *\n+                 * @param cpuCoreCount the number of CPU cores\n+                 * @return the next stage of the definition\n+                 */\n+                WithContainerInstanceAttach<ParentT> withCpuCoreCount(double cpuCoreCount);\n+            }\n+\n+            interface WithGpuResource<ParentT> {\n+                WithContainerInstanceAttach<ParentT> withGpuResource(int gpuCoreCount, GpuSku gpuSku);\n+            }\n+\n+            /**\n+             * The stage of the container instance definition allowing to specify the memory size in GB.\n+             *\n+             * <p>The memory size can be specified as a fraction, i.e. 1.5 represents one and a half GB of memory.\n+             *\n+             * @param <ParentT> the stage of the parent definition to return to after attaching this definition\n+             */\n+            interface WithMemorySize<ParentT> {\n+                /**\n+                 * Specifies the memory size in GB assigned to this container instance.\n+                 *\n+                 * @param memorySize the memory size in GB\n+                 * @return the next stage of the definition\n+                 */\n+                WithContainerInstanceAttach<ParentT> withMemorySizeInGB(double memorySize);\n+            }\n+\n+            /**\n+             * The stage of the container instance definition allowing to specify the starting command line.\n+             *\n+             * @param <ParentT> the stage of the parent definition to return to after attaching this definition\n+             */\n+            interface WithStartingCommandLine<ParentT> {\n+                /**\n+                 * Specifies the starting command lines.\n+                 *\n+                 * @param executable the executable which it will call after initializing the container\n+                 * @param parameters the parameter list for the executable to be called\n+                 * @return the next stage of the definition\n+                 */\n+                WithContainerInstanceAttach<ParentT> withStartingCommandLine(String executable, String... parameters);\n+\n+                /**\n+                 * Specifies the starting command line.\n+                 *\n+                 * @param executable the executable or path to the executable that will be called after initializing the\n+                 *     container\n+                 * @return the next stage of the definition\n+                 */\n+                WithContainerInstanceAttach<ParentT> withStartingCommandLine(String executable);\n+            }\n+\n+            /**\n+             * The stage of the container instance definition allowing to specify the environment variables.\n+             *\n+             * @param <ParentT> the stage of the parent definition to return to after attaching this definition\n+             */\n+            interface WithEnvironmentVariables<ParentT> {\n+                /**\n+                 * Specifies the environment variables.\n+                 *\n+                 * @param environmentVariables the environment variables in a name and value pair to be set after the\n+                 *     container gets initialized\n+                 * @return the next stage of the definition\n+                 */\n+                WithContainerInstanceAttach<ParentT> withEnvironmentVariables(Map<String, String> environmentVariables);\n+\n+                /**\n+                 * Specifies the environment variable.\n+                 *\n+                 * @param envName the environment variable name\n+                 * @param envValue the environment variable value\n+                 * @return the next stage of the definition\n+                 */\n+                WithContainerInstanceAttach<ParentT> withEnvironmentVariable(String envName, String envValue);\n+\n+                /**\n+                 * Specifies a collection of name and secure value pairs for the environment variables.\n+                 *\n+                 * @param environmentVariables the environment variables in a name and value pair to be set after the\n+                 *     container gets initialized\n+                 * @return the next stage of the definition\n+                 */\n+                WithContainerInstanceAttach<ParentT> withEnvironmentVariableWithSecuredValue(\n+                    Map<String, String> environmentVariables);\n+\n+                /**\n+                 * Specifies the environment variable that has a secured value.\n+                 *\n+                 * @param envName the environment variable name\n+                 * @param securedValue the environment variable secured value\n+                 * @return the next stage of the definition\n+                 */\n+                WithContainerInstanceAttach<ParentT> withEnvironmentVariableWithSecuredValue(\n+                    String envName, String securedValue);\n+            }\n+\n+            /**\n+             * The stage of the container instance definition allowing to specify volume mount setting.\n+             *\n+             * @param <ParentT> the stage of the parent definition to return to after attaching this definition\n+             */\n+            interface WithVolumeMountSetting<ParentT> {\n+                /**\n+                 * Specifies the container group's volume to be mounted by the container instance at a specified mount\n+                 * path.\n+                 *\n+                 * <p>Mounting an Azure file share as a volume in a container is a two-step process. First, you provide\n+                 * the details of the share as part of defining the container group, then you specify how you wan the\n+                 * volume mounted within one or more of the containers in the group.\n+                 *\n+                 * @param volumeName the volume name as defined in the volumes of the container group\n+                 * @param mountPath the local path the volume will be mounted at\n+                 * @return the next stage of the definition\n+                 * @throws IllegalArgumentException thrown if volumeName was not defined in the respective container\n+                 *     group definition stage.\n+                 */\n+                WithContainerInstanceAttach<ParentT> withVolumeMountSetting(String volumeName, String mountPath);\n+\n+                /**\n+                 * Specifies the container group's volume to be mounted by the container instance at a specified mount\n+                 * path.\n+                 *\n+                 * <p>Mounting an Azure file share as a volume in a container is a two-step process. First, you provide\n+                 * the details of the share as part of defining the container group, then you specify how you wan the\n+                 * volume mounted within one or more of the containers in the group.\n+                 *\n+                 * @param volumeMountSetting the name and value pair representing volume names as defined in the volumes\n+                 *     of the container group and the local paths the volume will be mounted at\n+                 * @return the next stage of the definition\n+                 * @throws IllegalArgumentException thrown if volumeName was not defined in the respective container\n+                 *     group definition stage.\n+                 */\n+                WithContainerInstanceAttach<ParentT> withVolumeMountSetting(Map<String, String> volumeMountSetting);\n+\n+                /**\n+                 * Specifies the container group's volume to be mounted by the container instance at a specified mount\n+                 * path.\n+                 *\n+                 * <p>Mounting an Azure file share as a volume in a container is a two-step process. First, you provide\n+                 * the details of the share as part of defining the container group, then you specify how you wan the\n+                 * volume mounted within one or more of the containers in the group.\n+                 *\n+                 * @param volumeName the volume name as defined in the volumes of the container group\n+                 * @param mountPath the local path the volume will be mounted at\n+                 * @return the next stage of the definition\n+                 * @throws IllegalArgumentException thrown if volumeName was not defined in the respective container\n+                 *     group definition stage.\n+                 */\n+                WithContainerInstanceAttach<ParentT> withReadOnlyVolumeMountSetting(\n+                    String volumeName, String mountPath);\n+\n+                /**\n+                 * Specifies the container group's volume to be mounted by the container instance at a specified mount\n+                 * path.\n+                 *\n+                 * <p>Mounting an Azure file share as a volume in a container is a two-step process. First, you provide\n+                 * the details of the share as part of defining the container group, then you specify how you wan the\n+                 * volume mounted within one or more of the containers in the group.\n+                 *\n+                 * @param volumeMountSetting the name and value pair representing volume names as defined in the volumes\n+                 *     of the container group and the local paths the volume will be mounted at\n+                 * @return the next stage of the definition\n+                 * @throws IllegalArgumentException thrown if volumeName was not defined in the respective container\n+                 *     group definition stage.\n+                 */\n+                WithContainerInstanceAttach<ParentT> withReadOnlyVolumeMountSetting(\n+                    Map<String, String> volumeMountSetting);\n+            }\n+\n+            /**\n+             * The final stage of the container instance definition.\n+             *\n+             * <p>At this stage, any remaining optional settings can be specified, or the subnet definition can be\n+             * attached to the parent virtual network definition.\n+             *\n+             * @param <ParentT> the stage of the parent definition to return to after attaching this definition\n+             */\n+            interface WithContainerInstanceAttach<ParentT>\n+                extends WithCpuCoreCount<ParentT>,\n+                    WithGpuResource<ParentT>,\n+                    WithMemorySize<ParentT>,\n+                    WithStartingCommandLine<ParentT>,\n+                    WithEnvironmentVariables<ParentT>,\n+                    WithVolumeMountSetting<ParentT>,\n+                    Attachable.InDefinition<ParentT> {\n+            }\n+\n+            /** Grouping of the container group's volume definition stages. */\n+            interface ContainerInstanceDefinition<ParentT>\n+                extends ContainerInstanceDefinitionBlank<ParentT>,\n+                    WithImage<ParentT>,\n+                    WithOrWithoutPorts<ParentT>,\n+                    WithPortsOrContainerInstanceAttach<ParentT>,\n+                    WithContainerInstanceAttach<ParentT> {\n+            }\n+        }\n+\n+        /**\n+         * The stage of the container instance definition allowing to specify having system assigned managed service\n+         * identity.\n+         */\n+        interface WithSystemAssignedManagedServiceIdentity {\n+            /**\n+             * Specifies a system assigned managed service identity for the container group.\n+             *\n+             * @return the next stage of the definition\n+             */\n+            WithSystemAssignedIdentityBasedAccessOrCreate withSystemAssignedManagedServiceIdentity();\n+        }\n+\n+        /**\n+         * The stage of the container instance definition allowing to specify system assigned managed service identity\n+         * with specific role based access.\n+         */\n+        interface WithSystemAssignedIdentityBasedAccessOrCreate extends WithCreate {\n+            /**\n+             * Specifies a system assigned managed service identity with access to a specific resource with a specified\n+             * role.\n+             *\n+             * @param resourceId the id of the resource you are setting up access to\n+             * @param role access role to be assigned to the identity\n+             * @return the next stage of the definition\n+             */\n+            WithSystemAssignedIdentityBasedAccessOrCreate withSystemAssignedIdentityBasedAccessTo(\n+                String resourceId, BuiltInRole role);\n+\n+            /**\n+             * Specifies a system assigned managed service identity with access to the current resource group and with\n+             * the specified role.\n+             *\n+             * @param role access role to be assigned to the identity\n+             * @return the next stage of the definition\n+             */\n+            WithSystemAssignedIdentityBasedAccessOrCreate withSystemAssignedIdentityBasedAccessToCurrentResourceGroup(\n+                BuiltInRole role);\n+\n+            /**\n+             * Specifies a system assigned managed service identity with access to a specific resource with a specified\n+             * role from the id.\n+             *\n+             * @param resourceId the id of the resource you are setting up access to\n+             * @param roleDefinitionId id of the access role to be assigned to the identity\n+             * @return the next stage of the definition\n+             */\n+            WithSystemAssignedIdentityBasedAccessOrCreate withSystemAssignedIdentityBasedAccessTo(\n+                String resourceId, String roleDefinitionId);\n+\n+            /**\n+             * Specifies a system assigned managed service identity with access to the current resource group and with\n+             * the specified role from the id.\n+             *\n+             * @param roleDefinitionId id of the access role to be assigned to the identity\n+             * @return the next stage of the definition\n+             */\n+            WithSystemAssignedIdentityBasedAccessOrCreate withSystemAssignedIdentityBasedAccessToCurrentResourceGroup(\n+                String roleDefinitionId);\n+        }\n+\n+        /**\n+         * The stage of the container instance definition allowing to specify user assigned managed service identity.\n+         */\n+        interface WithUserAssignedManagedServiceIdentity {\n+            /**\n+             * Specifies the definition of a not-yet-created user assigned identity to be associated with the virtual\n+             * machine.\n+             *\n+             * @param creatableIdentity a creatable identity definition\n+             * @return the next stage of the definition\n+             */\n+            WithCreate withNewUserAssignedManagedServiceIdentity(Creatable<Identity> creatableIdentity);\n+\n+            /**\n+             * Specifies an existing user assigned identity to be associate with the container group.\n+             *\n+             * @param identity the identity\n+             * @return the next stage of the definition\n+             */\n+            WithCreate withExistingUserAssignedManagedServiceIdentity(Identity identity);\n+        }\n+\n+        /** The stage of the container group definition allowing to specify the container group restart policy. */\n+        interface WithRestartPolicy {\n+            /**\n+             * Specifies the restart policy for all the container instances within the container group.\n+             *\n+             * @param restartPolicy the restart policy for all the container instances within the container group\n+             * @return the next stage of the definition\n+             */\n+            WithCreate withRestartPolicy(ContainerGroupRestartPolicy restartPolicy);\n+        }\n+\n+        /** The stage of the container group definition allowing to specify the DNS prefix label. */\n+        interface WithDnsPrefix {\n+            /**\n+             * Specifies the DNS prefix to be used to create the FQDN for the container group.\n+             *\n+             * @param dnsPrefix the DNS prefix to be used to create the FQDN for the container group\n+             * @return the next stage of the definition\n+             */\n+            WithCreate withDnsPrefix(String dnsPrefix);\n+        }\n+\n+        /** The stage of the container group definition allowing to specify the network profile id. */\n+        interface WithNetworkProfile {\n+            /**\n+             * Specifies the network profile information for a container group.\n+             *\n+             * @param subscriptionId the ID of the subscription of the network profile\n+             * @param resourceGroupName the name of the resource group of the network profile\n+             * @param networkProfileName the name of the network profile\n+             * @return the next stage of the definition\n+             */\n+            DnsConfigFork withNetworkProfileId(\n+                String subscriptionId, String resourceGroupName, String networkProfileName);", "originalCommit": "2fff63b14095400606dab7ca68c774dbfccb229c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzkwMTAxMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13371#discussion_r457901010", "bodyText": "This is a old function, I didn't change it.", "author": "ChenTanyi", "createdAt": "2020-07-21T07:44:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg4OTI3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ3NDY2NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13371#discussion_r458474664", "bodyText": "If we want to do some breaking change, here is the best time. Anyway, up to you.", "author": "weidongxu-microsoft", "createdAt": "2020-07-22T01:06:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg4OTI3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg4OTk3OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13371#discussion_r457889979", "bodyText": "withNewNetworkProfileOnExistingVirtualNetwork, or .withExistingVirtualNetwork(...).withNewNetworkProfile(...)?", "author": "weidongxu-microsoft", "createdAt": "2020-07-21T07:23:45Z", "path": "sdk/containerinstance/mgmt/src/main/java/com/azure/resourcemanager/containerinstance/models/ContainerGroup.java", "diffHunk": "@@ -0,0 +1,1118 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.resourcemanager.containerinstance.models;\n+\n+import com.azure.core.annotation.Fluent;\n+import com.azure.core.implementation.annotation.Beta;\n+import com.azure.resourcemanager.authorization.models.BuiltInRole;\n+import com.azure.resourcemanager.containerinstance.ContainerInstanceManager;\n+import com.azure.resourcemanager.containerinstance.fluent.inner.ContainerGroupInner;\n+import com.azure.resourcemanager.msi.models.Identity;\n+import com.azure.resourcemanager.resources.fluentcore.arm.models.GroupableResource;\n+import com.azure.resourcemanager.resources.fluentcore.arm.models.Resource;\n+import com.azure.resourcemanager.resources.fluentcore.model.Appliable;\n+import com.azure.resourcemanager.resources.fluentcore.model.Attachable;\n+import com.azure.resourcemanager.resources.fluentcore.model.Creatable;\n+import com.azure.resourcemanager.resources.fluentcore.model.Refreshable;\n+import com.azure.resourcemanager.resources.fluentcore.model.Updatable;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import reactor.core.publisher.Mono;\n+\n+/** An immutable client-side representation of an Azure Container Group. */\n+@Fluent\n+@Beta\n+public interface ContainerGroup\n+    extends GroupableResource<ContainerInstanceManager, ContainerGroupInner>,\n+        Refreshable<ContainerGroup>,\n+        Updatable<ContainerGroup.Update> {\n+\n+    /***********************************************************\n+     * Getters\n+     ***********************************************************/\n+\n+    /** @return the container instances in this container group */\n+    Map<String, Container> containers();\n+\n+    /** @return all the ports publicly exposed for this container group */\n+    Set<Port> externalPorts();\n+\n+    /** @return the TCP ports publicly exposed for this container group */\n+    int[] externalTcpPorts();\n+\n+    /** @return the UDP ports publicly exposed for this container group */\n+    int[] externalUdpPorts();\n+\n+    /** @return the volumes for this container group */\n+    Map<String, Volume> volumes();\n+\n+    /** @return the Docker image registry servers by which the container group is created from */\n+    Collection<String> imageRegistryServers();\n+\n+    /** @return the container group restart policy */\n+    ContainerGroupRestartPolicy restartPolicy();\n+\n+    /** @return the DNS prefix which was specified at creation time */\n+    String dnsPrefix();\n+\n+    /** @return the FQDN for the container group */\n+    String fqdn();\n+\n+    /** @return the IP address */\n+    String ipAddress();\n+\n+    /** @return true if IP address is public */\n+    boolean isIPAddressPublic();\n+\n+    /** @return true if IP address is private */\n+    boolean isIPAddressPrivate();\n+\n+    /** @return the base level OS type required by the containers in the group */\n+    OperatingSystemTypes osType();\n+\n+    /** @return the state of the container group; only valid in response */\n+    String state();\n+\n+    /** @return the provisioningState of the container group */\n+    String provisioningState();\n+\n+    /** @return the container group events */\n+    Set<Event> events();\n+\n+    /** @return the DNS configuration for the container group */\n+    DnsConfiguration dnsConfig();\n+\n+    /** @return the id of the network profile for the container group */\n+    String networkProfileId();\n+\n+    /** @return whether managed service identity is enabled for the container group */\n+    boolean isManagedServiceIdentityEnabled();\n+\n+    /**\n+     * @return the tenant id of the system assigned managed service identity. Null if managed service identity is not\n+     *     configured.\n+     */\n+    String systemAssignedManagedServiceIdentityTenantId();\n+\n+    /**\n+     * @return the principal id of the system assigned managed service identity. Null if managed service identity is not\n+     *     configured.\n+     */\n+    String systemAssignedManagedServiceIdentityPrincipalId();\n+\n+    /** @return whether managed service identity is system assigned, user assigned, both, or neither */\n+    ResourceIdentityType managedServiceIdentityType();\n+\n+    /** @return the ids of the user assigned managed service identities. Returns an empty set if no MSIs are set. */\n+    Set<String> userAssignedManagedServiceIdentityIds();\n+\n+    /** @return the log analytics information of the container group. */\n+    LogAnalytics logAnalytics();\n+\n+    /***********************************************************\n+     * Actions\n+     ***********************************************************/\n+\n+    /**\n+     * Restarts all containers in a container group in place. If container image has updates, new image will be\n+     * downloaded.\n+     */\n+    void restart();\n+\n+    /**\n+     * Restarts all containers in a container group in place asynchronously. If container image has updates, new image\n+     * will be downloaded.\n+     *\n+     * @return a representation of the deferred computation of this call\n+     */\n+    Mono<Void> restartAsync();\n+\n+    /** Stops all containers in a container group. Compute resources will be de-allocated and billing will stop. */\n+    void stop();\n+\n+    /**\n+     * Stops all containers in a container group asynchronously. Compute resources will be de-allocated and billing will\n+     * stop.\n+     *\n+     * @return a representation of the deferred computation of this call\n+     */\n+    Mono<Void> stopAsync();\n+\n+    /**\n+     * Get the log content for the specified container instance within the container group.\n+     *\n+     * @param containerName the container instance name\n+     * @throws IllegalArgumentException thrown if parameters fail the validation\n+     * @return all available log lines\n+     */\n+    String getLogContent(String containerName);\n+\n+    /**\n+     * Get the log content for the specified container instance within the container group.\n+     *\n+     * @param containerName the container instance name\n+     * @param tailLineCount only get the last log lines up to this\n+     * @throws IllegalArgumentException thrown if parameters fail the validation\n+     * @return the log lines from the end, up to the number specified\n+     */\n+    String getLogContent(String containerName, int tailLineCount);\n+\n+    /**\n+     * Get the log content for the specified container instance within the container group.\n+     *\n+     * @param containerName the container instance name\n+     * @throws IllegalArgumentException thrown if parameters fail the validation\n+     * @return a representation of the future computation of this call\n+     */\n+    Mono<String> getLogContentAsync(String containerName);\n+\n+    /**\n+     * Get the log content for the specified container instance within the container group.\n+     *\n+     * @param containerName the container instance name\n+     * @param tailLineCount only get the last log lines up to this\n+     * @throws IllegalArgumentException thrown if parameters fail the validation\n+     * @return a representation of the future computation of this call\n+     */\n+    Mono<String> getLogContentAsync(String containerName, int tailLineCount);\n+\n+    /**\n+     * Starts the exec command for a specific container instance.\n+     *\n+     * @param containerName the container instance name\n+     * @param command the command to be executed\n+     * @param row the row size of the terminal\n+     * @param column the column size of the terminal\n+     * @throws IllegalArgumentException thrown if parameters fail the validation\n+     * @return the log lines from the end, up to the number specified\n+     */\n+    ContainerExecResponse executeCommand(String containerName, String command, int row, int column);\n+\n+    /**\n+     * Starts the exec command for a specific container instance within the container group.\n+     *\n+     * @param containerName the container instance name\n+     * @param command the command to be executed\n+     * @param row the row size of the terminal\n+     * @param column the column size of the terminal\n+     * @throws IllegalArgumentException thrown if parameters fail the validation\n+     * @return a representation of the future computation of this call\n+     */\n+    Mono<ContainerExecResponse> executeCommandAsync(String containerName, String command, int row, int column);\n+\n+    /** Starts the exec command for a specific container instance within the current group asynchronously. */\n+    interface Definition\n+        extends DefinitionStages.Blank,\n+            DefinitionStages.WithGroup,\n+            DefinitionStages.WithOsType,\n+            DefinitionStages.WithPublicOrPrivateImageRegistry,\n+            DefinitionStages.WithPrivateImageRegistryOrVolume,\n+            DefinitionStages.WithVolume,\n+            DefinitionStages.WithFirstContainerInstance,\n+            DefinitionStages.WithSystemAssignedManagedServiceIdentity,\n+            DefinitionStages.WithSystemAssignedIdentityBasedAccessOrCreate,\n+            DefinitionStages.WithNextContainerInstance,\n+            DefinitionStages.DnsConfigFork,\n+            DefinitionStages.WithCreate {\n+    }\n+\n+    /** Grouping of the container group definition stages. */\n+    interface DefinitionStages {\n+        /** The first stage of the container group definition. */\n+        interface Blank extends GroupableResource.DefinitionWithRegion<WithGroup> {\n+        }\n+\n+        /** The stage of the container group definition allowing to specify the resource group. */\n+        interface WithGroup extends GroupableResource.DefinitionStages.WithGroup<DefinitionStages.WithOsType> {\n+        }\n+\n+        /** The stage of the container group definition allowing to specify the OS type. */\n+        interface WithOsType {\n+            /**\n+             * Specifies this is a Linux container group.\n+             *\n+             * @return the next stage of the definition\n+             */\n+            WithPublicOrPrivateImageRegistry withLinux();\n+\n+            /**\n+             * Specifies this is a Windows container group.\n+             *\n+             * @return the next stage of the definition\n+             */\n+            WithPublicOrPrivateImageRegistry withWindows();\n+        }\n+\n+        /** The stage of the container group definition allowing to specify a public only or private image registry. */\n+        interface WithPublicOrPrivateImageRegistry extends WithPublicImageRegistryOnly, WithPrivateImageRegistry {\n+        }\n+\n+        /** The stage of the container group definition allowing to skip the private image registry. */\n+        interface WithPublicImageRegistryOnly {\n+            /**\n+             * Only public container image repository will be used to create the container instances in the container\n+             * group.\n+             *\n+             * @return the next stage of the definition\n+             */\n+            WithPrivateImageRegistryOrVolume withPublicImageRegistryOnly();\n+        }\n+\n+        /** The stage of the container group definition allowing to specify a private image registry. */\n+        interface WithPrivateImageRegistry {\n+            /**\n+             * Specifies the private container image registry server login for the container group.\n+             *\n+             * @param server Docker image registry server, without protocol such as \"http\" and \"https\"\n+             * @param username the username for the private registry\n+             * @param password the password for the private registry\n+             * @return the next stage of the definition\n+             */\n+            WithPrivateImageRegistryOrVolume withPrivateImageRegistry(String server, String username, String password);\n+        }\n+\n+        /** The stage of the container group definition allowing to specify a private image registry or a volume. */\n+        interface WithPrivateImageRegistryOrVolume extends WithPrivateImageRegistry {\n+            /**\n+             * Skips the definition of volumes to be shared by the container instances.\n+             *\n+             * <p>An IllegalArgumentException will be thrown if a container instance attempts to define a volume\n+             * mounting.\n+             *\n+             * @return the next stage of the definition\n+             */\n+            WithFirstContainerInstance withoutVolume();\n+\n+            /**\n+             * Specifies a new Azure file share name to be created.\n+             *\n+             * @param volumeName the name of the volume\n+             * @param shareName the Azure file share name to be created\n+             * @return the next stage of the definition\n+             */\n+            WithFirstContainerInstance withNewAzureFileShareVolume(String volumeName, String shareName);\n+\n+            /**\n+             * Specifies an empty directory volume that can be shared by the container instances in the container group.\n+             *\n+             * @param name the name of the empty directory volume\n+             * @return the next stage of the definition\n+             */\n+            WithFirstContainerInstance withEmptyDirectoryVolume(String name);\n+\n+            /**\n+             * Begins the definition of a volume that can be shared by the container instances in the container group.\n+             *\n+             * <p>The definition must be completed with a call to {@link\n+             * VolumeDefinitionStages.WithVolumeAttach#attach()}\n+             *\n+             * @param name the name of the volume\n+             * @return the next stage of the definition\n+             */\n+            VolumeDefinitionStages.VolumeDefinitionBlank<WithVolume> defineVolume(String name);\n+        }\n+\n+        /**\n+         * The stage of the container group definition allowing to specify a volume that can be mounted by a container\n+         * instance.\n+         */\n+        interface WithVolume extends WithFirstContainerInstance {\n+            /**\n+             * Begins the definition of a volume that can be shared by the container instances in the container group.\n+             *\n+             * <p>The definition must be completed with a call to {@link\n+             * VolumeDefinitionStages.WithVolumeAttach#attach()}\n+             *\n+             * @param name the name of the volume\n+             * @return the next stage of the definition\n+             */\n+            VolumeDefinitionStages.VolumeDefinitionBlank<WithVolume> defineVolume(String name);\n+        }\n+\n+        /** Grouping of volume definition stages. */\n+        interface VolumeDefinitionStages {\n+            /**\n+             * The first stage of the volume definition.\n+             *\n+             * @param <ParentT> the stage of the parent definition to return to after attaching this definition\n+             */\n+            interface VolumeDefinitionBlank<ParentT> extends WithAzureFileShare<ParentT> {\n+            }\n+\n+            /**\n+             * The stage of the volume definition allowing to specify a read only Azure File Share name.\n+             *\n+             * @param <ParentT> the stage of the parent definition to return to after attaching this definition\n+             */\n+            interface WithAzureFileShare<ParentT> {\n+                /**\n+                 * Specifies an existing Azure file share name.\n+                 *\n+                 * @param shareName an existing Azure file share name\n+                 * @return the next stage of the definition\n+                 */\n+                WithStorageAccountName<ParentT> withExistingReadWriteAzureFileShare(String shareName);\n+\n+                /**\n+                 * Specifies an existing Azure file share name.\n+                 *\n+                 * @param shareName an existing Azure file share name\n+                 * @return the next stage of the definition\n+                 */\n+                WithStorageAccountName<ParentT> withExistingReadOnlyAzureFileShare(String shareName);\n+            }\n+\n+            /**\n+             * The stage of the volume definition allowing to specify the storage account name to access to the Azure\n+             * file.\n+             *\n+             * @param <ParentT> the stage of the parent definition to return to after attaching this definition\n+             */\n+            interface WithStorageAccountName<ParentT> {\n+                /**\n+                 * Specifies the storage account name to access to the Azure file.\n+                 *\n+                 * @param storageAccountName the storage account name\n+                 * @return the next stage of the definition\n+                 */\n+                WithStorageAccountKey<ParentT> withStorageAccountName(String storageAccountName);\n+            }\n+\n+            /**\n+             * The stage of the volume definition allowing to specify the storage account key to access to the Azure\n+             * file.\n+             *\n+             * @param <ParentT> the stage of the parent definition to return to after attaching this definition\n+             */\n+            interface WithStorageAccountKey<ParentT> {\n+                /**\n+                 * Specifies the storage account key to access to the Azure file.\n+                 *\n+                 * @param storageAccountKey the storage account key\n+                 * @return the next stage of the definition\n+                 */\n+                WithVolumeAttach<ParentT> withStorageAccountKey(String storageAccountKey);\n+            }\n+\n+            /**\n+             * The stage of the volume definition allowing to specify the secrets map.\n+             *\n+             * @param <ParentT> the stage of the parent definition to return to after attaching this definition\n+             */\n+            interface WithSecretsMap<ParentT> {\n+                /**\n+                 * Specifies the secrets map.\n+                 *\n+                 * <p>The secret value must be specified in Base64 encoding\n+                 *\n+                 * @param secrets the new volume secrets map; value must be in Base64 encoding\n+                 * @return the next stage of the definition\n+                 */\n+                WithVolumeAttach<ParentT> withSecrets(Map<String, String> secrets);\n+            }\n+\n+            /**\n+             * The stage of the volume definition allowing to specify the Git URL mappings.\n+             *\n+             * @param <ParentT> the stage of the parent definition to return to after attaching this definition\n+             */\n+            interface WithGitUrl<ParentT> {\n+                /**\n+                 * Specifies the Git URL for the new volume.\n+                 *\n+                 * @param gitUrl the Git URL for the new volume\n+                 * @return the next stage of the definition\n+                 */\n+                WithGitDirectoryName<ParentT> withGitUrl(String gitUrl);\n+            }\n+\n+            /**\n+             * The stage of the volume definition allowing to specify the Git target directory name mappings.\n+             *\n+             * @param <ParentT> the stage of the parent definition to return to after attaching this definition\n+             */\n+            interface WithGitDirectoryName<ParentT> extends WithGitRevision<ParentT> {\n+                /**\n+                 * Specifies the Git target directory name for the new volume.\n+                 *\n+                 * <p>Must not contain or start with '..'. If '.' is supplied, the volume directory will be the git\n+                 * repository. Otherwise, if specified, the volume will contain the git repository in the subdirectory\n+                 * with the given name.\n+                 *\n+                 * @param gitDirectoryName the Git target directory name for the new volume\n+                 * @return the next stage of the definition\n+                 */\n+                WithGitRevision<ParentT> withGitDirectoryName(String gitDirectoryName);\n+            }\n+\n+            /**\n+             * The stage of the volume definition allowing to specify the Git revision.\n+             *\n+             * @param <ParentT> the stage of the parent definition to return to after attaching this definition\n+             */\n+            interface WithGitRevision<ParentT> extends WithVolumeAttach<ParentT> {\n+                /**\n+                 * Specifies the Git revision for the new volume.\n+                 *\n+                 * @param gitRevision the Git revision for the new volume\n+                 * @return the next stage of the definition\n+                 */\n+                WithVolumeAttach<ParentT> withGitRevision(String gitRevision);\n+            }\n+\n+            /**\n+             * The final stage of the volume definition.\n+             *\n+             * <p>At this stage, any remaining optional settings can be specified, or the subnet definition can be\n+             * attached to the parent virtual network definition.\n+             *\n+             * @param <ParentT> the stage of the parent definition to return to after attaching this definition\n+             */\n+            interface WithVolumeAttach<ParentT> extends Attachable.InDefinition<ParentT> {\n+            }\n+\n+            /** Grouping of the container group's volume definition stages. */\n+            interface VolumeDefinition<ParentT>\n+                extends VolumeDefinitionBlank<ParentT>,\n+                    WithAzureFileShare<ParentT>,\n+                    WithStorageAccountName<ParentT>,\n+                    WithStorageAccountKey<ParentT>,\n+                    WithSecretsMap<ParentT>,\n+                    WithGitUrl<ParentT>,\n+                    WithGitDirectoryName<ParentT>,\n+                    WithGitRevision<ParentT>,\n+                    WithVolumeAttach<ParentT> {\n+            }\n+        }\n+\n+        /** The stage of the container group definition allowing to specify first required container instance. */\n+        interface WithFirstContainerInstance {\n+            /**\n+             * Begins the definition of a container instance.\n+             *\n+             * @param name the name of the container instance\n+             * @return the next stage of the definition\n+             */\n+            ContainerInstanceDefinitionStages.ContainerInstanceDefinitionBlank<WithNextContainerInstance>\n+                defineContainerInstance(String name);\n+\n+            /**\n+             * Defines one container instance for the specified image with one CPU count and 1.5 GB memory, with TCP\n+             * port 80 opened externally.\n+             *\n+             * @param imageName the name of the container image\n+             * @return the next stage of the definition\n+             */\n+            WithCreate withContainerInstance(String imageName);\n+\n+            /**\n+             * Defines one container instance for the specified image with one CPU count and 1.5 GB memory, with a\n+             * custom TCP port opened externally.\n+             *\n+             * @param imageName the name of the container image\n+             * @param port the external port to be opened\n+             * @return the next stage of the definition\n+             */\n+            WithCreate withContainerInstance(String imageName, int port);\n+        }\n+\n+        /** The stage of the container group definition allowing to specify a container instance. */\n+        interface WithNextContainerInstance extends WithCreate {\n+            /**\n+             * Begins the definition of a container instance.\n+             *\n+             * @param name the name of the volume\n+             * @return the next stage of the definition\n+             */\n+            ContainerInstanceDefinitionStages.ContainerInstanceDefinitionBlank<WithNextContainerInstance>\n+                defineContainerInstance(String name);\n+        }\n+\n+        /** Grouping of volume definition stages. */\n+        interface ContainerInstanceDefinitionStages {\n+            /**\n+             * The first stage of the container instance definition.\n+             *\n+             * @param <ParentT> the stage of the parent definition to return to after attaching this definition\n+             */\n+            interface ContainerInstanceDefinitionBlank<ParentT> extends WithImage<ParentT> {\n+            }\n+\n+            /**\n+             * The stage of the container instance definition allowing to specify the container image.\n+             *\n+             * @param <ParentT> the stage of the parent definition to return to after attaching this definition\n+             */\n+            interface WithImage<ParentT> {\n+                /**\n+                 * Specifies the container image to be used.\n+                 *\n+                 * @param imageName the container image\n+                 * @return the next stage of the definition\n+                 */\n+                WithOrWithoutPorts<ParentT> withImage(String imageName);\n+            }\n+\n+            /**\n+             * The stage of the container instance definition allowing to specify (or not) the container ports.\n+             *\n+             * @param <ParentT> the stage of the parent definition to return to after attaching this definition\n+             */\n+            interface WithOrWithoutPorts<ParentT> extends WithPorts<ParentT>, WithoutPorts<ParentT> {\n+            }\n+\n+            /**\n+             * The stage of the container instance definition allowing not to specify any container ports internal or\n+             * external.\n+             *\n+             * @param <ParentT> the stage of the parent definition to return to after attaching this definition\n+             */\n+            interface WithoutPorts<ParentT> {\n+                /**\n+                 * Specifies that not ports will be opened internally or externally for this container instance.\n+                 *\n+                 * @return the next stage of the definition\n+                 */\n+                WithContainerInstanceAttach<ParentT> withoutPorts();\n+            }\n+\n+            /**\n+             * The stage of the container instance definition allowing to specify one or more container ports.\n+             *\n+             * @param <ParentT> the stage of the parent definition to return to after attaching this definition\n+             */\n+            interface WithPortsOrContainerInstanceAttach<ParentT>\n+                extends WithPorts<ParentT>, WithContainerInstanceAttach<ParentT> {\n+            }\n+\n+            /**\n+             * The stage of the container instance definition allowing to specify the container ports.\n+             *\n+             * @param <ParentT> the stage of the parent definition to return to after attaching this definition\n+             */\n+            interface WithPorts<ParentT> {\n+                /**\n+                 * Specifies the container's TCP ports available to external clients.\n+                 *\n+                 * <p>A public IP address will be create to allow external clients to reach the containers within the\n+                 * group. To enable external clients to reach a container within the group, you must expose the port on\n+                 * the IP address and from the container. Because containers within the group share a port namespace,\n+                 * port mapping is not supported.\n+                 *\n+                 * @param ports array of TCP ports to be exposed externally\n+                 * @return the next stage of the definition\n+                 */\n+                WithPortsOrContainerInstanceAttach<ParentT> withExternalTcpPorts(int... ports);\n+\n+                /**\n+                 * Specifies the container's TCP port available to external clients.\n+                 *\n+                 * <p>A public IP address will be create to allow external clients to reach the containers within the\n+                 * group. To enable external clients to reach a container within the group, you must expose the port on\n+                 * the IP address and from the container. Because containers within the group share a port namespace,\n+                 * port mapping is not supported.\n+                 *\n+                 * @param port TCP port to be exposed externally\n+                 * @return the next stage of the definition\n+                 */\n+                WithPortsOrContainerInstanceAttach<ParentT> withExternalTcpPort(int port);\n+\n+                /**\n+                 * Specifies the container's UDP ports available to external clients.\n+                 *\n+                 * <p>A public IP address will be create to allow external clients to reach the containers within the\n+                 * group. To enable external clients to reach a container within the group, you must expose the port on\n+                 * the IP address and from the container. Because containers within the group share a port namespace,\n+                 * port mapping is not supported.\n+                 *\n+                 * @param ports array of UDP ports to be exposed externally\n+                 * @return the next stage of the definition\n+                 */\n+                WithPortsOrContainerInstanceAttach<ParentT> withExternalUdpPorts(int... ports);\n+\n+                /**\n+                 * Specifies the container's UDP port available to external clients.\n+                 *\n+                 * <p>A public IP address will be create to allow external clients to reach the containers within the\n+                 * group. To enable external clients to reach a container within the group, you must expose the port on\n+                 * the IP address and from the container. Because containers within the group share a port namespace,\n+                 * port mapping is not supported.\n+                 *\n+                 * @param port UDP port to be exposed externally\n+                 * @return the next stage of the definition\n+                 */\n+                WithPortsOrContainerInstanceAttach<ParentT> withExternalUdpPort(int port);\n+\n+                /**\n+                 * Specifies the container's TCP ports are available to internal clients only (other container instances\n+                 * within the container group).\n+                 *\n+                 * <p>Containers within a group can reach each other via localhost on the ports that they have exposed,\n+                 * even if those ports are not exposed externally on the group's IP address.\n+                 *\n+                 * @param ports array of TCP ports to be exposed internally\n+                 * @return the next stage of the definition\n+                 */\n+                WithPortsOrContainerInstanceAttach<ParentT> withInternalTcpPorts(int... ports);\n+\n+                /**\n+                 * Specifies the container's Udp ports are available to internal clients only (other container instances\n+                 * within the container group).\n+                 *\n+                 * <p>Containers within a group can reach each other via localhost on the ports that they have exposed,\n+                 * even if those ports are not exposed externally on the group's IP address.\n+                 *\n+                 * @param ports array of UDP ports to be exposed internally\n+                 * @return the next stage of the definition\n+                 */\n+                WithPortsOrContainerInstanceAttach<ParentT> withInternalUdpPorts(int... ports);\n+\n+                /**\n+                 * Specifies the container's TCP port is available to internal clients only (other container instances\n+                 * within the container group).\n+                 *\n+                 * <p>Containers within a group can reach each other via localhost on the ports that they have exposed,\n+                 * even if those ports are not exposed externally on the group's IP address.\n+                 *\n+                 * @param port TCP port to be exposed internally\n+                 * @return the next stage of the definition\n+                 */\n+                WithPortsOrContainerInstanceAttach<ParentT> withInternalTcpPort(int port);\n+\n+                /**\n+                 * Specifies the container's UDP port is available to internal clients only (other container instances\n+                 * within the container group).\n+                 *\n+                 * <p>Containers within a group can reach each other via localhost on the ports that they have exposed,\n+                 * even if those ports are not exposed externally on the group's IP address.\n+                 *\n+                 * @param port UDP port to be exposed internally\n+                 * @return the next stage of the definition\n+                 */\n+                WithPortsOrContainerInstanceAttach<ParentT> withInternalUdpPort(int port);\n+            }\n+\n+            /**\n+             * The stage of the container instance definition allowing to specify the number of CPU cores.\n+             *\n+             * <p>The CPU cores can be specified as a fraction, i.e. 1.5 represents one and a half atomic CPU cores will\n+             * be assigned to this container instance.\n+             *\n+             * @param <ParentT> the stage of the parent definition to return to after attaching this definition\n+             */\n+            interface WithCpuCoreCount<ParentT> {\n+                /**\n+                 * Specifies the number of CPU cores assigned to this container instance.\n+                 *\n+                 * @param cpuCoreCount the number of CPU cores\n+                 * @return the next stage of the definition\n+                 */\n+                WithContainerInstanceAttach<ParentT> withCpuCoreCount(double cpuCoreCount);\n+            }\n+\n+            interface WithGpuResource<ParentT> {\n+                WithContainerInstanceAttach<ParentT> withGpuResource(int gpuCoreCount, GpuSku gpuSku);\n+            }\n+\n+            /**\n+             * The stage of the container instance definition allowing to specify the memory size in GB.\n+             *\n+             * <p>The memory size can be specified as a fraction, i.e. 1.5 represents one and a half GB of memory.\n+             *\n+             * @param <ParentT> the stage of the parent definition to return to after attaching this definition\n+             */\n+            interface WithMemorySize<ParentT> {\n+                /**\n+                 * Specifies the memory size in GB assigned to this container instance.\n+                 *\n+                 * @param memorySize the memory size in GB\n+                 * @return the next stage of the definition\n+                 */\n+                WithContainerInstanceAttach<ParentT> withMemorySizeInGB(double memorySize);\n+            }\n+\n+            /**\n+             * The stage of the container instance definition allowing to specify the starting command line.\n+             *\n+             * @param <ParentT> the stage of the parent definition to return to after attaching this definition\n+             */\n+            interface WithStartingCommandLine<ParentT> {\n+                /**\n+                 * Specifies the starting command lines.\n+                 *\n+                 * @param executable the executable which it will call after initializing the container\n+                 * @param parameters the parameter list for the executable to be called\n+                 * @return the next stage of the definition\n+                 */\n+                WithContainerInstanceAttach<ParentT> withStartingCommandLine(String executable, String... parameters);\n+\n+                /**\n+                 * Specifies the starting command line.\n+                 *\n+                 * @param executable the executable or path to the executable that will be called after initializing the\n+                 *     container\n+                 * @return the next stage of the definition\n+                 */\n+                WithContainerInstanceAttach<ParentT> withStartingCommandLine(String executable);\n+            }\n+\n+            /**\n+             * The stage of the container instance definition allowing to specify the environment variables.\n+             *\n+             * @param <ParentT> the stage of the parent definition to return to after attaching this definition\n+             */\n+            interface WithEnvironmentVariables<ParentT> {\n+                /**\n+                 * Specifies the environment variables.\n+                 *\n+                 * @param environmentVariables the environment variables in a name and value pair to be set after the\n+                 *     container gets initialized\n+                 * @return the next stage of the definition\n+                 */\n+                WithContainerInstanceAttach<ParentT> withEnvironmentVariables(Map<String, String> environmentVariables);\n+\n+                /**\n+                 * Specifies the environment variable.\n+                 *\n+                 * @param envName the environment variable name\n+                 * @param envValue the environment variable value\n+                 * @return the next stage of the definition\n+                 */\n+                WithContainerInstanceAttach<ParentT> withEnvironmentVariable(String envName, String envValue);\n+\n+                /**\n+                 * Specifies a collection of name and secure value pairs for the environment variables.\n+                 *\n+                 * @param environmentVariables the environment variables in a name and value pair to be set after the\n+                 *     container gets initialized\n+                 * @return the next stage of the definition\n+                 */\n+                WithContainerInstanceAttach<ParentT> withEnvironmentVariableWithSecuredValue(\n+                    Map<String, String> environmentVariables);\n+\n+                /**\n+                 * Specifies the environment variable that has a secured value.\n+                 *\n+                 * @param envName the environment variable name\n+                 * @param securedValue the environment variable secured value\n+                 * @return the next stage of the definition\n+                 */\n+                WithContainerInstanceAttach<ParentT> withEnvironmentVariableWithSecuredValue(\n+                    String envName, String securedValue);\n+            }\n+\n+            /**\n+             * The stage of the container instance definition allowing to specify volume mount setting.\n+             *\n+             * @param <ParentT> the stage of the parent definition to return to after attaching this definition\n+             */\n+            interface WithVolumeMountSetting<ParentT> {\n+                /**\n+                 * Specifies the container group's volume to be mounted by the container instance at a specified mount\n+                 * path.\n+                 *\n+                 * <p>Mounting an Azure file share as a volume in a container is a two-step process. First, you provide\n+                 * the details of the share as part of defining the container group, then you specify how you wan the\n+                 * volume mounted within one or more of the containers in the group.\n+                 *\n+                 * @param volumeName the volume name as defined in the volumes of the container group\n+                 * @param mountPath the local path the volume will be mounted at\n+                 * @return the next stage of the definition\n+                 * @throws IllegalArgumentException thrown if volumeName was not defined in the respective container\n+                 *     group definition stage.\n+                 */\n+                WithContainerInstanceAttach<ParentT> withVolumeMountSetting(String volumeName, String mountPath);\n+\n+                /**\n+                 * Specifies the container group's volume to be mounted by the container instance at a specified mount\n+                 * path.\n+                 *\n+                 * <p>Mounting an Azure file share as a volume in a container is a two-step process. First, you provide\n+                 * the details of the share as part of defining the container group, then you specify how you wan the\n+                 * volume mounted within one or more of the containers in the group.\n+                 *\n+                 * @param volumeMountSetting the name and value pair representing volume names as defined in the volumes\n+                 *     of the container group and the local paths the volume will be mounted at\n+                 * @return the next stage of the definition\n+                 * @throws IllegalArgumentException thrown if volumeName was not defined in the respective container\n+                 *     group definition stage.\n+                 */\n+                WithContainerInstanceAttach<ParentT> withVolumeMountSetting(Map<String, String> volumeMountSetting);\n+\n+                /**\n+                 * Specifies the container group's volume to be mounted by the container instance at a specified mount\n+                 * path.\n+                 *\n+                 * <p>Mounting an Azure file share as a volume in a container is a two-step process. First, you provide\n+                 * the details of the share as part of defining the container group, then you specify how you wan the\n+                 * volume mounted within one or more of the containers in the group.\n+                 *\n+                 * @param volumeName the volume name as defined in the volumes of the container group\n+                 * @param mountPath the local path the volume will be mounted at\n+                 * @return the next stage of the definition\n+                 * @throws IllegalArgumentException thrown if volumeName was not defined in the respective container\n+                 *     group definition stage.\n+                 */\n+                WithContainerInstanceAttach<ParentT> withReadOnlyVolumeMountSetting(\n+                    String volumeName, String mountPath);\n+\n+                /**\n+                 * Specifies the container group's volume to be mounted by the container instance at a specified mount\n+                 * path.\n+                 *\n+                 * <p>Mounting an Azure file share as a volume in a container is a two-step process. First, you provide\n+                 * the details of the share as part of defining the container group, then you specify how you wan the\n+                 * volume mounted within one or more of the containers in the group.\n+                 *\n+                 * @param volumeMountSetting the name and value pair representing volume names as defined in the volumes\n+                 *     of the container group and the local paths the volume will be mounted at\n+                 * @return the next stage of the definition\n+                 * @throws IllegalArgumentException thrown if volumeName was not defined in the respective container\n+                 *     group definition stage.\n+                 */\n+                WithContainerInstanceAttach<ParentT> withReadOnlyVolumeMountSetting(\n+                    Map<String, String> volumeMountSetting);\n+            }\n+\n+            /**\n+             * The final stage of the container instance definition.\n+             *\n+             * <p>At this stage, any remaining optional settings can be specified, or the subnet definition can be\n+             * attached to the parent virtual network definition.\n+             *\n+             * @param <ParentT> the stage of the parent definition to return to after attaching this definition\n+             */\n+            interface WithContainerInstanceAttach<ParentT>\n+                extends WithCpuCoreCount<ParentT>,\n+                    WithGpuResource<ParentT>,\n+                    WithMemorySize<ParentT>,\n+                    WithStartingCommandLine<ParentT>,\n+                    WithEnvironmentVariables<ParentT>,\n+                    WithVolumeMountSetting<ParentT>,\n+                    Attachable.InDefinition<ParentT> {\n+            }\n+\n+            /** Grouping of the container group's volume definition stages. */\n+            interface ContainerInstanceDefinition<ParentT>\n+                extends ContainerInstanceDefinitionBlank<ParentT>,\n+                    WithImage<ParentT>,\n+                    WithOrWithoutPorts<ParentT>,\n+                    WithPortsOrContainerInstanceAttach<ParentT>,\n+                    WithContainerInstanceAttach<ParentT> {\n+            }\n+        }\n+\n+        /**\n+         * The stage of the container instance definition allowing to specify having system assigned managed service\n+         * identity.\n+         */\n+        interface WithSystemAssignedManagedServiceIdentity {\n+            /**\n+             * Specifies a system assigned managed service identity for the container group.\n+             *\n+             * @return the next stage of the definition\n+             */\n+            WithSystemAssignedIdentityBasedAccessOrCreate withSystemAssignedManagedServiceIdentity();\n+        }\n+\n+        /**\n+         * The stage of the container instance definition allowing to specify system assigned managed service identity\n+         * with specific role based access.\n+         */\n+        interface WithSystemAssignedIdentityBasedAccessOrCreate extends WithCreate {\n+            /**\n+             * Specifies a system assigned managed service identity with access to a specific resource with a specified\n+             * role.\n+             *\n+             * @param resourceId the id of the resource you are setting up access to\n+             * @param role access role to be assigned to the identity\n+             * @return the next stage of the definition\n+             */\n+            WithSystemAssignedIdentityBasedAccessOrCreate withSystemAssignedIdentityBasedAccessTo(\n+                String resourceId, BuiltInRole role);\n+\n+            /**\n+             * Specifies a system assigned managed service identity with access to the current resource group and with\n+             * the specified role.\n+             *\n+             * @param role access role to be assigned to the identity\n+             * @return the next stage of the definition\n+             */\n+            WithSystemAssignedIdentityBasedAccessOrCreate withSystemAssignedIdentityBasedAccessToCurrentResourceGroup(\n+                BuiltInRole role);\n+\n+            /**\n+             * Specifies a system assigned managed service identity with access to a specific resource with a specified\n+             * role from the id.\n+             *\n+             * @param resourceId the id of the resource you are setting up access to\n+             * @param roleDefinitionId id of the access role to be assigned to the identity\n+             * @return the next stage of the definition\n+             */\n+            WithSystemAssignedIdentityBasedAccessOrCreate withSystemAssignedIdentityBasedAccessTo(\n+                String resourceId, String roleDefinitionId);\n+\n+            /**\n+             * Specifies a system assigned managed service identity with access to the current resource group and with\n+             * the specified role from the id.\n+             *\n+             * @param roleDefinitionId id of the access role to be assigned to the identity\n+             * @return the next stage of the definition\n+             */\n+            WithSystemAssignedIdentityBasedAccessOrCreate withSystemAssignedIdentityBasedAccessToCurrentResourceGroup(\n+                String roleDefinitionId);\n+        }\n+\n+        /**\n+         * The stage of the container instance definition allowing to specify user assigned managed service identity.\n+         */\n+        interface WithUserAssignedManagedServiceIdentity {\n+            /**\n+             * Specifies the definition of a not-yet-created user assigned identity to be associated with the virtual\n+             * machine.\n+             *\n+             * @param creatableIdentity a creatable identity definition\n+             * @return the next stage of the definition\n+             */\n+            WithCreate withNewUserAssignedManagedServiceIdentity(Creatable<Identity> creatableIdentity);\n+\n+            /**\n+             * Specifies an existing user assigned identity to be associate with the container group.\n+             *\n+             * @param identity the identity\n+             * @return the next stage of the definition\n+             */\n+            WithCreate withExistingUserAssignedManagedServiceIdentity(Identity identity);\n+        }\n+\n+        /** The stage of the container group definition allowing to specify the container group restart policy. */\n+        interface WithRestartPolicy {\n+            /**\n+             * Specifies the restart policy for all the container instances within the container group.\n+             *\n+             * @param restartPolicy the restart policy for all the container instances within the container group\n+             * @return the next stage of the definition\n+             */\n+            WithCreate withRestartPolicy(ContainerGroupRestartPolicy restartPolicy);\n+        }\n+\n+        /** The stage of the container group definition allowing to specify the DNS prefix label. */\n+        interface WithDnsPrefix {\n+            /**\n+             * Specifies the DNS prefix to be used to create the FQDN for the container group.\n+             *\n+             * @param dnsPrefix the DNS prefix to be used to create the FQDN for the container group\n+             * @return the next stage of the definition\n+             */\n+            WithCreate withDnsPrefix(String dnsPrefix);\n+        }\n+\n+        /** The stage of the container group definition allowing to specify the network profile id. */\n+        interface WithNetworkProfile {\n+            /**\n+             * Specifies the network profile information for a container group.\n+             *\n+             * @param subscriptionId the ID of the subscription of the network profile\n+             * @param resourceGroupName the name of the resource group of the network profile\n+             * @param networkProfileName the name of the network profile\n+             * @return the next stage of the definition\n+             */\n+            DnsConfigFork withNetworkProfileId(\n+                String subscriptionId, String resourceGroupName, String networkProfileName);\n+\n+            /**\n+             * Specifies the virtual network in network profile for a container group.\n+             *\n+             * @param virtualNetworkId the ID of the virtual network\n+             * @param subnetName the name of the subnet within the virtual network.; the subnet must have the service\n+             *     endpoints enabled for 'Microsoft.ContainerInstance/containerGroups'.\n+             * @return the next stage of the definition\n+             */\n+            DnsConfigFork withExistingVirtualNetwork(String virtualNetworkId, String subnetName);", "originalCommit": "2fff63b14095400606dab7ca68c774dbfccb229c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg5NDI0NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13371#discussion_r457894245", "bodyText": "remember to run credcheck for storage key", "author": "weidongxu-microsoft", "createdAt": "2020-07-21T07:32:03Z", "path": "sdk/containerinstance/mgmt/src/main/java/com/azure/resourcemanager/containerinstance/implementation/ContainerGroupImpl.java", "diffHunk": "@@ -0,0 +1,811 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.resourcemanager.containerinstance.implementation;\n+\n+import com.azure.core.management.Resource;\n+import com.azure.resourcemanager.authorization.implementation.RoleAssignmentHelper;\n+import com.azure.resourcemanager.authorization.models.BuiltInRole;\n+import com.azure.resourcemanager.containerinstance.ContainerInstanceManager;\n+import com.azure.resourcemanager.containerinstance.fluent.inner.ContainerGroupInner;\n+import com.azure.resourcemanager.containerinstance.models.Container;\n+import com.azure.resourcemanager.containerinstance.models.ContainerExecRequest;\n+import com.azure.resourcemanager.containerinstance.models.ContainerExecRequestTerminalSize;\n+import com.azure.resourcemanager.containerinstance.models.ContainerExecResponse;\n+import com.azure.resourcemanager.containerinstance.models.ContainerGroup;\n+import com.azure.resourcemanager.containerinstance.models.ContainerGroupDiagnostics;\n+import com.azure.resourcemanager.containerinstance.models.ContainerGroupIpAddressType;\n+import com.azure.resourcemanager.containerinstance.models.ContainerGroupNetworkProfile;\n+import com.azure.resourcemanager.containerinstance.models.ContainerGroupNetworkProtocol;\n+import com.azure.resourcemanager.containerinstance.models.ContainerGroupRestartPolicy;\n+import com.azure.resourcemanager.containerinstance.models.DnsConfiguration;\n+import com.azure.resourcemanager.containerinstance.models.Event;\n+import com.azure.resourcemanager.containerinstance.models.ImageRegistryCredential;\n+import com.azure.resourcemanager.containerinstance.models.IpAddress;\n+import com.azure.resourcemanager.containerinstance.models.LogAnalytics;\n+import com.azure.resourcemanager.containerinstance.models.LogAnalyticsLogType;\n+import com.azure.resourcemanager.containerinstance.models.OperatingSystemTypes;\n+import com.azure.resourcemanager.containerinstance.models.Port;\n+import com.azure.resourcemanager.containerinstance.models.ResourceIdentityType;\n+import com.azure.resourcemanager.containerinstance.models.Volume;\n+import com.azure.resourcemanager.msi.models.Identity;\n+import com.azure.resourcemanager.network.fluent.inner.IpConfigurationProfileInner;\n+import com.azure.resourcemanager.network.fluent.inner.NetworkProfileInner;\n+import com.azure.resourcemanager.network.fluent.inner.SubnetInner;\n+import com.azure.resourcemanager.network.models.ContainerNetworkInterfaceConfiguration;\n+import com.azure.resourcemanager.network.models.Network;\n+import com.azure.resourcemanager.resources.fluentcore.arm.models.implementation.GroupableParentResourceImpl;\n+import com.azure.resourcemanager.resources.fluentcore.model.Creatable;\n+import com.azure.resourcemanager.resources.fluentcore.utils.Utils;\n+import com.azure.resourcemanager.storage.models.StorageAccount;\n+import com.azure.storage.file.share.ShareServiceAsyncClient;\n+import com.azure.storage.file.share.ShareServiceClientBuilder;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+\n+/** Implementation for ContainerGroup and its create interfaces. */\n+public class ContainerGroupImpl\n+    extends GroupableParentResourceImpl<\n+        ContainerGroup, ContainerGroupInner, ContainerGroupImpl, ContainerInstanceManager>\n+    implements ContainerGroup, ContainerGroup.Definition, ContainerGroup.Update {\n+\n+    private String creatableStorageAccountKey;\n+    private Creatable<Network> creatableVirtualNetwork;\n+    private NetworkProfileInner creatableNetworkProfileInner;\n+    private String creatableNetworkProfileName;\n+    private Map<String, String> newFileShares;\n+\n+    private Map<String, Container> containers;\n+    private Map<String, Volume> volumes;\n+    private List<String> imageRegistryServers;\n+    private int[] externalTcpPorts;\n+    private int[] externalUdpPorts;\n+    private ContainerGroupMsiHandler containerGroupMsiHandler;\n+\n+    protected ContainerGroupImpl(String name, ContainerGroupInner innerObject, ContainerInstanceManager manager) {\n+        super(name, innerObject, manager);\n+        this.containerGroupMsiHandler = new ContainerGroupMsiHandler(this);\n+        initializeChildrenFromInner();\n+    }\n+\n+    private Mono<Void> beforeCreation() {\n+        Mono<Void> mono = Mono.empty();\n+        if (creatableVirtualNetwork != null) {\n+            mono =\n+                mono\n+                    .then(creatableVirtualNetwork.createAsync().last())\n+                    .flatMap(\n+                        network -> {\n+                            creatableVirtualNetwork = null;\n+                            return Mono.empty();\n+                        });\n+        }\n+        if (creatableNetworkProfileName != null && creatableNetworkProfileInner != null) {\n+            mono =\n+                mono\n+                    .then(\n+                        manager()\n+                            .networkManager()\n+                            .inner()\n+                            .getNetworkProfiles()\n+                            .createOrUpdateAsync(\n+                                resourceGroupName(), creatableNetworkProfileName, creatableNetworkProfileInner)\n+                            .flatMap(\n+                                profile -> {\n+                                    creatableNetworkProfileName = null;\n+                                    creatableNetworkProfileInner = null;\n+                                    return Mono.empty();\n+                                }));\n+        }\n+        return mono;\n+    }\n+\n+    @Override\n+    protected Mono<ContainerGroupInner> createInner() {\n+        this.containerGroupMsiHandler.processCreatedExternalIdentities();\n+        this.containerGroupMsiHandler.handleExternalIdentities();\n+        final ContainerGroupImpl self = this;\n+\n+        if (!isInCreateMode()) {\n+            Resource resource = new Resource();\n+            resource.withLocation(self.regionName());\n+            resource.withTags(self.tags());\n+            return beforeCreation()\n+                .then(\n+                    manager()\n+                        .inner()\n+                        .getContainerGroups()\n+                        .updateAsync(self.resourceGroupName(), self.name(), resource));\n+        } else if (newFileShares == null || creatableStorageAccountKey == null) {\n+            return beforeCreation()\n+                .then(manager().inner().getContainerGroups().createOrUpdateAsync(resourceGroupName(), name(), inner()));\n+        } else {\n+            final StorageAccount storageAccount = this.taskResult(this.creatableStorageAccountKey);\n+            return beforeCreation()\n+                .thenMany(createFileShareAsync(storageAccount))\n+                .map(\n+                    volumeParameters ->\n+                        this\n+                            .defineVolume(volumeParameters.volumeName)\n+                            .withExistingReadWriteAzureFileShare(volumeParameters.fileShareName)\n+                            .withStorageAccountName(storageAccount.name())\n+                            .withStorageAccountKey(volumeParameters.storageAccountKey)\n+                            .attach())\n+                .then(\n+                    this\n+                        .manager()\n+                        .inner()\n+                        .getContainerGroups()\n+                        .createOrUpdateAsync(resourceGroupName(), name(), inner()));\n+        }\n+    }\n+\n+    private static class VolumeParameters {\n+        private String volumeName;\n+        private String fileShareName;\n+        private String storageAccountKey;\n+\n+        VolumeParameters(String volumeName, String fileShareName, String storageAccountKey) {\n+            this.volumeName = volumeName;\n+            this.fileShareName = fileShareName;\n+            this.storageAccountKey = storageAccountKey;\n+        }\n+    }\n+\n+    private Flux<VolumeParameters> createFileShareAsync(final StorageAccount storageAccount) {\n+        return storageAccount\n+            .getKeysAsync()\n+            .map(storageAccountKeys -> storageAccountKeys.get(0).value())", "originalCommit": "2fff63b14095400606dab7ca68c774dbfccb229c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzkyOTc0Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13371#discussion_r457929746", "bodyText": "All playback tests are not using the Share File Volume, so no keys are recorded.", "author": "ChenTanyi", "createdAt": "2020-07-21T08:34:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg5NDI0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzkwNzQzNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13371#discussion_r457907437", "bodyText": "Why we add beta here?", "author": "xseeseesee", "createdAt": "2020-07-21T07:55:50Z", "path": "sdk/management/azure/src/main/java/com/azure/resourcemanager/Azure.java", "diffHunk": "@@ -682,13 +684,13 @@ public KubernetesClusters kubernetesClusters() {\n         return containerServiceManager.kubernetesClusters();\n     }\n \n-    //    /**\n-    //     * @return entry point to managing Azure Container Instances.\n-    //     */\n-    //    @Beta(SinceVersion.V1_3_0)\n-    //    public ContainerGroups containerGroups() {\n-    //        return containerInstanceManager.containerGroups();\n-    //    }\n+    /**\n+     * @return entry point to managing Azure Container Instances.\n+     */\n+    @Beta", "originalCommit": "2d2b97ebdf353bb84d6a088c51ca8b7ca9f8d5f1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzkxMTIwNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/13371#discussion_r457911204", "bodyText": "It is still a beta previously", "author": "ChenTanyi", "createdAt": "2020-07-21T08:02:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzkwNzQzNw=="}], "type": "inlineReview"}, {"oid": "3f92a3eab173dcc211e4b698ca1ca9508d64101a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3f92a3eab173dcc211e4b698ca1ca9508d64101a", "message": "add withExistingNetworkProfile and withNewNetworkProfileOnExistingVirtualNetwork", "committedDate": "2020-07-21T07:59:12Z", "type": "commit"}, {"oid": "198e80d56b9e033462450d7d9981cece7d03764f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/198e80d56b9e033462450d7d9981cece7d03764f", "message": "fix compile error", "committedDate": "2020-07-21T08:23:54Z", "type": "commit"}, {"oid": "dd50580f561c1791e4933e9b8c5ca07a10d89253", "url": "https://github.com/Azure/azure-sdk-for-java/commit/dd50580f561c1791e4933e9b8c5ca07a10d89253", "message": "remove Beta", "committedDate": "2020-07-21T08:25:37Z", "type": "commit"}, {"oid": "a3af859646720d5e45dd906edf5a5fe727b13ae5", "url": "https://github.com/Azure/azure-sdk-for-java/commit/a3af859646720d5e45dd906edf5a5fe727b13ae5", "message": "remove unused import", "committedDate": "2020-07-21T09:07:51Z", "type": "commit"}, {"oid": "f80cf7198aa0d6721544005e604057151cfa34b4", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f80cf7198aa0d6721544005e604057151cfa34b4", "message": "fix checkstyle", "committedDate": "2020-07-21T10:08:31Z", "type": "commit"}]}