{"pr_number": 10265, "pr_title": "Tracer support in cosmosdb", "pr_createdAt": "2020-04-15T19:27:26Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/10265", "timeline": [{"oid": "089307a3a8167f96dd38ecbf3c3a1ca6a1ca32b2", "url": "https://github.com/Azure/azure-sdk-for-java/commit/089307a3a8167f96dd38ecbf3c3a1ca6a1ca32b2", "message": "initial commit", "committedDate": "2020-04-08T14:36:47Z", "type": "commit"}, {"oid": "175222e616cf0ff1026ff70735fcc36377d05054", "url": "https://github.com/Azure/azure-sdk-for-java/commit/175222e616cf0ff1026ff70735fcc36377d05054", "message": "changing sample", "committedDate": "2020-04-08T14:46:01Z", "type": "commit"}, {"oid": "fe03e665cc2fdbef20b5aab7961a690854d8f48c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/fe03e665cc2fdbef20b5aab7961a690854d8f48c", "message": "adding query api tracer support", "committedDate": "2020-04-13T16:29:48Z", "type": "commit"}, {"oid": "9f9cce807228f3e8cbe3ec9654a58823f432ad4f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/9f9cce807228f3e8cbe3ec9654a58823f432ad4f", "message": "merging with master", "committedDate": "2020-04-14T18:46:05Z", "type": "commit"}, {"oid": "e2e8e9e468a8a8c038ea4c1cf70e33414395b775", "url": "https://github.com/Azure/azure-sdk-for-java/commit/e2e8e9e468a8a8c038ea4c1cf70e33414395b775", "message": "reverting change for jaeger ui local testing", "committedDate": "2020-04-14T19:25:12Z", "type": "commit"}, {"oid": "c2fc40f3a35df2381104f88817209804491ae329", "url": "https://github.com/Azure/azure-sdk-for-java/commit/c2fc40f3a35df2381104f88817209804491ae329", "message": "adding tracers in trigger udf and sproc", "committedDate": "2020-04-15T19:11:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA4MzE5MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r409083190", "bodyText": "As per conversation with Sameekhsa and Anu, core team will provide withContext, fluxContext api with map attributes to handle nested calls on sdk more cleanly", "author": "simplynaveen20", "createdAt": "2020-04-15T19:30:04Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncClient.java", "diffHunk": "@@ -223,10 +221,14 @@ CosmosKeyCredential cosmosKeyCredential() {\n         }\n         Database wrappedDatabase = new Database();\n         wrappedDatabase.setId(databaseSettings.getId());\n-        return asyncDocumentClient.createDatabase(wrappedDatabase, ModelBridgeInternal.toRequestOptions(options))\n-                   .map(databaseResourceResponse -> ModelBridgeInternal.createCosmosAsyncDatabaseResponse(databaseResourceResponse,\n-                       this))\n-                   .single();\n+        final CosmosDatabaseRequestOptions requestOptions = options;\n+        return withContext(context -> createDatabase(wrappedDatabase, requestOptions, context)).subscriberContext(reactorContext -> {", "originalCommit": "c2fc40f3a35df2381104f88817209804491ae329", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE4NTg4Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r409185883", "bodyText": "This overload should already be available to use on latest core i.e <version>1.4.0-beta.1</version>", "author": "samvaity", "createdAt": "2020-04-15T23:08:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA4MzE5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ5NzM0Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r412497347", "bodyText": "Checked offline with Sameeksha 1.4.0-beta.1 does not have the requested overload", "author": "simplynaveen20", "createdAt": "2020-04-21T21:16:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA4MzE5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgzMjcwMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r414832703", "bodyText": "Discussed with Sameeksha offline , as of now cosmos sdk wont need it", "author": "simplynaveen20", "createdAt": "2020-04-24T20:07:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA4MzE5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA4NDQ0Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r409084447", "bodyText": "Ending span on very first element of pagedFlux , avoiding accountability of any user side delay. Please let me know if anyone think other wise and want it on OnComplete()", "author": "simplynaveen20", "createdAt": "2020-04-15T19:32:26Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/util/CosmosPagedFlux.java", "diffHunk": "@@ -84,4 +117,28 @@ public void subscribe(CoreSubscriber<? super T> coreSubscriber) {\n             return Flux.fromIterable(elements);\n         }).subscribe(coreSubscriber);\n     }\n+\n+    private Flux<FeedResponse<T>> byPage(CosmosPagedFluxOptions pagedFluxOptions, Context context) {\n+        final AtomicReference<Context> parentContext =  new AtomicReference<>(Context.NONE);\n+\n+        return this.optionsFluxFunction.apply(pagedFluxOptions).doOnSubscribe(ignoredValue -> {\n+            if (pagedFluxOptions.getTracerProvider().isEnabled()) {\n+                reactor.util.context.Context reactorContext = FluxUtil.toReactorContext(context);\n+                Objects.requireNonNull(reactorContext.hasKey(TracerProvider.MASTER_CALL));\n+                Optional<Object> callerFunc = reactorContext.getOrEmpty(TracerProvider.NESTED_CALL);\n+                if (!callerFunc.isPresent()) {\n+                    parentContext.set(pagedFluxOptions.getTracerProvider().startSpan(pagedFluxOptions.getTracerSpanName(),\n+                        context.addData(TracerProvider.ATTRIBUTE_MAP, pagedFluxOptions.getTracingAttributes()), ProcessKind.DATABASE));\n+                }\n+            }\n+        }).doOnEach(responseSignal -> {", "originalCommit": "c2fc40f3a35df2381104f88817209804491ae329", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE5MjA4MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r409192080", "bodyText": "@trask Would like to know your thoughts on the expected behavior, if we should end the span of the first element received.", "author": "samvaity", "createdAt": "2020-04-15T23:27:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA4NDQ0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUxNTgzOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r412515839", "bodyText": "@simplynaveen20 @samvaity That's a great question! I think that ideally it would capture until complete, while at the same time somehow capturing the internal time that was spent waiting on cosmosdb. Maybe the diagnostic data returned from the cosmosdb server could represent the internal time, as event(s) on the overarching span? This doesn't have to be part of the initial work though, and it's ok if you want to end the span on first element until we have a way to separate cosmosdb internal time from (external) user time while iterating over results.", "author": "trask", "createdAt": "2020-04-21T21:49:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA4NDQ0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkwOTQ2Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r414909466", "bodyText": "Moved to to doOnComplete()(It will include both sdk + user side time). However we have diagnostics to find out exact time taken by SDK", "author": "simplynaveen20", "createdAt": "2020-04-24T23:03:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA4NDQ0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkxMTQ3Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r414911476", "bodyText": "oh, nice, will that be part of the diagnostics that we capture in the next phase?", "author": "trask", "createdAt": "2020-04-24T23:10:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA4NDQ0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTEyMzg4MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r409123881", "bodyText": "@simplynaveen20 - It seems the trace specific doOnSubscribe | doOnSuccess | doOnError   handlers need to be repeated in all APIs. Wondering it makes sense to centralize it\nWith that this method looks something like:\nprivate Mono<CosmosAsyncTriggerResponse> read(Context context) {\n    Mono<CosmosAsyncDatabaseResponse> resultPublisher = asyncDocumentClient.createDatabase(database, ModelBridgeInternal.toRequestOptions(options))\n        .map(databaseResourceResponse -> ModelBridgeInternal.createCosmosAsyncDatabaseResponse(databaseResourceResponse,\n            this))\n        .single()\n    if (!tracerProvider.isEnabled()) {\n        return resultPublisher;\n    } else {\n        final String spanName = \"read.\" + database.getId();\n        Map<String, String> tracingAttributes = new HashMap<String, String>() {{\n            put(TracerProvider.DB_TYPE, TracerProvider.DB_TYPE_VALUE);\n            put(TracerProvider.DB_INSTANCE, database.getId());\n            put(TracerProvider.DB_URL, serviceEndpoint);\n            put(TracerProvider.DB_STATEMENT, spanName);\n        }};\n        return traceEnabledPublisher(resultPublisher, tracingAttributes, context);\n    }\n}\n\n// Reusable code \n//\nprivate <T> Mono<T> traceEnabledPublisher(Mono<T> resultPublisher, Map<String, String> tracingAttributes, Context context) {\n    return resultPublisher\n        .doOnSubscribe(ignoredValue -> {\n                reactor.util.context.Context reactorContext = FluxUtil.toReactorContext(context);\n                Objects.requireNonNull(reactorContext.hasKey(TracerProvider.MASTER_CALL));\n                Optional<Object> callerFunc = reactorContext.getOrEmpty(TracerProvider.NESTED_CALL);\n                if (!callerFunc.isPresent()) {\n                    parentContext.set(tracerProvider.startSpan(spanName,\n                        context.addData(TracerProvider.ATTRIBUTE_MAP, tracingAttributes), ProcessKind.DATABASE));\n                }\n        }).doOnSuccess(response -> {\n            tracerProvider.endSpan(parentContext.get(), Signal.complete(), response.getStatusCode());\n        }).doOnError(throwable -> {\n            tracerProvider.endSpan(parentContext.get(), Signal.error(throwable), 0);\n        });\n}", "author": "anuchandy", "createdAt": "2020-04-15T20:47:13Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncClient.java", "diffHunk": "@@ -411,4 +421,101 @@ public CosmosAsyncDatabase getDatabase(String id) {\n     public void close() {\n         asyncDocumentClient.close();\n     }\n+\n+    TracerProvider getTracerProvider(){\n+        return this.tracerProvider;\n+    }\n+\n+    private Mono<CosmosAsyncDatabaseResponse> createDatabaseIfNotExistsInternal(CosmosAsyncDatabase database) {\n+        return withContext(context -> createDatabaseIfNotExistsInternal(database, context)).subscriberContext(reactorContext -> {\n+            Optional<String> master = reactorContext.getOrEmpty(TracerProvider.MASTER_CALL);\n+            if (master.isPresent()) {\n+                reactorContext = reactorContext.put(TracerProvider.NESTED_CALL, true);\n+            }\n+            return reactorContext.put(TracerProvider.MASTER_CALL, true);\n+        });\n+    }\n+\n+    private Mono<CosmosAsyncDatabaseResponse> createDatabaseIfNotExistsInternal(CosmosAsyncDatabase database,\n+                                                                                Context context) {\n+        final boolean isTracingEnabled = tracerProvider.isEnabled();\n+        final AtomicReference<Context> parentContext = isTracingEnabled\n+            ? new AtomicReference<>(Context.NONE)\n+            : null;\n+        String spanName = \"createDatabaseIfNotExistsInternal.\" + database.getId();\n+        Map<String, String> tracingAttributes = new HashMap<String, String>() {{\n+            put(TracerProvider.DB_TYPE, TracerProvider.DB_TYPE_VALUE);\n+            put(TracerProvider.DB_INSTANCE, database.getId());\n+            put(TracerProvider.DB_URL, serviceEndpoint);\n+            put(TracerProvider.DB_STATEMENT, spanName);\n+        }};\n+\n+        return database.read().onErrorResume(exception -> {\n+            final Throwable unwrappedException = Exceptions.unwrap(exception);\n+            if (unwrappedException instanceof CosmosClientException) {\n+                final CosmosClientException cosmosClientException = (CosmosClientException) unwrappedException;\n+                if (cosmosClientException.getStatusCode() == HttpConstants.StatusCodes.NOTFOUND) {\n+                    return createDatabase(new CosmosDatabaseProperties(database.getId()),\n+                        new CosmosDatabaseRequestOptions());\n+                }\n+            }\n+            return Mono.error(unwrappedException);\n+        }).doOnSubscribe(ignoredValue -> {\n+            if (isTracingEnabled) {\n+                reactor.util.context.Context reactorContext = FluxUtil.toReactorContext(context);\n+                Objects.requireNonNull(reactorContext.hasKey(TracerProvider.MASTER_CALL));\n+                Optional<Object> callerFunc = reactorContext.getOrEmpty(TracerProvider.NESTED_CALL);\n+                if (!callerFunc.isPresent()) {\n+                    parentContext.set(tracerProvider.startSpan(spanName,\n+                        context.addData(TracerProvider.ATTRIBUTE_MAP, tracingAttributes), ProcessKind.DATABASE));\n+                }\n+            }\n+        }).doOnSuccess(response -> {\n+            if (isTracingEnabled) {\n+                tracerProvider.endSpan(parentContext.get(), Signal.complete(), response.getStatusCode());\n+            }\n+        }).doOnError(throwable -> {\n+            if (isTracingEnabled) {\n+                tracerProvider.endSpan(parentContext.get(), Signal.error(throwable), 0);\n+            }\n+        });\n+    }\n+\n+    private Mono<CosmosAsyncDatabaseResponse> createDatabase(Database database, CosmosDatabaseRequestOptions options, Context context){\n+        final boolean isTracingEnabled = tracerProvider.isEnabled();\n+        final AtomicReference<Context> parentContext = isTracingEnabled\n+            ? new AtomicReference<>(Context.NONE)\n+            : null;\n+        String spanName = \"createDatabase.\" + database.getId();\n+        Map<String, String> tracingAttributes = new HashMap<String, String>() {{\n+            put(TracerProvider.DB_TYPE, TracerProvider.DB_TYPE_VALUE);\n+            put(TracerProvider.DB_INSTANCE, database.getId());\n+            put(TracerProvider.DB_URL, serviceEndpoint);\n+            put(TracerProvider.DB_STATEMENT, spanName);\n+        }};\n+\n+        return asyncDocumentClient.createDatabase(database, ModelBridgeInternal.toRequestOptions(options))\n+            .map(databaseResourceResponse -> ModelBridgeInternal.createCosmosAsyncDatabaseResponse(databaseResourceResponse,\n+                this))\n+            .single()\n+            .doOnSubscribe(ignoredValue -> {\n+                if (isTracingEnabled) {\n+                    reactor.util.context.Context reactorContext = FluxUtil.toReactorContext(context);\n+                    Objects.requireNonNull(reactorContext.hasKey(TracerProvider.MASTER_CALL));\n+                    Optional<Object> callerFunc = reactorContext.getOrEmpty(TracerProvider.NESTED_CALL);\n+                    if (!callerFunc.isPresent()) {\n+                        parentContext.set(tracerProvider.startSpan(spanName,\n+                            context.addData(TracerProvider.ATTRIBUTE_MAP, tracingAttributes), ProcessKind.DATABASE));\n+                    }\n+                }\n+            }).doOnSuccess(response -> {\n+                if (isTracingEnabled) {\n+                    tracerProvider.endSpan(parentContext.get(), Signal.complete(), response.getStatusCode());\n+                }\n+            }).doOnError(throwable -> {\n+                if (isTracingEnabled) {\n+                    tracerProvider.endSpan(parentContext.get(), Signal.error(throwable), 0);\n+                }\n+            });\n+    }", "originalCommit": "c2fc40f3a35df2381104f88817209804491ae329", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE3MjY0NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r409172644", "bodyText": "Yea actually I am thinking of cleaning this , and some other ones too  .Thank for suggestion . Will send it in next iteration", "author": "simplynaveen20", "createdAt": "2020-04-15T22:32:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTEyMzg4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ5NzQ4Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r412497482", "bodyText": "Done", "author": "simplynaveen20", "createdAt": "2020-04-21T21:16:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTEyMzg4MQ=="}], "type": "inlineReview"}, {"oid": "eb82b61e1ff3d7c78d68435cc485f452fbe41b2d", "url": "https://github.com/Azure/azure-sdk-for-java/commit/eb82b61e1ff3d7c78d68435cc485f452fbe41b2d", "message": "Merge branch 'latest-master' into users/nakumars/tracercosmosdb", "committedDate": "2020-04-21T13:41:47Z", "type": "commit"}, {"oid": "e614db5d38ff2f4947900fa0174774f8c13f37fe", "url": "https://github.com/Azure/azure-sdk-for-java/commit/e614db5d38ff2f4947900fa0174774f8c13f37fe", "message": "adding test case and refactoring code", "committedDate": "2020-04-21T21:13:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4MDg4Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r412580886", "bodyText": "the lambda that's passed to subscriberContext() looks identical across lots of places, could be reused\nalso, I think it could be simplified:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return withContext(context -> createDatabase(wrappedDatabase, requestOptions, context)).subscriberContext(reactorContext -> {\n          \n          \n            \n                        Optional<String> master = reactorContext.getOrEmpty(TracerProvider.MASTER_CALL);\n          \n          \n            \n                        if (master.isPresent()) {\n          \n          \n            \n                            reactorContext = reactorContext.put(TracerProvider.NESTED_CALL, true);\n          \n          \n            \n                        }\n          \n          \n            \n                        return reactorContext.put(TracerProvider.MASTER_CALL, true);\n          \n          \n            \n                    });\n          \n          \n            \n                    return withContext(context -> createDatabase(wrappedDatabase, requestOptions, context)).subscriberContext(reactorContext -> {\n          \n          \n            \n                        if (reactorContext.hasKey(TracerProvider.MASTER_CALL)) {\n          \n          \n            \n                            return reactorContext.put(TracerProvider.NESTED_CALL, true);\n          \n          \n            \n                        } else {\n          \n          \n            \n                            return reactorContext.put(TracerProvider.MASTER_CALL, true);\n          \n          \n            \n                        }\n          \n          \n            \n                    });", "author": "trask", "createdAt": "2020-04-22T00:23:45Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncClient.java", "diffHunk": "@@ -281,10 +278,14 @@ CosmosKeyCredential cosmosKeyCredential() {\n         ModelBridgeInternal.setOfferThroughput(options, throughput);\n         Database wrappedDatabase = new Database();\n         wrappedDatabase.setId(databaseSettings.getId());\n-        return asyncDocumentClient.createDatabase(wrappedDatabase, ModelBridgeInternal.toRequestOptions(options))\n-                   .map(databaseResourceResponse -> ModelBridgeInternal.createCosmosAsyncDatabaseResponse(databaseResourceResponse,\n-                       this))\n-                   .single();\n+        final CosmosDatabaseRequestOptions requestOptions = options;\n+        return withContext(context -> createDatabase(wrappedDatabase, requestOptions, context)).subscriberContext(reactorContext -> {\n+            Optional<String> master = reactorContext.getOrEmpty(TracerProvider.MASTER_CALL);\n+            if (master.isPresent()) {\n+                reactorContext = reactorContext.put(TracerProvider.NESTED_CALL, true);\n+            }\n+            return reactorContext.put(TracerProvider.MASTER_CALL, true);\n+        });", "originalCommit": "e614db5d38ff2f4947900fa0174774f8c13f37fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYyNzE5MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r412627191", "bodyText": "just throwing out another option here, instead of tracking MASTER_CALL and NESTED_CALL independently, is to add a single item into the context COSMOS_CALL_DEPTH, e.g.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return withContext(context -> createDatabase(wrappedDatabase, requestOptions, context)).subscriberContext(reactorContext -> {\n          \n          \n            \n                        Optional<String> master = reactorContext.getOrEmpty(TracerProvider.MASTER_CALL);\n          \n          \n            \n                        if (master.isPresent()) {\n          \n          \n            \n                            reactorContext = reactorContext.put(TracerProvider.NESTED_CALL, true);\n          \n          \n            \n                        }\n          \n          \n            \n                        return reactorContext.put(TracerProvider.MASTER_CALL, true);\n          \n          \n            \n                    });\n          \n          \n            \n                    return withContext(context -> createDatabase(wrappedDatabase, requestOptions, context)).subscriberContext(reactorContext -> {\n          \n          \n            \n                        int callDepth = reactorContext.getOrDefault(TracerProvider.COSMOS_CALL_DEPTH, 0);\n          \n          \n            \n                        if (callDepth == 0) {\n          \n          \n            \n                            return reactorContext.put(TracerProvider.COSMOS_CALL_DEPTH, 1);\n          \n          \n            \n                        } else if (callDepth == 1) {\n          \n          \n            \n                            return reactorContext.put(TracerProvider.COSMOS_CALL_DEPTH, 2);\n          \n          \n            \n                        } else {\n          \n          \n            \n                            // tracking beyond 2 levels isn't needed, and would create extra copies of the context\n          \n          \n            \n                            return reactorContext;\n          \n          \n            \n                        }\n          \n          \n            \n                    });", "author": "trask", "createdAt": "2020-04-22T02:42:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4MDg4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYyOTA2OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r412629068", "bodyText": "Last option (promise \ud83d\ude04), in case you don't like auto-boxing of the integers in the last option (not sure that I do). Define an enum CallDepth with values ZERO, ONE, TWO_OR_MORE, and then:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return withContext(context -> createDatabase(wrappedDatabase, requestOptions, context)).subscriberContext(reactorContext -> {\n          \n          \n            \n                        Optional<String> master = reactorContext.getOrEmpty(TracerProvider.MASTER_CALL);\n          \n          \n            \n                        if (master.isPresent()) {\n          \n          \n            \n                            reactorContext = reactorContext.put(TracerProvider.NESTED_CALL, true);\n          \n          \n            \n                        }\n          \n          \n            \n                        return reactorContext.put(TracerProvider.MASTER_CALL, true);\n          \n          \n            \n                    });\n          \n          \n            \n                    return withContext(context -> createDatabase(wrappedDatabase, requestOptions, context)).subscriberContext(reactorContext -> {\n          \n          \n            \n                        CallDepth callDepth = reactorContext.getOrDefault(TracerProvider.COSMOS_CALL_DEPTH, CallDepth.ZERO);\n          \n          \n            \n                        if (callDepth == CallDepth.ZERO) {\n          \n          \n            \n                            return reactorContext.put(TracerProvider.COSMOS_CALL_DEPTH, CallDepth.ONE);\n          \n          \n            \n                        } else if (callDepth == CallDepth.ONE) {\n          \n          \n            \n                            return reactorContext.put(TracerProvider.COSMOS_CALL_DEPTH, CallDepth.TWO_OR_MORE);\n          \n          \n            \n                        } else {\n          \n          \n            \n                            return reactorContext;\n          \n          \n            \n                        }\n          \n          \n            \n                    });", "author": "trask", "createdAt": "2020-04-22T02:48:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4MDg4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgzNDA4MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r414834080", "bodyText": "Moved the PR out draft version, did bunch of refactoring , and I like your third option i.e using\nCallDepth (more intuitive for code readability)  , thanks for advice :)", "author": "simplynaveen20", "createdAt": "2020-04-24T20:09:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4MDg4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4Njg2Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r412586867", "bodyText": "these 3 methods look the same other than mapping response to status code. maybe extract out private method that also takes a Function<T, Integer> and delegate to that?", "author": "trask", "createdAt": "2020-04-22T00:41:33Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -0,0 +1,209 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation;\n+\n+import com.azure.core.util.Context;\n+import com.azure.core.util.FluxUtil;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.core.util.tracing.ProcessKind;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.cosmos.CosmosClientException;\n+import com.azure.cosmos.models.CosmosAsyncItemResponse;\n+import com.azure.cosmos.models.CosmosResponse;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Signal;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+public class TracerProvider {\n+    private final ClientLogger logger = new ClientLogger(TracerProvider.class);\n+    private final List<Tracer> tracers = new ArrayList<>();\n+    public final static String DB_TYPE_VALUE = \"cosmosdb\";\n+    public final static String DB_TYPE = \"db.type\";\n+    public final static String DB_INSTANCE = \"db.instance\";\n+    public final static String DB_URL = \"db.url\";\n+    public static final String DB_STATEMENT = \"db.statement\";\n+    public static final String ERROR_MSG = \"error.msg\";\n+    public static final String ERROR_TYPE = \"error.type\";\n+    public static final String ERROR_STACK = \"error.stack\";\n+    public static final String MASTER_CALL = \"masterCall\";\n+    public static final String NESTED_CALL = \"nestedCall\";\n+\n+    public static final Object ATTRIBUTE_MAP = \"span-attributes\";\n+\n+\n+    public TracerProvider(Iterable<Tracer> tracers) {\n+        Objects.requireNonNull(tracers, \"'tracers' cannot be null.\");\n+        tracers.forEach(e -> this.tracers.add(e));\n+    }\n+\n+    public boolean isEnabled() {\n+        return tracers.size() > 0;\n+    }\n+\n+    /**\n+     * For each tracer plugged into the SDK a new tracing span is created.\n+     * <p>\n+     * The {@code context} will be checked for containing information about a parent span. If a parent span is found the\n+     * new span will be added as a child, otherwise the span will be created and added to the context and any downstream\n+     * start calls will use the created span as the parent.\n+     *\n+     * @param context Additional metadata that is passed through the call stack.\n+     * @return An updated context object.\n+     */\n+    public Context startSpan(String methodName, Context context, ProcessKind processKind) {\n+        Context local = Objects.requireNonNull(context, \"'context' cannot be null.\");\n+        Objects.requireNonNull(processKind, \"'processKind' cannot be null.\");\n+\n+        for (Tracer tracer : tracers) {\n+            local = tracer.start(methodName, local, processKind);\n+        }\n+\n+        return local;\n+    }\n+\n+    /**\n+     * Given a context containing the current tracing span the span is marked completed with status info from\n+     * {@link Signal}.  For each tracer plugged into the SDK the current tracing span is marked as completed.\n+     *\n+     * @param context Additional metadata that is passed through the call stack.\n+     * @param signal  The signal indicates the status and contains the metadata we need to end the tracing span.\n+     */\n+    public void endSpan(Context context, Signal<CosmosResponse> signal, int statusCode) {\n+        Objects.requireNonNull(context, \"'context' cannot be null.\");\n+        Objects.requireNonNull(signal, \"'signal' cannot be null.\");\n+\n+        switch (signal.getType()) {\n+            case ON_COMPLETE:\n+                end(statusCode, null, context);\n+                break;\n+            case ON_ERROR:\n+                Throwable throwable = null;\n+                if (signal.hasError()) {\n+                    // The last status available is on error, this contains the thrown error.\n+                    throwable = signal.getThrowable();\n+\n+                    if (throwable instanceof CosmosClientException) {\n+                        CosmosClientException exception = (CosmosClientException) throwable;\n+                        // confirm ?\n+                        statusCode = exception.getStatusCode();\n+                    }\n+                }\n+                end(statusCode, throwable, context);\n+                break;\n+            default:\n+                // ON_SUBSCRIBE and ON_NEXT don't have the information to end the span so just return.\n+                break;\n+        }\n+    }\n+\n+    public <T extends CosmosResponse> Mono<T> traceEnabledCosmosResponsePublisher(Mono<T> resultPublisher,\n+                                                                                  Map<String, String> tracingAttributes,\n+                                                                                  Context context,\n+                                                                                  String spanName) {\n+        final boolean isTracingEnabled = this.isEnabled();\n+        final AtomicReference<Context> parentContext = isTracingEnabled\n+            ? new AtomicReference<>(Context.NONE)\n+            : null;\n+        return resultPublisher\n+            .doOnSubscribe(ignoredValue -> {\n+                if (isTracingEnabled) {\n+                    reactor.util.context.Context reactorContext = FluxUtil.toReactorContext(context);\n+                    Objects.requireNonNull(reactorContext.hasKey(TracerProvider.MASTER_CALL));\n+                    Optional<Object> callerFunc = reactorContext.getOrEmpty(TracerProvider.NESTED_CALL);\n+                    if (!callerFunc.isPresent()) {\n+                        parentContext.set(this.startSpan(spanName,\n+                            context.addData(TracerProvider.ATTRIBUTE_MAP, tracingAttributes), ProcessKind.DATABASE));\n+                    }\n+                }\n+            }).doOnSuccess(response -> {\n+                if (isTracingEnabled) {\n+                    this.endSpan(parentContext.get(), Signal.complete(), response.getStatusCode());\n+                }\n+            }).doOnError(throwable -> {\n+                if (isTracingEnabled) {\n+                    this.endSpan(parentContext.get(), Signal.error(throwable), 0);\n+                }\n+            });\n+    }\n+\n+    public <T> Mono<T> traceEnabledNonCosmosResponsePublisher(Mono<T> resultPublisher,\n+                                                              Map<String, String> tracingAttributes,\n+                                                              Context context,\n+                                                              String spanName) {\n+        final boolean isTracingEnabled = this.isEnabled();\n+        final AtomicReference<Context> parentContext = isTracingEnabled\n+            ? new AtomicReference<>(Context.NONE)\n+            : null;\n+        return resultPublisher\n+            .doOnSubscribe(ignoredValue -> {\n+                if (isTracingEnabled) {\n+                    reactor.util.context.Context reactorContext = FluxUtil.toReactorContext(context);\n+                    Objects.requireNonNull(reactorContext.hasKey(TracerProvider.MASTER_CALL));\n+                    Optional<Object> callerFunc = reactorContext.getOrEmpty(TracerProvider.NESTED_CALL);\n+                    if (!callerFunc.isPresent()) {\n+                        parentContext.set(this.startSpan(spanName,\n+                            context.addData(TracerProvider.ATTRIBUTE_MAP, tracingAttributes), ProcessKind.DATABASE));\n+                    }\n+                }\n+            }).doOnSuccess(response -> {\n+                if (isTracingEnabled) {\n+                    this.endSpan(parentContext.get(), Signal.complete(), 200);\n+                }\n+            }).doOnError(throwable -> {\n+                if (isTracingEnabled) {\n+                    this.endSpan(parentContext.get(), Signal.error(throwable), 0);\n+                }\n+            });\n+    }\n+\n+    public <T> Mono<CosmosAsyncItemResponse<T>> traceEnabledCosmosItemResponsePublisher(Mono<CosmosAsyncItemResponse<T>> resultPublisher,\n+                                                                                        Map<String, String> tracingAttributes,\n+                                                                                        Context context,\n+                                                                                        String spanName) {\n+        final boolean isTracingEnabled = this.isEnabled();\n+        final AtomicReference<Context> parentContext = isTracingEnabled\n+            ? new AtomicReference<>(Context.NONE)\n+            : null;\n+        return resultPublisher\n+            .doOnSubscribe(ignoredValue -> {\n+                if (isTracingEnabled) {\n+                    reactor.util.context.Context reactorContext = FluxUtil.toReactorContext(context);\n+                    Objects.requireNonNull(reactorContext.hasKey(TracerProvider.MASTER_CALL));\n+                    Optional<Object> callerFunc = reactorContext.getOrEmpty(TracerProvider.NESTED_CALL);\n+                    if (!callerFunc.isPresent()) {\n+                        parentContext.set(this.startSpan(spanName,\n+                            context.addData(TracerProvider.ATTRIBUTE_MAP, tracingAttributes), ProcessKind.DATABASE));\n+                    }\n+                }\n+            }).doOnSuccess(response -> {\n+                if (isTracingEnabled) {\n+                    this.endSpan(parentContext.get(), Signal.complete(), response.getStatusCode());\n+                }\n+            }).doOnError(throwable -> {\n+                if (isTracingEnabled) {\n+                    this.endSpan(parentContext.get(), Signal.error(throwable), 0);\n+                }\n+            });\n+    }", "originalCommit": "e614db5d38ff2f4947900fa0174774f8c13f37fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgzNjc3NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r414836775", "bodyText": "Done", "author": "simplynaveen20", "createdAt": "2020-04-24T20:15:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4Njg2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4NzEzNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r412587134", "bodyText": "hasKey never returns null", "author": "trask", "createdAt": "2020-04-22T00:42:18Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -0,0 +1,209 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation;\n+\n+import com.azure.core.util.Context;\n+import com.azure.core.util.FluxUtil;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.core.util.tracing.ProcessKind;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.cosmos.CosmosClientException;\n+import com.azure.cosmos.models.CosmosAsyncItemResponse;\n+import com.azure.cosmos.models.CosmosResponse;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Signal;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+public class TracerProvider {\n+    private final ClientLogger logger = new ClientLogger(TracerProvider.class);\n+    private final List<Tracer> tracers = new ArrayList<>();\n+    public final static String DB_TYPE_VALUE = \"cosmosdb\";\n+    public final static String DB_TYPE = \"db.type\";\n+    public final static String DB_INSTANCE = \"db.instance\";\n+    public final static String DB_URL = \"db.url\";\n+    public static final String DB_STATEMENT = \"db.statement\";\n+    public static final String ERROR_MSG = \"error.msg\";\n+    public static final String ERROR_TYPE = \"error.type\";\n+    public static final String ERROR_STACK = \"error.stack\";\n+    public static final String MASTER_CALL = \"masterCall\";\n+    public static final String NESTED_CALL = \"nestedCall\";\n+\n+    public static final Object ATTRIBUTE_MAP = \"span-attributes\";\n+\n+\n+    public TracerProvider(Iterable<Tracer> tracers) {\n+        Objects.requireNonNull(tracers, \"'tracers' cannot be null.\");\n+        tracers.forEach(e -> this.tracers.add(e));\n+    }\n+\n+    public boolean isEnabled() {\n+        return tracers.size() > 0;\n+    }\n+\n+    /**\n+     * For each tracer plugged into the SDK a new tracing span is created.\n+     * <p>\n+     * The {@code context} will be checked for containing information about a parent span. If a parent span is found the\n+     * new span will be added as a child, otherwise the span will be created and added to the context and any downstream\n+     * start calls will use the created span as the parent.\n+     *\n+     * @param context Additional metadata that is passed through the call stack.\n+     * @return An updated context object.\n+     */\n+    public Context startSpan(String methodName, Context context, ProcessKind processKind) {\n+        Context local = Objects.requireNonNull(context, \"'context' cannot be null.\");\n+        Objects.requireNonNull(processKind, \"'processKind' cannot be null.\");\n+\n+        for (Tracer tracer : tracers) {\n+            local = tracer.start(methodName, local, processKind);\n+        }\n+\n+        return local;\n+    }\n+\n+    /**\n+     * Given a context containing the current tracing span the span is marked completed with status info from\n+     * {@link Signal}.  For each tracer plugged into the SDK the current tracing span is marked as completed.\n+     *\n+     * @param context Additional metadata that is passed through the call stack.\n+     * @param signal  The signal indicates the status and contains the metadata we need to end the tracing span.\n+     */\n+    public void endSpan(Context context, Signal<CosmosResponse> signal, int statusCode) {\n+        Objects.requireNonNull(context, \"'context' cannot be null.\");\n+        Objects.requireNonNull(signal, \"'signal' cannot be null.\");\n+\n+        switch (signal.getType()) {\n+            case ON_COMPLETE:\n+                end(statusCode, null, context);\n+                break;\n+            case ON_ERROR:\n+                Throwable throwable = null;\n+                if (signal.hasError()) {\n+                    // The last status available is on error, this contains the thrown error.\n+                    throwable = signal.getThrowable();\n+\n+                    if (throwable instanceof CosmosClientException) {\n+                        CosmosClientException exception = (CosmosClientException) throwable;\n+                        // confirm ?\n+                        statusCode = exception.getStatusCode();\n+                    }\n+                }\n+                end(statusCode, throwable, context);\n+                break;\n+            default:\n+                // ON_SUBSCRIBE and ON_NEXT don't have the information to end the span so just return.\n+                break;\n+        }\n+    }\n+\n+    public <T extends CosmosResponse> Mono<T> traceEnabledCosmosResponsePublisher(Mono<T> resultPublisher,\n+                                                                                  Map<String, String> tracingAttributes,\n+                                                                                  Context context,\n+                                                                                  String spanName) {\n+        final boolean isTracingEnabled = this.isEnabled();\n+        final AtomicReference<Context> parentContext = isTracingEnabled\n+            ? new AtomicReference<>(Context.NONE)\n+            : null;\n+        return resultPublisher\n+            .doOnSubscribe(ignoredValue -> {\n+                if (isTracingEnabled) {\n+                    reactor.util.context.Context reactorContext = FluxUtil.toReactorContext(context);\n+                    Objects.requireNonNull(reactorContext.hasKey(TracerProvider.MASTER_CALL));\n+                    Optional<Object> callerFunc = reactorContext.getOrEmpty(TracerProvider.NESTED_CALL);\n+                    if (!callerFunc.isPresent()) {\n+                        parentContext.set(this.startSpan(spanName,\n+                            context.addData(TracerProvider.ATTRIBUTE_MAP, tracingAttributes), ProcessKind.DATABASE));\n+                    }\n+                }\n+            }).doOnSuccess(response -> {\n+                if (isTracingEnabled) {\n+                    this.endSpan(parentContext.get(), Signal.complete(), response.getStatusCode());\n+                }\n+            }).doOnError(throwable -> {\n+                if (isTracingEnabled) {\n+                    this.endSpan(parentContext.get(), Signal.error(throwable), 0);\n+                }\n+            });\n+    }\n+\n+    public <T> Mono<T> traceEnabledNonCosmosResponsePublisher(Mono<T> resultPublisher,\n+                                                              Map<String, String> tracingAttributes,\n+                                                              Context context,\n+                                                              String spanName) {\n+        final boolean isTracingEnabled = this.isEnabled();\n+        final AtomicReference<Context> parentContext = isTracingEnabled\n+            ? new AtomicReference<>(Context.NONE)\n+            : null;\n+        return resultPublisher\n+            .doOnSubscribe(ignoredValue -> {\n+                if (isTracingEnabled) {\n+                    reactor.util.context.Context reactorContext = FluxUtil.toReactorContext(context);\n+                    Objects.requireNonNull(reactorContext.hasKey(TracerProvider.MASTER_CALL));\n+                    Optional<Object> callerFunc = reactorContext.getOrEmpty(TracerProvider.NESTED_CALL);\n+                    if (!callerFunc.isPresent()) {\n+                        parentContext.set(this.startSpan(spanName,\n+                            context.addData(TracerProvider.ATTRIBUTE_MAP, tracingAttributes), ProcessKind.DATABASE));\n+                    }\n+                }\n+            }).doOnSuccess(response -> {\n+                if (isTracingEnabled) {\n+                    this.endSpan(parentContext.get(), Signal.complete(), 200);\n+                }\n+            }).doOnError(throwable -> {\n+                if (isTracingEnabled) {\n+                    this.endSpan(parentContext.get(), Signal.error(throwable), 0);\n+                }\n+            });\n+    }\n+\n+    public <T> Mono<CosmosAsyncItemResponse<T>> traceEnabledCosmosItemResponsePublisher(Mono<CosmosAsyncItemResponse<T>> resultPublisher,\n+                                                                                        Map<String, String> tracingAttributes,\n+                                                                                        Context context,\n+                                                                                        String spanName) {\n+        final boolean isTracingEnabled = this.isEnabled();\n+        final AtomicReference<Context> parentContext = isTracingEnabled\n+            ? new AtomicReference<>(Context.NONE)\n+            : null;\n+        return resultPublisher\n+            .doOnSubscribe(ignoredValue -> {\n+                if (isTracingEnabled) {\n+                    reactor.util.context.Context reactorContext = FluxUtil.toReactorContext(context);\n+                    Objects.requireNonNull(reactorContext.hasKey(TracerProvider.MASTER_CALL));", "originalCommit": "e614db5d38ff2f4947900fa0174774f8c13f37fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgzNjY2Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r414836662", "bodyText": "Removed this method usage", "author": "simplynaveen20", "createdAt": "2020-04-24T20:14:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4NzEzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU5OTMxMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r412599310", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                Optional<Object> callerFunc = reactorContext.getOrEmpty(TracerProvider.NESTED_CALL);\n          \n          \n            \n                                if (!callerFunc.isPresent()) {\n          \n          \n            \n                                if (!reactorContext.hasKey(TracerProvider.NESTED_CALL)) {", "author": "trask", "createdAt": "2020-04-22T01:20:07Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -0,0 +1,209 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation;\n+\n+import com.azure.core.util.Context;\n+import com.azure.core.util.FluxUtil;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.core.util.tracing.ProcessKind;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.cosmos.CosmosClientException;\n+import com.azure.cosmos.models.CosmosAsyncItemResponse;\n+import com.azure.cosmos.models.CosmosResponse;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Signal;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+public class TracerProvider {\n+    private final ClientLogger logger = new ClientLogger(TracerProvider.class);\n+    private final List<Tracer> tracers = new ArrayList<>();\n+    public final static String DB_TYPE_VALUE = \"cosmosdb\";\n+    public final static String DB_TYPE = \"db.type\";\n+    public final static String DB_INSTANCE = \"db.instance\";\n+    public final static String DB_URL = \"db.url\";\n+    public static final String DB_STATEMENT = \"db.statement\";\n+    public static final String ERROR_MSG = \"error.msg\";\n+    public static final String ERROR_TYPE = \"error.type\";\n+    public static final String ERROR_STACK = \"error.stack\";\n+    public static final String MASTER_CALL = \"masterCall\";\n+    public static final String NESTED_CALL = \"nestedCall\";\n+\n+    public static final Object ATTRIBUTE_MAP = \"span-attributes\";\n+\n+\n+    public TracerProvider(Iterable<Tracer> tracers) {\n+        Objects.requireNonNull(tracers, \"'tracers' cannot be null.\");\n+        tracers.forEach(e -> this.tracers.add(e));\n+    }\n+\n+    public boolean isEnabled() {\n+        return tracers.size() > 0;\n+    }\n+\n+    /**\n+     * For each tracer plugged into the SDK a new tracing span is created.\n+     * <p>\n+     * The {@code context} will be checked for containing information about a parent span. If a parent span is found the\n+     * new span will be added as a child, otherwise the span will be created and added to the context and any downstream\n+     * start calls will use the created span as the parent.\n+     *\n+     * @param context Additional metadata that is passed through the call stack.\n+     * @return An updated context object.\n+     */\n+    public Context startSpan(String methodName, Context context, ProcessKind processKind) {\n+        Context local = Objects.requireNonNull(context, \"'context' cannot be null.\");\n+        Objects.requireNonNull(processKind, \"'processKind' cannot be null.\");\n+\n+        for (Tracer tracer : tracers) {\n+            local = tracer.start(methodName, local, processKind);\n+        }\n+\n+        return local;\n+    }\n+\n+    /**\n+     * Given a context containing the current tracing span the span is marked completed with status info from\n+     * {@link Signal}.  For each tracer plugged into the SDK the current tracing span is marked as completed.\n+     *\n+     * @param context Additional metadata that is passed through the call stack.\n+     * @param signal  The signal indicates the status and contains the metadata we need to end the tracing span.\n+     */\n+    public void endSpan(Context context, Signal<CosmosResponse> signal, int statusCode) {\n+        Objects.requireNonNull(context, \"'context' cannot be null.\");\n+        Objects.requireNonNull(signal, \"'signal' cannot be null.\");\n+\n+        switch (signal.getType()) {\n+            case ON_COMPLETE:\n+                end(statusCode, null, context);\n+                break;\n+            case ON_ERROR:\n+                Throwable throwable = null;\n+                if (signal.hasError()) {\n+                    // The last status available is on error, this contains the thrown error.\n+                    throwable = signal.getThrowable();\n+\n+                    if (throwable instanceof CosmosClientException) {\n+                        CosmosClientException exception = (CosmosClientException) throwable;\n+                        // confirm ?\n+                        statusCode = exception.getStatusCode();\n+                    }\n+                }\n+                end(statusCode, throwable, context);\n+                break;\n+            default:\n+                // ON_SUBSCRIBE and ON_NEXT don't have the information to end the span so just return.\n+                break;\n+        }\n+    }\n+\n+    public <T extends CosmosResponse> Mono<T> traceEnabledCosmosResponsePublisher(Mono<T> resultPublisher,\n+                                                                                  Map<String, String> tracingAttributes,\n+                                                                                  Context context,\n+                                                                                  String spanName) {\n+        final boolean isTracingEnabled = this.isEnabled();\n+        final AtomicReference<Context> parentContext = isTracingEnabled\n+            ? new AtomicReference<>(Context.NONE)\n+            : null;\n+        return resultPublisher\n+            .doOnSubscribe(ignoredValue -> {\n+                if (isTracingEnabled) {\n+                    reactor.util.context.Context reactorContext = FluxUtil.toReactorContext(context);\n+                    Objects.requireNonNull(reactorContext.hasKey(TracerProvider.MASTER_CALL));\n+                    Optional<Object> callerFunc = reactorContext.getOrEmpty(TracerProvider.NESTED_CALL);\n+                    if (!callerFunc.isPresent()) {\n+                        parentContext.set(this.startSpan(spanName,\n+                            context.addData(TracerProvider.ATTRIBUTE_MAP, tracingAttributes), ProcessKind.DATABASE));\n+                    }\n+                }\n+            }).doOnSuccess(response -> {\n+                if (isTracingEnabled) {\n+                    this.endSpan(parentContext.get(), Signal.complete(), response.getStatusCode());\n+                }\n+            }).doOnError(throwable -> {\n+                if (isTracingEnabled) {\n+                    this.endSpan(parentContext.get(), Signal.error(throwable), 0);\n+                }\n+            });\n+    }\n+\n+    public <T> Mono<T> traceEnabledNonCosmosResponsePublisher(Mono<T> resultPublisher,\n+                                                              Map<String, String> tracingAttributes,\n+                                                              Context context,\n+                                                              String spanName) {\n+        final boolean isTracingEnabled = this.isEnabled();\n+        final AtomicReference<Context> parentContext = isTracingEnabled\n+            ? new AtomicReference<>(Context.NONE)\n+            : null;\n+        return resultPublisher\n+            .doOnSubscribe(ignoredValue -> {\n+                if (isTracingEnabled) {\n+                    reactor.util.context.Context reactorContext = FluxUtil.toReactorContext(context);\n+                    Objects.requireNonNull(reactorContext.hasKey(TracerProvider.MASTER_CALL));\n+                    Optional<Object> callerFunc = reactorContext.getOrEmpty(TracerProvider.NESTED_CALL);\n+                    if (!callerFunc.isPresent()) {\n+                        parentContext.set(this.startSpan(spanName,\n+                            context.addData(TracerProvider.ATTRIBUTE_MAP, tracingAttributes), ProcessKind.DATABASE));\n+                    }\n+                }\n+            }).doOnSuccess(response -> {\n+                if (isTracingEnabled) {\n+                    this.endSpan(parentContext.get(), Signal.complete(), 200);\n+                }\n+            }).doOnError(throwable -> {\n+                if (isTracingEnabled) {\n+                    this.endSpan(parentContext.get(), Signal.error(throwable), 0);\n+                }\n+            });\n+    }\n+\n+    public <T> Mono<CosmosAsyncItemResponse<T>> traceEnabledCosmosItemResponsePublisher(Mono<CosmosAsyncItemResponse<T>> resultPublisher,\n+                                                                                        Map<String, String> tracingAttributes,\n+                                                                                        Context context,\n+                                                                                        String spanName) {\n+        final boolean isTracingEnabled = this.isEnabled();\n+        final AtomicReference<Context> parentContext = isTracingEnabled\n+            ? new AtomicReference<>(Context.NONE)\n+            : null;\n+        return resultPublisher\n+            .doOnSubscribe(ignoredValue -> {\n+                if (isTracingEnabled) {\n+                    reactor.util.context.Context reactorContext = FluxUtil.toReactorContext(context);\n+                    Objects.requireNonNull(reactorContext.hasKey(TracerProvider.MASTER_CALL));\n+                    Optional<Object> callerFunc = reactorContext.getOrEmpty(TracerProvider.NESTED_CALL);\n+                    if (!callerFunc.isPresent()) {", "originalCommit": "e614db5d38ff2f4947900fa0174774f8c13f37fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgzNDQ0OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r414834448", "bodyText": "Moved to CallDepth enum, all set on this", "author": "simplynaveen20", "createdAt": "2020-04-24T20:10:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU5OTMxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYyOTYwOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r412629609", "bodyText": "probably should prefix/namespace these since they are put into the reactor context, just to make sure they don't conflict with anything that users may put into there", "author": "trask", "createdAt": "2020-04-22T02:49:52Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -0,0 +1,209 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation;\n+\n+import com.azure.core.util.Context;\n+import com.azure.core.util.FluxUtil;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.core.util.tracing.ProcessKind;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.cosmos.CosmosClientException;\n+import com.azure.cosmos.models.CosmosAsyncItemResponse;\n+import com.azure.cosmos.models.CosmosResponse;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Signal;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+public class TracerProvider {\n+    private final ClientLogger logger = new ClientLogger(TracerProvider.class);\n+    private final List<Tracer> tracers = new ArrayList<>();\n+    public final static String DB_TYPE_VALUE = \"cosmosdb\";\n+    public final static String DB_TYPE = \"db.type\";\n+    public final static String DB_INSTANCE = \"db.instance\";\n+    public final static String DB_URL = \"db.url\";\n+    public static final String DB_STATEMENT = \"db.statement\";\n+    public static final String ERROR_MSG = \"error.msg\";\n+    public static final String ERROR_TYPE = \"error.type\";\n+    public static final String ERROR_STACK = \"error.stack\";\n+    public static final String MASTER_CALL = \"masterCall\";\n+    public static final String NESTED_CALL = \"nestedCall\";", "originalCommit": "e614db5d38ff2f4947900fa0174774f8c13f37fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgzNDU5NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r414834594", "bodyText": "Not needed anymore", "author": "simplynaveen20", "createdAt": "2020-04-24T20:10:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYyOTYwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzI3NDgwOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r413274809", "bodyText": "Given the requirements to set these specific attributes on every span it would help if we could use\nlocal = tracer.start(methodName, local); // will start the span\ntracer.setAttribute(DB_INSTANCE, \"myDatabaseName\", local); // use the current span to set attributes on it\nThis way we don't have to add a new ProcessKind and this startSpan overload can be used as it.", "author": "samvaity", "createdAt": "2020-04-22T19:48:51Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -0,0 +1,209 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation;\n+\n+import com.azure.core.util.Context;\n+import com.azure.core.util.FluxUtil;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.core.util.tracing.ProcessKind;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.cosmos.CosmosClientException;\n+import com.azure.cosmos.models.CosmosAsyncItemResponse;\n+import com.azure.cosmos.models.CosmosResponse;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Signal;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+public class TracerProvider {\n+    private final ClientLogger logger = new ClientLogger(TracerProvider.class);\n+    private final List<Tracer> tracers = new ArrayList<>();\n+    public final static String DB_TYPE_VALUE = \"cosmosdb\";\n+    public final static String DB_TYPE = \"db.type\";\n+    public final static String DB_INSTANCE = \"db.instance\";\n+    public final static String DB_URL = \"db.url\";\n+    public static final String DB_STATEMENT = \"db.statement\";\n+    public static final String ERROR_MSG = \"error.msg\";\n+    public static final String ERROR_TYPE = \"error.type\";\n+    public static final String ERROR_STACK = \"error.stack\";\n+    public static final String MASTER_CALL = \"masterCall\";\n+    public static final String NESTED_CALL = \"nestedCall\";\n+\n+    public static final Object ATTRIBUTE_MAP = \"span-attributes\";\n+\n+\n+    public TracerProvider(Iterable<Tracer> tracers) {\n+        Objects.requireNonNull(tracers, \"'tracers' cannot be null.\");\n+        tracers.forEach(e -> this.tracers.add(e));\n+    }\n+\n+    public boolean isEnabled() {\n+        return tracers.size() > 0;\n+    }\n+\n+    /**\n+     * For each tracer plugged into the SDK a new tracing span is created.\n+     * <p>\n+     * The {@code context} will be checked for containing information about a parent span. If a parent span is found the\n+     * new span will be added as a child, otherwise the span will be created and added to the context and any downstream\n+     * start calls will use the created span as the parent.\n+     *\n+     * @param context Additional metadata that is passed through the call stack.\n+     * @return An updated context object.\n+     */\n+    public Context startSpan(String methodName, Context context, ProcessKind processKind) {\n+        Context local = Objects.requireNonNull(context, \"'context' cannot be null.\");\n+        Objects.requireNonNull(processKind, \"'processKind' cannot be null.\");\n+\n+        for (Tracer tracer : tracers) {\n+            local = tracer.start(methodName, local, processKind);", "originalCommit": "e614db5d38ff2f4947900fa0174774f8c13f37fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgzNDg3NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r414834875", "bodyText": "Removed ProcessKind dependency.", "author": "simplynaveen20", "createdAt": "2020-04-24T20:11:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzI3NDgwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzg5OTg1Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r413899853", "bodyText": "this logs the query text? If the query has private info, this will get logged? is that ok?", "author": "moderakh", "createdAt": "2020-04-23T15:32:38Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncClient.java", "diffHunk": "@@ -386,6 +389,8 @@ CosmosKeyCredential cosmosKeyCredential() {\n      */\n     public CosmosPagedFlux<CosmosDatabaseProperties> queryDatabases(SqlQuerySpec querySpec, FeedOptions options) {\n         return UtilBridgeInternal.createCosmosPagedFlux(pagedFluxOptions -> {\n+            String spanName = \"queryDatabases.\" + querySpec.getQueryText();", "originalCommit": "e614db5d38ff2f4947900fa0174774f8c13f37fe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkwMTQ3OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r413901479", "bodyText": "seems this code is repeated exactly, can this be factored out as a function and passed here?\n\\liked this\nreturn withContext(context -> replace(containerProperties, requestOptions, context))\n    .subscriberContext(reactorContext -> factoredOutFunc())", "author": "moderakh", "createdAt": "2020-04-23T15:34:33Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -156,9 +192,34 @@ public String getId() {\n         if (options == null) {\n             options = new CosmosContainerRequestOptions();\n         }\n-        return database.getDocClientWrapper()\n-                   .replaceCollection(ModelBridgeInternal.getV2Collection(containerProperties), ModelBridgeInternal.toRequestOptions(options))\n-                   .map(response -> ModelBridgeInternal.createCosmosAsyncContainerResponse(response, database)).single();\n+\n+        final CosmosContainerRequestOptions requestOptions = options;\n+        return withContext(context -> replace(containerProperties, requestOptions, context)).subscriberContext(reactorContext -> {\n+            Optional<String> master = reactorContext.getOrEmpty(TracerProvider.MASTER_CALL);\n+            if (master.isPresent()) {\n+                reactorContext = reactorContext.put(TracerProvider.NESTED_CALL, true);\n+            }\n+            return reactorContext.put(TracerProvider.MASTER_CALL, true);", "originalCommit": "e614db5d38ff2f4947900fa0174774f8c13f37fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgzNTUzMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r414835532", "bodyText": "I was waiting on final handshake between cosmos and core for withContext api, did the refactoring now.", "author": "simplynaveen20", "createdAt": "2020-04-24T20:12:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkwMTQ3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkwMjA4NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r413902085", "bodyText": "exactly the same code, can this be factored out\nreturn withContext(context -> replace(containerProperties, requestOptions, context))\n    .subscriberContext(reactorContext -> factoredOutFunc())", "author": "moderakh", "createdAt": "2020-04-23T15:35:21Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -216,16 +276,37 @@ public String getId() {\n         if (options == null) {\n             options = new CosmosItemRequestOptions();\n         }\n+\n+        final CosmosItemRequestOptions requestOptions = options;\n+        return withContext(context -> createItem(item, requestOptions, context)).subscriberContext(reactorContext -> {\n+            Optional<String> master = reactorContext.getOrEmpty(TracerProvider.MASTER_CALL);\n+            if (master.isPresent()) {\n+                reactorContext = reactorContext.put(TracerProvider.NESTED_CALL, true);\n+            }\n+            return reactorContext.put(TracerProvider.MASTER_CALL, true);", "originalCommit": "e614db5d38ff2f4947900fa0174774f8c13f37fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgzNjM1Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r414836352", "bodyText": "Done", "author": "simplynaveen20", "createdAt": "2020-04-24T20:14:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkwMjA4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkwMzE0Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r413903146", "bodyText": "does this log the user query? is that ok? user query may have private info?\n\"queryItems.\" + this.getId() + \".\" + sqlQuerySpec.getQueryText();", "author": "moderakh", "createdAt": "2020-04-23T15:36:35Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -379,6 +464,9 @@ public String getId() {\n     private <T> CosmosPagedFlux<T> queryItemsInternal(\n         SqlQuerySpec sqlQuerySpec, FeedOptions feedOptions, Class<T> classType) {\n         return UtilBridgeInternal.createCosmosPagedFlux(pagedFluxOptions -> {\n+            String spanName = \"queryItems.\" + this.getId() + \".\" + sqlQuerySpec.getQueryText();", "originalCommit": "e614db5d38ff2f4947900fa0174774f8c13f37fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgzNTU4NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r414835585", "bodyText": "@trask  whats your thought on this , I think @moderakh has a point here.", "author": "simplynaveen20", "createdAt": "2020-04-24T20:12:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkwMzE0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkwMTgzNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r414901834", "bodyText": "For jdbc, we only capture PreparedStatement query templates, and not the actual bind parameters provided by the user. We do something similar for MongoDB and other databases. is querytext a parameterized query template? or are bind parameters already embedded into it?", "author": "trask", "createdAt": "2020-04-24T22:40:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkwMzE0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTkwNTM4OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r415905389", "bodyText": "Cosmos have two api for query , one take plain text with parameter embedded into it and second takes SqlQuerySpec , which is template based. For plain text query, code itself create SqlQuerySpec and use common code flow as above.\nWe have two option here -\n\nOnly log query if user uses SqlQuerySpec  api , but this will be inconsistent.\nLog for both as it is happening now , assuming for all the sensitive query user will use SqlQuerySpec  api.\nDon't log query text any of the apis.\n\nI would go with option 1 , as I can take inconsistency over possibility of leaking private info. Option 3 will be my second choice\nThoughts ?", "author": "simplynaveen20", "createdAt": "2020-04-27T15:20:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkwMzE0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA2NTA0Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r416065047", "bodyText": "yes, option 1 sounds good. we still want to capture a span for plain text queries, but use something more generic for the span name and db.statement attribute, e.g. the same value that you put into db.instance would be acceptable", "author": "trask", "createdAt": "2020-04-27T18:50:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkwMzE0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM5NjAzNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r420396037", "bodyText": "done", "author": "simplynaveen20", "createdAt": "2020-05-05T20:47:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkwMzE0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkwMzU2Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r413903563", "bodyText": "can we factor out this code, here and other places?\ne.g,\nreturn withContext(context -> replaceItem(itemType, itemId, doc, requestOptions,context))\n    .subscriberContext(reactorContext -> factoredOutFunc())", "author": "moderakh", "createdAt": "2020-04-23T15:37:07Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -481,11 +572,14 @@ public String getId() {\n         ModelBridgeInternal.setPartitionKey(options, partitionKey);\n         @SuppressWarnings(\"unchecked\")\n         Class<T> itemType = (Class<T>) item.getClass();\n-        return this.getDatabase()\n-                   .getDocClientWrapper()\n-                   .replaceDocument(getItemLink(itemId), doc, ModelBridgeInternal.toRequestOptions(options))\n-                   .map(response -> ModelBridgeInternal.createCosmosAsyncItemResponse(response, itemType))\n-                   .single();\n+        final CosmosItemRequestOptions requestOptions = options;\n+        return withContext(context -> replaceItem(itemType, itemId, doc, requestOptions,context)).subscriberContext(reactorContext -> {\n+            Optional<String> master = reactorContext.getOrEmpty(TracerProvider.MASTER_CALL);\n+            if (master.isPresent()) {\n+                reactorContext = reactorContext.put(TracerProvider.NESTED_CALL, true);\n+            }\n+            return reactorContext.put(TracerProvider.MASTER_CALL, true);", "originalCommit": "e614db5d38ff2f4947900fa0174774f8c13f37fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgzNjA2MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r414836060", "bodyText": "Done", "author": "simplynaveen20", "createdAt": "2020-04-24T20:13:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkwMzU2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkwNjIwMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r413906202", "bodyText": "exactly same code as above, can we factor out?\nMap<String, String> createTracingMap(...) {\n   ...\n}\n\nand then invoke createTracingMap() here", "author": "moderakh", "createdAt": "2020-04-23T15:40:23Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -681,4 +763,168 @@ String getParentLink() {\n     String getLink() {\n         return this.link;\n     }\n+\n+    private Mono<CosmosAsyncItemResponse<Object>> deleteItem(\n+        String itemId,\n+        RequestOptions requestOptions,\n+        Context context) {\n+        String spanName = \"deleteItem.\" + this.getId();\n+        Map<String, String> tracingAttributes = new HashMap<String, String>() {{\n+            put(TracerProvider.DB_TYPE, TracerProvider.DB_TYPE_VALUE);\n+            put(TracerProvider.DB_INSTANCE, getId());\n+            put(TracerProvider.DB_URL, database.getClient().getServiceEndpoint());\n+            put(TracerProvider.DB_STATEMENT, spanName);\n+        }};\n+\n+        Mono<CosmosAsyncItemResponse<Object>> responseMono =  this.getDatabase()\n+            .getDocClientWrapper()\n+            .deleteDocument(getItemLink(itemId), requestOptions)\n+            .map(response -> ModelBridgeInternal.createCosmosAsyncItemResponseWithObjectType(response))\n+            .single();\n+        return database.getClient().getTracerProvider().traceEnabledCosmosItemResponsePublisher(responseMono,\n+            tracingAttributes,\n+            context, spanName);\n+    }\n+\n+    private <T> Mono<CosmosAsyncItemResponse<T>> replaceItem(\n+        Class<T> itemType,\n+        String itemId,\n+        Document doc,\n+        CosmosItemRequestOptions options,\n+        Context context) {\n+        String spanName = \"replaceItem.\" + this.getId();\n+        Map<String, String> tracingAttributes = new HashMap<String, String>() {{\n+            put(TracerProvider.DB_TYPE, TracerProvider.DB_TYPE_VALUE);\n+            put(TracerProvider.DB_INSTANCE, getId());\n+            put(TracerProvider.DB_URL, database.getClient().getServiceEndpoint());\n+            put(TracerProvider.DB_STATEMENT, spanName);\n+        }};", "originalCommit": "e614db5d38ff2f4947900fa0174774f8c13f37fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgzNjIxMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r414836211", "bodyText": "Done", "author": "simplynaveen20", "createdAt": "2020-04-24T20:14:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkwNjIwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkwNjUzMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r413906531", "bodyText": "ditto, here and other places.", "author": "moderakh", "createdAt": "2020-04-23T15:40:52Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -681,4 +763,168 @@ String getParentLink() {\n     String getLink() {\n         return this.link;\n     }\n+\n+    private Mono<CosmosAsyncItemResponse<Object>> deleteItem(\n+        String itemId,\n+        RequestOptions requestOptions,\n+        Context context) {\n+        String spanName = \"deleteItem.\" + this.getId();\n+        Map<String, String> tracingAttributes = new HashMap<String, String>() {{\n+            put(TracerProvider.DB_TYPE, TracerProvider.DB_TYPE_VALUE);\n+            put(TracerProvider.DB_INSTANCE, getId());\n+            put(TracerProvider.DB_URL, database.getClient().getServiceEndpoint());\n+            put(TracerProvider.DB_STATEMENT, spanName);\n+        }};\n+\n+        Mono<CosmosAsyncItemResponse<Object>> responseMono =  this.getDatabase()\n+            .getDocClientWrapper()\n+            .deleteDocument(getItemLink(itemId), requestOptions)\n+            .map(response -> ModelBridgeInternal.createCosmosAsyncItemResponseWithObjectType(response))\n+            .single();\n+        return database.getClient().getTracerProvider().traceEnabledCosmosItemResponsePublisher(responseMono,\n+            tracingAttributes,\n+            context, spanName);\n+    }\n+\n+    private <T> Mono<CosmosAsyncItemResponse<T>> replaceItem(\n+        Class<T> itemType,\n+        String itemId,\n+        Document doc,\n+        CosmosItemRequestOptions options,\n+        Context context) {\n+        String spanName = \"replaceItem.\" + this.getId();\n+        Map<String, String> tracingAttributes = new HashMap<String, String>() {{\n+            put(TracerProvider.DB_TYPE, TracerProvider.DB_TYPE_VALUE);\n+            put(TracerProvider.DB_INSTANCE, getId());\n+            put(TracerProvider.DB_URL, database.getClient().getServiceEndpoint());\n+            put(TracerProvider.DB_STATEMENT, spanName);\n+        }};\n+\n+        Mono<CosmosAsyncItemResponse<T>> responseMono = this.getDatabase()\n+            .getDocClientWrapper()\n+            .replaceDocument(getItemLink(itemId), doc, ModelBridgeInternal.toRequestOptions(options))\n+            .map(response -> ModelBridgeInternal.createCosmosAsyncItemResponse(response, itemType))\n+            .single();\n+        return database.getClient().getTracerProvider().traceEnabledCosmosItemResponsePublisher(responseMono,\n+            tracingAttributes,\n+            context, spanName);\n+    }\n+\n+    private <T> Mono<CosmosAsyncItemResponse<T>> upsertItem(T item, CosmosItemRequestOptions options, Context context) {\n+        String spanName = \"upsertItem.\" + this.getId();\n+        Map<String, String> tracingAttributes = new HashMap<String, String>() {{\n+            put(TracerProvider.DB_TYPE, TracerProvider.DB_TYPE_VALUE);\n+            put(TracerProvider.DB_INSTANCE, getId());\n+            put(TracerProvider.DB_URL, database.getClient().getServiceEndpoint());\n+            put(TracerProvider.DB_STATEMENT, spanName);\n+        }};", "originalCommit": "e614db5d38ff2f4947900fa0174774f8c13f37fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgzNjEyMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r414836122", "bodyText": "Done", "author": "simplynaveen20", "createdAt": "2020-04-24T20:13:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkwNjUzMQ=="}], "type": "inlineReview"}, {"oid": "c4ae21b2d1031f572abd8ba9c46b2e591a167b25", "url": "https://github.com/Azure/azure-sdk-for-java/commit/c4ae21b2d1031f572abd8ba9c46b2e591a167b25", "message": "Merge branch 'latest-master' into users/nakumars/tracercosmosdb", "committedDate": "2020-04-24T18:49:27Z", "type": "commit"}, {"oid": "eabbec95e6c61b20fa9365824e0944c5c5dcaf1a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/eabbec95e6c61b20fa9365824e0944c5c5dcaf1a", "message": "refactoring code with PR ready version", "committedDate": "2020-04-24T20:05:35Z", "type": "commit"}, {"oid": "36dde959516c9db168cca34023a105bbb19aa5da", "url": "https://github.com/Azure/azure-sdk-for-java/commit/36dde959516c9db168cca34023a105bbb19aa5da", "message": "ending span on doOnComplete", "committedDate": "2020-04-24T21:06:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDk5NDE0OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r414994148", "bodyText": "Does documentDB refer to us? if so, that name is deprecated.", "author": "moderakh", "createdAt": "2020-04-25T06:23:33Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -0,0 +1,206 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation;\n+\n+import com.azure.core.util.Context;\n+import com.azure.core.util.FluxUtil;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.cosmos.CosmosClientException;\n+import com.azure.cosmos.models.CosmosAsyncItemResponse;\n+import com.azure.cosmos.models.CosmosResponse;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Signal;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+import static com.azure.core.util.tracing.Tracer.AZ_TRACING_NAMESPACE_KEY;\n+\n+public class TracerProvider {\n+    private final ClientLogger logger = new ClientLogger(TracerProvider.class);\n+    private final List<Tracer> tracers = new ArrayList<>();\n+    public final static String DB_TYPE_VALUE = \"cosmosdb\";\n+    public final static String DB_TYPE = \"db.type\";\n+    public final static String DB_INSTANCE = \"db.instance\";\n+    public final static String DB_URL = \"db.url\";\n+    public static final String DB_STATEMENT = \"db.statement\";\n+    public static final String ERROR_MSG = \"error.msg\";\n+    public static final String ERROR_TYPE = \"error.type\";\n+    public static final String ERROR_STACK = \"error.stack\";\n+    public static final String COSMOS_CALL_DEPTH = \"cosmosCallDepth\";\n+    public static final String MICROSOFT_DOCOMENTDB = \"Microsoft.DocumentDB\";", "originalCommit": "36dde959516c9db168cca34023a105bbb19aa5da", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjAyMDA4Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r416020086", "bodyText": "This is the supported resource provider list of Azure services that gives the value Microsoft.DocumentDB for Cosmos.\nFeature request to include this on all Track 2 SDK's - #7049", "author": "samvaity", "createdAt": "2020-04-27T17:45:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDk5NDE0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE4NTY4Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r424185687", "bodyText": "@samvaity it seems as per the link you shared the resource provider name of our service is not updated from Microsoft.DocumentDB to Microsoft.Cosmos.\n@samvaity My question to you is if for tracer work, this is merge implementation details or whether in the application insight the customers will see the term \"DocumentDB\" ?", "author": "moderakh", "createdAt": "2020-05-13T05:46:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDk5NDE0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE4NjQxNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r424186415", "bodyText": "FYI @kirankumarkolli", "author": "moderakh", "createdAt": "2020-05-13T05:48:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDk5NDE0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE4OTYyMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r424189623", "bodyText": "The customers would see the term \"DocumentDB\".\nI think the ask was from the Azure Monitor team to be able to group spans/trace information for a particular Azure service and wanted to follow consistent naming across different components (i. Azure Monitor).\n\nAzure Monitor exporter will use this information to navigate to the corresponding Azure resource from AzMon UX and show proper icons. #7049\n\nI agree we should not follow deprecated naming but then is this listed incorrectly on the list too?\n@trask Do you think if Cosmos should still be referred to as Microsoft.DocumentDB?", "author": "samvaity", "createdAt": "2020-05-13T05:58:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDk5NDE0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE5MDA0NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r424190044", "bodyText": "Our SDK names already deviate from the RP name.\nJust for context: \"Azure Cosmos DB\" is the new branding (and RP will rebrand eventually).\nFor all Track2 libraries: How about using the package name 'Azure.Cosmos\" in our specific case?\n/cc: @JonathanGiles", "author": "kirankumarkolli", "createdAt": "2020-05-13T06:00:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDk5NDE0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTEwNTE5OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r439105199", "bodyText": "Discussed with Sameeksha , once the documentation here  updates with azure.cosmosdb, we will change in the code too. Other azure services are also mentioned as Microsoft currently.", "author": "simplynaveen20", "createdAt": "2020-06-11T22:27:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDk5NDE0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDk5NDE5Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r414994197", "bodyText": "shouldn't this be \"cosmos\" instead of \"cosmosdb\"", "author": "moderakh", "createdAt": "2020-04-25T06:23:54Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -0,0 +1,206 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation;\n+\n+import com.azure.core.util.Context;\n+import com.azure.core.util.FluxUtil;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.cosmos.CosmosClientException;\n+import com.azure.cosmos.models.CosmosAsyncItemResponse;\n+import com.azure.cosmos.models.CosmosResponse;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Signal;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+import static com.azure.core.util.tracing.Tracer.AZ_TRACING_NAMESPACE_KEY;\n+\n+public class TracerProvider {\n+    private final ClientLogger logger = new ClientLogger(TracerProvider.class);\n+    private final List<Tracer> tracers = new ArrayList<>();\n+    public final static String DB_TYPE_VALUE = \"cosmosdb\";", "originalCommit": "36dde959516c9db168cca34023a105bbb19aa5da", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM5NjQ0NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r420396445", "bodyText": "@trask  ?", "author": "simplynaveen20", "createdAt": "2020-05-05T20:48:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDk5NDE5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ0MTQ2MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r420441460", "bodyText": "both are good from my perspective \ud83d\udc4d", "author": "trask", "createdAt": "2020-05-05T22:21:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDk5NDE5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3NDEyOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r424174129", "bodyText": "The brand of our service, our package name, etc, is cosmos. So this should match that.", "author": "moderakh", "createdAt": "2020-05-13T05:04:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDk5NDE5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE5MDg0Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r424190843", "bodyText": "For consistency on SDK lets use \"Cosmos\"", "author": "kirankumarkolli", "createdAt": "2020-05-13T06:02:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDk5NDE5Nw=="}], "type": "inlineReview"}, {"oid": "36743ca506ec2fca6e25fe1c80062abcaba04688", "url": "https://github.com/Azure/azure-sdk-for-java/commit/36743ca506ec2fca6e25fe1c80062abcaba04688", "message": "resolving error", "committedDate": "2020-05-04T15:02:31Z", "type": "commit"}, {"oid": "cff33addaf0ee49c7ec153f0a6a8d6474f3870ef", "url": "https://github.com/Azure/azure-sdk-for-java/commit/cff33addaf0ee49c7ec153f0a6a8d6474f3870ef", "message": "merging with master", "committedDate": "2020-05-04T15:33:04Z", "type": "commit"}, {"oid": "8ca24ec529a3e6ea073cde068f3e46b2173cc6e5", "url": "https://github.com/Azure/azure-sdk-for-java/commit/8ca24ec529a3e6ea073cde068f3e46b2173cc6e5", "message": "perf improvement", "committedDate": "2020-05-05T20:06:26Z", "type": "commit"}, {"oid": "21034b55d17e22f587a0a9004359423c21959d4b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/21034b55d17e22f587a0a9004359423c21959d4b", "message": "resolving merge conflict", "committedDate": "2020-05-06T16:07:20Z", "type": "commit"}, {"oid": "1f9f1397b3ef30c383800bd32e6ebc1986c2567b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/1f9f1397b3ef30c383800bd32e6ebc1986c2567b", "message": "fixing build error", "committedDate": "2020-05-06T16:37:16Z", "type": "commit"}, {"oid": "aab85a6184c6ceda774df0b0ae055ee78af29289", "url": "https://github.com/Azure/azure-sdk-for-java/commit/aab85a6184c6ceda774df0b0ae055ee78af29289", "message": "resolving merge conflict", "committedDate": "2020-05-11T14:27:12Z", "type": "commit"}, {"oid": "d14a0bb5ee30f455dd35b545f564ec6b0ee5beb7", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d14a0bb5ee30f455dd35b545f564ec6b0ee5beb7", "message": "resolving merge conflict", "committedDate": "2020-05-11T14:29:15Z", "type": "commit"}, {"oid": "8fbad2c39de56e6a74e0ea2014c274bd0d1abe2e", "url": "https://github.com/Azure/azure-sdk-for-java/commit/8fbad2c39de56e6a74e0ea2014c274bd0d1abe2e", "message": "check non opentelementry jar non existence in starting of all api", "committedDate": "2020-05-11T14:36:28Z", "type": "commit"}, {"oid": "6b09e5c2504b94e80788d30048c96836bd20c1cb", "url": "https://github.com/Azure/azure-sdk-for-java/commit/6b09e5c2504b94e80788d30048c96836bd20c1cb", "message": "fixing checkstyle", "committedDate": "2020-05-11T15:18:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE4NzAyOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r423187028", "bodyText": "The withContext overload would be used for context passing and not just tracing context-related so should be included regardless of tracing presence.\n@srnagar", "author": "samvaity", "createdAt": "2020-05-11T17:04:27Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncClient.java", "diffHunk": "@@ -199,7 +201,12 @@ boolean isContentResponseOnWriteEnabled() {\n      * an error.\n      */\n     public Mono<CosmosAsyncDatabaseResponse> createDatabaseIfNotExists(CosmosDatabaseProperties databaseSettings) {\n-        return createDatabaseIfNotExistsInternal(getDatabase(databaseSettings.getId()));\n+        if(!getTracerProvider().isEnabled()) {\n+            return createDatabaseIfNotExistsInternal(getDatabase(databaseSettings.getId()));\n+        }\n+\n+        return withContext(context -> createDatabaseIfNotExistsInternal(getDatabase(databaseSettings.getId()),", "originalCommit": "8fbad2c39de56e6a74e0ea2014c274bd0d1abe2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzIwNzE0OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r423207149", "bodyText": "We don't want any perf hit due to tracing code flow if user has not opt in the tracing. Unless we have any requirement which need with context , and that will be out of scope of this PR", "author": "simplynaveen20", "createdAt": "2020-05-11T17:38:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE4NzAyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkwMjE0Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r423902147", "bodyText": "@samvaity is right, context is used not just for tracing. So, !getTracerProvider().isEnabled() is not the right check to determine whether to use withContext() or not.", "author": "srnagar", "createdAt": "2020-05-12T17:17:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE4NzAyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU1MjE2OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r424552169", "bodyText": "as discussed offline will introduce this on demand", "author": "simplynaveen20", "createdAt": "2020-05-13T15:59:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE4NzAyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU2ODc3Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r433568777", "bodyText": "I would like this to be resolved within this PR - Context is general purpose and not specifically tied to tracing. That it is treated as such here means that we are not following convention and users who are using Context for other purposes, e.g. in their own http policies, will get a surprise when the context is not properly propagating for them.", "author": "JonathanGiles", "createdAt": "2020-06-02T01:13:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE4NzAyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTEyMjIxOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r439122218", "bodyText": "With context having perf hit , if we do it on all, then non tracer user will get affected , already communicated to Sameeksha and Srikanta. We will track it as separate item and will introduce it on demand and we will then revisit perf again.", "author": "simplynaveen20", "createdAt": "2020-06-11T23:20:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE4NzAyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE4ODM4MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r423188380", "bodyText": "Should this span name be createDatabaseIfNotExists and not internal?", "author": "samvaity", "createdAt": "2020-05-11T17:06:40Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncClient.java", "diffHunk": "@@ -444,4 +447,77 @@ public CosmosAsyncDatabase getDatabase(String id) {\n     public void close() {\n         asyncDocumentClient.close();\n     }\n+\n+    TracerProvider getTracerProvider(){\n+        return this.tracerProvider;\n+    }\n+\n+    private CosmosPagedFlux<CosmosDatabaseProperties> queryDatabasesInternal(boolean isParameterised, SqlQuerySpec querySpec, FeedOptions options){\n+        return UtilBridgeInternal.createCosmosPagedFlux(pagedFluxOptions -> {\n+            String spanName;\n+            if (isParameterised) {\n+                spanName = \"queryDatabases.\" + querySpec.getQueryText();\n+            } else {\n+                spanName = \"queryDatabases\";\n+            }\n+\n+            pagedFluxOptions.setTracerInformation(this.tracerProvider, spanName, this.serviceEndpoint, null);\n+            setContinuationTokenAndMaxItemCount(pagedFluxOptions, options);\n+            return getDocClientWrapper().queryDatabases(querySpec, options)\n+                .map(response -> BridgeInternal.createFeedResponse(\n+                    ModelBridgeInternal.getCosmosDatabasePropertiesFromV2Results(response.getResults()),\n+                    response.getResponseHeaders()));\n+        });\n+    }\n+\n+\n+    private Mono<CosmosAsyncDatabaseResponse> createDatabaseIfNotExistsInternal(CosmosAsyncDatabase database,\n+                                                                                Context context) {\n+        String spanName = \"createDatabaseIfNotExistsInternal.\" + database.getId();", "originalCommit": "6b09e5c2504b94e80788d30048c96836bd20c1cb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "81040b270c3a369ae5289428143c144b9e57d54c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/81040b270c3a369ae5289428143c144b9e57d54c", "message": "resolving comments", "committedDate": "2020-05-11T18:09:41Z", "type": "commit"}, {"oid": "dbc74c8f7ea56fdcf88c1bc35032d81139302805", "url": "https://github.com/Azure/azure-sdk-for-java/commit/dbc74c8f7ea56fdcf88c1bc35032d81139302805", "message": "Merge branch 'latest-master' into users/nakumars/tracercosmosdb", "committedDate": "2020-05-11T18:20:59Z", "type": "commit"}, {"oid": "806cdf154862a36147c6bc3cfebe582e6fa323b3", "url": "https://github.com/Azure/azure-sdk-for-java/commit/806cdf154862a36147c6bc3cfebe582e6fa323b3", "message": "check style fix as per java 8", "committedDate": "2020-05-11T18:56:09Z", "type": "commit"}, {"oid": "d061db5abcbf948ae4159576f7ee94a75eca574f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d061db5abcbf948ae4159576f7ee94a75eca574f", "message": "adding azure-core-tracing-opentelemetry in test scope", "committedDate": "2020-05-11T21:11:36Z", "type": "commit"}, {"oid": "32d9172690f0c9bb71a539f3b6cbca1a7cfd19d2", "url": "https://github.com/Azure/azure-sdk-for-java/commit/32d9172690f0c9bb71a539f3b6cbca1a7cfd19d2", "message": "resolving conflict", "committedDate": "2020-05-11T23:17:04Z", "type": "commit"}, {"oid": "0fc0cc923557735ac777c7037e5a5491e6675467", "url": "https://github.com/Azure/azure-sdk-for-java/commit/0fc0cc923557735ac777c7037e5a5491e6675467", "message": "build error fix", "committedDate": "2020-05-11T23:38:49Z", "type": "commit"}, {"oid": "1290ae13cd5eb1995ddd3a4bbc9a705456fafd9a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/1290ae13cd5eb1995ddd3a4bbc9a705456fafd9a", "message": "test failure fix", "committedDate": "2020-05-12T01:19:20Z", "type": "commit"}, {"oid": "d2a815459cf553a0f24126b0765e5b3a375ccd4b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d2a815459cf553a0f24126b0765e5b3a375ccd4b", "message": "test fix", "committedDate": "2020-05-12T02:00:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk0NTI1Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r423945253", "bodyText": "callDepth cannot be null as you are doing getOrDefault in the previous line.\nAlso, it's better to use if (callDepth == null) { throw exception; } instead of using assert. If the assertion fails, it throws AssertionError extends from Error which is considered fatal and the program cannot recover.", "author": "srnagar", "createdAt": "2020-05-12T18:27:53Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -0,0 +1,197 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation;\n+\n+import com.azure.core.util.Context;\n+import com.azure.core.util.FluxUtil;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.cosmos.CosmosClientException;\n+import com.azure.cosmos.models.CosmosAsyncItemResponse;\n+import com.azure.cosmos.models.CosmosResponse;\n+import com.azure.cosmos.models.ResourceWrapper;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Signal;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+import static com.azure.core.util.tracing.Tracer.AZ_TRACING_NAMESPACE_KEY;\n+\n+public class TracerProvider {\n+    private final List<Tracer> tracers = new ArrayList<>();\n+    private final boolean isEnabled;\n+    public final static String DB_TYPE_VALUE = \"cosmosdb\";\n+    public final static String DB_TYPE = \"db.type\";\n+    public final static String DB_INSTANCE = \"db.instance\";\n+    public final static String DB_URL = \"db.url\";\n+    public static final String DB_STATEMENT = \"db.statement\";\n+    public static final String ERROR_MSG = \"error.msg\";\n+    public static final String ERROR_TYPE = \"error.type\";\n+    public static final String ERROR_STACK = \"error.stack\";\n+    public static final String COSMOS_CALL_DEPTH = \"cosmosCallDepth\";\n+    public static final String MICROSOFT_DOCOMENTDB = \"Microsoft.DocumentDB\";\n+\n+\n+    public final static Function<reactor.util.context.Context, reactor.util.context.Context> callDepthAttributeFunc = (\n+        reactor.util.context.Context reactorContext) -> {\n+        CallDepth callDepth = reactorContext.getOrDefault(COSMOS_CALL_DEPTH, CallDepth.ZERO);\n+        assert callDepth != null;", "originalCommit": "d2a815459cf553a0f24126b0765e5b3a375ccd4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU1MTc5NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r424551795", "bodyText": "as discussed offline , it is due to spot bug", "author": "simplynaveen20", "createdAt": "2020-05-13T15:58:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk0NTI1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk1MjcwNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r423952706", "bodyText": "This code segment is common for both overloads of createDatabaseIfNotExistsInternal. Consider extracting into a common method instead of repeating it.", "author": "srnagar", "createdAt": "2020-05-12T18:40:53Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncClient.java", "diffHunk": "@@ -444,4 +447,77 @@ public CosmosAsyncDatabase getDatabase(String id) {\n     public void close() {\n         asyncDocumentClient.close();\n     }\n+\n+    TracerProvider getTracerProvider(){\n+        return this.tracerProvider;\n+    }\n+\n+    private CosmosPagedFlux<CosmosDatabaseProperties> queryDatabasesInternal(boolean isParameterised, SqlQuerySpec querySpec, FeedOptions options){\n+        return UtilBridgeInternal.createCosmosPagedFlux(pagedFluxOptions -> {\n+            String spanName;\n+            if (isParameterised) {\n+                spanName = \"queryDatabases.\" + querySpec.getQueryText();\n+            } else {\n+                spanName = \"queryDatabases\";\n+            }\n+\n+            pagedFluxOptions.setTracerInformation(this.tracerProvider, spanName, this.serviceEndpoint, null);\n+            setContinuationTokenAndMaxItemCount(pagedFluxOptions, options);\n+            return getDocClientWrapper().queryDatabases(querySpec, options)\n+                .map(response -> BridgeInternal.createFeedResponse(\n+                    ModelBridgeInternal.getCosmosDatabasePropertiesFromV2Results(response.getResults()),\n+                    response.getResponseHeaders()));\n+        });\n+    }\n+\n+\n+    private Mono<CosmosAsyncDatabaseResponse> createDatabaseIfNotExistsInternal(CosmosAsyncDatabase database,\n+                                                                                Context context) {\n+        String spanName = \"createDatabaseIfNotExists.\" + database.getId();\n+        Mono<CosmosAsyncDatabaseResponse> responseMono = database.read().onErrorResume(exception -> {\n+            final Throwable unwrappedException = Exceptions.unwrap(exception);\n+            if (unwrappedException instanceof CosmosClientException) {\n+                final CosmosClientException cosmosClientException = (CosmosClientException) unwrappedException;\n+                if (cosmosClientException.getStatusCode() == HttpConstants.StatusCodes.NOTFOUND) {\n+                    return createDatabase(new CosmosDatabaseProperties(database.getId()),\n+                        new CosmosDatabaseRequestOptions());\n+                }\n+            }\n+            return Mono.error(unwrappedException);\n+        });", "originalCommit": "d2a815459cf553a0f24126b0765e5b3a375ccd4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3NTgwNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r424175804", "bodyText": "code style: callDepthAttributeFunc is a static field. CALL_DEPTH_ATTRIBUTE_FUNC ?", "author": "moderakh", "createdAt": "2020-05-13T05:10:22Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -0,0 +1,197 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation;\n+\n+import com.azure.core.util.Context;\n+import com.azure.core.util.FluxUtil;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.cosmos.CosmosClientException;\n+import com.azure.cosmos.models.CosmosAsyncItemResponse;\n+import com.azure.cosmos.models.CosmosResponse;\n+import com.azure.cosmos.models.ResourceWrapper;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Signal;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+import static com.azure.core.util.tracing.Tracer.AZ_TRACING_NAMESPACE_KEY;\n+\n+public class TracerProvider {\n+    private final List<Tracer> tracers = new ArrayList<>();\n+    private final boolean isEnabled;\n+    public final static String DB_TYPE_VALUE = \"cosmosdb\";\n+    public final static String DB_TYPE = \"db.type\";\n+    public final static String DB_INSTANCE = \"db.instance\";\n+    public final static String DB_URL = \"db.url\";\n+    public static final String DB_STATEMENT = \"db.statement\";\n+    public static final String ERROR_MSG = \"error.msg\";\n+    public static final String ERROR_TYPE = \"error.type\";\n+    public static final String ERROR_STACK = \"error.stack\";\n+    public static final String COSMOS_CALL_DEPTH = \"cosmosCallDepth\";\n+    public static final String MICROSOFT_DOCOMENTDB = \"Microsoft.DocumentDB\";\n+\n+\n+    public final static Function<reactor.util.context.Context, reactor.util.context.Context> callDepthAttributeFunc = (", "originalCommit": "d2a815459cf553a0f24126b0765e5b3a375ccd4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3NTk4NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r424175984", "bodyText": "MICROSOFT_DOCOMENTDB -> RESOURCE_PROVIDER_NAME", "author": "moderakh", "createdAt": "2020-05-13T05:11:01Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -0,0 +1,197 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation;\n+\n+import com.azure.core.util.Context;\n+import com.azure.core.util.FluxUtil;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.cosmos.CosmosClientException;\n+import com.azure.cosmos.models.CosmosAsyncItemResponse;\n+import com.azure.cosmos.models.CosmosResponse;\n+import com.azure.cosmos.models.ResourceWrapper;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Signal;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+import static com.azure.core.util.tracing.Tracer.AZ_TRACING_NAMESPACE_KEY;\n+\n+public class TracerProvider {\n+    private final List<Tracer> tracers = new ArrayList<>();\n+    private final boolean isEnabled;\n+    public final static String DB_TYPE_VALUE = \"cosmosdb\";\n+    public final static String DB_TYPE = \"db.type\";\n+    public final static String DB_INSTANCE = \"db.instance\";\n+    public final static String DB_URL = \"db.url\";\n+    public static final String DB_STATEMENT = \"db.statement\";\n+    public static final String ERROR_MSG = \"error.msg\";\n+    public static final String ERROR_TYPE = \"error.type\";\n+    public static final String ERROR_STACK = \"error.stack\";\n+    public static final String COSMOS_CALL_DEPTH = \"cosmosCallDepth\";\n+    public static final String MICROSOFT_DOCOMENTDB = \"Microsoft.DocumentDB\";", "originalCommit": "d2a815459cf553a0f24126b0765e5b3a375ccd4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3ODgyOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r424178828", "bodyText": "regardless of if tracing is enabled or not we are passing the Pageflux to the tracing stack, and recreating some internal Map in FluxUtil::toAzureContext\nThis should sit behind a tracing enabled flag.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return FluxUtil.fluxContext(context ->  byPage(cosmosPagedFluxOptions, context)).subscriberContext(TracerProvider.callDepthAttributeFunc);\n          \n          \n            \n            if (tracing.enabled) {\n          \n          \n            \n             return FluxUtil.fluxContext(context ->  byPage(cosmosPagedFluxOptions, context)).subscriberContext(TracerProvider.callDepthAttributeFunc);\n          \n          \n            \n            } else {\n          \n          \n            \n             return this.optionsFluxFunction.apply(cosmosPagedFluxOptions);\n          \n          \n            \n            }\n          \n      \n    \n    \n  \n\nYou should be able to factor out the common if/else code into a method and just call that here, but it seems to me we should have a short circurt for when tracing is not enabled.", "author": "moderakh", "createdAt": "2020-05-13T05:22:14Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/util/CosmosPagedFlux.java", "diffHunk": "@@ -37,24 +44,23 @@\n     @Override\n     public Flux<FeedResponse<T>> byPage() {\n         CosmosPagedFluxOptions cosmosPagedFluxOptions = new CosmosPagedFluxOptions();\n-\n-        return this.optionsFluxFunction.apply(cosmosPagedFluxOptions);\n+        return FluxUtil.fluxContext(context ->  byPage(cosmosPagedFluxOptions, context)).subscriberContext(TracerProvider.callDepthAttributeFunc);", "originalCommit": "d2a815459cf553a0f24126b0765e5b3a375ccd4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUxMDE5Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r424510197", "bodyText": "Cosmos page flux does not hold any state , so we don't have tracing.enabled flag till optionsFluxFunction.apply is called, please suggest", "author": "simplynaveen20", "createdAt": "2020-05-13T15:03:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3ODgyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc1ODkyMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r430758921", "bodyText": "done", "author": "simplynaveen20", "createdAt": "2020-05-26T23:18:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3ODgyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3OTA4Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r424179082", "bodyText": "magic number 200 should be a constant.", "author": "moderakh", "createdAt": "2020-05-13T05:23:15Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/util/CosmosPagedFlux.java", "diffHunk": "@@ -84,4 +90,26 @@ public void subscribe(CoreSubscriber<? super T> coreSubscriber) {\n             return Flux.fromIterable(elements);\n         }).subscribe(coreSubscriber);\n     }\n+\n+    private Flux<FeedResponse<T>> byPage(CosmosPagedFluxOptions pagedFluxOptions, Context context) {\n+        final AtomicReference<Context> parentContext =  new AtomicReference<>(Context.NONE);\n+        TracerProvider.CallDepth callDepth = FluxUtil.toReactorContext(context).getOrDefault(COSMOS_CALL_DEPTH,\n+            TracerProvider.CallDepth.ZERO);\n+        assert callDepth != null;\n+        final boolean isNestedCall = callDepth.equals(TracerProvider.CallDepth.TWO_OR_MORE);\n+        return this.optionsFluxFunction.apply(pagedFluxOptions).doOnSubscribe(ignoredValue -> {\n+            if ( pagedFluxOptions.getTracerProvider().isEnabled() && !isNestedCall) {\n+                    parentContext.set(pagedFluxOptions.getTracerProvider().startSpan(pagedFluxOptions.getTracerSpanName(), pagedFluxOptions.getDatabaseId(), pagedFluxOptions.getServiceEndpoint(),\n+                        context));\n+            }\n+        }).doOnComplete(() -> {\n+            if ( pagedFluxOptions.getTracerProvider().isEnabled() && !isNestedCall) {\n+                pagedFluxOptions.getTracerProvider().endSpan(parentContext.get(), Signal.complete(), 200);", "originalCommit": "d2a815459cf553a0f24126b0765e5b3a375ccd4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE3OTE4Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r424179187", "bodyText": "license header.", "author": "moderakh", "createdAt": "2020-05-13T05:23:37Z", "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/CosmosTracerTest.java", "diffHunk": "@@ -0,0 +1,251 @@\n+package com.azure.cosmos;", "originalCommit": "d2a815459cf553a0f24126b0765e5b3a375ccd4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE4MTEwNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r424181107", "bodyText": "this will have additional cost even if tracer not enabled.\ni see in the code withContext is doing Map creation etc.\nwe should short circuit this if tracer is not enabled.", "author": "moderakh", "createdAt": "2020-05-13T05:29:59Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -85,8 +88,13 @@ public String getId() {\n         if (options == null) {\n             options = new CosmosContainerRequestOptions();\n         }\n-        return database.getDocClientWrapper().readCollection(getLink(), ModelBridgeInternal.toRequestOptions(options))\n-                   .map(response -> ModelBridgeInternal.createCosmosAsyncContainerResponse(response, database)).single();\n+\n+        final CosmosContainerRequestOptions requestOptions = options;\n+        if(!database.getClient().getTracerProvider().isEnabled()){\n+            return readInternal(options);\n+        }\n+\n+        return withContext(context -> read(requestOptions, context)).subscriberContext(TracerProvider.callDepthAttributeFunc);", "originalCommit": "d2a815459cf553a0f24126b0765e5b3a375ccd4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ5NDIxNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r424494214", "bodyText": "its already after the tracer enable check", "author": "simplynaveen20", "createdAt": "2020-05-13T14:43:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE4MTEwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE4MTIxNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r424181215", "bodyText": "ditto, here and in other places.", "author": "moderakh", "createdAt": "2020-05-13T05:30:16Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -104,8 +112,13 @@ public String getId() {\n         if (options == null) {\n             options = new CosmosContainerRequestOptions();\n         }\n-        return database.getDocClientWrapper().deleteCollection(getLink(), ModelBridgeInternal.toRequestOptions(options))\n-                   .map(response -> ModelBridgeInternal.createCosmosAsyncContainerResponse(response, database)).single();\n+\n+        if (!database.getClient().getTracerProvider().isEnabled()) {\n+            return deleteInternal(options);\n+        }\n+\n+        final CosmosContainerRequestOptions requestOptions = options;\n+        return withContext(context -> deleteInternal(requestOptions, context)).subscriberContext(TracerProvider.callDepthAttributeFunc);", "originalCommit": "d2a815459cf553a0f24126b0765e5b3a375ccd4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ5NDUxOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r424494519", "bodyText": "its already after the tracer enable check", "author": "simplynaveen20", "createdAt": "2020-05-13T14:43:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE4MTIxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE4MTY1Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r424181653", "bodyText": "id is the id of the container. so it means in the scope of this container \"createItem.\" + this.getId() can be pre-computed for the container, rather than re-computing it each time.\nCould you pre-compute this in the container level.", "author": "moderakh", "createdAt": "2020-05-13T05:31:56Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -218,16 +234,33 @@ public String getId() {\n         if (options == null) {\n             options = new CosmosItemRequestOptions();\n         }\n+\n+        if (!database.getClient().getTracerProvider().isEnabled()) {\n+            return createItemInternal(item, options);\n+        }\n+\n+        final CosmosItemRequestOptions requestOptions = options;\n+        return withContext(context -> createItemInternal(item, requestOptions, context)).subscriberContext(TracerProvider.callDepthAttributeFunc);\n+    }\n+\n+    private <T> Mono<CosmosAsyncItemResponse<T>> createItemInternal(T item, CosmosItemRequestOptions options, Context context) {\n+        String spanName = \"createItem.\" + this.getId();", "originalCommit": "d2a815459cf553a0f24126b0765e5b3a375ccd4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE4MTg0NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r424181845", "bodyText": "id is the id of the container. so it means in the scope of this container \"readAllItems.\" + this.getId() can be pre-computed for the container, rather than re-computing it each time.\nCould you pre-compute this in the container level.\nhere and other places.", "author": "moderakh", "createdAt": "2020-05-13T05:32:33Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -302,6 +334,9 @@ public String getId() {\n      */\n     public <T> CosmosPagedFlux<T> readAllItems(FeedOptions options, Class<T> classType) {\n         return UtilBridgeInternal.createCosmosPagedFlux(pagedFluxOptions -> {\n+            String spanName = \"readAllItems.\" + this.getId();", "originalCommit": "d2a815459cf553a0f24126b0765e5b3a375ccd4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE4MjQ0MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r424182440", "bodyText": "\"readItem.\" + this.getId() can be pre-computed in container rather than re-computing each time.\nplease pre-compute in the container.\nand for similar other operations.", "author": "moderakh", "createdAt": "2020-05-13T05:34:38Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -747,4 +776,182 @@ String getParentLink() {\n     String getLink() {\n         return this.link;\n     }\n+\n+    private Mono<CosmosAsyncItemResponse<Object>> deleteItemInternal(\n+        String itemId,\n+        RequestOptions requestOptions,\n+        Context context) {\n+        String spanName = \"deleteItem.\" + this.getId();\n+        Mono<CosmosAsyncItemResponse<Object>> responseMono = deleteItemInternal(itemId, requestOptions);\n+        return database.getClient().getTracerProvider().traceEnabledCosmosItemResponsePublisher(responseMono,\n+            context, spanName, database.getId(), database.getClient().getServiceEndpoint());\n+    }\n+\n+    private Mono<CosmosAsyncItemResponse<Object>> deleteItemInternal(\n+        String itemId,\n+        RequestOptions requestOptions) {\n+        return this.getDatabase()\n+            .getDocClientWrapper()\n+            .deleteDocument(getItemLink(itemId), requestOptions)\n+            .map(response -> ModelBridgeInternal.createCosmosAsyncItemResponseWithObjectType(response))\n+            .single();\n+    }\n+\n+    private <T> Mono<CosmosAsyncItemResponse<T>> replaceItemInternal(\n+        Class<T> itemType,\n+        String itemId,\n+        Document doc,\n+        CosmosItemRequestOptions options,\n+        Context context) {\n+        String spanName = \"replaceItem.\" + this.getId();\n+        Mono<CosmosAsyncItemResponse<T>> responseMono = replaceItemInternal(itemType, itemId, doc, options);\n+        return database.getClient().getTracerProvider().traceEnabledCosmosItemResponsePublisher(responseMono,\n+            context, spanName, database.getId(), database.getClient().getServiceEndpoint());\n+    }\n+\n+    private <T> Mono<CosmosAsyncItemResponse<T>> replaceItemInternal(\n+        Class<T> itemType,\n+        String itemId,\n+        Document doc,\n+        CosmosItemRequestOptions options) {\n+       return this.getDatabase()\n+            .getDocClientWrapper()\n+            .replaceDocument(getItemLink(itemId), doc, ModelBridgeInternal.toRequestOptions(options))\n+            .map(response -> ModelBridgeInternal.createCosmosAsyncItemResponse(response, itemType))\n+            .single();\n+    }\n+\n+    private <T> Mono<CosmosAsyncItemResponse<T>> upsertItemInternal(T item, CosmosItemRequestOptions options, Context context) {\n+        String spanName = \"upsertItem.\" + this.getId();\n+        Mono<CosmosAsyncItemResponse<T>> responseMono = upsertItemInternal(item, options);\n+        return database.getClient().getTracerProvider().traceEnabledCosmosItemResponsePublisher(responseMono,\n+            context, spanName, database.getId(), database.getClient().getServiceEndpoint());\n+    }\n+\n+    private <T> Mono<CosmosAsyncItemResponse<T>> upsertItemInternal(T item, CosmosItemRequestOptions options) {\n+        @SuppressWarnings(\"unchecked\")\n+        Class<T> itemType = (Class<T>) item.getClass();\n+        return this.getDatabase().getDocClientWrapper()\n+            .upsertDocument(this.getLink(), item,\n+                ModelBridgeInternal.toRequestOptions(options),\n+                true)\n+            .map(response -> ModelBridgeInternal.createCosmosAsyncItemResponse(response, itemType))\n+            .single();\n+    }\n+\n+    private <T> Mono<CosmosAsyncItemResponse<T>> readItemInternal(\n+        String itemId, PartitionKey partitionKey,\n+        RequestOptions requestOptions, Class<T> itemType,\n+        Context context) {\n+        String spanName = \"readItem.\" + this.getId();", "originalCommit": "d2a815459cf553a0f24126b0765e5b3a375ccd4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "30c2f8962f070e59790585b7abee6aa5e5a136a1", "url": "https://github.com/Azure/azure-sdk-for-java/commit/30c2f8962f070e59790585b7abee6aa5e5a136a1", "message": "resolving comments", "committedDate": "2020-05-13T15:56:57Z", "type": "commit"}, {"oid": "e7fa831bfcdc284440ff14a26ec84bd02732c79c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/e7fa831bfcdc284440ff14a26ec84bd02732c79c", "message": "complie error fix", "committedDate": "2020-05-13T17:38:31Z", "type": "commit"}, {"oid": "3aa851d64c0ee1d43d1d86994d4e19a677ac7dc8", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3aa851d64c0ee1d43d1d86994d4e19a677ac7dc8", "message": "removing query text from tracer", "committedDate": "2020-05-15T14:51:03Z", "type": "commit"}, {"oid": "0debac080b3ff04085ed11f0fdaa2a482a8eb096", "url": "https://github.com/Azure/azure-sdk-for-java/commit/0debac080b3ff04085ed11f0fdaa2a482a8eb096", "message": "resolving merge conflict", "committedDate": "2020-05-15T16:14:16Z", "type": "commit"}, {"oid": "8efa4514350b03035400964d817e4136b4e03486", "url": "https://github.com/Azure/azure-sdk-for-java/commit/8efa4514350b03035400964d817e4136b4e03486", "message": "merge with master and removing subscriber context for perf gain", "committedDate": "2020-05-26T23:17:29Z", "type": "commit"}, {"oid": "e7fe8bb66384a0999cb137e3d0476540cf419c84", "url": "https://github.com/Azure/azure-sdk-for-java/commit/e7fe8bb66384a0999cb137e3d0476540cf419c84", "message": "resolving merge conflict", "committedDate": "2020-05-26T23:20:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA0OTQxOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r432049418", "bodyText": "does 0 have a specific meaning in the failure context?\nshoudn't we pass error code here instead of 0?\nFor example if it is a CosmosException then cosmosExcpetion.getStatusCode() instead of 0 ?", "author": "moderakh", "createdAt": "2020-05-28T18:51:04Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/util/CosmosPagedFlux.java", "diffHunk": "@@ -84,4 +103,18 @@ public void subscribe(CoreSubscriber<? super T> coreSubscriber) {\n             return Flux.fromIterable(elements);\n         }).subscribe(coreSubscriber);\n     }\n+\n+    private Flux<FeedResponse<T>> byPage(CosmosPagedFluxOptions pagedFluxOptions, Context context) {\n+        final AtomicReference<Context> parentContext = new AtomicReference<>(Context.NONE);\n+        return this.optionsFluxFunction.apply(pagedFluxOptions).doOnSubscribe(ignoredValue -> {\n+            parentContext.set(pagedFluxOptions.getTracerProvider().startSpan(pagedFluxOptions.getTracerSpanName(),\n+                pagedFluxOptions.getDatabaseId(), pagedFluxOptions.getServiceEndpoint(),\n+                context));\n+        }).doOnComplete(() -> {\n+            pagedFluxOptions.getTracerProvider().endSpan(parentContext.get(), Signal.complete(),\n+                HttpConstants.StatusCodes.OK);\n+        }).doOnError(throwable -> {\n+            pagedFluxOptions.getTracerProvider().endSpan(parentContext.get(), Signal.error(throwable), 0);", "originalCommit": "e7fe8bb66384a0999cb137e3d0476540cf419c84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUwMzM4Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r433503383", "bodyText": "+1 we should pass the failing status code.", "author": "samvaity", "createdAt": "2020-06-01T21:35:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA0OTQxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk4ODgxMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r438988812", "bodyText": "end span method have the logic of parsing cosmos exception from throwable , and sending status code. If exception is non cosmos then only this 0 will get entertain", "author": "simplynaveen20", "createdAt": "2020-06-11T18:28:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA0OTQxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA1MjM1Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r432052352", "bodyText": "fix indentation plz. args on the same indentation.", "author": "moderakh", "createdAt": "2020-05-28T18:56:18Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -0,0 +1,175 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation;\n+\n+import com.azure.core.util.Context;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.cosmos.CosmosException;\n+import com.azure.cosmos.models.CosmosAsyncItemResponse;\n+import com.azure.cosmos.models.CosmosResponse;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Signal;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+import static com.azure.core.util.tracing.Tracer.AZ_TRACING_NAMESPACE_KEY;\n+\n+public class TracerProvider {\n+    private final List<Tracer> tracers = new ArrayList<>();\n+    private final boolean isEnabled;\n+    public final static String DB_TYPE_VALUE = \"Cosmos\";\n+    public final static String DB_TYPE = \"db.type\";\n+    public final static String DB_INSTANCE = \"db.instance\";\n+    public final static String DB_URL = \"db.url\";\n+    public static final String DB_STATEMENT = \"db.statement\";\n+    public static final String ERROR_MSG = \"error.msg\";\n+    public static final String ERROR_TYPE = \"error.type\";\n+    public static final String ERROR_STACK = \"error.stack\";\n+    public static final String COSMOS_CALL_DEPTH = \"cosmosCallDepth\";\n+    public static final String COSMOS_CALL_DEPTH_VAL = \"nested\";\n+    public static final String RESOURCE_PROVIDER_NAME = \"Microsoft.DocumentDB\";\n+\n+    public TracerProvider(Iterable<Tracer> tracers) {\n+        Objects.requireNonNull(tracers, \"'tracers' cannot be null.\");\n+        tracers.forEach(this.tracers::add);\n+        isEnabled = this.tracers.size() > 0;\n+    }\n+\n+    public boolean isEnabled() {\n+        return isEnabled;\n+    }\n+\n+    /**\n+     * For each tracer plugged into the SDK a new tracing span is created.\n+     * <p>\n+     * The {@code context} will be checked for containing information about a parent span. If a parent span is found the\n+     * new span will be added as a child, otherwise the span will be created and added to the context and any downstream\n+     * start calls will use the created span as the parent.\n+     *\n+     * @param context Additional metadata that is passed through the call stack.\n+     * @return An updated context object.\n+     */\n+    public Context startSpan(String methodName, String databaseId, String endpoint, Context context) {\n+        Context local = Objects.requireNonNull(context, \"'context' cannot be null.\");\n+        for (Tracer tracer : tracers) {\n+            local = tracer.start(methodName, local); // start the span and return the started span\n+            if (databaseId != null) {\n+                tracer.setAttribute(TracerProvider.DB_INSTANCE, databaseId, local);\n+            }\n+\n+            tracer.setAttribute(AZ_TRACING_NAMESPACE_KEY, RESOURCE_PROVIDER_NAME, local);\n+            tracer.setAttribute(TracerProvider.DB_TYPE, DB_TYPE_VALUE, local);\n+            tracer.setAttribute(TracerProvider.DB_URL, endpoint, local);\n+            tracer.setAttribute(TracerProvider.DB_STATEMENT, methodName, local);\n+        }\n+\n+        return local;\n+    }\n+\n+    /**\n+     * Given a context containing the current tracing span the span is marked completed with status info from\n+     * {@link Signal}.  For each tracer plugged into the SDK the current tracing span is marked as completed.\n+     *\n+     * @param context Additional metadata that is passed through the call stack.\n+     * @param signal  The signal indicates the status and contains the metadata we need to end the tracing span.\n+     */\n+    public <T extends CosmosResponse<? extends Resource>> void endSpan(Context context, Signal<T> signal, int statusCode) {\n+        Objects.requireNonNull(context, \"'context' cannot be null.\");\n+        Objects.requireNonNull(signal, \"'signal' cannot be null.\");\n+\n+        switch (signal.getType()) {\n+            case ON_COMPLETE:\n+                end(statusCode, null, context);\n+                break;\n+            case ON_ERROR:\n+                Throwable throwable = null;\n+                if (signal.hasError()) {\n+                    // The last status available is on error, this contains the thrown error.\n+                    throwable = signal.getThrowable();\n+\n+                    if (throwable instanceof CosmosException) {\n+                        CosmosException exception = (CosmosException) throwable;\n+                        // confirm ?\n+                        statusCode = exception.getStatusCode();\n+                    }\n+                }\n+                end(statusCode, throwable, context);\n+                break;\n+            default:\n+                // ON_SUBSCRIBE and ON_NEXT don't have the information to end the span so just return.\n+                break;\n+        }\n+    }\n+\n+    public <T extends CosmosResponse<?>> Mono<T> traceEnabledCosmosResponsePublisher(Mono<T> resultPublisher,\n+                                                                                                             Context context,\n+                                                                                                             String spanName,\n+                                                                                                             String databaseId,\n+                                                                                                             String endpoint) {", "originalCommit": "e7fe8bb66384a0999cb137e3d0476540cf419c84", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA1MzI1Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r432053256", "bodyText": "why are we sending 0? does 0 have special meaning?\nif so shouldn't 0 be used a constant?", "author": "moderakh", "createdAt": "2020-05-28T18:57:57Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -0,0 +1,175 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation;\n+\n+import com.azure.core.util.Context;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.cosmos.CosmosException;\n+import com.azure.cosmos.models.CosmosAsyncItemResponse;\n+import com.azure.cosmos.models.CosmosResponse;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Signal;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+import static com.azure.core.util.tracing.Tracer.AZ_TRACING_NAMESPACE_KEY;\n+\n+public class TracerProvider {\n+    private final List<Tracer> tracers = new ArrayList<>();\n+    private final boolean isEnabled;\n+    public final static String DB_TYPE_VALUE = \"Cosmos\";\n+    public final static String DB_TYPE = \"db.type\";\n+    public final static String DB_INSTANCE = \"db.instance\";\n+    public final static String DB_URL = \"db.url\";\n+    public static final String DB_STATEMENT = \"db.statement\";\n+    public static final String ERROR_MSG = \"error.msg\";\n+    public static final String ERROR_TYPE = \"error.type\";\n+    public static final String ERROR_STACK = \"error.stack\";\n+    public static final String COSMOS_CALL_DEPTH = \"cosmosCallDepth\";\n+    public static final String COSMOS_CALL_DEPTH_VAL = \"nested\";\n+    public static final String RESOURCE_PROVIDER_NAME = \"Microsoft.DocumentDB\";\n+\n+    public TracerProvider(Iterable<Tracer> tracers) {\n+        Objects.requireNonNull(tracers, \"'tracers' cannot be null.\");\n+        tracers.forEach(this.tracers::add);\n+        isEnabled = this.tracers.size() > 0;\n+    }\n+\n+    public boolean isEnabled() {\n+        return isEnabled;\n+    }\n+\n+    /**\n+     * For each tracer plugged into the SDK a new tracing span is created.\n+     * <p>\n+     * The {@code context} will be checked for containing information about a parent span. If a parent span is found the\n+     * new span will be added as a child, otherwise the span will be created and added to the context and any downstream\n+     * start calls will use the created span as the parent.\n+     *\n+     * @param context Additional metadata that is passed through the call stack.\n+     * @return An updated context object.\n+     */\n+    public Context startSpan(String methodName, String databaseId, String endpoint, Context context) {\n+        Context local = Objects.requireNonNull(context, \"'context' cannot be null.\");\n+        for (Tracer tracer : tracers) {\n+            local = tracer.start(methodName, local); // start the span and return the started span\n+            if (databaseId != null) {\n+                tracer.setAttribute(TracerProvider.DB_INSTANCE, databaseId, local);\n+            }\n+\n+            tracer.setAttribute(AZ_TRACING_NAMESPACE_KEY, RESOURCE_PROVIDER_NAME, local);\n+            tracer.setAttribute(TracerProvider.DB_TYPE, DB_TYPE_VALUE, local);\n+            tracer.setAttribute(TracerProvider.DB_URL, endpoint, local);\n+            tracer.setAttribute(TracerProvider.DB_STATEMENT, methodName, local);\n+        }\n+\n+        return local;\n+    }\n+\n+    /**\n+     * Given a context containing the current tracing span the span is marked completed with status info from\n+     * {@link Signal}.  For each tracer plugged into the SDK the current tracing span is marked as completed.\n+     *\n+     * @param context Additional metadata that is passed through the call stack.\n+     * @param signal  The signal indicates the status and contains the metadata we need to end the tracing span.\n+     */\n+    public <T extends CosmosResponse<? extends Resource>> void endSpan(Context context, Signal<T> signal, int statusCode) {\n+        Objects.requireNonNull(context, \"'context' cannot be null.\");\n+        Objects.requireNonNull(signal, \"'signal' cannot be null.\");\n+\n+        switch (signal.getType()) {\n+            case ON_COMPLETE:\n+                end(statusCode, null, context);\n+                break;\n+            case ON_ERROR:\n+                Throwable throwable = null;\n+                if (signal.hasError()) {\n+                    // The last status available is on error, this contains the thrown error.\n+                    throwable = signal.getThrowable();\n+\n+                    if (throwable instanceof CosmosException) {\n+                        CosmosException exception = (CosmosException) throwable;\n+                        // confirm ?\n+                        statusCode = exception.getStatusCode();\n+                    }\n+                }\n+                end(statusCode, throwable, context);\n+                break;\n+            default:\n+                // ON_SUBSCRIBE and ON_NEXT don't have the information to end the span so just return.\n+                break;\n+        }\n+    }\n+\n+    public <T extends CosmosResponse<?>> Mono<T> traceEnabledCosmosResponsePublisher(Mono<T> resultPublisher,\n+                                                                                                             Context context,\n+                                                                                                             String spanName,\n+                                                                                                             String databaseId,\n+                                                                                                             String endpoint) {\n+        return traceEnabledPublisher(resultPublisher,  context, spanName,databaseId, endpoint,\n+            (T response) -> response.getStatusCode());\n+    }\n+\n+    public <T> Mono<T> traceEnabledNonCosmosResponsePublisher(Mono<T> resultPublisher,\n+                                                              Context context,\n+                                                              String spanName,\n+                                                              String databaseId,\n+                                                              String endpoint) {\n+        return traceEnabledPublisher(resultPublisher,  context, spanName, databaseId, endpoint, (T response) -> HttpConstants.StatusCodes.OK);\n+    }\n+\n+    public <T> Mono<CosmosAsyncItemResponse<T>> traceEnabledCosmosItemResponsePublisher(Mono<CosmosAsyncItemResponse<T>> resultPublisher,\n+                                                                                        Context context,\n+                                                                                        String spanName,\n+                                                                                        String databaseId,\n+                                                                                        String endpoint) {\n+        return traceEnabledPublisher(resultPublisher, context, spanName,databaseId, endpoint,\n+            CosmosAsyncItemResponse::getStatusCode);\n+    }\n+\n+    public <T> Mono<T> traceEnabledPublisher(Mono<T> resultPublisher,\n+                                             Context context,\n+                                             String spanName,\n+                                             String databaseId,\n+                                             String endpoint,\n+                                             Function<T, Integer> statusCodeFunc) {\n+        final AtomicReference<Context> parentContext = new AtomicReference<>(Context.NONE);\n+        Optional<Object> callDepth = context.getData(COSMOS_CALL_DEPTH);\n+        final boolean isNestedCall = callDepth.isPresent();\n+        return resultPublisher\n+            .doOnSubscribe(ignoredValue -> {\n+                if (!isNestedCall) {\n+                    parentContext.set(this.startSpan(spanName, databaseId, endpoint,\n+                        context));\n+                }\n+            }).doOnSuccess(response -> {\n+                if (!isNestedCall) {\n+                    this.endSpan(parentContext.get(), Signal.complete(), statusCodeFunc.apply(response));\n+                }\n+            }).doOnError(throwable -> {\n+                if (!isNestedCall) {\n+                    this.endSpan(parentContext.get(), Signal.error(throwable), 0);", "originalCommit": "e7fe8bb66384a0999cb137e3d0476540cf419c84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk4ODY0NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r438988645", "bodyText": "end span method have the logic of parsing cosmos exception from throwable , and sending status code. If exception is non cosmos then only this 0 will get entertain", "author": "simplynaveen20", "createdAt": "2020-06-11T18:28:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA1MzI1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA2NDI2NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r432064265", "bodyText": "very long line hard to read, it would be great if we break\nin method invocation, either all args should go in one line (if not a long line)\notherwise one arg per line.\nhere and other places. please. this should improve the readibility.", "author": "moderakh", "createdAt": "2020-05-28T19:18:32Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -224,16 +270,32 @@ public String getId() {\n         if (options == null) {\n             options = new CosmosItemRequestOptions();\n         }\n+\n+        if (!database.getClient().getTracerProvider().isEnabled()) {\n+            return createItemInternal(item, options);\n+        }\n+\n+        final CosmosItemRequestOptions requestOptions = options;\n+        return withContext(context -> createItemInternal(item, requestOptions, context));\n+    }\n+\n+    private <T> Mono<CosmosAsyncItemResponse<T>> createItemInternal(T item, CosmosItemRequestOptions options, Context context) {\n+        Mono<CosmosAsyncItemResponse<T>> responseMono = createItemInternal(item, options);\n+        return database.getClient().getTracerProvider().traceEnabledCosmosItemResponsePublisher(responseMono, context", "originalCommit": "e7fe8bb66384a0999cb137e3d0476540cf419c84", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3MDM1Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r432070357", "bodyText": "why don't we have \"readItem\" span name here?", "author": "moderakh", "createdAt": "2020-05-28T19:30:25Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -46,12 +49,42 @@\n     private final CosmosAsyncDatabase database;\n     private final String id;\n     private final String link;\n+    private final String replaceContainerSpanName;\n+    private final String deleteContainerSpanName;\n+    private final String replaceProvisionedThroughputSpanName;\n+    private final String readProvisionedThroughputSpanName;\n+    private final String replaceThroughputSpanName;\n+    private final String readThroughputSpanName;\n+    private final String readContainerSpanName;\n+    private final String upsertItemSpanName;\n+    private final String deleteItemSpanName;\n+    private final String replaceItemSpanName;\n+    private final String createItemSpanName;\n+    private final String readAllItemsSpanName;\n+    private final String queryItemsSpanName;\n+    private final String readAllConflictsSpanName;\n+    private final String queryConflictsSpanName;\n     private CosmosAsyncScripts scripts;\n \n     CosmosAsyncContainer(String id, CosmosAsyncDatabase database) {\n         this.id = id;\n         this.database = database;\n         this.link = getParentLink() + \"/\" + getURIPathSegment() + \"/\" + getId();\n+        this.replaceContainerSpanName = \"replaceContainer.\" + this.id;\n+        this.deleteContainerSpanName = \"deleteContainer.\" + this.id;\n+        this.replaceProvisionedThroughputSpanName = \"replaceProvisionedThroughput.\" + this.id;\n+        this.readProvisionedThroughputSpanName = \"readProvisionedThroughput.\" + this.id;\n+        this.replaceThroughputSpanName = \"replaceThroughput.\" + this.id;\n+        this.readThroughputSpanName = \"readThroughput.\" + this.id;\n+        this.readContainerSpanName = \"readContainer.\" + this.id;\n+        this.upsertItemSpanName = \"upsertItem.\" + this.id;\n+        this.deleteItemSpanName = \"deleteItem.\" + this.id;\n+        this.replaceItemSpanName = \"replaceItem.\" + this.id;\n+        this.createItemSpanName = \"createItem.\" + this.id;\n+        this.readAllItemsSpanName = \"readAllItems.\" + this.id;\n+        this.queryItemsSpanName = \"queryItems.\" + this.id;\n+        this.readAllConflictsSpanName = \"readAllConflicts.\" + this.id;\n+        this.queryConflictsSpanName = \"queryConflicts.\" + this.id;", "originalCommit": "e7fe8bb66384a0999cb137e3d0476540cf419c84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk4Nzg2Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r438987863", "bodyText": "done", "author": "simplynaveen20", "createdAt": "2020-06-11T18:27:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3MDM1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE0MDk4OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r432140989", "bodyText": "CosmosPagedFlux allows both paginated iteration and also item by item iteration.\nI see that we covered the pageByPage iteration through adding CosmosPagedFlux#byPage(.) what about the item by item iteration shoudldn't we cover that as well?", "author": "moderakh", "createdAt": "2020-05-28T21:43:06Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/util/CosmosPagedFlux.java", "diffHunk": "@@ -84,4 +103,18 @@ public void subscribe(CoreSubscriber<? super T> coreSubscriber) {\n             return Flux.fromIterable(elements);\n         }).subscribe(coreSubscriber);\n     }\n+\n+    private Flux<FeedResponse<T>> byPage(CosmosPagedFluxOptions pagedFluxOptions, Context context) {", "originalCommit": "e7fe8bb66384a0999cb137e3d0476540cf419c84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE3NzY2Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r432177666", "bodyText": "discussed offline.", "author": "moderakh", "createdAt": "2020-05-28T23:26:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE0MDk4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE1NTQ3OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r432155478", "bodyText": "readContainerSpanName -> readItemSpanName. Please check other ones too.", "author": "moderakh", "createdAt": "2020-05-28T22:18:35Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -768,4 +782,244 @@ String getParentLink() {\n     String getLink() {\n         return this.link;\n     }\n+\n+    private Mono<CosmosAsyncItemResponse<Object>> deleteItemInternal(\n+        String itemId,\n+        RequestOptions requestOptions,\n+        Context context) {\n+        Mono<CosmosAsyncItemResponse<Object>> responseMono = deleteItemInternal(itemId, requestOptions);\n+        return database.getClient().getTracerProvider().traceEnabledCosmosItemResponsePublisher(responseMono,\n+            context, this.deleteItemSpanName, database.getId(), database.getClient().getServiceEndpoint());\n+    }\n+\n+    private Mono<CosmosAsyncItemResponse<Object>> deleteItemInternal(\n+        String itemId,\n+        RequestOptions requestOptions) {\n+        return this.getDatabase()\n+            .getDocClientWrapper()\n+            .deleteDocument(getItemLink(itemId), requestOptions)\n+            .map(response -> ModelBridgeInternal.createCosmosAsyncItemResponseWithObjectType(response))\n+            .single();\n+    }\n+\n+    private <T> Mono<CosmosAsyncItemResponse<T>> replaceItemInternal(\n+        Class<T> itemType,\n+        String itemId,\n+        Document doc,\n+        CosmosItemRequestOptions options,\n+        Context context) {\n+        Mono<CosmosAsyncItemResponse<T>> responseMono = replaceItemInternal(itemType, itemId, doc, options);\n+        return database.getClient().getTracerProvider().traceEnabledCosmosItemResponsePublisher(responseMono,\n+            context, this.replaceItemSpanName, database.getId(), database.getClient().getServiceEndpoint());\n+    }\n+\n+    private <T> Mono<CosmosAsyncItemResponse<T>> replaceItemInternal(\n+        Class<T> itemType,\n+        String itemId,\n+        Document doc,\n+        CosmosItemRequestOptions options) {\n+       return this.getDatabase()\n+            .getDocClientWrapper()\n+            .replaceDocument(getItemLink(itemId), doc, ModelBridgeInternal.toRequestOptions(options))\n+            .map(response -> ModelBridgeInternal.createCosmosAsyncItemResponse(response, itemType))\n+            .single();\n+    }\n+\n+    private <T> Mono<CosmosAsyncItemResponse<T>> upsertItemInternal(T item, CosmosItemRequestOptions options, Context context) {\n+        Mono<CosmosAsyncItemResponse<T>> responseMono = upsertItemInternal(item, options);\n+        return database.getClient().getTracerProvider().traceEnabledCosmosItemResponsePublisher(responseMono,\n+            context, this.upsertItemSpanName, database.getId(), database.getClient().getServiceEndpoint());\n+    }\n+\n+    private <T> Mono<CosmosAsyncItemResponse<T>> upsertItemInternal(T item, CosmosItemRequestOptions options) {\n+        @SuppressWarnings(\"unchecked\")\n+        Class<T> itemType = (Class<T>) item.getClass();\n+        return this.getDatabase().getDocClientWrapper()\n+            .upsertDocument(this.getLink(), item,\n+                ModelBridgeInternal.toRequestOptions(options),\n+                true)\n+            .map(response -> ModelBridgeInternal.createCosmosAsyncItemResponse(response, itemType))\n+            .single();\n+    }\n+\n+    private <T> Mono<CosmosAsyncItemResponse<T>> readItemInternal(\n+        String itemId, PartitionKey partitionKey,\n+        RequestOptions requestOptions, Class<T> itemType,\n+        Context context) {\n+        Mono<CosmosAsyncItemResponse<T>> responseMono = readItemInternal(itemId, partitionKey, requestOptions, itemType);\n+        return database.getClient().getTracerProvider().traceEnabledCosmosItemResponsePublisher(responseMono,\n+            context, this.readContainerSpanName, database.getId(), database.getClient().getServiceEndpoint());", "originalCommit": "e7fe8bb66384a0999cb137e3d0476540cf419c84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk4Nzc5Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r438987793", "bodyText": "done", "author": "simplynaveen20", "createdAt": "2020-06-11T18:26:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE1NTQ3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE1NTU5OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r432155598", "bodyText": "bug: partitionKey is not passed here.", "author": "moderakh", "createdAt": "2020-05-28T22:18:52Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -768,4 +782,244 @@ String getParentLink() {\n     String getLink() {\n         return this.link;\n     }\n+\n+    private Mono<CosmosAsyncItemResponse<Object>> deleteItemInternal(\n+        String itemId,\n+        RequestOptions requestOptions,\n+        Context context) {\n+        Mono<CosmosAsyncItemResponse<Object>> responseMono = deleteItemInternal(itemId, requestOptions);\n+        return database.getClient().getTracerProvider().traceEnabledCosmosItemResponsePublisher(responseMono,\n+            context, this.deleteItemSpanName, database.getId(), database.getClient().getServiceEndpoint());\n+    }\n+\n+    private Mono<CosmosAsyncItemResponse<Object>> deleteItemInternal(\n+        String itemId,\n+        RequestOptions requestOptions) {\n+        return this.getDatabase()\n+            .getDocClientWrapper()\n+            .deleteDocument(getItemLink(itemId), requestOptions)\n+            .map(response -> ModelBridgeInternal.createCosmosAsyncItemResponseWithObjectType(response))\n+            .single();\n+    }\n+\n+    private <T> Mono<CosmosAsyncItemResponse<T>> replaceItemInternal(\n+        Class<T> itemType,\n+        String itemId,\n+        Document doc,\n+        CosmosItemRequestOptions options,\n+        Context context) {\n+        Mono<CosmosAsyncItemResponse<T>> responseMono = replaceItemInternal(itemType, itemId, doc, options);\n+        return database.getClient().getTracerProvider().traceEnabledCosmosItemResponsePublisher(responseMono,\n+            context, this.replaceItemSpanName, database.getId(), database.getClient().getServiceEndpoint());\n+    }\n+\n+    private <T> Mono<CosmosAsyncItemResponse<T>> replaceItemInternal(\n+        Class<T> itemType,\n+        String itemId,\n+        Document doc,\n+        CosmosItemRequestOptions options) {\n+       return this.getDatabase()\n+            .getDocClientWrapper()\n+            .replaceDocument(getItemLink(itemId), doc, ModelBridgeInternal.toRequestOptions(options))\n+            .map(response -> ModelBridgeInternal.createCosmosAsyncItemResponse(response, itemType))\n+            .single();\n+    }\n+\n+    private <T> Mono<CosmosAsyncItemResponse<T>> upsertItemInternal(T item, CosmosItemRequestOptions options, Context context) {\n+        Mono<CosmosAsyncItemResponse<T>> responseMono = upsertItemInternal(item, options);\n+        return database.getClient().getTracerProvider().traceEnabledCosmosItemResponsePublisher(responseMono,\n+            context, this.upsertItemSpanName, database.getId(), database.getClient().getServiceEndpoint());\n+    }\n+\n+    private <T> Mono<CosmosAsyncItemResponse<T>> upsertItemInternal(T item, CosmosItemRequestOptions options) {\n+        @SuppressWarnings(\"unchecked\")\n+        Class<T> itemType = (Class<T>) item.getClass();\n+        return this.getDatabase().getDocClientWrapper()\n+            .upsertDocument(this.getLink(), item,\n+                ModelBridgeInternal.toRequestOptions(options),\n+                true)\n+            .map(response -> ModelBridgeInternal.createCosmosAsyncItemResponse(response, itemType))\n+            .single();\n+    }\n+\n+    private <T> Mono<CosmosAsyncItemResponse<T>> readItemInternal(\n+        String itemId, PartitionKey partitionKey,\n+        RequestOptions requestOptions, Class<T> itemType,\n+        Context context) {\n+        Mono<CosmosAsyncItemResponse<T>> responseMono = readItemInternal(itemId, partitionKey, requestOptions, itemType);\n+        return database.getClient().getTracerProvider().traceEnabledCosmosItemResponsePublisher(responseMono,\n+            context, this.readContainerSpanName, database.getId(), database.getClient().getServiceEndpoint());\n+    }\n+\n+    private <T> Mono<CosmosAsyncItemResponse<T>> readItemInternal(\n+        String itemId, PartitionKey partitionKey,\n+        RequestOptions requestOptions, Class<T> itemType) {\n+        return this.getDatabase().getDocClientWrapper()\n+            .readDocument(getItemLink(itemId), requestOptions)\n+            .map(response -> ModelBridgeInternal.createCosmosAsyncItemResponse(response, itemType))", "originalCommit": "e7fe8bb66384a0999cb137e3d0476540cf419c84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk4NzczNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r438987734", "bodyText": "done", "author": "simplynaveen20", "createdAt": "2020-06-11T18:26:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE1NTU5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ3OTkxMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r433479912", "bodyText": "These are not required as com.azure.core module already requires them transitively.", "author": "srnagar", "createdAt": "2020-06-01T20:45:56Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/module-info.java", "diffHunk": "@@ -24,13 +24,18 @@\n     requires micrometer.core;\n     //  This is only required by guava shaded libraries\n     requires java.logging;\n+    requires reactor.core;\n+    requires org.reactivestreams;\n+    requires com.fasterxml.jackson.databind;\n+    requires org.slf4j;", "originalCommit": "e7fe8bb66384a0999cb137e3d0476540cf419c84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk4NzU0MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r438987541", "bodyText": "done", "author": "simplynaveen20", "createdAt": "2020-06-11T18:26:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ3OTkxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ5MjQ3NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r433492474", "bodyText": "Seeing this is used frequently throughout the class, can this be extracted to somewhere common?", "author": "samvaity", "createdAt": "2020-06-01T21:10:50Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncContainer.java", "diffHunk": "@@ -164,9 +207,13 @@ public String getId() {\n         if (options == null) {\n             options = new CosmosContainerRequestOptions();\n         }\n-        return database.getDocClientWrapper()\n-                   .replaceCollection(ModelBridgeInternal.getV2Collection(containerProperties), ModelBridgeInternal.toRequestOptions(options))\n-                   .map(response -> ModelBridgeInternal.createCosmosAsyncContainerResponse(response, database)).single();\n+\n+        if(!database.getClient().getTracerProvider().isEnabled()) {", "originalCommit": "e7fe8bb66384a0999cb137e3d0476540cf419c84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk4NzQ3MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r438987471", "bodyText": "Eventually this check will go away when we will go via withContext all the time.", "author": "simplynaveen20", "createdAt": "2020-06-11T18:26:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ5MjQ3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ5NTU2OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r433495569", "bodyText": "The span name should match the method name which is read here", "author": "samvaity", "createdAt": "2020-06-01T21:17:31Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/CosmosAsyncUserDefinedFunction.java", "diffHunk": "@@ -115,4 +121,45 @@ String getLink() {\n         builder.append(getId());\n         return builder.toString();\n     }\n+\n+    private Mono<CosmosAsyncUserDefinedFunctionResponse> readInternal(Context context) {\n+        String spanName = \"readUDF.\" + container.getId();", "originalCommit": "e7fe8bb66384a0999cb137e3d0476540cf419c84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ5NTk0Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r433495947", "bodyText": "Same for methods replace and delete below.", "author": "samvaity", "createdAt": "2020-06-01T21:18:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ5NTU2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk4Njk1OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r438986958", "bodyText": "Discussed offline , we need resource name on read/delete/replace as we have hierarchy model and all the resource have same api name for these operation, so we need to differentiate them", "author": "simplynaveen20", "createdAt": "2020-06-11T18:25:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ5NTU2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ5NzEzNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r433497137", "bodyText": "We don't need to support multiple tracer implementation.\nRefer here - https://github.com/Azure/azure-sdk-for-java/blob/master/sdk/core/azure-core-amqp/src/main/java/com/azure/core/amqp/implementation/TracerProvider.java#L40", "author": "samvaity", "createdAt": "2020-06-01T21:21:00Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -0,0 +1,175 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation;\n+\n+import com.azure.core.util.Context;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.cosmos.CosmosException;\n+import com.azure.cosmos.models.CosmosAsyncItemResponse;\n+import com.azure.cosmos.models.CosmosResponse;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Signal;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+import static com.azure.core.util.tracing.Tracer.AZ_TRACING_NAMESPACE_KEY;\n+\n+public class TracerProvider {\n+    private final List<Tracer> tracers = new ArrayList<>();\n+    private final boolean isEnabled;\n+    public final static String DB_TYPE_VALUE = \"Cosmos\";\n+    public final static String DB_TYPE = \"db.type\";\n+    public final static String DB_INSTANCE = \"db.instance\";\n+    public final static String DB_URL = \"db.url\";\n+    public static final String DB_STATEMENT = \"db.statement\";\n+    public static final String ERROR_MSG = \"error.msg\";\n+    public static final String ERROR_TYPE = \"error.type\";\n+    public static final String ERROR_STACK = \"error.stack\";\n+    public static final String COSMOS_CALL_DEPTH = \"cosmosCallDepth\";\n+    public static final String COSMOS_CALL_DEPTH_VAL = \"nested\";\n+    public static final String RESOURCE_PROVIDER_NAME = \"Microsoft.DocumentDB\";\n+\n+    public TracerProvider(Iterable<Tracer> tracers) {\n+        Objects.requireNonNull(tracers, \"'tracers' cannot be null.\");\n+        tracers.forEach(this.tracers::add);\n+        isEnabled = this.tracers.size() > 0;\n+    }\n+\n+    public boolean isEnabled() {\n+        return isEnabled;\n+    }\n+\n+    /**\n+     * For each tracer plugged into the SDK a new tracing span is created.\n+     * <p>\n+     * The {@code context} will be checked for containing information about a parent span. If a parent span is found the\n+     * new span will be added as a child, otherwise the span will be created and added to the context and any downstream\n+     * start calls will use the created span as the parent.\n+     *\n+     * @param context Additional metadata that is passed through the call stack.\n+     * @return An updated context object.\n+     */\n+    public Context startSpan(String methodName, String databaseId, String endpoint, Context context) {\n+        Context local = Objects.requireNonNull(context, \"'context' cannot be null.\");\n+        for (Tracer tracer : tracers) {", "originalCommit": "e7fe8bb66384a0999cb137e3d0476540cf419c84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk4NjIyNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r438986227", "bodyText": "done", "author": "simplynaveen20", "createdAt": "2020-06-11T18:23:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ5NzEzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ5ODA0Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r433498043", "bodyText": "AZ_TRACING_NAMESPACE_KEY needs to be passed using the context as the tracer expects it in the context here and aligns with other SDK behavior.", "author": "samvaity", "createdAt": "2020-06-01T21:23:05Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -0,0 +1,175 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation;\n+\n+import com.azure.core.util.Context;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.cosmos.CosmosException;\n+import com.azure.cosmos.models.CosmosAsyncItemResponse;\n+import com.azure.cosmos.models.CosmosResponse;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Signal;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+import static com.azure.core.util.tracing.Tracer.AZ_TRACING_NAMESPACE_KEY;\n+\n+public class TracerProvider {\n+    private final List<Tracer> tracers = new ArrayList<>();\n+    private final boolean isEnabled;\n+    public final static String DB_TYPE_VALUE = \"Cosmos\";\n+    public final static String DB_TYPE = \"db.type\";\n+    public final static String DB_INSTANCE = \"db.instance\";\n+    public final static String DB_URL = \"db.url\";\n+    public static final String DB_STATEMENT = \"db.statement\";\n+    public static final String ERROR_MSG = \"error.msg\";\n+    public static final String ERROR_TYPE = \"error.type\";\n+    public static final String ERROR_STACK = \"error.stack\";\n+    public static final String COSMOS_CALL_DEPTH = \"cosmosCallDepth\";\n+    public static final String COSMOS_CALL_DEPTH_VAL = \"nested\";\n+    public static final String RESOURCE_PROVIDER_NAME = \"Microsoft.DocumentDB\";\n+\n+    public TracerProvider(Iterable<Tracer> tracers) {\n+        Objects.requireNonNull(tracers, \"'tracers' cannot be null.\");\n+        tracers.forEach(this.tracers::add);\n+        isEnabled = this.tracers.size() > 0;\n+    }\n+\n+    public boolean isEnabled() {\n+        return isEnabled;\n+    }\n+\n+    /**\n+     * For each tracer plugged into the SDK a new tracing span is created.\n+     * <p>\n+     * The {@code context} will be checked for containing information about a parent span. If a parent span is found the\n+     * new span will be added as a child, otherwise the span will be created and added to the context and any downstream\n+     * start calls will use the created span as the parent.\n+     *\n+     * @param context Additional metadata that is passed through the call stack.\n+     * @return An updated context object.\n+     */\n+    public Context startSpan(String methodName, String databaseId, String endpoint, Context context) {\n+        Context local = Objects.requireNonNull(context, \"'context' cannot be null.\");\n+        for (Tracer tracer : tracers) {\n+            local = tracer.start(methodName, local); // start the span and return the started span\n+            if (databaseId != null) {\n+                tracer.setAttribute(TracerProvider.DB_INSTANCE, databaseId, local);\n+            }\n+\n+            tracer.setAttribute(AZ_TRACING_NAMESPACE_KEY, RESOURCE_PROVIDER_NAME, local);", "originalCommit": "e7fe8bb66384a0999cb137e3d0476540cf419c84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk4NjEyOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r438986129", "bodyText": "removed setting AZ_TRACING_NAMESPACE_KEY explicitly on tracer", "author": "simplynaveen20", "createdAt": "2020-06-11T18:23:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ5ODA0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTEyNTM5OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r439125399", "bodyText": "As discussed keeping it the same i.e. AZ_TRACING_NAMESPACE_KEY on attributes, user will get extra warning log if he don't pass this. Will revisit it again in next tracing PR", "author": "simplynaveen20", "createdAt": "2020-06-11T23:32:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ5ODA0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ5ODQxMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r433498410", "bodyText": "remove this comment?", "author": "samvaity", "createdAt": "2020-06-01T21:23:48Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -0,0 +1,175 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation;\n+\n+import com.azure.core.util.Context;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.cosmos.CosmosException;\n+import com.azure.cosmos.models.CosmosAsyncItemResponse;\n+import com.azure.cosmos.models.CosmosResponse;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Signal;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+import static com.azure.core.util.tracing.Tracer.AZ_TRACING_NAMESPACE_KEY;\n+\n+public class TracerProvider {\n+    private final List<Tracer> tracers = new ArrayList<>();\n+    private final boolean isEnabled;\n+    public final static String DB_TYPE_VALUE = \"Cosmos\";\n+    public final static String DB_TYPE = \"db.type\";\n+    public final static String DB_INSTANCE = \"db.instance\";\n+    public final static String DB_URL = \"db.url\";\n+    public static final String DB_STATEMENT = \"db.statement\";\n+    public static final String ERROR_MSG = \"error.msg\";\n+    public static final String ERROR_TYPE = \"error.type\";\n+    public static final String ERROR_STACK = \"error.stack\";\n+    public static final String COSMOS_CALL_DEPTH = \"cosmosCallDepth\";\n+    public static final String COSMOS_CALL_DEPTH_VAL = \"nested\";\n+    public static final String RESOURCE_PROVIDER_NAME = \"Microsoft.DocumentDB\";\n+\n+    public TracerProvider(Iterable<Tracer> tracers) {\n+        Objects.requireNonNull(tracers, \"'tracers' cannot be null.\");\n+        tracers.forEach(this.tracers::add);\n+        isEnabled = this.tracers.size() > 0;\n+    }\n+\n+    public boolean isEnabled() {\n+        return isEnabled;\n+    }\n+\n+    /**\n+     * For each tracer plugged into the SDK a new tracing span is created.\n+     * <p>\n+     * The {@code context} will be checked for containing information about a parent span. If a parent span is found the\n+     * new span will be added as a child, otherwise the span will be created and added to the context and any downstream\n+     * start calls will use the created span as the parent.\n+     *\n+     * @param context Additional metadata that is passed through the call stack.\n+     * @return An updated context object.\n+     */\n+    public Context startSpan(String methodName, String databaseId, String endpoint, Context context) {\n+        Context local = Objects.requireNonNull(context, \"'context' cannot be null.\");\n+        for (Tracer tracer : tracers) {\n+            local = tracer.start(methodName, local); // start the span and return the started span\n+            if (databaseId != null) {\n+                tracer.setAttribute(TracerProvider.DB_INSTANCE, databaseId, local);\n+            }\n+\n+            tracer.setAttribute(AZ_TRACING_NAMESPACE_KEY, RESOURCE_PROVIDER_NAME, local);\n+            tracer.setAttribute(TracerProvider.DB_TYPE, DB_TYPE_VALUE, local);\n+            tracer.setAttribute(TracerProvider.DB_URL, endpoint, local);\n+            tracer.setAttribute(TracerProvider.DB_STATEMENT, methodName, local);\n+        }\n+\n+        return local;\n+    }\n+\n+    /**\n+     * Given a context containing the current tracing span the span is marked completed with status info from\n+     * {@link Signal}.  For each tracer plugged into the SDK the current tracing span is marked as completed.\n+     *\n+     * @param context Additional metadata that is passed through the call stack.\n+     * @param signal  The signal indicates the status and contains the metadata we need to end the tracing span.\n+     */\n+    public <T extends CosmosResponse<? extends Resource>> void endSpan(Context context, Signal<T> signal, int statusCode) {\n+        Objects.requireNonNull(context, \"'context' cannot be null.\");\n+        Objects.requireNonNull(signal, \"'signal' cannot be null.\");\n+\n+        switch (signal.getType()) {\n+            case ON_COMPLETE:\n+                end(statusCode, null, context);\n+                break;\n+            case ON_ERROR:\n+                Throwable throwable = null;\n+                if (signal.hasError()) {\n+                    // The last status available is on error, this contains the thrown error.\n+                    throwable = signal.getThrowable();\n+\n+                    if (throwable instanceof CosmosException) {\n+                        CosmosException exception = (CosmosException) throwable;\n+                        // confirm ?", "originalCommit": "e7fe8bb66384a0999cb137e3d0476540cf419c84", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ5OTU3OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r433499578", "bodyText": "Why are we always sending a 200 OK status here?", "author": "samvaity", "createdAt": "2020-06-01T21:26:23Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -0,0 +1,175 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation;\n+\n+import com.azure.core.util.Context;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.cosmos.CosmosException;\n+import com.azure.cosmos.models.CosmosAsyncItemResponse;\n+import com.azure.cosmos.models.CosmosResponse;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Signal;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+import static com.azure.core.util.tracing.Tracer.AZ_TRACING_NAMESPACE_KEY;\n+\n+public class TracerProvider {\n+    private final List<Tracer> tracers = new ArrayList<>();\n+    private final boolean isEnabled;\n+    public final static String DB_TYPE_VALUE = \"Cosmos\";\n+    public final static String DB_TYPE = \"db.type\";\n+    public final static String DB_INSTANCE = \"db.instance\";\n+    public final static String DB_URL = \"db.url\";\n+    public static final String DB_STATEMENT = \"db.statement\";\n+    public static final String ERROR_MSG = \"error.msg\";\n+    public static final String ERROR_TYPE = \"error.type\";\n+    public static final String ERROR_STACK = \"error.stack\";\n+    public static final String COSMOS_CALL_DEPTH = \"cosmosCallDepth\";\n+    public static final String COSMOS_CALL_DEPTH_VAL = \"nested\";\n+    public static final String RESOURCE_PROVIDER_NAME = \"Microsoft.DocumentDB\";\n+\n+    public TracerProvider(Iterable<Tracer> tracers) {\n+        Objects.requireNonNull(tracers, \"'tracers' cannot be null.\");\n+        tracers.forEach(this.tracers::add);\n+        isEnabled = this.tracers.size() > 0;\n+    }\n+\n+    public boolean isEnabled() {\n+        return isEnabled;\n+    }\n+\n+    /**\n+     * For each tracer plugged into the SDK a new tracing span is created.\n+     * <p>\n+     * The {@code context} will be checked for containing information about a parent span. If a parent span is found the\n+     * new span will be added as a child, otherwise the span will be created and added to the context and any downstream\n+     * start calls will use the created span as the parent.\n+     *\n+     * @param context Additional metadata that is passed through the call stack.\n+     * @return An updated context object.\n+     */\n+    public Context startSpan(String methodName, String databaseId, String endpoint, Context context) {\n+        Context local = Objects.requireNonNull(context, \"'context' cannot be null.\");\n+        for (Tracer tracer : tracers) {\n+            local = tracer.start(methodName, local); // start the span and return the started span\n+            if (databaseId != null) {\n+                tracer.setAttribute(TracerProvider.DB_INSTANCE, databaseId, local);\n+            }\n+\n+            tracer.setAttribute(AZ_TRACING_NAMESPACE_KEY, RESOURCE_PROVIDER_NAME, local);\n+            tracer.setAttribute(TracerProvider.DB_TYPE, DB_TYPE_VALUE, local);\n+            tracer.setAttribute(TracerProvider.DB_URL, endpoint, local);\n+            tracer.setAttribute(TracerProvider.DB_STATEMENT, methodName, local);\n+        }\n+\n+        return local;\n+    }\n+\n+    /**\n+     * Given a context containing the current tracing span the span is marked completed with status info from\n+     * {@link Signal}.  For each tracer plugged into the SDK the current tracing span is marked as completed.\n+     *\n+     * @param context Additional metadata that is passed through the call stack.\n+     * @param signal  The signal indicates the status and contains the metadata we need to end the tracing span.\n+     */\n+    public <T extends CosmosResponse<? extends Resource>> void endSpan(Context context, Signal<T> signal, int statusCode) {\n+        Objects.requireNonNull(context, \"'context' cannot be null.\");\n+        Objects.requireNonNull(signal, \"'signal' cannot be null.\");\n+\n+        switch (signal.getType()) {\n+            case ON_COMPLETE:\n+                end(statusCode, null, context);\n+                break;\n+            case ON_ERROR:\n+                Throwable throwable = null;\n+                if (signal.hasError()) {\n+                    // The last status available is on error, this contains the thrown error.\n+                    throwable = signal.getThrowable();\n+\n+                    if (throwable instanceof CosmosException) {\n+                        CosmosException exception = (CosmosException) throwable;\n+                        // confirm ?\n+                        statusCode = exception.getStatusCode();\n+                    }\n+                }\n+                end(statusCode, throwable, context);\n+                break;\n+            default:\n+                // ON_SUBSCRIBE and ON_NEXT don't have the information to end the span so just return.\n+                break;\n+        }\n+    }\n+\n+    public <T extends CosmosResponse<?>> Mono<T> traceEnabledCosmosResponsePublisher(Mono<T> resultPublisher,\n+                                                                                                             Context context,\n+                                                                                                             String spanName,\n+                                                                                                             String databaseId,\n+                                                                                                             String endpoint) {\n+        return traceEnabledPublisher(resultPublisher,  context, spanName,databaseId, endpoint,\n+            (T response) -> response.getStatusCode());\n+    }\n+\n+    public <T> Mono<T> traceEnabledNonCosmosResponsePublisher(Mono<T> resultPublisher,\n+                                                              Context context,\n+                                                              String spanName,\n+                                                              String databaseId,\n+                                                              String endpoint) {\n+        return traceEnabledPublisher(resultPublisher,  context, spanName, databaseId, endpoint, (T response) -> HttpConstants.StatusCodes.OK);", "originalCommit": "e7fe8bb66384a0999cb137e3d0476540cf419c84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTEyNTYzMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r439125633", "bodyText": "Initially we had non cosmosResponse api returning Mono, now we removed those api , so removing this method altogether", "author": "simplynaveen20", "createdAt": "2020-06-11T23:32:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ5OTU3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUwMjU1NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r433502554", "bodyText": "do we think this is a good idea?\nespecially since Throwable.printStackTrace() isn't thread-safe and could give out confusing logs/statements?\ncc: @srnagar", "author": "samvaity", "createdAt": "2020-06-01T21:33:26Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/implementation/TracerProvider.java", "diffHunk": "@@ -0,0 +1,175 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos.implementation;\n+\n+import com.azure.core.util.Context;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.cosmos.CosmosException;\n+import com.azure.cosmos.models.CosmosAsyncItemResponse;\n+import com.azure.cosmos.models.CosmosResponse;\n+import reactor.core.publisher.Mono;\n+import reactor.core.publisher.Signal;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+\n+import static com.azure.core.util.tracing.Tracer.AZ_TRACING_NAMESPACE_KEY;\n+\n+public class TracerProvider {\n+    private final List<Tracer> tracers = new ArrayList<>();\n+    private final boolean isEnabled;\n+    public final static String DB_TYPE_VALUE = \"Cosmos\";\n+    public final static String DB_TYPE = \"db.type\";\n+    public final static String DB_INSTANCE = \"db.instance\";\n+    public final static String DB_URL = \"db.url\";\n+    public static final String DB_STATEMENT = \"db.statement\";\n+    public static final String ERROR_MSG = \"error.msg\";\n+    public static final String ERROR_TYPE = \"error.type\";\n+    public static final String ERROR_STACK = \"error.stack\";\n+    public static final String COSMOS_CALL_DEPTH = \"cosmosCallDepth\";\n+    public static final String COSMOS_CALL_DEPTH_VAL = \"nested\";\n+    public static final String RESOURCE_PROVIDER_NAME = \"Microsoft.DocumentDB\";\n+\n+    public TracerProvider(Iterable<Tracer> tracers) {\n+        Objects.requireNonNull(tracers, \"'tracers' cannot be null.\");\n+        tracers.forEach(this.tracers::add);\n+        isEnabled = this.tracers.size() > 0;\n+    }\n+\n+    public boolean isEnabled() {\n+        return isEnabled;\n+    }\n+\n+    /**\n+     * For each tracer plugged into the SDK a new tracing span is created.\n+     * <p>\n+     * The {@code context} will be checked for containing information about a parent span. If a parent span is found the\n+     * new span will be added as a child, otherwise the span will be created and added to the context and any downstream\n+     * start calls will use the created span as the parent.\n+     *\n+     * @param context Additional metadata that is passed through the call stack.\n+     * @return An updated context object.\n+     */\n+    public Context startSpan(String methodName, String databaseId, String endpoint, Context context) {\n+        Context local = Objects.requireNonNull(context, \"'context' cannot be null.\");\n+        for (Tracer tracer : tracers) {\n+            local = tracer.start(methodName, local); // start the span and return the started span\n+            if (databaseId != null) {\n+                tracer.setAttribute(TracerProvider.DB_INSTANCE, databaseId, local);\n+            }\n+\n+            tracer.setAttribute(AZ_TRACING_NAMESPACE_KEY, RESOURCE_PROVIDER_NAME, local);\n+            tracer.setAttribute(TracerProvider.DB_TYPE, DB_TYPE_VALUE, local);\n+            tracer.setAttribute(TracerProvider.DB_URL, endpoint, local);\n+            tracer.setAttribute(TracerProvider.DB_STATEMENT, methodName, local);\n+        }\n+\n+        return local;\n+    }\n+\n+    /**\n+     * Given a context containing the current tracing span the span is marked completed with status info from\n+     * {@link Signal}.  For each tracer plugged into the SDK the current tracing span is marked as completed.\n+     *\n+     * @param context Additional metadata that is passed through the call stack.\n+     * @param signal  The signal indicates the status and contains the metadata we need to end the tracing span.\n+     */\n+    public <T extends CosmosResponse<? extends Resource>> void endSpan(Context context, Signal<T> signal, int statusCode) {\n+        Objects.requireNonNull(context, \"'context' cannot be null.\");\n+        Objects.requireNonNull(signal, \"'signal' cannot be null.\");\n+\n+        switch (signal.getType()) {\n+            case ON_COMPLETE:\n+                end(statusCode, null, context);\n+                break;\n+            case ON_ERROR:\n+                Throwable throwable = null;\n+                if (signal.hasError()) {\n+                    // The last status available is on error, this contains the thrown error.\n+                    throwable = signal.getThrowable();\n+\n+                    if (throwable instanceof CosmosException) {\n+                        CosmosException exception = (CosmosException) throwable;\n+                        // confirm ?\n+                        statusCode = exception.getStatusCode();\n+                    }\n+                }\n+                end(statusCode, throwable, context);\n+                break;\n+            default:\n+                // ON_SUBSCRIBE and ON_NEXT don't have the information to end the span so just return.\n+                break;\n+        }\n+    }\n+\n+    public <T extends CosmosResponse<?>> Mono<T> traceEnabledCosmosResponsePublisher(Mono<T> resultPublisher,\n+                                                                                                             Context context,\n+                                                                                                             String spanName,\n+                                                                                                             String databaseId,\n+                                                                                                             String endpoint) {\n+        return traceEnabledPublisher(resultPublisher,  context, spanName,databaseId, endpoint,\n+            (T response) -> response.getStatusCode());\n+    }\n+\n+    public <T> Mono<T> traceEnabledNonCosmosResponsePublisher(Mono<T> resultPublisher,\n+                                                              Context context,\n+                                                              String spanName,\n+                                                              String databaseId,\n+                                                              String endpoint) {\n+        return traceEnabledPublisher(resultPublisher,  context, spanName, databaseId, endpoint, (T response) -> HttpConstants.StatusCodes.OK);\n+    }\n+\n+    public <T> Mono<CosmosAsyncItemResponse<T>> traceEnabledCosmosItemResponsePublisher(Mono<CosmosAsyncItemResponse<T>> resultPublisher,\n+                                                                                        Context context,\n+                                                                                        String spanName,\n+                                                                                        String databaseId,\n+                                                                                        String endpoint) {\n+        return traceEnabledPublisher(resultPublisher, context, spanName,databaseId, endpoint,\n+            CosmosAsyncItemResponse::getStatusCode);\n+    }\n+\n+    public <T> Mono<T> traceEnabledPublisher(Mono<T> resultPublisher,\n+                                             Context context,\n+                                             String spanName,\n+                                             String databaseId,\n+                                             String endpoint,\n+                                             Function<T, Integer> statusCodeFunc) {\n+        final AtomicReference<Context> parentContext = new AtomicReference<>(Context.NONE);\n+        Optional<Object> callDepth = context.getData(COSMOS_CALL_DEPTH);\n+        final boolean isNestedCall = callDepth.isPresent();\n+        return resultPublisher\n+            .doOnSubscribe(ignoredValue -> {\n+                if (!isNestedCall) {\n+                    parentContext.set(this.startSpan(spanName, databaseId, endpoint,\n+                        context));\n+                }\n+            }).doOnSuccess(response -> {\n+                if (!isNestedCall) {\n+                    this.endSpan(parentContext.get(), Signal.complete(), statusCodeFunc.apply(response));\n+                }\n+            }).doOnError(throwable -> {\n+                if (!isNestedCall) {\n+                    this.endSpan(parentContext.get(), Signal.error(throwable), 0);\n+                }\n+            });\n+    }\n+\n+    private void end(int statusCode, Throwable throwable, Context context) {\n+        for (Tracer tracer : tracers) {\n+            if (throwable != null) {\n+                tracer.setAttribute(TracerProvider.ERROR_MSG, throwable.getMessage(), context);\n+                tracer.setAttribute(TracerProvider.ERROR_TYPE, throwable.getClass().getName(), context);\n+                StringWriter errorStack = new StringWriter();\n+                throwable.printStackTrace(new PrintWriter(errorStack));", "originalCommit": "e7fe8bb66384a0999cb137e3d0476540cf419c84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU3NzA0Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r433577043", "bodyText": "I don't think we should have the entire stacktrace in tracing. It's important to capture that there was an error but the stracktrace is likely not that useful. Stacktrace should be available in logs, if that's necessary. It's also a security issue to capture stacktrace since the user cannot control or turn it off.", "author": "srnagar", "createdAt": "2020-06-02T01:45:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUwMjU1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTEyNTczMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r439125731", "bodyText": "Removed the error stacktrace", "author": "simplynaveen20", "createdAt": "2020-06-11T23:33:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUwMjU1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUwMjY3OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r433502678", "bodyText": "isTracerEnable --> isTracerEnabled", "author": "samvaity", "createdAt": "2020-06-01T21:33:47Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/util/CosmosPagedFlux.java", "diffHunk": "@@ -29,41 +34,55 @@\n public final class CosmosPagedFlux<T> extends ContinuablePagedFlux<String, T, FeedResponse<T>> {\n \n     private final Function<CosmosPagedFluxOptions, Flux<FeedResponse<T>>> optionsFluxFunction;\n+    private final boolean isTracerEnable;", "originalCommit": "e7fe8bb66384a0999cb137e3d0476540cf419c84", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUwMzY2Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r433503663", "bodyText": "isTraceeEnable --> isTracerEnabled", "author": "samvaity", "createdAt": "2020-06-01T21:36:11Z", "path": "sdk/cosmos/azure-cosmos/src/main/java/com/azure/cosmos/util/UtilBridgeInternal.java", "diffHunk": "@@ -24,10 +24,11 @@\n     private UtilBridgeInternal() {}\n \n     @Warning(value = INTERNAL_USE_ONLY_WARNING)\n-    public static <T> CosmosPagedFlux<T> createCosmosPagedFlux(Function<CosmosPagedFluxOptions, Flux<FeedResponse<T>>> pagedFluxOptionsFluxFunction) {\n-        return new CosmosPagedFlux<>(pagedFluxOptionsFluxFunction);\n+    public static <T> CosmosPagedFlux<T> createCosmosPagedFlux(Function<CosmosPagedFluxOptions, Flux<FeedResponse<T>>> pagedFluxOptionsFluxFunction, boolean isTracerEnable) {", "originalCommit": "e7fe8bb66384a0999cb137e3d0476540cf419c84", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUwNDI1NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r433504255", "bodyText": "use StepVerifier instead of block for testing async calls?", "author": "samvaity", "createdAt": "2020-06-01T21:37:44Z", "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/CosmosTracerTest.java", "diffHunk": "@@ -0,0 +1,251 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos;\n+\n+import com.azure.core.util.Context;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.cosmos.implementation.CosmosItemProperties;\n+import com.azure.cosmos.implementation.LifeCycleUtils;\n+import com.azure.cosmos.implementation.TestConfigurations;\n+import com.azure.cosmos.implementation.TracerProvider;\n+import com.azure.cosmos.implementation.directconnectivity.ReflectionUtils;\n+import com.azure.cosmos.models.CosmosItemRequestOptions;\n+import com.azure.cosmos.models.CosmosStoredProcedureProperties;\n+import com.azure.cosmos.models.CosmosTriggerProperties;\n+import com.azure.cosmos.models.CosmosUserDefinedFunctionProperties;\n+import com.azure.cosmos.models.FeedOptions;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.azure.cosmos.models.TriggerOperation;\n+import com.azure.cosmos.models.TriggerType;\n+import com.azure.cosmos.rx.TestSuiteBase;\n+import org.mockito.Matchers;\n+import org.mockito.Mockito;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.ServiceLoader;\n+import java.util.UUID;\n+\n+public class CosmosTracerTest extends TestSuiteBase {\n+    private static final String ITEM_ID = \"tracerDoc\";\n+    CosmosAsyncClient client;\n+    CosmosAsyncDatabase cosmosAsyncDatabase;\n+    CosmosAsyncContainer cosmosAsyncContainer;\n+\n+    @BeforeClass(groups = {\"emulator\"}, timeOut = SETUP_TIMEOUT)\n+    public void beforeClass() {\n+        client = new CosmosClientBuilder()\n+            .endpoint(TestConfigurations.HOST)\n+            .key(TestConfigurations.MASTER_KEY)\n+            .directMode(DirectConnectionConfig.getDefaultConfig())\n+            .buildAsyncClient();\n+        cosmosAsyncDatabase = getSharedCosmosDatabase(client);\n+        cosmosAsyncContainer = getSharedMultiPartitionCosmosContainer(client);\n+\n+    }\n+\n+    @Test(groups = {\"emulator\"}, timeOut = TIMEOUT)\n+    public void cosmosAsyncClient() {\n+        TracerProvider tracer = Mockito.spy(new TracerProvider(ServiceLoader.load(Tracer.class)));\n+        ReflectionUtils.setTracerProvider(client, tracer);\n+\n+        client.createDatabaseIfNotExists(cosmosAsyncDatabase.getId()).block();", "originalCommit": "e7fe8bb66384a0999cb137e3d0476540cf419c84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk4NTQ5OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r438985498", "bodyText": "Will address testing format comment in next  tracer event pr as discussed offline", "author": "simplynaveen20", "createdAt": "2020-06-11T18:22:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUwNDI1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUwNDY3Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r433504672", "bodyText": "Rather than any string could we validate the span names and attributes being set on the span?", "author": "samvaity", "createdAt": "2020-06-01T21:38:41Z", "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/CosmosTracerTest.java", "diffHunk": "@@ -0,0 +1,251 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.cosmos;\n+\n+import com.azure.core.util.Context;\n+import com.azure.core.util.tracing.Tracer;\n+import com.azure.cosmos.implementation.CosmosItemProperties;\n+import com.azure.cosmos.implementation.LifeCycleUtils;\n+import com.azure.cosmos.implementation.TestConfigurations;\n+import com.azure.cosmos.implementation.TracerProvider;\n+import com.azure.cosmos.implementation.directconnectivity.ReflectionUtils;\n+import com.azure.cosmos.models.CosmosItemRequestOptions;\n+import com.azure.cosmos.models.CosmosStoredProcedureProperties;\n+import com.azure.cosmos.models.CosmosTriggerProperties;\n+import com.azure.cosmos.models.CosmosUserDefinedFunctionProperties;\n+import com.azure.cosmos.models.FeedOptions;\n+import com.azure.cosmos.models.PartitionKey;\n+import com.azure.cosmos.models.TriggerOperation;\n+import com.azure.cosmos.models.TriggerType;\n+import com.azure.cosmos.rx.TestSuiteBase;\n+import org.mockito.Matchers;\n+import org.mockito.Mockito;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import java.util.ServiceLoader;\n+import java.util.UUID;\n+\n+public class CosmosTracerTest extends TestSuiteBase {\n+    private static final String ITEM_ID = \"tracerDoc\";\n+    CosmosAsyncClient client;\n+    CosmosAsyncDatabase cosmosAsyncDatabase;\n+    CosmosAsyncContainer cosmosAsyncContainer;\n+\n+    @BeforeClass(groups = {\"emulator\"}, timeOut = SETUP_TIMEOUT)\n+    public void beforeClass() {\n+        client = new CosmosClientBuilder()\n+            .endpoint(TestConfigurations.HOST)\n+            .key(TestConfigurations.MASTER_KEY)\n+            .directMode(DirectConnectionConfig.getDefaultConfig())\n+            .buildAsyncClient();\n+        cosmosAsyncDatabase = getSharedCosmosDatabase(client);\n+        cosmosAsyncContainer = getSharedMultiPartitionCosmosContainer(client);\n+\n+    }\n+\n+    @Test(groups = {\"emulator\"}, timeOut = TIMEOUT)\n+    public void cosmosAsyncClient() {\n+        TracerProvider tracer = Mockito.spy(new TracerProvider(ServiceLoader.load(Tracer.class)));\n+        ReflectionUtils.setTracerProvider(client, tracer);\n+\n+        client.createDatabaseIfNotExists(cosmosAsyncDatabase.getId()).block();\n+        Mockito.verify(tracer, Mockito.times(1)).startSpan(Matchers.anyString(), Matchers.anyString(),", "originalCommit": "e7fe8bb66384a0999cb137e3d0476540cf419c84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk4NTM4Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r438985382", "bodyText": "Will address all testing format comment in next  tracer event pr as discussed offline", "author": "simplynaveen20", "createdAt": "2020-06-11T18:22:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUwNDY3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUwNjI2OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r433506269", "bodyText": "Should consider adding tests for TracerProvider.", "author": "samvaity", "createdAt": "2020-06-01T21:42:22Z", "path": "sdk/cosmos/azure-cosmos/src/test/java/com/azure/cosmos/rx/TestSuiteBase.java", "diffHunk": "@@ -469,8 +469,8 @@ public static CosmosItemProperties createDocument(CosmosAsyncContainer cosmosCon\n     }", "originalCommit": "e7fe8bb66384a0999cb137e3d0476540cf419c84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUxNTU4Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r433515582", "bodyText": "Also, consider adding a nesting call example to validate the behavior of spans.", "author": "samvaity", "createdAt": "2020-06-01T22:06:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUwNjI2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk4NDkwOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/10265#discussion_r438984908", "bodyText": "This is cover by start span count assert , test will fail if there is nesting . Will add explicit test in next pr covering event", "author": "simplynaveen20", "createdAt": "2020-06-11T18:21:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUwNjI2OQ=="}], "type": "inlineReview"}, {"oid": "3461604e14d02caffdb2e6df5e9755702bf658c6", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3461604e14d02caffdb2e6df5e9755702bf658c6", "message": "resolving merge conflict after GA", "committedDate": "2020-06-11T18:04:42Z", "type": "commit"}, {"oid": "0984a9ceadd61b2c0862a4a6ae3b968693952d57", "url": "https://github.com/Azure/azure-sdk-for-java/commit/0984a9ceadd61b2c0862a4a6ae3b968693952d57", "message": "code formating change and some comment resolution", "committedDate": "2020-06-11T22:11:06Z", "type": "commit"}, {"oid": "b9c60a2431add13e597f3c7874f590cc8695945f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b9c60a2431add13e597f3c7874f590cc8695945f", "message": "resolving comments", "committedDate": "2020-06-11T23:30:10Z", "type": "commit"}, {"oid": "aaabc72ed458360d2e758f05e8744f2ba22d2d8e", "url": "https://github.com/Azure/azure-sdk-for-java/commit/aaabc72ed458360d2e758f05e8744f2ba22d2d8e", "message": "moving AZ_TRACING_NAMESPACE_KEY to context from span attribute", "committedDate": "2020-06-15T16:33:48Z", "type": "commit"}, {"oid": "8024999b269086cdc804cf1b2212abde9f21ca6a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/8024999b269086cdc804cf1b2212abde9f21ca6a", "message": "updating core opentelementry jar", "committedDate": "2020-06-15T18:40:41Z", "type": "commit"}]}