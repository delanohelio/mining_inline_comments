{"pr_number": 12302, "pr_title": "Return paging metadata as top-level API", "pr_createdAt": "2020-06-17T23:56:23Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/12302", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM1MDIyMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12302#discussion_r442350223", "bodyText": "I'm not certain this is the right pattern to be using. Looking at the method calls below, getting their property informationwill trigger a service call and as @brjohnstmsft mentioned this information is variable between calls. I believe the pattern we should be following is closer to what @anuchandy used when creating PollerFlux with caching responses, in this case the first response will be cached in this class instead of the most recent response.\nThe high level flow would be the following,\n\nCreate a property on the class that will be set on first page retrieved.\nWrap the passed supplier in another supplier that will retrieve the first page and set the variable.\nIf one of the property methods on the class are called before the first page is retrieved it will get the first page and cache it, when the Flux is iterated we join that page with all the next page retrievals.\n\nThis may have some side affects depending on much time passes between the property access and iterating the flux.\n\n\n\nGiven Java's use of Reactor for paging a few more questions arise:\n\nWhat happens when the consumer begins their iteration using a continuation token.\nHow does this fit into the reactive stream concept.\n\nThe former may be resolved by having this class override those methods to better handle it, but there still is an issue that this Flux could be used multiple times with different starting locations.\nSearchPagedFlux searchFlux = search(\"search string);\n\nsearchFlux.subscribe(/* iterate by item */);\n\n/* Some code later */\n\nsearchFlux.byPage(continuationToken).subscribe(/* iterate pages from starting token */);\nIn this case the SearchPagedFlux has been retained and will contain top level data for the first invocation, but there is not reason it couldn't be reused later.\nAs seen above there is also a pattern mismatch with how these top level properties need to be accessed. The consumer either needs to explicitly retain access to the PagedFlux or they need to use it directly before iterating, both are a bit of an anti-pattern for reactive programming.\nSome of the issues raised here are more corner cases but I want to make sure we think through them.", "author": "alzimmermsft", "createdAt": "2020-06-18T16:23:52Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/util/SearchPagedFlux.java", "diffHunk": "@@ -17,13 +20,16 @@\n  * element type is {@link SearchResult}, and the page type is {@link SearchPagedResponse}.\n  */\n public final class SearchPagedFlux extends PagedFluxBase<SearchResult, SearchPagedResponse> {\n+    private final Supplier<Mono<SearchPagedResponse>> firstPageRetriever;", "originalCommit": "66da7c5bc5325322cc6a70153a83f7c539098ff6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQxNTczNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12302#discussion_r442415736", "bodyText": "Based on the offline discussion, we are going to pause the PR with the answer of\nWhether customer is using metadata (total count) together with paging result or use it independently?\nOption 1: (Use it together)\nWe will have such paging response without touching SearchPagedFlux\nSearchPagedResponse\n{\n      private Long totalCount; // with public getter, setter\n      private Double coverage; // with public getter, setter\n      private Map facetResult; // with public getter, setter\n      private SearchResultItemContext(result item, metadata...) // with public getter, setter\n}\n\nOption 2: (Independent use)\nWe will have such paging flux, and remove page level metadata.\nSearchPagedFlux \n{\n        private Supplier firstPageRetriver;\n        private Long firstPagedCount;\n\n        public synchronized Mono<Double> getCoverage() {\n            if (firstPageCoverage != null) {\n                return Mono.just(firstPageCoverage);\n            }\n\n            return firstPageRetriever.get().flatMap(response -> {\n                if (response.getCoverage() == null) {\n                    return Mono.empty();\n                }\n                firstPageCoverage = response.getCoverage();\n                return Mono.just(firstPageCoverage);\n             });\n        }\n}", "author": "sima-zhu", "createdAt": "2020-06-18T18:17:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM1MDIyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQxNjQ4MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12302#discussion_r442416480", "bodyText": "@brjohnstmsft", "author": "sima-zhu", "createdAt": "2020-06-18T18:19:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM1MDIyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM1MTI3OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12302#discussion_r442351279", "bodyText": "Just to make clear, we are now hiding the per-page metadata. I don't have an issue with it, just wanted to make certain I understand this change.", "author": "alzimmermsft", "createdAt": "2020-06-18T16:25:32Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/util/SearchPagedResponse.java", "diffHunk": "@@ -81,7 +81,7 @@ private static String createContinuationToken(SimpleResponse<SearchDocumentsResu\n      * @return The percentage of the index covered in the search request if {@code minimumCoverage} was set in the\n      * request, otherwise {@code null}.\n      */\n-    public Double getCoverage() {\n+    Double getCoverage() {", "originalCommit": "66da7c5bc5325322cc6a70153a83f7c539098ff6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjkxNDEyNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12302#discussion_r442914126", "bodyText": "Talked offline. We won't provide page-level API", "author": "sima-zhu", "createdAt": "2020-06-19T15:44:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM1MTI3OQ=="}], "type": "inlineReview"}, {"oid": "74545a69b2c7a982cd6125953006fa53b03db05b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/74545a69b2c7a982cd6125953006fa53b03db05b", "message": "Implemented top-level API for search page results.", "committedDate": "2020-06-19T15:37:58Z", "type": "commit"}, {"oid": "74545a69b2c7a982cd6125953006fa53b03db05b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/74545a69b2c7a982cd6125953006fa53b03db05b", "message": "Implemented top-level API for search page results.", "committedDate": "2020-06-19T15:37:58Z", "type": "forcePushed"}, {"oid": "dd0d2240f21da902284cad24d61d74eb0c67e57c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/dd0d2240f21da902284cad24d61d74eb0c67e57c", "message": "Fixed linting issues", "committedDate": "2020-06-19T15:50:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjkzNjk2OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12302#discussion_r442936968", "bodyText": "Should do this in the map operation above. doOnNext is meant for side-effect operations such as logging and tracing.", "author": "alzimmermsft", "createdAt": "2020-06-19T16:27:50Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/SearchAsyncClient.java", "diffHunk": "@@ -404,28 +405,39 @@ public SearchPagedFlux search(String searchText) {\n      */\n     public SearchPagedFlux search(String searchText, SearchOptions searchOptions, RequestOptions requestOptions) {\n         SearchRequest request = createSearchRequest(searchText, searchOptions);\n+        SearchFirstPageResponseWrapper firstPageResponse = new SearchFirstPageResponseWrapper();\n         Function<String, Mono<SearchPagedResponse>> func = continuationToken -> withContext(context ->\n-            search(request, requestOptions, continuationToken, context));\n+            search(request, requestOptions, continuationToken, firstPageResponse, context));\n         return new SearchPagedFlux(() -> func.apply(null), func);\n     }\n \n     SearchPagedFlux search(String searchText, SearchOptions searchOptions, RequestOptions requestOptions,\n         Context context) {\n         SearchRequest request = createSearchRequest(searchText, searchOptions);\n+        SearchFirstPageResponseWrapper firstPageResponseWrapper = new SearchFirstPageResponseWrapper();\n         Function<String, Mono<SearchPagedResponse>> func = continuationToken ->\n-            search(request, requestOptions, continuationToken, context);\n+            search(request, requestOptions, continuationToken, firstPageResponseWrapper, context);\n         return new SearchPagedFlux(() -> func.apply(null), func);\n     }\n \n     private Mono<SearchPagedResponse> search(SearchRequest request, RequestOptions requestOptions,\n-        String continuationToken, Context context) {\n+        String continuationToken, SearchFirstPageResponseWrapper firstPageResponseWrapper, Context context) {\n+\n+        if (continuationToken == null && firstPageResponseWrapper.getFirstPageResponse() != null) {\n+            return Mono.just(firstPageResponseWrapper.getFirstPageResponse());\n+        }\n         SearchRequest requestToUse = (continuationToken == null) ? request\n             : SearchContinuationToken.deserializeToken(serviceVersion.getVersion(), continuationToken);\n \n         return restClient.documents().searchPostWithRestResponseAsync(requestToUse,\n             RequestOptionsConverter.map(requestOptions), context)\n             .onErrorMap(MappingUtils::exceptionMapper)\n-            .map(searchDocumentResponse -> new SearchPagedResponse(searchDocumentResponse, serviceVersion));\n+            .map(searchDocumentResponse -> new SearchPagedResponse(searchDocumentResponse, serviceVersion))\n+            .doOnNext(response -> {", "originalCommit": "dd0d2240f21da902284cad24d61d74eb0c67e57c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk1ODczMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12302#discussion_r442958732", "bodyText": "I don't think this wrapper is necessary. You could directly use the SearchPagedResponse.", "author": "srnagar", "createdAt": "2020-06-19T17:17:55Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/implementation/models/SearchFirstPageResponseWrapper.java", "diffHunk": "@@ -0,0 +1,33 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.search.documents.implementation.models;\n+\n+import com.azure.search.documents.util.SearchPagedResponse;\n+\n+/**\n+ * This class is a wrapper on first page response from search result.\n+ */\n+public class SearchFirstPageResponseWrapper {", "originalCommit": "dd0d2240f21da902284cad24d61d74eb0c67e57c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk3NjI3Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12302#discussion_r442976277", "bodyText": "This is what I use to expose the metadata between each paging call. Also the class serves as local caching.\nWe cannot expose metadata API in SearchPageResponse, so I put the wrapper under implementation.", "author": "sima-zhu", "createdAt": "2020-06-19T17:58:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk1ODczMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA0MzQwOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12302#discussion_r443043409", "bodyText": "Talked offline. There is no hurt to have a wrapper here. Merge the PR for now. Will try to see if there is reactor api which can cache and reuse the publisher.", "author": "sima-zhu", "createdAt": "2020-06-19T21:04:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk1ODczMg=="}], "type": "inlineReview"}, {"oid": "c981b1d1494c40c186176970e1c7c46857a3c4f5", "url": "https://github.com/Azure/azure-sdk-for-java/commit/c981b1d1494c40c186176970e1c7c46857a3c4f5", "message": "Address Alan's feedback", "committedDate": "2020-06-19T17:56:57Z", "type": "commit"}, {"oid": "6b0157d7cf2314d3ee91f26ff3bce47cc51239bc", "url": "https://github.com/Azure/azure-sdk-for-java/commit/6b0157d7cf2314d3ee91f26ff3bce47cc51239bc", "message": "Update SearchAsyncClient.java", "committedDate": "2020-06-19T19:41:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI2NDYxNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/12302#discussion_r443264617", "bodyText": "This is not valid HTML - you should have the opening <p> tag on the same line as the paragraph, and a closing </p> tag at the end of the paragraph.", "author": "JonathanGiles", "createdAt": "2020-06-21T22:56:17Z", "path": "sdk/search/azure-search-documents/src/main/java/com/azure/search/documents/util/SearchPagedIterable.java", "diffHunk": "@@ -6,19 +6,61 @@\n import com.azure.core.http.rest.PagedIterableBase;\n import com.azure.core.util.paging.ContinuablePagedIterable;\n import com.azure.search.documents.implementation.models.SearchRequest;\n+import com.azure.search.documents.models.FacetResult;\n import com.azure.search.documents.models.SearchResult;\n \n+import java.util.List;\n+import java.util.Map;\n+\n /**\n  * Implementation of {@link ContinuablePagedIterable} where the continuation token type is {@link SearchRequest}, the\n  * element type is {@link SearchResult}, and the page type is {@link SearchPagedResponse}.\n  */\n public final class SearchPagedIterable extends PagedIterableBase<SearchResult, SearchPagedResponse> {\n+    private final SearchPagedFlux pagedFlux;\n+\n     /**\n      * Creates an instance of {@link SearchPagedIterable}.\n      *\n      * @param pagedFlux The {@link SearchPagedFlux} that will be consumed as an iterable.\n      */\n     public SearchPagedIterable(SearchPagedFlux pagedFlux) {\n         super(pagedFlux);\n+        this.pagedFlux = pagedFlux;\n+    }\n+\n+    /**\n+     * The percentage of the index covered in the search request.\n+     * <p>", "originalCommit": "6b0157d7cf2314d3ee91f26ff3bce47cc51239bc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}