{"pr_number": 16452, "pr_title": "End to end TLS SSL", "pr_createdAt": "2020-10-16T13:34:14Z", "pr_url": "https://github.com/Azure/azure-sdk-for-java/pull/16452", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgyNTU4MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508825581", "bodyText": "This will work on IMDS supported Azure Platforms only.\nFor e.g This won't work in App Service.", "author": "g2vinay", "createdAt": "2020-10-20T20:41:33Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/AuthClient.java", "diffHunk": "@@ -0,0 +1,182 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import com.azure.security.keyvault.jca.rest.OAuthToken;\n+\n+import java.util.HashMap;\n+import java.util.logging.Logger;\n+\n+import static java.util.logging.Level.FINER;\n+\n+/**\n+ * The REST client specific to getting an access token for Azure REST APIs.\n+ */\n+class AuthClient extends DelegateRestClient {\n+\n+    /**\n+     * Stores the Client ID fragment.\n+     */\n+    private static final String CLIENT_ID_FRAGMENT = \"&client_id=\";\n+\n+    /**\n+     * Stores the Client Secret fragment.\n+     */\n+    private static final String CLIENT_SECRET_FRAGMENT = \"&client_secret=\";\n+\n+    /**\n+     * Stores the Grant Type fragment.\n+     */\n+    private static final String GRANT_TYPE_FRAGMENT = \"grant_type=client_credentials\";\n+\n+    /**\n+     * Stores the Resource fragment.\n+     */\n+    private static final String RESOURCE_FRAGMENT = \"&resource=\";\n+\n+    /**\n+     * Stores the OAuth2 token base URL.\n+     */\n+    private static final String OAUTH2_TOKEN_BASE_URL = \"https://login.microsoftonline.com/\";\n+\n+    /**\n+     * Stores the OAuth2 token postfix.\n+     */\n+    private static final String OAUTH2_TOKEN_POSTFIX = \"/oauth2/token\";\n+\n+    /**\n+     * Stores the OAuth2 managed identity URL.\n+     */\n+    private static final String OAUTH2_MANAGED_IDENTITY_TOKEN_URL\n+        = \"http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01\";", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNzQzNzE5Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r607437192", "bodyText": "Hi, the case of App Service has been handled separately. And according to this doc, requesting access tokens via Azure resources VM Extension Endpoint is also not encouraged. Thus are there any other cases that are not covered? Thanks", "author": "yiliuTo", "createdAt": "2021-04-06T02:03:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgyNTU4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgyNjQ2NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508826465", "bodyText": "Why do we need to build the custom Auth Client ?\nMSAL offers this support, can we directly use MSAL here ?", "author": "g2vinay", "createdAt": "2020-10-20T20:43:11Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/AuthClient.java", "diffHunk": "@@ -0,0 +1,182 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import com.azure.security.keyvault.jca.rest.OAuthToken;\n+\n+import java.util.HashMap;\n+import java.util.logging.Logger;\n+\n+import static java.util.logging.Level.FINER;\n+\n+/**\n+ * The REST client specific to getting an access token for Azure REST APIs.\n+ */\n+class AuthClient extends DelegateRestClient {", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE3MTIxMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510171210", "bodyText": "MSAL would only be usable in this particular case if a) it is self-contained as a JAR and b) it can be properly shaded and relocated so customers are not impacted by versioning. As far as I can tell that is not the case hence it using its own client.", "author": "mnriem", "createdAt": "2020-10-22T13:41:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgyNjQ2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgyODI1NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508828254", "bodyText": "There's a newer 2019 API version available, which uses IDENTITY_ENDPOINT and IDENTITY_HEADER env vars.", "author": "g2vinay", "createdAt": "2020-10-20T20:46:18Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/AuthClient.java", "diffHunk": "@@ -0,0 +1,182 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import com.azure.security.keyvault.jca.rest.OAuthToken;\n+\n+import java.util.HashMap;\n+import java.util.logging.Logger;\n+\n+import static java.util.logging.Level.FINER;\n+\n+/**\n+ * The REST client specific to getting an access token for Azure REST APIs.\n+ */\n+class AuthClient extends DelegateRestClient {\n+\n+    /**\n+     * Stores the Client ID fragment.\n+     */\n+    private static final String CLIENT_ID_FRAGMENT = \"&client_id=\";\n+\n+    /**\n+     * Stores the Client Secret fragment.\n+     */\n+    private static final String CLIENT_SECRET_FRAGMENT = \"&client_secret=\";\n+\n+    /**\n+     * Stores the Grant Type fragment.\n+     */\n+    private static final String GRANT_TYPE_FRAGMENT = \"grant_type=client_credentials\";\n+\n+    /**\n+     * Stores the Resource fragment.\n+     */\n+    private static final String RESOURCE_FRAGMENT = \"&resource=\";\n+\n+    /**\n+     * Stores the OAuth2 token base URL.\n+     */\n+    private static final String OAUTH2_TOKEN_BASE_URL = \"https://login.microsoftonline.com/\";\n+\n+    /**\n+     * Stores the OAuth2 token postfix.\n+     */\n+    private static final String OAUTH2_TOKEN_POSTFIX = \"/oauth2/token\";\n+\n+    /**\n+     * Stores the OAuth2 managed identity URL.\n+     */\n+    private static final String OAUTH2_MANAGED_IDENTITY_TOKEN_URL\n+        = \"http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01\";\n+\n+    /**\n+     * Stores our logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(AuthClient.class.getName());\n+\n+    /**\n+     * Constructor.\n+     *\n+     * <p>\n+     * The constructor creates a default RestClient.\n+     * </p>\n+     */\n+    AuthClient() {\n+        super(RestClientFactory.createClient());\n+    }\n+\n+    /**\n+     * Get an access token for a managed identity.\n+     *\n+     * @param resource the resource.\n+     * @return the authorization token.\n+     */\n+    public String getAccessToken(String resource) {\n+        String result;\n+\n+        if (System.getenv(\"WEBSITE_SITE_NAME\") != null\n+            && !System.getenv(\"WEBSITE_SITE_NAME\").isEmpty()) {\n+            result = getAccessTokenOnAppService(resource);\n+        } else {\n+            result = getAccessTokenOnOthers(resource);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Get an access token.\n+     *\n+     * @param resource the resource.\n+     * @param tenantId the tenant ID.\n+     * @param clientId the client ID.\n+     * @param clientSecret the client secret.\n+     * @return the authorization token.\n+     */\n+    public String getAccessToken(String resource, String tenantId,\n+                                 String clientId, String clientSecret) {\n+        LOGGER.entering(\"AuthClient\", \"getAccessToken\", new Object[] {\n+            resource, tenantId, clientId, clientSecret });\n+        LOGGER.info(\"Getting access token using client ID / client secret\");\n+        String result = null;\n+\n+        StringBuilder oauth2Url = new StringBuilder();\n+        oauth2Url.append(OAUTH2_TOKEN_BASE_URL)\n+                 .append(tenantId)\n+                 .append(OAUTH2_TOKEN_POSTFIX);\n+\n+        StringBuilder requestBody = new StringBuilder();\n+        requestBody.append(GRANT_TYPE_FRAGMENT)\n+                   .append(CLIENT_ID_FRAGMENT).append(clientId)\n+                   .append(CLIENT_SECRET_FRAGMENT).append(clientSecret)\n+                   .append(RESOURCE_FRAGMENT).append(resource);\n+\n+        String body = post(oauth2Url.toString(), requestBody.toString(), \"application/x-www-form-urlencoded\");\n+        if (body != null) {\n+            JsonConverter converter = JsonConverterFactory.createJsonConverter();\n+            OAuthToken token = (OAuthToken) converter.fromJson(body, OAuthToken.class);\n+            result = token.getAccess_token();\n+        }\n+        LOGGER.log(FINER, \"Access token: {0}\", result);\n+        return result;\n+    }\n+\n+    /**\n+     * Get the access token on Azure App Service.\n+     *\n+     * @param resource the resource.\n+     * @return the authorization token.\n+     */\n+    private String getAccessTokenOnAppService(String resource) {\n+        LOGGER.entering(\"AuthClient\", \"getAccessTokenOnAppService\", resource);\n+        LOGGER.info(\"Getting access token using managed identity based on MSI_SECRET\");\n+        String result = null;\n+\n+        StringBuilder url = new StringBuilder();\n+        url.append(System.getenv(\"MSI_ENDPOINT\"))\n+           .append(\"?api-version=2017-09-01\")", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzQ2NjgxNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r597466816", "bodyText": "Hi @g2vinay , I found the following information that when using Linux Consumption, 2017 API version is required. Thus is it a better choice that we remain use of 2017 API version to support more cases?", "author": "yiliuTo", "createdAt": "2021-03-19T07:50:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgyODI1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgyODg3Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508828872", "bodyText": "with 2017 API version, I believe the expiry time comes in different formats on Windows and Linux based App Services,\nis that being handled here ?", "author": "g2vinay", "createdAt": "2020-10-20T20:47:27Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/AuthClient.java", "diffHunk": "@@ -0,0 +1,182 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import com.azure.security.keyvault.jca.rest.OAuthToken;\n+\n+import java.util.HashMap;\n+import java.util.logging.Logger;\n+\n+import static java.util.logging.Level.FINER;\n+\n+/**\n+ * The REST client specific to getting an access token for Azure REST APIs.\n+ */\n+class AuthClient extends DelegateRestClient {\n+\n+    /**\n+     * Stores the Client ID fragment.\n+     */\n+    private static final String CLIENT_ID_FRAGMENT = \"&client_id=\";\n+\n+    /**\n+     * Stores the Client Secret fragment.\n+     */\n+    private static final String CLIENT_SECRET_FRAGMENT = \"&client_secret=\";\n+\n+    /**\n+     * Stores the Grant Type fragment.\n+     */\n+    private static final String GRANT_TYPE_FRAGMENT = \"grant_type=client_credentials\";\n+\n+    /**\n+     * Stores the Resource fragment.\n+     */\n+    private static final String RESOURCE_FRAGMENT = \"&resource=\";\n+\n+    /**\n+     * Stores the OAuth2 token base URL.\n+     */\n+    private static final String OAUTH2_TOKEN_BASE_URL = \"https://login.microsoftonline.com/\";\n+\n+    /**\n+     * Stores the OAuth2 token postfix.\n+     */\n+    private static final String OAUTH2_TOKEN_POSTFIX = \"/oauth2/token\";\n+\n+    /**\n+     * Stores the OAuth2 managed identity URL.\n+     */\n+    private static final String OAUTH2_MANAGED_IDENTITY_TOKEN_URL\n+        = \"http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01\";\n+\n+    /**\n+     * Stores our logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(AuthClient.class.getName());\n+\n+    /**\n+     * Constructor.\n+     *\n+     * <p>\n+     * The constructor creates a default RestClient.\n+     * </p>\n+     */\n+    AuthClient() {\n+        super(RestClientFactory.createClient());\n+    }\n+\n+    /**\n+     * Get an access token for a managed identity.\n+     *\n+     * @param resource the resource.\n+     * @return the authorization token.\n+     */\n+    public String getAccessToken(String resource) {\n+        String result;\n+\n+        if (System.getenv(\"WEBSITE_SITE_NAME\") != null\n+            && !System.getenv(\"WEBSITE_SITE_NAME\").isEmpty()) {\n+            result = getAccessTokenOnAppService(resource);\n+        } else {\n+            result = getAccessTokenOnOthers(resource);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Get an access token.\n+     *\n+     * @param resource the resource.\n+     * @param tenantId the tenant ID.\n+     * @param clientId the client ID.\n+     * @param clientSecret the client secret.\n+     * @return the authorization token.\n+     */\n+    public String getAccessToken(String resource, String tenantId,\n+                                 String clientId, String clientSecret) {\n+        LOGGER.entering(\"AuthClient\", \"getAccessToken\", new Object[] {\n+            resource, tenantId, clientId, clientSecret });\n+        LOGGER.info(\"Getting access token using client ID / client secret\");\n+        String result = null;\n+\n+        StringBuilder oauth2Url = new StringBuilder();\n+        oauth2Url.append(OAUTH2_TOKEN_BASE_URL)\n+                 .append(tenantId)\n+                 .append(OAUTH2_TOKEN_POSTFIX);\n+\n+        StringBuilder requestBody = new StringBuilder();\n+        requestBody.append(GRANT_TYPE_FRAGMENT)\n+                   .append(CLIENT_ID_FRAGMENT).append(clientId)\n+                   .append(CLIENT_SECRET_FRAGMENT).append(clientSecret)\n+                   .append(RESOURCE_FRAGMENT).append(resource);\n+\n+        String body = post(oauth2Url.toString(), requestBody.toString(), \"application/x-www-form-urlencoded\");\n+        if (body != null) {\n+            JsonConverter converter = JsonConverterFactory.createJsonConverter();\n+            OAuthToken token = (OAuthToken) converter.fromJson(body, OAuthToken.class);\n+            result = token.getAccess_token();\n+        }\n+        LOGGER.log(FINER, \"Access token: {0}\", result);\n+        return result;\n+    }\n+\n+    /**\n+     * Get the access token on Azure App Service.\n+     *\n+     * @param resource the resource.\n+     * @return the authorization token.\n+     */\n+    private String getAccessTokenOnAppService(String resource) {\n+        LOGGER.entering(\"AuthClient\", \"getAccessTokenOnAppService\", resource);\n+        LOGGER.info(\"Getting access token using managed identity based on MSI_SECRET\");\n+        String result = null;\n+\n+        StringBuilder url = new StringBuilder();\n+        url.append(System.getenv(\"MSI_ENDPOINT\"))\n+           .append(\"?api-version=2017-09-01\")\n+           .append(RESOURCE_FRAGMENT).append(resource);\n+\n+        HashMap<String, String> headers = new HashMap<>();\n+        headers.put(\"Metadata\", \"true\");\n+        headers.put(\"Secret\", System.getenv(\"MSI_SECRET\"));\n+        String body = get(url.toString(), headers);\n+\n+        if (body != null) {\n+            JsonConverter converter = JsonConverterFactory.createJsonConverter();\n+            OAuthToken token = (OAuthToken) converter.fromJson(body, OAuthToken.class);", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgzMDcyNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508830726", "bodyText": "This URL won't work on all of the other Azure Platforms, for e.g. Azure Service Fabric", "author": "g2vinay", "createdAt": "2020-10-20T20:50:47Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/AuthClient.java", "diffHunk": "@@ -0,0 +1,182 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import com.azure.security.keyvault.jca.rest.OAuthToken;\n+\n+import java.util.HashMap;\n+import java.util.logging.Logger;\n+\n+import static java.util.logging.Level.FINER;\n+\n+/**\n+ * The REST client specific to getting an access token for Azure REST APIs.\n+ */\n+class AuthClient extends DelegateRestClient {\n+\n+    /**\n+     * Stores the Client ID fragment.\n+     */\n+    private static final String CLIENT_ID_FRAGMENT = \"&client_id=\";\n+\n+    /**\n+     * Stores the Client Secret fragment.\n+     */\n+    private static final String CLIENT_SECRET_FRAGMENT = \"&client_secret=\";\n+\n+    /**\n+     * Stores the Grant Type fragment.\n+     */\n+    private static final String GRANT_TYPE_FRAGMENT = \"grant_type=client_credentials\";\n+\n+    /**\n+     * Stores the Resource fragment.\n+     */\n+    private static final String RESOURCE_FRAGMENT = \"&resource=\";\n+\n+    /**\n+     * Stores the OAuth2 token base URL.\n+     */\n+    private static final String OAUTH2_TOKEN_BASE_URL = \"https://login.microsoftonline.com/\";\n+\n+    /**\n+     * Stores the OAuth2 token postfix.\n+     */\n+    private static final String OAUTH2_TOKEN_POSTFIX = \"/oauth2/token\";\n+\n+    /**\n+     * Stores the OAuth2 managed identity URL.\n+     */\n+    private static final String OAUTH2_MANAGED_IDENTITY_TOKEN_URL\n+        = \"http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01\";\n+\n+    /**\n+     * Stores our logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(AuthClient.class.getName());\n+\n+    /**\n+     * Constructor.\n+     *\n+     * <p>\n+     * The constructor creates a default RestClient.\n+     * </p>\n+     */\n+    AuthClient() {\n+        super(RestClientFactory.createClient());\n+    }\n+\n+    /**\n+     * Get an access token for a managed identity.\n+     *\n+     * @param resource the resource.\n+     * @return the authorization token.\n+     */\n+    public String getAccessToken(String resource) {\n+        String result;\n+\n+        if (System.getenv(\"WEBSITE_SITE_NAME\") != null\n+            && !System.getenv(\"WEBSITE_SITE_NAME\").isEmpty()) {\n+            result = getAccessTokenOnAppService(resource);\n+        } else {\n+            result = getAccessTokenOnOthers(resource);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Get an access token.\n+     *\n+     * @param resource the resource.\n+     * @param tenantId the tenant ID.\n+     * @param clientId the client ID.\n+     * @param clientSecret the client secret.\n+     * @return the authorization token.\n+     */\n+    public String getAccessToken(String resource, String tenantId,\n+                                 String clientId, String clientSecret) {\n+        LOGGER.entering(\"AuthClient\", \"getAccessToken\", new Object[] {\n+            resource, tenantId, clientId, clientSecret });\n+        LOGGER.info(\"Getting access token using client ID / client secret\");\n+        String result = null;\n+\n+        StringBuilder oauth2Url = new StringBuilder();\n+        oauth2Url.append(OAUTH2_TOKEN_BASE_URL)\n+                 .append(tenantId)\n+                 .append(OAUTH2_TOKEN_POSTFIX);\n+\n+        StringBuilder requestBody = new StringBuilder();\n+        requestBody.append(GRANT_TYPE_FRAGMENT)\n+                   .append(CLIENT_ID_FRAGMENT).append(clientId)\n+                   .append(CLIENT_SECRET_FRAGMENT).append(clientSecret)\n+                   .append(RESOURCE_FRAGMENT).append(resource);\n+\n+        String body = post(oauth2Url.toString(), requestBody.toString(), \"application/x-www-form-urlencoded\");\n+        if (body != null) {\n+            JsonConverter converter = JsonConverterFactory.createJsonConverter();\n+            OAuthToken token = (OAuthToken) converter.fromJson(body, OAuthToken.class);\n+            result = token.getAccess_token();\n+        }\n+        LOGGER.log(FINER, \"Access token: {0}\", result);\n+        return result;\n+    }\n+\n+    /**\n+     * Get the access token on Azure App Service.\n+     *\n+     * @param resource the resource.\n+     * @return the authorization token.\n+     */\n+    private String getAccessTokenOnAppService(String resource) {\n+        LOGGER.entering(\"AuthClient\", \"getAccessTokenOnAppService\", resource);\n+        LOGGER.info(\"Getting access token using managed identity based on MSI_SECRET\");\n+        String result = null;\n+\n+        StringBuilder url = new StringBuilder();\n+        url.append(System.getenv(\"MSI_ENDPOINT\"))\n+           .append(\"?api-version=2017-09-01\")\n+           .append(RESOURCE_FRAGMENT).append(resource);\n+\n+        HashMap<String, String> headers = new HashMap<>();\n+        headers.put(\"Metadata\", \"true\");\n+        headers.put(\"Secret\", System.getenv(\"MSI_SECRET\"));\n+        String body = get(url.toString(), headers);\n+\n+        if (body != null) {\n+            JsonConverter converter = JsonConverterFactory.createJsonConverter();\n+            OAuthToken token = (OAuthToken) converter.fromJson(body, OAuthToken.class);\n+            result = token.getAccess_token();\n+        }\n+        LOGGER.exiting(\"AuthClient\", \"getAccessTokenOnAppService\", result);\n+        return result;\n+    }\n+\n+    /**\n+     * Get the authorization token on everything else but Azure App Service.\n+     *\n+     * @param resource the resource.\n+     * @return the authorization token.\n+     */\n+    private String getAccessTokenOnOthers(String resource) {\n+        LOGGER.entering(\"AuthClient\", \"getAccessTokenOnOthers\", resource);\n+        LOGGER.info(\"Getting access token using managed identity\");\n+        String result = null;\n+\n+        StringBuilder url = new StringBuilder();\n+        url.append(OAUTH2_MANAGED_IDENTITY_TOKEN_URL)", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk1MjAxNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508952015", "bodyText": "Don't need to have public methods on a package private class", "author": "g2vinay", "createdAt": "2020-10-21T02:31:39Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/KeyVaultClient.java", "diffHunk": "@@ -0,0 +1,244 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import com.azure.security.keyvault.jca.rest.CertificateBundle;\n+import com.azure.security.keyvault.jca.rest.CertificateItem;\n+import com.azure.security.keyvault.jca.rest.CertificateListResult;\n+import com.azure.security.keyvault.jca.rest.CertificatePolicy;\n+import com.azure.security.keyvault.jca.rest.KeyProperties;\n+import com.azure.security.keyvault.jca.rest.SecretBundle;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.security.Key;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.logging.Logger;\n+\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.WARNING;\n+\n+/**\n+ * The REST client specific to Azure KeyVault.\n+ */\n+class KeyVaultClient extends DelegateRestClient {\n+\n+    /**\n+     * Stores the logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(KeyVaultClient.class.getName());\n+\n+    /**\n+     * Stores the API version postfix.\n+     */\n+    private static final String API_VERSION_POSTFIX = \"?api-version=7.1\";\n+\n+    /**\n+     * Stores the KeyVault URI.\n+     */\n+    private final String keyVaultUri;\n+\n+    /**\n+     * Stores the tenant ID.\n+     */\n+    private String tenantId;\n+\n+    /**\n+     * Stores the client ID.\n+     */\n+    private String clientId;\n+\n+    /**\n+     * Stores the client secret.\n+     */\n+    private String clientSecret;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param keyVaultUri the KeyVault URI.\n+     */\n+    KeyVaultClient(String keyVaultUri) {\n+        super(RestClientFactory.createClient());\n+        LOGGER.log(INFO, \"Using KeyVault: {0}\", keyVaultUri);\n+        if (!keyVaultUri.endsWith(\"/\")) {\n+            keyVaultUri = keyVaultUri + \"/\";\n+        }\n+        this.keyVaultUri = keyVaultUri;\n+    }\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param keyVaultUri the KeyVault URI.\n+     * @param tenantId the tenant ID.\n+     * @param clientId the client ID.\n+     * @param clientSecret the client secret.\n+     */\n+    KeyVaultClient(final String keyVaultUri, final String tenantId, final String clientId, final String clientSecret) {\n+        this(keyVaultUri);\n+        this.tenantId = tenantId;\n+        this.clientId = clientId;\n+        this.clientSecret = clientSecret;\n+    }\n+\n+    /**\n+     * Get the access token.\n+     *\n+     * @return the access token.\n+     */\n+    private String getAccessToken() {\n+        LOGGER.entering(\"KeyVaultClient\", \"getAccessToken\");\n+        String accessToken = null;\n+        try {\n+            AuthClient authClient = new AuthClient();\n+            String resource = URLEncoder.encode(\"https://vault.azure.net\", \"UTF-8\");\n+            if (tenantId != null && clientId != null && clientSecret != null) {\n+                accessToken = authClient.getAccessToken(resource, tenantId, clientId, clientSecret);\n+            } else {\n+                accessToken = authClient.getAccessToken(resource);\n+            }\n+        } catch (UnsupportedEncodingException uee) {\n+            LOGGER.log(WARNING, \"Unsupported encoding\", uee);\n+        }\n+        LOGGER.exiting(\"KeyVaultClient\", \"getAccessToken\", accessToken);\n+        return accessToken;\n+    }\n+\n+    /**\n+     * Get the list of aliases.\n+     *\n+     * @return the list of aliases.\n+     */\n+    public List<String> getAliases() {", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE1NDcxNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r511154714", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-23T21:04:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk1MjAxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE2MzgzOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r511163839", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-23T21:30:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk1MjAxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk1MjM0Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508952343", "bodyText": "why protected and not public ?", "author": "g2vinay", "createdAt": "2020-10-21T02:32:53Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/KeyVaultKeyManagerFactory.java", "diffHunk": "@@ -0,0 +1,49 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import javax.net.ssl.KeyManager;\n+import javax.net.ssl.KeyManagerFactorySpi;\n+import javax.net.ssl.ManagerFactoryParameters;\n+import java.security.KeyStore;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.logging.Logger;\n+\n+/**\n+ * The KeyVault variant of the KeyManagerFactory.\n+ */\n+public class KeyVaultKeyManagerFactory extends KeyManagerFactorySpi {\n+\n+    /**\n+     * Stores the logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(KeyVaultKeyManagerFactory.class.getName());\n+\n+    /**\n+     * Stores the key managers.\n+     */\n+    private final List<KeyManager> keyManagers = new ArrayList<>();\n+\n+    @Override\n+    protected void engineInit(KeyStore keystore, char[] password) {", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDIwMDk2Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510200967", "bodyText": "Not my choice this is part of the KeyManagerFactory delivered as part of JCA", "author": "mnriem", "createdAt": "2020-10-22T14:19:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk1MjM0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk1MjYyMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508952621", "bodyText": "is this method meant to not do anything ?\nBetter to throw an UnsupportedOperationException, to let user know,", "author": "g2vinay", "createdAt": "2020-10-21T02:34:09Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/KeyVaultKeyManagerFactory.java", "diffHunk": "@@ -0,0 +1,49 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import javax.net.ssl.KeyManager;\n+import javax.net.ssl.KeyManagerFactorySpi;\n+import javax.net.ssl.ManagerFactoryParameters;\n+import java.security.KeyStore;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.logging.Logger;\n+\n+/**\n+ * The KeyVault variant of the KeyManagerFactory.\n+ */\n+public class KeyVaultKeyManagerFactory extends KeyManagerFactorySpi {\n+\n+    /**\n+     * Stores the logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(KeyVaultKeyManagerFactory.class.getName());\n+\n+    /**\n+     * Stores the key managers.\n+     */\n+    private final List<KeyManager> keyManagers = new ArrayList<>();\n+\n+    @Override\n+    protected void engineInit(KeyStore keystore, char[] password) {\n+        LOGGER.entering(\n+            \"KeyVaultKeyManagerFactory\",\n+            \"engineInit\",\n+            new Object[] { keystore, new String(password) }\n+        );\n+        KeyVaultKeyManager manager = new KeyVaultKeyManager(keystore, password);\n+        keyManagers.add(manager);\n+    }\n+\n+    @Override\n+    protected void engineInit(ManagerFactoryParameters spec) {", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ2MTczOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510461739", "bodyText": "Yes it is meant to do nothing. And the API is defined and it does not state UnsupportedOperationException can be thrown.", "author": "mnriem", "createdAt": "2020-10-22T21:15:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk1MjYyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk1MzAzNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508953035", "bodyText": "Consider adding code snippets in Javadocs for public API.", "author": "g2vinay", "createdAt": "2020-10-21T02:35:44Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/KeyVaultKeyStore.java", "diffHunk": "@@ -0,0 +1,325 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.security.Key;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.KeyStoreSpi;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableEntryException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.logging.Logger;\n+\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.WARNING;\n+\n+/**\n+ * The Azure KeyVault implementation of the KeyStoreSpi.\n+ */\n+public class KeyVaultKeyStore extends KeyStoreSpi {\n+\n+    /**\n+     * Stores the logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(KeyVaultKeyStore.class.getName());\n+\n+    /**\n+     * Stores the list of aliases.\n+     */\n+    private List<String> aliases;\n+\n+    /**\n+     * Stores the certificates by alias.\n+     */\n+    private final HashMap<String, Certificate> certificates = new HashMap<>();\n+\n+    /**\n+     * Stores the certificate keys by alias.\n+     */\n+    private final HashMap<String, Key> certificateKeys = new HashMap<>();\n+\n+    /**\n+     * Stores the creation date.\n+     */\n+    private final Date creationDate;\n+\n+    /**\n+     * Stores the key vault client.\n+     */\n+    private KeyVaultClient keyVault;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * <p>\n+     * The constructor uses System.getProperty for\n+     * <code>azure.keyvault.uri</code>, <code>azure.keyvault.tenantId</code>,\n+     * <code>azure.keyvault.clientId</code>,\n+     * <code>azure.keyvault.clientSecret</code> to initialize the keyvault\n+     * client.\n+     * </p>\n+     */\n+    public KeyVaultKeyStore() {\n+        creationDate = new Date();\n+        String keyVaultUri = System.getProperty(\"azure.keyvault.uri\");\n+        String tenantId = System.getProperty(\"azure.keyvault.tenantId\");\n+        String clientId = System.getProperty(\"azure.keyvault.clientId\");\n+        String clientSecret = System.getProperty(\"azure.keyvault.clientSecret\");\n+        keyVault = new KeyVaultClient(keyVaultUri, tenantId, clientId, clientSecret);\n+    }\n+\n+    @Override\n+    public Enumeration<String> engineAliases() {\n+        if (aliases == null) {\n+            aliases = keyVault.getAliases();\n+        }\n+        return Collections.enumeration(aliases);\n+    }\n+\n+    @Override\n+    public boolean engineContainsAlias(String alias) {", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ2Nzk3Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510467973", "bodyText": "This is an API that has been part of Java for a long time and as such has its own documentation so no need to add code snippets here.", "author": "mnriem", "createdAt": "2020-10-22T21:27:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk1MzAzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk1MzMxNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508953314", "bodyText": "Consider throwing UnsupportedOperationException to offer a better User experience, in all the methods that do not have any logic in them.\nCurrently, user will just wonder if the operation executed successfully or not.", "author": "g2vinay", "createdAt": "2020-10-21T02:36:55Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/KeyVaultKeyStore.java", "diffHunk": "@@ -0,0 +1,325 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.security.Key;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.KeyStoreSpi;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableEntryException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.logging.Logger;\n+\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.WARNING;\n+\n+/**\n+ * The Azure KeyVault implementation of the KeyStoreSpi.\n+ */\n+public class KeyVaultKeyStore extends KeyStoreSpi {\n+\n+    /**\n+     * Stores the logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(KeyVaultKeyStore.class.getName());\n+\n+    /**\n+     * Stores the list of aliases.\n+     */\n+    private List<String> aliases;\n+\n+    /**\n+     * Stores the certificates by alias.\n+     */\n+    private final HashMap<String, Certificate> certificates = new HashMap<>();\n+\n+    /**\n+     * Stores the certificate keys by alias.\n+     */\n+    private final HashMap<String, Key> certificateKeys = new HashMap<>();\n+\n+    /**\n+     * Stores the creation date.\n+     */\n+    private final Date creationDate;\n+\n+    /**\n+     * Stores the key vault client.\n+     */\n+    private KeyVaultClient keyVault;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * <p>\n+     * The constructor uses System.getProperty for\n+     * <code>azure.keyvault.uri</code>, <code>azure.keyvault.tenantId</code>,\n+     * <code>azure.keyvault.clientId</code>,\n+     * <code>azure.keyvault.clientSecret</code> to initialize the keyvault\n+     * client.\n+     * </p>\n+     */\n+    public KeyVaultKeyStore() {\n+        creationDate = new Date();\n+        String keyVaultUri = System.getProperty(\"azure.keyvault.uri\");\n+        String tenantId = System.getProperty(\"azure.keyvault.tenantId\");\n+        String clientId = System.getProperty(\"azure.keyvault.clientId\");\n+        String clientSecret = System.getProperty(\"azure.keyvault.clientSecret\");\n+        keyVault = new KeyVaultClient(keyVaultUri, tenantId, clientId, clientSecret);\n+    }\n+\n+    @Override\n+    public Enumeration<String> engineAliases() {\n+        if (aliases == null) {\n+            aliases = keyVault.getAliases();\n+        }\n+        return Collections.enumeration(aliases);\n+    }\n+\n+    @Override\n+    public boolean engineContainsAlias(String alias) {\n+        return engineIsCertificateEntry(alias);\n+    }\n+\n+    @Override\n+    public void engineDeleteEntry(String alias) {\n+    }\n+\n+    @Override\n+    public boolean engineEntryInstanceOf(String alias, Class<? extends KeyStore.Entry> entryClass) {\n+        return super.engineEntryInstanceOf(alias, entryClass);\n+    }\n+\n+    @Override\n+    public Certificate engineGetCertificate(String alias) {\n+        Certificate certificate;\n+        if (certificates.containsKey(alias)) {\n+            certificate = certificates.get(alias);\n+        } else {\n+            certificate = keyVault.getCertificate(alias);\n+            if (certificate != null) {\n+                certificates.put(alias, certificate);\n+                if (!aliases.contains(alias)) {\n+                    aliases.add(alias);\n+                }\n+            }\n+        }\n+        return certificate;\n+    }\n+\n+    @Override\n+    public String engineGetCertificateAlias(Certificate cert) {\n+        String alias = null;\n+        if (cert != null) {\n+            if (aliases == null) {\n+                aliases = keyVault.getAliases();\n+            }\n+            for (String candidateAlias : aliases) {\n+                Certificate certificate = engineGetCertificate(candidateAlias);\n+                if (certificate.equals(cert)) {\n+                    alias = candidateAlias;\n+                    break;\n+                }\n+            }\n+        }\n+        return alias;\n+    }\n+\n+    @Override\n+    public Certificate[] engineGetCertificateChain(String alias) {\n+        Certificate[] chain = null;\n+        Certificate certificate = engineGetCertificate(alias);\n+        if (certificate != null) {\n+            chain = new Certificate[1];\n+            chain[0] = certificate;\n+        }\n+        return chain;\n+    }\n+\n+    @Override\n+    public Date engineGetCreationDate(String alias) {\n+        return creationDate;\n+    }\n+\n+    @Override\n+    public KeyStore.Entry engineGetEntry(String alias, KeyStore.ProtectionParameter protParam) throws KeyStoreException, NoSuchAlgorithmException, UnrecoverableEntryException {\n+        return super.engineGetEntry(alias, protParam);\n+    }\n+\n+    @Override\n+    public Key engineGetKey(String alias, char[] password) {\n+        Key key;\n+        if (certificateKeys.containsKey(alias)) {\n+            key = certificateKeys.get(alias);\n+        } else {\n+            key = keyVault.getKey(alias, password);\n+            if (key != null) {\n+                certificateKeys.put(alias, key);\n+                if (!aliases.contains(alias)) {\n+                    aliases.add(alias);\n+                }\n+            }\n+        }\n+        return key;\n+    }\n+\n+    @Override\n+    public boolean engineIsCertificateEntry(String alias) {\n+        if (aliases == null) {\n+            aliases = keyVault.getAliases();\n+        }\n+        return aliases.contains(alias);\n+    }\n+\n+    @Override\n+    public boolean engineIsKeyEntry(String alias) {\n+        return engineIsCertificateEntry(alias);\n+    }\n+\n+    @Override\n+    public void engineLoad(KeyStore.LoadStoreParameter param) {\n+        if (param instanceof KeyVaultLoadStoreParameter) {\n+            KeyVaultLoadStoreParameter parameter = (KeyVaultLoadStoreParameter) param;\n+            keyVault = new KeyVaultClient(\n+                parameter.getUri(),\n+                parameter.getTenantId(),\n+                parameter.getClientId(),\n+                parameter.getClientSecret());\n+        }\n+        sideLoad();\n+    }\n+\n+    @Override\n+    public void engineLoad(InputStream stream, char[] password) {\n+        sideLoad();\n+    }\n+\n+    @Override\n+    public void engineSetCertificateEntry(String alias, Certificate certificate) {\n+        if (aliases == null) {\n+            aliases = keyVault.getAliases();\n+        }\n+        if (!aliases.contains(alias)) {\n+            aliases.add(alias);\n+            certificates.put(alias, certificate);\n+        }\n+    }\n+\n+    @Override\n+    public void engineSetEntry(String alias, KeyStore.Entry entry, KeyStore.ProtectionParameter protParam) throws KeyStoreException {\n+        super.engineSetEntry(alias, entry, protParam);\n+    }\n+\n+    @Override\n+    public void engineSetKeyEntry(String alias, Key key, char[] password, Certificate[] chain) {", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE2MDQ1Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r511160452", "bodyText": "The API contract is defined by the JCA specification / JavaDoc and it does not state UnsupportedOperationException can be thrown.", "author": "mnriem", "createdAt": "2020-10-23T21:20:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODk1MzMxNA=="}], "type": "inlineReview"}, {"oid": "9011247ff09367559d9d560811805d4c59e3a735", "url": "https://github.com/Azure/azure-sdk-for-java/commit/9011247ff09367559d9d560811805d4c59e3a735", "message": "Add JCA provider for Azure KeyVault", "committedDate": "2020-09-22T23:04:36Z", "type": "commit"}, {"oid": "366021aeb4f0e0ec7b464172128d93e487de0c57", "url": "https://github.com/Azure/azure-sdk-for-java/commit/366021aeb4f0e0ec7b464172128d93e487de0c57", "message": "Added the starter", "committedDate": "2020-09-29T21:16:18Z", "type": "commit"}, {"oid": "4229ad580682118919f8e647e9cd5b9b326850c8", "url": "https://github.com/Azure/azure-sdk-for-java/commit/4229ad580682118919f8e647e9cd5b9b326850c8", "message": "Added sample", "committedDate": "2020-09-30T14:43:58Z", "type": "commit"}, {"oid": "7720e9c3a85af9ebbef866874c536482b2edadaa", "url": "https://github.com/Azure/azure-sdk-for-java/commit/7720e9c3a85af9ebbef866874c536482b2edadaa", "message": "Cleaned up sample", "committedDate": "2020-09-30T15:00:18Z", "type": "commit"}, {"oid": "f4294f9fe29522ffdd548d0e892591a2ac4e3840", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f4294f9fe29522ffdd548d0e892591a2ac4e3840", "message": "Remove unncessary deployment.yml", "committedDate": "2020-09-30T15:36:28Z", "type": "commit"}, {"oid": "49239ee2e3cb96a8d9a22e89872317abd911f1b8", "url": "https://github.com/Azure/azure-sdk-for-java/commit/49239ee2e3cb96a8d9a22e89872317abd911f1b8", "message": "Add system assigned identity support step #1", "committedDate": "2020-10-01T22:20:00Z", "type": "commit"}, {"oid": "502bd8724d382e35bf731213433c651b3f41774d", "url": "https://github.com/Azure/azure-sdk-for-java/commit/502bd8724d382e35bf731213433c651b3f41774d", "message": "Added system managed identity support for App Service", "committedDate": "2020-10-02T18:28:28Z", "type": "commit"}, {"oid": "599b7ed42da34deeee1ffa2bf86bac3a327b5f07", "url": "https://github.com/Azure/azure-sdk-for-java/commit/599b7ed42da34deeee1ffa2bf86bac3a327b5f07", "message": "Added README for JCA provider", "committedDate": "2020-10-06T17:28:35Z", "type": "commit"}, {"oid": "d8d0bc0e7fc1d3eedaadab0429ddc40a28c303aa", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d8d0bc0e7fc1d3eedaadab0429ddc40a28c303aa", "message": "Added README for JCA provider", "committedDate": "2020-10-06T17:48:49Z", "type": "commit"}, {"oid": "316bd9507b53434d22e0d7b5ca3eccdb0e87baa3", "url": "https://github.com/Azure/azure-sdk-for-java/commit/316bd9507b53434d22e0d7b5ca3eccdb0e87baa3", "message": "Add instructions to build starter", "committedDate": "2020-10-06T18:13:56Z", "type": "commit"}, {"oid": "0c0c67a5debd73cbdbda1f1e2756d35120b54536", "url": "https://github.com/Azure/azure-sdk-for-java/commit/0c0c67a5debd73cbdbda1f1e2756d35120b54536", "message": "Add instructions to build starter", "committedDate": "2020-10-06T18:17:13Z", "type": "commit"}, {"oid": "d4a5a1fb5161da287dc2fc12b9ec927ffd05b6bc", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d4a5a1fb5161da287dc2fc12b9ec927ffd05b6bc", "message": "Add instructions to build starter", "committedDate": "2020-10-06T18:20:40Z", "type": "commit"}, {"oid": "95aea0e56c3859922d4ed467093a67fb2ce55a58", "url": "https://github.com/Azure/azure-sdk-for-java/commit/95aea0e56c3859922d4ed467093a67fb2ce55a58", "message": "Add instructions to build starter", "committedDate": "2020-10-06T18:22:19Z", "type": "commit"}, {"oid": "7fc29460aedef752bbb58f6fb04363b7460e272d", "url": "https://github.com/Azure/azure-sdk-for-java/commit/7fc29460aedef752bbb58f6fb04363b7460e272d", "message": "Add instructions to build starter", "committedDate": "2020-10-06T18:25:52Z", "type": "commit"}, {"oid": "b7dcb077e3fd6a02d9525c23f7f7396bcf7dc089", "url": "https://github.com/Azure/azure-sdk-for-java/commit/b7dcb077e3fd6a02d9525c23f7f7396bcf7dc089", "message": "Minor fixes", "committedDate": "2020-10-06T19:42:48Z", "type": "commit"}, {"oid": "8da02d29665be3376b4991f8fce8afaf5012fcc8", "url": "https://github.com/Azure/azure-sdk-for-java/commit/8da02d29665be3376b4991f8fce8afaf5012fcc8", "message": "Added setDelegate", "committedDate": "2020-10-06T19:54:27Z", "type": "commit"}, {"oid": "8bece1fc97b81c3926dddee0b6d702857f92f195", "url": "https://github.com/Azure/azure-sdk-for-java/commit/8bece1fc97b81c3926dddee0b6d702857f92f195", "message": "Added logging", "committedDate": "2020-10-07T15:19:08Z", "type": "commit"}, {"oid": "0c3e63f9b7aed69b0715c82fc92bfc11adbe9731", "url": "https://github.com/Azure/azure-sdk-for-java/commit/0c3e63f9b7aed69b0715c82fc92bfc11adbe9731", "message": "Added more logging", "committedDate": "2020-10-08T14:49:14Z", "type": "commit"}, {"oid": "f0624cfffca6fc3dc78f8e6c301c55abceb1796d", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f0624cfffca6fc3dc78f8e6c301c55abceb1796d", "message": "Added more logging", "committedDate": "2020-10-08T14:49:53Z", "type": "commit"}, {"oid": "8ec0bc7df4035f2a2e71a094d89e96d4e9e966b9", "url": "https://github.com/Azure/azure-sdk-for-java/commit/8ec0bc7df4035f2a2e71a094d89e96d4e9e966b9", "message": "Added configuration for Spring Cloud gateway", "committedDate": "2020-10-08T18:02:51Z", "type": "commit"}, {"oid": "8dbd7ace724ac5d5caec744d09f27d092cb33432", "url": "https://github.com/Azure/azure-sdk-for-java/commit/8dbd7ace724ac5d5caec744d09f27d092cb33432", "message": "Added creating an Azure KeyVault section", "committedDate": "2020-10-08T18:58:48Z", "type": "commit"}, {"oid": "132ec369267fe682dd8e1e93801be79d60a74624", "url": "https://github.com/Azure/azure-sdk-for-java/commit/132ec369267fe682dd8e1e93801be79d60a74624", "message": "Add instructions to create a self-signed certificate", "committedDate": "2020-10-08T19:07:39Z", "type": "commit"}, {"oid": "bec1cf67b63b8220a3bfd9d652348f8b312e3e80", "url": "https://github.com/Azure/azure-sdk-for-java/commit/bec1cf67b63b8220a3bfd9d652348f8b312e3e80", "message": "Add 'assign a managed identity'", "committedDate": "2020-10-08T19:18:26Z", "type": "commit"}, {"oid": "da1774b8199f067e025548b80e3fd2276886cde0", "url": "https://github.com/Azure/azure-sdk-for-java/commit/da1774b8199f067e025548b80e3fd2276886cde0", "message": "Add instructions to grant a managed identity access to keyvault", "committedDate": "2020-10-08T19:29:33Z", "type": "commit"}, {"oid": "c89d604786124ea2879e8a3aa0b9acb4a5958fbc", "url": "https://github.com/Azure/azure-sdk-for-java/commit/c89d604786124ea2879e8a3aa0b9acb4a5958fbc", "message": "Add link to JCA provider", "committedDate": "2020-10-08T22:16:54Z", "type": "commit"}, {"oid": "f9d0dd5bf2640a87ba483452b4e36b5abbe86cf7", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f9d0dd5bf2640a87ba483452b4e36b5abbe86cf7", "message": "Added link to JCA reference guide", "committedDate": "2020-10-09T13:40:15Z", "type": "commit"}, {"oid": "61c8a1980e0257f294161bee33bd2e7a8473cc12", "url": "https://github.com/Azure/azure-sdk-for-java/commit/61c8a1980e0257f294161bee33bd2e7a8473cc12", "message": "Add link to our Spring Boot starter", "committedDate": "2020-10-09T14:28:48Z", "type": "commit"}, {"oid": "53316f374235c924674dfc94fd35f7a6ae31abf7", "url": "https://github.com/Azure/azure-sdk-for-java/commit/53316f374235c924674dfc94fd35f7a6ae31abf7", "message": "Make sure server.ssl.key-store and server.ssl.trust-store are set automatically when applicable", "committedDate": "2020-10-09T14:50:22Z", "type": "commit"}, {"oid": "ea2eb042c90284240b08ef87e0103faf5df6d23f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ea2eb042c90284240b08ef87e0103faf5df6d23f", "message": "Fix Spring Boot starter link", "committedDate": "2020-10-09T18:02:13Z", "type": "commit"}, {"oid": "fa393b1e2525b27252d978e1dbf31dea7cfd893e", "url": "https://github.com/Azure/azure-sdk-for-java/commit/fa393b1e2525b27252d978e1dbf31dea7cfd893e", "message": "Merge branch 'end-to-end-tls-ssl' of https://github.com/selvasingh/azure-sdk-for-java into end-to-end-tls-ssl", "committedDate": "2020-10-09T22:47:15Z", "type": "commit"}, {"oid": "716acd7f264d3e2e425a241ddaebeae7bc4a27cc", "url": "https://github.com/Azure/azure-sdk-for-java/commit/716acd7f264d3e2e425a241ddaebeae7bc4a27cc", "message": "Reworked logging", "committedDate": "2020-10-13T15:54:06Z", "type": "commit"}, {"oid": "10e00108e663c0d552fca49e59671f72aa8271f8", "url": "https://github.com/Azure/azure-sdk-for-java/commit/10e00108e663c0d552fca49e59671f72aa8271f8", "message": "Reworked logging", "committedDate": "2020-10-13T17:31:00Z", "type": "commit"}, {"oid": "736723184f7e4decd1fc25b913388ef6264fa42c", "url": "https://github.com/Azure/azure-sdk-for-java/commit/736723184f7e4decd1fc25b913388ef6264fa42c", "message": "Added certificate side-loading", "committedDate": "2020-10-13T21:10:23Z", "type": "commit"}, {"oid": "809cc3466531692f6955d3d89f2bc3fb1892d2bf", "url": "https://github.com/Azure/azure-sdk-for-java/commit/809cc3466531692f6955d3d89f2bc3fb1892d2bf", "message": "Add logging for side-loading", "committedDate": "2020-10-13T22:11:51Z", "type": "commit"}, {"oid": "8078ad456ec578264bbf81a1a6d3f4e80925fb0d", "url": "https://github.com/Azure/azure-sdk-for-java/commit/8078ad456ec578264bbf81a1a6d3f4e80925fb0d", "message": "Add logging for side-loading", "committedDate": "2020-10-13T22:12:27Z", "type": "commit"}, {"oid": "99b94da5cf85ffd29bf5d5cb4d94c976fc9758b0", "url": "https://github.com/Azure/azure-sdk-for-java/commit/99b94da5cf85ffd29bf5d5cb4d94c976fc9758b0", "message": "Add README content for side-loading", "committedDate": "2020-10-14T14:54:23Z", "type": "commit"}, {"oid": "653933b8e01ef4265ce57a0939249668d3d17b22", "url": "https://github.com/Azure/azure-sdk-for-java/commit/653933b8e01ef4265ce57a0939249668d3d17b22", "message": "Add README content for side-loading", "committedDate": "2020-10-14T14:55:00Z", "type": "commit"}, {"oid": "d7f1606d509ea93217fd9251f1d8eaf06fef5991", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d7f1606d509ea93217fd9251f1d8eaf06fef5991", "message": "Add statement what to do when Spring Cloud Config server is in the mix", "committedDate": "2020-10-14T15:02:17Z", "type": "commit"}, {"oid": "fff173c1817341086e9296f32984cc1e4e339340", "url": "https://github.com/Azure/azure-sdk-for-java/commit/fff173c1817341086e9296f32984cc1e4e339340", "message": "Add logging of KeyVault URI", "committedDate": "2020-10-14T15:47:22Z", "type": "commit"}, {"oid": "bbfdc10a9665cee9814efa222504ad4c4ccadf38", "url": "https://github.com/Azure/azure-sdk-for-java/commit/bbfdc10a9665cee9814efa222504ad4c4ccadf38", "message": "Programmatically determine whether or not using Tomcat", "committedDate": "2020-10-14T17:04:20Z", "type": "commit"}, {"oid": "f8ee1b0c5e015e3267d162f199dfbb8ba8c8d7ef", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f8ee1b0c5e015e3267d162f199dfbb8ba8c8d7ef", "message": "Added KeyVault TrustManagerFactory", "committedDate": "2020-10-15T16:29:24Z", "type": "commit"}, {"oid": "ebccc65463839ce622cb27b6b88692469c1d6ccc", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ebccc65463839ce622cb27b6b88692469c1d6ccc", "message": "Added KeyVault TrustManagerFactory", "committedDate": "2020-10-15T16:30:08Z", "type": "commit"}, {"oid": "4391b3ec64410ccddd74779dfc81d05d38b4fac5", "url": "https://github.com/Azure/azure-sdk-for-java/commit/4391b3ec64410ccddd74779dfc81d05d38b4fac5", "message": "Updated groupId", "committedDate": "2020-10-16T14:04:29Z", "type": "commit"}, {"oid": "afb7883fc4361dacd9645e215e73f6307c38af99", "url": "https://github.com/Azure/azure-sdk-for-java/commit/afb7883fc4361dacd9645e215e73f6307c38af99", "message": "Updated artificatId", "committedDate": "2020-10-16T14:12:05Z", "type": "commit"}, {"oid": "a96ae4dbbbc3066d8c96ea8f2e3fd403f684db55", "url": "https://github.com/Azure/azure-sdk-for-java/commit/a96ae4dbbbc3066d8c96ea8f2e3fd403f684db55", "message": "Updated package names", "committedDate": "2020-10-16T14:59:16Z", "type": "commit"}, {"oid": "abbf13d267850b92ec9ac55b5deb780c86bc8ccf", "url": "https://github.com/Azure/azure-sdk-for-java/commit/abbf13d267850b92ec9ac55b5deb780c86bc8ccf", "message": "Add KeyVault URI to Spring Cloud Gateway snippet", "committedDate": "2020-10-16T15:01:58Z", "type": "commit"}, {"oid": "73f25b2f5a45cc00b6173540e153fa6489c5e524", "url": "https://github.com/Azure/azure-sdk-for-java/commit/73f25b2f5a45cc00b6173540e153fa6489c5e524", "message": "Allow for disabling hostname verification", "committedDate": "2020-10-16T15:36:14Z", "type": "commit"}, {"oid": "4d9d1eeab3406126bafbcc78506968a4690b2b94", "url": "https://github.com/Azure/azure-sdk-for-java/commit/4d9d1eeab3406126bafbcc78506968a4690b2b94", "message": "Change properties to include JCA 'namespace' in it", "committedDate": "2020-10-16T18:36:00Z", "type": "commit"}, {"oid": "0da1ecc9862afa4706d2549d6976d3a27a916827", "url": "https://github.com/Azure/azure-sdk-for-java/commit/0da1ecc9862afa4706d2549d6976d3a27a916827", "message": "Add core principles", "committedDate": "2020-10-16T22:13:52Z", "type": "commit"}, {"oid": "414a7fbd0939e0efadbf2a12814784c10f1b44b3", "url": "https://github.com/Azure/azure-sdk-for-java/commit/414a7fbd0939e0efadbf2a12814784c10f1b44b3", "message": "Add core principles", "committedDate": "2020-10-16T22:17:39Z", "type": "commit"}, {"oid": "221f65589ca731572e20d82b8a28bbace277dfb4", "url": "https://github.com/Azure/azure-sdk-for-java/commit/221f65589ca731572e20d82b8a28bbace277dfb4", "message": "Add core principles", "committedDate": "2020-10-16T22:19:49Z", "type": "commit"}, {"oid": "70bab18e1cb98e7b7fba897738c66b7b8d876316", "url": "https://github.com/Azure/azure-sdk-for-java/commit/70bab18e1cb98e7b7fba897738c66b7b8d876316", "message": "Minor renaming of project to reflect it is a JCA provider for Azure Key Vault", "committedDate": "2020-10-16T22:22:35Z", "type": "commit"}, {"oid": "026d3860ae20ddd1e11008994958f9eee1c4ca67", "url": "https://github.com/Azure/azure-sdk-for-java/commit/026d3860ae20ddd1e11008994958f9eee1c4ca67", "message": "No logic change, just format xml file.", "committedDate": "2020-10-19T02:42:41Z", "type": "commit"}, {"oid": "92fec34e2939b7cc91535926abaafde1cd007678", "url": "https://github.com/Azure/azure-sdk-for-java/commit/92fec34e2939b7cc91535926abaafde1cd007678", "message": "Fix error reported by pom_file_version_scanner.ps1.", "committedDate": "2020-10-19T02:49:20Z", "type": "commit"}, {"oid": "309bb8e0c16bae9f5af710dd1b61ee36fc817216", "url": "https://github.com/Azure/azure-sdk-for-java/commit/309bb8e0c16bae9f5af710dd1b61ee36fc817216", "message": "Format file in sdk/spring/azure-spring-boot-starter-keyvault-certificates.", "committedDate": "2020-10-19T02:54:51Z", "type": "commit"}, {"oid": "309af4f8590c4af6b226b7ec3f106f9f209e6815", "url": "https://github.com/Azure/azure-sdk-for-java/commit/309af4f8590c4af6b226b7ec3f106f9f209e6815", "message": "Format files in sdk/keyvault/azure-security-keyvault-jca.", "committedDate": "2020-10-19T02:58:21Z", "type": "commit"}, {"oid": "ecfe01d1a1da565478a23c2b26791c40b59395e1", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ecfe01d1a1da565478a23c2b26791c40b59395e1", "message": "Format files in sdk/spring/azure-spring-boot-samples/azure-spring-boot-sample-keyvault-certificates.", "committedDate": "2020-10-19T03:00:01Z", "type": "commit"}, {"oid": "8653364c9cad4f6aa791aad7e35be049e2a30d48", "url": "https://github.com/Azure/azure-sdk-for-java/commit/8653364c9cad4f6aa791aad7e35be049e2a30d48", "message": "Change groupId from com.azure.spring to com.azure.", "committedDate": "2020-10-19T03:08:06Z", "type": "commit"}, {"oid": "851ae2009ac021db319c479e7e83c7b53fdadef1", "url": "https://github.com/Azure/azure-sdk-for-java/commit/851ae2009ac021db319c479e7e83c7b53fdadef1", "message": "Add new projects in to root pom modules.", "committedDate": "2020-10-19T05:10:51Z", "type": "commit"}, {"oid": "d52fe29e958e33ce2caba2bbbc9d6f94bf0d6d34", "url": "https://github.com/Azure/azure-sdk-for-java/commit/d52fe29e958e33ce2caba2bbbc9d6f94bf0d6d34", "message": "Merge branch 'master' into end-to-end-tls-ssl", "committedDate": "2020-10-19T05:15:24Z", "type": "commit"}, {"oid": "5870ffebe39af980da2c5a838fb400c1c6283807", "url": "https://github.com/Azure/azure-sdk-for-java/commit/5870ffebe39af980da2c5a838fb400c1c6283807", "message": "Update CHANGELOG.md and README.md.", "committedDate": "2020-10-19T05:24:36Z", "type": "commit"}, {"oid": "539e5df91c0003b48979ade0b328a987a438cfd4", "url": "https://github.com/Azure/azure-sdk-for-java/commit/539e5df91c0003b48979ade0b328a987a438cfd4", "message": "Add version tag in azure-security-keyvault-jca\\pom.xml.", "committedDate": "2020-10-19T05:36:33Z", "type": "commit"}, {"oid": "dc057a08e09f65a821606d45673eb53ddea88a14", "url": "https://github.com/Azure/azure-sdk-for-java/commit/dc057a08e09f65a821606d45673eb53ddea88a14", "message": "No logic change, just make code easier to read.", "committedDate": "2020-10-19T06:04:41Z", "type": "commit"}, {"oid": "274b2ed08b5ad881c1316b2c2893a5798b0b3d9d", "url": "https://github.com/Azure/azure-sdk-for-java/commit/274b2ed08b5ad881c1316b2c2893a5798b0b3d9d", "message": "No logic change, just make code easier to read.", "committedDate": "2020-10-19T06:51:13Z", "type": "commit"}, {"oid": "4d6a973b6bdcc9c6030068ed47245ef37f53aaa4", "url": "https://github.com/Azure/azure-sdk-for-java/commit/4d6a973b6bdcc9c6030068ed47245ef37f53aaa4", "message": "No logic change, just make code easier to read.", "committedDate": "2020-10-19T07:05:22Z", "type": "commit"}, {"oid": "4f0dbadd0ac19c90191332f04154357deb48445a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/4f0dbadd0ac19c90191332f04154357deb48445a", "message": "No logic change, just make code easier to read.", "committedDate": "2020-10-19T07:11:19Z", "type": "commit"}, {"oid": "67bdb82b6e1c35ebb0d6f8359444e552310913d4", "url": "https://github.com/Azure/azure-sdk-for-java/commit/67bdb82b6e1c35ebb0d6f8359444e552310913d4", "message": "No logic change, just make code easier to read.", "committedDate": "2020-10-19T07:32:58Z", "type": "commit"}, {"oid": "bdd4047ed6747eb8bfb09cc20fe4fd416a7e3d90", "url": "https://github.com/Azure/azure-sdk-for-java/commit/bdd4047ed6747eb8bfb09cc20fe4fd416a7e3d90", "message": "Delete unused files.", "committedDate": "2020-10-19T07:38:13Z", "type": "commit"}, {"oid": "6867d33121ae8521811d5e081af1ce892e10f98b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/6867d33121ae8521811d5e081af1ce892e10f98b", "message": "No logic change.", "committedDate": "2020-10-19T07:42:19Z", "type": "commit"}, {"oid": "8a2ab04a2ae4432597ed21e459610498456b0078", "url": "https://github.com/Azure/azure-sdk-for-java/commit/8a2ab04a2ae4432597ed21e459610498456b0078", "message": "Update release version and current version of 'azure-spring-boot-starter-keyvault-certificates'.", "committedDate": "2020-10-19T07:46:06Z", "type": "commit"}, {"oid": "3f8c15216655c55fa1f62f70fb7d1765c93e4d9a", "url": "https://github.com/Azure/azure-sdk-for-java/commit/3f8c15216655c55fa1f62f70fb7d1765c93e4d9a", "message": "Update README.md.", "committedDate": "2020-10-19T07:52:43Z", "type": "commit"}, {"oid": "74306ece6b01047ec828e3d51307a5751e7d2085", "url": "https://github.com/Azure/azure-sdk-for-java/commit/74306ece6b01047ec828e3d51307a5751e7d2085", "message": "1. Set azure-security-keyvault-jca's version to 1.0.0-beta.1.\n2. Set parent for azure-spring-boot-starter-keyvault-certificates.", "committedDate": "2020-10-19T08:04:58Z", "type": "commit"}, {"oid": "039d92ca5049fb1bd017bd49c05a8500febac1ae", "url": "https://github.com/Azure/azure-sdk-for-java/commit/039d92ca5049fb1bd017bd49c05a8500febac1ae", "message": "No logic change.", "committedDate": "2020-10-19T08:19:20Z", "type": "commit"}, {"oid": "4c3a3a758fef1e3ed30aeb8ef03c4c30f5caf775", "url": "https://github.com/Azure/azure-sdk-for-java/commit/4c3a3a758fef1e3ed30aeb8ef03c4c30f5caf775", "message": "Change azure-spring-boot-sample-keyvault-certificates's groupId to com.azure.spring.", "committedDate": "2020-10-19T08:27:59Z", "type": "commit"}, {"oid": "eee1baf9fa320e0be8a446f34b243bc04a07b959", "url": "https://github.com/Azure/azure-sdk-for-java/commit/eee1baf9fa320e0be8a446f34b243bc04a07b959", "message": "Skip maven-surefire-plugin by default.", "committedDate": "2020-10-19T09:10:57Z", "type": "commit"}, {"oid": "f1568c2d0d1f1daf05d335f08386247045fef5c0", "url": "https://github.com/Azure/azure-sdk-for-java/commit/f1568c2d0d1f1daf05d335f08386247045fef5c0", "message": "Change azure-spring-boot-starter-keyvault-certificates's version to 3.0.0-beta.1.", "committedDate": "2020-10-19T09:20:59Z", "type": "commit"}, {"oid": "625c50f879815abbdfca356acd5201ec9f1816df", "url": "https://github.com/Azure/azure-sdk-for-java/commit/625c50f879815abbdfca356acd5201ec9f1816df", "message": "Fix groupId error about httpclient5.", "committedDate": "2020-10-19T09:23:05Z", "type": "commit"}, {"oid": "5c90b80bd17690bf00c0e525497bdb47ad3d3914", "url": "https://github.com/Azure/azure-sdk-for-java/commit/5c90b80bd17690bf00c0e525497bdb47ad3d3914", "message": "Changes to accomodate X509ExtendedTrustManager", "committedDate": "2020-10-19T15:35:09Z", "type": "commit"}, {"oid": "767c6624aaae2225c21c14e1eae3ef80174a9e4b", "url": "https://github.com/Azure/azure-sdk-for-java/commit/767c6624aaae2225c21c14e1eae3ef80174a9e4b", "message": "Restore Dockerfile", "committedDate": "2020-10-19T18:24:50Z", "type": "commit"}, {"oid": "ee6952d0682aab298dc39603928769585cc12f8f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ee6952d0682aab298dc39603928769585cc12f8f", "message": "Comment out links for now", "committedDate": "2020-10-19T18:37:14Z", "type": "commit"}, {"oid": "30df750f99d01ac9f452da23d91c052f25ce5973", "url": "https://github.com/Azure/azure-sdk-for-java/commit/30df750f99d01ac9f452da23d91c052f25ce5973", "message": "Add package-info for the starter", "committedDate": "2020-10-19T19:07:43Z", "type": "commit"}, {"oid": "41ada7f7d7262c81206d610096e4099dc3e41f6f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/41ada7f7d7262c81206d610096e4099dc3e41f6f", "message": "Add parent POMs back to see what else fails", "committedDate": "2020-10-19T19:37:06Z", "type": "commit"}, {"oid": "5198b86c28c4cbc2c64bdef453a93cc5f56b4816", "url": "https://github.com/Azure/azure-sdk-for-java/commit/5198b86c28c4cbc2c64bdef453a93cc5f56b4816", "message": "Updates for pipeline", "committedDate": "2020-10-19T20:11:54Z", "type": "commit"}, {"oid": "2438787c2456ffc5906e4b9378aa75bd55a64bbb", "url": "https://github.com/Azure/azure-sdk-for-java/commit/2438787c2456ffc5906e4b9378aa75bd55a64bbb", "message": "Updates for pipeline", "committedDate": "2020-10-19T20:23:08Z", "type": "commit"}, {"oid": "5dc3b16b885c130e6b098e492116f9b9d6674484", "url": "https://github.com/Azure/azure-sdk-for-java/commit/5dc3b16b885c130e6b098e492116f9b9d6674484", "message": "Allow for given dependencies", "committedDate": "2020-10-19T20:39:12Z", "type": "commit"}, {"oid": "da408a1c2c78fb9667a814e30a9885c2e51648ce", "url": "https://github.com/Azure/azure-sdk-for-java/commit/da408a1c2c78fb9667a814e30a9885c2e51648ce", "message": "Make build pass", "committedDate": "2020-10-19T20:56:33Z", "type": "commit"}, {"oid": "df48b766baea0d99551b1d5e5ff4c5e06a028239", "url": "https://github.com/Azure/azure-sdk-for-java/commit/df48b766baea0d99551b1d5e5ff4c5e06a028239", "message": "Make build pass", "committedDate": "2020-10-19T21:00:05Z", "type": "commit"}, {"oid": "51e9ada11f3d681fcab735668287190d97f9f6ab", "url": "https://github.com/Azure/azure-sdk-for-java/commit/51e9ada11f3d681fcab735668287190d97f9f6ab", "message": "Make build pass", "committedDate": "2020-10-19T21:11:20Z", "type": "commit"}, {"oid": "966ba73d5e3e451611fc8a349295115855a93789", "url": "https://github.com/Azure/azure-sdk-for-java/commit/966ba73d5e3e451611fc8a349295115855a93789", "message": "Make build pass", "committedDate": "2020-10-19T21:31:04Z", "type": "commit"}, {"oid": "75e41868e86a84b401914d778e6c54e8c6d19c29", "url": "https://github.com/Azure/azure-sdk-for-java/commit/75e41868e86a84b401914d778e6c54e8c6d19c29", "message": "Make build pass", "committedDate": "2020-10-19T21:39:41Z", "type": "commit"}, {"oid": "22916a83b3adf58ca85e43fac5dabb01b489e1d2", "url": "https://github.com/Azure/azure-sdk-for-java/commit/22916a83b3adf58ca85e43fac5dabb01b489e1d2", "message": "Make build pass", "committedDate": "2020-10-19T21:48:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE0OTgxNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508149816", "bodyText": "We don't include author tags in our JavaDoc.", "author": "JonathanGiles", "createdAt": "2020-10-20T01:11:24Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/AuthClient.java", "diffHunk": "@@ -0,0 +1,184 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import com.azure.security.keyvault.jca.rest.OAuthToken;\n+\n+import java.util.HashMap;\n+import java.util.logging.Logger;\n+\n+import static java.util.logging.Level.FINER;\n+\n+/**\n+ * The REST client specific to getting an access token for Azure REST APIs.\n+ *\n+ * @author Manfred Riem (manfred.riem@microsoft.com)", "originalCommit": "22916a83b3adf58ca85e43fac5dabb01b489e1d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE2NDIyMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508164223", "bodyText": "I will address this", "author": "mnriem", "createdAt": "2020-10-20T02:04:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE0OTgxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE1MDQwMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508150401", "bodyText": "It looks like elsewhere you have a dependency on slf4j - it would be good to standardise on that (which is also what the azure SDKs have standardised on).", "author": "JonathanGiles", "createdAt": "2020-10-20T01:13:36Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/AuthClient.java", "diffHunk": "@@ -0,0 +1,184 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import com.azure.security.keyvault.jca.rest.OAuthToken;\n+\n+import java.util.HashMap;\n+import java.util.logging.Logger;\n+\n+import static java.util.logging.Level.FINER;", "originalCommit": "22916a83b3adf58ca85e43fac5dabb01b489e1d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE2NDg2OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508164869", "bodyText": "As the JAR is self-contained it is not relying on SLF4J for its logging. Even though Jackson is pulling it in as a dependency it is not used for logging by the JCA provider itself.", "author": "mnriem", "createdAt": "2020-10-20T02:06:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODE1MDQwMQ=="}], "type": "inlineReview"}, {"oid": "ea0d71be65833cabbe6aabb96f5a4988d30c3ada", "url": "https://github.com/Azure/azure-sdk-for-java/commit/ea0d71be65833cabbe6aabb96f5a4988d30c3ada", "message": "Add 2 new artifact into ci.yml.", "committedDate": "2020-10-20T02:32:41Z", "type": "commit"}, {"oid": "01a56131b1edde280cd7ec6ea9aa6ee8ab4db60f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/01a56131b1edde280cd7ec6ea9aa6ee8ab4db60f", "message": "Fix error in pipeline.", "committedDate": "2020-10-20T02:42:26Z", "type": "commit"}, {"oid": "59b9585bd9ca4de1246d417961916376e3bf226f", "url": "https://github.com/Azure/azure-sdk-for-java/commit/59b9585bd9ca4de1246d417961916376e3bf226f", "message": "Removed @author", "committedDate": "2020-10-20T12:26:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgwNzI4Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508807286", "bodyText": "Is this intended to work against clouds other than Azure Public Cloud? If so this would need to be configurable.", "author": "schaabs", "createdAt": "2020-10-20T20:09:39Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/AuthClient.java", "diffHunk": "@@ -0,0 +1,182 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import com.azure.security.keyvault.jca.rest.OAuthToken;\n+\n+import java.util.HashMap;\n+import java.util.logging.Logger;\n+\n+import static java.util.logging.Level.FINER;\n+\n+/**\n+ * The REST client specific to getting an access token for Azure REST APIs.\n+ */\n+class AuthClient extends DelegateRestClient {\n+\n+    /**\n+     * Stores the Client ID fragment.\n+     */\n+    private static final String CLIENT_ID_FRAGMENT = \"&client_id=\";\n+\n+    /**\n+     * Stores the Client Secret fragment.\n+     */\n+    private static final String CLIENT_SECRET_FRAGMENT = \"&client_secret=\";\n+\n+    /**\n+     * Stores the Grant Type fragment.\n+     */\n+    private static final String GRANT_TYPE_FRAGMENT = \"grant_type=client_credentials\";\n+\n+    /**\n+     * Stores the Resource fragment.\n+     */\n+    private static final String RESOURCE_FRAGMENT = \"&resource=\";\n+\n+    /**\n+     * Stores the OAuth2 token base URL.\n+     */\n+    private static final String OAUTH2_TOKEN_BASE_URL = \"https://login.microsoftonline.com/\";", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgxMzAxNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508813017", "bodyText": "Certificates downloaded from Key Vault through the get secret API might be in PKCS12 or PEM format. These can be differentiated by the by the contentType of the secret bundle.", "author": "schaabs", "createdAt": "2020-10-20T20:20:29Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/KeyVaultClient.java", "diffHunk": "@@ -0,0 +1,244 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import com.azure.security.keyvault.jca.rest.CertificateBundle;\n+import com.azure.security.keyvault.jca.rest.CertificateItem;\n+import com.azure.security.keyvault.jca.rest.CertificateListResult;\n+import com.azure.security.keyvault.jca.rest.CertificatePolicy;\n+import com.azure.security.keyvault.jca.rest.KeyProperties;\n+import com.azure.security.keyvault.jca.rest.SecretBundle;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.security.Key;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.logging.Logger;\n+\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.WARNING;\n+\n+/**\n+ * The REST client specific to Azure KeyVault.\n+ */\n+class KeyVaultClient extends DelegateRestClient {\n+\n+    /**\n+     * Stores the logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(KeyVaultClient.class.getName());\n+\n+    /**\n+     * Stores the API version postfix.\n+     */\n+    private static final String API_VERSION_POSTFIX = \"?api-version=7.1\";\n+\n+    /**\n+     * Stores the KeyVault URI.\n+     */\n+    private final String keyVaultUri;\n+\n+    /**\n+     * Stores the tenant ID.\n+     */\n+    private String tenantId;\n+\n+    /**\n+     * Stores the client ID.\n+     */\n+    private String clientId;\n+\n+    /**\n+     * Stores the client secret.\n+     */\n+    private String clientSecret;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param keyVaultUri the KeyVault URI.\n+     */\n+    KeyVaultClient(String keyVaultUri) {\n+        super(RestClientFactory.createClient());\n+        LOGGER.log(INFO, \"Using KeyVault: {0}\", keyVaultUri);\n+        if (!keyVaultUri.endsWith(\"/\")) {\n+            keyVaultUri = keyVaultUri + \"/\";\n+        }\n+        this.keyVaultUri = keyVaultUri;\n+    }\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param keyVaultUri the KeyVault URI.\n+     * @param tenantId the tenant ID.\n+     * @param clientId the client ID.\n+     * @param clientSecret the client secret.\n+     */\n+    KeyVaultClient(final String keyVaultUri, final String tenantId, final String clientId, final String clientSecret) {\n+        this(keyVaultUri);\n+        this.tenantId = tenantId;\n+        this.clientId = clientId;\n+        this.clientSecret = clientSecret;\n+    }\n+\n+    /**\n+     * Get the access token.\n+     *\n+     * @return the access token.\n+     */\n+    private String getAccessToken() {\n+        LOGGER.entering(\"KeyVaultClient\", \"getAccessToken\");\n+        String accessToken = null;\n+        try {\n+            AuthClient authClient = new AuthClient();\n+            String resource = URLEncoder.encode(\"https://vault.azure.net\", \"UTF-8\");\n+            if (tenantId != null && clientId != null && clientSecret != null) {\n+                accessToken = authClient.getAccessToken(resource, tenantId, clientId, clientSecret);\n+            } else {\n+                accessToken = authClient.getAccessToken(resource);\n+            }\n+        } catch (UnsupportedEncodingException uee) {\n+            LOGGER.log(WARNING, \"Unsupported encoding\", uee);\n+        }\n+        LOGGER.exiting(\"KeyVaultClient\", \"getAccessToken\", accessToken);\n+        return accessToken;\n+    }\n+\n+    /**\n+     * Get the list of aliases.\n+     *\n+     * @return the list of aliases.\n+     */\n+    public List<String> getAliases() {\n+        ArrayList<String> result = new ArrayList<>();\n+        HashMap<String, String> headers = new HashMap<>();\n+        headers.put(\"Authorization\", \"Bearer \" + getAccessToken());\n+        String url = String.format(\"%scertificates%s\", keyVaultUri, API_VERSION_POSTFIX);\n+        String response = get(url, headers);\n+        CertificateListResult certificateListResult = null;\n+        if (response != null) {\n+            JsonConverter converter = JsonConverterFactory.createJsonConverter();\n+            certificateListResult = (CertificateListResult) converter.fromJson(response, CertificateListResult.class);\n+        }\n+        if (certificateListResult != null && certificateListResult.getValue().size() > 0) {\n+            for (CertificateItem certificateItem : certificateListResult.getValue()) {\n+                String id = certificateItem.getId();\n+                String alias = id.substring(id.indexOf(\"certificates\") + \"certificates\".length() + 1);\n+                result.add(alias);\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Get the certificate bundle.\n+     *\n+     * @param alias the alias.\n+     * @return the certificate bundle.\n+     */\n+    private CertificateBundle getCertificateBundle(String alias) {\n+        CertificateBundle result = null;\n+        HashMap<String, String> headers = new HashMap<>();\n+        headers.put(\"Authorization\", \"Bearer \" + getAccessToken());\n+        String url = String.format(\"%scertificates/%s%s\", keyVaultUri, alias, API_VERSION_POSTFIX);\n+        String response = get(url, headers);\n+        if (response != null) {\n+            JsonConverter converter = JsonConverterFactory.createJsonConverter();\n+            result = (CertificateBundle) converter.fromJson(response, CertificateBundle.class);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Get the certificate.\n+     *\n+     * @param alias the alias.\n+     * @return the certificate, or null if not found.\n+     */\n+    public Certificate getCertificate(String alias) {\n+        LOGGER.entering(\"KeyVaultClient\", \"getCertificate\", alias);\n+        LOGGER.log(INFO, \"Getting certificate for alias: {0}\", alias);\n+        X509Certificate certificate = null;\n+        CertificateBundle certificateBundle = getCertificateBundle(alias);\n+        if (certificateBundle != null) {\n+            String certificateString = certificateBundle.getCer();\n+            if (certificateString != null) {\n+                try {\n+                    CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n+                    certificate = (X509Certificate) cf.generateCertificate(\n+                        new ByteArrayInputStream(Base64.getDecoder().decode(certificateBundle.getCer()))\n+                    );\n+                } catch (CertificateException ce) {\n+                    LOGGER.log(WARNING, \"Certificate error\", ce);\n+                }\n+            }\n+        }\n+        LOGGER.exiting(\"KeyVaultClient\", \"getCertificate\", certificate);\n+        return certificate;\n+    }\n+\n+    /**\n+     * Get the key.\n+     *\n+     * @param alias the alias.\n+     * @param password the password.\n+     * @return the key.\n+     */\n+    public Key getKey(String alias, char[] password) {\n+        LOGGER.entering(\"KeyVaultClient\", \"getKey\", new Object[] { alias, password });\n+        LOGGER.log(INFO, \"Getting key for alias: {0}\", alias);\n+        Key key = null;\n+        CertificateBundle certificateBundle = getCertificateBundle(alias);\n+        boolean isExportable = Optional.ofNullable(certificateBundle)\n+                                       .map(CertificateBundle::getPolicy)\n+                                       .map(CertificatePolicy::getKey_props)\n+                                       .map(KeyProperties::isExportable)\n+                                       .orElse(false);\n+        if (isExportable) {\n+            // Because the certificate is exportable the private key is\n+            // available. So we'll use the KeyVault Secrets API to get the \n+            // private key.\n+            String certificateSecretUri = certificateBundle.getSid();\n+            HashMap<String, String> headers = new HashMap<>();\n+            headers.put(\"Authorization\", \"Bearer \" + getAccessToken());\n+            String body = get(certificateSecretUri + API_VERSION_POSTFIX, headers);\n+            if (body != null) {\n+                JsonConverter converter = JsonConverterFactory.createJsonConverter();\n+                SecretBundle secretBundle = (SecretBundle) converter.fromJson(body, SecretBundle.class);\n+                try {\n+                    KeyStore keyStore = KeyStore.getInstance(\"PKCS12\");", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgxODE2Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508818162", "bodyText": "I believe the resource string will need to be url encoded no?", "author": "schaabs", "createdAt": "2020-10-20T20:28:13Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/AuthClient.java", "diffHunk": "@@ -0,0 +1,182 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import com.azure.security.keyvault.jca.rest.OAuthToken;\n+\n+import java.util.HashMap;\n+import java.util.logging.Logger;\n+\n+import static java.util.logging.Level.FINER;\n+\n+/**\n+ * The REST client specific to getting an access token for Azure REST APIs.\n+ */\n+class AuthClient extends DelegateRestClient {\n+\n+    /**\n+     * Stores the Client ID fragment.\n+     */\n+    private static final String CLIENT_ID_FRAGMENT = \"&client_id=\";\n+\n+    /**\n+     * Stores the Client Secret fragment.\n+     */\n+    private static final String CLIENT_SECRET_FRAGMENT = \"&client_secret=\";\n+\n+    /**\n+     * Stores the Grant Type fragment.\n+     */\n+    private static final String GRANT_TYPE_FRAGMENT = \"grant_type=client_credentials\";\n+\n+    /**\n+     * Stores the Resource fragment.\n+     */\n+    private static final String RESOURCE_FRAGMENT = \"&resource=\";\n+\n+    /**\n+     * Stores the OAuth2 token base URL.\n+     */\n+    private static final String OAUTH2_TOKEN_BASE_URL = \"https://login.microsoftonline.com/\";\n+\n+    /**\n+     * Stores the OAuth2 token postfix.\n+     */\n+    private static final String OAUTH2_TOKEN_POSTFIX = \"/oauth2/token\";\n+\n+    /**\n+     * Stores the OAuth2 managed identity URL.\n+     */\n+    private static final String OAUTH2_MANAGED_IDENTITY_TOKEN_URL\n+        = \"http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01\";\n+\n+    /**\n+     * Stores our logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(AuthClient.class.getName());\n+\n+    /**\n+     * Constructor.\n+     *\n+     * <p>\n+     * The constructor creates a default RestClient.\n+     * </p>\n+     */\n+    AuthClient() {\n+        super(RestClientFactory.createClient());\n+    }\n+\n+    /**\n+     * Get an access token for a managed identity.\n+     *\n+     * @param resource the resource.\n+     * @return the authorization token.\n+     */\n+    public String getAccessToken(String resource) {\n+        String result;\n+\n+        if (System.getenv(\"WEBSITE_SITE_NAME\") != null\n+            && !System.getenv(\"WEBSITE_SITE_NAME\").isEmpty()) {\n+            result = getAccessTokenOnAppService(resource);\n+        } else {\n+            result = getAccessTokenOnOthers(resource);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Get an access token.\n+     *\n+     * @param resource the resource.\n+     * @param tenantId the tenant ID.\n+     * @param clientId the client ID.\n+     * @param clientSecret the client secret.\n+     * @return the authorization token.\n+     */\n+    public String getAccessToken(String resource, String tenantId,\n+                                 String clientId, String clientSecret) {\n+        LOGGER.entering(\"AuthClient\", \"getAccessToken\", new Object[] {\n+            resource, tenantId, clientId, clientSecret });\n+        LOGGER.info(\"Getting access token using client ID / client secret\");\n+        String result = null;\n+\n+        StringBuilder oauth2Url = new StringBuilder();\n+        oauth2Url.append(OAUTH2_TOKEN_BASE_URL)\n+                 .append(tenantId)\n+                 .append(OAUTH2_TOKEN_POSTFIX);\n+\n+        StringBuilder requestBody = new StringBuilder();\n+        requestBody.append(GRANT_TYPE_FRAGMENT)\n+                   .append(CLIENT_ID_FRAGMENT).append(clientId)\n+                   .append(CLIENT_SECRET_FRAGMENT).append(clientSecret)\n+                   .append(RESOURCE_FRAGMENT).append(resource);\n+\n+        String body = post(oauth2Url.toString(), requestBody.toString(), \"application/x-www-form-urlencoded\");\n+        if (body != null) {\n+            JsonConverter converter = JsonConverterFactory.createJsonConverter();\n+            OAuthToken token = (OAuthToken) converter.fromJson(body, OAuthToken.class);\n+            result = token.getAccess_token();\n+        }\n+        LOGGER.log(FINER, \"Access token: {0}\", result);\n+        return result;\n+    }\n+\n+    /**\n+     * Get the access token on Azure App Service.\n+     *\n+     * @param resource the resource.\n+     * @return the authorization token.\n+     */\n+    private String getAccessTokenOnAppService(String resource) {\n+        LOGGER.entering(\"AuthClient\", \"getAccessTokenOnAppService\", resource);\n+        LOGGER.info(\"Getting access token using managed identity based on MSI_SECRET\");\n+        String result = null;\n+\n+        StringBuilder url = new StringBuilder();\n+        url.append(System.getenv(\"MSI_ENDPOINT\"))\n+           .append(\"?api-version=2017-09-01\")\n+           .append(RESOURCE_FRAGMENT).append(resource);\n+\n+        HashMap<String, String> headers = new HashMap<>();\n+        headers.put(\"Metadata\", \"true\");\n+        headers.put(\"Secret\", System.getenv(\"MSI_SECRET\"));\n+        String body = get(url.toString(), headers);\n+\n+        if (body != null) {\n+            JsonConverter converter = JsonConverterFactory.createJsonConverter();\n+            OAuthToken token = (OAuthToken) converter.fromJson(body, OAuthToken.class);\n+            result = token.getAccess_token();\n+        }\n+        LOGGER.exiting(\"AuthClient\", \"getAccessTokenOnAppService\", result);\n+        return result;\n+    }\n+\n+    /**\n+     * Get the authorization token on everything else but Azure App Service.\n+     *\n+     * @param resource the resource.\n+     * @return the authorization token.\n+     */\n+    private String getAccessTokenOnOthers(String resource) {\n+        LOGGER.entering(\"AuthClient\", \"getAccessTokenOnOthers\", resource);\n+        LOGGER.info(\"Getting access token using managed identity\");\n+        String result = null;\n+\n+        StringBuilder url = new StringBuilder();\n+        url.append(OAUTH2_MANAGED_IDENTITY_TOKEN_URL)\n+           .append(RESOURCE_FRAGMENT).append(resource);", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM4NDM2Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510384363", "bodyText": "The KeyVaultClient code passes in a url encoded version so nothing further needs to be done", "author": "mnriem", "createdAt": "2020-10-22T18:51:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgxODE2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgxODQ4NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508818484", "bodyText": "I believe the resource string will need to be url encoded no?", "author": "schaabs", "createdAt": "2020-10-20T20:28:52Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/AuthClient.java", "diffHunk": "@@ -0,0 +1,182 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import com.azure.security.keyvault.jca.rest.OAuthToken;\n+\n+import java.util.HashMap;\n+import java.util.logging.Logger;\n+\n+import static java.util.logging.Level.FINER;\n+\n+/**\n+ * The REST client specific to getting an access token for Azure REST APIs.\n+ */\n+class AuthClient extends DelegateRestClient {\n+\n+    /**\n+     * Stores the Client ID fragment.\n+     */\n+    private static final String CLIENT_ID_FRAGMENT = \"&client_id=\";\n+\n+    /**\n+     * Stores the Client Secret fragment.\n+     */\n+    private static final String CLIENT_SECRET_FRAGMENT = \"&client_secret=\";\n+\n+    /**\n+     * Stores the Grant Type fragment.\n+     */\n+    private static final String GRANT_TYPE_FRAGMENT = \"grant_type=client_credentials\";\n+\n+    /**\n+     * Stores the Resource fragment.\n+     */\n+    private static final String RESOURCE_FRAGMENT = \"&resource=\";\n+\n+    /**\n+     * Stores the OAuth2 token base URL.\n+     */\n+    private static final String OAUTH2_TOKEN_BASE_URL = \"https://login.microsoftonline.com/\";\n+\n+    /**\n+     * Stores the OAuth2 token postfix.\n+     */\n+    private static final String OAUTH2_TOKEN_POSTFIX = \"/oauth2/token\";\n+\n+    /**\n+     * Stores the OAuth2 managed identity URL.\n+     */\n+    private static final String OAUTH2_MANAGED_IDENTITY_TOKEN_URL\n+        = \"http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01\";\n+\n+    /**\n+     * Stores our logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(AuthClient.class.getName());\n+\n+    /**\n+     * Constructor.\n+     *\n+     * <p>\n+     * The constructor creates a default RestClient.\n+     * </p>\n+     */\n+    AuthClient() {\n+        super(RestClientFactory.createClient());\n+    }\n+\n+    /**\n+     * Get an access token for a managed identity.\n+     *\n+     * @param resource the resource.\n+     * @return the authorization token.\n+     */\n+    public String getAccessToken(String resource) {\n+        String result;\n+\n+        if (System.getenv(\"WEBSITE_SITE_NAME\") != null\n+            && !System.getenv(\"WEBSITE_SITE_NAME\").isEmpty()) {\n+            result = getAccessTokenOnAppService(resource);\n+        } else {\n+            result = getAccessTokenOnOthers(resource);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Get an access token.\n+     *\n+     * @param resource the resource.\n+     * @param tenantId the tenant ID.\n+     * @param clientId the client ID.\n+     * @param clientSecret the client secret.\n+     * @return the authorization token.\n+     */\n+    public String getAccessToken(String resource, String tenantId,\n+                                 String clientId, String clientSecret) {\n+        LOGGER.entering(\"AuthClient\", \"getAccessToken\", new Object[] {\n+            resource, tenantId, clientId, clientSecret });\n+        LOGGER.info(\"Getting access token using client ID / client secret\");\n+        String result = null;\n+\n+        StringBuilder oauth2Url = new StringBuilder();\n+        oauth2Url.append(OAUTH2_TOKEN_BASE_URL)\n+                 .append(tenantId)\n+                 .append(OAUTH2_TOKEN_POSTFIX);\n+\n+        StringBuilder requestBody = new StringBuilder();\n+        requestBody.append(GRANT_TYPE_FRAGMENT)\n+                   .append(CLIENT_ID_FRAGMENT).append(clientId)\n+                   .append(CLIENT_SECRET_FRAGMENT).append(clientSecret)\n+                   .append(RESOURCE_FRAGMENT).append(resource);\n+\n+        String body = post(oauth2Url.toString(), requestBody.toString(), \"application/x-www-form-urlencoded\");\n+        if (body != null) {\n+            JsonConverter converter = JsonConverterFactory.createJsonConverter();\n+            OAuthToken token = (OAuthToken) converter.fromJson(body, OAuthToken.class);\n+            result = token.getAccess_token();\n+        }\n+        LOGGER.log(FINER, \"Access token: {0}\", result);\n+        return result;\n+    }\n+\n+    /**\n+     * Get the access token on Azure App Service.\n+     *\n+     * @param resource the resource.\n+     * @return the authorization token.\n+     */\n+    private String getAccessTokenOnAppService(String resource) {\n+        LOGGER.entering(\"AuthClient\", \"getAccessTokenOnAppService\", resource);\n+        LOGGER.info(\"Getting access token using managed identity based on MSI_SECRET\");\n+        String result = null;\n+\n+        StringBuilder url = new StringBuilder();\n+        url.append(System.getenv(\"MSI_ENDPOINT\"))\n+           .append(\"?api-version=2017-09-01\")\n+           .append(RESOURCE_FRAGMENT).append(resource);", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM5MjQwNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510392406", "bodyText": "The KeyVaultClient code passes in a url encoded version so nothing further needs to be done", "author": "mnriem", "createdAt": "2020-10-22T19:05:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgxODQ4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc1MzMzOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508753339", "bodyText": "Are we making a simple REST call for getting credentials instead of using our Azure Identity library to avoid pulling more dependencies into this JAR?", "author": "vcolin7", "createdAt": "2020-10-20T18:37:20Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/AuthClient.java", "diffHunk": "@@ -0,0 +1,182 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import com.azure.security.keyvault.jca.rest.OAuthToken;\n+\n+import java.util.HashMap;\n+import java.util.logging.Logger;\n+\n+import static java.util.logging.Level.FINER;\n+\n+/**\n+ * The REST client specific to getting an access token for Azure REST APIs.\n+ */\n+class AuthClient extends DelegateRestClient {\n+\n+    /**\n+     * Stores the Client ID fragment.\n+     */\n+    private static final String CLIENT_ID_FRAGMENT = \"&client_id=\";\n+\n+    /**\n+     * Stores the Client Secret fragment.\n+     */\n+    private static final String CLIENT_SECRET_FRAGMENT = \"&client_secret=\";\n+\n+    /**\n+     * Stores the Grant Type fragment.\n+     */\n+    private static final String GRANT_TYPE_FRAGMENT = \"grant_type=client_credentials\";\n+\n+    /**\n+     * Stores the Resource fragment.\n+     */\n+    private static final String RESOURCE_FRAGMENT = \"&resource=\";\n+\n+    /**\n+     * Stores the OAuth2 token base URL.\n+     */\n+    private static final String OAUTH2_TOKEN_BASE_URL = \"https://login.microsoftonline.com/\";\n+\n+    /**\n+     * Stores the OAuth2 token postfix.\n+     */\n+    private static final String OAUTH2_TOKEN_POSTFIX = \"/oauth2/token\";\n+\n+    /**\n+     * Stores the OAuth2 managed identity URL.\n+     */\n+    private static final String OAUTH2_MANAGED_IDENTITY_TOKEN_URL\n+        = \"http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01\";\n+\n+    /**\n+     * Stores our logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(AuthClient.class.getName());\n+\n+    /**\n+     * Constructor.\n+     *\n+     * <p>\n+     * The constructor creates a default RestClient.\n+     * </p>\n+     */\n+    AuthClient() {\n+        super(RestClientFactory.createClient());\n+    }\n+\n+    /**\n+     * Get an access token for a managed identity.\n+     *\n+     * @param resource the resource.\n+     * @return the authorization token.\n+     */\n+    public String getAccessToken(String resource) {\n+        String result;\n+\n+        if (System.getenv(\"WEBSITE_SITE_NAME\") != null\n+            && !System.getenv(\"WEBSITE_SITE_NAME\").isEmpty()) {\n+            result = getAccessTokenOnAppService(resource);\n+        } else {\n+            result = getAccessTokenOnOthers(resource);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Get an access token.\n+     *\n+     * @param resource the resource.\n+     * @param tenantId the tenant ID.\n+     * @param clientId the client ID.\n+     * @param clientSecret the client secret.\n+     * @return the authorization token.\n+     */\n+    public String getAccessToken(String resource, String tenantId,\n+                                 String clientId, String clientSecret) {\n+        LOGGER.entering(\"AuthClient\", \"getAccessToken\", new Object[] {\n+            resource, tenantId, clientId, clientSecret });\n+        LOGGER.info(\"Getting access token using client ID / client secret\");\n+        String result = null;\n+\n+        StringBuilder oauth2Url = new StringBuilder();\n+        oauth2Url.append(OAUTH2_TOKEN_BASE_URL)\n+                 .append(tenantId)\n+                 .append(OAUTH2_TOKEN_POSTFIX);\n+\n+        StringBuilder requestBody = new StringBuilder();\n+        requestBody.append(GRANT_TYPE_FRAGMENT)\n+                   .append(CLIENT_ID_FRAGMENT).append(clientId)\n+                   .append(CLIENT_SECRET_FRAGMENT).append(clientSecret)\n+                   .append(RESOURCE_FRAGMENT).append(resource);\n+\n+        String body = post(oauth2Url.toString(), requestBody.toString(), \"application/x-www-form-urlencoded\");", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDIyNzczMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510227730", "bodyText": "That is correct.", "author": "mnriem", "createdAt": "2020-10-22T14:52:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc1MzMzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc2Nzc3Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508767772", "bodyText": "Is this the only version that will be used for getting a token? If there are more versions available for this I would prefer us to use an expandable enum in future releases.", "author": "vcolin7", "createdAt": "2020-10-20T18:58:20Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/AuthClient.java", "diffHunk": "@@ -0,0 +1,182 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import com.azure.security.keyvault.jca.rest.OAuthToken;\n+\n+import java.util.HashMap;\n+import java.util.logging.Logger;\n+\n+import static java.util.logging.Level.FINER;\n+\n+/**\n+ * The REST client specific to getting an access token for Azure REST APIs.\n+ */\n+class AuthClient extends DelegateRestClient {\n+\n+    /**\n+     * Stores the Client ID fragment.\n+     */\n+    private static final String CLIENT_ID_FRAGMENT = \"&client_id=\";\n+\n+    /**\n+     * Stores the Client Secret fragment.\n+     */\n+    private static final String CLIENT_SECRET_FRAGMENT = \"&client_secret=\";\n+\n+    /**\n+     * Stores the Grant Type fragment.\n+     */\n+    private static final String GRANT_TYPE_FRAGMENT = \"grant_type=client_credentials\";\n+\n+    /**\n+     * Stores the Resource fragment.\n+     */\n+    private static final String RESOURCE_FRAGMENT = \"&resource=\";\n+\n+    /**\n+     * Stores the OAuth2 token base URL.\n+     */\n+    private static final String OAUTH2_TOKEN_BASE_URL = \"https://login.microsoftonline.com/\";\n+\n+    /**\n+     * Stores the OAuth2 token postfix.\n+     */\n+    private static final String OAUTH2_TOKEN_POSTFIX = \"/oauth2/token\";\n+\n+    /**\n+     * Stores the OAuth2 managed identity URL.\n+     */\n+    private static final String OAUTH2_MANAGED_IDENTITY_TOKEN_URL\n+        = \"http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01\";\n+\n+    /**\n+     * Stores our logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(AuthClient.class.getName());\n+\n+    /**\n+     * Constructor.\n+     *\n+     * <p>\n+     * The constructor creates a default RestClient.\n+     * </p>\n+     */\n+    AuthClient() {\n+        super(RestClientFactory.createClient());\n+    }\n+\n+    /**\n+     * Get an access token for a managed identity.\n+     *\n+     * @param resource the resource.\n+     * @return the authorization token.\n+     */\n+    public String getAccessToken(String resource) {\n+        String result;\n+\n+        if (System.getenv(\"WEBSITE_SITE_NAME\") != null\n+            && !System.getenv(\"WEBSITE_SITE_NAME\").isEmpty()) {\n+            result = getAccessTokenOnAppService(resource);\n+        } else {\n+            result = getAccessTokenOnOthers(resource);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Get an access token.\n+     *\n+     * @param resource the resource.\n+     * @param tenantId the tenant ID.\n+     * @param clientId the client ID.\n+     * @param clientSecret the client secret.\n+     * @return the authorization token.\n+     */\n+    public String getAccessToken(String resource, String tenantId,\n+                                 String clientId, String clientSecret) {\n+        LOGGER.entering(\"AuthClient\", \"getAccessToken\", new Object[] {\n+            resource, tenantId, clientId, clientSecret });\n+        LOGGER.info(\"Getting access token using client ID / client secret\");\n+        String result = null;\n+\n+        StringBuilder oauth2Url = new StringBuilder();\n+        oauth2Url.append(OAUTH2_TOKEN_BASE_URL)\n+                 .append(tenantId)\n+                 .append(OAUTH2_TOKEN_POSTFIX);\n+\n+        StringBuilder requestBody = new StringBuilder();\n+        requestBody.append(GRANT_TYPE_FRAGMENT)\n+                   .append(CLIENT_ID_FRAGMENT).append(clientId)\n+                   .append(CLIENT_SECRET_FRAGMENT).append(clientSecret)\n+                   .append(RESOURCE_FRAGMENT).append(resource);\n+\n+        String body = post(oauth2Url.toString(), requestBody.toString(), \"application/x-www-form-urlencoded\");\n+        if (body != null) {\n+            JsonConverter converter = JsonConverterFactory.createJsonConverter();\n+            OAuthToken token = (OAuthToken) converter.fromJson(body, OAuthToken.class);\n+            result = token.getAccess_token();\n+        }\n+        LOGGER.log(FINER, \"Access token: {0}\", result);\n+        return result;\n+    }\n+\n+    /**\n+     * Get the access token on Azure App Service.\n+     *\n+     * @param resource the resource.\n+     * @return the authorization token.\n+     */\n+    private String getAccessTokenOnAppService(String resource) {\n+        LOGGER.entering(\"AuthClient\", \"getAccessTokenOnAppService\", resource);\n+        LOGGER.info(\"Getting access token using managed identity based on MSI_SECRET\");\n+        String result = null;\n+\n+        StringBuilder url = new StringBuilder();\n+        url.append(System.getenv(\"MSI_ENDPOINT\"))\n+           .append(\"?api-version=2017-09-01\")", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE2OTUwOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r511169508", "bodyText": "This will be indeed the only version as this code is not user configurable. This is by design so we eliminate user error.", "author": "mnriem", "createdAt": "2020-10-23T21:46:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc2Nzc3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc3MjkzMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508772931", "bodyText": "We should use a ServiceVersion enum like other SDKs do in future releases to support multiple versions.", "author": "vcolin7", "createdAt": "2020-10-20T19:07:14Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/KeyVaultClient.java", "diffHunk": "@@ -0,0 +1,244 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import com.azure.security.keyvault.jca.rest.CertificateBundle;\n+import com.azure.security.keyvault.jca.rest.CertificateItem;\n+import com.azure.security.keyvault.jca.rest.CertificateListResult;\n+import com.azure.security.keyvault.jca.rest.CertificatePolicy;\n+import com.azure.security.keyvault.jca.rest.KeyProperties;\n+import com.azure.security.keyvault.jca.rest.SecretBundle;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.security.Key;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.logging.Logger;\n+\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.WARNING;\n+\n+/**\n+ * The REST client specific to Azure KeyVault.\n+ */\n+class KeyVaultClient extends DelegateRestClient {\n+\n+    /**\n+     * Stores the logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(KeyVaultClient.class.getName());\n+\n+    /**\n+     * Stores the API version postfix.\n+     */\n+    private static final String API_VERSION_POSTFIX = \"?api-version=7.1\";", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE2ODczNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r511168736", "bodyText": "As this is completely hidden from the user and they can't configure it we do not need to support multiple versions. The project does need to be updated if the 7.1 would no longer be supported.", "author": "mnriem", "createdAt": "2020-10-23T21:44:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc3MjkzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc3MzczOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508773739", "bodyText": "Even though it is technically a URI, in our Key Vault Java libraries we refer to this as a keyVaultUrl or vaultUrl, so I think we should be consistent to avoid confusing users.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /**\n          \n          \n            \n                 * Stores the KeyVault URI.\n          \n          \n            \n                 */\n          \n          \n            \n                private final String keyVaultUri;\n          \n          \n            \n                /**\n          \n          \n            \n                 * Stores the KeyVault URL.\n          \n          \n            \n                 */\n          \n          \n            \n                private final String keyVaultUrl;", "author": "vcolin7", "createdAt": "2020-10-20T19:08:41Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/KeyVaultClient.java", "diffHunk": "@@ -0,0 +1,244 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import com.azure.security.keyvault.jca.rest.CertificateBundle;\n+import com.azure.security.keyvault.jca.rest.CertificateItem;\n+import com.azure.security.keyvault.jca.rest.CertificateListResult;\n+import com.azure.security.keyvault.jca.rest.CertificatePolicy;\n+import com.azure.security.keyvault.jca.rest.KeyProperties;\n+import com.azure.security.keyvault.jca.rest.SecretBundle;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.security.Key;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.logging.Logger;\n+\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.WARNING;\n+\n+/**\n+ * The REST client specific to Azure KeyVault.\n+ */\n+class KeyVaultClient extends DelegateRestClient {\n+\n+    /**\n+     * Stores the logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(KeyVaultClient.class.getName());\n+\n+    /**\n+     * Stores the API version postfix.\n+     */\n+    private static final String API_VERSION_POSTFIX = \"?api-version=7.1\";\n+\n+    /**\n+     * Stores the KeyVault URI.\n+     */\n+    private final String keyVaultUri;", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDkzMDcxNQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510930715", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-23T14:39:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc3MzczOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc5MzI1NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508793254", "bodyText": "nit; If we already have the value of certificateBundle.getCer() in certificateString we can use the variable here.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    new ByteArrayInputStream(Base64.getDecoder().decode(certificateBundle.getCer()))\n          \n          \n            \n                                    new ByteArrayInputStream(Base64.getDecoder().decode(certificateString))", "author": "vcolin7", "createdAt": "2020-10-20T19:44:35Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/KeyVaultClient.java", "diffHunk": "@@ -0,0 +1,244 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import com.azure.security.keyvault.jca.rest.CertificateBundle;\n+import com.azure.security.keyvault.jca.rest.CertificateItem;\n+import com.azure.security.keyvault.jca.rest.CertificateListResult;\n+import com.azure.security.keyvault.jca.rest.CertificatePolicy;\n+import com.azure.security.keyvault.jca.rest.KeyProperties;\n+import com.azure.security.keyvault.jca.rest.SecretBundle;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.security.Key;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.logging.Logger;\n+\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.WARNING;\n+\n+/**\n+ * The REST client specific to Azure KeyVault.\n+ */\n+class KeyVaultClient extends DelegateRestClient {\n+\n+    /**\n+     * Stores the logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(KeyVaultClient.class.getName());\n+\n+    /**\n+     * Stores the API version postfix.\n+     */\n+    private static final String API_VERSION_POSTFIX = \"?api-version=7.1\";\n+\n+    /**\n+     * Stores the KeyVault URI.\n+     */\n+    private final String keyVaultUri;\n+\n+    /**\n+     * Stores the tenant ID.\n+     */\n+    private String tenantId;\n+\n+    /**\n+     * Stores the client ID.\n+     */\n+    private String clientId;\n+\n+    /**\n+     * Stores the client secret.\n+     */\n+    private String clientSecret;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param keyVaultUri the KeyVault URI.\n+     */\n+    KeyVaultClient(String keyVaultUri) {\n+        super(RestClientFactory.createClient());\n+        LOGGER.log(INFO, \"Using KeyVault: {0}\", keyVaultUri);\n+        if (!keyVaultUri.endsWith(\"/\")) {\n+            keyVaultUri = keyVaultUri + \"/\";\n+        }\n+        this.keyVaultUri = keyVaultUri;\n+    }\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param keyVaultUri the KeyVault URI.\n+     * @param tenantId the tenant ID.\n+     * @param clientId the client ID.\n+     * @param clientSecret the client secret.\n+     */\n+    KeyVaultClient(final String keyVaultUri, final String tenantId, final String clientId, final String clientSecret) {\n+        this(keyVaultUri);\n+        this.tenantId = tenantId;\n+        this.clientId = clientId;\n+        this.clientSecret = clientSecret;\n+    }\n+\n+    /**\n+     * Get the access token.\n+     *\n+     * @return the access token.\n+     */\n+    private String getAccessToken() {\n+        LOGGER.entering(\"KeyVaultClient\", \"getAccessToken\");\n+        String accessToken = null;\n+        try {\n+            AuthClient authClient = new AuthClient();\n+            String resource = URLEncoder.encode(\"https://vault.azure.net\", \"UTF-8\");\n+            if (tenantId != null && clientId != null && clientSecret != null) {\n+                accessToken = authClient.getAccessToken(resource, tenantId, clientId, clientSecret);\n+            } else {\n+                accessToken = authClient.getAccessToken(resource);\n+            }\n+        } catch (UnsupportedEncodingException uee) {\n+            LOGGER.log(WARNING, \"Unsupported encoding\", uee);\n+        }\n+        LOGGER.exiting(\"KeyVaultClient\", \"getAccessToken\", accessToken);\n+        return accessToken;\n+    }\n+\n+    /**\n+     * Get the list of aliases.\n+     *\n+     * @return the list of aliases.\n+     */\n+    public List<String> getAliases() {\n+        ArrayList<String> result = new ArrayList<>();\n+        HashMap<String, String> headers = new HashMap<>();\n+        headers.put(\"Authorization\", \"Bearer \" + getAccessToken());\n+        String url = String.format(\"%scertificates%s\", keyVaultUri, API_VERSION_POSTFIX);\n+        String response = get(url, headers);\n+        CertificateListResult certificateListResult = null;\n+        if (response != null) {\n+            JsonConverter converter = JsonConverterFactory.createJsonConverter();\n+            certificateListResult = (CertificateListResult) converter.fromJson(response, CertificateListResult.class);\n+        }\n+        if (certificateListResult != null && certificateListResult.getValue().size() > 0) {\n+            for (CertificateItem certificateItem : certificateListResult.getValue()) {\n+                String id = certificateItem.getId();\n+                String alias = id.substring(id.indexOf(\"certificates\") + \"certificates\".length() + 1);\n+                result.add(alias);\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Get the certificate bundle.\n+     *\n+     * @param alias the alias.\n+     * @return the certificate bundle.\n+     */\n+    private CertificateBundle getCertificateBundle(String alias) {\n+        CertificateBundle result = null;\n+        HashMap<String, String> headers = new HashMap<>();\n+        headers.put(\"Authorization\", \"Bearer \" + getAccessToken());\n+        String url = String.format(\"%scertificates/%s%s\", keyVaultUri, alias, API_VERSION_POSTFIX);\n+        String response = get(url, headers);\n+        if (response != null) {\n+            JsonConverter converter = JsonConverterFactory.createJsonConverter();\n+            result = (CertificateBundle) converter.fromJson(response, CertificateBundle.class);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Get the certificate.\n+     *\n+     * @param alias the alias.\n+     * @return the certificate, or null if not found.\n+     */\n+    public Certificate getCertificate(String alias) {\n+        LOGGER.entering(\"KeyVaultClient\", \"getCertificate\", alias);\n+        LOGGER.log(INFO, \"Getting certificate for alias: {0}\", alias);\n+        X509Certificate certificate = null;\n+        CertificateBundle certificateBundle = getCertificateBundle(alias);\n+        if (certificateBundle != null) {\n+            String certificateString = certificateBundle.getCer();\n+            if (certificateString != null) {\n+                try {\n+                    CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n+                    certificate = (X509Certificate) cf.generateCertificate(\n+                        new ByteArrayInputStream(Base64.getDecoder().decode(certificateBundle.getCer()))", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDkzOTczNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510939734", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-23T14:52:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc5MzI1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc5NTMyNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508795326", "bodyText": "I'm not entirely familiar with the KeyStore class, is it possible this can throw a NoSuchElementException in this case?", "author": "vcolin7", "createdAt": "2020-10-20T19:48:14Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/KeyVaultClient.java", "diffHunk": "@@ -0,0 +1,244 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import com.azure.security.keyvault.jca.rest.CertificateBundle;\n+import com.azure.security.keyvault.jca.rest.CertificateItem;\n+import com.azure.security.keyvault.jca.rest.CertificateListResult;\n+import com.azure.security.keyvault.jca.rest.CertificatePolicy;\n+import com.azure.security.keyvault.jca.rest.KeyProperties;\n+import com.azure.security.keyvault.jca.rest.SecretBundle;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLEncoder;\n+import java.security.Key;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.logging.Logger;\n+\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.WARNING;\n+\n+/**\n+ * The REST client specific to Azure KeyVault.\n+ */\n+class KeyVaultClient extends DelegateRestClient {\n+\n+    /**\n+     * Stores the logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(KeyVaultClient.class.getName());\n+\n+    /**\n+     * Stores the API version postfix.\n+     */\n+    private static final String API_VERSION_POSTFIX = \"?api-version=7.1\";\n+\n+    /**\n+     * Stores the KeyVault URI.\n+     */\n+    private final String keyVaultUri;\n+\n+    /**\n+     * Stores the tenant ID.\n+     */\n+    private String tenantId;\n+\n+    /**\n+     * Stores the client ID.\n+     */\n+    private String clientId;\n+\n+    /**\n+     * Stores the client secret.\n+     */\n+    private String clientSecret;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param keyVaultUri the KeyVault URI.\n+     */\n+    KeyVaultClient(String keyVaultUri) {\n+        super(RestClientFactory.createClient());\n+        LOGGER.log(INFO, \"Using KeyVault: {0}\", keyVaultUri);\n+        if (!keyVaultUri.endsWith(\"/\")) {\n+            keyVaultUri = keyVaultUri + \"/\";\n+        }\n+        this.keyVaultUri = keyVaultUri;\n+    }\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param keyVaultUri the KeyVault URI.\n+     * @param tenantId the tenant ID.\n+     * @param clientId the client ID.\n+     * @param clientSecret the client secret.\n+     */\n+    KeyVaultClient(final String keyVaultUri, final String tenantId, final String clientId, final String clientSecret) {\n+        this(keyVaultUri);\n+        this.tenantId = tenantId;\n+        this.clientId = clientId;\n+        this.clientSecret = clientSecret;\n+    }\n+\n+    /**\n+     * Get the access token.\n+     *\n+     * @return the access token.\n+     */\n+    private String getAccessToken() {\n+        LOGGER.entering(\"KeyVaultClient\", \"getAccessToken\");\n+        String accessToken = null;\n+        try {\n+            AuthClient authClient = new AuthClient();\n+            String resource = URLEncoder.encode(\"https://vault.azure.net\", \"UTF-8\");\n+            if (tenantId != null && clientId != null && clientSecret != null) {\n+                accessToken = authClient.getAccessToken(resource, tenantId, clientId, clientSecret);\n+            } else {\n+                accessToken = authClient.getAccessToken(resource);\n+            }\n+        } catch (UnsupportedEncodingException uee) {\n+            LOGGER.log(WARNING, \"Unsupported encoding\", uee);\n+        }\n+        LOGGER.exiting(\"KeyVaultClient\", \"getAccessToken\", accessToken);\n+        return accessToken;\n+    }\n+\n+    /**\n+     * Get the list of aliases.\n+     *\n+     * @return the list of aliases.\n+     */\n+    public List<String> getAliases() {\n+        ArrayList<String> result = new ArrayList<>();\n+        HashMap<String, String> headers = new HashMap<>();\n+        headers.put(\"Authorization\", \"Bearer \" + getAccessToken());\n+        String url = String.format(\"%scertificates%s\", keyVaultUri, API_VERSION_POSTFIX);\n+        String response = get(url, headers);\n+        CertificateListResult certificateListResult = null;\n+        if (response != null) {\n+            JsonConverter converter = JsonConverterFactory.createJsonConverter();\n+            certificateListResult = (CertificateListResult) converter.fromJson(response, CertificateListResult.class);\n+        }\n+        if (certificateListResult != null && certificateListResult.getValue().size() > 0) {\n+            for (CertificateItem certificateItem : certificateListResult.getValue()) {\n+                String id = certificateItem.getId();\n+                String alias = id.substring(id.indexOf(\"certificates\") + \"certificates\".length() + 1);\n+                result.add(alias);\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Get the certificate bundle.\n+     *\n+     * @param alias the alias.\n+     * @return the certificate bundle.\n+     */\n+    private CertificateBundle getCertificateBundle(String alias) {\n+        CertificateBundle result = null;\n+        HashMap<String, String> headers = new HashMap<>();\n+        headers.put(\"Authorization\", \"Bearer \" + getAccessToken());\n+        String url = String.format(\"%scertificates/%s%s\", keyVaultUri, alias, API_VERSION_POSTFIX);\n+        String response = get(url, headers);\n+        if (response != null) {\n+            JsonConverter converter = JsonConverterFactory.createJsonConverter();\n+            result = (CertificateBundle) converter.fromJson(response, CertificateBundle.class);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Get the certificate.\n+     *\n+     * @param alias the alias.\n+     * @return the certificate, or null if not found.\n+     */\n+    public Certificate getCertificate(String alias) {\n+        LOGGER.entering(\"KeyVaultClient\", \"getCertificate\", alias);\n+        LOGGER.log(INFO, \"Getting certificate for alias: {0}\", alias);\n+        X509Certificate certificate = null;\n+        CertificateBundle certificateBundle = getCertificateBundle(alias);\n+        if (certificateBundle != null) {\n+            String certificateString = certificateBundle.getCer();\n+            if (certificateString != null) {\n+                try {\n+                    CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n+                    certificate = (X509Certificate) cf.generateCertificate(\n+                        new ByteArrayInputStream(Base64.getDecoder().decode(certificateBundle.getCer()))\n+                    );\n+                } catch (CertificateException ce) {\n+                    LOGGER.log(WARNING, \"Certificate error\", ce);\n+                }\n+            }\n+        }\n+        LOGGER.exiting(\"KeyVaultClient\", \"getCertificate\", certificate);\n+        return certificate;\n+    }\n+\n+    /**\n+     * Get the key.\n+     *\n+     * @param alias the alias.\n+     * @param password the password.\n+     * @return the key.\n+     */\n+    public Key getKey(String alias, char[] password) {\n+        LOGGER.entering(\"KeyVaultClient\", \"getKey\", new Object[] { alias, password });\n+        LOGGER.log(INFO, \"Getting key for alias: {0}\", alias);\n+        Key key = null;\n+        CertificateBundle certificateBundle = getCertificateBundle(alias);\n+        boolean isExportable = Optional.ofNullable(certificateBundle)\n+                                       .map(CertificateBundle::getPolicy)\n+                                       .map(CertificatePolicy::getKey_props)\n+                                       .map(KeyProperties::isExportable)\n+                                       .orElse(false);\n+        if (isExportable) {\n+            // Because the certificate is exportable the private key is\n+            // available. So we'll use the KeyVault Secrets API to get the \n+            // private key.\n+            String certificateSecretUri = certificateBundle.getSid();\n+            HashMap<String, String> headers = new HashMap<>();\n+            headers.put(\"Authorization\", \"Bearer \" + getAccessToken());\n+            String body = get(certificateSecretUri + API_VERSION_POSTFIX, headers);\n+            if (body != null) {\n+                JsonConverter converter = JsonConverterFactory.createJsonConverter();\n+                SecretBundle secretBundle = (SecretBundle) converter.fromJson(body, SecretBundle.class);\n+                try {\n+                    KeyStore keyStore = KeyStore.getInstance(\"PKCS12\");\n+                    keyStore.load(\n+                        new ByteArrayInputStream(Base64.getDecoder().decode(secretBundle.getValue())),\n+                        \"\".toCharArray()\n+                    );\n+                    alias = keyStore.aliases().nextElement();", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ0NzgyNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510447824", "bodyText": "In this particular case because we create a new Keystore and we load a specifically with just one certificate `NoSuchElementException' would not be thrown, because if loading failed it would have triggered the catch block.", "author": "mnriem", "createdAt": "2020-10-22T20:49:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc5NTMyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgyMTE5Ng==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508821196", "bodyText": "Should we also log a warning if the alias turns out to be null in the end?", "author": "vcolin7", "createdAt": "2020-10-20T20:33:46Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/KeyVaultKeyManager.java", "diffHunk": "@@ -0,0 +1,163 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import javax.net.ssl.X509ExtendedKeyManager;\n+import java.net.Socket;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.Principal;\n+import java.security.PrivateKey;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Logger;\n+\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.WARNING;\n+\n+/**\n+ * The KeyVault variant of the X509ExtendedKeyManager.\n+ */\n+public class KeyVaultKeyManager extends X509ExtendedKeyManager {\n+\n+    /**\n+     * Stores the logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(KeyVaultKeyManager.class.getName());\n+\n+    /**\n+     * Stores the keystore.\n+     */\n+    private final KeyStore keystore;\n+\n+    /**\n+     * Stores the password.\n+     */\n+    private final char[] password;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param keystore the keystore.\n+     * @param password the password.\n+     */\n+    public KeyVaultKeyManager(KeyStore keystore, char[] password) {\n+        LOGGER.entering(\"KeyVaultKeyManager\", \"<init>\", new Object[] { keystore, password });\n+        this.keystore = keystore;\n+        this.password = password;\n+    }\n+\n+    @Override\n+    public String chooseClientAlias(String[] keyType, Principal[] issuers, Socket socket) {\n+        LOGGER.entering(\n+            \"KeyVaultKeyManager\",\n+            \"chooseClientAlias\",\n+            new Object[] { keyType, issuers, socket }\n+        );\n+        String alias = null;\n+        try {\n+            /*\n+             * If we only have one alias and the keystore type is not 'AzureKeyVault'\n+             * return that alias as a match.\n+             */\n+            if (!keystore.getProvider().getName().equals(\"AzureKeyVault\")\n+                && keystore.size() == 1) {\n+                alias = keystore.aliases().nextElement();\n+            }\n+        } catch (KeyStoreException kse) {\n+            LOGGER.log(WARNING, \"Unable to choose client alias\", kse);", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAxODkwMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r511018901", "bodyText": "No as that would cause the application potentially to be very chatty. If the customer would need to know if it is indeed returning null they can change the logging level.", "author": "mnriem", "createdAt": "2020-10-23T17:01:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgyMTE5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgyMzQxNw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508823417", "bodyText": "We don't need to check if keystoreChain is not empty if we are using a foreach loop.", "author": "vcolin7", "createdAt": "2020-10-20T20:37:41Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/KeyVaultKeyManager.java", "diffHunk": "@@ -0,0 +1,163 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import javax.net.ssl.X509ExtendedKeyManager;\n+import java.net.Socket;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.Principal;\n+import java.security.PrivateKey;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Logger;\n+\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.WARNING;\n+\n+/**\n+ * The KeyVault variant of the X509ExtendedKeyManager.\n+ */\n+public class KeyVaultKeyManager extends X509ExtendedKeyManager {\n+\n+    /**\n+     * Stores the logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(KeyVaultKeyManager.class.getName());\n+\n+    /**\n+     * Stores the keystore.\n+     */\n+    private final KeyStore keystore;\n+\n+    /**\n+     * Stores the password.\n+     */\n+    private final char[] password;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param keystore the keystore.\n+     * @param password the password.\n+     */\n+    public KeyVaultKeyManager(KeyStore keystore, char[] password) {\n+        LOGGER.entering(\"KeyVaultKeyManager\", \"<init>\", new Object[] { keystore, password });\n+        this.keystore = keystore;\n+        this.password = password;\n+    }\n+\n+    @Override\n+    public String chooseClientAlias(String[] keyType, Principal[] issuers, Socket socket) {\n+        LOGGER.entering(\n+            \"KeyVaultKeyManager\",\n+            \"chooseClientAlias\",\n+            new Object[] { keyType, issuers, socket }\n+        );\n+        String alias = null;\n+        try {\n+            /*\n+             * If we only have one alias and the keystore type is not 'AzureKeyVault'\n+             * return that alias as a match.\n+             */\n+            if (!keystore.getProvider().getName().equals(\"AzureKeyVault\")\n+                && keystore.size() == 1) {\n+                alias = keystore.aliases().nextElement();\n+            }\n+        } catch (KeyStoreException kse) {\n+            LOGGER.log(WARNING, \"Unable to choose client alias\", kse);\n+        }\n+        LOGGER.exiting(\"KeyVaultKeyManager\", \"chooseClientAlias\", alias);\n+        return alias;\n+    }\n+\n+    @Override\n+    public String chooseServerAlias(String keyType, Principal[] issuers, Socket socket) {\n+        LOGGER.entering(\n+            \"KeyVaultKeyManager\",\n+            \"chooseServerAlias\",\n+            new Object[] { keyType, issuers, socket }\n+        );\n+        String alias = null;\n+        try {\n+            /*\n+             * If we only have one alias and the keystore type is not 'AzureKeyVault'\n+             * return that alias as a match.\n+             */\n+            if (!keystore.getProvider().getName().equals(\"AzureKeyVault\")\n+                && keystore.size() == 1) {\n+                alias = keystore.aliases().nextElement();\n+            }\n+        } catch (KeyStoreException kse) {\n+            LOGGER.log(WARNING, \"Unable to choose server alias\", kse);\n+        }\n+        LOGGER.exiting(\"KeyVaultKeyManager\", \"chooseServerAlias\", alias);\n+        return alias;\n+    }\n+\n+    @Override\n+    public String[] getClientAliases(String keyType, Principal[] issuers) {\n+        LOGGER.log(INFO, \"KeyVaultKeyManager.getClientAliases: {0}, {1}\",\n+            new Object[] { keyType, issuers });\n+        String[] aliases = null;\n+        try {\n+            aliases = Collections.list(keystore.aliases()).toArray(new String[0]);\n+        } catch (KeyStoreException kse) {\n+            LOGGER.log(WARNING, \"Unable to get client aliases\", kse);\n+        }\n+        LOGGER.log(INFO, \"KeyVaultKeyManager.getClientAliases: {0}\", aliases);\n+        return aliases;\n+    }\n+\n+    @Override\n+    public X509Certificate[] getCertificateChain(String alias) {\n+        LOGGER.entering(\"KeyVaultKeyManager\", \"getCertificateChain\", alias);\n+        List<X509Certificate> chain = new ArrayList<>();\n+        try {\n+            Certificate[] keystoreChain = keystore.getCertificateChain(alias);\n+            if (keystoreChain.length > 0) {\n+                for (Certificate certificate : keystoreChain) {", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk0NzIyMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510947221", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-23T15:02:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgyMzQxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgyNjAzNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508826034", "bodyText": "We might want to rename this to keyVaultClient.", "author": "vcolin7", "createdAt": "2020-10-20T20:42:24Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/KeyVaultKeyStore.java", "diffHunk": "@@ -0,0 +1,325 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.security.Key;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.KeyStoreSpi;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableEntryException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.logging.Logger;\n+\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.WARNING;\n+\n+/**\n+ * The Azure KeyVault implementation of the KeyStoreSpi.\n+ */\n+public class KeyVaultKeyStore extends KeyStoreSpi {\n+\n+    /**\n+     * Stores the logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(KeyVaultKeyStore.class.getName());\n+\n+    /**\n+     * Stores the list of aliases.\n+     */\n+    private List<String> aliases;\n+\n+    /**\n+     * Stores the certificates by alias.\n+     */\n+    private final HashMap<String, Certificate> certificates = new HashMap<>();\n+\n+    /**\n+     * Stores the certificate keys by alias.\n+     */\n+    private final HashMap<String, Key> certificateKeys = new HashMap<>();\n+\n+    /**\n+     * Stores the creation date.\n+     */\n+    private final Date creationDate;\n+\n+    /**\n+     * Stores the key vault client.\n+     */\n+    private KeyVaultClient keyVault;", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk1NzAxMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510957010", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-23T15:18:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgyNjAzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgyOTE1Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508829152", "bodyText": "Is there a scenario where a certificate could have different contents to what's already cached and it needs to be set? If that's the case, it wouldn't be possible with this logic.", "author": "vcolin7", "createdAt": "2020-10-20T20:47:58Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/KeyVaultKeyStore.java", "diffHunk": "@@ -0,0 +1,325 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.security.Key;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.KeyStoreSpi;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableEntryException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.logging.Logger;\n+\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.WARNING;\n+\n+/**\n+ * The Azure KeyVault implementation of the KeyStoreSpi.\n+ */\n+public class KeyVaultKeyStore extends KeyStoreSpi {\n+\n+    /**\n+     * Stores the logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(KeyVaultKeyStore.class.getName());\n+\n+    /**\n+     * Stores the list of aliases.\n+     */\n+    private List<String> aliases;\n+\n+    /**\n+     * Stores the certificates by alias.\n+     */\n+    private final HashMap<String, Certificate> certificates = new HashMap<>();\n+\n+    /**\n+     * Stores the certificate keys by alias.\n+     */\n+    private final HashMap<String, Key> certificateKeys = new HashMap<>();\n+\n+    /**\n+     * Stores the creation date.\n+     */\n+    private final Date creationDate;\n+\n+    /**\n+     * Stores the key vault client.\n+     */\n+    private KeyVaultClient keyVault;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * <p>\n+     * The constructor uses System.getProperty for\n+     * <code>azure.keyvault.uri</code>, <code>azure.keyvault.tenantId</code>,\n+     * <code>azure.keyvault.clientId</code>,\n+     * <code>azure.keyvault.clientSecret</code> to initialize the keyvault\n+     * client.\n+     * </p>\n+     */\n+    public KeyVaultKeyStore() {\n+        creationDate = new Date();\n+        String keyVaultUri = System.getProperty(\"azure.keyvault.uri\");\n+        String tenantId = System.getProperty(\"azure.keyvault.tenantId\");\n+        String clientId = System.getProperty(\"azure.keyvault.clientId\");\n+        String clientSecret = System.getProperty(\"azure.keyvault.clientSecret\");\n+        keyVault = new KeyVaultClient(keyVaultUri, tenantId, clientId, clientSecret);\n+    }\n+\n+    @Override\n+    public Enumeration<String> engineAliases() {\n+        if (aliases == null) {\n+            aliases = keyVault.getAliases();\n+        }\n+        return Collections.enumeration(aliases);\n+    }\n+\n+    @Override\n+    public boolean engineContainsAlias(String alias) {\n+        return engineIsCertificateEntry(alias);\n+    }\n+\n+    @Override\n+    public void engineDeleteEntry(String alias) {\n+    }\n+\n+    @Override\n+    public boolean engineEntryInstanceOf(String alias, Class<? extends KeyStore.Entry> entryClass) {\n+        return super.engineEntryInstanceOf(alias, entryClass);\n+    }\n+\n+    @Override\n+    public Certificate engineGetCertificate(String alias) {\n+        Certificate certificate;\n+        if (certificates.containsKey(alias)) {\n+            certificate = certificates.get(alias);\n+        } else {\n+            certificate = keyVault.getCertificate(alias);\n+            if (certificate != null) {\n+                certificates.put(alias, certificate);\n+                if (!aliases.contains(alias)) {\n+                    aliases.add(alias);\n+                }\n+            }\n+        }\n+        return certificate;\n+    }\n+\n+    @Override\n+    public String engineGetCertificateAlias(Certificate cert) {\n+        String alias = null;\n+        if (cert != null) {\n+            if (aliases == null) {\n+                aliases = keyVault.getAliases();\n+            }\n+            for (String candidateAlias : aliases) {\n+                Certificate certificate = engineGetCertificate(candidateAlias);\n+                if (certificate.equals(cert)) {\n+                    alias = candidateAlias;\n+                    break;\n+                }\n+            }\n+        }\n+        return alias;\n+    }\n+\n+    @Override\n+    public Certificate[] engineGetCertificateChain(String alias) {\n+        Certificate[] chain = null;\n+        Certificate certificate = engineGetCertificate(alias);\n+        if (certificate != null) {\n+            chain = new Certificate[1];\n+            chain[0] = certificate;\n+        }\n+        return chain;\n+    }\n+\n+    @Override\n+    public Date engineGetCreationDate(String alias) {\n+        return creationDate;\n+    }\n+\n+    @Override\n+    public KeyStore.Entry engineGetEntry(String alias, KeyStore.ProtectionParameter protParam) throws KeyStoreException, NoSuchAlgorithmException, UnrecoverableEntryException {\n+        return super.engineGetEntry(alias, protParam);\n+    }\n+\n+    @Override\n+    public Key engineGetKey(String alias, char[] password) {\n+        Key key;\n+        if (certificateKeys.containsKey(alias)) {\n+            key = certificateKeys.get(alias);\n+        } else {\n+            key = keyVault.getKey(alias, password);\n+            if (key != null) {\n+                certificateKeys.put(alias, key);\n+                if (!aliases.contains(alias)) {\n+                    aliases.add(alias);\n+                }\n+            }\n+        }\n+        return key;\n+    }\n+\n+    @Override\n+    public boolean engineIsCertificateEntry(String alias) {\n+        if (aliases == null) {\n+            aliases = keyVault.getAliases();\n+        }\n+        return aliases.contains(alias);\n+    }\n+\n+    @Override\n+    public boolean engineIsKeyEntry(String alias) {\n+        return engineIsCertificateEntry(alias);\n+    }\n+\n+    @Override\n+    public void engineLoad(KeyStore.LoadStoreParameter param) {\n+        if (param instanceof KeyVaultLoadStoreParameter) {\n+            KeyVaultLoadStoreParameter parameter = (KeyVaultLoadStoreParameter) param;\n+            keyVault = new KeyVaultClient(\n+                parameter.getUri(),\n+                parameter.getTenantId(),\n+                parameter.getClientId(),\n+                parameter.getClientSecret());\n+        }\n+        sideLoad();\n+    }\n+\n+    @Override\n+    public void engineLoad(InputStream stream, char[] password) {\n+        sideLoad();\n+    }\n+\n+    @Override\n+    public void engineSetCertificateEntry(String alias, Certificate certificate) {", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk3MjU3MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510972571", "bodyText": "Correct. The Azure Key Vault is a read-only KeyStore from the perspective of the user with the one exception that it does side-loading for certificates from the classpath. Which is why this method is implemented the way it is.", "author": "mnriem", "createdAt": "2020-10-23T15:39:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgyOTE1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgzMDk5OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508830999", "bodyText": "I'm not familiar with JCA but I wonder why these methods for keys are empty but we have things like engineIsKeyEntry where we call engineIsCertificateEntry inside. How is engineIsKeyEntry different that it needs an implementation, is it 100% expected to be used and the other methods are not? Are there scenarios where things like engineSetKeyEntry might need an implementation?", "author": "vcolin7", "createdAt": "2020-10-20T20:51:10Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/KeyVaultKeyStore.java", "diffHunk": "@@ -0,0 +1,325 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.security.Key;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.KeyStoreSpi;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableEntryException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.logging.Logger;\n+\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.WARNING;\n+\n+/**\n+ * The Azure KeyVault implementation of the KeyStoreSpi.\n+ */\n+public class KeyVaultKeyStore extends KeyStoreSpi {\n+\n+    /**\n+     * Stores the logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(KeyVaultKeyStore.class.getName());\n+\n+    /**\n+     * Stores the list of aliases.\n+     */\n+    private List<String> aliases;\n+\n+    /**\n+     * Stores the certificates by alias.\n+     */\n+    private final HashMap<String, Certificate> certificates = new HashMap<>();\n+\n+    /**\n+     * Stores the certificate keys by alias.\n+     */\n+    private final HashMap<String, Key> certificateKeys = new HashMap<>();\n+\n+    /**\n+     * Stores the creation date.\n+     */\n+    private final Date creationDate;\n+\n+    /**\n+     * Stores the key vault client.\n+     */\n+    private KeyVaultClient keyVault;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * <p>\n+     * The constructor uses System.getProperty for\n+     * <code>azure.keyvault.uri</code>, <code>azure.keyvault.tenantId</code>,\n+     * <code>azure.keyvault.clientId</code>,\n+     * <code>azure.keyvault.clientSecret</code> to initialize the keyvault\n+     * client.\n+     * </p>\n+     */\n+    public KeyVaultKeyStore() {\n+        creationDate = new Date();\n+        String keyVaultUri = System.getProperty(\"azure.keyvault.uri\");\n+        String tenantId = System.getProperty(\"azure.keyvault.tenantId\");\n+        String clientId = System.getProperty(\"azure.keyvault.clientId\");\n+        String clientSecret = System.getProperty(\"azure.keyvault.clientSecret\");\n+        keyVault = new KeyVaultClient(keyVaultUri, tenantId, clientId, clientSecret);\n+    }\n+\n+    @Override\n+    public Enumeration<String> engineAliases() {\n+        if (aliases == null) {\n+            aliases = keyVault.getAliases();\n+        }\n+        return Collections.enumeration(aliases);\n+    }\n+\n+    @Override\n+    public boolean engineContainsAlias(String alias) {\n+        return engineIsCertificateEntry(alias);\n+    }\n+\n+    @Override\n+    public void engineDeleteEntry(String alias) {\n+    }\n+\n+    @Override\n+    public boolean engineEntryInstanceOf(String alias, Class<? extends KeyStore.Entry> entryClass) {\n+        return super.engineEntryInstanceOf(alias, entryClass);\n+    }\n+\n+    @Override\n+    public Certificate engineGetCertificate(String alias) {\n+        Certificate certificate;\n+        if (certificates.containsKey(alias)) {\n+            certificate = certificates.get(alias);\n+        } else {\n+            certificate = keyVault.getCertificate(alias);\n+            if (certificate != null) {\n+                certificates.put(alias, certificate);\n+                if (!aliases.contains(alias)) {\n+                    aliases.add(alias);\n+                }\n+            }\n+        }\n+        return certificate;\n+    }\n+\n+    @Override\n+    public String engineGetCertificateAlias(Certificate cert) {\n+        String alias = null;\n+        if (cert != null) {\n+            if (aliases == null) {\n+                aliases = keyVault.getAliases();\n+            }\n+            for (String candidateAlias : aliases) {\n+                Certificate certificate = engineGetCertificate(candidateAlias);\n+                if (certificate.equals(cert)) {\n+                    alias = candidateAlias;\n+                    break;\n+                }\n+            }\n+        }\n+        return alias;\n+    }\n+\n+    @Override\n+    public Certificate[] engineGetCertificateChain(String alias) {\n+        Certificate[] chain = null;\n+        Certificate certificate = engineGetCertificate(alias);\n+        if (certificate != null) {\n+            chain = new Certificate[1];\n+            chain[0] = certificate;\n+        }\n+        return chain;\n+    }\n+\n+    @Override\n+    public Date engineGetCreationDate(String alias) {\n+        return creationDate;\n+    }\n+\n+    @Override\n+    public KeyStore.Entry engineGetEntry(String alias, KeyStore.ProtectionParameter protParam) throws KeyStoreException, NoSuchAlgorithmException, UnrecoverableEntryException {\n+        return super.engineGetEntry(alias, protParam);\n+    }\n+\n+    @Override\n+    public Key engineGetKey(String alias, char[] password) {\n+        Key key;\n+        if (certificateKeys.containsKey(alias)) {\n+            key = certificateKeys.get(alias);\n+        } else {\n+            key = keyVault.getKey(alias, password);\n+            if (key != null) {\n+                certificateKeys.put(alias, key);\n+                if (!aliases.contains(alias)) {\n+                    aliases.add(alias);\n+                }\n+            }\n+        }\n+        return key;\n+    }\n+\n+    @Override\n+    public boolean engineIsCertificateEntry(String alias) {\n+        if (aliases == null) {\n+            aliases = keyVault.getAliases();\n+        }\n+        return aliases.contains(alias);\n+    }\n+\n+    @Override\n+    public boolean engineIsKeyEntry(String alias) {\n+        return engineIsCertificateEntry(alias);\n+    }\n+\n+    @Override\n+    public void engineLoad(KeyStore.LoadStoreParameter param) {\n+        if (param instanceof KeyVaultLoadStoreParameter) {\n+            KeyVaultLoadStoreParameter parameter = (KeyVaultLoadStoreParameter) param;\n+            keyVault = new KeyVaultClient(\n+                parameter.getUri(),\n+                parameter.getTenantId(),\n+                parameter.getClientId(),\n+                parameter.getClientSecret());\n+        }\n+        sideLoad();\n+    }\n+\n+    @Override\n+    public void engineLoad(InputStream stream, char[] password) {\n+        sideLoad();\n+    }\n+\n+    @Override\n+    public void engineSetCertificateEntry(String alias, Certificate certificate) {\n+        if (aliases == null) {\n+            aliases = keyVault.getAliases();\n+        }\n+        if (!aliases.contains(alias)) {\n+            aliases.add(alias);\n+            certificates.put(alias, certificate);\n+        }\n+    }\n+\n+    @Override\n+    public void engineSetEntry(String alias, KeyStore.Entry entry, KeyStore.ProtectionParameter protParam) throws KeyStoreException {\n+        super.engineSetEntry(alias, entry, protParam);\n+    }\n+\n+    @Override\n+    public void engineSetKeyEntry(String alias, Key key, char[] password, Certificate[] chain) {\n+    }\n+\n+    @Override\n+    public void engineSetKeyEntry(String alias, byte[] key, Certificate[] chain) {\n+    }", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAwNTk5Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r511005992", "bodyText": "Set engineSet methods do not get an implementation here because the Azure Key Vault KeyStore is a read-only KeyStore", "author": "mnriem", "createdAt": "2020-10-23T16:37:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgzMDk5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgzNDAyNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508834026", "bodyText": "InputStream and BufferedReader must be closed after use in a finally block to avoid leaks. It is even more convenient to use try-with-resources statements.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    InputStream in = getClass().getResourceAsStream(path);\n          \n          \n            \n                    if (in != null) {\n          \n          \n            \n                        BufferedReader br = new BufferedReader(new InputStreamReader(in));\n          \n          \n            \n                        String resource;\n          \n          \n            \n                        while ((resource = br.readLine()) != null) {\n          \n          \n            \n                            filenames.add(resource);\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                    return filenames.toArray(new String[0]);\n          \n          \n            \n                    try (InputStream in = getClass().getResourceAsStream(path)) {\n          \n          \n            \n                        if (in != null) {\n          \n          \n            \n                            try (BufferedReader br = new BufferedReader(new InputStreamReader(in))) {\n          \n          \n            \n                                String resource;\n          \n          \n            \n                                while ((resource = br.readLine()) != null) {\n          \n          \n            \n                                    filenames.add(resource);\n          \n          \n            \n                                }\n          \n          \n            \n                            }\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                    return filenames.toArray(new String[0]);", "author": "vcolin7", "createdAt": "2020-10-20T20:56:34Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/KeyVaultKeyStore.java", "diffHunk": "@@ -0,0 +1,325 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.security.Key;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.KeyStoreSpi;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableEntryException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.logging.Logger;\n+\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.WARNING;\n+\n+/**\n+ * The Azure KeyVault implementation of the KeyStoreSpi.\n+ */\n+public class KeyVaultKeyStore extends KeyStoreSpi {\n+\n+    /**\n+     * Stores the logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(KeyVaultKeyStore.class.getName());\n+\n+    /**\n+     * Stores the list of aliases.\n+     */\n+    private List<String> aliases;\n+\n+    /**\n+     * Stores the certificates by alias.\n+     */\n+    private final HashMap<String, Certificate> certificates = new HashMap<>();\n+\n+    /**\n+     * Stores the certificate keys by alias.\n+     */\n+    private final HashMap<String, Key> certificateKeys = new HashMap<>();\n+\n+    /**\n+     * Stores the creation date.\n+     */\n+    private final Date creationDate;\n+\n+    /**\n+     * Stores the key vault client.\n+     */\n+    private KeyVaultClient keyVault;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * <p>\n+     * The constructor uses System.getProperty for\n+     * <code>azure.keyvault.uri</code>, <code>azure.keyvault.tenantId</code>,\n+     * <code>azure.keyvault.clientId</code>,\n+     * <code>azure.keyvault.clientSecret</code> to initialize the keyvault\n+     * client.\n+     * </p>\n+     */\n+    public KeyVaultKeyStore() {\n+        creationDate = new Date();\n+        String keyVaultUri = System.getProperty(\"azure.keyvault.uri\");\n+        String tenantId = System.getProperty(\"azure.keyvault.tenantId\");\n+        String clientId = System.getProperty(\"azure.keyvault.clientId\");\n+        String clientSecret = System.getProperty(\"azure.keyvault.clientSecret\");\n+        keyVault = new KeyVaultClient(keyVaultUri, tenantId, clientId, clientSecret);\n+    }\n+\n+    @Override\n+    public Enumeration<String> engineAliases() {\n+        if (aliases == null) {\n+            aliases = keyVault.getAliases();\n+        }\n+        return Collections.enumeration(aliases);\n+    }\n+\n+    @Override\n+    public boolean engineContainsAlias(String alias) {\n+        return engineIsCertificateEntry(alias);\n+    }\n+\n+    @Override\n+    public void engineDeleteEntry(String alias) {\n+    }\n+\n+    @Override\n+    public boolean engineEntryInstanceOf(String alias, Class<? extends KeyStore.Entry> entryClass) {\n+        return super.engineEntryInstanceOf(alias, entryClass);\n+    }\n+\n+    @Override\n+    public Certificate engineGetCertificate(String alias) {\n+        Certificate certificate;\n+        if (certificates.containsKey(alias)) {\n+            certificate = certificates.get(alias);\n+        } else {\n+            certificate = keyVault.getCertificate(alias);\n+            if (certificate != null) {\n+                certificates.put(alias, certificate);\n+                if (!aliases.contains(alias)) {\n+                    aliases.add(alias);\n+                }\n+            }\n+        }\n+        return certificate;\n+    }\n+\n+    @Override\n+    public String engineGetCertificateAlias(Certificate cert) {\n+        String alias = null;\n+        if (cert != null) {\n+            if (aliases == null) {\n+                aliases = keyVault.getAliases();\n+            }\n+            for (String candidateAlias : aliases) {\n+                Certificate certificate = engineGetCertificate(candidateAlias);\n+                if (certificate.equals(cert)) {\n+                    alias = candidateAlias;\n+                    break;\n+                }\n+            }\n+        }\n+        return alias;\n+    }\n+\n+    @Override\n+    public Certificate[] engineGetCertificateChain(String alias) {\n+        Certificate[] chain = null;\n+        Certificate certificate = engineGetCertificate(alias);\n+        if (certificate != null) {\n+            chain = new Certificate[1];\n+            chain[0] = certificate;\n+        }\n+        return chain;\n+    }\n+\n+    @Override\n+    public Date engineGetCreationDate(String alias) {\n+        return creationDate;\n+    }\n+\n+    @Override\n+    public KeyStore.Entry engineGetEntry(String alias, KeyStore.ProtectionParameter protParam) throws KeyStoreException, NoSuchAlgorithmException, UnrecoverableEntryException {\n+        return super.engineGetEntry(alias, protParam);\n+    }\n+\n+    @Override\n+    public Key engineGetKey(String alias, char[] password) {\n+        Key key;\n+        if (certificateKeys.containsKey(alias)) {\n+            key = certificateKeys.get(alias);\n+        } else {\n+            key = keyVault.getKey(alias, password);\n+            if (key != null) {\n+                certificateKeys.put(alias, key);\n+                if (!aliases.contains(alias)) {\n+                    aliases.add(alias);\n+                }\n+            }\n+        }\n+        return key;\n+    }\n+\n+    @Override\n+    public boolean engineIsCertificateEntry(String alias) {\n+        if (aliases == null) {\n+            aliases = keyVault.getAliases();\n+        }\n+        return aliases.contains(alias);\n+    }\n+\n+    @Override\n+    public boolean engineIsKeyEntry(String alias) {\n+        return engineIsCertificateEntry(alias);\n+    }\n+\n+    @Override\n+    public void engineLoad(KeyStore.LoadStoreParameter param) {\n+        if (param instanceof KeyVaultLoadStoreParameter) {\n+            KeyVaultLoadStoreParameter parameter = (KeyVaultLoadStoreParameter) param;\n+            keyVault = new KeyVaultClient(\n+                parameter.getUri(),\n+                parameter.getTenantId(),\n+                parameter.getClientId(),\n+                parameter.getClientSecret());\n+        }\n+        sideLoad();\n+    }\n+\n+    @Override\n+    public void engineLoad(InputStream stream, char[] password) {\n+        sideLoad();\n+    }\n+\n+    @Override\n+    public void engineSetCertificateEntry(String alias, Certificate certificate) {\n+        if (aliases == null) {\n+            aliases = keyVault.getAliases();\n+        }\n+        if (!aliases.contains(alias)) {\n+            aliases.add(alias);\n+            certificates.put(alias, certificate);\n+        }\n+    }\n+\n+    @Override\n+    public void engineSetEntry(String alias, KeyStore.Entry entry, KeyStore.ProtectionParameter protParam) throws KeyStoreException {\n+        super.engineSetEntry(alias, entry, protParam);\n+    }\n+\n+    @Override\n+    public void engineSetKeyEntry(String alias, Key key, char[] password, Certificate[] chain) {\n+    }\n+\n+    @Override\n+    public void engineSetKeyEntry(String alias, byte[] key, Certificate[] chain) {\n+    }\n+\n+    @Override\n+    public int engineSize() {\n+        return aliases != null ? aliases.size() : 0;\n+    }\n+\n+    @Override\n+    public void engineStore(OutputStream stream, char[] password) {\n+    }\n+\n+    @Override\n+    public void engineStore(KeyStore.LoadStoreParameter param) {\n+    }\n+\n+    /**\n+     * Get the filenames.\n+     *\n+     * @param path the path.\n+     * @return the filenames.\n+     * @throws IOException when an I/O error occurs.\n+     */\n+    private String[] getFilenames(String path) throws IOException {\n+        List<String> filenames = new ArrayList<>();\n+        InputStream in = getClass().getResourceAsStream(path);\n+        if (in != null) {\n+            BufferedReader br = new BufferedReader(new InputStreamReader(in));\n+            String resource;\n+            while ((resource = br.readLine()) != null) {\n+                filenames.add(resource);\n+            }\n+        }\n+        return filenames.toArray(new String[0]);", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTA0MjM0NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r511042344", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-23T17:46:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgzNDAyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgzNTM1OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508835359", "bodyText": "Use a try-with-resources block to ensure this is closed after use.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    ByteArrayOutputStream byteOutput = new ByteArrayOutputStream();\n          \n          \n            \n                    byte[] buffer = new byte[1024];\n          \n          \n            \n                    while (true) {\n          \n          \n            \n                        int r = inputStream.read(buffer);\n          \n          \n            \n                        if (r == -1) {\n          \n          \n            \n                            break;\n          \n          \n            \n                        }\n          \n          \n            \n                        byteOutput.write(buffer, 0, r);\n          \n          \n            \n                    }\n          \n          \n            \n                    return byteOutput.toByteArray();\n          \n          \n            \n                    byte[] bytes;\n          \n          \n            \n                    try (ByteArrayOutputStream byteOutput = new ByteArrayOutputStream()) {\n          \n          \n            \n                        byte[] buffer = new byte[1024];\n          \n          \n            \n                        while (true) {\n          \n          \n            \n                            int r = inputStream.read(buffer);\n          \n          \n            \n                            if (r == -1) {\n          \n          \n            \n                                break;\n          \n          \n            \n                            }\n          \n          \n            \n                            byteOutput.write(buffer, 0, r);\n          \n          \n            \n                        }\n          \n          \n            \n                        bytes = byteOutput.toByteArray();\n          \n          \n            \n                    }\n          \n          \n            \n                    return bytes;", "author": "vcolin7", "createdAt": "2020-10-20T20:59:03Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/KeyVaultKeyStore.java", "diffHunk": "@@ -0,0 +1,325 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.security.Key;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.KeyStoreSpi;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableEntryException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.logging.Logger;\n+\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.WARNING;\n+\n+/**\n+ * The Azure KeyVault implementation of the KeyStoreSpi.\n+ */\n+public class KeyVaultKeyStore extends KeyStoreSpi {\n+\n+    /**\n+     * Stores the logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(KeyVaultKeyStore.class.getName());\n+\n+    /**\n+     * Stores the list of aliases.\n+     */\n+    private List<String> aliases;\n+\n+    /**\n+     * Stores the certificates by alias.\n+     */\n+    private final HashMap<String, Certificate> certificates = new HashMap<>();\n+\n+    /**\n+     * Stores the certificate keys by alias.\n+     */\n+    private final HashMap<String, Key> certificateKeys = new HashMap<>();\n+\n+    /**\n+     * Stores the creation date.\n+     */\n+    private final Date creationDate;\n+\n+    /**\n+     * Stores the key vault client.\n+     */\n+    private KeyVaultClient keyVault;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * <p>\n+     * The constructor uses System.getProperty for\n+     * <code>azure.keyvault.uri</code>, <code>azure.keyvault.tenantId</code>,\n+     * <code>azure.keyvault.clientId</code>,\n+     * <code>azure.keyvault.clientSecret</code> to initialize the keyvault\n+     * client.\n+     * </p>\n+     */\n+    public KeyVaultKeyStore() {\n+        creationDate = new Date();\n+        String keyVaultUri = System.getProperty(\"azure.keyvault.uri\");\n+        String tenantId = System.getProperty(\"azure.keyvault.tenantId\");\n+        String clientId = System.getProperty(\"azure.keyvault.clientId\");\n+        String clientSecret = System.getProperty(\"azure.keyvault.clientSecret\");\n+        keyVault = new KeyVaultClient(keyVaultUri, tenantId, clientId, clientSecret);\n+    }\n+\n+    @Override\n+    public Enumeration<String> engineAliases() {\n+        if (aliases == null) {\n+            aliases = keyVault.getAliases();\n+        }\n+        return Collections.enumeration(aliases);\n+    }\n+\n+    @Override\n+    public boolean engineContainsAlias(String alias) {\n+        return engineIsCertificateEntry(alias);\n+    }\n+\n+    @Override\n+    public void engineDeleteEntry(String alias) {\n+    }\n+\n+    @Override\n+    public boolean engineEntryInstanceOf(String alias, Class<? extends KeyStore.Entry> entryClass) {\n+        return super.engineEntryInstanceOf(alias, entryClass);\n+    }\n+\n+    @Override\n+    public Certificate engineGetCertificate(String alias) {\n+        Certificate certificate;\n+        if (certificates.containsKey(alias)) {\n+            certificate = certificates.get(alias);\n+        } else {\n+            certificate = keyVault.getCertificate(alias);\n+            if (certificate != null) {\n+                certificates.put(alias, certificate);\n+                if (!aliases.contains(alias)) {\n+                    aliases.add(alias);\n+                }\n+            }\n+        }\n+        return certificate;\n+    }\n+\n+    @Override\n+    public String engineGetCertificateAlias(Certificate cert) {\n+        String alias = null;\n+        if (cert != null) {\n+            if (aliases == null) {\n+                aliases = keyVault.getAliases();\n+            }\n+            for (String candidateAlias : aliases) {\n+                Certificate certificate = engineGetCertificate(candidateAlias);\n+                if (certificate.equals(cert)) {\n+                    alias = candidateAlias;\n+                    break;\n+                }\n+            }\n+        }\n+        return alias;\n+    }\n+\n+    @Override\n+    public Certificate[] engineGetCertificateChain(String alias) {\n+        Certificate[] chain = null;\n+        Certificate certificate = engineGetCertificate(alias);\n+        if (certificate != null) {\n+            chain = new Certificate[1];\n+            chain[0] = certificate;\n+        }\n+        return chain;\n+    }\n+\n+    @Override\n+    public Date engineGetCreationDate(String alias) {\n+        return creationDate;\n+    }\n+\n+    @Override\n+    public KeyStore.Entry engineGetEntry(String alias, KeyStore.ProtectionParameter protParam) throws KeyStoreException, NoSuchAlgorithmException, UnrecoverableEntryException {\n+        return super.engineGetEntry(alias, protParam);\n+    }\n+\n+    @Override\n+    public Key engineGetKey(String alias, char[] password) {\n+        Key key;\n+        if (certificateKeys.containsKey(alias)) {\n+            key = certificateKeys.get(alias);\n+        } else {\n+            key = keyVault.getKey(alias, password);\n+            if (key != null) {\n+                certificateKeys.put(alias, key);\n+                if (!aliases.contains(alias)) {\n+                    aliases.add(alias);\n+                }\n+            }\n+        }\n+        return key;\n+    }\n+\n+    @Override\n+    public boolean engineIsCertificateEntry(String alias) {\n+        if (aliases == null) {\n+            aliases = keyVault.getAliases();\n+        }\n+        return aliases.contains(alias);\n+    }\n+\n+    @Override\n+    public boolean engineIsKeyEntry(String alias) {\n+        return engineIsCertificateEntry(alias);\n+    }\n+\n+    @Override\n+    public void engineLoad(KeyStore.LoadStoreParameter param) {\n+        if (param instanceof KeyVaultLoadStoreParameter) {\n+            KeyVaultLoadStoreParameter parameter = (KeyVaultLoadStoreParameter) param;\n+            keyVault = new KeyVaultClient(\n+                parameter.getUri(),\n+                parameter.getTenantId(),\n+                parameter.getClientId(),\n+                parameter.getClientSecret());\n+        }\n+        sideLoad();\n+    }\n+\n+    @Override\n+    public void engineLoad(InputStream stream, char[] password) {\n+        sideLoad();\n+    }\n+\n+    @Override\n+    public void engineSetCertificateEntry(String alias, Certificate certificate) {\n+        if (aliases == null) {\n+            aliases = keyVault.getAliases();\n+        }\n+        if (!aliases.contains(alias)) {\n+            aliases.add(alias);\n+            certificates.put(alias, certificate);\n+        }\n+    }\n+\n+    @Override\n+    public void engineSetEntry(String alias, KeyStore.Entry entry, KeyStore.ProtectionParameter protParam) throws KeyStoreException {\n+        super.engineSetEntry(alias, entry, protParam);\n+    }\n+\n+    @Override\n+    public void engineSetKeyEntry(String alias, Key key, char[] password, Certificate[] chain) {\n+    }\n+\n+    @Override\n+    public void engineSetKeyEntry(String alias, byte[] key, Certificate[] chain) {\n+    }\n+\n+    @Override\n+    public int engineSize() {\n+        return aliases != null ? aliases.size() : 0;\n+    }\n+\n+    @Override\n+    public void engineStore(OutputStream stream, char[] password) {\n+    }\n+\n+    @Override\n+    public void engineStore(KeyStore.LoadStoreParameter param) {\n+    }\n+\n+    /**\n+     * Get the filenames.\n+     *\n+     * @param path the path.\n+     * @return the filenames.\n+     * @throws IOException when an I/O error occurs.\n+     */\n+    private String[] getFilenames(String path) throws IOException {\n+        List<String> filenames = new ArrayList<>();\n+        InputStream in = getClass().getResourceAsStream(path);\n+        if (in != null) {\n+            BufferedReader br = new BufferedReader(new InputStreamReader(in));\n+            String resource;\n+            while ((resource = br.readLine()) != null) {\n+                filenames.add(resource);\n+            }\n+        }\n+        return filenames.toArray(new String[0]);\n+    }\n+\n+    /**\n+     * Read all the bytes for a given input stream.\n+     *\n+     * @param inputStream the input stream.\n+     * @return the byte-array.\n+     * @throws IOException when an I/O error occurs.\n+     */\n+    private byte[] readAllBytes(InputStream inputStream) throws IOException {\n+        ByteArrayOutputStream byteOutput = new ByteArrayOutputStream();\n+        byte[] buffer = new byte[1024];\n+        while (true) {\n+            int r = inputStream.read(buffer);\n+            if (r == -1) {\n+                break;\n+            }\n+            byteOutput.write(buffer, 0, r);\n+        }\n+        return byteOutput.toByteArray();", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTExMDE4OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r511110189", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-23T19:32:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgzNTM1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgzNjkxOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508836918", "bodyText": "Adding null check in case bytes could not be read considering my previous comment.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        byte[] bytes = readAllBytes(inputStream);\n          \n          \n            \n                                        try {\n          \n          \n            \n                                            CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n          \n          \n            \n                                            X509Certificate certificate = (X509Certificate) cf.generateCertificate(\n          \n          \n            \n                                                new ByteArrayInputStream(bytes));\n          \n          \n            \n                                            engineSetCertificateEntry(alias, certificate);\n          \n          \n            \n                                            LOGGER.log(INFO, \"Side loaded certificate: {0} from: {1}\",\n          \n          \n            \n                                                new Object[] { alias, filename });\n          \n          \n            \n                                        } catch (CertificateException e) {\n          \n          \n            \n                                            LOGGER.log(WARNING, \"Unable to side-load certificate\", e);\n          \n          \n            \n                                        }\n          \n          \n            \n                                        byte[] bytes = readAllBytes(inputStream);\n          \n          \n            \n                                        if (bytes != null) {\n          \n          \n            \n                                            try {\n          \n          \n            \n                                                CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n          \n          \n            \n                                                X509Certificate certificate = (X509Certificate) cf.generateCertificate(\n          \n          \n            \n                                                    new ByteArrayInputStream(bytes));\n          \n          \n            \n                                                engineSetCertificateEntry(alias, certificate);\n          \n          \n            \n                                                LOGGER.log(INFO, \"Side loaded certificate: {0} from: {1}\",\n          \n          \n            \n                                                    new Object[]{alias, filename});\n          \n          \n            \n                                            } catch (CertificateException e) {\n          \n          \n            \n                                                LOGGER.log(WARNING, \"Unable to side-load certificate\", e);\n          \n          \n            \n                                            }\n          \n          \n            \n                                        } else {\n          \n          \n            \n                                            LOGGER.log(WARNING, \"Unable to side-load certificate\");\n          \n          \n            \n                                        }", "author": "vcolin7", "createdAt": "2020-10-20T21:01:44Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/KeyVaultKeyStore.java", "diffHunk": "@@ -0,0 +1,325 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.security.Key;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.KeyStoreSpi;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableEntryException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.logging.Logger;\n+\n+import static java.util.logging.Level.INFO;\n+import static java.util.logging.Level.WARNING;\n+\n+/**\n+ * The Azure KeyVault implementation of the KeyStoreSpi.\n+ */\n+public class KeyVaultKeyStore extends KeyStoreSpi {\n+\n+    /**\n+     * Stores the logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(KeyVaultKeyStore.class.getName());\n+\n+    /**\n+     * Stores the list of aliases.\n+     */\n+    private List<String> aliases;\n+\n+    /**\n+     * Stores the certificates by alias.\n+     */\n+    private final HashMap<String, Certificate> certificates = new HashMap<>();\n+\n+    /**\n+     * Stores the certificate keys by alias.\n+     */\n+    private final HashMap<String, Key> certificateKeys = new HashMap<>();\n+\n+    /**\n+     * Stores the creation date.\n+     */\n+    private final Date creationDate;\n+\n+    /**\n+     * Stores the key vault client.\n+     */\n+    private KeyVaultClient keyVault;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * <p>\n+     * The constructor uses System.getProperty for\n+     * <code>azure.keyvault.uri</code>, <code>azure.keyvault.tenantId</code>,\n+     * <code>azure.keyvault.clientId</code>,\n+     * <code>azure.keyvault.clientSecret</code> to initialize the keyvault\n+     * client.\n+     * </p>\n+     */\n+    public KeyVaultKeyStore() {\n+        creationDate = new Date();\n+        String keyVaultUri = System.getProperty(\"azure.keyvault.uri\");\n+        String tenantId = System.getProperty(\"azure.keyvault.tenantId\");\n+        String clientId = System.getProperty(\"azure.keyvault.clientId\");\n+        String clientSecret = System.getProperty(\"azure.keyvault.clientSecret\");\n+        keyVault = new KeyVaultClient(keyVaultUri, tenantId, clientId, clientSecret);\n+    }\n+\n+    @Override\n+    public Enumeration<String> engineAliases() {\n+        if (aliases == null) {\n+            aliases = keyVault.getAliases();\n+        }\n+        return Collections.enumeration(aliases);\n+    }\n+\n+    @Override\n+    public boolean engineContainsAlias(String alias) {\n+        return engineIsCertificateEntry(alias);\n+    }\n+\n+    @Override\n+    public void engineDeleteEntry(String alias) {\n+    }\n+\n+    @Override\n+    public boolean engineEntryInstanceOf(String alias, Class<? extends KeyStore.Entry> entryClass) {\n+        return super.engineEntryInstanceOf(alias, entryClass);\n+    }\n+\n+    @Override\n+    public Certificate engineGetCertificate(String alias) {\n+        Certificate certificate;\n+        if (certificates.containsKey(alias)) {\n+            certificate = certificates.get(alias);\n+        } else {\n+            certificate = keyVault.getCertificate(alias);\n+            if (certificate != null) {\n+                certificates.put(alias, certificate);\n+                if (!aliases.contains(alias)) {\n+                    aliases.add(alias);\n+                }\n+            }\n+        }\n+        return certificate;\n+    }\n+\n+    @Override\n+    public String engineGetCertificateAlias(Certificate cert) {\n+        String alias = null;\n+        if (cert != null) {\n+            if (aliases == null) {\n+                aliases = keyVault.getAliases();\n+            }\n+            for (String candidateAlias : aliases) {\n+                Certificate certificate = engineGetCertificate(candidateAlias);\n+                if (certificate.equals(cert)) {\n+                    alias = candidateAlias;\n+                    break;\n+                }\n+            }\n+        }\n+        return alias;\n+    }\n+\n+    @Override\n+    public Certificate[] engineGetCertificateChain(String alias) {\n+        Certificate[] chain = null;\n+        Certificate certificate = engineGetCertificate(alias);\n+        if (certificate != null) {\n+            chain = new Certificate[1];\n+            chain[0] = certificate;\n+        }\n+        return chain;\n+    }\n+\n+    @Override\n+    public Date engineGetCreationDate(String alias) {\n+        return creationDate;\n+    }\n+\n+    @Override\n+    public KeyStore.Entry engineGetEntry(String alias, KeyStore.ProtectionParameter protParam) throws KeyStoreException, NoSuchAlgorithmException, UnrecoverableEntryException {\n+        return super.engineGetEntry(alias, protParam);\n+    }\n+\n+    @Override\n+    public Key engineGetKey(String alias, char[] password) {\n+        Key key;\n+        if (certificateKeys.containsKey(alias)) {\n+            key = certificateKeys.get(alias);\n+        } else {\n+            key = keyVault.getKey(alias, password);\n+            if (key != null) {\n+                certificateKeys.put(alias, key);\n+                if (!aliases.contains(alias)) {\n+                    aliases.add(alias);\n+                }\n+            }\n+        }\n+        return key;\n+    }\n+\n+    @Override\n+    public boolean engineIsCertificateEntry(String alias) {\n+        if (aliases == null) {\n+            aliases = keyVault.getAliases();\n+        }\n+        return aliases.contains(alias);\n+    }\n+\n+    @Override\n+    public boolean engineIsKeyEntry(String alias) {\n+        return engineIsCertificateEntry(alias);\n+    }\n+\n+    @Override\n+    public void engineLoad(KeyStore.LoadStoreParameter param) {\n+        if (param instanceof KeyVaultLoadStoreParameter) {\n+            KeyVaultLoadStoreParameter parameter = (KeyVaultLoadStoreParameter) param;\n+            keyVault = new KeyVaultClient(\n+                parameter.getUri(),\n+                parameter.getTenantId(),\n+                parameter.getClientId(),\n+                parameter.getClientSecret());\n+        }\n+        sideLoad();\n+    }\n+\n+    @Override\n+    public void engineLoad(InputStream stream, char[] password) {\n+        sideLoad();\n+    }\n+\n+    @Override\n+    public void engineSetCertificateEntry(String alias, Certificate certificate) {\n+        if (aliases == null) {\n+            aliases = keyVault.getAliases();\n+        }\n+        if (!aliases.contains(alias)) {\n+            aliases.add(alias);\n+            certificates.put(alias, certificate);\n+        }\n+    }\n+\n+    @Override\n+    public void engineSetEntry(String alias, KeyStore.Entry entry, KeyStore.ProtectionParameter protParam) throws KeyStoreException {\n+        super.engineSetEntry(alias, entry, protParam);\n+    }\n+\n+    @Override\n+    public void engineSetKeyEntry(String alias, Key key, char[] password, Certificate[] chain) {\n+    }\n+\n+    @Override\n+    public void engineSetKeyEntry(String alias, byte[] key, Certificate[] chain) {\n+    }\n+\n+    @Override\n+    public int engineSize() {\n+        return aliases != null ? aliases.size() : 0;\n+    }\n+\n+    @Override\n+    public void engineStore(OutputStream stream, char[] password) {\n+    }\n+\n+    @Override\n+    public void engineStore(KeyStore.LoadStoreParameter param) {\n+    }\n+\n+    /**\n+     * Get the filenames.\n+     *\n+     * @param path the path.\n+     * @return the filenames.\n+     * @throws IOException when an I/O error occurs.\n+     */\n+    private String[] getFilenames(String path) throws IOException {\n+        List<String> filenames = new ArrayList<>();\n+        InputStream in = getClass().getResourceAsStream(path);\n+        if (in != null) {\n+            BufferedReader br = new BufferedReader(new InputStreamReader(in));\n+            String resource;\n+            while ((resource = br.readLine()) != null) {\n+                filenames.add(resource);\n+            }\n+        }\n+        return filenames.toArray(new String[0]);\n+    }\n+\n+    /**\n+     * Read all the bytes for a given input stream.\n+     *\n+     * @param inputStream the input stream.\n+     * @return the byte-array.\n+     * @throws IOException when an I/O error occurs.\n+     */\n+    private byte[] readAllBytes(InputStream inputStream) throws IOException {\n+        ByteArrayOutputStream byteOutput = new ByteArrayOutputStream();\n+        byte[] buffer = new byte[1024];\n+        while (true) {\n+            int r = inputStream.read(buffer);\n+            if (r == -1) {\n+                break;\n+            }\n+            byteOutput.write(buffer, 0, r);\n+        }\n+        return byteOutput.toByteArray();\n+    }\n+\n+    /**\n+     * Side-load certificate from classpath.\n+     */\n+    private void sideLoad() {\n+        try {\n+            String[] filenames = getFilenames(\"/keyvault\");\n+            if (filenames.length > 0) {\n+                for (String filename : filenames) {\n+                    try (InputStream inputStream = getClass().getResourceAsStream(\"/keyvault/\" + filename)) {\n+                        String alias = filename;\n+                        if (alias != null) {\n+                            if (alias.lastIndexOf('.') != -1) {\n+                                alias = alias.substring(0, alias.lastIndexOf('.'));\n+                            }\n+                            byte[] bytes = readAllBytes(inputStream);\n+                            try {\n+                                CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n+                                X509Certificate certificate = (X509Certificate) cf.generateCertificate(\n+                                    new ByteArrayInputStream(bytes));\n+                                engineSetCertificateEntry(alias, certificate);\n+                                LOGGER.log(INFO, \"Side loaded certificate: {0} from: {1}\",\n+                                    new Object[] { alias, filename });\n+                            } catch (CertificateException e) {\n+                                LOGGER.log(WARNING, \"Unable to side-load certificate\", e);\n+                            }", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTEyMjE3OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r511122179", "bodyText": "Not needed as it will either return a byte-array (potentially empty) or throw an IOException", "author": "mnriem", "createdAt": "2020-10-23T19:49:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgzNjkxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgzODU1MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508838550", "bodyText": "X509ExtendedTrustManager already implements X509TrustManager.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class KeyVaultTrustManager extends X509ExtendedTrustManager implements X509TrustManager {\n          \n          \n            \n            public class KeyVaultTrustManager extends X509ExtendedTrustManager {", "author": "vcolin7", "createdAt": "2020-10-20T21:04:47Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/KeyVaultTrustManager.java", "diffHunk": "@@ -0,0 +1,153 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import javax.net.ssl.TrustManagerFactory;\n+import javax.net.ssl.X509TrustManager;\n+import java.io.IOException;\n+import java.net.Socket;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import javax.net.ssl.SSLEngine;\n+import javax.net.ssl.X509ExtendedTrustManager;\n+\n+/**\n+ * The KeyVault variant of the X509TrustManager.\n+ */\n+public class KeyVaultTrustManager extends X509ExtendedTrustManager implements X509TrustManager {", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTEzMjQ0Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r511132442", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-23T20:09:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgzODU1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgzOTQ0NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508839445", "bodyText": "Can we use a logger in instances like these like in the rest of the classes in this package?", "author": "vcolin7", "createdAt": "2020-10-20T21:06:27Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/KeyVaultTrustManager.java", "diffHunk": "@@ -0,0 +1,153 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import javax.net.ssl.TrustManagerFactory;\n+import javax.net.ssl.X509TrustManager;\n+import java.io.IOException;\n+import java.net.Socket;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import javax.net.ssl.SSLEngine;\n+import javax.net.ssl.X509ExtendedTrustManager;\n+\n+/**\n+ * The KeyVault variant of the X509TrustManager.\n+ */\n+public class KeyVaultTrustManager extends X509ExtendedTrustManager implements X509TrustManager {\n+\n+    /**\n+     * Stores the default trust manager.\n+     */\n+    private X509TrustManager defaultTrustManager;\n+\n+    /**\n+     * Stores the keystore.\n+     */\n+    private KeyStore keyStore;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param keyStore the keystore.\n+     */\n+    public KeyVaultTrustManager(KeyStore keyStore) {\n+        this.keyStore = keyStore;\n+        if (this.keyStore == null) {\n+            try {\n+                this.keyStore = KeyStore.getInstance(\"AzureKeyVault\");\n+                this.keyStore.load(null, null);\n+            } catch (KeyStoreException | IOException | NoSuchAlgorithmException | CertificateException ex) {\n+                ex.printStackTrace();", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0MDc5MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508840790", "bodyText": "Would returning an empty array cause any bugs down the line?", "author": "vcolin7", "createdAt": "2020-10-20T21:08:47Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/KeyVaultTrustManager.java", "diffHunk": "@@ -0,0 +1,153 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import javax.net.ssl.TrustManagerFactory;\n+import javax.net.ssl.X509TrustManager;\n+import java.io.IOException;\n+import java.net.Socket;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import javax.net.ssl.SSLEngine;\n+import javax.net.ssl.X509ExtendedTrustManager;\n+\n+/**\n+ * The KeyVault variant of the X509TrustManager.\n+ */\n+public class KeyVaultTrustManager extends X509ExtendedTrustManager implements X509TrustManager {\n+\n+    /**\n+     * Stores the default trust manager.\n+     */\n+    private X509TrustManager defaultTrustManager;\n+\n+    /**\n+     * Stores the keystore.\n+     */\n+    private KeyStore keyStore;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param keyStore the keystore.\n+     */\n+    public KeyVaultTrustManager(KeyStore keyStore) {\n+        this.keyStore = keyStore;\n+        if (this.keyStore == null) {\n+            try {\n+                this.keyStore = KeyStore.getInstance(\"AzureKeyVault\");\n+                this.keyStore.load(null, null);\n+            } catch (KeyStoreException | IOException | NoSuchAlgorithmException | CertificateException ex) {\n+                ex.printStackTrace();\n+            }\n+        }\n+        try {\n+            TrustManagerFactory factory = TrustManagerFactory.getInstance(\"PKIX\", \"SunJSSE\");\n+            factory.init(keyStore);\n+            defaultTrustManager = (X509TrustManager) factory.getTrustManagers()[0];\n+        } catch (NoSuchAlgorithmException | NoSuchProviderException | KeyStoreException ex) {\n+            ex.printStackTrace();\n+        }\n+        if (defaultTrustManager == null) {\n+            try {\n+                TrustManagerFactory factory = TrustManagerFactory.getInstance(\"PKIX\", \"IbmJSSE\");\n+                factory.init(keyStore);\n+                defaultTrustManager = (X509TrustManager) factory.getTrustManagers()[0];\n+            } catch (NoSuchAlgorithmException | NoSuchProviderException | KeyStoreException ex) {\n+                ex.printStackTrace();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void checkClientTrusted(X509Certificate[] chain, String authType)\n+        throws CertificateException {\n+\n+        boolean pass = true;\n+\n+        /*\n+         * Step 1 - see if the default trust manager passes.\n+         */\n+        try {\n+            defaultTrustManager.checkClientTrusted(chain, authType);\n+        } catch (CertificateException ce) {\n+            pass = false;\n+        }\n+\n+        /*\n+         * Step 2 - see if the certificate exists in the keystore.\n+         */\n+        if (!pass) {\n+            String alias = null;\n+            try {\n+                alias = keyStore.getCertificateAlias(chain[0]);\n+            } catch (KeyStoreException kse) {\n+                kse.printStackTrace();\n+            }\n+            if (alias == null) {\n+                throw new CertificateException(\"Unable to verify in keystore\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void checkServerTrusted(X509Certificate[] chain, String authType)\n+        throws CertificateException {\n+\n+        boolean pass = true;\n+\n+        /*\n+         * Step 1 - see if the default trust manager passes.\n+         */\n+        try {\n+            defaultTrustManager.checkServerTrusted(chain, authType);\n+        } catch (CertificateException ce) {\n+            pass = false;\n+        }\n+\n+        /*\n+         * Step 2 - see if the certificate exists in the keystore.\n+         */\n+        if (!pass) {\n+            String alias = null;\n+            try {\n+                alias = keyStore.getCertificateAlias(chain[0]);\n+            } catch (KeyStoreException kse) {\n+                kse.printStackTrace();\n+            }\n+            if (alias == null) {\n+                throw new CertificateException(\"Unable to verify in keystore\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public X509Certificate[] getAcceptedIssuers() {\n+        return new X509Certificate[0];\n+    }", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTEzOTMwNA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r511139304", "bodyText": "For the current use cases this is enough. This might change when we implement support for mTLS.", "author": "mnriem", "createdAt": "2020-10-23T20:25:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0MDc5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0MTkwMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508841902", "bodyText": "Can we name these getKeyProperties and setKeyProperties?", "author": "vcolin7", "createdAt": "2020-10-20T21:10:55Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/rest/CertificatePolicy.java", "diffHunk": "@@ -0,0 +1,35 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca.rest;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * The CertificatePolicy REST model.\n+ */\n+public class CertificatePolicy implements Serializable {\n+\n+    /**\n+     * Stores the key properties.\n+     */\n+    private KeyProperties keyProperties;\n+\n+    /**\n+     * Get the key properties.\n+     *\n+     * @return the key properties.\n+     */\n+    public KeyProperties getKey_props() {\n+        return keyProperties;\n+    }\n+\n+    /**\n+     * Set the key properties.\n+     *\n+     * @param keyProperties the key properties.\n+     */\n+    public void setKey_props(KeyProperties keyProperties) {\n+        this.keyProperties = keyProperties;\n+    }", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE0NDA1Nw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r511144057", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-23T20:37:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0MTkwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0MjIwMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508842200", "bodyText": "Can we name these getAccessToken and setAccessToken?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public String getAccess_token() {\n          \n          \n            \n                    return access_token;\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                /**\n          \n          \n            \n                 * Set the access token.\n          \n          \n            \n                 *\n          \n          \n            \n                 * @param accessToken the access token.\n          \n          \n            \n                 */\n          \n          \n            \n                public void setAccess_token(String accessToken) {\n          \n          \n            \n                    this.access_token = accessToken;\n          \n          \n            \n                }\n          \n          \n            \n                public String getAccessToken() {\n          \n          \n            \n                    return accessToken;\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                /**\n          \n          \n            \n                 * Set the access token.\n          \n          \n            \n                 *\n          \n          \n            \n                 * @param accessToken the access token.\n          \n          \n            \n                 */\n          \n          \n            \n                public void setAccessToken(String accessToken) {\n          \n          \n            \n                    this.accessToken = accessToken;\n          \n          \n            \n                }", "author": "vcolin7", "createdAt": "2020-10-20T21:11:30Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/rest/OAuthToken.java", "diffHunk": "@@ -0,0 +1,34 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.security.keyvault.jca.rest;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * An OAuth2 token.\n+ */\n+public class OAuthToken implements Serializable {\n+\n+    /**\n+     * Stores the access token.\n+     */\n+    private String access_token;\n+\n+    /**\n+     * Get the access token.\n+     *\n+     * @return the access token.\n+     */\n+    public String getAccess_token() {\n+        return access_token;\n+    }\n+\n+    /**\n+     * Set the access token.\n+     *\n+     * @param accessToken the access token.\n+     */\n+    public void setAccess_token(String accessToken) {\n+        this.access_token = accessToken;\n+    }", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE3MTM1MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r511171350", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-23T21:52:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0MjIwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0MjYwMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508842602", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private String access_token;\n          \n          \n            \n                private String accessToken;", "author": "vcolin7", "createdAt": "2020-10-20T21:12:18Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/main/java/com/azure/security/keyvault/jca/rest/OAuthToken.java", "diffHunk": "@@ -0,0 +1,34 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.security.keyvault.jca.rest;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * An OAuth2 token.\n+ */\n+public class OAuthToken implements Serializable {\n+\n+    /**\n+     * Stores the access token.\n+     */\n+    private String access_token;", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE3MTQzOA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r511171438", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-23T21:52:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0MjYwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0MzMxMg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508843312", "bodyText": "Let's remove the author tag from our Javadoc :)\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            /**\n          \n          \n            \n             * The JUnit tests for the DelegateRestClient class.\n          \n          \n            \n             *\n          \n          \n            \n             * @author Manfred Riem (manfred.riem@microsoft.com)\n          \n          \n            \n             */\n          \n          \n            \n            /**\n          \n          \n            \n             * The JUnit tests for the DelegateRestClient class.\n          \n          \n            \n             */", "author": "vcolin7", "createdAt": "2020-10-20T21:13:46Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/test/java/com/azure/security/keyvault/jca/DelegateRestClientTest.java", "diffHunk": "@@ -0,0 +1,25 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+\n+/**\n+ * The JUnit tests for the DelegateRestClient class.\n+ *\n+ * @author Manfred Riem (manfred.riem@microsoft.com)\n+ */", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI3MjI1MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510272250", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-22T15:51:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0MzMxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0MzU1NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508843554", "bodyText": "Author tag.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            /**\n          \n          \n            \n             * The JUnit tests for the JsonbJsonConverter class.\n          \n          \n            \n             *\n          \n          \n            \n             * @author Manfred Riem (manfred.riem@microsoft.com)\n          \n          \n            \n             */\n          \n          \n            \n            /**\n          \n          \n            \n             * The JUnit tests for the JsonbJsonConverter class.\n          \n          \n            \n             */", "author": "vcolin7", "createdAt": "2020-10-20T21:14:14Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/test/java/com/azure/security/keyvault/jca/JacksonJsonConverterTest.java", "diffHunk": "@@ -0,0 +1,46 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import com.azure.security.keyvault.jca.rest.CertificateBundle;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The JUnit tests for the JsonbJsonConverter class.\n+ *\n+ * @author Manfred Riem (manfred.riem@microsoft.com)\n+ */", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI3MjA3OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510272079", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-22T15:51:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0MzU1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0Mzc1NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508843754", "bodyText": "Author tag.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            /**\n          \n          \n            \n             * The JUnit tests for the KeyVaultCertificate class.\n          \n          \n            \n             *\n          \n          \n            \n             * @author Manfred Riem (manfred.riem@microsoft.com)\n          \n          \n            \n             */\n          \n          \n            \n            /**\n          \n          \n            \n             * The JUnit tests for the KeyVaultCertificate class.\n          \n          \n            \n             */", "author": "vcolin7", "createdAt": "2020-10-20T21:14:36Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/test/java/com/azure/security/keyvault/jca/KeyVaultCertificateTest.java", "diffHunk": "@@ -0,0 +1,369 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.ByteArrayInputStream;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.security.ProviderException;\n+import java.security.PublicKey;\n+import java.security.SignatureException;\n+import java.security.cert.CertificateEncodingException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateExpiredException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.CertificateNotYetValidException;\n+import java.security.cert.X509Certificate;\n+import java.util.Base64;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.Set;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * The JUnit tests for the KeyVaultCertificate class.\n+ *\n+ * @author Manfred Riem (manfred.riem@microsoft.com)\n+ */", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI3MTk3OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510271978", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-22T15:51:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0Mzc1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0NTYzMQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508845631", "bodyText": "JUnit 5 allows to expect exceptions to be thrown via the following. Let's keep this in mind for future iterations.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    try {\n          \n          \n            \n                        KeyVaultCertificate certificate = new KeyVaultCertificate(x509Certificate);\n          \n          \n            \n                        certificate.checkValidity(new Date(100, Calendar.FEBRUARY, 1));\n          \n          \n            \n                        fail();\n          \n          \n            \n                    } catch (CertificateExpiredException ex) {\n          \n          \n            \n                        fail();\n          \n          \n            \n                    } catch (CertificateNotYetValidException exception) {\n          \n          \n            \n                        // expecting this as the TEST_CERTIFICATE is not valid against given date.\n          \n          \n            \n                    }\n          \n          \n            \n                    Assertions.assertThrows(CertificateNotYetValidException.class, () -> {\n          \n          \n            \n                        KeyVaultCertificate certificate = new KeyVaultCertificate(x509Certificate);\n          \n          \n            \n                        certificate.checkValidity(new Date(100, Calendar.FEBRUARY, 1));\n          \n          \n            \n                    });", "author": "vcolin7", "createdAt": "2020-10-20T21:18:07Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/test/java/com/azure/security/keyvault/jca/KeyVaultCertificateTest.java", "diffHunk": "@@ -0,0 +1,369 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.ByteArrayInputStream;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.security.ProviderException;\n+import java.security.PublicKey;\n+import java.security.SignatureException;\n+import java.security.cert.CertificateEncodingException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateExpiredException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.CertificateNotYetValidException;\n+import java.security.cert.X509Certificate;\n+import java.util.Base64;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.Set;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/**\n+ * The JUnit tests for the KeyVaultCertificate class.\n+ *\n+ * @author Manfred Riem (manfred.riem@microsoft.com)\n+ */\n+public class KeyVaultCertificateTest {\n+\n+    /**\n+     * Stores the CER test certificate (which is valid til 2120).\n+     */\n+    private static final String TEST_CERTIFICATE\n+        = \"MIIDeDCCAmCgAwIBAgIQGghBu97rQJKNnUHPWU7xjDANBgkqhkiG9w0BAQsFADAk\"\n+        + \"MSIwIAYDVQQDExlodW5kcmVkLXllYXJzLmV4YW1wbGUuY29tMCAXDTIwMDkwMjE3\"\n+        + \"NDUyNFoYDzIxMjAwOTAyMTc1NTI0WjAkMSIwIAYDVQQDExlodW5kcmVkLXllYXJz\"\n+        + \"LmV4YW1wbGUuY29tMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAuU14\"\n+        + \"btkN5wmcO2WKXqm1NUKXzi79EtqiFFkrLgPAwj5NNwMw2Akm3GpdEpwkJ8/q3l7d\"\n+        + \"frDEVOO9gwZbz7xppyqutjxjllw8CCgjFdfK02btz56CGgh3X25ZZtzPbuMZJM0j\"\n+        + \"o4mVEdaFNJ0eUeMppS0DcbbuTWCF7Jf1gvr8GVqx+E0IJUFkE+D4kdTbnJSaeK0A\"\n+        + \"KEt94z88MPX18h8ud14uRVmUCYVZrZeswdE2tO1BpazrXELHuXCtrjGxsDDjDzeP\"\n+        + \"98aFI9kblkqoJS4TsmloLEjwZLm80cyJDEmpXXMtR7C0FFXFI1BAtIa4mxSgBLsT\"\n+        + \"L4GVPEGNANR8COYkHQIDAQABo4GjMIGgMA4GA1UdDwEB/wQEAwIFoDAJBgNVHRME\"\n+        + \"AjAAMB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjAkBgNVHREEHTAbghlo\"\n+        + \"dW5kcmVkLXllYXJzLmV4YW1wbGUuY29tMB8GA1UdIwQYMBaAFOGTt4H3ho30O4e+\"\n+        + \"hebwJjm2VMvIMB0GA1UdDgQWBBThk7eB94aN9DuHvoXm8CY5tlTLyDANBgkqhkiG\"\n+        + \"9w0BAQsFAAOCAQEAGp8mCioVCmM+kZv6r+K2j2uog1k4HBwN1NfRoSsibDB8+QXF\"\n+        + \"bmNf3M0imiuR/KJgODyuROwaa/AalxNFMOP8XTL2YmP7XsddBs9ONHHQXKjY/Ojl\"\n+        + \"PsIPR7vZjwYPfEB+XEKl2fOIxDQQ921POBV7M6DdTC49T5X+FsLR1AIIfinVetT9\"\n+        + \"QmNuvzulBX0T0rea/qpcPK4HTj7ToyImOaf8sXRv2s2ODLUrKWu5hhTNH2l6RIkQ\"\n+        + \"U/aIAdQRfDaSE9jhtcVu5d5kCgBs7nz5AzeCisDPo5zIt4Mxej3iVaAJ79oEbHOE\"\n+        + \"p192KLXLV/pscA4Wgb+PJ8AAEa5B6xq8p9JO+Q==\";\n+\n+    /**\n+     * Stores the X.509 certificate.\n+     */\n+    private X509Certificate x509Certificate;\n+\n+    /**\n+     * Setup before each test.\n+     *\n+     */\n+    @BeforeEach\n+    public void setUp() {\n+        try {\n+            byte[] certificateBytes = Base64.getDecoder().decode(TEST_CERTIFICATE);\n+            CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n+            x509Certificate = (X509Certificate) cf.generateCertificate(new ByteArrayInputStream(certificateBytes));\n+        } catch (CertificateException e) {\n+            throw new ProviderException(e);\n+        }\n+    }\n+\n+    /**\n+     * Test checkValidity method.\n+     */\n+    @Test\n+    public void testCheckValidity() {\n+        try {\n+            KeyVaultCertificate certificate = new KeyVaultCertificate(x509Certificate);\n+            certificate.checkValidity();\n+        } catch (CertificateExpiredException | CertificateNotYetValidException cnyve) {\n+            fail();\n+        }\n+    }\n+\n+    /**\n+     * Test checkValidity method.\n+     */\n+    @Test\n+    public void testCheckValidity2() {\n+        try {\n+            KeyVaultCertificate certificate = new KeyVaultCertificate(x509Certificate);\n+            certificate.checkValidity(new Date(100, Calendar.FEBRUARY, 1));\n+            fail();\n+        } catch (CertificateExpiredException ex) {\n+            fail();\n+        } catch (CertificateNotYetValidException exception) {\n+            // expecting this as the TEST_CERTIFICATE is not valid against given date.\n+        }", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0NjM2Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508846362", "bodyText": "Author tag.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            /**\n          \n          \n            \n             * The JUnit tests for the KeyVaultProvider class.\n          \n          \n            \n             *\n          \n          \n            \n             * @author Manfred Riem (manfred.riem@microsoft.com)\n          \n          \n            \n             */\n          \n          \n            \n            /**\n          \n          \n            \n             * The JUnit tests for the KeyVaultProvider class.\n          \n          \n            \n             */", "author": "vcolin7", "createdAt": "2020-10-20T21:19:27Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/test/java/com/azure/security/keyvault/jca/KeyVaultJcaProviderTest.java", "diffHunk": "@@ -0,0 +1,47 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.security.KeyStore;\n+import java.security.Security;\n+\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+\n+/**\n+ * The JUnit tests for the KeyVaultProvider class.\n+ *\n+ * @author Manfred Riem (manfred.riem@microsoft.com)\n+ */", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI3MTczNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510271736", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-22T15:50:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0NjM2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0NjU1MQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508846551", "bodyText": "Author tag.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            /**\n          \n          \n            \n             * The JUnit tests for the KeyVaultKeyStore class.\n          \n          \n            \n             *\n          \n          \n            \n             * @author Manfred Riem (manfred.riem@microsoft.com)\n          \n          \n            \n             */\n          \n          \n            \n            /**\n          \n          \n            \n             * The JUnit tests for the KeyVaultKeyStore class.\n          \n          \n            \n             */", "author": "vcolin7", "createdAt": "2020-10-20T21:19:51Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/test/java/com/azure/security/keyvault/jca/KeyVaultKeyStoreTest.java", "diffHunk": "@@ -0,0 +1,206 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.ByteArrayInputStream;\n+import java.security.ProviderException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.X509Certificate;\n+import java.util.Base64;\n+\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The JUnit tests for the KeyVaultKeyStore class.\n+ *\n+ * @author Manfred Riem (manfred.riem@microsoft.com)\n+ */", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI3MTYwNg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510271606", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-22T15:50:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0NjU1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0Njk4Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508846982", "bodyText": "Why do we catch exceptions and use fail() in most places and we throw an exception here? I don't think it's a bad idea to just let things throw if they don't follow the happy path. Is there a specific reason you decided to use fail() in some catch blocks?", "author": "vcolin7", "createdAt": "2020-10-20T21:20:39Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/test/java/com/azure/security/keyvault/jca/KeyVaultKeyStoreTest.java", "diffHunk": "@@ -0,0 +1,206 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.ByteArrayInputStream;\n+import java.security.ProviderException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.X509Certificate;\n+import java.util.Base64;\n+\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+/**\n+ * The JUnit tests for the KeyVaultKeyStore class.\n+ *\n+ * @author Manfred Riem (manfred.riem@microsoft.com)\n+ */\n+public class KeyVaultKeyStoreTest {\n+\n+    /**\n+     * Stores the CER test certificate (which is valid til 2120).\n+     */\n+    private static final String TEST_CERTIFICATE\n+        = \"MIIDeDCCAmCgAwIBAgIQGghBu97rQJKNnUHPWU7xjDANBgkqhkiG9w0BAQsFADAk\"\n+        + \"MSIwIAYDVQQDExlodW5kcmVkLXllYXJzLmV4YW1wbGUuY29tMCAXDTIwMDkwMjE3\"\n+        + \"NDUyNFoYDzIxMjAwOTAyMTc1NTI0WjAkMSIwIAYDVQQDExlodW5kcmVkLXllYXJz\"\n+        + \"LmV4YW1wbGUuY29tMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAuU14\"\n+        + \"btkN5wmcO2WKXqm1NUKXzi79EtqiFFkrLgPAwj5NNwMw2Akm3GpdEpwkJ8/q3l7d\"\n+        + \"frDEVOO9gwZbz7xppyqutjxjllw8CCgjFdfK02btz56CGgh3X25ZZtzPbuMZJM0j\"\n+        + \"o4mVEdaFNJ0eUeMppS0DcbbuTWCF7Jf1gvr8GVqx+E0IJUFkE+D4kdTbnJSaeK0A\"\n+        + \"KEt94z88MPX18h8ud14uRVmUCYVZrZeswdE2tO1BpazrXELHuXCtrjGxsDDjDzeP\"\n+        + \"98aFI9kblkqoJS4TsmloLEjwZLm80cyJDEmpXXMtR7C0FFXFI1BAtIa4mxSgBLsT\"\n+        + \"L4GVPEGNANR8COYkHQIDAQABo4GjMIGgMA4GA1UdDwEB/wQEAwIFoDAJBgNVHRME\"\n+        + \"AjAAMB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjAkBgNVHREEHTAbghlo\"\n+        + \"dW5kcmVkLXllYXJzLmV4YW1wbGUuY29tMB8GA1UdIwQYMBaAFOGTt4H3ho30O4e+\"\n+        + \"hebwJjm2VMvIMB0GA1UdDgQWBBThk7eB94aN9DuHvoXm8CY5tlTLyDANBgkqhkiG\"\n+        + \"9w0BAQsFAAOCAQEAGp8mCioVCmM+kZv6r+K2j2uog1k4HBwN1NfRoSsibDB8+QXF\"\n+        + \"bmNf3M0imiuR/KJgODyuROwaa/AalxNFMOP8XTL2YmP7XsddBs9ONHHQXKjY/Ojl\"\n+        + \"PsIPR7vZjwYPfEB+XEKl2fOIxDQQ921POBV7M6DdTC49T5X+FsLR1AIIfinVetT9\"\n+        + \"QmNuvzulBX0T0rea/qpcPK4HTj7ToyImOaf8sXRv2s2ODLUrKWu5hhTNH2l6RIkQ\"\n+        + \"U/aIAdQRfDaSE9jhtcVu5d5kCgBs7nz5AzeCisDPo5zIt4Mxej3iVaAJ79oEbHOE\"\n+        + \"p192KLXLV/pscA4Wgb+PJ8AAEa5B6xq8p9JO+Q==\";\n+\n+    @Test\n+    public void testEngineGetCertificate() {\n+        KeyVaultKeyStore keystore = new KeyVaultKeyStore();\n+        KeyVaultLoadStoreParameter parameter = new KeyVaultLoadStoreParameter(\n+            System.getProperty(\"azure.keyvault.uri\"),\n+            System.getProperty(\"azure.tenant.id\"),\n+            System.getProperty(\"azure.client.id\"),\n+            System.getProperty(\"azure.client.secret\"));\n+        keystore.engineLoad(parameter);\n+        assertNull(keystore.engineGetCertificate(\"myalias\"));\n+    }\n+\n+    @Test\n+    public void testEngineGetCertificateAlias() {\n+        KeyVaultKeyStore keystore = new KeyVaultKeyStore();\n+        KeyVaultLoadStoreParameter parameter = new KeyVaultLoadStoreParameter(\n+            System.getProperty(\"azure.keyvault.uri\"),\n+            System.getProperty(\"azure.tenant.id\"),\n+            System.getProperty(\"azure.client.id\"),\n+            System.getProperty(\"azure.client.secret\"));\n+        keystore.engineLoad(parameter);\n+        assertNull(keystore.engineGetCertificateAlias(null));\n+    }\n+\n+    @Test\n+    public void testEngineGetCertificateChain() {\n+        KeyVaultKeyStore keystore = new KeyVaultKeyStore();\n+        KeyVaultLoadStoreParameter parameter = new KeyVaultLoadStoreParameter(\n+            System.getProperty(\"azure.keyvault.uri\"),\n+            System.getProperty(\"azure.tenant.id\"),\n+            System.getProperty(\"azure.client.id\"),\n+            System.getProperty(\"azure.client.secret\"));\n+        keystore.engineLoad(parameter);\n+        assertNull(keystore.engineGetCertificateChain(\"myalias\"));\n+    }\n+\n+    @Test\n+    public void testEngineIsCertificateEntry() {\n+        KeyVaultKeyStore keystore = new KeyVaultKeyStore();\n+        KeyVaultLoadStoreParameter parameter = new KeyVaultLoadStoreParameter(\n+            System.getProperty(\"azure.keyvault.uri\"),\n+            System.getProperty(\"azure.tenant.id\"),\n+            System.getProperty(\"azure.client.id\"),\n+            System.getProperty(\"azure.client.secret\"));\n+        keystore.engineLoad(parameter);\n+        assertFalse(keystore.engineIsCertificateEntry(\"myalias\"));\n+    }\n+\n+    @Test\n+    public void testEngineSetCertificateEntry() {\n+        KeyVaultKeyStore keystore = new KeyVaultKeyStore();\n+        KeyVaultLoadStoreParameter parameter = new KeyVaultLoadStoreParameter(\n+            System.getProperty(\"azure.keyvault.uri\"),\n+            System.getProperty(\"azure.tenant.id\"),\n+            System.getProperty(\"azure.client.id\"),\n+            System.getProperty(\"azure.client.secret\"));\n+        keystore.engineLoad(parameter);\n+\n+        X509Certificate certificate;\n+\n+        try {\n+            byte[] certificateBytes = Base64.getDecoder().decode(TEST_CERTIFICATE);\n+            CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n+            certificate = (X509Certificate) cf.generateCertificate(new ByteArrayInputStream(certificateBytes));\n+        } catch (CertificateException e) {\n+            throw new ProviderException(e);\n+        }", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0NzE3Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508847172", "bodyText": "Author tag.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            /**\n          \n          \n            \n             * The JUnit tests for the KeyVaultLoadStoreParameter class.\n          \n          \n            \n             *\n          \n          \n            \n             * @author Manfred Riem (manfred.riem@microsoft.com)\n          \n          \n            \n             */\n          \n          \n            \n            /**\n          \n          \n            \n             * The JUnit tests for the KeyVaultLoadStoreParameter class.\n          \n          \n            \n             */", "author": "vcolin7", "createdAt": "2020-10-20T21:21:03Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/test/java/com/azure/security/keyvault/jca/KeyVaultLoadStoreParameterTest.java", "diffHunk": "@@ -0,0 +1,30 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+\n+/**\n+ * The JUnit tests for the KeyVaultLoadStoreParameter class.\n+ *\n+ * @author Manfred Riem (manfred.riem@microsoft.com)\n+ */", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI3MDU3NQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510270575", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-22T15:49:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0NzE3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0NzMxMw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508847313", "bodyText": "Author tag.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            /**\n          \n          \n            \n             * The JUnit tests for the LegacyRestClient class.\n          \n          \n            \n             *\n          \n          \n            \n             * @author Manfred Riem (manfred.riem@microsoft.com)\n          \n          \n            \n             */\n          \n          \n            \n            /**\n          \n          \n            \n             * The JUnit tests for the LegacyRestClient class.\n          \n          \n            \n             */", "author": "vcolin7", "createdAt": "2020-10-20T21:21:20Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/test/java/com/azure/security/keyvault/jca/LegacyRestClientTest.java", "diffHunk": "@@ -0,0 +1,25 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+\n+/**\n+ * The JUnit tests for the LegacyRestClient class.\n+ *\n+ * @author Manfred Riem (manfred.riem@microsoft.com)\n+ */", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI3MDQyMA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510270420", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-22T15:49:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0NzMxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0NzQyOQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508847429", "bodyText": "Author tag.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            /**\n          \n          \n            \n             * The JUnit tests for the RestClientFactory class.\n          \n          \n            \n             *\n          \n          \n            \n             * @author Manfred Riem (manfred.riem@microsoft.com)\n          \n          \n            \n             */\n          \n          \n            \n            /**\n          \n          \n            \n             * The JUnit tests for the RestClientFactory class.\n          \n          \n            \n             */", "author": "vcolin7", "createdAt": "2020-10-20T21:21:35Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/test/java/com/azure/security/keyvault/jca/RestClientFactoryTest.java", "diffHunk": "@@ -0,0 +1,24 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+\n+/**\n+ * The JUnit tests for the RestClientFactory class.\n+ *\n+ * @author Manfred Riem (manfred.riem@microsoft.com)\n+ */", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI3MDI5Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510270292", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-22T15:48:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0NzQyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0NzU4OA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508847588", "bodyText": "Author tag.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            /**\n          \n          \n            \n             * The unit test validating the ServerSocket is created using a certificate from Azure KeyVault.\n          \n          \n            \n             *\n          \n          \n            \n             * @author Manfred Riem (manfred.riem@microsoft.com)\n          \n          \n            \n             */\n          \n          \n            \n            /**\n          \n          \n            \n             * The unit test validating the ServerSocket is created using a certificate from Azure KeyVault.\n          \n          \n            \n             */", "author": "vcolin7", "createdAt": "2020-10-20T21:21:53Z", "path": "sdk/keyvault/azure-security-keyvault-jca/src/test/java/com/azure/security/keyvault/jca/ServerSocketTest.java", "diffHunk": "@@ -0,0 +1,248 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+\n+package com.azure.security.keyvault.jca;\n+\n+import org.apache.hc.client5.http.classic.methods.HttpGet;\n+import org.apache.hc.client5.http.impl.classic.CloseableHttpClient;\n+import org.apache.hc.client5.http.impl.classic.HttpClients;\n+import org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManager;\n+import org.apache.hc.client5.http.impl.io.PoolingHttpClientConnectionManagerBuilder;\n+import org.apache.hc.client5.http.ssl.SSLConnectionSocketFactory;\n+import org.apache.hc.client5.http.ssl.SSLConnectionSocketFactoryBuilder;\n+import org.apache.hc.client5.http.ssl.TrustSelfSignedStrategy;\n+import org.apache.hc.core5.http.ClassicHttpResponse;\n+import org.apache.hc.core5.http.io.HttpClientResponseHandler;\n+import org.apache.hc.core5.ssl.SSLContexts;\n+import org.junit.jupiter.api.Test;\n+\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLServerSocket;\n+import javax.net.ssl.SSLServerSocketFactory;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.Socket;\n+import java.security.KeyStore;\n+import java.security.Security;\n+import java.security.cert.X509Certificate;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+/**\n+ * The unit test validating the ServerSocket is created using a certificate from Azure KeyVault.\n+ *\n+ * @author Manfred Riem (manfred.riem@microsoft.com)\n+ */", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDE1NDU1Mg==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r510154552", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-22T13:19:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0NzU4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1Nzc2Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508857763", "bodyText": "This logger is not used in the class at all.", "author": "vcolin7", "createdAt": "2020-10-20T21:42:12Z", "path": "sdk/spring/azure-spring-boot-starter-keyvault-certificates/src/main/java/com/azure/spring/security/keyvault/certificates/starter/KeyVaultCertificatesEnvironmentPostProcessor.java", "diffHunk": "@@ -0,0 +1,109 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.spring.security.keyvault.certificates.starter;\n+\n+import com.azure.security.keyvault.jca.KeyVaultJcaProvider;\n+import com.azure.security.keyvault.jca.KeyVaultTrustManagerFactoryProvider;\n+\n+import java.security.Security;\n+import java.util.Properties;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+\n+import org.springframework.boot.SpringApplication;\n+import org.springframework.boot.env.EnvironmentPostProcessor;\n+import org.springframework.core.annotation.Order;\n+import org.springframework.core.env.ConfigurableEnvironment;\n+import org.springframework.core.env.MutablePropertySources;\n+import org.springframework.core.env.PropertiesPropertySource;\n+\n+import static org.springframework.core.Ordered.LOWEST_PRECEDENCE;\n+\n+@Order(LOWEST_PRECEDENCE)\n+public class KeyVaultCertificatesEnvironmentPostProcessor implements EnvironmentPostProcessor {\n+\n+    /**\n+     * Stores the logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(KeyVaultCertificatesEnvironmentPostProcessor.class.getName());", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE2MzI2NA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r511163264", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-23T21:28:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1Nzc2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1OTE0MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508859140", "bodyText": "nit; Making things prettier.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            HttpsURLConnection.setDefaultHostnameVerifier((hostname, session) -> {\n          \n          \n            \n                                return true;\n          \n          \n            \n                            });\n          \n          \n            \n                            HttpsURLConnection.setDefaultHostnameVerifier((hostname, session) -> true);", "author": "vcolin7", "createdAt": "2020-10-20T21:45:12Z", "path": "sdk/spring/azure-spring-boot-starter-keyvault-certificates/src/main/java/com/azure/spring/security/keyvault/certificates/starter/KeyVaultCertificatesEnvironmentPostProcessor.java", "diffHunk": "@@ -0,0 +1,109 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.spring.security.keyvault.certificates.starter;\n+\n+import com.azure.security.keyvault.jca.KeyVaultJcaProvider;\n+import com.azure.security.keyvault.jca.KeyVaultTrustManagerFactoryProvider;\n+\n+import java.security.Security;\n+import java.util.Properties;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+\n+import org.springframework.boot.SpringApplication;\n+import org.springframework.boot.env.EnvironmentPostProcessor;\n+import org.springframework.core.annotation.Order;\n+import org.springframework.core.env.ConfigurableEnvironment;\n+import org.springframework.core.env.MutablePropertySources;\n+import org.springframework.core.env.PropertiesPropertySource;\n+\n+import static org.springframework.core.Ordered.LOWEST_PRECEDENCE;\n+\n+@Order(LOWEST_PRECEDENCE)\n+public class KeyVaultCertificatesEnvironmentPostProcessor implements EnvironmentPostProcessor {\n+\n+    /**\n+     * Stores the logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(KeyVaultCertificatesEnvironmentPostProcessor.class.getName());\n+\n+    @Override\n+    public void postProcessEnvironment(ConfigurableEnvironment environment,\n+                                       SpringApplication application) {\n+\n+        Properties systemProperties = System.getProperties();\n+\n+        String uri = environment.getProperty(\"azure.keyvault.uri\");\n+        if (uri != null) {\n+            systemProperties.put(\"azure.keyvault.uri\", uri);\n+\n+            String tenantId = environment.getProperty(\"azure.keyvault.tenantId\");\n+            if (tenantId != null) {\n+                systemProperties.put(\"azure.keyvault.tenantId\", tenantId);\n+            }\n+\n+            String clientId = environment.getProperty(\"azure.keyvault.clientId\");\n+            if (clientId != null) {\n+                systemProperties.put(\"azure.keyvault.clientId\", clientId);\n+            }\n+\n+            String clientSecret = environment.getProperty(\"azure.keyvault.clientSecret\");\n+            if (clientSecret != null) {\n+                systemProperties.put(\"azure.keyvault.clientSecret\", clientSecret);\n+            }\n+\n+            String keyStoreType = environment.getProperty(\"server.ssl.key-store-type\");\n+\n+            if (keyStoreType != null && keyStoreType.equals(\"AzureKeyVault\")) {\n+                MutablePropertySources sources = environment.getPropertySources();\n+                Properties properties = new Properties();\n+                properties.put(\"server.ssl.key-store\", \"classpath:keyvault.dummy\");\n+\n+                try {\n+                    Class.forName(\"org.apache.tomcat.InstanceManager\");\n+                    properties.put(\"server.ssl.key-store-type\", \"DKS\");\n+                } catch (ClassNotFoundException ex) {\n+                }\n+\n+                PropertiesPropertySource propertySource =\n+                        new PropertiesPropertySource(\"KeyStorePropertySource\", properties);\n+                sources.addFirst(propertySource);\n+            }\n+\n+            String trustStoreType = environment.getProperty(\"server.ssl.trust-store-type\");\n+\n+            if (trustStoreType != null && trustStoreType.equals(\"AzureKeyVault\")) {\n+                MutablePropertySources sources = environment.getPropertySources();\n+                Properties properties = new Properties();\n+                properties.put(\"server.ssl.trust-store\", \"classpath:keyvault.dummy\");\n+\n+                try {\n+                    Class.forName(\"org.apache.tomcat.InstanceManager\");\n+                    properties.put(\"server.ssl.trust-store-type\", \"DKS\");\n+                } catch (ClassNotFoundException ex) {\n+                }\n+\n+                PropertiesPropertySource propertySource = \n+                        new PropertiesPropertySource(\"TrustStorePropertySource\", properties);\n+                sources.addFirst(propertySource);\n+            }\n+\n+            KeyVaultJcaProvider provider = new KeyVaultJcaProvider();\n+            Security.insertProviderAt(provider, 1);\n+\n+            String enabled = environment.getProperty(\"azure.keyvault.jca.overrideTrustManagerFactory\");\n+            if (Boolean.parseBoolean(enabled)) {\n+                KeyVaultTrustManagerFactoryProvider factoryProvider =\n+                    new KeyVaultTrustManagerFactoryProvider();\n+                Security.insertProviderAt(factoryProvider, 1);\n+            }\n+\n+            enabled = environment.getProperty(\"azure.keyvault.jca.disableHostnameVerification\");\n+            if (Boolean.parseBoolean(enabled)) {\n+                HttpsURLConnection.setDefaultHostnameVerifier((hostname, session) -> {\n+                    return true;\n+                });", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE1MDM1OQ==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r511150359", "bodyText": "Fixed", "author": "mnriem", "createdAt": "2020-10-23T20:53:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1OTE0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2MTM2MA==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r508861360", "bodyText": "I noticed that the all classes that are part of the Key Vault Secrets Spring Boot Starter live in the azure-spring-boot folder under the package com.azure.spring.keyvault, should this be there as well?", "author": "vcolin7", "createdAt": "2020-10-20T21:49:44Z", "path": "sdk/spring/azure-spring-boot-starter-keyvault-certificates/src/main/java/com/azure/spring/security/keyvault/certificates/starter/KeyVaultCertificatesEnvironmentPostProcessor.java", "diffHunk": "@@ -0,0 +1,109 @@\n+// Copyright (c) Microsoft Corporation. All rights reserved.\n+// Licensed under the MIT License.\n+package com.azure.spring.security.keyvault.certificates.starter;\n+\n+import com.azure.security.keyvault.jca.KeyVaultJcaProvider;\n+import com.azure.security.keyvault.jca.KeyVaultTrustManagerFactoryProvider;\n+\n+import java.security.Security;\n+import java.util.Properties;\n+import java.util.logging.Logger;\n+import javax.net.ssl.HttpsURLConnection;\n+\n+import org.springframework.boot.SpringApplication;\n+import org.springframework.boot.env.EnvironmentPostProcessor;\n+import org.springframework.core.annotation.Order;\n+import org.springframework.core.env.ConfigurableEnvironment;\n+import org.springframework.core.env.MutablePropertySources;\n+import org.springframework.core.env.PropertiesPropertySource;\n+\n+import static org.springframework.core.Ordered.LOWEST_PRECEDENCE;\n+\n+@Order(LOWEST_PRECEDENCE)\n+public class KeyVaultCertificatesEnvironmentPostProcessor implements EnvironmentPostProcessor {", "originalCommit": "59b9585bd9ca4de1246d417961916376e3bf226f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE1MTc5Mw==", "url": "https://github.com/Azure/azure-sdk-for-java/pull/16452#discussion_r511151793", "bodyText": "@chenrujun @saragluna Can you answer this question?", "author": "mnriem", "createdAt": "2020-10-23T20:56:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2MTM2MA=="}], "type": "inlineReview"}]}